{
  "module_name": "auth2-hostbased.c",
  "hash_id": "19cdef0be7da3b4b52910ba53c6f6767a8cd7ec8fdcd444764f55153c9249855",
  "original_prompt": "Ingested from openssh-9.6p1/auth2-hostbased.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"xmalloc.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"kex.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"canohost.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"pathnames.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n\n \nextern ServerOptions options;\n\nstatic int\nuserauth_hostbased(struct ssh *ssh, const char *method)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshbuf *b;\n\tstruct sshkey *key = NULL;\n\tchar *pkalg, *cuser, *chost;\n\tu_char *pkblob, *sig;\n\tsize_t alen, blen, slen;\n\tint r, pktype, authenticated = 0;\n\n\t \n\tif ((r = sshpkt_get_cstring(ssh, &pkalg, &alen)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &chost, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &cuser, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &sig, &slen)) != 0)\n\t\tfatal_fr(r, \"parse packet\");\n\n\tdebug_f(\"cuser %s chost %s pkalg %s slen %zu\",\n\t    cuser, chost, pkalg, slen);\n#ifdef DEBUG_PK\n\tdebug(\"signature:\");\n\tsshbuf_dump_data(sig, slen, stderr);\n#endif\n\tpktype = sshkey_type_from_name(pkalg);\n\tif (pktype == KEY_UNSPEC) {\n\t\t \n\t\tlogit_f(\"unsupported public key algorithm: %s\",\n\t\t    pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\terror_fr(r, \"key_from_blob\");\n\t\tgoto done;\n\t}\n\tif (key == NULL) {\n\t\terror_f(\"cannot decode key: %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror_f(\"type mismatch for decoded key \"\n\t\t    \"(received %d, expected %d)\", key->type, pktype);\n\t\tgoto done;\n\t}\n\tif (match_pattern_list(pkalg, options.hostbased_accepted_algos, 0) != 1) {\n\t\tlogit_f(\"signature algorithm %s not in \"\n\t\t    \"HostbasedAcceptedAlgorithms\", pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_check_cert_sigtype(key,\n\t    options.ca_sign_algorithms)) != 0) {\n\t\tlogit_fr(r, \"certificate signature algorithm %s\",\n\t\t    (key->cert == NULL || key->cert->signature_type == NULL) ?\n\t\t    \"(null)\" : key->cert->signature_type);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_check_rsa_length(key,\n\t    options.required_rsa_size)) != 0) {\n\t\tlogit_r(r, \"refusing %s key\", sshkey_type(key));\n\t\tgoto done;\n\t}\n\n\tif (!authctxt->valid || authctxt->user == NULL) {\n\t\tdebug2_f(\"disabled because of invalid user\");\n\t\tgoto done;\n\t}\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\t \n\tif ((r = sshbuf_put_stringb(b, ssh->kex->session_id)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, method)) != 0 ||\n\t    (r = sshbuf_put_string(b, pkalg, alen)) != 0 ||\n\t    (r = sshbuf_put_string(b, pkblob, blen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, cuser)) != 0)\n\t\tfatal_fr(r, \"reconstruct packet\");\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\n\tauth2_record_info(authctxt,\n\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\", cuser, chost);\n\n\t \n\tauthenticated = 0;\n\tif (PRIVSEP(hostbased_key_allowed(ssh, authctxt->pw, cuser,\n\t    chost, key)) &&\n\t    PRIVSEP(sshkey_verify(key, sig, slen,\n\t    sshbuf_ptr(b), sshbuf_len(b), pkalg, ssh->compat, NULL)) == 0)\n\t\tauthenticated = 1;\n\n\tauth2_record_key(authctxt, authenticated, key);\n\tsshbuf_free(b);\ndone:\n\tdebug2_f(\"authenticated %d\", authenticated);\n\tsshkey_free(key);\n\tfree(pkalg);\n\tfree(pkblob);\n\tfree(cuser);\n\tfree(chost);\n\tfree(sig);\n\treturn authenticated;\n}\n\n \nint\nhostbased_key_allowed(struct ssh *ssh, struct passwd *pw,\n    const char *cuser, char *chost, struct sshkey *key)\n{\n\tconst char *resolvedname, *ipaddr, *lookup, *reason;\n\tHostStatus host_status;\n\tint len;\n\tchar *fp;\n\n\tif (auth_key_is_revoked(key))\n\t\treturn 0;\n\n\tresolvedname = auth_get_canonical_hostname(ssh, options.use_dns);\n\tipaddr = ssh_remote_ipaddr(ssh);\n\n\tdebug2_f(\"chost %s resolvedname %s ipaddr %s\",\n\t    chost, resolvedname, ipaddr);\n\n\tif (((len = strlen(chost)) > 0) && chost[len - 1] == '.') {\n\t\tdebug2(\"stripping trailing dot from chost %s\", chost);\n\t\tchost[len - 1] = '\\0';\n\t}\n\n\tif (options.hostbased_uses_name_from_packet_only) {\n\t\tif (auth_rhosts2(pw, cuser, chost, chost) == 0) {\n\t\t\tdebug2_f(\"auth_rhosts2 refused user \\\"%.100s\\\" \"\n\t\t\t    \"host \\\"%.100s\\\" (from packet)\", cuser, chost);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = chost;\n\t} else {\n\t\tif (strcasecmp(resolvedname, chost) != 0)\n\t\t\tlogit(\"userauth_hostbased mismatch: \"\n\t\t\t    \"client sends %s, but we resolve %s to %s\",\n\t\t\t    chost, ipaddr, resolvedname);\n\t\tif (auth_rhosts2(pw, cuser, resolvedname, ipaddr) == 0) {\n\t\t\tdebug2_f(\"auth_rhosts2 refused \"\n\t\t\t    \"user \\\"%.100s\\\" host \\\"%.100s\\\" addr \\\"%.100s\\\"\",\n\t\t\t    cuser, resolvedname, ipaddr);\n\t\t\treturn 0;\n\t\t}\n\t\tlookup = resolvedname;\n\t}\n\tdebug2_f(\"access allowed by auth_rhosts2\");\n\n\tif (sshkey_is_cert(key) &&\n\t    sshkey_cert_check_authority_now(key, 1, 0, 0, lookup, &reason)) {\n\t\terror(\"%s\", reason);\n\t\tauth_debug_add(\"%s\", reason);\n\t\treturn 0;\n\t}\n\n\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t    _PATH_SSH_SYSTEM_HOSTFILE,\n\t    options.ignore_user_known_hosts ? NULL : _PATH_SSH_USER_HOSTFILE);\n\n\t \n\tif (host_status == HOST_NEW) {\n\t\thost_status = check_key_in_hostfiles(pw, key, lookup,\n\t\t    _PATH_SSH_SYSTEM_HOSTFILE2,\n\t\t    options.ignore_user_known_hosts ? NULL :\n\t\t    _PATH_SSH_USER_HOSTFILE2);\n\t}\n\n\tif (host_status == HOST_OK) {\n\t\tif (sshkey_is_cert(key)) {\n\t\t\tif ((fp = sshkey_fingerprint(key->cert->signature_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal_f(\"sshkey_fingerprint fail\");\n\t\t\tverbose(\"Accepted certificate ID \\\"%s\\\" signed by \"\n\t\t\t    \"%s CA %s from %s@%s\", key->cert->key_id,\n\t\t\t    sshkey_type(key->cert->signature_key), fp,\n\t\t\t    cuser, lookup);\n\t\t} else {\n\t\t\tif ((fp = sshkey_fingerprint(key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\t\tfatal_f(\"sshkey_fingerprint fail\");\n\t\t\tverbose(\"Accepted %s public key %s from %s@%s\",\n\t\t\t    sshkey_type(key), fp, cuser, lookup);\n\t\t}\n\t\tfree(fp);\n\t}\n\n\treturn (host_status == HOST_OK);\n}\n\nAuthmethod method_hostbased = {\n\t\"hostbased\",\n\tNULL,\n\tuserauth_hostbased,\n\t&options.hostbased_authentication\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}