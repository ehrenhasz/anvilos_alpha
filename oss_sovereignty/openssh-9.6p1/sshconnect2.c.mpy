{
  "module_name": "sshconnect2.c",
  "hash_id": "eaae0ac63d24582fb4f071182cc5ed186ad778abf61db7a2b61f0336ac544699",
  "original_prompt": "Ingested from openssh-9.6p1/sshconnect2.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n#include <vis.h>\n#endif\n\n#include \"openbsd-compat/sys-queue.h\"\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"sshconnect.h\"\n#include \"authfile.h\"\n#include \"dh.h\"\n#include \"authfd.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"readconf.h\"\n#include \"match.h\"\n#include \"dispatch.h\"\n#include \"canohost.h\"\n#include \"msg.h\"\n#include \"pathnames.h\"\n#include \"uidswap.h\"\n#include \"hostfile.h\"\n#include \"ssherr.h\"\n#include \"utf8.h\"\n#include \"ssh-sk.h\"\n#include \"sk-api.h\"\n\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n\n \nextern char *client_version_string;\nextern char *server_version_string;\nextern Options options;\n\n \n\nstatic char *xxx_host;\nstatic struct sockaddr *xxx_hostaddr;\nstatic const struct ssh_conn_info *xxx_conn_info;\n\nstatic int\nverify_host_key_callback(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tint r;\n\n\tif ((r = sshkey_check_rsa_length(hostkey,\n\t    options.required_rsa_size)) != 0)\n\t\tfatal_r(r, \"Bad server host key\");\n\tif (verify_host_key(xxx_host, xxx_hostaddr, hostkey,\n\t    xxx_conn_info) == -1)\n\t\tfatal(\"Host key verification failed.\");\n\treturn 0;\n}\n\n \nstatic char *\nfirst_alg(const char *algs)\n{\n\tchar *ret, *cp;\n\n\tret = xstrdup(algs);\n\tif ((cp = strchr(ret, ',')) != NULL)\n\t\t*cp = '\\0';\n\treturn ret;\n}\n\nstatic char *\norder_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *oavail = NULL, *avail = NULL, *first = NULL, *last = NULL;\n\tchar *alg = NULL, *hostname = NULL, *ret = NULL, *best = NULL;\n\tsize_t maxlen;\n\tstruct hostkeys *hostkeys = NULL;\n\tint ktype;\n\tu_int i;\n\n\t \n\tget_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);\n\thostkeys = init_hostkeys();\n\tfor (i = 0; i < options.num_user_hostfiles; i++)\n\t\tload_hostkeys(hostkeys, hostname, options.user_hostfiles[i], 0);\n\tfor (i = 0; i < options.num_system_hostfiles; i++) {\n\t\tload_hostkeys(hostkeys, hostname,\n\t\t    options.system_hostfiles[i], 0);\n\t}\n\tif (options.known_hosts_command != NULL) {\n\t\tload_hostkeys_command(hostkeys, options.known_hosts_command,\n\t\t    \"ORDER\", cinfo, NULL, hostname);\n\t}\n\t \n\tbest = first_alg(options.hostkeyalgorithms);\n\tif (lookup_key_in_hostkeys_by_type(hostkeys,\n\t    sshkey_type_plain(sshkey_type_from_name(best)),\n\t    sshkey_ecdsa_nid_from_name(best), NULL)) {\n\t\tdebug3_f(\"have matching best-preference key type %s, \"\n\t\t    \"using HostkeyAlgorithms verbatim\", best);\n\t\tret = xstrdup(options.hostkeyalgorithms);\n\t\tgoto out;\n\t}\n\n\t \n\toavail = avail = xstrdup(options.hostkeyalgorithms);\n\tmaxlen = strlen(avail) + 1;\n\tfirst = xmalloc(maxlen);\n\tlast = xmalloc(maxlen);\n\t*first = *last = '\\0';\n\n#define ALG_APPEND(to, from) \\\n\tdo { \\\n\t\tif (*to != '\\0') \\\n\t\t\tstrlcat(to, \",\", maxlen); \\\n\t\tstrlcat(to, from, maxlen); \\\n\t} while (0)\n\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tfatal_f(\"unknown alg %s\", alg);\n\t\t \n\t\tif (sshkey_type_is_cert(ktype) &&\n\t\t    lookup_marker_in_hostkeys(hostkeys, MRK_CA)) {\n\t\t\tALG_APPEND(first, alg);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (lookup_key_in_hostkeys_by_type(hostkeys,\n\t\t    sshkey_type_plain(ktype),\n\t\t    sshkey_ecdsa_nid_from_name(alg), NULL)) {\n\t\t\tALG_APPEND(first, alg);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tALG_APPEND(last, alg);\n\t}\n#undef ALG_APPEND\n\txasprintf(&ret, \"%s%s%s\", first,\n\t    (*first == '\\0' || *last == '\\0') ? \"\" : \",\", last);\n\tif (*first != '\\0')\n\t\tdebug3_f(\"prefer hostkeyalgs: %s\", first);\n\telse\n\t\tdebug3_f(\"no algorithms matched; accept original\");\n out:\n\tfree(best);\n\tfree(first);\n\tfree(last);\n\tfree(hostname);\n\tfree(oavail);\n\tfree_hostkeys(hostkeys);\n\n\treturn ret;\n}\n\nvoid\nssh_kex2(struct ssh *ssh, char *host, struct sockaddr *hostaddr, u_short port,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *myproposal[PROPOSAL_MAX];\n\tchar *s, *all_key, *hkalgs = NULL;\n\tint r, use_known_hosts_order = 0;\n\n\txxx_host = host;\n\txxx_hostaddr = hostaddr;\n\txxx_conn_info = cinfo;\n\n\tif (options.rekey_limit || options.rekey_interval)\n\t\tssh_packet_set_rekey_limits(ssh, options.rekey_limit,\n\t\t    options.rekey_interval);\n\n\t \n\tif (options.hostkeyalgorithms == NULL ||\n\t    options.hostkeyalgorithms[0] == '-' ||\n\t    options.hostkeyalgorithms[0] == '+')\n\t\tuse_known_hosts_order = 1;\n\n\t \n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&options.hostkeyalgorithms,\n\t    kex_default_pk_alg(), all_key)) != 0)\n\t\tfatal_fr(r, \"kex_assemble_namelist\");\n\tfree(all_key);\n\n\tif ((s = kex_names_cat(options.kex_algorithms, \"ext-info-c\")) == NULL)\n\t\tfatal_f(\"kex_names_cat\");\n\n\tif (use_known_hosts_order)\n\t\thkalgs = order_hostkeyalgs(host, hostaddr, port, cinfo);\n\n\tkex_proposal_populate_entries(ssh, myproposal, s, options.ciphers,\n\t    options.macs, compression_alg_list(options.compression),\n\t    hkalgs ? hkalgs : options.hostkeyalgorithms);\n\n\tfree(hkalgs);\n\n\t \n\tif ((r = kex_setup(ssh, myproposal)) != 0)\n\t\tfatal_r(r, \"kex_setup\");\n#ifdef WITH_OPENSSL\n\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif\n\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\tssh->kex->verify_host_key=&verify_host_key_callback;\n\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &ssh->kex->done);\n\n\t \n\tfree(myproposal[PROPOSAL_KEX_ALGS]);\n\tmyproposal[PROPOSAL_KEX_ALGS] =\n\t    compat_kex_proposal(ssh, options.kex_algorithms);\n\tif ((r = kex_prop2buf(ssh->kex->my, myproposal)) != 0)\n\t\tfatal_r(r, \"kex_prop2buf\");\n\n#ifdef DEBUG_KEXDH\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"markus\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n#endif\n\tkex_proposal_free_entries(myproposal);\n}\n\n \n\ntypedef struct cauthctxt Authctxt;\ntypedef struct cauthmethod Authmethod;\ntypedef struct identity Identity;\ntypedef struct idlist Idlist;\n\nstruct identity {\n\tTAILQ_ENTRY(identity) next;\n\tint\tagent_fd;\t\t \n\tstruct sshkey\t*key;\t\t \n\tchar\t*filename;\t\t \n\tint\ttried;\n\tint\tisprivate;\t\t \n\tint\tuserprovided;\n};\nTAILQ_HEAD(idlist, identity);\n\nstruct cauthctxt {\n\tconst char *server_user;\n\tconst char *local_user;\n\tconst char *host;\n\tconst char *service;\n\tstruct cauthmethod *method;\n\tsig_atomic_t success;\n\tchar *authlist;\n#ifdef GSSAPI\n\t \n\tgss_OID_set gss_supported_mechs;\n\tu_int mech_tried;\n#endif\n\t \n\tstruct idlist keys;\n\tint agent_fd;\n\t \n\tSensitive *sensitive;\n\tchar *oktypes, *ktypes;\n\tconst char *active_ktype;\n\t \n\tint info_req_seen;\n\tint attempt_kbdint;\n\t \n\tint attempt_passwd;\n\t \n\tvoid *methoddata;\n};\n\nstruct cauthmethod {\n\tchar\t*name;\t\t \n\tint\t(*userauth)(struct ssh *ssh);\n\tvoid\t(*cleanup)(struct ssh *ssh);\n\tint\t*enabled;\t \n\tint\t*batch_flag;\t \n};\n\nstatic int input_userauth_service_accept(int, u_int32_t, struct ssh *);\nstatic int input_userauth_success(int, u_int32_t, struct ssh *);\nstatic int input_userauth_failure(int, u_int32_t, struct ssh *);\nstatic int input_userauth_banner(int, u_int32_t, struct ssh *);\nstatic int input_userauth_error(int, u_int32_t, struct ssh *);\nstatic int input_userauth_info_req(int, u_int32_t, struct ssh *);\nstatic int input_userauth_pk_ok(int, u_int32_t, struct ssh *);\nstatic int input_userauth_passwd_changereq(int, u_int32_t, struct ssh *);\n\nstatic int userauth_none(struct ssh *);\nstatic int userauth_pubkey(struct ssh *);\nstatic int userauth_passwd(struct ssh *);\nstatic int userauth_kbdint(struct ssh *);\nstatic int userauth_hostbased(struct ssh *);\n\n#ifdef GSSAPI\nstatic int userauth_gssapi(struct ssh *);\nstatic void userauth_gssapi_cleanup(struct ssh *);\nstatic int input_gssapi_response(int type, u_int32_t, struct ssh *);\nstatic int input_gssapi_token(int type, u_int32_t, struct ssh *);\nstatic int input_gssapi_error(int, u_int32_t, struct ssh *);\nstatic int input_gssapi_errtok(int, u_int32_t, struct ssh *);\n#endif\n\nvoid\tuserauth(struct ssh *, char *);\n\nstatic void pubkey_cleanup(struct ssh *);\nstatic int sign_and_send_pubkey(struct ssh *ssh, Identity *);\nstatic void pubkey_prepare(struct ssh *, Authctxt *);\nstatic void pubkey_reset(Authctxt *);\nstatic struct sshkey *load_identity_file(Identity *);\n\nstatic Authmethod *authmethod_get(char *authlist);\nstatic Authmethod *authmethod_lookup(const char *name);\nstatic char *authmethods_get(void);\n\nAuthmethod authmethods[] = {\n#ifdef GSSAPI\n\t{\"gssapi-with-mic\",\n\t\tuserauth_gssapi,\n\t\tuserauth_gssapi_cleanup,\n\t\t&options.gss_authentication,\n\t\tNULL},\n#endif\n\t{\"hostbased\",\n\t\tuserauth_hostbased,\n\t\tNULL,\n\t\t&options.hostbased_authentication,\n\t\tNULL},\n\t{\"publickey\",\n\t\tuserauth_pubkey,\n\t\tNULL,\n\t\t&options.pubkey_authentication,\n\t\tNULL},\n\t{\"keyboard-interactive\",\n\t\tuserauth_kbdint,\n\t\tNULL,\n\t\t&options.kbd_interactive_authentication,\n\t\t&options.batch_mode},\n\t{\"password\",\n\t\tuserauth_passwd,\n\t\tNULL,\n\t\t&options.password_authentication,\n\t\t&options.batch_mode},\n\t{\"none\",\n\t\tuserauth_none,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL},\n\t{NULL, NULL, NULL, NULL, NULL}\n};\n\nvoid\nssh_userauth2(struct ssh *ssh, const char *local_user,\n    const char *server_user, char *host, Sensitive *sensitive)\n{\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t \n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t \n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.attempt_kbdint = 0;\n\tauthctxt.attempt_passwd = 0;\n#if GSSAPI\n\tauthctxt.gss_supported_mechs = NULL;\n\tauthctxt.mech_tried = 0;\n#endif\n\tauthctxt.agent_fd = -1;\n\tif (authctxt.method == NULL)\n\t\tfatal_f(\"internal error: cannot send userauth none request\");\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, kex_input_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t \n\tpubkey_cleanup(ssh);\n#ifdef GSSAPI\n\tif (authctxt.gss_supported_mechs != NULL) {\n\t\tu_int ms;\n\n\t\tgss_release_oid_set(&ms, &authctxt.gss_supported_mechs);\n\t\tauthctxt.gss_supported_mechs = NULL;\n\t}\n#endif\n\tssh->authctxt = NULL;\n\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\tverbose(\"Authenticated to %s ([%s]:%d) using \\\"%s\\\".\", host,\n\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t\t    authctxt.method->name);\n\t} else {\n\t\tverbose(\"Authenticated to %s (via proxy) using \\\"%s\\\".\", host,\n\t\t    authctxt.method->name);\n\t}\n}\n\nstatic int\ninput_userauth_service_accept(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tint r;\n\n\tif (ssh_packet_remaining(ssh) > 0) {\n\t\tchar *reply;\n\n\t\tif ((r = sshpkt_get_cstring(ssh, &reply, NULL)) != 0)\n\t\t\tgoto out;\n\t\tdebug2(\"service_accept: %s\", reply);\n\t\tfree(reply);\n\t} else {\n\t\tdebug2(\"buggy server: service_accept w/o service\");\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tdebug(\"SSH2_MSG_SERVICE_ACCEPT received\");\n\n\t \n\tuserauth_none(ssh);\n\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, ssh->kex->ext_info_s ?\n\t    &kex_input_ext_info : &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);\n\tr = 0;\n out:\n\treturn r;\n}\n\nvoid\nuserauth(struct ssh *ssh, char *authlist)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(ssh);\n\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tif (authlist == NULL) {\n\t\tauthlist = authctxt->authlist;\n\t} else {\n\t\tfree(authctxt->authlist);\n\t\tauthctxt->authlist = authlist;\n\t}\n\tfor (;;) {\n\t\tAuthmethod *method = authmethod_get(authlist);\n\t\tif (method == NULL)\n\t\t\tfatal(\"%s@%s: Permission denied (%s).\",\n\t\t\t    authctxt->server_user, authctxt->host, authlist);\n\t\tauthctxt->method = method;\n\n\t\t \n\t\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_PER_METHOD_MIN,\n\t\t    SSH2_MSG_USERAUTH_PER_METHOD_MAX, NULL);\n\n\t\t \n\t\tif (method->userauth(ssh) != 0) {\n\t\t\tdebug2(\"we sent a %s packet, wait for reply\", method->name);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdebug2(\"we did not send a packet, disable method\");\n\t\t\tmethod->enabled = NULL;\n\t\t}\n\t}\n}\n\nstatic int\ninput_userauth_error(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tfatal_f(\"bad message during authentication: type %d\", type);\n\treturn 0;\n}\n\nstatic int\ninput_userauth_banner(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tsize_t len;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\tif ((r = sshpkt_get_cstring(ssh, &msg, &len)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, NULL, NULL)) != 0)\n\t\tgoto out;\n\tif (len > 0 && options.log_level >= SYSLOG_LEVEL_INFO)\n\t\tfmprintf(stderr, \"%s\", msg);\n\tr = 0;\n out:\n\tfree(msg);\n\treturn r;\n}\n\nstatic int\ninput_userauth_success(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\"no authentication context\");\n\tfree(authctxt->authlist);\n\tauthctxt->authlist = NULL;\n\tif (authctxt->method != NULL && authctxt->method->cleanup != NULL)\n\t\tauthctxt->method->cleanup(ssh);\n\tfree(authctxt->methoddata);\n\tauthctxt->methoddata = NULL;\n\tauthctxt->success = 1;\t\t\t \n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, dispatch_protocol_error);\n\treturn 0;\n}\n\n#if 0\nstatic int\ninput_userauth_success_unexpected(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\"no authentication context\");\n\n\tfatal(\"Unexpected authentication success during %s.\",\n\t    authctxt->method->name);\n\treturn 0;\n}\n#endif\n\nstatic int\ninput_userauth_failure(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *authlist = NULL;\n\tu_char partial;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_failure: no authentication context\");\n\n\tif (sshpkt_get_cstring(ssh, &authlist, NULL) != 0 ||\n\t    sshpkt_get_u8(ssh, &partial) != 0 ||\n\t    sshpkt_get_end(ssh) != 0)\n\t\tgoto out;\n\n\tif (partial != 0) {\n\t\tverbose(\"Authenticated using \\\"%s\\\" with partial success.\",\n\t\t    authctxt->method->name);\n\t\t \n\t\tpubkey_reset(authctxt);\n\t}\n\tdebug(\"Authentications that can continue: %s\", authlist);\n\n\tuserauth(ssh, authlist);\n\tauthlist = NULL;\n out:\n\tfree(authlist);\n\treturn 0;\n}\n\n \nstatic char *\nformat_identity(Identity *id)\n{\n\tchar *fp = NULL, *ret = NULL;\n\tconst char *note = \"\";\n\n\tif (id->key != NULL) {\n\t\tfp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t}\n\tif (id->key) {\n\t\tif ((id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\tnote = \" token\";\n\t\telse if (sshkey_is_sk(id->key))\n\t\t\tnote = \" authenticator\";\n\t}\n\txasprintf(&ret, \"%s %s%s%s%s%s%s\",\n\t    id->filename,\n\t    id->key ? sshkey_type(id->key) : \"\", id->key ? \" \" : \"\",\n\t    fp ? fp : \"\",\n\t    id->userprovided ? \" explicit\" : \"\", note,\n\t    id->agent_fd != -1 ? \" agent\" : \"\");\n\tfree(fp);\n\treturn ret;\n}\n\nstatic int\ninput_userauth_pk_ok(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tstruct sshkey *key = NULL;\n\tIdentity *id = NULL;\n\tint pktype, found = 0, sent = 0;\n\tsize_t blen;\n\tchar *pkalg = NULL, *fp = NULL, *ident = NULL;\n\tu_char *pkblob = NULL;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_pk_ok: no authentication context\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n\t    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto done;\n\n\tif ((pktype = sshkey_type_from_name(pkalg)) == KEY_UNSPEC) {\n\t\tdebug_f(\"server sent unknown pkalg %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n\t\tdebug_r(r, \"no key from blob. pkalg %s\", pkalg);\n\t\tgoto done;\n\t}\n\tif (key->type != pktype) {\n\t\terror(\"input_userauth_pk_ok: type mismatch \"\n\t\t    \"for decoded key (received %d, expected %d)\",\n\t\t    key->type, pktype);\n\t\tgoto done;\n\t}\n\n\t \n\tTAILQ_FOREACH_REVERSE(id, &authctxt->keys, idlist, next) {\n\t\tif (sshkey_equal(key, id->key)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found || id == NULL) {\n\t\tfp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t\t    SSH_FP_DEFAULT);\n\t\terror_f(\"server replied with unknown key: %s %s\",\n\t\t    sshkey_type(key), fp == NULL ? \"<ERROR>\" : fp);\n\t\tgoto done;\n\t}\n\tident = format_identity(id);\n\tdebug(\"Server accepts key: %s\", ident);\n\tsent = sign_and_send_pubkey(ssh, id);\n\tr = 0;\n done:\n\tsshkey_free(key);\n\tfree(ident);\n\tfree(fp);\n\tfree(pkalg);\n\tfree(pkblob);\n\n\t \n\tif (r == 0 && sent == 0)\n\t\tuserauth(ssh, NULL);\n\treturn r;\n}\n\n#ifdef GSSAPI\nstatic int\nuserauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tGssctxt *gssctxt = NULL;\n\tOM_uint32 min;\n\tint r, ok = 0;\n\tgss_OID mech = NULL;\n\n\t \n\n\tif (authctxt->gss_supported_mechs == NULL)\n\t\tgss_indicate_mechs(&min, &authctxt->gss_supported_mechs);\n\n\t \n\twhile (authctxt->mech_tried < authctxt->gss_supported_mechs->count &&\n\t    !ok) {\n\t\tmech = &authctxt->gss_supported_mechs->\n\t\t    elements[authctxt->mech_tried];\n\t\t \n\t\tif (mech->length < 128 && ssh_gssapi_check_mechanism(&gssctxt,\n\t\t    mech, authctxt->host)) {\n\t\t\tok = 1;  \n\t\t} else {\n\t\t\tauthctxt->mech_tried++;\n\t\t}\n\t}\n\n\tif (!ok || mech == NULL)\n\t\treturn 0;\n\n\tauthctxt->methoddata=(void *)gssctxt;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, 1)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, (mech->length) + 2)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, SSH_GSS_OIDTYPE)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, mech->length)) != 0 ||\n\t    (r = sshpkt_put(ssh, mech->elements, mech->length)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE, &input_gssapi_response);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERROR, &input_gssapi_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\n\tauthctxt->mech_tried++;  \n\n\treturn 1;\n}\n\nstatic void\nuserauth_gssapi_cleanup(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tGssctxt *gssctxt = (Gssctxt *)authctxt->methoddata;\n\n\tssh_gssapi_delete_ctx(&gssctxt);\n\tauthctxt->methoddata = NULL;\n}\n\nstatic OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send %u packet\", type);\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t \n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"send completion\");\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\",\n\t\t\t    ssh->kex->session_id);\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_mutable_ptr failed\");\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal_fr(r, \"send MIC\");\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int\ninput_gssapi_response(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tsize_t oidlen;\n\tu_char *oidv = NULL;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\t \n\tif ((r = sshpkt_get_string(ssh, &oidv, &oidlen)) != 0)\n\t\tgoto done;\n\n\tif (oidlen <= 2 ||\n\t    oidv[0] != SSH_GSS_OIDTYPE ||\n\t    oidv[1] != oidlen - 2) {\n\t\tdebug(\"Badly encoded mechanism OID received\");\n\t\tuserauth(ssh, NULL);\n\t\tgoto ok;\n\t}\n\n\tif (!ssh_gssapi_check_oid(gssctxt, oidv + 2, oidlen - 2))\n\t\tfatal(\"Server returned different OID than expected\");\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto done;\n\n\tif (GSS_ERROR(process_gssapi_token(ssh, GSS_C_NO_BUFFER))) {\n\t\t \n\t\tdebug(\"Trying to start again\");\n\t\tuserauth(ssh, NULL);\n\t\tgoto ok;\n\t}\n ok:\n\tr = 0;\n done:\n\tfree(oidv);\n\treturn r;\n}\n\nstatic int\ninput_gssapi_token(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_buffer_desc recv_tok;\n\tu_char *p = NULL;\n\tsize_t len;\n\tOM_uint32 status;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\tstatus = process_gssapi_token(ssh, &recv_tok);\n\n\t \n\tif (GSS_ERROR(status)) {\n\t\tuserauth(ssh, NULL);\n\t\t \n\t}\n\tr = 0;\n out:\n\tfree(p);\n\treturn r;\n}\n\nstatic int\ninput_gssapi_errtok(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc recv_tok;\n\tOM_uint32 ms;\n\tu_char *p = NULL;\n\tsize_t len;\n\tint r;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_gssapi_response: no authentication context\");\n\tgssctxt = authctxt->methoddata;\n\n\tif ((r = sshpkt_get_string(ssh, &p, &len)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\tfree(p);\n\t\treturn r;\n\t}\n\n\t \n\trecv_tok.value = p;\n\trecv_tok.length = len;\n\t(void)ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    &recv_tok, &send_tok, NULL);\n\tfree(p);\n\tgss_release_buffer(&ms, &send_tok);\n\n\t \n\treturn 0;\n}\n\nstatic int\ninput_gssapi_error(int type, u_int32_t plen, struct ssh *ssh)\n{\n\tchar *msg = NULL;\n\tchar *lang = NULL;\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t \n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t \n\t    (r = sshpkt_get_cstring(ssh, &msg, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tr = sshpkt_get_end(ssh);\n\tdebug(\"Server GSSAPI Error:\\n%s\", msg);\n out:\n\tfree(msg);\n\tfree(lang);\n\treturn r;\n}\n#endif  \n\nstatic int\nuserauth_none(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tint r;\n\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\treturn 1;\n}\n\nstatic int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\txasprintf(&prompt, \"%s@%s's password: \", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\n\treturn 1;\n}\n\n \nstatic int\ninput_userauth_passwd_changereq(int type, u_int32_t seqnr, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *info = NULL, *lang = NULL, *password = NULL, *retype = NULL;\n\tchar prompt[256];\n\tconst char *host;\n\tint r;\n\n\tdebug2(\"input_userauth_passwd_changereq\");\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_passwd_changereq: \"\n\t\t    \"no authentication context\");\n\thost = options.host_key_alias ? options.host_key_alias : authctxt->host;\n\n\tif ((r = sshpkt_get_cstring(ssh, &info, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(info) > 0)\n\t\tlogit(\"%s\", info);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 1)) != 0)\t \n\t\tgoto out;\n\n\tsnprintf(prompt, sizeof(prompt),\n\t    \"Enter %.30s@%.128s's old password: \",\n\t    authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_put_cstring(ssh, password)) != 0)\n\t\tgoto out;\n\n\tfreezero(password, strlen(password));\n\tpassword = NULL;\n\twhile (password == NULL) {\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Enter %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tpassword = read_passphrase(prompt, RP_ALLOW_EOF);\n\t\tif (password == NULL) {\n\t\t\t \n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tsnprintf(prompt, sizeof(prompt),\n\t\t    \"Retype %.30s@%.128s's new password: \",\n\t\t    authctxt->server_user, host);\n\t\tretype = read_passphrase(prompt, 0);\n\t\tif (strcmp(password, retype) != 0) {\n\t\t\tfreezero(password, strlen(password));\n\t\t\tlogit(\"Mismatch; try again, EOF to quit.\");\n\t\t\tpassword = NULL;\n\t\t}\n\t\tfreezero(retype, strlen(retype));\n\t}\n\tif ((r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\tr = 0;\n out:\n\tif (password)\n\t\tfreezero(password, strlen(password));\n\tfree(info);\n\tfree(lang);\n\treturn r;\n}\n\n \nstatic char *\nkey_sig_algorithm(struct ssh *ssh, const struct sshkey *key)\n{\n\tchar *allowed, *oallowed, *cp, *tmp, *alg = NULL;\n\tconst char *server_sig_algs;\n\n\t \n\tif (ssh == NULL || ssh->kex->server_sig_algs == NULL ||\n\t    (key->type != KEY_RSA && key->type != KEY_RSA_CERT) ||\n\t    (key->type == KEY_RSA_CERT && (ssh->compat & SSH_BUG_SIGTYPE))) {\n\t\t \n\t\treturn match_list(sshkey_ssh_name(key),\n\t\t    options.pubkey_accepted_algos, NULL);\n\t}\n\n\t \n\tserver_sig_algs = ssh->kex->server_sig_algs;\n\tif (key->type == KEY_RSA && (ssh->compat & SSH_BUG_SIGTYPE74))\n\t\tserver_sig_algs = \"rsa-sha2-256,rsa-sha2-512\";\n\n\t \n\toallowed = allowed = xstrdup(options.pubkey_accepted_algos);\n\twhile ((cp = strsep(&allowed, \",\")) != NULL) {\n\t\tif (sshkey_type_from_name(cp) != key->type)\n\t\t\tcontinue;\n\t\ttmp = match_list(sshkey_sigalg_by_name(cp),\n\t\t    server_sig_algs, NULL);\n\t\tif (tmp != NULL)\n\t\t\talg = xstrdup(cp);\n\t\tfree(tmp);\n\t\tif (alg != NULL)\n\t\t\tbreak;\n\t}\n\tfree(oallowed);\n\treturn alg;\n}\n\nstatic int\nidentity_sign(struct identity *id, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, u_int compat, const char *alg)\n{\n\tstruct sshkey *sign_key = NULL, *prv = NULL;\n\tint is_agent = 0, retried = 0, r = SSH_ERR_INTERNAL_ERROR;\n\tstruct notifier_ctx *notifier = NULL;\n\tchar *fp = NULL, *pin = NULL, *prompt = NULL;\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\t \n\tif (id->key != NULL && id->agent_fd != -1) {\n\t\treturn ssh_agent_sign(id->agent_fd, id->key, sigp, lenp,\n\t\t    data, datalen, alg, compat);\n\t}\n\n\t \n\tif (id->key != NULL &&\n\t    (id->isprivate || (id->key->flags & SSHKEY_FLAG_EXT))) {\n\t\tsign_key = id->key;\n\t\tis_agent = 1;\n\t} else {\n\t\t \n\t\tif ((prv = load_identity_file(id)) == NULL)\n\t\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\t\tif (id->key != NULL && !sshkey_equal_public(prv, id->key)) {\n\t\t\terror_f(\"private key %s contents do not match public\",\n\t\t\t    id->filename);\n\t\t\tr = SSH_ERR_KEY_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t\tsign_key = prv;\n\t}\n retry_pin:\n\t \n\tif (!is_agent && sshkey_is_sk(sign_key) &&\n\t    (sign_key->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {\n\t\t \n\t\tif ((fp = sshkey_fingerprint(sign_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tnotifier = notify_start(options.batch_mode,\n\t\t    \"Confirm user presence for key %s %s\",\n\t\t    sshkey_type(sign_key), fp);\n\t\tfree(fp);\n\t}\n\tif ((r = sshkey_sign(sign_key, sigp, lenp, data, datalen,\n\t    alg, options.sk_provider, pin, compat)) != 0) {\n\t\tdebug_fr(r, \"sshkey_sign\");\n\t\tif (!retried && pin == NULL && !is_agent &&\n\t\t    sshkey_is_sk(sign_key) &&\n\t\t    r == SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\t\tnotify_complete(notifier, NULL);\n\t\t\tnotifier = NULL;\n\t\t\txasprintf(&prompt, \"Enter PIN for %s key %s: \",\n\t\t\t    sshkey_type(sign_key), id->filename);\n\t\t\tpin = read_passphrase(prompt, 0);\n\t\t\tretried = 1;\n\t\t\tgoto retry_pin;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshkey_check_sigtype(*sigp, *lenp, alg)) != 0) {\n\t\tdebug_fr(r, \"sshkey_check_sigtype\");\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n out:\n\tfree(prompt);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\tnotify_complete(notifier, r == 0 ? \"User presence confirmed\" : NULL);\n\tsshkey_free(prv);\n\treturn r;\n}\n\nstatic int\nid_filename_matches(Identity *id, Identity *private_id)\n{\n\tstatic const char * const suffixes[] = { \".pub\", \"-cert.pub\", NULL };\n\tsize_t len = strlen(id->filename), plen = strlen(private_id->filename);\n\tsize_t i, slen;\n\n\tif (strcmp(id->filename, private_id->filename) == 0)\n\t\treturn 1;\n\tfor (i = 0; suffixes[i]; i++) {\n\t\tslen = strlen(suffixes[i]);\n\t\tif (len > slen && plen == len - slen &&\n\t\t    strcmp(id->filename + (len - slen), suffixes[i]) == 0 &&\n\t\t    memcmp(id->filename, private_id->filename, plen) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\nsign_and_send_pubkey(struct ssh *ssh, Identity *id)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tstruct sshbuf *b = NULL;\n\tIdentity *private_id, *sign_id = NULL;\n\tu_char *signature = NULL;\n\tsize_t slen = 0, skip = 0;\n\tint r, fallback_sigtype, sent = 0;\n\tchar *alg = NULL, *fp = NULL;\n\tconst char *loc = \"\", *method = \"publickey\";\n\tint hostbound = 0;\n\n\t \n\tif ((ssh->kex->flags & KEX_HAS_PUBKEY_HOSTBOUND) != 0 &&\n\t    (options.pubkey_authentication & SSH_PUBKEY_AUTH_HBOUND) != 0) {\n\t\thostbound = 1;\n\t\tmethod = \"publickey-hostbound-v00@openssh.com\";\n\t}\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\n\tdebug3_f(\"using %s with %s %s\", method, sshkey_type(id->key), fp);\n\n\t \n\tif (sshkey_is_cert(id->key)) {\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tsign_id = private_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (sign_id == NULL &&\n\t\t    !id->isprivate && id->agent_fd == -1 &&\n\t\t    (id->key->flags & SSHKEY_FLAG_EXT) == 0) {\n\t\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\t\tif (private_id->key == NULL &&\n\t\t\t\t    id_filename_matches(id, private_id)) {\n\t\t\t\t\tsign_id = private_id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sign_id != NULL) {\n\t\t\tdebug2_f(\"using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", sign_id->filename,\n\t\t\t    sign_id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug_f(\"no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", id->filename);\n\t\t}\n\t}\n\n\t \n\tif (sign_id == NULL)\n\t\tsign_id = id;\n\n\t \n\tfor (fallback_sigtype = 0; fallback_sigtype <= 1; fallback_sigtype++) {\n\t\tfree(alg);\n\t\tslen = 0;\n\t\tsignature = NULL;\n\t\tif ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,\n\t\t    id->key)) == NULL) {\n\t\t\terror_f(\"no mutual signature supported\");\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3_f(\"signing using %s %s\", alg, fp);\n\n\t\tsshbuf_free(b);\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\t\tif ((r = sshbuf_putb(b, ssh->kex->session_id)) != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_putb\");\n\t\t} else {\n\t\t\tif ((r = sshbuf_put_stringb(b,\n\t\t\t    ssh->kex->session_id)) != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_put_stringb\");\n\t\t}\n\t\tskip = sshbuf_len(b);\n\t\tif ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, method)) != 0 ||\n\t\t    (r = sshbuf_put_u8(b, 1)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(b, alg)) != 0 ||\n\t\t    (r = sshkey_puts(id->key, b)) != 0) {\n\t\t\tfatal_fr(r, \"assemble signed data\");\n\t\t}\n\t\tif (hostbound) {\n\t\t\tif (ssh->kex->initial_hostkey == NULL) {\n\t\t\t\tfatal_f(\"internal error: initial hostkey \"\n\t\t\t\t    \"not recorded\");\n\t\t\t}\n\t\t\tif ((r = sshkey_puts(ssh->kex->initial_hostkey, b)) != 0)\n\t\t\t\tfatal_fr(r, \"assemble %s hostkey\", method);\n\t\t}\n\t\t \n\t\tr = identity_sign(sign_id, &signature, &slen,\n\t\t    sshbuf_ptr(b), sshbuf_len(b), ssh->compat, alg);\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\telse if (r == SSH_ERR_KEY_NOT_FOUND)\n\t\t\tgoto out;  \n\t\telse if (r == SSH_ERR_SIGN_ALG_UNSUPPORTED &&\n\t\t    !fallback_sigtype) {\n\t\t\tif (sign_id->agent_fd != -1)\n\t\t\t\tloc = \"agent \";\n\t\t\telse if ((sign_id->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tloc = \"token \";\n\t\t\tlogit(\"%skey %s %s returned incorrect signature type\",\n\t\t\t    loc, sshkey_type(id->key), fp);\n\t\t\tcontinue;\n\t\t}\n\t\terror_fr(r, \"signing failed for %s \\\"%s\\\"%s\",\n\t\t    sshkey_type(sign_id->key), sign_id->filename,\n\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\tgoto out;\n\t}\n\tif (slen == 0 || signature == NULL)  \n\t\tfatal_f(\"no signature\");\n\n\t \n\tif ((r = sshbuf_put_string(b, signature, slen)) != 0)\n\t\tfatal_fr(r, \"append signature\");\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\t \n\tif ((r = sshbuf_consume(b, skip + 1)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_putb(ssh, b)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"enqueue request\");\n\n\t \n\tsent = 1;\n\n out:\n\tfree(fp);\n\tfree(alg);\n\tsshbuf_free(b);\n\tfreezero(signature, slen);\n\treturn sent;\n}\n\nstatic int\nsend_pubkey_test(struct ssh *ssh, Identity *id)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tu_char *blob = NULL;\n\tchar *alg = NULL;\n\tsize_t bloblen;\n\tu_int have_sig = 0;\n\tint sent = 0, r;\n\n\tif ((alg = key_sig_algorithm(ssh, id->key)) == NULL) {\n\t\tdebug_f(\"no mutual signature algorithm\");\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_blob(id->key, &blob, &bloblen)) != 0) {\n\t\t \n\t\tdebug3_f(\"cannot handle key\");\n\t\tgoto out;\n\t}\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PK_OK, &input_userauth_pk_ok);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, have_sig)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, alg)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, blob, bloblen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\tsent = 1;\n\n out:\n\tfree(alg);\n\tfree(blob);\n\treturn sent;\n}\n\nstatic struct sshkey *\nload_identity_file(Identity *id)\n{\n\tstruct sshkey *private = NULL;\n\tchar prompt[300], *passphrase, *comment;\n\tint r, quit = 0, i;\n\tstruct stat st;\n\n\tif (stat(id->filename, &st) == -1) {\n\t\tdo_log2(id->userprovided ?\n\t\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_DEBUG3,\n\t\t    \"no such identity: %s: %s\", id->filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tsnprintf(prompt, sizeof prompt,\n\t    \"Enter passphrase for key '%.100s': \", id->filename);\n\tfor (i = 0; i <= options.number_of_password_prompts; i++) {\n\t\tif (i == 0)\n\t\t\tpassphrase = \"\";\n\t\telse {\n\t\t\tpassphrase = read_passphrase(prompt, 0);\n\t\t\tif (*passphrase == '\\0') {\n\t\t\t\tdebug2(\"no passphrase given, try next key\");\n\t\t\t\tfree(passphrase);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswitch ((r = sshkey_load_private_type(KEY_UNSPEC, id->filename,\n\t\t    passphrase, &private, &comment))) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase SSH_ERR_KEY_WRONG_PASSPHRASE:\n\t\t\tif (options.batch_mode) {\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tdebug2(\"bad passphrase given, try again...\");\n\t\t\tbreak;\n\t\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tdebug2_r(r, \"Load key \\\"%s\\\"\", id->filename);\n\t\t\t\tquit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\tdefault:\n\t\t\terror_r(r, \"Load key \\\"%s\\\"\", id->filename);\n\t\t\tquit = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (private != NULL && sshkey_is_sk(private) &&\n\t\t    options.sk_provider == NULL) {\n\t\t\tdebug(\"key \\\"%s\\\" is an authenticator-hosted key, \"\n\t\t\t    \"but no provider specified\", id->filename);\n\t\t\tsshkey_free(private);\n\t\t\tprivate = NULL;\n\t\t\tquit = 1;\n\t\t}\n\t\tif (!quit && (r = sshkey_check_rsa_length(private,\n\t\t    options.required_rsa_size)) != 0) {\n\t\t\tdebug_fr(r, \"Skipping key %s\", id->filename);\n\t\t\tsshkey_free(private);\n\t\t\tprivate = NULL;\n\t\t\tquit = 1;\n\t\t}\n\t\tif (!quit && private != NULL && id->agent_fd == -1 &&\n\t\t    !(id->key && id->isprivate))\n\t\t\tmaybe_add_key_to_agent(id->filename, private, comment,\n\t\t\t    passphrase);\n\t\tif (i > 0)\n\t\t\tfreezero(passphrase, strlen(passphrase));\n\t\tfree(comment);\n\t\tif (private != NULL || quit)\n\t\t\tbreak;\n\t}\n\treturn private;\n}\n\nstatic int\nkey_type_allowed_by_config(struct sshkey *key)\n{\n\tif (match_pattern_list(sshkey_ssh_name(key),\n\t    options.pubkey_accepted_algos, 0) == 1)\n\t\treturn 1;\n\n\t \n\tswitch (key->type) {\n\tcase KEY_RSA:\n\t\tif (match_pattern_list(\"rsa-sha2-512\",\n\t\t    options.pubkey_accepted_algos, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256\",\n\t\t    options.pubkey_accepted_algos, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase KEY_RSA_CERT:\n\t\tif (match_pattern_list(\"rsa-sha2-512-cert-v01@openssh.com\",\n\t\t    options.pubkey_accepted_algos, 0) == 1)\n\t\t\treturn 1;\n\t\tif (match_pattern_list(\"rsa-sha2-256-cert-v01@openssh.com\",\n\t\t    options.pubkey_accepted_algos, 0) == 1)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nget_agent_identities(struct ssh *ssh, int *agent_fdp,\n    struct ssh_identitylist **idlistp)\n{\n\tint r, agent_fd;\n\tstruct ssh_identitylist *idlist;\n\n\tif ((r = ssh_get_authentication_socket(&agent_fd)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\tdebug_fr(r, \"ssh_get_authentication_socket\");\n\t\treturn r;\n\t}\n\tif ((r = ssh_agent_bind_hostkey(agent_fd, ssh->kex->initial_hostkey,\n\t    ssh->kex->session_id, ssh->kex->initial_sig, 0)) == 0)\n\t\tdebug_f(\"bound agent to hostkey\");\n\telse\n\t\tdebug2_fr(r, \"ssh_agent_bind_hostkey\");\n\n\tif ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {\n\t\tdebug_fr(r, \"ssh_fetch_identitylist\");\n\t\tclose(agent_fd);\n\t\treturn r;\n\t}\n\t \n\t*agent_fdp = agent_fd;\n\t*idlistp = idlist;\n\tdebug_f(\"agent returned %zu keys\", idlist->nkeys);\n\treturn 0;\n}\n\n \nstatic void\npubkey_prepare(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstruct identity *id, *id2, *tmp;\n\tstruct idlist agent, files, *preferred;\n\tstruct sshkey *key;\n\tint disallowed, agent_fd = -1, i, r, found;\n\tsize_t j;\n\tstruct ssh_identitylist *idlist;\n\tchar *cp, *ident;\n\n\tTAILQ_INIT(&agent);\t \n\tTAILQ_INIT(&files);\t \n\tpreferred = &authctxt->keys;\n\tTAILQ_INIT(preferred);\t \n\n\t \n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tkey = options.identity_keys[i];\n\t\tif (key && key->cert &&\n\t\t    key->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\tdebug_f(\"ignoring certificate %s: not a user \"\n\t\t\t    \"certificate\", options.identity_files[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (key && sshkey_is_sk(key) && options.sk_provider == NULL) {\n\t\t\tdebug_f(\"ignoring authenticator-hosted key %s as no \"\n\t\t\t    \"SecurityKeyProvider has been specified\",\n\t\t\t    options.identity_files[i]);\n\t\t\tcontinue;\n\t\t}\n\t\toptions.identity_keys[i] = NULL;\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.identity_files[i]);\n\t\tid->userprovided = options.identity_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(&files, id, next);\n\t}\n\t \n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tkey = options.certificates[i];\n\t\tif (!sshkey_is_cert(key) || key->cert == NULL ||\n\t\t    key->cert->type != SSH2_CERT_TYPE_USER) {\n\t\t\tdebug_f(\"ignoring certificate %s: not a user \"\n\t\t\t    \"certificate\", options.identity_files[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (key && sshkey_is_sk(key) && options.sk_provider == NULL) {\n\t\t\tdebug_f(\"ignoring authenticator-hosted key \"\n\t\t\t    \"certificate %s as no \"\n\t\t\t    \"SecurityKeyProvider has been specified\",\n\t\t\t    options.identity_files[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tid = xcalloc(1, sizeof(*id));\n\t\tid->agent_fd = -1;\n\t\tid->key = key;\n\t\tid->filename = xstrdup(options.certificate_files[i]);\n\t\tid->userprovided = options.certificate_file_userprovided[i];\n\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t}\n\t \n\tif ((r = get_agent_identities(ssh, &agent_fd, &idlist)) == 0) {\n\t\tfor (j = 0; j < idlist->nkeys; j++) {\n\t\t\tif ((r = sshkey_check_rsa_length(idlist->keys[j],\n\t\t\t    options.required_rsa_size)) != 0) {\n\t\t\t\tdebug_fr(r, \"ignoring %s agent key\",\n\t\t\t\t    sshkey_ssh_name(idlist->keys[j]));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = 0;\n\t\t\tTAILQ_FOREACH(id, &files, next) {\n\t\t\t\t \n\t\t\t\tif (sshkey_equal(idlist->keys[j], id->key)) {\n\t\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found && !options.identities_only) {\n\t\t\t\tid = xcalloc(1, sizeof(*id));\n\t\t\t\t \n\t\t\t\tid->key = idlist->keys[j];\n\t\t\t\tid->filename = idlist->comments[j];\n\t\t\t\tidlist->keys[j] = NULL;\n\t\t\t\tidlist->comments[j] = NULL;\n\t\t\t\tid->agent_fd = agent_fd;\n\t\t\t\tTAILQ_INSERT_TAIL(&agent, id, next);\n\t\t\t}\n\t\t}\n\t\tssh_free_identitylist(idlist);\n\t\t \n\t\tTAILQ_CONCAT(preferred, &agent, next);\n\t\tauthctxt->agent_fd = agent_fd;\n\t}\n\t \n\tTAILQ_FOREACH_SAFE(id, &files, next, tmp) {\n\t\tif (id->key == NULL || (id->key->flags & SSHKEY_FLAG_EXT) == 0)\n\t\t\tcontinue;\n\t\tfound = 0;\n\t\tTAILQ_FOREACH(id2, &files, next) {\n\t\t\tif (id2->key == NULL ||\n\t\t\t    (id2->key->flags & SSHKEY_FLAG_EXT) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (sshkey_equal(id->key, id2->key)) {\n\t\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\t\tTAILQ_INSERT_TAIL(preferred, id, next);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!found && options.identities_only) {\n\t\t\tTAILQ_REMOVE(&files, id, next);\n\t\t\tfreezero(id, sizeof(*id));\n\t\t}\n\t}\n\t \n\tTAILQ_CONCAT(preferred, &files, next);\n\t \n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tdisallowed = 0;\n\t\tcp = NULL;\n\t\tif (id->key == NULL)\n\t\t\tcontinue;\n\t\tif (!key_type_allowed_by_config(id->key)) {\n\t\t\tdebug(\"Skipping %s key %s - corresponding algorithm \"\n\t\t\t    \"not in PubkeyAcceptedAlgorithms\",\n\t\t\t    sshkey_ssh_name(id->key), id->filename);\n\t\t\tdisallowed = 1;\n\t\t} else if (ssh->kex->server_sig_algs != NULL &&\n\t\t    (cp = key_sig_algorithm(ssh, id->key)) == NULL) {\n\t\t\tdebug(\"Skipping %s key %s - corresponding algorithm \"\n\t\t\t    \"not supported by server\",\n\t\t\t    sshkey_ssh_name(id->key), id->filename);\n\t\t\tdisallowed = 1;\n\t\t}\n\t\tfree(cp);\n\t\tif (!disallowed)\n\t\t\tcontinue;\n\t\t \n\t\tTAILQ_REMOVE(preferred, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tmemset(id, 0, sizeof(*id));\n\t}\n\t \n\tTAILQ_FOREACH_SAFE(id, preferred, next, id2) {\n\t\tident = format_identity(id);\n\t\tdebug(\"Will attempt key: %s\", ident);\n\t\tfree(ident);\n\t}\n\tdebug2_f(\"done\");\n}\n\nstatic void\npubkey_cleanup(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tIdentity *id;\n\n\tif (authctxt->agent_fd != -1) {\n\t\tssh_close_authentication_socket(authctxt->agent_fd);\n\t\tauthctxt->agent_fd = -1;\n\t}\n\tfor (id = TAILQ_FIRST(&authctxt->keys); id;\n\t    id = TAILQ_FIRST(&authctxt->keys)) {\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tfree(id);\n\t}\n}\n\nstatic void\npubkey_reset(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tTAILQ_FOREACH(id, &authctxt->keys, next)\n\t\tid->tried = 0;\n}\n\nstatic int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\tstatic int prepared;\n\n\tif (!prepared) {\n\t\tpubkey_prepare(ssh, authctxt);\n\t\tprepared = 1;\n\t}\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t \n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t \n\t\tif (id->key != NULL) {\n\t\t\tident = format_identity(id);\n\t\t\tdebug(\"Offering public key: %s\", ident);\n\t\t\tfree(ident);\n\t\t\tsent = send_pubkey_test(ssh, id);\n\t\t} else {\n\t\t\tdebug(\"Trying private key: %s\", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (id->key != NULL) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent)\n\t\t\treturn (sent);\n\t}\n\treturn (0);\n}\n\n \nstatic int\nuserauth_kbdint(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tint r;\n\n\tif (authctxt->attempt_kbdint++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\t \n\tif (authctxt->attempt_kbdint > 1 && !authctxt->info_req_seen) {\n\t\tdebug3(\"userauth_kbdint: disable: no info_req_seen\");\n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST, NULL);\n\t\treturn 0;\n\t}\n\n\tdebug2(\"userauth_kbdint\");\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t\t \n\t    (r = sshpkt_put_cstring(ssh, options.kbd_interactive_devices ?\n\t    options.kbd_interactive_devices : \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST, &input_userauth_info_req);\n\treturn 1;\n}\n\n \nstatic int\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *display_prompt = NULL, *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2_f(\"entering\");\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\"no authentication context\");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\"%s\", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\"%s\", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2_f(\"num_prompts %d\", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tif (asmprintf(&display_prompt, INT_MAX, NULL, \"(%s@%s) %s\",\n\t\t    authctxt->server_user, options.host_key_alias ?\n\t\t    options.host_key_alias : authctxt->host, prompt) == -1)\n\t\t\tfatal_f(\"asmprintf failed\");\n\t\tresponse = read_passphrase(display_prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tfree(display_prompt);\n\t\tdisplay_prompt = response = prompt = NULL;\n\t}\n\t \n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(display_prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}\n\nstatic int\nssh_keysign(struct ssh *ssh, struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen)\n{\n\tstruct sshbuf *b;\n\tstruct stat st;\n\tpid_t pid;\n\tint r, to[2], from[2], status;\n\tint sock = ssh_packet_get_connection_in(ssh);\n\tu_char rversion = 0, version = 2;\n\tvoid (*osigchld)(int);\n\n\t*sigp = NULL;\n\t*lenp = 0;\n\n\tif (stat(_PATH_SSH_KEY_SIGN, &st) == -1) {\n\t\terror_f(\"not installed: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (fflush(stdout) != 0) {\n\t\terror_f(\"fflush: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(to) == -1) {\n\t\terror_f(\"pipe: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(from) == -1) {\n\t\terror_f(\"pipe: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif ((pid = fork()) == -1) {\n\t\terror_f(\"fork: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\tif (pid == 0) {\n\t\tclose(from[0]);\n\t\tif (dup2(from[1], STDOUT_FILENO) == -1)\n\t\t\tfatal_f(\"dup2: %s\", strerror(errno));\n\t\tclose(to[1]);\n\t\tif (dup2(to[0], STDIN_FILENO) == -1)\n\t\t\tfatal_f(\"dup2: %s\", strerror(errno));\n\t\tclose(from[1]);\n\t\tclose(to[0]);\n\n\t\tif (dup2(sock, STDERR_FILENO + 1) == -1)\n\t\t\tfatal_f(\"dup2: %s\", strerror(errno));\n\t\tsock = STDERR_FILENO + 1;\n\t\tif (fcntl(sock, F_SETFD, 0) == -1)  \n\t\t\tdebug3_f(\"fcntl F_SETFD: %s\", strerror(errno));\n\t\tclosefrom(sock + 1);\n\n\t\tdebug3_f(\"[child] pid=%ld, exec %s\",\n\t\t    (long)getpid(), _PATH_SSH_KEY_SIGN);\n\t\texecl(_PATH_SSH_KEY_SIGN, _PATH_SSH_KEY_SIGN, (char *)NULL);\n\t\tfatal_f(\"exec(%s): %s\", _PATH_SSH_KEY_SIGN,\n\t\t    strerror(errno));\n\t}\n\tclose(from[1]);\n\tclose(to[0]);\n\tsock = STDERR_FILENO + 1;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\t \n\tif ((r = sshbuf_put_u32(b, sock)) != 0 ||\n\t    (r = sshbuf_put_string(b, data, datalen)) != 0)\n\t\tfatal_fr(r, \"buffer error\");\n\tif (ssh_msg_send(to[1], version, b) == -1)\n\t\tfatal_f(\"couldn't send request\");\n\tsshbuf_reset(b);\n\tr = ssh_msg_recv(from[0], b);\n\tclose(from[0]);\n\tclose(to[1]);\n\tif (r < 0) {\n\t\terror_f(\"no reply\");\n\t\tgoto fail;\n\t}\n\n\terrno = 0;\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR) {\n\t\t\terror_f(\"waitpid %ld: %s\", (long)pid, strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror_f(\"exited abnormally\");\n\t\tgoto fail;\n\t}\n\tif (WEXITSTATUS(status) != 0) {\n\t\terror_f(\"exited with status %d\", WEXITSTATUS(status));\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_u8(b, &rversion)) != 0) {\n\t\terror_fr(r, \"buffer error\");\n\t\tgoto fail;\n\t}\n\tif (rversion != version) {\n\t\terror_f(\"bad version\");\n\t\tgoto fail;\n\t}\n\tif ((r = sshbuf_get_string(b, sigp, lenp)) != 0) {\n\t\terror_fr(r, \"buffer error\");\n fail:\n\t\tssh_signal(SIGCHLD, osigchld);\n\t\tsshbuf_free(b);\n\t\treturn -1;\n\t}\n\tssh_signal(SIGCHLD, osigchld);\n\tsshbuf_free(b);\n\n\treturn 0;\n}\n\nstatic int\nuserauth_hostbased(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tstruct sshkey *private = NULL;\n\tstruct sshbuf *b = NULL;\n\tu_char *sig = NULL, *keyblob = NULL;\n\tchar *fp = NULL, *chost = NULL, *lname = NULL;\n\tsize_t siglen = 0, keylen = 0;\n\tint i, r, success = 0;\n\n\tif (authctxt->ktypes == NULL) {\n\t\tauthctxt->oktypes = xstrdup(options.hostbased_accepted_algos);\n\t\tauthctxt->ktypes = authctxt->oktypes;\n\t}\n\n\t \n\tfor (;;) {\n\t\tif (authctxt->active_ktype == NULL)\n\t\t\tauthctxt->active_ktype = strsep(&authctxt->ktypes, \",\");\n\t\tif (authctxt->active_ktype == NULL ||\n\t\t    *authctxt->active_ktype == '\\0')\n\t\t\tbreak;\n\t\tdebug3_f(\"trying key type %s\", authctxt->active_ktype);\n\n\t\t \n\t\tprivate = NULL;\n\t\tfor (i = 0; i < authctxt->sensitive->nkeys; i++) {\n\t\t\tif (authctxt->sensitive->keys[i] == NULL ||\n\t\t\t    authctxt->sensitive->keys[i]->type == KEY_UNSPEC)\n\t\t\t\tcontinue;\n\t\t\tif (!sshkey_match_keyname_to_sigalgs(\n\t\t\t    sshkey_ssh_name(authctxt->sensitive->keys[i]),\n\t\t\t    authctxt->active_ktype))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tprivate = authctxt->sensitive->keys[i];\n\t\t\tauthctxt->sensitive->keys[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (private != NULL)\n\t\t\tbreak;\n\t\t \n\t\tauthctxt->active_ktype = NULL;\n\t}\n\tif (private == NULL) {\n\t\tfree(authctxt->oktypes);\n\t\tauthctxt->oktypes = authctxt->ktypes = NULL;\n\t\tauthctxt->active_ktype = NULL;\n\t\tdebug(\"No more client hostkeys for hostbased authentication.\");\n\t\tgoto out;\n\t}\n\n\tif ((fp = sshkey_fingerprint(private, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL) {\n\t\terror_f(\"sshkey_fingerprint failed\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"trying hostkey %s %s using sigalg %s\",\n\t    sshkey_ssh_name(private), fp, authctxt->active_ktype);\n\n\t \n\tlname = get_local_name(ssh_packet_get_connection_in(ssh));\n\tif (lname == NULL) {\n\t\terror_f(\"cannot get local ipaddr/name\");\n\t\tgoto out;\n\t}\n\n\t \n\txasprintf(&chost, \"%s.\", lname);\n\tdebug2_f(\"chost %s\", chost);\n\n\t \n\tif ((b = sshbuf_new()) == NULL) {\n\t\terror_f(\"sshbuf_new failed\");\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_to_blob(private, &keyblob, &keylen)) != 0) {\n\t\terror_fr(r, \"sshkey_to_blob\");\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_stringb(b, ssh->kex->session_id)) != 0 ||\n\t    (r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->server_user)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->method->name)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->active_ktype)) != 0 ||\n\t    (r = sshbuf_put_string(b, keyblob, keylen)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, chost)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, authctxt->local_user)) != 0) {\n\t\terror_fr(r, \"buffer error\");\n\t\tgoto out;\n\t}\n\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tif ((r = ssh_keysign(ssh, private, &sig, &siglen,\n\t    sshbuf_ptr(b), sshbuf_len(b))) != 0) {\n\t\terror(\"sign using hostkey %s %s failed\",\n\t\t    sshkey_ssh_name(private), fp);\n\t\tgoto out;\n\t}\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->active_ktype)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, keyblob, keylen)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, chost)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->local_user)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, sig, siglen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0) {\n\t\terror_fr(r, \"packet error\");\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n\n out:\n\tif (sig != NULL)\n\t\tfreezero(sig, siglen);\n\tfree(keyblob);\n\tfree(lname);\n\tfree(fp);\n\tfree(chost);\n\tsshkey_free(private);\n\tsshbuf_free(b);\n\n\treturn success;\n}\n\n \n\n \nstatic int\nauthmethod_is_enabled(Authmethod *method)\n{\n\tif (method == NULL)\n\t\treturn 0;\n\t \n\tif  (method->enabled == NULL || *method->enabled == 0)\n\t\treturn 0;\n\t \n\tif  (method->batch_flag != NULL && *method->batch_flag != 0)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic Authmethod *\nauthmethod_lookup(const char *name)\n{\n\tAuthmethod *method = NULL;\n\tif (name != NULL)\n\t\tfor (method = authmethods; method->name != NULL; method++)\n\t\t\tif (strcmp(name, method->name) == 0)\n\t\t\t\treturn method;\n\tdebug2(\"Unrecognized authentication method name: %s\", name ? name : \"NULL\");\n\treturn NULL;\n}\n\n \nstatic Authmethod *current = NULL;\nstatic char *supported = NULL;\nstatic char *preferred = NULL;\n\n \nstatic Authmethod *\nauthmethod_get(char *authlist)\n{\n\tchar *name = NULL;\n\tu_int next;\n\n\t \n\tif (authlist == NULL || strlen(authlist) == 0)\n\t\tauthlist = options.preferred_authentications;\n\n\tif (supported == NULL || strcmp(authlist, supported) != 0) {\n\t\tdebug3(\"start over, passed a different list %s\", authlist);\n\t\tfree(supported);\n\t\tsupported = xstrdup(authlist);\n\t\tpreferred = options.preferred_authentications;\n\t\tdebug3(\"preferred %s\", preferred);\n\t\tcurrent = NULL;\n\t} else if (current != NULL && authmethod_is_enabled(current))\n\t\treturn current;\n\n\tfor (;;) {\n\t\tif ((name = match_list(preferred, supported, &next)) == NULL) {\n\t\t\tdebug(\"No more authentication methods to try.\");\n\t\t\tcurrent = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\tpreferred += next;\n\t\tdebug3(\"authmethod_lookup %s\", name);\n\t\tdebug3(\"remaining preferred: %s\", preferred);\n\t\tif ((current = authmethod_lookup(name)) != NULL &&\n\t\t    authmethod_is_enabled(current)) {\n\t\t\tdebug3(\"authmethod_is_enabled %s\", name);\n\t\t\tdebug(\"Next authentication method: %s\", name);\n\t\t\tfree(name);\n\t\t\treturn current;\n\t\t}\n\t\tfree(name);\n\t}\n}\n\nstatic char *\nauthmethods_get(void)\n{\n\tAuthmethod *method = NULL;\n\tstruct sshbuf *b;\n\tchar *list;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tfor (method = authmethods; method->name != NULL; method++) {\n\t\tif (authmethod_is_enabled(method)) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", method->name)) != 0)\n\t\t\t\tfatal_fr(r, \"buffer error\");\n\t\t}\n\t}\n\tif ((list = sshbuf_dup_string(b)) == NULL)\n\t\tfatal_f(\"sshbuf_dup_string failed\");\n\tsshbuf_free(b);\n\treturn list;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}