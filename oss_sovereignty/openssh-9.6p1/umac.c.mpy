{
  "module_name": "umac.c",
  "hash_id": "dd09e2368d294acdbf648cc0c8fae556c76daedee7b9b2491644214a6d80326b",
  "original_prompt": "Ingested from openssh-9.6p1/umac.c",
  "human_readable_source": " \n \n\n  \n \n \n\n#ifndef UMAC_OUTPUT_LEN\n#define UMAC_OUTPUT_LEN     8   \n#endif\n\n#if UMAC_OUTPUT_LEN != 4 && UMAC_OUTPUT_LEN != 8 && \\\n    UMAC_OUTPUT_LEN != 12 && UMAC_OUTPUT_LEN != 16\n# error UMAC_OUTPUT_LEN must be defined to 4, 8, 12 or 16\n#endif\n\n \n \n \n \n \n\n \n \n \n\n#include \"includes.h\"\n#include <sys/types.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n\n#include \"xmalloc.h\"\n#include \"umac.h\"\n#include \"misc.h\"\n\n \n \n \n\n \ntypedef u_int8_t\tUINT8;   \ntypedef u_int16_t\tUINT16;  \ntypedef u_int32_t\tUINT32;  \ntypedef u_int64_t\tUINT64;  \ntypedef unsigned int\tUWORD;   \n\n \n \n \n\n#define UMAC_KEY_LEN           16   \n\n \n \n \n\n#if BYTE_ORDER == LITTLE_ENDIAN\n#define __LITTLE_ENDIAN__ 1\n#else\n#define __LITTLE_ENDIAN__ 0\n#endif\n\n \n \n \n \n \n\n\n \n \n \n \n \n\n\n \n \n \n\n#define MUL64(a,b) ((UINT64)((UINT64)(UINT32)(a) * (UINT64)(UINT32)(b)))\n\n \n \n \n\n#if (__LITTLE_ENDIAN__)\n#define LOAD_UINT32_REVERSED(p)\t\tget_u32(p)\n#define STORE_UINT32_REVERSED(p,v)\tput_u32(p,v)\n#else\n#define LOAD_UINT32_REVERSED(p)\t\tget_u32_le(p)\n#define STORE_UINT32_REVERSED(p,v)\tput_u32_le(p,v)\n#endif\n\n#define LOAD_UINT32_LITTLE(p)\t\t(get_u32_le(p))\n#define STORE_UINT32_BIG(p,v)\t\tput_u32(p, v)\n\n \n \n \n \n \n\n \n#define AES_BLOCK_LEN  16\n\n \n#ifdef WITH_OPENSSL\n#include \"openbsd-compat/openssl-compat.h\"\n#ifndef USE_BUILTIN_RIJNDAEL\n# include <openssl/aes.h>\n#endif\ntypedef AES_KEY aes_int_key[1];\n#define aes_encryption(in,out,int_key)                  \\\n  AES_encrypt((u_char *)(in),(u_char *)(out),(AES_KEY *)int_key)\n#define aes_key_setup(key,int_key)                      \\\n  AES_set_encrypt_key((const u_char *)(key),UMAC_KEY_LEN*8,int_key)\n#else\n#include \"rijndael.h\"\n#define AES_ROUNDS ((UMAC_KEY_LEN / 4) + 6)\ntypedef UINT8 aes_int_key[AES_ROUNDS+1][4][4];\t \n#define aes_encryption(in,out,int_key) \\\n  rijndaelEncrypt((u32 *)(int_key), AES_ROUNDS, (u8 *)(in), (u8 *)(out))\n#define aes_key_setup(key,int_key) \\\n  rijndaelKeySetupEnc((u32 *)(int_key), (const unsigned char *)(key), \\\n  UMAC_KEY_LEN*8)\n#endif\n\n \nstatic void kdf(void *bufp, aes_int_key key, UINT8 ndx, int nbytes)\n{\n    UINT8 in_buf[AES_BLOCK_LEN] = {0};\n    UINT8 out_buf[AES_BLOCK_LEN];\n    UINT8 *dst_buf = (UINT8 *)bufp;\n    int i;\n\n     \n    in_buf[AES_BLOCK_LEN-9] = ndx;\n    in_buf[AES_BLOCK_LEN-1] = i = 1;\n\n    while (nbytes >= AES_BLOCK_LEN) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,AES_BLOCK_LEN);\n        in_buf[AES_BLOCK_LEN-1] = ++i;\n        nbytes -= AES_BLOCK_LEN;\n        dst_buf += AES_BLOCK_LEN;\n    }\n    if (nbytes) {\n        aes_encryption(in_buf, out_buf, key);\n        memcpy(dst_buf,out_buf,nbytes);\n    }\n    explicit_bzero(in_buf, sizeof(in_buf));\n    explicit_bzero(out_buf, sizeof(out_buf));\n}\n\n \n\ntypedef struct {\n    UINT8 cache[AES_BLOCK_LEN];   \n    UINT8 nonce[AES_BLOCK_LEN];   \n    aes_int_key prf_key;          \n} pdf_ctx;\n\nstatic void pdf_init(pdf_ctx *pc, aes_int_key prf_key)\n{\n    UINT8 buf[UMAC_KEY_LEN];\n\n    kdf(buf, prf_key, 0, UMAC_KEY_LEN);\n    aes_key_setup(buf, pc->prf_key);\n\n     \n    memset(pc->nonce, 0, sizeof(pc->nonce));\n    aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    explicit_bzero(buf, sizeof(buf));\n}\n\nstatic void pdf_gen_xor(pdf_ctx *pc, const UINT8 nonce[8],\n    UINT8 buf[UMAC_OUTPUT_LEN])\n{\n     \n\n#if (UMAC_OUTPUT_LEN == 4)\n#define LOW_BIT_MASK 3\n#elif (UMAC_OUTPUT_LEN == 8)\n#define LOW_BIT_MASK 1\n#elif (UMAC_OUTPUT_LEN > 8)\n#define LOW_BIT_MASK 0\n#endif\n    union {\n        UINT8 tmp_nonce_lo[4];\n        UINT32 align;\n    } t;\n#if LOW_BIT_MASK != 0\n    int ndx = nonce[7] & LOW_BIT_MASK;\n#endif\n    *(UINT32 *)t.tmp_nonce_lo = ((const UINT32 *)nonce)[1];\n    t.tmp_nonce_lo[3] &= ~LOW_BIT_MASK;  \n\n    if ( (((UINT32 *)t.tmp_nonce_lo)[0] != ((UINT32 *)pc->nonce)[1]) ||\n         (((const UINT32 *)nonce)[0] != ((UINT32 *)pc->nonce)[0]) )\n    {\n        ((UINT32 *)pc->nonce)[0] = ((const UINT32 *)nonce)[0];\n        ((UINT32 *)pc->nonce)[1] = ((UINT32 *)t.tmp_nonce_lo)[0];\n        aes_encryption(pc->nonce, pc->cache, pc->prf_key);\n    }\n\n#if (UMAC_OUTPUT_LEN == 4)\n    *((UINT32 *)buf) ^= ((UINT32 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 8)\n    *((UINT64 *)buf) ^= ((UINT64 *)pc->cache)[ndx];\n#elif (UMAC_OUTPUT_LEN == 12)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT32 *)buf)[2] ^= ((UINT32 *)pc->cache)[2];\n#elif (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)buf)[0] ^= ((UINT64 *)pc->cache)[0];\n    ((UINT64 *)buf)[1] ^= ((UINT64 *)pc->cache)[1];\n#endif\n}\n\n \n \n \n \n \n\n \n\n  \n\n#define STREAMS (UMAC_OUTPUT_LEN / 4)  \n#define L1_KEY_LEN         1024      \n#define L1_KEY_SHIFT         16      \n#define L1_PAD_BOUNDARY      32      \n#define ALLOC_BOUNDARY       16      \n#define HASH_BUF_BYTES       64      \n\ntypedef struct {\n    UINT8  nh_key [L1_KEY_LEN + L1_KEY_SHIFT * (STREAMS - 1)];  \n    UINT8  data   [HASH_BUF_BYTES];     \n    int next_data_empty;     \n    int bytes_hashed;        \n    UINT64 state[STREAMS];                \n} nh_ctx;\n\n\n#if (UMAC_OUTPUT_LEN == 4)\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n \n{\n    UINT64 h;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7;\n\n    h = *((UINT64 *)hp);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n        k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n        h += MUL64((k0 + d0), (k4 + d4));\n        h += MUL64((k1 + d1), (k5 + d5));\n        h += MUL64((k2 + d2), (k6 + d6));\n        h += MUL64((k3 + d3), (k7 + d7));\n\n        d += 8;\n        k += 8;\n    } while (--c);\n  *((UINT64 *)hp) = h;\n}\n\n#elif (UMAC_OUTPUT_LEN == 8)\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n \n{\n  UINT64 h1,h2;\n  UWORD c = dlen / 32;\n  UINT32 *k = (UINT32 *)kp;\n  const UINT32 *d = (const UINT32 *)dp;\n  UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n  UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11;\n\n  h1 = *((UINT64 *)hp);\n  h2 = *((UINT64 *)hp + 1);\n  k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n  do {\n    d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n    d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n    d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n    d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n\n    h1 += MUL64((k0 + d0), (k4 + d4));\n    h2 += MUL64((k4 + d0), (k8 + d4));\n\n    h1 += MUL64((k1 + d1), (k5 + d5));\n    h2 += MUL64((k5 + d1), (k9 + d5));\n\n    h1 += MUL64((k2 + d2), (k6 + d6));\n    h2 += MUL64((k6 + d2), (k10 + d6));\n\n    h1 += MUL64((k3 + d3), (k7 + d7));\n    h2 += MUL64((k7 + d3), (k11 + d7));\n\n    k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n\n    d += 8;\n    k += 8;\n  } while (--c);\n  ((UINT64 *)hp)[0] = h1;\n  ((UINT64 *)hp)[1] = h2;\n}\n\n#elif (UMAC_OUTPUT_LEN == 12)\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n \n{\n    UINT64 h1,h2,h3;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n}\n\n#elif (UMAC_OUTPUT_LEN == 16)\n\nstatic void nh_aux(void *kp, const void *dp, void *hp, UINT32 dlen)\n \n{\n    UINT64 h1,h2,h3,h4;\n    UWORD c = dlen / 32;\n    UINT32 *k = (UINT32 *)kp;\n    const UINT32 *d = (const UINT32 *)dp;\n    UINT32 d0,d1,d2,d3,d4,d5,d6,d7;\n    UINT32 k0,k1,k2,k3,k4,k5,k6,k7,\n        k8,k9,k10,k11,k12,k13,k14,k15,\n        k16,k17,k18,k19;\n\n    h1 = *((UINT64 *)hp);\n    h2 = *((UINT64 *)hp + 1);\n    h3 = *((UINT64 *)hp + 2);\n    h4 = *((UINT64 *)hp + 3);\n    k0 = *(k+0); k1 = *(k+1); k2 = *(k+2); k3 = *(k+3);\n    k4 = *(k+4); k5 = *(k+5); k6 = *(k+6); k7 = *(k+7);\n    do {\n        d0 = LOAD_UINT32_LITTLE(d+0); d1 = LOAD_UINT32_LITTLE(d+1);\n        d2 = LOAD_UINT32_LITTLE(d+2); d3 = LOAD_UINT32_LITTLE(d+3);\n        d4 = LOAD_UINT32_LITTLE(d+4); d5 = LOAD_UINT32_LITTLE(d+5);\n        d6 = LOAD_UINT32_LITTLE(d+6); d7 = LOAD_UINT32_LITTLE(d+7);\n        k8 = *(k+8); k9 = *(k+9); k10 = *(k+10); k11 = *(k+11);\n        k12 = *(k+12); k13 = *(k+13); k14 = *(k+14); k15 = *(k+15);\n        k16 = *(k+16); k17 = *(k+17); k18 = *(k+18); k19 = *(k+19);\n\n        h1 += MUL64((k0 + d0), (k4 + d4));\n        h2 += MUL64((k4 + d0), (k8 + d4));\n        h3 += MUL64((k8 + d0), (k12 + d4));\n        h4 += MUL64((k12 + d0), (k16 + d4));\n\n        h1 += MUL64((k1 + d1), (k5 + d5));\n        h2 += MUL64((k5 + d1), (k9 + d5));\n        h3 += MUL64((k9 + d1), (k13 + d5));\n        h4 += MUL64((k13 + d1), (k17 + d5));\n\n        h1 += MUL64((k2 + d2), (k6 + d6));\n        h2 += MUL64((k6 + d2), (k10 + d6));\n        h3 += MUL64((k10 + d2), (k14 + d6));\n        h4 += MUL64((k14 + d2), (k18 + d6));\n\n        h1 += MUL64((k3 + d3), (k7 + d7));\n        h2 += MUL64((k7 + d3), (k11 + d7));\n        h3 += MUL64((k11 + d3), (k15 + d7));\n        h4 += MUL64((k15 + d3), (k19 + d7));\n\n        k0 = k8; k1 = k9; k2 = k10; k3 = k11;\n        k4 = k12; k5 = k13; k6 = k14; k7 = k15;\n        k8 = k16; k9 = k17; k10 = k18; k11 = k19;\n\n        d += 8;\n        k += 8;\n    } while (--c);\n    ((UINT64 *)hp)[0] = h1;\n    ((UINT64 *)hp)[1] = h2;\n    ((UINT64 *)hp)[2] = h3;\n    ((UINT64 *)hp)[3] = h4;\n}\n\n \n#endif   \n \n\n\n \n\nstatic void nh_transform(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n \n{\n    UINT8 *key;\n\n    key = hc->nh_key + hc->bytes_hashed;\n    nh_aux(key, buf, hc->state, nbytes);\n}\n\n \n\n#if (__LITTLE_ENDIAN__)\nstatic void endian_convert(void *buf, UWORD bpw, UINT32 num_bytes)\n \n \n{\n    UWORD iters = num_bytes / bpw;\n    if (bpw == 4) {\n        UINT32 *p = (UINT32 *)buf;\n        do {\n            *p = LOAD_UINT32_REVERSED(p);\n            p++;\n        } while (--iters);\n    } else if (bpw == 8) {\n        UINT32 *p = (UINT32 *)buf;\n        UINT32 t;\n        do {\n            t = LOAD_UINT32_REVERSED(p+1);\n            p[1] = LOAD_UINT32_REVERSED(p);\n            p[0] = t;\n            p += 2;\n        } while (--iters);\n    }\n}\n#define endian_convert_if_le(x,y,z) endian_convert((x),(y),(z))\n#else\n#define endian_convert_if_le(x,y,z) do{}while(0)   \n#endif\n\n \n\nstatic void nh_reset(nh_ctx *hc)\n \n{\n    hc->bytes_hashed = 0;\n    hc->next_data_empty = 0;\n    hc->state[0] = 0;\n#if (UMAC_OUTPUT_LEN >= 8)\n    hc->state[1] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    hc->state[2] = 0;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    hc->state[3] = 0;\n#endif\n\n}\n\n \n\nstatic void nh_init(nh_ctx *hc, aes_int_key prf_key)\n \n{\n    kdf(hc->nh_key, prf_key, 1, sizeof(hc->nh_key));\n    endian_convert_if_le(hc->nh_key, 4, sizeof(hc->nh_key));\n    nh_reset(hc);\n}\n\n \n\nstatic void nh_update(nh_ctx *hc, const UINT8 *buf, UINT32 nbytes)\n \n \n{\n    UINT32 i,j;\n\n    j = hc->next_data_empty;\n    if ((j + nbytes) >= HASH_BUF_BYTES) {\n        if (j) {\n            i = HASH_BUF_BYTES - j;\n            memcpy(hc->data+j, buf, i);\n            nh_transform(hc,hc->data,HASH_BUF_BYTES);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += HASH_BUF_BYTES;\n        }\n        if (nbytes >= HASH_BUF_BYTES) {\n            i = nbytes & ~(HASH_BUF_BYTES - 1);\n            nh_transform(hc, buf, i);\n            nbytes -= i;\n            buf += i;\n            hc->bytes_hashed += i;\n        }\n        j = 0;\n    }\n    memcpy(hc->data + j, buf, nbytes);\n    hc->next_data_empty = j + nbytes;\n}\n\n \n\nstatic void zero_pad(UINT8 *p, int nbytes)\n{\n \n    if (nbytes >= (int)sizeof(UWORD)) {\n        while ((ptrdiff_t)p % sizeof(UWORD)) {\n            *p = 0;\n            nbytes--;\n            p++;\n        }\n        while (nbytes >= (int)sizeof(UWORD)) {\n            *(UWORD *)p = 0;\n            nbytes -= sizeof(UWORD);\n            p += sizeof(UWORD);\n        }\n    }\n    while (nbytes) {\n        *p = 0;\n        nbytes--;\n        p++;\n    }\n}\n\n \n\nstatic void nh_final(nh_ctx *hc, UINT8 *result)\n \n{\n    int nh_len, nbits;\n\n    if (hc->next_data_empty != 0) {\n        nh_len = ((hc->next_data_empty + (L1_PAD_BOUNDARY - 1)) &\n                                                ~(L1_PAD_BOUNDARY - 1));\n        zero_pad(hc->data + hc->next_data_empty,\n                                          nh_len - hc->next_data_empty);\n        nh_transform(hc, hc->data, nh_len);\n        hc->bytes_hashed += hc->next_data_empty;\n    } else if (hc->bytes_hashed == 0) {\n\tnh_len = L1_PAD_BOUNDARY;\n        zero_pad(hc->data, L1_PAD_BOUNDARY);\n        nh_transform(hc, hc->data, nh_len);\n    }\n\n    nbits = (hc->bytes_hashed << 3);\n    ((UINT64 *)result)[0] = ((UINT64 *)hc->state)[0] + nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = ((UINT64 *)hc->state)[1] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = ((UINT64 *)hc->state)[2] + nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = ((UINT64 *)hc->state)[3] + nbits;\n#endif\n    nh_reset(hc);\n}\n\n \n\nstatic void nh(nh_ctx *hc, const UINT8 *buf, UINT32 padded_len,\n               UINT32 unpadded_len, UINT8 *result)\n \n{\n    UINT32 nbits;\n\n     \n    nbits = (unpadded_len << 3);\n\n    ((UINT64 *)result)[0] = nbits;\n#if (UMAC_OUTPUT_LEN >= 8)\n    ((UINT64 *)result)[1] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    ((UINT64 *)result)[2] = nbits;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    ((UINT64 *)result)[3] = nbits;\n#endif\n\n    nh_aux(hc->nh_key, buf, result, padded_len);\n}\n\n \n \n \n \n \n\n \n\n \n \n \n\n \n \n \n\n \n#define p36    ((UINT64)0x0000000FFFFFFFFBull)               \n#define p64    ((UINT64)0xFFFFFFFFFFFFFFC5ull)               \n#define m36    ((UINT64)0x0000000FFFFFFFFFull)   \n\n\n \n\ntypedef struct uhash_ctx {\n    nh_ctx hash;                           \n    UINT64 poly_key_8[STREAMS];            \n    UINT64 poly_accum[STREAMS];            \n    UINT64 ip_keys[STREAMS*4];             \n    UINT32 ip_trans[STREAMS];              \n    UINT32 msg_len;                        \n                                           \n} uhash_ctx;\ntypedef struct uhash_ctx *uhash_ctx_t;\n\n \n\n\n \n\nstatic UINT64 poly64(UINT64 cur, UINT64 key, UINT64 data)\n{\n    UINT32 key_hi = (UINT32)(key >> 32),\n           key_lo = (UINT32)key,\n           cur_hi = (UINT32)(cur >> 32),\n           cur_lo = (UINT32)cur,\n           x_lo,\n           x_hi;\n    UINT64 X,T,res;\n\n    X =  MUL64(key_hi, cur_lo) + MUL64(cur_hi, key_lo);\n    x_lo = (UINT32)X;\n    x_hi = (UINT32)(X >> 32);\n\n    res = (MUL64(key_hi, cur_hi) + x_hi) * 59 + MUL64(key_lo, cur_lo);\n\n    T = ((UINT64)x_lo << 32);\n    res += T;\n    if (res < T)\n        res += 59;\n\n    res += data;\n    if (res < data)\n        res += 59;\n\n    return res;\n}\n\n\n \nstatic void poly_hash(uhash_ctx_t hc, UINT32 data_in[])\n{\n    int i;\n    UINT64 *data=(UINT64*)data_in;\n\n    for (i = 0; i < STREAMS; i++) {\n        if ((UINT32)(data[i] >> 32) == 0xfffffffful) {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], p64 - 1);\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], (data[i] - 59));\n        } else {\n            hc->poly_accum[i] = poly64(hc->poly_accum[i],\n                                       hc->poly_key_8[i], data[i]);\n        }\n    }\n}\n\n\n \n\n\n \n\nstatic UINT64 ip_aux(UINT64 t, UINT64 *ipkp, UINT64 data)\n{\n    t = t + ipkp[0] * (UINT64)(UINT16)(data >> 48);\n    t = t + ipkp[1] * (UINT64)(UINT16)(data >> 32);\n    t = t + ipkp[2] * (UINT64)(UINT16)(data >> 16);\n    t = t + ipkp[3] * (UINT64)(UINT16)(data);\n\n    return t;\n}\n\nstatic UINT32 ip_reduce_p36(UINT64 t)\n{\n \n    UINT64 ret;\n\n    ret = (t & m36) + 5 * (t >> 36);\n    if (ret >= p36)\n        ret -= p36;\n\n     \n    return (UINT32)(ret);\n}\n\n\n \nstatic void ip_short(uhash_ctx_t ahc, UINT8 *nh_res, u_char *res)\n{\n    UINT64 t;\n    UINT64 *nhp = (UINT64 *)nh_res;\n\n    t  = ip_aux(0,ahc->ip_keys, nhp[0]);\n    STORE_UINT32_BIG((UINT32 *)res+0, ip_reduce_p36(t) ^ ahc->ip_trans[0]);\n#if (UMAC_OUTPUT_LEN >= 8)\n    t  = ip_aux(0,ahc->ip_keys+4, nhp[1]);\n    STORE_UINT32_BIG((UINT32 *)res+1, ip_reduce_p36(t) ^ ahc->ip_trans[1]);\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    t  = ip_aux(0,ahc->ip_keys+8, nhp[2]);\n    STORE_UINT32_BIG((UINT32 *)res+2, ip_reduce_p36(t) ^ ahc->ip_trans[2]);\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    t  = ip_aux(0,ahc->ip_keys+12, nhp[3]);\n    STORE_UINT32_BIG((UINT32 *)res+3, ip_reduce_p36(t) ^ ahc->ip_trans[3]);\n#endif\n}\n\n \nstatic void ip_long(uhash_ctx_t ahc, u_char *res)\n{\n    int i;\n    UINT64 t;\n\n    for (i = 0; i < STREAMS; i++) {\n         \n        if (ahc->poly_accum[i] >= p64)\n            ahc->poly_accum[i] -= p64;\n        t  = ip_aux(0,ahc->ip_keys+(i*4), ahc->poly_accum[i]);\n        STORE_UINT32_BIG((UINT32 *)res+i,\n                         ip_reduce_p36(t) ^ ahc->ip_trans[i]);\n    }\n}\n\n\n \n\n \n\n \nstatic int uhash_reset(uhash_ctx_t pc)\n{\n    nh_reset(&pc->hash);\n    pc->msg_len = 0;\n    pc->poly_accum[0] = 1;\n#if (UMAC_OUTPUT_LEN >= 8)\n    pc->poly_accum[1] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN >= 12)\n    pc->poly_accum[2] = 1;\n#endif\n#if (UMAC_OUTPUT_LEN == 16)\n    pc->poly_accum[3] = 1;\n#endif\n    return 1;\n}\n\n \n\n \nstatic void uhash_init(uhash_ctx_t ahc, aes_int_key prf_key)\n{\n    int i;\n    UINT8 buf[(8*STREAMS+4)*sizeof(UINT64)];\n\n     \n    memset(ahc, 0, sizeof(uhash_ctx));\n\n     \n    nh_init(&ahc->hash, prf_key);\n\n     \n    kdf(buf, prf_key, 2, sizeof(buf));     \n    for (i = 0; i < STREAMS; i++) {\n         \n        memcpy(ahc->poly_key_8+i, buf+24*i, 8);\n        endian_convert_if_le(ahc->poly_key_8+i, 8, 8);\n         \n        ahc->poly_key_8[i] &= ((UINT64)0x01ffffffu << 32) + 0x01ffffffu;\n        ahc->poly_accum[i] = 1;   \n    }\n\n     \n    kdf(buf, prf_key, 3, sizeof(buf));  \n    for (i = 0; i < STREAMS; i++)\n          memcpy(ahc->ip_keys+4*i, buf+(8*i+4)*sizeof(UINT64),\n                                                 4*sizeof(UINT64));\n    endian_convert_if_le(ahc->ip_keys, sizeof(UINT64),\n                                                  sizeof(ahc->ip_keys));\n    for (i = 0; i < STREAMS*4; i++)\n        ahc->ip_keys[i] %= p36;   \n\n     \n     \n    kdf(ahc->ip_trans, prf_key, 4, STREAMS * sizeof(UINT32));\n    endian_convert_if_le(ahc->ip_trans, sizeof(UINT32),\n                         STREAMS * sizeof(UINT32));\n    explicit_bzero(buf, sizeof(buf));\n}\n\n \n\n#if 0\nstatic uhash_ctx_t uhash_alloc(u_char key[])\n{\n \n    uhash_ctx_t ctx;\n    u_char bytes_to_add;\n    aes_int_key prf_key;\n\n    ctx = (uhash_ctx_t)malloc(sizeof(uhash_ctx)+ALLOC_BOUNDARY);\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_add = ALLOC_BOUNDARY -\n                              ((ptrdiff_t)ctx & (ALLOC_BOUNDARY -1));\n            ctx = (uhash_ctx_t)((u_char *)ctx + bytes_to_add);\n            *((u_char *)ctx - 1) = bytes_to_add;\n        }\n        aes_key_setup(key,prf_key);\n        uhash_init(ctx, prf_key);\n    }\n    return (ctx);\n}\n#endif\n\n \n\n#if 0\nstatic int uhash_free(uhash_ctx_t ctx)\n{\n \n    u_char bytes_to_sub;\n\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_sub = *((u_char *)ctx - 1);\n            ctx = (uhash_ctx_t)((u_char *)ctx - bytes_to_sub);\n        }\n        free(ctx);\n    }\n    return (1);\n}\n#endif\n \n\nstatic int uhash_update(uhash_ctx_t ctx, const u_char *input, long len)\n \n{\n    UWORD bytes_hashed, bytes_remaining;\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len + len <= L1_KEY_LEN) {\n        nh_update(&ctx->hash, (const UINT8 *)input, len);\n        ctx->msg_len += len;\n    } else {\n\n         bytes_hashed = ctx->msg_len % L1_KEY_LEN;\n         if (ctx->msg_len == L1_KEY_LEN)\n             bytes_hashed = L1_KEY_LEN;\n\n         if (bytes_hashed + len >= L1_KEY_LEN) {\n\n              \n              \n              \n             if (bytes_hashed) {\n                 bytes_remaining = (L1_KEY_LEN - bytes_hashed);\n                 nh_update(&ctx->hash, (const UINT8 *)input, bytes_remaining);\n                 nh_final(&ctx->hash, nh_result);\n                 ctx->msg_len += bytes_remaining;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n                 len -= bytes_remaining;\n                 input += bytes_remaining;\n             }\n\n              \n             while (len >= L1_KEY_LEN) {\n                 nh(&ctx->hash, (const UINT8 *)input, L1_KEY_LEN,\n                                   L1_KEY_LEN, nh_result);\n                 ctx->msg_len += L1_KEY_LEN;\n                 len -= L1_KEY_LEN;\n                 input += L1_KEY_LEN;\n                 poly_hash(ctx,(UINT32 *)nh_result);\n             }\n         }\n\n          \n         if (len) {\n             nh_update(&ctx->hash, (const UINT8 *)input, len);\n             ctx->msg_len += len;\n         }\n     }\n\n    return (1);\n}\n\n \n\nstatic int uhash_final(uhash_ctx_t ctx, u_char *res)\n \n{\n    UINT64 result_buf[STREAMS];\n    UINT8 *nh_result = (UINT8 *)&result_buf;\n\n    if (ctx->msg_len > L1_KEY_LEN) {\n        if (ctx->msg_len % L1_KEY_LEN) {\n            nh_final(&ctx->hash, nh_result);\n            poly_hash(ctx,(UINT32 *)nh_result);\n        }\n        ip_long(ctx, res);\n    } else {\n        nh_final(&ctx->hash, nh_result);\n        ip_short(ctx,nh_result, res);\n    }\n    uhash_reset(ctx);\n    return (1);\n}\n\n \n\n#if 0\nstatic int uhash(uhash_ctx_t ahc, u_char *msg, long len, u_char *res)\n \n \n{\n    UINT8 nh_result[STREAMS*sizeof(UINT64)];\n    UINT32 nh_len;\n    int extra_zeroes_needed;\n\n     \n    if (len <= L1_KEY_LEN) {\n\tif (len == 0)                   \n\t\tnh_len = L1_PAD_BOUNDARY;   \n\telse\n\t\tnh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n        extra_zeroes_needed = nh_len - len;\n        zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n        nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n        ip_short(ahc,nh_result, res);\n    } else {\n         \n        do {\n            nh(&ahc->hash, (UINT8 *)msg, L1_KEY_LEN, L1_KEY_LEN, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n            len -= L1_KEY_LEN;\n            msg += L1_KEY_LEN;\n        } while (len >= L1_KEY_LEN);\n        if (len) {\n            nh_len = ((len + (L1_PAD_BOUNDARY - 1)) & ~(L1_PAD_BOUNDARY - 1));\n            extra_zeroes_needed = nh_len - len;\n            zero_pad((UINT8 *)msg + len, extra_zeroes_needed);\n            nh(&ahc->hash, (UINT8 *)msg, nh_len, len, nh_result);\n            poly_hash(ahc,(UINT32 *)nh_result);\n        }\n\n        ip_long(ahc, res);\n    }\n\n    uhash_reset(ahc);\n    return 1;\n}\n#endif\n\n \n \n \n \n \n\n \nstruct umac_ctx {\n    uhash_ctx hash;           \n    pdf_ctx pdf;              \n    void *free_ptr;           \n} umac_ctx;\n\n \n\n#if 0\nint umac_reset(struct umac_ctx *ctx)\n \n{\n    uhash_reset(&ctx->hash);\n    return (1);\n}\n#endif\n\n \n\nint umac_delete(struct umac_ctx *ctx)\n \n{\n    if (ctx) {\n        if (ALLOC_BOUNDARY)\n            ctx = (struct umac_ctx *)ctx->free_ptr;\n        freezero(ctx, sizeof(*ctx) + ALLOC_BOUNDARY);\n    }\n    return (1);\n}\n\n \n\nstruct umac_ctx *umac_new(const u_char key[])\n \n{\n    struct umac_ctx *ctx, *octx;\n    size_t bytes_to_add;\n    aes_int_key prf_key;\n\n    octx = ctx = xcalloc(1, sizeof(*ctx) + ALLOC_BOUNDARY);\n    if (ctx) {\n        if (ALLOC_BOUNDARY) {\n            bytes_to_add = ALLOC_BOUNDARY -\n                              ((ptrdiff_t)ctx & (ALLOC_BOUNDARY - 1));\n            ctx = (struct umac_ctx *)((u_char *)ctx + bytes_to_add);\n        }\n        ctx->free_ptr = octx;\n        aes_key_setup(key, prf_key);\n        pdf_init(&ctx->pdf, prf_key);\n        uhash_init(&ctx->hash, prf_key);\n        explicit_bzero(prf_key, sizeof(prf_key));\n    }\n\n    return (ctx);\n}\n\n \n\nint umac_final(struct umac_ctx *ctx, u_char tag[], const u_char nonce[8])\n \n{\n    uhash_final(&ctx->hash, (u_char *)tag);\n    pdf_gen_xor(&ctx->pdf, (const UINT8 *)nonce, (UINT8 *)tag);\n\n    return (1);\n}\n\n \n\nint umac_update(struct umac_ctx *ctx, const u_char *input, long len)\n \n \n \n{\n    uhash_update(&ctx->hash, input, len);\n    return (1);\n}\n\n \n\n#if 0\nint umac(struct umac_ctx *ctx, u_char *input,\n         long len, u_char tag[],\n         u_char nonce[8])\n \n{\n    uhash(&ctx->hash, input, len, (u_char *)tag);\n    pdf_gen_xor(&ctx->pdf, (UINT8 *)nonce, (UINT8 *)tag);\n\n    return (1);\n}\n#endif\n\n \n \n \n \n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}