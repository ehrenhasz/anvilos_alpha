{
  "module_name": "mac.c",
  "hash_id": "07a2e2a29d92d95a55d86cb8d4fb93ce6fb737424eefa1e15173cc64adbd7349",
  "original_prompt": "Ingested from openssh-9.6p1/mac.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"digest.h\"\n#include \"hmac.h\"\n#include \"umac.h\"\n#include \"mac.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#define SSH_DIGEST\t1\t \n#define SSH_UMAC\t2\t \n#define SSH_UMAC128\t3\n\nstruct macalg {\n\tchar\t\t*name;\n\tint\t\ttype;\n\tint\t\talg;\n\tint\t\ttruncatebits;\t \n\tint\t\tkey_len;\t \n\tint\t\tlen;\t\t \n\tint\t\tetm;\t\t \n};\n\nstatic const struct macalg macs[] = {\n\t \n\t{ \"hmac-sha1\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 0 },\n\t{ \"hmac-sha1-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 0 },\n\t{ \"hmac-sha2-256\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 0 },\n\t{ \"hmac-sha2-512\",\t\t\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 0 },\n\t{ \"hmac-md5\",\t\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 0 },\n\t{ \"hmac-md5-96\",\t\t\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 0 },\n\t{ \"umac-64@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 0 },\n\t{ \"umac-128@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 0 },\n\n\t \n\t{ \"hmac-sha1-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_SHA1, 0, 0, 0, 1 },\n\t{ \"hmac-sha1-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA1, 96, 0, 0, 1 },\n\t{ \"hmac-sha2-256-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA256, 0, 0, 0, 1 },\n\t{ \"hmac-sha2-512-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_SHA512, 0, 0, 0, 1 },\n\t{ \"hmac-md5-etm@openssh.com\",\t\tSSH_DIGEST, SSH_DIGEST_MD5, 0, 0, 0, 1 },\n\t{ \"hmac-md5-96-etm@openssh.com\",\tSSH_DIGEST, SSH_DIGEST_MD5, 96, 0, 0, 1 },\n\t{ \"umac-64-etm@openssh.com\",\t\tSSH_UMAC, 0, 0, 128, 64, 1 },\n\t{ \"umac-128-etm@openssh.com\",\t\tSSH_UMAC128, 0, 0, 128, 128, 1 },\n\n\t{ NULL,\t\t\t\t\t0, 0, 0, 0, 0, 0 }\n};\n\n \nchar *\nmac_alg_list(char sep)\n{\n\tchar *ret = NULL, *tmp;\n\tsize_t nlen, rlen = 0;\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (ret != NULL)\n\t\t\tret[rlen++] = sep;\n\t\tnlen = strlen(m->name);\n\t\tif ((tmp = realloc(ret, rlen + nlen + 2)) == NULL) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = tmp;\n\t\tmemcpy(ret + rlen, m->name, nlen + 1);\n\t\trlen += nlen;\n\t}\n\treturn ret;\n}\n\nstatic int\nmac_setup_by_alg(struct sshmac *mac, const struct macalg *macalg)\n{\n\tmac->type = macalg->type;\n\tif (mac->type == SSH_DIGEST) {\n\t\tif ((mac->hmac_ctx = ssh_hmac_start(macalg->alg)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tmac->key_len = mac->mac_len = ssh_hmac_bytes(macalg->alg);\n\t} else {\n\t\tmac->mac_len = macalg->len / 8;\n\t\tmac->key_len = macalg->key_len / 8;\n\t\tmac->umac_ctx = NULL;\n\t}\n\tif (macalg->truncatebits != 0)\n\t\tmac->mac_len = macalg->truncatebits / 8;\n\tmac->etm = macalg->etm;\n\treturn 0;\n}\n\nint\nmac_setup(struct sshmac *mac, char *name)\n{\n\tconst struct macalg *m;\n\n\tfor (m = macs; m->name != NULL; m++) {\n\t\tif (strcmp(name, m->name) != 0)\n\t\t\tcontinue;\n\t\tif (mac != NULL)\n\t\t\treturn mac_setup_by_alg(mac, m);\n\t\treturn 0;\n\t}\n\treturn SSH_ERR_INVALID_ARGUMENT;\n}\n\nint\nmac_init(struct sshmac *mac)\n{\n\tif (mac->key == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tswitch (mac->type) {\n\tcase SSH_DIGEST:\n\t\tif (mac->hmac_ctx == NULL ||\n\t\t    ssh_hmac_init(mac->hmac_ctx, mac->key, mac->key_len) < 0)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\treturn 0;\n\tcase SSH_UMAC:\n\t\tif ((mac->umac_ctx = umac_new(mac->key)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\tcase SSH_UMAC128:\n\t\tif ((mac->umac_ctx = umac128_new(mac->key)) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\treturn 0;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n}\n\nint\nmac_compute(struct sshmac *mac, u_int32_t seqno,\n    const u_char *data, int datalen,\n    u_char *digest, size_t dlen)\n{\n\tstatic union {\n\t\tu_char m[SSH_DIGEST_MAX_LENGTH];\n\t\tu_int64_t for_align;\n\t} u;\n\tu_char b[4];\n\tu_char nonce[8];\n\n\tif (mac->mac_len > sizeof(u))\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tswitch (mac->type) {\n\tcase SSH_DIGEST:\n\t\tput_u32(b, seqno);\n\t\t \n\t\tif (ssh_hmac_init(mac->hmac_ctx, NULL, 0) < 0 ||\n\t\t    ssh_hmac_update(mac->hmac_ctx, b, sizeof(b)) < 0 ||\n\t\t    ssh_hmac_update(mac->hmac_ctx, data, datalen) < 0 ||\n\t\t    ssh_hmac_final(mac->hmac_ctx, u.m, sizeof(u.m)) < 0)\n\t\t\treturn SSH_ERR_LIBCRYPTO_ERROR;\n\t\tbreak;\n\tcase SSH_UMAC:\n\t\tPOKE_U64(nonce, seqno);\n\t\tumac_update(mac->umac_ctx, data, datalen);\n\t\tumac_final(mac->umac_ctx, u.m, nonce);\n\t\tbreak;\n\tcase SSH_UMAC128:\n\t\tput_u64(nonce, seqno);\n\t\tumac128_update(mac->umac_ctx, data, datalen);\n\t\tumac128_final(mac->umac_ctx, u.m, nonce);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (digest != NULL) {\n\t\tif (dlen > mac->mac_len)\n\t\t\tdlen = mac->mac_len;\n\t\tmemcpy(digest, u.m, dlen);\n\t}\n\treturn 0;\n}\n\nint\nmac_check(struct sshmac *mac, u_int32_t seqno,\n    const u_char *data, size_t dlen,\n    const u_char *theirmac, size_t mlen)\n{\n\tu_char ourmac[SSH_DIGEST_MAX_LENGTH];\n\tint r;\n\n\tif (mac->mac_len > mlen)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tif ((r = mac_compute(mac, seqno, data, dlen,\n\t    ourmac, sizeof(ourmac))) != 0)\n\t\treturn r;\n\tif (timingsafe_bcmp(ourmac, theirmac, mac->mac_len) != 0)\n\t\treturn SSH_ERR_MAC_INVALID;\n\treturn 0;\n}\n\nvoid\nmac_clear(struct sshmac *mac)\n{\n\tif (mac->type == SSH_UMAC) {\n\t\tif (mac->umac_ctx != NULL)\n\t\t\tumac_delete(mac->umac_ctx);\n\t} else if (mac->type == SSH_UMAC128) {\n\t\tif (mac->umac_ctx != NULL)\n\t\t\tumac128_delete(mac->umac_ctx);\n\t} else if (mac->hmac_ctx != NULL)\n\t\tssh_hmac_free(mac->hmac_ctx);\n\tmac->hmac_ctx = NULL;\n\tmac->umac_ctx = NULL;\n}\n\n \n#define\tMAC_SEP\t\",\"\nint\nmac_valid(const char *names)\n{\n\tchar *maclist, *cp, *p;\n\n\tif (names == NULL || strcmp(names, \"\") == 0)\n\t\treturn 0;\n\tif ((maclist = cp = strdup(names)) == NULL)\n\t\treturn 0;\n\tfor ((p = strsep(&cp, MAC_SEP)); p && *p != '\\0';\n\t    (p = strsep(&cp, MAC_SEP))) {\n\t\tif (mac_setup(NULL, p) < 0) {\n\t\t\tfree(maclist);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfree(maclist);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}