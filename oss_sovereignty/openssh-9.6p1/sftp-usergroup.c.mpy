{
  "module_name": "sftp-usergroup.c",
  "hash_id": "375e016c0130c605316d77e9f529a8ce306309493faa5c7c22e6c67756721cfa",
  "original_prompt": "Ingested from openssh-9.6p1/sftp-usergroup.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <openbsd-compat/sys-tree.h>\n\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"log.h\"\n#include \"xmalloc.h\"\n\n#include \"sftp-common.h\"\n#include \"sftp-client.h\"\n#include \"sftp-usergroup.h\"\n\n \nstruct idname {\n        u_int id;\n\tchar *name;\n        RB_ENTRY(idname) entry;\n\t \n};\nstatic int\nidname_cmp(struct idname *a, struct idname *b)\n{\n\tif (a->id == b->id)\n\t\treturn 0;\n\treturn a->id > b->id ? 1 : -1;\n}\nRB_HEAD(idname_tree, idname);\nRB_GENERATE_STATIC(idname_tree, idname, entry, idname_cmp)\n\nstatic struct idname_tree user_idname = RB_INITIALIZER(&user_idname);\nstatic struct idname_tree group_idname = RB_INITIALIZER(&group_idname);\n\nstatic void\nidname_free(struct idname *idname)\n{\n\tif (idname == NULL)\n\t\treturn;\n\tfree(idname->name);\n\tfree(idname);\n}\n\nstatic void\nidname_enter(struct idname_tree *tree, u_int id, const char *name)\n{\n\tstruct idname *idname;\n\n\tif ((idname = xcalloc(1, sizeof(*idname))) == NULL)\n\t\tfatal_f(\"alloc\");\n\tidname->id = id;\n\tidname->name = xstrdup(name);\n\tif (RB_INSERT(idname_tree, tree, idname) != NULL)\n\t\tidname_free(idname);\n}\n\nstatic const char *\nidname_lookup(struct idname_tree *tree, u_int id)\n{\n\tstruct idname idname, *found;\n\n\tmemset(&idname, 0, sizeof(idname));\n\tidname.id = id;\n\tif ((found = RB_FIND(idname_tree, tree, &idname)) != NULL)\n\t\treturn found->name;\n\treturn NULL;\n}\n\nstatic void\nfreenames(char **names, u_int nnames)\n{\n\tu_int i;\n\n\tif (names == NULL)\n\t\treturn;\n\tfor (i = 0; i < nnames; i++)\n\t\tfree(names[i]);\n\tfree(names);\n}\n\nstatic void\nlookup_and_record(struct sftp_conn *conn,\n    u_int *uids, u_int nuids, u_int *gids, u_int ngids)\n{\n\tint r;\n\tu_int i;\n\tchar **usernames = NULL, **groupnames = NULL;\n\n\tif ((r = sftp_get_users_groups_by_id(conn, uids, nuids, gids, ngids,\n\t    &usernames, &groupnames)) != 0) {\n\t\tdebug_fr(r, \"sftp_get_users_groups_by_id\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < nuids; i++) {\n\t\tif (usernames[i] == NULL) {\n\t\t\tdebug3_f(\"uid %u not resolved\", uids[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3_f(\"record uid %u => \\\"%s\\\"\", uids[i], usernames[i]);\n\t\tidname_enter(&user_idname, uids[i], usernames[i]);\n\t}\n\tfor (i = 0; i < ngids; i++) {\n\t\tif (groupnames[i] == NULL) {\n\t\t\tdebug3_f(\"gid %u not resolved\", gids[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3_f(\"record gid %u => \\\"%s\\\"\", gids[i], groupnames[i]);\n\t\tidname_enter(&group_idname, gids[i], groupnames[i]);\n\t}\n\tfreenames(usernames, nuids);\n\tfreenames(groupnames, ngids);\n}\n\nstatic int\nhas_id(u_int id, u_int *ids, u_int nids)\n{\n\tu_int i;\n\n\tif (nids == 0)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < nids; i++) {\n\t\tif (ids[i] == id)\n\t\t\tbreak;\n\t}\n\treturn i < nids;\n}\n\nstatic void\ncollect_ids_from_glob(glob_t *g, int user, u_int **idsp, u_int *nidsp)\n{\n\tu_int id, i, n = 0, *ids = NULL;\n\n\tfor (i = 0; g->gl_pathv[i] != NULL; i++) {\n\t\tif (user) {\n\t\t\tif (ruser_name(g->gl_statv[i]->st_uid) != NULL)\n\t\t\t\tcontinue;  \n\t\t\tid = (u_int)g->gl_statv[i]->st_uid;\n\t\t} else {\n\t\t\tif (rgroup_name(g->gl_statv[i]->st_gid) != NULL)\n\t\t\t\tcontinue;  \n\t\t\tid = (u_int)g->gl_statv[i]->st_gid;\n\t\t}\n\t\tif (has_id(id, ids, n))\n\t\t\tcontinue;\n\t\tids = xrecallocarray(ids, n, n + 1, sizeof(*ids));\n\t\tids[n++] = id;\n\t}\n\t*idsp = ids;\n\t*nidsp = n;\n}\n\nvoid\nget_remote_user_groups_from_glob(struct sftp_conn *conn, glob_t *g)\n{\n\tu_int *uids = NULL, nuids = 0, *gids = NULL, ngids = 0;\n\n\tif (!sftp_can_get_users_groups_by_id(conn))\n\t\treturn;\n\n\tcollect_ids_from_glob(g, 1, &uids, &nuids);\n\tcollect_ids_from_glob(g, 0, &gids, &ngids);\n\tlookup_and_record(conn, uids, nuids, gids, ngids);\n\tfree(uids);\n\tfree(gids);\n}\n\nstatic void\ncollect_ids_from_dirents(SFTP_DIRENT **d, int user, u_int **idsp, u_int *nidsp)\n{\n\tu_int id, i, n = 0, *ids = NULL;\n\n\tfor (i = 0; d[i] != NULL; i++) {\n\t\tif (user) {\n\t\t\tif (ruser_name((uid_t)(d[i]->a.uid)) != NULL)\n\t\t\t\tcontinue;  \n\t\t\tid = d[i]->a.uid;\n\t\t} else {\n\t\t\tif (rgroup_name((gid_t)(d[i]->a.gid)) != NULL)\n\t\t\t\tcontinue;  \n\t\t\tid = d[i]->a.gid;\n\t\t}\n\t\tif (has_id(id, ids, n))\n\t\t\tcontinue;\n\t\tids = xrecallocarray(ids, n, n + 1, sizeof(*ids));\n\t\tids[n++] = id;\n\t}\n\t*idsp = ids;\n\t*nidsp = n;\n}\n\nvoid\nget_remote_user_groups_from_dirents(struct sftp_conn *conn, SFTP_DIRENT **d)\n{\n\tu_int *uids = NULL, nuids = 0, *gids = NULL, ngids = 0;\n\n\tif (!sftp_can_get_users_groups_by_id(conn))\n\t\treturn;\n\n\tcollect_ids_from_dirents(d, 1, &uids, &nuids);\n\tcollect_ids_from_dirents(d, 0, &gids, &ngids);\n\tlookup_and_record(conn, uids, nuids, gids, ngids);\n\tfree(uids);\n\tfree(gids);\n}\n\nconst char *\nruser_name(uid_t uid)\n{\n\treturn idname_lookup(&user_idname, (u_int)uid);\n}\n\nconst char *\nrgroup_name(uid_t gid)\n{\n\treturn idname_lookup(&group_idname, (u_int)gid);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}