{
  "module_name": "packet.c",
  "hash_id": "32eec044b320b10f77587c0acae17e3e749371945da2bcd33202a690d89b50c9",
  "original_prompt": "Ingested from openssh-9.6p1/packet.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include \"openbsd-compat/sys-queue.h\"\n#include <sys/socket.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <netdb.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <signal.h>\n#include <time.h>\n\n \n#ifdef WITH_OPENSSL\n# include <openssl/bn.h>\n# include <openssl/evp.h>\n# ifdef OPENSSL_HAS_ECC\n#  include <openssl/ec.h>\n# endif\n#endif\n\n#ifdef WITH_ZLIB\n#include <zlib.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"compat.h\"\n#include \"ssh2.h\"\n#include \"cipher.h\"\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"digest.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"canohost.h\"\n#include \"misc.h\"\n#include \"channels.h\"\n#include \"ssh.h\"\n#include \"packet.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n\n#ifdef PACKET_DEBUG\n#define DBG(x) x\n#else\n#define DBG(x)\n#endif\n\n#define PACKET_MAX_SIZE (256 * 1024)\n\nstruct packet_state {\n\tu_int32_t seqnr;\n\tu_int32_t packets;\n\tu_int64_t blocks;\n\tu_int64_t bytes;\n};\n\nstruct packet {\n\tTAILQ_ENTRY(packet) next;\n\tu_char type;\n\tstruct sshbuf *payload;\n};\n\nstruct session_state {\n\t \n\tint connection_in;\n\tint connection_out;\n\n\t \n\tu_int remote_protocol_flags;\n\n\t \n\tstruct sshcipher_ctx *receive_context;\n\n\t \n\tstruct sshcipher_ctx *send_context;\n\n\t \n\tstruct sshbuf *input;\n\n\t \n\tstruct sshbuf *output;\n\n\t \n\tstruct sshbuf *outgoing_packet;\n\n\t \n\tstruct sshbuf *incoming_packet;\n\n\t \n\tstruct sshbuf *compression_buffer;\n\n#ifdef WITH_ZLIB\n\t \n\tz_stream compression_in_stream;\n\tz_stream compression_out_stream;\n#endif\n\tint compression_in_started;\n\tint compression_out_started;\n\tint compression_in_failures;\n\tint compression_out_failures;\n\n\t \n\tu_int max_packet_size;\n\n\t \n\tint initialized;\n\n\t \n\tint interactive_mode;\n\n\t \n\tint server_side;\n\n\t \n\tint after_authentication;\n\n\tint keep_alive_timeouts;\n\n\t \n\tint packet_timeout_ms;\n\n\t \n\tstruct newkeys *newkeys[MODE_MAX];\n\tstruct packet_state p_read, p_send;\n\n\t \n\tu_int64_t max_blocks_in, max_blocks_out, rekey_limit;\n\n\t \n\tu_int32_t rekey_interval;\t \n\ttime_t rekey_time;\t \n\n\t \n\tu_char extra_pad;\n\n\t \n\tu_int packet_discard;\n\tsize_t packet_discard_mac_already;\n\tstruct sshmac *packet_discard_mac;\n\n\t \n\tu_int packlen;\n\n\t \n\tint rekeying;\n\n\t \n\tint mux;\n\n\t \n\tint set_interactive_called;\n\n\t \n\tint set_maxsize_called;\n\n\t \n\tint cipher_warning_done;\n\n\t \n\tssh_packet_hook_fn *hook_in;\n\tvoid *hook_in_ctx;\n\n\tTAILQ_HEAD(, packet) outgoing;\n};\n\nstruct ssh *\nssh_alloc_session_state(void)\n{\n\tstruct ssh *ssh = NULL;\n\tstruct session_state *state = NULL;\n\n\tif ((ssh = calloc(1, sizeof(*ssh))) == NULL ||\n\t    (state = calloc(1, sizeof(*state))) == NULL ||\n\t    (ssh->kex = kex_new()) == NULL ||\n\t    (state->input = sshbuf_new()) == NULL ||\n\t    (state->output = sshbuf_new()) == NULL ||\n\t    (state->outgoing_packet = sshbuf_new()) == NULL ||\n\t    (state->incoming_packet = sshbuf_new()) == NULL)\n\t\tgoto fail;\n\tTAILQ_INIT(&state->outgoing);\n\tTAILQ_INIT(&ssh->private_keys);\n\tTAILQ_INIT(&ssh->public_keys);\n\tstate->connection_in = -1;\n\tstate->connection_out = -1;\n\tstate->max_packet_size = 32768;\n\tstate->packet_timeout_ms = -1;\n\tstate->p_send.packets = state->p_read.packets = 0;\n\tstate->initialized = 1;\n\t \n\tstate->rekeying = 1;\n\tssh->state = state;\n\treturn ssh;\n fail:\n\tif (ssh) {\n\t\tkex_free(ssh->kex);\n\t\tfree(ssh);\n\t}\n\tif (state) {\n\t\tsshbuf_free(state->input);\n\t\tsshbuf_free(state->output);\n\t\tsshbuf_free(state->incoming_packet);\n\t\tsshbuf_free(state->outgoing_packet);\n\t\tfree(state);\n\t}\n\treturn NULL;\n}\n\nvoid\nssh_packet_set_input_hook(struct ssh *ssh, ssh_packet_hook_fn *hook, void *ctx)\n{\n\tssh->state->hook_in = hook;\n\tssh->state->hook_in_ctx = ctx;\n}\n\n \nint\nssh_packet_is_rekeying(struct ssh *ssh)\n{\n\treturn ssh->state->rekeying ||\n\t    (ssh->kex != NULL && ssh->kex->done == 0);\n}\n\n \nstruct ssh *\nssh_packet_set_connection(struct ssh *ssh, int fd_in, int fd_out)\n{\n\tstruct session_state *state;\n\tconst struct sshcipher *none = cipher_by_name(\"none\");\n\tint r;\n\n\tif (none == NULL) {\n\t\terror_f(\"cannot load cipher 'none'\");\n\t\treturn NULL;\n\t}\n\tif (ssh == NULL)\n\t\tssh = ssh_alloc_session_state();\n\tif (ssh == NULL) {\n\t\terror_f(\"could not allocate state\");\n\t\treturn NULL;\n\t}\n\tstate = ssh->state;\n\tstate->connection_in = fd_in;\n\tstate->connection_out = fd_out;\n\tif ((r = cipher_init(&state->send_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_ENCRYPT)) != 0 ||\n\t    (r = cipher_init(&state->receive_context, none,\n\t    (const u_char *)\"\", 0, NULL, 0, CIPHER_DECRYPT)) != 0) {\n\t\terror_fr(r, \"cipher_init failed\");\n\t\tfree(ssh);  \n\t\treturn NULL;\n\t}\n\tstate->newkeys[MODE_IN] = state->newkeys[MODE_OUT] = NULL;\n\t \n\t(void)ssh_remote_ipaddr(ssh);\n\treturn ssh;\n}\n\nvoid\nssh_packet_set_timeout(struct ssh *ssh, int timeout, int count)\n{\n\tstruct session_state *state = ssh->state;\n\n\tif (timeout <= 0 || count <= 0) {\n\t\tstate->packet_timeout_ms = -1;\n\t\treturn;\n\t}\n\tif ((INT_MAX / 1000) / count < timeout)\n\t\tstate->packet_timeout_ms = INT_MAX;\n\telse\n\t\tstate->packet_timeout_ms = timeout * count * 1000;\n}\n\nvoid\nssh_packet_set_mux(struct ssh *ssh)\n{\n\tssh->state->mux = 1;\n\tssh->state->rekeying = 0;\n\tkex_free(ssh->kex);\n\tssh->kex = NULL;\n}\n\nint\nssh_packet_get_mux(struct ssh *ssh)\n{\n\treturn ssh->state->mux;\n}\n\nint\nssh_packet_set_log_preamble(struct ssh *ssh, const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tfree(ssh->log_preamble);\n\tif (fmt == NULL)\n\t\tssh->log_preamble = NULL;\n\telse {\n\t\tva_start(args, fmt);\n\t\tr = vasprintf(&ssh->log_preamble, fmt, args);\n\t\tva_end(args);\n\t\tif (r < 0 || ssh->log_preamble == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\treturn 0;\n}\n\nint\nssh_packet_stop_discard(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif (state->packet_discard_mac) {\n\t\tchar buf[1024];\n\t\tsize_t dlen = PACKET_MAX_SIZE;\n\n\t\tif (dlen > state->packet_discard_mac_already)\n\t\t\tdlen -= state->packet_discard_mac_already;\n\t\tmemset(buf, 'a', sizeof(buf));\n\t\twhile (sshbuf_len(state->incoming_packet) < dlen)\n\t\t\tif ((r = sshbuf_put(state->incoming_packet, buf,\n\t\t\t    sizeof(buf))) != 0)\n\t\t\t\treturn r;\n\t\t(void) mac_compute(state->packet_discard_mac,\n\t\t    state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->incoming_packet), dlen,\n\t\t    NULL, 0);\n\t}\n\tlogit(\"Finished discarding for %.200s port %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\treturn SSH_ERR_MAC_INVALID;\n}\n\nstatic int\nssh_packet_start_discard(struct ssh *ssh, struct sshenc *enc,\n    struct sshmac *mac, size_t mac_already, u_int discard)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif (enc == NULL || !cipher_is_cbc(enc->cipher) || (mac && mac->etm)) {\n\t\tif ((r = sshpkt_disconnect(ssh, \"Packet corrupt\")) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_MAC_INVALID;\n\t}\n\t \n\tif (mac && mac->enabled) {\n\t\tstate->packet_discard_mac = mac;\n\t\tstate->packet_discard_mac_already = mac_already;\n\t}\n\tif (sshbuf_len(state->input) >= discard)\n\t\treturn ssh_packet_stop_discard(ssh);\n\tstate->packet_discard = discard - sshbuf_len(state->input);\n\treturn 0;\n}\n\n \n\nint\nssh_packet_connection_is_on_socket(struct ssh *ssh)\n{\n\tstruct session_state *state;\n\tstruct sockaddr_storage from, to;\n\tsocklen_t fromlen, tolen;\n\n\tif (ssh == NULL || ssh->state == NULL)\n\t\treturn 0;\n\n\tstate = ssh->state;\n\tif (state->connection_in == -1 || state->connection_out == -1)\n\t\treturn 0;\n\t \n\tif (state->connection_in == state->connection_out)\n\t\treturn 1;\n\tfromlen = sizeof(from);\n\tmemset(&from, 0, sizeof(from));\n\tif (getpeername(state->connection_in, (struct sockaddr *)&from,\n\t    &fromlen) == -1)\n\t\treturn 0;\n\ttolen = sizeof(to);\n\tmemset(&to, 0, sizeof(to));\n\tif (getpeername(state->connection_out, (struct sockaddr *)&to,\n\t    &tolen) == -1)\n\t\treturn 0;\n\tif (fromlen != tolen || memcmp(&from, &to, fromlen) != 0)\n\t\treturn 0;\n\tif (from.ss_family != AF_INET && from.ss_family != AF_INET6)\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid\nssh_packet_get_bytes(struct ssh *ssh, u_int64_t *ibytes, u_int64_t *obytes)\n{\n\tif (ibytes)\n\t\t*ibytes = ssh->state->p_read.bytes;\n\tif (obytes)\n\t\t*obytes = ssh->state->p_send.bytes;\n}\n\nint\nssh_packet_connection_af(struct ssh *ssh)\n{\n\treturn get_sock_af(ssh->state->connection_out);\n}\n\n \n\nvoid\nssh_packet_set_nonblocking(struct ssh *ssh)\n{\n\t \n\tset_nonblock(ssh->state->connection_in);\n\n\tif (ssh->state->connection_out != ssh->state->connection_in)\n\t\tset_nonblock(ssh->state->connection_out);\n}\n\n \n\nint\nssh_packet_get_connection_in(struct ssh *ssh)\n{\n\treturn ssh->state->connection_in;\n}\n\n \n\nint\nssh_packet_get_connection_out(struct ssh *ssh)\n{\n\treturn ssh->state->connection_out;\n}\n\n \n\nconst char *\nssh_remote_ipaddr(struct ssh *ssh)\n{\n\tint sock;\n\n\t \n\tif (ssh->remote_ipaddr == NULL) {\n\t\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\t\tsock = ssh->state->connection_in;\n\t\t\tssh->remote_ipaddr = get_peer_ipaddr(sock);\n\t\t\tssh->remote_port = get_peer_port(sock);\n\t\t\tssh->local_ipaddr = get_local_ipaddr(sock);\n\t\t\tssh->local_port = get_local_port(sock);\n\t\t} else {\n\t\t\tssh->remote_ipaddr = xstrdup(\"UNKNOWN\");\n\t\t\tssh->remote_port = 65535;\n\t\t\tssh->local_ipaddr = xstrdup(\"UNKNOWN\");\n\t\t\tssh->local_port = 65535;\n\t\t}\n\t}\n\treturn ssh->remote_ipaddr;\n}\n\n \n\nint\nssh_remote_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh);  \n\treturn ssh->remote_port;\n}\n\n \n\nconst char *\nssh_local_ipaddr(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh);  \n\treturn ssh->local_ipaddr;\n}\n\n \n\nint\nssh_local_port(struct ssh *ssh)\n{\n\t(void)ssh_remote_ipaddr(ssh);  \n\treturn ssh->local_port;\n}\n\n \nconst char *\nssh_packet_rdomain_in(struct ssh *ssh)\n{\n\tif (ssh->rdomain_in != NULL)\n\t\treturn ssh->rdomain_in;\n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn NULL;\n\tssh->rdomain_in = get_rdomain(ssh->state->connection_in);\n\treturn ssh->rdomain_in;\n}\n\n \n\nstatic void\nssh_packet_close_internal(struct ssh *ssh, int do_close)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int mode;\n\n\tif (!state->initialized)\n\t\treturn;\n\tstate->initialized = 0;\n\tif (do_close) {\n\t\tif (state->connection_in == state->connection_out) {\n\t\t\tclose(state->connection_out);\n\t\t} else {\n\t\t\tclose(state->connection_in);\n\t\t\tclose(state->connection_out);\n\t\t}\n\t}\n\tsshbuf_free(state->input);\n\tsshbuf_free(state->output);\n\tsshbuf_free(state->outgoing_packet);\n\tsshbuf_free(state->incoming_packet);\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tkex_free_newkeys(state->newkeys[mode]);\t \n\t\tstate->newkeys[mode] = NULL;\n\t\tssh_clear_newkeys(ssh, mode);\t\t \n\t}\n#ifdef WITH_ZLIB\n\t \n\tif (do_close && state->compression_buffer) {\n\t\tsshbuf_free(state->compression_buffer);\n\t\tif (state->compression_out_started) {\n\t\t\tz_streamp stream = &state->compression_out_stream;\n\t\t\tdebug(\"compress outgoing: \"\n\t\t\t    \"raw data %llu, compressed %llu, factor %.2f\",\n\t\t\t\t(unsigned long long)stream->total_in,\n\t\t\t\t(unsigned long long)stream->total_out,\n\t\t\t\tstream->total_in == 0 ? 0.0 :\n\t\t\t\t(double) stream->total_out / stream->total_in);\n\t\t\tif (state->compression_out_failures == 0)\n\t\t\t\tdeflateEnd(stream);\n\t\t}\n\t\tif (state->compression_in_started) {\n\t\t\tz_streamp stream = &state->compression_in_stream;\n\t\t\tdebug(\"compress incoming: \"\n\t\t\t    \"raw data %llu, compressed %llu, factor %.2f\",\n\t\t\t    (unsigned long long)stream->total_out,\n\t\t\t    (unsigned long long)stream->total_in,\n\t\t\t    stream->total_out == 0 ? 0.0 :\n\t\t\t    (double) stream->total_in / stream->total_out);\n\t\t\tif (state->compression_in_failures == 0)\n\t\t\t\tinflateEnd(stream);\n\t\t}\n\t}\n#endif\t \n\tcipher_free(state->send_context);\n\tcipher_free(state->receive_context);\n\tstate->send_context = state->receive_context = NULL;\n\tif (do_close) {\n\t\tfree(ssh->local_ipaddr);\n\t\tssh->local_ipaddr = NULL;\n\t\tfree(ssh->remote_ipaddr);\n\t\tssh->remote_ipaddr = NULL;\n\t\tfree(ssh->state);\n\t\tssh->state = NULL;\n\t\tkex_free(ssh->kex);\n\t\tssh->kex = NULL;\n\t}\n}\n\nvoid\nssh_packet_close(struct ssh *ssh)\n{\n\tssh_packet_close_internal(ssh, 1);\n}\n\nvoid\nssh_packet_clear_keys(struct ssh *ssh)\n{\n\tssh_packet_close_internal(ssh, 0);\n}\n\n \n\nvoid\nssh_packet_set_protocol_flags(struct ssh *ssh, u_int protocol_flags)\n{\n\tssh->state->remote_protocol_flags = protocol_flags;\n}\n\n \n\nu_int\nssh_packet_get_protocol_flags(struct ssh *ssh)\n{\n\treturn ssh->state->remote_protocol_flags;\n}\n\n \n\nstatic int\nssh_packet_init_compression(struct ssh *ssh)\n{\n\tif (!ssh->state->compression_buffer &&\n\t    ((ssh->state->compression_buffer = sshbuf_new()) == NULL))\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\treturn 0;\n}\n\n#ifdef WITH_ZLIB\nstatic int\nstart_compression_out(struct ssh *ssh, int level)\n{\n\tif (level < 1 || level > 9)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tdebug(\"Enabling compression at level %d.\", level);\n\tif (ssh->state->compression_out_started == 1)\n\t\tdeflateEnd(&ssh->state->compression_out_stream);\n\tswitch (deflateInit(&ssh->state->compression_out_stream, level)) {\n\tcase Z_OK:\n\t\tssh->state->compression_out_started = 1;\n\t\tbreak;\n\tcase Z_MEM_ERROR:\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tdefault:\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}\n\nstatic int\nstart_compression_in(struct ssh *ssh)\n{\n\tif (ssh->state->compression_in_started == 1)\n\t\tinflateEnd(&ssh->state->compression_in_stream);\n\tswitch (inflateInit(&ssh->state->compression_in_stream)) {\n\tcase Z_OK:\n\t\tssh->state->compression_in_started = 1;\n\t\tbreak;\n\tcase Z_MEM_ERROR:\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tdefault:\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)\n{\n\tu_char buf[4096];\n\tint r, status;\n\n\tif (ssh->state->compression_out_started != 1)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif (sshbuf_len(in) == 0)\n\t\treturn 0;\n\n\t \n\tif ((ssh->state->compression_out_stream.next_in =\n\t    sshbuf_mutable_ptr(in)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tssh->state->compression_out_stream.avail_in = sshbuf_len(in);\n\n\t \n\tdo {\n\t\t \n\t\tssh->state->compression_out_stream.next_out = buf;\n\t\tssh->state->compression_out_stream.avail_out = sizeof(buf);\n\n\t\t \n\t\tstatus = deflate(&ssh->state->compression_out_stream,\n\t\t    Z_PARTIAL_FLUSH);\n\t\tswitch (status) {\n\t\tcase Z_MEM_ERROR:\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tcase Z_OK:\n\t\t\t \n\t\t\tif ((r = sshbuf_put(out, buf, sizeof(buf) -\n\t\t\t    ssh->state->compression_out_stream.avail_out)) != 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase Z_STREAM_ERROR:\n\t\tdefault:\n\t\t\tssh->state->compression_out_failures++;\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t} while (ssh->state->compression_out_stream.avail_out == 0);\n\treturn 0;\n}\n\nstatic int\nuncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)\n{\n\tu_char buf[4096];\n\tint r, status;\n\n\tif (ssh->state->compression_in_started != 1)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\tif ((ssh->state->compression_in_stream.next_in =\n\t    sshbuf_mutable_ptr(in)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tssh->state->compression_in_stream.avail_in = sshbuf_len(in);\n\n\tfor (;;) {\n\t\t \n\t\tssh->state->compression_in_stream.next_out = buf;\n\t\tssh->state->compression_in_stream.avail_out = sizeof(buf);\n\n\t\tstatus = inflate(&ssh->state->compression_in_stream,\n\t\t    Z_SYNC_FLUSH);\n\t\tswitch (status) {\n\t\tcase Z_OK:\n\t\t\tif ((r = sshbuf_put(out, buf, sizeof(buf) -\n\t\t\t    ssh->state->compression_in_stream.avail_out)) != 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase Z_BUF_ERROR:\n\t\t\t \n\t\t\treturn 0;\n\t\tcase Z_DATA_ERROR:\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tcase Z_MEM_ERROR:\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tcase Z_STREAM_ERROR:\n\t\tdefault:\n\t\t\tssh->state->compression_in_failures++;\n\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t}\n\t}\n\t \n}\n\n#else\t \n\nstatic int\nstart_compression_out(struct ssh *ssh, int level)\n{\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n\nstatic int\nstart_compression_in(struct ssh *ssh)\n{\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n\nstatic int\ncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)\n{\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n\nstatic int\nuncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)\n{\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n#endif\t \n\nvoid\nssh_clear_newkeys(struct ssh *ssh, int mode)\n{\n\tif (ssh->kex && ssh->kex->newkeys[mode]) {\n\t\tkex_free_newkeys(ssh->kex->newkeys[mode]);\n\t\tssh->kex->newkeys[mode] = NULL;\n\t}\n}\n\nint\nssh_set_newkeys(struct ssh *ssh, int mode)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct sshcomp *comp;\n\tstruct sshcipher_ctx **ccp;\n\tstruct packet_state *ps;\n\tu_int64_t *max_blocks;\n\tconst char *wmsg;\n\tint r, crypt_type;\n\tconst char *dir = mode == MODE_OUT ? \"out\" : \"in\";\n\n\tdebug2_f(\"mode %d\", mode);\n\n\tif (mode == MODE_OUT) {\n\t\tccp = &state->send_context;\n\t\tcrypt_type = CIPHER_ENCRYPT;\n\t\tps = &state->p_send;\n\t\tmax_blocks = &state->max_blocks_out;\n\t} else {\n\t\tccp = &state->receive_context;\n\t\tcrypt_type = CIPHER_DECRYPT;\n\t\tps = &state->p_read;\n\t\tmax_blocks = &state->max_blocks_in;\n\t}\n\tif (state->newkeys[mode] != NULL) {\n\t\tdebug_f(\"rekeying %s, input %llu bytes %llu blocks, \"\n\t\t    \"output %llu bytes %llu blocks\", dir,\n\t\t    (unsigned long long)state->p_read.bytes,\n\t\t    (unsigned long long)state->p_read.blocks,\n\t\t    (unsigned long long)state->p_send.bytes,\n\t\t    (unsigned long long)state->p_send.blocks);\n\t\tkex_free_newkeys(state->newkeys[mode]);\n\t\tstate->newkeys[mode] = NULL;\n\t}\n\t \n\tps->packets = ps->blocks = 0;\n\t \n\tif ((state->newkeys[mode] = ssh->kex->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tssh->kex->newkeys[mode] = NULL;\n\tenc  = &state->newkeys[mode]->enc;\n\tmac  = &state->newkeys[mode]->mac;\n\tcomp = &state->newkeys[mode]->comp;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = mac_init(mac)) != 0)\n\t\t\treturn r;\n\t}\n\tmac->enabled = 1;\n\tDBG(debug_f(\"cipher_init: %s\", dir));\n\tcipher_free(*ccp);\n\t*ccp = NULL;\n\tif ((r = cipher_init(ccp, enc->cipher, enc->key, enc->key_len,\n\t    enc->iv, enc->iv_len, crypt_type)) != 0)\n\t\treturn r;\n\tif (!state->cipher_warning_done &&\n\t    (wmsg = cipher_warning_message(*ccp)) != NULL) {\n\t\terror(\"Warning: %s\", wmsg);\n\t\tstate->cipher_warning_done = 1;\n\t}\n\t \n\t \n\tif ((comp->type == COMP_ZLIB ||\n\t    (comp->type == COMP_DELAYED &&\n\t    state->after_authentication)) && comp->enabled == 0) {\n\t\tif ((r = ssh_packet_init_compression(ssh)) < 0)\n\t\t\treturn r;\n\t\tif (mode == MODE_OUT) {\n\t\t\tif ((r = start_compression_out(ssh, 6)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\tif ((r = start_compression_in(ssh)) != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tcomp->enabled = 1;\n\t}\n\t \n\tif (enc->block_size >= 16)\n\t\t*max_blocks = (u_int64_t)1 << (enc->block_size*2);\n\telse\n\t\t*max_blocks = ((u_int64_t)1 << 30) / enc->block_size;\n\tif (state->rekey_limit)\n\t\t*max_blocks = MINIMUM(*max_blocks,\n\t\t    state->rekey_limit / enc->block_size);\n\tdebug(\"rekey %s after %llu blocks\", dir,\n\t    (unsigned long long)*max_blocks);\n\treturn 0;\n}\n\n#define MAX_PACKETS\t(1U<<31)\nstatic int\nssh_packet_need_rekeying(struct ssh *ssh, u_int outbound_packet_len)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int32_t out_blocks;\n\n\t \n\tif (!state->after_authentication)\n\t\treturn 0;\n\n\t \n\tif (ssh_packet_is_rekeying(ssh))\n\t\treturn 0;\n\n\t \n\tif (ssh->compat & SSH_BUG_NOREKEY)\n\t\treturn 0;\n\n\t \n\tif (state->p_send.packets == 0 && state->p_read.packets == 0)\n\t\treturn 0;\n\n\t \n\tif (state->rekey_interval != 0 &&\n\t    (int64_t)state->rekey_time + state->rekey_interval <= monotime())\n\t\treturn 1;\n\n\t \n\tif (state->p_send.packets > MAX_PACKETS ||\n\t    state->p_read.packets > MAX_PACKETS)\n\t\treturn 1;\n\n\t \n\tout_blocks = ROUNDUP(outbound_packet_len,\n\t    state->newkeys[MODE_OUT]->enc.block_size);\n\treturn (state->max_blocks_out &&\n\t    (state->p_send.blocks + out_blocks > state->max_blocks_out)) ||\n\t    (state->max_blocks_in &&\n\t    (state->p_read.blocks > state->max_blocks_in));\n}\n\nint\nssh_packet_check_rekey(struct ssh *ssh)\n{\n\tif (!ssh_packet_need_rekeying(ssh, 0))\n\t\treturn 0;\n\tdebug3_f(\"rekex triggered\");\n\treturn kex_start_rekex(ssh);\n}\n\n \nstatic int\nssh_packet_enable_delayed_compress(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshcomp *comp = NULL;\n\tint r, mode;\n\n\t \n\tstate->after_authentication = 1;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\t \n\t\tif (state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &state->newkeys[mode]->comp;\n\t\tif (comp && !comp->enabled && comp->type == COMP_DELAYED) {\n\t\t\tif ((r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\t\treturn r;\n\t\t\tif (mode == MODE_OUT) {\n\t\t\t\tif ((r = start_compression_out(ssh, 6)) != 0)\n\t\t\t\t\treturn r;\n\t\t\t} else {\n\t\t\t\tif ((r = start_compression_in(ssh)) != 0)\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t\tcomp->enabled = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint\nssh_packet_log_type(u_char type)\n{\n\tswitch (type) {\n\tcase SSH2_MSG_PING:\n\tcase SSH2_MSG_PONG:\n\tcase SSH2_MSG_CHANNEL_DATA:\n\tcase SSH2_MSG_CHANNEL_EXTENDED_DATA:\n\tcase SSH2_MSG_CHANNEL_WINDOW_ADJUST:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n \nint\nssh_packet_send2_wrapped(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tu_char type, *cp, macbuf[SSH_DIGEST_MAX_LENGTH];\n\tu_char tmp, padlen, pad = 0;\n\tu_int authlen = 0, aadlen = 0;\n\tu_int len;\n\tstruct sshenc *enc   = NULL;\n\tstruct sshmac *mac   = NULL;\n\tstruct sshcomp *comp = NULL;\n\tint r, block_size;\n\n\tif (state->newkeys[MODE_OUT] != NULL) {\n\t\tenc  = &state->newkeys[MODE_OUT]->enc;\n\t\tmac  = &state->newkeys[MODE_OUT]->mac;\n\t\tcomp = &state->newkeys[MODE_OUT]->comp;\n\t\t \n\t\tif ((authlen = cipher_authlen(enc->cipher)) != 0)\n\t\t\tmac = NULL;\n\t}\n\tblock_size = enc ? enc->block_size : 8;\n\taadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;\n\n\ttype = (sshbuf_ptr(state->outgoing_packet))[5];\n\tif (ssh_packet_log_type(type))\n\t\tdebug3(\"send packet: type %u\", type);\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"plain:     \");\n\tsshbuf_dump(state->outgoing_packet, stderr);\n#endif\n\n\tif (comp && comp->enabled) {\n\t\tlen = sshbuf_len(state->outgoing_packet);\n\t\t \n\t\tif ((r = sshbuf_consume(state->outgoing_packet, 5)) != 0)\n\t\t\tgoto out;\n\t\tsshbuf_reset(state->compression_buffer);\n\t\tif ((r = compress_buffer(ssh, state->outgoing_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tsshbuf_reset(state->outgoing_packet);\n\t\tif ((r = sshbuf_put(state->outgoing_packet,\n\t\t    \"\\0\\0\\0\\0\\0\", 5)) != 0 ||\n\t\t    (r = sshbuf_putb(state->outgoing_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tDBG(debug(\"compression: raw %d compressed %zd\", len,\n\t\t    sshbuf_len(state->outgoing_packet)));\n\t}\n\n\t \n\tlen = sshbuf_len(state->outgoing_packet);\n\n\t \n\tlen -= aadlen;  \n\tpadlen = block_size - (len % block_size);\n\tif (padlen < 4)\n\t\tpadlen += block_size;\n\tif (state->extra_pad) {\n\t\ttmp = state->extra_pad;\n\t\tstate->extra_pad =\n\t\t    ROUNDUP(state->extra_pad, block_size);\n\t\t \n\t\tif (state->extra_pad < tmp)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\ttmp = (len + padlen) % state->extra_pad;\n\t\t \n\t\tif (tmp > state->extra_pad)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t\tpad = state->extra_pad - tmp;\n\t\tDBG(debug3_f(\"adding %d (len %d padlen %d extra_pad %d)\",\n\t\t    pad, len, padlen, state->extra_pad));\n\t\ttmp = padlen;\n\t\tpadlen += pad;\n\t\t \n\t\tif (padlen < tmp)\n\t\t\treturn SSH_ERR_INVALID_ARGUMENT;  \n\t\tstate->extra_pad = 0;\n\t}\n\tif ((r = sshbuf_reserve(state->outgoing_packet, padlen, &cp)) != 0)\n\t\tgoto out;\n\tif (enc && !cipher_ctx_is_plaintext(state->send_context)) {\n\t\t \n\t\tarc4random_buf(cp, padlen);\n\t} else {\n\t\t \n\t\texplicit_bzero(cp, padlen);\n\t}\n\t \n\tlen = sshbuf_len(state->outgoing_packet);\n\tcp = sshbuf_mutable_ptr(state->outgoing_packet);\n\tif (cp == NULL) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tPOKE_U32(cp, len - 4);\n\tcp[4] = padlen;\n\tDBG(debug(\"send: len %d (includes padlen %d, aadlen %d)\",\n\t    len, padlen, aadlen));\n\n\t \n\tif (mac && mac->enabled && !mac->etm) {\n\t\tif ((r = mac_compute(mac, state->p_send.seqnr,\n\t\t    sshbuf_ptr(state->outgoing_packet), len,\n\t\t    macbuf, sizeof(macbuf))) != 0)\n\t\t\tgoto out;\n\t\tDBG(debug(\"done calc MAC out #%d\", state->p_send.seqnr));\n\t}\n\t \n\tif ((r = sshbuf_reserve(state->output,\n\t    sshbuf_len(state->outgoing_packet) + authlen, &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(state->send_context, state->p_send.seqnr, cp,\n\t    sshbuf_ptr(state->outgoing_packet),\n\t    len - aadlen, aadlen, authlen)) != 0)\n\t\tgoto out;\n\t \n\tif (mac && mac->enabled) {\n\t\tif (mac->etm) {\n\t\t\t \n\t\t\tif ((r = mac_compute(mac, state->p_send.seqnr,\n\t\t\t    cp, len, macbuf, sizeof(macbuf))) != 0)\n\t\t\t\tgoto out;\n\t\t\tDBG(debug(\"done calc MAC(EtM) out #%d\",\n\t\t\t    state->p_send.seqnr));\n\t\t}\n\t\tif ((r = sshbuf_put(state->output, macbuf, mac->mac_len)) != 0)\n\t\t\tgoto out;\n\t}\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"encrypted: \");\n\tsshbuf_dump(state->output, stderr);\n#endif\n\t \n\tif (++state->p_send.seqnr == 0) {\n\t\tif ((ssh->kex->flags & KEX_INITIAL) != 0) {\n\t\t\tssh_packet_disconnect(ssh, \"outgoing sequence number \"\n\t\t\t    \"wrapped during initial key exchange\");\n\t\t}\n\t\tlogit(\"outgoing seqnr wraps around\");\n\t}\n\tif (++state->p_send.packets == 0)\n\t\tif (!(ssh->compat & SSH_BUG_NOREKEY))\n\t\t\treturn SSH_ERR_NEED_REKEY;\n\tstate->p_send.blocks += len / block_size;\n\tstate->p_send.bytes += len;\n\tsshbuf_reset(state->outgoing_packet);\n\n\tif (type == SSH2_MSG_NEWKEYS && ssh->kex->kex_strict) {\n\t\tdebug_f(\"resetting send seqnr %u\", state->p_send.seqnr);\n\t\tstate->p_send.seqnr = 0;\n\t}\n\n\tif (type == SSH2_MSG_NEWKEYS)\n\t\tr = ssh_set_newkeys(ssh, MODE_OUT);\n\telse if (type == SSH2_MSG_USERAUTH_SUCCESS && state->server_side)\n\t\tr = ssh_packet_enable_delayed_compress(ssh);\n\telse\n\t\tr = 0;\n out:\n\treturn r;\n}\n\n \nstatic int\nssh_packet_type_is_kex(u_char type)\n{\n\treturn\n\t    type >= SSH2_MSG_TRANSPORT_MIN &&\n\t    type <= SSH2_MSG_TRANSPORT_MAX &&\n\t    type != SSH2_MSG_SERVICE_REQUEST &&\n\t    type != SSH2_MSG_SERVICE_ACCEPT &&\n\t    type != SSH2_MSG_EXT_INFO;\n}\n\nint\nssh_packet_send2(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct packet *p;\n\tu_char type;\n\tint r, need_rekey;\n\n\tif (sshbuf_len(state->outgoing_packet) < 6)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\ttype = sshbuf_ptr(state->outgoing_packet)[5];\n\tneed_rekey = !ssh_packet_type_is_kex(type) &&\n\t    ssh_packet_need_rekeying(ssh, sshbuf_len(state->outgoing_packet));\n\n\t \n\tif ((need_rekey || state->rekeying) && !ssh_packet_type_is_kex(type)) {\n\t\tif (need_rekey)\n\t\t\tdebug3_f(\"rekex triggered\");\n\t\tdebug(\"enqueue packet: %u\", type);\n\t\tp = calloc(1, sizeof(*p));\n\t\tif (p == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tp->type = type;\n\t\tp->payload = state->outgoing_packet;\n\t\tTAILQ_INSERT_TAIL(&state->outgoing, p, next);\n\t\tstate->outgoing_packet = sshbuf_new();\n\t\tif (state->outgoing_packet == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tif (need_rekey) {\n\t\t\t \n\t\t\treturn kex_start_rekex(ssh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (type == SSH2_MSG_KEXINIT)\n\t\tstate->rekeying = 1;\n\n\tif ((r = ssh_packet_send2_wrapped(ssh)) != 0)\n\t\treturn r;\n\n\t \n\tif (type == SSH2_MSG_NEWKEYS) {\n\t\tstate->rekeying = 0;\n\t\tstate->rekey_time = monotime();\n\t\twhile ((p = TAILQ_FIRST(&state->outgoing))) {\n\t\t\ttype = p->type;\n\t\t\t \n\t\t\tif (ssh_packet_need_rekeying(ssh,\n\t\t\t    sshbuf_len(p->payload))) {\n\t\t\t\tdebug3_f(\"queued packet triggered rekex\");\n\t\t\t\treturn kex_start_rekex(ssh);\n\t\t\t}\n\t\t\tdebug(\"dequeue packet: %u\", type);\n\t\t\tsshbuf_free(state->outgoing_packet);\n\t\t\tstate->outgoing_packet = p->payload;\n\t\t\tTAILQ_REMOVE(&state->outgoing, p, next);\n\t\t\tmemset(p, 0, sizeof(*p));\n\t\t\tfree(p);\n\t\t\tif ((r = ssh_packet_send2_wrapped(ssh)) != 0)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nint\nssh_packet_read_seqnr(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tint len, r, ms_remain = 0;\n\tstruct pollfd pfd;\n\tchar buf[8192];\n\tstruct timeval start;\n\tstruct timespec timespec, *timespecp = NULL;\n\n\tDBG(debug(\"packet_read()\"));\n\n\t \n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tgoto out;\n\n\t \n\tfor (;;) {\n\t\t \n\t\tif ((r = ssh_packet_read_poll_seqnr(ssh, typep, seqnr_p)) != 0)\n\t\t\tbreak;\n\t\t \n\t\tif (*typep != SSH_MSG_NONE)\n\t\t\tbreak;\n\t\t \n\t\tpfd.fd = state->connection_in;\n\t\tpfd.events = POLLIN;\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimespecp = &timespec;\n\t\t}\n\t\t \n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms > 0) {\n\t\t\t\tms_to_timespec(&timespec, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((r = ppoll(&pfd, 1, timespecp, NULL)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK) {\n\t\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (state->packet_timeout_ms <= 0)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (r == 0) {\n\t\t\tr = SSH_ERR_CONN_TIMEOUT;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tlen = read(state->connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tr = SSH_ERR_CONN_CLOSED;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len == -1) {\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif ((r = ssh_packet_process_incoming(ssh, buf, len)) != 0)\n\t\t\tgoto out;\n\t}\n out:\n\treturn r;\n}\n\nint\nssh_packet_read(struct ssh *ssh)\n{\n\tu_char type;\n\tint r;\n\n\tif ((r = ssh_packet_read_seqnr(ssh, &type, NULL)) != 0)\n\t\tfatal_fr(r, \"read\");\n\treturn type;\n}\n\nstatic int\nssh_packet_read_poll2_mux(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *cp;\n\tsize_t need;\n\tint r;\n\n\tif (ssh->kex)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t*typep = SSH_MSG_NONE;\n\tcp = sshbuf_ptr(state->input);\n\tif (state->packlen == 0) {\n\t\tif (sshbuf_len(state->input) < 4 + 1)\n\t\t\treturn 0;  \n\t\tstate->packlen = PEEK_U32(cp);\n\t\tif (state->packlen < 4 + 1 ||\n\t\t    state->packlen > PACKET_MAX_SIZE)\n\t\t\treturn SSH_ERR_MESSAGE_INCOMPLETE;\n\t}\n\tneed = state->packlen + 4;\n\tif (sshbuf_len(state->input) < need)\n\t\treturn 0;  \n\tsshbuf_reset(state->incoming_packet);\n\tif ((r = sshbuf_put(state->incoming_packet, cp + 4,\n\t    state->packlen)) != 0 ||\n\t    (r = sshbuf_consume(state->input, need)) != 0 ||\n\t    (r = sshbuf_get_u8(state->incoming_packet, NULL)) != 0 ||\n\t    (r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)\n\t\treturn r;\n\tif (ssh_packet_log_type(*typep))\n\t\tdebug3_f(\"type %u\", *typep);\n\t \n\t \n\tstate->packlen = 0;\n\treturn r;\n}\n\nint\nssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int padlen, need;\n\tu_char *cp;\n\tu_int maclen, aadlen = 0, authlen = 0, block_size;\n\tstruct sshenc *enc   = NULL;\n\tstruct sshmac *mac   = NULL;\n\tstruct sshcomp *comp = NULL;\n\tint r;\n\n\tif (state->mux)\n\t\treturn ssh_packet_read_poll2_mux(ssh, typep, seqnr_p);\n\n\t*typep = SSH_MSG_NONE;\n\n\tif (state->packet_discard)\n\t\treturn 0;\n\n\tif (state->newkeys[MODE_IN] != NULL) {\n\t\tenc  = &state->newkeys[MODE_IN]->enc;\n\t\tmac  = &state->newkeys[MODE_IN]->mac;\n\t\tcomp = &state->newkeys[MODE_IN]->comp;\n\t\t \n\t\tif ((authlen = cipher_authlen(enc->cipher)) != 0)\n\t\t\tmac = NULL;\n\t}\n\tmaclen = mac && mac->enabled ? mac->mac_len : 0;\n\tblock_size = enc ? enc->block_size : 8;\n\taadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;\n\n\tif (aadlen && state->packlen == 0) {\n\t\tif (cipher_get_length(state->receive_context,\n\t\t    &state->packlen, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)\n\t\t\treturn 0;\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tsshbuf_dump(state->input, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\tif ((r = sshpkt_disconnect(ssh, \"Packet corrupt\")) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_CONN_CORRUPT;\n\t\t}\n\t\tsshbuf_reset(state->incoming_packet);\n\t} else if (state->packlen == 0) {\n\t\t \n\t\tif (sshbuf_len(state->input) < block_size)\n\t\t\treturn 0;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_reserve(state->incoming_packet, block_size,\n\t\t    &cp)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = cipher_crypt(state->receive_context,\n\t\t    state->p_send.seqnr, cp, sshbuf_ptr(state->input),\n\t\t    block_size, 0, 0)) != 0)\n\t\t\tgoto out;\n\t\tstate->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tfprintf(stderr, \"input: \\n\");\n\t\t\tsshbuf_dump(state->input, stderr);\n\t\t\tfprintf(stderr, \"incoming_packet: \\n\");\n\t\t\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t\t    PACKET_MAX_SIZE);\n\t\t}\n\t\tif ((r = sshbuf_consume(state->input, block_size)) != 0)\n\t\t\tgoto out;\n\t}\n\tDBG(debug(\"input: packet len %u\", state->packlen+4));\n\n\tif (aadlen) {\n\t\t \n\t\tneed = state->packlen;\n\t} else {\n\t\t \n\t\tneed = 4 + state->packlen - block_size;\n\t}\n\tDBG(debug(\"partial packet: block %d, need %d, maclen %d, authlen %d,\"\n\t    \" aadlen %d\", block_size, need, maclen, authlen, aadlen));\n\tif (need % block_size != 0) {\n\t\tlogit(\"padding error: need %d block %d mod %d\",\n\t\t    need, block_size, need % block_size);\n\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t    PACKET_MAX_SIZE - block_size);\n\t}\n\t \n\tif (sshbuf_len(state->input) < aadlen + need + authlen + maclen)\n\t\treturn 0;  \n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read_poll enc/full: \");\n\tsshbuf_dump(state->input, stderr);\n#endif\n\t \n\tif (mac && mac->enabled && mac->etm) {\n\t\tif ((r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), aadlen + need,\n\t\t    sshbuf_ptr(state->input) + aadlen + need + authlen,\n\t\t    maclen)) != 0) {\n\t\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,\n\t    &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,\n\t    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)\n\t\tgoto out;\n\tif (mac && mac->enabled) {\n\t\t \n\t\tif (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->incoming_packet),\n\t\t    sshbuf_len(state->incoming_packet),\n\t\t    sshbuf_ptr(state->input), maclen)) != 0) {\n\t\t\tif (r != SSH_ERR_MAC_INVALID)\n\t\t\t\tgoto out;\n\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tif (need + block_size > PACKET_MAX_SIZE)\n\t\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac,\n\t\t\t    sshbuf_len(state->incoming_packet),\n\t\t\t    PACKET_MAX_SIZE - need - block_size);\n\t\t}\n\t\t \n\t\tDBG(debug(\"MAC #%d ok\", state->p_read.seqnr));\n\t\tif ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)\n\t\t\tgoto out;\n\t}\n\n\tif (seqnr_p != NULL)\n\t\t*seqnr_p = state->p_read.seqnr;\n\tif (++state->p_read.seqnr == 0) {\n\t\tif ((ssh->kex->flags & KEX_INITIAL) != 0) {\n\t\t\tssh_packet_disconnect(ssh, \"incoming sequence number \"\n\t\t\t    \"wrapped during initial key exchange\");\n\t\t}\n\t\tlogit(\"incoming seqnr wraps around\");\n\t}\n\tif (++state->p_read.packets == 0)\n\t\tif (!(ssh->compat & SSH_BUG_NOREKEY))\n\t\t\treturn SSH_ERR_NEED_REKEY;\n\tstate->p_read.blocks += (state->packlen + 4) / block_size;\n\tstate->p_read.bytes += state->packlen + 4;\n\n\t \n\tpadlen = sshbuf_ptr(state->incoming_packet)[4];\n\tDBG(debug(\"input: padlen %d\", padlen));\n\tif (padlen < 4)\t{\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Corrupted padlen %d on input.\", padlen)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_CONN_CORRUPT;\n\t}\n\n\t \n\tif ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||\n\t    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))\n\t\tgoto out;\n\n\tDBG(debug(\"input: len before de-compress %zd\",\n\t    sshbuf_len(state->incoming_packet)));\n\tif (comp && comp->enabled) {\n\t\tsshbuf_reset(state->compression_buffer);\n\t\tif ((r = uncompress_buffer(ssh, state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_putb(state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tDBG(debug(\"input: len after de-compress %zd\",\n\t\t    sshbuf_len(state->incoming_packet)));\n\t}\n\t \n\tif ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)\n\t\tgoto out;\n\tif (ssh_packet_log_type(*typep))\n\t\tdebug3(\"receive packet: type %u\", *typep);\n\tif (*typep < SSH2_MSG_MIN) {\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Invalid ssh2 packet type: %d\", *typep)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_PROTOCOL_ERROR;\n\t}\n\tif (state->hook_in != NULL &&\n\t    (r = state->hook_in(ssh, state->incoming_packet, typep,\n\t    state->hook_in_ctx)) != 0)\n\t\treturn r;\n\tif (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)\n\t\tr = ssh_packet_enable_delayed_compress(ssh);\n\telse\n\t\tr = 0;\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read/plain[%d]:\\r\\n\", *typep);\n\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t \n\tstate->packlen = 0;\n\tif (*typep == SSH2_MSG_NEWKEYS && ssh->kex->kex_strict) {\n\t\tdebug_f(\"resetting read seqnr %u\", state->p_read.seqnr);\n\t\tstate->p_read.seqnr = 0;\n\t}\n\n\tif ((r = ssh_packet_check_rekey(ssh)) != 0)\n\t\treturn r;\n out:\n\treturn r;\n}\n\nint\nssh_packet_read_poll_seqnr(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int reason, seqnr;\n\tint r;\n\tu_char *msg;\n\tconst u_char *d;\n\tsize_t len;\n\n\tfor (;;) {\n\t\tmsg = NULL;\n\t\tr = ssh_packet_read_poll2(ssh, typep, seqnr_p);\n\t\tif (r != 0)\n\t\t\treturn r;\n\t\tif (*typep == 0) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tstate->keep_alive_timeouts = 0;\n\t\tDBG(debug(\"received packet type %d\", *typep));\n\n\t\t \n\t\tif (*typep == SSH2_MSG_DISCONNECT) {\n\t\t\tif ((r = sshpkt_get_u32(ssh, &reason)) != 0 ||\n\t\t\t    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0)\n\t\t\t\treturn r;\n\t\t\t \n\t\t\tdo_log2(ssh->state->server_side &&\n\t\t\t    reason == SSH2_DISCONNECT_BY_APPLICATION ?\n\t\t\t    SYSLOG_LEVEL_INFO : SYSLOG_LEVEL_ERROR,\n\t\t\t    \"Received disconnect from %s port %d:\"\n\t\t\t    \"%u: %.400s\", ssh_remote_ipaddr(ssh),\n\t\t\t    ssh_remote_port(ssh), reason, msg);\n\t\t\tfree(msg);\n\t\t\treturn SSH_ERR_DISCONNECTED;\n\t\t}\n\n\t\t \n\t\tif (ssh->kex != NULL &&\n\t\t    (ssh->kex->flags & KEX_INITIAL) && ssh->kex->kex_strict)\n\t\t\treturn 0;\n\t\t \n\t\tswitch (*typep) {\n\t\tcase SSH2_MSG_IGNORE:\n\t\t\tdebug3(\"Received SSH2_MSG_IGNORE\");\n\t\t\tbreak;\n\t\tcase SSH2_MSG_DEBUG:\n\t\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\n\t\t\t    (r = sshpkt_get_string(ssh, &msg, NULL)) != 0 ||\n\t\t\t    (r = sshpkt_get_string(ssh, NULL, NULL)) != 0) {\n\t\t\t\tfree(msg);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tdebug(\"Remote: %.900s\", msg);\n\t\t\tfree(msg);\n\t\t\tbreak;\n\t\tcase SSH2_MSG_UNIMPLEMENTED:\n\t\t\tif ((r = sshpkt_get_u32(ssh, &seqnr)) != 0)\n\t\t\t\treturn r;\n\t\t\tdebug(\"Received SSH2_MSG_UNIMPLEMENTED for %u\",\n\t\t\t    seqnr);\n\t\t\tbreak;\n\t\tcase SSH2_MSG_PING:\n\t\t\tif ((r = sshpkt_get_string_direct(ssh, &d, &len)) != 0)\n\t\t\t\treturn r;\n\t\t\tDBG(debug(\"Received SSH2_MSG_PING len %zu\", len));\n\t\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_PONG)) != 0 ||\n\t\t\t    (r = sshpkt_put_string(ssh, d, len)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase SSH2_MSG_PONG:\n\t\t\tif ((r = sshpkt_get_string_direct(ssh,\n\t\t\t    NULL, &len)) != 0)\n\t\t\t\treturn r;\n\t\t\tDBG(debug(\"Received SSH2_MSG_PONG len %zu\", len));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n \nint\nssh_packet_process_incoming(struct ssh *ssh, const char *buf, u_int len)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif (state->packet_discard) {\n\t\tstate->keep_alive_timeouts = 0;  \n\t\tif (len >= state->packet_discard) {\n\t\t\tif ((r = ssh_packet_stop_discard(ssh)) != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tstate->packet_discard -= len;\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_put(state->input, buf, len)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nint\nssh_packet_process_read(struct ssh *ssh, int fd)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\tsize_t rlen;\n\n\tif ((r = sshbuf_read(fd, state->input, PACKET_MAX_SIZE, &rlen)) != 0)\n\t\treturn r;\n\n\tif (state->packet_discard) {\n\t\tif ((r = sshbuf_consume_end(state->input, rlen)) != 0)\n\t\t\treturn r;\n\t\tstate->keep_alive_timeouts = 0;  \n\t\tif (rlen >= state->packet_discard) {\n\t\t\tif ((r = ssh_packet_stop_discard(ssh)) != 0)\n\t\t\t\treturn r;\n\t\t}\n\t\tstate->packet_discard -= rlen;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nint\nssh_packet_remaining(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->incoming_packet);\n}\n\n \nvoid\nssh_packet_send_debug(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tif ((ssh->compat & SSH_BUG_DEBUG))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tdebug3(\"sending debug message: %s\", buf);\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_DEBUG)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||  \n\t    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \"send DEBUG\");\n}\n\nvoid\nsshpkt_fmt_connection_id(struct ssh *ssh, char *s, size_t l)\n{\n\tsnprintf(s, l, \"%.200s%s%s port %d\",\n\t    ssh->log_preamble ? ssh->log_preamble : \"\",\n\t    ssh->log_preamble ? \" \" : \"\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n}\n\n \nstatic void\nsshpkt_vfatal(struct ssh *ssh, int r, const char *fmt, va_list ap)\n{\n\tchar *tag = NULL, remote_id[512];\n\tint oerrno = errno;\n\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\n\tswitch (r) {\n\tcase SSH_ERR_CONN_CLOSED:\n\t\tssh_packet_clear_keys(ssh);\n\t\tlogdie(\"Connection closed by %s\", remote_id);\n\tcase SSH_ERR_CONN_TIMEOUT:\n\t\tssh_packet_clear_keys(ssh);\n\t\tlogdie(\"Connection %s %s timed out\",\n\t\t    ssh->state->server_side ? \"from\" : \"to\", remote_id);\n\tcase SSH_ERR_DISCONNECTED:\n\t\tssh_packet_clear_keys(ssh);\n\t\tlogdie(\"Disconnected from %s\", remote_id);\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\tif (errno == ECONNRESET) {\n\t\t\tssh_packet_clear_keys(ssh);\n\t\t\tlogdie(\"Connection reset by %s\", remote_id);\n\t\t}\n\t\t \n\tcase SSH_ERR_NO_CIPHER_ALG_MATCH:\n\tcase SSH_ERR_NO_MAC_ALG_MATCH:\n\tcase SSH_ERR_NO_COMPRESS_ALG_MATCH:\n\tcase SSH_ERR_NO_KEX_ALG_MATCH:\n\tcase SSH_ERR_NO_HOSTKEY_ALG_MATCH:\n\t\tif (ssh->kex && ssh->kex->failed_choice) {\n\t\t\tssh_packet_clear_keys(ssh);\n\t\t\terrno = oerrno;\n\t\t\tlogdie(\"Unable to negotiate with %s: %s. \"\n\t\t\t    \"Their offer: %s\", remote_id, ssh_err(r),\n\t\t\t    ssh->kex->failed_choice);\n\t\t}\n\t\t \n\tdefault:\n\t\tif (vasprintf(&tag, fmt, ap) == -1) {\n\t\t\tssh_packet_clear_keys(ssh);\n\t\t\tlogdie_f(\"could not allocate failure message\");\n\t\t}\n\t\tssh_packet_clear_keys(ssh);\n\t\terrno = oerrno;\n\t\tlogdie_r(r, \"%s%sConnection %s %s\",\n\t\t    tag != NULL ? tag : \"\", tag != NULL ? \": \" : \"\",\n\t\t    ssh->state->server_side ? \"from\" : \"to\", remote_id);\n\t}\n}\n\nvoid\nsshpkt_fatal(struct ssh *ssh, int r, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tsshpkt_vfatal(ssh, r, fmt, ap);\n\t \n\tva_end(ap);\n\tlogdie_f(\"should have exited\");\n}\n\n \nvoid\nssh_packet_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024], remote_id[512];\n\tva_list args;\n\tstatic int disconnecting = 0;\n\tint r;\n\n\tif (disconnecting)\t \n\t\tfatal(\"packet_disconnect called recursively.\");\n\tdisconnecting = 1;\n\n\t \n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\t \n\tlogit(\"Disconnecting %s: %.100s\", remote_id, buf);\n\n\t \n\tif ((r = sshpkt_disconnect(ssh, \"%s\", buf)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s\", __func__);\n\n\tif ((r = ssh_packet_write_wait(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s\", __func__);\n\n\t \n\tssh_packet_close(ssh);\n\tcleanup_exit(255);\n}\n\n \nint\nssh_packet_write_poll(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tint len = sshbuf_len(state->output);\n\tint r;\n\n\tif (len > 0) {\n\t\tlen = write(state->connection_out,\n\t\t    sshbuf_ptr(state->output), len);\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN ||\n\t\t\t    errno == EWOULDBLOCK)\n\t\t\t\treturn 0;\n\t\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t\t}\n\t\tif (len == 0)\n\t\t\treturn SSH_ERR_CONN_CLOSED;\n\t\tif ((r = sshbuf_consume(state->output, len)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nint\nssh_packet_write_wait(struct ssh *ssh)\n{\n\tint ret, r, ms_remain = 0;\n\tstruct timeval start;\n\tstruct timespec timespec, *timespecp = NULL;\n\tstruct session_state *state = ssh->state;\n\tstruct pollfd pfd;\n\n\tif ((r = ssh_packet_write_poll(ssh)) != 0)\n\t\treturn r;\n\twhile (ssh_packet_have_data_to_write(ssh)) {\n\t\tpfd.fd = state->connection_out;\n\t\tpfd.events = POLLOUT;\n\n\t\tif (state->packet_timeout_ms > 0) {\n\t\t\tms_remain = state->packet_timeout_ms;\n\t\t\ttimespecp = &timespec;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (state->packet_timeout_ms > 0) {\n\t\t\t\tms_to_timespec(&timespec, ms_remain);\n\t\t\t\tmonotime_tv(&start);\n\t\t\t}\n\t\t\tif ((ret = ppoll(&pfd, 1, timespecp, NULL)) >= 0)\n\t\t\t\tbreak;\n\t\t\tif (errno != EAGAIN && errno != EINTR &&\n\t\t\t    errno != EWOULDBLOCK)\n\t\t\t\tbreak;\n\t\t\tif (state->packet_timeout_ms <= 0)\n\t\t\t\tcontinue;\n\t\t\tms_subtract_diff(&start, &ms_remain);\n\t\t\tif (ms_remain <= 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == 0)\n\t\t\treturn SSH_ERR_CONN_TIMEOUT;\n\t\tif ((r = ssh_packet_write_poll(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \n\nint\nssh_packet_have_data_to_write(struct ssh *ssh)\n{\n\treturn sshbuf_len(ssh->state->output) != 0;\n}\n\n \n\nint\nssh_packet_not_very_much_data_to_write(struct ssh *ssh)\n{\n\tif (ssh->state->interactive_mode)\n\t\treturn sshbuf_len(ssh->state->output) < 16384;\n\telse\n\t\treturn sshbuf_len(ssh->state->output) < 128 * 1024;\n}\n\n \n\nint\nssh_packet_interactive_data_to_write(struct ssh *ssh)\n{\n\treturn ssh->state->interactive_mode &&\n\t    sshbuf_len(ssh->state->output) < 256;\n}\n\nvoid\nssh_packet_set_tos(struct ssh *ssh, int tos)\n{\n\tif (!ssh_packet_connection_is_on_socket(ssh) || tos == INT_MAX)\n\t\treturn;\n\tset_sock_tos(ssh->state->connection_in, tos);\n}\n\n \n\nvoid\nssh_packet_set_interactive(struct ssh *ssh, int interactive, int qos_interactive, int qos_bulk)\n{\n\tstruct session_state *state = ssh->state;\n\n\tif (state->set_interactive_called)\n\t\treturn;\n\tstate->set_interactive_called = 1;\n\n\t \n\tstate->interactive_mode = interactive;\n\n\t \n\tif (!ssh_packet_connection_is_on_socket(ssh))\n\t\treturn;\n\tset_nodelay(state->connection_in);\n\tssh_packet_set_tos(ssh, interactive ? qos_interactive : qos_bulk);\n}\n\n \n\nint\nssh_packet_is_interactive(struct ssh *ssh)\n{\n\treturn ssh->state->interactive_mode;\n}\n\nint\nssh_packet_set_maxsize(struct ssh *ssh, u_int s)\n{\n\tstruct session_state *state = ssh->state;\n\n\tif (state->set_maxsize_called) {\n\t\tlogit_f(\"called twice: old %d new %d\",\n\t\t    state->max_packet_size, s);\n\t\treturn -1;\n\t}\n\tif (s < 4 * 1024 || s > 1024 * 1024) {\n\t\tlogit_f(\"bad size %d\", s);\n\t\treturn -1;\n\t}\n\tstate->set_maxsize_called = 1;\n\tdebug_f(\"setting to %d\", s);\n\tstate->max_packet_size = s;\n\treturn s;\n}\n\nint\nssh_packet_inc_alive_timeouts(struct ssh *ssh)\n{\n\treturn ++ssh->state->keep_alive_timeouts;\n}\n\nvoid\nssh_packet_set_alive_timeouts(struct ssh *ssh, int ka)\n{\n\tssh->state->keep_alive_timeouts = ka;\n}\n\nu_int\nssh_packet_get_maxsize(struct ssh *ssh)\n{\n\treturn ssh->state->max_packet_size;\n}\n\nvoid\nssh_packet_set_rekey_limits(struct ssh *ssh, u_int64_t bytes, u_int32_t seconds)\n{\n\tdebug3(\"rekey after %llu bytes, %u seconds\", (unsigned long long)bytes,\n\t    (unsigned int)seconds);\n\tssh->state->rekey_limit = bytes;\n\tssh->state->rekey_interval = seconds;\n}\n\ntime_t\nssh_packet_get_rekey_timeout(struct ssh *ssh)\n{\n\ttime_t seconds;\n\n\tseconds = ssh->state->rekey_time + ssh->state->rekey_interval -\n\t    monotime();\n\treturn (seconds <= 0 ? 1 : seconds);\n}\n\nvoid\nssh_packet_set_server(struct ssh *ssh)\n{\n\tssh->state->server_side = 1;\n\tssh->kex->server = 1;  \n}\n\nvoid\nssh_packet_set_authenticated(struct ssh *ssh)\n{\n\tssh->state->after_authentication = 1;\n}\n\nvoid *\nssh_packet_get_input(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->input;\n}\n\nvoid *\nssh_packet_get_output(struct ssh *ssh)\n{\n\treturn (void *)ssh->state->output;\n}\n\n \nstatic int\nssh_packet_set_postauth(struct ssh *ssh)\n{\n\tint r;\n\n\tdebug_f(\"called\");\n\t \n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tif ((r = ssh_packet_enable_delayed_compress(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\n \n\n \nstatic int\nkex_to_blob(struct sshbuf *m, struct kex *kex)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(m, kex->we_need)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, kex->hostkey_alg)) != 0 ||\n\t    (r = sshbuf_put_u32(m, kex->hostkey_type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, kex->hostkey_nid)) != 0 ||\n\t    (r = sshbuf_put_u32(m, kex->kex_type)) != 0 ||\n\t    (r = sshbuf_put_u32(m, kex->kex_strict)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, kex->my)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, kex->peer)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, kex->client_version)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, kex->server_version)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, kex->session_id)) != 0 ||\n\t    (r = sshbuf_put_u32(m, kex->flags)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\n \nstatic int\nnewkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n\n \nint\nssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tint r;\n\n\tif ((r = kex_to_blob(m, ssh->kex)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_to_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_put_u32(m, state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_put_u64(m, state->p_read.bytes)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstatic int\nnewkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b = NULL;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey = NULL;\n\tsize_t keylen, ivlen, maclen;\n\tint r;\n\n\tif ((newkey = calloc(1, sizeof(*newkey))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\n\tif ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)\n\t\tgoto out;\n\tif ((enc->cipher = cipher_by_name(enc->name)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = mac_setup(mac, mac->name)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)\n\t\t\tgoto out;\n\t\tif (maclen > mac->key_len) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tmac->key_len = maclen;\n\t}\n\tif ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)\n\t\tgoto out;\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tenc->key_len = keylen;\n\tenc->iv_len = ivlen;\n\tssh->kex->newkeys[mode] = newkey;\n\tnewkey = NULL;\n\tr = 0;\n out:\n\tfree(newkey);\n\tsshbuf_free(b);\n\treturn r;\n}\n\n \nstatic int\nkex_from_blob(struct sshbuf *m, struct kex **kexp)\n{\n\tstruct kex *kex;\n\tint r;\n\n\tif ((kex = kex_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_get_u32(m, &kex->we_need)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &kex->hostkey_alg, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, (u_int *)&kex->hostkey_type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, (u_int *)&kex->hostkey_nid)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &kex->kex_type)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &kex->kex_strict)) != 0 ||\n\t    (r = sshbuf_get_stringb(m, kex->my)) != 0 ||\n\t    (r = sshbuf_get_stringb(m, kex->peer)) != 0 ||\n\t    (r = sshbuf_get_stringb(m, kex->client_version)) != 0 ||\n\t    (r = sshbuf_get_stringb(m, kex->server_version)) != 0 ||\n\t    (r = sshbuf_get_stringb(m, kex->session_id)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &kex->flags)) != 0)\n\t\tgoto out;\n\tkex->server = 1;\n\tkex->done = 1;\n\tr = 0;\n out:\n\tif (r != 0 || kexp == NULL) {\n\t\tkex_free(kex);\n\t\tif (kexp != NULL)\n\t\t\t*kexp = NULL;\n\t} else {\n\t\tkex_free(*kexp);\n\t\t*kexp = kex;\n\t}\n\treturn r;\n}\n\n \nint\nssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *input, *output;\n\tsize_t ilen, olen;\n\tint r;\n\n\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\treturn r;\n\t \n\tstate->rekey_time = monotime();\n\t \n\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\treturn r;\n\n\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n\t\treturn r;\n\n\tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3_f(\"done\");\n\treturn 0;\n}\n\n \n\n \n\nint\nsshpkt_put(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put(ssh->state->outgoing_packet, v, len);\n}\n\nint\nsshpkt_putb(struct ssh *ssh, const struct sshbuf *b)\n{\n\treturn sshbuf_putb(ssh->state->outgoing_packet, b);\n}\n\nint\nsshpkt_put_u8(struct ssh *ssh, u_char val)\n{\n\treturn sshbuf_put_u8(ssh->state->outgoing_packet, val);\n}\n\nint\nsshpkt_put_u32(struct ssh *ssh, u_int32_t val)\n{\n\treturn sshbuf_put_u32(ssh->state->outgoing_packet, val);\n}\n\nint\nsshpkt_put_u64(struct ssh *ssh, u_int64_t val)\n{\n\treturn sshbuf_put_u64(ssh->state->outgoing_packet, val);\n}\n\nint\nsshpkt_put_string(struct ssh *ssh, const void *v, size_t len)\n{\n\treturn sshbuf_put_string(ssh->state->outgoing_packet, v, len);\n}\n\nint\nsshpkt_put_cstring(struct ssh *ssh, const void *v)\n{\n\treturn sshbuf_put_cstring(ssh->state->outgoing_packet, v);\n}\n\nint\nsshpkt_put_stringb(struct ssh *ssh, const struct sshbuf *v)\n{\n\treturn sshbuf_put_stringb(ssh->state->outgoing_packet, v);\n}\n\nint\nsshpkt_getb_froms(struct ssh *ssh, struct sshbuf **valp)\n{\n\treturn sshbuf_froms(ssh->state->incoming_packet, valp);\n}\n\n#ifdef WITH_OPENSSL\n#ifdef OPENSSL_HAS_ECC\nint\nsshpkt_put_ec(struct ssh *ssh, const EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_put_ec(ssh->state->outgoing_packet, v, g);\n}\n#endif  \n\n\nint\nsshpkt_put_bignum2(struct ssh *ssh, const BIGNUM *v)\n{\n\treturn sshbuf_put_bignum2(ssh->state->outgoing_packet, v);\n}\n#endif  \n\n \n\nint\nsshpkt_get(struct ssh *ssh, void *valp, size_t len)\n{\n\treturn sshbuf_get(ssh->state->incoming_packet, valp, len);\n}\n\nint\nsshpkt_get_u8(struct ssh *ssh, u_char *valp)\n{\n\treturn sshbuf_get_u8(ssh->state->incoming_packet, valp);\n}\n\nint\nsshpkt_get_u32(struct ssh *ssh, u_int32_t *valp)\n{\n\treturn sshbuf_get_u32(ssh->state->incoming_packet, valp);\n}\n\nint\nsshpkt_get_u64(struct ssh *ssh, u_int64_t *valp)\n{\n\treturn sshbuf_get_u64(ssh->state->incoming_packet, valp);\n}\n\nint\nsshpkt_get_string(struct ssh *ssh, u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string(ssh->state->incoming_packet, valp, lenp);\n}\n\nint\nsshpkt_get_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_string_direct(ssh->state->incoming_packet, valp, lenp);\n}\n\nint\nsshpkt_peek_string_direct(struct ssh *ssh, const u_char **valp, size_t *lenp)\n{\n\treturn sshbuf_peek_string_direct(ssh->state->incoming_packet, valp, lenp);\n}\n\nint\nsshpkt_get_cstring(struct ssh *ssh, char **valp, size_t *lenp)\n{\n\treturn sshbuf_get_cstring(ssh->state->incoming_packet, valp, lenp);\n}\n\n#ifdef WITH_OPENSSL\n#ifdef OPENSSL_HAS_ECC\nint\nsshpkt_get_ec(struct ssh *ssh, EC_POINT *v, const EC_GROUP *g)\n{\n\treturn sshbuf_get_ec(ssh->state->incoming_packet, v, g);\n}\n#endif  \n\nint\nsshpkt_get_bignum2(struct ssh *ssh, BIGNUM **valp)\n{\n\treturn sshbuf_get_bignum2(ssh->state->incoming_packet, valp);\n}\n#endif  \n\nint\nsshpkt_get_end(struct ssh *ssh)\n{\n\tif (sshbuf_len(ssh->state->incoming_packet) > 0)\n\t\treturn SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\treturn 0;\n}\n\nconst u_char *\nsshpkt_ptr(struct ssh *ssh, size_t *lenp)\n{\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(ssh->state->incoming_packet);\n\treturn sshbuf_ptr(ssh->state->incoming_packet);\n}\n\n \n\nint\nsshpkt_start(struct ssh *ssh, u_char type)\n{\n\tu_char buf[6];  \n\n\tDBG(debug(\"packet_start[%d]\", type));\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[sizeof(buf) - 1] = type;\n\tsshbuf_reset(ssh->state->outgoing_packet);\n\treturn sshbuf_put(ssh->state->outgoing_packet, buf, sizeof(buf));\n}\n\nstatic int\nssh_packet_send_mux(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tu_char type, *cp;\n\tsize_t len;\n\tint r;\n\n\tif (ssh->kex)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tlen = sshbuf_len(state->outgoing_packet);\n\tif (len < 6)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tcp = sshbuf_mutable_ptr(state->outgoing_packet);\n\ttype = cp[5];\n\tif (ssh_packet_log_type(type))\n\t\tdebug3_f(\"type %u\", type);\n\t \n\tif (type >= SSH2_MSG_CONNECTION_MIN &&\n\t    type <= SSH2_MSG_CONNECTION_MAX) {\n\t\tPOKE_U32(cp, len - 4);\n\t\tif ((r = sshbuf_putb(state->output,\n\t\t    state->outgoing_packet)) != 0)\n\t\t\treturn r;\n\t\t \n\t}\n\tsshbuf_reset(state->outgoing_packet);\n\treturn 0;\n}\n\n \nint\nsshpkt_msg_ignore(struct ssh *ssh, u_int nbytes)\n{\n\tu_int32_t rnd = 0;\n\tint r;\n\tu_int i;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_IGNORE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, nbytes)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < nbytes; i++) {\n\t\tif (i % 4 == 0)\n\t\t\trnd = arc4random();\n\t\tif ((r = sshpkt_put_u8(ssh, (u_char)rnd & 0xff)) != 0)\n\t\t\treturn r;\n\t\trnd >>= 8;\n\t}\n\treturn 0;\n}\n\n \n\nint\nsshpkt_send(struct ssh *ssh)\n{\n\tif (ssh->state && ssh->state->mux)\n\t\treturn ssh_packet_send_mux(ssh);\n\treturn ssh_packet_send2(ssh);\n}\n\nint\nsshpkt_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tdebug2_f(\"sending SSH2_MSG_DISCONNECT: %s\", buf);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_PROTOCOL_ERROR)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\n \nint\nsshpkt_add_padding(struct ssh *ssh, u_char pad)\n{\n\tssh->state->extra_pad = pad;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}