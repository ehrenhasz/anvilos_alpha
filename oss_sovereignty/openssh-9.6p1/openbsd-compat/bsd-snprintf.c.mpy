{
  "module_name": "bsd-snprintf.c",
  "hash_id": "b1fc3b87f50ce449710e32e3cb43d68c945cb0150be569bd297e808306121672",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bsd-snprintf.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#if defined(BROKEN_SNPRINTF)\t\t \n# undef HAVE_SNPRINTF\n# undef HAVE_VSNPRINTF\n#endif\n\n#if !defined(HAVE_SNPRINTF) || !defined(HAVE_VSNPRINTF)\n\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n\n#ifdef HAVE_LONG_DOUBLE\n# define LDOUBLE long double\n#else\n# define LDOUBLE double\n#endif\n\n#ifdef HAVE_LONG_LONG\n# define LLONG long long\n#else\n# define LLONG long\n#endif\n\n \n\n \n#define DP_S_DEFAULT 0\n#define DP_S_FLAGS   1\n#define DP_S_MIN     2\n#define DP_S_DOT     3\n#define DP_S_MAX     4\n#define DP_S_MOD     5\n#define DP_S_CONV    6\n#define DP_S_DONE    7\n\n \n#define DP_F_MINUS\t(1 << 0)\n#define DP_F_PLUS\t(1 << 1)\n#define DP_F_SPACE\t(1 << 2)\n#define DP_F_NUM\t(1 << 3)\n#define DP_F_ZERO\t(1 << 4)\n#define DP_F_UP\t\t(1 << 5)\n#define DP_F_UNSIGNED\t(1 << 6)\n\n \n#define DP_C_SHORT   1\n#define DP_C_LONG    2\n#define DP_C_LDOUBLE 3\n#define DP_C_LLONG   4\n#define DP_C_SIZE    5\n#define DP_C_INTMAX  6\n\n#define char_to_int(p) ((p)- '0')\n#ifndef MAX\n# define MAX(p,q) (((p) >= (q)) ? (p) : (q))\n#endif\n\n#define DOPR_OUTCH(buf, pos, buflen, thechar) \\\n\tdo { \\\n\t\tif (pos + 1 >= INT_MAX) { \\\n\t\t\terrno = ERANGE; \\\n\t\t\treturn -1; \\\n\t\t} \\\n\t\tif (pos < buflen) \\\n\t\t\tbuf[pos] = thechar; \\\n\t\t(pos)++; \\\n\t} while (0)\n\nstatic int dopr(char *buffer, size_t maxlen, const char *format,\n    va_list args_in);\nstatic int fmtstr(char *buffer, size_t *currlen, size_t maxlen,\n    char *value, int flags, int min, int max);\nstatic int fmtint(char *buffer, size_t *currlen, size_t maxlen,\n    intmax_t value, int base, int min, int max, int flags);\nstatic int fmtfp(char *buffer, size_t *currlen, size_t maxlen,\n    LDOUBLE fvalue, int min, int max, int flags);\n\nstatic int\ndopr(char *buffer, size_t maxlen, const char *format, va_list args_in)\n{\n\tchar ch;\n\tintmax_t value;\n\tLDOUBLE fvalue;\n\tchar *strvalue;\n\tint min;\n\tint max;\n\tint state;\n\tint flags;\n\tint cflags;\n\tsize_t currlen;\n\tva_list args;\n\n\tVA_COPY(args, args_in);\n\n\tstate = DP_S_DEFAULT;\n\tcurrlen = flags = cflags = min = 0;\n\tmax = -1;\n\tch = *format++;\n\n\twhile (state != DP_S_DONE) {\n\t\tif (ch == '\\0')\n\t\t\tstate = DP_S_DONE;\n\n\t\tswitch(state) {\n\t\tcase DP_S_DEFAULT:\n\t\t\tif (ch == '%')\n\t\t\t\tstate = DP_S_FLAGS;\n\t\t\telse\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\tch = *format++;\n\t\t\tbreak;\n\t\tcase DP_S_FLAGS:\n\t\t\tswitch (ch) {\n\t\t\tcase '-':\n\t\t\t\tflags |= DP_F_MINUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\t\tflags |= DP_F_PLUS;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\tflags |= DP_F_SPACE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tflags |= DP_F_NUM;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\tflags |= DP_F_ZERO;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = DP_S_MIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MIN:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tmin = 10*min + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmin = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_DOT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_DOT:\n\t\t\tif (ch == '.') {\n\t\t\t\tstate = DP_S_MAX;\n\t\t\t\tch = *format++;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MAX:\n\t\t\tif (isdigit((unsigned char)ch)) {\n\t\t\t\tif (max < 0)\n\t\t\t\t\tmax = 0;\n\t\t\t\tmax = 10*max + char_to_int (ch);\n\t\t\t\tch = *format++;\n\t\t\t} else if (ch == '*') {\n\t\t\t\tmax = va_arg (args, int);\n\t\t\t\tch = *format++;\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t} else {\n\t\t\t\tstate = DP_S_MOD;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_S_MOD:\n\t\t\tswitch (ch) {\n\t\t\tcase 'h':\n\t\t\t\tcflags = DP_C_SHORT;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\tcflags = DP_C_INTMAX;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tcflags = DP_C_LONG;\n\t\t\t\tch = *format++;\n\t\t\t\tif (ch == 'l') {\t \n\t\t\t\t\tcflags = DP_C_LLONG;\n\t\t\t\t\tch = *format++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tcflags = DP_C_LDOUBLE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tcflags = DP_C_SIZE;\n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = DP_S_CONV;\n\t\t\tbreak;\n\t\tcase DP_S_CONV:\n\t\t\tswitch (ch) {\n\t\t\tcase 'd':\n\t\t\tcase 'i':\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = va_arg (args, long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = va_arg (args, LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, ssize_t);\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, intmax_t);\n\t\t\t\telse\n\t\t\t\t\tvalue = va_arg (args, int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    value, 10, min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    8, min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    10, min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'x':\n\t\t\t\tflags |= DP_F_UNSIGNED;\n\t\t\t\tif (cflags == DP_C_SHORT)\n\t\t\t\t\tvalue = va_arg (args, unsigned int);\n\t\t\t\telse if (cflags == DP_C_LONG)\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned long int);\n\t\t\t\telse if (cflags == DP_C_LLONG)\n\t\t\t\t\tvalue = (LLONG)va_arg (args, unsigned LLONG);\n\t\t\t\telse if (cflags == DP_C_SIZE)\n\t\t\t\t\tvalue = va_arg (args, size_t);\n#ifdef notyet\n\t\t\t\telse if (cflags == DP_C_INTMAX)\n\t\t\t\t\tvalue = va_arg (args, uintmax_t);\n#endif\n\t\t\t\telse\n\t\t\t\t\tvalue = (long)va_arg (args, unsigned int);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen, value,\n\t\t\t\t    16, min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'e':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tflags |= DP_F_UP;\n\t\t\tcase 'g':\n\t\t\t\tif (cflags == DP_C_LDOUBLE)\n\t\t\t\t\tfvalue = va_arg (args, LDOUBLE);\n\t\t\t\telse\n\t\t\t\t\tfvalue = va_arg (args, double);\n\t\t\t\tif (fmtfp(buffer, &currlen, maxlen, fvalue,\n\t\t\t\t    min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen,\n\t\t\t\t    va_arg (args, int));\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tstrvalue = va_arg (args, char *);\n\t\t\t\tif (!strvalue) strvalue = \"(NULL)\";\n\t\t\t\tif (max == -1) {\n\t\t\t\t\tmax = strlen(strvalue);\n\t\t\t\t}\n\t\t\t\tif (min > 0 && max >= 0 && min > max) max = min;\n\t\t\t\tif (fmtstr(buffer, &currlen, maxlen,\n\t\t\t\t    strvalue, flags, min, max) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tstrvalue = va_arg (args, void *);\n\t\t\t\tif (fmtint(buffer, &currlen, maxlen,\n\t\t\t\t    (long) strvalue, 16, min, max, flags) == -1)\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n#if we_dont_want_this_in_openssh\n\t\t\tcase 'n':\n\t\t\t\tif (cflags == DP_C_SHORT) {\n\t\t\t\t\tshort int *num;\n\t\t\t\t\tnum = va_arg (args, short int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t} else if (cflags == DP_C_LONG) {\n\t\t\t\t\tlong int *num;\n\t\t\t\t\tnum = va_arg (args, long int *);\n\t\t\t\t\t*num = (long int)currlen;\n\t\t\t\t} else if (cflags == DP_C_LLONG) {\n\t\t\t\t\tLLONG *num;\n\t\t\t\t\tnum = va_arg (args, LLONG *);\n\t\t\t\t\t*num = (LLONG)currlen;\n\t\t\t\t} else if (cflags == DP_C_SIZE) {\n\t\t\t\t\tssize_t *num;\n\t\t\t\t\tnum = va_arg (args, ssize_t *);\n\t\t\t\t\t*num = (ssize_t)currlen;\n\t\t\t\t} else if (cflags == DP_C_INTMAX) {\n\t\t\t\t\tintmax_t *num;\n\t\t\t\t\tnum = va_arg (args, intmax_t *);\n\t\t\t\t\t*num = (intmax_t)currlen;\n\t\t\t\t} else {\n\t\t\t\t\tint *num;\n\t\t\t\t\tnum = va_arg (args, int *);\n\t\t\t\t\t*num = currlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tcase '%':\n\t\t\t\tDOPR_OUTCH(buffer, currlen, maxlen, ch);\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\t \n\t\t\t\tch = *format++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch = *format++;\n\t\t\tstate = DP_S_DEFAULT;\n\t\t\tflags = cflags = min = 0;\n\t\t\tmax = -1;\n\t\t\tbreak;\n\t\tcase DP_S_DONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;  \n\t\t}\n\t}\n\tif (maxlen != 0) {\n\t\tif (currlen < maxlen - 1)\n\t\t\tbuffer[currlen] = '\\0';\n\t\telse if (maxlen > 0)\n\t\t\tbuffer[maxlen - 1] = '\\0';\n\t}\n\tva_end(args);\n\treturn currlen < INT_MAX ? (int)currlen : -1;\n fail:\n\tva_end(args);\n\treturn -1;\n}\n\nstatic int\nfmtstr(char *buffer, size_t *currlen, size_t maxlen,\n    char *value, int flags, int min, int max)\n{\n\tint padlen, strln;      \n\tint cnt = 0;\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtstr min=%d max=%d s=[%s]\\n\", min, max, value);\n#endif\n\tif (value == 0) {\n\t\tvalue = \"<NULL>\";\n\t}\n\n\tfor (strln = 0; strln < max && value[strln]; ++strln);  \n\tpadlen = min - strln;\n\tif (padlen < 0)\n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS)\n\t\tpadlen = -padlen;  \n\n\twhile ((padlen > 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t\t++cnt;\n\t}\n\twhile (*value && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, *value);\n\t\tvalue++;\n\t\t++cnt;\n\t}\n\twhile ((padlen < 0) && (cnt < max)) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t\t++cnt;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int\nfmtint(char *buffer, size_t *currlen, size_t maxlen,\n    intmax_t value, int base, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tunsigned LLONG uvalue;\n\tchar convert[20];\n\tint place = 0;\n\tint spadlen = 0;  \n\tint zpadlen = 0;  \n\tint caps = 0;\n\n\tif (max < 0)\n\t\tmax = 0;\n\n\tuvalue = value;\n\n\tif(!(flags & DP_F_UNSIGNED)) {\n\t\tif( value < 0 ) {\n\t\t\tsignvalue = '-';\n\t\t\tuvalue = -value;\n\t\t} else {\n\t\t\tif (flags & DP_F_PLUS)   \n\t\t\t\tsignvalue = '+';\n\t\t\telse if (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n\n\tif (flags & DP_F_UP) caps = 1;  \n\n\tdo {\n\t\tconvert[place++] =\n\t\t\t(caps? \"0123456789ABCDEF\":\"0123456789abcdef\")\n\t\t\t[uvalue % (unsigned)base  ];\n\t\tuvalue = (uvalue / (unsigned)base );\n\t} while(uvalue && (place < 20));\n\tif (place == 20) place--;\n\tconvert[place] = 0;\n\n\tzpadlen = max - place;\n\tspadlen = min - MAX (max, place) - (signvalue ? 1 : 0);\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (spadlen < 0) spadlen = 0;\n\tif (flags & DP_F_ZERO) {\n\t\tzpadlen = MAX(zpadlen, spadlen);\n\t\tspadlen = 0;\n\t}\n\tif (flags & DP_F_MINUS)\n\t\tspadlen = -spadlen;  \n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"zpad: %d, spad: %d, min: %d, max: %d, place: %d\\n\",\n\t    zpadlen, spadlen, min, max, place);\n#endif\n\n\t \n\twhile (spadlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--spadlen;\n\t}\n\n\t \n\tif (signvalue)\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\n\t \n\tif (zpadlen > 0) {\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\t}\n\n\t \n\twhile (place > 0) {\n\t\t--place;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, convert[place]);\n\t}\n\n\t \n\twhile (spadlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++spadlen;\n\t}\n\treturn 0;\n}\n\nstatic LDOUBLE abs_val(LDOUBLE value)\n{\n\tLDOUBLE result = value;\n\n\tif (value < 0)\n\t\tresult = -value;\n\n\treturn result;\n}\n\nstatic LDOUBLE POW10(int val)\n{\n\tLDOUBLE result = 1;\n\n\twhile (val) {\n\t\tresult *= 10;\n\t\tval--;\n\t}\n\n\treturn result;\n}\n\nstatic LLONG ROUND(LDOUBLE value)\n{\n\tLLONG intpart;\n\n\tintpart = (LLONG)value;\n\tvalue = value - intpart;\n\tif (value >= 0.5) intpart++;\n\n\treturn intpart;\n}\n\n \nstatic double my_modf(double x0, double *iptr)\n{\n\tint i;\n\tlong l;\n\tdouble x = x0;\n\tdouble f = 1.0;\n\n\tfor (i=0;i<100;i++) {\n\t\tl = (long)x;\n\t\tif (l <= (x+1) && l >= (x-1)) break;\n\t\tx *= 0.1;\n\t\tf *= 10.0;\n\t}\n\n\tif (i == 100) {\n\t\t \n\t\t(*iptr) = 0;\n\t\treturn 0;\n\t}\n\n\tif (i != 0) {\n\t\tdouble i2;\n\t\tdouble ret;\n\n\t\tret = my_modf(x0-l*f, &i2);\n\t\t(*iptr) = l*f + i2;\n\t\treturn ret;\n\t}\n\n\t(*iptr) = l;\n\treturn x - (*iptr);\n}\n\n\nstatic int\nfmtfp (char *buffer, size_t *currlen, size_t maxlen,\n    LDOUBLE fvalue, int min, int max, int flags)\n{\n\tint signvalue = 0;\n\tdouble ufvalue;\n\tchar iconvert[311];\n\tchar fconvert[311];\n\tint iplace = 0;\n\tint fplace = 0;\n\tint padlen = 0;  \n\tint zpadlen = 0;\n#if 0\n\tint caps = 0;\n#endif\n\tint idx;\n\tdouble intpart;\n\tdouble fracpart;\n\tdouble temp;\n\n\t \n\tif (max < 0)\n\t\tmax = 6;\n\n\tufvalue = abs_val (fvalue);\n\n\tif (fvalue < 0) {\n\t\tsignvalue = '-';\n\t} else {\n\t\tif (flags & DP_F_PLUS) {  \n\t\t\tsignvalue = '+';\n\t\t} else {\n\t\t\tif (flags & DP_F_SPACE)\n\t\t\t\tsignvalue = ' ';\n\t\t}\n\t}\n\n#if 0\n\tif (flags & DP_F_UP) caps = 1;  \n#endif\n\n#if 0\n\t if (max == 0) ufvalue += 0.5;  \n#endif\n\n\t \n\tif (max > 16)\n\t\tmax = 16;\n\n\t \n\n\ttemp = ufvalue;\n\tmy_modf(temp, &intpart);\n\n\tfracpart = ROUND((POW10(max)) * (ufvalue - intpart));\n\n\tif (fracpart >= POW10(max)) {\n\t\tintpart++;\n\t\tfracpart -= POW10(max);\n\t}\n\n\t \n\tdo {\n\t\ttemp = intpart*0.1;\n\t\tmy_modf(temp, &intpart);\n\t\tidx = (int) ((temp -intpart +0.05)* 10.0);\n\t\t \n\t\t \n\t\ticonvert[iplace++] = \"0123456789\"[idx];\n\t} while (intpart && (iplace < 311));\n\tif (iplace == 311) iplace--;\n\ticonvert[iplace] = 0;\n\n\t \n\tif (fracpart)\n\t{\n\t\tdo {\n\t\t\ttemp = fracpart*0.1;\n\t\t\tmy_modf(temp, &fracpart);\n\t\t\tidx = (int) ((temp -fracpart +0.05)* 10.0);\n\t\t\t \n\t\t\t \n\t\t\tfconvert[fplace++] = \"0123456789\"[idx];\n\t\t} while(fracpart && (fplace < 311));\n\t\tif (fplace == 311) fplace--;\n\t}\n\tfconvert[fplace] = 0;\n\n\t \n\tpadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\n\tzpadlen = max - fplace;\n\tif (zpadlen < 0) zpadlen = 0;\n\tif (padlen < 0)\n\t\tpadlen = 0;\n\tif (flags & DP_F_MINUS)\n\t\tpadlen = -padlen;  \n\n\tif ((flags & DP_F_ZERO) && (padlen > 0)) {\n\t\tif (signvalue) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\t\t\t--padlen;\n\t\t\tsignvalue = 0;\n\t\t}\n\t\twhile (padlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--padlen;\n\t\t}\n\t}\n\twhile (padlen > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t--padlen;\n\t}\n\tif (signvalue)\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, signvalue);\n\n\twhile (iplace > 0) {\n\t\t--iplace;\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, iconvert[iplace]);\n\t}\n\n#ifdef DEBUG_SNPRINTF\n\tprintf(\"fmtfp: fplace=%d zpadlen=%d\\n\", fplace, zpadlen);\n#endif\n\n\t \n\tif (max > 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '.');\n\n\t\twhile (zpadlen > 0) {\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, '0');\n\t\t\t--zpadlen;\n\t\t}\n\n\t\twhile (fplace > 0) {\n\t\t\t--fplace;\n\t\t\tDOPR_OUTCH(buffer, *currlen, maxlen, fconvert[fplace]);\n\t\t}\n\t}\n\n\twhile (padlen < 0) {\n\t\tDOPR_OUTCH(buffer, *currlen, maxlen, ' ');\n\t\t++padlen;\n\t}\n\treturn 0;\n}\n#endif  \n\n#if !defined(HAVE_VSNPRINTF)\nint\nvsnprintf (char *str, size_t count, const char *fmt, va_list args)\n{\n\treturn dopr(str, count, fmt, args);\n}\n#endif\n\n#if !defined(HAVE_SNPRINTF)\nint\nsnprintf(char *str, size_t count, SNPRINTF_CONST char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}