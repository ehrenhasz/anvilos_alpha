{
  "module_name": "getopt_long.c",
  "hash_id": "7cfd9e846c7d845ffb7612cc3034af565eb8beb5b90facfeb93c11ff1c8d9c7c",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/getopt_long.c",
  "human_readable_source": " \n \n\n \n \n\n \n#include \"includes.h\"\n\n#if !defined(HAVE_GETOPT) || !defined(HAVE_GETOPT_OPTRESET)\n\n \n#define warnx\t\tlogit\n\n#if 0\n#include <err.h>\n#include <getopt.h>\n#endif\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"log.h\"\n\nstruct option {\n\t \n\tconst char *name;\n\t \n\tint has_arg;\n\t \n\tint *flag;\n\t \n\tint val;\n};\n\nint\topterr = 1;\t\t \nint\toptind = 1;\t\t \nint\toptopt = '?';\t\t \nint\toptreset;\t\t \nchar    *optarg;\t\t \n\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n\n#define FLAG_PERMUTE\t0x01\t \n#define FLAG_ALLARGS\t0x02\t \n#define FLAG_LONGONLY\t0x04\t \n\n \n#define\tBADCH\t\t(int)'?'\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tINORDER\t\t(int)1\n\n#define\tEMSG\t\t\"\"\n\nstatic int getopt_internal(int, char * const *, const char *,\n\t\t\t   const struct option *, int *, int);\nstatic int parse_long_options(char * const *, const char *,\n\t\t\t      const struct option *, int *, int);\nstatic int gcd(int, int);\nstatic void permute_args(int, int, int, char * const *);\n\nstatic char *place = EMSG;  \n\n \nstatic int nonopt_start = -1;  \nstatic int nonopt_end = -1;    \n\n \nstatic const char recargchar[] = \"option requires an argument -- %c\";\nstatic const char recargstring[] = \"option requires an argument -- %s\";\nstatic const char ambig[] = \"ambiguous option -- %.*s\";\nstatic const char noarg[] = \"option doesn't take an argument -- %.*s\";\nstatic const char illoptchar[] = \"unknown option -- %c\";\nstatic const char illoptstring[] = \"unknown option -- %s\";\n\n \nstatic int\ngcd(int a, int b)\n{\n\tint c;\n\n\tc = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\n\treturn (b);\n}\n\n \nstatic void\npermute_args(int panonopt_start, int panonopt_end, int opt_end,\n\tchar * const *nargv)\n{\n\tint cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;\n\tchar *swap;\n\n\t \n\tnnonopts = panonopt_end - panonopt_start;\n\tnopts = opt_end - panonopt_end;\n\tncycle = gcd(nnonopts, nopts);\n\tcyclelen = (opt_end - panonopt_start) / ncycle;\n\n\tfor (i = 0; i < ncycle; i++) {\n\t\tcstart = panonopt_end+i;\n\t\tpos = cstart;\n\t\tfor (j = 0; j < cyclelen; j++) {\n\t\t\tif (pos >= panonopt_end)\n\t\t\t\tpos -= nnonopts;\n\t\t\telse\n\t\t\t\tpos += nopts;\n\t\t\tswap = nargv[pos];\n\t\t\t \n\t\t\t((char **) nargv)[pos] = nargv[cstart];\n\t\t\t \n\t\t\t((char **)nargv)[cstart] = swap;\n\t\t}\n\t}\n}\n\n \nstatic int\nparse_long_options(char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int short_too)\n{\n\tchar *current_argv, *has_equal;\n\tsize_t current_argv_len;\n\tint i, match;\n\n\tcurrent_argv = place;\n\tmatch = -1;\n\n\toptind++;\n\n\tif ((has_equal = strchr(current_argv, '=')) != NULL) {\n\t\t \n\t\tcurrent_argv_len = has_equal - current_argv;\n\t\thas_equal++;\n\t} else\n\t\tcurrent_argv_len = strlen(current_argv);\n\n\tfor (i = 0; long_options[i].name; i++) {\n\t\t \n\t\tif (strncmp(current_argv, long_options[i].name,\n\t\t    current_argv_len))\n\t\t\tcontinue;\n\n\t\tif (strlen(long_options[i].name) == current_argv_len) {\n\t\t\t \n\t\t\tmatch = i;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (short_too && current_argv_len == 1)\n\t\t\tcontinue;\n\n\t\tif (match == -1)\t \n\t\t\tmatch = i;\n\t\telse {\n\t\t\t \n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(ambig, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\toptopt = 0;\n\t\t\treturn (BADCH);\n\t\t}\n\t}\n\tif (match != -1) {\t\t \n\t\tif (long_options[match].has_arg == no_argument\n\t\t    && has_equal) {\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(noarg, (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\t \n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\treturn (BADARG);\n\t\t}\n\t\tif (long_options[match].has_arg == required_argument ||\n\t\t    long_options[match].has_arg == optional_argument) {\n\t\t\tif (has_equal)\n\t\t\t\toptarg = has_equal;\n\t\t\telse if (long_options[match].has_arg ==\n\t\t\t    required_argument) {\n\t\t\t\t \n\t\t\t\toptarg = nargv[optind++];\n\t\t\t}\n\t\t}\n\t\tif ((long_options[match].has_arg == required_argument)\n\t\t    && (optarg == NULL)) {\n\t\t\t \n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargstring,\n\t\t\t\t    current_argv);\n\t\t\t \n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\t--optind;\n\t\t\treturn (BADARG);\n\t\t}\n\t} else {\t\t\t \n\t\tif (short_too) {\n\t\t\t--optind;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptstring, current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (idx)\n\t\t*idx = match;\n\tif (long_options[match].flag) {\n\t\t*long_options[match].flag = long_options[match].val;\n\t\treturn (0);\n\t} else\n\t\treturn (long_options[match].val);\n}\n\n \nstatic int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t \n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t \n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t \n\tif (posixly_correct == -1 || optreset)\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t \n\t\toptreset = 0;\n\t\tif (optind >= nargc) {           \n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t \n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t \n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n\t\t\tplace = EMSG;\t\t \n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t \n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t \n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t \n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t \n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t \n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t \n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t \n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n\t\tif (*place == '-')\n\t\t\tplace++;\t\t \n\t\telse if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t \n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t \n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t \n\t\tif (*place)\t\t\t \n\t\t\t ;\n\t\telse if (++optind >= nargc) {\t \n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t \n\t\t\tplace = nargv[optind];\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t \n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t \n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t \n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t \n\t\t\tif (++optind >= nargc) {\t \n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t \n\treturn (optchar);\n}\n\n \nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t \n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}\n\n#if 0\n \nint\ngetopt_long(int nargc, char * const *nargv, const char *options,\n    const struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE));\n}\n\n \nint\ngetopt_long_only(int nargc, char * const *nargv, const char *options,\n    const struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE|FLAG_LONGONLY));\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}