{
  "module_name": "port-net.c",
  "hash_id": "010bb09204a95f90f6ca51b9ddf80e6becf59b9a4ab1b4c53e671f8b92f8ed53",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/port-net.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"channels.h\"\n#include \"ssherr.h\"\n\n \n\n#if defined(SYS_RDOMAIN_LINUX) || defined(SSH_TUN_LINUX)\n#include <linux/if.h>\n#endif\n\n#if defined(SYS_RDOMAIN_LINUX)\nchar *\nsys_get_rdomain(int fd)\n{\n\tchar dev[IFNAMSIZ + 1];\n\tsocklen_t len = sizeof(dev) - 1;\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, dev, &len) == -1) {\n\t\terror(\"%s: cannot determine VRF for fd=%d : %s\",\n\t\t    __func__, fd, strerror(errno));\n\t\treturn NULL;\n\t}\n\tdev[len] = '\\0';\n\treturn strdup(dev);\n}\n\nint\nsys_set_rdomain(int fd, const char *name)\n{\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\terror(\"%s: setsockopt(%d, SO_BINDTODEVICE, %s): %s\",\n\t\t    __func__, fd, name, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint\nsys_valid_rdomain(const char *name)\n{\n\tint fd;\n\n\t \n\tif ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)\n\t\treturn 0;\n\tif (setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t    name, strlen(name)) == -1) {\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\tclose(fd);\n\treturn 1;\n}\n#elif defined(SYS_RDOMAIN_XXX)\n \nchar *\nsys_get_rdomain(int fd)\n{\n\treturn NULL;\n}\n\nint\nsys_set_rdomain(int fd, const char *name)\n{\n\treturn -1;\n}\n\nint\nvalid_rdomain(const char *name)\n{\n\treturn 0;\n}\n\nvoid\nsys_set_process_rdomain(const char *name)\n{\n\tfatal(\"%s: not supported\", __func__);\n}\n#endif  \n\n \n\n \n\n#if defined(SSH_TUN_LINUX)\n#include <linux/if_tun.h>\n#define TUN_CTRL_DEV \"/dev/net/tun\"\n\nint\nsys_tun_open(int tun, int mode, char **ifname)\n{\n\tstruct ifreq ifr;\n\tint fd = -1;\n\tconst char *name = NULL;\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\tif ((fd = open(TUN_CTRL_DEV, O_RDWR)) == -1) {\n\t\tdebug(\"%s: failed to open tunnel control device \\\"%s\\\": %s\",\n\t\t    __func__, TUN_CTRL_DEV, strerror(errno));\n\t\treturn (-1);\n\t}\n\n\tbzero(&ifr, sizeof(ifr));\n\n\tif (mode == SSH_TUNMODE_ETHERNET) {\n\t\tifr.ifr_flags = IFF_TAP;\n\t\tname = \"tap%d\";\n\t} else {\n\t\tifr.ifr_flags = IFF_TUN;\n\t\tname = \"tun%d\";\n\t}\n\tifr.ifr_flags |= IFF_NO_PI;\n\n\tif (tun != SSH_TUNID_ANY) {\n\t\tif (tun > SSH_TUNID_MAX) {\n\t\t\tdebug(\"%s: invalid tunnel id %x: %s\", __func__,\n\t\t\t    tun, strerror(errno));\n\t\t\tgoto failed;\n\t\t}\n\t\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), name, tun);\n\t}\n\n\tif (ioctl(fd, TUNSETIFF, &ifr) == -1) {\n\t\tdebug(\"%s: failed to configure tunnel (mode %d): %s\", __func__,\n\t\t    mode, strerror(errno));\n\t\tgoto failed;\n\t}\n\n\tif (tun == SSH_TUNID_ANY)\n\t\tdebug(\"%s: tunnel mode %d fd %d\", __func__, mode, fd);\n\telse\n\t\tdebug(\"%s: %s mode %d fd %d\", __func__, ifr.ifr_name, mode, fd);\n\n\tif (ifname != NULL && (*ifname = strdup(ifr.ifr_name)) == NULL)\n\t\tgoto failed;\n\n\treturn (fd);\n\n failed:\n\tclose(fd);\n\treturn (-1);\n}\n#endif  \n\n#ifdef SSH_TUN_FREEBSD\n#include <sys/socket.h>\n#include <net/if.h>\n\n#ifdef HAVE_NET_IF_TUN_H\n#include <net/if_tun.h>\n#endif\n\nint\nsys_tun_open(int tun, int mode, char **ifname)\n{\n\tstruct ifreq ifr;\n\tchar name[100];\n\tint fd = -1, sock;\n\tconst char *tunbase = \"tun\";\n#if defined(TUNSIFHEAD) && !defined(SSH_TUN_PREPEND_AF)\n\tint flag;\n#endif\n\n\tif (ifname != NULL)\n\t\t*ifname = NULL;\n\n\tif (mode == SSH_TUNMODE_ETHERNET) {\n#ifdef SSH_TUN_NO_L2\n\t\tdebug(\"%s: no layer 2 tunnelling support\", __func__);\n\t\treturn (-1);\n#else\n\t\ttunbase = \"tap\";\n#endif\n\t}\n\n\t \n\tif (tun <= SSH_TUNID_MAX) {\n\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\", tunbase, tun);\n\t\tfd = open(name, O_RDWR);\n\t} else if (tun == SSH_TUNID_ANY) {\n\t\tfor (tun = 100; tun >= 0; tun--) {\n\t\t\tsnprintf(name, sizeof(name), \"/dev/%s%d\",\n\t\t\t    tunbase, tun);\n\t\t\tif ((fd = open(name, O_RDWR)) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdebug(\"%s: invalid tunnel %u\\n\", __func__, tun);\n\t\treturn (-1);\n\t}\n\n\tif (fd < 0) {\n\t\tdebug(\"%s: %s open failed: %s\", __func__, name,\n\t\t    strerror(errno));\n\t\treturn (-1);\n\t}\n\n\t \n#if defined(TUNSIFHEAD) && !defined(SSH_TUN_PREPEND_AF)\n\tflag = 1;\n\tif (mode != SSH_TUNMODE_ETHERNET &&\n\t    ioctl(fd, TUNSIFHEAD, &flag) == -1) {\n\t\tdebug(\"%s: ioctl(%d, TUNSIFHEAD, 1): %s\", __func__, fd,\n\t\t    strerror(errno));\n\t\tclose(fd);\n\t}\n#endif\n\n\tdebug(\"%s: %s mode %d fd %d\", __func__, name, mode, fd);\n\n\t \n\tsnprintf(ifr.ifr_name, sizeof(ifr.ifr_name), \"%s%d\", tunbase, tun);\n\tif ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n\t\tgoto failed;\n\n\tif (ioctl(sock, SIOCGIFFLAGS, &ifr) == -1)\n\t\tgoto failed;\n\tif ((ifr.ifr_flags & IFF_UP) == 0) {\n\t\tifr.ifr_flags |= IFF_UP;\n\t\tif (ioctl(sock, SIOCSIFFLAGS, &ifr) == -1)\n\t\t\tgoto failed;\n\t}\n\n\tif (ifname != NULL && (*ifname = strdup(ifr.ifr_name)) == NULL)\n\t\tgoto failed;\n\n\tclose(sock);\n\treturn (fd);\n\n failed:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tif (sock >= 0)\n\t\tclose(sock);\n\tdebug(\"%s: failed to set %s mode %d: %s\", __func__, name,\n\t    mode, strerror(errno));\n\treturn (-1);\n}\n#endif  \n\n \n\n#if defined(SSH_TUN_FILTER)\n \n#define OPENBSD_AF_INET\t\t2\n#define OPENBSD_AF_INET6\t24\n\nint\nsys_tun_infilter(struct ssh *ssh, struct Channel *c, char *buf, int _len)\n{\n\tint r;\n\tsize_t len;\n\tchar *ptr = buf;\n#if defined(SSH_TUN_PREPEND_AF)\n\tchar rbuf[CHAN_RBUF];\n\tstruct ip iph;\n#endif\n#if defined(SSH_TUN_PREPEND_AF) || defined(SSH_TUN_COMPAT_AF)\n\tu_int32_t af;\n#endif\n\n\t \n\tif (_len < 0)\n\t\treturn -1;\n\tlen = _len;\n\n#if defined(SSH_TUN_PREPEND_AF)\n\tif (len <= sizeof(iph) || len > sizeof(rbuf) - 4)\n\t\treturn -1;\n\t \n\tmemcpy(&iph, buf, sizeof(iph));\n\taf = iph.ip_v == 6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET;\n\t \n\tmemcpy(rbuf + 4, buf, len);\n\tlen += 4;\n\tPOKE_U32(rbuf, af);\n\tptr = rbuf;\n#elif defined(SSH_TUN_COMPAT_AF)\n\t \n\tif (len <= 4)\n\t\treturn -1;\n\taf = PEEK_U32(buf);\n\t \n\tPOKE_U32(buf, af == AF_INET6 ? OPENBSD_AF_INET6 : OPENBSD_AF_INET);\n#endif\n\n\tif ((r = sshbuf_put_string(c->input, ptr, len)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\treturn (0);\n}\n\nu_char *\nsys_tun_outfilter(struct ssh *ssh, struct Channel *c,\n    u_char **data, size_t *dlen)\n{\n\tu_char *buf;\n\tu_int32_t af;\n\tint r;\n\n\t \n\tif ((r = sshbuf_get_string(c->output, data, dlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (*dlen < sizeof(af))\n\t\treturn (NULL);\n\tbuf = *data;\n\n#if defined(SSH_TUN_PREPEND_AF)\n\t \n\t*dlen -= sizeof(af);\n\tbuf = *data + sizeof(af);\n#elif defined(SSH_TUN_COMPAT_AF)\n\t \n\taf = (PEEK_U32(buf) == OPENBSD_AF_INET6) ? AF_INET6 : AF_INET;\n\tPOKE_U32(buf, af);\n#endif\n\treturn (buf);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}