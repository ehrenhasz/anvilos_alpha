{
  "module_name": "bsd-cygwin_util.c",
  "hash_id": "1284efe7e9dfd4ace6864fef854654dacd911d4d1f67a051b6ce4ebaf7f660b6",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bsd-cygwin_util.c",
  "human_readable_source": " \n\n#define NO_BINARY_OPEN\t \n#include \"includes.h\"\n\n#ifdef HAVE_CYGWIN\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <wctype.h>\n\n#include \"xmalloc.h\"\n\nint\nbinary_open(const char *filename, int flags, ...)\n{\n\tva_list ap;\n\tmode_t mode;\n\n\tva_start(ap, flags);\n\tmode = va_arg(ap, mode_t);\n\tva_end(ap);\n\treturn (open(filename, flags | O_BINARY, mode));\n}\n\nint\ncheck_ntsec(const char *filename)\n{\n\treturn (pathconf(filename, _PC_POSIX_PERMISSIONS));\n}\n\nconst char *\ncygwin_ssh_privsep_user()\n{\n  static char cyg_privsep_user[DNLEN + UNLEN + 2];\n\n  if (!cyg_privsep_user[0])\n    {\n#ifdef CW_CYGNAME_FROM_WINNAME\n      if (cygwin_internal (CW_CYGNAME_FROM_WINNAME, \"sshd\", cyg_privsep_user,\n\t\t\t   sizeof cyg_privsep_user) != 0)\n#endif\n\tstrlcpy(cyg_privsep_user, \"sshd\", sizeof(cyg_privsep_user));\n    }\n  return cyg_privsep_user;\n}\n\n#define NL(x) x, (sizeof (x) - 1)\n#define WENV_SIZ (sizeof (wenv_arr) / sizeof (wenv_arr[0]))\n\nstatic struct wenv {\n\tconst char *name;\n\tsize_t namelen;\n} wenv_arr[] = {\n\t{ NL(\"ALLUSERSPROFILE=\") },\n\t{ NL(\"COMPUTERNAME=\") },\n\t{ NL(\"COMSPEC=\") },\n\t{ NL(\"CYGWIN=\") },\n\t{ NL(\"OS=\") },\n\t{ NL(\"PATH=\") },\n\t{ NL(\"PATHEXT=\") },\n\t{ NL(\"PROGRAMFILES=\") },\n\t{ NL(\"SYSTEMDRIVE=\") },\n\t{ NL(\"SYSTEMROOT=\") },\n\t{ NL(\"WINDIR=\") }\n};\n\nchar **\nfetch_windows_environment(void)\n{\n\tchar **e, **p;\n\tunsigned int i, idx = 0;\n\n\tp = xcalloc(WENV_SIZ + 1, sizeof(char *));\n\tfor (e = environ; *e != NULL; ++e) {\n\t\tfor (i = 0; i < WENV_SIZ; ++i) {\n\t\t\tif (!strncmp(*e, wenv_arr[i].name, wenv_arr[i].namelen))\n\t\t\t\tp[idx++] = *e;\n\t\t}\n\t}\n\tp[idx] = NULL;\n\treturn p;\n}\n\nvoid\nfree_windows_environment(char **p)\n{\n\tfree(p);\n}\n\n \n\nstatic int\n__match_pattern (const wchar_t *s, const wchar_t *pattern)\n{\n\tfor (;;) {\n\t\t \n\t\tif (!*pattern)\n\t\t\treturn !*s;\n\n\t\tif (*pattern == '*') {\n\t\t\t \n\t\t\tpattern++;\n\n\t\t\t \n\t\t\tif (!*pattern)\n\t\t\t\treturn 1;\n\n\t\t\t \n\t\t\tif (*pattern != '?' && *pattern != '*') {\n\t\t\t\t \n\t\t\t\tfor (; *s; s++)\n\t\t\t\t\tif (*s == *pattern &&\n\t\t\t\t\t    __match_pattern(s + 1, pattern + 1))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tfor (; *s; s++)\n\t\t\t\tif (__match_pattern(s, pattern))\n\t\t\t\t\treturn 1;\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (!*s)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (*pattern != '?' && towlower(*pattern) != towlower(*s))\n\t\t\treturn 0;\n\n\t\t \n\t\ts++;\n\t\tpattern++;\n\t}\n\t \n}\n\nstatic int\n_match_pattern(const char *s, const char *pattern)\n{\n\twchar_t *ws;\n\twchar_t *wpattern;\n\tsize_t len;\n\tint ret;\n\n\tif ((len = mbstowcs(NULL, s, 0)) == (size_t) -1)\n\t\treturn 0;\n\tws = (wchar_t *) xcalloc(len + 1, sizeof (wchar_t));\n\tmbstowcs(ws, s, len + 1);\n\tif ((len = mbstowcs(NULL, pattern, 0)) == (size_t) -1)\n\t\treturn 0;\n\twpattern = (wchar_t *) xcalloc(len + 1, sizeof (wchar_t));\n\tmbstowcs(wpattern, pattern, len + 1);\n\tret = __match_pattern (ws, wpattern);\n\tfree(ws);\n\tfree(wpattern);\n\treturn ret;\n}\n\n \nint\ncygwin_ug_match_pattern_list(const char *string, const char *pattern)\n{\n\tchar sub[1024];\n\tint negated;\n\tint got_positive;\n\tu_int i, subi, len = strlen(pattern);\n\n\tgot_positive = 0;\n\tfor (i = 0; i < len;) {\n\t\t \n\t\tif (pattern[i] == '!') {\n\t\t\tnegated = 1;\n\t\t\ti++;\n\t\t} else\n\t\t\tnegated = 0;\n\n\t\t \n\t\tfor (subi = 0;\n\t\t    i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n\t\t    subi++, i++)\n\t\t\tsub[subi] = pattern[i];\n\t\t \n\t\tif (subi >= sizeof(sub) - 1)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (i < len && pattern[i] == ',')\n\t\t\ti++;\n\n\t\t \n\t\tsub[subi] = '\\0';\n\n\t\t \n\t\tif (_match_pattern(string, sub)) {\n\t\t\tif (negated)\n\t\t\t\treturn -1;\t\t \n\t\t\telse\n\t\t\t\tgot_positive = 1;\t \n\t\t}\n\t}\n\n\t \n\treturn got_positive;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}