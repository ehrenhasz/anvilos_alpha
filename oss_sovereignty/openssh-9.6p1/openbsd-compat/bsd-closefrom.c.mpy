{
  "module_name": "bsd-closefrom.c",
  "hash_id": "f020147228da9da8798258dc9082e87e1f0636731c9a358297149637a50ef7ef",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bsd-closefrom.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n#if !defined(HAVE_CLOSEFROM) || defined(BROKEN_CLOSEFROM)\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdio.h>\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#endif\n#include <limits.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# ifdef HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# ifdef HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# ifdef HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n#if defined(HAVE_LIBPROC_H)\n# include <libproc.h>\n#endif\n\n#ifndef OPEN_MAX\n# define OPEN_MAX\t256\n#endif\n\n#if 0\n__unused static const char rcsid[] = \"$Sudo: closefrom.c,v 1.11 2006/08/17 15:26:54 millert Exp $\";\n#endif  \n\n#ifndef HAVE_FCNTL_CLOSEM\n \nstatic void\nclosefrom_fallback(int lowfd)\n{\n\tlong fd, maxfd;\n\n\t \n#ifdef HAVE_SYSCONF\n\tmaxfd = sysconf(_SC_OPEN_MAX);\n#else\n\tmaxfd = getdtablesize();\n#endif  \n\tif (maxfd < 0)\n\t\tmaxfd = OPEN_MAX;\n\n\tfor (fd = lowfd; fd < maxfd; fd++)\n\t\t(void) close((int) fd);\n}\n#endif  \n\n#ifdef HAVE_FCNTL_CLOSEM\nvoid\nclosefrom(int lowfd)\n{\n    (void) fcntl(lowfd, F_CLOSEM, 0);\n}\n#elif defined(HAVE_LIBPROC_H) && defined(HAVE_PROC_PIDINFO)\nvoid\nclosefrom(int lowfd)\n{\n\tint i, r, sz;\n\tpid_t pid = getpid();\n\tstruct proc_fdinfo *fdinfo_buf = NULL;\n\n\tsz = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, NULL, 0);\n\tif (sz == 0)\n\t\treturn;  \n\telse if (sz == -1)\n\t\tgoto fallback;\n\tif ((fdinfo_buf = malloc(sz)) == NULL)\n\t\tgoto fallback;\n\tr = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fdinfo_buf, sz);\n\tif (r < 0 || r > sz)\n\t\tgoto fallback;\n\tfor (i = 0; i < r / (int)PROC_PIDLISTFD_SIZE; i++) {\n\t\tif (fdinfo_buf[i].proc_fd >= lowfd)\n\t\t\tclose(fdinfo_buf[i].proc_fd);\n\t}\n\tfree(fdinfo_buf);\n\treturn;\n fallback:\n\tfree(fdinfo_buf);\n\tclosefrom_fallback(lowfd);\n\treturn;\n}\n#elif defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)\nvoid\nclosefrom(int lowfd)\n{\n    long fd;\n    char fdpath[PATH_MAX], *endp;\n    struct dirent *dent;\n    DIR *dirp;\n    int len;\n\n#ifdef HAVE_CLOSE_RANGE\n\tif (close_range(lowfd, INT_MAX, 0) == 0)\n\t\treturn;\n#endif\n\n     \n    len = snprintf(fdpath, sizeof(fdpath), \"/proc/%ld/fd\", (long)getpid());\n    if (len > 0 && (size_t)len < sizeof(fdpath) && (dirp = opendir(fdpath))) {\n\twhile ((dent = readdir(dirp)) != NULL) {\n\t    fd = strtol(dent->d_name, &endp, 10);\n\t    if (dent->d_name != endp && *endp == '\\0' &&\n\t\tfd >= 0 && fd < INT_MAX && fd >= lowfd && fd != dirfd(dirp))\n\t\t(void) close((int) fd);\n\t}\n\t(void) closedir(dirp);\n\treturn;\n    }\n     \n    closefrom_fallback(lowfd);\n}\n#else\nvoid\nclosefrom(int lowfd)\n{\n\tclosefrom_fallback(lowfd);\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}