{
  "module_name": "memmem.c",
  "hash_id": "81f08ba3aa46cfdf0acd8ff8a664cbb992a81ba94d6f3dc39fb6adffb96f3540",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/memmem.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"includes.h\"\n\n#ifndef HAVE_MEMMEM\n\n#include <string.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n\nstatic char *\ntwobyte_memmem(const unsigned char *h, size_t k, const unsigned char *n)\n{\n\tuint16_t nw = n[0]<<8 | n[1], hw = h[0]<<8 | h[1];\n\tfor (h+=2, k-=2; k; k--, hw = hw<<8 | *h++)\n\t\tif (hw == nw) return (char *)h-2;\n\treturn hw == nw ? (char *)h-2 : 0;\n}\n\nstatic char *\nthreebyte_memmem(const unsigned char *h, size_t k, const unsigned char *n)\n{\n\tuint32_t nw = n[0]<<24 | n[1]<<16 | n[2]<<8;\n\tuint32_t hw = h[0]<<24 | h[1]<<16 | h[2]<<8;\n\tfor (h+=3, k-=3; k; k--, hw = (hw|*h++)<<8)\n\t\tif (hw == nw) return (char *)h-3;\n\treturn hw == nw ? (char *)h-3 : 0;\n}\n\nstatic char *\nfourbyte_memmem(const unsigned char *h, size_t k, const unsigned char *n)\n{\n\tuint32_t nw = n[0]<<24 | n[1]<<16 | n[2]<<8 | n[3];\n\tuint32_t hw = h[0]<<24 | h[1]<<16 | h[2]<<8 | h[3];\n\tfor (h+=4, k-=4; k; k--, hw = hw<<8 | *h++)\n\t\tif (hw == nw) return (char *)h-4;\n\treturn hw == nw ? (char *)h-4 : 0;\n}\n\n#if 0\n \n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n\n#define BITOP(a,b,op) \\\n ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))\n\n \nstatic char *\ntwoway_memmem(const unsigned char *h, const unsigned char *z,\n    const unsigned char *n, size_t l)\n{\n\tsize_t i, ip, jp, k, p, ms, p0, mem, mem0;\n\tsize_t byteset[32 / sizeof(size_t)] = { 0 };\n\tsize_t shift[256];\n\n\t \n\tfor (i=0; i<l; i++)\n\t\tBITOP(byteset, n[i], |=), shift[n[i]] = i+1;\n\n\t \n\tip = -1; jp = 0; k = p = 1;\n\twhile (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] > n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n\tms = ip;\n\tp0 = p;\n\n\t \n\tip = -1; jp = 0; k = p = 1;\n\twhile (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] < n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n\tif (ip+1 > ms+1) ms = ip;\n\telse p = p0;\n\n\t \n\tif (memcmp(n, n+p, ms+1)) {\n\t\tmem0 = 0;\n\t\tp = MAX(ms, l-ms-1) + 1;\n\t} else mem0 = l-p;\n\tmem = 0;\n\n\t \n\tfor (;;) {\n\t\t \n\t\tif (z-h < l) return 0;\n\n\t\t \n\t\tif (BITOP(byteset, h[l-1], &)) {\n\t\t\tk = l-shift[h[l-1]];\n\t\t\tif (k) {\n\t\t\t\tif (k < mem) k = mem;\n\t\t\t\th += k;\n\t\t\t\tmem = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\th += l;\n\t\t\tmem = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (k=MAX(ms+1,mem); k<l && n[k] == h[k]; k++);\n\t\tif (k < l) {\n\t\t\th += k-ms;\n\t\t\tmem = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tfor (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\n\t\tif (k <= mem) return (char *)h;\n\t\th += p;\n\t\tmem = mem0;\n\t}\n}\n\nvoid *\nmemmem(const void *h0, size_t k, const void *n0, size_t l)\n{\n\tconst unsigned char *h = h0, *n = n0;\n\n\t \n\tif (!l) return (void *)h;\n\n\t \n\tif (k<l) return 0;\n\n\t \n\th = memchr(h0, *n, k);\n\tif (!h || l==1) return (void *)h;\n\tk -= h - (const unsigned char *)h0;\n\tif (k<l) return 0;\n\tif (l==2) return twobyte_memmem(h, k, n);\n\tif (l==3) return threebyte_memmem(h, k, n);\n\tif (l==4) return fourbyte_memmem(h, k, n);\n\n\treturn twoway_memmem(h, h+k, n, l);\n}\nDEF_WEAK(memmem);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}