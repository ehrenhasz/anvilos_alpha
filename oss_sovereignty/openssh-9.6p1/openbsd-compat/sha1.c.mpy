{
  "module_name": "sha1.c",
  "hash_id": "a4e0202f4ced86159b984bc2f70ea790a5857b038bbcd84b96fda5eb3983c476",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/sha1.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#ifndef WITH_OPENSSL\n\n#include <sys/types.h>\n#include <string.h>\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\n \n#if BYTE_ORDER == LITTLE_ENDIAN\n# define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \\\n    |(rol(block->l[i],8)&0x00FF00FF))\n#else\n# define blk0(i) block->l[i]\n#endif\n#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \\\n    ^block->l[(i+2)&15]^block->l[i&15],1))\n\n \n#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);\n#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);\n#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);\n#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);\n\ntypedef union {\n\tu_int8_t c[64];\n\tu_int32_t l[16];\n} CHAR64LONG16;\n\n \nvoid\nSHA1Transform(u_int32_t state[5], const u_int8_t buffer[SHA1_BLOCK_LENGTH])\n{\n\tu_int32_t a, b, c, d, e;\n\tu_int8_t workspace[SHA1_BLOCK_LENGTH];\n\tCHAR64LONG16 *block = (CHAR64LONG16 *)workspace;\n\n\t(void)memcpy(block, buffer, SHA1_BLOCK_LENGTH);\n\n\t \n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\te = state[4];\n\n\t \n\tR0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);\n\tR0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);\n\tR0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);\n\tR0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);\n\tR1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n\tR2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n\tR2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n\tR2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);\n\tR2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);\n\tR2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);\n\tR3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);\n\tR3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);\n\tR3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);\n\tR3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);\n\tR3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);\n\tR4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);\n\tR4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);\n\tR4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);\n\tR4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);\n\tR4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);\n\n\t \n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n\tstate[4] += e;\n\n\t \n\ta = b = c = d = e = 0;\n}\nDEF_WEAK(SHA1Transform);\n\n\n \nvoid\nSHA1Init(SHA1_CTX *context)\n{\n\n\t \n\tcontext->count = 0;\n\tcontext->state[0] = 0x67452301;\n\tcontext->state[1] = 0xEFCDAB89;\n\tcontext->state[2] = 0x98BADCFE;\n\tcontext->state[3] = 0x10325476;\n\tcontext->state[4] = 0xC3D2E1F0;\n}\nDEF_WEAK(SHA1Init);\n\n\n \nvoid\nSHA1Update(SHA1_CTX *context, const u_int8_t *data, size_t len)\n{\n\tsize_t i, j;\n\n\tj = (size_t)((context->count >> 3) & 63);\n\tcontext->count += ((u_int64_t)len << 3);\n\tif ((j + len) > 63) {\n\t\t(void)memcpy(&context->buffer[j], data, (i = 64-j));\n\t\tSHA1Transform(context->state, context->buffer);\n\t\tfor ( ; i + 63 < len; i += 64)\n\t\t\tSHA1Transform(context->state, (u_int8_t *)&data[i]);\n\t\tj = 0;\n\t} else {\n\t\ti = 0;\n\t}\n\t(void)memcpy(&context->buffer[j], &data[i], len - i);\n}\nDEF_WEAK(SHA1Update);\n\n\n \nvoid\nSHA1Pad(SHA1_CTX *context)\n{\n\tu_int8_t finalcount[8];\n\tu_int i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tfinalcount[i] = (u_int8_t)((context->count >>\n\t\t    ((7 - (i & 7)) * 8)) & 255);\t \n\t}\n\tSHA1Update(context, (u_int8_t *)\"\\200\", 1);\n\twhile ((context->count & 504) != 448)\n\t\tSHA1Update(context, (u_int8_t *)\"\\0\", 1);\n\tSHA1Update(context, finalcount, 8);  \n}\nDEF_WEAK(SHA1Pad);\n\nvoid\nSHA1Final(u_int8_t digest[SHA1_DIGEST_LENGTH], SHA1_CTX *context)\n{\n\tu_int i;\n\n\tSHA1Pad(context);\n\tfor (i = 0; i < SHA1_DIGEST_LENGTH; i++) {\n\t\tdigest[i] = (u_int8_t)\n\t\t   ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);\n\t}\n\texplicit_bzero(context, sizeof(*context));\n}\nDEF_WEAK(SHA1Final);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}