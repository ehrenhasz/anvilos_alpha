{
  "module_name": "sys-tree.h",
  "hash_id": "7527eb18598ecbfcef8d16cd12ddf87dc397784cf0ff5d7953c2ab9860367276",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/sys-tree.h",
  "human_readable_source": " \n \n\n \n\n#include \"config.h\"\n#ifdef NO_ATTRIBUTE_ON_RETURN_TYPE\n# define __attribute__(x)\n#endif\n\n#ifndef\t_SYS_TREE_H_\n#define\t_SYS_TREE_H_\n\n \n\n#define SPLAY_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *sph_root;  \t\t\t\\\n}\n\n#define SPLAY_INITIALIZER(root)\t\t\t\t\t\t\\\n\t{ NULL }\n\n#define SPLAY_INIT(root) do {\t\t\t\t\t\t\\\n\t(root)->sph_root = NULL;\t\t\t\t\t\\\n} while (0)\n\n#define SPLAY_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *spe_left;  \t\t\t\\\n\tstruct type *spe_right;  \t\t\t\\\n}\n\n#define SPLAY_LEFT(elm, field)\t\t(elm)->field.spe_left\n#define SPLAY_RIGHT(elm, field)\t\t(elm)->field.spe_right\n#define SPLAY_ROOT(head)\t\t(head)->sph_root\n#define SPLAY_EMPTY(head)\t\t(SPLAY_ROOT(head) == NULL)\n\n \n#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {\t\t\t\\\n\tSPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);\t\\\n\tSPLAY_RIGHT(tmp, field) = (head)->sph_root;\t\t\t\\\n\t(head)->sph_root = tmp;\t\t\t\t\t\t\\\n} while (0)\n\t\n#define SPLAY_ROTATE_LEFT(head, tmp, field) do {\t\t\t\\\n\tSPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);\t\\\n\tSPLAY_LEFT(tmp, field) = (head)->sph_root;\t\t\t\\\n\t(head)->sph_root = tmp;\t\t\t\t\t\t\\\n} while (0)\n\n#define SPLAY_LINKLEFT(head, tmp, field) do {\t\t\t\t\\\n\tSPLAY_LEFT(tmp, field) = (head)->sph_root;\t\t\t\\\n\ttmp = (head)->sph_root;\t\t\t\t\t\t\\\n\t(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\t\t\\\n} while (0)\n\n#define SPLAY_LINKRIGHT(head, tmp, field) do {\t\t\t\t\\\n\tSPLAY_RIGHT(tmp, field) = (head)->sph_root;\t\t\t\\\n\ttmp = (head)->sph_root;\t\t\t\t\t\t\\\n\t(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\t\\\n} while (0)\n\n#define SPLAY_ASSEMBLE(head, node, left, right, field) do {\t\t\\\n\tSPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);\t\\\n\tSPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);\\\n\tSPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);\t\\\n\tSPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);\t\\\n} while (0)\n\n \n\n#define SPLAY_PROTOTYPE(name, type, field, cmp)\t\t\t\t\\\nvoid name##_SPLAY(struct name *, struct type *);\t\t\t\\\nvoid name##_SPLAY_MINMAX(struct name *, int);\t\t\t\t\\\nstruct type *name##_SPLAY_INSERT(struct name *, struct type *);\t\t\\\nstruct type *name##_SPLAY_REMOVE(struct name *, struct type *);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\\\nstatic __inline struct type *\t\t\t\t\t\t\\\nname##_SPLAY_FIND(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (SPLAY_EMPTY(head))\t\t\t\t\t\t\\\n\t\treturn(NULL);\t\t\t\t\t\t\\\n\tname##_SPLAY(head, elm);\t\t\t\t\t\\\n\tif ((cmp)(elm, (head)->sph_root) == 0)\t\t\t\t\\\n\t\treturn (head->sph_root);\t\t\t\t\\\n\treturn (NULL);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic __inline struct type *\t\t\t\t\t\t\\\nname##_SPLAY_NEXT(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tname##_SPLAY(head, elm);\t\t\t\t\t\\\n\tif (SPLAY_RIGHT(elm, field) != NULL) {\t\t\t\t\\\n\t\telm = SPLAY_RIGHT(elm, field);\t\t\t\t\\\n\t\twhile (SPLAY_LEFT(elm, field) != NULL) {\t\t\\\n\t\t\telm = SPLAY_LEFT(elm, field);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\telm = NULL;\t\t\t\t\t\t\\\n\treturn (elm);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic __inline struct type *\t\t\t\t\t\t\\\nname##_SPLAY_MIN_MAX(struct name *head, int val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tname##_SPLAY_MINMAX(head, val);\t\t\t\t\t\\\n        return (SPLAY_ROOT(head));\t\t\t\t\t\\\n}\n\n \n#define SPLAY_GENERATE(name, type, field, cmp)\t\t\t\t\\\nstruct type *\t\t\t\t\t\t\t\t\\\nname##_SPLAY_INSERT(struct name *head, struct type *elm)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n    if (SPLAY_EMPTY(head)) {\t\t\t\t\t\t\\\n\t    SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;\t\\\n    } else {\t\t\t\t\t\t\t\t\\\n\t    int __comp;\t\t\t\t\t\t\t\\\n\t    name##_SPLAY(head, elm);\t\t\t\t\t\\\n\t    __comp = (cmp)(elm, (head)->sph_root);\t\t\t\\\n\t    if(__comp < 0) {\t\t\t\t\t\t\\\n\t\t    SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);\\\n\t\t    SPLAY_RIGHT(elm, field) = (head)->sph_root;\t\t\\\n\t\t    SPLAY_LEFT((head)->sph_root, field) = NULL;\t\t\\\n\t    } else if (__comp > 0) {\t\t\t\t\t\\\n\t\t    SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);\\\n\t\t    SPLAY_LEFT(elm, field) = (head)->sph_root;\t\t\\\n\t\t    SPLAY_RIGHT((head)->sph_root, field) = NULL;\t\\\n\t    } else\t\t\t\t\t\t\t\\\n\t\t    return ((head)->sph_root);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n    (head)->sph_root = (elm);\t\t\t\t\t\t\\\n    return (NULL);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstruct type *\t\t\t\t\t\t\t\t\\\nname##_SPLAY_REMOVE(struct name *head, struct type *elm)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *__tmp;\t\t\t\t\t\t\\\n\tif (SPLAY_EMPTY(head))\t\t\t\t\t\t\\\n\t\treturn (NULL);\t\t\t\t\t\t\\\n\tname##_SPLAY(head, elm);\t\t\t\t\t\\\n\tif ((cmp)(elm, (head)->sph_root) == 0) {\t\t\t\\\n\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL) {\t\\\n\t\t\t(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\t(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\\\n\t\t\tname##_SPLAY(head, elm);\t\t\t\\\n\t\t\tSPLAY_RIGHT((head)->sph_root, field) = __tmp;\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\treturn (elm);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn (NULL);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid\t\t\t\t\t\t\t\t\t\\\nname##_SPLAY(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\tint __comp;\t\t\t\t\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile ((__comp = (cmp)(elm, (head)->sph_root))) {\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif ((cmp)(elm, __tmp) < 0){\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif ((cmp)(elm, __tmp) > 0){\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\nvoid name##_SPLAY_MINMAX(struct name *head, int __comp) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type __node, *__left, *__right, *__tmp;\t\t\t\\\n\\\n\tSPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\\n\t__left = __right = &__node;\t\t\t\t\t\\\n\\\n\twhile (1) {\t\t\t\t\t\t\t\\\n\t\tif (__comp < 0) {\t\t\t\t\t\\\n\t\t\t__tmp = SPLAY_LEFT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp < 0){\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_RIGHT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_LEFT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKLEFT(head, __right, field);\t\t\\\n\t\t} else if (__comp > 0) {\t\t\t\t\\\n\t\t\t__tmp = SPLAY_RIGHT((head)->sph_root, field);\t\\\n\t\t\tif (__tmp == NULL)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tif (__comp > 0) {\t\t\t\t\\\n\t\t\t\tSPLAY_ROTATE_LEFT(head, __tmp, field);\t\\\n\t\t\t\tif (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\\n\t\t\t\t\tbreak;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tSPLAY_LINKRIGHT(head, __left, field);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSPLAY_ASSEMBLE(head, &__node, __left, __right, field);\t\t\\\n}\n\n#define SPLAY_NEGINF\t-1\n#define SPLAY_INF\t1\n\n#define SPLAY_INSERT(name, x, y)\tname##_SPLAY_INSERT(x, y)\n#define SPLAY_REMOVE(name, x, y)\tname##_SPLAY_REMOVE(x, y)\n#define SPLAY_FIND(name, x, y)\t\tname##_SPLAY_FIND(x, y)\n#define SPLAY_NEXT(name, x, y)\t\tname##_SPLAY_NEXT(x, y)\n#define SPLAY_MIN(name, x)\t\t(SPLAY_EMPTY(x) ? NULL\t\\\n\t\t\t\t\t: name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))\n#define SPLAY_MAX(name, x)\t\t(SPLAY_EMPTY(x) ? NULL\t\\\n\t\t\t\t\t: name##_SPLAY_MIN_MAX(x, SPLAY_INF))\n\n#define SPLAY_FOREACH(x, name, head)\t\t\t\t\t\\\n\tfor ((x) = SPLAY_MIN(name, head);\t\t\t\t\\\n\t     (x) != NULL;\t\t\t\t\t\t\\\n\t     (x) = SPLAY_NEXT(name, head, x))\n\n \n#define RB_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *rbh_root;  \t\t\t\\\n}\n\n#define RB_INITIALIZER(root)\t\t\t\t\t\t\\\n\t{ NULL }\n\n#define RB_INIT(root) do {\t\t\t\t\t\t\\\n\t(root)->rbh_root = NULL;\t\t\t\t\t\\\n} while (0)\n\n#define RB_BLACK\t0\n#define RB_RED\t\t1\n#define RB_ENTRY(type)\t\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *rbe_left;\t\t \t\t\\\n\tstruct type *rbe_right;\t\t \t\t\\\n\tstruct type *rbe_parent;\t \t\t\\\n\tint rbe_color;\t\t\t \t\t\\\n}\n\n#define RB_LEFT(elm, field)\t\t(elm)->field.rbe_left\n#define RB_RIGHT(elm, field)\t\t(elm)->field.rbe_right\n#define RB_PARENT(elm, field)\t\t(elm)->field.rbe_parent\n#define RB_COLOR(elm, field)\t\t(elm)->field.rbe_color\n#define RB_ROOT(head)\t\t\t(head)->rbh_root\n#define RB_EMPTY(head)\t\t\t(RB_ROOT(head) == NULL)\n\n#define RB_SET(elm, parent, field) do {\t\t\t\t\t\\\n\tRB_PARENT(elm, field) = parent;\t\t\t\t\t\\\n\tRB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;\t\t\\\n\tRB_COLOR(elm, field) = RB_RED;\t\t\t\t\t\\\n} while (0)\n\n#define RB_SET_BLACKRED(black, red, field) do {\t\t\t\t\\\n\tRB_COLOR(black, field) = RB_BLACK;\t\t\t\t\\\n\tRB_COLOR(red, field) = RB_RED;\t\t\t\t\t\\\n} while (0)\n\n#ifndef RB_AUGMENT\n#define RB_AUGMENT(x)\tdo {} while (0)\n#endif\n\n#define RB_ROTATE_LEFT(head, elm, tmp, field) do {\t\t\t\\\n\t(tmp) = RB_RIGHT(elm, field);\t\t\t\t\t\\\n\tif ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field))) {\t\t\\\n\t\tRB_PARENT(RB_LEFT(tmp, field), field) = (elm);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tRB_AUGMENT(elm);\t\t\t\t\t\t\\\n\tif ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {\t\t\\\n\t\tif ((elm) == RB_LEFT(RB_PARENT(elm, field), field))\t\\\n\t\t\tRB_LEFT(RB_PARENT(elm, field), field) = (tmp);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tRB_RIGHT(RB_PARENT(elm, field), field) = (tmp);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t(head)->rbh_root = (tmp);\t\t\t\t\\\n\tRB_LEFT(tmp, field) = (elm);\t\t\t\t\t\\\n\tRB_PARENT(elm, field) = (tmp);\t\t\t\t\t\\\n\tRB_AUGMENT(tmp);\t\t\t\t\t\t\\\n\tif ((RB_PARENT(tmp, field)))\t\t\t\t\t\\\n\t\tRB_AUGMENT(RB_PARENT(tmp, field));\t\t\t\\\n} while (0)\n\n#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {\t\t\t\\\n\t(tmp) = RB_LEFT(elm, field);\t\t\t\t\t\\\n\tif ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field))) {\t\t\\\n\t\tRB_PARENT(RB_RIGHT(tmp, field), field) = (elm);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tRB_AUGMENT(elm);\t\t\t\t\t\t\\\n\tif ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {\t\t\\\n\t\tif ((elm) == RB_LEFT(RB_PARENT(elm, field), field))\t\\\n\t\t\tRB_LEFT(RB_PARENT(elm, field), field) = (tmp);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tRB_RIGHT(RB_PARENT(elm, field), field) = (tmp);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t(head)->rbh_root = (tmp);\t\t\t\t\\\n\tRB_RIGHT(tmp, field) = (elm);\t\t\t\t\t\\\n\tRB_PARENT(elm, field) = (tmp);\t\t\t\t\t\\\n\tRB_AUGMENT(tmp);\t\t\t\t\t\t\\\n\tif ((RB_PARENT(tmp, field)))\t\t\t\t\t\\\n\t\tRB_AUGMENT(RB_PARENT(tmp, field));\t\t\t\\\n} while (0)\n\n \n#define\tRB_PROTOTYPE(name, type, field, cmp)\t\t\t\t\\\n\tRB_PROTOTYPE_INTERNAL(name, type, field, cmp,)\n#define\tRB_PROTOTYPE_STATIC(name, type, field, cmp)\t\t\t\\\n\tRB_PROTOTYPE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)\n#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)\t\t\\\nattr void name##_RB_INSERT_COLOR(struct name *, struct type *);\t\t\\\nattr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\\\nattr struct type *name##_RB_REMOVE(struct name *, struct type *);\t\\\nattr struct type *name##_RB_INSERT(struct name *, struct type *);\t\\\nattr struct type *name##_RB_FIND(struct name *, struct type *);\t\t\\\nattr struct type *name##_RB_NFIND(struct name *, struct type *);\t\\\nattr struct type *name##_RB_NEXT(struct type *);\t\t\t\\\nattr struct type *name##_RB_PREV(struct type *);\t\t\t\\\nattr struct type *name##_RB_MINMAX(struct name *, int);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\n \n#define\tRB_GENERATE(name, type, field, cmp)\t\t\t\t\\\n\tRB_GENERATE_INTERNAL(name, type, field, cmp,)\n#define\tRB_GENERATE_STATIC(name, type, field, cmp)\t\t\t\\\n\tRB_GENERATE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)\n#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)\t\t\\\nattr void\t\t\t\t\t\t\t\t\\\nname##_RB_INSERT_COLOR(struct name *head, struct type *elm)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *parent, *gparent, *tmp;\t\t\t\t\\\n\twhile ((parent = RB_PARENT(elm, field)) &&\t\t\t\\\n\t    RB_COLOR(parent, field) == RB_RED) {\t\t\t\\\n\t\tgparent = RB_PARENT(parent, field);\t\t\t\\\n\t\tif (parent == RB_LEFT(gparent, field)) {\t\t\\\n\t\t\ttmp = RB_RIGHT(gparent, field);\t\t\t\\\n\t\t\tif (tmp && RB_COLOR(tmp, field) == RB_RED) {\t\\\n\t\t\t\tRB_COLOR(tmp, field) = RB_BLACK;\t\\\n\t\t\t\tRB_SET_BLACKRED(parent, gparent, field);\\\n\t\t\t\telm = gparent;\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif (RB_RIGHT(parent, field) == elm) {\t\t\\\n\t\t\t\tRB_ROTATE_LEFT(head, parent, tmp, field);\\\n\t\t\t\ttmp = parent;\t\t\t\t\\\n\t\t\t\tparent = elm;\t\t\t\t\\\n\t\t\t\telm = tmp;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tRB_SET_BLACKRED(parent, gparent, field);\t\\\n\t\t\tRB_ROTATE_RIGHT(head, gparent, tmp, field);\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\ttmp = RB_LEFT(gparent, field);\t\t\t\\\n\t\t\tif (tmp && RB_COLOR(tmp, field) == RB_RED) {\t\\\n\t\t\t\tRB_COLOR(tmp, field) = RB_BLACK;\t\\\n\t\t\t\tRB_SET_BLACKRED(parent, gparent, field);\\\n\t\t\t\telm = gparent;\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif (RB_LEFT(parent, field) == elm) {\t\t\\\n\t\t\t\tRB_ROTATE_RIGHT(head, parent, tmp, field);\\\n\t\t\t\ttmp = parent;\t\t\t\t\\\n\t\t\t\tparent = elm;\t\t\t\t\\\n\t\t\t\telm = tmp;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tRB_SET_BLACKRED(parent, gparent, field);\t\\\n\t\t\tRB_ROTATE_LEFT(head, gparent, tmp, field);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tRB_COLOR(head->rbh_root, field) = RB_BLACK;\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nattr void\t\t\t\t\t\t\t\t\\\nname##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *tmp;\t\t\t\t\t\t\\\n\twhile ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&\t\\\n\t    elm != RB_ROOT(head)) {\t\t\t\t\t\\\n\t\tif (RB_LEFT(parent, field) == elm) {\t\t\t\\\n\t\t\ttmp = RB_RIGHT(parent, field);\t\t\t\\\n\t\t\tif (RB_COLOR(tmp, field) == RB_RED) {\t\t\\\n\t\t\t\tRB_SET_BLACKRED(tmp, parent, field);\t\\\n\t\t\t\tRB_ROTATE_LEFT(head, parent, tmp, field);\\\n\t\t\t\ttmp = RB_RIGHT(parent, field);\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif ((RB_LEFT(tmp, field) == NULL ||\t\t\\\n\t\t\t    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\\\n\t\t\t    (RB_RIGHT(tmp, field) == NULL ||\t\t\\\n\t\t\t    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\\\n\t\t\t\tRB_COLOR(tmp, field) = RB_RED;\t\t\\\n\t\t\t\telm = parent;\t\t\t\t\\\n\t\t\t\tparent = RB_PARENT(elm, field);\t\t\\\n\t\t\t} else {\t\t\t\t\t\\\n\t\t\t\tif (RB_RIGHT(tmp, field) == NULL ||\t\\\n\t\t\t\t    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {\\\n\t\t\t\t\tstruct type *oleft;\t\t\\\n\t\t\t\t\tif ((oleft = RB_LEFT(tmp, field)))\\\n\t\t\t\t\t\tRB_COLOR(oleft, field) = RB_BLACK;\\\n\t\t\t\t\tRB_COLOR(tmp, field) = RB_RED;\t\\\n\t\t\t\t\tRB_ROTATE_RIGHT(head, tmp, oleft, field);\\\n\t\t\t\t\ttmp = RB_RIGHT(parent, field);\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\tRB_COLOR(tmp, field) = RB_COLOR(parent, field);\\\n\t\t\t\tRB_COLOR(parent, field) = RB_BLACK;\t\\\n\t\t\t\tif (RB_RIGHT(tmp, field))\t\t\\\n\t\t\t\t\tRB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;\\\n\t\t\t\tRB_ROTATE_LEFT(head, parent, tmp, field);\\\n\t\t\t\telm = RB_ROOT(head);\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\ttmp = RB_LEFT(parent, field);\t\t\t\\\n\t\t\tif (RB_COLOR(tmp, field) == RB_RED) {\t\t\\\n\t\t\t\tRB_SET_BLACKRED(tmp, parent, field);\t\\\n\t\t\t\tRB_ROTATE_RIGHT(head, parent, tmp, field);\\\n\t\t\t\ttmp = RB_LEFT(parent, field);\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif ((RB_LEFT(tmp, field) == NULL ||\t\t\\\n\t\t\t    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\\\n\t\t\t    (RB_RIGHT(tmp, field) == NULL ||\t\t\\\n\t\t\t    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\\\n\t\t\t\tRB_COLOR(tmp, field) = RB_RED;\t\t\\\n\t\t\t\telm = parent;\t\t\t\t\\\n\t\t\t\tparent = RB_PARENT(elm, field);\t\t\\\n\t\t\t} else {\t\t\t\t\t\\\n\t\t\t\tif (RB_LEFT(tmp, field) == NULL ||\t\\\n\t\t\t\t    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {\\\n\t\t\t\t\tstruct type *oright;\t\t\\\n\t\t\t\t\tif ((oright = RB_RIGHT(tmp, field)))\\\n\t\t\t\t\t\tRB_COLOR(oright, field) = RB_BLACK;\\\n\t\t\t\t\tRB_COLOR(tmp, field) = RB_RED;\t\\\n\t\t\t\t\tRB_ROTATE_LEFT(head, tmp, oright, field);\\\n\t\t\t\t\ttmp = RB_LEFT(parent, field);\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t\tRB_COLOR(tmp, field) = RB_COLOR(parent, field);\\\n\t\t\t\tRB_COLOR(parent, field) = RB_BLACK;\t\\\n\t\t\t\tif (RB_LEFT(tmp, field))\t\t\\\n\t\t\t\t\tRB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;\\\n\t\t\t\tRB_ROTATE_RIGHT(head, parent, tmp, field);\\\n\t\t\t\telm = RB_ROOT(head);\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (elm)\t\t\t\t\t\t\t\\\n\t\tRB_COLOR(elm, field) = RB_BLACK;\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_REMOVE(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *child, *parent, *old = elm;\t\t\t\\\n\tint color;\t\t\t\t\t\t\t\\\n\tif (RB_LEFT(elm, field) == NULL)\t\t\t\t\\\n\t\tchild = RB_RIGHT(elm, field);\t\t\t\t\\\n\telse if (RB_RIGHT(elm, field) == NULL)\t\t\t\t\\\n\t\tchild = RB_LEFT(elm, field);\t\t\t\t\\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tstruct type *left;\t\t\t\t\t\\\n\t\telm = RB_RIGHT(elm, field);\t\t\t\t\\\n\t\twhile ((left = RB_LEFT(elm, field)))\t\t\t\\\n\t\t\telm = left;\t\t\t\t\t\\\n\t\tchild = RB_RIGHT(elm, field);\t\t\t\t\\\n\t\tparent = RB_PARENT(elm, field);\t\t\t\t\\\n\t\tcolor = RB_COLOR(elm, field);\t\t\t\t\\\n\t\tif (child)\t\t\t\t\t\t\\\n\t\t\tRB_PARENT(child, field) = parent;\t\t\\\n\t\tif (parent) {\t\t\t\t\t\t\\\n\t\t\tif (RB_LEFT(parent, field) == elm)\t\t\\\n\t\t\t\tRB_LEFT(parent, field) = child;\t\t\\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tRB_RIGHT(parent, field) = child;\t\\\n\t\t\tRB_AUGMENT(parent);\t\t\t\t\\\n\t\t} else\t\t\t\t\t\t\t\\\n\t\t\tRB_ROOT(head) = child;\t\t\t\t\\\n\t\tif (RB_PARENT(elm, field) == old)\t\t\t\\\n\t\t\tparent = elm;\t\t\t\t\t\\\n\t\t(elm)->field = (old)->field;\t\t\t\t\\\n\t\tif (RB_PARENT(old, field)) {\t\t\t\t\\\n\t\t\tif (RB_LEFT(RB_PARENT(old, field), field) == old)\\\n\t\t\t\tRB_LEFT(RB_PARENT(old, field), field) = elm;\\\n\t\t\telse\t\t\t\t\t\t\\\n\t\t\t\tRB_RIGHT(RB_PARENT(old, field), field) = elm;\\\n\t\t\tRB_AUGMENT(RB_PARENT(old, field));\t\t\\\n\t\t} else\t\t\t\t\t\t\t\\\n\t\t\tRB_ROOT(head) = elm;\t\t\t\t\\\n\t\tRB_PARENT(RB_LEFT(old, field), field) = elm;\t\t\\\n\t\tif (RB_RIGHT(old, field))\t\t\t\t\\\n\t\t\tRB_PARENT(RB_RIGHT(old, field), field) = elm;\t\\\n\t\tif (parent) {\t\t\t\t\t\t\\\n\t\t\tleft = parent;\t\t\t\t\t\\\n\t\t\tdo {\t\t\t\t\t\t\\\n\t\t\t\tRB_AUGMENT(left);\t\t\t\\\n\t\t\t} while ((left = RB_PARENT(left, field)));\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tgoto color;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tparent = RB_PARENT(elm, field);\t\t\t\t\t\\\n\tcolor = RB_COLOR(elm, field);\t\t\t\t\t\\\n\tif (child)\t\t\t\t\t\t\t\\\n\t\tRB_PARENT(child, field) = parent;\t\t\t\\\n\tif (parent) {\t\t\t\t\t\t\t\\\n\t\tif (RB_LEFT(parent, field) == elm)\t\t\t\\\n\t\t\tRB_LEFT(parent, field) = child;\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tRB_RIGHT(parent, field) = child;\t\t\\\n\t\tRB_AUGMENT(parent);\t\t\t\t\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\tRB_ROOT(head) = child;\t\t\t\t\t\\\ncolor:\t\t\t\t\t\t\t\t\t\\\n\tif (color == RB_BLACK)\t\t\t\t\t\t\\\n\t\tname##_RB_REMOVE_COLOR(head, parent, child);\t\t\\\n\treturn (old);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_INSERT(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *tmp;\t\t\t\t\t\t\\\n\tstruct type *parent = NULL;\t\t\t\t\t\\\n\tint comp = 0;\t\t\t\t\t\t\t\\\n\ttmp = RB_ROOT(head);\t\t\t\t\t\t\\\n\twhile (tmp) {\t\t\t\t\t\t\t\\\n\t\tparent = tmp;\t\t\t\t\t\t\\\n\t\tcomp = (cmp)(elm, parent);\t\t\t\t\\\n\t\tif (comp < 0)\t\t\t\t\t\t\\\n\t\t\ttmp = RB_LEFT(tmp, field);\t\t\t\\\n\t\telse if (comp > 0)\t\t\t\t\t\\\n\t\t\ttmp = RB_RIGHT(tmp, field);\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\treturn (tmp);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tRB_SET(elm, parent, field);\t\t\t\t\t\\\n\tif (parent != NULL) {\t\t\t\t\t\t\\\n\t\tif (comp < 0)\t\t\t\t\t\t\\\n\t\t\tRB_LEFT(parent, field) = elm;\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tRB_RIGHT(parent, field) = elm;\t\t\t\\\n\t\tRB_AUGMENT(parent);\t\t\t\t\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\tRB_ROOT(head) = elm;\t\t\t\t\t\\\n\tname##_RB_INSERT_COLOR(head, elm);\t\t\t\t\\\n\treturn (NULL);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_FIND(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *tmp = RB_ROOT(head);\t\t\t\t\\\n\tint comp;\t\t\t\t\t\t\t\\\n\twhile (tmp) {\t\t\t\t\t\t\t\\\n\t\tcomp = cmp(elm, tmp);\t\t\t\t\t\\\n\t\tif (comp < 0)\t\t\t\t\t\t\\\n\t\t\ttmp = RB_LEFT(tmp, field);\t\t\t\\\n\t\telse if (comp > 0)\t\t\t\t\t\\\n\t\t\ttmp = RB_RIGHT(tmp, field);\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\treturn (tmp);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn (NULL);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_NFIND(struct name *head, struct type *elm)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *tmp = RB_ROOT(head);\t\t\t\t\\\n\tstruct type *res = NULL;\t\t\t\t\t\\\n\tint comp;\t\t\t\t\t\t\t\\\n\twhile (tmp) {\t\t\t\t\t\t\t\\\n\t\tcomp = cmp(elm, tmp);\t\t\t\t\t\\\n\t\tif (comp < 0) {\t\t\t\t\t\t\\\n\t\t\tres = tmp;\t\t\t\t\t\\\n\t\t\ttmp = RB_LEFT(tmp, field);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\telse if (comp > 0)\t\t\t\t\t\\\n\t\t\ttmp = RB_RIGHT(tmp, field);\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\treturn (tmp);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn (res);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_NEXT(struct type *elm)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (RB_RIGHT(elm, field)) {\t\t\t\t\t\\\n\t\telm = RB_RIGHT(elm, field);\t\t\t\t\\\n\t\twhile (RB_LEFT(elm, field))\t\t\t\t\\\n\t\t\telm = RB_LEFT(elm, field);\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tif (RB_PARENT(elm, field) &&\t\t\t\t\\\n\t\t    (elm == RB_LEFT(RB_PARENT(elm, field), field)))\t\\\n\t\t\telm = RB_PARENT(elm, field);\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\twhile (RB_PARENT(elm, field) &&\t\t\t\\\n\t\t\t    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\\\n\t\t\t\telm = RB_PARENT(elm, field);\t\t\\\n\t\t\telm = RB_PARENT(elm, field);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn (elm);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_PREV(struct type *elm)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (RB_LEFT(elm, field)) {\t\t\t\t\t\\\n\t\telm = RB_LEFT(elm, field);\t\t\t\t\\\n\t\twhile (RB_RIGHT(elm, field))\t\t\t\t\\\n\t\t\telm = RB_RIGHT(elm, field);\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tif (RB_PARENT(elm, field) &&\t\t\t\t\\\n\t\t    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\t\\\n\t\t\telm = RB_PARENT(elm, field);\t\t\t\\\n\t\telse {\t\t\t\t\t\t\t\\\n\t\t\twhile (RB_PARENT(elm, field) &&\t\t\t\\\n\t\t\t    (elm == RB_LEFT(RB_PARENT(elm, field), field)))\\\n\t\t\t\telm = RB_PARENT(elm, field);\t\t\\\n\t\t\telm = RB_PARENT(elm, field);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn (elm);\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nattr struct type *\t\t\t\t\t\t\t\\\nname##_RB_MINMAX(struct name *head, int val)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct type *tmp = RB_ROOT(head);\t\t\t\t\\\n\tstruct type *parent = NULL;\t\t\t\t\t\\\n\twhile (tmp) {\t\t\t\t\t\t\t\\\n\t\tparent = tmp;\t\t\t\t\t\t\\\n\t\tif (val < 0)\t\t\t\t\t\t\\\n\t\t\ttmp = RB_LEFT(tmp, field);\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\ttmp = RB_RIGHT(tmp, field);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn (parent);\t\t\t\t\t\t\\\n}\n\n#define RB_NEGINF\t-1\n#define RB_INF\t1\n\n#define RB_INSERT(name, x, y)\tname##_RB_INSERT(x, y)\n#define RB_REMOVE(name, x, y)\tname##_RB_REMOVE(x, y)\n#define RB_FIND(name, x, y)\tname##_RB_FIND(x, y)\n#define RB_NFIND(name, x, y)\tname##_RB_NFIND(x, y)\n#define RB_NEXT(name, x, y)\tname##_RB_NEXT(y)\n#define RB_PREV(name, x, y)\tname##_RB_PREV(y)\n#define RB_MIN(name, x)\t\tname##_RB_MINMAX(x, RB_NEGINF)\n#define RB_MAX(name, x)\t\tname##_RB_MINMAX(x, RB_INF)\n\n#define RB_FOREACH(x, name, head)\t\t\t\t\t\\\n\tfor ((x) = RB_MIN(name, head);\t\t\t\t\t\\\n\t     (x) != NULL;\t\t\t\t\t\t\\\n\t     (x) = name##_RB_NEXT(x))\n\n#define RB_FOREACH_SAFE(x, name, head, y)\t\t\t\t\\\n\tfor ((x) = RB_MIN(name, head);\t\t\t\t\t\\\n\t    ((x) != NULL) && ((y) = name##_RB_NEXT(x), 1);\t\t\\\n\t     (x) = (y))\n\n#define RB_FOREACH_REVERSE(x, name, head)\t\t\t\t\\\n\tfor ((x) = RB_MAX(name, head);\t\t\t\t\t\\\n\t     (x) != NULL;\t\t\t\t\t\t\\\n\t     (x) = name##_RB_PREV(x))\n\n#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)\t\t\t\\\n\tfor ((x) = RB_MAX(name, head);\t\t\t\t\t\\\n\t    ((x) != NULL) && ((y) = name##_RB_PREV(x), 1);\t\t\\\n\t     (x) = (y))\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}