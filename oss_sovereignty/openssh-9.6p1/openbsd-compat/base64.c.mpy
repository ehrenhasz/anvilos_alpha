{
  "module_name": "base64.c",
  "hash_id": "e1593891ada1973ccb7905cfb0d66aa7e4da455cdf9c2cf9bad863c724f1b012",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/base64.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include \"includes.h\"\n\n#if (!defined(HAVE_B64_NTOP) && !defined(HAVE___B64_NTOP)) || (!defined(HAVE_B64_PTON) && !defined(HAVE___B64_PTON))\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <ctype.h>\n#include <stdio.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"base64.h\"\n\nstatic const char Base64[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nstatic const char Pad64 = '=';\n\n \n\n#if !defined(HAVE_B64_NTOP) && !defined(HAVE___B64_NTOP) \nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize)\n{\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tu_int i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n    \n\t \n\tif (0 != srclength) {\n\t\t \n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\t\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t \n\treturn (datalength);\n}\n#endif  \n\n#if !defined(HAVE_B64_PTON) && !defined(HAVE___B64_PTON)\n\n \n\nint\nb64_pton(char const *src, u_char *target, size_t targsize)\n{\n\tu_int tarindex, state;\n\tint ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t \n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0)\t\t \n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif (tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tif (ch == Pad64) {\t\t \n\t\tch = *src++;\t\t \n\t\tswitch (state) {\n\t\tcase 0:\t\t \n\t\tcase 1:\t\t \n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t \n\t\t\t \n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t \n\t\t\t \n\t\t\t \n\n\t\tcase 3:\t\t \n\t\t\t \n\t\t\tfor (; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t \n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t \n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}\n\n#endif  \n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}