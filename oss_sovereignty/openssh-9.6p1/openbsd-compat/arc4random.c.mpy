{
  "module_name": "arc4random.c",
  "hash_id": "80d2c73e5422eb1d07cf22e769fe977d1fde8a246a585016c50020e0a31dde2f",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/arc4random.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <fcntl.h>\n#include <limits.h>\n#include <signal.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/time.h>\n\n#ifndef HAVE_ARC4RANDOM\n\n \nint _ssh_compat_getentropy(void *, size_t);\n#ifdef getentropy\n# undef getentropy\n#endif\n#define getentropy(x, y) (_ssh_compat_getentropy((x), (y)))\n\n#include \"log.h\"\n\n#define KEYSTREAM_ONLY\n#include \"chacha_private.h\"\n\n#define minimum(a, b) ((a) < (b) ? (a) : (b))\n\n#if defined(__GNUC__) || defined(_MSC_VER)\n#define inline __inline\n#else\t\t\t\t \n#define inline\n#endif\t\t\t\t \n\n#define KEYSZ\t32\n#define IVSZ\t8\n#define BLOCKSZ\t64\n#define RSBUFSZ\t(16*BLOCKSZ)\n\n#define REKEY_BASE\t(1024*1024)  \n\n \nstatic struct _rs {\n\tsize_t\t\trs_have;\t \n\tsize_t\t\trs_count;\t \n} *rs;\n\n \nstatic struct _rsx {\n\tchacha_ctx\trs_chacha;\t \n\tu_char\t\trs_buf[RSBUFSZ];\t \n} *rsx;\n\nstatic inline int _rs_allocate(struct _rs **, struct _rsx **);\nstatic inline void _rs_forkdetect(void);\n#include \"arc4random.h\"\n\nstatic inline void _rs_rekey(u_char *dat, size_t datlen);\n\nstatic inline void\n_rs_init(u_char *buf, size_t n)\n{\n\tif (n < KEYSZ + IVSZ)\n\t\treturn;\n\n\tif (rs == NULL) {\n\t\tif (_rs_allocate(&rs, &rsx) == -1)\n\t\t\t_exit(1);\n\t}\n\n\tchacha_keysetup(&rsx->rs_chacha, buf, KEYSZ * 8);\n\tchacha_ivsetup(&rsx->rs_chacha, buf + KEYSZ);\n}\n\nstatic void\n_rs_stir(void)\n{\n\tu_char rnd[KEYSZ + IVSZ];\n\tuint32_t rekey_fuzz = 0;\n\n\tif (getentropy(rnd, sizeof rnd) == -1)\n\t\t_getentropy_fail();\n\n\tif (!rs)\n\t\t_rs_init(rnd, sizeof(rnd));\n\telse\n\t\t_rs_rekey(rnd, sizeof(rnd));\n\texplicit_bzero(rnd, sizeof(rnd));\t \n\n\t \n\trs->rs_have = 0;\n\tmemset(rsx->rs_buf, 0, sizeof(rsx->rs_buf));\n\n\t \n\tchacha_encrypt_bytes(&rsx->rs_chacha, (uint8_t *)&rekey_fuzz,\n\t    (uint8_t *)&rekey_fuzz, sizeof(rekey_fuzz));\n\trs->rs_count = REKEY_BASE + (rekey_fuzz % REKEY_BASE);\n}\n\nstatic inline void\n_rs_stir_if_needed(size_t len)\n{\n\t_rs_forkdetect();\n\tif (!rs || rs->rs_count <= len)\n\t\t_rs_stir();\n\tif (rs->rs_count <= len)\n\t\trs->rs_count = 0;\n\telse\n\t\trs->rs_count -= len;\n}\n\nstatic inline void\n_rs_rekey(u_char *dat, size_t datlen)\n{\n#ifndef KEYSTREAM_ONLY\n\tmemset(rsx->rs_buf, 0, sizeof(rsx->rs_buf));\n#endif\n\t \n\tchacha_encrypt_bytes(&rsx->rs_chacha, rsx->rs_buf,\n\t    rsx->rs_buf, sizeof(rsx->rs_buf));\n\t \n\tif (dat) {\n\t\tsize_t i, m;\n\n\t\tm = minimum(datlen, KEYSZ + IVSZ);\n\t\tfor (i = 0; i < m; i++)\n\t\t\trsx->rs_buf[i] ^= dat[i];\n\t}\n\t \n\t_rs_init(rsx->rs_buf, KEYSZ + IVSZ);\n\tmemset(rsx->rs_buf, 0, KEYSZ + IVSZ);\n\trs->rs_have = sizeof(rsx->rs_buf) - KEYSZ - IVSZ;\n}\n\nstatic inline void\n_rs_random_buf(void *_buf, size_t n)\n{\n\tu_char *buf = (u_char *)_buf;\n\tu_char *keystream;\n\tsize_t m;\n\n\t_rs_stir_if_needed(n);\n\twhile (n > 0) {\n\t\tif (rs->rs_have > 0) {\n\t\t\tm = minimum(n, rs->rs_have);\n\t\t\tkeystream = rsx->rs_buf + sizeof(rsx->rs_buf)\n\t\t\t    - rs->rs_have;\n\t\t\tmemcpy(buf, keystream, m);\n\t\t\tmemset(keystream, 0, m);\n\t\t\tbuf += m;\n\t\t\tn -= m;\n\t\t\trs->rs_have -= m;\n\t\t}\n\t\tif (rs->rs_have == 0)\n\t\t\t_rs_rekey(NULL, 0);\n\t}\n}\n\nstatic inline void\n_rs_random_u32(uint32_t *val)\n{\n\tu_char *keystream;\n\n\t_rs_stir_if_needed(sizeof(*val));\n\tif (rs->rs_have < sizeof(*val))\n\t\t_rs_rekey(NULL, 0);\n\tkeystream = rsx->rs_buf + sizeof(rsx->rs_buf) - rs->rs_have;\n\tmemcpy(val, keystream, sizeof(*val));\n\tmemset(keystream, 0, sizeof(*val));\n\trs->rs_have -= sizeof(*val);\n}\n\nuint32_t\narc4random(void)\n{\n\tuint32_t val;\n\n\t_ARC4_LOCK();\n\t_rs_random_u32(&val);\n\t_ARC4_UNLOCK();\n\treturn val;\n}\nDEF_WEAK(arc4random);\n\n \n# ifndef HAVE_ARC4RANDOM_BUF\nvoid\narc4random_buf(void *buf, size_t n)\n{\n\t_ARC4_LOCK();\n\t_rs_random_buf(buf, n);\n\t_ARC4_UNLOCK();\n}\nDEF_WEAK(arc4random_buf);\n# endif  \n#endif  \n\n \n#if !defined(HAVE_ARC4RANDOM_BUF) && defined(HAVE_ARC4RANDOM)\nvoid\narc4random_buf(void *_buf, size_t n)\n{\n\tsize_t i;\n\tu_int32_t r = 0;\n\tchar *buf = (char *)_buf;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tr = arc4random();\n\t\tbuf[i] = r & 0xff;\n\t\tr >>= 8;\n\t}\n\texplicit_bzero(&r, sizeof(r));\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}