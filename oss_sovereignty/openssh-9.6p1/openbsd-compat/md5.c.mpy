{
  "module_name": "md5.c",
  "hash_id": "11cfad3ca1fd900e0db02dfb9015fd34310b1e89b9005dc86d0fcca09daeabb1",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/md5.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#ifndef WITH_OPENSSL\n\n#include <sys/types.h>\n#include <string.h>\n#include \"md5.h\"\n\n#define PUT_64BIT_LE(cp, value) do {\t\t\t\t\t\\\n\t(cp)[7] = (value) >> 56;\t\t\t\t\t\\\n\t(cp)[6] = (value) >> 48;\t\t\t\t\t\\\n\t(cp)[5] = (value) >> 40;\t\t\t\t\t\\\n\t(cp)[4] = (value) >> 32;\t\t\t\t\t\\\n\t(cp)[3] = (value) >> 24;\t\t\t\t\t\\\n\t(cp)[2] = (value) >> 16;\t\t\t\t\t\\\n\t(cp)[1] = (value) >> 8;\t\t\t\t\t\t\\\n\t(cp)[0] = (value); } while (0)\n\n#define PUT_32BIT_LE(cp, value) do {\t\t\t\t\t\\\n\t(cp)[3] = (value) >> 24;\t\t\t\t\t\\\n\t(cp)[2] = (value) >> 16;\t\t\t\t\t\\\n\t(cp)[1] = (value) >> 8;\t\t\t\t\t\t\\\n\t(cp)[0] = (value); } while (0)\n\nstatic u_int8_t PADDING[MD5_BLOCK_LENGTH] = {\n\t0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\n \nvoid\nMD5Init(MD5_CTX *ctx)\n{\n\tctx->count = 0;\n\tctx->state[0] = 0x67452301;\n\tctx->state[1] = 0xefcdab89;\n\tctx->state[2] = 0x98badcfe;\n\tctx->state[3] = 0x10325476;\n}\n\n \nvoid\nMD5Update(MD5_CTX *ctx, const unsigned char *input, size_t len)\n{\n\tsize_t have, need;\n\n\t \n\thave = (size_t)((ctx->count >> 3) & (MD5_BLOCK_LENGTH - 1));\n\tneed = MD5_BLOCK_LENGTH - have;\n\n\t \n\tctx->count += (u_int64_t)len << 3;\n\n\tif (len >= need) {\n\t\tif (have != 0) {\n\t\t\tmemcpy(ctx->buffer + have, input, need);\n\t\t\tMD5Transform(ctx->state, ctx->buffer);\n\t\t\tinput += need;\n\t\t\tlen -= need;\n\t\t\thave = 0;\n\t\t}\n\n\t\t \n\t\twhile (len >= MD5_BLOCK_LENGTH) {\n\t\t\tMD5Transform(ctx->state, input);\n\t\t\tinput += MD5_BLOCK_LENGTH;\n\t\t\tlen -= MD5_BLOCK_LENGTH;\n\t\t}\n\t}\n\n\t \n\tif (len != 0)\n\t\tmemcpy(ctx->buffer + have, input, len);\n}\n\n \nvoid\nMD5Pad(MD5_CTX *ctx)\n{\n\tu_int8_t count[8];\n\tsize_t padlen;\n\n\t \n\tPUT_64BIT_LE(count, ctx->count);\n\n\t \n\tpadlen = MD5_BLOCK_LENGTH -\n\t    ((ctx->count >> 3) & (MD5_BLOCK_LENGTH - 1));\n\tif (padlen < 1 + 8)\n\t\tpadlen += MD5_BLOCK_LENGTH;\n\tMD5Update(ctx, PADDING, padlen - 8);\t\t \n\tMD5Update(ctx, count, 8);\n}\n\n \nvoid\nMD5Final(unsigned char digest[MD5_DIGEST_LENGTH], MD5_CTX *ctx)\n{\n\tint i;\n\n\tMD5Pad(ctx);\n\tfor (i = 0; i < 4; i++)\n\t\tPUT_32BIT_LE(digest + i * 4, ctx->state[i]);\n\tmemset(ctx, 0, sizeof(*ctx));\n}\n\n\n \n\n \n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n \n#define MD5STEP(f, w, x, y, z, data, s) \\\n\t( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )\n\n \nvoid\nMD5Transform(u_int32_t state[4], const u_int8_t block[MD5_BLOCK_LENGTH])\n{\n\tu_int32_t a, b, c, d, in[MD5_BLOCK_LENGTH / 4];\n\n#if BYTE_ORDER == LITTLE_ENDIAN\n\tmemcpy(in, block, sizeof(in));\n#else\n\tfor (a = 0; a < MD5_BLOCK_LENGTH / 4; a++) {\n\t\tin[a] = (u_int32_t)(\n\t\t    (u_int32_t)(block[a * 4 + 0]) |\n\t\t    (u_int32_t)(block[a * 4 + 1]) <<  8 |\n\t\t    (u_int32_t)(block[a * 4 + 2]) << 16 |\n\t\t    (u_int32_t)(block[a * 4 + 3]) << 24);\n\t}\n#endif\n\n\ta = state[0];\n\tb = state[1];\n\tc = state[2];\n\td = state[3];\n\n\tMD5STEP(F1, a, b, c, d, in[ 0] + 0xd76aa478,  7);\n\tMD5STEP(F1, d, a, b, c, in[ 1] + 0xe8c7b756, 12);\n\tMD5STEP(F1, c, d, a, b, in[ 2] + 0x242070db, 17);\n\tMD5STEP(F1, b, c, d, a, in[ 3] + 0xc1bdceee, 22);\n\tMD5STEP(F1, a, b, c, d, in[ 4] + 0xf57c0faf,  7);\n\tMD5STEP(F1, d, a, b, c, in[ 5] + 0x4787c62a, 12);\n\tMD5STEP(F1, c, d, a, b, in[ 6] + 0xa8304613, 17);\n\tMD5STEP(F1, b, c, d, a, in[ 7] + 0xfd469501, 22);\n\tMD5STEP(F1, a, b, c, d, in[ 8] + 0x698098d8,  7);\n\tMD5STEP(F1, d, a, b, c, in[ 9] + 0x8b44f7af, 12);\n\tMD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n\tMD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n\tMD5STEP(F1, a, b, c, d, in[12] + 0x6b901122,  7);\n\tMD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n\tMD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n\tMD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n\tMD5STEP(F2, a, b, c, d, in[ 1] + 0xf61e2562,  5);\n\tMD5STEP(F2, d, a, b, c, in[ 6] + 0xc040b340,  9);\n\tMD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n\tMD5STEP(F2, b, c, d, a, in[ 0] + 0xe9b6c7aa, 20);\n\tMD5STEP(F2, a, b, c, d, in[ 5] + 0xd62f105d,  5);\n\tMD5STEP(F2, d, a, b, c, in[10] + 0x02441453,  9);\n\tMD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n\tMD5STEP(F2, b, c, d, a, in[ 4] + 0xe7d3fbc8, 20);\n\tMD5STEP(F2, a, b, c, d, in[ 9] + 0x21e1cde6,  5);\n\tMD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6,  9);\n\tMD5STEP(F2, c, d, a, b, in[ 3] + 0xf4d50d87, 14);\n\tMD5STEP(F2, b, c, d, a, in[ 8] + 0x455a14ed, 20);\n\tMD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905,  5);\n\tMD5STEP(F2, d, a, b, c, in[ 2] + 0xfcefa3f8,  9);\n\tMD5STEP(F2, c, d, a, b, in[ 7] + 0x676f02d9, 14);\n\tMD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n\tMD5STEP(F3, a, b, c, d, in[ 5] + 0xfffa3942,  4);\n\tMD5STEP(F3, d, a, b, c, in[ 8] + 0x8771f681, 11);\n\tMD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n\tMD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n\tMD5STEP(F3, a, b, c, d, in[ 1] + 0xa4beea44,  4);\n\tMD5STEP(F3, d, a, b, c, in[ 4] + 0x4bdecfa9, 11);\n\tMD5STEP(F3, c, d, a, b, in[ 7] + 0xf6bb4b60, 16);\n\tMD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n\tMD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6,  4);\n\tMD5STEP(F3, d, a, b, c, in[ 0] + 0xeaa127fa, 11);\n\tMD5STEP(F3, c, d, a, b, in[ 3] + 0xd4ef3085, 16);\n\tMD5STEP(F3, b, c, d, a, in[ 6] + 0x04881d05, 23);\n\tMD5STEP(F3, a, b, c, d, in[ 9] + 0xd9d4d039,  4);\n\tMD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n\tMD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n\tMD5STEP(F3, b, c, d, a, in[2 ] + 0xc4ac5665, 23);\n\n\tMD5STEP(F4, a, b, c, d, in[ 0] + 0xf4292244,  6);\n\tMD5STEP(F4, d, a, b, c, in[7 ] + 0x432aff97, 10);\n\tMD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n\tMD5STEP(F4, b, c, d, a, in[5 ] + 0xfc93a039, 21);\n\tMD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3,  6);\n\tMD5STEP(F4, d, a, b, c, in[3 ] + 0x8f0ccc92, 10);\n\tMD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n\tMD5STEP(F4, b, c, d, a, in[1 ] + 0x85845dd1, 21);\n\tMD5STEP(F4, a, b, c, d, in[8 ] + 0x6fa87e4f,  6);\n\tMD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n\tMD5STEP(F4, c, d, a, b, in[6 ] + 0xa3014314, 15);\n\tMD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n\tMD5STEP(F4, a, b, c, d, in[4 ] + 0xf7537e82,  6);\n\tMD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n\tMD5STEP(F4, c, d, a, b, in[2 ] + 0x2ad7d2bb, 15);\n\tMD5STEP(F4, b, c, d, a, in[9 ] + 0xeb86d391, 21);\n\n\tstate[0] += a;\n\tstate[1] += b;\n\tstate[2] += c;\n\tstate[3] += d;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}