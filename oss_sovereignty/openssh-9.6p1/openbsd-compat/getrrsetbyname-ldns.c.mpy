{
  "module_name": "getrrsetbyname-ldns.c",
  "hash_id": "37ea1b3101654caf79cec8cd00bede846774685a35286128af16c13632e2f89d",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/getrrsetbyname-ldns.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"includes.h\"\n\n#if !defined (HAVE_GETRRSETBYNAME) && defined (HAVE_LDNS)\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <ldns/ldns.h>\n\n#include \"getrrsetbyname.h\"\n#include \"log.h\"\n#include \"xmalloc.h\"\n\n#define malloc(x)\t(xmalloc(x))\n#define calloc(x, y)\t(xcalloc((x),(y)))\n\nint\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n\t       unsigned int rdtype, unsigned int flags,\n\t       struct rrsetinfo **res)\n{\n\tint result;\n\tunsigned int i, j, index_ans, index_sig;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct rdatainfo *rdata;\n\tsize_t len;\n\tldns_resolver *ldns_res = NULL;\n\tldns_rdf *domain = NULL;\n\tldns_pkt *pkt = NULL;\n\tldns_rr_list *rrsigs = NULL, *rrdata = NULL;\n\tldns_status err;\n\tldns_rr *rr;\n\n\t \n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tdomain = ldns_dname_new_frm_str(hostname);\n\tif ((err = ldns_resolver_new_frm_file(&ldns_res, NULL)) != \\\n\t    LDNS_STATUS_OK) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef LDNS_DEBUG\n\tldns_resolver_set_debug(ldns_res, true);\n#endif  \n\n\tldns_resolver_set_dnssec(ldns_res, true);  \n\n\t \n\tpkt = ldns_resolver_query(ldns_res, domain, rdtype, rdclass, LDNS_RD);\n\n\t \n\tif (!pkt || ldns_pkt_ancount(pkt) < 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t \n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\trrdata = ldns_pkt_rr_list_by_type(pkt, rdtype, LDNS_SECTION_ANSWER);\n\trrset->rri_nrdatas = ldns_rr_list_rr_count(rrdata);\n\tif (!rrset->rri_nrdatas) {\n\t\tresult = ERRSET_NODATA;\n\t\tgoto fail;\n\t}\n\n\t \n\tlen = ldns_rdf_size(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0)));\n\tif ((rrset->rri_name = malloc(len)) == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\tmemcpy(rrset->rri_name,\n\t    ldns_rdf_data(ldns_rr_owner(ldns_rr_list_rr(rrdata, 0))), len);\n\n\trrset->rri_rdclass = ldns_rr_get_class(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_rdtype = ldns_rr_get_type(ldns_rr_list_rr(rrdata, 0));\n\trrset->rri_ttl = ldns_rr_ttl(ldns_rr_list_rr(rrdata, 0));\n\n\tdebug2(\"ldns: got %u answers from DNS\", rrset->rri_nrdatas);\n\n\t \n\tif (ldns_pkt_ad(pkt)) {\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t} else {  \n\t\tldns_rr_list * trusted_keys = ldns_rr_list_new();\n\n\t\tdebug2(\"ldns: trying to validate RRset\");\n\t\t \n\t\trrsigs = ldns_pkt_rr_list_by_type(pkt, LDNS_RR_TYPE_RRSIG,\n\t\t    LDNS_SECTION_ANSWER);\n\n\t\trrset->rri_nsigs = ldns_rr_list_rr_count(rrsigs);\n\t\tdebug2(\"ldns: got %u signature(s) (RRTYPE %u) from DNS\",\n\t\t       rrset->rri_nsigs, LDNS_RR_TYPE_RRSIG);\n\n\t\tif ((err = ldns_verify_trusted(ldns_res, rrdata, rrsigs,\n\t\t     trusted_keys)) == LDNS_STATUS_OK) {\n\t\t\trrset->rri_flags |= RRSET_VALIDATED;\n\t\t\tdebug2(\"ldns: RRset is signed with a valid key\");\n\t\t} else {\n\t\t\tdebug2(\"ldns: RRset validation failed: %s\",\n\t\t\t    ldns_get_errorstr_by_id(err));\n\t\t}\n\n\t\tldns_rr_list_deep_free(trusted_keys);\n\t}\n\n\t \n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t   sizeof(struct rdatainfo));\n\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs,\n\t\t    sizeof(struct rdatainfo));\n\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tfor (i=0, index_ans=0, index_sig=0; i< pkt->_header->_ancount; i++) {\n\t\trdata = NULL;\n\t\trr = ldns_rr_list_rr(ldns_pkt_answer(pkt), i);\n\n\t\tif (ldns_rr_get_class(rr) == rrset->rri_rdclass &&\n\t\t    ldns_rr_get_type(rr) == rrset->rri_rdtype) {\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\t\t}\n\n\t\tif (rr->_rr_class == rrset->rri_rdclass &&\n\t\t    rr->_rr_type == LDNS_RR_TYPE_RRSIG &&\n\t\t    rrset->rri_sigs) {\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\t\t}\n\n\t\tif (rdata) {\n\t\t\tsize_t rdata_offset = 0;\n\n\t\t\trdata->rdi_length = 0;\n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\trdata->rdi_length +=\n\t\t\t\t    ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t}\n\n\t\t\trdata->rdi_data = malloc(rdata->rdi_length);\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (j=0; j< rr->_rd_count; j++) {\n\t\t\t\tlen = ldns_rdf_size(ldns_rr_rdf(rr, j));\n\t\t\t\tmemcpy(rdata->rdi_data + rdata_offset,\n\t\t\t\t       ldns_rdf_data(ldns_rr_rdf(rr, j)), len);\n\t\t\t\trdata_offset += len;\n\t\t\t}\n\t\t}\n\t}\n\n\t*res = rrset;\n\tresult = ERRSET_SUCCESS;\n\nfail:\n\t \n\tldns_rdf_deep_free(domain);\n\tldns_pkt_free(pkt);\n\tldns_rr_list_deep_free(rrsigs);\n\tldns_rr_list_deep_free(rrdata);\n\tldns_resolver_deep_free(ldns_res);\n\n\treturn result;\n}\n\n\nvoid\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}