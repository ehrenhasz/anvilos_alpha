{
  "module_name": "port-aix.c",
  "hash_id": "06a01a3d121368ecd614a6d24793fb1181b91a352be5403491c0534a4c215ed8",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/port-aix.c",
  "human_readable_source": " \n#include \"includes.h\"\n\n#ifdef _AIX\n\n#include \"xmalloc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"ssh.h\"\n#include \"ssh_api.h\"\n#include \"log.h\"\n\n#include <errno.h>\n#if defined(HAVE_NETDB_H)\n# include <netdb.h>\n#endif\n#include <uinfo.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n\n#ifdef WITH_AIXAUTHENTICATE\n# include <login.h>\n# include <userpw.h>\n# if defined(HAVE_SYS_AUDIT_H) && defined(AIX_LOGINFAILED_4ARG)\n#  include <sys/audit.h>\n# endif\n# include <usersec.h>\n#endif\n\n#include \"port-aix.h\"\n\nstatic char *lastlogin_msg = NULL;\n\n# ifdef HAVE_SETAUTHDB\nstatic char old_registry[REGISTRY_SIZE] = \"\";\n# endif\n\n \nvoid\naix_usrinfo(struct passwd *pw)\n{\n\tu_int i;\n\tsize_t len;\n\tchar *cp;\n\n\tlen = sizeof(\"LOGNAME= NAME= \") + (2 * strlen(pw->pw_name));\n\tcp = xmalloc(len);\n\n\ti = snprintf(cp, len, \"LOGNAME=%s%cNAME=%s%c\", pw->pw_name, '\\0',\n\t    pw->pw_name, '\\0');\n\tif (usrinfo(SETUINFO, cp, i) == -1)\n\t\tfatal(\"Couldn't set usrinfo: %s\", strerror(errno));\n\tdebug3(\"AIX/UsrInfo: set len %d\", i);\n\n\tfree(cp);\n}\n\n# ifdef WITH_AIXAUTHENTICATE\n \nvoid\naix_remove_embedded_newlines(char *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfor (; *p; p++) {\n\t\tif (*p == '\\n')\n\t\t\t*p = ' ';\n\t}\n\t \n\tif (*--p == ' ')\n\t\t*p = '\\0';\n}\n\n \nstatic int\naix_valid_authentications(const char *user)\n{\n\tchar *auth1, *sys, *p;\n\tint valid = 1;\n\n\tif (getuserattr((char *)user, S_AUTHSYSTEM, &sys, SEC_CHAR) != 0) {\n\t\tlogit(\"Can't retrieve attribute SYSTEM for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tdebug3(\"AIX SYSTEM attribute %s\", sys);\n\tif (strcmp(sys, \"NONE\") != 0)\n\t\treturn 1;\t \n\n\tif (getuserattr((char *)user, S_AUTH1, &auth1, SEC_LIST) != 0) {\n\t\tlogit(\"Can't retrieve attribute auth1 for %s: %.100s\",\n\t\t    user, strerror(errno));\n\t\treturn 0;\n\t}\n\n\tp = auth1;\n\t \n\twhile (p[0] != '\\0' && p[1] != '\\0') {\n\t\tdebug3(\"AIX auth1 attribute list member %s\", p);\n\t\tif (strcmp(p, \"NONE\") != 0 && strcmp(p, \"SYSTEM\")) {\n\t\t\tlogit(\"Account %s has unsupported auth1 value '%s'\",\n\t\t\t    user, p);\n\t\t\tvalid = 0;\n\t\t}\n\t\tp += strlen(p) + 1;\n\t}\n\n\treturn (valid);\n}\n\n \nint\nsys_auth_passwd(struct ssh *ssh, const char *password)\n{\n\tAuthctxt *ctxt = ssh->authctxt;\n\tchar *authmsg = NULL, *msg = NULL, *name = ctxt->pw->pw_name;\n\tint r, authsuccess = 0, expired, reenter, result;\n\n\tdo {\n\t\tresult = authenticate((char *)name, (char *)password, &reenter,\n\t\t    &authmsg);\n\t\taix_remove_embedded_newlines(authmsg);\n\t\tdebug3(\"AIX/authenticate result %d, authmsg %.100s\", result,\n\t\t    authmsg);\n\t} while (reenter);\n\n\tif (!aix_valid_authentications(name))\n\t\tresult = -1;\n\n\tif (result == 0) {\n\t\tauthsuccess = 1;\n\n\t\t \n\t\taix_setauthdb(name);\n\n\t\t \n\t\texpired = passwdexpired(name, &msg);\n\t\tif (msg && *msg) {\n\t\t\tif ((r = sshbuf_put(ctxt->loginmsg,\n\t\t\t    msg, strlen(msg))) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\taix_remove_embedded_newlines(msg);\n\t\t}\n\t\tdebug3(\"AIX/passwdexpired returned %d msg %.100s\", expired, msg);\n\n\t\tswitch (expired) {\n\t\tcase 0:  \n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tctxt->force_pwchange = 1;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tlogit(\"Password can't be changed for user %s: %.100s\",\n\t\t\t    name, msg);\n\t\t\tfree(msg);\n\t\t\tauthsuccess = 0;\n\t\t}\n\n\t\taix_restoreauthdb();\n\t}\n\n\tfree(authmsg);\n\n\treturn authsuccess;\n}\n\n \nint\nsys_auth_allowed_user(struct passwd *pw, struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint r, result, permitted = 0;\n\tstruct stat st;\n\n\t \n\tif (pw->pw_uid == 0 || geteuid() != 0) {\n\t\tdebug3(\"%s: not checking\", __func__);\n\t\treturn 1;\n\t}\n\n\tresult = loginrestrictions(pw->pw_name, S_RLOGIN, NULL, &msg);\n\tif (result == 0)\n\t\tpermitted = 1;\n\t \n\tif (result == -1 && errno == EPERM && stat(_PATH_NOLOGIN, &st) == 0)\n\t\tpermitted = 1;\n\telse if (msg != NULL) {\n\t\tif ((r = sshbuf_put(loginmsg, msg, strlen(msg))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif (msg == NULL)\n\t\tmsg = xstrdup(\"(none)\");\n\taix_remove_embedded_newlines(msg);\n\tdebug3(\"AIX/loginrestrictions returned %d msg %.100s\", result, msg);\n\n\tif (!permitted)\n\t\tlogit(\"Login restricted for %s: %.100s\", pw->pw_name, msg);\n\tfree(msg);\n\treturn permitted;\n}\n\nint\nsys_auth_record_login(const char *user, const char *host, const char *ttynm,\n    struct sshbuf *loginmsg)\n{\n\tchar *msg = NULL;\n\tint success = 0;\n\n\taix_setauthdb(user);\n\tif (loginsuccess((char *)user, (char *)host, (char *)ttynm, &msg) == 0) {\n\t\tsuccess = 1;\n\t\tif (msg != NULL) {\n\t\t\tdebug(\"AIX/loginsuccess: msg %s\", msg);\n\t\t\tif (lastlogin_msg == NULL)\n\t\t\t\tlastlogin_msg = msg;\n\t\t}\n\t}\n\taix_restoreauthdb();\n\treturn (success);\n}\n\nchar *\nsys_auth_get_lastlogin_msg(const char *user, uid_t uid)\n{\n\tchar *msg = lastlogin_msg;\n\n\tlastlogin_msg = NULL;\n\treturn msg;\n}\n\n#  ifdef CUSTOM_FAILED_LOGIN\n \nvoid\nrecord_failed_login(struct ssh *ssh, const char *user, const char *hostname,\n    const char *ttyname)\n{\n\tif (geteuid() != 0)\n\t\treturn;\n\n\taix_setauthdb(user);\n#   ifdef AIX_LOGINFAILED_4ARG\n\tloginfailed((char *)user, (char *)hostname, (char *)ttyname,\n\t    AUDIT_FAIL_AUTH);\n#   else\n\tloginfailed((char *)user, (char *)hostname, (char *)ttyname);\n#   endif\n\taix_restoreauthdb();\n}\n#  endif  \n\n \nvoid\naix_setauthdb(const char *user)\n{\n#  ifdef HAVE_SETAUTHDB\n\tchar *registry;\n\n\tif (setuserdb(S_READ) == -1) {\n\t\tdebug3(\"%s: Could not open userdb to read\", __func__);\n\t\treturn;\n\t}\n\n\tif (getuserattr((char *)user, S_REGISTRY, &registry, SEC_CHAR) == 0) {\n\t\tif (setauthdb(registry, old_registry) == 0)\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s'\", registry);\n\t\telse\n\t\t\tdebug3(\"AIX/setauthdb set registry '%s' failed: %s\",\n\t\t\t    registry, strerror(errno));\n\t} else\n\t\tdebug3(\"%s: Could not read S_REGISTRY for user: %s\", __func__,\n\t\t    strerror(errno));\n\tenduserdb();\n#  endif  \n}\n\n \nvoid\naix_restoreauthdb(void)\n{\n#  ifdef HAVE_SETAUTHDB\n\tif (setauthdb(old_registry, NULL) == 0)\n\t\tdebug3(\"%s: restoring old registry '%s'\", __func__,\n\t\t    old_registry);\n\telse\n\t\tdebug3(\"%s: failed to restore old registry %s\", __func__,\n\t\t    old_registry);\n#  endif  \n}\n\n# endif  \n\n# ifdef USE_AIX_KRB_NAME\n \nchar *\naix_krb5_get_principal_name(const char *const_pw_name)\n{\n\tchar *pw_name = (char *)const_pw_name;\n\tchar *authname = NULL, *authdomain = NULL, *principal = NULL;\n\n\tsetuserdb(S_READ);\n\tif (getuserattr(pw_name, S_AUTHDOMAIN, &authdomain, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHDOMAIN: %s\", strerror(errno));\n\tif (getuserattr(pw_name, S_AUTHNAME, &authname, SEC_CHAR) != 0)\n\t\tdebug(\"AIX getuserattr S_AUTHNAME: %s\", strerror(errno));\n\n\tif (authdomain != NULL)\n\t\txasprintf(&principal, \"%s@%s\", authname ? authname : pw_name,\n\t\t    authdomain);\n\telse if (authname != NULL)\n\t\tprincipal = xstrdup(authname);\n\tenduserdb();\n\treturn principal;\n}\n# endif  \n\n# if defined(AIX_GETNAMEINFO_HACK) && !defined(BROKEN_ADDRINFO)\n# undef getnameinfo\n \nint\nsshaix_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n    size_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in6 *sa6;\n\tu_int32_t *a6;\n\n\tif (flags & (NI_NUMERICHOST|NI_NUMERICSERV) &&\n\t    sa->sa_family == AF_INET6) {\n\t\tsa6 = (struct sockaddr_in6 *)sa;\n\t\ta6 = sa6->sin6_addr.u6_addr.u6_addr32;\n\n\t\tif (a6[0] == 0 && a6[1] == 0 && a6[2] == 0 && a6[3] == 0) {\n\t\t\tstrlcpy(host, \"::\", hostlen);\n\t\t\tsnprintf(serv, servlen, \"%d\", sa6->sin6_port);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);\n}\n# endif  \n\n# if defined(USE_GETGRSET)\n#  include <stdlib.h>\nint\ngetgrouplist(const char *user, gid_t pgid, gid_t *groups, int *grpcnt)\n{\n\tchar *cp, *grplist, *grp;\n\tgid_t gid;\n\tint ret = 0, ngroups = 0, maxgroups;\n\tlong long ll;\n\n\tmaxgroups = *grpcnt;\n\n\tif ((cp = grplist = getgrset(user)) == NULL)\n\t\treturn -1;\n\n\t \n\tif (maxgroups <= 0) {\n\t\t*grpcnt = 0;\n\t\treturn -1;\n\t}\n\n\t \n\tgroups[ngroups++] = pgid;\n\n\t \n\twhile ((grp = strsep(&grplist, \",\")) != NULL) {\n\t\tll = strtoll(grp, NULL, 10);\n\t\tif (ngroups >= maxgroups || ll < 0 || ll > UID_MAX) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tgid = (gid_t)ll;\n\t\tif (gid == pgid)\n\t\t\tcontinue;\t \n\t\tgroups[ngroups++] = gid;\n\t}\nout:\n\tfree(cp);\n\t*grpcnt = ngroups;\n\treturn ret;\n}\n# endif\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}