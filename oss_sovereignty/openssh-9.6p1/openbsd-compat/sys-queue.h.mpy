{
  "module_name": "sys-queue.h",
  "hash_id": "a354da6c388b4864d17e9dc72012ac78835c3a3d126ddef0268bc0ef3d629d95",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/sys-queue.h",
  "human_readable_source": " \n \n\n \n\n \n\n#ifndef\t_FAKE_QUEUE_H_\n#define\t_FAKE_QUEUE_H_\n\n \n#undef CIRCLEQ_EMPTY\n#undef CIRCLEQ_END\n#undef CIRCLEQ_ENTRY\n#undef CIRCLEQ_FIRST\n#undef CIRCLEQ_FOREACH\n#undef CIRCLEQ_FOREACH_REVERSE\n#undef CIRCLEQ_HEAD\n#undef CIRCLEQ_HEAD_INITIALIZER\n#undef CIRCLEQ_INIT\n#undef CIRCLEQ_INSERT_AFTER\n#undef CIRCLEQ_INSERT_BEFORE\n#undef CIRCLEQ_INSERT_HEAD\n#undef CIRCLEQ_INSERT_TAIL\n#undef CIRCLEQ_LAST\n#undef CIRCLEQ_NEXT\n#undef CIRCLEQ_PREV\n#undef CIRCLEQ_REMOVE\n#undef CIRCLEQ_REPLACE\n#undef LIST_EMPTY\n#undef LIST_END\n#undef LIST_ENTRY\n#undef LIST_FIRST\n#undef LIST_FOREACH\n#undef LIST_FOREACH_SAFE\n#undef LIST_HEAD\n#undef LIST_HEAD_INITIALIZER\n#undef LIST_INIT\n#undef LIST_INSERT_AFTER\n#undef LIST_INSERT_BEFORE\n#undef LIST_INSERT_HEAD\n#undef LIST_NEXT\n#undef LIST_REMOVE\n#undef LIST_REPLACE\n#undef SIMPLEQ_CONCAT\n#undef SIMPLEQ_EMPTY\n#undef SIMPLEQ_END\n#undef SIMPLEQ_ENTRY\n#undef SIMPLEQ_FIRST\n#undef SIMPLEQ_FOREACH\n#undef SIMPLEQ_FOREACH_SAFE\n#undef SIMPLEQ_HEAD\n#undef SIMPLEQ_HEAD_INITIALIZER\n#undef SIMPLEQ_INIT\n#undef SIMPLEQ_INSERT_AFTER\n#undef SIMPLEQ_INSERT_HEAD\n#undef SIMPLEQ_INSERT_TAIL\n#undef SIMPLEQ_NEXT\n#undef SIMPLEQ_REMOVE_AFTER\n#undef SIMPLEQ_REMOVE_HEAD\n#undef SLIST_EMPTY\n#undef SLIST_END\n#undef SLIST_ENTRY\n#undef SLIST_FIRST\n#undef SLIST_FOREACH\n#undef SLIST_FOREACH_PREVPTR\n#undef SLIST_FOREACH_SAFE\n#undef SLIST_HEAD\n#undef SLIST_HEAD_INITIALIZER\n#undef SLIST_INIT\n#undef SLIST_INSERT_AFTER\n#undef SLIST_INSERT_HEAD\n#undef SLIST_NEXT\n#undef SLIST_REMOVE\n#undef SLIST_REMOVE_AFTER\n#undef SLIST_REMOVE_HEAD\n#undef SLIST_REMOVE_NEXT\n#undef TAILQ_CONCAT\n#undef TAILQ_EMPTY\n#undef TAILQ_END\n#undef TAILQ_ENTRY\n#undef TAILQ_FIRST\n#undef TAILQ_FOREACH\n#undef TAILQ_FOREACH_REVERSE\n#undef TAILQ_FOREACH_REVERSE_SAFE\n#undef TAILQ_FOREACH_SAFE\n#undef TAILQ_HEAD\n#undef TAILQ_HEAD_INITIALIZER\n#undef TAILQ_INIT\n#undef TAILQ_INSERT_AFTER\n#undef TAILQ_INSERT_BEFORE\n#undef TAILQ_INSERT_HEAD\n#undef TAILQ_INSERT_TAIL\n#undef TAILQ_LAST\n#undef TAILQ_NEXT\n#undef TAILQ_PREV\n#undef TAILQ_REMOVE\n#undef TAILQ_REPLACE\n\n \n\n#if defined(QUEUE_MACRO_DEBUG) || (defined(_KERNEL) && defined(DIAGNOSTIC))\n#define _Q_INVALID ((void *)-1)\n#define _Q_INVALIDATE(a) (a) = _Q_INVALID\n#else\n#define _Q_INVALIDATE(a)\n#endif\n\n \n#define SLIST_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *slh_first;\t \t\t\t\\\n}\n\n#define\tSLIST_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL }\n\n#define SLIST_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *sle_next;\t \t\t\t\\\n}\n\n \n#define\tSLIST_FIRST(head)\t((head)->slh_first)\n#define\tSLIST_END(head)\t\tNULL\n#define\tSLIST_EMPTY(head)\t(SLIST_FIRST(head) == SLIST_END(head))\n#define\tSLIST_NEXT(elm, field)\t((elm)->field.sle_next)\n\n#define\tSLIST_FOREACH(var, head, field)\t\t\t\t\t\\\n\tfor((var) = SLIST_FIRST(head);\t\t\t\t\t\\\n\t    (var) != SLIST_END(head);\t\t\t\t\t\\\n\t    (var) = SLIST_NEXT(var, field))\n\n#define\tSLIST_FOREACH_SAFE(var, head, field, tvar)\t\t\t\\\n\tfor ((var) = SLIST_FIRST(head);\t\t\t\t\\\n\t    (var) && ((tvar) = SLIST_NEXT(var, field), 1);\t\t\\\n\t    (var) = (tvar))\n\n \n#define\tSLIST_INIT(head) {\t\t\t\t\t\t\\\n\tSLIST_FIRST(head) = SLIST_END(head);\t\t\t\t\\\n}\n\n#define\tSLIST_INSERT_AFTER(slistelm, elm, field) do {\t\t\t\\\n\t(elm)->field.sle_next = (slistelm)->field.sle_next;\t\t\\\n\t(slistelm)->field.sle_next = (elm);\t\t\t\t\\\n} while (0)\n\n#define\tSLIST_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\t(elm)->field.sle_next = (head)->slh_first;\t\t\t\\\n\t(head)->slh_first = (elm);\t\t\t\t\t\\\n} while (0)\n\n#define\tSLIST_REMOVE_AFTER(elm, field) do {\t\t\t\t\\\n\t(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;\t\\\n} while (0)\n\n#define\tSLIST_REMOVE_HEAD(head, field) do {\t\t\t\t\\\n\t(head)->slh_first = (head)->slh_first->field.sle_next;\t\t\\\n} while (0)\n\n#define SLIST_REMOVE(head, elm, type, field) do {\t\t\t\\\n\tif ((head)->slh_first == (elm)) {\t\t\t\t\\\n\t\tSLIST_REMOVE_HEAD((head), field);\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tstruct type *curelm = (head)->slh_first;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\twhile (curelm->field.sle_next != (elm))\t\t\t\\\n\t\t\tcurelm = curelm->field.sle_next;\t\t\\\n\t\tcurelm->field.sle_next =\t\t\t\t\\\n\t\t    curelm->field.sle_next->field.sle_next;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.sle_next);\t\t\t\t\\\n} while (0)\n\n \n#define LIST_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *lh_first;\t \t\t\t\\\n}\n\n#define LIST_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL }\n\n#define LIST_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *le_next;\t \t\t\t\\\n\tstruct type **le_prev;\t \t\\\n}\n\n \n#define\tLIST_FIRST(head)\t\t((head)->lh_first)\n#define\tLIST_END(head)\t\t\tNULL\n#define\tLIST_EMPTY(head)\t\t(LIST_FIRST(head) == LIST_END(head))\n#define\tLIST_NEXT(elm, field)\t\t((elm)->field.le_next)\n\n#define LIST_FOREACH(var, head, field)\t\t\t\t\t\\\n\tfor((var) = LIST_FIRST(head);\t\t\t\t\t\\\n\t    (var)!= LIST_END(head);\t\t\t\t\t\\\n\t    (var) = LIST_NEXT(var, field))\n\n#define\tLIST_FOREACH_SAFE(var, head, field, tvar)\t\t\t\\\n\tfor ((var) = LIST_FIRST(head);\t\t\t\t\\\n\t    (var) && ((tvar) = LIST_NEXT(var, field), 1);\t\t\\\n\t    (var) = (tvar))\n\n \n#define\tLIST_INIT(head) do {\t\t\t\t\t\t\\\n\tLIST_FIRST(head) = LIST_END(head);\t\t\t\t\\\n} while (0)\n\n#define LIST_INSERT_AFTER(listelm, elm, field) do {\t\t\t\\\n\tif (((elm)->field.le_next = (listelm)->field.le_next) != NULL)\t\\\n\t\t(listelm)->field.le_next->field.le_prev =\t\t\\\n\t\t    &(elm)->field.le_next;\t\t\t\t\\\n\t(listelm)->field.le_next = (elm);\t\t\t\t\\\n\t(elm)->field.le_prev = &(listelm)->field.le_next;\t\t\\\n} while (0)\n\n#define\tLIST_INSERT_BEFORE(listelm, elm, field) do {\t\t\t\\\n\t(elm)->field.le_prev = (listelm)->field.le_prev;\t\t\\\n\t(elm)->field.le_next = (listelm);\t\t\t\t\\\n\t*(listelm)->field.le_prev = (elm);\t\t\t\t\\\n\t(listelm)->field.le_prev = &(elm)->field.le_next;\t\t\\\n} while (0)\n\n#define LIST_INSERT_HEAD(head, elm, field) do {\t\t\t\t\\\n\tif (((elm)->field.le_next = (head)->lh_first) != NULL)\t\t\\\n\t\t(head)->lh_first->field.le_prev = &(elm)->field.le_next;\\\n\t(head)->lh_first = (elm);\t\t\t\t\t\\\n\t(elm)->field.le_prev = &(head)->lh_first;\t\t\t\\\n} while (0)\n\n#define LIST_REMOVE(elm, field) do {\t\t\t\t\t\\\n\tif ((elm)->field.le_next != NULL)\t\t\t\t\\\n\t\t(elm)->field.le_next->field.le_prev =\t\t\t\\\n\t\t    (elm)->field.le_prev;\t\t\t\t\\\n\t*(elm)->field.le_prev = (elm)->field.le_next;\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.le_prev);\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.le_next);\t\t\t\t\\\n} while (0)\n\n#define LIST_REPLACE(elm, elm2, field) do {\t\t\t\t\\\n\tif (((elm2)->field.le_next = (elm)->field.le_next) != NULL)\t\\\n\t\t(elm2)->field.le_next->field.le_prev =\t\t\t\\\n\t\t    &(elm2)->field.le_next;\t\t\t\t\\\n\t(elm2)->field.le_prev = (elm)->field.le_prev;\t\t\t\\\n\t*(elm2)->field.le_prev = (elm2);\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.le_prev);\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.le_next);\t\t\t\t\\\n} while (0)\n\n \n#define SIMPLEQ_HEAD(name, type)\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *sqh_first;\t \t\t\t\\\n\tstruct type **sqh_last;\t \t\t\\\n}\n\n#define SIMPLEQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL, &(head).sqh_first }\n\n#define SIMPLEQ_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *sqe_next;\t \t\t\t\\\n}\n\n \n#define\tSIMPLEQ_FIRST(head)\t    ((head)->sqh_first)\n#define\tSIMPLEQ_END(head)\t    NULL\n#define\tSIMPLEQ_EMPTY(head)\t    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))\n#define\tSIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)\n\n#define SIMPLEQ_FOREACH(var, head, field)\t\t\t\t\\\n\tfor((var) = SIMPLEQ_FIRST(head);\t\t\t\t\\\n\t    (var) != SIMPLEQ_END(head);\t\t\t\t\t\\\n\t    (var) = SIMPLEQ_NEXT(var, field))\n\n#define\tSIMPLEQ_FOREACH_SAFE(var, head, field, tvar)\t\t\t\\\n\tfor ((var) = SIMPLEQ_FIRST(head);\t\t\t\t\\\n\t    (var) && ((tvar) = SIMPLEQ_NEXT(var, field), 1);\t\t\\\n\t    (var) = (tvar))\n\n \n#define\tSIMPLEQ_INIT(head) do {\t\t\t\t\t\t\\\n\t(head)->sqh_first = NULL;\t\t\t\t\t\\\n\t(head)->sqh_last = &(head)->sqh_first;\t\t\t\t\\\n} while (0)\n\n#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tif (((elm)->field.sqe_next = (head)->sqh_first) == NULL)\t\\\n\t\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\\\n\t(head)->sqh_first = (elm);\t\t\t\t\t\\\n} while (0)\n\n#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n\t(elm)->field.sqe_next = NULL;\t\t\t\t\t\\\n\t*(head)->sqh_last = (elm);\t\t\t\t\t\\\n\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\t\\\n} while (0)\n\n#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n\tif (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\\\n\t\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\\\n\t(listelm)->field.sqe_next = (elm);\t\t\t\t\\\n} while (0)\n\n#define SIMPLEQ_REMOVE_HEAD(head, field) do {\t\t\t\\\n\tif (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \\\n\t\t(head)->sqh_last = &(head)->sqh_first;\t\t\t\\\n} while (0)\n\n#define SIMPLEQ_REMOVE_AFTER(head, elm, field) do {\t\t\t\\\n\tif (((elm)->field.sqe_next = (elm)->field.sqe_next->field.sqe_next) \\\n\t    == NULL)\t\t\t\t\t\t\t\\\n\t\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\\\n} while (0)\n\n#define SIMPLEQ_CONCAT(head1, head2) do {\t\t\t\t\\\n\tif (!SIMPLEQ_EMPTY((head2))) {\t\t\t\t\t\\\n\t\t*(head1)->sqh_last = (head2)->sqh_first;\t\t\\\n\t\t(head1)->sqh_last = (head2)->sqh_last;\t\t\t\\\n\t\tSIMPLEQ_INIT((head2));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define XSIMPLEQ_HEAD(name, type)\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *sqx_first;\t \t\t\t\\\n\tstruct type **sqx_last;\t \t\t\\\n\tunsigned long sqx_cookie;\t\t\t\t\t\\\n}\n\n#define XSIMPLEQ_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *sqx_next;\t \t\t\t\\\n}\n\n \n#define XSIMPLEQ_XOR(head, ptr)\t    ((__typeof(ptr))((head)->sqx_cookie ^ \\\n\t\t\t\t\t(unsigned long)(ptr)))\n#define\tXSIMPLEQ_FIRST(head)\t    XSIMPLEQ_XOR(head, ((head)->sqx_first))\n#define\tXSIMPLEQ_END(head)\t    NULL\n#define\tXSIMPLEQ_EMPTY(head)\t    (XSIMPLEQ_FIRST(head) == XSIMPLEQ_END(head))\n#define\tXSIMPLEQ_NEXT(head, elm, field)    XSIMPLEQ_XOR(head, ((elm)->field.sqx_next))\n\n\n#define XSIMPLEQ_FOREACH(var, head, field)\t\t\t\t\\\n\tfor ((var) = XSIMPLEQ_FIRST(head);\t\t\t\t\\\n\t    (var) != XSIMPLEQ_END(head);\t\t\t\t\\\n\t    (var) = XSIMPLEQ_NEXT(head, var, field))\n\n#define\tXSIMPLEQ_FOREACH_SAFE(var, head, field, tvar)\t\t\t\\\n\tfor ((var) = XSIMPLEQ_FIRST(head);\t\t\t\t\\\n\t    (var) && ((tvar) = XSIMPLEQ_NEXT(head, var, field), 1);\t\\\n\t    (var) = (tvar))\n\n \n#define\tXSIMPLEQ_INIT(head) do {\t\t\t\t\t\\\n\tarc4random_buf(&(head)->sqx_cookie, sizeof((head)->sqx_cookie)); \\\n\t(head)->sqx_first = XSIMPLEQ_XOR(head, NULL);\t\t\t\\\n\t(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first);\t\\\n} while (0)\n\n#define XSIMPLEQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tif (((elm)->field.sqx_next = (head)->sqx_first) ==\t\t\\\n\t    XSIMPLEQ_XOR(head, NULL))\t\t\t\t\t\\\n\t\t(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \\\n\t(head)->sqx_first = XSIMPLEQ_XOR(head, (elm));\t\t\t\\\n} while (0)\n\n#define XSIMPLEQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n\t(elm)->field.sqx_next = XSIMPLEQ_XOR(head, NULL);\t\t\\\n\t*(XSIMPLEQ_XOR(head, (head)->sqx_last)) = XSIMPLEQ_XOR(head, (elm)); \\\n\t(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);\t\\\n} while (0)\n\n#define XSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n\tif (((elm)->field.sqx_next = (listelm)->field.sqx_next) ==\t\\\n\t    XSIMPLEQ_XOR(head, NULL))\t\t\t\t\t\\\n\t\t(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \\\n\t(listelm)->field.sqx_next = XSIMPLEQ_XOR(head, (elm));\t\t\\\n} while (0)\n\n#define XSIMPLEQ_REMOVE_HEAD(head, field) do {\t\t\t\t\\\n\tif (((head)->sqx_first = XSIMPLEQ_XOR(head,\t\t\t\\\n\t    (head)->sqx_first)->field.sqx_next) == XSIMPLEQ_XOR(head, NULL)) \\\n\t\t(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first); \\\n} while (0)\n\n#define XSIMPLEQ_REMOVE_AFTER(head, elm, field) do {\t\t\t\\\n\tif (((elm)->field.sqx_next = XSIMPLEQ_XOR(head,\t\t\t\\\n\t    (elm)->field.sqx_next)->field.sqx_next)\t\t\t\\\n\t    == XSIMPLEQ_XOR(head, NULL))\t\t\t\t\\\n\t\t(head)->sqx_last = \t\t\t\t\t\\\n\t\t    XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);\t\t\\\n} while (0)\n\n\n \n#define TAILQ_HEAD(name, type)\t\t\t\t\t\t\\\nstruct name {\t\t\t\t\t\t\t\t\\\n\tstruct type *tqh_first;\t \t\t\t\\\n\tstruct type **tqh_last;\t \t\t\\\n}\n\n#define TAILQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n\t{ NULL, &(head).tqh_first }\n\n#define TAILQ_ENTRY(type)\t\t\t\t\t\t\\\nstruct {\t\t\t\t\t\t\t\t\\\n\tstruct type *tqe_next;\t \t\t\t\\\n\tstruct type **tqe_prev;\t \t\\\n}\n\n \n#define\tTAILQ_FIRST(head)\t\t((head)->tqh_first)\n#define\tTAILQ_END(head)\t\t\tNULL\n#define\tTAILQ_NEXT(elm, field)\t\t((elm)->field.tqe_next)\n#define TAILQ_LAST(head, headname)\t\t\t\t\t\\\n\t(*(((struct headname *)((head)->tqh_last))->tqh_last))\n \n#define TAILQ_PREV(elm, headname, field)\t\t\t\t\\\n\t(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))\n#define\tTAILQ_EMPTY(head)\t\t\t\t\t\t\\\n\t(TAILQ_FIRST(head) == TAILQ_END(head))\n\n#define TAILQ_FOREACH(var, head, field)\t\t\t\t\t\\\n\tfor((var) = TAILQ_FIRST(head);\t\t\t\t\t\\\n\t    (var) != TAILQ_END(head);\t\t\t\t\t\\\n\t    (var) = TAILQ_NEXT(var, field))\n\n#define\tTAILQ_FOREACH_SAFE(var, head, field, tvar)\t\t\t\\\n\tfor ((var) = TAILQ_FIRST(head);\t\t\t\t\t\\\n\t    (var) != TAILQ_END(head) &&\t\t\t\t\t\\\n\t    ((tvar) = TAILQ_NEXT(var, field), 1);\t\t\t\\\n\t    (var) = (tvar))\n\n\n#define TAILQ_FOREACH_REVERSE(var, head, headname, field)\t\t\\\n\tfor((var) = TAILQ_LAST(head, headname);\t\t\t\t\\\n\t    (var) != TAILQ_END(head);\t\t\t\t\t\\\n\t    (var) = TAILQ_PREV(var, headname, field))\n\n#define\tTAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)\t\\\n\tfor ((var) = TAILQ_LAST(head, headname);\t\t\t\\\n\t    (var) != TAILQ_END(head) &&\t\t\t\t\t\\\n\t    ((tvar) = TAILQ_PREV(var, headname, field), 1);\t\t\\\n\t    (var) = (tvar))\n\n \n#define\tTAILQ_INIT(head) do {\t\t\t\t\t\t\\\n\t(head)->tqh_first = NULL;\t\t\t\t\t\\\n\t(head)->tqh_last = &(head)->tqh_first;\t\t\t\t\\\n} while (0)\n\n#define TAILQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n\tif (((elm)->field.tqe_next = (head)->tqh_first) != NULL)\t\\\n\t\t(head)->tqh_first->field.tqe_prev =\t\t\t\\\n\t\t    &(elm)->field.tqe_next;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = &(elm)->field.tqe_next;\t\t\\\n\t(head)->tqh_first = (elm);\t\t\t\t\t\\\n\t(elm)->field.tqe_prev = &(head)->tqh_first;\t\t\t\\\n} while (0)\n\n#define TAILQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n\t(elm)->field.tqe_next = NULL;\t\t\t\t\t\\\n\t(elm)->field.tqe_prev = (head)->tqh_last;\t\t\t\\\n\t*(head)->tqh_last = (elm);\t\t\t\t\t\\\n\t(head)->tqh_last = &(elm)->field.tqe_next;\t\t\t\\\n} while (0)\n\n#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n\tif (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\\\n\t\t(elm)->field.tqe_next->field.tqe_prev =\t\t\t\\\n\t\t    &(elm)->field.tqe_next;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = &(elm)->field.tqe_next;\t\t\\\n\t(listelm)->field.tqe_next = (elm);\t\t\t\t\\\n\t(elm)->field.tqe_prev = &(listelm)->field.tqe_next;\t\t\\\n} while (0)\n\n#define\tTAILQ_INSERT_BEFORE(listelm, elm, field) do {\t\t\t\\\n\t(elm)->field.tqe_prev = (listelm)->field.tqe_prev;\t\t\\\n\t(elm)->field.tqe_next = (listelm);\t\t\t\t\\\n\t*(listelm)->field.tqe_prev = (elm);\t\t\t\t\\\n\t(listelm)->field.tqe_prev = &(elm)->field.tqe_next;\t\t\\\n} while (0)\n\n#define TAILQ_REMOVE(head, elm, field) do {\t\t\t\t\\\n\tif (((elm)->field.tqe_next) != NULL)\t\t\t\t\\\n\t\t(elm)->field.tqe_next->field.tqe_prev =\t\t\t\\\n\t\t    (elm)->field.tqe_prev;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = (elm)->field.tqe_prev;\t\t\\\n\t*(elm)->field.tqe_prev = (elm)->field.tqe_next;\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.tqe_prev);\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.tqe_next);\t\t\t\t\\\n} while (0)\n\n#define TAILQ_REPLACE(head, elm, elm2, field) do {\t\t\t\\\n\tif (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)\t\\\n\t\t(elm2)->field.tqe_next->field.tqe_prev =\t\t\\\n\t\t    &(elm2)->field.tqe_next;\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t(head)->tqh_last = &(elm2)->field.tqe_next;\t\t\\\n\t(elm2)->field.tqe_prev = (elm)->field.tqe_prev;\t\t\t\\\n\t*(elm2)->field.tqe_prev = (elm2);\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.tqe_prev);\t\t\t\t\\\n\t_Q_INVALIDATE((elm)->field.tqe_next);\t\t\t\t\\\n} while (0)\n\n#define TAILQ_CONCAT(head1, head2, field) do {\t\t\t\t\\\n\tif (!TAILQ_EMPTY(head2)) {\t\t\t\t\t\\\n\t\t*(head1)->tqh_last = (head2)->tqh_first;\t\t\\\n\t\t(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;\t\\\n\t\t(head1)->tqh_last = (head2)->tqh_last;\t\t\t\\\n\t\tTAILQ_INIT((head2));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}