{
  "module_name": "bsd-pselect.c",
  "hash_id": "cac3df55e6d61682246a13d9d4ef2d09269b2d10ff92687eca1cb63e113b17ed",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bsd-pselect.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n#ifndef HAVE_PSELECT\n\n#include <sys/types.h>\n#include <sys/time.h>\n#ifdef HAVE_SYS_SELECT_H\n# include <sys/select.h>\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"log.h\"\n#include \"misc.h\"       \n\n#ifndef HAVE_SIGHANDLER_T\ntypedef void (*sighandler_t)(int);\n#endif\n\nstatic sighandler_t saved_sighandler[_NSIG];\n\n \n#define REEXEC_MIN_FREE_FD (STDERR_FILENO + 4)\nstatic int\npselect_notify_setup_fd(int *fd)\n{\n\tint r;\n\n\tif ((r = fcntl(*fd, F_DUPFD, REEXEC_MIN_FREE_FD)) < 0 ||\n\t    fcntl(r, F_SETFD, FD_CLOEXEC) < 0 || r >= FD_SETSIZE)\n\t\treturn -1;\n\t(void)close(*fd);\n\treturn (*fd = r);\n}\n\n \nstatic pid_t notify_pid;\nstatic int notify_pipe[2];\nstatic void\npselect_notify_setup(void)\n{\n\tstatic int initialized;\n\n\tif (initialized && notify_pid == getpid())\n\t\treturn;\n\tif (notify_pid == 0)\n\t\tdebug3_f(\"initializing\");\n\telse {\n\t\tdebug3_f(\"pid changed, reinitializing\");\n\t\tif (notify_pipe[0] != -1)\n\t\t\tclose(notify_pipe[0]);\n\t\tif (notify_pipe[1] != -1)\n\t\t\tclose(notify_pipe[1]);\n\t}\n\tif (pipe(notify_pipe) == -1) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if (pselect_notify_setup_fd(&notify_pipe[0]) == -1 ||\n\t    pselect_notify_setup_fd(&notify_pipe[1]) == -1) {\n\t\terror(\"fcntl(notify_pipe, ...) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\tnotify_pid = getpid();\n\t\tdebug3_f(\"pid %d saved %d pipe0 %d pipe1 %d\", getpid(),\n\t\t    notify_pid, notify_pipe[0], notify_pipe[1]);\n\t\tinitialized = 1;\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;     \n\tnotify_pipe[1] = -1;     \n}\nstatic void\npselect_notify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}\nstatic void\npselect_notify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}\nstatic void\npselect_notify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset)) {\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2_f(\"reading\");\n\t\tFD_CLR(notify_pipe[0], readset);\n\t}\n}\n\n \nstatic void\npselect_sig_handler(int sig)\n{\n\tint save_errno = errno;\n\n\tpselect_notify_parent();\n\tif (saved_sighandler[sig] != NULL)\n\t\t(*saved_sighandler[sig])(sig);   \n\terrno = save_errno;\n}\n\n \n\nint\npselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,\n    const struct timespec *timeout, const sigset_t *mask)\n{\n\tint ret, sig, saved_errno, unmasked = 0;\n\tsigset_t osig;\n\tstruct sigaction sa, osa;\n\tstruct timeval tv, *tvp = NULL;\n\n\tif (timeout != NULL) {\n\t\ttv.tv_sec = timeout->tv_sec;\n\t\ttv.tv_usec = timeout->tv_nsec / 1000;\n\t\ttvp = &tv;\n\t}\n\tif (mask == NULL)   \n\t\treturn select(nfds, readfds, writefds, exceptfds, tvp);\n\n\t \n\tfor (sig = 0; sig < _NSIG; sig++) {\n\t\tif (sig == SIGKILL || sig == SIGSTOP || sigismember(mask, sig))\n\t\t\tcontinue;\n\t\tif (sigaction(sig, NULL, &sa) == 0 &&\n\t\t    sa.sa_handler != SIG_IGN && sa.sa_handler != SIG_DFL) {\n\t\t\tunmasked = 1;\n\t\t\tif (sa.sa_handler == pselect_sig_handler)\n\t\t\t\tcontinue;\n\t\t\tsa.sa_handler = pselect_sig_handler;\n\t\t\tif (sigaction(sig, &sa, &osa) == 0) {\n\t\t\t\tdebug3_f(\"installing signal handler for %s, \"\n\t\t\t\t    \"previous %p\", strsignal(sig),\n\t\t\t\t     osa.sa_handler);\n\t\t\t\tsaved_sighandler[sig] = osa.sa_handler;\n\t\t\t}\n\t\t}\n\t}\n\tif (unmasked) {\n\t\tpselect_notify_setup();\n\t\tpselect_notify_prepare(readfds);\n\t\tnfds = MAX(nfds, notify_pipe[0] + 1);\n\t}\n\n\t \n\tsigprocmask(SIG_SETMASK, mask, &osig);\n\tret = select(nfds, readfds, writefds, exceptfds, tvp);\n\tsaved_errno = errno;\n\tsigprocmask(SIG_SETMASK, &osig, NULL);\n\n\tif (unmasked)\n\t\tpselect_notify_done(readfds);\n\terrno = saved_errno;\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}