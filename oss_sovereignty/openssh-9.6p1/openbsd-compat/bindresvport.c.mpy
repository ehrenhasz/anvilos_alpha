{
  "module_name": "bindresvport.c",
  "hash_id": "db762ec0e0a61f74ae05150a30e1e239ec11a7c855d33e207d30e0223792e41b",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bindresvport.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include \"includes.h\"\n\n#ifndef HAVE_BINDRESVPORT_SA\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define STARTPORT 600\n#define ENDPORT (IPPORT_RESERVED - 1)\n#define NPORTS\t(ENDPORT - STARTPORT + 1)\n\n \nint\nbindresvport_sa(int sd, struct sockaddr *sa)\n{\n\tint error, af;\n\tstruct sockaddr_storage myaddr;\n\tstruct sockaddr_in *in;\n\tstruct sockaddr_in6 *in6;\n\tu_int16_t *portp;\n\tu_int16_t port;\n\tsocklen_t salen;\n\tint i;\n\n\tif (sa == NULL) {\n\t\tmemset(&myaddr, 0, sizeof(myaddr));\n\t\tsa = (struct sockaddr *)&myaddr;\n\t\tsalen = sizeof(myaddr);\n\n\t\tif (getsockname(sd, sa, &salen) == -1)\n\t\t\treturn -1;\t \n\n\t\taf = sa->sa_family;\n\t\tmemset(&myaddr, 0, salen);\n\t} else\n\t\taf = sa->sa_family;\n\n\tif (af == AF_INET) {\n\t\tin = (struct sockaddr_in *)sa;\n\t\tsalen = sizeof(struct sockaddr_in);\n\t\tportp = &in->sin_port;\n\t} else if (af == AF_INET6) {\n\t\tin6 = (struct sockaddr_in6 *)sa;\n\t\tsalen = sizeof(struct sockaddr_in6);\n\t\tportp = &in6->sin6_port;\n\t} else {\n\t\terrno = EPFNOSUPPORT;\n\t\treturn (-1);\n\t}\n\tsa->sa_family = af;\n\n\tport = ntohs(*portp);\n\tif (port == 0)\n\t\tport = arc4random_uniform(NPORTS) + STARTPORT;\n\n\t \n\terror = -1;\n\n\tfor(i = 0; i < NPORTS; i++) {\n\t\t*portp = htons(port);\n\t\t\n\t\terror = bind(sd, sa, salen);\n\n\t\t \n\t\tif (error == 0)\n\t\t\tbreak;\n\t\t\t\n\t\t \n\t\tif ((error < 0) && !((errno == EADDRINUSE) || (errno == EINVAL)))\n\t\t\tbreak;\n\t\t\t\n\t\tport++;\n\t\tif (port > ENDPORT)\n\t\t\tport = STARTPORT;\n\t}\n\n\treturn (error);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}