{
  "module_name": "inet_ntop.c",
  "hash_id": "86ed8a77eabeefb4e450adb48fd128c92249dbc8fef58e34943b63c300602495",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/inet_ntop.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"includes.h\"\n\n#ifndef HAVE_INET_NTOP\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <arpa/nameser.h>\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n\n#ifndef IN6ADDRSZ\n#define IN6ADDRSZ   16                     \n#endif\n\n#ifndef INT16SZ\n#define INT16SZ     2     \n#endif\n\n \n\nstatic const char *inet_ntop4(const u_char *src, char *dst, size_t size);\nstatic const char *inet_ntop6(const u_char *src, char *dst, size_t size);\n\n \nconst char *\ninet_ntop(int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, (size_t)size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, (size_t)size));\n\tdefault:\n\t\terrno = EAFNOSUPPORT;\n\t\treturn (NULL);\n\t}\n\t \n}\n\n \nstatic const char *\ninet_ntop4(const u_char *src, char *dst, size_t size)\n{\n\tstatic const char fmt[] = \"%u.%u.%u.%u\";\n\tchar tmp[sizeof \"255.255.255.255\"];\n\tint l;\n\n\tl = snprintf(tmp, size, fmt, src[0], src[1], src[2], src[3]);\n\tif (l <= 0 || l >= size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}\n\n \nstatic const char *\ninet_ntop6(const u_char *src, char *dst, size_t size)\n{\n\t \n\tchar tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"];\n\tchar *tp, *ep;\n\tstruct { int base, len; } best, cur;\n\tu_int words[IN6ADDRSZ / INT16SZ];\n\tint i;\n\tint advance;\n\n\t \n\tmemset(words, '\\0', sizeof words);\n\tfor (i = 0; i < IN6ADDRSZ; i++)\n\t\twords[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n\tbest.base = -1;\n\tcur.base = -1;\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {\n\t\tif (words[i] == 0) {\n\t\t\tif (cur.base == -1)\n\t\t\t\tcur.base = i, cur.len = 1;\n\t\t\telse\n\t\t\t\tcur.len++;\n\t\t} else {\n\t\t\tif (cur.base != -1) {\n\t\t\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\t\t\tbest = cur;\n\t\t\t\tcur.base = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur.base != -1) {\n\t\tif (best.base == -1 || cur.len > best.len)\n\t\t\tbest = cur;\n\t}\n\tif (best.base != -1 && best.len < 2)\n\t\tbest.base = -1;\n\n\t \n\ttp = tmp;\n\tep = tmp + sizeof(tmp);\n\tfor (i = 0; i < (IN6ADDRSZ / INT16SZ) && tp < ep; i++) {\n\t\t \n\t\tif (best.base != -1 && i >= best.base &&\n\t\t    i < (best.base + best.len)) {\n\t\t\tif (i == best.base) {\n\t\t\t\tif (tp + 1 >= ep)\n\t\t\t\t\treturn (NULL);\n\t\t\t\t*tp++ = ':';\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (i != 0) {\n\t\t\tif (tp + 1 >= ep)\n\t\t\t\treturn (NULL);\n\t\t\t*tp++ = ':';\n\t\t}\n\t\t \n\t\tif (i == 6 && best.base == 0 &&\n\t\t    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n\t\t\tif (!inet_ntop4(src+12, tp, (size_t)(ep - tp)))\n\t\t\t\treturn (NULL);\n\t\t\ttp += strlen(tp);\n\t\t\tbreak;\n\t\t}\n\t\tadvance = snprintf(tp, ep - tp, \"%x\", words[i]);\n\t\tif (advance <= 0 || advance >= ep - tp)\n\t\t\treturn (NULL);\n\t\ttp += advance;\n\t}\n\t \n\tif (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ)) {\n\t\tif (tp + 1 >= ep)\n\t\t\treturn (NULL);\n\t\t*tp++ = ':';\n\t}\n\tif (tp + 1 >= ep)\n\t\treturn (NULL);\n\t*tp++ = '\\0';\n\n\t \n\tif ((size_t)(tp - tmp) > size) {\n\t\terrno = ENOSPC;\n\t\treturn (NULL);\n\t}\n\tstrlcpy(dst, tmp, size);\n\treturn (dst);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}