{
  "module_name": "readpassphrase.c",
  "hash_id": "305ddd4367b61d7c5573da8f6eb2118597ded710c2bb7c6fd6cf8630f06687b2",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/readpassphrase.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"includes.h\"\n\n#ifndef HAVE_READPASSPHRASE\n\n#include <termios.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <readpassphrase.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifndef TCSASOFT\n \n# define TCSASOFT 0\n#endif\n\n \n#if !defined(_POSIX_VDISABLE) && defined(VDISABLE)\n#  define _POSIX_VDISABLE       VDISABLE\n#endif\n\nstatic volatile sig_atomic_t signo[_NSIG];\n\nstatic void handler(int);\n\nchar *\nreadpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)\n{\n\tssize_t nr;\n\tint input, output, save_errno, i, need_restart;\n\tchar ch, *p, *end;\n\tstruct termios term, oterm;\n\tstruct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n\tstruct sigaction savetstp, savettin, savettou, savepipe;\n\n\t \n\tif (bufsiz == 0) {\n\t\terrno = EINVAL;\n\t\treturn(NULL);\n\t}\n\nrestart:\n\tfor (i = 0; i < _NSIG; i++)\n\t\tsigno[i] = 0;\n\tnr = -1;\n\tsave_errno = 0;\n\tneed_restart = 0;\n\t \n\tif ((flags & RPP_STDIN) ||\n\t    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {\n\t\tif (flags & RPP_REQUIRE_TTY) {\n\t\t\terrno = ENOTTY;\n\t\t\treturn(NULL);\n\t\t}\n\t\tinput = STDIN_FILENO;\n\t\toutput = STDERR_FILENO;\n\t}\n\n\t \n\tif (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {\n\t\tmemcpy(&term, &oterm, sizeof(term));\n\t\tif (!(flags & RPP_ECHO_ON))\n\t\t\tterm.c_lflag &= ~(ECHO | ECHONL);\n#ifdef VSTATUS\n\t\tif (term.c_cc[VSTATUS] != _POSIX_VDISABLE)\n\t\t\tterm.c_cc[VSTATUS] = _POSIX_VDISABLE;\n#endif\n\t\t(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);\n\t} else {\n\t\tmemset(&term, 0, sizeof(term));\n\t\tterm.c_lflag |= ECHO;\n\t\tmemset(&oterm, 0, sizeof(oterm));\n\t\toterm.c_lflag |= ECHO;\n\t}\n\n\t \n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\t\t \n\tsa.sa_handler = handler;\n\t(void)sigaction(SIGALRM, &sa, &savealrm);\n\t(void)sigaction(SIGHUP, &sa, &savehup);\n\t(void)sigaction(SIGINT, &sa, &saveint);\n\t(void)sigaction(SIGPIPE, &sa, &savepipe);\n\t(void)sigaction(SIGQUIT, &sa, &savequit);\n\t(void)sigaction(SIGTERM, &sa, &saveterm);\n\t(void)sigaction(SIGTSTP, &sa, &savetstp);\n\t(void)sigaction(SIGTTIN, &sa, &savettin);\n\t(void)sigaction(SIGTTOU, &sa, &savettou);\n\n\tif (!(flags & RPP_STDIN))\n\t\t(void)write(output, prompt, strlen(prompt));\n\tend = buf + bufsiz - 1;\n\tp = buf;\n\twhile ((nr = read(input, &ch, 1)) == 1 && ch != '\\n' && ch != '\\r') {\n\t\tif (p < end) {\n\t\t\tif ((flags & RPP_SEVENBIT))\n\t\t\t\tch &= 0x7f;\n\t\t\tif (isalpha((unsigned char)ch)) {\n\t\t\t\tif ((flags & RPP_FORCELOWER))\n\t\t\t\t\tch = (char)tolower((unsigned char)ch);\n\t\t\t\tif ((flags & RPP_FORCEUPPER))\n\t\t\t\t\tch = (char)toupper((unsigned char)ch);\n\t\t\t}\n\t\t\t*p++ = ch;\n\t\t}\n\t}\n\t*p = '\\0';\n\tsave_errno = errno;\n\tif (!(term.c_lflag & ECHO))\n\t\t(void)write(output, \"\\n\", 1);\n\n\t \n\tif (memcmp(&term, &oterm, sizeof(term)) != 0) {\n\t\tconst int sigttou = signo[SIGTTOU];\n\n\t\t \n\t\twhile (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&\n\t\t    errno == EINTR && !signo[SIGTTOU])\n\t\t\tcontinue;\n\t\tsigno[SIGTTOU] = sigttou;\n\t}\n\t(void)sigaction(SIGALRM, &savealrm, NULL);\n\t(void)sigaction(SIGHUP, &savehup, NULL);\n\t(void)sigaction(SIGINT, &saveint, NULL);\n\t(void)sigaction(SIGQUIT, &savequit, NULL);\n\t(void)sigaction(SIGPIPE, &savepipe, NULL);\n\t(void)sigaction(SIGTERM, &saveterm, NULL);\n\t(void)sigaction(SIGTSTP, &savetstp, NULL);\n\t(void)sigaction(SIGTTIN, &savettin, NULL);\n\t(void)sigaction(SIGTTOU, &savettou, NULL);\n\tif (input != STDIN_FILENO)\n\t\t(void)close(input);\n\n\t \n\tfor (i = 0; i < _NSIG; i++) {\n\t\tif (signo[i]) {\n\t\t\tkill(getpid(), i);\n\t\t\tswitch (i) {\n\t\t\tcase SIGTSTP:\n\t\t\tcase SIGTTIN:\n\t\t\tcase SIGTTOU:\n\t\t\t\tneed_restart = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_restart)\n\t\tgoto restart;\n\n\tif (save_errno)\n\t\terrno = save_errno;\n\treturn(nr == -1 ? NULL : buf);\n}\nDEF_WEAK(readpassphrase);\n\n#if 0\nchar *\ngetpass(const char *prompt)\n{\n\tstatic char buf[_PASSWORD_LEN + 1];\n\n\treturn(readpassphrase(prompt, buf, sizeof(buf), RPP_ECHO_OFF));\n}\n#endif\n\nstatic void handler(int s)\n{\n\n\tsigno[s] = 1;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}