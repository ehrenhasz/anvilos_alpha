{
  "module_name": "bsd-misc.c",
  "hash_id": "4e26af09be4cfe7044f2a80ef3f7b08a0621f1bf70c41fb53ec8b1a45b116f41",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bsd-misc.c",
  "human_readable_source": "\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_SELECT_H\n# include <sys/select.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <fcntl.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n#include <unistd.h>\n\n#ifndef HAVE___PROGNAME\nchar *__progname;\n#endif\n\n \nchar *ssh_get_progname(char *argv0)\n{\n\tchar *p, *q;\n#ifdef HAVE___PROGNAME\n\textern char *__progname;\n\n\tp = __progname;\n#else\n\tif (argv0 == NULL)\n\t\treturn (\"unknown\");\t \n\tp = strrchr(argv0, '/');\n\tif (p == NULL)\n\t\tp = argv0;\n\telse\n\t\tp++;\n#endif\n\tif ((q = strdup(p)) == NULL) {\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\treturn q;\n}\n\n#ifndef HAVE_SETLOGIN\nint setlogin(const char *name)\n{\n\treturn (0);\n}\n#endif  \n\n#ifndef HAVE_INNETGR\nint innetgr(const char *netgroup, const char *host,\n\t    const char *user, const char *domain)\n{\n\treturn (0);\n}\n#endif  \n\n#if !defined(HAVE_SETEUID) && defined(HAVE_SETREUID)\nint seteuid(uid_t euid)\n{\n\treturn (setreuid(-1, euid));\n}\n#endif  \n\n#if !defined(HAVE_SETEGID) && defined(HAVE_SETRESGID)\nint setegid(uid_t egid)\n{\n\treturn(setresgid(-1, egid, -1));\n}\n#endif  \n\n#if !defined(HAVE_STRERROR) && defined(HAVE_SYS_ERRLIST) && defined(HAVE_SYS_NERR)\nconst char *strerror(int e)\n{\n\textern int sys_nerr;\n\textern char *sys_errlist[];\n\n\tif ((e >= 0) && (e < sys_nerr))\n\t\treturn (sys_errlist[e]);\n\n\treturn (\"unlisted error\");\n}\n#endif\n\n#ifndef HAVE_UTIMES\nint utimes(const char *filename, struct timeval *tvp)\n{\n\tstruct utimbuf ub;\n\n\tub.actime = tvp[0].tv_sec;\n\tub.modtime = tvp[1].tv_sec;\n\n\treturn (utime(filename, &ub));\n}\n#endif\n\n#ifndef HAVE_UTIMENSAT\n \nint\nutimensat(int fd, const char *path, const struct timespec times[2],\n    int flag)\n{\n\tstruct timeval tv[2];\n# ifdef HAVE_FUTIMES\n\tint ret, oflags = O_WRONLY;\n# endif\n\n\ttv[0].tv_sec = times[0].tv_sec;\n\ttv[0].tv_usec = times[0].tv_nsec / 1000;\n\ttv[1].tv_sec = times[1].tv_sec;\n\ttv[1].tv_usec = times[1].tv_nsec / 1000;\n\n\tif (fd != AT_FDCWD) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n# ifndef HAVE_FUTIMES\n\treturn utimes(path, tv);\n# else\n#  ifdef O_NOFOLLOW\n\tif (flag & AT_SYMLINK_NOFOLLOW)\n\t\toflags |= O_NOFOLLOW;\n#  endif  \n\tif ((fd = open(path, oflags)) == -1)\n\t\treturn -1;\n\tret = futimes(fd, tv);\n\tclose(fd);\n\treturn ret;\n# endif\n}\n#endif\n\n#ifndef HAVE_FCHOWNAT\n \nint\nfchownat(int fd, const char *path, uid_t owner, gid_t group, int flag)\n{\n\tint ret, oflags = O_WRONLY;\n\n\tif (fd != AT_FDCWD) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n# ifndef HAVE_FCHOWN\n\treturn chown(path, owner, group);\n# else\n#  ifdef O_NOFOLLOW\n\tif (flag & AT_SYMLINK_NOFOLLOW)\n\t\toflags |= O_NOFOLLOW;\n#  endif  \n\tif ((fd = open(path, oflags)) == -1)\n\t\treturn -1;\n\tret = fchown(fd, owner, group);\n\tclose(fd);\n\treturn ret;\n# endif\n}\n#endif\n\n#ifndef HAVE_FCHMODAT\n \nint\nfchmodat(int fd, const char *path, mode_t mode, int flag)\n{\n\tint ret, oflags = O_WRONLY;\n\n\tif (fd != AT_FDCWD) {\n\t\terrno = ENOSYS;\n\t\treturn -1;\n\t}\n# ifndef HAVE_FCHMOD\n\treturn chmod(path, mode);\n# else\n#  ifdef O_NOFOLLOW\n\tif (flag & AT_SYMLINK_NOFOLLOW)\n\t\toflags |= O_NOFOLLOW;\n#  endif  \n\tif ((fd = open(path, oflags)) == -1)\n\t\treturn -1;\n\tret = fchmod(fd, mode);\n\tclose(fd);\n\treturn ret;\n# endif\n}\n#endif\n\n#ifndef HAVE_TRUNCATE\nint truncate(const char *path, off_t length)\n{\n\tint fd, ret, saverrno;\n\n\tfd = open(path, O_WRONLY);\n\tif (fd < 0)\n\t\treturn (-1);\n\n\tret = ftruncate(fd, length);\n\tsaverrno = errno;\n\tclose(fd);\n\tif (ret == -1)\n\t\terrno = saverrno;\n\n\treturn(ret);\n}\n#endif  \n\n#if !defined(HAVE_NANOSLEEP) && !defined(HAVE_NSLEEP)\nint nanosleep(const struct timespec *req, struct timespec *rem)\n{\n\tint rc, saverrno;\n\textern int errno;\n\tstruct timeval tstart, tstop, tremain, time2wait;\n\n\tTIMESPEC_TO_TIMEVAL(&time2wait, req)\n\t(void) gettimeofday(&tstart, NULL);\n\trc = select(0, NULL, NULL, NULL, &time2wait);\n\tif (rc == -1) {\n\t\tsaverrno = errno;\n\t\t(void) gettimeofday (&tstop, NULL);\n\t\terrno = saverrno;\n\t\ttremain.tv_sec = time2wait.tv_sec -\n\t\t\t(tstop.tv_sec - tstart.tv_sec);\n\t\ttremain.tv_usec = time2wait.tv_usec -\n\t\t\t(tstop.tv_usec - tstart.tv_usec);\n\t\ttremain.tv_sec += tremain.tv_usec / 1000000L;\n\t\ttremain.tv_usec %= 1000000L;\n\t} else {\n\t\ttremain.tv_sec = 0;\n\t\ttremain.tv_usec = 0;\n\t}\n\tif (rem != NULL)\n\t\tTIMEVAL_TO_TIMESPEC(&tremain, rem)\n\n\treturn(rc);\n}\n#endif\n\n#if !defined(HAVE_USLEEP)\nint usleep(unsigned int useconds)\n{\n\tstruct timespec ts;\n\n\tts.tv_sec = useconds / 1000000;\n\tts.tv_nsec = (useconds % 1000000) * 1000;\n\treturn nanosleep(&ts, NULL);\n}\n#endif\n\n#ifndef HAVE_TCGETPGRP\npid_t\ntcgetpgrp(int fd)\n{\n\tint ctty_pgrp;\n\n\tif (ioctl(fd, TIOCGPGRP, &ctty_pgrp) == -1)\n\t\treturn(-1);\n\telse\n\t\treturn(ctty_pgrp);\n}\n#endif  \n\n#ifndef HAVE_TCSENDBREAK\nint\ntcsendbreak(int fd, int duration)\n{\n# if defined(TIOCSBRK) && defined(TIOCCBRK)\n\tstruct timeval sleepytime;\n\n\tsleepytime.tv_sec = 0;\n\tsleepytime.tv_usec = 400000;\n\tif (ioctl(fd, TIOCSBRK, 0) == -1)\n\t\treturn (-1);\n\t(void)select(0, 0, 0, 0, &sleepytime);\n\tif (ioctl(fd, TIOCCBRK, 0) == -1)\n\t\treturn (-1);\n\treturn (0);\n# else\n\treturn -1;\n# endif\n}\n#endif  \n\n#ifndef HAVE_STRDUP\nchar *\nstrdup(const char *str)\n{\n\tsize_t len;\n\tchar *cp;\n\n\tlen = strlen(str) + 1;\n\tcp = malloc(len);\n\tif (cp != NULL)\n\t\treturn(memcpy(cp, str, len));\n\treturn NULL;\n}\n#endif\n\n#ifndef HAVE_ISBLANK\nint\nisblank(int c)\n{\n\treturn (c == ' ' || c == '\\t');\n}\n#endif\n\n#ifndef HAVE_GETPGID\npid_t\ngetpgid(pid_t pid)\n{\n#if defined(HAVE_GETPGRP) && !defined(GETPGRP_VOID) && GETPGRP_VOID == 0\n\treturn getpgrp(pid);\n#elif defined(HAVE_GETPGRP)\n\tif (pid == 0)\n\t\treturn getpgrp();\n#endif\n\n\terrno = ESRCH;\n\treturn -1;\n}\n#endif\n\n#ifndef HAVE_PLEDGE\nint\npledge(const char *promises, const char *paths[])\n{\n\treturn 0;\n}\n#endif\n\n#ifndef HAVE_MBTOWC\n \nint\nmbtowc(wchar_t *pwc, const char *s, size_t n)\n{\n\tif (s == NULL || *s == '\\0')\n\t\treturn 0;\t \n\tif (*s < 0 || *s > 0x7f || n < 1) {\n\t\terrno = EOPNOTSUPP;\n\t\treturn -1;\n\t}\n\tif (pwc != NULL)\n\t\t*pwc = *s;\n\treturn 1;\n}\n#endif\n\n#ifndef HAVE_LLABS\nlong long\nllabs(long long j)\n{\n\treturn (j < 0 ? -j : j);\n}\n#endif\n\n#ifndef HAVE_BZERO\nvoid\nbzero(void *b, size_t n)\n{\n\t(void)memset(b, 0, n);\n}\n#endif\n\n#ifndef HAVE_RAISE\nint\nraise(int sig)\n{\n\tkill(getpid(), sig);\n}\n#endif\n\n#ifndef HAVE_GETSID\npid_t\ngetsid(pid_t pid)\n{\n\terrno = ENOSYS;\n\treturn -1;\n}\n#endif\n\n#ifndef HAVE_KILLPG\nint\nkillpg(pid_t pgrp, int sig)\n{\n\treturn kill(pgrp, sig);\n}\n#endif\n\n#ifdef FFLUSH_NULL_BUG\n#undef fflush\nint _ssh_compat_fflush(FILE *f)\n{\n\tint r1, r2;\n\n\tif (f == NULL) {\n\t\tr1 = fflush(stdout);\n\t\tr2 = fflush(stderr);\n\t\tif (r1 == -1 || r2 == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\treturn fflush(f);\n}\n#endif\n\n#ifndef HAVE_LOCALTIME_R\nstruct tm *\nlocaltime_r(const time_t *timep, struct tm *result)\n{\n\tstruct tm *tm = localtime(timep);\n\t*result = *tm;\n\treturn result;\n}\n#endif\n\n#ifdef ASAN_OPTIONS\nconst char *__asan_default_options(void) {\n\treturn ASAN_OPTIONS;\n}\n#endif\n\n#ifdef MSAN_OPTIONS\nconst char *__msan_default_options(void) {\n\treturn MSAN_OPTIONS;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}