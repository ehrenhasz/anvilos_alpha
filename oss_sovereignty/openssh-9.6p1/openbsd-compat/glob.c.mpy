{
  "module_name": "glob.c",
  "hash_id": "d7c9c10db475b94ea4acd08ea714eff9214c915d7b79d512a376c1f309dc2da5",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/glob.c",
  "human_readable_source": " \n \n\n \n\n \n\n#include \"includes.h\"\n#include \"glob.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <dirent.h>\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdlib.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <string.h>\n#include <unistd.h>\n\n#if !defined(HAVE_GLOB) || !defined(GLOB_HAS_ALTDIRFUNC) || \\\n    !defined(GLOB_HAS_GL_MATCHC) || !defined(GLOB_HAS_GL_STATV) || \\\n    !defined(HAVE_DECL_GLOB_NOMATCH) || HAVE_DECL_GLOB_NOMATCH == 0 || \\\n    defined(BROKEN_GLOB)\n\n#include \"charclass.h\"\n\n#ifdef TILDE\n# undef TILDE\n#endif\n\n#define\tDOLLAR\t\t'$'\n#define\tDOT\t\t'.'\n#define\tEOS\t\t'\\0'\n#define\tLBRACKET\t'['\n#define\tNOT\t\t'!'\n#define\tQUESTION\t'?'\n#define\tQUOTE\t\t'\\\\'\n#define\tRANGE\t\t'-'\n#define\tRBRACKET\t']'\n#define\tSEP\t\t'/'\n#define\tSTAR\t\t'*'\n#define\tTILDE\t\t'~'\n#define\tUNDERSCORE\t'_'\n#define\tLBRACE\t\t'{'\n#define\tRBRACE\t\t'}'\n#define\tSLASH\t\t'/'\n#define\tCOMMA\t\t','\n\n#ifndef DEBUG\n\n#define\tM_QUOTE\t\t0x8000\n#define\tM_PROTECT\t0x4000\n#define\tM_MASK\t\t0xffff\n#define\tM_ASCII\t\t0x00ff\n\ntypedef u_short Char;\n\n#else\n\n#define\tM_QUOTE\t\t0x80\n#define\tM_PROTECT\t0x40\n#define\tM_MASK\t\t0xff\n#define\tM_ASCII\t\t0x7f\n\ntypedef char Char;\n\n#endif\n\n\n#define\tCHAR(c)\t\t((Char)((c)&M_ASCII))\n#define\tMETA(c)\t\t((Char)((c)|M_QUOTE))\n#define\tM_ALL\t\tMETA('*')\n#define\tM_END\t\tMETA(']')\n#define\tM_NOT\t\tMETA('!')\n#define\tM_ONE\t\tMETA('?')\n#define\tM_RNG\t\tMETA('-')\n#define\tM_SET\t\tMETA('[')\n#define\tM_CLASS\t\tMETA(':')\n#define\tismeta(c)\t(((c)&M_QUOTE) != 0)\n\n#define\tGLOB_LIMIT_MALLOC\t65536\n#define\tGLOB_LIMIT_STAT\t\t2048\n#define\tGLOB_LIMIT_READDIR\t16384\n\nstruct glob_lim {\n\tsize_t\tglim_malloc;\n\tsize_t\tglim_stat;\n\tsize_t\tglim_readdir;\n};\n\nstruct glob_path_stat {\n\tchar\t\t*gps_path;\n\tstruct stat\t*gps_stat;\n};\n\nstatic int\t compare(const void *, const void *);\nstatic int\t compare_gps(const void *, const void *);\nstatic int\t g_Ctoc(const Char *, char *, size_t);\nstatic int\t g_lstat(Char *, struct stat *, glob_t *);\nstatic DIR\t*g_opendir(Char *, glob_t *);\nstatic Char\t*g_strchr(const Char *, int);\nstatic int\t g_strncmp(const Char *, const char *, size_t);\nstatic int\t g_stat(Char *, struct stat *, glob_t *);\nstatic int\t glob0(const Char *, glob_t *, struct glob_lim *);\nstatic int\t glob1(Char *, Char *, glob_t *, struct glob_lim *);\nstatic int\t glob2(Char *, Char *, Char *, Char *, Char *, Char *,\n\t\t    glob_t *, struct glob_lim *);\nstatic int\t glob3(Char *, Char *, Char *, Char *, Char *,\n\t\t    Char *, Char *, glob_t *, struct glob_lim *);\nstatic int\t globextend(const Char *, glob_t *, struct glob_lim *,\n\t\t    struct stat *);\nstatic const Char *\n\t\t globtilde(const Char *, Char *, size_t, glob_t *);\nstatic int\t globexp1(const Char *, glob_t *, struct glob_lim *);\nstatic int\t globexp2(const Char *, const Char *, glob_t *,\n\t\t    struct glob_lim *);\nstatic int\t match(Char *, Char *, Char *);\n#ifdef DEBUG\nstatic void\t qprintf(const char *, Char *);\n#endif\n\nint\nglob(const char *pattern, int flags, int (*errfunc)(const char *, int),\n    glob_t *pglob)\n{\n\tconst u_char *patnext;\n\tint c;\n\tChar *bufnext, *bufend, patbuf[PATH_MAX];\n\tstruct glob_lim limit = { 0, 0, 0 };\n\n\tpatnext = (u_char *) pattern;\n\tif (!(flags & GLOB_APPEND)) {\n\t\tpglob->gl_pathc = 0;\n\t\tpglob->gl_pathv = NULL;\n\t\tpglob->gl_statv = NULL;\n\t\tif (!(flags & GLOB_DOOFFS))\n\t\t\tpglob->gl_offs = 0;\n\t}\n\tpglob->gl_flags = flags & ~GLOB_MAGCHAR;\n\tpglob->gl_errfunc = errfunc;\n\tpglob->gl_matchc = 0;\n\n\tif (strnlen(pattern, PATH_MAX) == PATH_MAX)\n\t\treturn(GLOB_NOMATCH);\n\n\tif (pglob->gl_offs >= SSIZE_MAX || pglob->gl_pathc >= SSIZE_MAX ||\n\t    pglob->gl_pathc >= SSIZE_MAX - pglob->gl_offs - 1)\n\t\treturn GLOB_NOSPACE;\n\n\tbufnext = patbuf;\n\tbufend = bufnext + PATH_MAX - 1;\n\tif (flags & GLOB_NOESCAPE)\n\t\twhile (bufnext < bufend && (c = *patnext++) != EOS)\n\t\t\t*bufnext++ = c;\n\telse {\n\t\t \n\t\twhile (bufnext < bufend && (c = *patnext++) != EOS)\n\t\t\tif (c == QUOTE) {\n\t\t\t\tif ((c = *patnext++) == EOS) {\n\t\t\t\t\tc = QUOTE;\n\t\t\t\t\t--patnext;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = c | M_PROTECT;\n\t\t\t} else\n\t\t\t\t*bufnext++ = c;\n\t}\n\t*bufnext = EOS;\n\n\tif (flags & GLOB_BRACE)\n\t\treturn globexp1(patbuf, pglob, &limit);\n\telse\n\t\treturn glob0(patbuf, pglob, &limit);\n}\n\n \nstatic int\nglobexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char* ptr = pattern;\n\n\t \n\tif (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)\n\t\treturn glob0(pattern, pglob, limitp);\n\n\tif ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)\n\t\treturn globexp2(ptr, pattern, pglob, limitp);\n\n\treturn glob0(pattern, pglob, limitp);\n}\n\n\n \nstatic int\nglobexp2(const Char *ptr, const Char *pattern, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tint     i, rv;\n\tChar   *lm, *ls;\n\tconst Char *pe, *pm, *pl;\n\tChar    patbuf[PATH_MAX];\n\n\t \n\tfor (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)\n\t\t;\n\t*lm = EOS;\n\tls = lm;\n\n\t \n\tfor (i = 0, pe = ++ptr; *pe; pe++)\n\t\tif (*pe == LBRACKET) {\n\t\t\t \n\t\t\tfor (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)\n\t\t\t\t;\n\t\t\tif (*pe == EOS) {\n\t\t\t\t \n\t\t\t\tpe = pm;\n\t\t\t}\n\t\t} else if (*pe == LBRACE)\n\t\t\ti++;\n\t\telse if (*pe == RBRACE) {\n\t\t\tif (i == 0)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\n\t \n\tif (i != 0 || *pe == EOS)\n\t\treturn glob0(patbuf, pglob, limitp);\n\n\tfor (i = 0, pl = pm = ptr; pm <= pe; pm++) {\n\t\tswitch (*pm) {\n\t\tcase LBRACKET:\n\t\t\t \n\t\t\tfor (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)\n\t\t\t\t;\n\t\t\tif (*pm == EOS) {\n\t\t\t\t \n\t\t\t\tpm = pl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LBRACE:\n\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase RBRACE:\n\t\t\tif (i) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\tcase COMMA:\n\t\t\tif (i && *pm == COMMA)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tfor (lm = ls; (pl < pm); *lm++ = *pl++)\n\t\t\t\t\t;\n\n\t\t\t\t \n\t\t\t\tfor (pl = pe + 1; (*lm++ = *pl++) != EOS; )\n\t\t\t\t\t;\n\n\t\t\t\t \n#ifdef DEBUG\n\t\t\t\tqprintf(\"globexp2:\", patbuf);\n#endif\n\t\t\t\trv = globexp1(patbuf, pglob, limitp);\n\t\t\t\tif (rv && rv != GLOB_NOMATCH)\n\t\t\t\t\treturn rv;\n\n\t\t\t\t \n\t\t\t\tpl = pm + 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n \nstatic const Char *\nglobtilde(const Char *pattern, Char *patbuf, size_t patbuf_len, glob_t *pglob)\n{\n\tstruct passwd *pwd;\n\tchar *h;\n\tconst Char *p;\n\tChar *b, *eb;\n\n\tif (*pattern != TILDE || !(pglob->gl_flags & GLOB_TILDE))\n\t\treturn pattern;\n\n\t \n\teb = &patbuf[patbuf_len - 1];\n\tfor (p = pattern + 1, h = (char *) patbuf;\n\t    h < (char *)eb && *p && *p != SLASH; *h++ = *p++)\n\t\t;\n\n\t*h = EOS;\n\n#if 0\n\tif (h == (char *)eb)\n\t\treturn what;\n#endif\n\n\tif (((char *) patbuf)[0] == EOS) {\n\t\t \n#if 0\n\t\tif (issetugid() != 0 || (h = getenv(\"HOME\")) == NULL) {\n#endif\n\t\tif ((getuid() != geteuid()) || (h = getenv(\"HOME\")) == NULL) {\n\t\t\tif ((pwd = getpwuid(getuid())) == NULL)\n\t\t\t\treturn pattern;\n\t\t\telse\n\t\t\t\th = pwd->pw_dir;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((pwd = getpwnam((char*) patbuf)) == NULL)\n\t\t\treturn pattern;\n\t\telse\n\t\t\th = pwd->pw_dir;\n\t}\n\n\t \n\tfor (b = patbuf; b < eb && *h; *b++ = *h++)\n\t\t;\n\n\t \n\twhile (b < eb && (*b++ = *p++) != EOS)\n\t\t;\n\t*b = EOS;\n\n\treturn patbuf;\n}\n\nstatic int\ng_strncmp(const Char *s1, const char *s2, size_t n)\n{\n\tint rv = 0;\n\n\twhile (n--) {\n\t\trv = *(Char *)s1 - *(const unsigned char *)s2++;\n\t\tif (rv)\n\t\t\tbreak;\n\t\tif (*s1++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn rv;\n}\n\nstatic int\ng_charclass(const Char **patternp, Char **bufnextp)\n{\n\tconst Char *pattern = *patternp + 1;\n\tChar *bufnext = *bufnextp;\n\tconst Char *colon;\n\tstruct cclass *cc;\n\tsize_t len;\n\n\tif ((colon = g_strchr(pattern, ':')) == NULL || colon[1] != ']')\n\t\treturn 1;\t \n\n\tlen = (size_t)(colon - pattern);\n\tfor (cc = cclasses; cc->name != NULL; cc++) {\n\t\tif (!g_strncmp(pattern, cc->name, len) && cc->name[len] == '\\0')\n\t\t\tbreak;\n\t}\n\tif (cc->name == NULL)\n\t\treturn -1;\t \n\t*bufnext++ = M_CLASS;\n\t*bufnext++ = (Char)(cc - &cclasses[0]);\n\t*bufnextp = bufnext;\n\t*patternp += len + 3;\n\n\treturn 0;\n}\n\n \nstatic int\nglob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)\n{\n\tconst Char *qpatnext;\n\tint c, err;\n\tsize_t oldpathc;\n\tChar *bufnext, patbuf[PATH_MAX];\n\n\tqpatnext = globtilde(pattern, patbuf, PATH_MAX, pglob);\n\toldpathc = pglob->gl_pathc;\n\tbufnext = patbuf;\n\n\t \n\twhile ((c = *qpatnext++) != EOS) {\n\t\tswitch (c) {\n\t\tcase LBRACKET:\n\t\t\tc = *qpatnext;\n\t\t\tif (c == NOT)\n\t\t\t\t++qpatnext;\n\t\t\tif (*qpatnext == EOS ||\n\t\t\t    g_strchr(qpatnext+1, RBRACKET) == NULL) {\n\t\t\t\t*bufnext++ = LBRACKET;\n\t\t\t\tif (c == NOT)\n\t\t\t\t\t--qpatnext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*bufnext++ = M_SET;\n\t\t\tif (c == NOT)\n\t\t\t\t*bufnext++ = M_NOT;\n\t\t\tc = *qpatnext++;\n\t\t\tdo {\n\t\t\t\tif (c == LBRACKET && *qpatnext == ':') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\terr = g_charclass(&qpatnext,\n\t\t\t\t\t\t    &bufnext);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tc = *qpatnext++;\n\t\t\t\t\t} while (c == LBRACKET && *qpatnext == ':');\n\t\t\t\t\tif (err == -1 &&\n\t\t\t\t\t    !(pglob->gl_flags & GLOB_NOCHECK))\n\t\t\t\t\t\treturn GLOB_NOMATCH;\n\t\t\t\t\tif (c == RBRACKET)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\tif (*qpatnext == RANGE &&\n\t\t\t\t    (c = qpatnext[1]) != RBRACKET) {\n\t\t\t\t\t*bufnext++ = M_RNG;\n\t\t\t\t\t*bufnext++ = CHAR(c);\n\t\t\t\t\tqpatnext += 2;\n\t\t\t\t}\n\t\t\t} while ((c = *qpatnext++) != RBRACKET);\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_END;\n\t\t\tbreak;\n\t\tcase QUESTION:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t*bufnext++ = M_ONE;\n\t\t\tbreak;\n\t\tcase STAR:\n\t\t\tpglob->gl_flags |= GLOB_MAGCHAR;\n\t\t\t \n\t\t\tif (bufnext == patbuf || bufnext[-1] != M_ALL)\n\t\t\t\t*bufnext++ = M_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*bufnext++ = CHAR(c);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufnext = EOS;\n#ifdef DEBUG\n\tqprintf(\"glob0:\", patbuf);\n#endif\n\n\tif ((err = glob1(patbuf, patbuf+PATH_MAX-1, pglob, limitp)) != 0)\n\t\treturn(err);\n\n\t \n\tif (pglob->gl_pathc == oldpathc) {\n\t\tif ((pglob->gl_flags & GLOB_NOCHECK) ||\n\t\t    ((pglob->gl_flags & GLOB_NOMAGIC) &&\n\t\t    !(pglob->gl_flags & GLOB_MAGCHAR)))\n\t\t\treturn(globextend(pattern, pglob, limitp, NULL));\n\t\telse\n\t\t\treturn(GLOB_NOMATCH);\n\t}\n\tif (!(pglob->gl_flags & GLOB_NOSORT)) {\n\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT)) {\n\t\t\t \n\t\t\tstruct glob_path_stat *path_stat;\n\t\t\tsize_t i;\n\t\t\tsize_t n = pglob->gl_pathc - oldpathc;\n\t\t\tsize_t o = pglob->gl_offs + oldpathc;\n\n\t\t\tif ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)\n\t\t\t\treturn GLOB_NOSPACE;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpath_stat[i].gps_path = pglob->gl_pathv[o + i];\n\t\t\t\tpath_stat[i].gps_stat = pglob->gl_statv[o + i];\n\t\t\t}\n\t\t\tqsort(path_stat, n, sizeof(*path_stat), compare_gps);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tpglob->gl_pathv[o + i] = path_stat[i].gps_path;\n\t\t\t\tpglob->gl_statv[o + i] = path_stat[i].gps_stat;\n\t\t\t}\n\t\t\tfree(path_stat);\n\t\t} else {\n\t\t\tqsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,\n\t\t\t    pglob->gl_pathc - oldpathc, sizeof(char *),\n\t\t\t    compare);\n\t\t}\n\t}\n\treturn(0);\n}\n\nstatic int\ncompare(const void *p, const void *q)\n{\n\treturn(strcmp(*(char **)p, *(char **)q));\n}\n\nstatic int\ncompare_gps(const void *_p, const void *_q)\n{\n\tconst struct glob_path_stat *p = (const struct glob_path_stat *)_p;\n\tconst struct glob_path_stat *q = (const struct glob_path_stat *)_q;\n\n\treturn(strcmp(p->gps_path, q->gps_path));\n}\n\nstatic int\nglob1(Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tChar pathbuf[PATH_MAX];\n\n\t \n\tif (*pattern == EOS)\n\t\treturn(0);\n\treturn(glob2(pathbuf, pathbuf+PATH_MAX-1,\n\t    pathbuf, pathbuf+PATH_MAX-1,\n\t    pattern, pattern_last, pglob, limitp));\n}\n\n \nstatic int\nglob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)\n{\n\tstruct stat sb;\n\tChar *p, *q;\n\tint anymeta;\n\n\t \n\tfor (anymeta = 0;;) {\n\t\tif (*pattern == EOS) {\t\t \n\t\t\t*pathend = EOS;\n\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {\n\t\t\t\terrno = 0;\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif (g_lstat(pathbuf, &sb, pglob))\n\t\t\t\treturn(0);\n\n\t\t\tif (((pglob->gl_flags & GLOB_MARK) &&\n\t\t\t    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||\n\t\t\t    (S_ISLNK(sb.st_mode) &&\n\t\t\t    (g_stat(pathbuf, &sb, pglob) == 0) &&\n\t\t\t    S_ISDIR(sb.st_mode)))) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = SEP;\n\t\t\t\t*pathend = EOS;\n\t\t\t}\n\t\t\t++pglob->gl_matchc;\n\t\t\treturn(globextend(pathbuf, pglob, limitp, &sb));\n\t\t}\n\n\t\t \n\t\tq = pathend;\n\t\tp = pattern;\n\t\twhile (*p != EOS && *p != SEP) {\n\t\t\tif (ismeta(*p))\n\t\t\t\tanymeta = 1;\n\t\t\tif (q+1 > pathend_last)\n\t\t\t\treturn (1);\n\t\t\t*q++ = *p++;\n\t\t}\n\n\t\tif (!anymeta) {\t\t \n\t\t\tpathend = q;\n\t\t\tpattern = p;\n\t\t\twhile (*pattern == SEP) {\n\t\t\t\tif (pathend+1 > pathend_last)\n\t\t\t\t\treturn (1);\n\t\t\t\t*pathend++ = *pattern++;\n\t\t\t}\n\t\t} else\n\t\t\t \n\t\t\treturn(glob3(pathbuf, pathbuf_last, pathend,\n\t\t\t    pathend_last, pattern, p, pattern_last,\n\t\t\t    pglob, limitp));\n\t}\n\t \n}\n\nstatic int\nglob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,\n    Char *pattern, Char *restpattern, Char *restpattern_last, glob_t *pglob,\n    struct glob_lim *limitp)\n{\n\tstruct dirent *dp;\n\tDIR *dirp;\n\tint err;\n\tchar buf[PATH_MAX];\n\n\t \n\tstruct dirent *(*readdirfunc)(void *);\n\n\tif (pathend > pathend_last)\n\t\treturn (1);\n\t*pathend = EOS;\n\terrno = 0;\n\n\tif ((dirp = g_opendir(pathbuf, pglob)) == NULL) {\n\t\t \n\t\tif (pglob->gl_errfunc) {\n\t\t\tif (g_Ctoc(pathbuf, buf, sizeof(buf)))\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t\tif (pglob->gl_errfunc(buf, errno) ||\n\t\t\t    pglob->gl_flags & GLOB_ERR)\n\t\t\t\treturn(GLOB_ABORTED);\n\t\t}\n\t\treturn(0);\n\t}\n\n\terr = 0;\n\n\t \n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treaddirfunc = pglob->gl_readdir;\n\telse\n\t\treaddirfunc = (struct dirent *(*)(void *))readdir;\n\twhile ((dp = (*readdirfunc)(dirp))) {\n\t\tu_char *sc;\n\t\tChar *dc;\n\n\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t    limitp->glim_readdir++ >= GLOB_LIMIT_READDIR) {\n\t\t\terrno = 0;\n\t\t\t*pathend++ = SEP;\n\t\t\t*pathend = EOS;\n\t\t\terr = GLOB_NOSPACE;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dp->d_name[0] == DOT && *pattern != DOT)\n\t\t\tcontinue;\n\t\tdc = pathend;\n\t\tsc = (u_char *) dp->d_name;\n\t\twhile (dc < pathend_last && (*dc++ = *sc++) != EOS)\n\t\t\t;\n\t\tif (dc >= pathend_last) {\n\t\t\t*dc = EOS;\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!match(pathend, pattern, restpattern)) {\n\t\t\t*pathend = EOS;\n\t\t\tcontinue;\n\t\t}\n\t\terr = glob2(pathbuf, pathbuf_last, --dc, pathend_last,\n\t\t    restpattern, restpattern_last, pglob, limitp);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\t(*pglob->gl_closedir)(dirp);\n\telse\n\t\tclosedir(dirp);\n\treturn(err);\n}\n\n\n \nstatic int\nglobextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,\n    struct stat *sb)\n{\n\tchar **pathv;\n\tsize_t i, newn, len;\n\tchar *copy = NULL;\n\tconst Char *p;\n\tstruct stat **statv;\n\n\tnewn = 2 + pglob->gl_pathc + pglob->gl_offs;\n\tif (pglob->gl_offs >= SSIZE_MAX ||\n\t    pglob->gl_pathc >= SSIZE_MAX ||\n\t    newn >= SSIZE_MAX ||\n\t    SIZE_MAX / sizeof(*pathv) <= newn ||\n\t    SIZE_MAX / sizeof(*statv) <= newn) {\n nospace:\n\t\tfor (i = pglob->gl_offs; i < newn - 2; i++) {\n\t\t\tif (pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_pathv[i]);\n\t\t\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&\n\t\t\t    pglob->gl_pathv && pglob->gl_pathv[i])\n\t\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t\treturn(GLOB_NOSPACE);\n\t}\n\n\tpathv = reallocarray(pglob->gl_pathv, newn, sizeof(*pathv));\n\tif (pathv == NULL)\n\t\tgoto nospace;\n\tif (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {\n\t\t \n\t\tpathv += pglob->gl_offs;\n\t\tfor (i = pglob->gl_offs; i > 0; i--)\n\t\t\t*--pathv = NULL;\n\t}\n\tpglob->gl_pathv = pathv;\n\n\tif ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {\n\t\tstatv = reallocarray(pglob->gl_statv, newn, sizeof(*statv));\n\t\tif (statv == NULL)\n\t\t\tgoto nospace;\n\t\tif (pglob->gl_statv == NULL && pglob->gl_offs > 0) {\n\t\t\t \n\t\t\tstatv += pglob->gl_offs;\n\t\t\tfor (i = pglob->gl_offs; i > 0; i--)\n\t\t\t\t*--statv = NULL;\n\t\t}\n\t\tpglob->gl_statv = statv;\n\t\tif (sb == NULL)\n\t\t\tstatv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\t\telse {\n\t\t\tlimitp->glim_malloc += sizeof(**statv);\n\t\t\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t\t\t    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {\n\t\t\t\terrno = 0;\n\t\t\t\treturn(GLOB_NOSPACE);\n\t\t\t}\n\t\t\tif ((statv[pglob->gl_offs + pglob->gl_pathc] =\n\t\t\t    malloc(sizeof(**statv))) == NULL)\n\t\t\t\tgoto copy_error;\n\t\t\tmemcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,\n\t\t\t    sizeof(*sb));\n\t\t}\n\t\tstatv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;\n\t}\n\n\tfor (p = path; *p++;)\n\t\t;\n\tlen = (size_t)(p - path);\n\tlimitp->glim_malloc += len;\n\tif ((copy = malloc(len)) != NULL) {\n\t\tif (g_Ctoc(path, copy, len)) {\n\t\t\tfree(copy);\n\t\t\treturn(GLOB_NOSPACE);\n\t\t}\n\t\tpathv[pglob->gl_offs + pglob->gl_pathc++] = copy;\n\t}\n\tpathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n\tif ((pglob->gl_flags & GLOB_LIMIT) &&\n\t    (newn * sizeof(*pathv)) + limitp->glim_malloc >\n\t    GLOB_LIMIT_MALLOC) {\n\t\terrno = 0;\n\t\treturn(GLOB_NOSPACE);\n\t}\n copy_error:\n\treturn(copy == NULL ? GLOB_NOSPACE : 0);\n}\n\n\n \nstatic int\nmatch(Char *name, Char *pat, Char *patend)\n{\n\tint ok, negate_range;\n\tChar c, k;\n\tChar *nextp = NULL;\n\tChar *nextn = NULL;\n\nloop:\n\twhile (pat < patend) {\n\t\tc = *pat++;\n\t\tswitch (c & M_MASK) {\n\t\tcase M_ALL:\n\t\t\twhile (pat < patend && (*pat & M_MASK) == M_ALL)\n\t\t\t\tpat++;\t \n\t\t\tif (pat == patend)\n\t\t\t\treturn(1);\n\t\t\tif (*name == EOS)\n\t\t\t\treturn(0);\n\t\t\tnextn = name + 1;\n\t\t\tnextp = pat - 1;\n\t\t\tbreak;\n\t\tcase M_ONE:\n\t\t\tif (*name++ == EOS)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tcase M_SET:\n\t\t\tok = 0;\n\t\t\tif ((k = *name++) == EOS)\n\t\t\t\tgoto fail;\n\t\t\tif ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)\n\t\t\t\t++pat;\n\t\t\twhile (((c = *pat++) & M_MASK) != M_END) {\n\t\t\t\tif ((c & M_MASK) == M_CLASS) {\n\t\t\t\t\tChar idx = *pat & M_MASK;\n\t\t\t\t\tif (idx < NCCLASSES &&\n\t\t\t\t\t    cclasses[idx].isctype(k))\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t++pat;\n\t\t\t\t}\n\t\t\t\tif ((*pat & M_MASK) == M_RNG) {\n\t\t\t\t\tif (c <= k && k <= pat[1])\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\tpat += 2;\n\t\t\t\t} else if (c == k)\n\t\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tif (ok == negate_range)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*name++ != c)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (*name == EOS)\n\t\treturn(1);\n\nfail:\n\tif (nextn) {\n\t\tpat = nextp;\n\t\tname = nextn;\n\t\tgoto loop;\n\t}\n\treturn(0);\n}\n\n \nvoid\nglobfree(glob_t *pglob)\n{\n\tsize_t i;\n\tchar **pp;\n\n\tif (pglob->gl_pathv != NULL) {\n\t\tpp = pglob->gl_pathv + pglob->gl_offs;\n\t\tfor (i = pglob->gl_pathc; i--; ++pp)\n\t\t\tfree(*pp);\n\t\tfree(pglob->gl_pathv);\n\t\tpglob->gl_pathv = NULL;\n\t}\n\tif (pglob->gl_statv != NULL) {\n\t\tfor (i = 0; i < pglob->gl_pathc; i++) {\n\t\t\tfree(pglob->gl_statv[i]);\n\t\t}\n\t\tfree(pglob->gl_statv);\n\t\tpglob->gl_statv = NULL;\n\t}\n}\n\nstatic DIR *\ng_opendir(Char *str, glob_t *pglob)\n{\n\tchar buf[PATH_MAX];\n\n\tif (!*str)\n\t\tstrlcpy(buf, \".\", sizeof buf);\n\telse {\n\t\tif (g_Ctoc(str, buf, sizeof(buf)))\n\t\t\treturn(NULL);\n\t}\n\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_opendir)(buf));\n\n\treturn(opendir(buf));\n}\n\nstatic int\ng_lstat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[PATH_MAX];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_lstat)(buf, sb));\n\treturn(lstat(buf, sb));\n}\n\nstatic int\ng_stat(Char *fn, struct stat *sb, glob_t *pglob)\n{\n\tchar buf[PATH_MAX];\n\n\tif (g_Ctoc(fn, buf, sizeof(buf)))\n\t\treturn(-1);\n\tif (pglob->gl_flags & GLOB_ALTDIRFUNC)\n\t\treturn((*pglob->gl_stat)(buf, sb));\n\treturn(stat(buf, sb));\n}\n\nstatic Char *\ng_strchr(const Char *str, int ch)\n{\n\tdo {\n\t\tif (*str == ch)\n\t\t\treturn ((Char *)str);\n\t} while (*str++);\n\treturn (NULL);\n}\n\nstatic int\ng_Ctoc(const Char *str, char *buf, size_t len)\n{\n\n\twhile (len--) {\n\t\tif ((*buf++ = *str++) == EOS)\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}\n\n#ifdef DEBUG\nstatic void\nqprintf(const char *str, Char *s)\n{\n\tChar *p;\n\n\t(void)printf(\"%s:\\n\", str);\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", CHAR(*p));\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", *p & M_PROTECT ? '\"' : ' ');\n\t(void)printf(\"\\n\");\n\tfor (p = s; *p; p++)\n\t\t(void)printf(\"%c\", ismeta(*p) ? '_' : ' ');\n\t(void)printf(\"\\n\");\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}