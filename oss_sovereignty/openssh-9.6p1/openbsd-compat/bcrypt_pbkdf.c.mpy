{
  "module_name": "bcrypt_pbkdf.c",
  "hash_id": "e741fc592be35141a39791deca6fc6e1887a620f6ff33b68e371d0b04eb89264",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/bcrypt_pbkdf.c",
  "human_readable_source": " \n \n\n \n\n \n\n#include \"includes.h\"\n\n#ifndef HAVE_BCRYPT_PBKDF\n\n#include <sys/types.h>\n\n#ifdef HAVE_STDLIB_H\n# include <stdlib.h>\n#endif\n#include <string.h>\n\n#ifdef HAVE_BLF_H\n# include <blf.h>\n#endif\n\n#include \"crypto_api.h\"\n#ifdef SHA512_DIGEST_LENGTH\n# undef SHA512_DIGEST_LENGTH\n#endif\n#define SHA512_DIGEST_LENGTH crypto_hash_sha512_BYTES\n\n#define\tMINIMUM(a,b) (((a) < (b)) ? (a) : (b))\n\n \n\n#define BCRYPT_WORDS 8\n#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)\n\nstatic void\nbcrypt_hash(uint8_t *sha2pass, uint8_t *sha2salt, uint8_t *out)\n{\n\tblf_ctx state;\n\tuint8_t ciphertext[BCRYPT_HASHSIZE] =\n\t    \"OxychromaticBlowfishSwatDynamite\";\n\tuint32_t cdata[BCRYPT_WORDS];\n\tint i;\n\tuint16_t j;\n\tsize_t shalen = SHA512_DIGEST_LENGTH;\n\n\t \n\tBlowfish_initstate(&state);\n\tBlowfish_expandstate(&state, sha2salt, shalen, sha2pass, shalen);\n\tfor (i = 0; i < 64; i++) {\n\t\tBlowfish_expand0state(&state, sha2salt, shalen);\n\t\tBlowfish_expand0state(&state, sha2pass, shalen);\n\t}\n\n\t \n\tj = 0;\n\tfor (i = 0; i < BCRYPT_WORDS; i++)\n\t\tcdata[i] = Blowfish_stream2word(ciphertext, sizeof(ciphertext),\n\t\t    &j);\n\tfor (i = 0; i < 64; i++)\n\t\tblf_enc(&state, cdata, BCRYPT_WORDS / 2);\n\n\t \n\tfor (i = 0; i < BCRYPT_WORDS; i++) {\n\t\tout[4 * i + 3] = (cdata[i] >> 24) & 0xff;\n\t\tout[4 * i + 2] = (cdata[i] >> 16) & 0xff;\n\t\tout[4 * i + 1] = (cdata[i] >> 8) & 0xff;\n\t\tout[4 * i + 0] = cdata[i] & 0xff;\n\t}\n\n\t \n\texplicit_bzero(ciphertext, sizeof(ciphertext));\n\texplicit_bzero(cdata, sizeof(cdata));\n\texplicit_bzero(&state, sizeof(state));\n}\n\nint\nbcrypt_pbkdf(const char *pass, size_t passlen, const uint8_t *salt, size_t saltlen,\n    uint8_t *key, size_t keylen, unsigned int rounds)\n{\n\tuint8_t sha2pass[SHA512_DIGEST_LENGTH];\n\tuint8_t sha2salt[SHA512_DIGEST_LENGTH];\n\tuint8_t out[BCRYPT_HASHSIZE];\n\tuint8_t tmpout[BCRYPT_HASHSIZE];\n\tuint8_t *countsalt;\n\tsize_t i, j, amt, stride;\n\tuint32_t count;\n\tsize_t origkeylen = keylen;\n\n\t \n\tif (rounds < 1)\n\t\tgoto bad;\n\tif (passlen == 0 || saltlen == 0 || keylen == 0 ||\n\t    keylen > sizeof(out) * sizeof(out) || saltlen > 1<<20)\n\t\tgoto bad;\n\tif ((countsalt = calloc(1, saltlen + 4)) == NULL)\n\t\tgoto bad;\n\tstride = (keylen + sizeof(out) - 1) / sizeof(out);\n\tamt = (keylen + stride - 1) / stride;\n\n\tmemcpy(countsalt, salt, saltlen);\n\n\t \n\tcrypto_hash_sha512(sha2pass, pass, passlen);\n\n\t \n\tfor (count = 1; keylen > 0; count++) {\n\t\tcountsalt[saltlen + 0] = (count >> 24) & 0xff;\n\t\tcountsalt[saltlen + 1] = (count >> 16) & 0xff;\n\t\tcountsalt[saltlen + 2] = (count >> 8) & 0xff;\n\t\tcountsalt[saltlen + 3] = count & 0xff;\n\n\t\t \n\t\tcrypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n\n\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\tmemcpy(out, tmpout, sizeof(out));\n\n\t\tfor (i = 1; i < rounds; i++) {\n\t\t\t \n\t\t\tcrypto_hash_sha512(sha2salt, tmpout, sizeof(tmpout));\n\t\t\tbcrypt_hash(sha2pass, sha2salt, tmpout);\n\t\t\tfor (j = 0; j < sizeof(out); j++)\n\t\t\t\tout[j] ^= tmpout[j];\n\t\t}\n\n\t\t \n\t\tamt = MINIMUM(amt, keylen);\n\t\tfor (i = 0; i < amt; i++) {\n\t\t\tsize_t dest = i * stride + (count - 1);\n\t\t\tif (dest >= origkeylen)\n\t\t\t\tbreak;\n\t\t\tkey[dest] = out[i];\n\t\t}\n\t\tkeylen -= i;\n\t}\n\n\t \n\tfreezero(countsalt, saltlen + 4);\n\texplicit_bzero(out, sizeof(out));\n\texplicit_bzero(tmpout, sizeof(tmpout));\n\n\treturn 0;\n\nbad:\n\t \n\tarc4random_buf(key, keylen);\n\treturn -1;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}