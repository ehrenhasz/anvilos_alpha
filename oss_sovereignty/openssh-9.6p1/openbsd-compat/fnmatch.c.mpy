{
  "module_name": "fnmatch.c",
  "hash_id": "2dbf5c781a189b05494d714dddab66eeec25558553987a4c5f5a62a448079d9f",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/fnmatch.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n \n\n#include \"includes.h\"\n#ifndef HAVE_FNMATCH\n\n#include <fnmatch.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"charclass.h\"\n\n#define\tRANGE_MATCH\t1\n#define\tRANGE_NOMATCH\t0\n#define\tRANGE_ERROR\t(-1)\n\nstatic int\nclassmatch(const char *pattern, char test, int foldcase, const char **ep)\n{\n\tconst char * const mismatch = pattern;\n\tconst char *colon;\n\tstruct cclass *cc;\n\tint rval = RANGE_NOMATCH;\n\tsize_t len;\n\n\tif (pattern[0] != '[' || pattern[1] != ':') {\n\t\t*ep = mismatch;\n\t\treturn RANGE_ERROR;\n\t}\n\tpattern += 2;\n\n\tif ((colon = strchr(pattern, ':')) == NULL || colon[1] != ']') {\n\t\t*ep = mismatch;\n\t\treturn RANGE_ERROR;\n\t}\n\t*ep = colon + 2;\n\tlen = (size_t)(colon - pattern);\n\n\tif (foldcase && strncmp(pattern, \"upper:]\", 7) == 0)\n\t\tpattern = \"lower:]\";\n\tfor (cc = cclasses; cc->name != NULL; cc++) {\n\t\tif (!strncmp(pattern, cc->name, len) && cc->name[len] == '\\0') {\n\t\t\tif (cc->isctype((unsigned char)test))\n\t\t\t\trval = RANGE_MATCH;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (cc->name == NULL) {\n\t\t \n\t\t*ep = mismatch;\n\t\trval = RANGE_ERROR;\n\t}\n\treturn rval;\n}\n\n \nstatic int fnmatch_ch(const char **pattern, const char **string, int flags)\n{\n\tconst char * const mismatch = *pattern;\n\tconst int nocase = !!(flags & FNM_CASEFOLD);\n\tconst int escape = !(flags & FNM_NOESCAPE);\n\tconst int slash = !!(flags & FNM_PATHNAME);\n\tint result = FNM_NOMATCH;\n\tconst char *startch;\n\tint negate;\n\n\tif (**pattern == '[') {\n\t\t++*pattern;\n\n\t\t \n\t\tnegate = (**pattern == '!') || (**pattern == '^');\n\t\tif (negate)\n\t\t\t++*pattern;\n\n\t\t \n\t\tif (**pattern == ']')\n\t\t\tgoto leadingclosebrace;\n\n\t\twhile (**pattern) {\n\t\t\tif (**pattern == ']') {\n\t\t\t\t++*pattern;\n\t\t\t\t \n\t\t\t\t++*string;\n\t\t\t\treturn (result ^ negate);\n\t\t\t}\n\n\t\t\tif (escape && (**pattern == '\\\\')) {\n\t\t\t\t++*pattern;\n\n\t\t\t\t \n\t\t\t\tif (!**pattern)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (slash && (**pattern == '/'))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tswitch (classmatch(*pattern, **string, nocase, pattern)) {\n\t\t\tcase RANGE_MATCH:\n\t\t\t\tresult = 0;\n\t\t\t\tcontinue;\n\t\t\tcase RANGE_NOMATCH:\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!**pattern)\n\t\t\t\tbreak;\n\nleadingclosebrace:\n\t\t\t \n\t\t\tif (((*pattern)[1] == '-') && ((*pattern)[2] != ']')) {\n\t\t\t\tstartch = *pattern;\n\t\t\t\t*pattern += (escape && ((*pattern)[2] == '\\\\')) ? 3 : 2;\n\n\t\t\t\t \n\t\t\t\tif (!**pattern || (slash && (**pattern == '/')))\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif ((**string >= *startch) && (**string <= **pattern))\n\t\t\t\t\tresult = 0;\n\t\t\t\telse if (nocase &&\n\t\t\t\t    (isupper((unsigned char)**string) ||\n\t\t\t\t     isupper((unsigned char)*startch) ||\n\t\t\t\t     isupper((unsigned char)**pattern)) &&\n\t\t\t\t    (tolower((unsigned char)**string) >=\n\t\t\t\t     tolower((unsigned char)*startch)) &&\n\t\t\t\t    (tolower((unsigned char)**string) <=\n\t\t\t\t     tolower((unsigned char)**pattern)))\n\t\t\t\t\tresult = 0;\n\n\t\t\t\t++*pattern;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((**string == **pattern))\n\t\t\t\tresult = 0;\n\t\t\telse if (nocase && (isupper((unsigned char)**string) ||\n\t\t\t    isupper((unsigned char)**pattern)) &&\n\t\t\t    (tolower((unsigned char)**string) ==\n\t\t\t    tolower((unsigned char)**pattern)))\n\t\t\t\tresult = 0;\n\n\t\t\t++*pattern;\n\t\t}\n\t\t \n\t\t*pattern = mismatch;\n\t\tresult = FNM_NOMATCH;\n\t} else if (**pattern == '?') {\n\t\t \n\t\tif (!**string || (slash && (**string == '/')))\n\t\t\treturn FNM_NOMATCH;\n\t\tresult = 0;\n\t\tgoto fnmatch_ch_success;\n\t} else if (escape && (**pattern == '\\\\') && (*pattern)[1]) {\n\t\t++*pattern;\n\t}\n\n\t \n\tif (**string == **pattern)\n\t\tresult = 0;\n\telse if (nocase && (isupper((unsigned char)**string) ||\n\t    isupper((unsigned char)**pattern)) &&\n\t    (tolower((unsigned char)**string) ==\n\t    tolower((unsigned char)**pattern)))\n\t\tresult = 0;\n\n\t \n\tif (**string == '\\0' || **pattern == '\\0' ||\n\t    (slash && ((**string == '/') || (**pattern == '/'))))\n\t\treturn result;\n\nfnmatch_ch_success:\n\t++*pattern;\n\t++*string;\n\treturn result;\n}\n\n\nint fnmatch(const char *pattern, const char *string, int flags)\n{\n\tstatic const char dummystring[2] = {' ', 0};\n\tconst int escape = !(flags & FNM_NOESCAPE);\n\tconst int slash = !!(flags & FNM_PATHNAME);\n\tconst int leading_dir = !!(flags & FNM_LEADING_DIR);\n\tconst char *dummyptr, *matchptr, *strendseg;\n\tint wild;\n\t \n\tconst char *strstartseg = NULL;\n\tconst char *mismatch = NULL;\n\tint matchlen = 0;\n\n\tif (*pattern == '*')\n\t\tgoto firstsegment;\n\n\twhile (*pattern && *string) {\n\t\t \n\t\tif (slash && escape && (*pattern == '\\\\') && (pattern[1] == '/'))\n\t\t\t++pattern;\n\t\tif (slash && (*pattern == '/') && (*string == '/')) {\n\t\t\t++pattern;\n\t\t\t++string;\n\t\t}\n\nfirstsegment:\n\t\t \n\t\tif ((flags & FNM_PERIOD) && (*string == '.')) {\n\t\t    if (*pattern == '.')\n\t\t\t    ++pattern;\n\t\t    else if (escape && (*pattern == '\\\\') && (pattern[1] == '.'))\n\t\t\t    pattern += 2;\n\t\t    else\n\t\t\t    return FNM_NOMATCH;\n\t\t    ++string;\n\t\t}\n\n\t\t \n\t\tif (slash) {\n\t\t\tstrendseg = strchr(string, '/');\n\t\t\tif (!strendseg)\n\t\t\t\tstrendseg = strchr(string, '\\0');\n\t\t} else {\n\t\t\tstrendseg = strchr(string, '\\0');\n\t\t}\n\n\t\t \n\t\twhile (*pattern) {\n\t\t\tif ((string > strendseg) ||\n\t\t\t    ((string == strendseg) && (*pattern != '*')))\n\t\t\t\tbreak;\n\n\t\t\tif (slash && ((*pattern == '/') ||\n\t\t\t    (escape && (*pattern == '\\\\') && (pattern[1] == '/'))))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tfor (wild = 0; (*pattern == '*') || (*pattern == '?'); ++pattern) {\n\t\t\t\tif (*pattern == '*') {\n\t\t\t\t\twild = 1;\n\t\t\t\t} else if (string < strendseg) {   \n\t\t\t\t\t \n\t\t\t\t\t++string;\n\t\t\t\t}\n\t\t\t\telse {   \n\t\t\t\t\treturn FNM_NOMATCH;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (wild) {\n\t\t\t\tstrstartseg = string;\n\t\t\t\tmismatch = pattern;\n\n\t\t\t\t \n\t\t\t\tfor (matchptr = pattern, matchlen = 0; 1; ++matchlen) {\n\t\t\t\t\tif ((*matchptr == '\\0') ||\n\t\t\t\t\t    (slash && ((*matchptr == '/') ||\n\t\t\t\t\t    (escape && (*matchptr == '\\\\') &&\n\t\t\t\t\t    (matchptr[1] == '/'))))) {\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tif (string + matchlen > strendseg)\n\t\t\t\t\t\t\treturn FNM_NOMATCH;\n\n\t\t\t\t\t\tstring = strendseg - matchlen;\n\t\t\t\t\t\twild = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (*matchptr == '*') {\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tif (string + matchlen > strendseg)\n\t\t\t\t\t\t\treturn FNM_NOMATCH;\n\n\t\t\t\t\t\t \n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tif (escape && (*matchptr == '\\\\') &&\n\t\t\t\t\t    matchptr[1]) {\n\t\t\t\t\t\tmatchptr += 2;\n\t\t\t\t\t} else if (*matchptr == '[') {\n\t\t\t\t\t\tdummyptr = dummystring;\n\t\t\t\t\t\tfnmatch_ch(&matchptr, &dummyptr,\n\t\t\t\t\t\t    flags);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++matchptr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\twhile (*pattern && (string < strendseg)) {\n\t\t\t\t \n\t\t\t\tif (*pattern == '*')\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (slash && ((*string == '/') ||\n\t\t\t\t    (*pattern == '/') || (escape &&\n\t\t\t\t    (*pattern == '\\\\') && (pattern[1] == '/'))))\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (!fnmatch_ch(&pattern, &string, flags))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tif (wild) {\n\t\t\t\t\t \n\t\t\t\t\tstring = ++strstartseg;\n\t\t\t\t\tif (string + matchlen > strendseg)\n\t\t\t\t\t\treturn FNM_NOMATCH;\n\n\t\t\t\t\tpattern = mismatch;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\treturn FNM_NOMATCH;\n\t\t\t}\n\t\t}\n\n\t\tif (*string && !((slash || leading_dir) && (*string == '/')))\n\t\t\treturn FNM_NOMATCH;\n\n\t\tif (*pattern && !(slash && ((*pattern == '/') ||\n\t\t    (escape && (*pattern == '\\\\') && (pattern[1] == '/')))))\n\t\t\treturn FNM_NOMATCH;\n\n\t\tif (leading_dir && !*pattern && *string == '/')\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!*string && !*pattern)\n\t\treturn 0;\n\n\t \n\treturn FNM_NOMATCH;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}