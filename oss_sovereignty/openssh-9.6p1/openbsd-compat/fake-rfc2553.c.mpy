{
  "module_name": "fake-rfc2553.c",
  "hash_id": "260c1c07eb877b86e674b219d5889a401e7d8ad36084d2d3e04a7f2138e13700",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/fake-rfc2553.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#ifndef HAVE_GETNAMEINFO\nint getnameinfo(const struct sockaddr *sa, size_t salen, char *host,\n\t\tsize_t hostlen, char *serv, size_t servlen, int flags)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\tstruct hostent *hp;\n\tchar tmpserv[16];\n\n\tif (sa->sa_family != AF_UNSPEC && sa->sa_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (serv != NULL) {\n\t\tsnprintf(tmpserv, sizeof(tmpserv), \"%d\", ntohs(sin->sin_port));\n\t\tif (strlcpy(serv, tmpserv, servlen) >= servlen)\n\t\t\treturn (EAI_MEMORY);\n\t}\n\n\tif (host != NULL) {\n\t\tif (flags & NI_NUMERICHOST) {\n\t\t\tif (strlcpy(host, inet_ntoa(sin->sin_addr),\n\t\t\t    hostlen) >= hostlen)\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\thp = gethostbyaddr((char *)&sin->sin_addr,\n\t\t\t    sizeof(struct in_addr), AF_INET);\n\t\t\tif (hp == NULL)\n\t\t\t\treturn (EAI_NODATA);\n\n\t\t\tif (strlcpy(host, hp->h_name, hostlen) >= hostlen)\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (0);\n}\n#endif  \n\n#ifndef HAVE_GAI_STRERROR\n#ifdef HAVE_CONST_GAI_STRERROR_PROTO\nconst char *\n#else\nchar *\n#endif\ngai_strerror(int err)\n{\n\tswitch (err) {\n\tcase EAI_NODATA:\n\t\treturn (\"no address associated with name\");\n\tcase EAI_MEMORY:\n\t\treturn (\"memory allocation failure.\");\n\tcase EAI_NONAME:\n\t\treturn (\"nodename nor servname provided, or not known\");\n\tcase EAI_FAMILY:\n\t\treturn (\"ai_family not supported\");\n\tdefault:\n\t\treturn (\"unknown/invalid error.\");\n\t}\n}\n#endif  \n\n#ifndef HAVE_FREEADDRINFO\nvoid\nfreeaddrinfo(struct addrinfo *ai)\n{\n\tstruct addrinfo *next;\n\n\tfor(; ai != NULL;) {\n\t\tnext = ai->ai_next;\n\t\tfree(ai);\n\t\tai = next;\n\t}\n}\n#endif  \n\n#ifndef HAVE_GETADDRINFO\nstatic struct\naddrinfo *malloc_ai(int port, u_long addr, const struct addrinfo *hints)\n{\n\tstruct addrinfo *ai;\n\n\tai = malloc(sizeof(*ai) + sizeof(struct sockaddr_in));\n\tif (ai == NULL)\n\t\treturn (NULL);\n\n\tmemset(ai, '\\0', sizeof(*ai) + sizeof(struct sockaddr_in));\n\n\tai->ai_addr = (struct sockaddr *)(ai + 1);\n\t \n\tai->ai_addrlen = sizeof(struct sockaddr_in);\n\tai->ai_addr->sa_family = ai->ai_family = AF_INET;\n\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_port = port;\n\t((struct sockaddr_in *)(ai)->ai_addr)->sin_addr.s_addr = addr;\n\n\t \n\tif (hints->ai_socktype)\n\t\tai->ai_socktype = hints->ai_socktype;\n\telse\n\t\tai->ai_socktype = SOCK_STREAM;\n\n\tif (hints->ai_protocol)\n\t\tai->ai_protocol = hints->ai_protocol;\n\n\treturn (ai);\n}\n\nint\ngetaddrinfo(const char *hostname, const char *servname,\n    const struct addrinfo *hints, struct addrinfo **res)\n{\n\tstruct hostent *hp;\n\tstruct servent *sp;\n\tstruct in_addr in;\n\tint i;\n\tlong int port;\n\tu_long addr;\n\n\tport = 0;\n\tif (hints && hints->ai_family != AF_UNSPEC &&\n\t    hints->ai_family != AF_INET)\n\t\treturn (EAI_FAMILY);\n\tif (servname != NULL) {\n\t\tchar *cp;\n\n\t\tport = strtol(servname, &cp, 10);\n\t\tif (port > 0 && port <= 65535 && *cp == '\\0')\n\t\t\tport = htons(port);\n\t\telse if ((sp = getservbyname(servname, NULL)) != NULL)\n\t\t\tport = sp->s_port;\n\t\telse\n\t\t\tport = 0;\n\t}\n\n\tif (hints && hints->ai_flags & AI_PASSIVE) {\n\t\taddr = htonl(0x00000000);\n\t\tif (hostname && inet_aton(hostname, &in) != 0)\n\t\t\taddr = in.s_addr;\n\t\t*res = malloc_ai(port, addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (!hostname) {\n\t\t*res = malloc_ai(port, htonl(0x7f000001), hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\tif (inet_aton(hostname, &in)) {\n\t\t*res = malloc_ai(port, in.s_addr, hints);\n\t\tif (*res == NULL)\n\t\t\treturn (EAI_MEMORY);\n\t\treturn (0);\n\t}\n\n\t \n\tif (hints && hints->ai_flags & AI_NUMERICHOST)\n\t\treturn (EAI_NONAME);\n\n\thp = gethostbyname(hostname);\n\tif (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {\n\t\tstruct addrinfo *cur, *prev;\n\n\t\tcur = prev = *res = NULL;\n\t\tfor (i = 0; hp->h_addr_list[i]; i++) {\n\t\t\tstruct in_addr *in = (struct in_addr *)hp->h_addr_list[i];\n\n\t\t\tcur = malloc_ai(port, in->s_addr, hints);\n\t\t\tif (cur == NULL) {\n\t\t\t\tif (*res != NULL)\n\t\t\t\t\tfreeaddrinfo(*res);\n\t\t\t\treturn (EAI_MEMORY);\n\t\t\t}\n\t\t\tif (prev)\n\t\t\t\tprev->ai_next = cur;\n\t\t\telse\n\t\t\t\t*res = cur;\n\n\t\t\tprev = cur;\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (EAI_NODATA);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}