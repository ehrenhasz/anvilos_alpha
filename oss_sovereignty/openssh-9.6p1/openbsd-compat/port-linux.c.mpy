{
  "module_name": "port-linux.c",
  "hash_id": "2992c2fa87261cc7922d230b0f5379bffd5d2dfc3b17fcd5dd6e4bb70a526acd",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/port-linux.c",
  "human_readable_source": " \n\n \n\n#include \"includes.h\"\n\n#if defined(WITH_SELINUX) || defined(LINUX_OOM_ADJUST)\n#include <errno.h>\n#include <stdarg.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"log.h\"\n#include \"xmalloc.h\"\n#include \"port-linux.h\"\n\n#ifdef WITH_SELINUX\n#include <selinux/selinux.h>\n#include <selinux/label.h>\n#include <selinux/get_context_list.h>\n\n#ifndef SSH_SELINUX_UNCONFINED_TYPE\n# define SSH_SELINUX_UNCONFINED_TYPE \":unconfined_t:\"\n#endif\n\n \nint\nssh_selinux_enabled(void)\n{\n\tstatic int enabled = -1;\n\n\tif (enabled == -1) {\n\t\tenabled = (is_selinux_enabled() == 1);\n\t\tdebug(\"SELinux support %s\", enabled ? \"enabled\" : \"disabled\");\n\t}\n\n\treturn (enabled);\n}\n\n \nstatic char *\nssh_selinux_getctxbyname(char *pwname)\n{\n\tchar *sc = NULL, *sename = NULL, *lvl = NULL;\n\tint r;\n\n#ifdef HAVE_GETSEUSERBYNAME\n\tif (getseuserbyname(pwname, &sename, &lvl) != 0)\n\t\treturn NULL;\n#else\n\tsename = pwname;\n\tlvl = NULL;\n#endif\n\n#ifdef HAVE_GET_DEFAULT_CONTEXT_WITH_LEVEL\n\tr = get_default_context_with_level(sename, lvl, NULL, &sc);\n#else\n\tr = get_default_context(sename, NULL, &sc);\n#endif\n\n\tif (r != 0) {\n\t\tswitch (security_getenforce()) {\n\t\tcase -1:\n\t\t\tfatal(\"%s: ssh_selinux_getctxbyname: \"\n\t\t\t    \"security_getenforce() failed\", __func__);\n\t\tcase 0:\n\t\t\terror(\"%s: Failed to get default SELinux security \"\n\t\t\t    \"context for %s\", __func__, pwname);\n\t\t\tsc = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: Failed to get default SELinux security \"\n\t\t\t    \"context for %s (in enforcing mode)\",\n\t\t\t    __func__, pwname);\n\t\t}\n\t}\n\n#ifdef HAVE_GETSEUSERBYNAME\n\tfree(sename);\n\tfree(lvl);\n#endif\n\n\treturn sc;\n}\n\n \nvoid\nssh_selinux_setup_exec_context(char *pwname)\n{\n\tchar *user_ctx = NULL;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tdebug3(\"%s: setting execution context\", __func__);\n\n\tuser_ctx = ssh_selinux_getctxbyname(pwname);\n\tif (setexeccon(user_ctx) != 0) {\n\t\tswitch (security_getenforce()) {\n\t\tcase -1:\n\t\t\tfatal(\"%s: security_getenforce() failed\", __func__);\n\t\tcase 0:\n\t\t\terror(\"%s: Failed to set SELinux execution \"\n\t\t\t    \"context for %s\", __func__, pwname);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"%s: Failed to set SELinux execution context \"\n\t\t\t    \"for %s (in enforcing mode)\", __func__, pwname);\n\t\t}\n\t}\n\tif (user_ctx != NULL)\n\t\tfreecon(user_ctx);\n\n\tdebug3(\"%s: done\", __func__);\n}\n\n \nvoid\nssh_selinux_setup_pty(char *pwname, const char *tty)\n{\n\tchar *new_tty_ctx = NULL, *user_ctx = NULL, *old_tty_ctx = NULL;\n\tsecurity_class_t chrclass;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tdebug3(\"%s: setting TTY context on %s\", __func__, tty);\n\n\tuser_ctx = ssh_selinux_getctxbyname(pwname);\n\n\t \n\n\tif (getfilecon(tty, &old_tty_ctx) == -1) {\n\t\terror(\"%s: getfilecon: %s\", __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\tif ((chrclass = string_to_security_class(\"chr_file\")) == 0) {\n\t\terror(\"%s: couldn't get security class for chr_file\", __func__);\n\t\tgoto out;\n\t}\n\tif (security_compute_relabel(user_ctx, old_tty_ctx,\n\t    chrclass, &new_tty_ctx) != 0) {\n\t\terror(\"%s: security_compute_relabel: %s\",\n\t\t    __func__, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tif (setfilecon(tty, new_tty_ctx) != 0)\n\t\terror(\"%s: setfilecon: %s\", __func__, strerror(errno));\n out:\n\tif (new_tty_ctx != NULL)\n\t\tfreecon(new_tty_ctx);\n\tif (old_tty_ctx != NULL)\n\t\tfreecon(old_tty_ctx);\n\tif (user_ctx != NULL)\n\t\tfreecon(user_ctx);\n\tdebug3(\"%s: done\", __func__);\n}\n\nvoid\nssh_selinux_change_context(const char *newname)\n{\n\tchar *oldctx, *newctx, *cx, *cx2;\n\tLogLevel log_level = SYSLOG_LEVEL_INFO;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\n\tif (getcon(&oldctx) < 0) {\n\t\tlogit_f(\"getcon failed with %s\", strerror(errno));\n\t\treturn;\n\t}\n\tif ((cx = strchr(oldctx, ':')) == NULL ||\n\t    (cx = strchr(cx + 1, ':')) == NULL ||\n\t    (cx - oldctx) >= INT_MAX) {\n\t\tlogit_f(\"unparsable context %s\", oldctx);\n\t\treturn;\n\t}\n\n\t \n\tif (strncmp(cx, SSH_SELINUX_UNCONFINED_TYPE,\n\t    sizeof(SSH_SELINUX_UNCONFINED_TYPE) - 1) == 0)\n\t\tlog_level = SYSLOG_LEVEL_DEBUG3;\n\n\tcx2 = strchr(cx + 1, ':');\n\txasprintf(&newctx, \"%.*s%s%s\", (int)(cx - oldctx + 1), oldctx,\n\t    newname, cx2 == NULL ? \"\" : cx2);\n\n\tdebug3_f(\"setting context from '%s' to '%s'\", oldctx, newctx);\n\tif (setcon(newctx) < 0)\n\t\tdo_log2_f(log_level, \"setcon %s from %s failed with %s\",\n\t\t    newctx, oldctx, strerror(errno));\n\tfree(oldctx);\n\tfree(newctx);\n}\n\nvoid\nssh_selinux_setfscreatecon(const char *path)\n{\n\tchar *context;\n\tstruct selabel_handle *shandle = NULL;\n\n\tif (!ssh_selinux_enabled())\n\t\treturn;\n\tif (path == NULL) {\n\t\tsetfscreatecon(NULL);\n\t\treturn;\n\t}\n\tif ((shandle = selabel_open(SELABEL_CTX_FILE, NULL, 0)) == NULL) {\n\t\tdebug_f(\"selabel_open failed\");\n\t\treturn;\n\t}\n\tif (selabel_lookup(shandle, &context, path, 0700) == 0)\n\t\tsetfscreatecon(context);\n\tselabel_close(shandle);\n}\n\n#endif  \n\n#ifdef LINUX_OOM_ADJUST\n \n\nstatic int oom_adj_save = INT_MIN;\nstatic char *oom_adj_path = NULL;\nstruct {\n\tchar *path;\n\tint value;\n} oom_adjust[] = {\n\t{\"/proc/self/oom_score_adj\", -1000},\t \n\t{\"/proc/self/oom_adj\", -17},\t\t \n\t{NULL, 0},\n};\n\n \nvoid\noom_adjust_setup(void)\n{\n\tint i, value;\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\t for (i = 0; oom_adjust[i].path != NULL; i++) {\n\t\toom_adj_path = oom_adjust[i].path;\n\t\tvalue = oom_adjust[i].value;\n\t\tif ((fp = fopen(oom_adj_path, \"r+\")) != NULL) {\n\t\t\tif (fscanf(fp, \"%d\", &oom_adj_save) != 1)\n\t\t\t\tverbose(\"error reading %s: %s\", oom_adj_path,\n\t\t\t\t    strerror(errno));\n\t\t\telse {\n\t\t\t\trewind(fp);\n\t\t\t\tif (fprintf(fp, \"%d\\n\", value) <= 0)\n\t\t\t\t\tverbose(\"error writing %s: %s\",\n\t\t\t\t\t   oom_adj_path, strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tdebug(\"Set %s from %d to %d\",\n\t\t\t\t\t   oom_adj_path, oom_adj_save, value);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t}\n\toom_adj_path = NULL;\n}\n\n \nvoid\noom_adjust_restore(void)\n{\n\tFILE *fp;\n\n\tdebug3(\"%s\", __func__);\n\tif (oom_adj_save == INT_MIN || oom_adj_path == NULL ||\n\t    (fp = fopen(oom_adj_path, \"w\")) == NULL)\n\t\treturn;\n\n\tif (fprintf(fp, \"%d\\n\", oom_adj_save) <= 0)\n\t\tverbose(\"error writing %s: %s\", oom_adj_path, strerror(errno));\n\telse\n\t\tdebug(\"Set %s to %d\", oom_adj_path, oom_adj_save);\n\n\tfclose(fp);\n\treturn;\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}