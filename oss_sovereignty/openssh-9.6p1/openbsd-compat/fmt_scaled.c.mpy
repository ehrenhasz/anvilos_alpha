{
  "module_name": "fmt_scaled.c",
  "hash_id": "f211fd3f2d2bae6694dbe9b935c8a98a39d91b760a8de3607e6f583d2d71cde9",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/fmt_scaled.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include \"includes.h\"\n\n#ifndef HAVE_FMT_SCALED\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\ntypedef enum {\n\tNONE = 0, KILO = 1, MEGA = 2, GIGA = 3, TERA = 4, PETA = 5, EXA = 6\n} unit_type;\n\n \nstatic const unit_type units[] = { NONE, KILO, MEGA, GIGA, TERA, PETA, EXA };\nstatic const char scale_chars[] = \"BKMGTPE\";\nstatic const long long scale_factors[] = {\n\t1LL,\n\t1024LL,\n\t1024LL*1024,\n\t1024LL*1024*1024,\n\t1024LL*1024*1024*1024,\n\t1024LL*1024*1024*1024*1024,\n\t1024LL*1024*1024*1024*1024*1024,\n};\n#define\tSCALE_LENGTH (sizeof(units)/sizeof(units[0]))\n\n#define MAX_DIGITS (SCALE_LENGTH * 3)\t \n\n \nint\nscan_scaled(char *scaled, long long *result)\n{\n\tchar *p = scaled;\n\tint sign = 0;\n\tunsigned int i, ndigits = 0, fract_digits = 0;\n\tlong long scale_fact = 1, whole = 0, fpart = 0;\n\n\t \n\twhile (isascii((unsigned char)*p) && isspace((unsigned char)*p))\n\t\t++p;\n\n\t \n\twhile (*p == '-' || *p == '+') {\n\t\tif (*p == '-') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = -1;\n\t\t\t++p;\n\t\t} else if (*p == '+') {\n\t\t\tif (sign) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tsign = +1;\n\t\t\t++p;\n\t\t}\n\t}\n\n\t \n\tfor (; isascii((unsigned char)*p) &&\n\t    (isdigit((unsigned char)*p) || *p=='.'); ++p) {\n\t\tif (*p == '.') {\n\t\t\tif (fract_digits > 0) {\t \n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfract_digits = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = (*p) - '0';\t\t\t \n\t\tif (fract_digits > 0) {\n\t\t\tif (fract_digits >= MAX_DIGITS-1)\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\tfract_digits++;\t\t \n\t\t\tif (fpart > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart *= 10;\n\t\t\tif (i > LLONG_MAX - fpart) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfpart += i;\n\t\t} else {\t\t\t\t \n\t\t\tif (++ndigits >= MAX_DIGITS) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (whole > LLONG_MAX / 10) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole *= 10;\n\t\t\tif (i > LLONG_MAX - whole) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\twhole += i;\n\t\t}\n\t}\n\n\tif (sign)\n\t\twhole *= sign;\n\n\t \n\tif (!*p) {\n\t\t*result = whole;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\n\t\t \n\t\tif (*p == scale_chars[i] ||\n\t\t\t*p == tolower((unsigned char)scale_chars[i])) {\n\n\t\t\t \n\t\t\tif (isalnum((unsigned char)*(p+1))) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tscale_fact = scale_factors[i];\n\n\t\t\t \n\t\t\tif (whole > LLONG_MAX / scale_fact ||\n\t\t\t    whole < LLONG_MIN / scale_fact) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\twhole *= scale_fact;\n\n\t\t\t \n\t\t\twhile (fpart >= LLONG_MAX / scale_fact ||\n\t\t\t    fpart <= LLONG_MIN / scale_fact) {\n\t\t\t\tfpart /= 10;\n\t\t\t\tfract_digits--;\n\t\t\t}\n\t\t\tfpart *= scale_fact;\n\t\t\tif (fract_digits > 0) {\n\t\t\t\tfor (i = 0; i < fract_digits -1; i++)\n\t\t\t\t\tfpart /= 10;\n\t\t\t}\n\t\t\tif (sign == -1)\n\t\t\t\twhole -= fpart;\n\t\t\telse\n\t\t\t\twhole += fpart;\n\t\t\t*result = whole;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\terrno = EINVAL;\n\treturn -1;\n}\n\n \nint\nfmt_scaled(long long number, char *result)\n{\n\tlong long abval, fract = 0;\n\tunsigned int i;\n\tunit_type unit = NONE;\n\n\t \n\tif (number == LLONG_MIN) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\tabval = llabs(number);\n\n\t \n\tif (abval / 1024 >= scale_factors[SCALE_LENGTH-1]) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < SCALE_LENGTH; i++) {\n\t\tif (abval/1024 < scale_factors[i]) {\n\t\t\tunit = units[i];\n\t\t\tfract = (i == 0) ? 0 : abval % scale_factors[i];\n\t\t\tnumber /= scale_factors[i];\n\t\t\tif (i > 0)\n\t\t\t\tfract /= scale_factors[i - 1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfract = (10 * fract + 512) / 1024;\n\t \n\tif (fract >= 10) {\n\t\tif (number >= 0)\n\t\t\tnumber++;\n\t\telse\n\t\t\tnumber--;\n\t\tfract = 0;\n\t} else if (fract < 0) {\n\t\t \n\t\tfract = 0;\n\t}\n\n\tif (number == 0)\n\t\tstrlcpy(result, \"0B\", FMT_SCALED_STRSIZE);\n\telse if (unit == NONE || number >= 100 || number <= -100) {\n\t\tif (fract >= 5) {\n\t\t\tif (number >= 0)\n\t\t\t\tnumber++;\n\t\t\telse\n\t\t\t\tnumber--;\n\t\t}\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld%c\",\n\t\t\tnumber, scale_chars[unit]);\n\t} else\n\t\t(void)snprintf(result, FMT_SCALED_STRSIZE, \"%lld.%1lld%c\",\n\t\t\tnumber, fract, scale_chars[unit]);\n\n\treturn 0;\n}\n\n#ifdef\tMAIN\n \nint\nmain(int argc, char **argv)\n{\n\tchar *cinput = \"1.5K\", buf[FMT_SCALED_STRSIZE];\n\tlong long ninput = 10483892, result;\n\n\tif (scan_scaled(cinput, &result) == 0)\n\t\tprintf(\"\\\"%s\\\" -> %lld\\n\", cinput, result);\n\telse\n\t\tperror(cinput);\n\n\tif (fmt_scaled(ninput, buf) == 0)\n\t\tprintf(\"%lld -> \\\"%s\\\"\\n\", ninput, buf);\n\telse\n\t\tfprintf(stderr, \"%lld invalid (%s)\\n\", ninput, strerror(errno));\n\n\treturn 0;\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}