{
  "module_name": "getcwd.c",
  "hash_id": "501ac246ae202d12a88d922866ceb2474d0e6a7970a54a647272424c43b4e6ca",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/getcwd.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#if !defined(HAVE_GETCWD)\n\n#include <sys/stat.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/dir.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"includes.h\"\n\n#define\tISDOT(dp) \\\n\t(dp->d_name[0] == '.' && (dp->d_name[1] == '\\0' || \\\n\t    (dp->d_name[1] == '.' && dp->d_name[2] == '\\0')))\n\nchar *\ngetcwd(char *pt, size_t size)\n{\n\tstruct dirent *dp;\n\tDIR *dir = NULL;\n\tdev_t dev;\n\tino_t ino;\n\tint first;\n\tchar *bpt, *bup;\n\tstruct stat s;\n\tdev_t root_dev;\n\tino_t root_ino;\n\tsize_t ptsize, upsize;\n\tint save_errno;\n\tchar *ept, *eup, *up;\n\n\t \n\tif (pt) {\n\t\tptsize = 0;\n\t\tif (size == 0) {\n\t\t\terrno = EINVAL;\n\t\t\treturn (NULL);\n\t\t} else if (size == 1) {\n\t\t\terrno = ERANGE;\n\t\t\treturn (NULL);\n\t\t}\n\t\tept = pt + size;\n\t} else {\n\t\tif ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)\n\t\t\treturn (NULL);\n\t\tept = pt + ptsize;\n\t}\n\tbpt = ept - 1;\n\t*bpt = '\\0';\n\n\t \n\tif ((up = malloc(upsize = MAXPATHLEN)) == NULL)\n\t\tgoto err;\n\teup = up + upsize;\n\tbup = up;\n\tup[0] = '.';\n\tup[1] = '\\0';\n\n\t \n\tif (stat(\"/\", &s))\n\t\tgoto err;\n\troot_dev = s.st_dev;\n\troot_ino = s.st_ino;\n\n\terrno = 0;\t\t\t \n\n\tfor (first = 1;; first = 0) {\n\t\t \n\t\tif (lstat(up, &s))\n\t\t\tgoto err;\n\n\t\t \n\t\tino = s.st_ino;\n\t\tdev = s.st_dev;\n\n\t\t \n\t\tif (root_dev == dev && root_ino == ino) {\n\t\t\t*--bpt = '/';\n\t\t\t \n\t\t\tmemmove(pt, bpt, ept - bpt);\n\t\t\tfree(up);\n\t\t\treturn (pt);\n\t\t}\n\n\t\t \n\t\tif (bup + 3  + MAXNAMLEN + 1 >= eup) {\n\t\t\tchar *nup;\n\n\t\t\tif ((nup = realloc(up, upsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbup = nup + (bup - up);\n\t\t\tup = nup;\n\t\t\teup = up + upsize;\n\t\t}\n\t\t*bup++ = '.';\n\t\t*bup++ = '.';\n\t\t*bup = '\\0';\n\n\t\t \n\t\tif (!(dir = opendir(up)) || fstat(dirfd(dir), &s))\n\t\t\tgoto err;\n\n\t\t \n\t\t*bup++ = '/';\n\n\t\t \n\t\tsave_errno = 0;\n\t\tif (s.st_dev == dev) {\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (dp->d_fileno == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tfor (;;) {\n\t\t\t\tif (!(dp = readdir(dir)))\n\t\t\t\t\tgoto notfound;\n\t\t\t\tif (ISDOT(dp))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(bup, dp->d_name, dp->d_namlen + 1);\n\n\t\t\t\t \n\t\t\t\tif (lstat(up, &s)) {\n\t\t\t\t\tif (!save_errno)\n\t\t\t\t\t\tsave_errno = errno;\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s.st_dev == dev && s.st_ino == ino)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t \n\t\tif (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {\n\t\t\tsize_t len;\n\t\t\tchar *npt;\n\n\t\t\tif (!ptsize) {\n\t\t\t\terrno = ERANGE;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlen = ept - bpt;\n\t\t\tif ((npt = realloc(pt, ptsize *= 2)) == NULL)\n\t\t\t\tgoto err;\n\t\t\tbpt = npt + (bpt - pt);\n\t\t\tpt = npt;\n\t\t\tept = pt + ptsize;\n\t\t\tmemmove(ept - len, bpt, len);\n\t\t\tbpt = ept - len;\n\t\t}\n\t\tif (!first)\n\t\t\t*--bpt = '/';\n\t\tbpt -= dp->d_namlen;\n\t\tmemcpy(bpt, dp->d_name, dp->d_namlen);\n\t\t(void)closedir(dir);\n\n\t\t \n\t\t*bup = '\\0';\n\t}\n\nnotfound:\n\t \n\tif (!errno)\n\t\terrno = save_errno ? save_errno : ENOENT;\n\t \nerr:\n\tsave_errno = errno;\n\n\tif (ptsize)\n\t\tfree(pt);\n\tfree(up);\n\tif (dir)\n\t\t(void)closedir(dir);\n\n\terrno = save_errno;\n\n\treturn (NULL);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}