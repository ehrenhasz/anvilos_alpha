{
  "module_name": "xcrypt.c",
  "hash_id": "b7b38916096748505a1b3b1695d97881cef353261853bee943bccfca723cd6d7",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/xcrypt.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <string.h>\n#include <unistd.h>\n#include <pwd.h>\n\n# if defined(HAVE_CRYPT_H) && !defined(HAVE_SECUREWARE)\n#  include <crypt.h>\n# endif\n\n# ifdef __hpux\n#  include <hpsecurity.h>\n#  include <prot.h>\n# endif\n\n# ifdef HAVE_SECUREWARE\n#  include <sys/security.h>\n#  include <sys/audit.h>\n#  include <prot.h>\n# endif\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n#  include <shadow.h>\n# endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n#  include <sys/label.h>\n#  include <sys/audit.h>\n#  include <pwdadj.h>\n# endif\n\n# if defined(WITH_OPENSSL) && !defined(HAVE_CRYPT) && defined(HAVE_DES_CRYPT)\n#  include <openssl/des.h>\n#  define crypt DES_crypt\n# endif\n\n#define MINIMUM(a, b)\t(((a) < (b)) ? (a) : (b))\n\n \nstatic const char *\npick_salt(void)\n{\n\tstruct passwd *pw;\n\tchar *passwd, *p;\n\tsize_t typelen;\n\tstatic char salt[32];\n\n\tif (salt[0] != '\\0')\n\t\treturn salt;\n\tstrlcpy(salt, \"xx\", sizeof(salt));\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL) {\n\t\tif ((passwd = shadow_pw(pw)) == NULL)\n\t\t\tcontinue;\n\t\tif (passwd[0] == '$' && (p = strrchr(passwd+1, '$')) != NULL) {\n\t\t\ttypelen = p - passwd + 1;\n\t\t\tstrlcpy(salt, passwd, MINIMUM(typelen, sizeof(salt)));\n\t\t\texplicit_bzero(passwd, strlen(passwd));\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tendpwent();\n\treturn salt;\n}\n\nchar *\nxcrypt(const char *password, const char *salt)\n{\n\tchar *crypted;\n\n\t \n\tif (salt == NULL)\n\t\tsalt = pick_salt();\n\n#if defined(__hpux) && !defined(HAVE_SECUREWARE)\n\tif (iscomsec())\n\t\tcrypted = bigcrypt(password, salt);\n\telse\n\t\tcrypted = crypt(password, salt);\n# elif defined(HAVE_SECUREWARE)\n\tcrypted = bigcrypt(password, salt);\n# else\n\tcrypted = crypt(password, salt);\n#endif\n\n\treturn crypted;\n}\n\n \n\nchar *\nshadow_pw(struct passwd *pw)\n{\n\tchar *pw_password = pw->pw_passwd;\n\n# if defined(HAVE_SHADOW_H) && !defined(DISABLE_SHADOW)\n\tstruct spwd *spw = getspnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->sp_pwdp;\n# endif\n\n#ifdef USE_LIBIAF\n\treturn(get_iaf_password(pw));\n#endif\n\n# if defined(HAVE_GETPWANAM) && !defined(DISABLE_SHADOW)\n\tstruct passwd_adjunct *spw;\n\tif (issecure() && (spw = getpwanam(pw->pw_name)) != NULL)\n\t\tpw_password = spw->pwa_passwd;\n# elif defined(HAVE_SECUREWARE)\n\tstruct pr_passwd *spw = getprpwnam(pw->pw_name);\n\n\tif (spw != NULL)\n\t\tpw_password = spw->ufld.fd_encrypt;\n# endif\n\n\treturn pw_password;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}