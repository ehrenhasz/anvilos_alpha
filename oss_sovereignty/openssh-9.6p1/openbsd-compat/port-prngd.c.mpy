{
  "module_name": "port-prngd.c",
  "hash_id": "1e738c13db90c2a9c7db127a35794e719a545098d5c032b9351575b9536e37f8",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/port-prngd.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_UN_H\n# include <sys/un.h>\n#endif\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stddef.h>  \n\n#include \"atomicio.h\"\n#include \"misc.h\"\n#include \"log.h\"\n\n#if defined(PRNGD_PORT) || defined(PRNGD_SOCKET)\n \nstatic int\nget_random_bytes_prngd(unsigned char *buf, int len,\n    unsigned short tcp_port, char *socket_path)\n{\n\tint fd, addr_len, rval, errors;\n\tu_char msg[2];\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)&addr;\n\tstruct sockaddr_un *addr_un = (struct sockaddr_un *)&addr;\n\tsshsig_t old_sigpipe;\n\n\t \n\tif (socket_path == NULL && tcp_port == 0)\n\t\tfatal(\"You must specify a port or a socket\");\n\tif (socket_path != NULL &&\n\t    strlen(socket_path) >= sizeof(addr_un->sun_path))\n\t\tfatal(\"Random pool path is too long\");\n\tif (len <= 0 || len > 255)\n\t\tfatal(\"Too many bytes (%d) to read from PRNGD\", len);\n\n\tmemset(&addr, '\\0', sizeof(addr));\n\n\tif (tcp_port != 0) {\n\t\taddr_in->sin_family = AF_INET;\n\t\taddr_in->sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\taddr_in->sin_port = htons(tcp_port);\n\t\taddr_len = sizeof(*addr_in);\n\t} else {\n\t\taddr_un->sun_family = AF_UNIX;\n\t\tstrlcpy(addr_un->sun_path, socket_path,\n\t\t    sizeof(addr_un->sun_path));\n\t\taddr_len = offsetof(struct sockaddr_un, sun_path) +\n\t\t    strlen(socket_path) + 1;\n\t}\n\n\told_sigpipe = ssh_signal(SIGPIPE, SIG_IGN);\n\n\terrors = 0;\n\trval = -1;\nreopen:\n\tfd = socket(addr.ss_family, SOCK_STREAM, 0);\n\tif (fd == -1) {\n\t\terror(\"Couldn't create socket: %s\", strerror(errno));\n\t\tgoto done;\n\t}\n\n\tif (connect(fd, (struct sockaddr*)&addr, addr_len) == -1) {\n\t\tif (tcp_port != 0) {\n\t\t\terror(\"Couldn't connect to PRNGD port %d: %s\",\n\t\t\t    tcp_port, strerror(errno));\n\t\t} else {\n\t\t\terror(\"Couldn't connect to PRNGD socket \\\"%s\\\": %s\",\n\t\t\t    addr_un->sun_path, strerror(errno));\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tmsg[0] = 0x02;\n\tmsg[1] = len;\n\n\tif (atomicio(vwrite, fd, msg, sizeof(msg)) != sizeof(msg)) {\n\t\tif (errno == EPIPE && errors < 10) {\n\t\t\tclose(fd);\n\t\t\terrors++;\n\t\t\tgoto reopen;\n\t\t}\n\t\terror(\"Couldn't write to PRNGD socket: %s\",\n\t\t    strerror(errno));\n\t\tgoto done;\n\t}\n\n\tif (atomicio(read, fd, buf, len) != (size_t)len) {\n\t\tif (errno == EPIPE && errors < 10) {\n\t\t\tclose(fd);\n\t\t\terrors++;\n\t\t\tgoto reopen;\n\t\t}\n\t\terror(\"Couldn't read from PRNGD socket: %s\",\n\t\t    strerror(errno));\n\t\tgoto done;\n\t}\n\n\trval = 0;\ndone:\n\tssh_signal(SIGPIPE, old_sigpipe);\n\tif (fd != -1)\n\t\tclose(fd);\n\treturn rval;\n}\n#endif  \n\nint\nseed_from_prngd(unsigned char *buf, size_t bytes)\n{\n#ifdef PRNGD_PORT\n\tdebug(\"trying egd/prngd port %d\", PRNGD_PORT);\n\tif (get_random_bytes_prngd(buf, bytes, PRNGD_PORT, NULL) == 0)\n\t\treturn 0;\n#endif\n#ifdef PRNGD_SOCKET\n\tdebug(\"trying egd/prngd socket %s\", PRNGD_SOCKET);\n\tif (get_random_bytes_prngd(buf, bytes, 0, PRNGD_SOCKET) == 0)\n\t\treturn 0;\n#endif\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}