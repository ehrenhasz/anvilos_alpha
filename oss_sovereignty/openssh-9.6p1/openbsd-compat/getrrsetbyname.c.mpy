{
  "module_name": "getrrsetbyname.c",
  "hash_id": "8d86aa63695643b62215ff4fa76ba1858c7403798f5fca72637cc48d1c7481e7",
  "original_prompt": "Ingested from openssh-9.6p1/openbsd-compat/getrrsetbyname.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n#include \"includes.h\"\n\n#if !defined (HAVE_GETRRSETBYNAME) && !defined (HAVE_LDNS)\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include \"getrrsetbyname.h\"\n\n#if defined(HAVE_DECL_H_ERRNO) && !HAVE_DECL_H_ERRNO\nextern int h_errno;\n#endif\n\n \n#ifdef _THREAD_PRIVATE\n# undef _THREAD_PRIVATE\n#endif\n#define _THREAD_PRIVATE(a,b,c) (c)\n\n#ifndef HAVE__RES_EXTERN\nstruct __res_state _res;\n#endif\n\n \n\n \n\n#ifndef INT32SZ\n# define INT32SZ\t4\n#endif\n#ifndef INT16SZ\n# define INT16SZ\t2\n#endif\n\n#ifndef GETSHORT\n#define GETSHORT(s, cp) { \\\n\tu_char *t_cp = (u_char *)(cp); \\\n\t(s) = ((u_int16_t)t_cp[0] << 8) \\\n\t    | ((u_int16_t)t_cp[1]) \\\n\t    ; \\\n\t(cp) += INT16SZ; \\\n}\n#endif\n\n#ifndef GETLONG\n#define GETLONG(l, cp) { \\\n\tu_char *t_cp = (u_char *)(cp); \\\n\t(l) = ((u_int32_t)t_cp[0] << 24) \\\n\t    | ((u_int32_t)t_cp[1] << 16) \\\n\t    | ((u_int32_t)t_cp[2] << 8) \\\n\t    | ((u_int32_t)t_cp[3]) \\\n\t    ; \\\n\t(cp) += INT32SZ; \\\n}\n#endif\n\n \n#if !defined(HAVE__GETSHORT) || !defined(HAVE__GETLONG) || \\\n    !defined(HAVE_DECL__GETSHORT) || HAVE_DECL__GETSHORT == 0 || \\\n    !defined(HAVE_DECL__GETLONG) || HAVE_DECL__GETLONG == 0\n# ifdef _getshort\n#  undef _getshort\n# endif\n# ifdef _getlong\n#  undef _getlong\n# endif\n# define _getshort(x) (_ssh_compat_getshort(x))\n# define _getlong(x) (_ssh_compat_getlong(x))\n \nstatic u_int16_t\n_getshort(const u_char *msgp)\n{\n\tu_int16_t u;\n\n\tGETSHORT(u, msgp);\n\treturn (u);\n}\n\nstatic u_int32_t\n_getlong(const u_char *msgp)\n{\n\tu_int32_t u;\n\n\tGETLONG(u, msgp);\n\treturn (u);\n}\n#endif  \n\n \n\n#define ANSWER_BUFFER_SIZE 0xffff\n\nstruct dns_query {\n\tchar\t\t\t*name;\n\tu_int16_t\t\ttype;\n\tu_int16_t\t\tclass;\n\tstruct dns_query\t*next;\n};\n\nstruct dns_rr {\n\tchar\t\t\t*name;\n\tu_int16_t\t\ttype;\n\tu_int16_t\t\tclass;\n\tu_int16_t\t\tttl;\n\tu_int16_t\t\tsize;\n\tvoid\t\t\t*rdata;\n\tstruct dns_rr\t\t*next;\n};\n\nstruct dns_response {\n\tHEADER\t\t\theader;\n\tstruct dns_query\t*query;\n\tstruct dns_rr\t\t*answer;\n\tstruct dns_rr\t\t*authority;\n\tstruct dns_rr\t\t*additional;\n};\n\nstatic struct dns_response *parse_dns_response(const u_char *, int);\nstatic struct dns_query *parse_dns_qsection(const u_char *, int,\n    const u_char **, int);\nstatic struct dns_rr *parse_dns_rrsection(const u_char *, int, const u_char **,\n    int);\n\nstatic void free_dns_query(struct dns_query *);\nstatic void free_dns_rr(struct dns_rr *);\nstatic void free_dns_response(struct dns_response *);\n\nstatic int count_dns_rr(struct dns_rr *, u_int16_t, u_int16_t);\n\nint\ngetrrsetbyname(const char *hostname, unsigned int rdclass,\n    unsigned int rdtype, unsigned int flags,\n    struct rrsetinfo **res)\n{\n\tstruct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);\n\tint result;\n\tstruct rrsetinfo *rrset = NULL;\n\tstruct dns_response *response = NULL;\n\tstruct dns_rr *rr;\n\tstruct rdatainfo *rdata;\n\tint length;\n\tunsigned int index_ans, index_sig;\n\tu_char answer[ANSWER_BUFFER_SIZE];\n\n\t \n\tif (rdclass > 0xffff || rdtype > 0xffff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (rdclass == 0xff || rdtype == 0xff) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (flags) {\n\t\tresult = ERRSET_INVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif ((_resp->options & RES_INIT) == 0 && res_init() == -1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n#ifdef DEBUG\n\t_resp->options |= RES_DEBUG;\n#endif  \n\n#ifdef RES_USE_DNSSEC\n\t \n\tif (_resp->options & RES_USE_EDNS0)\n\t\t_resp->options |= RES_USE_DNSSEC;\n#endif  \n\n\t \n\tlength = res_query(hostname, (signed int) rdclass, (signed int) rdtype,\n\t    answer, sizeof(answer));\n\tif (length < 0) {\n\t\tswitch(h_errno) {\n\t\tcase HOST_NOT_FOUND:\n\t\t\tresult = ERRSET_NONAME;\n\t\t\tgoto fail;\n\t\tcase NO_DATA:\n\t\t\tresult = ERRSET_NODATA;\n\t\t\tgoto fail;\n\t\tdefault:\n\t\t\tresult = ERRSET_FAIL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tresponse = parse_dns_response(answer, length);\n\tif (response == NULL) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\tif (response->header.qdcount != 1) {\n\t\tresult = ERRSET_FAIL;\n\t\tgoto fail;\n\t}\n\n\t \n\trrset = calloc(1, sizeof(struct rrsetinfo));\n\tif (rrset == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\trrset->rri_rdclass = response->query->class;\n\trrset->rri_rdtype = response->query->type;\n\trrset->rri_ttl = response->answer->ttl;\n\trrset->rri_nrdatas = response->header.ancount;\n\n#ifdef HAVE_HEADER_AD\n\t \n\tif (response->header.ad == 1)\n\t\trrset->rri_flags |= RRSET_VALIDATED;\n#endif\n\n\t \n\trrset->rri_name = strdup(response->answer->name);\n\tif (rrset->rri_name == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t \n\trrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,\n\t    rrset->rri_rdtype);\n\trrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,\n\t    T_RRSIG);\n\n\t \n\trrset->rri_rdatas = calloc(rrset->rri_nrdatas,\n\t    sizeof(struct rdatainfo));\n\tif (rrset->rri_rdatas == NULL) {\n\t\tresult = ERRSET_NOMEMORY;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (rrset->rri_nsigs > 0) {\n\t\trrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));\n\t\tif (rrset->rri_sigs == NULL) {\n\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tfor (rr = response->answer, index_ans = 0, index_sig = 0;\n\t    rr; rr = rr->next) {\n\n\t\trdata = NULL;\n\n\t\tif (rr->class == rrset->rri_rdclass &&\n\t\t    rr->type  == rrset->rri_rdtype)\n\t\t\trdata = &rrset->rri_rdatas[index_ans++];\n\n\t\tif (rr->class == rrset->rri_rdclass &&\n\t\t    rr->type  == T_RRSIG)\n\t\t\trdata = &rrset->rri_sigs[index_sig++];\n\n\t\tif (rdata) {\n\t\t\trdata->rdi_length = rr->size;\n\t\t\trdata->rdi_data   = malloc(rr->size);\n\n\t\t\tif (rdata->rdi_data == NULL) {\n\t\t\t\tresult = ERRSET_NOMEMORY;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tmemcpy(rdata->rdi_data, rr->rdata, rr->size);\n\t\t}\n\t}\n\tfree_dns_response(response);\n\n\t*res = rrset;\n\treturn (ERRSET_SUCCESS);\n\nfail:\n\tif (rrset != NULL)\n\t\tfreerrset(rrset);\n\tif (response != NULL)\n\t\tfree_dns_response(response);\n\treturn (result);\n}\n\nvoid\nfreerrset(struct rrsetinfo *rrset)\n{\n\tu_int16_t i;\n\n\tif (rrset == NULL)\n\t\treturn;\n\n\tif (rrset->rri_rdatas) {\n\t\tfor (i = 0; i < rrset->rri_nrdatas; i++) {\n\t\t\tif (rrset->rri_rdatas[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_rdatas[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_rdatas);\n\t}\n\n\tif (rrset->rri_sigs) {\n\t\tfor (i = 0; i < rrset->rri_nsigs; i++) {\n\t\t\tif (rrset->rri_sigs[i].rdi_data == NULL)\n\t\t\t\tbreak;\n\t\t\tfree(rrset->rri_sigs[i].rdi_data);\n\t\t}\n\t\tfree(rrset->rri_sigs);\n\t}\n\n\tif (rrset->rri_name)\n\t\tfree(rrset->rri_name);\n\tfree(rrset);\n}\n\n \nstatic struct dns_response *\nparse_dns_response(const u_char *answer, int size)\n{\n\tstruct dns_response *resp;\n\tconst u_char *cp;\n\n\tif (size < HFIXEDSZ)\n\t\treturn (NULL);\n\n\t \n\tresp = calloc(1, sizeof(*resp));\n\tif (resp == NULL)\n\t\treturn (NULL);\n\n\t \n\tcp = answer;\n\n\t \n\tmemcpy(&resp->header, cp, HFIXEDSZ);\n\tcp += HFIXEDSZ;\n\n\t \n\tresp->header.qdcount = ntohs(resp->header.qdcount);\n\tresp->header.ancount = ntohs(resp->header.ancount);\n\tresp->header.nscount = ntohs(resp->header.nscount);\n\tresp->header.arcount = ntohs(resp->header.arcount);\n\n\t \n\tif (resp->header.qdcount < 1) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tresp->query = parse_dns_qsection(answer, size, &cp,\n\t    resp->header.qdcount);\n\tif (resp->header.qdcount && resp->query == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tresp->answer = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.ancount);\n\tif (resp->header.ancount && resp->answer == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tresp->authority = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.nscount);\n\tif (resp->header.nscount && resp->authority == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\t \n\tresp->additional = parse_dns_rrsection(answer, size, &cp,\n\t    resp->header.arcount);\n\tif (resp->header.arcount && resp->additional == NULL) {\n\t\tfree_dns_response(resp);\n\t\treturn (NULL);\n\t}\n\n\treturn (resp);\n}\n\nstatic struct dns_query *\nparse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)\n{\n\tstruct dns_query *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n#define NEED(need) \\\n\tdo { \\\n\t\tif (*cp + need > answer + size) \\\n\t\t\tgoto fail; \\\n\t} while (0)\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\t\tif (*cp >= answer + size) {\n fail:\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\t \n\t\tcurr = calloc(1, sizeof(struct dns_query));\n\t\tif (curr == NULL)\n\t\t\tgoto fail;\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t \n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_query(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tNEED(length);\n\t\t*cp += length;\n\n\t\t \n\t\tNEED(INT16SZ);\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t \n\t\tNEED(INT16SZ);\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\t}\n#undef NEED\n\n\treturn (head);\n}\n\nstatic struct dns_rr *\nparse_dns_rrsection(const u_char *answer, int size, const u_char **cp,\n    int count)\n{\n\tstruct dns_rr *head, *curr, *prev;\n\tint i, length;\n\tchar name[MAXDNAME];\n\n#define NEED(need) \\\n\tdo { \\\n\t\tif (*cp + need > answer + size) \\\n\t\t\tgoto fail; \\\n\t} while (0)\n\n\tfor (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {\n\t\tif (*cp >= answer + size) {\n fail:\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t \n\t\tcurr = calloc(1, sizeof(struct dns_rr));\n\t\tif (curr == NULL)\n\t\t\tgoto fail;\n\t\tif (head == NULL)\n\t\t\thead = curr;\n\t\tif (prev != NULL)\n\t\t\tprev->next = curr;\n\n\t\t \n\t\tlength = dn_expand(answer, answer + size, *cp, name,\n\t\t    sizeof(name));\n\t\tif (length < 0) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tcurr->name = strdup(name);\n\t\tif (curr->name == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tNEED(length);\n\t\t*cp += length;\n\n\t\t \n\t\tNEED(INT16SZ);\n\t\tcurr->type = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t \n\t\tNEED(INT16SZ);\n\t\tcurr->class = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t \n\t\tNEED(INT32SZ);\n\t\tcurr->ttl = _getlong(*cp);\n\t\t*cp += INT32SZ;\n\n\t\t \n\t\tNEED(INT16SZ);\n\t\tcurr->size = _getshort(*cp);\n\t\t*cp += INT16SZ;\n\n\t\t \n\t\tNEED(curr->size);\n\t\tcurr->rdata = malloc(curr->size);\n\t\tif (curr->rdata == NULL) {\n\t\t\tfree_dns_rr(head);\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemcpy(curr->rdata, *cp, curr->size);\n\t\t*cp += curr->size;\n\t}\n#undef NEED\n\n\treturn (head);\n}\n\nstatic void\nfree_dns_query(struct dns_query *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tfree_dns_query(p->next);\n\tfree(p);\n}\n\nstatic void\nfree_dns_rr(struct dns_rr *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tif (p->name)\n\t\tfree(p->name);\n\tif (p->rdata)\n\t\tfree(p->rdata);\n\tfree_dns_rr(p->next);\n\tfree(p);\n}\n\nstatic void\nfree_dns_response(struct dns_response *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\n\tfree_dns_query(p->query);\n\tfree_dns_rr(p->answer);\n\tfree_dns_rr(p->authority);\n\tfree_dns_rr(p->additional);\n\tfree(p);\n}\n\nstatic int\ncount_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)\n{\n\tint n = 0;\n\n\twhile(p) {\n\t\tif (p->class == class && p->type == type)\n\t\t\tn++;\n\t\tp = p->next;\n\t}\n\n\treturn (n);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}