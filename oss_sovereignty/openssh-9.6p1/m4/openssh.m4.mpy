{
  "module_name": "openssh.m4",
  "hash_id": "3270ef2f36fca1e8cfe7b01a5af1f0f86167a3fc571696395b5e15d324dc87c5",
  "original_prompt": "Ingested from openssh-9.6p1/m4/openssh.m4",
  "human_readable_source": "dnl OpenSSH-specific autoconf macros\ndnl\n\ndnl The test program that is used to try to trigger various compiler\ndnl behaviours.\nAC_DEFUN([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t[AC_LANG_SOURCE([[\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n/* Trivial function to help test for -fzero-call-used-regs */\nint f(int n) {return rand() % n;}\nchar *f2(char *s, ...) {\n\tchar ret[64];\n\tva_list args;\n\tva_start(args, s);\n\tvsnprintf(ret, sizeof(ret), s, args);\n\tva_end(args);\n\treturn strdup(ret);\n}\nint main(int argc, char **argv) {\n\t(void)argv;\n\tchar b[256], *cp;\n\t/* Some math to catch -ftrapv problems in the toolchain */\n\tint i = 123 * argc, j = 456 + argc, k = 789 - argc;\n\tfloat l = i * 2.1;\n\tdouble m = l / 0.5;\n\tlong long int n = argc * 12345LL, o = 12345LL * (long long int)argc;\n\tf(1);\n\tsnprintf(b, sizeof b, \"%d %d %d %f %f %lld %lld\\n\", i,j,k,l,m,n,o);\n\tif (write(1, b, 0) == -1) exit(0);\n\tcp = f2(\"%d %d %d %f %f %lld %lld\\n\", i,j,k,l,m,n,o);\n\tfree(cp);\n\t/*\n\t * Test fallthrough behaviour.  clang 10's -Wimplicit-fallthrough does\n\t * not understand comments and we don't use the \"fallthrough\" attribute\n\t * that it's looking for.\n\t */\n\tswitch(i){\n\tcase 0: j += i;\n\t\t/* FALLTHROUGH */\n\tdefault: j += k;\n\t}\n\texit(0);\n}\n\t]])]\n)\n\ndnl OSSH_CHECK_CFLAG_COMPILE(check_flag[, define_flag])\ndnl Check that $CC accepts a flag 'check_flag'. If it is supported append\ndnl 'define_flag' to $CFLAGS. If 'define_flag' is not specified, then append\ndnl 'check_flag'.\nAC_DEFUN([OSSH_CHECK_CFLAG_COMPILE], [{\n\tAC_MSG_CHECKING([if $CC supports compile flag $1])\n\tsaved_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS $WERROR $1\"\n\t_define_flag=\"$2\"\n\ttest \"x$_define_flag\" = \"x\" && _define_flag=\"$1\"\n\tAC_COMPILE_IFELSE([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t\t[\nif $ac_cv_path_EGREP -i \"unrecognized option|warning.*ignored\" conftest.err >/dev/null\nthen\n\t\tAC_MSG_RESULT([no])\n\t\tCFLAGS=\"$saved_CFLAGS\"\nelse\n\t\tdnl If we are compiling natively, try running the program.\n\t\tAC_RUN_IFELSE([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  CFLAGS=\"$saved_CFLAGS $_define_flag\" ],\n\t\t\t[ AC_MSG_RESULT([no, fails at run time])\n\t\t\t  CFLAGS=\"$saved_CFLAGS\" ],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  CFLAGS=\"$saved_CFLAGS $_define_flag\" ],\n\t\t)\nfi],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  CFLAGS=\"$saved_CFLAGS\" ]\n\t)\n}])\n\ndnl OSSH_CHECK_CFLAG_LINK(check_flag[, define_flag])\ndnl Check that $CC accepts a flag 'check_flag'. If it is supported append\ndnl 'define_flag' to $CFLAGS. If 'define_flag' is not specified, then append\ndnl 'check_flag'.\nAC_DEFUN([OSSH_CHECK_CFLAG_LINK], [{\n\tAC_MSG_CHECKING([if $CC supports compile flag $1 and linking succeeds])\n\tsaved_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS $WERROR $1\"\n\t_define_flag=\"$2\"\n\ttest \"x$_define_flag\" = \"x\" && _define_flag=\"$1\"\n\tAC_LINK_IFELSE([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t\t[\nif $ac_cv_path_EGREP -i \"unrecognized option|warning.*ignored\" conftest.err >/dev/null\nthen\n\t\tAC_MSG_RESULT([no])\n\t\tCFLAGS=\"$saved_CFLAGS\"\nelse\n\t\tdnl If we are compiling natively, try running the program.\n\t\tAC_RUN_IFELSE([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  CFLAGS=\"$saved_CFLAGS $_define_flag\" ],\n\t\t\t[ AC_MSG_RESULT([no, fails at run time])\n\t\t\t  CFLAGS=\"$saved_CFLAGS\" ],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  CFLAGS=\"$saved_CFLAGS $_define_flag\" ],\n\t\t)\nfi],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  CFLAGS=\"$saved_CFLAGS\" ]\n\t)\n}])\n\ndnl OSSH_CHECK_LDFLAG_LINK(check_flag[, define_flag])\ndnl Check that $LD accepts a flag 'check_flag'. If it is supported append\ndnl 'define_flag' to $LDFLAGS. If 'define_flag' is not specified, then append\ndnl 'check_flag'.\nAC_DEFUN([OSSH_CHECK_LDFLAG_LINK], [{\n\tAC_MSG_CHECKING([if $LD supports link flag $1])\n\tsaved_LDFLAGS=\"$LDFLAGS\"\n\tLDFLAGS=\"$LDFLAGS $WERROR $1\"\n\t_define_flag=\"$2\"\n\ttest \"x$_define_flag\" = \"x\" && _define_flag=\"$1\"\n\tAC_LINK_IFELSE([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t\t[\nif $ac_cv_path_EGREP -i \"unrecognized option|warning.*ignored\" conftest.err >/dev/null\nthen\n\t\t  AC_MSG_RESULT([no])\n\t\t  LDFLAGS=\"$saved_LDFLAGS\"\nelse\n\t\t  dnl If we are compiling natively, try running the program.\n\t\t  AC_RUN_IFELSE([OSSH_COMPILER_FLAG_TEST_PROGRAM],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  LDFLAGS=\"$saved_LDFLAGS $_define_flag\" ],\n\t\t\t[ AC_MSG_RESULT([no, fails at run time])\n\t\t\t  LDFLAGS=\"$saved_LDFLAGS\" ],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  LDFLAGS=\"$saved_LDFLAGS $_define_flag\" ]\n\t\t  )\nfi\t\t],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  LDFLAGS=\"$saved_LDFLAGS\" ]\n\t)\n}])\n\ndnl OSSH_CHECK_HEADER_FOR_FIELD(field, header, symbol)\ndnl Does AC_EGREP_HEADER on 'header' for the string 'field'\ndnl If found, set 'symbol' to be defined. Cache the result.\ndnl TODO: This is not foolproof, better to compile and read from there\nAC_DEFUN([OSSH_CHECK_HEADER_FOR_FIELD], [\n# look for field '$1' in header '$2'\n\tdnl This strips characters illegal to m4 from the header filename\n\tossh_safe=`echo \"$2\" | sed 'y%./+-%__p_%'`\n\tdnl\n\tossh_varname=\"ossh_cv_$ossh_safe\"\"_has_\"$1\n\tAC_MSG_CHECKING(for $1 field in $2)\n\tAC_CACHE_VAL($ossh_varname, [\n\t\tAC_EGREP_HEADER($1, $2, [ dnl\n\t\t\teval \"$ossh_varname=yes\" dnl\n\t\t], [ dnl\n\t\t\teval \"$ossh_varname=no\" dnl\n\t\t]) dnl\n\t])\n\tossh_result=`eval 'echo $'\"$ossh_varname\"`\n\tif test -n \"`echo $ossh_varname`\"; then\n\t\tAC_MSG_RESULT($ossh_result)\n\t\tif test \"x$ossh_result\" = \"xyes\"; then\n\t\t\tAC_DEFINE($3, 1, [Define if you have $1 in $2])\n\t\tfi\n\telse\n\t\tAC_MSG_RESULT(no)\n\tfi\n])\n\ndnl Check for socklen_t: historically on BSD it is an int, and in\ndnl POSIX 1g it is a type of its own, but some platforms use different\ndnl types for the argument to getsockopt, getpeername, etc.  So we\ndnl have to test to find something that will work.\nAC_DEFUN([TYPE_SOCKLEN_T],\n[\n   AC_CHECK_TYPE([socklen_t], ,[\n      AC_MSG_CHECKING([for socklen_t equivalent])\n      AC_CACHE_VAL([curl_cv_socklen_t_equiv],\n      [\n\t # Systems have either \"struct sockaddr *\" or\n\t # \"void *\" as the second argument to getpeername\n\t curl_cv_socklen_t_equiv=\n\t for arg2 in \"struct sockaddr\" void; do\n\t    for t in int size_t unsigned long \"unsigned long\"; do\n\t       AC_COMPILE_IFELSE([\n\t\t  AC_LANG_PROGRAM([[\n\t\t    #include <sys/types.h>\n\t\t    #include <sys/socket.h>\n\t\t    int getpeername (int, $arg2 *, $t *);\n\t\t  ]], [[\n\t\t    $t len;\n\t\t    getpeername(0,0,&len);\n\t\t  ]])\n\t       ],[\n\t\t  curl_cv_socklen_t_equiv=\"$t\"\n\t\t  break\n\t       ])\n\t    done\n\t done\n\n\t if test \"x$curl_cv_socklen_t_equiv\" = x; then\n\t    AC_MSG_ERROR([Cannot find a type to use in place of socklen_t])\n\t fi\n      ])\n      AC_MSG_RESULT($curl_cv_socklen_t_equiv)\n      AC_DEFINE_UNQUOTED(socklen_t, $curl_cv_socklen_t_equiv,\n\t\t\t[type to use in place of socklen_t if not defined])],\n      [#include <sys/types.h>\n#include <sys/socket.h>])\n])\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}