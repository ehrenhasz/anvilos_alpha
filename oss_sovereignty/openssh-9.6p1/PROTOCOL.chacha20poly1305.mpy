{
  "module_name": "PROTOCOL.chacha20poly1305",
  "hash_id": "360c459325d5b5b683b6ddaf26a5a45af2dbf32eef95cdefe83dd25a40e34e5e",
  "original_prompt": "Ingested from openssh-9.6p1/PROTOCOL.chacha20poly1305",
  "human_readable_source": "This document describes the chacha20-poly1305@openssh.com authenticated\nencryption cipher supported by OpenSSH.\n\nBackground\n----------\n\nChaCha20 is a stream cipher designed by Daniel Bernstein and described\nin [1]. It operates by permuting 128 fixed bits, 128 or 256 bits of key,\na 64 bit nonce and a 64 bit counter into 64 bytes of output. This output\nis used as a keystream, with any unused bytes simply discarded.\n\nPoly1305[2], also by Daniel Bernstein, is a one-time Carter-Wegman MAC\nthat computes a 128 bit integrity tag given a message and a single-use\n256 bit secret key.\n\nThe chacha20-poly1305@openssh.com combines these two primitives into an\nauthenticated encryption mode. The construction used is based on that\nproposed for TLS by Adam Langley in [3], but differs in the layout of\ndata passed to the MAC and in the addition of encryption of the packet\nlengths.\n\nNegotiation\n-----------\n\nThe chacha20-poly1305@openssh.com offers both encryption and\nauthentication. As such, no separate MAC is required. If the\nchacha20-poly1305@openssh.com cipher is selected in key exchange,\nthe offered MAC algorithms are ignored and no MAC is required to be\nnegotiated.\n\nDetailed Construction\n---------------------\n\nThe chacha20-poly1305@openssh.com cipher requires 512 bits of key\nmaterial as output from the SSH key exchange. This forms two 256 bit\nkeys (K_1 and K_2), used by two separate instances of chacha20.\nThe first 256 bits constitute K_2 and the second 256 bits become\nK_1.\n\nThe instance keyed by K_1 is a stream cipher that is used only\nto encrypt the 4 byte packet length field. The second instance,\nkeyed by K_2, is used in conjunction with poly1305 to build an AEAD\n(Authenticated Encryption with Associated Data) that is used to encrypt\nand authenticate the entire packet.\n\nTwo separate cipher instances are used here so as to keep the packet\nlengths confidential but not create an oracle for the packet payload\ncipher by decrypting and using the packet length prior to checking\nthe MAC. By using an independently-keyed cipher instance to encrypt the\nlength, an active attacker seeking to exploit the packet input handling\nas a decryption oracle can learn nothing about the payload contents or\nits MAC (assuming key derivation, ChaCha20 and Poly1305 are secure).\n\nThe AEAD is constructed as follows: for each packet, generate a Poly1305\nkey by taking the first 256 bits of ChaCha20 stream output generated\nusing K_2, an IV consisting of the packet sequence number encoded as an\nuint64 under the SSH wire encoding rules and a ChaCha20 block counter of\nzero. The K_2 ChaCha20 block counter is then set to the little-endian\nencoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used\nfor encryption of the packet payload.\n\nPacket Handling\n---------------\n\nWhen receiving a packet, the length must be decrypted first. When 4\nbytes of ciphertext length have been received, they may be decrypted\nusing the K_1 key, a nonce consisting of the packet sequence number\nencoded as a uint64 under the usual SSH wire encoding and a zero block\ncounter to obtain the plaintext length.\n\nOnce the entire packet has been received, the MAC MUST be checked\nbefore decryption. A per-packet Poly1305 key is generated as described\nabove and the MAC tag calculated using Poly1305 with this key over the\nciphertext of the packet length and the payload together. The calculated\nMAC is then compared in constant time with the one appended to the\npacket and the packet decrypted using ChaCha20 as described above (with\nK_2, the packet sequence number as nonce and a starting block counter of\n1).\n\nTo send a packet, first encode the 4 byte length and encrypt it using\nK_1. Encrypt the packet payload (using K_2) and append it to the\nencrypted length. Finally, calculate a MAC tag and append it.\n\nRekeying\n--------\n\nChaCha20 must never reuse a {key, nonce} for encryption nor may it be\nused to encrypt more than 2^70 bytes under the same {key, nonce}. The\nSSH Transport protocol (RFC4253) recommends a far more conservative\nrekeying every 1GB of data sent or received. If this recommendation\nis followed, then chacha20-poly1305@openssh.com requires no special\nhandling in this area.\n\nReferences\n----------\n\n[1] \"ChaCha, a variant of Salsa20\", Daniel Bernstein\n    http://cr.yp.to/chacha/chacha-20080128.pdf\n\n[2] \"The Poly1305-AES message-authentication code\", Daniel Bernstein\n    http://cr.yp.to/mac/poly1305-20050329.pdf\n\n[3] \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley\n    http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03\n\n$OpenBSD: PROTOCOL.chacha20poly1305,v 1.5 2020/02/21 00:04:43 dtucker Exp $\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}