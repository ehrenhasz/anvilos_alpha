{
  "module_name": "ssh-sk.c",
  "hash_id": "67f1247a526f948c4b610a3b6514b84f754bf0c9de1482085c9a29c5c1d0cc04",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-sk.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#ifdef ENABLE_SK\n\n#include <dlfcn.h>\n#include <stddef.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <string.h>\n#include <stdio.h>\n\n#if defined(WITH_OPENSSL) && defined(OPENSSL_HAS_ECC)\n#include <openssl/objects.h>\n#include <openssl/ec.h>\n#endif  \n\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n\n#include \"ssh-sk.h\"\n#include \"sk-api.h\"\n#include \"crypto_api.h\"\n\n \n#ifndef OPENSSL_HAS_ECC\n# undef WITH_OPENSSL\n#endif\n\nstruct sshsk_provider {\n\tchar *path;\n\tvoid *dlhandle;\n\n\t \n\tuint32_t (*sk_api_version)(void);\n\n\t \n\tint (*sk_enroll)(int alg, const uint8_t *challenge,\n\t    size_t challenge_len, const char *application, uint8_t flags,\n\t    const char *pin, struct sk_option **opts,\n\t    struct sk_enroll_response **enroll_response);\n\n\t \n\tint (*sk_sign)(int alg, const uint8_t *message, size_t message_len,\n\t    const char *application,\n\t    const uint8_t *key_handle, size_t key_handle_len,\n\t    uint8_t flags, const char *pin, struct sk_option **opts,\n\t    struct sk_sign_response **sign_response);\n\n\t \n\tint (*sk_load_resident_keys)(const char *pin, struct sk_option **opts,\n\t    struct sk_resident_key ***rks, size_t *nrks);\n};\n\n \nint ssh_sk_enroll(int alg, const uint8_t *challenge,\n    size_t challenge_len, const char *application, uint8_t flags,\n    const char *pin, struct sk_option **opts,\n    struct sk_enroll_response **enroll_response);\nint ssh_sk_sign(int alg, const uint8_t *message, size_t message_len,\n    const char *application,\n    const uint8_t *key_handle, size_t key_handle_len,\n    uint8_t flags, const char *pin, struct sk_option **opts,\n    struct sk_sign_response **sign_response);\nint ssh_sk_load_resident_keys(const char *pin, struct sk_option **opts,\n    struct sk_resident_key ***rks, size_t *nrks);\n\nstatic void\nsshsk_free(struct sshsk_provider *p)\n{\n\tif (p == NULL)\n\t\treturn;\n\tfree(p->path);\n\tif (p->dlhandle != NULL)\n\t\tdlclose(p->dlhandle);\n\tfree(p);\n}\n\nstatic struct sshsk_provider *\nsshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\t \n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n#ifdef ENABLE_SK_INTERNAL\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n#else\n\t\terror(\"internal security key support not enabled\");\n\t\tgoto fail;\n#endif\n\t}\n\tif (lib_contains_symbol(path, \"sk_api_version\") != 0) {\n\t\terror(\"provider %s is not an OpenSSH FIDO library\", path);\n\t\tgoto fail;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL)\n\t\tfatal(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\t \n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}\n\nstatic void\nsshsk_free_enroll_response(struct sk_enroll_response *r)\n{\n\tif (r == NULL)\n\t\treturn;\n\tfreezero(r->key_handle, r->key_handle_len);\n\tfreezero(r->public_key, r->public_key_len);\n\tfreezero(r->signature, r->signature_len);\n\tfreezero(r->attestation_cert, r->attestation_cert_len);\n\tfreezero(r->authdata, r->authdata_len);\n\tfreezero(r, sizeof(*r));\n}\n\nstatic void\nsshsk_free_sign_response(struct sk_sign_response *r)\n{\n\tif (r == NULL)\n\t\treturn;\n\tfreezero(r->sig_r, r->sig_r_len);\n\tfreezero(r->sig_s, r->sig_s_len);\n\tfreezero(r, sizeof(*r));\n}\n\n#ifdef WITH_OPENSSL\n \nstatic int\nsshsk_ecdsa_assemble(struct sk_enroll_response *resp, struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL;\n\tstruct sshbuf *b = NULL;\n\tEC_POINT *q = NULL;\n\tint r;\n\n\t*keyp = NULL;\n\tif ((key = sshkey_new(KEY_ECDSA_SK)) == NULL) {\n\t\terror_f(\"sshkey_new failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tkey->ecdsa_nid = NID_X9_62_prime256v1;\n\tif ((key->ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid)) == NULL ||\n\t    (q = EC_POINT_new(EC_KEY_get0_group(key->ecdsa))) == NULL ||\n\t    (b = sshbuf_new()) == NULL) {\n\t\terror_f(\"allocation failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(b,\n\t    resp->public_key, resp->public_key_len)) != 0) {\n\t\terror_fr(r, \"sshbuf_put_string\");\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_ec(b, q, EC_KEY_get0_group(key->ecdsa))) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshkey_ec_validate_public(EC_KEY_get0_group(key->ecdsa), q) != 0) {\n\t\terror(\"Authenticator returned invalid ECDSA key\");\n\t\tr = SSH_ERR_KEY_INVALID_EC_VALUE;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_set_public_key(key->ecdsa, q) != 1) {\n\t\t \n\t\terror_f(\"allocation failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t \n\t*keyp = key;\n\tkey = NULL;  \n\tr = 0;\n out:\n\tEC_POINT_free(q);\n\tsshkey_free(key);\n\tsshbuf_free(b);\n\treturn r;\n}\n#endif  \n\nstatic int\nsshsk_ed25519_assemble(struct sk_enroll_response *resp, struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL;\n\tint r;\n\n\t*keyp = NULL;\n\tif (resp->public_key_len != ED25519_PK_SZ) {\n\t\terror_f(\"invalid size: %zu\", resp->public_key_len);\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((key = sshkey_new(KEY_ED25519_SK)) == NULL) {\n\t\terror_f(\"sshkey_new failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((key->ed25519_pk = malloc(ED25519_PK_SZ)) == NULL) {\n\t\terror_f(\"malloc failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmemcpy(key->ed25519_pk, resp->public_key, ED25519_PK_SZ);\n\t \n\t*keyp = key;\n\tkey = NULL;  \n\tr = 0;\n out:\n\tsshkey_free(key);\n\treturn r;\n}\n\nstatic int\nsshsk_key_from_response(int alg, const char *application, uint8_t flags,\n    struct sk_enroll_response *resp, struct sshkey **keyp)\n{\n\tstruct sshkey *key = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*keyp = NULL;\n\n\t \n\tif (resp->public_key == NULL || resp->key_handle == NULL) {\n\t\terror_f(\"sk_enroll response invalid\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tswitch (alg) {\n#ifdef WITH_OPENSSL\n\tcase SSH_SK_ECDSA:\n\t\tif ((r = sshsk_ecdsa_assemble(resp, &key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif  \n\tcase SSH_SK_ED25519:\n\t\tif ((r = sshsk_ed25519_assemble(resp, &key)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\terror_f(\"unsupported algorithm %d\", alg);\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tkey->sk_flags = flags;\n\tif ((key->sk_key_handle = sshbuf_new()) == NULL ||\n\t    (key->sk_reserved = sshbuf_new()) == NULL) {\n\t\terror_f(\"allocation failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((key->sk_application = strdup(application)) == NULL) {\n\t\terror_f(\"strdup application failed\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put(key->sk_key_handle, resp->key_handle,\n\t    resp->key_handle_len)) != 0) {\n\t\terror_fr(r, \"put key handle\");\n\t\tgoto out;\n\t}\n\t \n\tr = 0;\n\t*keyp = key;\n\tkey = NULL;\n out:\n\tsshkey_free(key);\n\treturn r;\n}\n\nstatic int\nskerr_to_ssherr(int skerr)\n{\n\tswitch (skerr) {\n\tcase SSH_SK_ERR_UNSUPPORTED:\n\t\treturn SSH_ERR_FEATURE_UNSUPPORTED;\n\tcase SSH_SK_ERR_PIN_REQUIRED:\n\t\treturn SSH_ERR_KEY_WRONG_PASSPHRASE;\n\tcase SSH_SK_ERR_DEVICE_NOT_FOUND:\n\t\treturn SSH_ERR_DEVICE_NOT_FOUND;\n\tcase SSH_SK_ERR_CREDENTIAL_EXISTS:\n\t\treturn SSH_ERR_KEY_BAD_PERMISSIONS;\n\tcase SSH_SK_ERR_GENERAL:\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n}\n\nstatic void\nsshsk_free_options(struct sk_option **opts)\n{\n\tsize_t i;\n\n\tif (opts == NULL)\n\t\treturn;\n\tfor (i = 0; opts[i] != NULL; i++) {\n\t\tfree(opts[i]->name);\n\t\tfree(opts[i]->value);\n\t\tfree(opts[i]);\n\t}\n\tfree(opts);\n}\n\nstatic int\nsshsk_add_option(struct sk_option ***optsp, size_t *noptsp,\n    const char *name, const char *value, uint8_t required)\n{\n\tstruct sk_option **opts = *optsp;\n\tsize_t nopts = *noptsp;\n\n\tif ((opts = recallocarray(opts, nopts, nopts + 2,  \n\t    sizeof(*opts))) == NULL) {\n\t\terror_f(\"array alloc failed\");\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\t*optsp = opts;\n\t*noptsp = nopts + 1;\n\tif ((opts[nopts] = calloc(1, sizeof(**opts))) == NULL) {\n\t\terror_f(\"alloc failed\");\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\tif ((opts[nopts]->name = strdup(name)) == NULL ||\n\t    (opts[nopts]->value = strdup(value)) == NULL) {\n\t\terror_f(\"alloc failed\");\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\t}\n\topts[nopts]->required = required;\n\treturn 0;\n}\n\nstatic int\nmake_options(const char *device, const char *user_id,\n    struct sk_option ***optsp)\n{\n\tstruct sk_option **opts = NULL;\n\tsize_t nopts = 0;\n\tint r, ret = SSH_ERR_INTERNAL_ERROR;\n\n\tif (device != NULL &&\n\t    (r = sshsk_add_option(&opts, &nopts, \"device\", device, 0)) != 0) {\n\t\tret = r;\n\t\tgoto out;\n\t}\n\tif (user_id != NULL &&\n\t    (r = sshsk_add_option(&opts, &nopts, \"user\", user_id, 0)) != 0) {\n\t\tret = r;\n\t\tgoto out;\n\t}\n\t \n\t*optsp = opts;\n\topts = NULL;\n\tnopts = 0;\n\tret = 0;\n out:\n\tsshsk_free_options(opts);\n\treturn ret;\n}\n\n\nstatic int\nfill_attestation_blob(const struct sk_enroll_response *resp,\n    struct sshbuf *attest)\n{\n\tint r;\n\n\tif (attest == NULL)\n\t\treturn 0;  \n\tif ((r = sshbuf_put_cstring(attest, \"ssh-sk-attest-v01\")) != 0 ||\n\t    (r = sshbuf_put_string(attest,\n\t    resp->attestation_cert, resp->attestation_cert_len)) != 0 ||\n\t    (r = sshbuf_put_string(attest,\n\t    resp->signature, resp->signature_len)) != 0 ||\n\t    (r = sshbuf_put_string(attest,\n\t    resp->authdata, resp->authdata_len)) != 0 ||\n\t    (r = sshbuf_put_u32(attest, 0)) != 0 ||  \n\t    (r = sshbuf_put_string(attest, NULL, 0)) != 0  ) {\n\t\terror_fr(r, \"compose\");\n\t\treturn r;\n\t}\n\t \n\treturn 0;\n}\n\nint\nsshsk_enroll(int type, const char *provider_path, const char *device,\n    const char *application, const char *userid, uint8_t flags,\n    const char *pin, struct sshbuf *challenge_buf,\n    struct sshkey **keyp, struct sshbuf *attest)\n{\n\tstruct sshsk_provider *skp = NULL;\n\tstruct sshkey *key = NULL;\n\tu_char randchall[32];\n\tconst u_char *challenge;\n\tsize_t challenge_len;\n\tstruct sk_enroll_response *resp = NULL;\n\tstruct sk_option **opts = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint alg;\n\n\tdebug_f(\"provider \\\"%s\\\", device \\\"%s\\\", application \\\"%s\\\", \"\n\t    \"userid \\\"%s\\\", flags 0x%02x, challenge len %zu%s\",\n\t    provider_path, device, application, userid, flags,\n\t    challenge_buf == NULL ? 0 : sshbuf_len(challenge_buf),\n\t    (pin != NULL && *pin != '\\0') ? \" with-pin\" : \"\");\n\n\t*keyp = NULL;\n\tif (attest)\n\t\tsshbuf_reset(attest);\n\n\tif ((r = make_options(device, userid, &opts)) != 0)\n\t\tgoto out;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n\t\talg = SSH_SK_ECDSA;\n\t\tbreak;\n#endif  \n\tcase KEY_ED25519_SK:\n\t\talg = SSH_SK_ED25519;\n\t\tbreak;\n\tdefault:\n\t\terror_f(\"unsupported key type\");\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (provider_path == NULL) {\n\t\terror_f(\"missing provider\");\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (application == NULL || *application == '\\0') {\n\t\terror_f(\"missing application\");\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif (challenge_buf == NULL) {\n\t\tdebug_f(\"using random challenge\");\n\t\tarc4random_buf(randchall, sizeof(randchall));\n\t\tchallenge = randchall;\n\t\tchallenge_len = sizeof(randchall);\n\t} else if (sshbuf_len(challenge_buf) == 0) {\n\t\terror(\"Missing enrollment challenge\");\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t} else {\n\t\tchallenge = sshbuf_ptr(challenge_buf);\n\t\tchallenge_len = sshbuf_len(challenge_buf);\n\t\tdebug3_f(\"using explicit challenge len=%zd\", challenge_len);\n\t}\n\tif ((skp = sshsk_open(provider_path)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;  \n\t\tgoto out;\n\t}\n\t \n\t \n\tif ((r = skp->sk_enroll(alg, challenge, challenge_len, application,\n\t    flags, pin, opts, &resp)) != 0) {\n\t\tdebug_f(\"provider \\\"%s\\\" failure %d\", provider_path, r);\n\t\tr = skerr_to_ssherr(r);\n\t\tgoto out;\n\t}\n\n\tif ((r = sshsk_key_from_response(alg, application, resp->flags,\n\t    resp, &key)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = fill_attestation_blob(resp, attest)) != 0)\n\t\tgoto out;\n\n\t \n\t*keyp = key;\n\tkey = NULL;  \n\tr = 0;\n out:\n\tsshsk_free_options(opts);\n\tsshsk_free(skp);\n\tsshkey_free(key);\n\tsshsk_free_enroll_response(resp);\n\texplicit_bzero(randchall, sizeof(randchall));\n\treturn r;\n}\n\n#ifdef WITH_OPENSSL\nstatic int\nsshsk_ecdsa_sig(struct sk_sign_response *resp, struct sshbuf *sig)\n{\n\tstruct sshbuf *inner_sig = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif (resp->sig_r == NULL || resp->sig_s == NULL) {\n\t\terror_f(\"sk_sign response invalid\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((inner_sig = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t \n\tif ((r = sshbuf_put_bignum2_bytes(inner_sig,\n\t    resp->sig_r, resp->sig_r_len)) != 0 ||\n\t    (r = sshbuf_put_bignum2_bytes(inner_sig,\n\t    resp->sig_s, resp->sig_s_len)) != 0) {\n\t\terror_fr(r, \"compose inner\");\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_stringb(sig, inner_sig)) != 0 ||\n\t    (r = sshbuf_put_u8(sig, resp->flags)) != 0 ||\n\t    (r = sshbuf_put_u32(sig, resp->counter)) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sig_r:\\n\", __func__);\n\tsshbuf_dump_data(resp->sig_r, resp->sig_r_len, stderr);\n\tfprintf(stderr, \"%s: sig_s:\\n\", __func__);\n\tsshbuf_dump_data(resp->sig_s, resp->sig_s_len, stderr);\n\tfprintf(stderr, \"%s: inner:\\n\", __func__);\n\tsshbuf_dump(inner_sig, stderr);\n#endif\n\tr = 0;\n out:\n\tsshbuf_free(inner_sig);\n\treturn r;\n}\n#endif  \n\nstatic int\nsshsk_ed25519_sig(struct sk_sign_response *resp, struct sshbuf *sig)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif (resp->sig_r == NULL) {\n\t\terror_f(\"sk_sign response invalid\");\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_string(sig,\n\t    resp->sig_r, resp->sig_r_len)) != 0 ||\n\t    (r = sshbuf_put_u8(sig, resp->flags)) != 0 ||\n\t    (r = sshbuf_put_u32(sig, resp->counter)) != 0) {\n\t\terror_fr(r, \"compose\");\n\t\tgoto out;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sig_r:\\n\", __func__);\n\tsshbuf_dump_data(resp->sig_r, resp->sig_r_len, stderr);\n#endif\n\tr = 0;\n out:\n\treturn r;\n}\n\nint\nsshsk_sign(const char *provider_path, struct sshkey *key,\n    u_char **sigp, size_t *lenp, const u_char *data, size_t datalen,\n    u_int compat, const char *pin)\n{\n\tstruct sshsk_provider *skp = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tint type, alg;\n\tstruct sk_sign_response *resp = NULL;\n\tstruct sshbuf *inner_sig = NULL, *sig = NULL;\n\tstruct sk_option **opts = NULL;\n\n\tdebug_f(\"provider \\\"%s\\\", key %s, flags 0x%02x%s\",\n\t    provider_path, sshkey_type(key), key->sk_flags,\n\t    (pin != NULL && *pin != '\\0') ? \" with-pin\" : \"\");\n\n\tif (sigp != NULL)\n\t\t*sigp = NULL;\n\tif (lenp != NULL)\n\t\t*lenp = 0;\n\ttype = sshkey_type_plain(key->type);\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n\t\talg = SSH_SK_ECDSA;\n\t\tbreak;\n#endif  \n\tcase KEY_ED25519_SK:\n\t\talg = SSH_SK_ED25519;\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t}\n\tif (provider_path == NULL ||\n\t    key->sk_key_handle == NULL ||\n\t    key->sk_application == NULL || *key->sk_application == '\\0') {\n\t\tr = SSH_ERR_INVALID_ARGUMENT;\n\t\tgoto out;\n\t}\n\tif ((skp = sshsk_open(provider_path)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;  \n\t\tgoto out;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sk_flags = 0x%02x, sk_application = \\\"%s\\\"\\n\",\n\t    __func__, key->sk_flags, key->sk_application);\n\tfprintf(stderr, \"%s: sk_key_handle:\\n\", __func__);\n\tsshbuf_dump(key->sk_key_handle, stderr);\n#endif\n\tif ((r = skp->sk_sign(alg, data, datalen, key->sk_application,\n\t    sshbuf_ptr(key->sk_key_handle), sshbuf_len(key->sk_key_handle),\n\t    key->sk_flags, pin, opts, &resp)) != 0) {\n\t\tdebug_f(\"sk_sign failed with code %d\", r);\n\t\tr = skerr_to_ssherr(r);\n\t\tgoto out;\n\t}\n\t \n\tif ((sig = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_cstring(sig, sshkey_ssh_name_plain(key))) != 0) {\n\t\terror_fr(r, \"compose outer\");\n\t\tgoto out;\n\t}\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_ECDSA_SK:\n\t\tif ((r = sshsk_ecdsa_sig(resp, sig)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n#endif  \n\tcase KEY_ED25519_SK:\n\t\tif ((r = sshsk_ed25519_sig(resp, sig)) != 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: sig_flags = 0x%02x, sig_counter = %u\\n\",\n\t    __func__, resp->flags, resp->counter);\n\tfprintf(stderr, \"%s: data to sign:\\n\", __func__);\n\tsshbuf_dump_data(data, datalen, stderr);\n\tfprintf(stderr, \"%s: sigbuf:\\n\", __func__);\n\tsshbuf_dump(sig, stderr);\n#endif\n\tif (sigp != NULL) {\n\t\tif ((*sigp = malloc(sshbuf_len(sig))) == NULL) {\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(*sigp, sshbuf_ptr(sig), sshbuf_len(sig));\n\t}\n\tif (lenp != NULL)\n\t\t*lenp = sshbuf_len(sig);\n\t \n\tr = 0;\n out:\n\tsshsk_free_options(opts);\n\tsshsk_free(skp);\n\tsshsk_free_sign_response(resp);\n\tsshbuf_free(sig);\n\tsshbuf_free(inner_sig);\n\treturn r;\n}\n\nstatic void\nsshsk_free_sk_resident_keys(struct sk_resident_key **rks, size_t nrks)\n{\n\tsize_t i;\n\n\tif (nrks == 0 || rks == NULL)\n\t\treturn;\n\tfor (i = 0; i < nrks; i++) {\n\t\tfree(rks[i]->application);\n\t\tfreezero(rks[i]->user_id, rks[i]->user_id_len);\n\t\tfreezero(rks[i]->key.key_handle, rks[i]->key.key_handle_len);\n\t\tfreezero(rks[i]->key.public_key, rks[i]->key.public_key_len);\n\t\tfreezero(rks[i]->key.signature, rks[i]->key.signature_len);\n\t\tfreezero(rks[i]->key.attestation_cert,\n\t\t    rks[i]->key.attestation_cert_len);\n\t\tfreezero(rks[i], sizeof(**rks));\n\t}\n\tfree(rks);\n}\n\nstatic void\nsshsk_free_resident_key(struct sshsk_resident_key *srk)\n{\n\tif (srk == NULL)\n\t\treturn;\n\tsshkey_free(srk->key);\n\tfreezero(srk->user_id, srk->user_id_len);\n\tfree(srk);\n}\n\n\nvoid\nsshsk_free_resident_keys(struct sshsk_resident_key **srks, size_t nsrks)\n{\n\tsize_t i;\n\n\tif (srks == NULL || nsrks == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nsrks; i++)\n\t\tsshsk_free_resident_key(srks[i]);\n\tfree(srks);\n}\n\nint\nsshsk_load_resident(const char *provider_path, const char *device,\n    const char *pin, u_int flags, struct sshsk_resident_key ***srksp,\n    size_t *nsrksp)\n{\n\tstruct sshsk_provider *skp = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sk_resident_key **rks = NULL;\n\tsize_t i, nrks = 0, nsrks = 0;\n\tstruct sshkey *key = NULL;\n\tstruct sshsk_resident_key *srk = NULL, **srks = NULL, **tmp;\n\tuint8_t sk_flags;\n\tstruct sk_option **opts = NULL;\n\n\tdebug_f(\"provider \\\"%s\\\"%s\", provider_path,\n\t    (pin != NULL && *pin != '\\0') ? \", have-pin\": \"\");\n\n\tif (srksp == NULL || nsrksp == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\t*srksp = NULL;\n\t*nsrksp = 0;\n\n\tif ((r = make_options(device, NULL, &opts)) != 0)\n\t\tgoto out;\n\tif ((skp = sshsk_open(provider_path)) == NULL) {\n\t\tr = SSH_ERR_INVALID_FORMAT;  \n\t\tgoto out;\n\t}\n\tif ((r = skp->sk_load_resident_keys(pin, opts, &rks, &nrks)) != 0) {\n\t\terror(\"Provider \\\"%s\\\" returned failure %d\", provider_path, r);\n\t\tr = skerr_to_ssherr(r);\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < nrks; i++) {\n\t\tdebug3_f(\"rk %zu: slot %zu, alg %d, app \\\"%s\\\", uidlen %zu\",\n\t\t    i, rks[i]->slot, rks[i]->alg, rks[i]->application,\n\t\t    rks[i]->user_id_len);\n\t\t \n\t\tif (strncmp(rks[i]->application, \"ssh:\", 4) != 0)\n\t\t\tcontinue;\n\t\tswitch (rks[i]->alg) {\n\t\tcase SSH_SK_ECDSA:\n\t\tcase SSH_SK_ED25519:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tsk_flags = SSH_SK_USER_PRESENCE_REQD|SSH_SK_RESIDENT_KEY;\n\t\tif ((rks[i]->flags & SSH_SK_USER_VERIFICATION_REQD))\n\t\t\tsk_flags |= SSH_SK_USER_VERIFICATION_REQD;\n\t\tif ((r = sshsk_key_from_response(rks[i]->alg,\n\t\t    rks[i]->application, sk_flags, &rks[i]->key, &key)) != 0)\n\t\t\tgoto out;\n\t\tif ((srk = calloc(1, sizeof(*srk))) == NULL) {\n\t\t\terror_f(\"calloc failed\");\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tsrk->key = key;\n\t\tkey = NULL;  \n\t\tif ((srk->user_id = calloc(1, rks[i]->user_id_len)) == NULL) {\n\t\t\terror_f(\"calloc failed\");\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(srk->user_id, rks[i]->user_id, rks[i]->user_id_len);\n\t\tsrk->user_id_len = rks[i]->user_id_len;\n\t\tif ((tmp = recallocarray(srks, nsrks, nsrks + 1,\n\t\t    sizeof(*tmp))) == NULL) {\n\t\t\terror_f(\"recallocarray failed\");\n\t\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\tsrks = tmp;\n\t\tsrks[nsrks++] = srk;\n\t\tsrk = NULL;\n\t\t \n\t}\n\t \n\t*srksp = srks;\n\t*nsrksp = nsrks;\n\tsrks = NULL;\n\tnsrks = 0;\n\tr = 0;\n out:\n\tsshsk_free_options(opts);\n\tsshsk_free(skp);\n\tsshsk_free_sk_resident_keys(rks, nrks);\n\tsshkey_free(key);\n\tsshsk_free_resident_key(srk);\n\tsshsk_free_resident_keys(srks, nsrks);\n\treturn r;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}