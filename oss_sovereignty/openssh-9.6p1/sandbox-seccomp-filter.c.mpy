{
  "module_name": "sandbox-seccomp-filter.c",
  "hash_id": "387f622f72874e6c8283de4e3597343350b2a214e896dd782baebdd574cf9193",
  "original_prompt": "Ingested from openssh-9.6p1/sandbox-seccomp-filter.c",
  "human_readable_source": " \n\n \n \n\n#if 0\n \n#ifdef SANDBOX_SECCOMP_FILTER_DEBUG\n# include <asm/siginfo.h>\n# define __have_siginfo_t 1\n# define __have_sigval_t 1\n# define __have_sigevent_t 1\n#endif  \n#endif\n\n#include \"includes.h\"\n\n#ifdef SANDBOX_SECCOMP_FILTER\n\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n\n#include <linux/futex.h>\n#include <linux/net.h>\n#include <linux/audit.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <elf.h>\n\n#include <asm/unistd.h>\n#ifdef __s390__\n#include <asm/zcrypt.h>\n#endif\n\n#include <errno.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>   \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"log.h\"\n#include \"ssh-sandbox.h\"\n#include \"xmalloc.h\"\n\n \n#define SECCOMP_FILTER_FAIL SECCOMP_RET_KILL\n\n \n#ifdef SANDBOX_SECCOMP_FILTER_DEBUG\n# undef SECCOMP_FILTER_FAIL\n# define SECCOMP_FILTER_FAIL SECCOMP_RET_TRAP\n#endif  \n\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n# define ARG_LO_OFFSET  0\n# define ARG_HI_OFFSET  sizeof(uint32_t)\n#elif __BYTE_ORDER == __BIG_ENDIAN\n# define ARG_LO_OFFSET  sizeof(uint32_t)\n# define ARG_HI_OFFSET  0\n#else\n#error \"Unknown endianness\"\n#endif\n\n \n#define SC_DENY(_nr, _errno) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ERRNO|(_errno))\n#define SC_ALLOW(_nr) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)\n#define SC_ALLOW_ARG(_nr, _arg_nr, _arg_val) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 6), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_LO_OFFSET), \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, \\\n\t    ((_arg_val) & 0xFFFFFFFF), 0, 3), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_HI_OFFSET), \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, \\\n\t    (((uint32_t)((uint64_t)(_arg_val) >> 32)) & 0xFFFFFFFF), 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t\toffsetof(struct seccomp_data, nr))\n \n#define SC_ALLOW_ARG_MASK(_nr, _arg_nr, _arg_mask) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 8), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_LO_OFFSET), \\\n\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, ~((_arg_mask) & 0xFFFFFFFF)), \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 0, 4), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_HI_OFFSET), \\\n\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, \\\n\t    ~(((uint32_t)((uint64_t)(_arg_mask) >> 32)) & 0xFFFFFFFF)), \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t\toffsetof(struct seccomp_data, nr))\n \n#define SC_DENY_UNLESS_ARG_MASK(_nr, _arg_nr, _arg_mask, _errno) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 8), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_LO_OFFSET), \\\n\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, ~((_arg_mask) & 0xFFFFFFFF)), \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 0, 3), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[(_arg_nr)]) + ARG_HI_OFFSET), \\\n\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, \\\n\t    ~(((uint32_t)((uint64_t)(_arg_mask) >> 32)) & 0xFFFFFFFF)), \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0, 1, 0), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ERRNO|(_errno)), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t\toffsetof(struct seccomp_data, nr))\n#define SC_DENY_UNLESS_MASK(_nr, _arg_nr, _arg_val, _errno) \\\n \n#if defined(__NR_futex) || defined(__NR_futex_time64)\n#define SC_FUTEX_MASK (FUTEX_PRIVATE_FLAG|FUTEX_CLOCK_REALTIME)\n#define SC_ALLOW_FUTEX_OP(_nr, _op) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (_nr), 0, 8), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[1]) + ARG_LO_OFFSET), \\\n\t  \\\n\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, ~(SC_FUTEX_MASK & 0xFFFFFFFF)), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ((_op) & 0xFFFFFFFF), 0, 4), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t    offsetof(struct seccomp_data, args[1]) + ARG_HI_OFFSET), \\\n\t  \\\n\tBPF_STMT(BPF_ALU+BPF_AND+BPF_K, \\\n\t    ~(((uint32_t)((uint64_t)SC_FUTEX_MASK >> 32)) & 0xFFFFFFFF)), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, \\\n\t    (((uint32_t)((uint64_t)(_op) >> 32)) & 0xFFFFFFFF), 0, 1), \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW), \\\n\t  \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr))\n\n \n# define SC_FUTEX(_nr) \\\n\tSC_ALLOW_FUTEX_OP(__NR_futex, FUTEX_WAIT), \\\n\tSC_ALLOW_FUTEX_OP(__NR_futex, FUTEX_WAIT_BITSET), \\\n\tSC_ALLOW_FUTEX_OP(__NR_futex, FUTEX_WAKE), \\\n\tSC_ALLOW_FUTEX_OP(__NR_futex, FUTEX_WAKE_BITSET), \\\n\tSC_ALLOW_FUTEX_OP(__NR_futex, FUTEX_REQUEUE), \\\n\tSC_ALLOW_FUTEX_OP(__NR_futex, FUTEX_CMP_REQUEUE)\n#endif  \n\n#if defined(__NR_mmap) || defined(__NR_mmap2)\n# ifdef MAP_FIXED_NOREPLACE\n#  define SC_MMAP_FLAGS MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_FIXED_NOREPLACE\n# else\n#  define SC_MMAP_FLAGS MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED\n# endif  \n \n# define SC_MMAP(_nr) \\\n\tSC_DENY_UNLESS_ARG_MASK(_nr, 3, SC_MMAP_FLAGS, EINVAL), \\\n\tSC_ALLOW_ARG_MASK(_nr, 2, PROT_READ|PROT_WRITE|PROT_NONE)\n#endif  \n\n \nstatic const struct sock_filter preauth_insns[] = {\n\t \n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n\t\toffsetof(struct seccomp_data, arch)),\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SECCOMP_AUDIT_ARCH, 1, 0),\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n\t \n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n\t\toffsetof(struct seccomp_data, nr)),\n\n\t \n#ifdef __NR_lstat\n\tSC_DENY(__NR_lstat, EACCES),\n#endif\n#ifdef __NR_lstat64\n\tSC_DENY(__NR_lstat64, EACCES),\n#endif\n#ifdef __NR_fstat\n\tSC_DENY(__NR_fstat, EACCES),\n#endif\n#ifdef __NR_fstat64\n\tSC_DENY(__NR_fstat64, EACCES),\n#endif\n#ifdef __NR_fstatat64\n\tSC_DENY(__NR_fstatat64, EACCES),\n#endif\n#ifdef __NR_open\n\tSC_DENY(__NR_open, EACCES),\n#endif\n#ifdef __NR_openat\n\tSC_DENY(__NR_openat, EACCES),\n#endif\n#ifdef __NR_newfstatat\n\tSC_DENY(__NR_newfstatat, EACCES),\n#endif\n#ifdef __NR_stat\n\tSC_DENY(__NR_stat, EACCES),\n#endif\n#ifdef __NR_stat64\n\tSC_DENY(__NR_stat64, EACCES),\n#endif\n#ifdef __NR_shmget\n\tSC_DENY(__NR_shmget, EACCES),\n#endif\n#ifdef __NR_shmat\n\tSC_DENY(__NR_shmat, EACCES),\n#endif\n#ifdef __NR_shmdt\n\tSC_DENY(__NR_shmdt, EACCES),\n#endif\n#ifdef __NR_ipc\n\tSC_DENY(__NR_ipc, EACCES),\n#endif\n#ifdef __NR_statx\n\tSC_DENY(__NR_statx, EACCES),\n#endif\n\n\t \n#ifdef __NR_brk\n\tSC_ALLOW(__NR_brk),\n#endif\n#ifdef __NR_clock_gettime\n\tSC_ALLOW(__NR_clock_gettime),\n#endif\n#ifdef __NR_clock_gettime64\n\tSC_ALLOW(__NR_clock_gettime64),\n#endif\n#ifdef __NR_close\n\tSC_ALLOW(__NR_close),\n#endif\n#ifdef __NR_exit\n\tSC_ALLOW(__NR_exit),\n#endif\n#ifdef __NR_exit_group\n\tSC_ALLOW(__NR_exit_group),\n#endif\n#ifdef __NR_futex\n\tSC_FUTEX(__NR_futex),\n#endif\n#ifdef __NR_futex_time64\n\tSC_FUTEX(__NR_futex_time64),\n#endif\n#ifdef __NR_geteuid\n\tSC_ALLOW(__NR_geteuid),\n#endif\n#ifdef __NR_geteuid32\n\tSC_ALLOW(__NR_geteuid32),\n#endif\n#ifdef __NR_getpgid\n\tSC_ALLOW(__NR_getpgid),\n#endif\n#ifdef __NR_getpid\n\tSC_ALLOW(__NR_getpid),\n#endif\n#ifdef __NR_getrandom\n\tSC_ALLOW(__NR_getrandom),\n#endif\n#ifdef __NR_gettid\n\tSC_ALLOW(__NR_gettid),\n#endif\n#ifdef __NR_gettimeofday\n\tSC_ALLOW(__NR_gettimeofday),\n#endif\n#ifdef __NR_getuid\n\tSC_ALLOW(__NR_getuid),\n#endif\n#ifdef __NR_getuid32\n\tSC_ALLOW(__NR_getuid32),\n#endif\n#ifdef __NR_madvise\n\tSC_ALLOW_ARG(__NR_madvise, 2, MADV_NORMAL),\n# ifdef MADV_FREE\n\tSC_ALLOW_ARG(__NR_madvise, 2, MADV_FREE),\n# endif\n# ifdef MADV_DONTNEED\n\tSC_ALLOW_ARG(__NR_madvise, 2, MADV_DONTNEED),\n# endif\n# ifdef MADV_DONTFORK\n\tSC_ALLOW_ARG(__NR_madvise, 2, MADV_DONTFORK),\n# endif\n# ifdef MADV_DONTDUMP\n\tSC_ALLOW_ARG(__NR_madvise, 2, MADV_DONTDUMP),\n# endif\n# ifdef MADV_WIPEONFORK\n\tSC_ALLOW_ARG(__NR_madvise, 2, MADV_WIPEONFORK),\n# endif\n\tSC_DENY(__NR_madvise, EINVAL),\n#endif\n#ifdef __NR_mmap\n\tSC_MMAP(__NR_mmap),\n#endif\n#ifdef __NR_mmap2\n\tSC_MMAP(__NR_mmap2),\n#endif\n#ifdef __NR_mprotect\n\tSC_ALLOW_ARG_MASK(__NR_mprotect, 2, PROT_READ|PROT_WRITE|PROT_NONE),\n#endif\n#ifdef __NR_mremap\n\tSC_ALLOW(__NR_mremap),\n#endif\n#ifdef __NR_munmap\n\tSC_ALLOW(__NR_munmap),\n#endif\n#ifdef __NR_nanosleep\n\tSC_ALLOW(__NR_nanosleep),\n#endif\n#ifdef __NR_clock_nanosleep\n\tSC_ALLOW(__NR_clock_nanosleep),\n#endif\n#ifdef __NR_clock_nanosleep_time64\n\tSC_ALLOW(__NR_clock_nanosleep_time64),\n#endif\n#ifdef __NR_clock_gettime64\n\tSC_ALLOW(__NR_clock_gettime64),\n#endif\n#ifdef __NR__newselect\n\tSC_ALLOW(__NR__newselect),\n#endif\n#ifdef __NR_ppoll\n\tSC_ALLOW(__NR_ppoll),\n#endif\n#ifdef __NR_ppoll_time64\n\tSC_ALLOW(__NR_ppoll_time64),\n#endif\n#ifdef __NR_poll\n\tSC_ALLOW(__NR_poll),\n#endif\n#ifdef __NR_pselect6\n\tSC_ALLOW(__NR_pselect6),\n#endif\n#ifdef __NR_pselect6_time64\n\tSC_ALLOW(__NR_pselect6_time64),\n#endif\n#ifdef __NR_read\n\tSC_ALLOW(__NR_read),\n#endif\n#ifdef __NR_rt_sigprocmask\n\tSC_ALLOW(__NR_rt_sigprocmask),\n#endif\n#ifdef __NR_select\n\tSC_ALLOW(__NR_select),\n#endif\n#ifdef __NR_shutdown\n\tSC_ALLOW(__NR_shutdown),\n#endif\n#ifdef __NR_sigprocmask\n\tSC_ALLOW(__NR_sigprocmask),\n#endif\n#ifdef __NR_time\n\tSC_ALLOW(__NR_time),\n#endif\n#ifdef __NR_write\n\tSC_ALLOW(__NR_write),\n#endif\n#ifdef __NR_writev\n\tSC_ALLOW(__NR_writev),\n#endif\n#ifdef __NR_socketcall\n\tSC_ALLOW_ARG(__NR_socketcall, 0, SYS_SHUTDOWN),\n\tSC_DENY(__NR_socketcall, EACCES),\n#endif\n#if defined(__NR_ioctl) && defined(__s390__)\n\t \n\tSC_ALLOW_ARG(__NR_ioctl, 1, Z90STAT_STATUS_MASK),\n\tSC_ALLOW_ARG(__NR_ioctl, 1, ICARSAMODEXPO),\n\tSC_ALLOW_ARG(__NR_ioctl, 1, ICARSACRT),\n\tSC_ALLOW_ARG(__NR_ioctl, 1, ZSECSENDCPRB),\n\t \n\tSC_ALLOW_ARG(__NR_ioctl, 1, ZSENDEP11CPRB),\n#endif\n#if defined(__x86_64__) && defined(__ILP32__) && defined(__X32_SYSCALL_BIT)\n\t \n\tSC_ALLOW(__NR_clock_gettime & ~__X32_SYSCALL_BIT),\n#endif\n\n\t \n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_FILTER_FAIL),\n};\n\nstatic const struct sock_fprog preauth_program = {\n\t.len = (unsigned short)(sizeof(preauth_insns)/sizeof(preauth_insns[0])),\n\t.filter = (struct sock_filter *)preauth_insns,\n};\n\nstruct ssh_sandbox {\n\tpid_t child_pid;\n};\n\nstruct ssh_sandbox *\nssh_sandbox_init(struct monitor *monitor)\n{\n\tstruct ssh_sandbox *box;\n\n\t \n\tdebug3(\"%s: preparing seccomp filter sandbox\", __func__);\n\tbox = xcalloc(1, sizeof(*box));\n\tbox->child_pid = 0;\n\n\treturn box;\n}\n\n#ifdef SANDBOX_SECCOMP_FILTER_DEBUG\nextern struct monitor *pmonitor;\nvoid mm_log_handler(LogLevel level, int forced, const char *msg, void *ctx);\n\nstatic void\nssh_sandbox_violation(int signum, siginfo_t *info, void *void_context)\n{\n\tchar msg[256];\n\n\tsnprintf(msg, sizeof(msg),\n\t    \"%s: unexpected system call (arch:0x%x,syscall:%d @ %p)\",\n\t    __func__, info->si_arch, info->si_syscall, info->si_call_addr);\n\tmm_log_handler(SYSLOG_LEVEL_FATAL, 0, msg, pmonitor);\n\t_exit(1);\n}\n\nstatic void\nssh_sandbox_child_debugging(void)\n{\n\tstruct sigaction act;\n\tsigset_t mask;\n\n\tdebug3(\"%s: installing SIGSYS handler\", __func__);\n\tmemset(&act, 0, sizeof(act));\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGSYS);\n\n\tact.sa_sigaction = &ssh_sandbox_violation;\n\tact.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSYS, &act, NULL) == -1)\n\t\tfatal(\"%s: sigaction(SIGSYS): %s\", __func__, strerror(errno));\n\tif (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n\t\tfatal(\"%s: sigprocmask(SIGSYS): %s\",\n\t\t    __func__, strerror(errno));\n}\n#endif  \n\nvoid\nssh_sandbox_child(struct ssh_sandbox *box)\n{\n\tstruct rlimit rl_zero, rl_one = {.rlim_cur = 1, .rlim_max = 1};\n\tint nnp_failed = 0;\n\n\t \n\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\tif (setrlimit(RLIMIT_FSIZE, &rl_zero) == -1)\n\t\tfatal(\"%s: setrlimit(RLIMIT_FSIZE, { 0, 0 }): %s\",\n\t\t\t__func__, strerror(errno));\n\t \n\tif (setrlimit(RLIMIT_NOFILE, &rl_one) == -1)\n\t\tfatal(\"%s: setrlimit(RLIMIT_NOFILE, { 0, 0 }): %s\",\n\t\t\t__func__, strerror(errno));\n\tif (setrlimit(RLIMIT_NPROC, &rl_zero) == -1)\n\t\tfatal(\"%s: setrlimit(RLIMIT_NPROC, { 0, 0 }): %s\",\n\t\t\t__func__, strerror(errno));\n\n#ifdef SANDBOX_SECCOMP_FILTER_DEBUG\n\tssh_sandbox_child_debugging();\n#endif  \n\n\tdebug3(\"%s: setting PR_SET_NO_NEW_PRIVS\", __func__);\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1) {\n\t\tdebug(\"%s: prctl(PR_SET_NO_NEW_PRIVS): %s\",\n\t\t    __func__, strerror(errno));\n\t\tnnp_failed = 1;\n\t}\n\tdebug3(\"%s: attaching seccomp filter program\", __func__);\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &preauth_program) == -1)\n\t\tdebug(\"%s: prctl(PR_SET_SECCOMP): %s\",\n\t\t    __func__, strerror(errno));\n\telse if (nnp_failed)\n\t\tfatal(\"%s: SECCOMP_MODE_FILTER activated but \"\n\t\t    \"PR_SET_NO_NEW_PRIVS failed\", __func__);\n}\n\nvoid\nssh_sandbox_parent_finish(struct ssh_sandbox *box)\n{\n\tfree(box);\n\tdebug3(\"%s: finished\", __func__);\n}\n\nvoid\nssh_sandbox_parent_preauth(struct ssh_sandbox *box, pid_t child_pid)\n{\n\tbox->child_pid = child_pid;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}