{
  "module_name": "ssh-ecdsa-sk.c",
  "hash_id": "04a17f8aab7b2a0e00bb07d11b92bcf69274fa00706a71012eed1d0c6f6c6fb4",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-ecdsa-sk.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/bn.h>\n#include <openssl/ec.h>\n#include <openssl/ecdsa.h>\n#include <openssl/evp.h>\n#endif\n\n#include <string.h>\n#include <stdio.h>  \n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#define SSHKEY_INTERNAL\n#include \"sshkey.h\"\n\n#ifndef OPENSSL_HAS_ECC\n \nint\nssh_ecdsa_sk_verify(const struct sshkey *key,\n    const u_char *signature, size_t signaturelen,\n    const u_char *data, size_t datalen, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\treturn SSH_ERR_FEATURE_UNSUPPORTED;\n}\n#else  \n\n \nextern struct sshkey_impl_funcs sshkey_ecdsa_funcs;\n\nstatic void\nssh_ecdsa_sk_cleanup(struct sshkey *k)\n{\n\tsshkey_sk_cleanup(k);\n\tsshkey_ecdsa_funcs.cleanup(k);\n}\n\nstatic int\nssh_ecdsa_sk_equal(const struct sshkey *a, const struct sshkey *b)\n{\n\tif (!sshkey_sk_fields_equal(a, b))\n\t\treturn 0;\n\tif (!sshkey_ecdsa_funcs.equal(a, b))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nssh_ecdsa_sk_serialize_public(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\n\tif ((r = sshkey_ecdsa_funcs.serialize_public(key, b, opts)) != 0)\n\t\treturn r;\n\tif ((r = sshkey_serialize_sk(key, b)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_sk_serialize_private(const struct sshkey *key, struct sshbuf *b,\n    enum sshkey_serialize_rep opts)\n{\n\tint r;\n\n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = sshkey_ecdsa_funcs.serialize_public(key,\n\t\t    b, opts)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshkey_serialize_private_sk(key, b)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_sk_copy_public(const struct sshkey *from, struct sshkey *to)\n{\n\tint r;\n\n\tif ((r = sshkey_ecdsa_funcs.copy_public(from, to)) != 0)\n\t\treturn r;\n\tif ((r = sshkey_copy_public_sk(from, to)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_sk_deserialize_public(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\n\tif ((r = sshkey_ecdsa_funcs.deserialize_public(ktype, b, key)) != 0)\n\t\treturn r;\n\tif ((r = sshkey_deserialize_sk(b, key)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nstatic int\nssh_ecdsa_sk_deserialize_private(const char *ktype, struct sshbuf *b,\n    struct sshkey *key)\n{\n\tint r;\n\n\tif (!sshkey_is_cert(key)) {\n\t\tif ((r = sshkey_ecdsa_funcs.deserialize_public(ktype,\n\t\t    b, key)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshkey_private_deserialize_sk(b, key)) != 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstatic int\nwebauthn_check_prepare_hash(const u_char *data, size_t datalen,\n    const char *origin, const struct sshbuf *wrapper,\n    uint8_t flags, const struct sshbuf *extensions,\n    u_char *msghash, size_t msghashlen)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *chall = NULL, *m = NULL;\n\n\tif ((m = sshbuf_new()) == NULL ||\n\t    (chall = sshbuf_from(data, datalen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t \n\tif (strchr(origin, '\\\"') != NULL ||\n\t    (flags & 0x40) != 0   ||\n\t    ((flags & 0x80) == 0  ) != (sshbuf_len(extensions) == 0)) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\n\t \n#define WEBAUTHN_0\t\"{\\\"type\\\":\\\"webauthn.get\\\",\\\"challenge\\\":\\\"\"\n#define WEBAUTHN_1\t\"\\\",\\\"origin\\\":\\\"\"\n#define WEBAUTHN_2\t\"\\\"\"\n\tif ((r = sshbuf_put(m, WEBAUTHN_0, sizeof(WEBAUTHN_0) - 1)) != 0 ||\n\t    (r = sshbuf_dtourlb64(chall, m, 0)) != 0 ||\n\t    (r = sshbuf_put(m, WEBAUTHN_1, sizeof(WEBAUTHN_1) - 1)) != 0 ||\n\t    (r = sshbuf_put(m, origin, strlen(origin))) != 0 ||\n\t    (r = sshbuf_put(m, WEBAUTHN_2, sizeof(WEBAUTHN_2) - 1)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: received origin: %s\\n\", __func__, origin);\n\tfprintf(stderr, \"%s: received clientData:\\n\", __func__);\n\tsshbuf_dump(wrapper, stderr);\n\tfprintf(stderr, \"%s: expected clientData premable:\\n\", __func__);\n\tsshbuf_dump(m, stderr);\n#endif\n\t \n\tif ((r = sshbuf_cmp(wrapper, 0, sshbuf_ptr(m), sshbuf_len(m))) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = ssh_digest_buffer(SSH_DIGEST_SHA256, wrapper,\n\t    msghash, msghashlen)) != 0)\n\t\tgoto out;\n\n\t \n\tr = 0;\n out:\n\tsshbuf_free(chall);\n\tsshbuf_free(m);\n\treturn r;\n}\n\nstatic int\nssh_ecdsa_sk_verify(const struct sshkey *key,\n    const u_char *sig, size_t siglen,\n    const u_char *data, size_t dlen, const char *alg, u_int compat,\n    struct sshkey_sig_details **detailsp)\n{\n\tECDSA_SIG *esig = NULL;\n\tBIGNUM *sig_r = NULL, *sig_s = NULL;\n\tu_char sig_flags;\n\tu_char msghash[32], apphash[32], sighash[32];\n\tu_int sig_counter;\n\tint is_webauthn = 0, ret = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *b = NULL, *sigbuf = NULL, *original_signed = NULL;\n\tstruct sshbuf *webauthn_wrapper = NULL, *webauthn_exts = NULL;\n\tchar *ktype = NULL, *webauthn_origin = NULL;\n\tstruct sshkey_sig_details *details = NULL;\n#ifdef DEBUG_SK\n\tchar *tmp = NULL;\n#endif\n\n\tif (detailsp != NULL)\n\t\t*detailsp = NULL;\n\tif (key == NULL || key->ecdsa == NULL ||\n\t    sshkey_type_plain(key->type) != KEY_ECDSA_SK ||\n\t    sig == NULL || siglen == 0)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tif (key->ecdsa_nid != NID_X9_62_prime256v1)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t \n\tif ((b = sshbuf_from(sig, siglen)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((details = calloc(1, sizeof(*details))) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (sshbuf_get_cstring(b, &ktype, NULL) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (strcmp(ktype, \"webauthn-sk-ecdsa-sha2-nistp256@openssh.com\") == 0)\n\t\tis_webauthn = 1;\n\telse if (strcmp(ktype, \"sk-ecdsa-sha2-nistp256@openssh.com\") != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_froms(b, &sigbuf) != 0 ||\n\t    sshbuf_get_u8(b, &sig_flags) != 0 ||\n\t    sshbuf_get_u32(b, &sig_counter) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (is_webauthn) {\n\t\tif (sshbuf_get_cstring(b, &webauthn_origin, NULL) != 0 ||\n\t\t    sshbuf_froms(b, &webauthn_wrapper) != 0 ||\n\t\t    sshbuf_froms(b, &webauthn_exts) != 0) {\n\t\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sshbuf_get_bignum2(sigbuf, &sig_r) != 0 ||\n\t    sshbuf_get_bignum2(sigbuf, &sig_s) != 0) {\n\t\tret = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(sigbuf) != 0) {\n\t\tret = SSH_ERR_UNEXPECTED_TRAILING_DATA;\n\t\tgoto out;\n\t}\n\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: data: (len %zu)\\n\", __func__, datalen);\n\t \n\tfprintf(stderr, \"%s: sig_r: %s\\n\", __func__, (tmp = BN_bn2hex(sig_r)));\n\tfree(tmp);\n\tfprintf(stderr, \"%s: sig_s: %s\\n\", __func__, (tmp = BN_bn2hex(sig_s)));\n\tfree(tmp);\n\tfprintf(stderr, \"%s: sig_flags = 0x%02x, sig_counter = %u\\n\",\n\t    __func__, sig_flags, sig_counter);\n\tif (is_webauthn) {\n\t\tfprintf(stderr, \"%s: webauthn origin: %s\\n\", __func__,\n\t\t    webauthn_origin);\n\t\tfprintf(stderr, \"%s: webauthn_wrapper:\\n\", __func__);\n\t\tsshbuf_dump(webauthn_wrapper, stderr);\n\t}\n#endif\n\tif ((esig = ECDSA_SIG_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (!ECDSA_SIG_set0(esig, sig_r, sig_s)) {\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tsig_r = sig_s = NULL;  \n\n\t \n\tif ((original_signed = sshbuf_new()) == NULL) {\n\t\tret = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (is_webauthn) {\n\t\tif ((ret = webauthn_check_prepare_hash(data, dlen,\n\t\t    webauthn_origin, webauthn_wrapper, sig_flags, webauthn_exts,\n\t\t    msghash, sizeof(msghash))) != 0)\n\t\t\tgoto out;\n\t} else if ((ret = ssh_digest_memory(SSH_DIGEST_SHA256, data, dlen,\n\t    msghash, sizeof(msghash))) != 0)\n\t\tgoto out;\n\t \n\tif ((ret = ssh_digest_memory(SSH_DIGEST_SHA256, key->sk_application,\n\t    strlen(key->sk_application), apphash, sizeof(apphash))) != 0)\n\t\tgoto out;\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: hashed application:\\n\", __func__);\n\tsshbuf_dump_data(apphash, sizeof(apphash), stderr);\n\tfprintf(stderr, \"%s: hashed message:\\n\", __func__);\n\tsshbuf_dump_data(msghash, sizeof(msghash), stderr);\n#endif\n\tif ((ret = sshbuf_put(original_signed,\n\t    apphash, sizeof(apphash))) != 0 ||\n\t    (ret = sshbuf_put_u8(original_signed, sig_flags)) != 0 ||\n\t    (ret = sshbuf_put_u32(original_signed, sig_counter)) != 0 ||\n\t    (ret = sshbuf_putb(original_signed, webauthn_exts)) != 0 ||\n\t    (ret = sshbuf_put(original_signed, msghash, sizeof(msghash))) != 0)\n\t\tgoto out;\n\t \n\tif ((ret = ssh_digest_buffer(SSH_DIGEST_SHA256, original_signed,\n\t    sighash, sizeof(sighash))) != 0)\n\t\tgoto out;\n\tdetails->sk_counter = sig_counter;\n\tdetails->sk_flags = sig_flags;\n#ifdef DEBUG_SK\n\tfprintf(stderr, \"%s: signed buf:\\n\", __func__);\n\tsshbuf_dump(original_signed, stderr);\n\tfprintf(stderr, \"%s: signed hash:\\n\", __func__);\n\tsshbuf_dump_data(sighash, sizeof(sighash), stderr);\n#endif\n\n\t \n\tswitch (ECDSA_do_verify(sighash, sizeof(sighash), esig, key->ecdsa)) {\n\tcase 1:\n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\tgoto out;\n\tdefault:\n\t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\t \n\tif (detailsp != NULL) {\n\t\t*detailsp = details;\n\t\tdetails = NULL;\n\t}\n out:\n\texplicit_bzero(&sig_flags, sizeof(sig_flags));\n\texplicit_bzero(&sig_counter, sizeof(sig_counter));\n\texplicit_bzero(msghash, sizeof(msghash));\n\texplicit_bzero(sighash, sizeof(msghash));\n\texplicit_bzero(apphash, sizeof(apphash));\n\tsshkey_sig_details_free(details);\n\tsshbuf_free(webauthn_wrapper);\n\tsshbuf_free(webauthn_exts);\n\tfree(webauthn_origin);\n\tsshbuf_free(original_signed);\n\tsshbuf_free(sigbuf);\n\tsshbuf_free(b);\n\tECDSA_SIG_free(esig);\n\tBN_clear_free(sig_r);\n\tBN_clear_free(sig_s);\n\tfree(ktype);\n\treturn ret;\n}\n\nstatic const struct sshkey_impl_funcs sshkey_ecdsa_sk_funcs = {\n\t \t\tNULL,\n\t \t\tNULL,\n\t \tssh_ecdsa_sk_cleanup,\n\t \t\tssh_ecdsa_sk_equal,\n\t  ssh_ecdsa_sk_serialize_public,\n\t  ssh_ecdsa_sk_deserialize_public,\n\t  ssh_ecdsa_sk_serialize_private,\n\t  ssh_ecdsa_sk_deserialize_private,\n\t \tNULL,\n\t \tssh_ecdsa_sk_copy_public,\n\t \t\tNULL,\n\t \t\tssh_ecdsa_sk_verify,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_sk_impl = {\n\t \t\t\"sk-ecdsa-sha2-nistp256@openssh.com\",\n\t \t\"ECDSA-SK\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA_SK,\n\t \t\tNID_X9_62_prime256v1,\n\t \t\t0,\n\t \t0,\n\t \t256,\n\t \t\t&sshkey_ecdsa_sk_funcs,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_sk_cert_impl = {\n\t \t\t\"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com\",\n\t \t\"ECDSA-SK-CERT\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA_SK_CERT,\n\t \t\tNID_X9_62_prime256v1,\n\t \t\t1,\n\t \t0,\n\t \t256,\n\t \t\t&sshkey_ecdsa_sk_funcs,\n};\n\nconst struct sshkey_impl sshkey_ecdsa_sk_webauthn_impl = {\n\t \t\t\"webauthn-sk-ecdsa-sha2-nistp256@openssh.com\",\n\t \t\"ECDSA-SK\",\n\t \t\tNULL,\n\t \t\tKEY_ECDSA_SK,\n\t \t\tNID_X9_62_prime256v1,\n\t \t\t0,\n\t \t1,\n\t \t256,\n\t \t\t&sshkey_ecdsa_sk_funcs,\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}