{
  "module_name": "readconf.c",
  "hash_id": "e2735844ae3358d26a0791932606d2a11b7efaa981b4fb8eb8cbff7dbff5d5b5",
  "original_prompt": "Ingested from openssh-9.6p1/readconf.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netinet/in_systm.h>\n#include <netinet/ip.h>\n#include <arpa/inet.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_IFADDRS_H\n# include <ifaddrs.h>\n#endif\n#include <limits.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#ifdef USE_SYSTEM_GLOB\n# include <glob.h>\n#else\n# include \"openbsd-compat/glob.h\"\n#endif\n#ifdef HAVE_UTIL_H\n#include <util.h>\n#endif\n#if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)\n# include <vis.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssherr.h\"\n#include \"cipher.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"readconf.h\"\n#include \"match.h\"\n#include \"kex.h\"\n#include \"mac.h\"\n#include \"uidswap.h\"\n#include \"myproposal.h\"\n#include \"digest.h\"\n\n \n\nstatic int read_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int *want_final_pass, int depth);\nstatic int process_config_line_depth(Options *options, struct passwd *pw,\n    const char *host, const char *original_host, char *line,\n    const char *filename, int linenum, int *activep, int flags,\n    int *want_final_pass, int depth);\n\n \n\ntypedef enum {\n\toBadOption,\n\toHost, oMatch, oInclude, oTag,\n\toForwardAgent, oForwardX11, oForwardX11Trusted, oForwardX11Timeout,\n\toGatewayPorts, oExitOnForwardFailure,\n\toPasswordAuthentication,\n\toXAuthLocation,\n\toIdentityFile, oHostname, oPort, oRemoteForward, oLocalForward,\n\toPermitRemoteOpen,\n\toCertificateFile, oAddKeysToAgent, oIdentityAgent,\n\toUser, oEscapeChar, oProxyCommand,\n\toGlobalKnownHostsFile, oUserKnownHostsFile, oConnectionAttempts,\n\toBatchMode, oCheckHostIP, oStrictHostKeyChecking, oCompression,\n\toTCPKeepAlive, oNumberOfPasswordPrompts,\n\toLogFacility, oLogLevel, oLogVerbose, oCiphers, oMacs,\n\toPubkeyAuthentication,\n\toKbdInteractiveAuthentication, oKbdInteractiveDevices, oHostKeyAlias,\n\toDynamicForward, oPreferredAuthentications, oHostbasedAuthentication,\n\toHostKeyAlgorithms, oBindAddress, oBindInterface, oPKCS11Provider,\n\toClearAllForwardings, oNoHostAuthenticationForLocalhost,\n\toEnableSSHKeysign, oRekeyLimit, oVerifyHostKeyDNS, oConnectTimeout,\n\toAddressFamily, oGssAuthentication, oGssDelegateCreds,\n\toServerAliveInterval, oServerAliveCountMax, oIdentitiesOnly,\n\toSendEnv, oSetEnv, oControlPath, oControlMaster, oControlPersist,\n\toHashKnownHosts,\n\toTunnel, oTunnelDevice,\n\toLocalCommand, oPermitLocalCommand, oRemoteCommand,\n\toVisualHostKey,\n\toKexAlgorithms, oIPQoS, oRequestTTY, oSessionType, oStdinNull,\n\toForkAfterAuthentication, oIgnoreUnknown, oProxyUseFdpass,\n\toCanonicalDomains, oCanonicalizeHostname, oCanonicalizeMaxDots,\n\toCanonicalizeFallbackLocal, oCanonicalizePermittedCNAMEs,\n\toStreamLocalBindMask, oStreamLocalBindUnlink, oRevokedHostKeys,\n\toFingerprintHash, oUpdateHostkeys, oHostbasedAcceptedAlgorithms,\n\toPubkeyAcceptedAlgorithms, oCASignatureAlgorithms, oProxyJump,\n\toSecurityKeyProvider, oKnownHostsCommand, oRequiredRSASize,\n\toEnableEscapeCommandline, oObscureKeystrokeTiming, oChannelTimeout,\n\toIgnore, oIgnoredUnknownOption, oDeprecated, oUnsupported\n} OpCodes;\n\n \n\nstatic struct {\n\tconst char *name;\n\tOpCodes opcode;\n} keywords[] = {\n\t \n\t{ \"protocol\", oIgnore },  \n\t{ \"cipher\", oDeprecated },\n\t{ \"fallbacktorsh\", oDeprecated },\n\t{ \"globalknownhostsfile2\", oDeprecated },\n\t{ \"rhostsauthentication\", oDeprecated },\n\t{ \"userknownhostsfile2\", oDeprecated },\n\t{ \"useroaming\", oDeprecated },\n\t{ \"usersh\", oDeprecated },\n\t{ \"useprivilegedport\", oDeprecated },\n\n\t \n\t{ \"afstokenpassing\", oUnsupported },\n\t{ \"kerberosauthentication\", oUnsupported },\n\t{ \"kerberostgtpassing\", oUnsupported },\n\t{ \"rsaauthentication\", oUnsupported },\n\t{ \"rhostsrsaauthentication\", oUnsupported },\n\t{ \"compressionlevel\", oUnsupported },\n\n\t \n#if defined(GSSAPI)\n\t{ \"gssapiauthentication\", oGssAuthentication },\n\t{ \"gssapidelegatecredentials\", oGssDelegateCreds },\n# else\n\t{ \"gssapiauthentication\", oUnsupported },\n\t{ \"gssapidelegatecredentials\", oUnsupported },\n#endif\n#ifdef ENABLE_PKCS11\n\t{ \"pkcs11provider\", oPKCS11Provider },\n\t{ \"smartcarddevice\", oPKCS11Provider },\n# else\n\t{ \"smartcarddevice\", oUnsupported },\n\t{ \"pkcs11provider\", oUnsupported },\n#endif\n\n\t{ \"forwardagent\", oForwardAgent },\n\t{ \"forwardx11\", oForwardX11 },\n\t{ \"forwardx11trusted\", oForwardX11Trusted },\n\t{ \"forwardx11timeout\", oForwardX11Timeout },\n\t{ \"exitonforwardfailure\", oExitOnForwardFailure },\n\t{ \"xauthlocation\", oXAuthLocation },\n\t{ \"gatewayports\", oGatewayPorts },\n\t{ \"passwordauthentication\", oPasswordAuthentication },\n\t{ \"kbdinteractiveauthentication\", oKbdInteractiveAuthentication },\n\t{ \"kbdinteractivedevices\", oKbdInteractiveDevices },\n\t{ \"challengeresponseauthentication\", oKbdInteractiveAuthentication },  \n\t{ \"skeyauthentication\", oKbdInteractiveAuthentication },  \n\t{ \"tisauthentication\", oKbdInteractiveAuthentication },   \n\t{ \"pubkeyauthentication\", oPubkeyAuthentication },\n\t{ \"dsaauthentication\", oPubkeyAuthentication },\t\t     \n\t{ \"hostbasedauthentication\", oHostbasedAuthentication },\n\t{ \"identityfile\", oIdentityFile },\n\t{ \"identityfile2\", oIdentityFile },\t\t\t \n\t{ \"identitiesonly\", oIdentitiesOnly },\n\t{ \"certificatefile\", oCertificateFile },\n\t{ \"addkeystoagent\", oAddKeysToAgent },\n\t{ \"identityagent\", oIdentityAgent },\n\t{ \"hostname\", oHostname },\n\t{ \"hostkeyalias\", oHostKeyAlias },\n\t{ \"proxycommand\", oProxyCommand },\n\t{ \"port\", oPort },\n\t{ \"ciphers\", oCiphers },\n\t{ \"macs\", oMacs },\n\t{ \"remoteforward\", oRemoteForward },\n\t{ \"localforward\", oLocalForward },\n\t{ \"permitremoteopen\", oPermitRemoteOpen },\n\t{ \"user\", oUser },\n\t{ \"host\", oHost },\n\t{ \"match\", oMatch },\n\t{ \"tag\", oTag },\n\t{ \"escapechar\", oEscapeChar },\n\t{ \"globalknownhostsfile\", oGlobalKnownHostsFile },\n\t{ \"userknownhostsfile\", oUserKnownHostsFile },\n\t{ \"connectionattempts\", oConnectionAttempts },\n\t{ \"batchmode\", oBatchMode },\n\t{ \"checkhostip\", oCheckHostIP },\n\t{ \"stricthostkeychecking\", oStrictHostKeyChecking },\n\t{ \"compression\", oCompression },\n\t{ \"tcpkeepalive\", oTCPKeepAlive },\n\t{ \"keepalive\", oTCPKeepAlive },\t\t\t\t \n\t{ \"numberofpasswordprompts\", oNumberOfPasswordPrompts },\n\t{ \"syslogfacility\", oLogFacility },\n\t{ \"loglevel\", oLogLevel },\n\t{ \"logverbose\", oLogVerbose },\n\t{ \"dynamicforward\", oDynamicForward },\n\t{ \"preferredauthentications\", oPreferredAuthentications },\n\t{ \"hostkeyalgorithms\", oHostKeyAlgorithms },\n\t{ \"casignaturealgorithms\", oCASignatureAlgorithms },\n\t{ \"bindaddress\", oBindAddress },\n\t{ \"bindinterface\", oBindInterface },\n\t{ \"clearallforwardings\", oClearAllForwardings },\n\t{ \"enablesshkeysign\", oEnableSSHKeysign },\n\t{ \"verifyhostkeydns\", oVerifyHostKeyDNS },\n\t{ \"nohostauthenticationforlocalhost\", oNoHostAuthenticationForLocalhost },\n\t{ \"rekeylimit\", oRekeyLimit },\n\t{ \"connecttimeout\", oConnectTimeout },\n\t{ \"addressfamily\", oAddressFamily },\n\t{ \"serveraliveinterval\", oServerAliveInterval },\n\t{ \"serveralivecountmax\", oServerAliveCountMax },\n\t{ \"sendenv\", oSendEnv },\n\t{ \"setenv\", oSetEnv },\n\t{ \"controlpath\", oControlPath },\n\t{ \"controlmaster\", oControlMaster },\n\t{ \"controlpersist\", oControlPersist },\n\t{ \"hashknownhosts\", oHashKnownHosts },\n\t{ \"include\", oInclude },\n\t{ \"tunnel\", oTunnel },\n\t{ \"tunneldevice\", oTunnelDevice },\n\t{ \"localcommand\", oLocalCommand },\n\t{ \"permitlocalcommand\", oPermitLocalCommand },\n\t{ \"remotecommand\", oRemoteCommand },\n\t{ \"visualhostkey\", oVisualHostKey },\n\t{ \"kexalgorithms\", oKexAlgorithms },\n\t{ \"ipqos\", oIPQoS },\n\t{ \"requesttty\", oRequestTTY },\n\t{ \"sessiontype\", oSessionType },\n\t{ \"stdinnull\", oStdinNull },\n\t{ \"forkafterauthentication\", oForkAfterAuthentication },\n\t{ \"proxyusefdpass\", oProxyUseFdpass },\n\t{ \"canonicaldomains\", oCanonicalDomains },\n\t{ \"canonicalizefallbacklocal\", oCanonicalizeFallbackLocal },\n\t{ \"canonicalizehostname\", oCanonicalizeHostname },\n\t{ \"canonicalizemaxdots\", oCanonicalizeMaxDots },\n\t{ \"canonicalizepermittedcnames\", oCanonicalizePermittedCNAMEs },\n\t{ \"streamlocalbindmask\", oStreamLocalBindMask },\n\t{ \"streamlocalbindunlink\", oStreamLocalBindUnlink },\n\t{ \"revokedhostkeys\", oRevokedHostKeys },\n\t{ \"fingerprinthash\", oFingerprintHash },\n\t{ \"updatehostkeys\", oUpdateHostkeys },\n\t{ \"hostbasedacceptedalgorithms\", oHostbasedAcceptedAlgorithms },\n\t{ \"hostbasedkeytypes\", oHostbasedAcceptedAlgorithms },  \n\t{ \"pubkeyacceptedalgorithms\", oPubkeyAcceptedAlgorithms },\n\t{ \"pubkeyacceptedkeytypes\", oPubkeyAcceptedAlgorithms },  \n\t{ \"ignoreunknown\", oIgnoreUnknown },\n\t{ \"proxyjump\", oProxyJump },\n\t{ \"securitykeyprovider\", oSecurityKeyProvider },\n\t{ \"knownhostscommand\", oKnownHostsCommand },\n\t{ \"requiredrsasize\", oRequiredRSASize },\n\t{ \"enableescapecommandline\", oEnableEscapeCommandline },\n\t{ \"obscurekeystroketiming\", oObscureKeystrokeTiming },\n\t{ \"channeltimeout\", oChannelTimeout },\n\n\t{ NULL, oBadOption }\n};\n\nstatic const char *lookup_opcode_name(OpCodes code);\n\nconst char *\nkex_default_pk_alg(void)\n{\n\tstatic char *pkalgs;\n\n\tif (pkalgs == NULL) {\n\t\tchar *all_key;\n\n\t\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\t\tpkalgs = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\t\tfree(all_key);\n\t}\n\treturn pkalgs;\n}\n\nchar *\nssh_connection_hash(const char *thishost, const char *host, const char *portstr,\n    const char *user, const char *jumphost)\n{\n\tstruct ssh_digest_ctx *md;\n\tu_char conn_hash[SSH_DIGEST_MAX_LENGTH];\n\n\tif ((md = ssh_digest_start(SSH_DIGEST_SHA1)) == NULL ||\n\t    ssh_digest_update(md, thishost, strlen(thishost)) < 0 ||\n\t    ssh_digest_update(md, host, strlen(host)) < 0 ||\n\t    ssh_digest_update(md, portstr, strlen(portstr)) < 0 ||\n\t    ssh_digest_update(md, user, strlen(user)) < 0 ||\n\t    ssh_digest_update(md, jumphost, strlen(jumphost)) < 0 ||\n\t    ssh_digest_final(md, conn_hash, sizeof(conn_hash)) < 0)\n\t\tfatal_f(\"mux digest failed\");\n\tssh_digest_free(md);\n\treturn tohex(conn_hash, ssh_digest_bytes(SSH_DIGEST_SHA1));\n}\n\n \n\nvoid\nadd_local_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t \n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->local_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->local_forwards = xreallocarray(options->local_forwards,\n\t    options->num_local_forwards + 1,\n\t    sizeof(*options->local_forwards));\n\tfwd = &options->local_forwards[options->num_local_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n}\n\n \n\nvoid\nadd_remote_forward(Options *options, const struct Forward *newfwd)\n{\n\tstruct Forward *fwd;\n\tint i;\n\n\t \n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tif (forward_equals(newfwd, options->remote_forwards + i))\n\t\t\treturn;\n\t}\n\toptions->remote_forwards = xreallocarray(options->remote_forwards,\n\t    options->num_remote_forwards + 1,\n\t    sizeof(*options->remote_forwards));\n\tfwd = &options->remote_forwards[options->num_remote_forwards++];\n\n\tfwd->listen_host = newfwd->listen_host;\n\tfwd->listen_port = newfwd->listen_port;\n\tfwd->listen_path = newfwd->listen_path;\n\tfwd->connect_host = newfwd->connect_host;\n\tfwd->connect_port = newfwd->connect_port;\n\tfwd->connect_path = newfwd->connect_path;\n\tfwd->handle = newfwd->handle;\n\tfwd->allocated_port = 0;\n}\n\nstatic void\nclear_forwardings(Options *options)\n{\n\tint i;\n\n\tfor (i = 0; i < options->num_local_forwards; i++) {\n\t\tfree(options->local_forwards[i].listen_host);\n\t\tfree(options->local_forwards[i].listen_path);\n\t\tfree(options->local_forwards[i].connect_host);\n\t\tfree(options->local_forwards[i].connect_path);\n\t}\n\tif (options->num_local_forwards > 0) {\n\t\tfree(options->local_forwards);\n\t\toptions->local_forwards = NULL;\n\t}\n\toptions->num_local_forwards = 0;\n\tfor (i = 0; i < options->num_remote_forwards; i++) {\n\t\tfree(options->remote_forwards[i].listen_host);\n\t\tfree(options->remote_forwards[i].listen_path);\n\t\tfree(options->remote_forwards[i].connect_host);\n\t\tfree(options->remote_forwards[i].connect_path);\n\t}\n\tif (options->num_remote_forwards > 0) {\n\t\tfree(options->remote_forwards);\n\t\toptions->remote_forwards = NULL;\n\t}\n\toptions->num_remote_forwards = 0;\n\toptions->tun_open = SSH_TUNMODE_NO;\n}\n\nvoid\nadd_certificate_file(Options *options, const char *path, int userprovided)\n{\n\tint i;\n\n\tif (options->num_certificate_files >= SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal(\"Too many certificate files specified (max %d)\",\n\t\t    SSH_MAX_CERTIFICATE_FILES);\n\n\t \n\tfor (i = 0; i < options->num_certificate_files; i++) {\n\t\tif (options->certificate_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->certificate_files[i], path) == 0) {\n\t\t\tdebug2_f(\"ignoring duplicate key %s\", path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->certificate_file_userprovided[options->num_certificate_files] =\n\t    userprovided;\n\toptions->certificate_files[options->num_certificate_files++] =\n\t    xstrdup(path);\n}\n\nvoid\nadd_identity_file(Options *options, const char *dir, const char *filename,\n    int userprovided)\n{\n\tchar *path;\n\tint i;\n\n\tif (options->num_identity_files >= SSH_MAX_IDENTITY_FILES)\n\t\tfatal(\"Too many identity files specified (max %d)\",\n\t\t    SSH_MAX_IDENTITY_FILES);\n\n\tif (dir == NULL)  \n\t\tpath = xstrdup(filename);\n\telse if (xasprintf(&path, \"%s%s\", dir, filename) >= PATH_MAX)\n\t\tfatal(\"Identity file path %s too long\", path);\n\n\t \n\tfor (i = 0; i < options->num_identity_files; i++) {\n\t\tif (options->identity_file_userprovided[i] == userprovided &&\n\t\t    strcmp(options->identity_files[i], path) == 0) {\n\t\t\tdebug2_f(\"ignoring duplicate key %s\", path);\n\t\t\tfree(path);\n\t\t\treturn;\n\t\t}\n\t}\n\n\toptions->identity_file_userprovided[options->num_identity_files] =\n\t    userprovided;\n\toptions->identity_files[options->num_identity_files++] = path;\n}\n\nint\ndefault_ssh_port(void)\n{\n\tstatic int port;\n\tstruct servent *sp;\n\n\tif (port == 0) {\n\t\tsp = getservbyname(SSH_SERVICE_NAME, \"tcp\");\n\t\tport = sp ? ntohs(sp->s_port) : SSH_DEFAULT_PORT;\n\t}\n\treturn port;\n}\n\n \nstatic int\nexecute_in_shell(const char *cmd)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\tif (access(shell, X_OK) == -1) {\n\t\tfatal(\"Shell \\\"%s\\\" is not executable: %s\",\n\t\t    shell, strerror(errno));\n\t}\n\n\tdebug(\"Executing command: '%.500s'\", cmd);\n\n\t \n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[4];\n\n\t\tif (stdfd_devnull(1, 1, 0) == -1)\n\t\t\tfatal_f(\"stdfd_devnull failed\");\n\t\tclosefrom(STDERR_FILENO + 1);\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = xstrdup(cmd);\n\t\targv[3] = NULL;\n\n\t\texecv(argv[0], argv);\n\t\terror(\"Unable to execute '%.100s': %s\", cmd, strerror(errno));\n\t\t \n\t\tssh_signal(SIGTERM, SIG_DFL);\n\t\tkill(getpid(), SIGTERM);\n\t\t_exit(1);\n\t}\n\t \n\tif (pid == -1)\n\t\tfatal_f(\"fork: %.100s\", strerror(errno));\n\n\twhile (waitpid(pid, &status, 0) == -1) {\n\t\tif (errno != EINTR && errno != EAGAIN)\n\t\t\tfatal_f(\"waitpid: %s\", strerror(errno));\n\t}\n\tif (!WIFEXITED(status)) {\n\t\terror(\"command '%.100s' exited abnormally\", cmd);\n\t\treturn -1;\n\t}\n\tdebug3(\"command returned status %d\", WEXITSTATUS(status));\n\treturn WEXITSTATUS(status);\n}\n\n \nstatic int\ncheck_match_ifaddrs(const char *addrlist)\n{\n#ifdef HAVE_IFADDRS_H\n\tstruct ifaddrs *ifa, *ifaddrs = NULL;\n\tint r, found = 0;\n\tchar addr[NI_MAXHOST];\n\tsocklen_t salen;\n\n\tif (getifaddrs(&ifaddrs) != 0) {\n\t\terror(\"match localnetwork: getifaddrs failed: %s\",\n\t\t    strerror(errno));\n\t\treturn 0;\n\t}\n\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n\t\tif (ifa->ifa_addr == NULL || ifa->ifa_name == NULL ||\n\t\t    (ifa->ifa_flags & IFF_UP) == 0)\n\t\t\tcontinue;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\tsalen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tsalen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n#ifdef AF_LINK\n\t\tcase AF_LINK:\n\t\t\t \n\t\t\tcontinue;\n#endif  \n\t\tdefault:\n\t\t\tdebug2_f(\"interface %s: unsupported address family %d\",\n\t\t\t    ifa->ifa_name, ifa->ifa_addr->sa_family);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((r = getnameinfo(ifa->ifa_addr, salen, addr, sizeof(addr),\n\t\t    NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\t\tdebug2_f(\"interface %s getnameinfo failed: %s\",\n\t\t\t    ifa->ifa_name, gai_strerror(r));\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3_f(\"interface %s addr %s\", ifa->ifa_name, addr);\n\t\tif (addr_match_cidr_list(addr, addrlist) == 1) {\n\t\t\tdebug3_f(\"matched interface %s: address %s in %s\",\n\t\t\t    ifa->ifa_name, addr, addrlist);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfreeifaddrs(ifaddrs);\n\treturn found;\n#else  \n\terror(\"match localnetwork: not supported on this platform\");\n\treturn 0;\n#endif  \n}\n\n \nstatic int\nmatch_cfg_line(Options *options, char **condition, struct passwd *pw,\n    const char *host_arg, const char *original_host, int final_pass,\n    int *want_final_pass, const char *filename, int linenum)\n{\n\tchar *arg, *oattrib, *attrib, *cmd, *cp = *condition, *host, *criteria;\n\tconst char *ruser;\n\tint r, port, this_result, result = 1, attributes = 0, negate;\n\tchar thishost[NI_MAXHOST], shorthost[NI_MAXHOST], portstr[NI_MAXSERV];\n\tchar uidstr[32];\n\n\t \n\tport = options->port <= 0 ? default_ssh_port() : options->port;\n\truser = options->user == NULL ? pw->pw_name : options->user;\n\tif (final_pass) {\n\t\thost = xstrdup(options->hostname);\n\t} else if (options->hostname != NULL) {\n\t\t \n\t\thost = percent_expand(options->hostname,\n\t\t    \"h\", host_arg, (char *)NULL);\n\t} else {\n\t\thost = xstrdup(host_arg);\n\t}\n\n\tdebug2(\"checking match for '%s' host %s originally %s\",\n\t    cp, host, original_host);\n\twhile ((oattrib = attrib = strdelim(&cp)) && *attrib != '\\0') {\n\t\t \n\t\tif (*attrib == '#') {\n\t\t\tcp = NULL;  \n\t\t\tbreak;\n\t\t}\n\t\targ = criteria = NULL;\n\t\tthis_result = 1;\n\t\tif ((negate = (attrib[0] == '!')))\n\t\t\tattrib++;\n\t\t \n\t\tif (strcasecmp(attrib, \"all\") == 0) {\n\t\t\tif (attributes > 1 || ((arg = strdelim(&cp)) != NULL &&\n\t\t\t    *arg != '\\0' && *arg != '#')) {\n\t\t\t\terror(\"%.200s line %d: '%s' cannot be combined \"\n\t\t\t\t    \"with other Match attributes\",\n\t\t\t\t    filename, linenum, oattrib);\n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (arg != NULL && *arg == '#')\n\t\t\t\tcp = NULL;  \n\t\t\tif (result)\n\t\t\t\tresult = negate ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\t\tattributes++;\n\t\t \n\t\tif (strcasecmp(attrib, \"canonical\") == 0 ||\n\t\t    strcasecmp(attrib, \"final\") == 0) {\n\t\t\t \n\t\t\tif (strcasecmp(attrib, \"final\") == 0 &&\n\t\t\t    want_final_pass != NULL)\n\t\t\t\t*want_final_pass = 1;\n\t\t\tr = !!final_pass;   \n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t\tdebug3(\"%.200s line %d: %smatched '%s'\",\n\t\t\t    filename, linenum,\n\t\t\t    this_result ? \"\" : \"not \", oattrib);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif ((arg = strdelim(&cp)) == NULL ||\n\t\t    *arg == '\\0' || *arg == '#') {\n\t\t\terror(\"Missing Match criteria for %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcasecmp(attrib, \"host\") == 0) {\n\t\t\tcriteria = xstrdup(host);\n\t\t\tr = match_hostname(host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"originalhost\") == 0) {\n\t\t\tcriteria = xstrdup(original_host);\n\t\t\tr = match_hostname(original_host, arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"user\") == 0) {\n\t\t\tcriteria = xstrdup(ruser);\n\t\t\tr = match_pattern_list(ruser, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"localuser\") == 0) {\n\t\t\tcriteria = xstrdup(pw->pw_name);\n\t\t\tr = match_pattern_list(pw->pw_name, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"localnetwork\") == 0) {\n\t\t\tif (addr_match_cidr_list(NULL, arg) == -1) {\n\t\t\t\t \n\t\t\t\tresult = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tr = check_match_ifaddrs(arg) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"tagged\") == 0) {\n\t\t\tcriteria = xstrdup(options->tag == NULL ? \"\" :\n\t\t\t    options->tag);\n\t\t\tr = match_pattern_list(criteria, arg, 0) == 1;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else if (strcasecmp(attrib, \"exec\") == 0) {\n\t\t\tchar *conn_hash_hex, *keyalias, *jmphost;\n\n\t\t\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\t\t\tfatal(\"gethostname: %s\", strerror(errno));\n\t\t\tjmphost = option_clear_or_none(options->jump_host) ?\n\t\t\t    \"\" : options->jump_host;\n\t\t\tstrlcpy(shorthost, thishost, sizeof(shorthost));\n\t\t\tshorthost[strcspn(thishost, \".\")] = '\\0';\n\t\t\tsnprintf(portstr, sizeof(portstr), \"%d\", port);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\tconn_hash_hex = ssh_connection_hash(thishost, host,\n\t\t\t    portstr, ruser, jmphost);\n\t\t\tkeyalias = options->host_key_alias ?\n\t\t\t    options->host_key_alias : host;\n\n\t\t\tcmd = percent_expand(arg,\n\t\t\t    \"C\", conn_hash_hex,\n\t\t\t    \"L\", shorthost,\n\t\t\t    \"d\", pw->pw_dir,\n\t\t\t    \"h\", host,\n\t\t\t    \"k\", keyalias,\n\t\t\t    \"l\", thishost,\n\t\t\t    \"n\", original_host,\n\t\t\t    \"p\", portstr,\n\t\t\t    \"r\", ruser,\n\t\t\t    \"u\", pw->pw_name,\n\t\t\t    \"i\", uidstr,\n\t\t\t    \"j\", jmphost,\n\t\t\t    (char *)NULL);\n\t\t\tfree(conn_hash_hex);\n\t\t\tif (result != 1) {\n\t\t\t\t \n\t\t\t\tdebug3(\"%.200s line %d: skipped exec \"\n\t\t\t\t    \"\\\"%.100s\\\"\", filename, linenum, cmd);\n\t\t\t\tfree(cmd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = execute_in_shell(cmd);\n\t\t\tif (r == -1) {\n\t\t\t\tfatal(\"%.200s line %d: match exec \"\n\t\t\t\t    \"'%.100s' error\", filename,\n\t\t\t\t    linenum, cmd);\n\t\t\t}\n\t\t\tcriteria = xstrdup(cmd);\n\t\t\tfree(cmd);\n\t\t\t \n\t\t\tr = r == 0;\n\t\t\tif (r == (negate ? 1 : 0))\n\t\t\t\tthis_result = result = 0;\n\t\t} else {\n\t\t\terror(\"Unsupported Match attribute %s\", attrib);\n\t\t\tresult = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tdebug3(\"%.200s line %d: %smatched '%s%s%.100s%s' \",\n\t\t    filename, linenum, this_result ? \"\": \"not \", oattrib,\n\t\t    criteria == NULL ? \"\" : \" \\\"\",\n\t\t    criteria == NULL ? \"\" : criteria,\n\t\t    criteria == NULL ? \"\" : \"\\\"\");\n\t\tfree(criteria);\n\t}\n\tif (attributes == 0) {\n\t\terror(\"One or more attributes required for Match\");\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n out:\n\tif (result != -1)\n\t\tdebug2(\"match %sfound\", result ? \"\" : \"not \");\n\t*condition = cp;\n\tfree(host);\n\treturn result;\n}\n\n \nstatic void\nrm_env(Options *options, const char *arg, const char *filename, int linenum)\n{\n\tu_int i, j, onum_send_env = options->num_send_env;\n\n\t \n\tfor (i = 0; i < options->num_send_env; ) {\n\t\tif (!match_pattern(options->send_env[i], arg + 1)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tdebug3(\"%s line %d: removing environment %s\",\n\t\t    filename, linenum, options->send_env[i]);\n\t\tfree(options->send_env[i]);\n\t\toptions->send_env[i] = NULL;\n\t\tfor (j = i; j < options->num_send_env - 1; j++) {\n\t\t\toptions->send_env[j] = options->send_env[j + 1];\n\t\t\toptions->send_env[j + 1] = NULL;\n\t\t}\n\t\toptions->num_send_env--;\n\t\t \n\t}\n\tif (onum_send_env != options->num_send_env) {\n\t\toptions->send_env = xrecallocarray(options->send_env,\n\t\t    onum_send_env, options->num_send_env,\n\t\t    sizeof(*options->send_env));\n\t}\n}\n\n \nstatic OpCodes\nparse_token(const char *cp, const char *filename, int linenum,\n    const char *ignored_unknown)\n{\n\tint i;\n\n\tfor (i = 0; keywords[i].name; i++)\n\t\tif (strcmp(cp, keywords[i].name) == 0)\n\t\t\treturn keywords[i].opcode;\n\tif (ignored_unknown != NULL &&\n\t    match_pattern_list(cp, ignored_unknown, 1) == 1)\n\t\treturn oIgnoredUnknownOption;\n\terror(\"%s: line %d: Bad configuration option: %s\",\n\t    filename, linenum, cp);\n\treturn oBadOption;\n}\n\n \nstruct multistate {\n\tchar *key;\n\tint value;\n};\nstatic const struct multistate multistate_flag[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoask[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_strict_hostkey[] = {\n\t{ \"true\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"false\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"yes\",\t\t\tSSH_STRICT_HOSTKEY_YES },\n\t{ \"no\",\t\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"ask\",\t\t\tSSH_STRICT_HOSTKEY_ASK },\n\t{ \"off\",\t\t\tSSH_STRICT_HOSTKEY_OFF },\n\t{ \"accept-new\",\t\t\tSSH_STRICT_HOSTKEY_NEW },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_yesnoaskconfirm[] = {\n\t{ \"true\",\t\t\t1 },\n\t{ \"false\",\t\t\t0 },\n\t{ \"yes\",\t\t\t1 },\n\t{ \"no\",\t\t\t\t0 },\n\t{ \"ask\",\t\t\t2 },\n\t{ \"confirm\",\t\t\t3 },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_addressfamily[] = {\n\t{ \"inet\",\t\t\tAF_INET },\n\t{ \"inet6\",\t\t\tAF_INET6 },\n\t{ \"any\",\t\t\tAF_UNSPEC },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_controlmaster[] = {\n\t{ \"true\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"yes\",\t\t\tSSHCTL_MASTER_YES },\n\t{ \"false\",\t\t\tSSHCTL_MASTER_NO },\n\t{ \"no\",\t\t\t\tSSHCTL_MASTER_NO },\n\t{ \"auto\",\t\t\tSSHCTL_MASTER_AUTO },\n\t{ \"ask\",\t\t\tSSHCTL_MASTER_ASK },\n\t{ \"autoask\",\t\t\tSSHCTL_MASTER_AUTO_ASK },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_tunnel[] = {\n\t{ \"ethernet\",\t\t\tSSH_TUNMODE_ETHERNET },\n\t{ \"point-to-point\",\t\tSSH_TUNMODE_POINTOPOINT },\n\t{ \"true\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"yes\",\t\t\tSSH_TUNMODE_DEFAULT },\n\t{ \"false\",\t\t\tSSH_TUNMODE_NO },\n\t{ \"no\",\t\t\t\tSSH_TUNMODE_NO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_requesttty[] = {\n\t{ \"true\",\t\t\tREQUEST_TTY_YES },\n\t{ \"yes\",\t\t\tREQUEST_TTY_YES },\n\t{ \"false\",\t\t\tREQUEST_TTY_NO },\n\t{ \"no\",\t\t\t\tREQUEST_TTY_NO },\n\t{ \"force\",\t\t\tREQUEST_TTY_FORCE },\n\t{ \"auto\",\t\t\tREQUEST_TTY_AUTO },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_sessiontype[] = {\n\t{ \"none\",\t\t\tSESSION_TYPE_NONE },\n\t{ \"subsystem\",\t\t\tSESSION_TYPE_SUBSYSTEM },\n\t{ \"default\",\t\t\tSESSION_TYPE_DEFAULT },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_canonicalizehostname[] = {\n\t{ \"true\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"false\",\t\t\tSSH_CANONICALISE_NO },\n\t{ \"yes\",\t\t\tSSH_CANONICALISE_YES },\n\t{ \"no\",\t\t\t\tSSH_CANONICALISE_NO },\n\t{ \"always\",\t\t\tSSH_CANONICALISE_ALWAYS },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_pubkey_auth[] = {\n\t{ \"true\",\t\t\tSSH_PUBKEY_AUTH_ALL },\n\t{ \"false\",\t\t\tSSH_PUBKEY_AUTH_NO },\n\t{ \"yes\",\t\t\tSSH_PUBKEY_AUTH_ALL },\n\t{ \"no\",\t\t\t\tSSH_PUBKEY_AUTH_NO },\n\t{ \"unbound\",\t\t\tSSH_PUBKEY_AUTH_UNBOUND },\n\t{ \"host-bound\",\t\t\tSSH_PUBKEY_AUTH_HBOUND },\n\t{ NULL, -1 }\n};\nstatic const struct multistate multistate_compression[] = {\n#ifdef WITH_ZLIB\n\t{ \"yes\",\t\t\tCOMP_ZLIB },\n#endif\n\t{ \"no\",\t\t\t\tCOMP_NONE },\n\t{ NULL, -1 }\n};\n\nstatic int\nparse_multistate_value(const char *arg, const char *filename, int linenum,\n    const struct multistate *multistate_ptr)\n{\n\tint i;\n\n\tif (!arg || *arg == '\\0') {\n\t\terror(\"%s line %d: missing argument.\", filename, linenum);\n\t\treturn -1;\n\t}\n\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0)\n\t\t\treturn multistate_ptr[i].value;\n\t}\n\treturn -1;\n}\n\n \nint\nprocess_config_line(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags)\n{\n\treturn process_config_line_depth(options, pw, host, original_host,\n\t    line, filename, linenum, activep, flags, NULL, 0);\n}\n\n#define WHITESPACE \" \\t\\r\\n\"\nstatic int\nprocess_config_line_depth(Options *options, struct passwd *pw, const char *host,\n    const char *original_host, char *line, const char *filename,\n    int linenum, int *activep, int flags, int *want_final_pass, int depth)\n{\n\tchar *str, **charptr, *endofnumber, *keyword, *arg, *arg2, *p;\n\tchar **cpptr, ***cppptr, fwdarg[256];\n\tu_int i, *uintptr, uvalue, max_entries = 0;\n\tint r, oactive, negated, opcode, *intptr, value, value2, cmdline = 0;\n\tint remotefwd, dynamicfwd, ca_only = 0;\n\tLogLevel *log_level_ptr;\n\tSyslogFacility *log_facility_ptr;\n\tlong long val64;\n\tsize_t len;\n\tstruct Forward fwd;\n\tconst struct multistate *multistate_ptr;\n\tstruct allowed_cname *cname;\n\tglob_t gl;\n\tconst char *errstr;\n\tchar **oav = NULL, **av;\n\tint oac = 0, ac;\n\tint ret = -1;\n\n\tif (activep == NULL) {  \n\t\tcmdline = 1;\n\t\tactivep = &cmdline;\n\t}\n\n\t \n\tif ((len = strlen(line)) == 0)\n\t\treturn 0;\n\tfor (len--; len > 0; len--) {\n\t\tif (strchr(WHITESPACE \"\\f\", line[len]) == NULL)\n\t\t\tbreak;\n\t\tline[len] = '\\0';\n\t}\n\n\tstr = line;\n\t \n\tif ((keyword = strdelim(&str)) == NULL)\n\t\treturn 0;\n\t \n\tif (*keyword == '\\0')\n\t\tkeyword = strdelim(&str);\n\tif (keyword == NULL || !*keyword || *keyword == '\\n' || *keyword == '#')\n\t\treturn 0;\n\t \n\tlowercase(keyword);\n\n\t \n\tif (str != NULL)\n\t\tstr += strspn(str, WHITESPACE);\n\tif (str == NULL || *str == '\\0') {\n\t\terror(\"%s line %d: no argument after keyword \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\treturn -1;\n\t}\n\topcode = parse_token(keyword, filename, linenum,\n\t    options->ignored_unknown);\n\tif (argv_split(str, &oac, &oav, 1) != 0) {\n\t\terror(\"%s line %d: invalid quotes\", filename, linenum);\n\t\treturn -1;\n\t}\n\tac = oac;\n\tav = oav;\n\n\tswitch (opcode) {\n\tcase oBadOption:\n\t\t \n\t\tgoto out;\n\tcase oIgnore:\n\t\targv_consume(&ac);\n\t\tbreak;\n\tcase oIgnoredUnknownOption:\n\t\tdebug(\"%s line %d: Ignored unknown option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\targv_consume(&ac);\n\t\tbreak;\n\tcase oConnectTimeout:\n\t\tintptr = &options->connection_timeout;\nparse_time:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%s line %d: missing time value.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = -1;\n\t\telse if ((value = convtime(arg)) == -1) {\n\t\t\terror(\"%s line %d: invalid time value.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardAgent:\n\t\tintptr = &options->forward_agent;\n\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%s line %d: missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\n\t\tvalue = -1;\n\t\tmultistate_ptr = multistate_flag;\n\t\tfor (i = 0; multistate_ptr[i].key != NULL; i++) {\n\t\t\tif (strcasecmp(arg, multistate_ptr[i].key) == 0) {\n\t\t\t\tvalue = multistate_ptr[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (value != -1) {\n\t\t\tif (*activep && *intptr == -1)\n\t\t\t\t*intptr = value;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = 1;\n\n\t\tcharptr = &options->forward_agent_sock_path;\n\t\tgoto parse_agent_path;\n\n\tcase oForwardX11:\n\t\tintptr = &options->forward_x11;\n parse_flag:\n\t\tmultistate_ptr = multistate_flag;\n parse_multistate:\n\t\targ = argv_next(&ac, &av);\n\t\tif ((value = parse_multistate_value(arg, filename, linenum,\n\t\t    multistate_ptr)) == -1) {\n\t\t\terror(\"%s line %d: unsupported option \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oForwardX11Trusted:\n\t\tintptr = &options->forward_x11_trusted;\n\t\tgoto parse_flag;\n\n\tcase oForwardX11Timeout:\n\t\tintptr = &options->forward_x11_timeout;\n\t\tgoto parse_time;\n\n\tcase oGatewayPorts:\n\t\tintptr = &options->fwd_opts.gateway_ports;\n\t\tgoto parse_flag;\n\n\tcase oExitOnForwardFailure:\n\t\tintptr = &options->exit_on_forward_failure;\n\t\tgoto parse_flag;\n\n\tcase oPasswordAuthentication:\n\t\tintptr = &options->password_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveAuthentication:\n\t\tintptr = &options->kbd_interactive_authentication;\n\t\tgoto parse_flag;\n\n\tcase oKbdInteractiveDevices:\n\t\tcharptr = &options->kbd_interactive_devices;\n\t\tgoto parse_string;\n\n\tcase oPubkeyAuthentication:\n\t\tmultistate_ptr = multistate_pubkey_auth;\n\t\tintptr = &options->pubkey_authentication;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedAuthentication:\n\t\tintptr = &options->hostbased_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssAuthentication:\n\t\tintptr = &options->gss_authentication;\n\t\tgoto parse_flag;\n\n\tcase oGssDelegateCreds:\n\t\tintptr = &options->gss_deleg_creds;\n\t\tgoto parse_flag;\n\n\tcase oBatchMode:\n\t\tintptr = &options->batch_mode;\n\t\tgoto parse_flag;\n\n\tcase oCheckHostIP:\n\t\tintptr = &options->check_host_ip;\n\t\tgoto parse_flag;\n\n\tcase oVerifyHostKeyDNS:\n\t\tintptr = &options->verify_host_key_dns;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oStrictHostKeyChecking:\n\t\tintptr = &options->strict_host_key_checking;\n\t\tmultistate_ptr = multistate_strict_hostkey;\n\t\tgoto parse_multistate;\n\n\tcase oCompression:\n\t\tintptr = &options->compression;\n\t\tmultistate_ptr = multistate_compression;\n\t\tgoto parse_multistate;\n\n\tcase oTCPKeepAlive:\n\t\tintptr = &options->tcp_keep_alive;\n\t\tgoto parse_flag;\n\n\tcase oNoHostAuthenticationForLocalhost:\n\t\tintptr = &options->no_host_authentication_for_localhost;\n\t\tgoto parse_flag;\n\n\tcase oNumberOfPasswordPrompts:\n\t\tintptr = &options->number_of_password_prompts;\n\t\tgoto parse_int;\n\n\tcase oRekeyLimit:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\", filename,\n\t\t\t    linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(arg, \"default\") == 0) {\n\t\t\tval64 = 0;\n\t\t} else {\n\t\t\tif (scan_scaled(arg, &val64) == -1) {\n\t\t\t\terror(\"%.200s line %d: Bad number '%s': %s\",\n\t\t\t\t    filename, linenum, arg, strerror(errno));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (val64 != 0 && val64 < 16) {\n\t\t\t\terror(\"%.200s line %d: RekeyLimit too small\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (*activep && options->rekey_limit == -1)\n\t\t\toptions->rekey_limit = val64;\n\t\tif (ac != 0) {  \n\t\t\tif (strcmp(av[0], \"none\") == 0) {\n\t\t\t\t(void)argv_next(&ac, &av);\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tintptr = &options->rekey_interval;\n\t\t\tgoto parse_time;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityFile:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_identity_files;\n\t\t\tif (*intptr >= SSH_MAX_IDENTITY_FILES) {\n\t\t\t\terror(\"%.200s line %d: Too many identity files \"\n\t\t\t\t    \"specified (max %d).\", filename, linenum,\n\t\t\t\t    SSH_MAX_IDENTITY_FILES);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadd_identity_file(options, NULL,\n\t\t\t    arg, flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oCertificateFile:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep) {\n\t\t\tintptr = &options->num_certificate_files;\n\t\t\tif (*intptr >= SSH_MAX_CERTIFICATE_FILES) {\n\t\t\t\terror(\"%.200s line %d: Too many certificate \"\n\t\t\t\t    \"files specified (max %d).\",\n\t\t\t\t    filename, linenum,\n\t\t\t\t    SSH_MAX_CERTIFICATE_FILES);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadd_certificate_file(options, arg,\n\t\t\t    flags & SSHCONF_USERCONF);\n\t\t}\n\t\tbreak;\n\n\tcase oXAuthLocation:\n\t\tcharptr=&options->xauth_location;\n\t\tgoto parse_string;\n\n\tcase oUser:\n\t\tcharptr = &options->user;\nparse_string:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oGlobalKnownHostsFile:\n\t\tcpptr = (char **)&options->system_hostfiles;\n\t\tuintptr = &options->num_system_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\nparse_char_array:\n\t\ti = 0;\n\t\tvalue = *uintptr == 0;  \n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (*activep && value) {\n\t\t\t\tif ((*uintptr) >= max_entries) {\n\t\t\t\t\terror(\"%s line %d: too many %s \"\n\t\t\t\t\t    \"entries.\", filename, linenum,\n\t\t\t\t\t    keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcpptr[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oUserKnownHostsFile:\n\t\tcpptr = (char **)&options->user_hostfiles;\n\t\tuintptr = &options->num_user_hostfiles;\n\t\tmax_entries = SSH_MAX_HOSTS_FILES;\n\t\tgoto parse_char_array;\n\n\tcase oHostname:\n\t\tcharptr = &options->hostname;\n\t\tgoto parse_string;\n\n\tcase oTag:\n\t\tcharptr = &options->tag;\n\t\tgoto parse_string;\n\n\tcase oHostKeyAlias:\n\t\tcharptr = &options->host_key_alias;\n\t\tgoto parse_string;\n\n\tcase oPreferredAuthentications:\n\t\tcharptr = &options->preferred_authentications;\n\t\tgoto parse_string;\n\n\tcase oBindAddress:\n\t\tcharptr = &options->bind_address;\n\t\tgoto parse_string;\n\n\tcase oBindInterface:\n\t\tcharptr = &options->bind_interface;\n\t\tgoto parse_string;\n\n\tcase oPKCS11Provider:\n\t\tcharptr = &options->pkcs11_provider;\n\t\tgoto parse_string;\n\n\tcase oSecurityKeyProvider:\n\t\tcharptr = &options->sk_provider;\n\t\tgoto parse_string;\n\n\tcase oKnownHostsCommand:\n\t\tcharptr = &options->known_hosts_command;\n\t\tgoto parse_command;\n\n\tcase oProxyCommand:\n\t\tcharptr = &options->proxy_command;\n\t\t \n\t\tif (options->jump_host != NULL)\n\t\t\tcharptr = &options->jump_host;  \nparse_command:\n\t\tif (str == NULL) {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tlen = strspn(str, WHITESPACE \"=\");\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(str + len);\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase oProxyJump:\n\t\tif (str == NULL) {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tlen = strspn(str, WHITESPACE \"=\");\n\t\t \n\t\tif (parse_jump(str + len, options, *activep) == -1) {\n\t\t\terror(\"%.200s line %d: Invalid ProxyJump \\\"%s\\\"\",\n\t\t\t    filename, linenum, str + len);\n\t\t\tgoto out;\n\t\t}\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase oPort:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = a2port(arg);\n\t\tif (value <= 0) {\n\t\t\terror(\"%.200s line %d: Bad port '%s'.\",\n\t\t\t    filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->port == -1)\n\t\t\toptions->port = value;\n\t\tbreak;\n\n\tcase oConnectionAttempts:\n\t\tintptr = &options->connection_attempts;\nparse_int:\n\t\targ = argv_next(&ac, &av);\n\t\tif ((errstr = atoi_err(arg, &value)) != NULL) {\n\t\t\terror(\"%s line %d: integer value %s.\",\n\t\t\t    filename, linenum, errstr);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oCiphers:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*arg != '-' &&\n\t\t    !ciphers_valid(*arg == '+' || *arg == '^' ? arg + 1 : arg)){\n\t\t\terror(\"%.200s line %d: Bad SSH2 cipher spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->ciphers == NULL)\n\t\t\toptions->ciphers = xstrdup(arg);\n\t\tbreak;\n\n\tcase oMacs:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*arg != '-' &&\n\t\t    !mac_valid(*arg == '+' || *arg == '^' ? arg + 1 : arg)) {\n\t\t\terror(\"%.200s line %d: Bad SSH2 MAC spec '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->macs == NULL)\n\t\t\toptions->macs = xstrdup(arg);\n\t\tbreak;\n\n\tcase oKexAlgorithms:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*arg != '-' &&\n\t\t    !kex_names_valid(*arg == '+' || *arg == '^' ?\n\t\t    arg + 1 : arg)) {\n\t\t\terror(\"%.200s line %d: Bad SSH2 KexAlgorithms '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->kex_algorithms == NULL)\n\t\t\toptions->kex_algorithms = xstrdup(arg);\n\t\tbreak;\n\n\tcase oHostKeyAlgorithms:\n\t\tcharptr = &options->hostkeyalgorithms;\n\t\tca_only = 0;\nparse_pubkey_algos:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*arg != '-' &&\n\t\t    !sshkey_names_valid2(*arg == '+' || *arg == '^' ?\n\t\t    arg + 1 : arg, 1, ca_only)) {\n\t\t\terror(\"%s line %d: Bad key types '%s'.\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oCASignatureAlgorithms:\n\t\tcharptr = &options->ca_sign_algorithms;\n\t\tca_only = 1;\n\t\tgoto parse_pubkey_algos;\n\n\tcase oLogLevel:\n\t\tlog_level_ptr = &options->log_level;\n\t\targ = argv_next(&ac, &av);\n\t\tvalue = log_level_number(arg);\n\t\tif (value == SYSLOG_LEVEL_NOT_SET) {\n\t\t\terror(\"%.200s line %d: unsupported log level '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *log_level_ptr == SYSLOG_LEVEL_NOT_SET)\n\t\t\t*log_level_ptr = (LogLevel) value;\n\t\tbreak;\n\n\tcase oLogFacility:\n\t\tlog_facility_ptr = &options->log_facility;\n\t\targ = argv_next(&ac, &av);\n\t\tvalue = log_facility_number(arg);\n\t\tif (value == SYSLOG_FACILITY_NOT_SET) {\n\t\t\terror(\"%.200s line %d: unsupported log facility '%s'\",\n\t\t\t    filename, linenum, arg ? arg : \"<NONE>\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (*log_facility_ptr == -1)\n\t\t\t*log_facility_ptr = (SyslogFacility) value;\n\t\tbreak;\n\n\tcase oLogVerbose:\n\t\tcppptr = &options->log_verbose;\n\t\tuintptr = &options->num_log_verbose;\n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (*activep && *uintptr == 0) {\n\t\t\t\t*cppptr = xrecallocarray(*cppptr, *uintptr,\n\t\t\t\t    *uintptr + 1, sizeof(**cppptr));\n\t\t\t\t(*cppptr)[(*uintptr)++] = xstrdup(arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oLocalForward:\n\tcase oRemoteForward:\n\tcase oDynamicForward:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\n\t\tremotefwd = (opcode == oRemoteForward);\n\t\tdynamicfwd = (opcode == oDynamicForward);\n\n\t\tif (!dynamicfwd) {\n\t\t\targ2 = argv_next(&ac, &av);\n\t\t\tif (arg2 == NULL || *arg2 == '\\0') {\n\t\t\t\tif (remotefwd)\n\t\t\t\t\tdynamicfwd = 1;\n\t\t\t\telse {\n\t\t\t\t\terror(\"%.200s line %d: Missing target \"\n\t\t\t\t\t    \"argument.\", filename, linenum);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsnprintf(fwdarg, sizeof(fwdarg), \"%s:%s\", arg,\n\t\t\t\t    arg2);\n\t\t\t}\n\t\t}\n\t\tif (dynamicfwd)\n\t\t\tstrlcpy(fwdarg, arg, sizeof(fwdarg));\n\n\t\tif (parse_forward(&fwd, fwdarg, dynamicfwd, remotefwd) == 0) {\n\t\t\terror(\"%.200s line %d: Bad forwarding specification.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (*activep) {\n\t\t\tif (remotefwd) {\n\t\t\t\tadd_remote_forward(options, &fwd);\n\t\t\t} else {\n\t\t\t\tadd_local_forward(options, &fwd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase oPermitRemoteOpen:\n\t\tuintptr = &options->num_permitted_remote_opens;\n\t\tcppptr = &options->permitted_remote_opens;\n\t\tuvalue = *uintptr;\t \n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\targ2 = xstrdup(arg);\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0 ||\n\t\t\t    strcasecmp(arg, \"any\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"%s\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword, arg);\n\t\t\t\t\tfree(arg2);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp = hpdelim(&arg);\n\t\t\t\tif (p == NULL) {\n\t\t\t\t\tfatal(\"%s line %d: missing host in %s\",\n\t\t\t\t\t    filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t\tp = cleanhostname(p);\n\t\t\t\t \n\t\t\t\tif (arg == NULL || (strcmp(arg, \"*\") != 0 &&\n\t\t\t\t    a2port(arg) <= 0)) {\n\t\t\t\t\tfatal(\"%s line %d: bad port number \"\n\t\t\t\t\t    \"in %s\", filename, linenum,\n\t\t\t\t\t    lookup_opcode_name(opcode));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*activep && uvalue == 0) {\n\t\t\t\topt_array_append(filename, linenum,\n\t\t\t\t    lookup_opcode_name(opcode),\n\t\t\t\t    cppptr, uintptr, arg2);\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t\ti++;\n\t\t}\n\t\tif (i == 0)\n\t\t\tfatal(\"%s line %d: missing %s specification\",\n\t\t\t    filename, linenum, lookup_opcode_name(opcode));\n\t\tbreak;\n\n\tcase oClearAllForwardings:\n\t\tintptr = &options->clear_forwardings;\n\t\tgoto parse_flag;\n\n\tcase oHost:\n\t\tif (cmdline) {\n\t\t\terror(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t\tgoto out;\n\t\t}\n\t\t*activep = 0;\n\t\targ2 = NULL;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((flags & SSHCONF_NEVERMATCH) != 0) {\n\t\t\t\targv_consume(&ac);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnegated = *arg == '!';\n\t\t\tif (negated)\n\t\t\t\targ++;\n\t\t\tif (match_pattern(host, arg)) {\n\t\t\t\tif (negated) {\n\t\t\t\t\tdebug(\"%.200s line %d: Skipping Host \"\n\t\t\t\t\t    \"block because of negated match \"\n\t\t\t\t\t    \"for %.100s\", filename, linenum,\n\t\t\t\t\t    arg);\n\t\t\t\t\t*activep = 0;\n\t\t\t\t\targv_consume(&ac);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!*activep)\n\t\t\t\t\targ2 = arg;  \n\t\t\t\t*activep = 1;\n\t\t\t}\n\t\t}\n\t\tif (*activep)\n\t\t\tdebug(\"%.200s line %d: Applying options for %.100s\",\n\t\t\t    filename, linenum, arg2);\n\t\tbreak;\n\n\tcase oMatch:\n\t\tif (cmdline) {\n\t\t\terror(\"Host directive not supported as a command-line \"\n\t\t\t    \"option\");\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = match_cfg_line(options, &str, pw, host, original_host,\n\t\t    flags & SSHCONF_FINAL, want_final_pass,\n\t\t    filename, linenum);\n\t\tif (value < 0) {\n\t\t\terror(\"%.200s line %d: Bad Match condition\", filename,\n\t\t\t    linenum);\n\t\t\tgoto out;\n\t\t}\n\t\t*activep = (flags & SSHCONF_NEVERMATCH) ? 0 : value;\n\t\t \n\n\t\tif (str == NULL || *str == '\\0')\n\t\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase oEscapeChar:\n\t\tintptr = &options->escape_char;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (strcmp(arg, \"none\") == 0)\n\t\t\tvalue = SSH_ESCAPECHAR_NONE;\n\t\telse if (arg[1] == '\\0')\n\t\t\tvalue = (u_char) arg[0];\n\t\telse if (arg[0] == '^' && arg[2] == 0 &&\n\t\t    (u_char) arg[1] >= 64 && (u_char) arg[1] < 128)\n\t\t\tvalue = (u_char) arg[1] & 31;\n\t\telse {\n\t\t\terror(\"%.200s line %d: Bad escape character.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oAddressFamily:\n\t\tintptr = &options->address_family;\n\t\tmultistate_ptr = multistate_addressfamily;\n\t\tgoto parse_multistate;\n\n\tcase oEnableSSHKeysign:\n\t\tintptr = &options->enable_ssh_keysign;\n\t\tgoto parse_flag;\n\n\tcase oIdentitiesOnly:\n\t\tintptr = &options->identities_only;\n\t\tgoto parse_flag;\n\n\tcase oServerAliveInterval:\n\t\tintptr = &options->server_alive_interval;\n\t\tgoto parse_time;\n\n\tcase oServerAliveCountMax:\n\t\tintptr = &options->server_alive_count_max;\n\t\tgoto parse_int;\n\n\tcase oSendEnv:\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0' || strchr(arg, '=') != NULL) {\n\t\t\t\terror(\"%s line %d: Invalid environment name.\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!*activep)\n\t\t\t\tcontinue;\n\t\t\tif (*arg == '-') {\n\t\t\t\t \n\t\t\t\trm_env(options, arg, filename, linenum);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\topt_array_append(filename, linenum,\n\t\t\t    lookup_opcode_name(opcode),\n\t\t\t    &options->send_env, &options->num_send_env, arg);\n\t\t}\n\t\tbreak;\n\n\tcase oSetEnv:\n\t\tvalue = options->num_setenv;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (strchr(arg, '=') == NULL) {\n\t\t\t\terror(\"%s line %d: Invalid SetEnv.\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!*activep || value != 0)\n\t\t\t\tcontinue;\n\t\t\tif (lookup_setenv_in_list(arg, options->setenv,\n\t\t\t    options->num_setenv) != NULL) {\n\t\t\t\tdebug2(\"%s line %d: ignoring duplicate env \"\n\t\t\t\t    \"name \\\"%.64s\\\"\", filename, linenum, arg);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\topt_array_append(filename, linenum,\n\t\t\t    lookup_opcode_name(opcode),\n\t\t\t    &options->setenv, &options->num_setenv, arg);\n\t\t}\n\t\tbreak;\n\n\tcase oControlPath:\n\t\tcharptr = &options->control_path;\n\t\tgoto parse_string;\n\n\tcase oControlMaster:\n\t\tintptr = &options->control_master;\n\t\tmultistate_ptr = multistate_controlmaster;\n\t\tgoto parse_multistate;\n\n\tcase oControlPersist:\n\t\t \n\t\tintptr = &options->control_persist;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing ControlPersist\"\n\t\t\t    \" argument.\", filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = 0;\n\t\tvalue2 = 0;\t \n\t\tif (strcmp(arg, \"no\") == 0 || strcmp(arg, \"false\") == 0)\n\t\t\tvalue = 0;\n\t\telse if (strcmp(arg, \"yes\") == 0 || strcmp(arg, \"true\") == 0)\n\t\t\tvalue = 1;\n\t\telse if ((value2 = convtime(arg)) >= 0)\n\t\t\tvalue = 1;\n\t\telse {\n\t\t\terror(\"%.200s line %d: Bad ControlPersist argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *intptr == -1) {\n\t\t\t*intptr = value;\n\t\t\toptions->control_persist_timeout = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oHashKnownHosts:\n\t\tintptr = &options->hash_known_hosts;\n\t\tgoto parse_flag;\n\n\tcase oTunnel:\n\t\tintptr = &options->tun_open;\n\t\tmultistate_ptr = multistate_tunnel;\n\t\tgoto parse_multistate;\n\n\tcase oTunnelDevice:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = a2tun(arg, &value2);\n\t\tif (value == SSH_TUNID_ERR) {\n\t\t\terror(\"%.200s line %d: Bad tun device.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->tun_local == -1) {\n\t\t\toptions->tun_local = value;\n\t\t\toptions->tun_remote = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oLocalCommand:\n\t\tcharptr = &options->local_command;\n\t\tgoto parse_command;\n\n\tcase oPermitLocalCommand:\n\t\tintptr = &options->permit_local_command;\n\t\tgoto parse_flag;\n\n\tcase oRemoteCommand:\n\t\tcharptr = &options->remote_command;\n\t\tgoto parse_command;\n\n\tcase oVisualHostKey:\n\t\tintptr = &options->visual_host_key;\n\t\tgoto parse_flag;\n\n\tcase oInclude:\n\t\tif (cmdline) {\n\t\t\terror(\"Include directive not supported as a \"\n\t\t\t    \"command-line option\");\n\t\t\tgoto out;\n\t\t}\n\t\tvalue = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (*arg == '~' && (flags & SSHCONF_USERCONF) == 0) {\n\t\t\t\terror(\"%.200s line %d: bad include path %s.\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!path_absolute(arg) && *arg != '~') {\n\t\t\t\txasprintf(&arg2, \"%s/%s\",\n\t\t\t\t    (flags & SSHCONF_USERCONF) ?\n\t\t\t\t    \"~/\" _PATH_SSH_USER_DIR : SSHDIR, arg);\n\t\t\t} else\n\t\t\t\targ2 = xstrdup(arg);\n\t\t\tmemset(&gl, 0, sizeof(gl));\n\t\t\tr = glob(arg2, GLOB_TILDE, NULL, &gl);\n\t\t\tif (r == GLOB_NOMATCH) {\n\t\t\t\tdebug(\"%.200s line %d: include %s matched no \"\n\t\t\t\t    \"files\",filename, linenum, arg2);\n\t\t\t\tfree(arg2);\n\t\t\t\tcontinue;\n\t\t\t} else if (r != 0) {\n\t\t\t\terror(\"%.200s line %d: glob failed for %s.\",\n\t\t\t\t    filename, linenum, arg2);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(arg2);\n\t\t\toactive = *activep;\n\t\t\tfor (i = 0; i < gl.gl_pathc; i++) {\n\t\t\t\tdebug3(\"%.200s line %d: Including file %s \"\n\t\t\t\t    \"depth %d%s\", filename, linenum,\n\t\t\t\t    gl.gl_pathv[i], depth,\n\t\t\t\t    oactive ? \"\" : \" (parse only)\");\n\t\t\t\tr = read_config_file_depth(gl.gl_pathv[i],\n\t\t\t\t    pw, host, original_host, options,\n\t\t\t\t    flags | SSHCONF_CHECKPERM |\n\t\t\t\t    (oactive ? 0 : SSHCONF_NEVERMATCH),\n\t\t\t\t    activep, want_final_pass, depth + 1);\n\t\t\t\tif (r != 1 && errno != ENOENT) {\n\t\t\t\t\terror(\"Can't open user config file \"\n\t\t\t\t\t    \"%.100s: %.100s\", gl.gl_pathv[i],\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t\tglobfree(&gl);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\t*activep = oactive;\n\t\t\t\tif (r != 1)\n\t\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\tglobfree(&gl);\n\t\t}\n\t\tif (value != 0)\n\t\t\tret = value;\n\t\tbreak;\n\n\tcase oIPQoS:\n\t\targ = argv_next(&ac, &av);\n\t\tif ((value = parse_ipqos(arg)) == -1) {\n\t\t\terror(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\targ = argv_next(&ac, &av);\n\t\tif (arg == NULL)\n\t\t\tvalue2 = value;\n\t\telse if ((value2 = parse_ipqos(arg)) == -1) {\n\t\t\terror(\"%s line %d: Bad IPQoS value: %s\",\n\t\t\t    filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->ip_qos_interactive == -1) {\n\t\t\toptions->ip_qos_interactive = value;\n\t\t\toptions->ip_qos_bulk = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oRequestTTY:\n\t\tintptr = &options->request_tty;\n\t\tmultistate_ptr = multistate_requesttty;\n\t\tgoto parse_multistate;\n\n\tcase oSessionType:\n\t\tintptr = &options->session_type;\n\t\tmultistate_ptr = multistate_sessiontype;\n\t\tgoto parse_multistate;\n\n\tcase oStdinNull:\n\t\tintptr = &options->stdin_null;\n\t\tgoto parse_flag;\n\n\tcase oForkAfterAuthentication:\n\t\tintptr = &options->fork_after_authentication;\n\t\tgoto parse_flag;\n\n\tcase oIgnoreUnknown:\n\t\tcharptr = &options->ignored_unknown;\n\t\tgoto parse_string;\n\n\tcase oProxyUseFdpass:\n\t\tintptr = &options->proxy_use_fdpass;\n\t\tgoto parse_flag;\n\n\tcase oCanonicalDomains:\n\t\tvalue = options->num_canonical_domains != 0;\n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (*arg == '\\0') {\n\t\t\t\terror(\"%s line %d: keyword %s empty argument\",\n\t\t\t\t    filename, linenum, keyword);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!valid_domain(arg, 1, &errstr)) {\n\t\t\t\terror(\"%s line %d: %s\", filename, linenum,\n\t\t\t\t    errstr);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_canonical_domains >=\n\t\t\t    MAX_CANON_DOMAINS) {\n\t\t\t\terror(\"%s line %d: too many hostname suffixes.\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toptions->canonical_domains[\n\t\t\t    options->num_canonical_domains++] = xstrdup(arg);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizePermittedCNAMEs:\n\t\tvalue = options->num_permitted_cnames != 0;\n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\targ2 = \"\";\n\t\t\t} else if (strcmp(arg, \"*\") == 0) {\n\t\t\t\targ2 = arg;\n\t\t\t} else {\n\t\t\t\tlowercase(arg);\n\t\t\t\tif ((arg2 = strchr(arg, ':')) == NULL ||\n\t\t\t\t    arg2[1] == '\\0') {\n\t\t\t\t\terror(\"%s line %d: \"\n\t\t\t\t\t    \"Invalid permitted CNAME \\\"%s\\\"\",\n\t\t\t\t\t    filename, linenum, arg);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t*arg2 = '\\0';\n\t\t\t\targ2++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!*activep || value)\n\t\t\t\tcontinue;\n\t\t\tif (options->num_permitted_cnames >=\n\t\t\t    MAX_CANON_DOMAINS) {\n\t\t\t\terror(\"%s line %d: too many permitted CNAMEs.\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcname = options->permitted_cnames +\n\t\t\t    options->num_permitted_cnames++;\n\t\t\tcname->source_list = xstrdup(arg);\n\t\t\tcname->target_list = xstrdup(arg2);\n\t\t}\n\t\tbreak;\n\n\tcase oCanonicalizeHostname:\n\t\tintptr = &options->canonicalize_hostname;\n\t\tmultistate_ptr = multistate_canonicalizehostname;\n\t\tgoto parse_multistate;\n\n\tcase oCanonicalizeMaxDots:\n\t\tintptr = &options->canonicalize_max_dots;\n\t\tgoto parse_int;\n\n\tcase oCanonicalizeFallbackLocal:\n\t\tintptr = &options->canonicalize_fallback_local;\n\t\tgoto parse_flag;\n\n\tcase oStreamLocalBindMask:\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing StreamLocalBindMask \"\n\t\t\t    \"argument.\", filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tvalue = strtol(arg, &endofnumber, 8);\n\t\tif (arg == endofnumber || value < 0 || value > 0777) {\n\t\t\terror(\"%.200s line %d: Bad mask.\", filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)value;\n\t\tbreak;\n\n\tcase oStreamLocalBindUnlink:\n\t\tintptr = &options->fwd_opts.streamlocal_bind_unlink;\n\t\tgoto parse_flag;\n\n\tcase oRevokedHostKeys:\n\t\tcharptr = &options->revoked_host_keys;\n\t\tgoto parse_string;\n\n\tcase oFingerprintHash:\n\t\tintptr = &options->fingerprint_hash;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif ((value = ssh_digest_alg_by_name(arg)) == -1) {\n\t\t\terror(\"%.200s line %d: Invalid hash algorithm \\\"%s\\\".\",\n\t\t\t    filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oUpdateHostkeys:\n\t\tintptr = &options->update_hostkeys;\n\t\tmultistate_ptr = multistate_yesnoask;\n\t\tgoto parse_multistate;\n\n\tcase oHostbasedAcceptedAlgorithms:\n\t\tcharptr = &options->hostbased_accepted_algos;\n\t\tca_only = 0;\n\t\tgoto parse_pubkey_algos;\n\n\tcase oPubkeyAcceptedAlgorithms:\n\t\tcharptr = &options->pubkey_accepted_algos;\n\t\tca_only = 0;\n\t\tgoto parse_pubkey_algos;\n\n\tcase oAddKeysToAgent:\n\t\targ = argv_next(&ac, &av);\n\t\targ2 = argv_next(&ac, &av);\n\t\tvalue = parse_multistate_value(arg, filename, linenum,\n\t\t    multistate_yesnoaskconfirm);\n\t\tvalue2 = 0;  \n\t\tif (value == 3 && arg2 != NULL) {\n\t\t\t \n\t\t\tif ((value2 = convtime(arg2)) == -1) {\n\t\t\t\terror(\"%s line %d: invalid time value.\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (value == -1 && arg2 == NULL) {\n\t\t\tif ((value2 = convtime(arg)) == -1) {\n\t\t\t\terror(\"%s line %d: unsupported option\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tvalue = 1;  \n\t\t} else if (value == -1 || arg2 != NULL) {\n\t\t\terror(\"%s line %d: unsupported option\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && options->add_keys_to_agent == -1) {\n\t\t\toptions->add_keys_to_agent = value;\n\t\t\toptions->add_keys_to_agent_lifespan = value2;\n\t\t}\n\t\tbreak;\n\n\tcase oIdentityAgent:\n\t\tcharptr = &options->identity_agent;\n\t\targ = argv_next(&ac, &av);\n\t\tif (!arg || *arg == '\\0') {\n\t\t\terror(\"%.200s line %d: Missing argument.\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n  parse_agent_path:\n\t\t \n\t\tif ((arg2 = dollar_expand(&r, arg)) == NULL || r) {\n\t\t\terror(\"%.200s line %d: Invalid environment expansion \"\n\t\t\t    \"%s.\", filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\tfree(arg2);\n\t\t \n\t\tif (arg[0] == '$' && arg[1] != '{' &&\n\t\t    !valid_env_name(arg + 1)) {\n\t\t\terror(\"%.200s line %d: Invalid environment name %s.\",\n\t\t\t    filename, linenum, arg);\n\t\t\tgoto out;\n\t\t}\n\t\tif (*activep && *charptr == NULL)\n\t\t\t*charptr = xstrdup(arg);\n\t\tbreak;\n\n\tcase oEnableEscapeCommandline:\n\t\tintptr = &options->enable_escape_commandline;\n\t\tgoto parse_flag;\n\n\tcase oRequiredRSASize:\n\t\tintptr = &options->required_rsa_size;\n\t\tgoto parse_int;\n\n\tcase oObscureKeystrokeTiming:\n\t\tvalue = -1;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\tif (value != -1) {\n\t\t\t\terror(\"%s line %d: invalid arguments\",\n\t\t\t\t    filename, linenum);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (strcmp(arg, \"yes\") == 0 ||\n\t\t\t    strcmp(arg, \"true\") == 0)\n\t\t\t\tvalue = SSH_KEYSTROKE_DEFAULT_INTERVAL_MS;\n\t\t\telse if (strcmp(arg, \"no\") == 0 ||\n\t\t\t    strcmp(arg, \"false\") == 0)\n\t\t\t\tvalue = 0;\n\t\t\telse if (strncmp(arg, \"interval:\", 9) == 0) {\n\t\t\t\tif ((errstr = atoi_err(arg + 9,\n\t\t\t\t    &value)) != NULL) {\n\t\t\t\t\terror(\"%s line %d: integer value %s.\",\n\t\t\t\t\t    filename, linenum, errstr);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (value <= 0 || value > 1000) {\n\t\t\t\t\terror(\"%s line %d: value out of range.\",\n\t\t\t\t\t    filename, linenum);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror(\"%s line %d: unsupported argument \\\"%s\\\"\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (value == -1) {\n\t\t\terror(\"%s line %d: missing argument\",\n\t\t\t    filename, linenum);\n\t\t\tgoto out;\n\t\t}\n\t\tintptr = &options->obscure_keystroke_timing_interval;\n\t\tif (*activep && *intptr == -1)\n\t\t\t*intptr = value;\n\t\tbreak;\n\n\tcase oChannelTimeout:\n\t\tuvalue = options->num_channel_timeouts;\n\t\ti = 0;\n\t\twhile ((arg = argv_next(&ac, &av)) != NULL) {\n\t\t\t \n\t\t\tif (strcasecmp(arg, \"none\") == 0) {\n\t\t\t\tif (i > 0 || ac > 0) {\n\t\t\t\t\terror(\"%s line %d: keyword %s \\\"none\\\" \"\n\t\t\t\t\t    \"argument must appear alone.\",\n\t\t\t\t\t    filename, linenum, keyword);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (parse_pattern_interval(arg,\n\t\t\t    NULL, NULL) != 0) {\n\t\t\t\tfatal(\"%s line %d: invalid channel timeout %s\",\n\t\t\t\t    filename, linenum, arg);\n\t\t\t}\n\t\t\tif (!*activep || uvalue != 0)\n\t\t\t\tcontinue;\n\t\t\topt_array_append(filename, linenum, keyword,\n\t\t\t    &options->channel_timeouts,\n\t\t\t    &options->num_channel_timeouts, arg);\n\t\t}\n\t\tbreak;\n\n\tcase oDeprecated:\n\t\tdebug(\"%s line %d: Deprecated option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tcase oUnsupported:\n\t\terror(\"%s line %d: Unsupported option \\\"%s\\\"\",\n\t\t    filename, linenum, keyword);\n\t\targv_consume(&ac);\n\t\tbreak;\n\n\tdefault:\n\t\terror(\"%s line %d: Unimplemented opcode %d\",\n\t\t    filename, linenum, opcode);\n\t\tgoto out;\n\t}\n\n\t \n\tif (ac > 0) {\n\t\terror(\"%.200s line %d: keyword %s extra arguments \"\n\t\t    \"at end of line\", filename, linenum, keyword);\n\t\tgoto out;\n\t}\n\n\t \n\tret = 0;\n out:\n\targv_free(oav, oac);\n\treturn ret;\n}\n\n \nint\nread_config_file(const char *filename, struct passwd *pw, const char *host,\n    const char *original_host, Options *options, int flags,\n    int *want_final_pass)\n{\n\tint active = 1;\n\n\treturn read_config_file_depth(filename, pw, host, original_host,\n\t    options, flags, &active, want_final_pass, 0);\n}\n\n#define READCONF_MAX_DEPTH\t16\nstatic int\nread_config_file_depth(const char *filename, struct passwd *pw,\n    const char *host, const char *original_host, Options *options,\n    int flags, int *activep, int *want_final_pass, int depth)\n{\n\tFILE *f;\n\tchar *line = NULL;\n\tsize_t linesize = 0;\n\tint linenum;\n\tint bad_options = 0;\n\n\tif (depth < 0 || depth > READCONF_MAX_DEPTH)\n\t\tfatal(\"Too many recursive configuration includes\");\n\n\tif ((f = fopen(filename, \"r\")) == NULL)\n\t\treturn 0;\n\n\tif (flags & SSHCONF_CHECKPERM) {\n\t\tstruct stat sb;\n\n\t\tif (fstat(fileno(f), &sb) == -1)\n\t\t\tfatal(\"fstat %s: %s\", filename, strerror(errno));\n\t\tif (((sb.st_uid != 0 && sb.st_uid != getuid()) ||\n\t\t    (sb.st_mode & 022) != 0))\n\t\t\tfatal(\"Bad owner or permissions on %s\", filename);\n\t}\n\n\tdebug(\"Reading configuration data %.200s\", filename);\n\n\t \n\tlinenum = 0;\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\t \n\t\tlinenum++;\n\t\t \n\t\tif (process_config_line_depth(options, pw, host, original_host,\n\t\t    line, filename, linenum, activep, flags, want_final_pass,\n\t\t    depth) != 0)\n\t\t\tbad_options++;\n\t}\n\tfree(line);\n\tfclose(f);\n\tif (bad_options > 0)\n\t\tfatal(\"%s: terminating, %d bad configuration options\",\n\t\t    filename, bad_options);\n\treturn 1;\n}\n\n \nint\noption_clear_or_none(const char *o)\n{\n\treturn o == NULL || strcasecmp(o, \"none\") == 0;\n}\n\n \nint\nconfig_has_permitted_cnames(Options *options)\n{\n\tif (options->num_permitted_cnames == 1 &&\n\t    strcasecmp(options->permitted_cnames[0].source_list, \"none\") == 0 &&\n\t    strcmp(options->permitted_cnames[0].target_list, \"\") == 0)\n\t\treturn 0;\n\treturn options->num_permitted_cnames > 0;\n}\n\n \n\nvoid\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->host_arg = NULL;\n\toptions->forward_agent = -1;\n\toptions->forward_agent_sock_path = NULL;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\tmemset(options->identity_keys, 0, sizeof(options->identity_keys));\n\toptions->num_certificate_files = 0;\n\tmemset(options->certificates, 0, sizeof(options->certificates));\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->permitted_remote_opens = NULL;\n\toptions->num_permitted_remote_opens = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->num_log_verbose = 0;\n\toptions->log_verbose = NULL;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->sk_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->add_keys_to_agent_lifespan = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->session_type = -1;\n\toptions->stdin_null = -1;\n\toptions->fork_after_authentication = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_accepted_algos = NULL;\n\toptions->pubkey_accepted_algos = NULL;\n\toptions->known_hosts_command = NULL;\n\toptions->required_rsa_size = -1;\n\toptions->enable_escape_commandline = -1;\n\toptions->obscure_keystroke_timing_interval = -1;\n\toptions->tag = NULL;\n\toptions->channel_timeouts = NULL;\n\toptions->num_channel_timeouts = 0;\n}\n\n \nvoid\nfill_default_options_for_canonicalization(Options *options)\n{\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n}\n\n \nint\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tchar *def_cipher, *def_mac, *def_kex, *def_key, *def_sig;\n\tint ret = 0, r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t \n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = SSH_PUBKEY_AUTH_ALL;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 0;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t \n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t \n\tif (options->add_keys_to_agent == -1) {\n\t\toptions->add_keys_to_agent = 0;\n\t\toptions->add_keys_to_agent_lifespan = 0;\n\t}\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ECDSA_SK, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519_SK, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->update_hostkeys == -1) {\n\t\tif (options->verify_host_key_dns <= 0 &&\n\t\t    (options->num_user_hostfiles == 0 ||\n\t\t    (options->num_user_hostfiles == 1 && strcmp(options->\n\t\t    user_hostfiles[0], _PATH_SSH_USER_HOSTFILE) == 0)))\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_YES;\n\t\telse\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_NO;\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->session_type == -1)\n\t\toptions->session_type = SESSION_TYPE_DEFAULT;\n\tif (options->stdin_null == -1)\n\t\toptions->stdin_null = 0;\n\tif (options->fork_after_authentication == -1)\n\t\toptions->fork_after_authentication = 0;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n#ifdef ENABLE_SK_INTERNAL\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"internal\");\n#else\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"$SSH_SK_PROVIDER\");\n#endif\n\tif (options->required_rsa_size == -1)\n\t\toptions->required_rsa_size = SSH_RSA_MINIMUM_MODULUS_SIZE;\n\tif (options->enable_escape_commandline == -1)\n\t\toptions->enable_escape_commandline = 0;\n\tif (options->obscure_keystroke_timing_interval == -1) {\n\t\toptions->obscure_keystroke_timing_interval =\n\t\t    SSH_KEYSTROKE_DEFAULT_INTERVAL_MS;\n\t}\n\n\t \n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n\t \n\tdef_cipher = match_filter_allowlist(KEX_CLIENT_ENCRYPT, all_cipher);\n\tdef_mac = match_filter_allowlist(KEX_CLIENT_MAC, all_mac);\n\tdef_kex = match_filter_allowlist(KEX_CLIENT_KEX, all_kex);\n\tdef_key = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\tdef_sig = match_filter_allowlist(SSH_ALLOWED_CA_SIGALGS, all_sig);\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) { \\\n\t\t\terror_fr(r, \"%s\", #what); \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\tASSEMBLE(ciphers, def_cipher, all_cipher);\n\tASSEMBLE(macs, def_mac, all_mac);\n\tASSEMBLE(kex_algorithms, def_kex, all_kex);\n\tASSEMBLE(hostbased_accepted_algos, def_key, all_key);\n\tASSEMBLE(pubkey_accepted_algos, def_key, all_key);\n\tASSEMBLE(ca_sign_algorithms, def_sig, all_sig);\n#undef ASSEMBLE\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n#define CLEAR_ON_NONE_ARRAY(v, nv, none) \\\n\tdo { \\\n\t\tif (options->nv == 1 && \\\n\t\t    strcasecmp(options->v[0], none) == 0) { \\\n\t\t\tfree(options->v[0]); \\\n\t\t\tfree(options->v); \\\n\t\t\toptions->v = NULL; \\\n\t\t\toptions->nv = 0; \\\n\t\t} \\\n\t} while (0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tCLEAR_ON_NONE(options->pkcs11_provider);\n\tCLEAR_ON_NONE(options->sk_provider);\n\tCLEAR_ON_NONE(options->known_hosts_command);\n\tCLEAR_ON_NONE_ARRAY(channel_timeouts, num_channel_timeouts, \"none\");\n#undef CLEAR_ON_NONE\n#undef CLEAR_ON_NONE_ARRAY\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\tif (options->num_permitted_cnames == 1 &&\n\t    !config_has_permitted_cnames(options)) {\n\t\t \n\t\tfree(options->permitted_cnames[0].source_list);\n\t\tfree(options->permitted_cnames[0].target_list);\n\t\tmemset(options->permitted_cnames, '\\0',\n\t\t    sizeof(*options->permitted_cnames));\n\t\toptions->num_permitted_cnames = 0;\n\t}\n\t \n\t \n\t \n\t \n\t \n\n\t \n\tret = 0;\n fail:\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\tfree(def_cipher);\n\tfree(def_mac);\n\tfree(def_kex);\n\tfree(def_key);\n\tfree(def_sig);\n\treturn ret;\n}\n\nvoid\nfree_options(Options *o)\n{\n\tint i;\n\n\tif (o == NULL)\n\t\treturn;\n\n#define FREE_ARRAY(type, n, a) \\\n\tdo { \\\n\t\ttype _i; \\\n\t\tfor (_i = 0; _i < (n); _i++) \\\n\t\t\tfree((a)[_i]); \\\n\t} while (0)\n\n\tfree(o->forward_agent_sock_path);\n\tfree(o->xauth_location);\n\tFREE_ARRAY(u_int, o->num_log_verbose, o->log_verbose);\n\tfree(o->log_verbose);\n\tfree(o->ciphers);\n\tfree(o->macs);\n\tfree(o->hostkeyalgorithms);\n\tfree(o->kex_algorithms);\n\tfree(o->ca_sign_algorithms);\n\tfree(o->hostname);\n\tfree(o->host_key_alias);\n\tfree(o->proxy_command);\n\tfree(o->user);\n\tFREE_ARRAY(u_int, o->num_system_hostfiles, o->system_hostfiles);\n\tFREE_ARRAY(u_int, o->num_user_hostfiles, o->user_hostfiles);\n\tfree(o->preferred_authentications);\n\tfree(o->bind_address);\n\tfree(o->bind_interface);\n\tfree(o->pkcs11_provider);\n\tfree(o->sk_provider);\n\tfor (i = 0; i < o->num_identity_files; i++) {\n\t\tfree(o->identity_files[i]);\n\t\tsshkey_free(o->identity_keys[i]);\n\t}\n\tfor (i = 0; i < o->num_certificate_files; i++) {\n\t\tfree(o->certificate_files[i]);\n\t\tsshkey_free(o->certificates[i]);\n\t}\n\tfree(o->identity_agent);\n\tfor (i = 0; i < o->num_local_forwards; i++) {\n\t\tfree(o->local_forwards[i].listen_host);\n\t\tfree(o->local_forwards[i].listen_path);\n\t\tfree(o->local_forwards[i].connect_host);\n\t\tfree(o->local_forwards[i].connect_path);\n\t}\n\tfree(o->local_forwards);\n\tfor (i = 0; i < o->num_remote_forwards; i++) {\n\t\tfree(o->remote_forwards[i].listen_host);\n\t\tfree(o->remote_forwards[i].listen_path);\n\t\tfree(o->remote_forwards[i].connect_host);\n\t\tfree(o->remote_forwards[i].connect_path);\n\t}\n\tfree(o->remote_forwards);\n\tfree(o->stdio_forward_host);\n\tFREE_ARRAY(u_int, o->num_send_env, o->send_env);\n\tfree(o->send_env);\n\tFREE_ARRAY(u_int, o->num_setenv, o->setenv);\n\tfree(o->setenv);\n\tfree(o->control_path);\n\tfree(o->local_command);\n\tfree(o->remote_command);\n\tFREE_ARRAY(int, o->num_canonical_domains, o->canonical_domains);\n\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\tfree(o->permitted_cnames[i].source_list);\n\t\tfree(o->permitted_cnames[i].target_list);\n\t}\n\tfree(o->revoked_host_keys);\n\tfree(o->hostbased_accepted_algos);\n\tfree(o->pubkey_accepted_algos);\n\tfree(o->jump_user);\n\tfree(o->jump_host);\n\tfree(o->jump_extra);\n\tfree(o->ignored_unknown);\n\texplicit_bzero(o, sizeof(*o));\n#undef FREE_ARRAY\n}\n\nstruct fwdarg {\n\tchar *arg;\n\tint ispath;\n};\n\n \nstatic int\nparse_fwd_field(char **p, struct fwdarg *fwd)\n{\n\tchar *ep, *cp = *p;\n\tint ispath = 0;\n\n\tif (*cp == '\\0') {\n\t\t*p = NULL;\n\t\treturn -1;\t \n\t}\n\n\t \n\tif (*cp == '[') {\n\t\t \n\t\tfor (ep = cp + 1; *ep != ']' && *ep != '\\0'; ep++) {\n\t\t\tif (*ep == '/')\n\t\t\t\tispath = 1;\n\t\t}\n\t\t \n\t\tif (ep[0] != ']' || (ep[1] != ':' && ep[1] != '\\0'))\n\t\t\treturn -1;\n\t\t \n\t\t*ep++ = '\\0';\n\t\tif (*ep != '\\0')\n\t\t\t*ep++ = '\\0';\n\t\tfwd->arg = cp + 1;\n\t\tfwd->ispath = ispath;\n\t\t*p = ep;\n\t\treturn 0;\n\t}\n\n\tfor (cp = *p; *cp != '\\0'; cp++) {\n\t\tswitch (*cp) {\n\t\tcase '\\\\':\n\t\t\tmemmove(cp, cp + 1, strlen(cp + 1) + 1);\n\t\t\tif (*cp == '\\0')\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tispath = 1;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\t*cp++ = '\\0';\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tfwd->arg = *p;\n\tfwd->ispath = ispath;\n\t*p = cp;\n\treturn 0;\n}\n\n \nint\nparse_forward(struct Forward *fwd, const char *fwdspec, int dynamicfwd, int remotefwd)\n{\n\tstruct fwdarg fwdargs[4];\n\tchar *p, *cp;\n\tint i, err;\n\n\tmemset(fwd, 0, sizeof(*fwd));\n\tmemset(fwdargs, 0, sizeof(fwdargs));\n\n\t \n\tcp = p = dollar_expand(&err, fwdspec);\n\tif (p == NULL || err)\n\t\treturn 0;\n\n\t \n\twhile (isspace((u_char)*cp))\n\t\tcp++;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (parse_fwd_field(&cp, &fwdargs[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (cp != NULL && *cp != '\\0') {\n\t\ti = 0;\t \n\t}\n\n\tswitch (i) {\n\tcase 1:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t}\n\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\tbreak;\n\n\tcase 2:\n\t\tif (fwdargs[0].ispath && fwdargs[1].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else if (fwdargs[1].ispath) {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_host = xstrdup(\"socks\");\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (fwdargs[0].ispath) {\n\t\t\tfwd->listen_path = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = PORT_STREAMLOCAL;\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t} else if (fwdargs[2].ispath) {\n\t\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\t\tfwd->connect_path = xstrdup(fwdargs[2].arg);\n\t\t\tfwd->connect_port = PORT_STREAMLOCAL;\n\t\t} else {\n\t\t\tfwd->listen_host = NULL;\n\t\t\tfwd->listen_port = a2port(fwdargs[0].arg);\n\t\t\tfwd->connect_host = xstrdup(fwdargs[1].arg);\n\t\t\tfwd->connect_port = a2port(fwdargs[2].arg);\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tfwd->listen_host = xstrdup(fwdargs[0].arg);\n\t\tfwd->listen_port = a2port(fwdargs[1].arg);\n\t\tfwd->connect_host = xstrdup(fwdargs[2].arg);\n\t\tfwd->connect_port = a2port(fwdargs[3].arg);\n\t\tbreak;\n\tdefault:\n\t\ti = 0;  \n\t}\n\n\tfree(p);\n\n\tif (dynamicfwd) {\n\t\tif (!(i == 1 || i == 2))\n\t\t\tgoto fail_free;\n\t} else {\n\t\tif (!(i == 3 || i == 4)) {\n\t\t\tif (fwd->connect_path == NULL &&\n\t\t\t    fwd->listen_path == NULL)\n\t\t\t\tgoto fail_free;\n\t\t}\n\t\tif (fwd->connect_port <= 0 && fwd->connect_path == NULL)\n\t\t\tgoto fail_free;\n\t}\n\n\tif ((fwd->listen_port < 0 && fwd->listen_path == NULL) ||\n\t    (!remotefwd && fwd->listen_port == 0))\n\t\tgoto fail_free;\n\tif (fwd->connect_host != NULL &&\n\t    strlen(fwd->connect_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\t \n\tif (fwd->connect_path != NULL &&\n\t    strlen(fwd->connect_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\tif (fwd->listen_host != NULL &&\n\t    strlen(fwd->listen_host) >= NI_MAXHOST)\n\t\tgoto fail_free;\n\tif (fwd->listen_path != NULL &&\n\t    strlen(fwd->listen_path) >= PATH_MAX_SUN)\n\t\tgoto fail_free;\n\n\treturn (i);\n\n fail_free:\n\tfree(fwd->connect_host);\n\tfwd->connect_host = NULL;\n\tfree(fwd->connect_path);\n\tfwd->connect_path = NULL;\n\tfree(fwd->listen_host);\n\tfwd->listen_host = NULL;\n\tfree(fwd->listen_path);\n\tfwd->listen_path = NULL;\n\treturn (0);\n}\n\nint\nparse_jump(const char *s, Options *o, int active)\n{\n\tchar *orig, *sdup, *cp;\n\tchar *host = NULL, *user = NULL;\n\tint r, ret = -1, port = -1, first;\n\n\tactive &= o->proxy_command == NULL && o->jump_host == NULL;\n\n\torig = sdup = xstrdup(s);\n\n\t \n\tif ((cp = strchr(orig, '#')) != NULL)\n\t\t*cp = '\\0';\n\trtrim(orig);\n\n\tfirst = active;\n\tdo {\n\t\tif (strcasecmp(s, \"none\") == 0)\n\t\t\tbreak;\n\t\tif ((cp = strrchr(sdup, ',')) == NULL)\n\t\t\tcp = sdup;  \n\t\telse\n\t\t\t*cp++ = '\\0';\n\n\t\tif (first) {\n\t\t\t \n\t\t\tr = parse_ssh_uri(cp, &user, &host, &port);\n\t\t\tif (r == -1 || (r == 1 &&\n\t\t\t    parse_user_host_port(cp, &user, &host, &port) != 0))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tr = parse_ssh_uri(cp, NULL, NULL, NULL);\n\t\t\tif (r == -1 || (r == 1 &&\n\t\t\t    parse_user_host_port(cp, NULL, NULL, NULL) != 0))\n\t\t\t\tgoto out;\n\t\t}\n\t\tfirst = 0;  \n\t} while (cp != sdup);\n\t \n\tif (active) {\n\t\tif (strcasecmp(s, \"none\") == 0) {\n\t\t\to->jump_host = xstrdup(\"none\");\n\t\t\to->jump_port = 0;\n\t\t} else {\n\t\t\to->jump_user = user;\n\t\t\to->jump_host = host;\n\t\t\to->jump_port = port;\n\t\t\to->proxy_command = xstrdup(\"none\");\n\t\t\tuser = host = NULL;\n\t\t\tif ((cp = strrchr(s, ',')) != NULL && cp != s) {\n\t\t\t\to->jump_extra = xstrdup(s);\n\t\t\t\to->jump_extra[cp - s] = '\\0';\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(orig);\n\tfree(user);\n\tfree(host);\n\treturn ret;\n}\n\nint\nparse_ssh_uri(const char *uri, char **userp, char **hostp, int *portp)\n{\n\tchar *user = NULL, *host = NULL, *path = NULL;\n\tint r, port;\n\n\tr = parse_uri(\"ssh\", uri, &user, &host, &port, &path);\n\tif (r == 0 && path != NULL)\n\t\tr = -1;\t\t \n\tif (r == 0) {\n\t\tif (userp != NULL) {\n\t\t\t*userp = user;\n\t\t\tuser = NULL;\n\t\t}\n\t\tif (hostp != NULL) {\n\t\t\t*hostp = host;\n\t\t\thost = NULL;\n\t\t}\n\t\tif (portp != NULL)\n\t\t\t*portp = port;\n\t}\n\tfree(user);\n\tfree(host);\n\tfree(path);\n\treturn r;\n}\n\n \nstatic const char *\nfmt_multistate_int(int val, const struct multistate *m)\n{\n\tu_int i;\n\n\tfor (i = 0; m[i].key != NULL; i++) {\n\t\tif (m[i].value == val)\n\t\t\treturn m[i].key;\n\t}\n\treturn \"UNKNOWN\";\n}\n\nstatic const char *\nfmt_intarg(OpCodes code, int val)\n{\n\tif (val == -1)\n\t\treturn \"unset\";\n\tswitch (code) {\n\tcase oAddressFamily:\n\t\treturn fmt_multistate_int(val, multistate_addressfamily);\n\tcase oVerifyHostKeyDNS:\n\tcase oUpdateHostkeys:\n\t\treturn fmt_multistate_int(val, multistate_yesnoask);\n\tcase oStrictHostKeyChecking:\n\t\treturn fmt_multistate_int(val, multistate_strict_hostkey);\n\tcase oControlMaster:\n\t\treturn fmt_multistate_int(val, multistate_controlmaster);\n\tcase oTunnel:\n\t\treturn fmt_multistate_int(val, multistate_tunnel);\n\tcase oRequestTTY:\n\t\treturn fmt_multistate_int(val, multistate_requesttty);\n\tcase oSessionType:\n\t\treturn fmt_multistate_int(val, multistate_sessiontype);\n\tcase oCanonicalizeHostname:\n\t\treturn fmt_multistate_int(val, multistate_canonicalizehostname);\n\tcase oAddKeysToAgent:\n\t\treturn fmt_multistate_int(val, multistate_yesnoaskconfirm);\n\tcase oPubkeyAuthentication:\n\t\treturn fmt_multistate_int(val, multistate_pubkey_auth);\n\tcase oFingerprintHash:\n\t\treturn ssh_digest_alg_name(val);\n\tdefault:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\treturn \"no\";\n\t\tcase 1:\n\t\t\treturn \"yes\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t\t}\n\t}\n}\n\nstatic const char *\nlookup_opcode_name(OpCodes code)\n{\n\tu_int i;\n\n\tfor (i = 0; keywords[i].name != NULL; i++)\n\t\tif (keywords[i].opcode == code)\n\t\t\treturn(keywords[i].name);\n\treturn \"UNKNOWN\";\n}\n\nstatic void\ndump_cfg_int(OpCodes code, int val)\n{\n\tif (code == oObscureKeystrokeTiming) {\n\t\tif (val == 0) {\n\t\t\tprintf(\"%s no\\n\", lookup_opcode_name(code));\n\t\t\treturn;\n\t\t} else if (val == SSH_KEYSTROKE_DEFAULT_INTERVAL_MS) {\n\t\t\tprintf(\"%s yes\\n\", lookup_opcode_name(code));\n\t\t\treturn;\n\t\t}\n\t\t \n\t}\n\tprintf(\"%s %d\\n\", lookup_opcode_name(code), val);\n}\n\nstatic void\ndump_cfg_fmtint(OpCodes code, int val)\n{\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), fmt_intarg(code, val));\n}\n\nstatic void\ndump_cfg_string(OpCodes code, const char *val)\n{\n\tif (val == NULL)\n\t\treturn;\n\tprintf(\"%s %s\\n\", lookup_opcode_name(code), val);\n}\n\nstatic void\ndump_cfg_strarray(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}\n\nstatic void\ndump_cfg_strarray_oneline(OpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tprintf(\"%s\", lookup_opcode_name(code));\n\tif (count == 0)\n\t\tprintf(\" none\");\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\" %s\",  vals[i]);\n\tprintf(\"\\n\");\n}\n\nstatic void\ndump_cfg_forwards(OpCodes code, u_int count, const struct Forward *fwds)\n{\n\tconst struct Forward *fwd;\n\tu_int i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tfwd = &fwds[i];\n\t\tif (code == oDynamicForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") != 0)\n\t\t\tcontinue;\n\t\tif (code == oLocalForward && fwd->connect_host != NULL &&\n\t\t    strcmp(fwd->connect_host, \"socks\") == 0)\n\t\t\tcontinue;\n\t\tprintf(\"%s\", lookup_opcode_name(code));\n\t\tif (fwd->listen_port == PORT_STREAMLOCAL)\n\t\t\tprintf(\" %s\", fwd->listen_path);\n\t\telse if (fwd->listen_host == NULL)\n\t\t\tprintf(\" %d\", fwd->listen_port);\n\t\telse {\n\t\t\tprintf(\" [%s]:%d\",\n\t\t\t    fwd->listen_host, fwd->listen_port);\n\t\t}\n\t\tif (code != oDynamicForward) {\n\t\t\tif (fwd->connect_port == PORT_STREAMLOCAL)\n\t\t\t\tprintf(\" %s\", fwd->connect_path);\n\t\t\telse if (fwd->connect_host == NULL)\n\t\t\t\tprintf(\" %d\", fwd->connect_port);\n\t\t\telse {\n\t\t\t\tprintf(\" [%s]:%d\",\n\t\t\t\t    fwd->connect_host, fwd->connect_port);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nvoid\ndump_client_config(Options *o, const char *host)\n{\n\tint i, r;\n\tchar buf[8], *all_key;\n\n\t \n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&o->hostkeyalgorithms, kex_default_pk_alg(),\n\t    all_key)) != 0)\n\t\tfatal_fr(r, \"expand HostKeyAlgorithms\");\n\tfree(all_key);\n\n\t \n\tdump_cfg_string(oHost, o->host_arg);\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostname, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t \n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif  \n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oSessionType, o->session_type);\n\tdump_cfg_fmtint(oStdinNull, o->stdin_null);\n\tdump_cfg_fmtint(oForkAfterAuthentication, o->fork_after_authentication);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\tdump_cfg_fmtint(oEnableEscapeCommandline, o->enable_escape_commandline);\n\n\t \n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\tdump_cfg_int(oRequiredRSASize, o->required_rsa_size);\n\tdump_cfg_int(oObscureKeystrokeTiming,\n\t    o->obscure_keystroke_timing_interval);\n\n\t \n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedAcceptedAlgorithms, o->hostbased_accepted_algos);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oSecurityKeyProvider, o->sk_provider);\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedAlgorithms, o->pubkey_accepted_algos);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\tdump_cfg_string(oKnownHostsCommand, o->known_hosts_command);\n\tdump_cfg_string(oTag, o->tag);\n\n\t \n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t \n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(oLogVerbose,\n\t    o->num_log_verbose, o->log_verbose);\n\tdump_cfg_strarray_oneline(oChannelTimeout,\n\t    o->num_channel_timeouts, o->channel_timeouts);\n\n\t \n\n\t \n\tif (o->num_permitted_remote_opens == 0)\n\t\tprintf(\"%s any\\n\", lookup_opcode_name(oPermitRemoteOpen));\n\telse\n\t\tdump_cfg_strarray_oneline(oPermitRemoteOpen,\n\t\t    o->num_permitted_remote_opens, o->permitted_remote_opens);\n\n\t \n\tif (o->add_keys_to_agent_lifespan <= 0)\n\t\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\telse {\n\t\tprintf(\"addkeystoagent%s %d\\n\",\n\t\t    o->add_keys_to_agent == 3 ? \" confirm\" : \"\",\n\t\t    o->add_keys_to_agent_lifespan);\n\t}\n\n\t \n\tif (o->forward_agent_sock_path == NULL)\n\t\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\telse\n\t\tdump_cfg_string(oForwardAgent, o->forward_agent_sock_path);\n\n\t \n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t \n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t \n\tprintf(\"canonicalizePermittedcnames\");\n\tif (o->num_permitted_cnames == 0)\n\t\tprintf(\" none\");\n\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t    o->permitted_cnames[i].target_list);\n\t}\n\tprintf(\"\\n\");\n\n\t \n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t \n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t \n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t \n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t \n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t \n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t \n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t \n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t     \n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t     \n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t     \n\t\t    i ? \"[\" : \"\",\n\t\t     \n\t\t    o->jump_host,\n\t\t     \n\t\t    i ? \"]\" : \"\",\n\t\t     \n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}