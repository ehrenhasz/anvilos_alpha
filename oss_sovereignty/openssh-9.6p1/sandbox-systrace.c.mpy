{
  "module_name": "sandbox-systrace.c",
  "hash_id": "d1037b340f6b409a226320929f6da1c98009303f735a5426a48d3fc518ebf2e5",
  "original_prompt": "Ingested from openssh-9.6p1/sandbox-systrace.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef SANDBOX_SYSTRACE\n\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#include <dev/systrace.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"atomicio.h\"\n#include \"log.h\"\n#include \"ssh-sandbox.h\"\n#include \"xmalloc.h\"\n\nstruct sandbox_policy {\n\tint syscall;\n\tint action;\n};\n\n \nstatic const struct sandbox_policy preauth_policy[] = {\n\t{ SYS_exit, SYSTR_POLICY_PERMIT },\n#ifdef SYS_kbind\n\t{ SYS_kbind, SYSTR_POLICY_PERMIT },\n#endif\n\n\t{ SYS_getpid, SYSTR_POLICY_PERMIT },\n\t{ SYS_getpgid, SYSTR_POLICY_PERMIT },\n\t{ SYS_clock_gettime, SYSTR_POLICY_PERMIT },\n\t{ SYS_gettimeofday, SYSTR_POLICY_PERMIT },\n\t{ SYS_nanosleep, SYSTR_POLICY_PERMIT },\n\t{ SYS_sigprocmask, SYSTR_POLICY_PERMIT },\n\n#ifdef SYS_getentropy\n\t \n\t{ SYS_getentropy, SYSTR_POLICY_PERMIT },\n#else\n\t \n\t{ SYS___sysctl, SYSTR_POLICY_PERMIT },\n#endif\n#ifdef SYS_sendsyslog\n\t{ SYS_sendsyslog, SYSTR_POLICY_PERMIT },\n#endif\n\n\t{ SYS_madvise, SYSTR_POLICY_PERMIT },\n\t{ SYS_mmap, SYSTR_POLICY_PERMIT },\n\t{ SYS_mprotect, SYSTR_POLICY_PERMIT },\n\t{ SYS_mquery, SYSTR_POLICY_PERMIT },\n\t{ SYS_munmap, SYSTR_POLICY_PERMIT },\n\n\t{ SYS_poll, SYSTR_POLICY_PERMIT },\n\t{ SYS_select, SYSTR_POLICY_PERMIT },\n\t{ SYS_read, SYSTR_POLICY_PERMIT },\n\t{ SYS_write, SYSTR_POLICY_PERMIT },\n\t{ SYS_shutdown, SYSTR_POLICY_PERMIT },\n\t{ SYS_close, SYSTR_POLICY_PERMIT },\n\n\t{ SYS_open, SYSTR_POLICY_NEVER },\n\n\t{ -1, -1 }\n};\n\nstruct ssh_sandbox {\n\tint systrace_fd;\n\tpid_t child_pid;\n\tvoid (*osigchld)(int);\n};\n\nstruct ssh_sandbox *\nssh_sandbox_init(struct monitor *monitor)\n{\n\tstruct ssh_sandbox *box;\n\n\tdebug3(\"%s: preparing systrace sandbox\", __func__);\n\tbox = xcalloc(1, sizeof(*box));\n\tbox->systrace_fd = -1;\n\tbox->child_pid = 0;\n\tbox->osigchld = ssh_signal(SIGCHLD, SIG_IGN);\n\n\treturn box;\n}\n\nvoid\nssh_sandbox_child(struct ssh_sandbox *box)\n{\n\tdebug3(\"%s: ready\", __func__);\n\tssh_signal(SIGCHLD, box->osigchld);\n\tif (kill(getpid(), SIGSTOP) != 0)\n\t\tfatal(\"%s: kill(%d, SIGSTOP)\", __func__, getpid());\n\tdebug3(\"%s: started\", __func__);\n}\n\nstatic void\nssh_sandbox_parent(struct ssh_sandbox *box, pid_t child_pid,\n    const struct sandbox_policy *allowed_syscalls)\n{\n\tint dev_systrace, i, j, found, status;\n\tpid_t pid;\n\tstruct systrace_policy policy;\n\n\t \n\tdebug3(\"%s: wait for child %ld\", __func__, (long)child_pid);\n\tdo {\n\t\tpid = waitpid(child_pid, &status, WUNTRACED);\n\t} while (pid == -1 && errno == EINTR);\n\tssh_signal(SIGCHLD, box->osigchld);\n\tif (!WIFSTOPPED(status)) {\n\t\tif (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: child terminated with signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (WIFEXITED(status))\n\t\t\tfatal(\"%s: child exited with status %d\",\n\t\t\t    __func__, WEXITSTATUS(status));\n\t\tfatal(\"%s: child not stopped\", __func__);\n\t}\n\tdebug3(\"%s: child %ld stopped\", __func__, (long)child_pid);\n\tbox->child_pid = child_pid;\n\n\t \n\tif ((dev_systrace = open(\"/dev/systrace\", O_RDONLY)) == -1)\n\t\tfatal(\"%s: open(\\\"/dev/systrace\\\"): %s\", __func__,\n\t\t    strerror(errno));\n\tif (ioctl(dev_systrace, STRIOCCLONE, &box->systrace_fd) == -1)\n\t\tfatal(\"%s: ioctl(STRIOCCLONE, %d): %s\", __func__,\n\t\t    dev_systrace, strerror(errno));\n\tclose(dev_systrace);\n\tdebug3(\"%s: systrace attach, fd=%d\", __func__, box->systrace_fd);\n\tif (ioctl(box->systrace_fd, STRIOCATTACH, &child_pid) == -1)\n\t\tfatal(\"%s: ioctl(%d, STRIOCATTACH, %d): %s\", __func__,\n\t\t    box->systrace_fd, child_pid, strerror(errno));\n\n\t \n\tmemset(&policy, 0, sizeof(policy));\n\tpolicy.strp_op = SYSTR_POLICY_NEW;\n\tpolicy.strp_maxents = SYS_MAXSYSCALL;\n\tif (ioctl(box->systrace_fd, STRIOCPOLICY, &policy) == -1)\n\t\tfatal(\"%s: ioctl(%d, STRIOCPOLICY (new)): %s\", __func__,\n\t\t    box->systrace_fd, strerror(errno));\n\n\tpolicy.strp_op = SYSTR_POLICY_ASSIGN;\n\tpolicy.strp_pid = box->child_pid;\n\tif (ioctl(box->systrace_fd, STRIOCPOLICY, &policy) == -1)\n\t\tfatal(\"%s: ioctl(%d, STRIOCPOLICY (assign)): %s\",\n\t\t    __func__, box->systrace_fd, strerror(errno));\n\n\t \n\tfor (i = 0; i < SYS_MAXSYSCALL; i++) {\n\t\tfound = 0;\n\t\tfor (j = 0; allowed_syscalls[j].syscall != -1; j++) {\n\t\t\tif (allowed_syscalls[j].syscall == i) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpolicy.strp_op = SYSTR_POLICY_MODIFY;\n\t\tpolicy.strp_code = i;\n\t\tpolicy.strp_policy = found ?\n\t\t    allowed_syscalls[j].action : SYSTR_POLICY_KILL;\n\t\tif (found)\n\t\t\tdebug3(\"%s: policy: enable syscall %d\", __func__, i);\n\t\tif (ioctl(box->systrace_fd, STRIOCPOLICY, &policy) == -1)\n\t\t\tfatal(\"%s: ioctl(%d, STRIOCPOLICY (modify)): %s\",\n\t\t\t    __func__, box->systrace_fd, strerror(errno));\n\t}\n\n\t \n\tdebug3(\"%s: start child %ld\", __func__, (long)child_pid);\n\tif (kill(box->child_pid, SIGCONT) != 0)\n\t\tfatal(\"%s: kill(%d, SIGCONT)\", __func__, box->child_pid);\n}\n\nvoid\nssh_sandbox_parent_finish(struct ssh_sandbox *box)\n{\n\t \n\tclose(box->systrace_fd);\n\n\tfree(box);\n\tdebug3(\"%s: finished\", __func__);\n}\n\nvoid\nssh_sandbox_parent_preauth(struct ssh_sandbox *box, pid_t child_pid)\n{\n\tssh_sandbox_parent(box, child_pid, preauth_policy);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}