{
  "module_name": "sftp-realpath.c",
  "hash_id": "bcd245bf56843f093f2604d8735bd298ef14b0fc58ab9680d7f0d0ccdf81f92c",
  "original_prompt": "Ingested from openssh-9.6p1/sftp-realpath.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#ifndef SYMLOOP_MAX\n# define SYMLOOP_MAX 32\n#endif\n\n \n\nchar *sftp_realpath(const char *path, char *resolved);\n\n \nchar *\nsftp_realpath(const char *path, char *resolved)\n{\n\tstruct stat sb;\n\tchar *p, *q, *s;\n\tsize_t left_len, resolved_len;\n\tunsigned symlinks;\n\tint serrno, slen, mem_allocated;\n\tchar left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];\n\n\tif (path[0] == '\\0') {\n\t\terrno = ENOENT;\n\t\treturn (NULL);\n\t}\n\n\tserrno = errno;\n\n\tif (resolved == NULL) {\n\t\tresolved = malloc(PATH_MAX);\n\t\tif (resolved == NULL)\n\t\t\treturn (NULL);\n\t\tmem_allocated = 1;\n\t} else\n\t\tmem_allocated = 0;\n\n\tsymlinks = 0;\n\tif (path[0] == '/') {\n\t\tresolved[0] = '/';\n\t\tresolved[1] = '\\0';\n\t\tif (path[1] == '\\0')\n\t\t\treturn (resolved);\n\t\tresolved_len = 1;\n\t\tleft_len = strlcpy(left, path + 1, sizeof(left));\n\t} else {\n\t\tif (getcwd(resolved, PATH_MAX) == NULL) {\n\t\t\tif (mem_allocated)\n\t\t\t\tfree(resolved);\n\t\t\telse\n\t\t\t\tstrlcpy(resolved, \".\", PATH_MAX);\n\t\t\treturn (NULL);\n\t\t}\n\t\tresolved_len = strlen(resolved);\n\t\tleft_len = strlcpy(left, path, sizeof(left));\n\t}\n\tif (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {\n\t\terrno = ENAMETOOLONG;\n\t\tgoto err;\n\t}\n\n\t \n\twhile (left_len != 0) {\n\t\t \n\t\tp = strchr(left, '/');\n\t\ts = p ? p : left + left_len;\n\t\tif (s - left >= (ptrdiff_t)sizeof(next_token)) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tmemcpy(next_token, left, s - left);\n\t\tnext_token[s - left] = '\\0';\n\t\tleft_len -= s - left;\n\t\tif (p != NULL)\n\t\t\tmemmove(left, s + 1, left_len + 1);\n\t\tif (resolved[resolved_len - 1] != '/') {\n\t\t\tif (resolved_len + 1 >= PATH_MAX) {\n\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tresolved[resolved_len++] = '/';\n\t\t\tresolved[resolved_len] = '\\0';\n\t\t}\n\t\tif (next_token[0] == '\\0')\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \".\") == 0)\n\t\t\tcontinue;\n\t\telse if (strcmp(next_token, \"..\") == 0) {\n\t\t\t \n\t\t\tif (resolved_len > 1) {\n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tresolved_len = strlcat(resolved, next_token, PATH_MAX);\n\t\tif (resolved_len >= PATH_MAX) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\tgoto err;\n\t\t}\n\t\tif (lstat(resolved, &sb) != 0) {\n\t\t\tif (errno == ENOENT && p == NULL) {\n\t\t\t\terrno = serrno;\n\t\t\t\treturn (resolved);\n\t\t\t}\n\t\t\tgoto err;\n\t\t}\n\t\tif (S_ISLNK(sb.st_mode)) {\n\t\t\tif (symlinks++ > SYMLOOP_MAX) {\n\t\t\t\terrno = ELOOP;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tslen = readlink(resolved, symlink, sizeof(symlink) - 1);\n\t\t\tif (slen < 0)\n\t\t\t\tgoto err;\n\t\t\tsymlink[slen] = '\\0';\n\t\t\tif (symlink[0] == '/') {\n\t\t\t\tresolved[1] = 0;\n\t\t\t\tresolved_len = 1;\n\t\t\t} else if (resolved_len > 1) {\n\t\t\t\t \n\t\t\t\tresolved[resolved_len - 1] = '\\0';\n\t\t\t\tq = strrchr(resolved, '/') + 1;\n\t\t\t\t*q = '\\0';\n\t\t\t\tresolved_len = q - resolved;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (p != NULL) {\n\t\t\t\tif (symlink[slen - 1] != '/') {\n\t\t\t\t\tif (slen + 1 >=\n\t\t\t\t\t    (ptrdiff_t)sizeof(symlink)) {\n\t\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\t\tsymlink[slen] = '/';\n\t\t\t\t\tsymlink[slen + 1] = 0;\n\t\t\t\t}\n\t\t\t\tleft_len = strlcat(symlink, left, sizeof(symlink));\n\t\t\t\tif (left_len >= sizeof(symlink)) {\n\t\t\t\t\terrno = ENAMETOOLONG;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tleft_len = strlcpy(left, symlink, sizeof(left));\n\t\t}\n\t}\n\n\t \n\tif (resolved_len > 1 && resolved[resolved_len - 1] == '/')\n\t\tresolved[resolved_len - 1] = '\\0';\n\treturn (resolved);\n\nerr:\n\tif (mem_allocated)\n\t\tfree(resolved);\n\treturn (NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}