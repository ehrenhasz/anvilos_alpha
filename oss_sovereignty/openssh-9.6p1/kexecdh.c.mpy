{
  "module_name": "kexecdh.c",
  "hash_id": "a4caaebe8f70985d9640d2337acbcf36d309986c80e2d94d6eba2a06745a8688",
  "original_prompt": "Ingested from openssh-9.6p1/kexecdh.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#if defined(WITH_OPENSSL) && defined(OPENSSL_HAS_ECC)\n\n#include <sys/types.h>\n\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n\n#include <openssl/ecdh.h>\n\n#include \"sshkey.h\"\n#include \"kex.h\"\n#include \"sshbuf.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n\nstatic int\nkex_ecdh_dec_key_group(struct kex *, const struct sshbuf *, EC_KEY *key,\n    const EC_GROUP *, struct sshbuf **);\n\nint\nkex_ecdh_keypair(struct kex *kex)\n{\n\tEC_KEY *client_key = NULL;\n\tconst EC_GROUP *group;\n\tconst EC_POINT *public_key;\n\tstruct sshbuf *buf = NULL;\n\tint r;\n\n\tif ((client_key = EC_KEY_new_by_curve_name(kex->ec_nid)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(client_key) != 1) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tgroup = EC_KEY_get0_group(client_key);\n\tpublic_key = EC_KEY_get0_public_key(client_key);\n\n\tif ((buf = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_ec(buf, public_key, group)) != 0 ||\n\t    (r = sshbuf_get_u32(buf, NULL)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_KEXECDH\n\tfputs(\"client private key:\\n\", stderr);\n\tsshkey_dump_ec_key(client_key);\n#endif\n\tkex->ec_client_key = client_key;\n\tkex->ec_group = group;\n\tclient_key = NULL;\t \n\tkex->client_pub = buf;\n\tbuf = NULL;\n out:\n\tEC_KEY_free(client_key);\n\tsshbuf_free(buf);\n\treturn r;\n}\n\nint\nkex_ecdh_enc(struct kex *kex, const struct sshbuf *client_blob,\n    struct sshbuf **server_blobp, struct sshbuf **shared_secretp)\n{\n\tconst EC_GROUP *group;\n\tconst EC_POINT *pub_key;\n\tEC_KEY *server_key = NULL;\n\tstruct sshbuf *server_blob = NULL;\n\tint r;\n\n\t*server_blobp = NULL;\n\t*shared_secretp = NULL;\n\n\tif ((server_key = EC_KEY_new_by_curve_name(kex->ec_nid)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (EC_KEY_generate_key(server_key) != 1) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\tgroup = EC_KEY_get0_group(server_key);\n\n#ifdef DEBUG_KEXECDH\n\tfputs(\"server private key:\\n\", stderr);\n\tsshkey_dump_ec_key(server_key);\n#endif\n\tpub_key = EC_KEY_get0_public_key(server_key);\n\tif ((server_blob = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_ec(server_blob, pub_key, group)) != 0 ||\n\t    (r = sshbuf_get_u32(server_blob, NULL)) != 0)\n\t\tgoto out;\n\tif ((r = kex_ecdh_dec_key_group(kex, client_blob, server_key, group,\n\t    shared_secretp)) != 0)\n\t\tgoto out;\n\t*server_blobp = server_blob;\n\tserver_blob = NULL;\n out:\n\tEC_KEY_free(server_key);\n\tsshbuf_free(server_blob);\n\treturn r;\n}\n\nstatic int\nkex_ecdh_dec_key_group(struct kex *kex, const struct sshbuf *ec_blob,\n    EC_KEY *key, const EC_GROUP *group, struct sshbuf **shared_secretp)\n{\n\tstruct sshbuf *buf = NULL;\n\tBIGNUM *shared_secret = NULL;\n\tEC_POINT *dh_pub = NULL;\n\tu_char *kbuf = NULL;\n\tsize_t klen = 0;\n\tint r;\n\n\t*shared_secretp = NULL;\n\n\tif ((buf = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_stringb(buf, ec_blob)) != 0)\n\t\tgoto out;\n\tif ((dh_pub = EC_POINT_new(group)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_get_ec(buf, dh_pub, group)) != 0) {\n\t\tgoto out;\n\t}\n\tsshbuf_reset(buf);\n\n#ifdef DEBUG_KEXECDH\n\tfputs(\"public key:\\n\", stderr);\n\tsshkey_dump_ec_point(group, dh_pub);\n#endif\n\tif (sshkey_ec_validate_public(group, dh_pub) != 0) {\n\t\tr = SSH_ERR_MESSAGE_INCOMPLETE;\n\t\tgoto out;\n\t}\n\tklen = (EC_GROUP_get_degree(group) + 7) / 8;\n\tif ((kbuf = malloc(klen)) == NULL ||\n\t    (shared_secret = BN_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif (ECDH_compute_key(kbuf, klen, dh_pub, key, NULL) != (int)klen ||\n\t    BN_bin2bn(kbuf, klen, shared_secret) == NULL) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n#ifdef DEBUG_KEXECDH\n\tdump_digest(\"shared secret\", kbuf, klen);\n#endif\n\tif ((r = sshbuf_put_bignum2(buf, shared_secret)) != 0)\n\t\tgoto out;\n\t*shared_secretp = buf;\n\tbuf = NULL;\n out:\n\tEC_POINT_clear_free(dh_pub);\n\tBN_clear_free(shared_secret);\n\tfreezero(kbuf, klen);\n\tsshbuf_free(buf);\n\treturn r;\n}\n\nint\nkex_ecdh_dec(struct kex *kex, const struct sshbuf *server_blob,\n    struct sshbuf **shared_secretp)\n{\n\tint r;\n\n\tr = kex_ecdh_dec_key_group(kex, server_blob, kex->ec_client_key,\n\t    kex->ec_group, shared_secretp);\n\tEC_KEY_free(kex->ec_client_key);\n\tkex->ec_client_key = NULL;\n\treturn r;\n}\n\n#else\n\n#include \"ssherr.h\"\n\nstruct kex;\nstruct sshbuf;\nstruct sshkey;\n\nint\nkex_ecdh_keypair(struct kex *kex)\n{\n\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}\n\nint\nkex_ecdh_enc(struct kex *kex, const struct sshbuf *client_blob,\n    struct sshbuf **server_blobp, struct sshbuf **shared_secretp)\n{\n\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}\n\nint\nkex_ecdh_dec(struct kex *kex, const struct sshbuf *server_blob,\n    struct sshbuf **shared_secretp)\n{\n\treturn SSH_ERR_SIGN_ALG_UNSUPPORTED;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}