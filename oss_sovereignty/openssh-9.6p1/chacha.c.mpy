{
  "module_name": "chacha.c",
  "hash_id": "97b6b3370711598e1cf2c768ba9af5414e57743262aed303630f139721b5a75f",
  "original_prompt": "Ingested from openssh-9.6p1/chacha.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include \"chacha.h\"\n\ntypedef unsigned char u8;\ntypedef unsigned int u32;\n\ntypedef struct chacha_ctx chacha_ctx;\n\n#define U8C(v) (v##U)\n#define U32C(v) (v##U)\n\n#define U8V(v) ((u8)(v) & U8C(0xFF))\n#define U32V(v) ((u32)(v) & U32C(0xFFFFFFFF))\n\n#define ROTL32(v, n) \\\n  (U32V((v) << (n)) | ((v) >> (32 - (n))))\n\n#define U8TO32_LITTLE(p) \\\n  (((u32)((p)[0])      ) | \\\n   ((u32)((p)[1]) <<  8) | \\\n   ((u32)((p)[2]) << 16) | \\\n   ((u32)((p)[3]) << 24))\n\n#define U32TO8_LITTLE(p, v) \\\n  do { \\\n    (p)[0] = U8V((v)      ); \\\n    (p)[1] = U8V((v) >>  8); \\\n    (p)[2] = U8V((v) >> 16); \\\n    (p)[3] = U8V((v) >> 24); \\\n  } while (0)\n\n#define ROTATE(v,c) (ROTL32(v,c))\n#define XOR(v,w) ((v) ^ (w))\n#define PLUS(v,w) (U32V((v) + (w)))\n#define PLUSONE(v) (PLUS((v),1))\n\n#define QUARTERROUND(a,b,c,d) \\\n  a = PLUS(a,b); d = ROTATE(XOR(d,a),16); \\\n  c = PLUS(c,d); b = ROTATE(XOR(b,c),12); \\\n  a = PLUS(a,b); d = ROTATE(XOR(d,a), 8); \\\n  c = PLUS(c,d); b = ROTATE(XOR(b,c), 7);\n\nstatic const char sigma[16] = \"expand 32-byte k\";\nstatic const char tau[16] = \"expand 16-byte k\";\n\nvoid\nchacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits)\n{\n  const char *constants;\n\n  x->input[4] = U8TO32_LITTLE(k + 0);\n  x->input[5] = U8TO32_LITTLE(k + 4);\n  x->input[6] = U8TO32_LITTLE(k + 8);\n  x->input[7] = U8TO32_LITTLE(k + 12);\n  if (kbits == 256) {  \n    k += 16;\n    constants = sigma;\n  } else {  \n    constants = tau;\n  }\n  x->input[8] = U8TO32_LITTLE(k + 0);\n  x->input[9] = U8TO32_LITTLE(k + 4);\n  x->input[10] = U8TO32_LITTLE(k + 8);\n  x->input[11] = U8TO32_LITTLE(k + 12);\n  x->input[0] = U8TO32_LITTLE(constants + 0);\n  x->input[1] = U8TO32_LITTLE(constants + 4);\n  x->input[2] = U8TO32_LITTLE(constants + 8);\n  x->input[3] = U8TO32_LITTLE(constants + 12);\n}\n\nvoid\nchacha_ivsetup(chacha_ctx *x, const u8 *iv, const u8 *counter)\n{\n  x->input[12] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 0);\n  x->input[13] = counter == NULL ? 0 : U8TO32_LITTLE(counter + 4);\n  x->input[14] = U8TO32_LITTLE(iv + 0);\n  x->input[15] = U8TO32_LITTLE(iv + 4);\n}\n\nvoid\nchacha_encrypt_bytes(chacha_ctx *x,const u8 *m,u8 *c,u32 bytes)\n{\n  u32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n  u32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n  u8 *ctarget = NULL;\n  u8 tmp[64];\n  u_int i;\n\n  if (!bytes) return;\n\n  j0 = x->input[0];\n  j1 = x->input[1];\n  j2 = x->input[2];\n  j3 = x->input[3];\n  j4 = x->input[4];\n  j5 = x->input[5];\n  j6 = x->input[6];\n  j7 = x->input[7];\n  j8 = x->input[8];\n  j9 = x->input[9];\n  j10 = x->input[10];\n  j11 = x->input[11];\n  j12 = x->input[12];\n  j13 = x->input[13];\n  j14 = x->input[14];\n  j15 = x->input[15];\n\n  for (;;) {\n    if (bytes < 64) {\n      for (i = 0;i < bytes;++i) tmp[i] = m[i];\n      m = tmp;\n      ctarget = c;\n      c = tmp;\n    }\n    x0 = j0;\n    x1 = j1;\n    x2 = j2;\n    x3 = j3;\n    x4 = j4;\n    x5 = j5;\n    x6 = j6;\n    x7 = j7;\n    x8 = j8;\n    x9 = j9;\n    x10 = j10;\n    x11 = j11;\n    x12 = j12;\n    x13 = j13;\n    x14 = j14;\n    x15 = j15;\n    for (i = 20;i > 0;i -= 2) {\n      QUARTERROUND( x0, x4, x8,x12)\n      QUARTERROUND( x1, x5, x9,x13)\n      QUARTERROUND( x2, x6,x10,x14)\n      QUARTERROUND( x3, x7,x11,x15)\n      QUARTERROUND( x0, x5,x10,x15)\n      QUARTERROUND( x1, x6,x11,x12)\n      QUARTERROUND( x2, x7, x8,x13)\n      QUARTERROUND( x3, x4, x9,x14)\n    }\n    x0 = PLUS(x0,j0);\n    x1 = PLUS(x1,j1);\n    x2 = PLUS(x2,j2);\n    x3 = PLUS(x3,j3);\n    x4 = PLUS(x4,j4);\n    x5 = PLUS(x5,j5);\n    x6 = PLUS(x6,j6);\n    x7 = PLUS(x7,j7);\n    x8 = PLUS(x8,j8);\n    x9 = PLUS(x9,j9);\n    x10 = PLUS(x10,j10);\n    x11 = PLUS(x11,j11);\n    x12 = PLUS(x12,j12);\n    x13 = PLUS(x13,j13);\n    x14 = PLUS(x14,j14);\n    x15 = PLUS(x15,j15);\n\n    x0 = XOR(x0,U8TO32_LITTLE(m + 0));\n    x1 = XOR(x1,U8TO32_LITTLE(m + 4));\n    x2 = XOR(x2,U8TO32_LITTLE(m + 8));\n    x3 = XOR(x3,U8TO32_LITTLE(m + 12));\n    x4 = XOR(x4,U8TO32_LITTLE(m + 16));\n    x5 = XOR(x5,U8TO32_LITTLE(m + 20));\n    x6 = XOR(x6,U8TO32_LITTLE(m + 24));\n    x7 = XOR(x7,U8TO32_LITTLE(m + 28));\n    x8 = XOR(x8,U8TO32_LITTLE(m + 32));\n    x9 = XOR(x9,U8TO32_LITTLE(m + 36));\n    x10 = XOR(x10,U8TO32_LITTLE(m + 40));\n    x11 = XOR(x11,U8TO32_LITTLE(m + 44));\n    x12 = XOR(x12,U8TO32_LITTLE(m + 48));\n    x13 = XOR(x13,U8TO32_LITTLE(m + 52));\n    x14 = XOR(x14,U8TO32_LITTLE(m + 56));\n    x15 = XOR(x15,U8TO32_LITTLE(m + 60));\n\n    j12 = PLUSONE(j12);\n    if (!j12) {\n      j13 = PLUSONE(j13);\n       \n    }\n\n    U32TO8_LITTLE(c + 0,x0);\n    U32TO8_LITTLE(c + 4,x1);\n    U32TO8_LITTLE(c + 8,x2);\n    U32TO8_LITTLE(c + 12,x3);\n    U32TO8_LITTLE(c + 16,x4);\n    U32TO8_LITTLE(c + 20,x5);\n    U32TO8_LITTLE(c + 24,x6);\n    U32TO8_LITTLE(c + 28,x7);\n    U32TO8_LITTLE(c + 32,x8);\n    U32TO8_LITTLE(c + 36,x9);\n    U32TO8_LITTLE(c + 40,x10);\n    U32TO8_LITTLE(c + 44,x11);\n    U32TO8_LITTLE(c + 48,x12);\n    U32TO8_LITTLE(c + 52,x13);\n    U32TO8_LITTLE(c + 56,x14);\n    U32TO8_LITTLE(c + 60,x15);\n\n    if (bytes <= 64) {\n      if (bytes < 64) {\n        for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n      }\n      x->input[12] = j12;\n      x->input[13] = j13;\n      return;\n    }\n    bytes -= 64;\n    c += 64;\n    m += 64;\n  }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}