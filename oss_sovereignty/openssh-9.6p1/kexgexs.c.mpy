{
  "module_name": "kexgexs.c",
  "hash_id": "5d2380e3750a8f8782c1e0f9391e7f823188c479db0343b9269187cc5523c834",
  "original_prompt": "Ingested from openssh-9.6p1/kexgexs.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#ifdef WITH_OPENSSL\n\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n\n#include <openssl/dh.h>\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n#include \"log.h\"\n#include \"packet.h\"\n#include \"dh.h\"\n#include \"ssh2.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"dispatch.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n\nstatic int input_kex_dh_gex_request(int, u_int32_t, struct ssh *);\nstatic int input_kex_dh_gex_init(int, u_int32_t, struct ssh *);\n\nint\nkexgex_server(struct ssh *ssh)\n{\n\tssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST,\n\t    &input_kex_dh_gex_request);\n\tdebug(\"expecting SSH2_MSG_KEX_DH_GEX_REQUEST\");\n\treturn 0;\n}\n\nstatic int\ninput_kex_dh_gex_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\tu_int min = 0, max = 0, nbits = 0;\n\tconst BIGNUM *dh_p, *dh_g;\n\n\tdebug(\"SSH2_MSG_KEX_DH_GEX_REQUEST received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_REQUEST, &kex_protocol_error);\n\n\tif ((r = sshpkt_get_u32(ssh, &min)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &nbits)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &max)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tkex->nbits = nbits;\n\tkex->min = min;\n\tkex->max = max;\n\tmin = MAXIMUM(DH_GRP_MIN, min);\n\tmax = MINIMUM(DH_GRP_MAX, max);\n\tnbits = MAXIMUM(DH_GRP_MIN, nbits);\n\tnbits = MINIMUM(DH_GRP_MAX, nbits);\n\n\tif (kex->max < kex->min || kex->nbits < kex->min ||\n\t    kex->max < kex->nbits || kex->max < DH_GRP_MIN) {\n\t\tr = SSH_ERR_DH_GEX_OUT_OF_RANGE;\n\t\tgoto out;\n\t}\n\n\t \n\tkex->dh = PRIVSEP(choose_dh(min, nbits, max));\n\tif (kex->dh == NULL) {\n\t\t(void)sshpkt_disconnect(ssh, \"no matching DH grp found\");\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tdebug(\"SSH2_MSG_KEX_DH_GEX_GROUP sent\");\n\tDH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_GROUP)) != 0 ||\n\t    (r = sshpkt_put_bignum2(ssh, dh_p)) != 0 ||\n\t    (r = sshpkt_put_bignum2(ssh, dh_g)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0)\n\t\tgoto out;\n\n\tdebug(\"expecting SSH2_MSG_KEX_DH_GEX_INIT\");\n\tssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_INIT, &input_kex_dh_gex_init);\n\tr = 0;\n out:\n\treturn r;\n}\n\nstatic int\ninput_kex_dh_gex_init(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tBIGNUM *dh_client_pub = NULL;\n\tconst BIGNUM *pub_key, *dh_p, *dh_g;\n\tstruct sshbuf *shared_secret = NULL;\n\tstruct sshbuf *server_host_key_blob = NULL;\n\tstruct sshkey *server_host_public, *server_host_private;\n\tu_char *signature = NULL;\n\tu_char hash[SSH_DIGEST_MAX_LENGTH];\n\tsize_t slen, hashlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_KEX_DH_GEX_INIT received\");\n\tssh_dispatch_set(ssh, SSH2_MSG_KEX_DH_GEX_INIT, &kex_protocol_error);\n\n\tif ((r = kex_load_hostkey(ssh, &server_host_private,\n\t    &server_host_public)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshpkt_get_bignum2(ssh, &dh_client_pub)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\tif ((shared_secret = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = kex_dh_compute_key(kex, dh_client_pub, shared_secret)) != 0)\n\t\tgoto out;\n\tif ((server_host_key_blob = sshbuf_new()) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_putb(server_host_public, server_host_key_blob)) != 0)\n\t\tgoto out;\n\n\t \n\tDH_get0_key(kex->dh, &pub_key, NULL);\n\tDH_get0_pqg(kex->dh, &dh_p, NULL, &dh_g);\n\thashlen = sizeof(hash);\n\tif ((r = kexgex_hash(\n\t    kex->hash_alg,\n\t    kex->client_version,\n\t    kex->server_version,\n\t    kex->peer,\n\t    kex->my,\n\t    server_host_key_blob,\n\t    kex->min, kex->nbits, kex->max,\n\t    dh_p, dh_g,\n\t    dh_client_pub,\n\t    pub_key,\n\t    sshbuf_ptr(shared_secret), sshbuf_len(shared_secret),\n\t    hash, &hashlen)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((r = kex->sign(ssh, server_host_private, server_host_public,\n\t    &signature, &slen, hash, hashlen, kex->hostkey_alg)) < 0)\n\t\tgoto out;\n\n\t \n\tif ((r = sshpkt_start(ssh, SSH2_MSG_KEX_DH_GEX_REPLY)) != 0 ||\n\t    (r = sshpkt_put_stringb(ssh, server_host_key_blob)) != 0 ||\n\t    (r = sshpkt_put_bignum2(ssh, pub_key)) != 0 ||      \n\t    (r = sshpkt_put_string(ssh, signature, slen)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tgoto out;\n\n\tif ((r = kex_derive_keys(ssh, hash, hashlen, shared_secret)) != 0 ||\n\t    (r = kex_send_newkeys(ssh)) != 0)\n\t\tgoto out;\n\n\t \n\tif (kex->initial_hostkey == NULL &&\n\t    (r = sshkey_from_private(server_host_public,\n\t    &kex->initial_hostkey)) != 0)\n\t\tgoto out;\n\t \n out:\n\texplicit_bzero(hash, sizeof(hash));\n\tDH_free(kex->dh);\n\tkex->dh = NULL;\n\tBN_clear_free(dh_client_pub);\n\tsshbuf_free(shared_secret);\n\tsshbuf_free(server_host_key_blob);\n\tfree(signature);\n\treturn r;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}