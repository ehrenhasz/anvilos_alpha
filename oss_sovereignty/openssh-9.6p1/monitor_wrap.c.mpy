{
  "module_name": "monitor_wrap.c",
  "hash_id": "5ed8d751edcc2f36b4a67e63822c0eb93bd156403f73f181f40fa8d1a13959e4",
  "original_prompt": "Ingested from openssh-9.6p1/monitor_wrap.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/uio.h>\n\n#include <errno.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n#include <openssl/evp.h>\n#endif\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#ifdef WITH_OPENSSL\n#include \"dh.h\"\n#endif\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#include \"kex.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n#include \"packet.h\"\n#include \"mac.h\"\n#include \"log.h\"\n#include \"auth-pam.h\"\n#include \"monitor.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"atomicio.h\"\n#include \"monitor_fdpass.h\"\n#include \"misc.h\"\n\n#include \"channels.h\"\n#include \"session.h\"\n#include \"servconf.h\"\n\n#include \"ssherr.h\"\n\n \nextern struct monitor *pmonitor;\nextern struct sshbuf *loginmsg;\nextern ServerOptions options;\n\nvoid\nmm_log_handler(LogLevel level, int forced, const char *msg, void *ctx)\n{\n\tstruct sshbuf *log_msg;\n\tstruct monitor *mon = (struct monitor *)ctx;\n\tint r;\n\tsize_t len;\n\n\tif (mon->m_log_sendfd == -1)\n\t\tfatal_f(\"no log channel\");\n\n\tif ((log_msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tif ((r = sshbuf_put_u32(log_msg, 0)) != 0 ||  \n\t    (r = sshbuf_put_u32(log_msg, level)) != 0 ||\n\t    (r = sshbuf_put_u32(log_msg, forced)) != 0 ||\n\t    (r = sshbuf_put_cstring(log_msg, msg)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tif ((len = sshbuf_len(log_msg)) < 4 || len > 0xffffffff)\n\t\tfatal_f(\"bad length %zu\", len);\n\tPOKE_U32(sshbuf_mutable_ptr(log_msg), len - 4);\n\tif (atomicio(vwrite, mon->m_log_sendfd,\n\t    sshbuf_mutable_ptr(log_msg), len) != len)\n\t\tfatal_f(\"write: %s\", strerror(errno));\n\tsshbuf_free(log_msg);\n}\n\nint\nmm_is_monitor(void)\n{\n\t \n\treturn (pmonitor && pmonitor->m_pid > 0);\n}\n\nvoid\nmm_request_send(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tsize_t mlen = sshbuf_len(m);\n\tu_char buf[5];\n\n\tdebug3_f(\"entering, type %d\", type);\n\n\tif (mlen >= 0xffffffff)\n\t\tfatal_f(\"bad length %zu\", mlen);\n\tPOKE_U32(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t \n\tif (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal_f(\"write: %s\", strerror(errno));\n\tif (atomicio(vwrite, sock, sshbuf_mutable_ptr(m), mlen) != mlen)\n\t\tfatal_f(\"write: %s\", strerror(errno));\n}\n\nvoid\nmm_request_receive(int sock, struct sshbuf *m)\n{\n\tu_char buf[4], *p = NULL;\n\tu_int msg_len;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {\n\t\tif (errno == EPIPE)\n\t\t\tcleanup_exit(255);\n\t\tfatal_f(\"read: %s\", strerror(errno));\n\t}\n\tmsg_len = PEEK_U32(buf);\n\tif (msg_len > 256 * 1024)\n\t\tfatal_f(\"read: bad msg_len %d\", msg_len);\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_reserve(m, msg_len, &p)) != 0)\n\t\tfatal_fr(r, \"reserve\");\n\tif (atomicio(read, sock, p, msg_len) != msg_len)\n\t\tfatal_f(\"read: %s\", strerror(errno));\n}\n\nvoid\nmm_request_receive_expect(int sock, enum monitor_reqtype type, struct sshbuf *m)\n{\n\tu_char rtype;\n\tint r;\n\n\tdebug3_f(\"entering, type %d\", type);\n\n\tmm_request_receive(sock, m);\n\tif ((r = sshbuf_get_u8(m, &rtype)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (rtype != type)\n\t\tfatal_f(\"read: rtype %d != type %d\", rtype, type);\n}\n\n#ifdef WITH_OPENSSL\nDH *\nmm_choose_dh(int min, int nbits, int max)\n{\n\tBIGNUM *p, *g;\n\tint r;\n\tu_char success = 0;\n\tstruct sshbuf *m;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u32(m, min)) != 0 ||\n\t    (r = sshbuf_put_u32(m, nbits)) != 0 ||\n\t    (r = sshbuf_put_u32(m, max)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_MODULI, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_MODULI\");\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_MODULI, m);\n\n\tif ((r = sshbuf_get_u8(m, &success)) != 0)\n\t\tfatal_fr(r, \"parse success\");\n\tif (success == 0)\n\t\tfatal_f(\"MONITOR_ANS_MODULI failed\");\n\n\tif ((r = sshbuf_get_bignum2(m, &p)) != 0 ||\n\t    (r = sshbuf_get_bignum2(m, &g)) != 0)\n\t\tfatal_fr(r, \"parse group\");\n\n\tdebug3_f(\"remaining %zu\", sshbuf_len(m));\n\tsshbuf_free(m);\n\n\treturn (dh_new_group(g, p));\n}\n#endif\n\nint\nmm_sshkey_sign(struct ssh *ssh, struct sshkey *key, u_char **sigp, size_t *lenp,\n    const u_char *data, size_t datalen, const char *hostkey_alg,\n    const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\tstruct kex *kex = *pmonitor->m_pkex;\n\tstruct sshbuf *m;\n\tu_int ndx = kex->host_key_index(key, 0, ssh);\n\tint r;\n\n\tdebug3_f(\"entering\");\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u32(m, ndx)) != 0 ||\n\t    (r = sshbuf_put_string(m, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, hostkey_alg)) != 0 ||\n\t    (r = sshbuf_put_u32(m, compat)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SIGN, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_SIGN\");\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SIGN, m);\n\tif ((r = sshbuf_get_string(m, sigp, lenp)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsshbuf_free(m);\n\n\treturn (0);\n}\n\n#define GETPW(b, id) \\\n\tdo { \\\n\t\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0) \\\n\t\t\tfatal_fr(r, \"parse pw %s\", #id); \\\n\t\tif (len != sizeof(pw->id)) \\\n\t\t\tfatal_fr(r, \"bad length for %s\", #id); \\\n\t\tmemcpy(&pw->id, p, len); \\\n\t} while (0)\n\nstruct passwd *\nmm_getpwnamallow(struct ssh *ssh, const char *username)\n{\n\tstruct sshbuf *m;\n\tstruct passwd *pw;\n\tsize_t len;\n\tu_int i;\n\tServerOptions *newopts;\n\tint r;\n\tu_char ok;\n\tconst u_char *p;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_cstring(m, username)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PWNAM, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_PWNAM\");\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PWNAM, m);\n\n\tif ((r = sshbuf_get_u8(m, &ok)) != 0)\n\t\tfatal_fr(r, \"parse success\");\n\tif (ok == 0) {\n\t\tpw = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tpw = xcalloc(sizeof(*pw), 1);\n\tGETPW(m, pw_uid);\n\tGETPW(m, pw_gid);\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tGETPW(m, pw_change);\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tGETPW(m, pw_expire);\n#endif\n\tif ((r = sshbuf_get_cstring(m, &pw->pw_name, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &pw->pw_passwd, NULL)) != 0 ||\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\t    (r = sshbuf_get_cstring(m, &pw->pw_gecos, NULL)) != 0 ||\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\t    (r = sshbuf_get_cstring(m, &pw->pw_class, NULL)) != 0 ||\n#endif\n\t    (r = sshbuf_get_cstring(m, &pw->pw_dir, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &pw->pw_shell, NULL)) != 0)\n\t\tfatal_fr(r, \"parse pw\");\n\nout:\n\t \n\tif ((r = sshbuf_get_string_direct(m, &p, &len)) != 0)\n\t\tfatal_fr(r, \"parse opts\");\n\tif (len != sizeof(*newopts))\n\t\tfatal_f(\"option block size mismatch\");\n\tnewopts = xcalloc(sizeof(*newopts), 1);\n\tmemcpy(newopts, p, sizeof(*newopts));\n\n#define M_CP_STROPT(x) do { \\\n\t\tif (newopts->x != NULL && \\\n\t\t    (r = sshbuf_get_cstring(m, &newopts->x, NULL)) != 0) \\\n\t\t\tfatal_fr(r, \"parse %s\", #x); \\\n\t} while (0)\n#define M_CP_STRARRAYOPT(x, nx) do { \\\n\t\tnewopts->x = newopts->nx == 0 ? \\\n\t\t    NULL : xcalloc(newopts->nx, sizeof(*newopts->x)); \\\n\t\tfor (i = 0; i < newopts->nx; i++) { \\\n\t\t\tif ((r = sshbuf_get_cstring(m, \\\n\t\t\t    &newopts->x[i], NULL)) != 0) \\\n\t\t\t\tfatal_fr(r, \"parse %s\", #x); \\\n\t\t} \\\n\t} while (0)\n\t \n\tCOPY_MATCH_STRING_OPTS();\n#undef M_CP_STROPT\n#undef M_CP_STRARRAYOPT\n\n\tcopy_set_server_options(&options, newopts, 1);\n\tlog_change_level(options.log_level);\n\tlog_verbose_reset();\n\tfor (i = 0; i < options.num_log_verbose; i++)\n\t\tlog_verbose_add(options.log_verbose[i]);\n\tprocess_permitopen(ssh, &options);\n\tprocess_channel_timeouts(ssh, &options);\n\tkex_set_server_sig_algs(ssh, options.pubkey_accepted_algos);\n\tfree(newopts);\n\tsshbuf_free(m);\n\n\treturn (pw);\n}\n\nchar *\nmm_auth2_read_banner(void)\n{\n\tstruct sshbuf *m;\n\tchar *banner;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTH2_READ_BANNER, m);\n\tsshbuf_reset(m);\n\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_AUTH2_READ_BANNER, m);\n\tif ((r = sshbuf_get_cstring(m, &banner, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsshbuf_free(m);\n\n\t \n\tif (strlen(banner) == 0) {\n\t\tfree(banner);\n\t\tbanner = NULL;\n\t}\n\treturn (banner);\n}\n\n \n\nvoid\nmm_inform_authserv(char *service, char *style)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_cstring(m, service)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, style ? style : \"\")) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHSERV, m);\n\n\tsshbuf_free(m);\n}\n\n \nint\nmm_auth_password(struct ssh *ssh, char *password)\n{\n\tstruct sshbuf *m;\n\tint r, authenticated = 0;\n#ifdef USE_PAM\n\tu_int maxtries = 0;\n#endif\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_cstring(m, password)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTHPASSWORD, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_AUTHPASSWORD\");\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_AUTHPASSWORD, m);\n\n\tif ((r = sshbuf_get_u32(m, &authenticated)) != 0)\n\t\tfatal_fr(r, \"parse\");\n#ifdef USE_PAM\n\tif ((r = sshbuf_get_u32(m, &maxtries)) != 0)\n\t\tfatal_fr(r, \"parse PAM\");\n\tif (maxtries > INT_MAX)\n\t\tfatal_fr(r, \"bad maxtries\");\n\tsshpam_set_maxtries_reached(maxtries);\n#endif\n\n\tsshbuf_free(m);\n\n\tdebug3_f(\"user %sauthenticated\", authenticated ? \"\" : \"not \");\n\treturn (authenticated);\n}\n\nint\nmm_user_key_allowed(struct ssh *ssh, struct passwd *pw, struct sshkey *key,\n    int pubkey_auth_attempt, struct sshauthopt **authoptp)\n{\n\treturn (mm_key_allowed(MM_USERKEY, NULL, NULL, key,\n\t    pubkey_auth_attempt, authoptp));\n}\n\nint\nmm_hostbased_key_allowed(struct ssh *ssh, struct passwd *pw,\n    const char *user, const char *host, struct sshkey *key)\n{\n\treturn (mm_key_allowed(MM_HOSTKEY, user, host, key, 0, NULL));\n}\n\nint\nmm_key_allowed(enum mm_keytype type, const char *user, const char *host,\n    struct sshkey *key, int pubkey_auth_attempt, struct sshauthopt **authoptp)\n{\n\tstruct sshbuf *m;\n\tint r, allowed = 0;\n\tstruct sshauthopt *opts = NULL;\n\n\tdebug3_f(\"entering\");\n\n\tif (authoptp != NULL)\n\t\t*authoptp = NULL;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u32(m, type)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, user ? user : \"\")) != 0 ||\n\t    (r = sshbuf_put_cstring(m, host ? host : \"\")) != 0 ||\n\t    (r = sshkey_puts(key, m)) != 0 ||\n\t    (r = sshbuf_put_u32(m, pubkey_auth_attempt)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYALLOWED, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_KEYALLOWED\");\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_KEYALLOWED, m);\n\n\tif ((r = sshbuf_get_u32(m, &allowed)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (allowed && type == MM_USERKEY &&\n\t    (r = sshauthopt_deserialise(m, &opts)) != 0)\n\t\tfatal_fr(r, \"sshauthopt_deserialise\");\n\tsshbuf_free(m);\n\n\tif (authoptp != NULL) {\n\t\t*authoptp = opts;\n\t\topts = NULL;\n\t}\n\tsshauthopt_free(opts);\n\n\treturn allowed;\n}\n\n \n\nint\nmm_sshkey_verify(const struct sshkey *key, const u_char *sig, size_t siglen,\n    const u_char *data, size_t datalen, const char *sigalg, u_int compat,\n    struct sshkey_sig_details **sig_detailsp)\n{\n\tstruct sshbuf *m;\n\tu_int encoded_ret = 0;\n\tint r;\n\tu_char sig_details_present, flags;\n\tu_int counter;\n\n\tdebug3_f(\"entering\");\n\n\tif (sig_detailsp != NULL)\n\t\t*sig_detailsp = NULL;\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshkey_puts(key, m)) != 0 ||\n\t    (r = sshbuf_put_string(m, sig, siglen)) != 0 ||\n\t    (r = sshbuf_put_string(m, data, datalen)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, sigalg == NULL ? \"\" : sigalg)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KEYVERIFY, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_KEYVERIFY\");\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_KEYVERIFY, m);\n\n\tif ((r = sshbuf_get_u32(m, &encoded_ret)) != 0 ||\n\t    (r = sshbuf_get_u8(m, &sig_details_present)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (sig_details_present && encoded_ret == 0) {\n\t\tif ((r = sshbuf_get_u32(m, &counter)) != 0 ||\n\t\t    (r = sshbuf_get_u8(m, &flags)) != 0)\n\t\t\tfatal_fr(r, \"parse sig_details\");\n\t\tif (sig_detailsp != NULL) {\n\t\t\t*sig_detailsp = xcalloc(1, sizeof(**sig_detailsp));\n\t\t\t(*sig_detailsp)->sk_counter = counter;\n\t\t\t(*sig_detailsp)->sk_flags = flags;\n\t\t}\n\t}\n\n\tsshbuf_free(m);\n\n\tif (encoded_ret != 0)\n\t\treturn SSH_ERR_SIGNATURE_INVALID;\n\treturn 0;\n}\n\nvoid\nmm_send_keystate(struct ssh *ssh, struct monitor *monitor)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = ssh_packet_get_state(ssh, m)) != 0)\n\t\tfatal_fr(r, \"ssh_packet_get_state\");\n\tmm_request_send(monitor->m_recvfd, MONITOR_REQ_KEYEXPORT, m);\n\tdebug3_f(\"Finished sending state\");\n\tsshbuf_free(m);\n}\n\nint\nmm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n{\n\tstruct sshbuf *m;\n\tchar *p, *msg;\n\tint success = 0, tmp1 = -1, tmp2 = -1, r;\n\n\t \n\tif ((tmp1 = dup(pmonitor->m_recvfd)) == -1 ||\n\t    (tmp2 = dup(pmonitor->m_recvfd)) == -1) {\n\t\terror_f(\"cannot allocate fds for pty\");\n\t\tif (tmp1 >= 0)\n\t\t\tclose(tmp1);\n\t\treturn 0;\n\t}\n\tclose(tmp1);\n\tclose(tmp2);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PTY, m);\n\n\tdebug3_f(\"waiting for MONITOR_ANS_PTY\");\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PTY, m);\n\n\tif ((r = sshbuf_get_u32(m, &success)) != 0)\n\t\tfatal_fr(r, \"parse success\");\n\tif (success == 0) {\n\t\tdebug3_f(\"pty alloc failed\");\n\t\tsshbuf_free(m);\n\t\treturn (0);\n\t}\n\tif ((r = sshbuf_get_cstring(m, &p, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &msg, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsshbuf_free(m);\n\n\tstrlcpy(namebuf, p, namebuflen);  \n\tfree(p);\n\n\tif ((r = sshbuf_put(loginmsg, msg, strlen(msg))) != 0)\n\t\tfatal_fr(r, \"put loginmsg\");\n\tfree(msg);\n\n\tif ((*ptyfd = mm_receive_fd(pmonitor->m_recvfd)) == -1 ||\n\t    (*ttyfd = mm_receive_fd(pmonitor->m_recvfd)) == -1)\n\t\tfatal_f(\"receive fds failed\");\n\n\t \n\treturn (1);\n}\n\nvoid\nmm_session_pty_cleanup2(Session *s)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tif (s->ttyfd == -1)\n\t\treturn;\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_cstring(m, s->tty)) != 0)\n\t\tfatal_fr(r, \"assmble\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PTYCLEANUP, m);\n\tsshbuf_free(m);\n\n\t \n\tif (s->ptymaster != -1 && close(s->ptymaster) == -1)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t \n\ts->ttyfd = -1;\n}\n\n#ifdef USE_PAM\nvoid\nmm_start_pam(struct ssh *ssh)\n{\n\tstruct sshbuf *m;\n\n\tdebug3(\"%s entering\", __func__);\n\tif (!options.use_pam)\n\t\tfatal(\"UsePAM=no, but ended up in %s anyway\", __func__);\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_START, m);\n\n\tsshbuf_free(m);\n}\n\nu_int\nmm_do_pam_account(void)\n{\n\tstruct sshbuf *m;\n\tu_int ret;\n\tchar *msg;\n\tsize_t msglen;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\tif (!options.use_pam)\n\t\tfatal(\"UsePAM=no, but ended up in %s anyway\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_ACCOUNT, m);\n\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_PAM_ACCOUNT, m);\n\tif ((r = sshbuf_get_u32(m, &ret)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &msg, &msglen)) != 0 ||\n\t    (r = sshbuf_put(loginmsg, msg, msglen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tfree(msg);\n\tsshbuf_free(m);\n\n\tdebug3(\"%s returning %d\", __func__, ret);\n\n\treturn (ret);\n}\n\nvoid *\nmm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tstruct sshbuf *m;\n\tint r, success;\n\n\tdebug3(\"%s\", __func__);\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_PAM_INIT_CTX, m);\n\tif ((r = sshbuf_get_u32(m, &success)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tsshbuf_free(m);\n\t\treturn (NULL);\n\t}\n\tsshbuf_free(m);\n\treturn (authctxt);\n}\n\nint\nmm_sshpam_query(void *ctx, char **name, char **info,\n    u_int *num, char ***prompts, u_int **echo_on)\n{\n\tstruct sshbuf *m;\n\tu_int i, n;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_QUERY, m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_QUERY\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_QUERY, m);\n\tif ((r = sshbuf_get_u32(m, &ret)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, name, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, info, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &n)) != 0 ||\n\t    (r = sshbuf_get_u32(m, num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"%s: pam_query returned %d\", __func__, ret);\n\tsshpam_set_maxtries_reached(n);\n\tif (*num > PAM_MAX_NUM_MSG)\n\t\tfatal(\"%s: received %u PAM messages, expected <= %u\",\n\t\t    __func__, *num, PAM_MAX_NUM_MSG);\n\t*prompts = xcalloc((*num + 1), sizeof(char *));\n\t*echo_on = xcalloc((*num + 1), sizeof(u_int));\n\tfor (i = 0; i < *num; ++i) {\n\t\tif ((r = sshbuf_get_cstring(m, &((*prompts)[i]), NULL)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &((*echo_on)[i]))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tsshbuf_free(m);\n\treturn (ret);\n}\n\nint\nmm_sshpam_respond(void *ctx, u_int num, char **resp)\n{\n\tstruct sshbuf *m;\n\tu_int n, i;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u32(m, num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfor (i = 0; i < num; ++i) {\n\t\tif ((r = sshbuf_put_cstring(m, resp[i])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_RESPOND, m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_RESPOND\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_PAM_RESPOND, m);\n\tif ((r = sshbuf_get_u32(m, &n)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tret = (int)n;  \n\tdebug3(\"%s: pam_respond returned %d\", __func__, ret);\n\tsshbuf_free(m);\n\treturn (ret);\n}\n\nvoid\nmm_sshpam_free_ctx(void *ctxtp)\n{\n\tstruct sshbuf *m;\n\n\tdebug3(\"%s\", __func__);\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_FREE_CTX, m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_FREE_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_PAM_FREE_CTX, m);\n\tsshbuf_free(m);\n}\n#endif  \n\n \n\nvoid\nmm_terminate(void)\n{\n\tstruct sshbuf *m;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_TERM, m);\n\tsshbuf_free(m);\n}\n\nstatic void\nmm_chall_setup(char **name, char **infotxt, u_int *numprompts,\n    char ***prompts, u_int **echo_on)\n{\n\t*name = xstrdup(\"\");\n\t*infotxt = xstrdup(\"\");\n\t*numprompts = 1;\n\t*prompts = xcalloc(*numprompts, sizeof(char *));\n\t*echo_on = xcalloc(*numprompts, sizeof(u_int));\n\t(*echo_on)[0] = 0;\n}\n\nint\nmm_bsdauth_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tstruct sshbuf *m;\n\tu_int success;\n\tchar *challenge;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_BSDAUTHQUERY, m);\n\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_BSDAUTHQUERY, m);\n\tif ((r = sshbuf_get_u32(m, &success)) != 0)\n\t\tfatal_fr(r, \"parse success\");\n\tif (success == 0) {\n\t\tdebug3_f(\"no challenge\");\n\t\tsshbuf_free(m);\n\t\treturn (-1);\n\t}\n\n\t \n\tif ((r = sshbuf_get_cstring(m, &challenge, NULL)) != 0)\n\t\tfatal_fr(r, \"parse challenge\");\n\tsshbuf_free(m);\n\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\t(*prompts)[0] = challenge;\n\n\tdebug3_f(\"received challenge: %s\", challenge);\n\n\treturn (0);\n}\n\nint\nmm_bsdauth_respond(void *ctx, u_int numresponses, char **responses)\n{\n\tstruct sshbuf *m;\n\tint r, authok;\n\n\tdebug3_f(\"entering\");\n\tif (numresponses != 1)\n\t\treturn (-1);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_cstring(m, responses[0])) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_BSDAUTHRESPOND, m);\n\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_BSDAUTHRESPOND, m);\n\n\tif ((r = sshbuf_get_u32(m, &authok)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsshbuf_free(m);\n\n\treturn ((authok == 0) ? -1 : 0);\n}\n\n#ifdef SSH_AUDIT_EVENTS\nvoid\nmm_audit_event(struct ssh *ssh, ssh_audit_event_t event)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u32(m, event)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUDIT_EVENT, m);\n\tsshbuf_free(m);\n}\n\nvoid\nmm_audit_run_command(const char *command)\n{\n\tstruct sshbuf *m;\n\tint r;\n\n\tdebug3(\"%s entering command %s\", __func__, command);\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_cstring(m, command)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUDIT_COMMAND, m);\n\tsshbuf_free(m);\n}\n#endif  \n\n#ifdef GSSAPI\nOM_uint32\nmm_ssh_gssapi_server_ctx(Gssctxt **ctx, gss_OID goid)\n{\n\tstruct sshbuf *m;\n\tOM_uint32 major;\n\tint r;\n\n\t \n\t*ctx = NULL;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_string(m, goid->elements, goid->length)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSETUP, m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSETUP, m);\n\n\tif ((r = sshbuf_get_u32(m, &major)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tsshbuf_free(m);\n\treturn (major);\n}\n\nOM_uint32\nmm_ssh_gssapi_accept_ctx(Gssctxt *ctx, gss_buffer_desc *in,\n    gss_buffer_desc *out, OM_uint32 *flagsp)\n{\n\tstruct sshbuf *m;\n\tOM_uint32 major;\n\tu_int flags;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_string(m, in->value, in->length)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSSTEP, m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_GSSSTEP, m);\n\n\tif ((r = sshbuf_get_u32(m, &major)) != 0 ||\n\t    (r = ssh_gssapi_get_buffer_desc(m, out)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (flagsp != NULL) {\n\t\tif ((r = sshbuf_get_u32(m, &flags)) != 0)\n\t\t\tfatal_fr(r, \"parse flags\");\n\t\t*flagsp = flags;\n\t}\n\n\tsshbuf_free(m);\n\n\treturn (major);\n}\n\nOM_uint32\nmm_ssh_gssapi_checkmic(Gssctxt *ctx, gss_buffer_t gssbuf, gss_buffer_t gssmic)\n{\n\tstruct sshbuf *m;\n\tOM_uint32 major;\n\tint r;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_string(m, gssbuf->value, gssbuf->length)) != 0 ||\n\t    (r = sshbuf_put_string(m, gssmic->value, gssmic->length)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSCHECKMIC, m);\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_GSSCHECKMIC, m);\n\n\tif ((r = sshbuf_get_u32(m, &major)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tsshbuf_free(m);\n\treturn(major);\n}\n\nint\nmm_ssh_gssapi_userok(char *user)\n{\n\tstruct sshbuf *m;\n\tint r, authenticated = 0;\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_GSSUSEROK, m);\n\tmm_request_receive_expect(pmonitor->m_recvfd,\n\t    MONITOR_ANS_GSSUSEROK, m);\n\n\tif ((r = sshbuf_get_u32(m, &authenticated)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tsshbuf_free(m);\n\tdebug3_f(\"user %sauthenticated\", authenticated ? \"\" : \"not \");\n\treturn (authenticated);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}