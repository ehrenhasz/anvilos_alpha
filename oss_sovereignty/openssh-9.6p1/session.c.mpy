{
  "module_name": "session.c",
  "hash_id": "c0597cdf66c6f3a9a2712c700a0bd1b8df94c0634b92d545d0b6a2a5819c609e",
  "original_prompt": "Ingested from openssh-9.6p1/session.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#include <arpa/inet.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"sshpty.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n#include \"uidswap.h\"\n#include \"channels.h\"\n#include \"sshkey.h\"\n#include \"cipher.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n#include \"authfd.h\"\n#include \"pathnames.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"sshlogin.h\"\n#include \"serverloop.h\"\n#include \"canohost.h\"\n#include \"session.h\"\n#include \"kex.h\"\n#include \"monitor_wrap.h\"\n#include \"sftp.h\"\n#include \"atomicio.h\"\n\n#if defined(KRB5) && defined(USE_AFS)\n#include <kafs.h>\n#endif\n\n#ifdef WITH_SELINUX\n#include <selinux/selinux.h>\n#endif\n\n#define IS_INTERNAL_SFTP(c) \\\n\t(!strncmp(c, INTERNAL_SFTP_NAME, sizeof(INTERNAL_SFTP_NAME) - 1) && \\\n\t (c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\\0' || \\\n\t  c[sizeof(INTERNAL_SFTP_NAME) - 1] == ' ' || \\\n\t  c[sizeof(INTERNAL_SFTP_NAME) - 1] == '\\t'))\n\n \n\nSession *session_new(void);\nvoid\tsession_set_fds(struct ssh *, Session *, int, int, int, int, int);\nvoid\tsession_pty_cleanup(Session *);\nvoid\tsession_proctitle(Session *);\nint\tsession_setup_x11fwd(struct ssh *, Session *);\nint\tdo_exec_pty(struct ssh *, Session *, const char *);\nint\tdo_exec_no_pty(struct ssh *, Session *, const char *);\nint\tdo_exec(struct ssh *, Session *, const char *);\nvoid\tdo_login(struct ssh *, Session *, const char *);\nvoid\tdo_child(struct ssh *, Session *, const char *);\nvoid\tdo_motd(void);\nint\tcheck_quietlogin(Session *, const char *);\n\nstatic void do_authenticated2(struct ssh *, Authctxt *);\n\nstatic int session_pty_req(struct ssh *, Session *);\n\n \nextern ServerOptions options;\nextern char *__progname;\nextern int debug_flag;\nextern u_int utmp_len;\nextern int startup_pipe;\nextern void destroy_sensitive_data(void);\nextern struct sshbuf *loginmsg;\nextern struct sshauthopt *auth_opts;\nextern char *tun_fwd_ifnames;  \n\n \nconst char *original_command = NULL;\n\n \nstatic int sessions_first_unused = -1;\nstatic int sessions_nalloc = 0;\nstatic Session *sessions = NULL;\n\n#define SUBSYSTEM_NONE\t\t\t0\n#define SUBSYSTEM_EXT\t\t\t1\n#define SUBSYSTEM_INT_SFTP\t\t2\n#define SUBSYSTEM_INT_SFTP_ERROR\t3\n\n#ifdef HAVE_LOGIN_CAP\nlogin_cap_t *lc;\n#endif\n\nstatic int is_child = 0;\nstatic int in_chroot = 0;\n\n \nstatic char *auth_info_file = NULL;\n\n \nstatic char *auth_sock_name = NULL;\nstatic char *auth_sock_dir = NULL;\n\n \n\nstatic void\nauth_sock_cleanup_proc(struct passwd *pw)\n{\n\tif (auth_sock_name != NULL) {\n\t\ttemporarily_use_uid(pw);\n\t\tunlink(auth_sock_name);\n\t\trmdir(auth_sock_dir);\n\t\tauth_sock_name = NULL;\n\t\trestore_uid();\n\t}\n}\n\nstatic int\nauth_input_request_forwarding(struct ssh *ssh, struct passwd * pw)\n{\n\tChannel *nc;\n\tint sock = -1;\n\n\tif (auth_sock_name != NULL) {\n\t\terror(\"authentication forwarding requested twice.\");\n\t\treturn 0;\n\t}\n\n\t \n\ttemporarily_use_uid(pw);\n\n\t \n\tauth_sock_dir = xstrdup(\"/tmp/ssh-XXXXXXXXXX\");\n\n\t \n\tif (mkdtemp(auth_sock_dir) == NULL) {\n\t\tssh_packet_send_debug(ssh, \"Agent forwarding disabled: \"\n\t\t    \"mkdtemp() failed: %.100s\", strerror(errno));\n\t\trestore_uid();\n\t\tfree(auth_sock_dir);\n\t\tauth_sock_dir = NULL;\n\t\tgoto authsock_err;\n\t}\n\n\txasprintf(&auth_sock_name, \"%s/agent.%ld\",\n\t    auth_sock_dir, (long) getpid());\n\n\t \n\tsock = unix_listener(auth_sock_name, SSH_LISTEN_BACKLOG, 0);\n\n\t \n\trestore_uid();\n\n\t \n\tif (sock < 0)\n\t\tgoto authsock_err;\n\n\t \n\tnc = channel_new(ssh, \"auth-listener\",\n\t    SSH_CHANNEL_AUTH_SOCKET, sock, sock, -1,\n\t    CHAN_X11_WINDOW_DEFAULT, CHAN_X11_PACKET_DEFAULT,\n\t    0, \"auth socket\", 1);\n\tnc->path = xstrdup(auth_sock_name);\n\treturn 1;\n\n authsock_err:\n\tfree(auth_sock_name);\n\tif (auth_sock_dir != NULL) {\n\t\ttemporarily_use_uid(pw);\n\t\trmdir(auth_sock_dir);\n\t\trestore_uid();\n\t\tfree(auth_sock_dir);\n\t}\n\tif (sock != -1)\n\t\tclose(sock);\n\tauth_sock_name = NULL;\n\tauth_sock_dir = NULL;\n\treturn 0;\n}\n\nstatic void\ndisplay_loginmsg(void)\n{\n\tint r;\n\n\tif (sshbuf_len(loginmsg) == 0)\n\t\treturn;\n\tif ((r = sshbuf_put_u8(loginmsg, 0)) != 0)\n\t\tfatal_fr(r, \"sshbuf_put_u8\");\n\tprintf(\"%s\", (char *)sshbuf_ptr(loginmsg));\n\tsshbuf_reset(loginmsg);\n}\n\nstatic void\nprepare_auth_info_file(struct passwd *pw, struct sshbuf *info)\n{\n\tint fd = -1, success = 0;\n\n\tif (!options.expose_userauth_info || info == NULL)\n\t\treturn;\n\n\ttemporarily_use_uid(pw);\n\tauth_info_file = xstrdup(\"/tmp/sshauth.XXXXXXXXXXXXXXX\");\n\tif ((fd = mkstemp(auth_info_file)) == -1) {\n\t\terror_f(\"mkstemp: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (atomicio(vwrite, fd, sshbuf_mutable_ptr(info),\n\t    sshbuf_len(info)) != sshbuf_len(info)) {\n\t\terror_f(\"write: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tif (close(fd) != 0) {\n\t\terror_f(\"close: %s\", strerror(errno));\n\t\tgoto out;\n\t}\n\tsuccess = 1;\n out:\n\tif (!success) {\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\trestore_uid();\n}\n\nstatic void\nset_fwdpermit_from_authopts(struct ssh *ssh, const struct sshauthopt *opts)\n{\n\tchar *tmp, *cp, *host;\n\tint port;\n\tsize_t i;\n\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_LOCAL);\n\t\tfor (i = 0; i < auth_opts->npermitopen; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitopen[i]);\n\t\t\t \n\t\t\tif ((host = hpdelim2(&cp, NULL)) == NULL)\n\t\t\t\tfatal_f(\"internal error: hpdelim\");\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal_f(\"internal error: permitopen port\");\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_LOCAL, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) != 0) {\n\t\tchannel_clear_permission(ssh, FORWARD_USER, FORWARD_REMOTE);\n\t\tfor (i = 0; i < auth_opts->npermitlisten; i++) {\n\t\t\ttmp = cp = xstrdup(auth_opts->permitlisten[i]);\n\t\t\t \n\t\t\tif ((host = hpdelim(&cp)) == NULL)\n\t\t\t\tfatal_f(\"internal error: hpdelim\");\n\t\t\thost = cleanhostname(host);\n\t\t\tif (cp == NULL || (port = permitopen_port(cp)) < 0)\n\t\t\t\tfatal_f(\"internal error: permitlisten port\");\n\t\t\tchannel_add_permission(ssh,\n\t\t\t    FORWARD_USER, FORWARD_REMOTE, host, port);\n\t\t\tfree(tmp);\n\t\t}\n\t}\n}\n\nvoid\ndo_authenticated(struct ssh *ssh, Authctxt *authctxt)\n{\n\tsetproctitle(\"%s\", authctxt->pw->pw_name);\n\n\tauth_log_authopts(\"active\", auth_opts, 0);\n\n\t \n\t \n\tset_fwdpermit_from_authopts(ssh, auth_opts);\n\n\tif (!auth_opts->permit_port_forwarding_flag ||\n\t    options.disable_forwarding) {\n\t\tchannel_disable_admin(ssh, FORWARD_LOCAL);\n\t\tchannel_disable_admin(ssh, FORWARD_REMOTE);\n\t} else {\n\t\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) == 0)\n\t\t\tchannel_disable_admin(ssh, FORWARD_LOCAL);\n\t\telse\n\t\t\tchannel_permit_all(ssh, FORWARD_LOCAL);\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0)\n\t\t\tchannel_disable_admin(ssh, FORWARD_REMOTE);\n\t\telse\n\t\t\tchannel_permit_all(ssh, FORWARD_REMOTE);\n\t}\n\tauth_debug_send(ssh);\n\n\tprepare_auth_info_file(authctxt->pw, authctxt->session_info);\n\n\tdo_authenticated2(ssh, authctxt);\n\n\tdo_cleanup(ssh, authctxt);\n}\n\n \nstatic int\nxauth_valid_string(const char *s)\n{\n\tsize_t i;\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (!isalnum((u_char)s[i]) &&\n\t\t    s[i] != '.' && s[i] != ':' && s[i] != '/' &&\n\t\t    s[i] != '-' && s[i] != '_')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n#define USE_PIPES 1\n \nint\ndo_exec_no_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tpid_t pid;\n#ifdef USE_PIPES\n\tint pin[2], pout[2], perr[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t \n\tif (pipe(pin) == -1) {\n\t\terror_f(\"pipe in: %.100s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (pipe(pout) == -1) {\n\t\terror_f(\"pipe out: %.100s\", strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\treturn -1;\n\t}\n\tif (pipe(perr) == -1) {\n\t\terror_f(\"pipe err: %.100s\", strerror(errno));\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\treturn -1;\n\t}\n#else\n\tint inout[2], err[2];\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_no_pty: no session\");\n\n\t \n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1) {\n\t\terror_f(\"socketpair #1: %.100s\", strerror(errno));\n\t\treturn -1;\n\t}\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, err) == -1) {\n\t\terror_f(\"socketpair #2: %.100s\", strerror(errno));\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\treturn -1;\n\t}\n#endif\n\n\tsession_proctitle(s);\n\n\t \n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror_f(\"fork: %.100s\", strerror(errno));\n#ifdef USE_PIPES\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n#else\n\t\tclose(inout[0]);\n\t\tclose(inout[1]);\n\t\tclose(err[0]);\n\t\tclose(err[1]);\n#endif\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\t \n\t\tif (setsid() == -1)\n\t\t\terror(\"setsid failed: %.100s\", strerror(errno));\n\n#ifdef USE_PIPES\n\t\t \n\t\tclose(pin[1]);\n\t\tif (dup2(pin[0], 0) == -1)\n\t\t\tperror(\"dup2 stdin\");\n\t\tclose(pin[0]);\n\n\t\t \n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) == -1)\n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(pout[1]);\n\n\t\t \n\t\tclose(perr[0]);\n\t\tif (dup2(perr[1], 2) == -1)\n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(perr[1]);\n#else\n\t\t \n\t\tclose(inout[1]);\n\t\tclose(err[1]);\n\t\tif (dup2(inout[0], 0) == -1)\t \n\t\t\tperror(\"dup2 stdin\");\n\t\tif (dup2(inout[0], 1) == -1)\t \n\t\t\tperror(\"dup2 stdout\");\n\t\tclose(inout[0]);\n\t\tif (dup2(err[0], 2) == -1)\t \n\t\t\tperror(\"dup2 stderr\");\n\t\tclose(err[0]);\n#endif\n\n\t\t \n\t\tdo_child(ssh, s, command);\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\t \n\tssh_packet_set_interactive(ssh, s->display != NULL,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\t \n\tsshbuf_reset(loginmsg);\n\n#ifdef USE_PIPES\n\t \n\tclose(pin[0]);\n\tclose(pout[1]);\n\tclose(perr[1]);\n\n\tsession_set_fds(ssh, s, pin[1], pout[0], perr[0],\n\t    s->is_subsystem, 0);\n#else\n\t \n\tclose(inout[0]);\n\tclose(err[0]);\n\n\t \n\tsession_set_fds(ssh, s, inout[1], inout[1], err[1],\n\t    s->is_subsystem, 0);\n#endif\n\treturn 0;\n}\n\n \nint\ndo_exec_pty(struct ssh *ssh, Session *s, const char *command)\n{\n\tint fdout, ptyfd, ttyfd, ptymaster;\n\tpid_t pid;\n\n\tif (s == NULL)\n\t\tfatal(\"do_exec_pty: no session\");\n\tptyfd = s->ptyfd;\n\tttyfd = s->ttyfd;\n\n\t \n\tif ((fdout = dup(ptyfd)) == -1) {\n\t\terror_f(\"dup #1: %s\", strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\t}\n\t \n\tif ((ptymaster = dup(ptyfd)) == -1) {\n\t\terror_f(\"dup #2: %s\", strerror(errno));\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\tclose(fdout);\n\t\treturn -1;\n\t}\n\n\t \n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\terror_f(\"fork: %.100s\", strerror(errno));\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\t\tclose(ttyfd);\n\t\tclose(ptyfd);\n\t\treturn -1;\n\tcase 0:\n\t\tis_child = 1;\n\n\t\tclose(fdout);\n\t\tclose(ptymaster);\n\n\t\t \n\t\tclose(ptyfd);\n\n\t\t \n\t\tpty_make_controlling_tty(&ttyfd, s->tty);\n\n\t\t \n\t\tif (dup2(ttyfd, 0) == -1)\n\t\t\terror(\"dup2 stdin: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 1) == -1)\n\t\t\terror(\"dup2 stdout: %s\", strerror(errno));\n\t\tif (dup2(ttyfd, 2) == -1)\n\t\t\terror(\"dup2 stderr: %s\", strerror(errno));\n\n\t\t \n\t\tclose(ttyfd);\n\n\t\t \n#ifndef HAVE_OSF_SIA\n\t\tdo_login(ssh, s, command);\n#endif\n\t\t \n\t\tdo_child(ssh, s, command);\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef HAVE_CYGWIN\n\tcygwin_set_impersonation_token(INVALID_HANDLE_VALUE);\n#endif\n\n\ts->pid = pid;\n\n\t \n\tclose(ttyfd);\n\n\t \n\ts->ptymaster = ptymaster;\n\tssh_packet_set_interactive(ssh, 1,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\tsession_set_fds(ssh, s, ptyfd, fdout, -1, 1, 1);\n\treturn 0;\n}\n\n \nint\ndo_exec(struct ssh *ssh, Session *s, const char *command)\n{\n\tint ret;\n\tconst char *forced = NULL, *tty = NULL;\n\tchar session_type[1024];\n\n\tif (options.adm_forced_command) {\n\t\toriginal_command = command;\n\t\tcommand = options.adm_forced_command;\n\t\tforced = \"(config)\";\n\t} else if (auth_opts->force_command != NULL) {\n\t\toriginal_command = command;\n\t\tcommand = auth_opts->force_command;\n\t\tforced = \"(key-option)\";\n\t}\n\ts->forced = 0;\n\tif (forced != NULL) {\n\t\ts->forced = 1;\n\t\tif (IS_INTERNAL_SFTP(command)) {\n\t\t\ts->is_subsystem = s->is_subsystem ?\n\t\t\t    SUBSYSTEM_INT_SFTP : SUBSYSTEM_INT_SFTP_ERROR;\n\t\t} else if (s->is_subsystem)\n\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"forced-command %s '%.900s'\", forced, command);\n\t} else if (s->is_subsystem) {\n\t\tsnprintf(session_type, sizeof(session_type),\n\t\t    \"subsystem '%.900s'\", s->subsys);\n\t} else if (command == NULL) {\n\t\tsnprintf(session_type, sizeof(session_type), \"shell\");\n\t} else {\n\t\t \n\t\tsnprintf(session_type, sizeof(session_type), \"command\");\n\t}\n\n\tif (s->ttyfd != -1) {\n\t\ttty = s->tty;\n\t\tif (strncmp(tty, \"/dev/\", 5) == 0)\n\t\t\ttty += 5;\n\t}\n\n\tverbose(\"Starting session: %s%s%s for %s from %.200s port %d id %d\",\n\t    session_type,\n\t    tty == NULL ? \"\" : \" on \",\n\t    tty == NULL ? \"\" : tty,\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n#ifdef SSH_AUDIT_EVENTS\n\tif (command != NULL)\n\t\tPRIVSEP(audit_run_command(command));\n\telse if (s->ttyfd == -1) {\n\t\tchar *shell = s->pw->pw_shell;\n\n\t\tif (shell[0] == '\\0')\t \n\t\t\tshell =_PATH_BSHELL;\n\t\tPRIVSEP(audit_run_command(shell));\n\t}\n#endif\n\tif (s->ttyfd != -1)\n\t\tret = do_exec_pty(ssh, s, command);\n\telse\n\t\tret = do_exec_no_pty(ssh, s, command);\n\n\toriginal_command = NULL;\n\n\t \n\tsshbuf_reset(loginmsg);\n\n\treturn ret;\n}\n\n \nvoid\ndo_login(struct ssh *ssh, Session *s, const char *command)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\tstruct passwd * pw = s->pw;\n\tpid_t pid = getpid();\n\n\t \n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t\t    (struct sockaddr *)&from, &fromlen) == -1) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\t \n\tif (!use_privsep)\n\t\trecord_login(pid, s->tty, pw->pw_name, pw->pw_uid,\n\t\t    session_get_remote_name_or_ip(ssh, utmp_len,\n\t\t    options.use_dns),\n\t\t    (struct sockaddr *)&from, fromlen);\n\n#ifdef USE_PAM\n\t \n\tif (options.use_pam && !use_privsep && s->authctxt->force_pwchange) {\n\t\tdisplay_loginmsg();\n\t\tdo_pam_chauthtok();\n\t\ts->authctxt->force_pwchange = 0;\n\t\t \n\t}\n#endif\n\n\tif (check_quietlogin(s, command))\n\t\treturn;\n\n\tdisplay_loginmsg();\n\n\tdo_motd();\n}\n\n \nvoid\ndo_motd(void)\n{\n\tFILE *f;\n\tchar buf[256];\n\n\tif (options.print_motd) {\n#ifdef HAVE_LOGIN_CAP\n\t\tf = fopen(login_getcapstr(lc, \"welcome\", \"/etc/motd\",\n\t\t    \"/etc/motd\"), \"r\");\n#else\n\t\tf = fopen(\"/etc/motd\", \"r\");\n#endif\n\t\tif (f) {\n\t\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\t\tfputs(buf, stdout);\n\t\t\tfclose(f);\n\t\t}\n\t}\n}\n\n\n \nint\ncheck_quietlogin(Session *s, const char *command)\n{\n\tchar buf[256];\n\tstruct passwd *pw = s->pw;\n\tstruct stat st;\n\n\t \n\tif (command != NULL)\n\t\treturn 1;\n\tsnprintf(buf, sizeof(buf), \"%.200s/.hushlogin\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"hushlogin\", 0) || stat(buf, &st) >= 0)\n\t\treturn 1;\n#else\n\tif (stat(buf, &st) >= 0)\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n \nstatic void\nread_environment_file(char ***env, u_int *envsize,\n\tconst char *filename, const char *allowlist)\n{\n\tFILE *f;\n\tchar *line = NULL, *cp, *value;\n\tsize_t linesize = 0;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (getline(&line, &linesize, f) != -1) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = line; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tif (allowlist != NULL &&\n\t\t    match_pattern_list(cp, allowlist, 0) != 1)\n\t\t\tcontinue;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfree(line);\n\tfclose(f);\n}\n\n#ifdef HAVE_ETC_DEFAULT_LOGIN\n \nstatic char *\nchild_get_env(char **env, const char *name)\n{\n\tint i;\n\tsize_t len;\n\n\tlen = strlen(name);\n\tfor (i=0; env[i] != NULL; i++)\n\t\tif (strncmp(name, env[i], len) == 0 && env[i][len] == '=')\n\t\t\treturn(env[i] + len + 1);\n\treturn NULL;\n}\n\n \nstatic void\nread_etc_default_login(char ***env, u_int *envsize, uid_t uid)\n{\n\tchar **tmpenv = NULL, *var;\n\tu_int i, tmpenvsize = 0;\n\tu_long mask;\n\n\t \n\tread_environment_file(&tmpenv, &tmpenvsize, \"/etc/default/login\",\n\t    options.permit_user_env_allowlist);\n\n\tif (tmpenv == NULL)\n\t\treturn;\n\n\tif (uid == 0)\n\t\tvar = child_get_env(tmpenv, \"SUPATH\");\n\telse\n\t\tvar = child_get_env(tmpenv, \"PATH\");\n\tif (var != NULL)\n\t\tchild_set_env(env, envsize, \"PATH\", var);\n\n\tif ((var = child_get_env(tmpenv, \"UMASK\")) != NULL)\n\t\tif (sscanf(var, \"%5lo\", &mask) == 1)\n\t\t\tumask((mode_t)mask);\n\n\tfor (i = 0; tmpenv[i] != NULL; i++)\n\t\tfree(tmpenv[i]);\n\tfree(tmpenv);\n}\n#endif  \n\n#if defined(USE_PAM) || defined(HAVE_CYGWIN)\nstatic void\ncopy_environment_denylist(char **source, char ***env, u_int *envsize,\n    const char *denylist)\n{\n\tchar *var_name, *var_val;\n\tint i;\n\n\tif (source == NULL)\n\t\treturn;\n\n\tfor(i = 0; source[i] != NULL; i++) {\n\t\tvar_name = xstrdup(source[i]);\n\t\tif ((var_val = strstr(var_name, \"=\")) == NULL) {\n\t\t\tfree(var_name);\n\t\t\tcontinue;\n\t\t}\n\t\t*var_val++ = '\\0';\n\n\t\tif (denylist == NULL ||\n\t\t    match_pattern_list(var_name, denylist, 0) != 1) {\n\t\t\tdebug3(\"Copy environment: %s=%s\", var_name, var_val);\n\t\t\tchild_set_env(env, envsize, var_name, var_val);\n\t\t}\n\n\t\tfree(var_name);\n\t}\n}\n#endif  \n\n#ifdef HAVE_CYGWIN\nstatic void\ncopy_environment(char **source, char ***env, u_int *envsize)\n{\n\tcopy_environment_denylist(source, env, envsize, NULL);\n}\n#endif\n\nstatic char **\ndo_setup_env(struct ssh *ssh, Session *s, const char *shell)\n{\n\tchar buf[256];\n\tsize_t n;\n\tu_int i, envsize;\n\tchar *ocp, *cp, *value, **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t \n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t \n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t \n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\t \n\tfor (i = 0; i < s->num_env; i++)\n\t\tchild_set_env(&env, &envsize, s->env[i].name, s->env[i].val);\n\n\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\telse\n\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else  \n# ifndef HAVE_CYGWIN\n\t \n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\tpath = child_get_env(env, \"PATH\");\n#  endif  \n\tif (path == NULL || *path == '\\0') {\n\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t    s->pw->pw_uid == 0 ?  SUPERUSER_PATH : _PATH_STDPATH);\n\t}\n# endif  \n#endif  \n\n\tif (!options.use_pam) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\",\n\t\t    _PATH_MAILDIR, pw->pw_name);\n\t\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\t}\n\n\t \n\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\n\t \n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\",\n\t\t    options.permit_user_env_allowlist);\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\n\t \n\tif (options.permit_user_env) {\n\t\tfor (n = 0 ; n < auth_opts->nenv; n++) {\n\t\t\tocp = xstrdup(auth_opts->env[n]);\n\t\t\tcp = strchr(ocp, '=');\n\t\t\tif (cp != NULL) {\n\t\t\t\t*cp = '\\0';\n\t\t\t\t \n\t\t\t\tif (options.permit_user_env_allowlist == NULL ||\n\t\t\t\t    match_pattern_list(ocp,\n\t\t\t\t    options.permit_user_env_allowlist, 0) == 1)\n\t\t\t\t\tchild_set_env(&env, &envsize,\n\t\t\t\t\t    ocp, cp + 1);\n\t\t\t}\n\t\t\tfree(ocp);\n\t\t}\n\t}\n\n\t \n\tif (options.permit_user_env) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/%s/environment\",\n\t\t    pw->pw_dir, _PATH_SSH_USER_DIR);\n\t\tread_environment_file(&env, &envsize, buf,\n\t\t    options.permit_user_env_allowlist);\n\t}\n\n#ifdef USE_PAM\n\t \n\tif (options.use_pam) {\n\t\tchar **p;\n\n\t\t \n#define PAM_ENV_DENYLIST  \"SSH_AUTH_INFO*,SSH_CONNECTION*\"\n\t\tp = fetch_pam_child_environment();\n\t\tcopy_environment_denylist(p, &env, &envsize,\n\t\t    PAM_ENV_DENYLIST);\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment_denylist(p, &env, &envsize,\n\t\t    PAM_ENV_DENYLIST);\n\t\tfree_pam_environment(p);\n\t}\n#endif  \n\n\t \n\tfor (i = 0; i < options.num_setenv; i++) {\n\t\tcp = xstrdup(options.setenv[i]);\n\t\tif ((value = strchr(cp, '=')) == NULL) {\n\t\t\t \n\t\t\tfatal(\"Invalid config SetEnv: %s\", options.setenv[i]);\n\t\t}\n\t\t*value++ = '\\0';\n\t\tchild_set_env(&env, &envsize, cp, value);\n\t\tfree(cp);\n\t}\n\n\t \n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(ssh_packet_get_connection_in(ssh));\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (tun_fwd_ifnames != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_TUNNEL\", tun_fwd_ifnames);\n\tif (auth_info_file != NULL)\n\t\tchild_set_env(&env, &envsize, \"SSH_USER_AUTH\", auth_info_file);\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n\tif (debug_flag) {\n\t\t \n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}\n\n \nstatic void\ndo_rc_files(struct ssh *ssh, Session *s, const char *shell)\n{\n\tFILE *f = NULL;\n\tchar *cmd = NULL, *user_rc = NULL;\n\tint do_xauth;\n\tstruct stat st;\n\n\tdo_xauth =\n\t    s->display != NULL && s->auth_proto != NULL && s->auth_data != NULL;\n\txasprintf(&user_rc, \"%s/%s\", s->pw->pw_dir, _PATH_SSH_USER_RC);\n\n\t \n\tif (!s->is_subsystem && options.adm_forced_command == NULL &&\n\t    auth_opts->permit_user_rc && options.permit_user_rc &&\n\t    stat(user_rc, &st) >= 0) {\n\t\tif (xasprintf(&cmd, \"%s -c '%s %s'\", shell, _PATH_BSHELL,\n\t\t    user_rc) == -1)\n\t\t\tfatal_f(\"xasprintf: %s\", strerror(errno));\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s\\n\", cmd);\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    user_rc);\n\t} else if (stat(_PATH_SSH_SYSTEM_RC, &st) >= 0) {\n\t\tif (debug_flag)\n\t\t\tfprintf(stderr, \"Running %s %s\\n\", _PATH_BSHELL,\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t\tf = popen(_PATH_BSHELL \" \" _PATH_SSH_SYSTEM_RC, \"w\");\n\t\tif (f) {\n\t\t\tif (do_xauth)\n\t\t\t\tfprintf(f, \"%s %s\\n\", s->auth_proto,\n\t\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    _PATH_SSH_SYSTEM_RC);\n\t} else if (do_xauth && options.xauth_location != NULL) {\n\t\t \n\t\tif (debug_flag) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"Running %.500s remove %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display);\n\t\t\tfprintf(stderr,\n\t\t\t    \"%.500s add %.100s %.100s %.100s\\n\",\n\t\t\t    options.xauth_location, s->auth_display,\n\t\t\t    s->auth_proto, s->auth_data);\n\t\t}\n\t\tif (xasprintf(&cmd, \"%s -q -\", options.xauth_location) == -1)\n\t\t\tfatal_f(\"xasprintf: %s\", strerror(errno));\n\t\tf = popen(cmd, \"w\");\n\t\tif (f) {\n\t\t\tfprintf(f, \"remove %s\\n\",\n\t\t\t    s->auth_display);\n\t\t\tfprintf(f, \"add %s %s %s\\n\",\n\t\t\t    s->auth_display, s->auth_proto,\n\t\t\t    s->auth_data);\n\t\t\tpclose(f);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Could not run %s\\n\",\n\t\t\t    cmd);\n\t\t}\n\t}\n\tfree(cmd);\n\tfree(user_rc);\n}\n\nstatic void\ndo_nologin(struct passwd *pw)\n{\n\tFILE *f = NULL;\n\tchar buf[1024], *nl, *def_nl = _PATH_NOLOGIN;\n\tstruct stat sb;\n\n#ifdef HAVE_LOGIN_CAP\n\tif (login_getcapbool(lc, \"ignorenologin\", 0) || pw->pw_uid == 0)\n\t\treturn;\n\tnl = login_getcapstr(lc, \"nologin\", def_nl, def_nl);\n#else\n\tif (pw->pw_uid == 0)\n\t\treturn;\n\tnl = def_nl;\n#endif\n\tif (stat(nl, &sb) == -1)\n\t\treturn;\n\n\t \n\tlogit(\"User %.100s not allowed because %s exists\", pw->pw_name, nl);\n\tif ((f = fopen(nl, \"r\")) != NULL) {\n\t\twhile (fgets(buf, sizeof(buf), f))\n\t\t\tfputs(buf, stderr);\n\t\tfclose(f);\n\t}\n\texit(254);\n}\n\n \nstatic void\nsafely_chroot(const char *path, uid_t uid)\n{\n\tconst char *cp;\n\tchar component[PATH_MAX];\n\tstruct stat st;\n\n\tif (!path_absolute(path))\n\t\tfatal(\"chroot path does not begin at root\");\n\tif (strlen(path) >= sizeof(component))\n\t\tfatal(\"chroot path too long\");\n\n\t \n\tfor (cp = path; cp != NULL;) {\n\t\tif ((cp = strchr(cp, '/')) == NULL)\n\t\t\tstrlcpy(component, path, sizeof(component));\n\t\telse {\n\t\t\tcp++;\n\t\t\tmemcpy(component, path, cp - path);\n\t\t\tcomponent[cp - path] = '\\0';\n\t\t}\n\t\n\t\tdebug3_f(\"checking '%s'\", component);\n\n\t\tif (stat(component, &st) != 0)\n\t\t\tfatal_f(\"stat(\\\"%s\\\"): %s\",\n\t\t\t    component, strerror(errno));\n\t\tif (st.st_uid != 0 || (st.st_mode & 022) != 0)\n\t\t\tfatal(\"bad ownership or modes for chroot \"\n\t\t\t    \"directory %s\\\"%s\\\"\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\t\tif (!S_ISDIR(st.st_mode))\n\t\t\tfatal(\"chroot path %s\\\"%s\\\" is not a directory\",\n\t\t\t    cp == NULL ? \"\" : \"component \", component);\n\n\t}\n\n\tif (chdir(path) == -1)\n\t\tfatal(\"Unable to chdir to chroot path \\\"%s\\\": \"\n\t\t    \"%s\", path, strerror(errno));\n\tif (chroot(path) == -1)\n\t\tfatal(\"chroot(\\\"%s\\\"): %s\", path, strerror(errno));\n\tif (chdir(\"/\") == -1)\n\t\tfatal_f(\"chdir(/) after chroot: %s\", strerror(errno));\n\tverbose(\"Changed root directory to \\\"%s\\\"\", path);\n}\n\n \nvoid\ndo_setusercontext(struct passwd *pw)\n{\n\tchar uidstr[32], *chroot_path, *tmp;\n\n\tplatform_setusercontext(pw);\n\n\tif (platform_privileged_uidswap()) {\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid,\n\t\t    (LOGIN_SETALL & ~(LOGIN_SETPATH|LOGIN_SETUSER))) < 0) {\n\t\t\tperror(\"unable to set user context\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (setlogin(pw->pw_name) < 0)\n\t\t\terror(\"setlogin failed: %s\", strerror(errno));\n\t\tif (setgid(pw->pw_gid) < 0) {\n\t\t\tperror(\"setgid\");\n\t\t\texit(1);\n\t\t}\n\t\t \n\t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n\t\t\tperror(\"initgroups\");\n\t\t\texit(1);\n\t\t}\n\t\tendgrent();\n#endif\n\n\t\tplatform_setusercontext_post_groups(pw);\n\n\t\tif (!in_chroot && options.chroot_directory != NULL &&\n\t\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n\t\t\ttmp = tilde_expand_filename(options.chroot_directory,\n\t\t\t    pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\tchroot_path = percent_expand(tmp, \"h\", pw->pw_dir,\n\t\t\t    \"u\", pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tsafely_chroot(chroot_path, pw->pw_uid);\n\t\t\tfree(tmp);\n\t\t\tfree(chroot_path);\n\t\t\t \n\t\t\tfree(options.chroot_directory);\n\t\t\toptions.chroot_directory = NULL;\n\t\t\tin_chroot = 1;\n\t\t}\n\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUSER) < 0) {\n\t\t\tperror(\"unable to set user context (setuser)\");\n\t\t\texit(1);\n\t\t}\n\t\t \n\t\t(void) setusercontext(lc, pw, pw->pw_uid, LOGIN_SETUMASK);\n#else\n# ifdef USE_LIBIAF\n\t\t \n\t\tif (!in_chroot && set_id(pw->pw_name) != 0)\n\t\t\tfatal(\"set_id(%s) Failed\", pw->pw_name);\n# endif  \n\t\t \n\t\tpermanently_set_uid(pw);\n#endif\n\t} else if (options.chroot_directory != NULL &&\n\t    strcasecmp(options.chroot_directory, \"none\") != 0) {\n\t\tfatal(\"server lacks privileges to chroot to ChrootDirectory\");\n\t}\n\n\tif (getuid() != pw->pw_uid || geteuid() != pw->pw_uid)\n\t\tfatal(\"Failed to set uids to %u.\", (u_int) pw->pw_uid);\n}\n\nstatic void\ndo_pwchange(Session *s)\n{\n\tfflush(NULL);\n\tfprintf(stderr, \"WARNING: Your password has expired.\\n\");\n\tif (s->ttyfd != -1) {\n\t\tfprintf(stderr,\n\t\t    \"You must change your password now and login again!\\n\");\n#ifdef WITH_SELINUX\n\t\tsetexeccon(NULL);\n#endif\n#ifdef PASSWD_NEEDS_USERNAME\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", s->pw->pw_name,\n\t\t    (char *)NULL);\n#else\n\t\texecl(_PATH_PASSWD_PROG, \"passwd\", (char *)NULL);\n#endif\n\t\tperror(\"passwd\");\n\t} else {\n\t\tfprintf(stderr,\n\t\t    \"Password change required but no TTY available.\\n\");\n\t}\n\texit(1);\n}\n\nstatic void\nchild_close_fds(struct ssh *ssh)\n{\n\textern int auth_sock;\n\n\tif (auth_sock != -1) {\n\t\tclose(auth_sock);\n\t\tauth_sock = -1;\n\t}\n\n\tif (ssh_packet_get_connection_in(ssh) ==\n\t    ssh_packet_get_connection_out(ssh))\n\t\tclose(ssh_packet_get_connection_in(ssh));\n\telse {\n\t\tclose(ssh_packet_get_connection_in(ssh));\n\t\tclose(ssh_packet_get_connection_out(ssh));\n\t}\n\t \n\t \n\tchannel_close_all(ssh);\n\n\t \n\tendpwent();\n\n\t \n\tlog_redirect_stderr_to(NULL);\n\n\t \n\tclosefrom(STDERR_FILENO + 1);\n}\n\n \n#define ARGV_MAX 10\nvoid\ndo_child(struct ssh *ssh, Session *s, const char *command)\n{\n\textern char **environ;\n\tchar **env, *argv[ARGV_MAX], remote_id[512];\n\tconst char *shell, *shell0;\n\tstruct passwd *pw = s->pw;\n\tint r = 0;\n\n\tsshpkt_fmt_connection_id(ssh, remote_id, sizeof(remote_id));\n\n\t \n\tdestroy_sensitive_data();\n\tssh_packet_clear_keys(ssh);\n\n\t \n\tif (s->authctxt->force_pwchange) {\n\t\tdo_setusercontext(pw);\n\t\tchild_close_fds(ssh);\n\t\tdo_pwchange(s);\n\t\texit(1);\n\t}\n\n\t \n#ifdef HAVE_OSF_SIA\n\tsession_setup_sia(pw, s->ttyfd == -1 ? NULL : s->tty);\n\tif (!check_quietlogin(s, command))\n\t\tdo_motd();\n#else  \n\t \n\tif (!options.use_pam)\n\t\tdo_nologin(pw);\n\tdo_setusercontext(pw);\n\t \n\tif (!check_quietlogin(s, command))\n\t\tdisplay_loginmsg();\n#endif  \n\n#ifdef USE_PAM\n\tif (options.use_pam && !is_pam_session_open()) {\n\t\tdebug3(\"PAM session not opened, exiting\");\n\t\tdisplay_loginmsg();\n\t\texit(254);\n\t}\n#endif\n\n\t \n\tshell = (pw->pw_shell[0] == '\\0') ? _PATH_BSHELL : pw->pw_shell;\n\n\t \n\tenv = do_setup_env(ssh, s, shell);\n\n#ifdef HAVE_LOGIN_CAP\n\tshell = login_getcapstr(lc, \"shell\", (char *)shell, (char *)shell);\n#endif\n\n\t \n\tchild_close_fds(ssh);\n\n\t \n\tenviron = env;\n\n#if defined(KRB5) && defined(USE_AFS)\n\t \n\n\tif (options.kerberos_get_afs_token && k_hasafs() &&\n\t    (s->authctxt->krb5_ctx != NULL)) {\n\t\tchar cell[64];\n\n\t\tdebug(\"Getting AFS token\");\n\n\t\tk_setpag();\n\n\t\tif (k_afs_cell_of_file(pw->pw_dir, cell, sizeof(cell)) == 0)\n\t\t\tkrb5_afslog(s->authctxt->krb5_ctx,\n\t\t\t    s->authctxt->krb5_fwd_ccache, cell, NULL);\n\n\t\tkrb5_afslog_home(s->authctxt->krb5_ctx,\n\t\t    s->authctxt->krb5_fwd_ccache, NULL, NULL, pw->pw_dir);\n\t}\n#endif\n\n\t \n\tif (chdir(pw->pw_dir) == -1) {\n\t\t \n#ifdef HAVE_LOGIN_CAP\n\t\tr = login_getcapbool(lc, \"requirehome\", 0);\n#endif\n\t\tif (r || !in_chroot) {\n\t\t\tfprintf(stderr, \"Could not chdir to home \"\n\t\t\t    \"directory %s: %s\\n\", pw->pw_dir,\n\t\t\t    strerror(errno));\n\t\t}\n\t\tif (r)\n\t\t\texit(1);\n\t}\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tdo_rc_files(ssh, s, shell);\n\n\t \n\tssh_signal(SIGPIPE, SIG_DFL);\n\n\tif (s->is_subsystem == SUBSYSTEM_INT_SFTP_ERROR) {\n\t\terror(\"Connection from %s: refusing non-sftp session\",\n\t\t    remote_id);\n\t\tprintf(\"This service allows sftp connections only.\\n\");\n\t\tfflush(NULL);\n\t\texit(1);\n\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n\t\textern int optind, optreset;\n\t\tint i;\n\t\tchar *p, *args;\n\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n\t\targs = xstrdup(command ? command : \"sftp-server\");\n\t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n\t\t\tif (i < ARGV_MAX - 1)\n\t\t\t\targv[i++] = p;\n\t\targv[i] = NULL;\n\t\toptind = optreset = 1;\n\t\t__progname = argv[0];\n#ifdef WITH_SELINUX\n\t\tssh_selinux_change_context(\"sftpd_t\");\n#endif\n\t\texit(sftp_server_main(i, argv, s->pw));\n\t}\n\n\tfflush(NULL);\n\n\t \n\tif ((shell0 = strrchr(shell, '/')) != NULL)\n\t\tshell0++;\n\telse\n\t\tshell0 = shell;\n\n\t \n\tif (!command) {\n\t\tchar argv0[256];\n\n\t\t \n\t\targv0[0] = '-';\n\n\t\tif (strlcpy(argv0 + 1, shell0, sizeof(argv0) - 1)\n\t\t    >= sizeof(argv0) - 1) {\n\t\t\terrno = EINVAL;\n\t\t\tperror(shell);\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\targv[0] = argv0;\n\t\targv[1] = NULL;\n\t\texecve(shell, argv, env);\n\n\t\t \n\t\tperror(shell);\n\t\texit(1);\n\t}\n\t \n\targv[0] = (char *) shell0;\n\targv[1] = \"-c\";\n\targv[2] = (char *) command;\n\targv[3] = NULL;\n\texecve(shell, argv, env);\n\tperror(shell);\n\texit(1);\n}\n\nvoid\nsession_unused(int id)\n{\n\tdebug3_f(\"session id %d unused\", id);\n\tif (id >= options.max_sessions ||\n\t    id >= sessions_nalloc) {\n\t\tfatal_f(\"insane session id %d (max %d nalloc %d)\",\n\t\t    id, options.max_sessions, sessions_nalloc);\n\t}\n\tmemset(&sessions[id], 0, sizeof(*sessions));\n\tsessions[id].self = id;\n\tsessions[id].used = 0;\n\tsessions[id].chanid = -1;\n\tsessions[id].ptyfd = -1;\n\tsessions[id].ttyfd = -1;\n\tsessions[id].ptymaster = -1;\n\tsessions[id].x11_chanids = NULL;\n\tsessions[id].next_unused = sessions_first_unused;\n\tsessions_first_unused = id;\n}\n\nSession *\nsession_new(void)\n{\n\tSession *s, *tmp;\n\n\tif (sessions_first_unused == -1) {\n\t\tif (sessions_nalloc >= options.max_sessions)\n\t\t\treturn NULL;\n\t\tdebug2_f(\"allocate (allocated %d max %d)\",\n\t\t    sessions_nalloc, options.max_sessions);\n\t\ttmp = xrecallocarray(sessions, sessions_nalloc,\n\t\t    sessions_nalloc + 1, sizeof(*sessions));\n\t\tif (tmp == NULL) {\n\t\t\terror_f(\"cannot allocate %d sessions\",\n\t\t\t    sessions_nalloc + 1);\n\t\t\treturn NULL;\n\t\t}\n\t\tsessions = tmp;\n\t\tsession_unused(sessions_nalloc++);\n\t}\n\n\tif (sessions_first_unused >= sessions_nalloc ||\n\t    sessions_first_unused < 0) {\n\t\tfatal_f(\"insane first_unused %d max %d nalloc %d\",\n\t\t    sessions_first_unused, options.max_sessions,\n\t\t    sessions_nalloc);\n\t}\n\n\ts = &sessions[sessions_first_unused];\n\tif (s->used)\n\t\tfatal_f(\"session %d already used\", sessions_first_unused);\n\tsessions_first_unused = s->next_unused;\n\ts->used = 1;\n\ts->next_unused = -1;\n\tdebug(\"session_new: session %d\", s->self);\n\n\treturn s;\n}\n\nstatic void\nsession_dump(void)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tdebug(\"dump: used %d next_unused %d session %d \"\n\t\t    \"channel %d pid %ld\",\n\t\t    s->used,\n\t\t    s->next_unused,\n\t\t    s->self,\n\t\t    s->chanid,\n\t\t    (long)s->pid);\n\t}\n}\n\nint\nsession_open(Authctxt *authctxt, int chanid)\n{\n\tSession *s = session_new();\n\tdebug(\"session_open: channel %d\", chanid);\n\tif (s == NULL) {\n\t\terror(\"no more sessions\");\n\t\treturn 0;\n\t}\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\tif (s->pw == NULL || !authctxt->valid)\n\t\tfatal(\"no user for session %d\", s->self);\n\tdebug(\"session_open: session %d: link with channel %d\", s->self, chanid);\n\ts->chanid = chanid;\n\treturn 1;\n}\n\nSession *\nsession_by_tty(char *tty)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1 && strcmp(s->tty, tty) == 0) {\n\t\t\tdebug(\"session_by_tty: session %d tty %s\", i, tty);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_tty: unknown tty %.100s\", tty);\n\tsession_dump();\n\treturn NULL;\n}\n\nstatic Session *\nsession_by_channel(int id)\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->chanid == id) {\n\t\t\tdebug(\"session_by_channel: session %d channel %d\",\n\t\t\t    i, id);\n\t\t\treturn s;\n\t\t}\n\t}\n\tdebug(\"session_by_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}\n\nstatic Session *\nsession_by_x11_channel(int id)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\n\t\tif (s->x11_chanids == NULL || !s->used)\n\t\t\tcontinue;\n\t\tfor (j = 0; s->x11_chanids[j] != -1; j++) {\n\t\t\tif (s->x11_chanids[j] == id) {\n\t\t\t\tdebug(\"session_by_x11_channel: session %d \"\n\t\t\t\t    \"channel %d\", s->self, id);\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"session_by_x11_channel: unknown channel %d\", id);\n\tsession_dump();\n\treturn NULL;\n}\n\nstatic Session *\nsession_by_pid(pid_t pid)\n{\n\tint i;\n\tdebug(\"session_by_pid: pid %ld\", (long)pid);\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->pid == pid)\n\t\t\treturn s;\n\t}\n\terror(\"session_by_pid: unknown pid %ld\", (long)pid);\n\tsession_dump();\n\treturn NULL;\n}\n\nstatic int\nsession_window_change_req(struct ssh *ssh, Session *s)\n{\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, &s->col)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->row)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->xpixel)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->ypixel)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\treturn 1;\n}\n\nstatic int\nsession_pty_req(struct ssh *ssh, Session *s)\n{\n\tint r;\n\n\tif (!auth_opts->permit_pty_flag || !options.permit_tty) {\n\t\tdebug(\"Allocating a pty not permitted for this connection.\");\n\t\treturn 0;\n\t}\n\tif (s->ttyfd != -1) {\n\t\tssh_packet_disconnect(ssh, \"Protocol error: you already have a pty.\");\n\t\treturn 0;\n\t}\n\n\tif ((r = sshpkt_get_cstring(ssh, &s->term, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->col)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->row)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->xpixel)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->ypixel)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tif (strcmp(s->term, \"\") == 0) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t}\n\n\t \n\tdebug(\"Allocating pty.\");\n\tif (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,\n\t    sizeof(s->tty)))) {\n\t\tfree(s->term);\n\t\ts->term = NULL;\n\t\ts->ptyfd = -1;\n\t\ts->ttyfd = -1;\n\t\terror(\"session_pty_req: session %d alloc failed\", s->self);\n\t\treturn 0;\n\t}\n\tdebug(\"session_pty_req: session %d alloc %s\", s->self, s->tty);\n\n\tssh_tty_parse_modes(ssh, s->ttyfd);\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tif (!use_privsep)\n\t\tpty_setowner(s->pw, s->tty);\n\n\t \n\tpty_change_window_size(s->ptyfd, s->row, s->col, s->xpixel, s->ypixel);\n\n\tsession_proctitle(s);\n\treturn 1;\n}\n\nstatic int\nsession_subsystem_req(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tint r, success = 0;\n\tchar *prog, *cmd, *type;\n\tu_int i;\n\n\tif ((r = sshpkt_get_cstring(ssh, &s->subsys, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tdebug2(\"subsystem request for %.100s by user %s\", s->subsys,\n\t    s->pw->pw_name);\n\n\tfor (i = 0; i < options.num_subsystems; i++) {\n\t\tif (strcmp(s->subsys, options.subsystem_name[i]) == 0) {\n\t\t\tprog = options.subsystem_command[i];\n\t\t\tcmd = options.subsystem_args[i];\n\t\t\tif (strcmp(INTERNAL_SFTP_NAME, prog) == 0) {\n\t\t\t\ts->is_subsystem = SUBSYSTEM_INT_SFTP;\n\t\t\t\tdebug(\"subsystem: %s\", prog);\n\t\t\t} else {\n\t\t\t\tif (stat(prog, &st) == -1)\n\t\t\t\t\tdebug(\"subsystem: cannot stat %s: %s\",\n\t\t\t\t\t    prog, strerror(errno));\n\t\t\t\ts->is_subsystem = SUBSYSTEM_EXT;\n\t\t\t\tdebug(\"subsystem: exec() %s\", cmd);\n\t\t\t}\n\t\t\txasprintf(&type, \"session:subsystem:%s\",\n\t\t\t    options.subsystem_name[i]);\n\t\t\tchannel_set_xtype(ssh, s->chanid, type);\n\t\t\tfree(type);\n\t\t\tsuccess = do_exec(ssh, s, cmd) == 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!success)\n\t\tlogit(\"subsystem request for %.100s by user %s failed, \"\n\t\t    \"subsystem not found\", s->subsys, s->pw->pw_name);\n\n\treturn success;\n}\n\nstatic int\nsession_x11_req(struct ssh *ssh, Session *s)\n{\n\tint r, success;\n\tu_char single_connection = 0;\n\n\tif (s->auth_proto != NULL || s->auth_data != NULL) {\n\t\terror(\"session_x11_req: session %d: \"\n\t\t    \"x11 forwarding already active\", s->self);\n\t\treturn 0;\n\t}\n\tif ((r = sshpkt_get_u8(ssh, &single_connection)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &s->auth_proto, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &s->auth_data, NULL)) != 0 ||\n\t    (r = sshpkt_get_u32(ssh, &s->screen)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\ts->single_connection = single_connection;\n\n\tif (xauth_valid_string(s->auth_proto) &&\n\t    xauth_valid_string(s->auth_data))\n\t\tsuccess = session_setup_x11fwd(ssh, s);\n\telse {\n\t\tsuccess = 0;\n\t\terror(\"Invalid X11 forwarding data\");\n\t}\n\tif (!success) {\n\t\tfree(s->auth_proto);\n\t\tfree(s->auth_data);\n\t\ts->auth_proto = NULL;\n\t\ts->auth_data = NULL;\n\t}\n\treturn success;\n}\n\nstatic int\nsession_shell_req(struct ssh *ssh, Session *s)\n{\n\tint r;\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tchannel_set_xtype(ssh, s->chanid, \"session:shell\");\n\n\treturn do_exec(ssh, s, NULL) == 0;\n}\n\nstatic int\nsession_exec_req(struct ssh *ssh, Session *s)\n{\n\tu_int success;\n\tint r;\n\tchar *command = NULL;\n\n\tif ((r = sshpkt_get_cstring(ssh, &command, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tchannel_set_xtype(ssh, s->chanid, \"session:command\");\n\n\tsuccess = do_exec(ssh, s, command) == 0;\n\tfree(command);\n\treturn success;\n}\n\nstatic int\nsession_break_req(struct ssh *ssh, Session *s)\n{\n\tint r;\n\n\tif ((r = sshpkt_get_u32(ssh, NULL)) != 0 ||  \n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\tif (s->ptymaster == -1 || tcsendbreak(s->ptymaster, 0) == -1)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\nsession_env_req(struct ssh *ssh, Session *s)\n{\n\tchar *name, *val;\n\tu_int i;\n\tint r;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &val, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\n\t \n\tif (s->num_env > 128) {\n\t\tdebug2(\"Ignoring env request %s: too many env vars\", name);\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < options.num_accept_env; i++) {\n\t\tif (match_pattern(name, options.accept_env[i])) {\n\t\t\tdebug2(\"Setting env %d: %s=%s\", s->num_env, name, val);\n\t\t\ts->env = xrecallocarray(s->env, s->num_env,\n\t\t\t    s->num_env + 1, sizeof(*s->env));\n\t\t\ts->env[s->num_env].name = name;\n\t\t\ts->env[s->num_env].val = val;\n\t\t\ts->num_env++;\n\t\t\treturn (1);\n\t\t}\n\t}\n\tdebug2(\"Ignoring env request %s: disallowed name\", name);\n\n fail:\n\tfree(name);\n\tfree(val);\n\treturn (0);\n}\n\n \nstatic int\nname2sig(char *name)\n{\n#define SSH_SIG(x) if (strcmp(name, #x) == 0) return SIG ## x\n\tSSH_SIG(HUP);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n#ifdef SIGINFO\n\tif (strcmp(name, \"INFO@openssh.com\") == 0)\n\t\treturn SIGINFO;\n#endif\n\treturn -1;\n}\n\nstatic int\nsession_signal_req(struct ssh *ssh, Session *s)\n{\n\tchar *signame = NULL;\n\tint r, sig, success = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &signame, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto out;\n\t}\n\tif ((sig = name2sig(signame)) == -1) {\n\t\terror_f(\"unsupported signal \\\"%s\\\"\", signame);\n\t\tgoto out;\n\t}\n\tif (s->pid <= 0) {\n\t\terror_f(\"no pid for session %d\", s->self);\n\t\tgoto out;\n\t}\n\tif (s->forced || s->is_subsystem) {\n\t\terror_f(\"refusing to send signal %s to %s session\",\n\t\t    signame, s->forced ? \"forced-command\" : \"subsystem\");\n\t\tgoto out;\n\t}\n\tif (!use_privsep || mm_is_monitor()) {\n\t\terror_f(\"session signalling requires privilege separation\");\n\t\tgoto out;\n\t}\n\n\tdebug_f(\"signal %s, killpg(%ld, %d)\", signame, (long)s->pid, sig);\n\ttemporarily_use_uid(s->pw);\n\tr = killpg(s->pid, sig);\n\trestore_uid();\n\tif (r != 0) {\n\t\terror_f(\"killpg(%ld, %d): %s\", (long)s->pid,\n\t\t    sig, strerror(errno));\n\t\tgoto out;\n\t}\n\n\t \n\tsuccess = 1;\n out:\n\tfree(signame);\n\treturn success;\n}\n\nstatic int\nsession_auth_agent_req(struct ssh *ssh, Session *s)\n{\n\tstatic int called = 0;\n\tint r;\n\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"%s: parse packet\", __func__);\n\tif (!auth_opts->permit_agent_forwarding_flag ||\n\t    !options.allow_agent_forwarding) {\n\t\tdebug_f(\"agent forwarding disabled\");\n\t\treturn 0;\n\t}\n\tif (called) {\n\t\treturn 0;\n\t} else {\n\t\tcalled = 1;\n\t\treturn auth_input_request_forwarding(ssh, s->pw);\n\t}\n}\n\nint\nsession_input_channel_req(struct ssh *ssh, Channel *c, const char *rtype)\n{\n\tint success = 0;\n\tSession *s;\n\n\tif ((s = session_by_channel(c->self)) == NULL) {\n\t\tlogit_f(\"no session %d req %.100s\", c->self, rtype);\n\t\treturn 0;\n\t}\n\tdebug_f(\"session %d req %s\", s->self, rtype);\n\n\t \n\tif (c->type == SSH_CHANNEL_LARVAL) {\n\t\tif (strcmp(rtype, \"shell\") == 0) {\n\t\t\tsuccess = session_shell_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"exec\") == 0) {\n\t\t\tsuccess = session_exec_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"pty-req\") == 0) {\n\t\t\tsuccess = session_pty_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"x11-req\") == 0) {\n\t\t\tsuccess = session_x11_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"auth-agent-req@openssh.com\") == 0) {\n\t\t\tsuccess = session_auth_agent_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"subsystem\") == 0) {\n\t\t\tsuccess = session_subsystem_req(ssh, s);\n\t\t} else if (strcmp(rtype, \"env\") == 0) {\n\t\t\tsuccess = session_env_req(ssh, s);\n\t\t}\n\t}\n\tif (strcmp(rtype, \"window-change\") == 0) {\n\t\tsuccess = session_window_change_req(ssh, s);\n\t} else if (strcmp(rtype, \"break\") == 0) {\n\t\tsuccess = session_break_req(ssh, s);\n\t} else if (strcmp(rtype, \"signal\") == 0) {\n\t\tsuccess = session_signal_req(ssh, s);\n\t}\n\n\treturn success;\n}\n\nvoid\nsession_set_fds(struct ssh *ssh, Session *s,\n    int fdin, int fdout, int fderr, int ignore_fderr, int is_tty)\n{\n\t \n\tif (s->chanid == -1)\n\t\tfatal(\"no channel for session %d\", s->self);\n\tchannel_set_fds(ssh, s->chanid,\n\t    fdout, fdin, fderr,\n\t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n}\n\n \nvoid\nsession_pty_cleanup2(Session *s)\n{\n\tif (s == NULL) {\n\t\terror_f(\"no session\");\n\t\treturn;\n\t}\n\tif (s->ttyfd == -1)\n\t\treturn;\n\n\tdebug_f(\"session %d release %s\", s->self, s->tty);\n\n\t \n\tif (s->pid != 0)\n\t\trecord_logout(s->pid, s->tty, s->pw->pw_name);\n\n\t \n\tif (getuid() == 0)\n\t\tpty_release(s->tty);\n\n\t \n\tif (s->ptymaster != -1 && close(s->ptymaster) == -1)\n\t\terror(\"close(s->ptymaster/%d): %s\",\n\t\t    s->ptymaster, strerror(errno));\n\n\t \n\ts->ttyfd = -1;\n}\n\nvoid\nsession_pty_cleanup(Session *s)\n{\n\tPRIVSEP(session_pty_cleanup2(s));\n}\n\nstatic char *\nsig2name(int sig)\n{\n#define SSH_SIG(x) if (sig == SIG ## x) return #x\n\tSSH_SIG(ABRT);\n\tSSH_SIG(ALRM);\n\tSSH_SIG(FPE);\n\tSSH_SIG(HUP);\n\tSSH_SIG(ILL);\n\tSSH_SIG(INT);\n\tSSH_SIG(KILL);\n\tSSH_SIG(PIPE);\n\tSSH_SIG(QUIT);\n\tSSH_SIG(SEGV);\n\tSSH_SIG(TERM);\n\tSSH_SIG(USR1);\n\tSSH_SIG(USR2);\n#undef\tSSH_SIG\n\treturn \"SIG@openssh.com\";\n}\n\nstatic void\nsession_close_x11(struct ssh *ssh, int id)\n{\n\tChannel *c;\n\n\tif ((c = channel_by_id(ssh, id)) == NULL) {\n\t\tdebug_f(\"x11 channel %d missing\", id);\n\t} else {\n\t\t \n\t\tdebug_f(\"detach x11 channel %d\", id);\n\t\tchannel_cancel_cleanup(ssh, id);\n\t\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\t\tchan_mark_dead(ssh, c);\n\t}\n}\n\nstatic void\nsession_close_single_x11(struct ssh *ssh, int id, int force, void *arg)\n{\n\tSession *s;\n\tu_int i;\n\n\tdebug3_f(\"channel %d\", id);\n\tchannel_cancel_cleanup(ssh, id);\n\tif ((s = session_by_x11_channel(id)) == NULL)\n\t\tfatal_f(\"no x11 channel %d\", id);\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tdebug_f(\"session %d: closing channel %d\",\n\t\t    s->self, s->x11_chanids[i]);\n\t\t \n\t\tif (s->x11_chanids[i] != id)\n\t\t\tsession_close_x11(ssh, s->x11_chanids[i]);\n\t}\n\tfree(s->x11_chanids);\n\ts->x11_chanids = NULL;\n\tfree(s->display);\n\ts->display = NULL;\n\tfree(s->auth_proto);\n\ts->auth_proto = NULL;\n\tfree(s->auth_data);\n\ts->auth_data = NULL;\n\tfree(s->auth_display);\n\ts->auth_display = NULL;\n}\n\nstatic void\nsession_exit_message(struct ssh *ssh, Session *s, int status)\n{\n\tChannel *c;\n\tint r;\n\tchar *note = NULL;\n\n\tif ((c = channel_lookup(ssh, s->chanid)) == NULL)\n\t\tfatal_f(\"session %d: no channel %d\", s->self, s->chanid);\n\n\tif (WIFEXITED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-status\", 0);\n\t\tif ((r = sshpkt_put_u32(ssh, WEXITSTATUS(status))) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: exit reply\", __func__);\n\t\txasprintf(&note, \"exit %d\", WEXITSTATUS(status));\n\t} else if (WIFSIGNALED(status)) {\n\t\tchannel_request_start(ssh, s->chanid, \"exit-signal\", 0);\n#ifndef WCOREDUMP\n# define WCOREDUMP(x) (0)\n#endif\n\t\tif ((r = sshpkt_put_cstring(ssh, sig2name(WTERMSIG(status)))) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, WCOREDUMP(status)? 1 : 0)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tsshpkt_fatal(ssh, r, \"%s: exit reply\", __func__);\n\t\txasprintf(&note, \"signal %d%s\", WTERMSIG(status),\n\t\t    WCOREDUMP(status) ? \" core dumped\" : \"\");\n\t} else {\n\t\t \n\t\tssh_packet_disconnect(ssh, \"wait returned status %04x.\",\n\t\t    status);\n\t}\n\n\tdebug_f(\"session %d channel %d pid %ld %s\", s->self, s->chanid,\n\t    (long)s->pid, note == NULL ? \"UNKNOWN\" : note);\n\tfree(note);\n\n\t \n\tdebug_f(\"release channel %d\", s->chanid);\n\n\t \n\tchannel_register_cleanup(ssh, c->self, session_close_by_channel, 1);\n\n\t \n\tif (c->ostate != CHAN_OUTPUT_CLOSED)\n\t\tchan_write_failed(ssh, c);\n}\n\nvoid\nsession_close(struct ssh *ssh, Session *s)\n{\n\tu_int i;\n\n\tverbose(\"Close session: user %s from %.200s port %d id %d\",\n\t    s->pw->pw_name,\n\t    ssh_remote_ipaddr(ssh),\n\t    ssh_remote_port(ssh),\n\t    s->self);\n\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\tfree(s->term);\n\tfree(s->display);\n\tfree(s->x11_chanids);\n\tfree(s->auth_display);\n\tfree(s->auth_data);\n\tfree(s->auth_proto);\n\tfree(s->subsys);\n\tif (s->env != NULL) {\n\t\tfor (i = 0; i < s->num_env; i++) {\n\t\t\tfree(s->env[i].name);\n\t\t\tfree(s->env[i].val);\n\t\t}\n\t\tfree(s->env);\n\t}\n\tsession_proctitle(s);\n\tsession_unused(s->self);\n}\n\nvoid\nsession_close_by_pid(struct ssh *ssh, pid_t pid, int status)\n{\n\tSession *s = session_by_pid(pid);\n\tif (s == NULL) {\n\t\tdebug_f(\"no session for pid %ld\", (long)pid);\n\t\treturn;\n\t}\n\tif (s->chanid != -1)\n\t\tsession_exit_message(ssh, s, status);\n\tif (s->ttyfd != -1)\n\t\tsession_pty_cleanup(s);\n\ts->pid = 0;\n}\n\n \nvoid\nsession_close_by_channel(struct ssh *ssh, int id, int force, void *arg)\n{\n\tSession *s = session_by_channel(id);\n\tu_int i;\n\n\tif (s == NULL) {\n\t\tdebug_f(\"no session for id %d\", id);\n\t\treturn;\n\t}\n\tdebug_f(\"channel %d child %ld\", id, (long)s->pid);\n\tif (s->pid != 0) {\n\t\tdebug_f(\"channel %d: has child, ttyfd %d\", id, s->ttyfd);\n\t\t \n\t\tif (s->ttyfd != -1)\n\t\t\tsession_pty_cleanup(s);\n\t\tif (!force)\n\t\t\treturn;\n\t}\n\t \n\tchannel_cancel_cleanup(ssh, s->chanid);\n\n\t \n\tif (s->x11_chanids != NULL) {\n\t\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\t\tsession_close_x11(ssh, s->x11_chanids[i]);\n\t\t\ts->x11_chanids[i] = -1;\n\t\t}\n\t}\n\n\ts->chanid = -1;\n\tsession_close(ssh, s);\n}\n\nvoid\nsession_destroy_all(struct ssh *ssh, void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(ssh, s);\n\t\t}\n\t}\n}\n\nstatic char *\nsession_tty_list(void)\n{\n\tstatic char buf[1024];\n\tint i;\n\tchar *cp;\n\n\tbuf[0] = '\\0';\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used && s->ttyfd != -1) {\n\n\t\t\tif (strncmp(s->tty, \"/dev/\", 5) != 0) {\n\t\t\t\tcp = strrchr(s->tty, '/');\n\t\t\t\tcp = (cp == NULL) ? s->tty : cp + 1;\n\t\t\t} else\n\t\t\t\tcp = s->tty + 5;\n\n\t\t\tif (buf[0] != '\\0')\n\t\t\t\tstrlcat(buf, \",\", sizeof buf);\n\t\t\tstrlcat(buf, cp, sizeof buf);\n\t\t}\n\t}\n\tif (buf[0] == '\\0')\n\t\tstrlcpy(buf, \"notty\", sizeof buf);\n\treturn buf;\n}\n\nvoid\nsession_proctitle(Session *s)\n{\n\tif (s->pw == NULL)\n\t\terror(\"no user for session %d\", s->self);\n\telse\n\t\tsetproctitle(\"%s@%s\", s->pw->pw_name, session_tty_list());\n}\n\nint\nsession_setup_x11fwd(struct ssh *ssh, Session *s)\n{\n\tstruct stat st;\n\tchar display[512], auth_display[512];\n\tchar hostname[NI_MAXHOST];\n\tu_int i;\n\n\tif (!auth_opts->permit_x11_forwarding_flag) {\n\t\tssh_packet_send_debug(ssh, \"X11 forwarding disabled by key options.\");\n\t\treturn 0;\n\t}\n\tif (!options.x11_forwarding) {\n\t\tdebug(\"X11 forwarding disabled in server configuration file.\");\n\t\treturn 0;\n\t}\n\tif (options.xauth_location == NULL ||\n\t    (stat(options.xauth_location, &st) == -1)) {\n\t\tssh_packet_send_debug(ssh, \"No xauth program; cannot forward X11.\");\n\t\treturn 0;\n\t}\n\tif (s->display != NULL) {\n\t\tdebug(\"X11 display already set.\");\n\t\treturn 0;\n\t}\n\tif (x11_create_display_inet(ssh, options.x11_display_offset,\n\t    options.x11_use_localhost, s->single_connection,\n\t    &s->display_number, &s->x11_chanids) == -1) {\n\t\tdebug(\"x11_create_display_inet failed.\");\n\t\treturn 0;\n\t}\n\tfor (i = 0; s->x11_chanids[i] != -1; i++) {\n\t\tchannel_register_cleanup(ssh, s->x11_chanids[i],\n\t\t    session_close_single_x11, 0);\n\t}\n\n\t \n\tif (gethostname(hostname, sizeof(hostname)) == -1)\n\t\tfatal(\"gethostname: %.100s\", strerror(errno));\n\t \n\tif (options.x11_use_localhost) {\n\t\tsnprintf(display, sizeof display, \"localhost:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\tsnprintf(auth_display, sizeof auth_display, \"unix:%u.%u\",\n\t\t    s->display_number, s->screen);\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(auth_display);\n\t} else {\n#ifdef IPADDR_IN_DISPLAY\n\t\tstruct hostent *he;\n\t\tstruct in_addr my_addr;\n\n\t\the = gethostbyname(hostname);\n\t\tif (he == NULL) {\n\t\t\terror(\"Can't get IP address for X11 DISPLAY.\");\n\t\t\tssh_packet_send_debug(ssh, \"Can't get IP address for X11 DISPLAY.\");\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(&my_addr, he->h_addr_list[0], sizeof(struct in_addr));\n\t\tsnprintf(display, sizeof display, \"%.50s:%u.%u\", inet_ntoa(my_addr),\n\t\t    s->display_number, s->screen);\n#else\n\t\tsnprintf(display, sizeof display, \"%.400s:%u.%u\", hostname,\n\t\t    s->display_number, s->screen);\n#endif\n\t\ts->display = xstrdup(display);\n\t\ts->auth_display = xstrdup(display);\n\t}\n\n\treturn 1;\n}\n\nstatic void\ndo_authenticated2(struct ssh *ssh, Authctxt *authctxt)\n{\n\tserver_loop2(ssh, authctxt);\n}\n\nvoid\ndo_cleanup(struct ssh *ssh, Authctxt *authctxt)\n{\n\tstatic int called = 0;\n\n\tdebug(\"do_cleanup\");\n\n\t \n\tif (is_child)\n\t\treturn;\n\n\t \n\tif (called)\n\t\treturn;\n\tcalled = 1;\n\n\tif (authctxt == NULL)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam) {\n\t\tsshpam_cleanup();\n\t\tsshpam_thread_cleanup();\n\t}\n#endif\n\n\tif (!authctxt->authenticated)\n\t\treturn;\n\n#ifdef KRB5\n\tif (options.kerberos_ticket_cleanup &&\n\t    authctxt->krb5_ctx)\n\t\tkrb5_cleanup_proc(authctxt);\n#endif\n\n#ifdef GSSAPI\n\tif (options.gss_cleanup_creds)\n\t\tssh_gssapi_cleanup_creds();\n#endif\n\n\t \n\tauth_sock_cleanup_proc(authctxt->pw);\n\n\t \n\tif (auth_info_file != NULL) {\n\t\ttemporarily_use_uid(authctxt->pw);\n\t\tunlink(auth_info_file);\n\t\trestore_uid();\n\t\tfree(auth_info_file);\n\t\tauth_info_file = NULL;\n\t}\n\n\t \n\tif (!use_privsep || mm_is_monitor())\n\t\tsession_destroy_all(ssh, session_pty_cleanup2);\n}\n\n \n\nconst char *\nsession_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)\n{\n\tconst char *remote = \"\";\n\n\tif (utmp_size > 0)\n\t\tremote = auth_get_canonical_hostname(ssh, use_dns);\n\tif (utmp_size == 0 || strlen(remote) > utmp_size)\n\t\tremote = ssh_remote_ipaddr(ssh);\n\treturn remote;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}