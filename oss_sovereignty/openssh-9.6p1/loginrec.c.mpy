{
  "module_name": "loginrec.c",
  "hash_id": "22d656db56a4496da1207e516b39b54c65fbedc8a00c32ed2a765ce50a0917f5",
  "original_prompt": "Ingested from openssh-9.6p1/loginrec.c",
  "human_readable_source": " \n\n \n\n\n \n\n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <netinet/in.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#include <pwd.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"ssh.h\"\n#include \"loginrec.h\"\n#include \"log.h\"\n#include \"atomicio.h\"\n#include \"packet.h\"\n#include \"canohost.h\"\n#include \"auth.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"misc.h\"\n\n#ifdef HAVE_UTIL_H\n# include <util.h>\n#endif\n\n \n\n#if HAVE_UTMP_H\nvoid set_utmp_time(struct logininfo *li, struct utmp *ut);\nvoid construct_utmp(struct logininfo *li, struct utmp *ut);\n#endif\n\n#ifdef HAVE_UTMPX_H\nvoid set_utmpx_time(struct logininfo *li, struct utmpx *ut);\nvoid construct_utmpx(struct logininfo *li, struct utmpx *ut);\n#endif\n\nint utmp_write_entry(struct logininfo *li);\nint utmpx_write_entry(struct logininfo *li);\nint wtmp_write_entry(struct logininfo *li);\nint wtmpx_write_entry(struct logininfo *li);\nint lastlog_write_entry(struct logininfo *li);\nint syslogin_write_entry(struct logininfo *li);\n\nint getlast_entry(struct logininfo *li);\nint lastlog_get_entry(struct logininfo *li);\nint utmpx_get_entry(struct logininfo *li);\nint wtmp_get_entry(struct logininfo *li);\nint wtmpx_get_entry(struct logininfo *li);\n\nextern struct sshbuf *loginmsg;\n\n \n#define MIN_SIZEOF(s1,s2) (sizeof(s1) < sizeof(s2) ? sizeof(s1) : sizeof(s2))\n\n \n\n \nint\nlogin_login(struct logininfo *li)\n{\n\tli->type = LTYPE_LOGIN;\n\treturn (login_write(li));\n}\n\n\n \nint\nlogin_logout(struct logininfo *li)\n{\n\tli->type = LTYPE_LOGOUT;\n\treturn (login_write(li));\n}\n\n \nunsigned int\nlogin_get_lastlog_time(const uid_t uid)\n{\n\tstruct logininfo li;\n\n\tif (login_get_lastlog(&li, uid))\n\t\treturn (li.tv_sec);\n\telse\n\t\treturn (0);\n}\n\n \nstruct logininfo *\nlogin_get_lastlog(struct logininfo *li, const uid_t uid)\n{\n\tstruct passwd *pw;\n\n\tmemset(li, '\\0', sizeof(*li));\n\tli->uid = uid;\n\n\t \n\tpw = getpwuid(uid);\n\tif (pw == NULL)\n\t\tfatal(\"%s: Cannot find account for uid %ld\", __func__,\n\t\t    (long)uid);\n\n\tif (strlcpy(li->username, pw->pw_name, sizeof(li->username)) >=\n\t    sizeof(li->username)) {\n\t\terror(\"%s: username too long (%lu > max %lu)\", __func__,\n\t\t    (unsigned long)strlen(pw->pw_name),\n\t\t    (unsigned long)sizeof(li->username) - 1);\n\t\treturn NULL;\n\t}\n\n\tif (getlast_entry(li))\n\t\treturn (li);\n\telse\n\t\treturn (NULL);\n}\n\n \nstruct\nlogininfo *login_alloc_entry(pid_t pid, const char *username,\n    const char *hostname, const char *line)\n{\n\tstruct logininfo *newli;\n\n\tnewli = xmalloc(sizeof(*newli));\n\tlogin_init_entry(newli, pid, username, hostname, line);\n\treturn (newli);\n}\n\n\n \nvoid\nlogin_free_entry(struct logininfo *li)\n{\n\tfree(li);\n}\n\n\n \nint\nlogin_init_entry(struct logininfo *li, pid_t pid, const char *username,\n    const char *hostname, const char *line)\n{\n\tstruct passwd *pw;\n\n\tmemset(li, 0, sizeof(*li));\n\n\tli->pid = pid;\n\n\t \n\tif (line)\n\t\tline_fullname(li->line, line, sizeof(li->line));\n\n\tif (username) {\n\t\tstrlcpy(li->username, username, sizeof(li->username));\n\t\tpw = getpwnam(li->username);\n\t\tif (pw == NULL) {\n\t\t\tfatal(\"%s: Cannot find user \\\"%s\\\"\", __func__,\n\t\t\t    li->username);\n\t\t}\n\t\tli->uid = pw->pw_uid;\n\t}\n\n\tif (hostname)\n\t\tstrlcpy(li->hostname, hostname, sizeof(li->hostname));\n\n\treturn (1);\n}\n\n \nvoid\nlogin_set_current_time(struct logininfo *li)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\n\tli->tv_sec = tv.tv_sec;\n\tli->tv_usec = tv.tv_usec;\n}\n\n \nvoid\nlogin_set_addr(struct logininfo *li, const struct sockaddr *sa,\n    const unsigned int sa_size)\n{\n\tunsigned int bufsize = sa_size;\n\n\t \n\tif (sizeof(li->hostaddr) < sa_size)\n\t\tbufsize = sizeof(li->hostaddr);\n\n\tmemcpy(&li->hostaddr.sa, sa, bufsize);\n}\n\n\n \nint\nlogin_write(struct logininfo *li)\n{\n#ifndef HAVE_CYGWIN\n\tif (geteuid() != 0) {\n\t\tlogit(\"Attempt to write login records by non-root user (aborting)\");\n\t\treturn (1);\n\t}\n#endif\n\n\t \n\tlogin_set_current_time(li);\n#ifdef USE_LOGIN\n\tsyslogin_write_entry(li);\n#endif\n#ifdef USE_LASTLOG\n\tif (li->type == LTYPE_LOGIN)\n\t\tlastlog_write_entry(li);\n#endif\n#ifdef USE_UTMP\n\tutmp_write_entry(li);\n#endif\n#ifdef USE_WTMP\n\twtmp_write_entry(li);\n#endif\n#ifdef USE_UTMPX\n\tutmpx_write_entry(li);\n#endif\n#ifdef USE_WTMPX\n\twtmpx_write_entry(li);\n#endif\n#ifdef CUSTOM_SYS_AUTH_RECORD_LOGIN\n\tif (li->type == LTYPE_LOGIN &&\n\t    !sys_auth_record_login(li->username,li->hostname,li->line,\n\t    loginmsg))\n\t\tlogit(\"Writing login record failed for %s\", li->username);\n#endif\n#ifdef SSH_AUDIT_EVENTS\n\tif (li->type == LTYPE_LOGIN)\n\t\taudit_session_open(li);\n\telse if (li->type == LTYPE_LOGOUT)\n\t\taudit_session_close(li);\n#endif\n\treturn (0);\n}\n\n#ifdef LOGIN_NEEDS_UTMPX\nint\nlogin_utmp_only(struct logininfo *li)\n{\n\tli->type = LTYPE_LOGIN;\n\tlogin_set_current_time(li);\n# ifdef USE_UTMP\n\tutmp_write_entry(li);\n# endif\n# ifdef USE_WTMP\n\twtmp_write_entry(li);\n# endif\n# ifdef USE_UTMPX\n\tutmpx_write_entry(li);\n# endif\n# ifdef USE_WTMPX\n\twtmpx_write_entry(li);\n# endif\n\treturn (0);\n}\n#endif\n\n \n\n \nint\ngetlast_entry(struct logininfo *li)\n{\n#ifdef USE_LASTLOG\n\treturn(lastlog_get_entry(li));\n#else  \n#if defined(USE_UTMPX) && defined(HAVE_SETUTXDB) && \\\n    defined(UTXDB_LASTLOGIN) && defined(HAVE_GETUTXUSER)\n\treturn (utmpx_get_entry(li));\n#endif\n\n#if defined(DISABLE_LASTLOG)\n\t \n\treturn (0);\n# elif defined(USE_WTMP) && \\\n    (defined(HAVE_TIME_IN_UTMP) || defined(HAVE_TV_IN_UTMP))\n\t \n\treturn (wtmp_get_entry(li));\n# elif defined(USE_WTMPX) && \\\n    (defined(HAVE_TIME_IN_UTMPX) || defined(HAVE_TV_IN_UTMPX))\n\t \n\treturn (wtmpx_get_entry(li));\n# else\n\t \n\treturn (0);\n# endif  \n#endif  \n}\n\n\n\n \n\n\n \nchar *\nline_fullname(char *dst, const char *src, u_int dstsize)\n{\n\tmemset(dst, '\\0', dstsize);\n\tif ((strncmp(src, \"/dev/\", 5) == 0) || (dstsize < (strlen(src) + 5)))\n\t\tstrlcpy(dst, src, dstsize);\n\telse {\n\t\tstrlcpy(dst, \"/dev/\", dstsize);\n\t\tstrlcat(dst, src, dstsize);\n\t}\n\treturn (dst);\n}\n\n \nchar *\nline_stripname(char *dst, const char *src, int dstsize)\n{\n\tmemset(dst, '\\0', dstsize);\n\tif (strncmp(src, \"/dev/\", 5) == 0)\n\t\tstrlcpy(dst, src + 5, dstsize);\n\telse\n\t\tstrlcpy(dst, src, dstsize);\n\treturn (dst);\n}\n\n \nchar *\nline_abbrevname(char *dst, const char *src, int dstsize)\n{\n\tsize_t len;\n\n\tmemset(dst, '\\0', dstsize);\n\n\t \n\tif (strncmp(src, \"/dev/\", 5) == 0)\n\t\tsrc += 5;\n\n#ifdef WITH_ABBREV_NO_TTY\n\tif (strncmp(src, \"tty\", 3) == 0)\n\t\tsrc += 3;\n#endif\n\n\tlen = strlen(src);\n\n\tif (len > 0) {\n\t\tif (((int)len - dstsize) > 0)\n\t\t\tsrc +=  ((int)len - dstsize);\n\n\t\t \n\t\tstrncpy(dst, src, (size_t)dstsize);\n\t}\n\n\treturn (dst);\n}\n\n \n\n#if defined(USE_UTMP) || defined (USE_WTMP) || defined (USE_LOGIN)\n\n \nvoid\nset_utmp_time(struct logininfo *li, struct utmp *ut)\n{\n# if defined(HAVE_TV_IN_UTMP)\n\tut->ut_tv.tv_sec = li->tv_sec;\n\tut->ut_tv.tv_usec = li->tv_usec;\n# elif defined(HAVE_TIME_IN_UTMP)\n\tut->ut_time = li->tv_sec;\n# endif\n}\n\nvoid\nconstruct_utmp(struct logininfo *li,\n\t\t    struct utmp *ut)\n{\n# ifdef HAVE_ADDR_V6_IN_UTMP\n\tstruct sockaddr_in6 *sa6;\n# endif\n\n\tmemset(ut, '\\0', sizeof(*ut));\n\n\t \n\n# ifdef HAVE_ID_IN_UTMP\n\tline_abbrevname(ut->ut_id, li->line, sizeof(ut->ut_id));\n# endif\n\n# ifdef HAVE_TYPE_IN_UTMP\n\t \n\tswitch (li->type) {\n\tcase LTYPE_LOGIN:\n\t\tut->ut_type = USER_PROCESS;\n\t\tbreak;\n\tcase LTYPE_LOGOUT:\n\t\tut->ut_type = DEAD_PROCESS;\n\t\tbreak;\n\t}\n# endif\n\tset_utmp_time(li, ut);\n\n\tline_stripname(ut->ut_line, li->line, sizeof(ut->ut_line));\n\n# ifdef HAVE_PID_IN_UTMP\n\tut->ut_pid = li->pid;\n# endif\n\n\t \n\tif (li->type == LTYPE_LOGOUT)\n\t\treturn;\n\n\t \n\n\t \n\tstrncpy(ut->ut_name, li->username,\n\t    MIN_SIZEOF(ut->ut_name, li->username));\n# ifdef HAVE_HOST_IN_UTMP\n\tstrncpy(ut->ut_host, li->hostname,\n\t    MIN_SIZEOF(ut->ut_host, li->hostname));\n# endif\n# ifdef HAVE_ADDR_IN_UTMP\n\t \n\tif (li->hostaddr.sa.sa_family == AF_INET)\n\t\tut->ut_addr = li->hostaddr.sa_in.sin_addr.s_addr;\n# endif\n# ifdef HAVE_ADDR_V6_IN_UTMP\n\t \n\tif (li->hostaddr.sa.sa_family == AF_INET6) {\n\t\tsa6 = ((struct sockaddr_in6 *)&li->hostaddr.sa);\n\t\tmemcpy(ut->ut_addr_v6, sa6->sin6_addr.s6_addr, 16);\n\t\tif (IN6_IS_ADDR_V4MAPPED(&sa6->sin6_addr)) {\n\t\t\tut->ut_addr_v6[0] = ut->ut_addr_v6[3];\n\t\t\tut->ut_addr_v6[1] = 0;\n\t\t\tut->ut_addr_v6[2] = 0;\n\t\t\tut->ut_addr_v6[3] = 0;\n\t\t}\n\t}\n# endif\n}\n#endif  \n\n \n\n#if defined(USE_UTMPX) || defined (USE_WTMPX)\n \nvoid\nset_utmpx_time(struct logininfo *li, struct utmpx *utx)\n{\n# if defined(HAVE_TV_IN_UTMPX)\n\tutx->ut_tv.tv_sec = li->tv_sec;\n\tutx->ut_tv.tv_usec = li->tv_usec;\n# elif defined(HAVE_TIME_IN_UTMPX)\n\tutx->ut_time = li->tv_sec;\n# endif\n}\n\nvoid\nconstruct_utmpx(struct logininfo *li, struct utmpx *utx)\n{\n# ifdef HAVE_ADDR_V6_IN_UTMP\n\tstruct sockaddr_in6 *sa6;\n#  endif\n\tmemset(utx, '\\0', sizeof(*utx));\n\n# ifdef HAVE_ID_IN_UTMPX\n\tline_abbrevname(utx->ut_id, li->line, sizeof(utx->ut_id));\n# endif\n\n\t \n\tswitch (li->type) {\n\tcase LTYPE_LOGIN:\n\t\tutx->ut_type = USER_PROCESS;\n\t\tbreak;\n\tcase LTYPE_LOGOUT:\n\t\tutx->ut_type = DEAD_PROCESS;\n\t\tbreak;\n\t}\n\tline_stripname(utx->ut_line, li->line, sizeof(utx->ut_line));\n\tset_utmpx_time(li, utx);\n\tutx->ut_pid = li->pid;\n\n\t \n\tstrncpy(utx->ut_user, li->username,\n\t    MIN_SIZEOF(utx->ut_user, li->username));\n\n\tif (li->type == LTYPE_LOGOUT)\n\t\treturn;\n\n\t \n\n# ifdef HAVE_HOST_IN_UTMPX\n\tstrncpy(utx->ut_host, li->hostname,\n\t    MIN_SIZEOF(utx->ut_host, li->hostname));\n# endif\n# ifdef HAVE_SS_IN_UTMPX\n\tutx->ut_ss = li->hostaddr.sa_storage;\n# endif\n# ifdef HAVE_ADDR_IN_UTMPX\n\t \n\tif (li->hostaddr.sa.sa_family == AF_INET)\n\t\tutx->ut_addr = li->hostaddr.sa_in.sin_addr.s_addr;\n# endif\n# ifdef HAVE_ADDR_V6_IN_UTMP\n\t \n\tif (li->hostaddr.sa.sa_family == AF_INET6) {\n\t\tsa6 = ((struct sockaddr_in6 *)&li->hostaddr.sa);\n\t\tmemcpy(utx->ut_addr_v6, sa6->sin6_addr.s6_addr, 16);\n\t\tif (IN6_IS_ADDR_V4MAPPED(&sa6->sin6_addr)) {\n\t\t\tutx->ut_addr_v6[0] = utx->ut_addr_v6[3];\n\t\t\tutx->ut_addr_v6[1] = 0;\n\t\t\tutx->ut_addr_v6[2] = 0;\n\t\t\tutx->ut_addr_v6[3] = 0;\n\t\t}\n\t}\n# endif\n# ifdef HAVE_SYSLEN_IN_UTMPX\n\t \n\tutx->ut_syslen = MINIMUM(strlen(li->hostname), sizeof(utx->ut_host));\n# endif\n}\n#endif  \n\n \n\n \n#ifdef USE_UTMP\n\n \n# if !defined(DISABLE_PUTUTLINE) && defined(HAVE_SETUTENT) && \\\n\tdefined(HAVE_PUTUTLINE)\n#  define UTMP_USE_LIBRARY\n# endif\n\n\n \n# ifdef UTMP_USE_LIBRARY\nstatic int\nutmp_write_library(struct logininfo *li, struct utmp *ut)\n{\n\tsetutent();\n\tpututline(ut);\n#  ifdef HAVE_ENDUTENT\n\tendutent();\n#  endif\n\treturn (1);\n}\n# else  \n\n \nstatic int\nutmp_write_direct(struct logininfo *li, struct utmp *ut)\n{\n\tstruct utmp old_ut;\n\tregister int fd;\n\tint tty;\n\n\t \n\n#if defined(HAVE_GETTTYENT)\n\tstruct ttyent *ty;\n\n\ttty=0;\n\tsetttyent();\n\twhile (NULL != (ty = getttyent())) {\n\t\ttty++;\n\t\tif (!strncmp(ty->ty_name, ut->ut_line, sizeof(ut->ut_line)))\n\t\t\tbreak;\n\t}\n\tendttyent();\n\n\tif (NULL == ty) {\n\t\tlogit(\"%s: tty not found\", __func__);\n\t\treturn (0);\n\t}\n#else  \n\n\ttty = ttyslot();  \n\n#endif  \n\n\tif (tty > 0 && (fd = open(UTMP_FILE, O_RDWR|O_CREAT, 0644)) >= 0) {\n\t\toff_t pos, ret;\n\n\t\tpos = (off_t)tty * sizeof(struct utmp);\n\t\tif ((ret = lseek(fd, pos, SEEK_SET)) == -1) {\n\t\t\tlogit(\"%s: lseek: %s\", __func__, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t\tif (ret != pos) {\n\t\t\tlogit(\"%s: Couldn't seek to tty %d slot in %s\",\n\t\t\t    __func__, tty, UTMP_FILE);\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t\t \n\t\tif (atomicio(read, fd, &old_ut, sizeof(old_ut)) == sizeof(old_ut) &&\n\t\t    (ut->ut_host[0] == '\\0') && (old_ut.ut_host[0] != '\\0') &&\n\t\t    (strncmp(old_ut.ut_line, ut->ut_line, sizeof(ut->ut_line)) == 0) &&\n\t\t    (strncmp(old_ut.ut_name, ut->ut_name, sizeof(ut->ut_name)) == 0))\n\t\t\tmemcpy(ut->ut_host, old_ut.ut_host, sizeof(ut->ut_host));\n\n\t\tif ((ret = lseek(fd, pos, SEEK_SET)) == -1) {\n\t\t\tlogit(\"%s: lseek: %s\", __func__, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t\tif (ret != pos) {\n\t\t\tlogit(\"%s: Couldn't seek to tty %d slot in %s\",\n\t\t\t    __func__, tty, UTMP_FILE);\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t\tif (atomicio(vwrite, fd, ut, sizeof(*ut)) != sizeof(*ut)) {\n\t\t\tlogit(\"%s: error writing %s: %s\", __func__,\n\t\t\t    UTMP_FILE, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\n\t\tclose(fd);\n\t\treturn (1);\n\t} else {\n\t\treturn (0);\n\t}\n}\n# endif  \n\nstatic int\nutmp_perform_login(struct logininfo *li)\n{\n\tstruct utmp ut;\n\n\tconstruct_utmp(li, &ut);\n# ifdef UTMP_USE_LIBRARY\n\tif (!utmp_write_library(li, &ut)) {\n\t\tlogit(\"%s: utmp_write_library() failed\", __func__);\n\t\treturn (0);\n\t}\n# else\n\tif (!utmp_write_direct(li, &ut)) {\n\t\tlogit(\"%s: utmp_write_direct() failed\", __func__);\n\t\treturn (0);\n\t}\n# endif\n\treturn (1);\n}\n\n\nstatic int\nutmp_perform_logout(struct logininfo *li)\n{\n\tstruct utmp ut;\n\n\tconstruct_utmp(li, &ut);\n# ifdef UTMP_USE_LIBRARY\n\tif (!utmp_write_library(li, &ut)) {\n\t\tlogit(\"%s: utmp_write_library() failed\", __func__);\n\t\treturn (0);\n\t}\n# else\n\tif (!utmp_write_direct(li, &ut)) {\n\t\tlogit(\"%s: utmp_write_direct() failed\", __func__);\n\t\treturn (0);\n\t}\n# endif\n\treturn (1);\n}\n\n\nint\nutmp_write_entry(struct logininfo *li)\n{\n\tswitch(li->type) {\n\tcase LTYPE_LOGIN:\n\t\treturn (utmp_perform_login(li));\n\n\tcase LTYPE_LOGOUT:\n\t\treturn (utmp_perform_logout(li));\n\n\tdefault:\n\t\tlogit(\"%s: invalid type field\", __func__);\n\t\treturn (0);\n\t}\n}\n#endif  \n\n\n \n\n \n#ifdef USE_UTMPX\n\n \n# if !defined(DISABLE_PUTUTXLINE) && defined(HAVE_SETUTXENT) && \\\n\tdefined(HAVE_PUTUTXLINE)\n#  define UTMPX_USE_LIBRARY\n# endif\n\n\n \n# ifdef UTMPX_USE_LIBRARY\nstatic int\nutmpx_write_library(struct logininfo *li, struct utmpx *utx)\n{\n\tsetutxent();\n\tpututxline(utx);\n\n#  ifdef HAVE_ENDUTXENT\n\tendutxent();\n#  endif\n\treturn (1);\n}\n\n# else  \n\n \nstatic int\nutmpx_write_direct(struct logininfo *li, struct utmpx *utx)\n{\n\tlogit(\"%s: not implemented!\", __func__);\n\treturn (0);\n}\n# endif  \n\nstatic int\nutmpx_perform_login(struct logininfo *li)\n{\n\tstruct utmpx utx;\n\n\tconstruct_utmpx(li, &utx);\n# ifdef UTMPX_USE_LIBRARY\n\tif (!utmpx_write_library(li, &utx)) {\n\t\tlogit(\"%s: utmp_write_library() failed\", __func__);\n\t\treturn (0);\n\t}\n# else\n\tif (!utmpx_write_direct(li, &ut)) {\n\t\tlogit(\"%s: utmp_write_direct() failed\", __func__);\n\t\treturn (0);\n\t}\n# endif\n\treturn (1);\n}\n\n\nstatic int\nutmpx_perform_logout(struct logininfo *li)\n{\n\tstruct utmpx utx;\n\n\tconstruct_utmpx(li, &utx);\n# ifdef HAVE_ID_IN_UTMPX\n\tline_abbrevname(utx.ut_id, li->line, sizeof(utx.ut_id));\n# endif\n# ifdef HAVE_TYPE_IN_UTMPX\n\tutx.ut_type = DEAD_PROCESS;\n# endif\n\n# ifdef UTMPX_USE_LIBRARY\n\tutmpx_write_library(li, &utx);\n# else\n\tutmpx_write_direct(li, &utx);\n# endif\n\treturn (1);\n}\n\nint\nutmpx_write_entry(struct logininfo *li)\n{\n\tswitch(li->type) {\n\tcase LTYPE_LOGIN:\n\t\treturn (utmpx_perform_login(li));\n\tcase LTYPE_LOGOUT:\n\t\treturn (utmpx_perform_logout(li));\n\tdefault:\n\t\tlogit(\"%s: invalid type field\", __func__);\n\t\treturn (0);\n\t}\n}\n#endif  \n\n\n \n\n#ifdef USE_WTMP\n\n \nstatic int\nwtmp_write(struct logininfo *li, struct utmp *ut)\n{\n\tstruct stat buf;\n\tint fd, ret = 1;\n\n\tif ((fd = open(WTMP_FILE, O_WRONLY|O_APPEND, 0)) < 0) {\n\t\tlogit(\"%s: problem writing %s: %s\", __func__,\n\t\t    WTMP_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (fstat(fd, &buf) == 0)\n\t\tif (atomicio(vwrite, fd, ut, sizeof(*ut)) != sizeof(*ut)) {\n\t\t\tftruncate(fd, buf.st_size);\n\t\t\tlogit(\"%s: problem writing %s: %s\", __func__,\n\t\t\t    WTMP_FILE, strerror(errno));\n\t\t\tret = 0;\n\t\t}\n\tclose(fd);\n\treturn (ret);\n}\n\nstatic int\nwtmp_perform_login(struct logininfo *li)\n{\n\tstruct utmp ut;\n\n\tconstruct_utmp(li, &ut);\n\treturn (wtmp_write(li, &ut));\n}\n\n\nstatic int\nwtmp_perform_logout(struct logininfo *li)\n{\n\tstruct utmp ut;\n\n\tconstruct_utmp(li, &ut);\n\treturn (wtmp_write(li, &ut));\n}\n\n\nint\nwtmp_write_entry(struct logininfo *li)\n{\n\tswitch(li->type) {\n\tcase LTYPE_LOGIN:\n\t\treturn (wtmp_perform_login(li));\n\tcase LTYPE_LOGOUT:\n\t\treturn (wtmp_perform_logout(li));\n\tdefault:\n\t\tlogit(\"%s: invalid type field\", __func__);\n\t\treturn (0);\n\t}\n}\n\n\n \n\n \nstatic int\nwtmp_islogin(struct logininfo *li, struct utmp *ut)\n{\n\tif (strncmp(li->username, ut->ut_name,\n\t    MIN_SIZEOF(li->username, ut->ut_name)) == 0) {\n# ifdef HAVE_TYPE_IN_UTMP\n\t\tif (ut->ut_type & USER_PROCESS)\n\t\t\treturn (1);\n# else\n\t\treturn (1);\n# endif\n\t}\n\treturn (0);\n}\n\nint\nwtmp_get_entry(struct logininfo *li)\n{\n\tstruct stat st;\n\tstruct utmp ut;\n\tint fd, found = 0;\n\n\t \n\tli->tv_sec = li->tv_usec = 0;\n\n\tif ((fd = open(WTMP_FILE, O_RDONLY)) < 0) {\n\t\tlogit(\"%s: problem opening %s: %s\", __func__,\n\t\t    WTMP_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (fstat(fd, &st) != 0) {\n\t\tlogit(\"%s: couldn't stat %s: %s\", __func__,\n\t\t    WTMP_FILE, strerror(errno));\n\t\tclose(fd);\n\t\treturn (0);\n\t}\n\n\t \n\tif (lseek(fd, -(off_t)sizeof(struct utmp), SEEK_END) == -1) {\n\t\t \n\t\tclose(fd);\n\t\treturn (0);\n\t}\n\n\twhile (!found) {\n\t\tif (atomicio(read, fd, &ut, sizeof(ut)) != sizeof(ut)) {\n\t\t\tlogit(\"%s: read of %s failed: %s\", __func__,\n\t\t\t    WTMP_FILE, strerror(errno));\n\t\t\tclose (fd);\n\t\t\treturn (0);\n\t\t}\n\t\tif (wtmp_islogin(li, &ut) ) {\n\t\t\tfound = 1;\n\t\t\t \n# ifdef HAVE_TIME_IN_UTMP\n\t\t\tli->tv_sec = ut.ut_time;\n# else\n#  if HAVE_TV_IN_UTMP\n\t\t\tli->tv_sec = ut.ut_tv.tv_sec;\n#  endif\n# endif\n\t\t\tline_fullname(li->line, ut.ut_line,\n\t\t\t    MIN_SIZEOF(li->line, ut.ut_line));\n# ifdef HAVE_HOST_IN_UTMP\n\t\t\tstrlcpy(li->hostname, ut.ut_host,\n\t\t\t    MIN_SIZEOF(li->hostname, ut.ut_host));\n# endif\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (lseek(fd, -(off_t)(2 * sizeof(struct utmp)), SEEK_CUR) == -1) {\n\t\t\t \n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t \n\tclose(fd);\n\treturn (1);\n}\n# endif  \n\n\n \n\n#ifdef USE_WTMPX\n \nstatic int\nwtmpx_write(struct logininfo *li, struct utmpx *utx)\n{\n#ifndef HAVE_UPDWTMPX\n\tstruct stat buf;\n\tint fd, ret = 1;\n\n\tif ((fd = open(WTMPX_FILE, O_WRONLY|O_APPEND, 0)) < 0) {\n\t\tlogit(\"%s: problem opening %s: %s\", __func__,\n\t\t    WTMPX_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (fstat(fd, &buf) == 0)\n\t\tif (atomicio(vwrite, fd, utx, sizeof(*utx)) != sizeof(*utx)) {\n\t\t\tftruncate(fd, buf.st_size);\n\t\t\tlogit(\"%s: problem writing %s: %s\", __func__,\n\t\t\t    WTMPX_FILE, strerror(errno));\n\t\t\tret = 0;\n\t\t}\n\tclose(fd);\n\n\treturn (ret);\n#else\n\tupdwtmpx(WTMPX_FILE, utx);\n\treturn (1);\n#endif\n}\n\n\nstatic int\nwtmpx_perform_login(struct logininfo *li)\n{\n\tstruct utmpx utx;\n\n\tconstruct_utmpx(li, &utx);\n\treturn (wtmpx_write(li, &utx));\n}\n\n\nstatic int\nwtmpx_perform_logout(struct logininfo *li)\n{\n\tstruct utmpx utx;\n\n\tconstruct_utmpx(li, &utx);\n\treturn (wtmpx_write(li, &utx));\n}\n\n\nint\nwtmpx_write_entry(struct logininfo *li)\n{\n\tswitch(li->type) {\n\tcase LTYPE_LOGIN:\n\t\treturn (wtmpx_perform_login(li));\n\tcase LTYPE_LOGOUT:\n\t\treturn (wtmpx_perform_logout(li));\n\tdefault:\n\t\tlogit(\"%s: invalid type field\", __func__);\n\t\treturn (0);\n\t}\n}\n\n \n\n \nstatic int\nwtmpx_islogin(struct logininfo *li, struct utmpx *utx)\n{\n\tif (strncmp(li->username, utx->ut_user,\n\t    MIN_SIZEOF(li->username, utx->ut_user)) == 0 ) {\n# ifdef HAVE_TYPE_IN_UTMPX\n\t\tif (utx->ut_type == USER_PROCESS)\n\t\t\treturn (1);\n# else\n\t\treturn (1);\n# endif\n\t}\n\treturn (0);\n}\n\n\nint\nwtmpx_get_entry(struct logininfo *li)\n{\n\tstruct stat st;\n\tstruct utmpx utx;\n\tint fd, found=0;\n\n\t \n\tli->tv_sec = li->tv_usec = 0;\n\n\tif ((fd = open(WTMPX_FILE, O_RDONLY)) < 0) {\n\t\tlogit(\"%s: problem opening %s: %s\", __func__,\n\t\t    WTMPX_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (fstat(fd, &st) != 0) {\n\t\tlogit(\"%s: couldn't stat %s: %s\", __func__,\n\t\t    WTMPX_FILE, strerror(errno));\n\t\tclose(fd);\n\t\treturn (0);\n\t}\n\n\t \n\tif (lseek(fd, -(off_t)sizeof(struct utmpx), SEEK_END) == -1 ) {\n\t\t \n\t\tclose(fd);\n\t\treturn (0);\n\t}\n\n\twhile (!found) {\n\t\tif (atomicio(read, fd, &utx, sizeof(utx)) != sizeof(utx)) {\n\t\t\tlogit(\"%s: read of %s failed: %s\", __func__,\n\t\t\t    WTMPX_FILE, strerror(errno));\n\t\t\tclose (fd);\n\t\t\treturn (0);\n\t\t}\n\t\t \n\t\tif (wtmpx_islogin(li, &utx)) {\n\t\t\tfound = 1;\n# if defined(HAVE_TV_IN_UTMPX)\n\t\t\tli->tv_sec = utx.ut_tv.tv_sec;\n# elif defined(HAVE_TIME_IN_UTMPX)\n\t\t\tli->tv_sec = utx.ut_time;\n# endif\n\t\t\tline_fullname(li->line, utx.ut_line, sizeof(li->line));\n# if defined(HAVE_HOST_IN_UTMPX)\n\t\t\tstrlcpy(li->hostname, utx.ut_host,\n\t\t\t    MIN_SIZEOF(li->hostname, utx.ut_host));\n# endif\n\t\t\tcontinue;\n\t\t}\n\t\tif (lseek(fd, -(off_t)(2 * sizeof(struct utmpx)), SEEK_CUR) == -1) {\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tclose(fd);\n\treturn (1);\n}\n#endif  \n\n \n\n#ifdef USE_LOGIN\nstatic int\nsyslogin_perform_login(struct logininfo *li)\n{\n\tstruct utmp *ut;\n\n\tut = xmalloc(sizeof(*ut));\n\tconstruct_utmp(li, ut);\n\tlogin(ut);\n\tfree(ut);\n\n\treturn (1);\n}\n\nstatic int\nsyslogin_perform_logout(struct logininfo *li)\n{\n# ifdef HAVE_LOGOUT\n\tchar line[UT_LINESIZE];\n\n\t(void)line_stripname(line, li->line, sizeof(line));\n\n\tif (!logout(line))\n\t\tlogit(\"%s: logout() returned an error\", __func__);\n#  ifdef HAVE_LOGWTMP\n\telse\n\t\tlogwtmp(line, \"\", \"\");\n#  endif\n\t \n# endif\n\treturn (1);\n}\n\nint\nsyslogin_write_entry(struct logininfo *li)\n{\n\tswitch (li->type) {\n\tcase LTYPE_LOGIN:\n\t\treturn (syslogin_perform_login(li));\n\tcase LTYPE_LOGOUT:\n\t\treturn (syslogin_perform_logout(li));\n\tdefault:\n\t\tlogit(\"%s: Invalid type field\", __func__);\n\t\treturn (0);\n\t}\n}\n#endif  \n\n \n\n \n\n#ifdef USE_LASTLOG\n\n#if !defined(LASTLOG_WRITE_PUTUTXLINE) || !defined(HAVE_GETLASTLOGXBYNAME)\n \nstatic int\nlastlog_openseek(struct logininfo *li, int *fd, int filemode)\n{\n\toff_t offset;\n\tchar lastlog_file[1024];\n\tstruct stat st;\n\n\tif (stat(LASTLOG_FILE, &st) != 0) {\n\t\tlogit(\"%s: Couldn't stat %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\t}\n\tif (S_ISDIR(st.st_mode)) {\n\t\tsnprintf(lastlog_file, sizeof(lastlog_file), \"%s/%s\",\n\t\t    LASTLOG_FILE, li->username);\n\t} else if (S_ISREG(st.st_mode)) {\n\t\tstrlcpy(lastlog_file, LASTLOG_FILE, sizeof(lastlog_file));\n\t} else {\n\t\tlogit(\"%s: %.100s is not a file or directory!\", __func__,\n\t\t    LASTLOG_FILE);\n\t\treturn (0);\n\t}\n\n\t*fd = open(lastlog_file, filemode, 0600);\n\tif (*fd < 0) {\n\t\tdebug(\"%s: Couldn't open %s: %s\", __func__,\n\t\t    lastlog_file, strerror(errno));\n\t\treturn (0);\n\t}\n\n\tif (S_ISREG(st.st_mode)) {\n\t\t \n\t\toffset = (off_t) ((u_long)li->uid * sizeof(struct lastlog));\n\n\t\tif (lseek(*fd, offset, SEEK_SET) != offset) {\n\t\t\tlogit(\"%s: %s->lseek(): %s\", __func__,\n\t\t\t    lastlog_file, strerror(errno));\n\t\t\tclose(*fd);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}\n#endif  \n\n#ifdef LASTLOG_WRITE_PUTUTXLINE\nint\nlastlog_write_entry(struct logininfo *li)\n{\n\tswitch(li->type) {\n\tcase LTYPE_LOGIN:\n\t\treturn 1;  \n\tdefault:\n\t\tlogit(\"lastlog_write_entry: Invalid type field\");\n\t\treturn 0;\n\t}\n}\n#else  \nint\nlastlog_write_entry(struct logininfo *li)\n{\n\tstruct lastlog last;\n\tint fd;\n\n\tswitch(li->type) {\n\tcase LTYPE_LOGIN:\n\t\t \n\t\tmemset(&last, '\\0', sizeof(last));\n\t\tline_stripname(last.ll_line, li->line, sizeof(last.ll_line));\n\t\tstrlcpy(last.ll_host, li->hostname,\n\t\t    MIN_SIZEOF(last.ll_host, li->hostname));\n\t\tlast.ll_time = li->tv_sec;\n\t\n\t\tif (!lastlog_openseek(li, &fd, O_RDWR|O_CREAT))\n\t\t\treturn (0);\n\t\n\t\t \n\t\tif (atomicio(vwrite, fd, &last, sizeof(last)) != sizeof(last)) {\n\t\t\tclose(fd);\n\t\t\tlogit(\"%s: Error writing to %s: %s\", __func__,\n\t\t\t    LASTLOG_FILE, strerror(errno));\n\t\t\treturn (0);\n\t\t}\n\t\n\t\tclose(fd);\n\t\treturn (1);\n\tdefault:\n\t\tlogit(\"%s: Invalid type field\", __func__);\n\t\treturn (0);\n\t}\n}\n#endif  \n\n#ifdef HAVE_GETLASTLOGXBYNAME\nint\nlastlog_get_entry(struct logininfo *li)\n{\n\tstruct lastlogx l, *ll;\n\n\tif ((ll = getlastlogxbyname(li->username, &l)) == NULL) {\n\t\tmemset(&l, '\\0', sizeof(l));\n\t\tll = &l;\n\t}\n\tline_fullname(li->line, ll->ll_line, sizeof(li->line));\n\tstrlcpy(li->hostname, ll->ll_host,\n\t\tMIN_SIZEOF(li->hostname, ll->ll_host));\n\tli->tv_sec = ll->ll_tv.tv_sec;\n\tli->tv_usec = ll->ll_tv.tv_usec;\n\treturn (1);\n}\n#else  \nint\nlastlog_get_entry(struct logininfo *li)\n{\n\tstruct lastlog last;\n\tint fd, ret;\n\n\tif (!lastlog_openseek(li, &fd, O_RDONLY))\n\t\treturn (0);\n\n\tret = atomicio(read, fd, &last, sizeof(last));\n\tclose(fd);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tmemset(&last, '\\0', sizeof(last));\n\t\t \n\tcase sizeof(last):\n\t\tline_fullname(li->line, last.ll_line, sizeof(li->line));\n\t\tstrlcpy(li->hostname, last.ll_host,\n\t\t    MIN_SIZEOF(li->hostname, last.ll_host));\n\t\tli->tv_sec = last.ll_time;\n\t\treturn (1);\n\tcase -1:\n\t\terror(\"%s: Error reading from %s: %s\", __func__,\n\t\t    LASTLOG_FILE, strerror(errno));\n\t\treturn (0);\n\tdefault:\n\t\terror(\"%s: Error reading from %s: Expecting %d, got %d\",\n\t\t    __func__, LASTLOG_FILE, (int)sizeof(last), ret);\n\t\treturn (0);\n\t}\n\n\t \n\treturn (0);\n}\n#endif  \n#endif  \n\n#if defined(USE_UTMPX) && defined(HAVE_SETUTXDB) && \\\n    defined(UTXDB_LASTLOGIN) && defined(HAVE_GETUTXUSER)\nint\nutmpx_get_entry(struct logininfo *li)\n{\n\tstruct utmpx *utx;\n\n\tif (setutxdb(UTXDB_LASTLOGIN, NULL) != 0)\n\t\treturn (0);\n\tutx = getutxuser(li->username);\n\tif (utx == NULL) {\n\t\tendutxent();\n\t\treturn (0);\n\t}\n\n\tline_fullname(li->line, utx->ut_line,\n\t    MIN_SIZEOF(li->line, utx->ut_line));\n\tstrlcpy(li->hostname, utx->ut_host,\n\t    MIN_SIZEOF(li->hostname, utx->ut_host));\n\tli->tv_sec = utx->ut_tv.tv_sec;\n\tli->tv_usec = utx->ut_tv.tv_usec;\n\tendutxent();\n\treturn (1);\n}\n#endif  \n\n#ifdef USE_BTMP\n   \n\nvoid\nrecord_failed_login(struct ssh *ssh, const char *username, const char *hostname,\n    const char *ttyn)\n{\n\tint fd;\n\tstruct utmp ut;\n\tstruct sockaddr_storage from;\n\tsocklen_t fromlen = sizeof(from);\n\tstruct sockaddr_in *a4;\n\tstruct sockaddr_in6 *a6;\n\ttime_t t;\n\tstruct stat fst;\n\n\tif (geteuid() != 0)\n\t\treturn;\n\tif ((fd = open(_PATH_BTMP, O_WRONLY | O_APPEND)) < 0) {\n\t\tdebug(\"Unable to open the btmp file %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\t\treturn;\n\t}\n\tif (fstat(fd, &fst) < 0) {\n\t\tlogit(\"%s: fstat of %s failed: %s\", __func__, _PATH_BTMP,\n\t\t    strerror(errno));\n\t\tgoto out;\n\t}\n\tif((fst.st_mode & (S_IXGRP | S_IRWXO)) || (fst.st_uid != 0)){\n\t\tlogit(\"Excess permission or bad ownership on file %s\",\n\t\t    _PATH_BTMP);\n\t\tgoto out;\n\t}\n\n\tmemset(&ut, 0, sizeof(ut));\n\t \n\tstrncpy(ut.ut_user, username, sizeof(ut.ut_user));\n\tstrlcpy(ut.ut_line, \"ssh:notty\", sizeof(ut.ut_line));\n\n\ttime(&t);\n\tut.ut_time = t;      \n\tut.ut_type = LOGIN_PROCESS;\n\tut.ut_pid = getpid();\n\n\t \n\tstrncpy(ut.ut_host, hostname, sizeof(ut.ut_host));\n\n\tif (ssh_packet_connection_is_on_socket(ssh) &&\n\t    getpeername(ssh_packet_get_connection_in(ssh),\n\t    (struct sockaddr *)&from, &fromlen) == 0) {\n\t\tipv64_normalise_mapped(&from, &fromlen);\n\t\tif (from.ss_family == AF_INET) {\n\t\t\ta4 = (struct sockaddr_in *)&from;\n\t\t\tmemcpy(&ut.ut_addr, &(a4->sin_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr, a4->sin_addr));\n\t\t}\n#ifdef HAVE_ADDR_V6_IN_UTMP\n\t\tif (from.ss_family == AF_INET6) {\n\t\t\ta6 = (struct sockaddr_in6 *)&from;\n\t\t\tmemcpy(&ut.ut_addr_v6, &(a6->sin6_addr),\n\t\t\t    MIN_SIZEOF(ut.ut_addr_v6, a6->sin6_addr));\n\t\t}\n#endif\n\t}\n\n\tif (atomicio(vwrite, fd, &ut, sizeof(ut)) != sizeof(ut))\n\t\terror(\"Failed to write to %s: %s\", _PATH_BTMP,\n\t\t    strerror(errno));\n\nout:\n\tclose(fd);\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}