{
  "module_name": "ssh-pkcs11-helper.c",
  "hash_id": "ef53572313530a29452cd1211ee08d3b28664e0bc624adc1e6a1dc9ff7d1d950",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-pkcs11-helper.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include \"openbsd-compat/sys-queue.h\"\n\n#include <stdlib.h>\n#include <errno.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"xmalloc.h\"\n#include \"sshbuf.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"ssh-pkcs11.h\"\n#include \"ssherr.h\"\n\n#ifdef ENABLE_PKCS11\n\n#ifdef WITH_OPENSSL\n\n \n\nstruct pkcs11_keyinfo {\n\tstruct sshkey\t*key;\n\tchar\t\t*providername, *label;\n\tTAILQ_ENTRY(pkcs11_keyinfo) next;\n};\n\nTAILQ_HEAD(, pkcs11_keyinfo) pkcs11_keylist;\n\n#define MAX_MSG_LENGTH\t\t10240  \n\n \nstruct sshbuf *iqueue;\nstruct sshbuf *oqueue;\n\nstatic void\nadd_key(struct sshkey *k, char *name, char *label)\n{\n\tstruct pkcs11_keyinfo *ki;\n\n\tki = xcalloc(1, sizeof(*ki));\n\tki->providername = xstrdup(name);\n\tki->key = k;\n\tki->label = xstrdup(label);\n\tTAILQ_INSERT_TAIL(&pkcs11_keylist, ki, next);\n}\n\nstatic void\ndel_keys_by_name(char *name)\n{\n\tstruct pkcs11_keyinfo *ki, *nxt;\n\n\tfor (ki = TAILQ_FIRST(&pkcs11_keylist); ki; ki = nxt) {\n\t\tnxt = TAILQ_NEXT(ki, next);\n\t\tif (!strcmp(ki->providername, name)) {\n\t\t\tTAILQ_REMOVE(&pkcs11_keylist, ki, next);\n\t\t\tfree(ki->providername);\n\t\t\tfree(ki->label);\n\t\t\tsshkey_free(ki->key);\n\t\t\tfree(ki);\n\t\t}\n\t}\n}\n\n \nstatic struct sshkey *\nlookup_key(struct sshkey *k)\n{\n\tstruct pkcs11_keyinfo *ki;\n\n\tTAILQ_FOREACH(ki, &pkcs11_keylist, next) {\n\t\tdebug(\"check %s %s %s\", sshkey_type(ki->key),\n\t\t    ki->providername, ki->label);\n\t\tif (sshkey_equal(k, ki->key))\n\t\t\treturn (ki->key);\n\t}\n\treturn (NULL);\n}\n\nstatic void\nsend_msg(struct sshbuf *m)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_stringb(oqueue, m)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n}\n\nstatic void\nprocess_add(void)\n{\n\tchar *name, *pin;\n\tstruct sshkey **keys = NULL;\n\tint r, i, nkeys;\n\tu_char *blob;\n\tsize_t blen;\n\tstruct sshbuf *msg;\n\tchar **labels = NULL;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &pin, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif ((nkeys = pkcs11_add_provider(name, pin, &keys, &labels)) > 0) {\n\t\tif ((r = sshbuf_put_u8(msg,\n\t\t    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t\t    (r = sshbuf_put_u32(msg, nkeys)) != 0)\n\t\t\tfatal_fr(r, \"compose\");\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\tif ((r = sshkey_to_blob(keys[i], &blob, &blen)) != 0) {\n\t\t\t\tdebug_fr(r, \"encode key\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_string(msg, blob, blen)) != 0 ||\n\t\t\t    (r = sshbuf_put_cstring(msg, labels[i])) != 0)\n\t\t\t\tfatal_fr(r, \"compose key\");\n\t\t\tfree(blob);\n\t\t\tadd_key(keys[i], name, labels[i]);\n\t\t\tfree(labels[i]);\n\t\t}\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, -nkeys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tfree(labels);\n\tfree(keys);  \n\tfree(pin);\n\tfree(name);\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nprocess_del(void)\n{\n\tchar *name, *pin;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &pin, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdel_keys_by_name(name);\n\tif ((r = sshbuf_put_u8(msg, pkcs11_del_provider(name) == 0 ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tfree(pin);\n\tfree(name);\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nprocess_sign(void)\n{\n\tu_char *blob, *data, *signature = NULL;\n\tsize_t blen, dlen, slen = 0;\n\tint r, ok = -1;\n\tstruct sshkey *key, *found;\n\tstruct sshbuf *msg;\n\n\t \n\tif ((r = sshbuf_get_string(iqueue, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_string(iqueue, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0)\n\t\tfatal_fr(r, \"decode key\");\n\telse {\n\t\tif ((found = lookup_key(key)) != NULL) {\n#ifdef WITH_OPENSSL\n\t\t\tint ret;\n\n\t\t\tif (key->type == KEY_RSA) {\n\t\t\t\tslen = RSA_size(key->rsa);\n\t\t\t\tsignature = xmalloc(slen);\n\t\t\t\tret = RSA_private_encrypt(dlen, data, signature,\n\t\t\t\t    found->rsa, RSA_PKCS1_PADDING);\n\t\t\t\tif (ret != -1) {\n\t\t\t\t\tslen = ret;\n\t\t\t\t\tok = 0;\n\t\t\t\t}\n#ifdef OPENSSL_HAS_ECC\n\t\t\t} else if (key->type == KEY_ECDSA) {\n\t\t\t\tu_int xslen = ECDSA_size(key->ecdsa);\n\n\t\t\t\tsignature = xmalloc(xslen);\n\t\t\t\t \n\t\t\t\tret = ECDSA_sign(-1, data, dlen, signature,\n\t\t\t\t    &xslen, found->ecdsa);\n\t\t\t\tif (ret != 0)\n\t\t\t\t\tok = 0;\n\t\t\t\telse\n\t\t\t\t\terror_f(\"ECDSA_sign returned %d\", ret);\n\t\t\t\tslen = xslen;\n#endif  \n\t\t\t} else\n\t\t\t\terror_f(\"don't know how to sign with key \"\n\t\t\t\t    \"type %d\", (int)key->type);\n#endif  \n\t\t}\n\t\tsshkey_free(key);\n\t}\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal_fr(r, \"compose response\");\n\t} else {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_FAILURE)) != 0)\n\t\t\tfatal_fr(r, \"compose failure response\");\n\t}\n\tfree(data);\n\tfree(blob);\n\tfree(signature);\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nprocess(void)\n{\n\tu_int msg_len;\n\tu_int buf_len;\n\tu_int consumed;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\n\tbuf_len = sshbuf_len(iqueue);\n\tif (buf_len < 5)\n\t\treturn;\t\t \n\tcp = sshbuf_ptr(iqueue);\n\tmsg_len = get_u32(cp);\n\tif (msg_len > MAX_MSG_LENGTH) {\n\t\terror(\"bad message len %d\", msg_len);\n\t\tcleanup_exit(11);\n\t}\n\tif (buf_len < msg_len + 4)\n\t\treturn;\n\tif ((r = sshbuf_consume(iqueue, 4)) != 0 ||\n\t    (r = sshbuf_get_u8(iqueue, &type)) != 0)\n\t\tfatal_fr(r, \"parse type/len\");\n\tbuf_len -= 4;\n\tswitch (type) {\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\t\tdebug(\"process_add\");\n\t\tprocess_add();\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tdebug(\"process_del\");\n\t\tprocess_del();\n\t\tbreak;\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tdebug(\"process_sign\");\n\t\tprocess_sign();\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unknown message %d\", type);\n\t\tbreak;\n\t}\n\t \n\tif (buf_len < sshbuf_len(iqueue)) {\n\t\terror(\"iqueue grew unexpectedly\");\n\t\tcleanup_exit(255);\n\t}\n\tconsumed = buf_len - sshbuf_len(iqueue);\n\tif (msg_len < consumed) {\n\t\terror(\"msg_len %d < consumed %d\", msg_len, consumed);\n\t\tcleanup_exit(255);\n\t}\n\tif (msg_len > consumed) {\n\t\tif ((r = sshbuf_consume(iqueue, msg_len - consumed)) != 0)\n\t\t\tfatal_fr(r, \"consume\");\n\t}\n}\n\nvoid\ncleanup_exit(int i)\n{\n\t \n\t_exit(i);\n}\n\n\nint\nmain(int argc, char **argv)\n{\n\tint r, ch, in, out, log_stderr = 0;\n\tssize_t len;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tLogLevel log_level = SYSLOG_LEVEL_ERROR;\n\tchar buf[4*4096];\n\textern char *__progname;\n\tstruct pollfd pfd[2];\n\n\t__progname = ssh_get_progname(argv[0]);\n\tseed_rng();\n\tTAILQ_INIT(&pkcs11_keylist);\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\twhile ((ch = getopt(argc, argv, \"v\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'v':\n\t\t\tlog_stderr = 1;\n\t\t\tif (log_level == SYSLOG_LEVEL_ERROR)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse if (log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\tlog_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"usage: %s [-v]\\n\", __progname);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\tpkcs11_init(0);\n\tin = STDIN_FILENO;\n\tout = STDOUT_FILENO;\n\n\tif ((iqueue = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((oqueue = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\twhile (1) {\n\t\tmemset(pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = in;\n\t\tpfd[1].fd = out;\n\n\t\t \n\t\tif ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&\n\t\t    (r = sshbuf_check_reserve(oqueue, MAX_MSG_LENGTH)) == 0)\n\t\t\tpfd[0].events = POLLIN;\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal_fr(r, \"reserve\");\n\n\t\tif (sshbuf_len(oqueue) > 0)\n\t\t\tpfd[1].events = POLLOUT;\n\n\t\tif ((r = poll(pfd, 2, -1  )) <= 0) {\n\t\t\tif (r == 0 || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"poll: %s\", strerror(errno));\n\t\t}\n\n\t\t \n\t\tif ((pfd[0].revents & (POLLIN|POLLHUP|POLLERR)) != 0) {\n\t\t\tlen = read(in, buf, sizeof buf);\n\t\t\tif (len == 0) {\n\t\t\t\tdebug(\"read eof\");\n\t\t\t\tcleanup_exit(0);\n\t\t\t} else if (len < 0) {\n\t\t\t\terror(\"read: %s\", strerror(errno));\n\t\t\t\tcleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_put(iqueue, buf, len)) != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_put\");\n\t\t}\n\t\t \n\t\tif ((pfd[1].revents & (POLLOUT|POLLHUP)) != 0) {\n\t\t\tlen = write(out, sshbuf_ptr(oqueue),\n\t\t\t    sshbuf_len(oqueue));\n\t\t\tif (len < 0) {\n\t\t\t\terror(\"write: %s\", strerror(errno));\n\t\t\t\tcleanup_exit(1);\n\t\t\t} else if ((r = sshbuf_consume(oqueue, len)) != 0)\n\t\t\t\tfatal_fr(r, \"consume\");\n\t\t}\n\n\t\t \n\t\tif ((r = sshbuf_check_reserve(oqueue, MAX_MSG_LENGTH)) == 0)\n\t\t\tprocess();\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal_fr(r, \"reserve\");\n\t}\n}\n\n#else  \nvoid\ncleanup_exit(int i)\n{\n\t_exit(i);\n}\n\nint\nmain(int argc, char **argv)\n{\n\tfprintf(stderr, \"PKCS#11 code is not enabled\\n\");\n\treturn 1;\n}\n#endif  \n#else  \nint\nmain(int argc, char **argv)\n{\n\textern char *__progname;\n\n\t__progname = ssh_get_progname(argv[0]);\n\tlog_init(__progname, SYSLOG_LEVEL_ERROR, SYSLOG_FACILITY_AUTH, 0);\n\tfatal(\"PKCS#11 support disabled at compile time\");\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}