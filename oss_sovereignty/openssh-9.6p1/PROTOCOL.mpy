{
  "module_name": "PROTOCOL",
  "hash_id": "6dc7d438541a928734281de9568ccce61222490bfa3b6c49901781be03d5d41a",
  "original_prompt": "Ingested from openssh-9.6p1/PROTOCOL",
  "human_readable_source": "This documents OpenSSH's deviations and extensions to the published SSH\nprotocol.\n\nNote that OpenSSH's sftp and sftp-server implement revision 3 of the SSH\nfilexfer protocol described in:\n\nhttps://www.openssh.com/txt/draft-ietf-secsh-filexfer-02.txt\n\nNewer versions of the draft will not be supported, though some features\nare individually implemented as extensions described below.\n\nThe protocol used by OpenSSH's ssh-agent is described in the file\nPROTOCOL.agent\n\n1. Transport protocol changes\n\n1.1. transport: Protocol 2 MAC algorithm \"umac-64@openssh.com\"\n\nThis is a new transport-layer MAC method using the UMAC algorithm\n(rfc4418). This method is identical to the \"umac-64\" method documented\nin:\n\nhttps://www.openssh.com/txt/draft-miller-secsh-umac-01.txt\n\n1.2. transport: Protocol 2 compression algorithm \"zlib@openssh.com\"\n\nThis transport-layer compression method uses the zlib compression\nalgorithm (identical to the \"zlib\" method in rfc4253), but delays the\nstart of compression until after authentication has completed. This\navoids exposing compression code to attacks from unauthenticated users.\n\nThe method is documented in:\n\nhttps://www.openssh.com/txt/draft-miller-secsh-compression-delayed-00.txt\n\n1.3. transport: New public key algorithms \"ssh-rsa-cert-v01@openssh.com\",\n     \"ssh-dsa-cert-v01@openssh.com\",\n     \"ecdsa-sha2-nistp256-cert-v01@openssh.com\",\n     \"ecdsa-sha2-nistp384-cert-v01@openssh.com\" and\n     \"ecdsa-sha2-nistp521-cert-v01@openssh.com\"\n\nOpenSSH introduces new public key algorithms to support certificate\nauthentication for users and host keys. These methods are documented\nin the file PROTOCOL.certkeys\n\n1.4. transport: Elliptic Curve cryptography\n\nOpenSSH supports ECC key exchange and public key authentication as\nspecified in RFC5656. Only the ecdsa-sha2-nistp256, ecdsa-sha2-nistp384\nand ecdsa-sha2-nistp521 curves over GF(p) are supported. Elliptic\ncurve points encoded using point compression are NOT accepted or\ngenerated.\n\n1.5 transport: Protocol 2 Encrypt-then-MAC MAC algorithms\n\nOpenSSH supports MAC algorithms, whose names contain \"-etm\", that\nperform the calculations in a different order to that defined in RFC\n4253. These variants use the so-called \"encrypt then MAC\" ordering,\ncalculating the MAC over the packet ciphertext rather than the\nplaintext. This ordering closes a security flaw in the SSH transport\nprotocol, where decryption of unauthenticated ciphertext provided a\n\"decryption oracle\" that could, in conjunction with cipher flaws, reveal\nsession plaintext.\n\nSpecifically, the \"-etm\" MAC algorithms modify the transport protocol\nto calculate the MAC over the packet ciphertext and to send the packet\nlength unencrypted. This is necessary for the transport to obtain the\nlength of the packet and location of the MAC tag so that it may be\nverified without decrypting unauthenticated data.\n\nAs such, the MAC covers:\n\n      mac = MAC(key, sequence_number || packet_length || encrypted_packet)\n\nwhere \"packet_length\" is encoded as a uint32 and \"encrypted_packet\"\ncontains:\n\n      byte      padding_length\n      byte[n1]  payload; n1 = packet_length - padding_length - 1\n      byte[n2]  random padding; n2 = padding_length\n\n1.6 transport: AES-GCM\n\nOpenSSH supports the AES-GCM algorithm as specified in RFC 5647.\nBecause of problems with the specification of the key exchange\nthe behaviour of OpenSSH differs from the RFC as follows:\n\nAES-GCM is only negotiated as the cipher algorithms\n\"aes128-gcm@openssh.com\" or \"aes256-gcm@openssh.com\" and never as\nan MAC algorithm. Additionally, if AES-GCM is selected as the cipher\nthe exchanged MAC algorithms are ignored and there doesn't have to be\na matching MAC.\n\n1.7 transport: chacha20-poly1305@openssh.com authenticated encryption\n\nOpenSSH supports authenticated encryption using ChaCha20 and Poly1305\nas described in PROTOCOL.chacha20poly1305.\n\n1.8 transport: curve25519-sha256@libssh.org key exchange algorithm\n\nOpenSSH supports the use of ECDH in Curve25519 for key exchange as\ndescribed at:\nhttp://git.libssh.org/users/aris/libssh.git/plain/doc/curve25519-sha256@libssh.org.txt?h=curve25519\n\nThis is identical to curve25519-sha256 as later published in RFC8731.\n\n1.9 transport: ping facility\n\nOpenSSH implements a transport level ping message SSH2_MSG_PING\nand a corresponding SSH2_MSG_PONG reply.\n\n#define SSH2_MSG_PING\t192\n#define SSH2_MSG_PONG\t193\n\nThe ping message is simply:\n\n\tbyte\t\tSSH_MSG_PING\n\tstring\t\tdata\n\nThe reply copies the data (which may be the empty string) from the\nping:\n\n\tbyte\t\tSSH_MSG_PONG\n\tstring\t\tdata\n\nReplies are sent in order. They are sent immediately except when rekeying\nis in progress, in which case they are queued until rekeying completes.\n\nThe server advertises support for these messages using the\nSSH2_MSG_EXT_INFO mechanism (RFC8308), with the following message:\n\n\tstring\t\t\"ping@openssh.com\"\n\tstring\t\t\"0\" (version)\n\nThe ping/reply message is implemented at the transport layer rather\nthan as a named global or channel request to allow pings with very\nshort packet lengths, which would not be possible with other\napproaches.\n\n1.9 transport: strict key exchange extension\n\nOpenSSH supports a number of transport-layer hardening measures under\na \"strict KEX\" feature. This feature is signalled similarly to the\nRFC8308 ext-info feature: by including a additional algorithm in the\ninitiial SSH2_MSG_KEXINIT kex_algorithms field. The client may append\n\"kex-strict-c-v00@openssh.com\" to its kex_algorithms and the server\nmay append \"kex-strict-s-v00@openssh.com\". These pseudo-algorithms\nare only valid in the initial SSH2_MSG_KEXINIT and MUST be ignored\nif they are present in subsequent SSH2_MSG_KEXINIT packets.\n\nWhen an endpoint that supports this extension observes this algorithm\nname in a peer's KEXINIT packet, it MUST make the following changes to\nthe the protocol:\n\na) During initial KEX, terminate the connection if any unexpected or\n   out-of-sequence packet is received. This includes terminating the\n   connection if the first packet received is not SSH2_MSG_KEXINIT.\n   Unexpected packets for the purpose of strict KEX include messages\n   that are otherwise valid at any time during the connection such as\n   SSH2_MSG_DEBUG and SSH2_MSG_IGNORE.\nb) After sending or receiving a SSH2_MSG_NEWKEYS message, reset the\n   packet sequence number to zero. This behaviour persists for the\n   duration of the connection (i.e. not just the first\n   SSH2_MSG_NEWKEYS).\n\n1.10 transport: SSH2_MSG_EXT_INFO during user authentication\n\nThis protocol extension allows the SSH2_MSG_EXT_INFO to be sent\nduring user authentication. RFC8308 does allow a second\nSSH2_MSG_EXT_INFO notification, but it may only be sent at the end\nof user authentication and this is too late to signal per-user\nserver signature algorithms.\n\nSupport for receiving the SSH2_MSG_EXT_INFO message during user\nauthentication is signalled by the client including a\n\"ext-info-in-auth@openssh.com\" key via its initial SSH2_MSG_EXT_INFO\nset after the SSH2_MSG_NEWKEYS message.\n\nA server that supports this extension MAY send a second\nSSH2_MSG_EXT_INFO message any time after the client's first\nSSH2_MSG_USERAUTH_REQUEST, regardless of whether it succeed or fails.\nThe client SHOULD be prepared to update the server-sig-algs that\nit received during an earlier SSH2_MSG_EXT_INFO with the later one.\n\n2. Connection protocol changes\n\n2.1. connection: Channel write close extension \"eow@openssh.com\"\n\nThe SSH connection protocol (rfc4254) provides the SSH_MSG_CHANNEL_EOF\nmessage to allow an endpoint to signal its peer that it will send no\nmore data over a channel. Unfortunately, there is no symmetric way for\nan endpoint to request that its peer should cease sending data to it\nwhile still keeping the channel open for the endpoint to send data to\nthe peer.\n\nThis is desirable, since it saves the transmission of data that would\notherwise need to be discarded and it allows an endpoint to signal local\nprocesses of the condition, e.g. by closing the corresponding file\ndescriptor.\n\nOpenSSH implements a channel extension message to perform this\nsignalling: \"eow@openssh.com\" (End Of Write). This message is sent by\nan endpoint when the local output of a session channel is closed or\nexperiences a write error. The message is formatted as follows:\n\n\tbyte\t\tSSH_MSG_CHANNEL_REQUEST\n\tuint32\t\trecipient channel\n\tstring\t\t\"eow@openssh.com\"\n\tboolean\t\tFALSE\n\nOn receiving this message, the peer SHOULD cease sending data of\nthe channel and MAY signal the process from which the channel data\noriginates (e.g. by closing its read file descriptor).\n\nAs with the symmetric SSH_MSG_CHANNEL_EOF message, the channel does\nremain open after a \"eow@openssh.com\" has been sent and more data may\nstill be sent in the other direction. This message does not consume\nwindow space and may be sent even if no window space is available.\n\nNB. due to certain broken SSH implementations aborting upon receipt\nof this message (in contravention of RFC4254 section 5.4), this\nmessage is only sent to OpenSSH peers (identified by banner).\nOther SSH implementations may be listed to receive this message\nupon request.\n\n2.2. connection: disallow additional sessions extension\n     \"no-more-sessions@openssh.com\"\n\nMost SSH connections will only ever request a single session, but a\nattacker may abuse a running ssh client to surreptitiously open\nadditional sessions under their control. OpenSSH provides a global\nrequest \"no-more-sessions@openssh.com\" to mitigate this attack.\n\nWhen an OpenSSH client expects that it will never open another session\n(i.e. it has been started with connection multiplexing disabled), it\nwill send the following global request:\n\n\tbyte\t\tSSH_MSG_GLOBAL_REQUEST\n\tstring\t\t\"no-more-sessions@openssh.com\"\n\tchar\t\twant-reply\n\nOn receipt of such a message, an OpenSSH server will refuse to open\nfuture channels of type \"session\" and instead immediately abort the\nconnection.\n\nNote that this is not a general defence against compromised clients\n(that is impossible), but it thwarts a simple attack.\n\nNB. due to certain broken SSH implementations aborting upon receipt\nof this message, the no-more-sessions request is only sent to OpenSSH\nservers (identified by banner). Other SSH implementations may be\nlisted to receive this message upon request.\n\n2.3. connection: Tunnel forward extension \"tun@openssh.com\"\n\nOpenSSH supports layer 2 and layer 3 tunnelling via the \"tun@openssh.com\"\nchannel type. This channel type supports forwarding of network packets\nwith datagram boundaries intact between endpoints equipped with\ninterfaces like the BSD tun(4) device. Tunnel forwarding channels are\nrequested by the client with the following packet:\n\n\tbyte\t\tSSH_MSG_CHANNEL_OPEN\n\tstring\t\t\"tun@openssh.com\"\n\tuint32\t\tsender channel\n\tuint32\t\tinitial window size\n\tuint32\t\tmaximum packet size\n\tuint32\t\ttunnel mode\n\tuint32\t\tremote unit number\n\nThe \"tunnel mode\" parameter specifies whether the tunnel should forward\nlayer 2 frames or layer 3 packets. It may take one of the following values:\n\n\tSSH_TUNMODE_POINTOPOINT  1\t\t/* layer 3 packets */\n\tSSH_TUNMODE_ETHERNET     2\t\t/* layer 2 frames */\n\nThe \"tunnel unit number\" specifies the remote interface number, or may\nbe 0x7fffffff to allow the server to automatically choose an interface. A\nserver that is not willing to open a client-specified unit should refuse\nthe request with a SSH_MSG_CHANNEL_OPEN_FAILURE error. On successful\nopen, the server should reply with SSH_MSG_CHANNEL_OPEN_SUCCESS.\n\nOnce established the client and server may exchange packet or frames\nover the tunnel channel by encapsulating them in SSH protocol strings\nand sending them as channel data. This ensures that packet boundaries\nare kept intact. Specifically, packets are transmitted using normal\nSSH_MSG_CHANNEL_DATA packets:\n\n\tbyte\t\tSSH_MSG_CHANNEL_DATA\n\tuint32\t\trecipient channel\n\tstring\t\tdata\n\nThe contents of the \"data\" field for layer 3 packets is:\n\n\tuint32\t\t\tpacket length\n\tuint32\t\t\taddress family\n\tbyte[packet length - 4]\tpacket data\n\nThe \"address family\" field identifies the type of packet in the message.\nIt may be one of:\n\n\tSSH_TUN_AF_INET\t\t2\t\t/* IPv4 */\n\tSSH_TUN_AF_INET6\t24\t\t/* IPv6 */\n\nThe \"packet data\" field consists of the IPv4/IPv6 datagram itself\nwithout any link layer header.\n\nThe contents of the \"data\" field for layer 2 packets is:\n\n\tuint32\t\t\tpacket length\n\tbyte[packet length]\tframe\n\nThe \"frame\" field contains an IEEE 802.3 Ethernet frame, including\nheader.\n\n2.4. connection: Unix domain socket forwarding\n\nOpenSSH supports local and remote Unix domain socket forwarding\nusing the \"streamlocal\" extension.  Forwarding is initiated as per\nTCP sockets but with a single path instead of a host and port.\n\nSimilar to direct-tcpip, direct-streamlocal is sent by the client\nto request that the server make a connection to a Unix domain socket.\n\n\tbyte\t\tSSH_MSG_CHANNEL_OPEN\n\tstring\t\t\"direct-streamlocal@openssh.com\"\n\tuint32\t\tsender channel\n\tuint32\t\tinitial window size\n\tuint32\t\tmaximum packet size\n\tstring\t\tsocket path\n\tstring\t\treserved\n\tuint32\t\treserved\n\nSimilar to forwarded-tcpip, forwarded-streamlocal is sent by the\nserver when the client has previously send the server a streamlocal-forward\nGLOBAL_REQUEST.\n\n\tbyte\t\tSSH_MSG_CHANNEL_OPEN\n\tstring\t\t\"forwarded-streamlocal@openssh.com\"\n\tuint32\t\tsender channel\n\tuint32\t\tinitial window size\n\tuint32\t\tmaximum packet size\n\tstring\t\tsocket path\n\tstring\t\treserved for future use\n\nThe reserved field is not currently defined and is ignored on the\nremote end.  It is intended to be used in the future to pass\ninformation about the socket file, such as ownership and mode.\nThe client currently sends the empty string for this field.\n\nSimilar to tcpip-forward, streamlocal-forward is sent by the client\nto request remote forwarding of a Unix domain socket.\n\n\tbyte\t\tSSH2_MSG_GLOBAL_REQUEST\n\tstring\t\t\"streamlocal-forward@openssh.com\"\n\tboolean\t\tTRUE\n\tstring\t\tsocket path\n\nSimilar to cancel-tcpip-forward, cancel-streamlocal-forward is sent\nby the client cancel the forwarding of a Unix domain socket.\n\n\tbyte\t\tSSH2_MSG_GLOBAL_REQUEST\n\tstring\t\t\"cancel-streamlocal-forward@openssh.com\"\n\tboolean\t\tFALSE\n\tstring\t\tsocket path\n\n2.5. connection: hostkey update and rotation \"hostkeys-00@openssh.com\"\nand \"hostkeys-prove-00@openssh.com\"\n\nOpenSSH supports a protocol extension allowing a server to inform\na client of all its protocol v.2 host keys after user-authentication\nhas completed.\n\n\tbyte\t\tSSH_MSG_GLOBAL_REQUEST\n\tstring\t\t\"hostkeys-00@openssh.com\"\n\tchar\t\t0 /* want-reply */\n\tstring[]\thostkeys\n\nUpon receiving this message, a client should check which of the\nsupplied host keys are present in known_hosts.\n\nNote that the server may send key types that the client does not\nsupport. The client should disregard such keys if they are received.\n\nIf the client identifies any keys that are not present for the host,\nit should send a \"hostkeys-prove@openssh.com\" message to request the\nserver prove ownership of the private half of the key.\n\n\tbyte\t\tSSH_MSG_GLOBAL_REQUEST\n\tstring\t\t\"hostkeys-prove-00@openssh.com\"\n\tchar\t\t1 /* want-reply */\n\tstring[]\thostkeys\n\nWhen a server receives this message, it should generate a signature\nusing each requested key over the following:\n\n\tstring\t\t\"hostkeys-prove-00@openssh.com\"\n\tstring\t\tsession identifier\n\tstring\t\thostkey\n\nThese signatures should be included in the reply, in the order matching\nthe hostkeys in the request:\n\n\tbyte\t\tSSH_MSG_REQUEST_SUCCESS\n\tstring[]\tsignatures\n\nWhen the client receives this reply (and not a failure), it should\nvalidate the signatures and may update its known_hosts file, adding keys\nthat it has not seen before and deleting keys for the server host that\nare no longer offered.\n\nThese extensions let a client learn key types that it had not previously\nencountered, thereby allowing it to potentially upgrade from weaker\nkey algorithms to better ones. It also supports graceful key rotation:\na server may offer multiple keys of the same type for a period (to\ngive clients an opportunity to learn them using this extension) before\nremoving the deprecated key from those offered.\n\n2.6. connection: SIGINFO support for \"signal\" channel request\n\nThe SSH channels protocol (RFC4254 section 6.9) supports sending a\nsignal to a session attached to a channel. OpenSSH supports one\nextension signal \"INFO@openssh.com\" that allows sending SIGINFO on\nBSD-derived systems.\n\n3. Authentication protocol changes\n\n3.1. Host-bound public key authentication\n\nThis is trivial change to the traditional \"publickey\" authentication\nmethod. The authentication request is identical to the original method\nbut for the name and one additional field:\n\n\tbyte\t\tSSH2_MSG_USERAUTH_REQUEST\n\tstring\t\tusername\n\tstring\t\t\"ssh-connection\"\n\tstring\t\t\"publickey-hostbound-v00@openssh.com\"\n\tbool\t\thas_signature\n\tstring\t\tpkalg\n\tstring\t\tpublic key\n\tstring\t\tserver host key\n\nBecause the entire SSH2_MSG_USERAUTH_REQUEST message is included in\nthe signed data, this ensures that a binding between the destination\nuser, the server identity and the session identifier is visible to the\nsigner. OpenSSH uses this binding via signed data to implement per-key\nrestrictions in ssh-agent.\n\nA server may advertise this method using the SSH2_MSG_EXT_INFO\nmechanism (RFC8308), with the following message:\n\n\tstring\t\t\"publickey-hostbound@openssh.com\"\n\tstring\t\t\"0\" (version)\n\nClients should prefer host-bound authentication when advertised by\nserver.\n\n4. SFTP protocol changes\n\n4.1. sftp: Reversal of arguments to SSH_FXP_SYMLINK\n\nWhen OpenSSH's sftp-server was implemented, the order of the arguments\nto the SSH_FXP_SYMLINK method was inadvertently reversed. Unfortunately,\nthe reversal was not noticed until the server was widely deployed. Since\nfixing this to follow the specification would cause incompatibility, the\ncurrent order was retained. For correct operation, clients should send\nSSH_FXP_SYMLINK as follows:\n\n\tuint32\t\tid\n\tstring\t\ttargetpath\n\tstring\t\tlinkpath\n\n4.2. sftp: Server extension announcement in SSH_FXP_VERSION\n\nOpenSSH's sftp-server lists the extensions it supports using the\nstandard extension announcement mechanism in the SSH_FXP_VERSION server\nhello packet:\n\n\tuint32\t\t3\t\t/* protocol version */\n\tstring\t\text1-name\n\tstring\t\text1-version\n\tstring\t\text2-name\n\tstring\t\text2-version\n\t...\n\tstring\t\textN-name\n\tstring\t\textN-version\n\nEach extension reports its integer version number as an ASCII encoded\nstring, e.g. \"1\". The version will be incremented if the extension is\never changed in an incompatible way. The server MAY advertise the same\nextension with multiple versions (though this is unlikely). Clients MUST\ncheck the version number before attempting to use the extension.\n\n4.3. sftp: Extension request \"posix-rename@openssh.com\"\n\nThis operation provides a rename operation with POSIX semantics, which\nare different to those provided by the standard SSH_FXP_RENAME in\ndraft-ietf-secsh-filexfer-02.txt. This request is implemented as a\nSSH_FXP_EXTENDED request with the following format:\n\n\tuint32\t\tid\n\tstring\t\t\"posix-rename@openssh.com\"\n\tstring\t\toldpath\n\tstring\t\tnewpath\n\nOn receiving this request the server will perform the POSIX operation\nrename(oldpath, newpath) and will respond with a SSH_FXP_STATUS message.\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n4.4. sftp: Extension requests \"statvfs@openssh.com\" and\n         \"fstatvfs@openssh.com\"\n\nThese requests correspond to the statvfs and fstatvfs POSIX system\ninterfaces. The \"statvfs@openssh.com\" request operates on an explicit\npathname, and is formatted as follows:\n\n\tuint32\t\tid\n\tstring\t\t\"statvfs@openssh.com\"\n\tstring\t\tpath\n\nThe \"fstatvfs@openssh.com\" operates on an open file handle:\n\n\tuint32\t\tid\n\tstring\t\t\"fstatvfs@openssh.com\"\n\tstring\t\thandle\n\nThese requests return a SSH_FXP_STATUS reply on failure. On success they\nreturn the following SSH_FXP_EXTENDED_REPLY reply:\n\n\tuint32\t\tid\n\tuint64\t\tf_bsize\t\t/* file system block size */\n\tuint64\t\tf_frsize\t/* fundamental fs block size */\n\tuint64\t\tf_blocks\t/* number of blocks (unit f_frsize) */\n\tuint64\t\tf_bfree\t\t/* free blocks in file system */\n\tuint64\t\tf_bavail\t/* free blocks for non-root */\n\tuint64\t\tf_files\t\t/* total file inodes */\n\tuint64\t\tf_ffree\t\t/* free file inodes */\n\tuint64\t\tf_favail\t/* free file inodes for to non-root */\n\tuint64\t\tf_fsid\t\t/* file system id */\n\tuint64\t\tf_flag\t\t/* bit mask of f_flag values */\n\tuint64\t\tf_namemax\t/* maximum filename length */\n\nThe values of the f_flag bitmask are as follows:\n\n\t#define SSH_FXE_STATVFS_ST_RDONLY\t0x1\t/* read-only */\n\t#define SSH_FXE_STATVFS_ST_NOSUID\t0x2\t/* no setuid */\n\nBoth the \"statvfs@openssh.com\" and \"fstatvfs@openssh.com\" extensions are\nadvertised in the SSH_FXP_VERSION hello with version \"2\".\n\n4.5. sftp: Extension request \"hardlink@openssh.com\"\n\nThis request is for creating a hard link to a regular file. This\nrequest is implemented as a SSH_FXP_EXTENDED request with the\nfollowing format:\n\n\tuint32\t\tid\n\tstring\t\t\"hardlink@openssh.com\"\n\tstring\t\toldpath\n\tstring\t\tnewpath\n\nOn receiving this request the server will perform the operation\nlink(oldpath, newpath) and will respond with a SSH_FXP_STATUS message.\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n4.6. sftp: Extension request \"fsync@openssh.com\"\n\nThis request asks the server to call fsync(2) on an open file handle.\n\n\tuint32\t\tid\n\tstring\t\t\"fsync@openssh.com\"\n\tstring\t\thandle\n\nOn receiving this request, a server will call fsync(handle_fd) and will\nrespond with a SSH_FXP_STATUS message.\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n4.7. sftp: Extension request \"lsetstat@openssh.com\"\n\nThis request is like the \"setstat\" command, but sets file attributes on\nsymlinks.  It is implemented as a SSH_FXP_EXTENDED request with the\nfollowing format:\n\n\tuint32\t\tid\n\tstring\t\t\"lsetstat@openssh.com\"\n\tstring\t\tpath\n\tATTRS\t\tattrs\n\nSee the \"setstat\" command for more details.\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n4.8. sftp: Extension request \"limits@openssh.com\"\n\nThis request is used to determine various limits the server might impose.\nClients should not attempt to exceed these limits as the server might sever\nthe connection immediately.\n\n\tuint32\t\tid\n\tstring\t\t\"limits@openssh.com\"\n\nThe server will respond with a SSH_FXP_EXTENDED_REPLY reply:\n\n\tuint32\t\tid\n\tuint64\t\tmax-packet-length\n\tuint64\t\tmax-read-length\n\tuint64\t\tmax-write-length\n\tuint64\t\tmax-open-handles\n\nThe 'max-packet-length' applies to the total number of bytes in a\nsingle SFTP packet.  Servers SHOULD set this at least to 34000.\n\nThe 'max-read-length' is the largest length in a SSH_FXP_READ packet.\nEven if the client requests a larger size, servers will usually respond\nwith a shorter SSH_FXP_DATA packet.  Servers SHOULD set this at least to\n32768.\n\nThe 'max-write-length' is the largest length in a SSH_FXP_WRITE packet\nthe server will accept.  Servers SHOULD set this at least to 32768.\n\nThe 'max-open-handles' is the maximum number of active handles that the\nserver allows (e.g. handles created by SSH_FXP_OPEN and SSH_FXP_OPENDIR\npackets).  Servers MAY count internal file handles against this limit\n(e.g. system logging or stdout/stderr), so clients SHOULD NOT expect to\nopen this many handles in practice.\n\nIf the server doesn't enforce a specific limit, then the field may be\nset to 0.  This implies the server relies on the OS to enforce limits\n(e.g. available memory or file handles), and such limits might be\ndynamic.  The client SHOULD take care to not try to exceed reasonable\nlimits.\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n4.9. sftp: Extension request \"expand-path@openssh.com\"\n\nThis request supports canonicalisation of relative paths and\nthose that need tilde-expansion, i.e. \"~\", \"~/...\" and \"~user/...\"\nThese paths are expanded using shell-like rules and the resultant\npath is canonicalised similarly to SSH2_FXP_REALPATH.\n\nIt is implemented as a SSH_FXP_EXTENDED request with the following\nformat:\n\n\tuint32\t\tid\n\tstring\t\t\"expand-path@openssh.com\"\n\tstring\t\tpath\n\nIts reply is the same format as that of SSH2_FXP_REALPATH.\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n4.10. sftp: Extension request \"copy-data\"\n\nThis request asks the server to copy data from one open file handle and\nwrite it to a different open file handle.  This avoids needing to transfer\nthe data across the network twice (a download followed by an upload).\n\n\tbyte\t\tSSH_FXP_EXTENDED\n\tuint32\t\tid\n\tstring\t\t\"copy-data\"\n\tstring\t\tread-from-handle\n\tuint64\t\tread-from-offset\n\tuint64\t\tread-data-length\n\tstring\t\twrite-to-handle\n\tuint64\t\twrite-to-offset\n\nThe server will copy read-data-length bytes starting from\nread-from-offset from the read-from-handle and write them to\nwrite-to-handle starting from write-to-offset, and then respond with a\nSSH_FXP_STATUS message.\n\nIt's equivalent to issuing a series of SSH_FXP_READ requests on\nread-from-handle and a series of requests of SSH_FXP_WRITE on\nwrite-to-handle.\n\nIf read-from-handle and write-to-handle are the same, the server will\nfail the request and respond with a SSH_FX_INVALID_PARAMETER message.\n\nIf read-data-length is 0, then the server will read data from the\nread-from-handle until EOF is reached.\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\nThis request is identical to the \"copy-data\" request documented in:\n\nhttps://tools.ietf.org/html/draft-ietf-secsh-filexfer-extensions-00#section-7\n\n4.11. sftp: Extension request \"home-directory\"\n\nThis request asks the server to expand the specified user's home directory.\nAn empty username implies the current user.  This can be used by the client\nto expand ~/ type paths locally.\n\n\tbyte\t\tSSH_FXP_EXTENDED\n\tuint32\t\tid\n\tstring\t\t\"home-directory\"\n\tstring\t\tusername\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\nThis provides similar information as the \"expand-path@openssh.com\" extension.\n\nThis request is identical to the \"home-directory\" request documented in:\n\nhttps://datatracker.ietf.org/doc/html/draft-ietf-secsh-filexfer-extensions-00#section-5\n\n4.12. sftp: Extension request \"users-groups-by-id@openssh.com\"\n\nThis request asks the server to return user and/or group names that\ncorrespond to one or more IDs (e.g. as returned from a SSH_FXP_STAT\nrequest). This may be used by the client to provide usernames in\ndirectory listings.\n\n\tbyte\t\tSSH_FXP_EXTENDED\n\tuint32\t\tid\n\tstring\t\t\"users-groups-by-id@openssh.com\"\n\tstring\t\tuids\n\tstring\t\tgids\n\nWhere \"uids\" and \"gids\" consists of one or more integer user or group\nidentifiers:\n\n\tuint32\t\tid-0\n\t...\n\nThe server will reply with a SSH_FXP_EXTENDED_REPLY:\n\n\tbyte\t\tSSH_FXP_EXTENDED_REPLY\n\tstring\t\tusernames\n\tstring\t\tgroupnames\n\nWhere \"username\" and \"groupnames\" consists of names in identical request\norder to \"uids\" and \"gids\" respectively:\n\n\tstring\t\tname-0\n\t...\n\nIf a name cannot be identified for a given user or group ID, an empty\nstring will be returned in its place.\n\nIt is acceptable for either \"uids\" or \"gids\" to be an empty set, in\nwhich case the respective \"usernames\" or \"groupnames\" list will also\nbe empty.\n\nThis extension is advertised in the SSH_FXP_VERSION hello with version\n\"1\".\n\n5. Miscellaneous changes\n\n5.1 Public key format\n\nOpenSSH public keys, as generated by ssh-keygen(1) and appearing in\nauthorized_keys files, are formatted as a single line of text consisting\nof the public key algorithm name followed by a base64-encoded key blob.\nThe public key blob (before base64 encoding) is the same format used for\nthe encoding of public keys sent on the wire: as described in RFC4253\nsection 6.6 for RSA and DSA keys, RFC5656 section 3.1 for ECDSA keys\nand the \"New public key formats\" section of PROTOCOL.certkeys for the\nOpenSSH certificate formats.\n\n5.2 Private key format\n\nOpenSSH private keys, as generated by ssh-keygen(1) use the format\ndescribed in PROTOCOL.key by default. As a legacy option, PEM format\n(RFC7468) private keys are also supported for RSA, DSA and ECDSA keys\nand were the default format before OpenSSH 7.8.\n\n5.3 KRL format\n\nOpenSSH supports a compact format for Key Revocation Lists (KRLs). This\nformat is described in the PROTOCOL.krl file.\n\n5.4 Connection multiplexing\n\nOpenSSH's connection multiplexing uses messages as described in\nPROTOCOL.mux over a Unix domain socket for communications between a\nmaster instance and later clients.\n\n5.5. Agent protocol extensions\n\nOpenSSH extends the usual agent protocol. These changes are documented\nin the PROTOCOL.agent file.\n\n$OpenBSD: PROTOCOL,v 1.51 2023/12/18 14:45:49 djm Exp $\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}