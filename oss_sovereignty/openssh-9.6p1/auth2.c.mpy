{
  "module_name": "auth2.c",
  "hash_id": "64bf80c78ab9a186ae121e997b270733f01802363dbd3eb25acc0f0e8f98b418",
  "original_prompt": "Ingested from openssh-9.6p1/auth2.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/uio.h>\n\n#include <fcntl.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#include <time.h>\n\n#include \"stdlib.h\"\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"ssh2.h\"\n#include \"packet.h\"\n#include \"log.h\"\n#include \"sshbuf.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"dispatch.h\"\n#include \"pathnames.h\"\n#include \"ssherr.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"digest.h\"\n#include \"kex.h\"\n\n \nextern ServerOptions options;\nextern struct sshbuf *loginmsg;\n\n \n\nextern Authmethod method_none;\nextern Authmethod method_pubkey;\nextern Authmethod method_passwd;\nextern Authmethod method_kbdint;\nextern Authmethod method_hostbased;\n#ifdef GSSAPI\nextern Authmethod method_gssapi;\n#endif\n\nAuthmethod *authmethods[] = {\n\t&method_none,\n\t&method_pubkey,\n#ifdef GSSAPI\n\t&method_gssapi,\n#endif\n\t&method_passwd,\n\t&method_kbdint,\n\t&method_hostbased,\n\tNULL\n};\n\n \n\nstatic int input_service_request(int, u_int32_t, struct ssh *);\nstatic int input_userauth_request(int, u_int32_t, struct ssh *);\n\n \nstatic Authmethod *authmethod_byname(const char *);\nstatic Authmethod *authmethod_lookup(Authctxt *, const char *);\nstatic char *authmethods_get(Authctxt *authctxt);\n\n#define MATCH_NONE\t0\t \n#define MATCH_METHOD\t1\t \n#define MATCH_BOTH\t2\t \n#define MATCH_PARTIAL\t3\t \nstatic int list_starts_with(const char *, const char *, const char *);\n\nchar *\nauth2_read_banner(void)\n{\n\tstruct stat st;\n\tchar *banner = NULL;\n\tsize_t len, n;\n\tint fd;\n\n\tif ((fd = open(options.banner, O_RDONLY)) == -1)\n\t\treturn (NULL);\n\tif (fstat(fd, &st) == -1) {\n\t\tclose(fd);\n\t\treturn (NULL);\n\t}\n\tif (st.st_size <= 0 || st.st_size > 1*1024*1024) {\n\t\tclose(fd);\n\t\treturn (NULL);\n\t}\n\n\tlen = (size_t)st.st_size;\t\t \n\tbanner = xmalloc(len + 1);\n\tn = atomicio(read, fd, banner, len);\n\tclose(fd);\n\n\tif (n != len) {\n\t\tfree(banner);\n\t\treturn (NULL);\n\t}\n\tbanner[n] = '\\0';\n\n\treturn (banner);\n}\n\nstatic void\nuserauth_send_banner(struct ssh *ssh, const char *msg)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_BANNER)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, msg)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t \n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\tdebug(\"%s: sent\", __func__);\n}\n\nstatic void\nuserauth_banner(struct ssh *ssh)\n{\n\tchar *banner = NULL;\n\n\tif (options.banner == NULL)\n\t\treturn;\n\n\tif ((banner = PRIVSEP(auth2_read_banner())) == NULL)\n\t\tgoto done;\n\tuserauth_send_banner(ssh, banner);\n\ndone:\n\tfree(banner);\n}\n\n \nvoid\ndo_authentication2(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\n\tssh_dispatch_init(ssh, &dispatch_protocol_error);\n\tif (ssh->kex->ext_info_c)\n\t\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &kex_input_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_REQUEST, &input_service_request);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt->success);\n\tssh->authctxt = NULL;\n}\n\nstatic int\ninput_service_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *service = NULL;\n\tint r, acceptit = 0;\n\n\tif ((r = sshpkt_get_cstring(ssh, &service, NULL)) != 0 ||\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\tgoto out;\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_service_request: no authctxt\");\n\n\tif (strcmp(service, \"ssh-userauth\") == 0) {\n\t\tif (!authctxt->success) {\n\t\t\tacceptit = 1;\n\t\t\t \n\t\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST,\n\t\t\t    &input_userauth_request);\n\t\t}\n\t}\n\t \n\n\tif (acceptit) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_ACCEPT)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, service)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdebug(\"bad service request %s\", service);\n\t\tssh_packet_disconnect(ssh, \"bad service request %s\", service);\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &dispatch_protocol_error);\n\tr = 0;\n out:\n\tfree(service);\n\treturn r;\n}\n\n#define MIN_FAIL_DELAY_SECONDS 0.005\n#define MAX_FAIL_DELAY_SECONDS 5.0\nstatic double\nuser_specific_delay(const char *user)\n{\n\tchar b[512];\n\tsize_t len = ssh_digest_bytes(SSH_DIGEST_SHA512);\n\tu_char *hash = xmalloc(len);\n\tdouble delay;\n\n\t(void)snprintf(b, sizeof b, \"%llu%s\",\n\t    (unsigned long long)options.timing_secret, user);\n\tif (ssh_digest_memory(SSH_DIGEST_SHA512, b, strlen(b), hash, len) != 0)\n\t\tfatal_f(\"ssh_digest_memory\");\n\t \n\tdelay = (double)PEEK_U32(hash) / 1000 / 1000 / 1000 / 1000;\n\tfreezero(hash, len);\n\tdebug3_f(\"user specific delay %0.3lfms\", delay/1000);\n\treturn MIN_FAIL_DELAY_SECONDS + delay;\n}\n\nstatic void\nensure_minimum_time_since(double start, double seconds)\n{\n\tstruct timespec ts;\n\tdouble elapsed = monotime_double() - start, req = seconds, remain;\n\n\tif (elapsed > MAX_FAIL_DELAY_SECONDS) {\n\t\tdebug3_f(\"elapsed %0.3lfms exceeded the max delay \"\n\t\t    \"requested %0.3lfms)\", elapsed*1000, req*1000);\n\t\treturn;\n\t}\n\n\t \n\twhile ((remain = seconds - elapsed) < 0.0)\n\t\tseconds *= 2;\n\n\tts.tv_sec = remain;\n\tts.tv_nsec = (remain - ts.tv_sec) * 1000000000;\n\tdebug3_f(\"elapsed %0.3lfms, delaying %0.3lfms (requested %0.3lfms)\",\n\t    elapsed*1000, remain*1000, req*1000);\n\tnanosleep(&ts, NULL);\n}\n\nstatic int\ninput_userauth_request(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tAuthmethod *m = NULL;\n\tchar *user = NULL, *service = NULL, *method = NULL, *style = NULL;\n\tint r, authenticated = 0;\n\tdouble tstart = monotime_double();\n\n\tif (authctxt == NULL)\n\t\tfatal(\"input_userauth_request: no authctxt\");\n\n\tif ((r = sshpkt_get_cstring(ssh, &user, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &service, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &method, NULL)) != 0)\n\t\tgoto out;\n\tdebug(\"userauth-request for user %s service %s method %s\", user, service, method);\n\tdebug(\"attempt %d failures %d\", authctxt->attempt, authctxt->failures);\n\n\tif ((style = strchr(user, ':')) != NULL)\n\t\t*style++ = 0;\n\n\tif (authctxt->attempt >= 1024)\n\t\tauth_maxtries_exceeded(ssh);\n\tif (authctxt->attempt++ == 0) {\n\t\t \n\t\tauthctxt->pw = PRIVSEP(getpwnamallow(ssh, user));\n\t\tauthctxt->user = xstrdup(user);\n\t\tif (authctxt->pw && strcmp(service, \"ssh-connection\")==0) {\n\t\t\tauthctxt->valid = 1;\n\t\t\tdebug2_f(\"setting up authctxt for %s\", user);\n\t\t} else {\n\t\t\tauthctxt->valid = 0;\n\t\t\t \n\t\t\tauthctxt->pw = fakepw();\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(ssh, SSH_INVALID_USER));\n#endif\n\t\t}\n#ifdef USE_PAM\n\t\tif (options.use_pam)\n\t\t\tPRIVSEP(start_pam(ssh));\n#endif\n\t\tssh_packet_set_log_preamble(ssh, \"%suser %s\",\n\t\t    authctxt->valid ? \"authenticating \" : \"invalid \", user);\n\t\tsetproctitle(\"%s%s\", authctxt->valid ? user : \"unknown\",\n\t\t    use_privsep ? \" [net]\" : \"\");\n\t\tauthctxt->service = xstrdup(service);\n\t\tauthctxt->style = style ? xstrdup(style) : NULL;\n\t\tif (use_privsep)\n\t\t\tmm_inform_authserv(service, style);\n\t\tuserauth_banner(ssh);\n\t\tif ((r = kex_server_update_ext_info(ssh)) != 0)\n\t\t\tfatal_fr(r, \"kex_server_update_ext_info failed\");\n\t\tif (auth2_setup_methods_lists(authctxt) != 0)\n\t\t\tssh_packet_disconnect(ssh,\n\t\t\t    \"no authentication methods enabled\");\n\t} else if (strcmp(user, authctxt->user) != 0 ||\n\t    strcmp(service, authctxt->service) != 0) {\n\t\tssh_packet_disconnect(ssh, \"Change of username or service \"\n\t\t    \"not allowed: (%s,%s) -> (%s,%s)\",\n\t\t    authctxt->user, authctxt->service, user, service);\n\t}\n\t \n\tauth2_challenge_stop(ssh);\n\n#ifdef GSSAPI\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, NULL);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE, NULL);\n#endif\n\n\tauth2_authctxt_reset_info(authctxt);\n\tauthctxt->postponed = 0;\n\tauthctxt->server_caused_failure = 0;\n\n\t \n\tm = authmethod_lookup(authctxt, method);\n\tif (m != NULL && authctxt->failures < options.max_authtries) {\n\t\tdebug2(\"input_userauth_request: try method %s\", method);\n\t\tauthenticated =\tm->userauth(ssh, method);\n\t}\n\tif (!authctxt->authenticated && strcmp(method, \"none\") != 0)\n\t\tensure_minimum_time_since(tstart,\n\t\t    user_specific_delay(authctxt->user));\n\tuserauth_finish(ssh, authenticated, method, NULL);\n\tr = 0;\n out:\n\tfree(service);\n\tfree(user);\n\tfree(method);\n\treturn r;\n}\n\nvoid\nuserauth_finish(struct ssh *ssh, int authenticated, const char *packet_method,\n    const char *submethod)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tAuthmethod *m = NULL;\n\tconst char *method = packet_method;\n\tchar *methods;\n\tint r, partial = 0;\n\n\tif (authenticated) {\n\t\tif (!authctxt->valid) {\n\t\t\tfatal(\"INTERNAL ERROR: authenticated invalid user %s\",\n\t\t\t    authctxt->user);\n\t\t}\n\t\tif (authctxt->postponed)\n\t\t\tfatal(\"INTERNAL ERROR: authenticated and postponed\");\n\t\t \n\t\tif ((m = authmethod_byname(method)) == NULL)\n\t\t\tfatal(\"INTERNAL ERROR: bad method %s\", method);\n\t\tmethod = m->name;\n\t}\n\n\t \n\tif (authenticated && authctxt->pw->pw_uid == 0 &&\n\t    !auth_root_allowed(ssh, method)) {\n\t\tauthenticated = 0;\n#ifdef SSH_AUDIT_EVENTS\n\t\tPRIVSEP(audit_event(ssh, SSH_LOGIN_ROOT_DENIED));\n#endif\n\t}\n\n\tif (authenticated && options.num_auth_methods != 0) {\n\t\tif (!auth2_update_methods_lists(authctxt, method, submethod)) {\n\t\t\tauthenticated = 0;\n\t\t\tpartial = 1;\n\t\t}\n\t}\n\n\t \n\tauth_log(ssh, authenticated, partial, method, submethod);\n\n\t \n\tif (authenticated || partial)\n\t\tauth2_update_session_info(authctxt, method, submethod);\n\n\tif (authctxt->postponed)\n\t\treturn;\n\n#ifdef USE_PAM\n\tif (options.use_pam && authenticated) {\n\t\tint r, success = PRIVSEP(do_pam_account());\n\n\t\t \n\t\tif (sshbuf_len(loginmsg) > 0) {\n\t\t\tif ((r = sshbuf_put(loginmsg, \"\\0\", 1)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tuserauth_send_banner(ssh, sshbuf_ptr(loginmsg));\n\t\t\tif ((r = ssh_packet_write_wait(ssh)) != 0) {\n\t\t\t\tsshpkt_fatal(ssh, r,\n\t\t\t\t    \"%s: send PAM banner\", __func__);\n\t\t\t}\n\t\t}\n\t\tif (!success) {\n\t\t\tfatal(\"Access denied for user %s by PAM account \"\n\t\t\t    \"configuration\", authctxt->user);\n\t\t}\n\t}\n#endif\n\n\tif (authenticated == 1) {\n\t\t \n\t\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_REQUEST,\n\t\t    &dispatch_protocol_ignore);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_SUCCESS)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send success packet\");\n\t\t \n\t\tauthctxt->success = 1;\n\t\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\t} else {\n\t\t \n\t\tif (!partial && !authctxt->server_caused_failure &&\n\t\t    (authctxt->attempt > 1 || strcmp(method, \"none\") != 0))\n\t\t\tauthctxt->failures++;\n\t\tif (authctxt->failures >= options.max_authtries) {\n#ifdef SSH_AUDIT_EVENTS\n\t\t\tPRIVSEP(audit_event(ssh, SSH_LOGIN_EXCEED_MAXTRIES));\n#endif\n\t\t\tauth_maxtries_exceeded(ssh);\n\t\t}\n\t\tmethods = authmethods_get(authctxt);\n\t\tdebug3_f(\"failure partial=%d next methods=\\\"%s\\\"\",\n\t\t    partial, methods);\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_FAILURE)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, methods)) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, partial)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send failure packet\");\n\t\tfree(methods);\n\t}\n}\n\n \nint\nauth2_method_allowed(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tu_int i;\n\n\t \n\tif (options.num_auth_methods == 0)\n\t\treturn 1;\n\tfor (i = 0; i < authctxt->num_auth_methods; i++) {\n\t\tif (list_starts_with(authctxt->auth_methods[i], method,\n\t\t    submethod) != MATCH_NONE)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic char *\nauthmethods_get(Authctxt *authctxt)\n{\n\tstruct sshbuf *b;\n\tchar *list;\n\tint i, r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tfor (i = 0; authmethods[i] != NULL; i++) {\n\t\tif (strcmp(authmethods[i]->name, \"none\") == 0)\n\t\t\tcontinue;\n\t\tif (authmethods[i]->enabled == NULL ||\n\t\t    *(authmethods[i]->enabled) == 0)\n\t\t\tcontinue;\n\t\tif (!auth2_method_allowed(authctxt, authmethods[i]->name,\n\t\t    NULL))\n\t\t\tcontinue;\n\t\tif ((r = sshbuf_putf(b, \"%s%s\", sshbuf_len(b) ? \",\" : \"\",\n\t\t    authmethods[i]->name)) != 0)\n\t\t\tfatal_fr(r, \"buffer error\");\n\t}\n\tif ((list = sshbuf_dup_string(b)) == NULL)\n\t\tfatal_f(\"sshbuf_dup_string failed\");\n\tsshbuf_free(b);\n\treturn list;\n}\n\nstatic Authmethod *\nauthmethod_byname(const char *name)\n{\n\tint i;\n\n\tif (name == NULL)\n\t\tfatal_f(\"NULL authentication method name\");\n\tfor (i = 0; authmethods[i] != NULL; i++) {\n\t\tif (strcmp(name, authmethods[i]->name) == 0 ||\n\t\t    (authmethods[i]->synonym != NULL &&\n\t\t    strcmp(name, authmethods[i]->synonym) == 0))\n\t\t\treturn authmethods[i];\n\t}\n\tdebug_f(\"unrecognized authentication method name: %s\", name);\n\treturn NULL;\n}\n\nstatic Authmethod *\nauthmethod_lookup(Authctxt *authctxt, const char *name)\n{\n\tAuthmethod *method;\n\n\tif ((method = authmethod_byname(name)) == NULL)\n\t\treturn NULL;\n\n\tif (method->enabled == NULL || *(method->enabled) == 0) {\n\t\tdebug3_f(\"method %s not enabled\", name);\n\t\treturn NULL;\n\t}\n\tif (!auth2_method_allowed(authctxt, method->name, NULL)) {\n\t\tdebug3_f(\"method %s not allowed \"\n\t\t    \"by AuthenticationMethods\", name);\n\t\treturn NULL;\n\t}\n\treturn method;\n}\n\n \nint\nauth2_methods_valid(const char *_methods, int need_enable)\n{\n\tchar *methods, *omethods, *method, *p;\n\tu_int i, found;\n\tint ret = -1;\n\n\tif (*_methods == '\\0') {\n\t\terror(\"empty authentication method list\");\n\t\treturn -1;\n\t}\n\tomethods = methods = xstrdup(_methods);\n\twhile ((method = strsep(&methods, \",\")) != NULL) {\n\t\tfor (found = i = 0; !found && authmethods[i] != NULL; i++) {\n\t\t\tif ((p = strchr(method, ':')) != NULL)\n\t\t\t\t*p = '\\0';\n\t\t\tif (strcmp(method, authmethods[i]->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (need_enable) {\n\t\t\t\tif (authmethods[i]->enabled == NULL ||\n\t\t\t\t    *(authmethods[i]->enabled) == 0) {\n\t\t\t\t\terror(\"Disabled method \\\"%s\\\" in \"\n\t\t\t\t\t    \"AuthenticationMethods list \\\"%s\\\"\",\n\t\t\t\t\t    method, _methods);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!found) {\n\t\t\terror(\"Unknown authentication method \\\"%s\\\" in list\",\n\t\t\t    method);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n out:\n\tfree(omethods);\n\treturn ret;\n}\n\n \nint\nauth2_setup_methods_lists(Authctxt *authctxt)\n{\n\tu_int i;\n\n\t \n\tif (options.num_auth_methods == 1 &&\n\t    strcmp(options.auth_methods[0], \"any\") == 0) {\n\t\tfree(options.auth_methods[0]);\n\t\toptions.auth_methods[0] = NULL;\n\t\toptions.num_auth_methods = 0;\n\t}\n\n\tif (options.num_auth_methods == 0)\n\t\treturn 0;\n\tdebug3_f(\"checking methods\");\n\tauthctxt->auth_methods = xcalloc(options.num_auth_methods,\n\t    sizeof(*authctxt->auth_methods));\n\tauthctxt->num_auth_methods = 0;\n\tfor (i = 0; i < options.num_auth_methods; i++) {\n\t\tif (auth2_methods_valid(options.auth_methods[i], 1) != 0) {\n\t\t\tlogit(\"Authentication methods list \\\"%s\\\" contains \"\n\t\t\t    \"disabled method, skipping\",\n\t\t\t    options.auth_methods[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"authentication methods list %d: %s\",\n\t\t    authctxt->num_auth_methods, options.auth_methods[i]);\n\t\tauthctxt->auth_methods[authctxt->num_auth_methods++] =\n\t\t    xstrdup(options.auth_methods[i]);\n\t}\n\tif (authctxt->num_auth_methods == 0) {\n\t\terror(\"No AuthenticationMethods left after eliminating \"\n\t\t    \"disabled methods\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nlist_starts_with(const char *methods, const char *method,\n    const char *submethod)\n{\n\tsize_t l = strlen(method);\n\tint match;\n\tconst char *p;\n\n\tif (strncmp(methods, method, l) != 0)\n\t\treturn MATCH_NONE;\n\tp = methods + l;\n\tmatch = MATCH_METHOD;\n\tif (*p == ':') {\n\t\tif (!submethod)\n\t\t\treturn MATCH_PARTIAL;\n\t\tl = strlen(submethod);\n\t\tp += 1;\n\t\tif (strncmp(submethod, p, l))\n\t\t\treturn MATCH_NONE;\n\t\tp += l;\n\t\tmatch = MATCH_BOTH;\n\t}\n\tif (*p != ',' && *p != '\\0')\n\t\treturn MATCH_NONE;\n\treturn match;\n}\n\n \nstatic int\nremove_method(char **methods, const char *method, const char *submethod)\n{\n\tchar *omethods = *methods, *p;\n\tsize_t l = strlen(method);\n\tint match;\n\n\tmatch = list_starts_with(omethods, method, submethod);\n\tif (match != MATCH_METHOD && match != MATCH_BOTH)\n\t\treturn 0;\n\tp = omethods + l;\n\tif (submethod && match == MATCH_BOTH)\n\t\tp += 1 + strlen(submethod);  \n\tif (*p == ',')\n\t\tp++;\n\t*methods = xstrdup(p);\n\tfree(omethods);\n\treturn 1;\n}\n\n \nint\nauth2_update_methods_lists(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tu_int i, found = 0;\n\n\tdebug3_f(\"updating methods list after \\\"%s\\\"\", method);\n\tfor (i = 0; i < authctxt->num_auth_methods; i++) {\n\t\tif (!remove_method(&(authctxt->auth_methods[i]), method,\n\t\t    submethod))\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tif (*authctxt->auth_methods[i] == '\\0') {\n\t\t\tdebug2(\"authentication methods list %d complete\", i);\n\t\t\treturn 1;\n\t\t}\n\t\tdebug3(\"authentication methods list %d remaining: \\\"%s\\\"\",\n\t\t    i, authctxt->auth_methods[i]);\n\t}\n\t \n\tif (!found)\n\t\tfatal_f(\"method not in AuthenticationMethods\");\n\treturn 0;\n}\n\n \nvoid auth2_authctxt_reset_info(Authctxt *authctxt)\n{\n\tsshkey_free(authctxt->auth_method_key);\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_key = NULL;\n\tauthctxt->auth_method_info = NULL;\n}\n\n \nvoid\nauth2_record_info(Authctxt *authctxt, const char *fmt, ...)\n{\n\tva_list ap;\n\tint i;\n\n\tfree(authctxt->auth_method_info);\n\tauthctxt->auth_method_info = NULL;\n\n\tva_start(ap, fmt);\n\ti = vasprintf(&authctxt->auth_method_info, fmt, ap);\n\tva_end(ap);\n\n\tif (i == -1)\n\t\tfatal_f(\"vasprintf failed\");\n}\n\n \nvoid\nauth2_record_key(Authctxt *authctxt, int authenticated,\n    const struct sshkey *key)\n{\n\tstruct sshkey **tmp, *dup;\n\tint r;\n\n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal_fr(r, \"copy key\");\n\tsshkey_free(authctxt->auth_method_key);\n\tauthctxt->auth_method_key = dup;\n\n\tif (!authenticated)\n\t\treturn;\n\n\t \n\tif ((r = sshkey_from_private(key, &dup)) != 0)\n\t\tfatal_fr(r, \"copy key\");\n\tif (authctxt->nprev_keys >= INT_MAX ||\n\t    (tmp = recallocarray(authctxt->prev_keys, authctxt->nprev_keys,\n\t    authctxt->nprev_keys + 1, sizeof(*authctxt->prev_keys))) == NULL)\n\t\tfatal_f(\"reallocarray failed\");\n\tauthctxt->prev_keys = tmp;\n\tauthctxt->prev_keys[authctxt->nprev_keys] = dup;\n\tauthctxt->nprev_keys++;\n\n}\n\n \nint\nauth2_key_already_used(Authctxt *authctxt, const struct sshkey *key)\n{\n\tu_int i;\n\tchar *fp;\n\n\tfor (i = 0; i < authctxt->nprev_keys; i++) {\n\t\tif (sshkey_equal_public(key, authctxt->prev_keys[i])) {\n\t\t\tfp = sshkey_fingerprint(authctxt->prev_keys[i],\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tdebug3_f(\"key already used: %s %s\",\n\t\t\t    sshkey_type(authctxt->prev_keys[i]),\n\t\t\t    fp == NULL ? \"UNKNOWN\" : fp);\n\t\t\tfree(fp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nvoid\nauth2_update_session_info(Authctxt *authctxt, const char *method,\n    const char *submethod)\n{\n\tint r;\n\n\tif (authctxt->session_info == NULL) {\n\t\tif ((authctxt->session_info = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new\");\n\t}\n\n\t \n\tif ((r = sshbuf_putf(authctxt->session_info, \"%s%s%s\",\n\t    method, submethod == NULL ? \"\" : \"/\",\n\t    submethod == NULL ? \"\" : submethod)) != 0)\n\t\tfatal_fr(r, \"append method\");\n\n\t \n\tif (authctxt->auth_method_key != NULL) {\n\t\tif ((r = sshbuf_put_u8(authctxt->session_info, ' ')) != 0 ||\n\t\t    (r = sshkey_format_text(authctxt->auth_method_key,\n\t\t    authctxt->session_info)) != 0)\n\t\t\tfatal_fr(r, \"append key\");\n\t}\n\n\tif (authctxt->auth_method_info != NULL) {\n\t\t \n\t\tif (strchr(authctxt->auth_method_info, '\\n') != NULL)\n\t\t\tfatal_f(\"auth_method_info contains \\\\n\");\n\t\tif ((r = sshbuf_put_u8(authctxt->session_info, ' ')) != 0 ||\n\t\t    (r = sshbuf_putf(authctxt->session_info, \"%s\",\n\t\t    authctxt->auth_method_info)) != 0) {\n\t\t\tfatal_fr(r, \"append method info\");\n\t\t}\n\t}\n\tif ((r = sshbuf_put_u8(authctxt->session_info, '\\n')) != 0)\n\t\tfatal_fr(r, \"append\");\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}