{
  "module_name": "sftp-server.c",
  "hash_id": "db1d9e8cc7a8bac0ddb6ba84efb824b15bf15f6a15a750660d881c2c9929c72c",
  "original_prompt": "Ingested from openssh-9.6p1/sftp-server.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <pwd.h>\n#include <grp.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"sshbuf.h\"\n#include \"ssherr.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"match.h\"\n#include \"uidswap.h\"\n\n#include \"sftp.h\"\n#include \"sftp-common.h\"\n\nchar *sftp_realpath(const char *, char *);  \n\n \n#define SFTP_MAX_READ_LENGTH (SFTP_MAX_MSG_LENGTH - 1024)\n\n \nstatic LogLevel log_level = SYSLOG_LEVEL_ERROR;\n\n \nstatic struct passwd *pw = NULL;\nstatic char *client_addr = NULL;\n\n \nstruct sshbuf *iqueue;\nstruct sshbuf *oqueue;\n\n \nstatic u_int version;\n\n \nstatic int init_done;\n\n \nstatic int readonly;\n\n \nstatic char *request_allowlist, *request_denylist;\n\n \ntypedef struct Stat Stat;\n\nstruct Stat {\n\tchar *name;\n\tchar *long_name;\n\tAttrib attrib;\n};\n\n \nstatic void process_open(u_int32_t id);\nstatic void process_close(u_int32_t id);\nstatic void process_read(u_int32_t id);\nstatic void process_write(u_int32_t id);\nstatic void process_stat(u_int32_t id);\nstatic void process_lstat(u_int32_t id);\nstatic void process_fstat(u_int32_t id);\nstatic void process_setstat(u_int32_t id);\nstatic void process_fsetstat(u_int32_t id);\nstatic void process_opendir(u_int32_t id);\nstatic void process_readdir(u_int32_t id);\nstatic void process_remove(u_int32_t id);\nstatic void process_mkdir(u_int32_t id);\nstatic void process_rmdir(u_int32_t id);\nstatic void process_realpath(u_int32_t id);\nstatic void process_rename(u_int32_t id);\nstatic void process_readlink(u_int32_t id);\nstatic void process_symlink(u_int32_t id);\nstatic void process_extended_posix_rename(u_int32_t id);\nstatic void process_extended_statvfs(u_int32_t id);\nstatic void process_extended_fstatvfs(u_int32_t id);\nstatic void process_extended_hardlink(u_int32_t id);\nstatic void process_extended_fsync(u_int32_t id);\nstatic void process_extended_lsetstat(u_int32_t id);\nstatic void process_extended_limits(u_int32_t id);\nstatic void process_extended_expand(u_int32_t id);\nstatic void process_extended_copy_data(u_int32_t id);\nstatic void process_extended_home_directory(u_int32_t id);\nstatic void process_extended_get_users_groups_by_id(u_int32_t id);\nstatic void process_extended(u_int32_t id);\n\nstruct sftp_handler {\n\tconst char *name;\t \n\tconst char *ext_name;\t \n\tu_int type;\t\t \n\tvoid (*handler)(u_int32_t);\n\tint does_write;\t\t \n};\n\nstatic const struct sftp_handler handlers[] = {\n\t \n\t{ \"open\", NULL, SSH2_FXP_OPEN, process_open, 0 },\n\t{ \"close\", NULL, SSH2_FXP_CLOSE, process_close, 0 },\n\t{ \"read\", NULL, SSH2_FXP_READ, process_read, 0 },\n\t{ \"write\", NULL, SSH2_FXP_WRITE, process_write, 1 },\n\t{ \"lstat\", NULL, SSH2_FXP_LSTAT, process_lstat, 0 },\n\t{ \"fstat\", NULL, SSH2_FXP_FSTAT, process_fstat, 0 },\n\t{ \"setstat\", NULL, SSH2_FXP_SETSTAT, process_setstat, 1 },\n\t{ \"fsetstat\", NULL, SSH2_FXP_FSETSTAT, process_fsetstat, 1 },\n\t{ \"opendir\", NULL, SSH2_FXP_OPENDIR, process_opendir, 0 },\n\t{ \"readdir\", NULL, SSH2_FXP_READDIR, process_readdir, 0 },\n\t{ \"remove\", NULL, SSH2_FXP_REMOVE, process_remove, 1 },\n\t{ \"mkdir\", NULL, SSH2_FXP_MKDIR, process_mkdir, 1 },\n\t{ \"rmdir\", NULL, SSH2_FXP_RMDIR, process_rmdir, 1 },\n\t{ \"realpath\", NULL, SSH2_FXP_REALPATH, process_realpath, 0 },\n\t{ \"stat\", NULL, SSH2_FXP_STAT, process_stat, 0 },\n\t{ \"rename\", NULL, SSH2_FXP_RENAME, process_rename, 1 },\n\t{ \"readlink\", NULL, SSH2_FXP_READLINK, process_readlink, 0 },\n\t{ \"symlink\", NULL, SSH2_FXP_SYMLINK, process_symlink, 1 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};\n\n \nstatic const struct sftp_handler extended_handlers[] = {\n\t{ \"posix-rename\", \"posix-rename@openssh.com\", 0,\n\t    process_extended_posix_rename, 1 },\n\t{ \"statvfs\", \"statvfs@openssh.com\", 0, process_extended_statvfs, 0 },\n\t{ \"fstatvfs\", \"fstatvfs@openssh.com\", 0, process_extended_fstatvfs, 0 },\n\t{ \"hardlink\", \"hardlink@openssh.com\", 0, process_extended_hardlink, 1 },\n\t{ \"fsync\", \"fsync@openssh.com\", 0, process_extended_fsync, 1 },\n\t{ \"lsetstat\", \"lsetstat@openssh.com\", 0, process_extended_lsetstat, 1 },\n\t{ \"limits\", \"limits@openssh.com\", 0, process_extended_limits, 0 },\n\t{ \"expand-path\", \"expand-path@openssh.com\", 0,\n\t    process_extended_expand, 0 },\n\t{ \"copy-data\", \"copy-data\", 0, process_extended_copy_data, 1 },\n\t{ \"home-directory\", \"home-directory\", 0,\n\t    process_extended_home_directory, 0 },\n\t{ \"users-groups-by-id\", \"users-groups-by-id@openssh.com\", 0,\n\t    process_extended_get_users_groups_by_id, 0 },\n\t{ NULL, NULL, 0, NULL, 0 }\n};\n\nstatic const struct sftp_handler *\nextended_handler_byname(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; extended_handlers[i].handler != NULL; i++) {\n\t\tif (strcmp(name, extended_handlers[i].ext_name) == 0)\n\t\t\treturn &extended_handlers[i];\n\t}\n\treturn NULL;\n}\n\nstatic int\nrequest_permitted(const struct sftp_handler *h)\n{\n\tchar *result;\n\n\tif (readonly && h->does_write) {\n\t\tverbose(\"Refusing %s request in read-only mode\", h->name);\n\t\treturn 0;\n\t}\n\tif (request_denylist != NULL &&\n\t    ((result = match_list(h->name, request_denylist, NULL))) != NULL) {\n\t\tfree(result);\n\t\tverbose(\"Refusing denylisted %s request\", h->name);\n\t\treturn 0;\n\t}\n\tif (request_allowlist != NULL &&\n\t    ((result = match_list(h->name, request_allowlist, NULL))) != NULL) {\n\t\tfree(result);\n\t\tdebug2(\"Permitting allowlisted %s request\", h->name);\n\t\treturn 1;\n\t}\n\tif (request_allowlist != NULL) {\n\t\tverbose(\"Refusing non-allowlisted %s request\", h->name);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\nerrno_to_portable(int unixerrno)\n{\n\tint ret = 0;\n\n\tswitch (unixerrno) {\n\tcase 0:\n\t\tret = SSH2_FX_OK;\n\t\tbreak;\n\tcase ENOENT:\n\tcase ENOTDIR:\n\tcase EBADF:\n\tcase ELOOP:\n\t\tret = SSH2_FX_NO_SUCH_FILE;\n\t\tbreak;\n\tcase EPERM:\n\tcase EACCES:\n\tcase EFAULT:\n\t\tret = SSH2_FX_PERMISSION_DENIED;\n\t\tbreak;\n\tcase ENAMETOOLONG:\n\tcase EINVAL:\n\t\tret = SSH2_FX_BAD_MESSAGE;\n\t\tbreak;\n\tcase ENOSYS:\n\t\tret = SSH2_FX_OP_UNSUPPORTED;\n\t\tbreak;\n\tdefault:\n\t\tret = SSH2_FX_FAILURE;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int\nflags_from_portable(int pflags)\n{\n\tint flags = 0;\n\n\tif ((pflags & SSH2_FXF_READ) &&\n\t    (pflags & SSH2_FXF_WRITE)) {\n\t\tflags = O_RDWR;\n\t} else if (pflags & SSH2_FXF_READ) {\n\t\tflags = O_RDONLY;\n\t} else if (pflags & SSH2_FXF_WRITE) {\n\t\tflags = O_WRONLY;\n\t}\n\tif (pflags & SSH2_FXF_APPEND)\n\t\tflags |= O_APPEND;\n\tif (pflags & SSH2_FXF_CREAT)\n\t\tflags |= O_CREAT;\n\tif (pflags & SSH2_FXF_TRUNC)\n\t\tflags |= O_TRUNC;\n\tif (pflags & SSH2_FXF_EXCL)\n\t\tflags |= O_EXCL;\n\treturn flags;\n}\n\nstatic const char *\nstring_from_portable(int pflags)\n{\n\tstatic char ret[128];\n\n\t*ret = '\\0';\n\n#define PAPPEND(str)\t{\t\t\t\t\\\n\t\tif (*ret != '\\0')\t\t\t\\\n\t\t\tstrlcat(ret, \",\", sizeof(ret));\t\\\n\t\tstrlcat(ret, str, sizeof(ret));\t\t\\\n\t}\n\n\tif (pflags & SSH2_FXF_READ)\n\t\tPAPPEND(\"READ\")\n\tif (pflags & SSH2_FXF_WRITE)\n\t\tPAPPEND(\"WRITE\")\n\tif (pflags & SSH2_FXF_APPEND)\n\t\tPAPPEND(\"APPEND\")\n\tif (pflags & SSH2_FXF_CREAT)\n\t\tPAPPEND(\"CREATE\")\n\tif (pflags & SSH2_FXF_TRUNC)\n\t\tPAPPEND(\"TRUNCATE\")\n\tif (pflags & SSH2_FXF_EXCL)\n\t\tPAPPEND(\"EXCL\")\n\n\treturn ret;\n}\n\n \n\ntypedef struct Handle Handle;\nstruct Handle {\n\tint use;\n\tDIR *dirp;\n\tint fd;\n\tint flags;\n\tchar *name;\n\tu_int64_t bytes_read, bytes_write;\n\tint next_unused;\n};\n\nenum {\n\tHANDLE_UNUSED,\n\tHANDLE_DIR,\n\tHANDLE_FILE\n};\n\nstatic Handle *handles = NULL;\nstatic u_int num_handles = 0;\nstatic int first_unused_handle = -1;\n\nstatic void handle_unused(int i)\n{\n\thandles[i].use = HANDLE_UNUSED;\n\thandles[i].next_unused = first_unused_handle;\n\tfirst_unused_handle = i;\n}\n\nstatic int\nhandle_new(int use, const char *name, int fd, int flags, DIR *dirp)\n{\n\tint i;\n\n\tif (first_unused_handle == -1) {\n\t\tif (num_handles + 1 <= num_handles)\n\t\t\treturn -1;\n\t\tnum_handles++;\n\t\thandles = xreallocarray(handles, num_handles, sizeof(Handle));\n\t\thandle_unused(num_handles - 1);\n\t}\n\n\ti = first_unused_handle;\n\tfirst_unused_handle = handles[i].next_unused;\n\n\thandles[i].use = use;\n\thandles[i].dirp = dirp;\n\thandles[i].fd = fd;\n\thandles[i].flags = flags;\n\thandles[i].name = xstrdup(name);\n\thandles[i].bytes_read = handles[i].bytes_write = 0;\n\n\treturn i;\n}\n\nstatic int\nhandle_is_ok(int i, int type)\n{\n\treturn i >= 0 && (u_int)i < num_handles && handles[i].use == type;\n}\n\nstatic int\nhandle_to_string(int handle, u_char **stringp, int *hlenp)\n{\n\tif (stringp == NULL || hlenp == NULL)\n\t\treturn -1;\n\t*stringp = xmalloc(sizeof(int32_t));\n\tput_u32(*stringp, handle);\n\t*hlenp = sizeof(int32_t);\n\treturn 0;\n}\n\nstatic int\nhandle_from_string(const u_char *handle, u_int hlen)\n{\n\tint val;\n\n\tif (hlen != sizeof(int32_t))\n\t\treturn -1;\n\tval = get_u32(handle);\n\tif (handle_is_ok(val, HANDLE_FILE) ||\n\t    handle_is_ok(val, HANDLE_DIR))\n\t\treturn val;\n\treturn -1;\n}\n\nstatic char *\nhandle_to_name(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_DIR)||\n\t    handle_is_ok(handle, HANDLE_FILE))\n\t\treturn handles[handle].name;\n\treturn NULL;\n}\n\nstatic DIR *\nhandle_to_dir(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_DIR))\n\t\treturn handles[handle].dirp;\n\treturn NULL;\n}\n\nstatic int\nhandle_to_fd(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE))\n\t\treturn handles[handle].fd;\n\treturn -1;\n}\n\nstatic int\nhandle_to_flags(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE))\n\t\treturn handles[handle].flags;\n\treturn 0;\n}\n\nstatic void\nhandle_update_read(int handle, ssize_t bytes)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)\n\t\thandles[handle].bytes_read += bytes;\n}\n\nstatic void\nhandle_update_write(int handle, ssize_t bytes)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)\n\t\thandles[handle].bytes_write += bytes;\n}\n\nstatic u_int64_t\nhandle_bytes_read(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE))\n\t\treturn (handles[handle].bytes_read);\n\treturn 0;\n}\n\nstatic u_int64_t\nhandle_bytes_write(int handle)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE))\n\t\treturn (handles[handle].bytes_write);\n\treturn 0;\n}\n\nstatic int\nhandle_close(int handle)\n{\n\tint ret = -1;\n\n\tif (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tret = close(handles[handle].fd);\n\t\tfree(handles[handle].name);\n\t\thandle_unused(handle);\n\t} else if (handle_is_ok(handle, HANDLE_DIR)) {\n\t\tret = closedir(handles[handle].dirp);\n\t\tfree(handles[handle].name);\n\t\thandle_unused(handle);\n\t} else {\n\t\terrno = ENOENT;\n\t}\n\treturn ret;\n}\n\nstatic void\nhandle_log_close(int handle, char *emsg)\n{\n\tif (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tlogit(\"%s%sclose \\\"%s\\\" bytes read %llu written %llu\",\n\t\t    emsg == NULL ? \"\" : emsg, emsg == NULL ? \"\" : \" \",\n\t\t    handle_to_name(handle),\n\t\t    (unsigned long long)handle_bytes_read(handle),\n\t\t    (unsigned long long)handle_bytes_write(handle));\n\t} else {\n\t\tlogit(\"%s%sclosedir \\\"%s\\\"\",\n\t\t    emsg == NULL ? \"\" : emsg, emsg == NULL ? \"\" : \" \",\n\t\t    handle_to_name(handle));\n\t}\n}\n\nstatic void\nhandle_log_exit(void)\n{\n\tu_int i;\n\n\tfor (i = 0; i < num_handles; i++)\n\t\tif (handles[i].use != HANDLE_UNUSED)\n\t\t\thandle_log_close(i, \"forced\");\n}\n\nstatic int\nget_handle(struct sshbuf *queue, int *hp)\n{\n\tu_char *handle;\n\tint r;\n\tsize_t hlen;\n\n\t*hp = -1;\n\tif ((r = sshbuf_get_string(queue, &handle, &hlen)) != 0)\n\t\treturn r;\n\tif (hlen < 256)\n\t\t*hp = handle_from_string(handle, hlen);\n\tfree(handle);\n\treturn 0;\n}\n\n \n\nstatic void\nsend_msg(struct sshbuf *m)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_stringb(oqueue, m)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_reset(m);\n}\n\nstatic const char *\nstatus_to_message(u_int32_t status)\n{\n\tstatic const char * const status_messages[] = {\n\t\t\"Success\",\t\t\t \n\t\t\"End of file\",\t\t\t \n\t\t\"No such file\",\t\t\t \n\t\t\"Permission denied\",\t\t \n\t\t\"Failure\",\t\t\t \n\t\t\"Bad message\",\t\t\t \n\t\t\"No connection\",\t\t \n\t\t\"Connection lost\",\t\t \n\t\t\"Operation unsupported\",\t \n\t\t\"Unknown error\"\t\t\t \n\t};\n\treturn (status_messages[MINIMUM(status,SSH2_FX_MAX)]);\n}\n\nstatic void\nsend_status_errmsg(u_int32_t id, u_int32_t status, const char *errmsg)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tdebug3(\"request %u: sent status %u\", id, status);\n\tif (log_level > SYSLOG_LEVEL_VERBOSE ||\n\t    (status != SSH2_FX_OK && status != SSH2_FX_EOF))\n\t\tlogit(\"sent status %s\", status_to_message(status));\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_STATUS)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, status)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif (version >= 3) {\n\t\tif ((r = sshbuf_put_cstring(msg, errmsg == NULL ?\n\t\t    status_to_message(status) : errmsg)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, \"\")) != 0)\n\t\t\tfatal_fr(r, \"compose message\");\n\t}\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nsend_status(u_int32_t id, u_int32_t status)\n{\n\tsend_status_errmsg(id, status, NULL);\n}\n\nstatic void\nsend_data_or_handle(char type, u_int32_t id, const u_char *data, int dlen)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, type)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_string(msg, data, dlen)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nsend_data(u_int32_t id, const u_char *data, int dlen)\n{\n\tdebug(\"request %u: sent data len %d\", id, dlen);\n\tsend_data_or_handle(SSH2_FXP_DATA, id, data, dlen);\n}\n\nstatic void\nsend_handle(u_int32_t id, int handle)\n{\n\tu_char *string;\n\tint hlen;\n\n\thandle_to_string(handle, &string, &hlen);\n\tdebug(\"request %u: sent handle %d\", id, handle);\n\tsend_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);\n\tfree(string);\n}\n\nstatic void\nsend_names(u_int32_t id, int count, const Stat *stats)\n{\n\tstruct sshbuf *msg;\n\tint i, r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_NAME)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, count)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tdebug(\"request %u: sent names count %d\", id, count);\n\tfor (i = 0; i < count; i++) {\n\t\tif ((r = sshbuf_put_cstring(msg, stats[i].name)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(msg, stats[i].long_name)) != 0 ||\n\t\t    (r = encode_attrib(msg, &stats[i].attrib)) != 0)\n\t\t\tfatal_fr(r, \"compose filenames/attrib\");\n\t}\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nsend_attrib(u_int32_t id, const Attrib *a)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tdebug(\"request %u: sent attrib have 0x%x\", id, a->flags);\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_ATTRS)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = encode_attrib(msg, a)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nsend_statvfs(u_int32_t id, struct statvfs *st)\n{\n\tstruct sshbuf *msg;\n\tu_int64_t flag;\n\tint r;\n\n\tflag = (st->f_flag & ST_RDONLY) ? SSH2_FXE_STATVFS_ST_RDONLY : 0;\n\tflag |= (st->f_flag & ST_NOSUID) ? SSH2_FXE_STATVFS_ST_NOSUID : 0;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED_REPLY)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_bsize)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_frsize)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_blocks)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_bfree)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_bavail)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_files)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_ffree)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_favail)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, FSID_TO_ULONG(st->f_fsid))) != 0 ||\n\t    (r = sshbuf_put_u64(msg, flag)) != 0 ||\n\t    (r = sshbuf_put_u64(msg, st->f_namemax)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\n \nstatic int\ncompose_extension(struct sshbuf *msg, const char *name, const char *ver)\n{\n\tint r;\n\tconst struct sftp_handler *exthnd;\n\n\tif ((exthnd = extended_handler_byname(name)) == NULL)\n\t\tfatal_f(\"internal error: no handler for %s\", name);\n\tif (!request_permitted(exthnd)) {\n\t\tdebug2_f(\"refusing to advertise disallowed extension %s\", name);\n\t\treturn 0;\n\t}\n\tif ((r = sshbuf_put_cstring(msg, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(msg, ver)) != 0)\n\t\tfatal_fr(r, \"compose %s\", name);\n\treturn 0;\n}\n\n \n\nstatic void\nprocess_init(void)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((r = sshbuf_get_u32(iqueue, &version)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tverbose(\"received client version %u\", version);\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_VERSION)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, SSH2_FILEXFER_VERSION)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\n\t  \n\tcompose_extension(msg, \"posix-rename@openssh.com\", \"1\");\n\tcompose_extension(msg, \"statvfs@openssh.com\", \"2\");\n\tcompose_extension(msg, \"fstatvfs@openssh.com\", \"2\");\n\tcompose_extension(msg, \"hardlink@openssh.com\", \"1\");\n\tcompose_extension(msg, \"fsync@openssh.com\", \"1\");\n\tcompose_extension(msg, \"lsetstat@openssh.com\", \"1\");\n\tcompose_extension(msg, \"limits@openssh.com\", \"1\");\n\tcompose_extension(msg, \"expand-path@openssh.com\", \"1\");\n\tcompose_extension(msg, \"copy-data\", \"1\");\n\tcompose_extension(msg, \"home-directory\", \"1\");\n\tcompose_extension(msg, \"users-groups-by-id@openssh.com\", \"1\");\n\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nprocess_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 ||  \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) != O_RDONLY ||\n\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd == -1) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_close(u_int32_t id)\n{\n\tint r, handle, ret, status = SSH2_FX_FAILURE;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: close handle %u\", id, handle);\n\thandle_log_close(handle, NULL);\n\tret = handle_close(handle);\n\tstatus = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n}\n\nstatic void\nprocess_read(u_int32_t id)\n{\n\tstatic u_char *buf;\n\tstatic size_t buflen;\n\tu_int32_t len;\n\tint r, handle, fd, ret, status = SSH2_FX_FAILURE;\n\tu_int64_t off;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0 ||\n\t    (r = sshbuf_get_u64(iqueue, &off)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &len)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug(\"request %u: read \\\"%s\\\" (handle %d) off %llu len %u\",\n\t    id, handle_to_name(handle), handle, (unsigned long long)off, len);\n\tif ((fd = handle_to_fd(handle)) == -1)\n\t\tgoto out;\n\tif (len > SFTP_MAX_READ_LENGTH) {\n\t\tdebug2(\"read change len %u to %u\", len, SFTP_MAX_READ_LENGTH);\n\t\tlen = SFTP_MAX_READ_LENGTH;\n\t}\n\tif (len > buflen) {\n\t\tdebug3_f(\"allocate %zu => %u\", buflen, len);\n\t\tif ((buf = realloc(buf, len)) == NULL)\n\t\t\tfatal_f(\"realloc failed\");\n\t\tbuflen = len;\n\t}\n\tif (lseek(fd, off, SEEK_SET) == -1) {\n\t\tstatus = errno_to_portable(errno);\n\t\terror_f(\"seek \\\"%.100s\\\": %s\", handle_to_name(handle),\n\t\t    strerror(errno));\n\t\tgoto out;\n\t}\n\tif (len == 0) {\n\t\t \n\t\tret = 0;\n\t} else if ((ret = read(fd, buf, len)) == -1) {\n\t\tstatus = errno_to_portable(errno);\n\t\terror_f(\"read \\\"%.100s\\\": %s\", handle_to_name(handle),\n\t\t    strerror(errno));\n\t\tgoto out;\n\t} else if (ret == 0) {\n\t\tstatus = SSH2_FX_EOF;\n\t\tgoto out;\n\t}\n\tsend_data(id, buf, ret);\n\thandle_update_read(handle, ret);\n\t \n\tstatus = SSH2_FX_OK;\n out:\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n}\n\nstatic void\nprocess_write(u_int32_t id)\n{\n\tu_int64_t off;\n\tsize_t len;\n\tint r, handle, fd, ret, status;\n\tu_char *data;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0 ||\n\t    (r = sshbuf_get_u64(iqueue, &off)) != 0 ||\n\t    (r = sshbuf_get_string(iqueue, &data, &len)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug(\"request %u: write \\\"%s\\\" (handle %d) off %llu len %zu\",\n\t    id, handle_to_name(handle), handle, (unsigned long long)off, len);\n\tfd = handle_to_fd(handle);\n\n\tif (fd < 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\telse {\n\t\tif (!(handle_to_flags(handle) & O_APPEND) &&\n\t\t    lseek(fd, off, SEEK_SET) == -1) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t\terror_f(\"seek \\\"%.100s\\\": %s\", handle_to_name(handle),\n\t\t\t    strerror(errno));\n\t\t} else {\n \n\t\t\tret = write(fd, data, len);\n\t\t\tif (ret == -1) {\n\t\t\t\tstatus = errno_to_portable(errno);\n\t\t\t\terror_f(\"write \\\"%.100s\\\": %s\",\n\t\t\t\t    handle_to_name(handle), strerror(errno));\n\t\t\t} else if ((size_t)ret == len) {\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t\thandle_update_write(handle, ret);\n\t\t\t} else {\n\t\t\t\tdebug2_f(\"nothing at all written\");\n\t\t\t\tstatus = SSH2_FX_FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\tsend_status(id, status);\n\tfree(data);\n}\n\nstatic void\nprocess_do_stat(u_int32_t id, int do_lstat)\n{\n\tAttrib a;\n\tstruct stat st;\n\tchar *name;\n\tint r, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: %sstat\", id, do_lstat ? \"l\" : \"\");\n\tverbose(\"%sstat name \\\"%s\\\"\", do_lstat ? \"l\" : \"\", name);\n\tr = do_lstat ? lstat(name, &st) : stat(name, &st);\n\tif (r == -1) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\tstat_to_attrib(&st, &a);\n\t\tsend_attrib(id, &a);\n\t\tstatus = SSH2_FX_OK;\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_stat(u_int32_t id)\n{\n\tprocess_do_stat(id, 0);\n}\n\nstatic void\nprocess_lstat(u_int32_t id)\n{\n\tprocess_do_stat(id, 1);\n}\n\nstatic void\nprocess_fstat(u_int32_t id)\n{\n\tAttrib a;\n\tstruct stat st;\n\tint fd, r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug(\"request %u: fstat \\\"%s\\\" (handle %u)\",\n\t    id, handle_to_name(handle), handle);\n\tfd = handle_to_fd(handle);\n\tif (fd >= 0) {\n\t\tr = fstat(fd, &st);\n\t\tif (r == -1) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\tstat_to_attrib(&st, &a);\n\t\t\tsend_attrib(id, &a);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n}\n\nstatic struct timeval *\nattrib_to_tv(const Attrib *a)\n{\n\tstatic struct timeval tv[2];\n\n\ttv[0].tv_sec = a->atime;\n\ttv[0].tv_usec = 0;\n\ttv[1].tv_sec = a->mtime;\n\ttv[1].tv_usec = 0;\n\treturn tv;\n}\n\nstatic struct timespec *\nattrib_to_ts(const Attrib *a)\n{\n\tstatic struct timespec ts[2];\n\n\tts[0].tv_sec = a->atime;\n\tts[0].tv_nsec = 0;\n\tts[1].tv_sec = a->mtime;\n\tts[1].tv_nsec = 0;\n\treturn ts;\n}\n\nstatic void\nprocess_setstat(u_int32_t id)\n{\n\tAttrib a;\n\tchar *name;\n\tint r, status = SSH2_FX_OK;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug(\"request %u: setstat name \\\"%s\\\"\", id, name);\n\tif (a.flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\tlogit(\"set \\\"%s\\\" size %llu\",\n\t\t    name, (unsigned long long)a.size);\n\t\tr = truncate(name, a.size);\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n\tif (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tlogit(\"set \\\"%s\\\" mode %04o\", name, a.perm);\n\t\tr = chmod(name, a.perm & 07777);\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n\tif (a.flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tchar buf[64];\n\t\ttime_t t = a.mtime;\n\n\t\tstrftime(buf, sizeof(buf), \"%Y%m%d-%H:%M:%S\",\n\t\t    localtime(&t));\n\t\tlogit(\"set \\\"%s\\\" modtime %s\", name, buf);\n\t\tr = utimes(name, attrib_to_tv(&a));\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n\tif (a.flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tlogit(\"set \\\"%s\\\" owner %lu group %lu\", name,\n\t\t    (u_long)a.uid, (u_long)a.gid);\n\t\tr = chown(name, a.uid, a.gid);\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_fsetstat(u_int32_t id)\n{\n\tAttrib a;\n\tint handle, fd, r;\n\tint status = SSH2_FX_OK;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0 ||\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug(\"request %u: fsetstat handle %d\", id, handle);\n\tfd = handle_to_fd(handle);\n\tif (fd < 0)\n\t\tstatus = SSH2_FX_FAILURE;\n\telse {\n\t\tchar *name = handle_to_name(handle);\n\n\t\tif (a.flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\t\tlogit(\"set \\\"%s\\\" size %llu\",\n\t\t\t    name, (unsigned long long)a.size);\n\t\t\tr = ftruncate(fd, a.size);\n\t\t\tif (r == -1)\n\t\t\t\tstatus = errno_to_portable(errno);\n\t\t}\n\t\tif (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\t\tlogit(\"set \\\"%s\\\" mode %04o\", name, a.perm);\n#ifdef HAVE_FCHMOD\n\t\t\tr = fchmod(fd, a.perm & 07777);\n#else\n\t\t\tr = chmod(name, a.perm & 07777);\n#endif\n\t\t\tif (r == -1)\n\t\t\t\tstatus = errno_to_portable(errno);\n\t\t}\n\t\tif (a.flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\t\tchar buf[64];\n\t\t\ttime_t t = a.mtime;\n\n\t\t\tstrftime(buf, sizeof(buf), \"%Y%m%d-%H:%M:%S\",\n\t\t\t    localtime(&t));\n\t\t\tlogit(\"set \\\"%s\\\" modtime %s\", name, buf);\n#ifdef HAVE_FUTIMES\n\t\t\tr = futimes(fd, attrib_to_tv(&a));\n#else\n\t\t\tr = utimes(name, attrib_to_tv(&a));\n#endif\n\t\t\tif (r == -1)\n\t\t\t\tstatus = errno_to_portable(errno);\n\t\t}\n\t\tif (a.flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\t\tlogit(\"set \\\"%s\\\" owner %lu group %lu\", name,\n\t\t\t    (u_long)a.uid, (u_long)a.gid);\n#ifdef HAVE_FCHOWN\n\t\t\tr = fchown(fd, a.uid, a.gid);\n#else\n\t\t\tr = chown(name, a.uid, a.gid);\n#endif\n\t\t\tif (r == -1)\n\t\t\t\tstatus = errno_to_portable(errno);\n\t\t}\n\t}\n\tsend_status(id, status);\n}\n\nstatic void\nprocess_opendir(u_int32_t id)\n{\n\tDIR *dirp = NULL;\n\tchar *path;\n\tint r, handle, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: opendir\", id);\n\tlogit(\"opendir \\\"%s\\\"\", path);\n\tdirp = opendir(path);\n\tif (dirp == NULL) {\n\t\tstatus = errno_to_portable(errno);\n\t} else {\n\t\thandle = handle_new(HANDLE_DIR, path, 0, 0, dirp);\n\t\tif (handle < 0) {\n\t\t\tclosedir(dirp);\n\t\t} else {\n\t\t\tsend_handle(id, handle);\n\t\t\tstatus = SSH2_FX_OK;\n\t\t}\n\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(path);\n}\n\nstatic void\nprocess_readdir(u_int32_t id)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *path;\n\tint r, handle;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug(\"request %u: readdir \\\"%s\\\" (handle %d)\", id,\n\t    handle_to_name(handle), handle);\n\tdirp = handle_to_dir(handle);\n\tpath = handle_to_name(handle);\n\tif (dirp == NULL || path == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t} else {\n\t\tstruct stat st;\n\t\tchar pathname[PATH_MAX];\n\t\tStat *stats;\n\t\tint nstats = 10, count = 0, i;\n\n\t\tstats = xcalloc(nstats, sizeof(Stat));\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (count >= nstats) {\n\t\t\t\tnstats *= 2;\n\t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n\t\t\t}\n \n\t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n\t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n\t\t\tif (lstat(pathname, &st) == -1)\n\t\t\t\tcontinue;\n\t\t\tstat_to_attrib(&st, &(stats[count].attrib));\n\t\t\tstats[count].name = xstrdup(dp->d_name);\n\t\t\tstats[count].long_name = ls_file(dp->d_name, &st,\n\t\t\t    0, 0, NULL, NULL);\n\t\t\tcount++;\n\t\t\t \n\t\t\t \n\t\t\tif (count == 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tsend_names(id, count, stats);\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tfree(stats[i].name);\n\t\t\t\tfree(stats[i].long_name);\n\t\t\t}\n\t\t} else {\n\t\t\tsend_status(id, SSH2_FX_EOF);\n\t\t}\n\t\tfree(stats);\n\t}\n}\n\nstatic void\nprocess_remove(u_int32_t id)\n{\n\tchar *name;\n\tint r, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: remove\", id);\n\tlogit(\"remove name \\\"%s\\\"\", name);\n\tr = unlink(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_mkdir(u_int32_t id)\n{\n\tAttrib a;\n\tchar *name;\n\tint r, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ?\n\t    a.perm & 07777 : 0777;\n\tdebug3(\"request %u: mkdir\", id);\n\tlogit(\"mkdir name \\\"%s\\\" mode 0%o\", name, mode);\n\tr = mkdir(name, mode);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_rmdir(u_int32_t id)\n{\n\tchar *name;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: rmdir\", id);\n\tlogit(\"rmdir name \\\"%s\\\"\", name);\n\tr = rmdir(name);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_realpath(u_int32_t id)\n{\n\tchar resolvedname[PATH_MAX];\n\tchar *path;\n\tint r;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (path[0] == '\\0') {\n\t\tfree(path);\n\t\tpath = xstrdup(\".\");\n\t}\n\tdebug3(\"request %u: realpath\", id);\n\tverbose(\"realpath \\\"%s\\\"\", path);\n\tif (sftp_realpath(path, resolvedname) == NULL) {\n\t\tsend_status(id, errno_to_portable(errno));\n\t} else {\n\t\tStat s;\n\t\tattrib_clear(&s.attrib);\n\t\ts.name = s.long_name = resolvedname;\n\t\tsend_names(id, 1, &s);\n\t}\n\tfree(path);\n}\n\nstatic void\nprocess_rename(u_int32_t id)\n{\n\tchar *oldpath, *newpath;\n\tint r, status;\n\tstruct stat sb;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: rename\", id);\n\tlogit(\"rename old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n\tstatus = SSH2_FX_FAILURE;\n\tif (lstat(oldpath, &sb) == -1)\n\t\tstatus = errno_to_portable(errno);\n\telse if (S_ISREG(sb.st_mode)) {\n\t\t \n\t\tif (link(oldpath, newpath) == -1) {\n\t\t\tif (errno == EOPNOTSUPP || errno == ENOSYS\n#ifdef EXDEV\n\t\t\t    || errno == EXDEV\n#endif\n#ifdef LINK_OPNOTSUPP_ERRNO\n\t\t\t    || errno == LINK_OPNOTSUPP_ERRNO\n#endif\n\t\t\t    ) {\n\t\t\t\tstruct stat st;\n\n\t\t\t\t \n\t\t\t\tif (stat(newpath, &st) == -1) {\n\t\t\t\t\tif (rename(oldpath, newpath) == -1)\n\t\t\t\t\t\tstatus =\n\t\t\t\t\t\t    errno_to_portable(errno);\n\t\t\t\t\telse\n\t\t\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus = errno_to_portable(errno);\n\t\t\t}\n\t\t} else if (unlink(oldpath) == -1) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t\t \n\t\t\tunlink(newpath);\n\t\t} else\n\t\t\tstatus = SSH2_FX_OK;\n\t} else if (stat(newpath, &sb) == -1) {\n\t\tif (rename(oldpath, newpath) == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t\telse\n\t\t\tstatus = SSH2_FX_OK;\n\t}\n\tsend_status(id, status);\n\tfree(oldpath);\n\tfree(newpath);\n}\n\nstatic void\nprocess_readlink(u_int32_t id)\n{\n\tint r, len;\n\tchar buf[PATH_MAX];\n\tchar *path;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: readlink\", id);\n\tverbose(\"readlink \\\"%s\\\"\", path);\n\tif ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)\n\t\tsend_status(id, errno_to_portable(errno));\n\telse {\n\t\tStat s;\n\n\t\tbuf[len] = '\\0';\n\t\tattrib_clear(&s.attrib);\n\t\ts.name = s.long_name = buf;\n\t\tsend_names(id, 1, &s);\n\t}\n\tfree(path);\n}\n\nstatic void\nprocess_symlink(u_int32_t id)\n{\n\tchar *oldpath, *newpath;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: symlink\", id);\n\tlogit(\"symlink old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n\t \n\tr = symlink(oldpath, newpath);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(oldpath);\n\tfree(newpath);\n}\n\nstatic void\nprocess_extended_posix_rename(u_int32_t id)\n{\n\tchar *oldpath, *newpath;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: posix-rename\", id);\n\tlogit(\"posix-rename old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n\tr = rename(oldpath, newpath);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(oldpath);\n\tfree(newpath);\n}\n\nstatic void\nprocess_extended_statvfs(u_int32_t id)\n{\n\tchar *path;\n\tstruct statvfs st;\n\tint r;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug3(\"request %u: statvfs\", id);\n\tlogit(\"statvfs \\\"%s\\\"\", path);\n\n\tif (statvfs(path, &st) != 0)\n\t\tsend_status(id, errno_to_portable(errno));\n\telse\n\t\tsend_statvfs(id, &st);\n\tfree(path);\n}\n\nstatic void\nprocess_extended_fstatvfs(u_int32_t id)\n{\n\tint r, handle, fd;\n\tstruct statvfs st;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug(\"request %u: fstatvfs \\\"%s\\\" (handle %u)\",\n\t    id, handle_to_name(handle), handle);\n\tif ((fd = handle_to_fd(handle)) < 0) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t\treturn;\n\t}\n\tif (fstatvfs(fd, &st) != 0)\n\t\tsend_status(id, errno_to_portable(errno));\n\telse\n\t\tsend_statvfs(id, &st);\n}\n\nstatic void\nprocess_extended_hardlink(u_int32_t id)\n{\n\tchar *oldpath, *newpath;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: hardlink\", id);\n\tlogit(\"hardlink old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n\tr = link(oldpath, newpath);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(oldpath);\n\tfree(newpath);\n}\n\nstatic void\nprocess_extended_fsync(u_int32_t id)\n{\n\tint handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;\n\n\tif ((r = get_handle(iqueue, &handle)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug3(\"request %u: fsync (handle %u)\", id, handle);\n\tverbose(\"fsync \\\"%s\\\"\", handle_to_name(handle));\n\tif ((fd = handle_to_fd(handle)) < 0)\n\t\tstatus = SSH2_FX_NO_SUCH_FILE;\n\telse if (handle_is_ok(handle, HANDLE_FILE)) {\n\t\tr = fsync(fd);\n\t\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\t}\n\tsend_status(id, status);\n}\n\nstatic void\nprocess_extended_lsetstat(u_int32_t id)\n{\n\tAttrib a;\n\tchar *name;\n\tint r, status = SSH2_FX_OK;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug(\"request %u: lsetstat name \\\"%s\\\"\", id, name);\n\tif (a.flags & SSH2_FILEXFER_ATTR_SIZE) {\n\t\t \n\t\tstatus = SSH2_FX_BAD_MESSAGE;\n\t\tgoto out;\n\t}\n\tif (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) {\n\t\tlogit(\"set \\\"%s\\\" mode %04o\", name, a.perm);\n\t\tr = fchmodat(AT_FDCWD, name,\n\t\t    a.perm & 07777, AT_SYMLINK_NOFOLLOW);\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n\tif (a.flags & SSH2_FILEXFER_ATTR_ACMODTIME) {\n\t\tchar buf[64];\n\t\ttime_t t = a.mtime;\n\n\t\tstrftime(buf, sizeof(buf), \"%Y%m%d-%H:%M:%S\",\n\t\t    localtime(&t));\n\t\tlogit(\"set \\\"%s\\\" modtime %s\", name, buf);\n\t\tr = utimensat(AT_FDCWD, name,\n\t\t    attrib_to_ts(&a), AT_SYMLINK_NOFOLLOW);\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n\tif (a.flags & SSH2_FILEXFER_ATTR_UIDGID) {\n\t\tlogit(\"set \\\"%s\\\" owner %lu group %lu\", name,\n\t\t    (u_long)a.uid, (u_long)a.gid);\n\t\tr = fchownat(AT_FDCWD, name, a.uid, a.gid,\n\t\t    AT_SYMLINK_NOFOLLOW);\n\t\tif (r == -1)\n\t\t\tstatus = errno_to_portable(errno);\n\t}\n out:\n\tsend_status(id, status);\n\tfree(name);\n}\n\nstatic void\nprocess_extended_limits(u_int32_t id)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\tuint64_t nfiles = 0;\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_NOFILE)\n\tstruct rlimit rlim;\n#endif\n\n\tdebug(\"request %u: limits\", id);\n\n#if defined(HAVE_GETRLIMIT) && defined(RLIMIT_NOFILE)\n\tif (getrlimit(RLIMIT_NOFILE, &rlim) != -1 && rlim.rlim_cur > 5)\n\t\tnfiles = rlim.rlim_cur - 5;  \n#endif\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED_REPLY)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t     \n\t    (r = sshbuf_put_u64(msg, SFTP_MAX_MSG_LENGTH)) != 0 ||\n\t     \n\t    (r = sshbuf_put_u64(msg, SFTP_MAX_READ_LENGTH)) != 0 ||\n\t     \n\t    (r = sshbuf_put_u64(msg, SFTP_MAX_MSG_LENGTH - 1024)) != 0 ||\n\t     \n\t    (r = sshbuf_put_u64(msg, nfiles)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(msg);\n\tsshbuf_free(msg);\n}\n\nstatic void\nprocess_extended_expand(u_int32_t id)\n{\n\tchar cwd[PATH_MAX], resolvedname[PATH_MAX];\n\tchar *path, *npath;\n\tint r;\n\tStat s;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (getcwd(cwd, sizeof(cwd)) == NULL) {\n\t\tsend_status(id, errno_to_portable(errno));\n\t\tgoto out;\n\t}\n\n\tdebug3(\"request %u: expand, original \\\"%s\\\"\", id, path);\n\tif (path[0] == '\\0') {\n\t\t \n\t\tfree(path);\n\t\tpath = xstrdup(\".\");\n\t} else if (*path == '~') {\n\t\t \n\t\t \n\t\tif (strcmp(path, \"~\") == 0) {\n\t\t\tfree(path);\n\t\t\tpath = xstrdup(cwd);\n\t\t} else if (strncmp(path, \"~/\", 2) == 0) {\n\t\t\tnpath = xstrdup(path + 2);\n\t\t\tfree(path);\n\t\t\txasprintf(&path, \"%s/%s\", cwd, npath);\n\t\t\tfree(npath);\n\t\t} else {\n\t\t\t \n\t\t\tif (tilde_expand(path, pw->pw_uid, &npath) != 0) {\n\t\t\t\tsend_status_errmsg(id,\n\t\t\t\t    errno_to_portable(ENOENT), \"no such user\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(path);\n\t\t\tpath = npath;\n\t\t}\n\t} else if (*path != '/') {\n\t\t \n\t\txasprintf(&npath, \"%s/%s\", cwd, path);\n\t\tfree(path);\n\t\tpath = npath;\n\t}\n\tverbose(\"expand \\\"%s\\\"\", path);\n\tif (sftp_realpath(path, resolvedname) == NULL) {\n\t\tsend_status(id, errno_to_portable(errno));\n\t\tgoto out;\n\t}\n\tattrib_clear(&s.attrib);\n\ts.name = s.long_name = resolvedname;\n\tsend_names(id, 1, &s);\n out:\n\tfree(path);\n}\n\nstatic void\nprocess_extended_copy_data(u_int32_t id)\n{\n\tu_char buf[64*1024];\n\tint read_handle, read_fd, write_handle, write_fd;\n\tu_int64_t len, read_off, read_len, write_off;\n\tint r, copy_until_eof, status = SSH2_FX_OP_UNSUPPORTED;\n\tsize_t ret;\n\n\tif ((r = get_handle(iqueue, &read_handle)) != 0 ||\n\t    (r = sshbuf_get_u64(iqueue, &read_off)) != 0 ||\n\t    (r = sshbuf_get_u64(iqueue, &read_len)) != 0 ||\n\t    (r = get_handle(iqueue, &write_handle)) != 0 ||\n\t    (r = sshbuf_get_u64(iqueue, &write_off)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug(\"request %u: copy-data from \\\"%s\\\" (handle %d) off %llu len %llu \"\n\t    \"to \\\"%s\\\" (handle %d) off %llu\",\n\t    id, handle_to_name(read_handle), read_handle,\n\t    (unsigned long long)read_off, (unsigned long long)read_len,\n\t    handle_to_name(write_handle), write_handle,\n\t    (unsigned long long)write_off);\n\n\t \n\tif (read_len == 0) {\n\t\tread_len = (u_int64_t)-1 - read_off;\n\t\tcopy_until_eof = 1;\n\t} else\n\t\tcopy_until_eof = 0;\n\n\tread_fd = handle_to_fd(read_handle);\n\twrite_fd = handle_to_fd(write_handle);\n\n\t \n\tif (read_handle == write_handle || read_fd < 0 || write_fd < 0 ||\n\t    !strcmp(handle_to_name(read_handle), handle_to_name(write_handle))) {\n\t\tstatus = SSH2_FX_FAILURE;\n\t\tgoto out;\n\t}\n\n\tif (lseek(read_fd, read_off, SEEK_SET) < 0) {\n\t\tstatus = errno_to_portable(errno);\n\t\terror(\"%s: read_seek failed\", __func__);\n\t\tgoto out;\n\t}\n\n\tif ((handle_to_flags(write_handle) & O_APPEND) == 0 &&\n\t    lseek(write_fd, write_off, SEEK_SET) < 0) {\n\t\tstatus = errno_to_portable(errno);\n\t\terror(\"%s: write_seek failed\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\twhile (read_len > 0 || copy_until_eof) {\n\t\tlen = MINIMUM(sizeof(buf), read_len);\n\t\tread_len -= len;\n\n\t\tret = atomicio(read, read_fd, buf, len);\n\t\tif (ret == 0 && errno == EPIPE) {\n\t\t\tstatus = copy_until_eof ? SSH2_FX_OK : SSH2_FX_EOF;\n\t\t\tbreak;\n\t\t} else if (ret == 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t\terror(\"%s: read failed: %s\", __func__, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\tlen = ret;\n\t\thandle_update_read(read_handle, len);\n\n\t\tret = atomicio(vwrite, write_fd, buf, len);\n\t\tif (ret != len) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t\terror(\"%s: write failed: %llu != %llu: %s\", __func__,\n\t\t\t    (unsigned long long)ret, (unsigned long long)len,\n\t\t\t    strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\thandle_update_write(write_handle, len);\n\t}\n\n\tif (read_len == 0)\n\t\tstatus = SSH2_FX_OK;\n\n out:\n\tsend_status(id, status);\n}\n\nstatic void\nprocess_extended_home_directory(u_int32_t id)\n{\n\tchar *username;\n\tstruct passwd *user_pw;\n\tint r;\n\tStat s;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &username, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3(\"request %u: home-directory \\\"%s\\\"\", id, username);\n\tif ((user_pw = getpwnam(username)) == NULL) {\n\t\tsend_status(id, SSH2_FX_FAILURE);\n\t\tgoto out;\n\t}\n\n\tverbose(\"home-directory \\\"%s\\\"\", pw->pw_dir);\n\tattrib_clear(&s.attrib);\n\ts.name = s.long_name = pw->pw_dir;\n\tsend_names(id, 1, &s);\n out:\n\tfree(username);\n}\n\nstatic void\nprocess_extended_get_users_groups_by_id(u_int32_t id)\n{\n\tstruct passwd *user_pw;\n\tstruct group *gr;\n\tstruct sshbuf *uids, *gids, *usernames, *groupnames, *msg;\n\tint r;\n\tu_int n, nusers = 0, ngroups = 0;\n\tconst char *name;\n\n\tif ((usernames = sshbuf_new()) == NULL ||\n\t    (groupnames = sshbuf_new()) == NULL ||\n\t    (msg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((r = sshbuf_froms(iqueue, &uids)) != 0 ||\n\t    (r = sshbuf_froms(iqueue, &gids)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug_f(\"uids len = %zu, gids len = %zu\",\n\t    sshbuf_len(uids), sshbuf_len(gids));\n\twhile (sshbuf_len(uids) != 0) {\n\t\tif ((r = sshbuf_get_u32(uids, &n)) != 0)\n\t\t\tfatal_fr(r, \"parse inner uid\");\n\t\tuser_pw = getpwuid((uid_t)n);\n\t\tname = user_pw == NULL ? \"\" : user_pw->pw_name;\n\t\tdebug3_f(\"uid %u => \\\"%s\\\"\", n, name);\n\t\tif ((r = sshbuf_put_cstring(usernames, name)) != 0)\n\t\t\tfatal_fr(r, \"assemble uid reply\");\n\t\tnusers++;\n\t}\n\twhile (sshbuf_len(gids) != 0) {\n\t\tif ((r = sshbuf_get_u32(gids, &n)) != 0)\n\t\t\tfatal_fr(r, \"parse inner gid\");\n\t\tgr = getgrgid((gid_t)n);\n\t\tname = gr == NULL ? \"\" : gr->gr_name;\n\t\tdebug3_f(\"gid %u => \\\"%s\\\"\", n, name);\n\t\tif ((r = sshbuf_put_cstring(groupnames, name)) != 0)\n\t\t\tfatal_fr(r, \"assemble gid reply\");\n\t\tnusers++;\n\t}\n\tverbose(\"users-groups-by-id: %u users, %u groups\", nusers, ngroups);\n\n\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED_REPLY)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n\t    (r = sshbuf_put_stringb(msg, usernames)) != 0 ||\n\t    (r = sshbuf_put_stringb(msg, groupnames)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tsend_msg(msg);\n\n\tsshbuf_free(uids);\n\tsshbuf_free(gids);\n\tsshbuf_free(usernames);\n\tsshbuf_free(groupnames);\n\tsshbuf_free(msg);\n}\n\nstatic void\nprocess_extended(u_int32_t id)\n{\n\tchar *request;\n\tint r;\n\tconst struct sftp_handler *exthand;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &request, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif ((exthand = extended_handler_byname(request)) == NULL) {\n\t\terror(\"Unknown extended request \\\"%.100s\\\"\", request);\n\t\tsend_status(id, SSH2_FX_OP_UNSUPPORTED);\t \n\t} else {\n\t\tif (!request_permitted(exthand))\n\t\t\tsend_status(id, SSH2_FX_PERMISSION_DENIED);\n\t\telse\n\t\t\texthand->handler(id);\n\t}\n\tfree(request);\n}\n\n \n\nstatic void\nprocess(void)\n{\n\tu_int msg_len;\n\tu_int buf_len;\n\tu_int consumed;\n\tu_char type;\n\tconst u_char *cp;\n\tint i, r;\n\tu_int32_t id;\n\n\tbuf_len = sshbuf_len(iqueue);\n\tif (buf_len < 5)\n\t\treturn;\t\t \n\tcp = sshbuf_ptr(iqueue);\n\tmsg_len = get_u32(cp);\n\tif (msg_len > SFTP_MAX_MSG_LENGTH) {\n\t\terror(\"bad message from %s local user %s\",\n\t\t    client_addr, pw->pw_name);\n\t\tsftp_server_cleanup_exit(11);\n\t}\n\tif (buf_len < msg_len + 4)\n\t\treturn;\n\tif ((r = sshbuf_consume(iqueue, 4)) != 0)\n\t\tfatal_fr(r, \"consume\");\n\tbuf_len -= 4;\n\tif ((r = sshbuf_get_u8(iqueue, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\n\tswitch (type) {\n\tcase SSH2_FXP_INIT:\n\t\tprocess_init();\n\t\tinit_done = 1;\n\t\tbreak;\n\tcase SSH2_FXP_EXTENDED:\n\t\tif (!init_done)\n\t\t\tfatal(\"Received extended request before init\");\n\t\tif ((r = sshbuf_get_u32(iqueue, &id)) != 0)\n\t\t\tfatal_fr(r, \"parse extended ID\");\n\t\tprocess_extended(id);\n\t\tbreak;\n\tdefault:\n\t\tif (!init_done)\n\t\t\tfatal(\"Received %u request before init\", type);\n\t\tif ((r = sshbuf_get_u32(iqueue, &id)) != 0)\n\t\t\tfatal_fr(r, \"parse ID\");\n\t\tfor (i = 0; handlers[i].handler != NULL; i++) {\n\t\t\tif (type == handlers[i].type) {\n\t\t\t\tif (!request_permitted(&handlers[i])) {\n\t\t\t\t\tsend_status(id,\n\t\t\t\t\t    SSH2_FX_PERMISSION_DENIED);\n\t\t\t\t} else {\n\t\t\t\t\thandlers[i].handler(id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (handlers[i].handler == NULL)\n\t\t\terror(\"Unknown message %u\", type);\n\t}\n\t \n\tif (buf_len < sshbuf_len(iqueue)) {\n\t\terror(\"iqueue grew unexpectedly\");\n\t\tsftp_server_cleanup_exit(255);\n\t}\n\tconsumed = buf_len - sshbuf_len(iqueue);\n\tif (msg_len < consumed) {\n\t\terror(\"msg_len %u < consumed %u\", msg_len, consumed);\n\t\tsftp_server_cleanup_exit(255);\n\t}\n\tif (msg_len > consumed &&\n\t    (r = sshbuf_consume(iqueue, msg_len - consumed)) != 0)\n\t\tfatal_fr(r, \"consume\");\n}\n\n \nvoid\nsftp_server_cleanup_exit(int i)\n{\n\tif (pw != NULL && client_addr != NULL) {\n\t\thandle_log_exit();\n\t\tlogit(\"session closed for local user %s from [%s]\",\n\t\t    pw->pw_name, client_addr);\n\t}\n\t_exit(i);\n}\n\nstatic void\nsftp_server_usage(void)\n{\n\textern char *__progname;\n\n\tfprintf(stderr,\n\t    \"usage: %s [-ehR] [-d start_directory] [-f log_facility] \"\n\t    \"[-l log_level]\\n\\t[-P denied_requests] \"\n\t    \"[-p allowed_requests] [-u umask]\\n\"\n\t    \"       %s -Q protocol_feature\\n\",\n\t    __progname, __progname);\n\texit(1);\n}\n\nint\nsftp_server_main(int argc, char **argv, struct passwd *user_pw)\n{\n\tint i, r, in, out, ch, skipargs = 0, log_stderr = 0;\n\tssize_t len, olen;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tchar *cp, *homedir = NULL, uidstr[32], buf[4*4096];\n\tlong mask;\n\n\textern char *optarg;\n\textern char *__progname;\n\n\t__progname = ssh_get_progname(argv[0]);\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\tpw = pwcopy(user_pw);\n\n\twhile (!skipargs && (ch = getopt(argc, argv,\n\t    \"d:f:l:P:p:Q:u:cehR\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'Q':\n\t\t\tif (strcasecmp(optarg, \"requests\") != 0) {\n\t\t\t\tfprintf(stderr, \"Invalid query type\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfor (i = 0; handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", handlers[i].name);\n\t\t\tfor (i = 0; extended_handlers[i].handler != NULL; i++)\n\t\t\t\tprintf(\"%s\\n\", extended_handlers[i].name);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\treadonly = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\t \n\t\t\tskipargs = 1;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tlog_stderr = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlog_level = log_level_number(optarg);\n\t\t\tif (log_level == SYSLOG_LEVEL_NOT_SET)\n\t\t\t\terror(\"Invalid log level \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tlog_facility = log_facility_number(optarg);\n\t\t\tif (log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\t\t\terror(\"Invalid log facility \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tcp = tilde_expand_filename(optarg, user_pw->pw_uid);\n\t\t\tsnprintf(uidstr, sizeof(uidstr), \"%llu\",\n\t\t\t    (unsigned long long)pw->pw_uid);\n\t\t\thomedir = percent_expand(cp, \"d\", user_pw->pw_dir,\n\t\t\t    \"u\", user_pw->pw_name, \"U\", uidstr, (char *)NULL);\n\t\t\tfree(cp);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (request_allowlist != NULL)\n\t\t\t\tfatal(\"Permitted requests already set\");\n\t\t\trequest_allowlist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (request_denylist != NULL)\n\t\t\t\tfatal(\"Refused requests already set\");\n\t\t\trequest_denylist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\terrno = 0;\n\t\t\tmask = strtol(optarg, &cp, 8);\n\t\t\tif (mask < 0 || mask > 0777 || *cp != '\\0' ||\n\t\t\t    cp == optarg || (mask == 0 && errno != 0))\n\t\t\t\tfatal(\"Invalid umask \\\"%s\\\"\", optarg);\n\t\t\t(void)umask((mode_t)mask);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tsftp_server_usage();\n\t\t}\n\t}\n\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\t \n\tplatform_disable_tracing(1);\t \n\n\t \n\tplatform_pledge_sftp_server();\n\n\tif ((cp = getenv(\"SSH_CONNECTION\")) != NULL) {\n\t\tclient_addr = xstrdup(cp);\n\t\tif ((cp = strchr(client_addr, ' ')) == NULL) {\n\t\t\terror(\"Malformed SSH_CONNECTION variable: \\\"%s\\\"\",\n\t\t\t    getenv(\"SSH_CONNECTION\"));\n\t\t\tsftp_server_cleanup_exit(255);\n\t\t}\n\t\t*cp = '\\0';\n\t} else\n\t\tclient_addr = xstrdup(\"UNKNOWN\");\n\n\tlogit(\"session opened for local user %s from [%s]\",\n\t    pw->pw_name, client_addr);\n\n\tin = STDIN_FILENO;\n\tout = STDOUT_FILENO;\n\n#ifdef HAVE_CYGWIN\n\tsetmode(in, O_BINARY);\n\tsetmode(out, O_BINARY);\n#endif\n\n\tif ((iqueue = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tif ((oqueue = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\n\tif (homedir != NULL) {\n\t\tif (chdir(homedir) != 0) {\n\t\t\terror(\"chdir to \\\"%s\\\" failed: %s\", homedir,\n\t\t\t    strerror(errno));\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tstruct pollfd pfd[2];\n\n\t\tmemset(pfd, 0, sizeof pfd);\n\t\tpfd[0].fd = pfd[1].fd = -1;\n\n\t\t \n\t\tif ((r = sshbuf_check_reserve(iqueue, sizeof(buf))) == 0 &&\n\t\t    (r = sshbuf_check_reserve(oqueue,\n\t\t    SFTP_MAX_MSG_LENGTH)) == 0) {\n\t\t\tpfd[0].fd = in;\n\t\t\tpfd[0].events = POLLIN;\n\t\t}\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal_fr(r, \"reserve\");\n\n\t\tolen = sshbuf_len(oqueue);\n\t\tif (olen > 0) {\n\t\t\tpfd[1].fd = out;\n\t\t\tpfd[1].events = POLLOUT;\n\t\t}\n\n\t\tif (poll(pfd, 2, -1) == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"poll: %s\", strerror(errno));\n\t\t\tsftp_server_cleanup_exit(2);\n\t\t}\n\n\t\t \n\t\tif (pfd[0].revents & (POLLIN|POLLHUP)) {\n\t\t\tlen = read(in, buf, sizeof buf);\n\t\t\tif (len == 0) {\n\t\t\t\tdebug(\"read eof\");\n\t\t\t\tsftp_server_cleanup_exit(0);\n\t\t\t} else if (len == -1) {\n\t\t\t\tif (errno != EAGAIN && errno != EINTR) {\n\t\t\t\t\terror(\"read: %s\", strerror(errno));\n\t\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t\t}\n\t\t\t} else if ((r = sshbuf_put(iqueue, buf, len)) != 0)\n\t\t\t\tfatal_fr(r, \"sshbuf_put\");\n\t\t}\n\t\t \n\t\tif (pfd[1].revents & (POLLOUT|POLLHUP)) {\n\t\t\tlen = write(out, sshbuf_ptr(oqueue), olen);\n\t\t\tif (len == 0 || (len == -1 && errno == EPIPE)) {\n\t\t\t\tdebug(\"write eof\");\n\t\t\t\tsftp_server_cleanup_exit(0);\n\t\t\t} else if (len == -1) {\n\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t\tif (errno != EAGAIN && errno != EINTR) {\n\t\t\t\t\terror(\"write: %s\", strerror(errno));\n\t\t\t\t\tsftp_server_cleanup_exit(1);\n\t\t\t\t}\n\t\t\t} else if ((r = sshbuf_consume(oqueue, len)) != 0)\n\t\t\t\tfatal_fr(r, \"consume\");\n\t\t}\n\n\t\t \n\t\tr = sshbuf_check_reserve(oqueue, SFTP_MAX_MSG_LENGTH);\n\t\tif (r == 0)\n\t\t\tprocess();\n\t\telse if (r != SSH_ERR_NO_BUFFER_SPACE)\n\t\t\tfatal_fr(r, \"reserve\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}