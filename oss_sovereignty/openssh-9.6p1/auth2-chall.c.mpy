{
  "module_name": "auth2-chall.c",
  "hash_id": "e9999aa186d05c436e747a9993765944770ab0cdbedecd72cb1fd1b9af79709f",
  "original_prompt": "Ingested from openssh-9.6p1/auth2-chall.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"xmalloc.h\"\n#include \"ssh2.h\"\n#include \"sshkey.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"dispatch.h\"\n#include \"ssherr.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n\n \nextern ServerOptions options;\n\nstatic int auth2_challenge_start(struct ssh *);\nstatic int send_userauth_info_request(struct ssh *);\nstatic int input_userauth_info_response(int, u_int32_t, struct ssh *);\n\n#ifdef BSD_AUTH\nextern KbdintDevice bsdauth_device;\n#else\n#ifdef USE_PAM\nextern KbdintDevice sshpam_device;\n#endif\n#endif\n\nKbdintDevice *devices[] = {\n#ifdef BSD_AUTH\n\t&bsdauth_device,\n#else\n#ifdef USE_PAM\n\t&sshpam_device,\n#endif\n#endif\n\tNULL\n};\n\ntypedef struct KbdintAuthctxt KbdintAuthctxt;\nstruct KbdintAuthctxt\n{\n\tchar *devices;\n\tvoid *ctxt;\n\tKbdintDevice *device;\n\tu_int nreq;\n\tu_int devices_done;\n};\n\n#ifdef USE_PAM\nvoid\nremove_kbdint_device(const char *devname)\n{\n\tint i, j;\n\n\tfor (i = 0; devices[i] != NULL; i++)\n\t\tif (strcmp(devices[i]->name, devname) == 0) {\n\t\t\tfor (j = i; devices[j] != NULL; j++)\n\t\t\t\tdevices[j] = devices[j+1];\n\t\t\ti--;\n\t\t}\n}\n#endif\n\nstatic KbdintAuthctxt *\nkbdint_alloc(const char *devs)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tstruct sshbuf *b;\n\tint i, r;\n\n#ifdef USE_PAM\n\tif (!options.use_pam)\n\t\tremove_kbdint_device(\"pam\");\n#endif\n\n\tkbdintctxt = xcalloc(1, sizeof(KbdintAuthctxt));\n\tif (strcmp(devs, \"\") == 0) {\n\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((r = sshbuf_putf(b, \"%s%s\",\n\t\t\t    sshbuf_len(b) ? \",\" : \"\", devices[i]->name)) != 0)\n\t\t\t\tfatal_fr(r, \"buffer error\");\n\t\t}\n\t\tif ((kbdintctxt->devices = sshbuf_dup_string(b)) == NULL)\n\t\t\tfatal_f(\"sshbuf_dup_string failed\");\n\t\tsshbuf_free(b);\n\t} else {\n\t\tkbdintctxt->devices = xstrdup(devs);\n\t}\n\tdebug(\"kbdint_alloc: devices '%s'\", kbdintctxt->devices);\n\tkbdintctxt->ctxt = NULL;\n\tkbdintctxt->device = NULL;\n\tkbdintctxt->nreq = 0;\n\n\treturn kbdintctxt;\n}\nstatic void\nkbdint_reset_device(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->ctxt) {\n\t\tkbdintctxt->device->free_ctx(kbdintctxt->ctxt);\n\t\tkbdintctxt->ctxt = NULL;\n\t}\n\tkbdintctxt->device = NULL;\n}\nstatic void\nkbdint_free(KbdintAuthctxt *kbdintctxt)\n{\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tfree(kbdintctxt->devices);\n\tfreezero(kbdintctxt, sizeof(*kbdintctxt));\n}\n \nstatic int\nkbdint_next_device(Authctxt *authctxt, KbdintAuthctxt *kbdintctxt)\n{\n\tsize_t len;\n\tchar *t;\n\tint i;\n\n\tif (kbdintctxt->device)\n\t\tkbdint_reset_device(kbdintctxt);\n\tdo {\n\t\tlen = kbdintctxt->devices ?\n\t\t    strcspn(kbdintctxt->devices, \",\") : 0;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; devices[i]; i++) {\n\t\t\tif ((kbdintctxt->devices_done & (1 << i)) != 0 ||\n\t\t\t    !auth2_method_allowed(authctxt,\n\t\t\t    \"keyboard-interactive\", devices[i]->name))\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(kbdintctxt->devices, devices[i]->name,\n\t\t\t    len) == 0) {\n\t\t\t\tkbdintctxt->device = devices[i];\n\t\t\t\tkbdintctxt->devices_done |= 1 << i;\n\t\t\t}\n\t\t}\n\t\tt = kbdintctxt->devices;\n\t\tkbdintctxt->devices = t[len] ? xstrdup(t+len+1) : NULL;\n\t\tfree(t);\n\t\tdebug2(\"kbdint_next_device: devices %s\", kbdintctxt->devices ?\n\t\t    kbdintctxt->devices : \"<empty>\");\n\t} while (kbdintctxt->devices && !kbdintctxt->device);\n\n\treturn kbdintctxt->device ? 1 : 0;\n}\n\n \nint\nauth2_challenge(struct ssh *ssh, char *devs)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tdebug(\"auth2_challenge: user=%s devs=%s\",\n\t    authctxt->user ? authctxt->user : \"<nouser>\",\n\t    devs ? devs : \"<no devs>\");\n\n\tif (authctxt->user == NULL || !devs)\n\t\treturn 0;\n\tif (authctxt->kbdintctxt == NULL)\n\t\tauthctxt->kbdintctxt = kbdint_alloc(devs);\n\treturn auth2_challenge_start(ssh);\n}\n\n \nvoid\nauth2_challenge_stop(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\t \n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE, NULL);\n\tif (authctxt->kbdintctxt != NULL) {\n\t\tkbdint_free(authctxt->kbdintctxt);\n\t\tauthctxt->kbdintctxt = NULL;\n\t}\n}\n\n \nstatic int\nauth2_challenge_start(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt = authctxt->kbdintctxt;\n\n\tdebug2(\"auth2_challenge_start: devices %s\",\n\t    kbdintctxt->devices ?  kbdintctxt->devices : \"<empty>\");\n\n\tif (kbdint_next_device(authctxt, kbdintctxt) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tdebug(\"auth2_challenge_start: trying authentication method '%s'\",\n\t    kbdintctxt->device->name);\n\n\tif ((kbdintctxt->ctxt = kbdintctxt->device->init_ctx(authctxt)) == NULL) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tif (send_userauth_info_request(ssh) == 0) {\n\t\tauth2_challenge_stop(ssh);\n\t\treturn 0;\n\t}\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE,\n\t    &input_userauth_info_response);\n\n\tauthctxt->postponed = 1;\n\treturn 0;\n}\n\nstatic int\nsend_userauth_info_request(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tu_int r, i, *echo_on;\n\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, name)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, instr)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\t \n\t    (r = sshpkt_put_u32(ssh, kbdintctxt->nreq)) != 0)\n\t\tfatal_fr(r, \"start packet\");\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tif ((r = sshpkt_put_cstring(ssh, prompts[i])) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, echo_on[i])) != 0)\n\t\t\tfatal_fr(r, \"assemble packet\");\n\t}\n\tif ((r = sshpkt_send(ssh)) != 0 ||\n\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\tfree(prompts[i]);\n\tfree(prompts);\n\tfree(echo_on);\n\tfree(name);\n\tfree(instr);\n\treturn 1;\n}\n\nstatic int\ninput_userauth_info_response(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tKbdintAuthctxt *kbdintctxt;\n\tint authenticated = 0, res;\n\tint r;\n\tu_int i, nresp;\n\tconst char *devicename = NULL;\n\tchar **response = NULL;\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\"no authctxt\");\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt == NULL || kbdintctxt->ctxt == NULL)\n\t\tfatal_f(\"no kbdintctxt\");\n\tif (kbdintctxt->device == NULL)\n\t\tfatal_f(\"no device\");\n\n\tauthctxt->postponed = 0;\t \n\tif ((r = sshpkt_get_u32(ssh, &nresp)) != 0)\n\t\tfatal_fr(r, \"parse packet\");\n\tif (nresp != kbdintctxt->nreq)\n\t\tfatal_f(\"wrong number of replies\");\n\tif (nresp > 100)\n\t\tfatal_f(\"too many replies\");\n\tif (nresp > 0) {\n\t\tresponse = xcalloc(nresp, sizeof(char *));\n\t\tfor (i = 0; i < nresp; i++) {\n\t\t\tif ((r = sshpkt_get_cstring(ssh, &response[i], NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"parse response\");\n\t\t}\n\t}\n\tif ((r = sshpkt_get_end(ssh)) != 0)\n\t\tfatal_fr(r, \"parse packet\");\n\n\tres = kbdintctxt->device->respond(kbdintctxt->ctxt, nresp, response);\n\n\tfor (i = 0; i < nresp; i++) {\n\t\texplicit_bzero(response[i], strlen(response[i]));\n\t\tfree(response[i]);\n\t}\n\tfree(response);\n\n\tswitch (res) {\n\tcase 0:\n\t\t \n\t\tauthenticated = authctxt->valid ? 1 : 0;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (send_userauth_info_request(ssh) == 1)\n\t\t\tauthctxt->postponed = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tdevicename = kbdintctxt->device->name;\n\tif (!authctxt->postponed) {\n\t\tif (authenticated) {\n\t\t\tauth2_challenge_stop(ssh);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tauth2_challenge_start(ssh);\n\t\t}\n\t}\n\tuserauth_finish(ssh, authenticated, \"keyboard-interactive\",\n\t    devicename);\n\treturn 0;\n}\n\nvoid\nprivsep_challenge_enable(void)\n{\n#if defined(BSD_AUTH) || defined(USE_PAM)\n\tint n = 0;\n#endif\n#ifdef BSD_AUTH\n\textern KbdintDevice mm_bsdauth_device;\n#endif\n#ifdef USE_PAM\n\textern KbdintDevice mm_sshpam_device;\n#endif\n\n#ifdef BSD_AUTH\n\tdevices[n++] = &mm_bsdauth_device;\n#else\n#ifdef USE_PAM\n\tdevices[n++] = &mm_sshpam_device;\n#endif\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}