{
  "module_name": "monitor_fdpass.c",
  "hash_id": "958eb5cdd28dcadb14a48789a03c7a2778072fd80d61deed911f74b4f54e3f69",
  "original_prompt": "Ingested from openssh-9.6p1/monitor_fdpass.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n\n#include <errno.h>\n#include <string.h>\n#include <stdarg.h>\n\n#ifdef HAVE_POLL_H\n# include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n\n#include \"log.h\"\n#include \"monitor_fdpass.h\"\n\nint\nmm_send_fd(int sock, int fd)\n{\n#if defined(HAVE_SENDMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tchar ch = '\\0';\n\tssize_t n;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = (caddr_t)&cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\t*(int *)CMSG_DATA(cmsg) = fd;\n#endif\n\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n\n\tpfd.fd = sock;\n\tpfd.events = POLLOUT;\n\twhile ((n = sendmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3_f(\"sendmsg(%d): %s\", fd, strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror_f(\"sendmsg(%d): %s\", fd, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror_f(\"sendmsg: expected sent 1 got %zd\", n);\n\t\treturn -1;\n\t}\n\treturn 0;\n#else\n\terror(\"%s: file descriptor passing not supported\", __func__);\n\treturn -1;\n#endif\n}\n\nint\nmm_receive_fd(int sock)\n{\n#if defined(HAVE_RECVMSG) && (defined(HAVE_ACCRIGHTS_IN_MSGHDR) || defined(HAVE_CONTROL_IN_MSGHDR))\n\tstruct msghdr msg;\n#ifndef HAVE_ACCRIGHTS_IN_MSGHDR\n\tunion {\n\t\tstruct cmsghdr hdr;\n\t\tchar buf[CMSG_SPACE(sizeof(int))];\n\t} cmsgbuf;\n\tstruct cmsghdr *cmsg;\n#endif\n\tstruct iovec vec;\n\tssize_t n;\n\tchar ch;\n\tint fd;\n\tstruct pollfd pfd;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &ch;\n\tvec.iov_len = 1;\n\tmsg.msg_iov = &vec;\n\tmsg.msg_iovlen = 1;\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tmsg.msg_accrights = (caddr_t)&fd;\n\tmsg.msg_accrightslen = sizeof(fd);\n#else\n\tmemset(&cmsgbuf, 0, sizeof(cmsgbuf));\n\tmsg.msg_control = &cmsgbuf.buf;\n\tmsg.msg_controllen = sizeof(cmsgbuf.buf);\n#endif\n\n\tpfd.fd = sock;\n\tpfd.events = POLLIN;\n\twhile ((n = recvmsg(sock, &msg, 0)) == -1 &&\n\t    (errno == EAGAIN || errno == EINTR)) {\n\t\tdebug3_f(\"recvmsg: %s\", strerror(errno));\n\t\t(void)poll(&pfd, 1, -1);\n\t}\n\tif (n == -1) {\n\t\terror_f(\"recvmsg: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (n != 1) {\n\t\terror_f(\"recvmsg: expected received 1 got %zd\", n);\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_ACCRIGHTS_IN_MSGHDR\n\tif (msg.msg_accrightslen != sizeof(fd)) {\n\t\terror_f(\"no fd\");\n\t\treturn -1;\n\t}\n#else\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (cmsg == NULL) {\n\t\terror_f(\"no message header\");\n\t\treturn -1;\n\t}\n\n#ifndef BROKEN_CMSG_TYPE\n\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\terror_f(\"expected %d got %d\", SCM_RIGHTS, cmsg->cmsg_type);\n\t\treturn -1;\n\t}\n#endif\n\tfd = (*(int *)CMSG_DATA(cmsg));\n#endif\n\treturn fd;\n#else\n\terror_f(\"file descriptor passing not supported\");\n\treturn -1;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}