{
  "module_name": "ssh.c",
  "hash_id": "7ec8963b0c9e34c8b4300de45011fb51c051f3432e51ba5ec3915f170a22208c",
  "original_prompt": "Ingested from openssh-9.6p1/ssh.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#include <sys/resource.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <limits.h>\n#include <locale.h>\n\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#endif\n#include \"openbsd-compat/openssl-compat.h\"\n#include \"openbsd-compat/sys-queue.h\"\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"ssh2.h\"\n#include \"canohost.h\"\n#include \"compat.h\"\n#include \"cipher.h\"\n#include \"packet.h\"\n#include \"sshbuf.h\"\n#include \"channels.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"authfile.h\"\n#include \"pathnames.h\"\n#include \"dispatch.h\"\n#include \"clientloop.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"readconf.h\"\n#include \"sshconnect.h\"\n#include \"kex.h\"\n#include \"mac.h\"\n#include \"sshpty.h\"\n#include \"match.h\"\n#include \"msg.h\"\n#include \"version.h\"\n#include \"ssherr.h\"\n#include \"myproposal.h\"\n#include \"utf8.h\"\n\n#ifdef ENABLE_PKCS11\n#include \"ssh-pkcs11.h\"\n#endif\n\nextern char *__progname;\n\n \n#ifndef HAVE_SETPROCTITLE\nstatic char **saved_av;\n#endif\n\n \nint debug_flag = 0;\n\n \nint tty_flag = 0;\n\n \nstatic int need_controlpersist_detach = 0;\n\n \nstatic int ostdin_null_flag, osession_type, otty_flag, orequest_tty;\nstatic int ofork_after_authentication;\n\n \nOptions options;\n\n \nchar *config = NULL;\n\n \nchar *host;\n\n \nchar *forward_agent_sock_path = NULL;\n\n \nstruct sockaddr_storage hostaddr;\n\n \nSensitive sensitive_data;\n\n \nstruct sshbuf *command;\n\n \nstatic int forward_confirms_pending = -1;\n\n \nextern int muxserver_sock;\nextern u_int muxclient_command;\n\n \n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\"usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address]\\n\"\n\"           [-c cipher_spec] [-D [bind_address:]port] [-E log_file]\\n\"\n\"           [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file]\\n\"\n\"           [-J destination] [-L address] [-l login_name] [-m mac_spec]\\n\"\n\"           [-O ctl_cmd] [-o option] [-P tag] [-p port] [-R address]\\n\"\n\"           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]\\n\"\n\"           destination [command [argument ...]]\\n\"\n\"       ssh [-Q query_option]\\n\"\n\t);\n\texit(255);\n}\n\nstatic int ssh_session2(struct ssh *, const struct ssh_conn_info *);\nstatic void load_public_identity_files(const struct ssh_conn_info *);\nstatic void main_sigchld_handler(int);\n\n \nstatic void\ntilde_expand_paths(char **paths, u_int num_paths)\n{\n\tu_int i;\n\tchar *cp;\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tcp = tilde_expand_filename(paths[i], getuid());\n\t\tfree(paths[i]);\n\t\tpaths[i] = cp;\n\t}\n}\n\n \nstatic char *\ndefault_client_percent_expand(const char *str,\n    const struct ssh_conn_info *cinfo)\n{\n\treturn percent_expand(str,\n\t    DEFAULT_CLIENT_PERCENT_EXPAND_ARGS(cinfo),\n\t    (char *)NULL);\n}\n\n \nstatic char *\ndefault_client_percent_dollar_expand(const char *str,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *ret;\n\n\tret = percent_dollar_expand(str,\n\t    DEFAULT_CLIENT_PERCENT_EXPAND_ARGS(cinfo),\n\t    (char *)NULL);\n\tif (ret == NULL)\n\t\tfatal(\"invalid environment variable expansion\");\n\treturn ret;\n}\n\n \nstatic struct addrinfo *\nresolve_host(const char *name, int port, int logerr, char *cname, size_t clen)\n{\n\tchar strport[NI_MAXSERV];\n\tconst char *errstr = NULL;\n\tstruct addrinfo hints, *res;\n\tint gaierr;\n\tLogLevel loglevel = SYSLOG_LEVEL_DEBUG1;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\tif (cname != NULL)\n\t\t*cname = '\\0';\n\tdebug3_f(\"lookup %s:%d\", name, port);\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\tif (cname != NULL)\n\t\thints.ai_flags = AI_CANONNAME;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tif (logerr || (gaierr != EAI_NONAME && gaierr != EAI_NODATA))\n\t\t\tloglevel = SYSLOG_LEVEL_ERROR;\n\t\tdo_log2(loglevel, \"%s: Could not resolve hostname %.100s: %s\",\n\t\t    __progname, name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (cname != NULL && res->ai_canonname != NULL) {\n\t\tif (!valid_domain(res->ai_canonname, 0, &errstr)) {\n\t\t\terror(\"ignoring bad CNAME \\\"%s\\\" for host \\\"%s\\\": %s\",\n\t\t\t    res->ai_canonname, name, errstr);\n\t\t} else if (strlcpy(cname, res->ai_canonname, clen) >= clen) {\n\t\t\terror_f(\"host \\\"%s\\\" cname \\\"%s\\\" too long (max %lu)\",\n\t\t\t    name,  res->ai_canonname, (u_long)clen);\n\t\t\tif (clen > 0)\n\t\t\t\t*cname = '\\0';\n\t\t}\n\t}\n\treturn res;\n}\n\n \nstatic int\nis_addr_fast(const char *name)\n{\n\treturn (strchr(name, '%') != NULL || strchr(name, ':') != NULL ||\n\t    strspn(name, \"0123456789.\") == strlen(name));\n}\n\n \nstatic int\nis_addr(const char *name)\n{\n\tchar strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\n\tif (is_addr_fast(name))\n\t\treturn 1;\n\n\tsnprintf(strport, sizeof strport, \"%u\", default_ssh_port());\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif (getaddrinfo(name, strport, &hints, &res) != 0)\n\t\treturn 0;\n\tif (res == NULL || res->ai_next != NULL) {\n\t\tfreeaddrinfo(res);\n\t\treturn 0;\n\t}\n\tfreeaddrinfo(res);\n\treturn 1;\n}\n\n \nstatic struct addrinfo *\nresolve_addr(const char *name, int port, char *caddr, size_t clen)\n{\n\tchar addr[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo hints, *res;\n\tint gaierr;\n\n\tif (port <= 0)\n\t\tport = default_ssh_port();\n\tsnprintf(strport, sizeof strport, \"%u\", port);\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = options.address_family == -1 ?\n\t    AF_UNSPEC : options.address_family;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_NUMERICHOST|AI_NUMERICSERV;\n\tif ((gaierr = getaddrinfo(name, strport, &hints, &res)) != 0) {\n\t\tdebug2_f(\"could not resolve name %.100s as address: %s\",\n\t\t    name, ssh_gai_strerror(gaierr));\n\t\treturn NULL;\n\t}\n\tif (res == NULL) {\n\t\tdebug_f(\"getaddrinfo %.100s returned no addresses\", name);\n\t\treturn NULL;\n\t}\n\tif (res->ai_next != NULL) {\n\t\tdebug_f(\"getaddrinfo %.100s returned multiple addresses\", name);\n\t\tgoto fail;\n\t}\n\tif ((gaierr = getnameinfo(res->ai_addr, res->ai_addrlen,\n\t    addr, sizeof(addr), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\tdebug_f(\"Could not format address for name %.100s: %s\",\n\t\t    name, ssh_gai_strerror(gaierr));\n\t\tgoto fail;\n\t}\n\tif (strlcpy(caddr, addr, clen) >= clen) {\n\t\terror_f(\"host \\\"%s\\\" addr \\\"%s\\\" too long (max %lu)\",\n\t\t    name,  addr, (u_long)clen);\n\t\tif (clen > 0)\n\t\t\t*caddr = '\\0';\n fail:\n\t\tfreeaddrinfo(res);\n\t\treturn NULL;\n\t}\n\treturn res;\n}\n\n \nstatic int\ncheck_follow_cname(int direct, char **namep, const char *cname)\n{\n\tint i;\n\tstruct allowed_cname *rule;\n\n\tif (*cname == '\\0' || !config_has_permitted_cnames(&options) ||\n\t    strcmp(*namep, cname) == 0)\n\t\treturn 0;\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn 0;\n\t \n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn 0;\n\tdebug3_f(\"check \\\"%s\\\" CNAME \\\"%s\\\"\", *namep, cname);\n\tfor (i = 0; i < options.num_permitted_cnames; i++) {\n\t\trule = options.permitted_cnames + i;\n\t\tif (match_pattern_list(*namep, rule->source_list, 1) != 1 ||\n\t\t    match_pattern_list(cname, rule->target_list, 1) != 1)\n\t\t\tcontinue;\n\t\tverbose(\"Canonicalized DNS aliased hostname \"\n\t\t    \"\\\"%s\\\" => \\\"%s\\\"\", *namep, cname);\n\t\tfree(*namep);\n\t\t*namep = xstrdup(cname);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic struct addrinfo *\nresolve_canonicalize(char **hostp, int port)\n{\n\tint i, direct, ndots;\n\tchar *cp, *fullhost, newname[NI_MAXHOST];\n\tstruct addrinfo *addrs;\n\n\t \n\tif ((addrs = resolve_addr(*hostp, port,\n\t    newname, sizeof(newname))) != NULL) {\n\t\tdebug2_f(\"hostname %.100s is address\", *hostp);\n\t\tif (strcasecmp(*hostp, newname) != 0) {\n\t\t\tdebug2_f(\"canonicalised address \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    *hostp, newname);\n\t\t\tfree(*hostp);\n\t\t\t*hostp = xstrdup(newname);\n\t\t}\n\t\treturn addrs;\n\t}\n\n\t \n\tif (is_addr_fast(*hostp)) {\n\t\tdebug_f(\"hostname %.100s is an unrecognised address\", *hostp);\n\t\treturn NULL;\n\t}\n\n\tif (options.canonicalize_hostname == SSH_CANONICALISE_NO)\n\t\treturn NULL;\n\n\t \n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    option_clear_or_none(options.jump_host);\n\tif (!direct &&\n\t    options.canonicalize_hostname != SSH_CANONICALISE_ALWAYS)\n\t\treturn NULL;\n\n\t \n\tif ((*hostp)[strlen(*hostp) - 1] == '.') {\n\t\tdebug3_f(\"name is fully qualified\");\n\t\tfullhost = xstrdup(*hostp);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) != NULL)\n\t\t\tgoto found;\n\t\tfree(fullhost);\n\t\tgoto notfound;\n\t}\n\n\t \n\tndots = 0;\n\tfor (cp = *hostp; *cp != '\\0'; cp++) {\n\t\tif (*cp == '.')\n\t\t\tndots++;\n\t}\n\tif (ndots > options.canonicalize_max_dots) {\n\t\tdebug3_f(\"not canonicalizing hostname \\\"%s\\\" (max dots %d)\",\n\t\t    *hostp, options.canonicalize_max_dots);\n\t\treturn NULL;\n\t}\n\t \n\tfor (i = 0; i < options.num_canonical_domains; i++) {\n\t\tif (strcasecmp(options.canonical_domains[i], \"none\") == 0)\n\t\t\tbreak;\n\t\txasprintf(&fullhost, \"%s.%s.\", *hostp,\n\t\t    options.canonical_domains[i]);\n\t\tdebug3_f(\"attempting \\\"%s\\\" => \\\"%s\\\"\", *hostp, fullhost);\n\t\tif ((addrs = resolve_host(fullhost, port, 0,\n\t\t    newname, sizeof(newname))) == NULL) {\n\t\t\tfree(fullhost);\n\t\t\tcontinue;\n\t\t}\n found:\n\t\t \n\t\tfullhost[strlen(fullhost) - 1] = '\\0';\n\t\t \n\t\tif (!check_follow_cname(direct, &fullhost, newname)) {\n\t\t\tdebug(\"Canonicalized hostname \\\"%s\\\" => \\\"%s\\\"\",\n\t\t\t    *hostp, fullhost);\n\t\t}\n\t\tfree(*hostp);\n\t\t*hostp = fullhost;\n\t\treturn addrs;\n\t}\n notfound:\n\tif (!options.canonicalize_fallback_local)\n\t\tfatal(\"%s: Could not resolve host \\\"%s\\\"\", __progname, *hostp);\n\tdebug2_f(\"host %s not found in any suffix\", *hostp);\n\treturn NULL;\n}\n\n \nstatic void\ncheck_load(int r, struct sshkey **k, const char *path, const char *message)\n{\n\tswitch (r) {\n\tcase 0:\n\t\t \n\t\tif (k != NULL && *k != NULL &&\n\t\t    (r = sshkey_check_rsa_length(*k,\n\t\t    options.required_rsa_size)) != 0) {\n\t\t\terror_r(r, \"load %s \\\"%s\\\"\", message, path);\n\t\t\tfree(*k);\n\t\t\t*k = NULL;\n\t\t}\n\t\tbreak;\n\tcase SSH_ERR_INTERNAL_ERROR:\n\tcase SSH_ERR_ALLOC_FAIL:\n\t\tfatal_r(r, \"load %s \\\"%s\\\"\", message, path);\n\tcase SSH_ERR_SYSTEM_ERROR:\n\t\t \n\t\tif (errno == ENOENT)\n\t\t\tbreak;\n\t\t \n\tdefault:\n\t\terror_r(r, \"load %s \\\"%s\\\"\", message, path);\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nprocess_config_files(const char *host_name, struct passwd *pw, int final_pass,\n    int *want_final_pass)\n{\n\tchar buf[PATH_MAX];\n\tint r;\n\n\tif (config != NULL) {\n\t\tif (strcasecmp(config, \"none\") != 0 &&\n\t\t    !read_config_file(config, pw, host, host_name, &options,\n\t\t    SSHCONF_USERCONF | (final_pass ? SSHCONF_FINAL : 0),\n\t\t    want_final_pass))\n\t\t\tfatal(\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\", config, strerror(errno));\n\t} else {\n\t\tr = snprintf(buf, sizeof buf, \"%s/%s\", pw->pw_dir,\n\t\t    _PATH_SSH_USER_CONFFILE);\n\t\tif (r > 0 && (size_t)r < sizeof(buf))\n\t\t\t(void)read_config_file(buf, pw, host, host_name,\n\t\t\t    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |\n\t\t\t    (final_pass ? SSHCONF_FINAL : 0), want_final_pass);\n\n\t\t \n\t\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,\n\t\t    host, host_name, &options,\n\t\t    final_pass ? SSHCONF_FINAL : 0, want_final_pass);\n\t}\n}\n\n \nstatic void\nset_addrinfo_port(struct addrinfo *addrs, int port)\n{\n\tstruct addrinfo *addr;\n\n\tfor (addr = addrs; addr != NULL; addr = addr->ai_next) {\n\t\tswitch (addr->ai_family) {\n\t\tcase AF_INET:\n\t\t\t((struct sockaddr_in *)addr->ai_addr)->\n\t\t\t    sin_port = htons(port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\t((struct sockaddr_in6 *)addr->ai_addr)->\n\t\t\t    sin6_port = htons(port);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nssh_conn_info_free(struct ssh_conn_info *cinfo)\n{\n\tif (cinfo == NULL)\n\t\treturn;\n\tfree(cinfo->conn_hash_hex);\n\tfree(cinfo->shorthost);\n\tfree(cinfo->uidstr);\n\tfree(cinfo->keyalias);\n\tfree(cinfo->thishost);\n\tfree(cinfo->host_arg);\n\tfree(cinfo->portstr);\n\tfree(cinfo->remhost);\n\tfree(cinfo->remuser);\n\tfree(cinfo->homedir);\n\tfree(cinfo->locuser);\n\tfree(cinfo->jmphost);\n\tfree(cinfo);\n}\n\nstatic int\nvalid_hostname(const char *s)\n{\n\tsize_t i;\n\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\"$\\\\;&<>|(){}\", s[i]) != NULL ||\n\t\t    isspace((u_char)s[i]) || iscntrl((u_char)s[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\nvalid_ruser(const char *s)\n{\n\tsize_t i;\n\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\";&<>|(){}\", s[i]) != NULL)\n\t\t\treturn 0;\n\t\t \n\t\tif (isspace((u_char)s[i]) && s[i + 1] == '-')\n\t\t\treturn 0;\n\t\t \n\t\tif (s[i] == '\\\\' && s[i + 1] == '\\0')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint\nmain(int ac, char **av)\n{\n\tstruct ssh *ssh = NULL;\n\tint i, r, opt, exit_status, use_syslog, direct, timeout_ms;\n\tint was_addr, config_test = 0, opt_terminated = 0, want_final_pass = 0;\n\tchar *p, *cp, *line, *argv0, *logfile;\n\tchar cname[NI_MAXHOST], thishost[NI_MAXHOST];\n\tstruct stat st;\n\tstruct passwd *pw;\n\textern int optind, optreset;\n\textern char *optarg;\n\tstruct Forward fwd;\n\tstruct addrinfo *addrs = NULL;\n\tsize_t n, len;\n\tu_int j;\n\tstruct ssh_conn_info *cinfo = NULL;\n\n\t \n\tsanitise_stdfd();\n\n\t \n\tclosefrom(STDERR_FILENO + 1);\n\n\t__progname = ssh_get_progname(av[0]);\n\n#ifndef HAVE_SETPROCTITLE\n\t \n\t \n\tsaved_av = xcalloc(ac + 1, sizeof(*saved_av));\n\tfor (i = 0; i < ac; i++)\n\t\tsaved_av[i] = xstrdup(av[i]);\n\tsaved_av[i] = NULL;\n\tcompat_init_setproctitle(ac, av);\n\tav = saved_av;\n#endif\n\n\tseed_rng();\n\n\t \n\tpw = getpwuid(getuid());\n\tif (!pw) {\n\t\tlogit(\"No user exists for uid %lu\", (u_long)getuid());\n\t\texit(255);\n\t}\n\t \n\tpw = pwcopy(pw);\n\n\t \n\tumask(022 | umask(077));\n\n\tmsetlocale();\n\n\t \n\tinitialize_options(&options);\n\n\t \n\tif ((ssh = ssh_alloc_session_state()) == NULL)\n\t\tfatal(\"Couldn't allocate session state\");\n\tchannel_init_channels(ssh);\n\n\t \n\thost = NULL;\n\tuse_syslog = 0;\n\tlogfile = NULL;\n\targv0 = av[0];\n\n again:\n\twhile ((opt = getopt(ac, av, \"1246ab:c:e:fgi:kl:m:no:p:qstvx\"\n\t    \"AB:CD:E:F:GI:J:KL:MNO:P:Q:R:S:TVw:W:XYy\")) != -1) {  \n\t\tswitch (opt) {\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t \n\t\t\tbreak;\n\t\tcase '4':\n\t\t\toptions.address_family = AF_INET;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\toptions.address_family = AF_INET6;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\toptions.stdin_null = 1;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\toptions.fork_after_authentication = 1;\n\t\t\toptions.stdin_null = 1;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\toptions.forward_x11 = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\toptions.forward_x11 = 1;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tuse_syslog = 1;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tconfig_test = 1;\n\t\t\tbreak;\n\t\tcase 'Y':\n\t\t\toptions.forward_x11 = 1;\n\t\t\toptions.forward_x11_trusted = 1;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\toptions.fwd_opts.gateway_ports = 1;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (options.stdio_forward_host != NULL)\n\t\t\t\tfatal(\"Cannot specify multiplexing \"\n\t\t\t\t    \"command with -W\");\n\t\t\telse if (muxclient_command != 0)\n\t\t\t\tfatal(\"Multiplexing command already specified\");\n\t\t\tif (strcmp(optarg, \"check\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_ALIVE_CHECK;\n\t\t\telse if (strcmp(optarg, \"forward\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_FORWARD;\n\t\t\telse if (strcmp(optarg, \"exit\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_TERMINATE;\n\t\t\telse if (strcmp(optarg, \"stop\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_STOP;\n\t\t\telse if (strcmp(optarg, \"cancel\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_CANCEL_FWD;\n\t\t\telse if (strcmp(optarg, \"proxy\") == 0)\n\t\t\t\tmuxclient_command = SSHMUX_COMMAND_PROXY;\n\t\t\telse\n\t\t\t\tfatal(\"Invalid multiplex command.\");\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (options.tag == NULL)\n\t\t\t\toptions.tag = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tcp = NULL;\n\t\t\tif (strcmp(optarg, \"cipher\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"Ciphers\") == 0)\n\t\t\t\tcp = cipher_alg_list('\\n', 0);\n\t\t\telse if (strcmp(optarg, \"cipher-auth\") == 0)\n\t\t\t\tcp = cipher_alg_list('\\n', 1);\n\t\t\telse if (strcmp(optarg, \"mac\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"MACs\") == 0)\n\t\t\t\tcp = mac_alg_list('\\n');\n\t\t\telse if (strcmp(optarg, \"kex\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"KexAlgorithms\") == 0)\n\t\t\t\tcp = kex_alg_list('\\n');\n\t\t\telse if (strcmp(optarg, \"key\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 0, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-cert\") == 0)\n\t\t\t\tcp = sshkey_alg_list(1, 0, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-plain\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 0, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-ca-sign\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"CASignatureAlgorithms\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 1, '\\n');\n\t\t\telse if (strcmp(optarg, \"key-sig\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"PubkeyAcceptedKeyTypes\") == 0 ||  \n\t\t\t    strcasecmp(optarg, \"PubkeyAcceptedAlgorithms\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"HostKeyAlgorithms\") == 0 ||\n\t\t\t    strcasecmp(optarg, \"HostbasedKeyTypes\") == 0 ||  \n\t\t\t    strcasecmp(optarg, \"HostbasedAcceptedKeyTypes\") == 0 ||  \n\t\t\t    strcasecmp(optarg, \"HostbasedAcceptedAlgorithms\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 0, 1, '\\n');\n\t\t\telse if (strcmp(optarg, \"sig\") == 0)\n\t\t\t\tcp = sshkey_alg_list(0, 1, 1, '\\n');\n\t\t\telse if (strcmp(optarg, \"protocol-version\") == 0)\n\t\t\t\tcp = xstrdup(\"2\");\n\t\t\telse if (strcmp(optarg, \"compression\") == 0) {\n\t\t\t\tcp = xstrdup(compression_alg_list(0));\n\t\t\t\tlen = strlen(cp);\n\t\t\t\tfor (n = 0; n < len; n++)\n\t\t\t\t\tif (cp[n] == ',')\n\t\t\t\t\t\tcp[n] = '\\n';\n\t\t\t} else if (strcmp(optarg, \"help\") == 0) {\n\t\t\t\tcp = xstrdup(\n\t\t\t\t    \"cipher\\ncipher-auth\\ncompression\\nkex\\n\"\n\t\t\t\t    \"key\\nkey-cert\\nkey-plain\\nkey-sig\\nmac\\n\"\n\t\t\t\t    \"protocol-version\\nsig\");\n\t\t\t}\n\t\t\tif (cp == NULL)\n\t\t\t\tfatal(\"Unsupported query \\\"%s\\\"\", optarg);\n\t\t\tprintf(\"%s\\n\", cp);\n\t\t\tfree(cp);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\toptions.forward_agent = 0;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\toptions.forward_agent = 1;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\toptions.gss_deleg_creds = 0;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\toptions.gss_authentication = 1;\n\t\t\toptions.gss_deleg_creds = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tp = tilde_expand_filename(optarg, getuid());\n\t\t\tif (stat(p, &st) == -1)\n\t\t\t\tfprintf(stderr, \"Warning: Identity file %s \"\n\t\t\t\t    \"not accessible: %s.\\n\", p,\n\t\t\t\t    strerror(errno));\n\t\t\telse\n\t\t\t\tadd_identity_file(&options, NULL, p, 1);\n\t\t\tfree(p);\n\t\t\tbreak;\n\t\tcase 'I':\n#ifdef ENABLE_PKCS11\n\t\t\tfree(options.pkcs11_provider);\n\t\t\toptions.pkcs11_provider = xstrdup(optarg);\n#else\n\t\t\tfprintf(stderr, \"no support for PKCS#11.\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tif (options.jump_host != NULL) {\n\t\t\t\tfatal(\"Only a single -J option is permitted \"\n\t\t\t\t    \"(use commas to separate multiple \"\n\t\t\t\t    \"jump hops)\");\n\t\t\t}\n\t\t\tif (options.proxy_command != NULL)\n\t\t\t\tfatal(\"Cannot specify -J with ProxyCommand\");\n\t\t\tif (parse_jump(optarg, &options, 1) == -1)\n\t\t\t\tfatal(\"Invalid -J argument\");\n\t\t\toptions.proxy_command = xstrdup(\"none\");\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (options.request_tty == REQUEST_TTY_YES)\n\t\t\t\toptions.request_tty = REQUEST_TTY_FORCE;\n\t\t\telse\n\t\t\t\toptions.request_tty = REQUEST_TTY_YES;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (debug_flag == 0) {\n\t\t\t\tdebug_flag = 1;\n\t\t\t\toptions.log_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\t} else {\n\t\t\t\tif (options.log_level < SYSLOG_LEVEL_DEBUG3) {\n\t\t\t\t\tdebug_flag++;\n\t\t\t\t\toptions.log_level++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tfprintf(stderr, \"%s, %s\\n\",\n\t\t\t    SSH_RELEASE, SSH_OPENSSL_VERSION);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (options.tun_open == -1)\n\t\t\t\toptions.tun_open = SSH_TUNMODE_DEFAULT;\n\t\t\toptions.tun_local = a2tun(optarg, &options.tun_remote);\n\t\t\tif (options.tun_local == SSH_TUNID_ERR) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad tun device '%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tif (options.stdio_forward_host != NULL)\n\t\t\t\tfatal(\"stdio forward already specified\");\n\t\t\tif (muxclient_command != 0)\n\t\t\t\tfatal(\"Cannot specify stdio forward with -O\");\n\t\t\tif (parse_forward(&fwd, optarg, 1, 0)) {\n\t\t\t\toptions.stdio_forward_host =\n\t\t\t\t    fwd.listen_port == PORT_STREAMLOCAL ?\n\t\t\t\t    fwd.listen_path : fwd.listen_host;\n\t\t\t\toptions.stdio_forward_port = fwd.listen_port;\n\t\t\t\tfree(fwd.connect_host);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad stdio forwarding specification '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\toptions.session_type = SESSION_TYPE_NONE;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\toptions.log_level = SYSLOG_LEVEL_QUIET;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tif (optarg[0] == '^' && optarg[2] == 0 &&\n\t\t\t    (u_char) optarg[1] >= 64 &&\n\t\t\t    (u_char) optarg[1] < 128)\n\t\t\t\toptions.escape_char = (u_char) optarg[1] & 31;\n\t\t\telse if (strlen(optarg) == 1)\n\t\t\t\toptions.escape_char = (u_char) optarg[0];\n\t\t\telse if (strcmp(optarg, \"none\") == 0)\n\t\t\t\toptions.escape_char = SSH_ESCAPECHAR_NONE;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Bad escape character '%s'.\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (!ciphers_valid(*optarg == '+' || *optarg == '^' ?\n\t\t\t    optarg + 1 : optarg)) {\n\t\t\t\tfprintf(stderr, \"Unknown cipher type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tfree(options.ciphers);\n\t\t\toptions.ciphers = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (mac_valid(optarg)) {\n\t\t\t\tfree(options.macs);\n\t\t\t\toptions.macs = xstrdup(optarg);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Unknown mac type '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tif (options.control_master == SSHCTL_MASTER_YES)\n\t\t\t\toptions.control_master = SSHCTL_MASTER_ASK;\n\t\t\telse\n\t\t\t\toptions.control_master = SSHCTL_MASTER_YES;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (options.port == -1) {\n\t\t\t\toptions.port = a2port(optarg);\n\t\t\t\tif (options.port <= 0) {\n\t\t\t\t\tfprintf(stderr, \"Bad port '%s'\\n\",\n\t\t\t\t\t    optarg);\n\t\t\t\t\texit(255);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (options.user == NULL)\n\t\t\t\toptions.user = optarg;\n\t\t\tbreak;\n\n\t\tcase 'L':\n\t\t\tif (parse_forward(&fwd, optarg, 0, 0))\n\t\t\t\tadd_local_forward(&options, &fwd);\n\t\t\telse {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad local forwarding specification '%s'\\n\",\n\t\t\t\t    optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'R':\n\t\t\tif (parse_forward(&fwd, optarg, 0, 1) ||\n\t\t\t    parse_forward(&fwd, optarg, 1, 1)) {\n\t\t\t\tadd_remote_forward(&options, &fwd);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad remote forwarding specification \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tif (parse_forward(&fwd, optarg, 1, 0)) {\n\t\t\t\tadd_local_forward(&options, &fwd);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Bad dynamic forwarding specification \"\n\t\t\t\t    \"'%s'\\n\", optarg);\n\t\t\t\texit(255);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'C':\n#ifdef WITH_ZLIB\n\t\t\toptions.compression = 1;\n#else\n\t\t\terror(\"Compression not supported, disabling.\");\n#endif\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tif (options.session_type != -1 &&\n\t\t\t    options.session_type != SESSION_TYPE_NONE)\n\t\t\t\tfatal(\"Cannot specify -N with -s/SessionType\");\n\t\t\toptions.session_type = SESSION_TYPE_NONE;\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\toptions.request_tty = REQUEST_TTY_NO;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tline = xstrdup(optarg);\n\t\t\tif (process_config_line(&options, pw,\n\t\t\t    host ? host : \"\", host ? host : \"\", line,\n\t\t\t    \"command-line\", 0, NULL, SSHCONF_USERCONF) != 0)\n\t\t\t\texit(255);\n\t\t\tfree(line);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (options.session_type != -1 &&\n\t\t\t    options.session_type != SESSION_TYPE_SUBSYSTEM)\n\t\t\t\tfatal(\"Cannot specify -s with -N/SessionType\");\n\t\t\toptions.session_type = SESSION_TYPE_SUBSYSTEM;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tfree(options.control_path);\n\t\t\toptions.control_path = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\toptions.bind_address = optarg;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toptions.bind_interface = optarg;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tconfig = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\n\tif (optind > 1 && strcmp(av[optind - 1], \"--\") == 0)\n\t\topt_terminated = 1;\n\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && !host) {\n\t\tint tport;\n\t\tchar *tuser;\n\t\tswitch (parse_ssh_uri(*av, &tuser, &host, &tport)) {\n\t\tcase -1:\n\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tif (options.user == NULL) {\n\t\t\t\toptions.user = tuser;\n\t\t\t\ttuser = NULL;\n\t\t\t}\n\t\t\tfree(tuser);\n\t\t\tif (options.port == -1 && tport != -1)\n\t\t\t\toptions.port = tport;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xstrdup(*av);\n\t\t\tcp = strrchr(p, '@');\n\t\t\tif (cp != NULL) {\n\t\t\t\tif (cp == p)\n\t\t\t\t\tusage();\n\t\t\t\tif (options.user == NULL) {\n\t\t\t\t\toptions.user = p;\n\t\t\t\t\tp = NULL;\n\t\t\t\t}\n\t\t\t\t*cp++ = '\\0';\n\t\t\t\thost = xstrdup(cp);\n\t\t\t\tfree(p);\n\t\t\t} else\n\t\t\t\thost = p;\n\t\t\tbreak;\n\t\t}\n\t\tif (ac > 1 && !opt_terminated) {\n\t\t\toptind = optreset = 1;\n\t\t\tgoto again;\n\t\t}\n\t\tac--, av++;\n\t}\n\n\t \n\tif (!host)\n\t\tusage();\n\n\tif (!valid_hostname(host))\n\t\tfatal(\"hostname contains invalid characters\");\n\tif (options.user != NULL && !valid_ruser(options.user))\n\t\tfatal(\"remote username contains invalid characters\");\n\toptions.host_arg = xstrdup(host);\n\n\t \n\tif ((command = sshbuf_new()) == NULL)\n\t\tfatal(\"sshbuf_new failed\");\n\n\t \n\tif (!ac) {\n\t\t \n\t\tif (options.session_type == SESSION_TYPE_SUBSYSTEM) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"You must specify a subsystem to invoke.\\n\");\n\t\t\tusage();\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ac; i++) {\n\t\t\tif ((r = sshbuf_putf(command, \"%s%s\",\n\t\t\t    i ? \" \" : \"\", av[i])) != 0)\n\t\t\t\tfatal_fr(r, \"buffer error\");\n\t\t}\n\t}\n\n\tssh_signal(SIGPIPE, SIG_IGN);  \n\n\t \n\tif (use_syslog && logfile != NULL)\n\t\tfatal(\"Can't specify both -y and -E\");\n\tif (logfile != NULL)\n\t\tlog_redirect_stderr_to(logfile);\n\tlog_init(argv0,\n\t    options.log_level == SYSLOG_LEVEL_NOT_SET ?\n\t    SYSLOG_LEVEL_INFO : options.log_level,\n\t    options.log_facility == SYSLOG_FACILITY_NOT_SET ?\n\t    SYSLOG_FACILITY_USER : options.log_facility,\n\t    !use_syslog);\n\n\tif (debug_flag)\n\t\tlogit(\"%s, %s\", SSH_RELEASE, SSH_OPENSSL_VERSION);\n\n\t \n\tprocess_config_files(options.host_arg, pw, 0, &want_final_pass);\n\tif (want_final_pass)\n\t\tdebug(\"configuration requests final Match pass\");\n\n\t \n\tfill_default_options_for_canonicalization(&options);\n\n\t \n\tif (options.hostname != NULL) {\n\t\t \n\t\tcp = percent_expand(options.hostname,\n\t\t    \"h\", host, (char *)NULL);\n\t\tfree(host);\n\t\thost = cp;\n\t\tfree(options.hostname);\n\t\toptions.hostname = xstrdup(host);\n\t}\n\n\t \n\tif ((was_addr = is_addr(host)) == 0)\n\t\tlowercase(host);\n\n\t \n\tif (options.canonicalize_hostname != SSH_CANONICALISE_NO || was_addr)\n\t\taddrs = resolve_canonicalize(&host, options.port);\n\n\t \n\tdirect = option_clear_or_none(options.proxy_command) &&\n\t    option_clear_or_none(options.jump_host);\n\tif (addrs == NULL && config_has_permitted_cnames(&options) && (direct ||\n\t    options.canonicalize_hostname == SSH_CANONICALISE_ALWAYS)) {\n\t\tif ((addrs = resolve_host(host, options.port,\n\t\t    direct, cname, sizeof(cname))) == NULL) {\n\t\t\t \n\t\t\tif (direct)\n\t\t\t\tcleanup_exit(255);  \n\t\t} else\n\t\t\tcheck_follow_cname(direct, &host, cname);\n\t}\n\n\t \n\tif (options.canonicalize_hostname != 0 && !want_final_pass) {\n\t\tdebug(\"hostname canonicalisation enabled, \"\n\t\t    \"will re-parse configuration\");\n\t\twant_final_pass = 1;\n\t}\n\n\tif (want_final_pass) {\n\t\tdebug(\"re-parsing configuration\");\n\t\tfree(options.hostname);\n\t\toptions.hostname = xstrdup(host);\n\t\tprocess_config_files(options.host_arg, pw, 1, NULL);\n\t\t \n\t\tif (addrs != NULL && options.port > 0)\n\t\t\tset_addrinfo_port(addrs, options.port);\n\t}\n\n\t \n\tif (fill_default_options(&options) != 0)\n\t\tcleanup_exit(255);\n\n\tif (options.user == NULL)\n\t\toptions.user = xstrdup(pw->pw_name);\n\n\t \n\tif (options.jump_host != NULL) {\n\t\tchar port_s[8];\n\t\tconst char *jumpuser = options.jump_user, *sshbin = argv0;\n\t\tint port = options.port, jumpport = options.jump_port;\n\n\t\tif (port <= 0)\n\t\t\tport = default_ssh_port();\n\t\tif (jumpport <= 0)\n\t\t\tjumpport = default_ssh_port();\n\t\tif (jumpuser == NULL)\n\t\t\tjumpuser = options.user;\n\t\tif (strcmp(options.jump_host, host) == 0 && port == jumpport &&\n\t\t    strcmp(options.user, jumpuser) == 0)\n\t\t\tfatal(\"jumphost loop via %s\", options.jump_host);\n\n\t\t \n\t\tif (strchr(argv0, '/') != NULL && access(argv0, X_OK) != 0)\n\t\t\tsshbin = \"ssh\";\n\n\t\t \n\t\tif (options.proxy_command != NULL)\n\t\t\tfatal(\"inconsistent options: ProxyCommand+ProxyJump\");\n\t\t \n\t\toptions.proxy_use_fdpass = 0;\n\t\tsnprintf(port_s, sizeof(port_s), \"%d\", options.jump_port);\n\t\txasprintf(&options.proxy_command,\n\t\t    \"%s%s%s%s%s%s%s%s%s%s%.*s -W '[%%h]:%%p' %s\",\n\t\t    sshbin,\n\t\t     \n\t\t    options.jump_user == NULL ? \"\" : \" -l \",\n\t\t    options.jump_user == NULL ? \"\" : options.jump_user,\n\t\t     \n\t\t    options.jump_port <= 0 ? \"\" : \" -p \",\n\t\t    options.jump_port <= 0 ? \"\" : port_s,\n\t\t     \n\t\t    options.jump_extra == NULL ? \"\" : \" -J \",\n\t\t    options.jump_extra == NULL ? \"\" : options.jump_extra,\n\t\t     \n\t\t    config == NULL ? \"\" : \" -F \",\n\t\t    config == NULL ? \"\" : config,\n\t\t     \n\t\t    debug_flag ? \" -\" : \"\",\n\t\t    debug_flag, \"vvv\",\n\t\t     \n\t\t    options.jump_host);\n\t\tdebug(\"Setting implicit ProxyCommand from ProxyJump: %s\",\n\t\t    options.proxy_command);\n\t}\n\n\tif (options.port == 0)\n\t\toptions.port = default_ssh_port();\n\tchannel_set_af(ssh, options.address_family);\n\n\t \n\tif (options.host_key_alias != NULL)\n\t\tlowercase(options.host_key_alias);\n\tif (options.proxy_command != NULL &&\n\t    strcmp(options.proxy_command, \"-\") == 0 &&\n\t    options.proxy_use_fdpass)\n\t\tfatal(\"ProxyCommand=- and ProxyUseFDPass are incompatible\");\n\tif (options.update_hostkeys == SSH_UPDATE_HOSTKEYS_ASK) {\n\t\tif (options.control_persist && options.control_path != NULL) {\n\t\t\tdebug(\"UpdateHostKeys=ask is incompatible with \"\n\t\t\t    \"ControlPersist; disabling\");\n\t\t\toptions.update_hostkeys = 0;\n\t\t} else if (sshbuf_len(command) != 0 ||\n\t\t    options.remote_command != NULL ||\n\t\t    options.request_tty == REQUEST_TTY_NO) {\n\t\t\tdebug(\"UpdateHostKeys=ask is incompatible with \"\n\t\t\t    \"remote command execution; disabling\");\n\t\t\toptions.update_hostkeys = 0;\n\t\t} else if (options.log_level < SYSLOG_LEVEL_INFO) {\n\t\t\t \n\t\t\toptions.update_hostkeys = 0;\n\t\t}\n\t}\n\tif (options.connection_attempts <= 0)\n\t\tfatal(\"Invalid number of ConnectionAttempts\");\n\n\tif (sshbuf_len(command) != 0 && options.remote_command != NULL)\n\t\tfatal(\"Cannot execute command-line and remote command.\");\n\n\t \n\tif (options.fork_after_authentication && sshbuf_len(command) == 0 &&\n\t    options.remote_command == NULL &&\n\t    options.session_type != SESSION_TYPE_NONE)\n\t\tfatal(\"Cannot fork into background without a command \"\n\t\t    \"to execute.\");\n\n\t \n\tlog_init(argv0, options.log_level, options.log_facility, !use_syslog);\n\tfor (j = 0; j < options.num_log_verbose; j++) {\n\t\tif (strcasecmp(options.log_verbose[j], \"none\") == 0)\n\t\t\tbreak;\n\t\tlog_verbose_add(options.log_verbose[j]);\n\t}\n\n\tif (options.request_tty == REQUEST_TTY_YES ||\n\t    options.request_tty == REQUEST_TTY_FORCE)\n\t\ttty_flag = 1;\n\n\t \n\tif (sshbuf_len(command) == 0 && options.remote_command == NULL)\n\t\ttty_flag = options.request_tty != REQUEST_TTY_NO;\n\n\t \n\tif (options.request_tty == REQUEST_TTY_NO ||\n\t    (muxclient_command && muxclient_command != SSHMUX_COMMAND_PROXY) ||\n\t    options.session_type == SESSION_TYPE_NONE)\n\t\ttty_flag = 0;\n\t \n\tif ((!isatty(fileno(stdin)) || options.stdin_null) &&\n\t    options.request_tty != REQUEST_TTY_FORCE) {\n\t\tif (tty_flag)\n\t\t\tlogit(\"Pseudo-terminal will not be allocated because \"\n\t\t\t    \"stdin is not a terminal.\");\n\t\ttty_flag = 0;\n\t}\n\n\t \n\tcinfo = xcalloc(1, sizeof(*cinfo));\n\tif (gethostname(thishost, sizeof(thishost)) == -1)\n\t\tfatal(\"gethostname: %s\", strerror(errno));\n\tcinfo->thishost = xstrdup(thishost);\n\tthishost[strcspn(thishost, \".\")] = '\\0';\n\tcinfo->shorthost = xstrdup(thishost);\n\txasprintf(&cinfo->portstr, \"%d\", options.port);\n\txasprintf(&cinfo->uidstr, \"%llu\",\n\t    (unsigned long long)pw->pw_uid);\n\tcinfo->keyalias = xstrdup(options.host_key_alias ?\n\t    options.host_key_alias : options.host_arg);\n\tcinfo->host_arg = xstrdup(options.host_arg);\n\tcinfo->remhost = xstrdup(host);\n\tcinfo->remuser = xstrdup(options.user);\n\tcinfo->homedir = xstrdup(pw->pw_dir);\n\tcinfo->locuser = xstrdup(pw->pw_name);\n\tcinfo->jmphost = xstrdup(options.jump_host == NULL ?\n\t    \"\" : options.jump_host);\n\tcinfo->conn_hash_hex = ssh_connection_hash(cinfo->thishost,\n\t    cinfo->remhost, cinfo->portstr, cinfo->remuser, cinfo->jmphost);\n\n\t \n\tif (options.remote_command != NULL) {\n\t\tdebug3(\"expanding RemoteCommand: %s\", options.remote_command);\n\t\tcp = options.remote_command;\n\t\toptions.remote_command = default_client_percent_expand(cp,\n\t\t    cinfo);\n\t\tdebug3(\"expanded RemoteCommand: %s\", options.remote_command);\n\t\tfree(cp);\n\t\tif ((r = sshbuf_put(command, options.remote_command,\n\t\t    strlen(options.remote_command))) != 0)\n\t\t\tfatal_fr(r, \"buffer error\");\n\t}\n\n\tif (options.control_path != NULL) {\n\t\tcp = tilde_expand_filename(options.control_path, getuid());\n\t\tfree(options.control_path);\n\t\toptions.control_path = default_client_percent_dollar_expand(cp,\n\t\t    cinfo);\n\t\tfree(cp);\n\t}\n\n\tif (options.identity_agent != NULL) {\n\t\tp = tilde_expand_filename(options.identity_agent, getuid());\n\t\tcp = default_client_percent_dollar_expand(p, cinfo);\n\t\tfree(p);\n\t\tfree(options.identity_agent);\n\t\toptions.identity_agent = cp;\n\t}\n\n\tif (options.revoked_host_keys != NULL) {\n\t\tp = tilde_expand_filename(options.revoked_host_keys, getuid());\n\t\tcp = default_client_percent_dollar_expand(p, cinfo);\n\t\tfree(p);\n\t\tfree(options.revoked_host_keys);\n\t\toptions.revoked_host_keys = cp;\n\t}\n\n\tif (options.forward_agent_sock_path != NULL) {\n\t\tp = tilde_expand_filename(options.forward_agent_sock_path,\n\t\t    getuid());\n\t\tcp = default_client_percent_dollar_expand(p, cinfo);\n\t\tfree(p);\n\t\tfree(options.forward_agent_sock_path);\n\t\toptions.forward_agent_sock_path = cp;\n\t\tif (stat(options.forward_agent_sock_path, &st) != 0) {\n\t\t\terror(\"Cannot forward agent socket path \\\"%s\\\": %s\",\n\t\t\t    options.forward_agent_sock_path, strerror(errno));\n\t\t\tif (options.exit_on_forward_failure)\n\t\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\n\tif (options.num_system_hostfiles > 0 &&\n\t    strcasecmp(options.system_hostfiles[0], \"none\") == 0) {\n\t\tif (options.num_system_hostfiles > 1)\n\t\t\tfatal(\"Invalid GlobalKnownHostsFiles: \\\"none\\\" \"\n\t\t\t    \"appears with other entries\");\n\t\tfree(options.system_hostfiles[0]);\n\t\toptions.system_hostfiles[0] = NULL;\n\t\toptions.num_system_hostfiles = 0;\n\t}\n\n\tif (options.num_user_hostfiles > 0 &&\n\t    strcasecmp(options.user_hostfiles[0], \"none\") == 0) {\n\t\tif (options.num_user_hostfiles > 1)\n\t\t\tfatal(\"Invalid UserKnownHostsFiles: \\\"none\\\" \"\n\t\t\t    \"appears with other entries\");\n\t\tfree(options.user_hostfiles[0]);\n\t\toptions.user_hostfiles[0] = NULL;\n\t\toptions.num_user_hostfiles = 0;\n\t}\n\tfor (j = 0; j < options.num_user_hostfiles; j++) {\n\t\tif (options.user_hostfiles[j] == NULL)\n\t\t\tcontinue;\n\t\tcp = tilde_expand_filename(options.user_hostfiles[j], getuid());\n\t\tp = default_client_percent_dollar_expand(cp, cinfo);\n\t\tif (strcmp(options.user_hostfiles[j], p) != 0)\n\t\t\tdebug3(\"expanded UserKnownHostsFile '%s' -> \"\n\t\t\t    \"'%s'\", options.user_hostfiles[j], p);\n\t\tfree(options.user_hostfiles[j]);\n\t\tfree(cp);\n\t\toptions.user_hostfiles[j] = p;\n\t}\n\n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tif (options.local_forwards[i].listen_path != NULL) {\n\t\t\tcp = options.local_forwards[i].listen_path;\n\t\t\tp = options.local_forwards[i].listen_path =\n\t\t\t    default_client_percent_expand(cp, cinfo);\n\t\t\tif (strcmp(cp, p) != 0)\n\t\t\t\tdebug3(\"expanded LocalForward listen path \"\n\t\t\t\t    \"'%s' -> '%s'\", cp, p);\n\t\t\tfree(cp);\n\t\t}\n\t\tif (options.local_forwards[i].connect_path != NULL) {\n\t\t\tcp = options.local_forwards[i].connect_path;\n\t\t\tp = options.local_forwards[i].connect_path =\n\t\t\t    default_client_percent_expand(cp, cinfo);\n\t\t\tif (strcmp(cp, p) != 0)\n\t\t\t\tdebug3(\"expanded LocalForward connect path \"\n\t\t\t\t    \"'%s' -> '%s'\", cp, p);\n\t\t\tfree(cp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tif (options.remote_forwards[i].listen_path != NULL) {\n\t\t\tcp = options.remote_forwards[i].listen_path;\n\t\t\tp = options.remote_forwards[i].listen_path =\n\t\t\t    default_client_percent_expand(cp, cinfo);\n\t\t\tif (strcmp(cp, p) != 0)\n\t\t\t\tdebug3(\"expanded RemoteForward listen path \"\n\t\t\t\t    \"'%s' -> '%s'\", cp, p);\n\t\t\tfree(cp);\n\t\t}\n\t\tif (options.remote_forwards[i].connect_path != NULL) {\n\t\t\tcp = options.remote_forwards[i].connect_path;\n\t\t\tp = options.remote_forwards[i].connect_path =\n\t\t\t    default_client_percent_expand(cp, cinfo);\n\t\t\tif (strcmp(cp, p) != 0)\n\t\t\t\tdebug3(\"expanded RemoteForward connect path \"\n\t\t\t\t    \"'%s' -> '%s'\", cp, p);\n\t\t\tfree(cp);\n\t\t}\n\t}\n\n\tif (config_test) {\n\t\tdump_client_config(&options, host);\n\t\texit(0);\n\t}\n\n\t \n\tif (options.sk_provider != NULL && *options.sk_provider == '$' &&\n\t    strlen(options.sk_provider) > 1) {\n\t\tif ((cp = getenv(options.sk_provider + 1)) == NULL) {\n\t\t\tdebug(\"Authenticator provider %s did not resolve; \"\n\t\t\t    \"disabling\", options.sk_provider);\n\t\t\tfree(options.sk_provider);\n\t\t\toptions.sk_provider = NULL;\n\t\t} else {\n\t\t\tdebug2(\"resolved SecurityKeyProvider %s => %s\",\n\t\t\t    options.sk_provider, cp);\n\t\t\tfree(options.sk_provider);\n\t\t\toptions.sk_provider = xstrdup(cp);\n\t\t}\n\t}\n\n\tif (muxclient_command != 0 && options.control_path == NULL)\n\t\tfatal(\"No ControlPath specified for \\\"-O\\\" command\");\n\tif (options.control_path != NULL) {\n\t\tint sock;\n\t\tif ((sock = muxclient(options.control_path)) >= 0) {\n\t\t\tssh_packet_set_connection(ssh, sock, sock);\n\t\t\tssh_packet_set_mux(ssh);\n\t\t\tgoto skip_connect;\n\t\t}\n\t}\n\n\t \n\tif (addrs == NULL && options.proxy_command == NULL) {\n\t\tdebug2(\"resolving \\\"%s\\\" port %d\", host, options.port);\n\t\tif ((addrs = resolve_host(host, options.port, 1,\n\t\t    cname, sizeof(cname))) == NULL)\n\t\t\tcleanup_exit(255);  \n\t}\n\n\tif (options.connection_timeout >= INT_MAX/1000)\n\t\ttimeout_ms = INT_MAX;\n\telse\n\t\ttimeout_ms = options.connection_timeout * 1000;\n\n\t \n\tchannel_clear_timeouts(ssh);\n\tfor (j = 0; j < options.num_channel_timeouts; j++) {\n\t\tdebug3(\"applying channel timeout %s\",\n\t\t    options.channel_timeouts[j]);\n\t\tif (parse_pattern_interval(options.channel_timeouts[j],\n\t\t    &cp, &i) != 0) {\n\t\t\tfatal_f(\"internal error: bad timeout %s\",\n\t\t\t    options.channel_timeouts[j]);\n\t\t}\n\t\tchannel_add_timeout(ssh, cp, i);\n\t\tfree(cp);\n\t}\n\n\t \n\tif (ssh_connect(ssh, host, options.host_arg, addrs, &hostaddr,\n\t    options.port, options.connection_attempts,\n\t    &timeout_ms, options.tcp_keep_alive) != 0)\n\t\texit(255);\n\n\tif (addrs != NULL)\n\t\tfreeaddrinfo(addrs);\n\n\tssh_packet_set_timeout(ssh, options.server_alive_interval,\n\t    options.server_alive_count_max);\n\n\tif (timeout_ms > 0)\n\t\tdebug3(\"timeout: %d ms remain after connect\", timeout_ms);\n\n\t \n\tsensitive_data.nkeys = 0;\n\tsensitive_data.keys = NULL;\n\tif (options.hostbased_authentication) {\n\t\tint loaded = 0;\n\n\t\tsensitive_data.nkeys = 10;\n\t\tsensitive_data.keys = xcalloc(sensitive_data.nkeys,\n\t\t    sizeof(*sensitive_data.keys));\n\n\t\t \n#define L_PUBKEY(p,o) do { \\\n\tif ((o) >= sensitive_data.nkeys) \\\n\t\tfatal_f(\"pubkey out of array bounds\"); \\\n\tcheck_load(sshkey_load_public(p, &(sensitive_data.keys[o]), NULL), \\\n\t    &(sensitive_data.keys[o]), p, \"pubkey\"); \\\n\tif (sensitive_data.keys[o] != NULL) { \\\n\t\tdebug2(\"hostbased key %d: %s key from \\\"%s\\\"\", o, \\\n\t\t    sshkey_ssh_name(sensitive_data.keys[o]), p); \\\n\t\tloaded++; \\\n\t} \\\n} while (0)\n#define L_CERT(p,o) do { \\\n\tif ((o) >= sensitive_data.nkeys) \\\n\t\tfatal_f(\"cert out of array bounds\"); \\\n\tcheck_load(sshkey_load_cert(p, &(sensitive_data.keys[o])), \\\n\t    &(sensitive_data.keys[o]), p, \"cert\"); \\\n\tif (sensitive_data.keys[o] != NULL) { \\\n\t\tdebug2(\"hostbased key %d: %s cert from \\\"%s\\\"\", o, \\\n\t\t    sshkey_ssh_name(sensitive_data.keys[o]), p); \\\n\t\tloaded++; \\\n\t} \\\n} while (0)\n\n\t\tif (options.hostbased_authentication == 1) {\n\t\t\tL_CERT(_PATH_HOST_ECDSA_KEY_FILE, 0);\n\t\t\tL_CERT(_PATH_HOST_ED25519_KEY_FILE, 1);\n\t\t\tL_CERT(_PATH_HOST_RSA_KEY_FILE, 2);\n\t\t\tL_CERT(_PATH_HOST_DSA_KEY_FILE, 3);\n\t\t\tL_PUBKEY(_PATH_HOST_ECDSA_KEY_FILE, 4);\n\t\t\tL_PUBKEY(_PATH_HOST_ED25519_KEY_FILE, 5);\n\t\t\tL_PUBKEY(_PATH_HOST_RSA_KEY_FILE, 6);\n\t\t\tL_PUBKEY(_PATH_HOST_DSA_KEY_FILE, 7);\n\t\t\tL_CERT(_PATH_HOST_XMSS_KEY_FILE, 8);\n\t\t\tL_PUBKEY(_PATH_HOST_XMSS_KEY_FILE, 9);\n\t\t\tif (loaded == 0)\n\t\t\t\tdebug(\"HostbasedAuthentication enabled but no \"\n\t\t\t\t   \"local public host keys could be loaded.\");\n\t\t}\n\t}\n\n\t \n\tload_public_identity_files(cinfo);\n\n\t \n\tif (options.identity_agent &&\n\t    strcmp(options.identity_agent, SSH_AUTHSOCKET_ENV_NAME) != 0) {\n\t\tif (strcmp(options.identity_agent, \"none\") == 0) {\n\t\t\tunsetenv(SSH_AUTHSOCKET_ENV_NAME);\n\t\t} else {\n\t\t\tcp = options.identity_agent;\n\t\t\t \n\t\t\tif (cp[0] == '$' && cp[1] != '{') {\n\t\t\t\tif (!valid_env_name(cp + 1)) {\n\t\t\t\t\tfatal(\"Invalid IdentityAgent \"\n\t\t\t\t\t    \"environment variable name %s\", cp);\n\t\t\t\t}\n\t\t\t\tif ((p = getenv(cp + 1)) == NULL)\n\t\t\t\t\tunsetenv(SSH_AUTHSOCKET_ENV_NAME);\n\t\t\t\telse\n\t\t\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME, p, 1);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsetenv(SSH_AUTHSOCKET_ENV_NAME, cp, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (options.forward_agent && options.forward_agent_sock_path != NULL) {\n\t\tcp = options.forward_agent_sock_path;\n\t\tif (cp[0] == '$') {\n\t\t\tif (!valid_env_name(cp + 1)) {\n\t\t\t\tfatal(\"Invalid ForwardAgent environment variable name %s\", cp);\n\t\t\t}\n\t\t\tif ((p = getenv(cp + 1)) != NULL)\n\t\t\t\tforward_agent_sock_path = xstrdup(p);\n\t\t\telse\n\t\t\t\toptions.forward_agent = 0;\n\t\t\tfree(cp);\n\t\t} else {\n\t\t\tforward_agent_sock_path = cp;\n\t\t}\n\t}\n\n\t \n\ttilde_expand_paths(options.system_hostfiles,\n\t    options.num_system_hostfiles);\n\ttilde_expand_paths(options.user_hostfiles, options.num_user_hostfiles);\n\n\tssh_signal(SIGCHLD, main_sigchld_handler);\n\n\t \n\tssh_login(ssh, &sensitive_data, host, (struct sockaddr *)&hostaddr,\n\t    options.port, pw, timeout_ms, cinfo);\n\n\t \n\tif (sensitive_data.nkeys != 0) {\n\t\tfor (i = 0; i < sensitive_data.nkeys; i++) {\n\t\t\tif (sensitive_data.keys[i] != NULL) {\n\t\t\t\t \n\t\t\t\tdebug3(\"clear hostkey %d\", i);\n\t\t\t\tsshkey_free(sensitive_data.keys[i]);\n\t\t\t\tsensitive_data.keys[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(sensitive_data.keys);\n\t}\n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tfree(options.identity_files[i]);\n\t\toptions.identity_files[i] = NULL;\n\t\tif (options.identity_keys[i]) {\n\t\t\tsshkey_free(options.identity_keys[i]);\n\t\t\toptions.identity_keys[i] = NULL;\n\t\t}\n\t}\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t}\n\n#ifdef ENABLE_PKCS11\n\t(void)pkcs11_del_provider(options.pkcs11_provider);\n#endif\n\n skip_connect:\n\texit_status = ssh_session2(ssh, cinfo);\n\tssh_conn_info_free(cinfo);\n\tssh_packet_close(ssh);\n\n\tif (options.control_path != NULL && muxserver_sock != -1)\n\t\tunlink(options.control_path);\n\n\t \n\tssh_kill_proxy_command();\n\n\treturn exit_status;\n}\n\nstatic void\ncontrol_persist_detach(void)\n{\n\tpid_t pid;\n\n\tdebug_f(\"backgrounding master process\");\n\n\t \n\tswitch ((pid = fork())) {\n\tcase -1:\n\t\tfatal_f(\"fork: %s\", strerror(errno));\n\tcase 0:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdebug2_f(\"background process is %ld\", (long)pid);\n\t\toptions.stdin_null = ostdin_null_flag;\n\t\toptions.request_tty = orequest_tty;\n\t\ttty_flag = otty_flag;\n\t\toptions.fork_after_authentication = ofork_after_authentication;\n\t\toptions.session_type = osession_type;\n\t\tclose(muxserver_sock);\n\t\tmuxserver_sock = -1;\n\t\toptions.control_master = SSHCTL_MASTER_NO;\n\t\t(void)muxclient(options.control_path);\n\t\t \n\t\tfatal(\"Failed to connect to new control master\");\n\t}\n\tif (stdfd_devnull(1, 1, !(log_is_on_stderr() && debug_flag)) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\tdaemon(1, 1);\n\tsetproctitle(\"%s [mux]\", options.control_path);\n}\n\n \nstatic void\nfork_postauth(void)\n{\n\tif (need_controlpersist_detach)\n\t\tcontrol_persist_detach();\n\tdebug(\"forking to background\");\n\toptions.fork_after_authentication = 0;\n\tif (daemon(1, 1) == -1)\n\t\tfatal(\"daemon() failed: %.200s\", strerror(errno));\n\tif (stdfd_devnull(1, 1, !(log_is_on_stderr() && debug_flag)) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n}\n\nstatic void\nforwarding_success(void)\n{\n\tif (forward_confirms_pending == -1)\n\t\treturn;\n\tif (--forward_confirms_pending == 0) {\n\t\tdebug_f(\"all expected forwarding replies received\");\n\t\tif (options.fork_after_authentication)\n\t\t\tfork_postauth();\n\t} else {\n\t\tdebug2_f(\"%d expected forwarding replies remaining\",\n\t\t    forward_confirms_pending);\n\t}\n}\n\n \nstatic void\nssh_confirm_remote_forward(struct ssh *ssh, int type, u_int32_t seq, void *ctxt)\n{\n\tstruct Forward *rfwd = (struct Forward *)ctxt;\n\tu_int port;\n\tint r;\n\n\t \n\tdebug(\"remote forward %s for: listen %s%s%d, connect %s:%d\",\n\t    type == SSH2_MSG_REQUEST_SUCCESS ? \"success\" : \"failure\",\n\t    rfwd->listen_path ? rfwd->listen_path :\n\t    rfwd->listen_host ? rfwd->listen_host : \"\",\n\t    (rfwd->listen_path || rfwd->listen_host) ? \":\" : \"\",\n\t    rfwd->listen_port, rfwd->connect_path ? rfwd->connect_path :\n\t    rfwd->connect_host, rfwd->connect_port);\n\tif (rfwd->listen_path == NULL && rfwd->listen_port == 0) {\n\t\tif (type == SSH2_MSG_REQUEST_SUCCESS) {\n\t\t\tif ((r = sshpkt_get_u32(ssh, &port)) != 0)\n\t\t\t\tfatal_fr(r, \"parse packet\");\n\t\t\tif (port > 65535) {\n\t\t\t\terror(\"Invalid allocated port %u for remote \"\n\t\t\t\t    \"forward to %s:%d\", port,\n\t\t\t\t    rfwd->connect_host, rfwd->connect_port);\n\t\t\t\t \n\t\t\t\ttype = SSH2_MSG_REQUEST_FAILURE;\n\t\t\t\tchannel_update_permission(ssh,\n\t\t\t\t    rfwd->handle, -1);\n\t\t\t} else {\n\t\t\t\trfwd->allocated_port = (int)port;\n\t\t\t\tlogit(\"Allocated port %u for remote \"\n\t\t\t\t    \"forward to %s:%d\",\n\t\t\t\t    rfwd->allocated_port, rfwd->connect_path ?\n\t\t\t\t    rfwd->connect_path : rfwd->connect_host,\n\t\t\t\t    rfwd->connect_port);\n\t\t\t\tchannel_update_permission(ssh,\n\t\t\t\t    rfwd->handle, rfwd->allocated_port);\n\t\t\t}\n\t\t} else {\n\t\t\tchannel_update_permission(ssh, rfwd->handle, -1);\n\t\t}\n\t}\n\n\tif (type == SSH2_MSG_REQUEST_FAILURE) {\n\t\tif (options.exit_on_forward_failure) {\n\t\t\tif (rfwd->listen_path != NULL)\n\t\t\t\tfatal(\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen path %s\", rfwd->listen_path);\n\t\t\telse\n\t\t\t\tfatal(\"Error: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\", rfwd->listen_port);\n\t\t} else {\n\t\t\tif (rfwd->listen_path != NULL)\n\t\t\t\tlogit(\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen path %s\", rfwd->listen_path);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: remote port forwarding failed \"\n\t\t\t\t    \"for listen port %d\", rfwd->listen_port);\n\t\t}\n\t}\n\tforwarding_success();\n}\n\nstatic void\nclient_cleanup_stdio_fwd(struct ssh *ssh, int id, int force, void *arg)\n{\n\tdebug(\"stdio forwarding: done\");\n\tcleanup_exit(0);\n}\n\nstatic void\nssh_stdio_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tif (!success)\n\t\tfatal(\"stdio forwarding failed\");\n}\n\nstatic void\nssh_tun_confirm(struct ssh *ssh, int id, int success, void *arg)\n{\n\tif (!success) {\n\t\terror(\"Tunnel forwarding failed\");\n\t\tif (options.exit_on_forward_failure)\n\t\t\tcleanup_exit(255);\n\t}\n\n\tdebug_f(\"tunnel forward established, id=%d\", id);\n\tforwarding_success();\n}\n\nstatic void\nssh_init_stdio_forwarding(struct ssh *ssh)\n{\n\tChannel *c;\n\tint in, out;\n\n\tif (options.stdio_forward_host == NULL)\n\t\treturn;\n\n\tdebug3_f(\"%s:%d\", options.stdio_forward_host,\n\t    options.stdio_forward_port);\n\n\tif ((in = dup(STDIN_FILENO)) == -1 ||\n\t    (out = dup(STDOUT_FILENO)) == -1)\n\t\tfatal_f(\"dup() in/out failed\");\n\tif ((c = channel_connect_stdio_fwd(ssh, options.stdio_forward_host,\n\t    options.stdio_forward_port, in, out,\n\t    CHANNEL_NONBLOCK_STDIO)) == NULL)\n\t\tfatal_f(\"channel_connect_stdio_fwd failed\");\n\tchannel_register_cleanup(ssh, c->self, client_cleanup_stdio_fwd, 0);\n\tchannel_register_open_confirm(ssh, c->self, ssh_stdio_confirm, NULL);\n}\n\nstatic void\nssh_init_forward_permissions(struct ssh *ssh, const char *what, char **opens,\n    u_int num_opens)\n{\n\tu_int i;\n\tint port;\n\tchar *addr, *arg, *oarg;\n\tint where = FORWARD_LOCAL;\n\n\tchannel_clear_permission(ssh, FORWARD_ADM, where);\n\tif (num_opens == 0)\n\t\treturn;  \n\n\t \n\tif (num_opens == 1 && strcmp(opens[0], \"any\") == 0)\n\t\treturn;\n\tif (num_opens == 1 && strcmp(opens[0], \"none\") == 0) {\n\t\tchannel_disable_admin(ssh, where);\n\t\treturn;\n\t}\n\t \n\tfor (i = 0; i < num_opens; i++) {\n\t\toarg = arg = xstrdup(opens[i]);\n\t\taddr = hpdelim(&arg);\n\t\tif (addr == NULL)\n\t\t\tfatal_f(\"missing host in %s\", what);\n\t\taddr = cleanhostname(addr);\n\t\tif (arg == NULL || ((port = permitopen_port(arg)) < 0))\n\t\t\tfatal_f(\"bad port number in %s\", what);\n\t\t \n\t\tchannel_add_permission(ssh, FORWARD_ADM,\n\t\t    where, addr, port);\n\t\tfree(oarg);\n\t}\n}\n\nstatic void\nssh_init_forwarding(struct ssh *ssh, char **ifname)\n{\n\tint success = 0;\n\tint i;\n\n\tssh_init_forward_permissions(ssh, \"permitremoteopen\",\n\t    options.permitted_remote_opens,\n\t    options.num_permitted_remote_opens);\n\n\tif (options.exit_on_forward_failure)\n\t\tforward_confirms_pending = 0;  \n\t \n\tfor (i = 0; i < options.num_local_forwards; i++) {\n\t\tdebug(\"Local connections to %.200s:%d forwarded to remote \"\n\t\t    \"address %.200s:%d\",\n\t\t    (options.local_forwards[i].listen_path != NULL) ?\n\t\t    options.local_forwards[i].listen_path :\n\t\t    (options.local_forwards[i].listen_host == NULL) ?\n\t\t    (options.fwd_opts.gateway_ports ? \"*\" : \"LOCALHOST\") :\n\t\t    options.local_forwards[i].listen_host,\n\t\t    options.local_forwards[i].listen_port,\n\t\t    (options.local_forwards[i].connect_path != NULL) ?\n\t\t    options.local_forwards[i].connect_path :\n\t\t    options.local_forwards[i].connect_host,\n\t\t    options.local_forwards[i].connect_port);\n\t\tsuccess += channel_setup_local_fwd_listener(ssh,\n\t\t    &options.local_forwards[i], &options.fwd_opts);\n\t}\n\tif (i > 0 && success != i && options.exit_on_forward_failure)\n\t\tfatal(\"Could not request local forwarding.\");\n\tif (i > 0 && success == 0)\n\t\terror(\"Could not request local forwarding.\");\n\n\t \n\tfor (i = 0; i < options.num_remote_forwards; i++) {\n\t\tdebug(\"Remote connections from %.200s:%d forwarded to \"\n\t\t    \"local address %.200s:%d\",\n\t\t    (options.remote_forwards[i].listen_path != NULL) ?\n\t\t    options.remote_forwards[i].listen_path :\n\t\t    (options.remote_forwards[i].listen_host == NULL) ?\n\t\t    \"LOCALHOST\" : options.remote_forwards[i].listen_host,\n\t\t    options.remote_forwards[i].listen_port,\n\t\t    (options.remote_forwards[i].connect_path != NULL) ?\n\t\t    options.remote_forwards[i].connect_path :\n\t\t    options.remote_forwards[i].connect_host,\n\t\t    options.remote_forwards[i].connect_port);\n\t\tif ((options.remote_forwards[i].handle =\n\t\t    channel_request_remote_forwarding(ssh,\n\t\t    &options.remote_forwards[i])) >= 0) {\n\t\t\tclient_register_global_confirm(\n\t\t\t    ssh_confirm_remote_forward,\n\t\t\t    &options.remote_forwards[i]);\n\t\t\tforward_confirms_pending++;\n\t\t} else if (options.exit_on_forward_failure)\n\t\t\tfatal(\"Could not request remote forwarding.\");\n\t\telse\n\t\t\tlogit(\"Warning: Could not request remote forwarding.\");\n\t}\n\n\t \n\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\tif ((*ifname = client_request_tun_fwd(ssh,\n\t\t    options.tun_open, options.tun_local,\n\t\t    options.tun_remote, ssh_tun_confirm, NULL)) != NULL)\n\t\t\tforward_confirms_pending++;\n\t\telse if (options.exit_on_forward_failure)\n\t\t\tfatal(\"Could not request tunnel forwarding.\");\n\t\telse\n\t\t\terror(\"Could not request tunnel forwarding.\");\n\t}\n\tif (forward_confirms_pending > 0) {\n\t\tdebug_f(\"expecting replies for %d forwards\",\n\t\t    forward_confirms_pending);\n\t}\n}\n\nstatic void\ncheck_agent_present(void)\n{\n\tint r;\n\n\tif (options.forward_agent) {\n\t\t \n\t\tif ((r = ssh_get_authentication_socket(NULL)) != 0) {\n\t\t\toptions.forward_agent = 0;\n\t\t\tif (r != SSH_ERR_AGENT_NOT_PRESENT)\n\t\t\t\tdebug_r(r, \"ssh_get_authentication_socket\");\n\t\t}\n\t}\n}\n\nstatic void\nssh_session2_setup(struct ssh *ssh, int id, int success, void *arg)\n{\n\textern char **environ;\n\tconst char *display, *term;\n\tint r, interactive = tty_flag;\n\tchar *proto = NULL, *data = NULL;\n\n\tif (!success)\n\t\treturn;  \n\n\tdisplay = getenv(\"DISPLAY\");\n\tif (display == NULL && options.forward_x11)\n\t\tdebug(\"X11 forwarding requested but DISPLAY not set\");\n\tif (options.forward_x11 && client_x11_get_proto(ssh, display,\n\t    options.xauth_location, options.forward_x11_trusted,\n\t    options.forward_x11_timeout, &proto, &data) == 0) {\n\t\t \n\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t    \"spoofing.\");\n\t\tx11_request_forwarding_with_spoofing(ssh, id, display, proto,\n\t\t    data, 1);\n\t\tclient_expect_confirm(ssh, id, \"X11 forwarding\", CONFIRM_WARN);\n\t\t \n\t\tinteractive = 1;\n\t}\n\n\tcheck_agent_present();\n\tif (options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tchannel_request_start(ssh, id, \"auth-agent-req@openssh.com\", 0);\n\t\tif ((r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send packet\");\n\t}\n\n\t \n\tssh_packet_set_interactive(ssh, interactive,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\tif ((term = lookup_env_in_list(\"TERM\", options.setenv,\n\t    options.num_setenv)) == NULL || *term == '\\0')\n\t\tterm = getenv(\"TERM\");\n\tclient_session2_setup(ssh, id, tty_flag,\n\t    options.session_type == SESSION_TYPE_SUBSYSTEM, term,\n\t    NULL, fileno(stdin), command, environ);\n}\n\n \nstatic int\nssh_session2_open(struct ssh *ssh)\n{\n\tChannel *c;\n\tint window, packetmax, in, out, err;\n\n\tif (options.stdin_null) {\n\t\tin = open(_PATH_DEVNULL, O_RDONLY);\n\t} else {\n\t\tin = dup(STDIN_FILENO);\n\t}\n\tout = dup(STDOUT_FILENO);\n\terr = dup(STDERR_FILENO);\n\n\tif (in == -1 || out == -1 || err == -1)\n\t\tfatal(\"dup() in/out/err failed\");\n\n\twindow = CHAN_SES_WINDOW_DEFAULT;\n\tpacketmax = CHAN_SES_PACKET_DEFAULT;\n\tif (tty_flag) {\n\t\twindow >>= 1;\n\t\tpacketmax >>= 1;\n\t}\n\tc = channel_new(ssh,\n\t    \"session\", SSH_CHANNEL_OPENING, in, out, err,\n\t    window, packetmax, CHAN_EXTENDED_WRITE,\n\t    \"client-session\", CHANNEL_NONBLOCK_STDIO);\n\n\tdebug3_f(\"channel_new: %d\", c->self);\n\n\tchannel_send_open(ssh, c->self);\n\tif (options.session_type != SESSION_TYPE_NONE)\n\t\tchannel_register_open_confirm(ssh, c->self,\n\t\t    ssh_session2_setup, NULL);\n\n\treturn c->self;\n}\n\nstatic int\nssh_session2(struct ssh *ssh, const struct ssh_conn_info *cinfo)\n{\n\tint r, interactive, id = -1;\n\tchar *cp, *tun_fwd_ifname = NULL;\n\n\t \n\tif (!options.control_persist)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tssh_init_forwarding(ssh, &tun_fwd_ifname);\n\n\tif (options.local_command != NULL) {\n\t\tdebug3(\"expanding LocalCommand: %s\", options.local_command);\n\t\tcp = options.local_command;\n\t\toptions.local_command = percent_expand(cp,\n\t\t    DEFAULT_CLIENT_PERCENT_EXPAND_ARGS(cinfo),\n\t\t    \"T\", tun_fwd_ifname == NULL ? \"NONE\" : tun_fwd_ifname,\n\t\t    (char *)NULL);\n\t\tdebug3(\"expanded LocalCommand: %s\", options.local_command);\n\t\tfree(cp);\n\t}\n\n\t \n\tif (!ssh_packet_get_mux(ssh))\n\t\tmuxserver_listen(ssh);\n\n\t \n\tif (options.control_persist && muxserver_sock != -1) {\n\t\tostdin_null_flag = options.stdin_null;\n\t\tosession_type = options.session_type;\n\t\torequest_tty = options.request_tty;\n\t\totty_flag = tty_flag;\n\t\tofork_after_authentication = options.fork_after_authentication;\n\t\toptions.stdin_null = 1;\n\t\toptions.session_type = SESSION_TYPE_NONE;\n\t\ttty_flag = 0;\n\t\tif ((osession_type != SESSION_TYPE_NONE ||\n\t\t    options.stdio_forward_host != NULL))\n\t\t\tneed_controlpersist_detach = 1;\n\t\toptions.fork_after_authentication = 1;\n\t}\n\t \n\tif (options.control_persist && muxserver_sock == -1)\n\t\tssh_init_stdio_forwarding(ssh);\n\n\tif (options.session_type != SESSION_TYPE_NONE)\n\t\tid = ssh_session2_open(ssh);\n\telse {\n\t\tinteractive = options.control_master == SSHCTL_MASTER_NO;\n\t\t \n\t\tif (need_controlpersist_detach)\n\t\t\tinteractive = otty_flag != 0;\n\t\tssh_packet_set_interactive(ssh, interactive,\n\t\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\t}\n\n\t \n\tif (options.control_master == SSHCTL_MASTER_NO &&\n\t    (ssh->compat & SSH_NEW_OPENSSH)) {\n\t\tdebug(\"Requesting no-more-sessions@openssh.com\");\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_GLOBAL_REQUEST)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh,\n\t\t    \"no-more-sessions@openssh.com\")) != 0 ||\n\t\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send packet\");\n\t}\n\n\t \n\tif (options.local_command != NULL &&\n\t    options.permit_local_command)\n\t\tssh_local_cmd(options.local_command);\n\n\t \n\tif (!need_controlpersist_detach && stdfd_devnull(0, 1, 0) == -1)\n\t\terror_f(\"stdfd_devnull failed\");\n\n\t \n\tif (options.fork_after_authentication) {\n\t\tif (options.exit_on_forward_failure &&\n\t\t    options.num_remote_forwards > 0) {\n\t\t\tdebug(\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\");\n\t\t} else\n\t\t\tfork_postauth();\n\t}\n\n\treturn client_loop(ssh, tty_flag, tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE, id);\n}\n\n \nstatic void\nload_public_identity_files(const struct ssh_conn_info *cinfo)\n{\n\tchar *filename, *cp;\n\tstruct sshkey *public;\n\tint i;\n\tu_int n_ids, n_certs;\n\tchar *identity_files[SSH_MAX_IDENTITY_FILES];\n\tstruct sshkey *identity_keys[SSH_MAX_IDENTITY_FILES];\n\tint identity_file_userprovided[SSH_MAX_IDENTITY_FILES];\n\tchar *certificate_files[SSH_MAX_CERTIFICATE_FILES];\n\tstruct sshkey *certificates[SSH_MAX_CERTIFICATE_FILES];\n\tint certificate_file_userprovided[SSH_MAX_CERTIFICATE_FILES];\n#ifdef ENABLE_PKCS11\n\tstruct sshkey **keys = NULL;\n\tchar **comments = NULL;\n\tint nkeys;\n#endif  \n\n\tn_ids = n_certs = 0;\n\tmemset(identity_files, 0, sizeof(identity_files));\n\tmemset(identity_keys, 0, sizeof(identity_keys));\n\tmemset(identity_file_userprovided, 0,\n\t    sizeof(identity_file_userprovided));\n\tmemset(certificate_files, 0, sizeof(certificate_files));\n\tmemset(certificates, 0, sizeof(certificates));\n\tmemset(certificate_file_userprovided, 0,\n\t    sizeof(certificate_file_userprovided));\n\n#ifdef ENABLE_PKCS11\n\tif (options.pkcs11_provider != NULL &&\n\t    options.num_identity_files < SSH_MAX_IDENTITY_FILES &&\n\t    (pkcs11_init(!options.batch_mode) == 0) &&\n\t    (nkeys = pkcs11_add_provider(options.pkcs11_provider, NULL,\n\t    &keys, &comments)) > 0) {\n\t\tfor (i = 0; i < nkeys; i++) {\n\t\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES) {\n\t\t\t\tsshkey_free(keys[i]);\n\t\t\t\tfree(comments[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tidentity_keys[n_ids] = keys[i];\n\t\t\tidentity_files[n_ids] = comments[i];  \n\t\t\tn_ids++;\n\t\t}\n\t\tfree(keys);\n\t\tfree(comments);\n\t}\n#endif  \n\tfor (i = 0; i < options.num_identity_files; i++) {\n\t\tif (n_ids >= SSH_MAX_IDENTITY_FILES ||\n\t\t    strcasecmp(options.identity_files[i], \"none\") == 0) {\n\t\t\tfree(options.identity_files[i]);\n\t\t\toptions.identity_files[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tcp = tilde_expand_filename(options.identity_files[i], getuid());\n\t\tfilename = default_client_percent_dollar_expand(cp, cinfo);\n\t\tfree(cp);\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    &public, filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.identity_files[i]);\n\t\tidentity_files[n_ids] = filename;\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tif (++n_ids >= SSH_MAX_IDENTITY_FILES)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (options.num_certificate_files != 0)\n\t\t\tcontinue;\n\t\txasprintf(&cp, \"%s-cert\", filename);\n\t\tcheck_load(sshkey_load_public(cp, &public, NULL),\n\t\t    &public, filename, \"pubkey\");\n\t\tdebug(\"identity file %s type %d\", cp,\n\t\t    public ? public->type : -1);\n\t\tif (public == NULL) {\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug_f(\"key %s type %s is not a certificate\",\n\t\t\t    cp, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(cp);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tidentity_files[n_ids] = xstrdup(filename);\n\t\tidentity_keys[n_ids] = public;\n\t\tidentity_file_userprovided[n_ids] =\n\t\t    options.identity_file_userprovided[i];\n\t\tn_ids++;\n\t}\n\n\tif (options.num_certificate_files > SSH_MAX_CERTIFICATE_FILES)\n\t\tfatal_f(\"too many certificates\");\n\tfor (i = 0; i < options.num_certificate_files; i++) {\n\t\tcp = tilde_expand_filename(options.certificate_files[i],\n\t\t    getuid());\n\t\tfilename = default_client_percent_dollar_expand(cp, cinfo);\n\t\tfree(cp);\n\n\t\tcheck_load(sshkey_load_public(filename, &public, NULL),\n\t\t    &public, filename, \"certificate\");\n\t\tdebug(\"certificate file %s type %d\", filename,\n\t\t    public ? public->type : -1);\n\t\tfree(options.certificate_files[i]);\n\t\toptions.certificate_files[i] = NULL;\n\t\tif (public == NULL) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sshkey_is_cert(public)) {\n\t\t\tdebug_f(\"key %s type %s is not a certificate\",\n\t\t\t    filename, sshkey_type(public));\n\t\t\tsshkey_free(public);\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\t\tcertificate_files[n_certs] = filename;\n\t\tcertificates[n_certs] = public;\n\t\tcertificate_file_userprovided[n_certs] =\n\t\t    options.certificate_file_userprovided[i];\n\t\t++n_certs;\n\t}\n\n\toptions.num_identity_files = n_ids;\n\tmemcpy(options.identity_files, identity_files, sizeof(identity_files));\n\tmemcpy(options.identity_keys, identity_keys, sizeof(identity_keys));\n\tmemcpy(options.identity_file_userprovided,\n\t    identity_file_userprovided, sizeof(identity_file_userprovided));\n\n\toptions.num_certificate_files = n_certs;\n\tmemcpy(options.certificate_files,\n\t    certificate_files, sizeof(certificate_files));\n\tmemcpy(options.certificates, certificates, sizeof(certificates));\n\tmemcpy(options.certificate_file_userprovided,\n\t    certificate_file_userprovided,\n\t    sizeof(certificate_file_userprovided));\n}\n\nstatic void\nmain_sigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tpid_t pid;\n\tint status;\n\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t    (pid == -1 && errno == EINTR))\n\t\t;\n\terrno = save_errno;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}