{
  "module_name": "sshconnect.c",
  "hash_id": "02501ea52f90c7c3f5ef67a783e715345f6651a66ca8c2b453204d3db8dccae8",
  "original_prompt": "Ingested from openssh-9.6p1/sshconnect.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <net/if.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <netdb.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#include <pwd.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <unistd.h>\n#ifdef HAVE_IFADDRS_H\n# include <ifaddrs.h>\n#endif\n\n#include \"xmalloc.h\"\n#include \"hostfile.h\"\n#include \"ssh.h\"\n#include \"sshbuf.h\"\n#include \"packet.h\"\n#include \"sshkey.h\"\n#include \"sshconnect.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"readconf.h\"\n#include \"atomicio.h\"\n#include \"dns.h\"\n#include \"monitor_fdpass.h\"\n#include \"ssh2.h\"\n#include \"version.h\"\n#include \"authfile.h\"\n#include \"ssherr.h\"\n#include \"authfd.h\"\n#include \"kex.h\"\n\nstruct sshkey *previous_host_key = NULL;\n\nstatic int matching_host_key_dns = 0;\n\nstatic pid_t proxy_command_pid = 0;\n\n \nextern int debug_flag;\nextern Options options;\nextern char *__progname;\n\nstatic int show_other_keys(struct hostkeys *, struct sshkey *);\nstatic void warn_changed_key(struct sshkey *);\n\n \nstatic char *\nexpand_proxy_command(const char *proxy_command, const char *user,\n    const char *host, const char *host_arg, int port)\n{\n\tchar *tmp, *ret, strport[NI_MAXSERV];\n\tconst char *keyalias = options.host_key_alias ?\n\t    options.host_key_alias : host_arg;\n\n\tsnprintf(strport, sizeof strport, \"%d\", port);\n\txasprintf(&tmp, \"exec %s\", proxy_command);\n\tret = percent_expand(tmp,\n\t    \"h\", host,\n\t    \"k\", keyalias,\n\t    \"n\", host_arg,\n\t    \"p\", strport,\n\t    \"r\", options.user,\n\t    (char *)NULL);\n\tfree(tmp);\n\treturn ret;\n}\n\n \nstatic int\nssh_proxy_fdpass_connect(struct ssh *ssh, const char *host,\n    const char *host_arg, u_short port, const char *proxy_command)\n{\n\tchar *command_string;\n\tint sp[2], sock;\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL)\n\t\tshell = _PATH_BSHELL;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) == -1)\n\t\tfatal(\"Could not create socketpair to communicate with \"\n\t\t    \"proxy dialer: %.100s\", strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, host_arg, port);\n\tdebug(\"Executing proxy dialer command: %.500s\", command_string);\n\n\t \n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\tclose(sp[1]);\n\t\t \n\t\tif (sp[0] != 0) {\n\t\t\tif (dup2(sp[0], 0) == -1)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t}\n\t\tif (sp[0] != 1) {\n\t\t\tif (dup2(sp[0], 1) == -1)\n\t\t\t\tperror(\"dup2 stdout\");\n\t\t}\n\t\tif (sp[0] >= 2)\n\t\t\tclose(sp[0]);\n\n\t\t \n\t\tif (!debug_flag && options.control_path != NULL &&\n\t\t    options.control_persist && stdfd_devnull(0, 0, 1) == -1)\n\t\t\terror_f(\"stdfd_devnull failed\");\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t \n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t \n\tif (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\tclose(sp[0]);\n\tfree(command_string);\n\n\tif ((sock = mm_receive_fd(sp[1])) == -1)\n\t\tfatal(\"proxy dialer did not pass back a connection\");\n\tclose(sp[1]);\n\n\twhile (waitpid(pid, NULL, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\n\t \n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1;  \n\n\treturn 0;\n}\n\n \nstatic int\nssh_proxy_connect(struct ssh *ssh, const char *host, const char *host_arg,\n    u_short port, const char *proxy_command)\n{\n\tchar *command_string;\n\tint pin[2], pout[2];\n\tpid_t pid;\n\tchar *shell;\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\t \n\tif (pipe(pin) == -1 || pipe(pout) == -1)\n\t\tfatal(\"Could not create pipes to communicate with the proxy: %.100s\",\n\t\t    strerror(errno));\n\n\tcommand_string = expand_proxy_command(proxy_command, options.user,\n\t    host, host_arg, port);\n\tdebug(\"Executing proxy command: %.500s\", command_string);\n\n\t \n\tif ((pid = fork()) == 0) {\n\t\tchar *argv[10];\n\n\t\t \n\t\tclose(pin[1]);\n\t\tif (pin[0] != 0) {\n\t\t\tif (dup2(pin[0], 0) == -1)\n\t\t\t\tperror(\"dup2 stdin\");\n\t\t\tclose(pin[0]);\n\t\t}\n\t\tclose(pout[0]);\n\t\tif (dup2(pout[1], 1) == -1)\n\t\t\tperror(\"dup2 stdout\");\n\t\t \n\t\tclose(pout[1]);\n\n\t\t \n\t\tif (!debug_flag && options.control_path != NULL &&\n\t\t    options.control_persist && stdfd_devnull(0, 0, 1) == -1)\n\t\t\terror_f(\"stdfd_devnull failed\");\n\n\t\targv[0] = shell;\n\t\targv[1] = \"-c\";\n\t\targv[2] = command_string;\n\t\targv[3] = NULL;\n\n\t\t \n\t\tssh_signal(SIGPIPE, SIG_DFL);\n\t\texecv(argv[0], argv);\n\t\tperror(argv[0]);\n\t\texit(1);\n\t}\n\t \n\tif (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\telse\n\t\tproxy_command_pid = pid;  \n\n\t \n\tclose(pin[0]);\n\tclose(pout[1]);\n\n\t \n\tfree(command_string);\n\n\t \n\tif (ssh_packet_set_connection(ssh, pout[0], pin[1]) == NULL)\n\t\treturn -1;  \n\n\treturn 0;\n}\n\nvoid\nssh_kill_proxy_command(void)\n{\n\t \n\tif (proxy_command_pid > 1)\n\t\tkill(proxy_command_pid, SIGHUP);\n}\n\n#ifdef HAVE_IFADDRS_H\n \nstatic int\ncheck_ifaddrs(const char *ifname, int af, const struct ifaddrs *ifaddrs,\n    struct sockaddr_storage *resultp, socklen_t *rlenp)\n{\n\tstruct sockaddr_in6 *sa6;\n\tstruct sockaddr_in *sa;\n\tstruct in6_addr *v6addr;\n\tconst struct ifaddrs *ifa;\n\tint allow_local;\n\n\t \n\tfor (allow_local = 0; allow_local < 2; allow_local++) {\n\t\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t\tif (ifa->ifa_addr == NULL || ifa->ifa_name == NULL ||\n\t\t\t    (ifa->ifa_flags & IFF_UP) == 0 ||\n\t\t\t    ifa->ifa_addr->sa_family != af ||\n\t\t\t    strcmp(ifa->ifa_name, options.bind_interface) != 0)\n\t\t\t\tcontinue;\n\t\t\tswitch (ifa->ifa_addr->sa_family) {\n\t\t\tcase AF_INET:\n\t\t\t\tsa = (struct sockaddr_in *)ifa->ifa_addr;\n\t\t\t\tif (!allow_local && sa->sin_addr.s_addr ==\n\t\t\t\t    htonl(INADDR_LOOPBACK))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in)) {\n\t\t\t\t\terror_f(\"v4 addr doesn't fit\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in);\n\t\t\t\tmemcpy(resultp, sa, *rlenp);\n\t\t\t\treturn 0;\n\t\t\tcase AF_INET6:\n\t\t\t\tsa6 = (struct sockaddr_in6 *)ifa->ifa_addr;\n\t\t\t\tv6addr = &sa6->sin6_addr;\n\t\t\t\tif (!allow_local &&\n\t\t\t\t    (IN6_IS_ADDR_LINKLOCAL(v6addr) ||\n\t\t\t\t    IN6_IS_ADDR_LOOPBACK(v6addr)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (*rlenp < sizeof(struct sockaddr_in6)) {\n\t\t\t\t\terror_f(\"v6 addr doesn't fit\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*rlenp = sizeof(struct sockaddr_in6);\n\t\t\t\tmemcpy(resultp, sa6, *rlenp);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n#endif\n\n \nstatic int\nssh_create_socket(struct addrinfo *ai)\n{\n\tint sock, r;\n\tstruct sockaddr_storage bindaddr;\n\tsocklen_t bindaddrlen = 0;\n\tstruct addrinfo hints, *res = NULL;\n#ifdef HAVE_IFADDRS_H\n\tstruct ifaddrs *ifaddrs = NULL;\n#endif\n\tchar ntop[NI_MAXHOST];\n\n\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\tif (sock == -1) {\n\t\terror(\"socket: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\t(void)fcntl(sock, F_SETFD, FD_CLOEXEC);\n\n\t \n\tif (options.ip_qos_interactive != INT_MAX)\n\t\tset_sock_tos(sock, options.ip_qos_interactive);\n\n\t \n\tif (options.bind_address == NULL && options.bind_interface == NULL)\n\t\treturn sock;\n\n\tif (options.bind_address != NULL) {\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ai->ai_family;\n\t\thints.ai_socktype = ai->ai_socktype;\n\t\thints.ai_protocol = ai->ai_protocol;\n\t\thints.ai_flags = AI_PASSIVE;\n\t\tif ((r = getaddrinfo(options.bind_address, NULL,\n\t\t    &hints, &res)) != 0) {\n\t\t\terror(\"getaddrinfo: %s: %s\", options.bind_address,\n\t\t\t    ssh_gai_strerror(r));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (res == NULL) {\n\t\t\terror(\"getaddrinfo: no addrs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(&bindaddr, res->ai_addr, res->ai_addrlen);\n\t\tbindaddrlen = res->ai_addrlen;\n\t} else if (options.bind_interface != NULL) {\n#ifdef HAVE_IFADDRS_H\n\t\tif ((r = getifaddrs(&ifaddrs)) != 0) {\n\t\t\terror(\"getifaddrs: %s: %s\", options.bind_interface,\n\t\t\t    strerror(errno));\n\t\t\tgoto fail;\n\t\t}\n\t\tbindaddrlen = sizeof(bindaddr);\n\t\tif (check_ifaddrs(options.bind_interface, ai->ai_family,\n\t\t    ifaddrs, &bindaddr, &bindaddrlen) != 0) {\n\t\t\tlogit(\"getifaddrs: %s: no suitable addresses\",\n\t\t\t    options.bind_interface);\n\t\t\tgoto fail;\n\t\t}\n#else\n\t\terror(\"BindInterface not supported on this platform.\");\n#endif\n\t}\n\tif ((r = getnameinfo((struct sockaddr *)&bindaddr, bindaddrlen,\n\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST)) != 0) {\n\t\terror_f(\"getnameinfo failed: %s\", ssh_gai_strerror(r));\n\t\tgoto fail;\n\t}\n\tif (bind(sock, (struct sockaddr *)&bindaddr, bindaddrlen) != 0) {\n\t\terror(\"bind %s: %s\", ntop, strerror(errno));\n\t\tgoto fail;\n\t}\n\tdebug_f(\"bound to %s\", ntop);\n\t \n\tgoto out;\nfail:\n\tclose(sock);\n\tsock = -1;\n out:\n\tif (res != NULL)\n\t\tfreeaddrinfo(res);\n#ifdef HAVE_IFADDRS_H\n\tif (ifaddrs != NULL)\n\t\tfreeifaddrs(ifaddrs);\n#endif\n\treturn sock;\n}\n\n \nstatic int\nssh_connect_direct(struct ssh *ssh, const char *host, struct addrinfo *aitop,\n    struct sockaddr_storage *hostaddr, u_short port, int connection_attempts,\n    int *timeout_ms, int want_keepalive)\n{\n\tint on = 1, saved_timeout_ms = *timeout_ms;\n\tint oerrno, sock = -1, attempt;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV];\n\tstruct addrinfo *ai;\n\n\tdebug3_f(\"entering\");\n\tmemset(ntop, 0, sizeof(ntop));\n\tmemset(strport, 0, sizeof(strport));\n\n\tfor (attempt = 0; attempt < connection_attempts; attempt++) {\n\t\tif (attempt > 0) {\n\t\t\t \n\t\t\tsleep(1);\n\t\t\tdebug(\"Trying again...\");\n\t\t}\n\t\t \n\t\tfor (ai = aitop; ai; ai = ai->ai_next) {\n\t\t\tif (ai->ai_family != AF_INET &&\n\t\t\t    ai->ai_family != AF_INET6) {\n\t\t\t\terrno = EAFNOSUPPORT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t    ntop, sizeof(ntop), strport, sizeof(strport),\n\t\t\t    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n\t\t\t\toerrno = errno;\n\t\t\t\terror_f(\"getnameinfo failed\");\n\t\t\t\terrno = oerrno;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (options.address_family != AF_UNSPEC &&\n\t\t\t    ai->ai_family != options.address_family) {\n\t\t\t\tdebug2_f(\"skipping address [%s]:%s: \"\n\t\t\t\t    \"wrong address family\", ntop, strport);\n\t\t\t\terrno = EAFNOSUPPORT;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug(\"Connecting to %.200s [%.100s] port %s.\",\n\t\t\t\thost, ntop, strport);\n\n\t\t\t \n\t\t\tsock = ssh_create_socket(ai);\n\t\t\tif (sock < 0) {\n\t\t\t\t \n\t\t\t\terrno = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t*timeout_ms = saved_timeout_ms;\n\t\t\tif (timeout_connect(sock, ai->ai_addr, ai->ai_addrlen,\n\t\t\t    timeout_ms) >= 0) {\n\t\t\t\t \n\t\t\t\tmemcpy(hostaddr, ai->ai_addr, ai->ai_addrlen);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\toerrno = errno;\n\t\t\t\tdebug(\"connect to address %s port %s: %s\",\n\t\t\t\t    ntop, strport, strerror(errno));\n\t\t\t\tclose(sock);\n\t\t\t\tsock = -1;\n\t\t\t\terrno = oerrno;\n\t\t\t}\n\t\t}\n\t\tif (sock != -1)\n\t\t\tbreak;\t \n\t}\n\n\t \n\tif (sock == -1) {\n\t\terror(\"ssh: connect to host %s port %s: %s\",\n\t\t    host, strport, errno == 0 ? \"failure\" : strerror(errno));\n\t\treturn -1;\n\t}\n\n\tdebug(\"Connection established.\");\n\n\t \n\tif (want_keepalive &&\n\t    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,\n\t    sizeof(on)) == -1)\n\t\terror(\"setsockopt SO_KEEPALIVE: %.100s\", strerror(errno));\n\n\t \n\tif (ssh_packet_set_connection(ssh, sock, sock) == NULL)\n\t\treturn -1;  \n\n\treturn 0;\n}\n\nint\nssh_connect(struct ssh *ssh, const char *host, const char *host_arg,\n    struct addrinfo *addrs, struct sockaddr_storage *hostaddr, u_short port,\n    int connection_attempts, int *timeout_ms, int want_keepalive)\n{\n\tint in, out;\n\n\tif (options.proxy_command == NULL) {\n\t\treturn ssh_connect_direct(ssh, host, addrs, hostaddr, port,\n\t\t    connection_attempts, timeout_ms, want_keepalive);\n\t} else if (strcmp(options.proxy_command, \"-\") == 0) {\n\t\tif ((in = dup(STDIN_FILENO)) == -1 ||\n\t\t    (out = dup(STDOUT_FILENO)) == -1) {\n\t\t\tif (in >= 0)\n\t\t\t\tclose(in);\n\t\t\terror_f(\"dup() in/out failed\");\n\t\t\treturn -1;  \n\t\t}\n\t\tif ((ssh_packet_set_connection(ssh, in, out)) == NULL)\n\t\t\treturn -1;  \n\t\treturn 0;\n\t} else if (options.proxy_use_fdpass) {\n\t\treturn ssh_proxy_fdpass_connect(ssh, host, host_arg, port,\n\t\t    options.proxy_command);\n\t}\n\treturn ssh_proxy_connect(ssh, host, host_arg, port,\n\t    options.proxy_command);\n}\n\n \nstatic int\nconfirm(const char *prompt, const char *fingerprint)\n{\n\tconst char *msg, *again = \"Please type 'yes' or 'no': \";\n\tconst char *again_fp = \"Please type 'yes', 'no' or the fingerprint: \";\n\tchar *p, *cp;\n\tint ret = -1;\n\n\tif (options.batch_mode)\n\t\treturn 0;\n\tfor (msg = prompt;;msg = fingerprint ? again_fp : again) {\n\t\tcp = p = read_passphrase(msg, RP_ECHO);\n\t\tif (p == NULL)\n\t\t\treturn 0;\n\t\tp += strspn(p, \" \\t\");  \n\t\tp[strcspn(p, \" \\t\\n\")] = '\\0';  \n\t\tif (p[0] == '\\0' || strcasecmp(p, \"no\") == 0)\n\t\t\tret = 0;\n\t\telse if (strcasecmp(p, \"yes\") == 0 || (fingerprint != NULL &&\n\t\t    strcmp(p, fingerprint) == 0))\n\t\t\tret = 1;\n\t\tfree(cp);\n\t\tif (ret != -1)\n\t\t\treturn ret;\n\t}\n}\n\nstatic int\nsockaddr_is_local(struct sockaddr *hostaddr)\n{\n\tswitch (hostaddr->sa_family) {\n\tcase AF_INET:\n\t\treturn (ntohl(((struct sockaddr_in *)hostaddr)->\n\t\t    sin_addr.s_addr) >> 24) == IN_LOOPBACKNET;\n\tcase AF_INET6:\n\t\treturn IN6_IS_ADDR_LOOPBACK(\n\t\t    &(((struct sockaddr_in6 *)hostaddr)->sin6_addr));\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nvoid\nget_hostfile_hostname_ipaddr(char *hostname, struct sockaddr *hostaddr,\n    u_short port, char **hostfile_hostname, char **hostfile_ipaddr)\n{\n\tchar ntop[NI_MAXHOST];\n\tsocklen_t addrlen;\n\n\tswitch (hostaddr == NULL ? -1 : hostaddr->sa_family) {\n\tcase -1:\n\t\taddrlen = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddrlen = sizeof(struct sockaddr_in);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddrlen = sizeof(struct sockaddr_in6);\n\t\tbreak;\n\tdefault:\n\t\taddrlen = sizeof(struct sockaddr);\n\t\tbreak;\n\t}\n\n\t \n\tif (hostfile_ipaddr != NULL) {\n\t\tif (options.proxy_command == NULL) {\n\t\t\tif (getnameinfo(hostaddr, addrlen,\n\t\t\t    ntop, sizeof(ntop), NULL, 0, NI_NUMERICHOST) != 0)\n\t\t\tfatal_f(\"getnameinfo failed\");\n\t\t\t*hostfile_ipaddr = put_host_port(ntop, port);\n\t\t} else {\n\t\t\t*hostfile_ipaddr = xstrdup(\"<no hostip for proxy \"\n\t\t\t    \"command>\");\n\t\t}\n\t}\n\n\t \n\tif (hostfile_hostname != NULL) {\n\t\tif (options.host_key_alias != NULL) {\n\t\t\t*hostfile_hostname = xstrdup(options.host_key_alias);\n\t\t\tdebug(\"using hostkeyalias: %s\", *hostfile_hostname);\n\t\t} else {\n\t\t\t*hostfile_hostname = put_host_port(hostname, port);\n\t\t}\n\t}\n}\n\n \nstatic int\npath_in_hostfiles(const char *path, char **hostfiles, u_int num_hostfiles)\n{\n\tu_int i;\n\n\tfor (i = 0; i < num_hostfiles; i++) {\n\t\tif (strcmp(path, hostfiles[i]) == 0)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstruct find_by_key_ctx {\n\tconst char *host, *ip;\n\tconst struct sshkey *key;\n\tchar **names;\n\tu_int nnames;\n};\n\n \nstatic char *\ntry_tilde_unexpand(const char *path)\n{\n\tchar *home, *ret = NULL;\n\tsize_t l;\n\n\tif (*path != '/')\n\t\treturn xstrdup(path);\n\tif ((home = getenv(\"HOME\")) == NULL || (l = strlen(home)) == 0)\n\t\treturn xstrdup(path);\n\tif (strncmp(path, home, l) != 0)\n\t\treturn xstrdup(path);\n\t \n\tif (home[l - 1] != '/' && path[l] != '/')\n\t\treturn xstrdup(path);\n\tif (path[l] == '/')\n\t\tl++;\n\txasprintf(&ret, \"~/%s\", path + l);\n\treturn ret;\n}\n\nstatic int\nhostkeys_find_by_key_cb(struct hostkey_foreach_line *l, void *_ctx)\n{\n\tstruct find_by_key_ctx *ctx = (struct find_by_key_ctx *)_ctx;\n\tchar *path;\n\n\t \n\tif ((l->match & HKF_MATCH_HOST) != 0)\n\t\treturn 0;\n\t \n\tif (l->marker != MRK_NONE)\n\t\treturn 0;\n\t \n\tif (l->key == NULL || !sshkey_equal(ctx->key, l->key))\n\t\treturn 0;\n\tpath = try_tilde_unexpand(l->path);\n\tdebug_f(\"found matching key in %s:%lu\", path, l->linenum);\n\tctx->names = xrecallocarray(ctx->names,\n\t    ctx->nnames, ctx->nnames + 1, sizeof(*ctx->names));\n\txasprintf(&ctx->names[ctx->nnames], \"%s:%lu: %s\", path, l->linenum,\n\t    strncmp(l->hosts, HASH_MAGIC, strlen(HASH_MAGIC)) == 0 ?\n\t    \"[hashed name]\" : l->hosts);\n\tctx->nnames++;\n\tfree(path);\n\treturn 0;\n}\n\nstatic int\nhostkeys_find_by_key_hostfile(const char *file, const char *which,\n    struct find_by_key_ctx *ctx)\n{\n\tint r;\n\n\tdebug3_f(\"trying %s hostfile \\\"%s\\\"\", which, file);\n\tif ((r = hostkeys_foreach(file, hostkeys_find_by_key_cb, ctx,\n\t    ctx->host, ctx->ip, HKF_WANT_PARSE_KEY, 0)) != 0) {\n\t\tif (r == SSH_ERR_SYSTEM_ERROR && errno == ENOENT) {\n\t\t\tdebug_f(\"hostkeys file %s does not exist\", file);\n\t\t\treturn 0;\n\t\t}\n\t\terror_fr(r, \"hostkeys_foreach failed for %s\", file);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nhostkeys_find_by_key(const char *host, const char *ip, const struct sshkey *key,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles,\n    char ***names, u_int *nnames)\n{\n\tstruct find_by_key_ctx ctx = {0, 0, 0, 0, 0};\n\tu_int i;\n\n\t*names = NULL;\n\t*nnames = 0;\n\n\tif (key == NULL || sshkey_is_cert(key))\n\t\treturn;\n\n\tctx.host = host;\n\tctx.ip = ip;\n\tctx.key = key;\n\n\tfor (i = 0; i < num_user_hostfiles; i++) {\n\t\tif (hostkeys_find_by_key_hostfile(user_hostfiles[i],\n\t\t    \"user\", &ctx) != 0)\n\t\t\tgoto fail;\n\t}\n\tfor (i = 0; i < num_system_hostfiles; i++) {\n\t\tif (hostkeys_find_by_key_hostfile(system_hostfiles[i],\n\t\t    \"system\", &ctx) != 0)\n\t\t\tgoto fail;\n\t}\n\t \n\t*names = ctx.names;\n\t*nnames = ctx.nnames;\n\tctx.names = NULL;\n\tctx.nnames = 0;\n\treturn;\n fail:\n\tfor (i = 0; i < ctx.nnames; i++)\n\t\tfree(ctx.names[i]);\n\tfree(ctx.names);\n}\n\n#define MAX_OTHER_NAMES\t8  \nstatic char *\nother_hostkeys_message(const char *host, const char *ip,\n    const struct sshkey *key,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles)\n{\n\tchar *ret = NULL, **othernames = NULL;\n\tu_int i, n, num_othernames = 0;\n\n\thostkeys_find_by_key(host, ip, key,\n\t    user_hostfiles, num_user_hostfiles,\n\t    system_hostfiles, num_system_hostfiles,\n\t    &othernames, &num_othernames);\n\tif (num_othernames == 0)\n\t\treturn xstrdup(\"This key is not known by any other names.\");\n\n\txasprintf(&ret, \"This host key is known by the following other \"\n\t    \"names/addresses:\");\n\n\tn = num_othernames;\n\tif (n > MAX_OTHER_NAMES)\n\t\tn = MAX_OTHER_NAMES;\n\tfor (i = 0; i < n; i++) {\n\t\txextendf(&ret, \"\\n\", \"    %s\", othernames[i]);\n\t}\n\tif (n < num_othernames) {\n\t\txextendf(&ret, \"\\n\", \"    (%d additional names omitted)\",\n\t\t    num_othernames - n);\n\t}\n\tfor (i = 0; i < num_othernames; i++)\n\t\tfree(othernames[i]);\n\tfree(othernames);\n\treturn ret;\n}\n\nvoid\nload_hostkeys_command(struct hostkeys *hostkeys, const char *command_template,\n    const char *invocation, const struct ssh_conn_info *cinfo,\n    const struct sshkey *host_key, const char *hostfile_hostname)\n{\n\tint r, i, ac = 0;\n\tchar *key_fp = NULL, *keytext = NULL, *tmp;\n\tchar *command = NULL, *tag = NULL, **av = NULL;\n\tFILE *f = NULL;\n\tpid_t pid;\n\tvoid (*osigchld)(int);\n\n\txasprintf(&tag, \"KnownHostsCommand-%s\", invocation);\n\n\tif (host_key != NULL) {\n\t\tif ((key_fp = sshkey_fingerprint(host_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\tif ((r = sshkey_to_base64(host_key, &keytext)) != 0)\n\t\t\tfatal_fr(r, \"sshkey_to_base64 failed\");\n\t}\n\t \n\tosigchld = ssh_signal(SIGCHLD, SIG_DFL);\n\n\t \n\tif (argv_split(command_template, &ac, &av, 0) != 0) {\n\t\terror(\"%s \\\"%s\\\" contains invalid quotes\", tag,\n\t\t    command_template);\n\t\tgoto out;\n\t}\n\tif (ac == 0) {\n\t\terror(\"%s \\\"%s\\\" yielded no arguments\", tag,\n\t\t    command_template);\n\t\tgoto out;\n\t}\n\tfor (i = 1; i < ac; i++) {\n\t\ttmp = percent_dollar_expand(av[i],\n\t\t    DEFAULT_CLIENT_PERCENT_EXPAND_ARGS(cinfo),\n\t\t    \"H\", hostfile_hostname,\n\t\t    \"I\", invocation,\n\t\t    \"t\", host_key == NULL ? \"NONE\" : sshkey_ssh_name(host_key),\n\t\t    \"f\", key_fp == NULL ? \"NONE\" : key_fp,\n\t\t    \"K\", keytext == NULL ? \"NONE\" : keytext,\n\t\t    (char *)NULL);\n\t\tif (tmp == NULL)\n\t\t\tfatal_f(\"percent_expand failed\");\n\t\tfree(av[i]);\n\t\tav[i] = tmp;\n\t}\n\t \n\tcommand = argv_assemble(ac, av);\n\n\tif ((pid = subprocess(tag, command, ac, av, &f,\n\t    SSH_SUBPROCESS_STDOUT_CAPTURE|SSH_SUBPROCESS_UNSAFE_PATH|\n\t    SSH_SUBPROCESS_PRESERVE_ENV, NULL, NULL, NULL)) == 0)\n\t\tgoto out;\n\n\tload_hostkeys_file(hostkeys, hostfile_hostname, tag, f, 1);\n\n\tif (exited_cleanly(pid, tag, command, 0) != 0)\n\t\tfatal(\"KnownHostsCommand failed\");\n\n out:\n\tif (f != NULL)\n\t\tfclose(f);\n\tssh_signal(SIGCHLD, osigchld);\n\tfor (i = 0; i < ac; i++)\n\t\tfree(av[i]);\n\tfree(av);\n\tfree(tag);\n\tfree(command);\n\tfree(key_fp);\n\tfree(keytext);\n}\n\n \n#define RDRW\t0\n#define RDONLY\t1\n#define ROQUIET\t2\nstatic int\ncheck_host_key(char *hostname, const struct ssh_conn_info *cinfo,\n    struct sockaddr *hostaddr, u_short port,\n    struct sshkey *host_key, int readonly, int clobber_port,\n    char **user_hostfiles, u_int num_user_hostfiles,\n    char **system_hostfiles, u_int num_system_hostfiles,\n    const char *hostfile_command)\n{\n\tHostStatus host_status = -1, ip_status = -1;\n\tstruct sshkey *raw_key = NULL;\n\tchar *ip = NULL, *host = NULL;\n\tchar hostline[1000], *hostp, *fp, *ra;\n\tchar msg[1024];\n\tconst char *type, *fail_reason = NULL;\n\tconst struct hostkey_entry *host_found = NULL, *ip_found = NULL;\n\tint len, cancelled_forwarding = 0, confirmed;\n\tint local = sockaddr_is_local(hostaddr);\n\tint r, want_cert = sshkey_is_cert(host_key), host_ip_differ = 0;\n\tint hostkey_trusted = 0;  \n\tstruct hostkeys *host_hostkeys, *ip_hostkeys;\n\tu_int i;\n\n\t \n\tif (options.no_host_authentication_for_localhost == 1 && local &&\n\t    options.host_key_alias == NULL) {\n\t\tdebug(\"Forcing accepting of host key for \"\n\t\t    \"loopback/localhost.\");\n\t\toptions.update_hostkeys = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif (strcspn(hostname, \"@?*#[]|'\\'\\\"\\\\\") != strlen(hostname)) {\n\t\tdebug_f(\"invalid hostname \\\"%s\\\"; will not record: %s\",\n\t\t    hostname, fail_reason);\n\t\treadonly = RDONLY;\n\t}\n\n\t \n\tget_hostfile_hostname_ipaddr(hostname, hostaddr,\n\t    clobber_port ? 0 : port, &host, &ip);\n\n\t \n\tif (options.check_host_ip && (local ||\n\t    strcmp(hostname, ip) == 0 || options.proxy_command != NULL))\n\t\toptions.check_host_ip = 0;\n\n\thost_hostkeys = init_hostkeys();\n\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, user_hostfiles[i], 0);\n\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\tload_hostkeys(host_hostkeys, host, system_hostfiles[i], 0);\n\tif (hostfile_command != NULL && !clobber_port) {\n\t\tload_hostkeys_command(host_hostkeys, hostfile_command,\n\t\t    \"HOSTNAME\", cinfo, host_key, host);\n\t}\n\n\tip_hostkeys = NULL;\n\tif (!want_cert && options.check_host_ip) {\n\t\tip_hostkeys = init_hostkeys();\n\t\tfor (i = 0; i < num_user_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, user_hostfiles[i], 0);\n\t\tfor (i = 0; i < num_system_hostfiles; i++)\n\t\t\tload_hostkeys(ip_hostkeys, ip, system_hostfiles[i], 0);\n\t\tif (hostfile_command != NULL && !clobber_port) {\n\t\t\tload_hostkeys_command(ip_hostkeys, hostfile_command,\n\t\t\t    \"ADDRESS\", cinfo, host_key, ip);\n\t\t}\n\t}\n\n retry:\n\t \n\twant_cert = sshkey_is_cert(host_key);\n\ttype = sshkey_type(host_key);\n\n\t \n\thost_status = check_key_in_hostkeys(host_hostkeys, host_key,\n\t    &host_found);\n\n\t \n\tif (!readonly && (num_user_hostfiles == 0 ||\n\t    (host_found != NULL && host_found->note != 0)))\n\t\treadonly = RDONLY;\n\n\t \n\tif (!want_cert && ip_hostkeys != NULL) {\n\t\tip_status = check_key_in_hostkeys(ip_hostkeys, host_key,\n\t\t    &ip_found);\n\t\tif (host_status == HOST_CHANGED &&\n\t\t    (ip_status != HOST_CHANGED ||\n\t\t    (ip_found != NULL &&\n\t\t    !sshkey_equal(ip_found->key, host_found->key))))\n\t\t\thost_ip_differ = 1;\n\t} else\n\t\tip_status = host_status;\n\n\tswitch (host_status) {\n\tcase HOST_OK:\n\t\t \n\t\tdebug(\"Host '%.200s' is known and matches the %s host %s.\",\n\t\t    host, type, want_cert ? \"certificate\" : \"key\");\n\t\tdebug(\"Found %s in %s:%lu\", want_cert ? \"CA key\" : \"key\",\n\t\t    host_found->file, host_found->line);\n\t\tif (want_cert) {\n\t\t\tif (sshkey_cert_check_host(host_key,\n\t\t\t    options.host_key_alias == NULL ?\n\t\t\t    hostname : options.host_key_alias, 0,\n\t\t\t    options.ca_sign_algorithms, &fail_reason) != 0) {\n\t\t\t\terror(\"%s\", fail_reason);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t \n\t\t\tif (options.update_hostkeys != 0) {\n\t\t\t\toptions.update_hostkeys = 0;\n\t\t\t\tdebug3_f(\"certificate host key in use; \"\n\t\t\t\t    \"disabling UpdateHostkeys\");\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (options.update_hostkeys != 0 &&\n\t\t    (path_in_hostfiles(host_found->file,\n\t\t    system_hostfiles, num_system_hostfiles) ||\n\t\t    (ip_status == HOST_OK && ip_found != NULL &&\n\t\t    path_in_hostfiles(ip_found->file,\n\t\t    system_hostfiles, num_system_hostfiles)))) {\n\t\t\toptions.update_hostkeys = 0;\n\t\t\tdebug3_f(\"host key found in GlobalKnownHostsFile; \"\n\t\t\t    \"disabling UpdateHostkeys\");\n\t\t}\n\t\tif (options.update_hostkeys != 0 && host_found->note) {\n\t\t\toptions.update_hostkeys = 0;\n\t\t\tdebug3_f(\"host key found via KnownHostsCommand; \"\n\t\t\t    \"disabling UpdateHostkeys\");\n\t\t}\n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tif (readonly || want_cert)\n\t\t\t\tlogit(\"%s host key for IP address \"\n\t\t\t\t    \"'%.128s' not in list of known hosts.\",\n\t\t\t\t    type, ip);\n\t\t\telse if (!add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t    host_key, options.hash_known_hosts))\n\t\t\t\tlogit(\"Failed to add the %s host key for IP \"\n\t\t\t\t    \"address '%.128s' to the list of known \"\n\t\t\t\t    \"hosts (%.500s).\", type, ip,\n\t\t\t\t    user_hostfiles[0]);\n\t\t\telse\n\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n\t\t\t\t    \"key for IP address '%.128s' to the list \"\n\t\t\t\t    \"of known hosts.\", type, ip);\n\t\t} else if (options.visual_host_key) {\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\t\tlogit(\"Host key fingerprint is %s\\n%s\", fp, ra);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t}\n\t\thostkey_trusted = 1;\n\t\tbreak;\n\tcase HOST_NEW:\n\t\tif (options.host_key_alias == NULL && port != 0 &&\n\t\t    port != SSH_DEFAULT_PORT && !clobber_port) {\n\t\t\tdebug(\"checking without port identifier\");\n\t\t\tif (check_host_key(hostname, cinfo, hostaddr, 0,\n\t\t\t    host_key, ROQUIET, 1,\n\t\t\t    user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles,\n\t\t\t    hostfile_command) == 0) {\n\t\t\t\tdebug(\"found matching key w/out port\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (readonly || want_cert)\n\t\t\tgoto fail;\n\t\t \n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_YES) {\n\t\t\t \n\t\t\terror(\"No %s host key is known for %.200s and you \"\n\t\t\t    \"have requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tchar *msg1 = NULL, *msg2 = NULL;\n\n\t\t\txasprintf(&msg1, \"The authenticity of host \"\n\t\t\t    \"'%.200s (%s)' can't be established\", host, ip);\n\n\t\t\tif (show_other_keys(host_hostkeys, host_key)) {\n\t\t\t\txextendf(&msg1, \"\\n\", \"but keys of different \"\n\t\t\t\t    \"type are already known for this host.\");\n\t\t\t} else\n\t\t\t\txextendf(&msg1, \"\", \".\");\n\n\t\t\tfp = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tra = sshkey_fingerprint(host_key,\n\t\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\t\tif (fp == NULL || ra == NULL)\n\t\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\t\txextendf(&msg1, \"\\n\", \"%s key fingerprint is %s.\",\n\t\t\t    type, fp);\n\t\t\tif (options.visual_host_key)\n\t\t\t\txextendf(&msg1, \"\\n\", \"%s\", ra);\n\t\t\tif (options.verify_host_key_dns) {\n\t\t\t\txextendf(&msg1, \"\\n\",\n\t\t\t\t    \"%s host key fingerprint found in DNS.\",\n\t\t\t\t    matching_host_key_dns ?\n\t\t\t\t    \"Matching\" : \"No matching\");\n\t\t\t}\n\t\t\t \n\t\t\tif ((msg2 = other_hostkeys_message(host, ip, host_key,\n\t\t\t    user_hostfiles, num_user_hostfiles,\n\t\t\t    system_hostfiles, num_system_hostfiles)) != NULL)\n\t\t\t\txextendf(&msg1, \"\\n\", \"%s\", msg2);\n\n\t\t\txextendf(&msg1, \"\\n\",\n\t\t\t    \"Are you sure you want to continue connecting \"\n\t\t\t    \"(yes/no/[fingerprint])? \");\n\n\t\t\tconfirmed = confirm(msg1, fp);\n\t\t\tfree(ra);\n\t\t\tfree(fp);\n\t\t\tfree(msg1);\n\t\t\tfree(msg2);\n\t\t\tif (!confirmed)\n\t\t\t\tgoto fail;\n\t\t\thostkey_trusted = 1;  \n\t\t}\n\t\t \n\t\tif (options.check_host_ip && ip_status == HOST_NEW) {\n\t\t\tsnprintf(hostline, sizeof(hostline), \"%s,%s\", host, ip);\n\t\t\thostp = hostline;\n\t\t\tif (options.hash_known_hosts) {\n\t\t\t\t \n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    host, host_key, options.hash_known_hosts) &&\n\t\t\t\t    add_host_to_hostfile(user_hostfiles[0], ip,\n\t\t\t\t    host_key, options.hash_known_hosts);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tr = add_host_to_hostfile(user_hostfiles[0],\n\t\t\t\t    hostline, host_key,\n\t\t\t\t    options.hash_known_hosts);\n\t\t\t}\n\t\t} else {\n\t\t\tr = add_host_to_hostfile(user_hostfiles[0], host,\n\t\t\t    host_key, options.hash_known_hosts);\n\t\t\thostp = host;\n\t\t}\n\n\t\tif (!r)\n\t\t\tlogit(\"Failed to add the host to the list of known \"\n\t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n\t\telse\n\t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n\t\t\t    \"list of known hosts.\", hostp, type);\n\t\tbreak;\n\tcase HOST_REVOKED:\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"@       WARNING: REVOKED HOST KEY DETECTED!               @\");\n\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\terror(\"The %s host key for %s is marked as revoked.\", type, host);\n\t\terror(\"This could mean that a stolen key is being used to\");\n\t\terror(\"impersonate this host.\");\n\n\t\t \n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"%s host key for %.200s was revoked and you have \"\n\t\t\t    \"requested strict checking.\", type, host);\n\t\t\tgoto fail;\n\t\t}\n\t\tgoto continue_unsafe;\n\n\tcase HOST_CHANGED:\n\t\tif (want_cert) {\n\t\t\t \n\t\t\tdebug(\"Host certificate authority does not \"\n\t\t\t    \"match %s in %s:%lu\", CA_MARKER,\n\t\t\t    host_found->file, host_found->line);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (readonly == ROQUIET)\n\t\t\tgoto fail;\n\t\tif (options.check_host_ip && host_ip_differ) {\n\t\t\tchar *key_msg;\n\t\t\tif (ip_status == HOST_NEW)\n\t\t\t\tkey_msg = \"is unknown\";\n\t\t\telse if (ip_status == HOST_OK)\n\t\t\t\tkey_msg = \"is unchanged\";\n\t\t\telse\n\t\t\t\tkey_msg = \"has a different value\";\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @\");\n\t\t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\t\t\terror(\"The %s host key for %s has changed,\", type, host);\n\t\t\terror(\"and the key for the corresponding IP address %s\", ip);\n\t\t\terror(\"%s. This could either mean that\", key_msg);\n\t\t\terror(\"DNS SPOOFING is happening or the IP address for the host\");\n\t\t\terror(\"and its host key have changed at the same time.\");\n\t\t\tif (ip_status != HOST_NEW)\n\t\t\t\terror(\"Offending key for IP in %s:%lu\",\n\t\t\t\t    ip_found->file, ip_found->line);\n\t\t}\n\t\t \n\t\twarn_changed_key(host_key);\n\t\tif (num_user_hostfiles > 0 || num_system_hostfiles > 0) {\n\t\t\terror(\"Add correct host key in %.100s to get rid \"\n\t\t\t    \"of this message.\", num_user_hostfiles > 0 ?\n\t\t\t    user_hostfiles[0] : system_hostfiles[0]);\n\t\t}\n\t\terror(\"Offending %s key in %s:%lu\",\n\t\t    sshkey_type(host_found->key),\n\t\t    host_found->file, host_found->line);\n\n\t\t \n\t\tif (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\terror(\"Host key for %.200s has changed and you have \"\n\t\t\t    \"requested strict checking.\", host);\n\t\t\tgoto fail;\n\t\t}\n\n continue_unsafe:\n\t\t \n\t\tif (options.password_authentication) {\n\t\t\terror(\"Password authentication is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.password_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.kbd_interactive_authentication) {\n\t\t\terror(\"Keyboard-interactive authentication is disabled\"\n\t\t\t    \" to avoid man-in-the-middle attacks.\");\n\t\t\toptions.kbd_interactive_authentication = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_agent) {\n\t\t\terror(\"Agent forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_agent = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.forward_x11) {\n\t\t\terror(\"X11 forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.forward_x11 = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.num_local_forwards > 0 ||\n\t\t    options.num_remote_forwards > 0) {\n\t\t\terror(\"Port forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.num_local_forwards =\n\t\t\t    options.num_remote_forwards = 0;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.tun_open != SSH_TUNMODE_NO) {\n\t\t\terror(\"Tunnel forwarding is disabled to avoid \"\n\t\t\t    \"man-in-the-middle attacks.\");\n\t\t\toptions.tun_open = SSH_TUNMODE_NO;\n\t\t\tcancelled_forwarding = 1;\n\t\t}\n\t\tif (options.update_hostkeys != 0) {\n\t\t\terror(\"UpdateHostkeys is disabled because the host \"\n\t\t\t    \"key is not trusted.\");\n\t\t\toptions.update_hostkeys = 0;\n\t\t}\n\t\tif (options.exit_on_forward_failure && cancelled_forwarding)\n\t\t\tfatal(\"Error: forwarding disabled due to host key \"\n\t\t\t    \"check failure\");\n\n\t\t \n\t\tbreak;\n\tcase HOST_FOUND:\n\t\tfatal(\"internal error\");\n\t\tbreak;\n\t}\n\n\tif (options.check_host_ip && host_status != HOST_CHANGED &&\n\t    ip_status == HOST_CHANGED) {\n\t\tsnprintf(msg, sizeof(msg),\n\t\t    \"Warning: the %s host key for '%.200s' \"\n\t\t    \"differs from the key for the IP address '%.128s'\"\n\t\t    \"\\nOffending key for IP in %s:%lu\",\n\t\t    type, host, ip, ip_found->file, ip_found->line);\n\t\tif (host_status == HOST_OK) {\n\t\t\tlen = strlen(msg);\n\t\t\tsnprintf(msg + len, sizeof(msg) - len,\n\t\t\t    \"\\nMatching host key in %s:%lu\",\n\t\t\t    host_found->file, host_found->line);\n\t\t}\n\t\tif (options.strict_host_key_checking ==\n\t\t    SSH_STRICT_HOSTKEY_ASK) {\n\t\t\tstrlcat(msg, \"\\nAre you sure you want \"\n\t\t\t    \"to continue connecting (yes/no)? \", sizeof(msg));\n\t\t\tif (!confirm(msg, NULL))\n\t\t\t\tgoto fail;\n\t\t} else if (options.strict_host_key_checking !=\n\t\t    SSH_STRICT_HOSTKEY_OFF) {\n\t\t\tlogit(\"%s\", msg);\n\t\t\terror(\"Exiting, you have requested strict checking.\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tlogit(\"%s\", msg);\n\t\t}\n\t}\n\n\tif (!hostkey_trusted && options.update_hostkeys) {\n\t\tdebug_f(\"hostkey not known or explicitly trusted: \"\n\t\t    \"disabling UpdateHostkeys\");\n\t\toptions.update_hostkeys = 0;\n\t}\n\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn 0;\n\nfail:\n\tif (want_cert && host_status != HOST_REVOKED) {\n\t\t \n\t\tdebug(\"No matching CA found. Retry with plain key\");\n\t\tif ((r = sshkey_from_private(host_key, &raw_key)) != 0)\n\t\t\tfatal_fr(r, \"decode key\");\n\t\tif ((r = sshkey_drop_cert(raw_key)) != 0)\n\t\t\tfatal_r(r, \"Couldn't drop certificate\");\n\t\thost_key = raw_key;\n\t\tgoto retry;\n\t}\n\tsshkey_free(raw_key);\n\tfree(ip);\n\tfree(host);\n\tif (host_hostkeys != NULL)\n\t\tfree_hostkeys(host_hostkeys);\n\tif (ip_hostkeys != NULL)\n\t\tfree_hostkeys(ip_hostkeys);\n\treturn -1;\n}\n\n \nint\nverify_host_key(char *host, struct sockaddr *hostaddr, struct sshkey *host_key,\n    const struct ssh_conn_info *cinfo)\n{\n\tu_int i;\n\tint r = -1, flags = 0;\n\tchar valid[64], *fp = NULL, *cafp = NULL;\n\tstruct sshkey *plain = NULL;\n\n\tif ((fp = sshkey_fingerprint(host_key,\n\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\terror_fr(r, \"fingerprint host key\");\n\t\tr = -1;\n\t\tgoto out;\n\t}\n\n\tif (sshkey_is_cert(host_key)) {\n\t\tif ((cafp = sshkey_fingerprint(host_key->cert->signature_key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n\t\t\terror_fr(r, \"fingerprint CA key\");\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tsshkey_format_cert_validity(host_key->cert,\n\t\t    valid, sizeof(valid));\n\t\tdebug(\"Server host certificate: %s %s, serial %llu \"\n\t\t    \"ID \\\"%s\\\" CA %s %s valid %s\",\n\t\t    sshkey_ssh_name(host_key), fp,\n\t\t    (unsigned long long)host_key->cert->serial,\n\t\t    host_key->cert->key_id,\n\t\t    sshkey_ssh_name(host_key->cert->signature_key), cafp,\n\t\t    valid);\n\t\tfor (i = 0; i < host_key->cert->nprincipals; i++) {\n\t\t\tdebug2(\"Server host certificate hostname: %s\",\n\t\t\t    host_key->cert->principals[i]);\n\t\t}\n\t} else {\n\t\tdebug(\"Server host key: %s %s\", sshkey_ssh_name(host_key), fp);\n\t}\n\n\tif (sshkey_equal(previous_host_key, host_key)) {\n\t\tdebug2_f(\"server host key %s %s matches cached key\",\n\t\t    sshkey_type(host_key), fp);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (options.revoked_host_keys != NULL) {\n\t\tr = sshkey_check_revoked(host_key, options.revoked_host_keys);\n\t\tswitch (r) {\n\t\tcase 0:\n\t\t\tbreak;  \n\t\tcase SSH_ERR_KEY_REVOKED:\n\t\t\terror(\"Host key %s %s revoked by file %s\",\n\t\t\t    sshkey_type(host_key), fp,\n\t\t\t    options.revoked_host_keys);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terror_r(r, \"Error checking host key %s %s in \"\n\t\t\t    \"revoked keys file %s\", sshkey_type(host_key),\n\t\t\t    fp, options.revoked_host_keys);\n\t\t\tr = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (options.verify_host_key_dns) {\n\t\t \n\t\tif ((r = sshkey_from_private(host_key, &plain)) != 0)\n\t\t\tgoto out;\n\t\tif (sshkey_is_cert(plain))\n\t\t\tsshkey_drop_cert(plain);\n\t\tif (verify_host_key_dns(host, hostaddr, plain, &flags) == 0) {\n\t\t\tif (flags & DNS_VERIFY_FOUND) {\n\t\t\t\tif (options.verify_host_key_dns == 1 &&\n\t\t\t\t    flags & DNS_VERIFY_MATCH &&\n\t\t\t\t    flags & DNS_VERIFY_SECURE) {\n\t\t\t\t\tr = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (flags & DNS_VERIFY_MATCH) {\n\t\t\t\t\tmatching_host_key_dns = 1;\n\t\t\t\t} else {\n\t\t\t\t\twarn_changed_key(plain);\n\t\t\t\t\terror(\"Update the SSHFP RR in DNS \"\n\t\t\t\t\t    \"with the new host key to get rid \"\n\t\t\t\t\t    \"of this message.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tr = check_host_key(host, cinfo, hostaddr, options.port, host_key,\n\t    RDRW, 0, options.user_hostfiles, options.num_user_hostfiles,\n\t    options.system_hostfiles, options.num_system_hostfiles,\n\t    options.known_hosts_command);\n\nout:\n\tsshkey_free(plain);\n\tfree(fp);\n\tfree(cafp);\n\tif (r == 0 && host_key != NULL) {\n\t\tsshkey_free(previous_host_key);\n\t\tr = sshkey_from_private(host_key, &previous_host_key);\n\t}\n\n\treturn r;\n}\n\n \nvoid\nssh_login(struct ssh *ssh, Sensitive *sensitive, const char *orighost,\n    struct sockaddr *hostaddr, u_short port, struct passwd *pw, int timeout_ms,\n    const struct ssh_conn_info *cinfo)\n{\n\tchar *host;\n\tchar *server_user, *local_user;\n\tint r;\n\n\tlocal_user = xstrdup(pw->pw_name);\n\tserver_user = options.user ? options.user : local_user;\n\n\t \n\thost = xstrdup(orighost);\n\tlowercase(host);\n\n\t \n\tif ((r = kex_exchange_identification(ssh, timeout_ms, NULL)) != 0)\n\t\tsshpkt_fatal(ssh, r, \"banner exchange\");\n\n\t \n\tssh_packet_set_nonblocking(ssh);\n\n\t \n\t \n\tdebug(\"Authenticating to %s:%d as '%s'\", host, port, server_user);\n\tssh_kex2(ssh, host, hostaddr, port, cinfo);\n\tssh_userauth2(ssh, local_user, server_user, host, sensitive);\n\tfree(local_user);\n\tfree(host);\n}\n\n \nstatic int\nshow_other_keys(struct hostkeys *hostkeys, struct sshkey *key)\n{\n\tint type[] = {\n\t\tKEY_RSA,\n\t\tKEY_DSA,\n\t\tKEY_ECDSA,\n\t\tKEY_ED25519,\n\t\tKEY_XMSS,\n\t\t-1\n\t};\n\tint i, ret = 0;\n\tchar *fp, *ra;\n\tconst struct hostkey_entry *found;\n\n\tfor (i = 0; type[i] != -1; i++) {\n\t\tif (type[i] == key->type)\n\t\t\tcontinue;\n\t\tif (!lookup_key_in_hostkeys_by_type(hostkeys, type[i],\n\t\t    -1, &found))\n\t\t\tcontinue;\n\t\tfp = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n\t\tra = sshkey_fingerprint(found->key,\n\t\t    options.fingerprint_hash, SSH_FP_RANDOMART);\n\t\tif (fp == NULL || ra == NULL)\n\t\t\tfatal_f(\"sshkey_fingerprint fail\");\n\t\tlogit(\"WARNING: %s key found for host %s\\n\"\n\t\t    \"in %s:%lu\\n\"\n\t\t    \"%s key fingerprint %s.\",\n\t\t    sshkey_type(found->key),\n\t\t    found->host, found->file, found->line,\n\t\t    sshkey_type(found->key), fp);\n\t\tif (options.visual_host_key)\n\t\t\tlogit(\"%s\", ra);\n\t\tfree(ra);\n\t\tfree(fp);\n\t\tret = 1;\n\t}\n\treturn ret;\n}\n\nstatic void\nwarn_changed_key(struct sshkey *host_key)\n{\n\tchar *fp;\n\n\tfp = sshkey_fingerprint(host_key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT);\n\tif (fp == NULL)\n\t\tfatal_f(\"sshkey_fingerprint fail\");\n\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\");\n\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n\terror(\"IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\");\n\terror(\"Someone could be eavesdropping on you right now (man-in-the-middle attack)!\");\n\terror(\"It is also possible that a host key has just been changed.\");\n\terror(\"The fingerprint for the %s key sent by the remote host is\\n%s.\",\n\t    sshkey_type(host_key), fp);\n\terror(\"Please contact your system administrator.\");\n\n\tfree(fp);\n}\n\n \nint\nssh_local_cmd(const char *args)\n{\n\tchar *shell;\n\tpid_t pid;\n\tint status;\n\tvoid (*osighand)(int);\n\n\tif (!options.permit_local_command ||\n\t    args == NULL || !*args)\n\t\treturn (1);\n\n\tif ((shell = getenv(\"SHELL\")) == NULL || *shell == '\\0')\n\t\tshell = _PATH_BSHELL;\n\n\tosighand = ssh_signal(SIGCHLD, SIG_DFL);\n\tpid = fork();\n\tif (pid == 0) {\n\t\tssh_signal(SIGPIPE, SIG_DFL);\n\t\tdebug3(\"Executing %s -c \\\"%s\\\"\", shell, args);\n\t\texecl(shell, shell, \"-c\", args, (char *)NULL);\n\t\terror(\"Couldn't execute %s -c \\\"%s\\\": %s\",\n\t\t    shell, args, strerror(errno));\n\t\t_exit(1);\n\t} else if (pid == -1)\n\t\tfatal(\"fork failed: %.100s\", strerror(errno));\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"Couldn't wait for child: %s\", strerror(errno));\n\tssh_signal(SIGCHLD, osighand);\n\n\tif (!WIFEXITED(status))\n\t\treturn (1);\n\n\treturn (WEXITSTATUS(status));\n}\n\nvoid\nmaybe_add_key_to_agent(const char *authfile, struct sshkey *private,\n    const char *comment, const char *passphrase)\n{\n\tint auth_sock = -1, r;\n\tconst char *skprovider = NULL;\n\n\tif (options.add_keys_to_agent == 0)\n\t\treturn;\n\n\tif ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {\n\t\tdebug3(\"no authentication agent, not adding key\");\n\t\treturn;\n\t}\n\n\tif (options.add_keys_to_agent == 2 &&\n\t    !ask_permission(\"Add key %s (%s) to agent?\", authfile, comment)) {\n\t\tdebug3(\"user denied adding this key\");\n\t\tclose(auth_sock);\n\t\treturn;\n\t}\n\tif (sshkey_is_sk(private))\n\t\tskprovider = options.sk_provider;\n\tif ((r = ssh_add_identity_constrained(auth_sock, private,\n\t    comment == NULL ? authfile : comment,\n\t    options.add_keys_to_agent_lifespan,\n\t    (options.add_keys_to_agent == 3), 0, skprovider, NULL, 0)) == 0)\n\t\tdebug(\"identity added to agent: %s\", authfile);\n\telse\n\t\tdebug(\"could not add identity to agent: %s (%d)\", authfile, r);\n\tclose(auth_sock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}