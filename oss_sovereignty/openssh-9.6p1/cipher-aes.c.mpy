{
  "module_name": "cipher-aes.c",
  "hash_id": "8e2f88da2e52463940240c9c0df68b147ca38be4ae735167a55f23155b85c619",
  "original_prompt": "Ingested from openssh-9.6p1/cipher-aes.c",
  "human_readable_source": " \n\n#include \"includes.h\"\n\n \n#include \"openbsd-compat/openssl-compat.h\"\n\n#ifdef USE_BUILTIN_RIJNDAEL\n#include <sys/types.h>\n\n#include <openssl/evp.h>\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"rijndael.h\"\n#include \"xmalloc.h\"\n#include \"log.h\"\n\n#define RIJNDAEL_BLOCKSIZE 16\nstruct ssh_rijndael_ctx\n{\n\trijndael_ctx\tr_ctx;\n\tu_char\t\tr_iv[RIJNDAEL_BLOCKSIZE];\n};\n\nstatic int\nssh_rijndael_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,\n    int enc)\n{\n\tstruct ssh_rijndael_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {\n\t\tc = xmalloc(sizeof(*c));\n\t\tEVP_CIPHER_CTX_set_app_data(ctx, c);\n\t}\n\tif (key != NULL) {\n\t\tif (enc == -1)\n\t\t\tenc = ctx->encrypt;\n\t\trijndael_set_key(&c->r_ctx, (u_char *)key,\n\t\t    8*EVP_CIPHER_CTX_key_length(ctx), enc);\n\t}\n\tif (iv != NULL)\n\t\tmemcpy(c->r_iv, iv, RIJNDAEL_BLOCKSIZE);\n\treturn (1);\n}\n\nstatic int\nssh_rijndael_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src,\n    size_t len)\n{\n\tstruct ssh_rijndael_ctx *c;\n\tu_char buf[RIJNDAEL_BLOCKSIZE];\n\tu_char *cprev, *cnow, *plain, *ivp;\n\tint i, j, blocks = len / RIJNDAEL_BLOCKSIZE;\n\n\tif (len == 0)\n\t\treturn (1);\n\tif (len % RIJNDAEL_BLOCKSIZE)\n\t\tfatal(\"ssh_rijndael_cbc: bad len %d\", len);\n\tif ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL) {\n\t\terror(\"ssh_rijndael_cbc: no context\");\n\t\treturn (0);\n\t}\n\tif (ctx->encrypt) {\n\t\tcnow  = dest;\n\t\tplain = (u_char *)src;\n\t\tcprev = c->r_iv;\n\t\tfor (i = 0; i < blocks; i++, plain+=RIJNDAEL_BLOCKSIZE,\n\t\t    cnow+=RIJNDAEL_BLOCKSIZE) {\n\t\t\tfor (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)\n\t\t\t\tbuf[j] = plain[j] ^ cprev[j];\n\t\t\trijndael_encrypt(&c->r_ctx, buf, cnow);\n\t\t\tcprev = cnow;\n\t\t}\n\t\tmemcpy(c->r_iv, cprev, RIJNDAEL_BLOCKSIZE);\n\t} else {\n\t\tcnow  = (u_char *) (src+len-RIJNDAEL_BLOCKSIZE);\n\t\tplain = dest+len-RIJNDAEL_BLOCKSIZE;\n\n\t\tmemcpy(buf, cnow, RIJNDAEL_BLOCKSIZE);\n\t\tfor (i = blocks; i > 0; i--, cnow-=RIJNDAEL_BLOCKSIZE,\n\t\t    plain-=RIJNDAEL_BLOCKSIZE) {\n\t\t\trijndael_decrypt(&c->r_ctx, cnow, plain);\n\t\t\tivp = (i == 1) ? c->r_iv : cnow-RIJNDAEL_BLOCKSIZE;\n\t\t\tfor (j = 0; j < RIJNDAEL_BLOCKSIZE; j++)\n\t\t\t\tplain[j] ^= ivp[j];\n\t\t}\n\t\tmemcpy(c->r_iv, buf, RIJNDAEL_BLOCKSIZE);\n\t}\n\treturn (1);\n}\n\nstatic int\nssh_rijndael_cleanup(EVP_CIPHER_CTX *ctx)\n{\n\tstruct ssh_rijndael_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {\n\t\tmemset(c, 0, sizeof(*c));\n\t\tfree(c);\n\t\tEVP_CIPHER_CTX_set_app_data(ctx, NULL);\n\t}\n\treturn (1);\n}\n\nvoid\nssh_rijndael_iv(EVP_CIPHER_CTX *evp, int doset, u_char * iv, u_int len)\n{\n\tstruct ssh_rijndael_ctx *c;\n\n\tif ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)\n\t\tfatal(\"ssh_rijndael_iv: no context\");\n\tif (doset)\n\t\tmemcpy(c->r_iv, iv, len);\n\telse\n\t\tmemcpy(iv, c->r_iv, len);\n}\n\nconst EVP_CIPHER *\nevp_rijndael(void)\n{\n\tstatic EVP_CIPHER rijndal_cbc;\n\n\tmemset(&rijndal_cbc, 0, sizeof(EVP_CIPHER));\n\trijndal_cbc.nid = NID_undef;\n\trijndal_cbc.block_size = RIJNDAEL_BLOCKSIZE;\n\trijndal_cbc.iv_len = RIJNDAEL_BLOCKSIZE;\n\trijndal_cbc.key_len = 16;\n\trijndal_cbc.init = ssh_rijndael_init;\n\trijndal_cbc.cleanup = ssh_rijndael_cleanup;\n\trijndal_cbc.do_cipher = ssh_rijndael_cbc;\n#ifndef SSH_OLD_EVP\n\trijndal_cbc.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH |\n\t    EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CUSTOM_IV;\n#endif\n\treturn (&rijndal_cbc);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}