{
  "module_name": "monitor.c",
  "hash_id": "ff7be9029f68547fe8fb3e8e32c0d0c546e7a1694fbedeef9680318c3abc9b16",
  "original_prompt": "Ingested from openssh-9.6p1/monitor.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#include <pwd.h>\n#include <signal.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <unistd.h>\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#else\n# ifdef HAVE_SYS_POLL_H\n#  include <sys/poll.h>\n# endif\n#endif\n\n#ifdef WITH_OPENSSL\n#include <openssl/dh.h>\n#endif\n\n#include \"openbsd-compat/sys-tree.h\"\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include \"atomicio.h\"\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"cipher.h\"\n#include \"kex.h\"\n#include \"dh.h\"\n#include \"auth-pam.h\"\n#include \"packet.h\"\n#include \"auth-options.h\"\n#include \"sshpty.h\"\n#include \"channels.h\"\n#include \"session.h\"\n#include \"sshlogin.h\"\n#include \"canohost.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"monitor.h\"\n#ifdef GSSAPI\n#include \"ssh-gss.h\"\n#endif\n#include \"monitor_wrap.h\"\n#include \"monitor_fdpass.h\"\n#include \"compat.h\"\n#include \"ssh2.h\"\n#include \"authfd.h\"\n#include \"match.h\"\n#include \"ssherr.h\"\n#include \"sk-api.h\"\n\n#ifdef GSSAPI\nstatic Gssctxt *gsscontext = NULL;\n#endif\n\n \nextern ServerOptions options;\nextern u_int utmp_len;\nextern struct sshbuf *loginmsg;\nextern struct sshauthopt *auth_opts;  \n\n \nstatic struct sshbuf *child_state;\n\n \n\nint mm_answer_moduli(struct ssh *, int, struct sshbuf *);\nint mm_answer_sign(struct ssh *, int, struct sshbuf *);\nint mm_answer_pwnamallow(struct ssh *, int, struct sshbuf *);\nint mm_answer_auth2_read_banner(struct ssh *, int, struct sshbuf *);\nint mm_answer_authserv(struct ssh *, int, struct sshbuf *);\nint mm_answer_authpassword(struct ssh *, int, struct sshbuf *);\nint mm_answer_bsdauthquery(struct ssh *, int, struct sshbuf *);\nint mm_answer_bsdauthrespond(struct ssh *, int, struct sshbuf *);\nint mm_answer_keyallowed(struct ssh *, int, struct sshbuf *);\nint mm_answer_keyverify(struct ssh *, int, struct sshbuf *);\nint mm_answer_pty(struct ssh *, int, struct sshbuf *);\nint mm_answer_pty_cleanup(struct ssh *, int, struct sshbuf *);\nint mm_answer_term(struct ssh *, int, struct sshbuf *);\nint mm_answer_sesskey(struct ssh *, int, struct sshbuf *);\nint mm_answer_sessid(struct ssh *, int, struct sshbuf *);\n\n#ifdef USE_PAM\nint mm_answer_pam_start(struct ssh *, int, struct sshbuf *);\nint mm_answer_pam_account(struct ssh *, int, struct sshbuf *);\nint mm_answer_pam_init_ctx(struct ssh *, int, struct sshbuf *);\nint mm_answer_pam_query(struct ssh *, int, struct sshbuf *);\nint mm_answer_pam_respond(struct ssh *, int, struct sshbuf *);\nint mm_answer_pam_free_ctx(struct ssh *, int, struct sshbuf *);\n#endif\n\n#ifdef GSSAPI\nint mm_answer_gss_setup_ctx(struct ssh *, int, struct sshbuf *);\nint mm_answer_gss_accept_ctx(struct ssh *, int, struct sshbuf *);\nint mm_answer_gss_userok(struct ssh *, int, struct sshbuf *);\nint mm_answer_gss_checkmic(struct ssh *, int, struct sshbuf *);\n#endif\n\n#ifdef SSH_AUDIT_EVENTS\nint mm_answer_audit_event(struct ssh *, int, struct sshbuf *);\nint mm_answer_audit_command(struct ssh *, int, struct sshbuf *);\n#endif\n\nstatic Authctxt *authctxt;\n\n \nstatic u_char *key_blob = NULL;\nstatic size_t key_bloblen = 0;\nstatic u_int key_blobtype = MM_NOKEY;\nstatic struct sshauthopt *key_opts = NULL;\nstatic char *hostbased_cuser = NULL;\nstatic char *hostbased_chost = NULL;\nstatic char *auth_method = \"unknown\";\nstatic char *auth_submethod = NULL;\nstatic u_int session_id2_len = 0;\nstatic u_char *session_id2 = NULL;\nstatic pid_t monitor_child_pid;\n\nstruct mon_table {\n\tenum monitor_reqtype type;\n\tint flags;\n\tint (*f)(struct ssh *, int, struct sshbuf *);\n};\n\n#define MON_ISAUTH\t0x0004\t \n#define MON_AUTHDECIDE\t0x0008\t \n#define MON_ONCE\t0x0010\t \n#define MON_ALOG\t0x0020\t \n\n#define MON_AUTH\t(MON_ISAUTH|MON_AUTHDECIDE)\n\n#define MON_PERMIT\t0x1000\t \n\nstatic int monitor_read(struct ssh *, struct monitor *, struct mon_table *,\n    struct mon_table **);\nstatic int monitor_read_log(struct monitor *);\n\nstruct mon_table mon_dispatch_proto20[] = {\n#ifdef WITH_OPENSSL\n    {MONITOR_REQ_MODULI, MON_ONCE, mm_answer_moduli},\n#endif\n    {MONITOR_REQ_SIGN, MON_ONCE, mm_answer_sign},\n    {MONITOR_REQ_PWNAM, MON_ONCE, mm_answer_pwnamallow},\n    {MONITOR_REQ_AUTHSERV, MON_ONCE, mm_answer_authserv},\n    {MONITOR_REQ_AUTH2_READ_BANNER, MON_ONCE, mm_answer_auth2_read_banner},\n    {MONITOR_REQ_AUTHPASSWORD, MON_AUTH, mm_answer_authpassword},\n#ifdef USE_PAM\n    {MONITOR_REQ_PAM_START, MON_ONCE, mm_answer_pam_start},\n    {MONITOR_REQ_PAM_ACCOUNT, 0, mm_answer_pam_account},\n    {MONITOR_REQ_PAM_INIT_CTX, MON_ONCE, mm_answer_pam_init_ctx},\n    {MONITOR_REQ_PAM_QUERY, 0, mm_answer_pam_query},\n    {MONITOR_REQ_PAM_RESPOND, MON_ONCE, mm_answer_pam_respond},\n    {MONITOR_REQ_PAM_FREE_CTX, MON_ONCE|MON_AUTHDECIDE, mm_answer_pam_free_ctx},\n#endif\n#ifdef SSH_AUDIT_EVENTS\n    {MONITOR_REQ_AUDIT_EVENT, MON_PERMIT, mm_answer_audit_event},\n#endif\n#ifdef BSD_AUTH\n    {MONITOR_REQ_BSDAUTHQUERY, MON_ISAUTH, mm_answer_bsdauthquery},\n    {MONITOR_REQ_BSDAUTHRESPOND, MON_AUTH, mm_answer_bsdauthrespond},\n#endif\n    {MONITOR_REQ_KEYALLOWED, MON_ISAUTH, mm_answer_keyallowed},\n    {MONITOR_REQ_KEYVERIFY, MON_AUTH, mm_answer_keyverify},\n#ifdef GSSAPI\n    {MONITOR_REQ_GSSSETUP, MON_ISAUTH, mm_answer_gss_setup_ctx},\n    {MONITOR_REQ_GSSSTEP, 0, mm_answer_gss_accept_ctx},\n    {MONITOR_REQ_GSSUSEROK, MON_ONCE|MON_AUTHDECIDE, mm_answer_gss_userok},\n    {MONITOR_REQ_GSSCHECKMIC, MON_ONCE, mm_answer_gss_checkmic},\n#endif\n    {0, 0, NULL}\n};\n\nstruct mon_table mon_dispatch_postauth20[] = {\n#ifdef WITH_OPENSSL\n    {MONITOR_REQ_MODULI, 0, mm_answer_moduli},\n#endif\n    {MONITOR_REQ_SIGN, 0, mm_answer_sign},\n    {MONITOR_REQ_PTY, 0, mm_answer_pty},\n    {MONITOR_REQ_PTYCLEANUP, 0, mm_answer_pty_cleanup},\n    {MONITOR_REQ_TERM, 0, mm_answer_term},\n#ifdef SSH_AUDIT_EVENTS\n    {MONITOR_REQ_AUDIT_EVENT, MON_PERMIT, mm_answer_audit_event},\n    {MONITOR_REQ_AUDIT_COMMAND, MON_PERMIT, mm_answer_audit_command},\n#endif\n    {0, 0, NULL}\n};\n\nstruct mon_table *mon_dispatch;\n\n \nstatic void\nmonitor_permit(struct mon_table *ent, enum monitor_reqtype type, int permit)\n{\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t\treturn;\n\t\t}\n\t\tent++;\n\t}\n}\n\nstatic void\nmonitor_permit_authentications(int permit)\n{\n\tstruct mon_table *ent = mon_dispatch;\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->flags & MON_AUTH) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t}\n\t\tent++;\n\t}\n}\n\nvoid\nmonitor_child_preauth(struct ssh *ssh, struct monitor *pmonitor)\n{\n\tstruct mon_table *ent;\n\tint authenticated = 0, partial = 0;\n\n\tdebug3(\"preauth child monitor started\");\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_log_sendfd = pmonitor->m_recvfd = -1;\n\n\tauthctxt = (Authctxt *)ssh->authctxt;\n\tmemset(authctxt, 0, sizeof(*authctxt));\n\tssh->authctxt = authctxt;\n\n\tauthctxt->loginmsg = loginmsg;\n\n\tmon_dispatch = mon_dispatch_proto20;\n\t \n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\n\t \n\twhile (!authenticated) {\n\t\tpartial = 0;\n\t\tauth_method = \"unknown\";\n\t\tauth_submethod = NULL;\n\t\tauth2_authctxt_reset_info(authctxt);\n\n\t\tauthenticated = (monitor_read(ssh, pmonitor,\n\t\t    mon_dispatch, &ent) == 1);\n\n\t\t \n\t\tif (options.num_auth_methods != 0) {\n\t\t\tif (authenticated &&\n\t\t\t    !auth2_update_methods_lists(authctxt,\n\t\t\t    auth_method, auth_submethod)) {\n\t\t\t\tdebug3_f(\"method %s: partial\", auth_method);\n\t\t\t\tauthenticated = 0;\n\t\t\t\tpartial = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (authenticated) {\n\t\t\tif (!(ent->flags & MON_AUTHDECIDE))\n\t\t\t\tfatal_f(\"unexpected authentication from %d\",\n\t\t\t\t    ent->type);\n\t\t\tif (authctxt->pw->pw_uid == 0 &&\n\t\t\t    !auth_root_allowed(ssh, auth_method))\n\t\t\t\tauthenticated = 0;\n#ifdef USE_PAM\n\t\t\t \n\t\t\tif (options.use_pam && authenticated) {\n\t\t\t\tstruct sshbuf *m;\n\n\t\t\t\tif ((m = sshbuf_new()) == NULL)\n\t\t\t\t\tfatal(\"%s: sshbuf_new failed\",\n\t\t\t\t\t    __func__);\n\t\t\t\tmm_request_receive_expect(pmonitor->m_sendfd,\n\t\t\t\t    MONITOR_REQ_PAM_ACCOUNT, m);\n\t\t\t\tauthenticated = mm_answer_pam_account(\n\t\t\t\t    ssh, pmonitor->m_sendfd, m);\n\t\t\t\tsshbuf_free(m);\n\t\t\t}\n#endif\n\t\t}\n\t\tif (ent->flags & (MON_AUTHDECIDE|MON_ALOG)) {\n\t\t\tauth_log(ssh, authenticated, partial,\n\t\t\t    auth_method, auth_submethod);\n\t\t\tif (!partial && !authenticated)\n\t\t\t\tauthctxt->failures++;\n\t\t\tif (authenticated || partial) {\n\t\t\t\tauth2_update_session_info(authctxt,\n\t\t\t\t    auth_method, auth_submethod);\n\t\t\t}\n\t\t}\n\t\tif (authctxt->failures > options.max_authtries) {\n\t\t\t \n\t\t\tfatal_f(\"privsep child made too many authentication \"\n\t\t\t    \"attempts\");\n\t\t}\n\t}\n\n\tif (!authctxt->valid)\n\t\tfatal_f(\"authenticated invalid user\");\n\tif (strcmp(auth_method, \"unknown\") == 0)\n\t\tfatal_f(\"authentication method name unknown\");\n\n\tdebug_f(\"user %s authenticated by privileged process\", authctxt->user);\n\tssh->authctxt = NULL;\n\tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n\n\tmm_get_keystate(ssh, pmonitor);\n\n\t \n\twhile (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)\n\t\t;\n\n\tif (pmonitor->m_recvfd >= 0)\n\t\tclose(pmonitor->m_recvfd);\n\tif (pmonitor->m_log_sendfd >= 0)\n\t\tclose(pmonitor->m_log_sendfd);\n\tpmonitor->m_sendfd = pmonitor->m_log_recvfd = -1;\n}\n\nstatic void\nmonitor_set_child_handler(pid_t pid)\n{\n\tmonitor_child_pid = pid;\n}\n\nstatic void\nmonitor_child_handler(int sig)\n{\n\tkill(monitor_child_pid, sig);\n}\n\nvoid\nmonitor_child_postauth(struct ssh *ssh, struct monitor *pmonitor)\n{\n\tclose(pmonitor->m_recvfd);\n\tpmonitor->m_recvfd = -1;\n\n\tmonitor_set_child_handler(pmonitor->m_pid);\n\tssh_signal(SIGHUP, &monitor_child_handler);\n\tssh_signal(SIGTERM, &monitor_child_handler);\n\tssh_signal(SIGINT, &monitor_child_handler);\n#ifdef SIGXFSZ\n\tssh_signal(SIGXFSZ, SIG_IGN);\n#endif\n\n\tmon_dispatch = mon_dispatch_postauth20;\n\n\t \n\tmonitor_permit(mon_dispatch, MONITOR_REQ_MODULI, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_SIGN, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_TERM, 1);\n\n\tif (auth_opts->permit_pty_flag) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PTY, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PTYCLEANUP, 1);\n\t}\n\n\tfor (;;)\n\t\tmonitor_read(ssh, pmonitor, mon_dispatch, NULL);\n}\n\nstatic int\nmonitor_read_log(struct monitor *pmonitor)\n{\n\tstruct sshbuf *logmsg;\n\tu_int len, level, forced;\n\tchar *msg;\n\tu_char *p;\n\tint r;\n\n\tif ((logmsg = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\n\t \n\tif ((r = sshbuf_reserve(logmsg, 4, &p)) != 0)\n\t\tfatal_fr(r, \"reserve len\");\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, 4) != 4) {\n\t\tif (errno == EPIPE) {\n\t\t\tsshbuf_free(logmsg);\n\t\t\tdebug_f(\"child log fd closed\");\n\t\t\tclose(pmonitor->m_log_recvfd);\n\t\t\tpmonitor->m_log_recvfd = -1;\n\t\t\treturn -1;\n\t\t}\n\t\tfatal_f(\"log fd read: %s\", strerror(errno));\n\t}\n\tif ((r = sshbuf_get_u32(logmsg, &len)) != 0)\n\t\tfatal_fr(r, \"parse len\");\n\tif (len <= 4 || len > 8192)\n\t\tfatal_f(\"invalid log message length %u\", len);\n\n\t \n\tsshbuf_reset(logmsg);\n\tif ((r = sshbuf_reserve(logmsg, len, &p)) != 0)\n\t\tfatal_fr(r, \"reserve msg\");\n\tif (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)\n\t\tfatal_f(\"log fd read: %s\", strerror(errno));\n\tif ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||\n\t    (r = sshbuf_get_u32(logmsg, &forced)) != 0 ||\n\t    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\t \n\tif (log_level_name(level) == NULL)\n\t\tfatal_f(\"invalid log level %u (corrupted message?)\", level);\n\tsshlogdirect(level, forced, \"%s [preauth]\", msg);\n\n\tsshbuf_free(logmsg);\n\tfree(msg);\n\n\treturn 0;\n}\n\nstatic int\nmonitor_read(struct ssh *ssh, struct monitor *pmonitor, struct mon_table *ent,\n    struct mon_table **pent)\n{\n\tstruct sshbuf *m;\n\tint r, ret;\n\tu_char type;\n\tstruct pollfd pfd[2];\n\n\tfor (;;) {\n\t\tmemset(&pfd, 0, sizeof(pfd));\n\t\tpfd[0].fd = pmonitor->m_sendfd;\n\t\tpfd[0].events = POLLIN;\n\t\tpfd[1].fd = pmonitor->m_log_recvfd;\n\t\tpfd[1].events = pfd[1].fd == -1 ? 0 : POLLIN;\n\t\tif (poll(pfd, pfd[1].fd == -1 ? 1 : 2, -1) == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tfatal_f(\"poll: %s\", strerror(errno));\n\t\t}\n\t\tif (pfd[1].revents) {\n\t\t\t \n\t\t\tmonitor_read_log(pmonitor);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pfd[0].revents)\n\t\t\tbreak;   \n\t}\n\n\tif ((m = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\n\tmm_request_receive(pmonitor->m_sendfd, m);\n\tif ((r = sshbuf_get_u8(m, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\n\tdebug3_f(\"checking request %d\", type);\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->type == type)\n\t\t\tbreak;\n\t\tent++;\n\t}\n\n\tif (ent->f != NULL) {\n\t\tif (!(ent->flags & MON_PERMIT))\n\t\t\tfatal_f(\"unpermitted request %d\", type);\n\t\tret = (*ent->f)(ssh, pmonitor->m_sendfd, m);\n\t\tsshbuf_free(m);\n\n\t\t \n\t\tif (ent->flags & MON_ONCE) {\n\t\t\tdebug2_f(\"%d used once, disabling now\", type);\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t}\n\n\t\tif (pent != NULL)\n\t\t\t*pent = ent;\n\n\t\treturn ret;\n\t}\n\n\tfatal_f(\"unsupported request: %d\", type);\n\n\t \n\treturn (-1);\n}\n\n \nstatic int\nmonitor_allowed_key(const u_char *blob, u_int bloblen)\n{\n\t \n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    timingsafe_bcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}\n\nstatic void\nmonitor_reset_key_state(void)\n{\n\t \n\tfree(key_blob);\n\tfree(hostbased_cuser);\n\tfree(hostbased_chost);\n\tsshauthopt_free(key_opts);\n\tkey_blob = NULL;\n\tkey_bloblen = 0;\n\tkey_blobtype = MM_NOKEY;\n\tkey_opts = NULL;\n\thostbased_cuser = NULL;\n\thostbased_chost = NULL;\n}\n\n#ifdef WITH_OPENSSL\nint\nmm_answer_moduli(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tDH *dh;\n\tconst BIGNUM *dh_p, *dh_g;\n\tint r;\n\tu_int min, want, max;\n\n\tif ((r = sshbuf_get_u32(m, &min)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &want)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &max)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tdebug3_f(\"got parameters: %d %d %d\", min, want, max);\n\t \n\tif (max < min || want < min || max < want)\n\t\tfatal_f(\"bad parameters: %d %d %d\", min, want, max);\n\n\tsshbuf_reset(m);\n\n\tdh = choose_dh(min, want, max);\n\tif (dh == NULL) {\n\t\tif ((r = sshbuf_put_u8(m, 0)) != 0)\n\t\t\tfatal_fr(r, \"assemble empty\");\n\t\treturn (0);\n\t} else {\n\t\t \n\t\tDH_get0_pqg(dh, &dh_p, NULL, &dh_g);\n\t\tif ((r = sshbuf_put_u8(m, 1)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(m, dh_p)) != 0 ||\n\t\t    (r = sshbuf_put_bignum2(m, dh_g)) != 0)\n\t\t\tfatal_fr(r, \"assemble\");\n\n\t\tDH_free(dh);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_MODULI, m);\n\treturn (0);\n}\n#endif\n\nint\nmm_answer_sign(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\textern int auth_sock;\t\t\t \n\tstruct sshkey *key;\n\tstruct sshbuf *sigbuf = NULL;\n\tu_char *p = NULL, *signature = NULL;\n\tchar *alg = NULL;\n\tsize_t datlen, siglen, alglen;\n\tint r, is_proof = 0;\n\tu_int keyid, compat;\n\tconst char proof_req[] = \"hostkeys-prove-00@openssh.com\";\n\n\tdebug3_f(\"entering\");\n\n\tif ((r = sshbuf_get_u32(m, &keyid)) != 0 ||\n\t    (r = sshbuf_get_string(m, &p, &datlen)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &alg, &alglen)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &compat)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tif (keyid > INT_MAX)\n\t\tfatal_f(\"invalid key ID\");\n\n\t \n\tif (datlen != 20 && datlen != 32 && datlen != 48 && datlen != 64) {\n\t\t \n\t\tif (session_id2_len == 0)  \n\t\t\tfatal_f(\"bad data length: %zu\", datlen);\n\t\tif ((key = get_hostkey_public_by_index(keyid, ssh)) == NULL)\n\t\t\tfatal_f(\"no hostkey for index %d\", keyid);\n\t\tif ((sigbuf = sshbuf_new()) == NULL)\n\t\t\tfatal_f(\"sshbuf_new\");\n\t\tif ((r = sshbuf_put_cstring(sigbuf, proof_req)) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf, session_id2,\n\t\t    session_id2_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0)\n\t\t\tfatal_fr(r, \"assemble private key proof\");\n\t\tif (datlen != sshbuf_len(sigbuf) ||\n\t\t    memcmp(p, sshbuf_ptr(sigbuf), sshbuf_len(sigbuf)) != 0)\n\t\t\tfatal_f(\"bad data length: %zu, hostkey proof len %zu\",\n\t\t\t    datlen, sshbuf_len(sigbuf));\n\t\tsshbuf_free(sigbuf);\n\t\tis_proof = 1;\n\t}\n\n\t \n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\n\tif ((key = get_hostkey_by_index(keyid)) != NULL) {\n\t\tif ((r = sshkey_sign(key, &signature, &siglen, p, datlen, alg,\n\t\t    options.sk_provider, NULL, compat)) != 0)\n\t\t\tfatal_fr(r, \"sign\");\n\t} else if ((key = get_hostkey_public_by_index(keyid, ssh)) != NULL &&\n\t    auth_sock > 0) {\n\t\tif ((r = ssh_agent_sign(auth_sock, key, &signature, &siglen,\n\t\t    p, datlen, alg, compat)) != 0)\n\t\t\tfatal_fr(r, \"agent sign\");\n\t} else\n\t\tfatal_f(\"no hostkey from index %d\", keyid);\n\n\tdebug3_f(\"%s %s signature len=%zu\", alg,\n\t    is_proof ? \"hostkey proof\" : \"KEX\", siglen);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_string(m, signature, siglen)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tfree(alg);\n\tfree(p);\n\tfree(signature);\n\n\tmm_request_send(sock, MONITOR_ANS_SIGN, m);\n\n\t \n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\n\treturn (0);\n}\n\n#define PUTPW(b, id) \\\n\tdo { \\\n\t\tif ((r = sshbuf_put_string(b, \\\n\t\t    &pwent->id, sizeof(pwent->id))) != 0) \\\n\t\t\tfatal_fr(r, \"assemble %s\", #id); \\\n\t} while (0)\n\n \nint\nmm_answer_pwnamallow(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tstruct passwd *pwent;\n\tint r, allowed = 0;\n\tu_int i;\n\n\tdebug3_f(\"entering\");\n\n\tif (authctxt->attempt++ != 0)\n\t\tfatal_f(\"multiple attempts for getpwnam\");\n\n\tif ((r = sshbuf_get_cstring(m, &authctxt->user, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tpwent = getpwnamallow(ssh, authctxt->user);\n\n\tsetproctitle(\"%s [priv]\", pwent ? authctxt->user : \"unknown\");\n\n\tsshbuf_reset(m);\n\n\tif (pwent == NULL) {\n\t\tif ((r = sshbuf_put_u8(m, 0)) != 0)\n\t\t\tfatal_fr(r, \"assemble fakepw\");\n\t\tauthctxt->pw = fakepw();\n\t\tgoto out;\n\t}\n\n\tallowed = 1;\n\tauthctxt->pw = pwent;\n\tauthctxt->valid = 1;\n\n\t \n\tif ((r = sshbuf_put_u8(m, 1)) != 0)\n\t\tfatal_fr(r, \"assemble ok\");\n\tPUTPW(m, pw_uid);\n\tPUTPW(m, pw_gid);\n#ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n\tPUTPW(m, pw_change);\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n\tPUTPW(m, pw_expire);\n#endif\n\tif ((r = sshbuf_put_cstring(m, pwent->pw_name)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, \"*\")) != 0 ||\n#ifdef HAVE_STRUCT_PASSWD_PW_GECOS\n\t    (r = sshbuf_put_cstring(m, pwent->pw_gecos)) != 0 ||\n#endif\n#ifdef HAVE_STRUCT_PASSWD_PW_CLASS\n\t    (r = sshbuf_put_cstring(m, pwent->pw_class)) != 0 ||\n#endif\n\t    (r = sshbuf_put_cstring(m, pwent->pw_dir)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, pwent->pw_shell)) != 0)\n\t\tfatal_fr(r, \"assemble pw\");\n\n out:\n\tssh_packet_set_log_preamble(ssh, \"%suser %s\",\n\t    authctxt->valid ? \"authenticating\" : \"invalid \", authctxt->user);\n\tif ((r = sshbuf_put_string(m, &options, sizeof(options))) != 0)\n\t\tfatal_fr(r, \"assemble options\");\n\n#define M_CP_STROPT(x) do { \\\n\t\tif (options.x != NULL && \\\n\t\t    (r = sshbuf_put_cstring(m, options.x)) != 0) \\\n\t\t\tfatal_fr(r, \"assemble %s\", #x); \\\n\t} while (0)\n#define M_CP_STRARRAYOPT(x, nx) do { \\\n\t\tfor (i = 0; i < options.nx; i++) { \\\n\t\t\tif ((r = sshbuf_put_cstring(m, options.x[i])) != 0) \\\n\t\t\t\tfatal_fr(r, \"assemble %s\", #x); \\\n\t\t} \\\n\t} while (0)\n\t \n\tCOPY_MATCH_STRING_OPTS();\n#undef M_CP_STROPT\n#undef M_CP_STRARRAYOPT\n\n\t \n\tif (auth2_setup_methods_lists(authctxt) != 0) {\n\t\t \n\t\tdebug_f(\"no valid authentication method lists\");\n\t}\n\n\tdebug3_f(\"sending MONITOR_ANS_PWNAM: %d\", allowed);\n\tmm_request_send(sock, MONITOR_ANS_PWNAM, m);\n\n\t \n\tmonitor_permit(mon_dispatch, MONITOR_REQ_AUTHSERV, 1);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_AUTH2_READ_BANNER, 1);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_START, 1);\n#endif\n\n\treturn (0);\n}\n\nint mm_answer_auth2_read_banner(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tchar *banner;\n\tint r;\n\n\tsshbuf_reset(m);\n\tbanner = auth2_read_banner();\n\tif ((r = sshbuf_put_cstring(m, banner != NULL ? banner : \"\")) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tmm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);\n\tfree(banner);\n\n\treturn (0);\n}\n\nint\nmm_answer_authserv(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tint r;\n\n\tmonitor_permit_authentications(1);\n\n\tif ((r = sshbuf_get_cstring(m, &authctxt->service, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &authctxt->style, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tdebug3_f(\"service=%s, style=%s\", authctxt->service, authctxt->style);\n\n\tif (strlen(authctxt->style) == 0) {\n\t\tfree(authctxt->style);\n\t\tauthctxt->style = NULL;\n\t}\n\n\treturn (0);\n}\n\n \nstatic int\nkey_base_type_match(const char *method, const struct sshkey *key,\n    const char *list)\n{\n\tchar *s, *l, *ol = xstrdup(list);\n\tint found = 0;\n\n\tl = ol;\n\tfor ((s = strsep(&l, \",\")); s && *s != '\\0'; (s = strsep(&l, \",\"))) {\n\t\tif (sshkey_type_from_name(s) == key->type) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\terror(\"%s key type %s is not in permitted list %s\", method,\n\t\t    sshkey_ssh_name(key), list);\n\t}\n\n\tfree(ol);\n\treturn found;\n}\n\nint\nmm_answer_authpassword(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tstatic int call_count;\n\tchar *passwd;\n\tint r, authenticated;\n\tsize_t plen;\n\n\tif (!options.password_authentication)\n\t\tfatal_f(\"password authentication not enabled\");\n\tif ((r = sshbuf_get_cstring(m, &passwd, &plen)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\t \n\tauthenticated = options.password_authentication &&\n\t    auth_password(ssh, passwd);\n\tfreezero(passwd, plen);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authenticated)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n#ifdef USE_PAM\n\tif ((r = sshbuf_put_u32(m, sshpam_get_maxtries_reached())) != 0)\n\t\tfatal_fr(r, \"assemble PAM\");\n#endif\n\n\tdebug3(\"%s: sending result %d\", __func__, authenticated);\n\tdebug3_f(\"sending result %d\", authenticated);\n\tmm_request_send(sock, MONITOR_ANS_AUTHPASSWORD, m);\n\n\tcall_count++;\n\tif (plen == 0 && call_count == 1)\n\t\tauth_method = \"none\";\n\telse\n\t\tauth_method = \"password\";\n\n\t \n\treturn (authenticated);\n}\n\n#ifdef BSD_AUTH\nint\nmm_answer_bsdauthquery(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tchar *name, *infotxt;\n\tu_int numprompts, *echo_on, success;\n\tchar **prompts;\n\tint r;\n\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal_f(\"kbd-int authentication not enabled\");\n\tsuccess = bsdauth_query(authctxt, &name, &infotxt, &numprompts,\n\t    &prompts, &echo_on) < 0 ? 0 : 1;\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, success)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tif (success) {\n\t\tif ((r = sshbuf_put_cstring(m, prompts[0])) != 0)\n\t\t\tfatal_fr(r, \"assemble prompt\");\n\t}\n\n\tdebug3_f(\"sending challenge success: %u\", success);\n\tmm_request_send(sock, MONITOR_ANS_BSDAUTHQUERY, m);\n\n\tif (success) {\n\t\tfree(name);\n\t\tfree(infotxt);\n\t\tfree(prompts);\n\t\tfree(echo_on);\n\t}\n\n\treturn (0);\n}\n\nint\nmm_answer_bsdauthrespond(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tchar *response;\n\tint r, authok;\n\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal_f(\"kbd-int authentication not enabled\");\n\tif (authctxt->as == NULL)\n\t\tfatal_f(\"no bsd auth session\");\n\n\tif ((r = sshbuf_get_cstring(m, &response, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tauthok = options.kbd_interactive_authentication &&\n\t    auth_userresponse(authctxt->as, response, 0);\n\tauthctxt->as = NULL;\n\tdebug3_f(\"<%s> = <%d>\", response, authok);\n\tfree(response);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authok)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tdebug3_f(\"sending authenticated: %d\", authok);\n\tmm_request_send(sock, MONITOR_ANS_BSDAUTHRESPOND, m);\n\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"bsdauth\";\n\n\treturn (authok != 0);\n}\n#endif\n\n#ifdef USE_PAM\nint\nmm_answer_pam_start(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tif (!options.use_pam)\n\t\tfatal(\"UsePAM not set, but ended up in %s anyway\", __func__);\n\n\tstart_pam(ssh);\n\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_ACCOUNT, 1);\n\tif (options.kbd_interactive_authentication)\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_INIT_CTX, 1);\n\n\treturn (0);\n}\n\nint\nmm_answer_pam_account(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tu_int ret;\n\tint r;\n\n\tif (!options.use_pam)\n\t\tfatal(\"%s: PAM not enabled\", __func__);\n\n\tret = do_pam_account();\n\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tmm_request_send(sock, MONITOR_ANS_PAM_ACCOUNT, m);\n\n\treturn (ret);\n}\n\nstatic void *sshpam_ctxt, *sshpam_authok;\nextern KbdintDevice sshpam_device;\n\nint\nmm_answer_pam_init_ctx(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tu_int ok = 0;\n\tint r;\n\n\tdebug3(\"%s\", __func__);\n\tif (!options.kbd_interactive_authentication)\n\t\tfatal(\"%s: kbd-int authentication not enabled\", __func__);\n\tif (sshpam_ctxt != NULL)\n\t\tfatal(\"%s: already called\", __func__);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tsshbuf_reset(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_QUERY, 1);\n\t\tok = 1;\n\t}\n\tif ((r = sshbuf_put_u32(m, ok)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}\n\nint\nmm_answer_pam_query(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tchar *name = NULL, *info = NULL, **prompts = NULL;\n\tu_int i, num = 0, *echo_on = 0;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tsshpam_authok = NULL;\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\tret = (sshpam_device.query)(sshpam_ctxt, &name, &info,\n\t    &num, &prompts, &echo_on);\n\tif (ret == 0 && num == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\tif (num > 1 || name == NULL || info == NULL)\n\t\tfatal(\"sshpam_device.query failed\");\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_RESPOND, 1);\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, name)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, info)) != 0 ||\n\t    (r = sshbuf_put_u32(m, sshpam_get_maxtries_reached())) != 0 ||\n\t    (r = sshbuf_put_u32(m, num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(name);\n\tfree(info);\n\tfor (i = 0; i < num; ++i) {\n\t\tif ((r = sshbuf_put_cstring(m, prompts[i])) != 0 ||\n\t\t    (r = sshbuf_put_u32(m, echo_on[i])) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tfree(prompts[i]);\n\t}\n\tfree(prompts);\n\tfree(echo_on);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\tmm_request_send(sock, MONITOR_ANS_PAM_QUERY, m);\n\treturn (0);\n}\n\nint\nmm_answer_pam_respond(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tchar **resp;\n\tu_int i, num;\n\tint r, ret;\n\n\tdebug3(\"%s\", __func__);\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\tsshpam_authok = NULL;\n\tif ((r = sshbuf_get_u32(m, &num)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (num > PAM_MAX_NUM_MSG) {\n\t\tfatal_f(\"Too many PAM messages, got %u, expected <= %u\",\n\t\t    num, (unsigned)PAM_MAX_NUM_MSG);\n\t}\n\tif (num > 0) {\n\t\tresp = xcalloc(num, sizeof(char *));\n\t\tfor (i = 0; i < num; ++i) {\n\t\t\tif ((r = sshbuf_get_cstring(m, &(resp[i]), NULL)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t}\n\t\tret = (sshpam_device.respond)(sshpam_ctxt, num, resp);\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tfree(resp[i]);\n\t\tfree(resp);\n\t} else {\n\t\tret = (sshpam_device.respond)(sshpam_ctxt, num, NULL);\n\t}\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tmm_request_send(sock, MONITOR_ANS_PAM_RESPOND, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\tif (ret == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\treturn (0);\n}\n\nint\nmm_answer_pam_free_ctx(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\tif (sshpam_ctxt == NULL)\n\t\tfatal(\"%s: no context\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tsshbuf_reset(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\t \n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_INIT_CTX, 1);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}\n#endif\n\nint\nmm_answer_keyallowed(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tstruct sshkey *key = NULL;\n\tchar *cuser, *chost;\n\tu_int pubkey_auth_attempt;\n\tu_int type = 0;\n\tint r, allowed = 0;\n\tstruct sshauthopt *opts = NULL;\n\n\tdebug3_f(\"entering\");\n\tif ((r = sshbuf_get_u32(m, &type)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &cuser, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &chost, NULL)) != 0 ||\n\t    (r = sshkey_froms(m, &key)) != 0 ||\n\t    (r = sshbuf_get_u32(m, &pubkey_auth_attempt)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (key != NULL && authctxt->valid) {\n\t\tswitch (type) {\n\t\tcase MM_USERKEY:\n\t\t\tauth_method = \"publickey\";\n\t\t\tif (!options.pubkey_authentication)\n\t\t\t\tbreak;\n\t\t\tif (auth2_key_already_used(authctxt, key))\n\t\t\t\tbreak;\n\t\t\tif (!key_base_type_match(auth_method, key,\n\t\t\t    options.pubkey_accepted_algos))\n\t\t\t\tbreak;\n\t\t\tallowed = user_key_allowed(ssh, authctxt->pw, key,\n\t\t\t    pubkey_auth_attempt, &opts);\n\t\t\tbreak;\n\t\tcase MM_HOSTKEY:\n\t\t\tauth_method = \"hostbased\";\n\t\t\tif (!options.hostbased_authentication)\n\t\t\t\tbreak;\n\t\t\tif (auth2_key_already_used(authctxt, key))\n\t\t\t\tbreak;\n\t\t\tif (!key_base_type_match(auth_method, key,\n\t\t\t    options.hostbased_accepted_algos))\n\t\t\t\tbreak;\n\t\t\tallowed = hostbased_key_allowed(ssh, authctxt->pw,\n\t\t\t    cuser, chost, key);\n\t\t\tauth2_record_info(authctxt,\n\t\t\t    \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\",\n\t\t\t    cuser, chost);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal_f(\"unknown key type %u\", type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdebug3_f(\"%s authentication%s: %s key is %s\", auth_method,\n\t    pubkey_auth_attempt ? \"\" : \" test\",\n\t    (key == NULL || !authctxt->valid) ? \"invalid\" : sshkey_type(key),\n\t    allowed ? \"allowed\" : \"not allowed\");\n\n\tauth2_record_key(authctxt, 0, key);\n\n\t \n\tmonitor_reset_key_state();\n\n\tif (allowed) {\n\t\t \n\t\tif ((r = sshkey_to_blob(key, &key_blob, &key_bloblen)) != 0)\n\t\t\tfatal_fr(r, \"sshkey_to_blob\");\n\t\tkey_blobtype = type;\n\t\tkey_opts = opts;\n\t\thostbased_cuser = cuser;\n\t\thostbased_chost = chost;\n\t} else {\n\t\t \n\t\tauth_log(ssh, 0, 0, auth_method, NULL);\n\t\tfree(cuser);\n\t\tfree(chost);\n\t}\n\tsshkey_free(key);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, allowed)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tif (opts != NULL && (r = sshauthopt_serialise(opts, m, 1)) != 0)\n\t\tfatal_fr(r, \"sshauthopt_serialise\");\n\tmm_request_send(sock, MONITOR_ANS_KEYALLOWED, m);\n\n\tif (!allowed)\n\t\tsshauthopt_free(opts);\n\n\treturn (0);\n}\n\nstatic int\nmonitor_valid_userblob(struct ssh *ssh, const u_char *data, u_int datalen)\n{\n\tstruct sshbuf *b;\n\tstruct sshkey *hostkey = NULL;\n\tconst u_char *p;\n\tchar *userstyle, *cp;\n\tsize_t len;\n\tu_char type;\n\tint hostbound = 0, r, fail = 0;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal_f(\"sshbuf_from\");\n\n\tif (ssh->compat & SSH_OLD_SESSIONID) {\n\t\tp = sshbuf_ptr(b);\n\t\tlen = sshbuf_len(b);\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len < session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t\tif ((r = sshbuf_consume(b, session_id2_len)) != 0)\n\t\t\tfatal_fr(r, \"consume\");\n\t} else {\n\t\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\t\tfatal_fr(r, \"parse sessionid\");\n\t\tif ((session_id2 == NULL) ||\n\t\t    (len != session_id2_len) ||\n\t\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\t\tfail++;\n\t}\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal_fr(r, \"parse userstyle\");\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t \n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal_fr(r, \"parse method\");\n\tif (strcmp(\"publickey\", cp) != 0) {\n\t\tif (strcmp(\"publickey-hostbound-v00@openssh.com\", cp) == 0)\n\t\t\thostbound = 1;\n\t\telse\n\t\t\tfail++;\n\t}\n\tfree(cp);\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal_fr(r, \"parse pktype\");\n\tif (type == 0)\n\t\tfail++;\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t \n\t    (r = sshbuf_skip_string(b)) != 0 ||\t \n\t    (hostbound && (r = sshkey_froms(b, &hostkey)) != 0))\n\t\tfatal_fr(r, \"parse pk\");\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\tif (hostkey != NULL) {\n\t\t \n\t\tif (get_hostkey_index(hostkey, 1, ssh) == -1)\n\t\t\tfatal_f(\"hostbound hostkey does not match\");\n\t\tsshkey_free(hostkey);\n\t}\n\treturn (fail == 0);\n}\n\nstatic int\nmonitor_valid_hostbasedblob(const u_char *data, u_int datalen,\n    const char *cuser, const char *chost)\n{\n\tstruct sshbuf *b;\n\tconst u_char *p;\n\tchar *cp, *userstyle;\n\tsize_t len;\n\tint r, fail = 0;\n\tu_char type;\n\n\tif ((b = sshbuf_from(data, datalen)) == NULL)\n\t\tfatal_f(\"sshbuf_new\");\n\tif ((r = sshbuf_get_string_direct(b, &p, &len)) != 0)\n\t\tfatal_fr(r, \"parse sessionid\");\n\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (timingsafe_bcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\n\tif ((r = sshbuf_get_u8(b, &type)) != 0)\n\t\tfatal_fr(r, \"parse type\");\n\tif (type != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal_fr(r, \"parse userstyle\");\n\txasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n\t    authctxt->style ? \":\" : \"\",\n\t    authctxt->style ? authctxt->style : \"\");\n\tif (strcmp(userstyle, cp) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: \"\n\t\t    \"expected %s != %.100s\", userstyle, cp);\n\t\tfail++;\n\t}\n\tfree(userstyle);\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t \n\t    (r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal_fr(r, \"parse method\");\n\tif (strcmp(cp, \"hostbased\") != 0)\n\t\tfail++;\n\tfree(cp);\n\tif ((r = sshbuf_skip_string(b)) != 0 ||\t \n\t    (r = sshbuf_skip_string(b)) != 0)\t \n\t\tfatal_fr(r, \"parse pk\");\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal_fr(r, \"parse host\");\n\tif (((len = strlen(cp)) > 0) && cp[len - 1] == '.')\n\t\tcp[len - 1] = '\\0';\n\tif (strcmp(cp, chost) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\t \n\tif ((r = sshbuf_get_cstring(b, &cp, NULL)) != 0)\n\t\tfatal_fr(r, \"parse ruser\");\n\tif (strcmp(cp, cuser) != 0)\n\t\tfail++;\n\tfree(cp);\n\n\tif (sshbuf_len(b) != 0)\n\t\tfail++;\n\tsshbuf_free(b);\n\treturn (fail == 0);\n}\n\nint\nmm_answer_keyverify(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tstruct sshkey *key;\n\tconst u_char *signature, *data, *blob;\n\tchar *sigalg = NULL, *fp = NULL;\n\tsize_t signaturelen, datalen, bloblen;\n\tint r, ret, req_presence = 0, req_verify = 0, valid_data = 0;\n\tint encoded_ret;\n\tstruct sshkey_sig_details *sig_details = NULL;\n\n\tif ((r = sshbuf_get_string_direct(m, &blob, &bloblen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &signature, &signaturelen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &data, &datalen)) != 0 ||\n\t    (r = sshbuf_get_cstring(m, &sigalg, NULL)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\n\tif (hostbased_cuser == NULL || hostbased_chost == NULL ||\n\t  !monitor_allowed_key(blob, bloblen))\n\t\tfatal_f(\"bad key, not previously allowed\");\n\n\t \n\tif (*sigalg == '\\0') {\n\t\tfree(sigalg);\n\t\tsigalg = NULL;\n\t}\n\n\t \n\tif ((r = sshkey_from_blob(blob, bloblen, &key)) != 0)\n\t\tfatal_fr(r, \"parse key\");\n\n\tswitch (key_blobtype) {\n\tcase MM_USERKEY:\n\t\tvalid_data = monitor_valid_userblob(ssh, data, datalen);\n\t\tauth_method = \"publickey\";\n\t\tbreak;\n\tcase MM_HOSTKEY:\n\t\tvalid_data = monitor_valid_hostbasedblob(data, datalen,\n\t\t    hostbased_cuser, hostbased_chost);\n\t\tauth_method = \"hostbased\";\n\t\tbreak;\n\tdefault:\n\t\tvalid_data = 0;\n\t\tbreak;\n\t}\n\tif (!valid_data)\n\t\tfatal_f(\"bad %s signature data blob\",\n\t\t    key_blobtype == MM_USERKEY ? \"userkey\" :\n\t\t    (key_blobtype == MM_HOSTKEY ? \"hostkey\" : \"unknown\"));\n\n\tif ((fp = sshkey_fingerprint(key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\tfatal_f(\"sshkey_fingerprint failed\");\n\n\tret = sshkey_verify(key, signature, signaturelen, data, datalen,\n\t    sigalg, ssh->compat, &sig_details);\n\tdebug3_f(\"%s %s signature using %s %s%s%s\", auth_method,\n\t    sshkey_type(key), sigalg == NULL ? \"default\" : sigalg,\n\t    (ret == 0) ? \"verified\" : \"unverified\",\n\t    (ret != 0) ? \": \" : \"\", (ret != 0) ? ssh_err(ret) : \"\");\n\n\tif (ret == 0 && key_blobtype == MM_USERKEY && sig_details != NULL) {\n\t\treq_presence = (options.pubkey_auth_options &\n\t\t    PUBKEYAUTH_TOUCH_REQUIRED) ||\n\t\t    !key_opts->no_require_user_presence;\n\t\tif (req_presence &&\n\t\t    (sig_details->sk_flags & SSH_SK_USER_PRESENCE_REQD) == 0) {\n\t\t\terror(\"public key %s %s signature for %s%s from %.128s \"\n\t\t\t    \"port %d rejected: user presence \"\n\t\t\t    \"(authenticator touch) requirement not met \",\n\t\t\t    sshkey_type(key), fp,\n\t\t\t    authctxt->valid ? \"\" : \"invalid user \",\n\t\t\t    authctxt->user, ssh_remote_ipaddr(ssh),\n\t\t\t    ssh_remote_port(ssh));\n\t\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\t}\n\t\treq_verify = (options.pubkey_auth_options &\n\t\t    PUBKEYAUTH_VERIFY_REQUIRED) || key_opts->require_verify;\n\t\tif (req_verify &&\n\t\t    (sig_details->sk_flags & SSH_SK_USER_VERIFICATION_REQD) == 0) {\n\t\t\terror(\"public key %s %s signature for %s%s from %.128s \"\n\t\t\t    \"port %d rejected: user verification requirement \"\n\t\t\t    \"not met \", sshkey_type(key), fp,\n\t\t\t    authctxt->valid ? \"\" : \"invalid user \",\n\t\t\t    authctxt->user, ssh_remote_ipaddr(ssh),\n\t\t\t    ssh_remote_port(ssh));\n\t\t\tret = SSH_ERR_SIGNATURE_INVALID;\n\t\t}\n\t}\n\tauth2_record_key(authctxt, ret == 0, key);\n\n\tif (key_blobtype == MM_USERKEY)\n\t\tauth_activate_options(ssh, key_opts);\n\tmonitor_reset_key_state();\n\n\tsshbuf_reset(m);\n\n\t \n\tencoded_ret = (ret != 0);\n\tif ((r = sshbuf_put_u32(m, encoded_ret)) != 0 ||\n\t    (r = sshbuf_put_u8(m, sig_details != NULL)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tif (sig_details != NULL) {\n\t\tif ((r = sshbuf_put_u32(m, sig_details->sk_counter)) != 0 ||\n\t\t    (r = sshbuf_put_u8(m, sig_details->sk_flags)) != 0)\n\t\t\tfatal_fr(r, \"assemble sk\");\n\t}\n\tsshkey_sig_details_free(sig_details);\n\tmm_request_send(sock, MONITOR_ANS_KEYVERIFY, m);\n\n\tfree(sigalg);\n\tfree(fp);\n\tsshkey_free(key);\n\n\treturn ret == 0;\n}\n\nstatic void\nmm_record_login(struct ssh *ssh, Session *s, struct passwd *pw)\n{\n\tsocklen_t fromlen;\n\tstruct sockaddr_storage from;\n\n\t \n\tmemset(&from, 0, sizeof(from));\n\tfromlen = sizeof(from);\n\tif (ssh_packet_connection_is_on_socket(ssh)) {\n\t\tif (getpeername(ssh_packet_get_connection_in(ssh),\n\t\t    (struct sockaddr *)&from, &fromlen) == -1) {\n\t\t\tdebug(\"getpeername: %.100s\", strerror(errno));\n\t\t\tcleanup_exit(255);\n\t\t}\n\t}\n\t \n\trecord_login(s->pid, s->tty, pw->pw_name, pw->pw_uid,\n\t    session_get_remote_name_or_ip(ssh, utmp_len, options.use_dns),\n\t    (struct sockaddr *)&from, fromlen);\n}\n\nstatic void\nmm_session_close(Session *s)\n{\n\tdebug3_f(\"session %d pid %ld\", s->self, (long)s->pid);\n\tif (s->ttyfd != -1) {\n\t\tdebug3_f(\"tty %s ptyfd %d\", s->tty, s->ptyfd);\n\t\tsession_pty_cleanup2(s);\n\t}\n\tsession_unused(s->self);\n}\n\nint\nmm_answer_pty(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\textern struct monitor *pmonitor;\n\tSession *s;\n\tint r, res, fd0;\n\n\tdebug3_f(\"entering\");\n\n\tsshbuf_reset(m);\n\ts = session_new();\n\tif (s == NULL)\n\t\tgoto error;\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\ts->pid = pmonitor->m_pid;\n\tres = pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty));\n\tif (res == 0)\n\t\tgoto error;\n\tpty_setowner(authctxt->pw, s->tty);\n\n\tif ((r = sshbuf_put_u32(m, 1)) != 0 ||\n\t    (r = sshbuf_put_cstring(m, s->tty)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\t \n\tif (dup2(s->ttyfd, 0) == -1)\n\t\tfatal_f(\"dup2\");\n\n\tmm_record_login(ssh, s, authctxt->pw);\n\n\t \n\tclose(0);\n\n\t \n\tif ((r = sshbuf_put_stringb(m, loginmsg)) != 0)\n\t\tfatal_fr(r, \"assemble loginmsg\");\n\tsshbuf_reset(loginmsg);\n\n\tmm_request_send(sock, MONITOR_ANS_PTY, m);\n\n\tif (mm_send_fd(sock, s->ptyfd) == -1 ||\n\t    mm_send_fd(sock, s->ttyfd) == -1)\n\t\tfatal_f(\"send fds failed\");\n\n\t \n\tif ((fd0 = open(_PATH_DEVNULL, O_RDONLY)) == -1)\n\t\tfatal_f(\"open(/dev/null): %s\", strerror(errno));\n\tif (fd0 != 0)\n\t\terror_f(\"fd0 %d != 0\", fd0);\n\n\t \n\tclose(s->ttyfd);\n\ts->ttyfd = s->ptyfd;\n\t \n\ts->ptymaster = s->ptyfd;\n\n\tdebug3_f(\"tty %s ptyfd %d\", s->tty, s->ttyfd);\n\n\treturn (0);\n\n error:\n\tif (s != NULL)\n\t\tmm_session_close(s);\n\tif ((r = sshbuf_put_u32(m, 0)) != 0)\n\t\tfatal_fr(r, \"assemble 0\");\n\tmm_request_send(sock, MONITOR_ANS_PTY, m);\n\treturn (0);\n}\n\nint\nmm_answer_pty_cleanup(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tSession *s;\n\tchar *tty;\n\tint r;\n\n\tdebug3_f(\"entering\");\n\n\tif ((r = sshbuf_get_cstring(m, &tty, NULL)) != 0)\n\t\tfatal_fr(r, \"parse tty\");\n\tif ((s = session_by_tty(tty)) != NULL)\n\t\tmm_session_close(s);\n\tsshbuf_reset(m);\n\tfree(tty);\n\treturn (0);\n}\n\nint\nmm_answer_term(struct ssh *ssh, int sock, struct sshbuf *req)\n{\n\textern struct monitor *pmonitor;\n\tint res, status;\n\n\tdebug3_f(\"tearing down sessions\");\n\n\t \n\tsession_destroy_all(ssh, &mm_session_close);\n\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\tsshpam_cleanup();\n#endif\n\n\twhile (waitpid(pmonitor->m_pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\texit(1);\n\n\tres = WIFEXITED(status) ? WEXITSTATUS(status) : 1;\n\n\t \n\texit(res);\n}\n\n#ifdef SSH_AUDIT_EVENTS\n \nint\nmm_answer_audit_event(struct ssh *ssh, int socket, struct sshbuf *m)\n{\n\tu_int n;\n\tssh_audit_event_t event;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\n\tif ((r = sshbuf_get_u32(m, &n)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tevent = (ssh_audit_event_t)n;\n\tswitch (event) {\n\tcase SSH_AUTH_FAIL_PUBKEY:\n\tcase SSH_AUTH_FAIL_HOSTBASED:\n\tcase SSH_AUTH_FAIL_GSSAPI:\n\tcase SSH_LOGIN_EXCEED_MAXTRIES:\n\tcase SSH_LOGIN_ROOT_DENIED:\n\tcase SSH_CONNECTION_CLOSE:\n\tcase SSH_INVALID_USER:\n\t\taudit_event(ssh, event);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"Audit event type %d not permitted\", event);\n\t}\n\n\treturn (0);\n}\n\nint\nmm_answer_audit_command(struct ssh *ssh, int socket, struct sshbuf *m)\n{\n\tchar *cmd;\n\tint r;\n\n\tdebug3(\"%s entering\", __func__);\n\tif ((r = sshbuf_get_cstring(m, &cmd, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t \n\taudit_run_command(cmd);\n\tfree(cmd);\n\treturn (0);\n}\n#endif  \n\nvoid\nmonitor_clear_keystate(struct ssh *ssh, struct monitor *pmonitor)\n{\n\tssh_clear_newkeys(ssh, MODE_IN);\n\tssh_clear_newkeys(ssh, MODE_OUT);\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n}\n\nvoid\nmonitor_apply_keystate(struct ssh *ssh, struct monitor *pmonitor)\n{\n\tstruct kex *kex;\n\tint r;\n\n\tdebug3_f(\"packet_set_state\");\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n\t\tfatal_fr(r, \"packet_set_state\");\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\tif ((kex = ssh->kex) == NULL)\n\t\tfatal_f(\"internal error: ssh->kex == NULL\");\n\tif (session_id2_len != sshbuf_len(ssh->kex->session_id)) {\n\t\tfatal_f(\"incorrect session id length %zu (expected %u)\",\n\t\t    sshbuf_len(ssh->kex->session_id), session_id2_len);\n\t}\n\tif (memcmp(sshbuf_ptr(ssh->kex->session_id), session_id2,\n\t    session_id2_len) != 0)\n\t\tfatal_f(\"session ID mismatch\");\n\t \n#ifdef WITH_OPENSSL\n\tkex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\tkex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif  \n\tkex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\tkex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\tkex->host_key_index=&get_hostkey_index;\n\tkex->sign = sshd_hostkey_sign;\n}\n\n \n\nvoid\nmm_get_keystate(struct ssh *ssh, struct monitor *pmonitor)\n{\n\tdebug3_f(\"Waiting for new keys\");\n\n\tif ((child_state = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tmm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_KEYEXPORT,\n\t    child_state);\n\tdebug3_f(\"GOT new keys\");\n}\n\n\n \n\n#define FD_CLOSEONEXEC(x) do { \\\n\tif (fcntl(x, F_SETFD, FD_CLOEXEC) == -1) \\\n\t\tfatal(\"fcntl(%d, F_SETFD)\", x); \\\n} while (0)\n\nstatic void\nmonitor_openfds(struct monitor *mon, int do_logfds)\n{\n\tint pair[2];\n#ifdef SO_ZEROIZE\n\tint on = 1;\n#endif\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)\n\t\tfatal_f(\"socketpair: %s\", strerror(errno));\n#ifdef SO_ZEROIZE\n\tif (setsockopt(pair[0], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt SO_ZEROIZE(0): %.100s\", strerror(errno));\n\tif (setsockopt(pair[1], SOL_SOCKET, SO_ZEROIZE, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt SO_ZEROIZE(1): %.100s\", strerror(errno));\n#endif\n\tFD_CLOSEONEXEC(pair[0]);\n\tFD_CLOSEONEXEC(pair[1]);\n\tmon->m_recvfd = pair[0];\n\tmon->m_sendfd = pair[1];\n\n\tif (do_logfds) {\n\t\tif (pipe(pair) == -1)\n\t\t\tfatal_f(\"pipe: %s\", strerror(errno));\n\t\tFD_CLOSEONEXEC(pair[0]);\n\t\tFD_CLOSEONEXEC(pair[1]);\n\t\tmon->m_log_recvfd = pair[0];\n\t\tmon->m_log_sendfd = pair[1];\n\t} else\n\t\tmon->m_log_recvfd = mon->m_log_sendfd = -1;\n}\n\n#define MM_MEMSIZE\t65536\n\nstruct monitor *\nmonitor_init(void)\n{\n\tstruct monitor *mon;\n\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\n\treturn mon;\n}\n\nvoid\nmonitor_reinit(struct monitor *mon)\n{\n\tmonitor_openfds(mon, 0);\n}\n\n#ifdef GSSAPI\nint\nmm_answer_gss_setup_ctx(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tgss_OID_desc goid;\n\tOM_uint32 major;\n\tsize_t len;\n\tu_char *p;\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal_f(\"GSSAPI authentication not enabled\");\n\n\tif ((r = sshbuf_get_string(m, &p, &len)) != 0)\n\t\tfatal_fr(r, \"parse\");\n\tgoid.elements = p;\n\tgoid.length = len;\n\n\tmajor = ssh_gssapi_server_ctx(&gsscontext, &goid);\n\n\tfree(goid.elements);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, major)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(sock, MONITOR_ANS_GSSSETUP, m);\n\n\t \n\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 1);\n\n\treturn (0);\n}\n\nint\nmm_answer_gss_accept_ctx(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tgss_buffer_desc in;\n\tgss_buffer_desc out = GSS_C_EMPTY_BUFFER;\n\tOM_uint32 major, minor;\n\tOM_uint32 flags = 0;  \n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal_f(\"GSSAPI authentication not enabled\");\n\n\tif ((r = ssh_gssapi_get_buffer_desc(m, &in)) != 0)\n\t\tfatal_fr(r, \"ssh_gssapi_get_buffer_desc\");\n\tmajor = ssh_gssapi_accept_ctx(gsscontext, &in, &out, &flags);\n\tfree(in.value);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, major)) != 0 ||\n\t    (r = sshbuf_put_string(m, out.value, out.length)) != 0 ||\n\t    (r = sshbuf_put_u32(m, flags)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\tmm_request_send(sock, MONITOR_ANS_GSSSTEP, m);\n\n\tgss_release_buffer(&minor, &out);\n\n\tif (major == GSS_S_COMPLETE) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSSTEP, 0);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSCHECKMIC, 1);\n\t}\n\treturn (0);\n}\n\nint\nmm_answer_gss_checkmic(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tgss_buffer_desc gssbuf, mic;\n\tOM_uint32 ret;\n\tint r;\n\n\tif (!options.gss_authentication)\n\t\tfatal_f(\"GSSAPI authentication not enabled\");\n\n\tif ((r = ssh_gssapi_get_buffer_desc(m, &gssbuf)) != 0 ||\n\t    (r = ssh_gssapi_get_buffer_desc(m, &mic)) != 0)\n\t\tfatal_fr(r, \"ssh_gssapi_get_buffer_desc\");\n\n\tret = ssh_gssapi_checkmic(gsscontext, &gssbuf, &mic);\n\n\tfree(gssbuf.value);\n\tfree(mic.value);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, ret)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tmm_request_send(sock, MONITOR_ANS_GSSCHECKMIC, m);\n\n\tif (!GSS_ERROR(ret))\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_GSSUSEROK, 1);\n\n\treturn (0);\n}\n\nint\nmm_answer_gss_userok(struct ssh *ssh, int sock, struct sshbuf *m)\n{\n\tint r, authenticated;\n\tconst char *displayname;\n\n\tif (!options.gss_authentication)\n\t\tfatal_f(\"GSSAPI authentication not enabled\");\n\n\tauthenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);\n\n\tsshbuf_reset(m);\n\tif ((r = sshbuf_put_u32(m, authenticated)) != 0)\n\t\tfatal_fr(r, \"assemble\");\n\n\tdebug3_f(\"sending result %d\", authenticated);\n\tmm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);\n\n\tauth_method = \"gssapi-with-mic\";\n\n\tif ((displayname = ssh_gssapi_displayname()) != NULL)\n\t\tauth2_record_info(authctxt, \"%s\", displayname);\n\n\t \n\treturn (authenticated);\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}