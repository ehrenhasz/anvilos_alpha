{
  "module_name": "ssh_api.c",
  "hash_id": "ba41dcb94edde611650d06b174b486bb33505b66546a019f9448b2c8952a91cf",
  "original_prompt": "Ingested from openssh-9.6p1/ssh_api.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"ssh_api.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"authfile.h\"\n#include \"sshkey.h\"\n#include \"misc.h\"\n#include \"ssh2.h\"\n#include \"version.h\"\n#include \"myproposal.h\"\n#include \"ssherr.h\"\n#include \"sshbuf.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include <string.h>\n\nint\t_ssh_exchange_banner(struct ssh *);\nint\t_ssh_send_banner(struct ssh *, struct sshbuf *);\nint\t_ssh_read_banner(struct ssh *, struct sshbuf *);\nint\t_ssh_order_hostkeyalgs(struct ssh *);\nint\t_ssh_verify_host_key(struct sshkey *, struct ssh *);\nstruct sshkey *_ssh_host_public_key(int, int, struct ssh *);\nstruct sshkey *_ssh_host_private_key(int, int, struct ssh *);\nint\t_ssh_host_key_sign(struct ssh *, struct sshkey *, struct sshkey *,\n    u_char **, size_t *, const u_char *, size_t, const char *);\n\n \nint\tuse_privsep = 0;\nint\tmm_sshkey_sign(struct sshkey *, u_char **, u_int *,\n    const u_char *, u_int, const char *, const char *, const char *, u_int);\n\n#ifdef WITH_OPENSSL\nDH\t*mm_choose_dh(int, int, int);\n#endif\n\nint\nmm_sshkey_sign(struct sshkey *key, u_char **sigp, u_int *lenp,\n    const u_char *data, u_int datalen, const char *alg,\n    const char *sk_provider, const char *sk_pin, u_int compat)\n{\n\treturn (-1);\n}\n\n#ifdef WITH_OPENSSL\nDH *\nmm_choose_dh(int min, int nbits, int max)\n{\n\treturn (NULL);\n}\n#endif\n\n \n\nint\nssh_init(struct ssh **sshp, int is_server, struct kex_params *kex_params)\n{\n\tchar *myproposal[PROPOSAL_MAX] = { KEX_CLIENT };\n\tstruct ssh *ssh;\n\tchar **proposal;\n\tstatic int called;\n\tint r;\n\n\tif (!called) {\n\t\tseed_rng();\n\t\tcalled = 1;\n\t}\n\n\tif ((ssh = ssh_packet_set_connection(NULL, -1, -1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (is_server)\n\t\tssh_packet_set_server(ssh);\n\n\t \n\tproposal = kex_params ? kex_params->proposal : myproposal;\n\tif ((r = kex_ready(ssh, proposal)) != 0) {\n\t\tssh_free(ssh);\n\t\treturn r;\n\t}\n\tssh->kex->server = is_server;\n\tif (is_server) {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_server;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_server;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_server;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_server;\n# endif\n#endif  \n\t\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_server;\n\t\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_server;\n\t\tssh->kex->load_host_public_key=&_ssh_host_public_key;\n\t\tssh->kex->load_host_private_key=&_ssh_host_private_key;\n\t\tssh->kex->sign=&_ssh_host_key_sign;\n\t} else {\n#ifdef WITH_OPENSSL\n\t\tssh->kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA1] = kex_gen_client;\n\t\tssh->kex->kex[KEX_DH_GRP14_SHA256] = kex_gen_client;\n\t\tssh->kex->kex[KEX_DH_GRP16_SHA512] = kex_gen_client;\n\t\tssh->kex->kex[KEX_DH_GRP18_SHA512] = kex_gen_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA1] = kexgex_client;\n\t\tssh->kex->kex[KEX_DH_GEX_SHA256] = kexgex_client;\n# ifdef OPENSSL_HAS_ECC\n\t\tssh->kex->kex[KEX_ECDH_SHA2] = kex_gen_client;\n# endif\n#endif  \n\t\tssh->kex->kex[KEX_C25519_SHA256] = kex_gen_client;\n\t\tssh->kex->kex[KEX_KEM_SNTRUP761X25519_SHA512] = kex_gen_client;\n\t\tssh->kex->verify_host_key =&_ssh_verify_host_key;\n\t}\n\t*sshp = ssh;\n\treturn 0;\n}\n\nvoid\nssh_free(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tif (ssh == NULL)\n\t\treturn;\n\n\t \n\twhile ((k = TAILQ_FIRST(&ssh->public_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->public_keys, k, next);\n\t\tif (ssh->kex && ssh->kex->server)\n\t\t\tsshkey_free(k->key);\n\t\tfree(k);\n\t}\n\twhile ((k = TAILQ_FIRST(&ssh->private_keys)) != NULL) {\n\t\tTAILQ_REMOVE(&ssh->private_keys, k, next);\n\t\tfree(k);\n\t}\n\tssh_packet_close(ssh);\n\tfree(ssh);\n}\n\nvoid\nssh_set_app_data(struct ssh *ssh, void *app_data)\n{\n\tssh->app_data = app_data;\n}\n\nvoid *\nssh_get_app_data(struct ssh *ssh)\n{\n\treturn ssh->app_data;\n}\n\n \nint\nssh_add_hostkey(struct ssh *ssh, struct sshkey *key)\n{\n\tstruct sshkey *pubkey = NULL;\n\tstruct key_entry *k = NULL, *k_prv = NULL;\n\tint r;\n\n\tif (ssh->kex->server) {\n\t\tif ((r = sshkey_from_private(key, &pubkey)) != 0)\n\t\t\treturn r;\n\t\tif ((k = malloc(sizeof(*k))) == NULL ||\n\t\t    (k_prv = malloc(sizeof(*k_prv))) == NULL) {\n\t\t\tfree(k);\n\t\t\tsshkey_free(pubkey);\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\t}\n\t\tk_prv->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->private_keys, k_prv, next);\n\n\t\t \n\t\tk->key = pubkey;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t} else {\n\t\tif ((k = malloc(sizeof(*k))) == NULL)\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tk->key = key;\n\t\tTAILQ_INSERT_TAIL(&ssh->public_keys, k, next);\n\t\tr = 0;\n\t}\n\n\treturn r;\n}\n\nint\nssh_set_verify_host_key_callback(struct ssh *ssh,\n    int (*cb)(struct sshkey *, struct ssh *))\n{\n\tif (cb == NULL || ssh->kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\n\tssh->kex->verify_host_key = cb;\n\n\treturn 0;\n}\n\nint\nssh_input_append(struct ssh *ssh, const u_char *data, size_t len)\n{\n\treturn sshbuf_put(ssh_packet_get_input(ssh), data, len);\n}\n\nint\nssh_packet_next(struct ssh *ssh, u_char *typep)\n{\n\tint r;\n\tu_int32_t seqnr;\n\tu_char type;\n\n\t \n\t*typep = SSH_MSG_NONE;\n\tif (sshbuf_len(ssh->kex->client_version) == 0 ||\n\t    sshbuf_len(ssh->kex->server_version) == 0)\n\t\treturn _ssh_exchange_banner(ssh);\n\t \n\tfor (;;) {\n\t\tif ((r = ssh_packet_read_poll2(ssh, &type, &seqnr)) != 0)\n\t\t\treturn r;\n\t\tif (type > 0 && type < DISPATCH_MAX &&\n\t\t    type >= SSH2_MSG_KEXINIT && type <= SSH2_MSG_TRANSPORT_MAX &&\n\t\t    ssh->dispatch[type] != NULL) {\n\t\t\tif ((r = (*ssh->dispatch[type])(type, seqnr, ssh)) != 0)\n\t\t\t\treturn r;\n\t\t} else {\n\t\t\t*typep = type;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nconst u_char *\nssh_packet_payload(struct ssh *ssh, size_t *lenp)\n{\n\treturn sshpkt_ptr(ssh, lenp);\n}\n\nint\nssh_packet_put(struct ssh *ssh, int type, const u_char *data, size_t len)\n{\n\tint r;\n\n\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t    (r = sshpkt_put(ssh, data, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}\n\nconst u_char *\nssh_output_ptr(struct ssh *ssh, size_t *len)\n{\n\tstruct sshbuf *output = ssh_packet_get_output(ssh);\n\n\t*len = sshbuf_len(output);\n\treturn sshbuf_ptr(output);\n}\n\nint\nssh_output_consume(struct ssh *ssh, size_t len)\n{\n\treturn sshbuf_consume(ssh_packet_get_output(ssh), len);\n}\n\nint\nssh_output_space(struct ssh *ssh, size_t len)\n{\n\treturn (0 == sshbuf_check_reserve(ssh_packet_get_output(ssh), len));\n}\n\nint\nssh_input_space(struct ssh *ssh, size_t len)\n{\n\treturn (0 == sshbuf_check_reserve(ssh_packet_get_input(ssh), len));\n}\n\n \nint\n_ssh_read_banner(struct ssh *ssh, struct sshbuf *banner)\n{\n\tstruct sshbuf *input = ssh_packet_get_input(ssh);\n\tconst char *mismatch = \"Protocol mismatch.\\r\\n\";\n\tconst u_char *s = sshbuf_ptr(input);\n\tu_char c;\n\tchar *cp = NULL, *remote_version = NULL;\n\tint r = 0, remote_major, remote_minor, expect_nl;\n\tsize_t n, j;\n\n\tfor (j = n = 0;;) {\n\t\tsshbuf_reset(banner);\n\t\texpect_nl = 0;\n\t\tfor (;;) {\n\t\t\tif (j >= sshbuf_len(input))\n\t\t\t\treturn 0;  \n\t\t\tc = s[j++];\n\t\t\tif (c == '\\r') {\n\t\t\t\texpect_nl = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t\tif (expect_nl)\n\t\t\t\tgoto bad;\n\t\t\tif ((r = sshbuf_put_u8(banner, c)) != 0)\n\t\t\t\treturn r;\n\t\t\tif (sshbuf_len(banner) > SSH_MAX_BANNER_LEN)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (sshbuf_len(banner) >= 4 &&\n\t\t    memcmp(sshbuf_ptr(banner), \"SSH-\", 4) == 0)\n\t\t\tbreak;\n\t\tdebug_f(\"%.*s\", (int)sshbuf_len(banner),\n\t\t    sshbuf_ptr(banner));\n\t\t \n\t\tif (ssh->kex->server || ++n > SSH_MAX_PRE_BANNER_LINES) {\n  bad:\n\t\t\tif ((r = sshbuf_put(ssh_packet_get_output(ssh),\n\t\t\t    mismatch, strlen(mismatch))) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_NO_PROTOCOL_VERSION;\n\t\t}\n\t}\n\tif ((r = sshbuf_consume(input, j)) != 0)\n\t\treturn r;\n\n\t \n\tif ((cp = sshbuf_dup_string(banner)) == NULL ||\n\t    (remote_version = calloc(1, sshbuf_len(banner))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sscanf(cp, \"SSH-%d.%d-%[^\\n]\\n\",\n\t    &remote_major, &remote_minor, remote_version) != 3) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tdebug(\"Remote protocol version %d.%d, remote software version %.100s\",\n\t    remote_major, remote_minor, remote_version);\n\n\tcompat_banner(ssh, remote_version);\n\tif  (remote_major == 1 && remote_minor == 99) {\n\t\tremote_major = 2;\n\t\tremote_minor = 0;\n\t}\n\tif (remote_major != 2)\n\t\tr = SSH_ERR_PROTOCOL_MISMATCH;\n\n\tdebug(\"Remote version string %.100s\", cp);\n out:\n\tfree(cp);\n\tfree(remote_version);\n\treturn r;\n}\n\n \nint\n_ssh_send_banner(struct ssh *ssh, struct sshbuf *banner)\n{\n\tchar *cp;\n\tint r;\n\n\tif ((r = sshbuf_putf(banner, \"SSH-2.0-%.100s\\r\\n\", SSH_VERSION)) != 0)\n\t\treturn r;\n\tif ((r = sshbuf_putb(ssh_packet_get_output(ssh), banner)) != 0)\n\t\treturn r;\n\t \n\tif ((r = sshbuf_consume_end(banner, 2)) != 0)\n\t\treturn r;\n\tif ((cp = sshbuf_dup_string(banner)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tdebug(\"Local version string %.100s\", cp);\n\tfree(cp);\n\treturn 0;\n}\n\nint\n_ssh_exchange_banner(struct ssh *ssh)\n{\n\tstruct kex *kex = ssh->kex;\n\tint r;\n\n\t \n\n\tr = 0;\n\tif (kex->server) {\n\t\tif (sshbuf_len(ssh->kex->server_version) == 0)\n\t\t\tr = _ssh_send_banner(ssh, ssh->kex->server_version);\n\t\tif (r == 0 &&\n\t\t    sshbuf_len(ssh->kex->server_version) != 0 &&\n\t\t    sshbuf_len(ssh->kex->client_version) == 0)\n\t\t\tr = _ssh_read_banner(ssh, ssh->kex->client_version);\n\t} else {\n\t\tif (sshbuf_len(ssh->kex->server_version) == 0)\n\t\t\tr = _ssh_read_banner(ssh, ssh->kex->server_version);\n\t\tif (r == 0 &&\n\t\t    sshbuf_len(ssh->kex->server_version) != 0 &&\n\t\t    sshbuf_len(ssh->kex->client_version) == 0)\n\t\t\tr = _ssh_send_banner(ssh, ssh->kex->client_version);\n\t}\n\tif (r != 0)\n\t\treturn r;\n\t \n\tif (sshbuf_len(ssh->kex->server_version) != 0 &&\n\t    sshbuf_len(ssh->kex->client_version) != 0) {\n\t\tif ((r = _ssh_order_hostkeyalgs(ssh)) != 0 ||\n\t\t    (r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstruct sshkey *\n_ssh_host_public_key(int type, int nid, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3_f(\"need %d\", type);\n\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\tdebug3_f(\"check %s\", sshkey_type(k->key));\n\t\tif (k->key->type == type &&\n\t\t    (type != KEY_ECDSA || k->key->ecdsa_nid == nid))\n\t\t\treturn (k->key);\n\t}\n\treturn (NULL);\n}\n\nstruct sshkey *\n_ssh_host_private_key(int type, int nid, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3_f(\"need %d\", type);\n\tTAILQ_FOREACH(k, &ssh->private_keys, next) {\n\t\tdebug3_f(\"check %s\", sshkey_type(k->key));\n\t\tif (k->key->type == type &&\n\t\t    (type != KEY_ECDSA || k->key->ecdsa_nid == nid))\n\t\t\treturn (k->key);\n\t}\n\treturn (NULL);\n}\n\nint\n_ssh_verify_host_key(struct sshkey *hostkey, struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\n\tdebug3_f(\"need %s\", sshkey_type(hostkey));\n\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\tdebug3_f(\"check %s\", sshkey_type(k->key));\n\t\tif (sshkey_equal_public(hostkey, k->key))\n\t\t\treturn (0);\t \n\t}\n\treturn (-1);\t \n}\n\n \nint\n_ssh_order_hostkeyalgs(struct ssh *ssh)\n{\n\tstruct key_entry *k;\n\tchar *orig, *avail, *oavail = NULL, *alg, *replace = NULL;\n\tchar **proposal;\n\tsize_t maxlen;\n\tint ktype, r;\n\n\t \n\tif ((r = kex_buf2prop(ssh->kex->my, NULL, &proposal)) != 0)\n\t\treturn r;\n\torig = proposal[PROPOSAL_SERVER_HOST_KEY_ALGS];\n\tif ((oavail = avail = strdup(orig)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tmaxlen = strlen(avail) + 1;\n\tif ((replace = calloc(1, maxlen)) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\t*replace = '\\0';\n\twhile ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n\t\tif ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n\t\t\tcontinue;\n\t\tTAILQ_FOREACH(k, &ssh->public_keys, next) {\n\t\t\tif (k->key->type == ktype ||\n\t\t\t    (sshkey_is_cert(k->key) && k->key->type ==\n\t\t\t    sshkey_type_plain(ktype))) {\n\t\t\t\tif (*replace != '\\0')\n\t\t\t\t\tstrlcat(replace, \",\", maxlen);\n\t\t\t\tstrlcat(replace, alg, maxlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (*replace != '\\0') {\n\t\tdebug2_f(\"orig/%d    %s\", ssh->kex->server, orig);\n\t\tdebug2_f(\"replace/%d %s\", ssh->kex->server, replace);\n\t\tfree(orig);\n\t\tproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = replace;\n\t\treplace = NULL;\t \n\t\tr = kex_prop2buf(ssh->kex->my, proposal);\n\t}\n out:\n\tfree(oavail);\n\tfree(replace);\n\tkex_prop_free(proposal);\n\treturn r;\n}\n\nint\n_ssh_host_key_sign(struct ssh *ssh, struct sshkey *privkey,\n    struct sshkey *pubkey, u_char **signature, size_t *slen,\n    const u_char *data, size_t dlen, const char *alg)\n{\n\treturn sshkey_sign(privkey, signature, slen, data, dlen,\n\t    alg, NULL, NULL, ssh->compat);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}