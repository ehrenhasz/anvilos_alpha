{
  "module_name": "bitmap.c",
  "hash_id": "a3ecb61c40789cd61048252e3ae6fe67974a7745b445101ea0291cfbb7bea339",
  "original_prompt": "Ingested from openssh-9.6p1/bitmap.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"bitmap.h\"\n\n#define BITMAP_WTYPE\tu_int\n#define BITMAP_MAX\t(1<<24)\n#define BITMAP_BYTES\t(sizeof(BITMAP_WTYPE))\n#define BITMAP_BITS\t(sizeof(BITMAP_WTYPE) * 8)\n#define BITMAP_WMASK\t((BITMAP_WTYPE)BITMAP_BITS - 1)\nstruct bitmap {\n\tBITMAP_WTYPE *d;\n\tsize_t len;  \n\tsize_t top;  \n};\n\nstruct bitmap *\nbitmap_new(void)\n{\n\tstruct bitmap *ret;\n\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL)\n\t\treturn NULL;\n\tif ((ret->d = calloc(1, BITMAP_BYTES)) == NULL) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret->len = 1;\n\tret->top = 0;\n\treturn ret;\n}\n\nvoid\nbitmap_free(struct bitmap *b)\n{\n\tif (b != NULL && b->d != NULL) {\n\t\tbitmap_zero(b);\n\t\tfree(b->d);\n\t\tb->d = NULL;\n\t}\n\tfree(b);\n}\n\nvoid\nbitmap_zero(struct bitmap *b)\n{\n\tmemset(b->d, 0, b->len * BITMAP_BYTES);\n\tb->top = 0;\n}\n\nint\nbitmap_test_bit(struct bitmap *b, u_int n)\n{\n\tif (b->top >= b->len)\n\t\treturn 0;  \n\tif (b->len == 0 || (n / BITMAP_BITS) > b->top)\n\t\treturn 0;\n\treturn (b->d[n / BITMAP_BITS] >> (n & BITMAP_WMASK)) & 1;\n}\n\nstatic int\nreserve(struct bitmap *b, u_int n)\n{\n\tBITMAP_WTYPE *tmp;\n\tsize_t nlen;\n\n\tif (b->top >= b->len || n > BITMAP_MAX)\n\t\treturn -1;  \n\tnlen = (n / BITMAP_BITS) + 1;\n\tif (b->len < nlen) {\n\t\tif ((tmp = recallocarray(b->d, b->len,\n\t\t    nlen, BITMAP_BYTES)) == NULL)\n\t\t\treturn -1;\n\t\tb->d = tmp;\n\t\tb->len = nlen;\n\t}\n\treturn 0;\n}\n\nint\nbitmap_set_bit(struct bitmap *b, u_int n)\n{\n\tint r;\n\tsize_t offset;\n\n\tif ((r = reserve(b, n)) != 0)\n\t\treturn r;\n\toffset = n / BITMAP_BITS;\n\tif (offset > b->top)\n\t\tb->top = offset;\n\tb->d[offset] |= (BITMAP_WTYPE)1 << (n & BITMAP_WMASK);\n\treturn 0;\n}\n\n \nstatic void\nretop(struct bitmap *b)\n{\n\tif (b->top >= b->len)\n\t\treturn;\n\twhile (b->top > 0 && b->d[b->top] == 0)\n\t\tb->top--;\n}\n\nvoid\nbitmap_clear_bit(struct bitmap *b, u_int n)\n{\n\tsize_t offset;\n\n\tif (b->top >= b->len || n > BITMAP_MAX)\n\t\treturn;  \n\toffset = n / BITMAP_BITS;\n\tif (offset > b->top)\n\t\treturn;\n\tb->d[offset] &= ~((BITMAP_WTYPE)1 << (n & BITMAP_WMASK));\n\t \n\tretop(b);\n}\n\nsize_t\nbitmap_nbits(struct bitmap *b)\n{\n\tsize_t bits;\n\tBITMAP_WTYPE w;\n\n\tretop(b);\n\tif (b->top >= b->len)\n\t\treturn 0;  \n\tif (b->len == 0 || (b->top == 0 && b->d[0] == 0))\n\t\treturn 0;\n\t \n\tw = b->d[b->top];\n\tbits = (b->top + 1) * BITMAP_BITS;\n\twhile (!(w & ((BITMAP_WTYPE)1 << (BITMAP_BITS - 1)))) {\n\t\tw <<= 1;\n\t\tbits--;\n\t}\n\treturn bits;\n}\n\nsize_t\nbitmap_nbytes(struct bitmap *b)\n{\n\treturn (bitmap_nbits(b) + 7) / 8;\n}\n\nint\nbitmap_to_string(struct bitmap *b, void *p, size_t l)\n{\n\tu_char *s = (u_char *)p;\n\tsize_t i, j, k, need = bitmap_nbytes(b);\n\n\tif (l < need || b->top >= b->len)\n\t\treturn -1;\n\tif (l > need)\n\t\tl = need;\n\t \n\tfor (i = k = 0; i < b->top + 1; i++) {\n\t\tfor (j = 0; j < BITMAP_BYTES; j++) {\n\t\t\tif (k >= l)\n\t\t\t\tbreak;\n\t\t\ts[need - 1 - k++] = (b->d[i] >> (j * 8)) & 0xff;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nbitmap_from_string(struct bitmap *b, const void *p, size_t l)\n{\n\tint r;\n\tsize_t i, offset, shift;\n\tconst u_char *s = (const u_char *)p;\n\n\tif (l > BITMAP_MAX / 8)\n\t\treturn -1;\n\tif ((r = reserve(b, l * 8)) != 0)\n\t\treturn r;\n\tbitmap_zero(b);\n\tif (l == 0)\n\t\treturn 0;\n\tb->top = offset = ((l + (BITMAP_BYTES - 1)) / BITMAP_BYTES) - 1;\n\tshift = ((l + (BITMAP_BYTES - 1)) % BITMAP_BYTES) * 8;\n\tfor (i = 0; i < l; i++) {\n\t\tb->d[offset] |= (BITMAP_WTYPE)s[i] << shift;\n\t\tif (shift == 0) {\n\t\t\toffset--;\n\t\t\tshift = BITMAP_BITS - 8;\n\t\t} else\n\t\t\tshift -= 8;\n\t}\n\tretop(b);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}