{
  "module_name": "moduli.c",
  "hash_id": "fe54328fc1cbb9c17e32b05ef54ab0d818074b7f5aaa2d37b4475c65b9910983",
  "original_prompt": "Ingested from openssh-9.6p1/moduli.c",
  "human_readable_source": " \n \n\n \n\n#include \"includes.h\"\n\n#ifdef WITH_OPENSSL\n\n#include <sys/types.h>\n\n#include <openssl/bn.h>\n#include <openssl/dh.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <time.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"xmalloc.h\"\n#include \"dh.h\"\n#include \"log.h\"\n#include \"misc.h\"\n\n#include \"openbsd-compat/openssl-compat.h\"\n\n \n\n \n#define QLINESIZE\t\t(100+8192)\n\n \n#define QSIZE_MINIMUM\t\t(511)\n\n \n\n \n#define SHIFT_BIT\t(3)\n#define SHIFT_BYTE\t(2)\n#define SHIFT_WORD\t(SHIFT_BIT+SHIFT_BYTE)\n#define SHIFT_MEGABYTE\t(20)\n#define SHIFT_MEGAWORD\t(SHIFT_MEGABYTE-SHIFT_BYTE)\n\n \n#define LARGE_MINIMUM\t(8UL)\t \n\n \n#define LARGE_MAXIMUM\t(127UL)\t \n\n \n#define SMALL_MAXIMUM\t(0xffffffffUL)\n\n \n#define TINY_NUMBER\t(1UL<<16)\n\n \n#define TEST_MAXIMUM\t(1UL<<16)\n#define TEST_MINIMUM\t(QSIZE_MINIMUM + 1)\n \n#define TEST_POWER\t(3)\t \n\n \n#define BIT_CLEAR(a,n)\t((a)[(n)>>SHIFT_WORD] &= ~(1L << ((n) & 31)))\n#define BIT_SET(a,n)\t((a)[(n)>>SHIFT_WORD] |= (1L << ((n) & 31)))\n#define BIT_TEST(a,n)\t((a)[(n)>>SHIFT_WORD] & (1L << ((n) & 31)))\n\n \n\n \n#define TRIAL_MINIMUM\t(4)\n\n \n\n \nstatic u_int32_t *TinySieve, tinybits;\n\n \nstatic u_int32_t *SmallSieve, smallbits, smallbase;\n\n \nstatic u_int32_t *LargeSieve, largewords, largetries, largenumbers;\nstatic u_int32_t largebits, largememory;\t \nstatic BIGNUM *largebase;\n\nint gen_candidates(FILE *, u_int32_t, u_int32_t, BIGNUM *);\nint prime_test(FILE *, FILE *, u_int32_t, u_int32_t, char *, unsigned long,\n    unsigned long);\n\n \nstatic int\nqfileout(FILE * ofile, u_int32_t otype, u_int32_t otests, u_int32_t otries,\n    u_int32_t osize, u_int32_t ogenerator, BIGNUM * omodulus)\n{\n\tstruct tm *gtm;\n\ttime_t time_now;\n\tint res;\n\n\ttime(&time_now);\n\tgtm = gmtime(&time_now);\n\tif (gtm == NULL)\n\t\treturn -1;\n\n\tres = fprintf(ofile, \"%04d%02d%02d%02d%02d%02d %u %u %u %u %x \",\n\t    gtm->tm_year + 1900, gtm->tm_mon + 1, gtm->tm_mday,\n\t    gtm->tm_hour, gtm->tm_min, gtm->tm_sec,\n\t    otype, otests, otries, osize, ogenerator);\n\n\tif (res < 0)\n\t\treturn (-1);\n\n\tif (BN_print_fp(ofile, omodulus) < 1)\n\t\treturn (-1);\n\n\tres = fprintf(ofile, \"\\n\");\n\tfflush(ofile);\n\n\treturn (res > 0 ? 0 : -1);\n}\n\n\n \nstatic void\nsieve_large(u_int32_t s32)\n{\n\tu_int64_t r, u, s = s32;\n\n\tdebug3(\"sieve_large %u\", s32);\n\tlargetries++;\n\t \n\tr = BN_mod_word(largebase, s32);\n\tif (r == 0)\n\t\tu = 0;  \n\telse\n\t\tu = s - r;  \n\n\tif (u < largebits * 2ULL) {\n\t\t \n\t\tif (u & 0x1)\n\t\t\tu += s;  \n\n\t\t \n\t\tfor (u /= 2; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n\n\t \n\tr = (2 * r + 1) % s;\n\tif (r == 0)\n\t\tu = 0;  \n\telse\n\t\tu = s - r;  \n\n\tif (u < largebits * 4ULL) {\n\t\t \n\t\twhile (u & 0x3) {\n\t\t\tif (SMALL_MAXIMUM - u < s)\n\t\t\t\treturn;\n\t\t\tu += s;\n\t\t}\n\n\t\t \n\t\tfor (u /= 4; u < largebits; u += s)\n\t\t\tBIT_SET(LargeSieve, u);\n\t}\n}\n\n \nint\ngen_candidates(FILE *out, u_int32_t memory, u_int32_t power, BIGNUM *start)\n{\n\tBIGNUM *q;\n\tu_int32_t j, r, s, t;\n\tu_int32_t smallwords = TINY_NUMBER >> 6;\n\tu_int32_t tinywords = TINY_NUMBER >> 6;\n\ttime_t time_start, time_stop;\n\tu_int32_t i;\n\tint ret = 0;\n\n\tlargememory = memory;\n\n\tif (memory != 0 &&\n\t    (memory < LARGE_MINIMUM || memory > LARGE_MAXIMUM)) {\n\t\terror(\"Invalid memory amount (min %ld, max %ld)\",\n\t\t    LARGE_MINIMUM, LARGE_MAXIMUM);\n\t\treturn (-1);\n\t}\n\n\t \n\tif (power > TEST_MAXIMUM) {\n\t\terror(\"Too many bits: %u > %lu\", power, TEST_MAXIMUM);\n\t\treturn (-1);\n\t} else if (power < TEST_MINIMUM) {\n\t\terror(\"Too few bits: %u < %u\", power, TEST_MINIMUM);\n\t\treturn (-1);\n\t}\n\tpower--;  \n\n\t \n\tlargewords = ((power * power) >> (SHIFT_WORD - TEST_POWER));\n\n\t \n\tif (largememory > LARGE_MAXIMUM) {\n\t\tlogit(\"Limited memory: %u MB; limit %lu MB\",\n\t\t    largememory, LARGE_MAXIMUM);\n\t\tlargememory = LARGE_MAXIMUM;\n\t}\n\n\tif (largewords <= (largememory << SHIFT_MEGAWORD)) {\n\t\tlogit(\"Increased memory: %u MB; need %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t} else if (largememory > 0) {\n\t\tlogit(\"Decreased memory: %u MB; want %u bytes\",\n\t\t    largememory, (largewords << SHIFT_BYTE));\n\t\tlargewords = (largememory << SHIFT_MEGAWORD);\n\t}\n\n\tTinySieve = xcalloc(tinywords, sizeof(u_int32_t));\n\ttinybits = tinywords << SHIFT_WORD;\n\n\tSmallSieve = xcalloc(smallwords, sizeof(u_int32_t));\n\tsmallbits = smallwords << SHIFT_WORD;\n\n\t \n\twhile ((LargeSieve = calloc(largewords, sizeof(u_int32_t))) == NULL)\n\t\tlargewords -= (1L << (SHIFT_MEGAWORD - 2));  \n\n\tlargebits = largewords << SHIFT_WORD;\n\tlargenumbers = largebits * 2;\t \n\n\t \n\tlargetries = 0;\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\n\t \n\tif ((largebase = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif (start == NULL) {\n\t\tif (BN_rand(largebase, power, 1, 1) == 0)\n\t\t\tfatal(\"BN_rand failed\");\n\t} else {\n\t\tif (BN_copy(largebase, start) == NULL)\n\t\t\tfatal(\"BN_copy: failed\");\n\t}\n\n\t \n\tif (BN_set_bit(largebase, 0) == 0)\n\t\tfatal(\"BN_set_bit: failed\");\n\n\ttime(&time_start);\n\n\tlogit(\"%.24s Sieve next %u plus %u-bit\", ctime(&time_start),\n\t    largenumbers, power);\n\tdebug2(\"start point: 0x%s\", BN_bn2hex(largebase));\n\n\t \n\tfor (i = 0; i < tinybits; i++) {\n\t\tif (BIT_TEST(TinySieve, i))\n\t\t\tcontinue;  \n\n\t\t \n\t\tt = 2 * i + 3;\n\n\t\t \n\t\tfor (j = i + t; j < tinybits; j += t)\n\t\t\tBIT_SET(TinySieve, j);\n\n\t\tsieve_large(t);\n\t}\n\n\t \n\tfor (smallbase = TINY_NUMBER + 3;\n\t    smallbase < (SMALL_MAXIMUM - TINY_NUMBER);\n\t    smallbase += TINY_NUMBER) {\n\t\tfor (i = 0; i < tinybits; i++) {\n\t\t\tif (BIT_TEST(TinySieve, i))\n\t\t\t\tcontinue;  \n\n\t\t\t \n\t\t\tt = 2 * i + 3;\n\t\t\tr = smallbase % t;\n\n\t\t\tif (r == 0) {\n\t\t\t\ts = 0;  \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ts = t - r;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (s & 1)\n\t\t\t\ts += t;  \n\n\t\t\t \n\t\t\tfor (s /= 2; s < smallbits; s += t)\n\t\t\t\tBIT_SET(SmallSieve, s);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < smallbits; i++) {\n\t\t\tif (BIT_TEST(SmallSieve, i))\n\t\t\t\tcontinue;  \n\n\t\t\t \n\t\t\tsieve_large((2 * i) + smallbase);\n\t\t}\n\n\t\tmemset(SmallSieve, 0, smallwords << SHIFT_BYTE);\n\t}\n\n\ttime(&time_stop);\n\n\tlogit(\"%.24s Sieved with %u small primes in %lld seconds\",\n\t    ctime(&time_stop), largetries, (long long)(time_stop - time_start));\n\n\tfor (j = r = 0; j < largebits; j++) {\n\t\tif (BIT_TEST(LargeSieve, j))\n\t\t\tcontinue;  \n\n\t\tdebug2(\"test q = largebase+%u\", 2 * j);\n\t\tif (BN_set_word(q, 2 * j) == 0)\n\t\t\tfatal(\"BN_set_word failed\");\n\t\tif (BN_add(q, q, largebase) == 0)\n\t\t\tfatal(\"BN_add failed\");\n\t\tif (qfileout(out, MODULI_TYPE_SOPHIE_GERMAIN,\n\t\t    MODULI_TESTS_SIEVE, largetries,\n\t\t    (power - 1)  , (0), q) == -1) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tr++;  \n\t}\n\n\ttime(&time_stop);\n\n\tfree(LargeSieve);\n\tfree(SmallSieve);\n\tfree(TinySieve);\n\n\tlogit(\"%.24s Found %u candidates\", ctime(&time_stop), r);\n\n\treturn (ret);\n}\n\nstatic void\nwrite_checkpoint(char *cpfile, u_int32_t lineno)\n{\n\tFILE *fp;\n\tchar tmp[PATH_MAX];\n\tint r, writeok, closeok;\n\n\tr = snprintf(tmp, sizeof(tmp), \"%s.XXXXXXXXXX\", cpfile);\n\tif (r < 0 || r >= PATH_MAX) {\n\t\tlogit(\"write_checkpoint: temp pathname too long\");\n\t\treturn;\n\t}\n\tif ((r = mkstemp(tmp)) == -1) {\n\t\tlogit(\"mkstemp(%s): %s\", tmp, strerror(errno));\n\t\treturn;\n\t}\n\tif ((fp = fdopen(r, \"w\")) == NULL) {\n\t\tlogit(\"write_checkpoint: fdopen: %s\", strerror(errno));\n\t\tunlink(tmp);\n\t\tclose(r);\n\t\treturn;\n\t}\n\twriteok = (fprintf(fp, \"%lu\\n\", (unsigned long)lineno) > 0);\n\tcloseok = (fclose(fp) == 0);\n\tif (writeok && closeok && rename(tmp, cpfile) == 0) {\n\t\tdebug3(\"wrote checkpoint line %lu to '%s'\",\n\t\t    (unsigned long)lineno, cpfile);\n\t} else {\n\t\tlogit(\"failed to write to checkpoint file '%s': %s\", cpfile,\n\t\t    strerror(errno));\n\t\t(void)unlink(tmp);\n\t}\n}\n\nstatic unsigned long\nread_checkpoint(char *cpfile)\n{\n\tFILE *fp;\n\tunsigned long lineno = 0;\n\n\tif ((fp = fopen(cpfile, \"r\")) == NULL)\n\t\treturn 0;\n\tif (fscanf(fp, \"%lu\\n\", &lineno) < 1)\n\t\tlogit(\"Failed to load checkpoint from '%s'\", cpfile);\n\telse\n\t\tlogit(\"Loaded checkpoint from '%s' line %lu\", cpfile, lineno);\n\tfclose(fp);\n\treturn lineno;\n}\n\nstatic unsigned long\ncount_lines(FILE *f)\n{\n\tunsigned long count = 0;\n\tchar lp[QLINESIZE + 1];\n\n\tif (fseek(f, 0, SEEK_SET) != 0) {\n\t\tdebug(\"input file is not seekable\");\n\t\treturn ULONG_MAX;\n\t}\n\twhile (fgets(lp, QLINESIZE + 1, f) != NULL)\n\t\tcount++;\n\trewind(f);\n\tdebug(\"input file has %lu lines\", count);\n\treturn count;\n}\n\nstatic char *\nfmt_time(time_t seconds)\n{\n\tint day, hr, min;\n\tstatic char buf[128];\n\n\tmin = (seconds / 60) % 60;\n\thr = (seconds / 60 / 60) % 24;\n\tday = seconds / 60 / 60 / 24;\n\tif (day > 0)\n\t\tsnprintf(buf, sizeof buf, \"%dd %d:%02d\", day, hr, min);\n\telse\n\t\tsnprintf(buf, sizeof buf, \"%d:%02d\", hr, min);\n\treturn buf;\n}\n\nstatic void\nprint_progress(unsigned long start_lineno, unsigned long current_lineno,\n    unsigned long end_lineno)\n{\n\tstatic time_t time_start, time_prev;\n\ttime_t time_now, elapsed;\n\tunsigned long num_to_process, processed, remaining, percent, eta;\n\tdouble time_per_line;\n\tchar *eta_str;\n\n\ttime_now = monotime();\n\tif (time_start == 0) {\n\t\ttime_start = time_prev = time_now;\n\t\treturn;\n\t}\n\t \n\tif (time_now - time_prev < 5 * 60)\n\t\treturn;\n\ttime_prev = time_now;\n\telapsed = time_now - time_start;\n\tprocessed = current_lineno - start_lineno;\n\tremaining = end_lineno - current_lineno;\n\tnum_to_process = end_lineno - start_lineno;\n\ttime_per_line = (double)elapsed / processed;\n\t \n\ttime(&time_now);\n\tif (end_lineno == ULONG_MAX) {\n\t\tlogit(\"%.24s processed %lu in %s\", ctime(&time_now),\n\t\t    processed, fmt_time(elapsed));\n\t\treturn;\n\t}\n\tpercent = 100 * processed / num_to_process;\n\teta = time_per_line * remaining;\n\teta_str = xstrdup(fmt_time(eta));\n\tlogit(\"%.24s processed %lu of %lu (%lu%%) in %s, ETA %s\",\n\t    ctime(&time_now), processed, num_to_process, percent,\n\t    fmt_time(elapsed), eta_str);\n\tfree(eta_str);\n}\n\n \nint\nprime_test(FILE *in, FILE *out, u_int32_t trials, u_int32_t generator_wanted,\n    char *checkpoint_file, unsigned long start_lineno, unsigned long num_lines)\n{\n\tBIGNUM *q, *p, *a;\n\tchar *cp, *lp;\n\tu_int32_t count_in = 0, count_out = 0, count_possible = 0;\n\tu_int32_t generator_known, in_tests, in_tries, in_type, in_size;\n\tunsigned long last_processed = 0, end_lineno;\n\ttime_t time_start, time_stop;\n\tint res, is_prime;\n\n\tif (trials < TRIAL_MINIMUM) {\n\t\terror(\"Minimum primality trials is %d\", TRIAL_MINIMUM);\n\t\treturn (-1);\n\t}\n\n\tif (num_lines == 0)\n\t\tend_lineno = count_lines(in);\n\telse\n\t\tend_lineno = start_lineno + num_lines;\n\n\ttime(&time_start);\n\n\tif ((p = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\tif ((q = BN_new()) == NULL)\n\t\tfatal(\"BN_new failed\");\n\n\tdebug2(\"%.24s Final %u Miller-Rabin trials (%x generator)\",\n\t    ctime(&time_start), trials, generator_wanted);\n\n\tif (checkpoint_file != NULL)\n\t\tlast_processed = read_checkpoint(checkpoint_file);\n\tlast_processed = start_lineno = MAXIMUM(last_processed, start_lineno);\n\tif (end_lineno == ULONG_MAX)\n\t\tdebug(\"process from line %lu from pipe\", last_processed);\n\telse\n\t\tdebug(\"process from line %lu to line %lu\", last_processed,\n\t\t    end_lineno);\n\n\tres = 0;\n\tlp = xmalloc(QLINESIZE + 1);\n\twhile (fgets(lp, QLINESIZE + 1, in) != NULL && count_in < end_lineno) {\n\t\tcount_in++;\n\t\tif (count_in <= last_processed) {\n\t\t\tdebug3(\"skipping line %u, before checkpoint or \"\n\t\t\t    \"specified start line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tif (checkpoint_file != NULL)\n\t\t\twrite_checkpoint(checkpoint_file, count_in);\n\t\tprint_progress(start_lineno, count_in, end_lineno);\n\t\tif (strlen(lp) < 14 || *lp == '!' || *lp == '#') {\n\t\t\tdebug2(\"%10u: comment or short line\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t \n\t\tcp = &lp[14];\t \n\n\t\t \n\t\tin_type = strtoul(cp, &cp, 10);\n\n\t\t \n\t\tin_tests = strtoul(cp, &cp, 10);\n\n\t\tif (in_tests & MODULI_TESTS_COMPOSITE) {\n\t\t\tdebug2(\"%10u: known composite\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tin_tries = strtoul(cp, &cp, 10);\n\n\t\t \n\t\tin_size = strtoul(cp, &cp, 10);\n\n\t\t \n\t\tgenerator_known = strtoul(cp, &cp, 16);\n\n\t\t \n\t\tcp += strspn(cp, \" \");\n\n\t\t \n\t\tswitch (in_type) {\n\t\tcase MODULI_TYPE_SOPHIE_GERMAIN:\n\t\t\tdebug2(\"%10u: (%u) Sophie-Germain\", count_in, in_type);\n\t\t\ta = q;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t \n\t\t\tif (BN_lshift(p, q, 1) == 0)\n\t\t\t\tfatal(\"BN_lshift failed\");\n\t\t\tif (BN_add_word(p, 1) == 0)\n\t\t\t\tfatal(\"BN_add_word failed\");\n\t\t\tin_size += 1;\n\t\t\tgenerator_known = 0;\n\t\t\tbreak;\n\t\tcase MODULI_TYPE_UNSTRUCTURED:\n\t\tcase MODULI_TYPE_SAFE:\n\t\tcase MODULI_TYPE_SCHNORR:\n\t\tcase MODULI_TYPE_STRONG:\n\t\tcase MODULI_TYPE_UNKNOWN:\n\t\t\tdebug2(\"%10u: (%u)\", count_in, in_type);\n\t\t\ta = p;\n\t\t\tif (BN_hex2bn(&a, cp) == 0)\n\t\t\t\tfatal(\"BN_hex2bn failed\");\n\t\t\t \n\t\t\tif (BN_rshift(q, p, 1) == 0)\n\t\t\t\tfatal(\"BN_rshift failed\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdebug2(\"Unknown prime type\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif ((u_int32_t)BN_num_bits(p) != (in_size + 1)) {\n\t\t\tdebug2(\"%10u: bit size %u mismatch\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\t\tif (in_size < QSIZE_MINIMUM) {\n\t\t\tdebug2(\"%10u: bit size %u too short\", count_in, in_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (in_tests & MODULI_TESTS_MILLER_RABIN)\n\t\t\tin_tries += trials;\n\t\telse\n\t\t\tin_tries = trials;\n\n\t\t \n\t\tif (generator_known == 0) {\n\t\t\tif (BN_mod_word(p, 24) == 11)\n\t\t\t\tgenerator_known = 2;\n\t\t\telse {\n\t\t\t\tu_int32_t r = BN_mod_word(p, 10);\n\n\t\t\t\tif (r == 3 || r == 7)\n\t\t\t\t\tgenerator_known = 5;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (generator_wanted > 0 &&\n\t\t    generator_wanted != generator_known) {\n\t\t\tdebug2(\"%10u: generator %d != %d\",\n\t\t\t    count_in, generator_known, generator_wanted);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (generator_known == 0) {\n\t\t\tdebug2(\"%10u: no known generator\", count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_possible++;\n\n\t\t \n\t\tis_prime = BN_is_prime_ex(q, 1, NULL, NULL);\n\t\tif (is_prime < 0)\n\t\t\tfatal(\"BN_is_prime_ex failed\");\n\t\tif (is_prime == 0) {\n\t\t\tdebug(\"%10u: q failed first possible prime test\",\n\t\t\t    count_in);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tis_prime = BN_is_prime_ex(p, trials, NULL, NULL);\n\t\tif (is_prime < 0)\n\t\t\tfatal(\"BN_is_prime_ex failed\");\n\t\tif (is_prime == 0) {\n\t\t\tdebug(\"%10u: p is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: p is almost certainly prime\", count_in);\n\n\t\t \n\t\tis_prime = BN_is_prime_ex(q, trials - 1, NULL, NULL);\n\t\tif (is_prime < 0)\n\t\t\tfatal(\"BN_is_prime_ex failed\");\n\t\tif (is_prime == 0) {\n\t\t\tdebug(\"%10u: q is not prime\", count_in);\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(\"%10u: q is almost certainly prime\", count_in);\n\n\t\tif (qfileout(out, MODULI_TYPE_SAFE,\n\t\t    in_tests | MODULI_TESTS_MILLER_RABIN,\n\t\t    in_tries, in_size, generator_known, p)) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount_out++;\n\t}\n\n\ttime(&time_stop);\n\tfree(lp);\n\tBN_free(p);\n\tBN_free(q);\n\n\tif (checkpoint_file != NULL)\n\t\tunlink(checkpoint_file);\n\n\tlogit(\"%.24s Found %u safe primes of %u candidates in %ld seconds\",\n\t    ctime(&time_stop), count_out, count_possible,\n\t    (long) (time_stop - time_start));\n\n\treturn (res);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}