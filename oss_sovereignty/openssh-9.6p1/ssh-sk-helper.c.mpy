{
  "module_name": "ssh-sk-helper.c",
  "hash_id": "c7f1a6151be331d305a69e0797f61d1e806b5dfa337ad8b968696509b30eae1b",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-sk-helper.c",
  "human_readable_source": " \n \n\n \n \n#include \"includes.h\"\n\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"xmalloc.h\"\n#include \"log.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"misc.h\"\n#include \"sshbuf.h\"\n#include \"msg.h\"\n#include \"uidswap.h\"\n#include \"ssherr.h\"\n#include \"ssh-sk.h\"\n\n#ifdef ENABLE_SK\nextern char *__progname;\n\nstatic struct sshbuf *reply_error(int r, char *fmt, ...)\n    __attribute__((__format__ (printf, 2, 3)));\n\nstatic struct sshbuf *\nreply_error(int r, char *fmt, ...)\n{\n\tchar *msg;\n\tva_list ap;\n\tstruct sshbuf *resp;\n\n\tva_start(ap, fmt);\n\txvasprintf(&msg, fmt, ap);\n\tva_end(ap);\n\tdebug(\"%s: %s\", __progname, msg);\n\tfree(msg);\n\n\tif (r >= 0)\n\t\tfatal_f(\"invalid error code %d\", r);\n\n\tif ((resp = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\tif (sshbuf_put_u32(resp, SSH_SK_HELPER_ERROR) != 0 ||\n\t    sshbuf_put_u32(resp, (u_int)-r) != 0)\n\t\tfatal(\"%s: buffer error\", __progname);\n\treturn resp;\n}\n\n \nstatic void\nnull_empty(char **s)\n{\n\tif (s == NULL || *s == NULL || **s != '\\0')\n\t\treturn;\n\n\tfree(*s);\n\t*s = NULL;\n}\n\nstatic struct sshbuf *\nprocess_sign(struct sshbuf *req)\n{\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\tstruct sshbuf *resp, *kbuf;\n\tstruct sshkey *key = NULL;\n\tuint32_t compat;\n\tconst u_char *message;\n\tu_char *sig = NULL;\n\tsize_t msglen, siglen = 0;\n\tchar *provider = NULL, *pin = NULL;\n\n\tif ((r = sshbuf_froms(req, &kbuf)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_string_direct(req, &message, &msglen)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, NULL, NULL)) != 0 ||  \n\t    (r = sshbuf_get_u32(req, &compat)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &pin, NULL)) != 0)\n\t\tfatal_r(r, \"%s: parse\", __progname);\n\tif (sshbuf_len(req) != 0)\n\t\tfatal(\"%s: trailing data in request\", __progname);\n\n\tif ((r = sshkey_private_deserialize(kbuf, &key)) != 0)\n\t\tfatal_r(r, \"%s: Unable to parse private key\", __progname);\n\tif (!sshkey_is_sk(key)) {\n\t\tfatal(\"%s: Unsupported key type %s\",\n\t\t    __progname, sshkey_ssh_name(key));\n\t}\n\n\tdebug_f(\"ready to sign with key %s, provider %s: \"\n\t    \"msg len %zu, compat 0x%lx\", sshkey_type(key),\n\t    provider, msglen, (u_long)compat);\n\n\tnull_empty(&pin);\n\n\tif ((r = sshsk_sign(provider, key, &sig, &siglen,\n\t    message, msglen, compat, pin)) != 0) {\n\t\tresp = reply_error(r, \"Signing failed: %s\", ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tif ((resp = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\n\tif ((r = sshbuf_put_u32(resp, SSH_SK_HELPER_SIGN)) != 0 ||\n\t    (r = sshbuf_put_string(resp, sig, siglen)) != 0)\n\t\tfatal_r(r, \"%s: compose\", __progname);\n out:\n\tsshkey_free(key);\n\tsshbuf_free(kbuf);\n\tfree(provider);\n\tif (sig != NULL)\n\t\tfreezero(sig, siglen);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\treturn resp;\n}\n\nstatic struct sshbuf *\nprocess_enroll(struct sshbuf *req)\n{\n\tint r;\n\tu_int type;\n\tchar *provider, *application, *pin, *device, *userid;\n\tuint8_t flags;\n\tstruct sshbuf *challenge, *attest, *kbuf, *resp;\n\tstruct sshkey *key;\n\n\tif ((attest = sshbuf_new()) == NULL ||\n\t    (kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\n\tif ((r = sshbuf_get_u32(req, &type)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &device, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &application, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &userid, NULL)) != 0 ||\n\t    (r = sshbuf_get_u8(req, &flags)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &pin, NULL)) != 0 ||\n\t    (r = sshbuf_froms(req, &challenge)) != 0)\n\t\tfatal_r(r, \"%s: parse\", __progname);\n\tif (sshbuf_len(req) != 0)\n\t\tfatal(\"%s: trailing data in request\", __progname);\n\n\tif (type > INT_MAX)\n\t\tfatal(\"%s: bad type %u\", __progname, type);\n\tif (sshbuf_len(challenge) == 0) {\n\t\tsshbuf_free(challenge);\n\t\tchallenge = NULL;\n\t}\n\tnull_empty(&device);\n\tnull_empty(&userid);\n\tnull_empty(&pin);\n\n\tif ((r = sshsk_enroll((int)type, provider, device, application, userid,\n\t    flags, pin, challenge, &key, attest)) != 0) {\n\t\tresp = reply_error(r, \"Enrollment failed: %s\", ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tif ((resp = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\tif ((r = sshkey_private_serialize(key, kbuf)) != 0)\n\t\tfatal_r(r, \"%s: encode key\", __progname);\n\tif ((r = sshbuf_put_u32(resp, SSH_SK_HELPER_ENROLL)) != 0 ||\n\t    (r = sshbuf_put_stringb(resp, kbuf)) != 0 ||\n\t    (r = sshbuf_put_stringb(resp, attest)) != 0)\n\t\tfatal_r(r, \"%s: compose\", __progname);\n\n out:\n\tsshkey_free(key);\n\tsshbuf_free(kbuf);\n\tsshbuf_free(attest);\n\tsshbuf_free(challenge);\n\tfree(provider);\n\tfree(application);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\n\treturn resp;\n}\n\nstatic struct sshbuf *\nprocess_load_resident(struct sshbuf *req)\n{\n\tint r;\n\tchar *provider, *pin, *device;\n\tstruct sshbuf *kbuf, *resp;\n\tstruct sshsk_resident_key **srks = NULL;\n\tsize_t nsrks = 0, i;\n\tu_int flags;\n\n\tif ((kbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\n\tif ((r = sshbuf_get_cstring(req, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &device, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(req, &pin, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(req, &flags)) != 0)\n\t\tfatal_r(r, \"%s: parse\", __progname);\n\tif (sshbuf_len(req) != 0)\n\t\tfatal(\"%s: trailing data in request\", __progname);\n\n\tnull_empty(&device);\n\tnull_empty(&pin);\n\n\tif ((r = sshsk_load_resident(provider, device, pin, flags,\n\t    &srks, &nsrks)) != 0) {\n\t\tresp = reply_error(r, \"sshsk_load_resident failed: %s\",\n\t\t    ssh_err(r));\n\t\tgoto out;\n\t}\n\n\tif ((resp = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\n\tif ((r = sshbuf_put_u32(resp, SSH_SK_HELPER_LOAD_RESIDENT)) != 0)\n\t\tfatal_r(r, \"%s: compose\", __progname);\n\n\tfor (i = 0; i < nsrks; i++) {\n\t\tdebug_f(\"key %zu %s %s uidlen %zu\", i,\n\t\t    sshkey_type(srks[i]->key), srks[i]->key->sk_application,\n\t\t    srks[i]->user_id_len);\n\t\tsshbuf_reset(kbuf);\n\t\tif ((r = sshkey_private_serialize(srks[i]->key, kbuf)) != 0)\n\t\t\tfatal_r(r, \"%s: encode key\", __progname);\n\t\tif ((r = sshbuf_put_stringb(resp, kbuf)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(resp, \"\")) != 0 ||  \n\t\t    (r = sshbuf_put_string(resp, srks[i]->user_id,\n\t\t    srks[i]->user_id_len)) != 0)\n\t\t\tfatal_r(r, \"%s: compose key\", __progname);\n\t}\n\n out:\n\tsshsk_free_resident_keys(srks, nsrks);\n\tsshbuf_free(kbuf);\n\tfree(provider);\n\tfree(device);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\treturn resp;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tLogLevel log_level = SYSLOG_LEVEL_ERROR;\n\tstruct sshbuf *req, *resp;\n\tint in, out, ch, r, vflag = 0;\n\tu_int rtype, ll = 0;\n\tuint8_t version, log_stderr = 0;\n\n\tsanitise_stdfd();\n\tlog_init(__progname, log_level, log_facility, log_stderr);\n\n\twhile ((ch = getopt(argc, argv, \"v\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'v':\n\t\t\tvflag = 1;\n\t\t\tif (log_level == SYSLOG_LEVEL_ERROR)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse if (log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\tlog_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"usage: %s [-v]\\n\", __progname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tlog_init(__progname, log_level, log_facility, vflag);\n\n\t \n\tclosefrom(STDERR_FILENO + 1);\n\tif ((in = dup(STDIN_FILENO)) == -1 || (out = dup(STDOUT_FILENO)) == -1)\n\t\tfatal(\"%s: dup: %s\", __progname, strerror(errno));\n\tclose(STDIN_FILENO);\n\tclose(STDOUT_FILENO);\n\tsanitise_stdfd();  \n\n\tif ((req = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __progname);\n\tif (ssh_msg_recv(in, req) < 0)\n\t\tfatal(\"ssh_msg_recv failed\");\n\tclose(in);\n\tdebug_f(\"received message len %zu\", sshbuf_len(req));\n\n\tif ((r = sshbuf_get_u8(req, &version)) != 0)\n\t\tfatal_r(r, \"%s: parse version\", __progname);\n\tif (version != SSH_SK_HELPER_VERSION) {\n\t\tfatal(\"unsupported version: received %d, expected %d\",\n\t\t    version, SSH_SK_HELPER_VERSION);\n\t}\n\n\tif ((r = sshbuf_get_u32(req, &rtype)) != 0 ||\n\t    (r = sshbuf_get_u8(req, &log_stderr)) != 0 ||\n\t    (r = sshbuf_get_u32(req, &ll)) != 0)\n\t\tfatal_r(r, \"%s: parse\", __progname);\n\n\tif (!vflag && log_level_name((LogLevel)ll) != NULL)\n\t\tlog_init(__progname, (LogLevel)ll, log_facility, log_stderr);\n\n\tswitch (rtype) {\n\tcase SSH_SK_HELPER_SIGN:\n\t\tresp = process_sign(req);\n\t\tbreak;\n\tcase SSH_SK_HELPER_ENROLL:\n\t\tresp = process_enroll(req);\n\t\tbreak;\n\tcase SSH_SK_HELPER_LOAD_RESIDENT:\n\t\tresp = process_load_resident(req);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: unsupported request type %u\", __progname, rtype);\n\t}\n\tsshbuf_free(req);\n\tdebug_f(\"reply len %zu\", sshbuf_len(resp));\n\n\tif (ssh_msg_send(out, SSH_SK_HELPER_VERSION, resp) == -1)\n\t\tfatal(\"ssh_msg_send failed\");\n\tsshbuf_free(resp);\n\tclose(out);\n\n\treturn (0);\n}\n#else  \n#include <stdio.h>\n\nint\nmain(int argc, char **argv)\n{\n\tfprintf(stderr, \"ssh-sk-helper: disabled at compile time\\n\");\n\treturn -1;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}