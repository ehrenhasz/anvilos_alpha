{
  "module_name": "ssh-add.c",
  "hash_id": "b498af650a9b1bd2a4923f93a875769e493c8f5b04a085eeb779083c4c0678bf",
  "original_prompt": "Ingested from openssh-9.6p1/ssh-add.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#ifdef WITH_OPENSSL\n# include <openssl/evp.h>\n# include \"openbsd-compat/openssl-compat.h\"\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <limits.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"log.h\"\n#include \"sshkey.h\"\n#include \"sshbuf.h\"\n#include \"authfd.h\"\n#include \"authfile.h\"\n#include \"pathnames.h\"\n#include \"misc.h\"\n#include \"ssherr.h\"\n#include \"digest.h\"\n#include \"ssh-sk.h\"\n#include \"sk-api.h\"\n#include \"hostfile.h\"\n\n \nextern char *__progname;\n\n \nstatic char *default_files[] = {\n#ifdef WITH_OPENSSL\n\t_PATH_SSH_CLIENT_ID_RSA,\n#ifdef OPENSSL_HAS_ECC\n\t_PATH_SSH_CLIENT_ID_ECDSA,\n\t_PATH_SSH_CLIENT_ID_ECDSA_SK,\n#endif\n#endif  \n\t_PATH_SSH_CLIENT_ID_ED25519,\n\t_PATH_SSH_CLIENT_ID_ED25519_SK,\n\t_PATH_SSH_CLIENT_ID_XMSS,\n\t_PATH_SSH_CLIENT_ID_DSA,\n\tNULL\n};\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\n \nstatic int lifetime = 0;\n\n \nstatic int confirm = 0;\n\n \nstatic u_int maxsign = 0;\nstatic u_int minleft = 0;\n\n \nstatic char *pass = NULL;\nstatic void\nclear_pass(void)\n{\n\tif (pass) {\n\t\tfreezero(pass, strlen(pass));\n\t\tpass = NULL;\n\t}\n}\n\nstatic int\ndelete_one(int agent_fd, const struct sshkey *key, const char *comment,\n    const char *path, int qflag)\n{\n\tint r;\n\n\tif ((r = ssh_remove_identity(agent_fd, key)) != 0) {\n\t\tfprintf(stderr, \"Could not remove identity \\\"%s\\\": %s\\n\",\n\t\t    path, ssh_err(r));\n\t\treturn r;\n\t}\n\tif (!qflag) {\n\t\tfprintf(stderr, \"Identity removed: %s %s (%s)\\n\", path,\n\t\t    sshkey_type(key), comment ? comment : \"no comment\");\n\t}\n\treturn 0;\n}\n\nstatic int\ndelete_stdin(int agent_fd, int qflag, int key_only, int cert_only)\n{\n\tchar *line = NULL, *cp;\n\tsize_t linesize = 0;\n\tstruct sshkey *key = NULL;\n\tint lnum = 0, r, ret = -1;\n\n\twhile (getline(&line, &linesize, stdin) != -1) {\n\t\tlnum++;\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tline[strcspn(line, \"\\n\")] = '\\0';\n\t\tcp = line + strspn(line, \" \\t\");\n\t\tif (*cp == '#' || *cp == '\\0')\n\t\t\tcontinue;\n\t\tif ((key = sshkey_new(KEY_UNSPEC)) == NULL)\n\t\t\tfatal_f(\"sshkey_new\");\n\t\tif ((r = sshkey_read(key, &cp)) != 0) {\n\t\t\terror_r(r, \"(stdin):%d: invalid key\", lnum);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((!key_only && !cert_only) ||\n\t\t    (key_only && !sshkey_is_cert(key)) ||\n\t\t    (cert_only && sshkey_is_cert(key))) {\n\t\t\tif (delete_one(agent_fd, key, cp,\n\t\t\t    \"(stdin)\", qflag) == 0)\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\tsshkey_free(key);\n\tfree(line);\n\treturn ret;\n}\n\nstatic int\ndelete_file(int agent_fd, const char *filename, int key_only,\n    int cert_only, int qflag)\n{\n\tstruct sshkey *public, *cert = NULL;\n\tchar *certpath = NULL, *comment = NULL;\n\tint r, ret = -1;\n\n\tif (strcmp(filename, \"-\") == 0)\n\t\treturn delete_stdin(agent_fd, qflag, key_only, cert_only);\n\n\tif ((r = sshkey_load_public(filename, &public,  &comment)) != 0) {\n\t\tprintf(\"Bad key file %s: %s\\n\", filename, ssh_err(r));\n\t\treturn -1;\n\t}\n\tif ((!key_only && !cert_only) ||\n\t    (key_only && !sshkey_is_cert(public)) ||\n\t    (cert_only && sshkey_is_cert(public))) {\n\t\tif (delete_one(agent_fd, public, comment, filename, qflag) == 0)\n\t\t\tret = 0;\n\t}\n\n\tif (key_only)\n\t\tgoto out;\n\n\t \n\tfree(comment);\n\tcomment = NULL;\n\txasprintf(&certpath, \"%s-cert.pub\", filename);\n\tif ((r = sshkey_load_public(certpath, &cert, &comment)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR || errno != ENOENT)\n\t\t\terror_r(r, \"Failed to load certificate \\\"%s\\\"\", certpath);\n\t\tgoto out;\n\t}\n\n\tif (!sshkey_equal_public(cert, public))\n\t\tfatal(\"Certificate %s does not match private key %s\",\n\t\t    certpath, filename);\n\n\tif (delete_one(agent_fd, cert, comment, certpath, qflag) == 0)\n\t\tret = 0;\n\n out:\n\tsshkey_free(cert);\n\tsshkey_free(public);\n\tfree(certpath);\n\tfree(comment);\n\n\treturn ret;\n}\n\n \nstatic int\ndelete_all(int agent_fd, int qflag)\n{\n\tint ret = -1;\n\n\t \n\tif (ssh_remove_all_identities(agent_fd, 2) == 0)\n\t\tret = 0;\n\t \n\tssh_remove_all_identities(agent_fd, 1);\n\n\tif (ret != 0)\n\t\tfprintf(stderr, \"Failed to remove all identities.\\n\");\n\telse if (!qflag)\n\t\tfprintf(stderr, \"All identities removed.\\n\");\n\n\treturn ret;\n}\n\nstatic int\nadd_file(int agent_fd, const char *filename, int key_only, int cert_only,\n    int qflag, const char *skprovider,\n    struct dest_constraint **dest_constraints,\n    size_t ndest_constraints)\n{\n\tstruct sshkey *private, *cert;\n\tchar *comment = NULL;\n\tchar msg[1024], *certpath = NULL;\n\tint r, fd, ret = -1;\n\tsize_t i;\n\tu_int32_t left;\n\tstruct sshbuf *keyblob;\n\tstruct ssh_identitylist *idlist;\n\n\tif (strcmp(filename, \"-\") == 0) {\n\t\tfd = STDIN_FILENO;\n\t\tfilename = \"(stdin)\";\n\t} else if ((fd = open(filename, O_RDONLY)) == -1) {\n\t\tperror(filename);\n\t\treturn -1;\n\t}\n\n\t \n\tif (fd != STDIN_FILENO) {\n\t\tif (sshkey_perm_ok(fd, filename) != 0) {\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif ((r = sshbuf_load_fd(fd, &keyblob)) != 0) {\n\t\tfprintf(stderr, \"Error loading key \\\"%s\\\": %s\\n\",\n\t\t    filename, ssh_err(r));\n\t\tsshbuf_free(keyblob);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tclose(fd);\n\n\t \n\tif ((r = sshkey_parse_private_fileblob(keyblob, \"\", &private,\n\t    &comment)) != 0 && r != SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\tfprintf(stderr, \"Error loading key \\\"%s\\\": %s\\n\",\n\t\t    filename, ssh_err(r));\n\t\tgoto fail_load;\n\t}\n\t \n\tif (private == NULL && pass != NULL) {\n\t\tif ((r = sshkey_parse_private_fileblob(keyblob, pass, &private,\n\t\t    &comment)) != 0 && r != SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\t\tfprintf(stderr, \"Error loading key \\\"%s\\\": %s\\n\",\n\t\t\t    filename, ssh_err(r));\n\t\t\tgoto fail_load;\n\t\t}\n\t}\n\tif (private == NULL) {\n\t\t \n\t\tclear_pass();\n\t\tsnprintf(msg, sizeof msg, \"Enter passphrase for %s%s: \",\n\t\t    filename, confirm ? \" (will confirm each use)\" : \"\");\n\t\tfor (;;) {\n\t\t\tpass = read_passphrase(msg, RP_ALLOW_STDIN);\n\t\t\tif (strcmp(pass, \"\") == 0)\n\t\t\t\tgoto fail_load;\n\t\t\tif ((r = sshkey_parse_private_fileblob(keyblob, pass,\n\t\t\t    &private, &comment)) == 0)\n\t\t\t\tbreak;\n\t\t\telse if (r != SSH_ERR_KEY_WRONG_PASSPHRASE) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Error loading key \\\"%s\\\": %s\\n\",\n\t\t\t\t    filename, ssh_err(r));\n fail_load:\n\t\t\t\tclear_pass();\n\t\t\t\tsshbuf_free(keyblob);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclear_pass();\n\t\t\tsnprintf(msg, sizeof msg,\n\t\t\t    \"Bad passphrase, try again for %s%s: \", filename,\n\t\t\t    confirm ? \" (will confirm each use)\" : \"\");\n\t\t}\n\t}\n\tif (comment == NULL || *comment == '\\0')\n\t\tcomment = xstrdup(filename);\n\tsshbuf_free(keyblob);\n\n\t \n\tif ((r = sshkey_set_filename(private, filename)) != 0) {\n\t\tfprintf(stderr, \"Could not add filename to private key: %s (%s)\\n\",\n\t\t    filename, comment);\n\t\tgoto out;\n\t}\n\tif (maxsign && minleft &&\n\t    (r = ssh_fetch_identitylist(agent_fd, &idlist)) == 0) {\n\t\tfor (i = 0; i < idlist->nkeys; i++) {\n\t\t\tif (!sshkey_equal_public(idlist->keys[i], private))\n\t\t\t\tcontinue;\n\t\t\tleft = sshkey_signatures_left(idlist->keys[i]);\n\t\t\tif (left < minleft) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Only %d signatures left.\\n\", left);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(stderr, \"Skipping update: \");\n\t\t\tif (left == minleft) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"required signatures left (%d).\\n\", left);\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"more signatures left (%d) than\"\n\t\t\t\t    \" required (%d).\\n\", left, minleft);\n\t\t\t}\n\t\t\tssh_free_identitylist(idlist);\n\t\t\tgoto out;\n\t\t}\n\t\tssh_free_identitylist(idlist);\n\t}\n\n\tif (sshkey_is_sk(private)) {\n\t\tif (skprovider == NULL) {\n\t\t\tfprintf(stderr, \"Cannot load FIDO key %s \"\n\t\t\t    \"without provider\\n\", filename);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tskprovider = NULL;\n\t}\n\n\tif (!cert_only &&\n\t    (r = ssh_add_identity_constrained(agent_fd, private, comment,\n\t    lifetime, confirm, maxsign, skprovider,\n\t    dest_constraints, ndest_constraints)) == 0) {\n\t\tret = 0;\n\t\tif (!qflag) {\n\t\t\tfprintf(stderr, \"Identity added: %s (%s)\\n\",\n\t\t\t    filename, comment);\n\t\t\tif (lifetime != 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Lifetime set to %d seconds\\n\", lifetime);\n\t\t\t}\n\t\t\tif (confirm != 0) {\n\t\t\t\tfprintf(stderr, \"The user must confirm \"\n\t\t\t\t    \"each use of the key\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Could not add identity \\\"%s\\\": %s\\n\",\n\t\t    filename, ssh_err(r));\n\t}\n\n\t \n\tif (key_only)\n\t\tgoto out;\n\n\t \n\txasprintf(&certpath, \"%s-cert.pub\", filename);\n\tif ((r = sshkey_load_public(certpath, &cert, NULL)) != 0) {\n\t\tif (r != SSH_ERR_SYSTEM_ERROR || errno != ENOENT)\n\t\t\terror_r(r, \"Failed to load certificate \\\"%s\\\"\",\n\t\t\t    certpath);\n\t\tgoto out;\n\t}\n\n\tif (!sshkey_equal_public(cert, private)) {\n\t\terror(\"Certificate %s does not match private key %s\",\n\t\t    certpath, filename);\n\t\tsshkey_free(cert);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((r = sshkey_to_certified(private)) != 0) {\n\t\terror_fr(r, \"sshkey_to_certified\");\n\t\tsshkey_free(cert);\n\t\tgoto out;\n\t}\n\tif ((r = sshkey_cert_copy(cert, private)) != 0) {\n\t\terror_fr(r, \"sshkey_cert_copy\");\n\t\tsshkey_free(cert);\n\t\tgoto out;\n\t}\n\tsshkey_free(cert);\n\n\tif ((r = ssh_add_identity_constrained(agent_fd, private, comment,\n\t    lifetime, confirm, maxsign, skprovider,\n\t    dest_constraints, ndest_constraints)) != 0) {\n\t\terror_r(r, \"Certificate %s (%s) add failed\", certpath,\n\t\t    private->cert->key_id);\n\t\tgoto out;\n\t}\n\t \n\tif (!qflag) {\n\t\tfprintf(stderr, \"Certificate added: %s (%s)\\n\", certpath,\n\t\t    private->cert->key_id);\n\t\tif (lifetime != 0) {\n\t\t\tfprintf(stderr, \"Lifetime set to %d seconds\\n\",\n\t\t\t    lifetime);\n\t\t}\n\t\tif (confirm != 0) {\n\t\t\tfprintf(stderr, \"The user must confirm each use \"\n\t\t\t    \"of the key\\n\");\n\t\t}\n\t}\n\n out:\n\tfree(certpath);\n\tfree(comment);\n\tsshkey_free(private);\n\n\treturn ret;\n}\n\nstatic int\nupdate_card(int agent_fd, int add, const char *id, int qflag,\n    int key_only, int cert_only,\n    struct dest_constraint **dest_constraints, size_t ndest_constraints,\n    struct sshkey **certs, size_t ncerts)\n{\n\tchar *pin = NULL;\n\tint r, ret = -1;\n\n\tif (key_only)\n\t\tncerts = 0;\n\n\tif (add) {\n\t\tif ((pin = read_passphrase(\"Enter passphrase for PKCS#11: \",\n\t\t    RP_ALLOW_STDIN)) == NULL)\n\t\t\treturn -1;\n\t}\n\n\tif ((r = ssh_update_card(agent_fd, add, id, pin == NULL ? \"\" : pin,\n\t    lifetime, confirm, dest_constraints, ndest_constraints,\n\t    cert_only, certs, ncerts)) == 0) {\n\t\tret = 0;\n\t\tif (!qflag) {\n\t\t\tfprintf(stderr, \"Card %s: %s\\n\",\n\t\t\t    add ? \"added\" : \"removed\", id);\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Could not %s card \\\"%s\\\": %s\\n\",\n\t\t    add ? \"add\" : \"remove\", id, ssh_err(r));\n\t\tret = -1;\n\t}\n\tfree(pin);\n\treturn ret;\n}\n\nstatic int\ntest_key(int agent_fd, const char *filename)\n{\n\tstruct sshkey *key = NULL;\n\tu_char *sig = NULL;\n\tconst char *alg = NULL;\n\tsize_t slen = 0;\n\tint r, ret = -1;\n\tchar data[1024];\n\n\tif ((r = sshkey_load_public(filename, &key, NULL)) != 0) {\n\t\terror_r(r, \"Couldn't read public key %s\", filename);\n\t\treturn -1;\n\t}\n\tif (sshkey_type_plain(key->type) == KEY_RSA)\n\t\talg = \"rsa-sha2-256\";\n\tarc4random_buf(data, sizeof(data));\n\tif ((r = ssh_agent_sign(agent_fd, key, &sig, &slen, data, sizeof(data),\n\t    alg, 0)) != 0) {\n\t\terror_r(r, \"Agent signature failed for %s\", filename);\n\t\tgoto done;\n\t}\n\tif ((r = sshkey_verify(key, sig, slen, data, sizeof(data),\n\t    alg, 0, NULL)) != 0) {\n\t\terror_r(r, \"Signature verification failed for %s\", filename);\n\t\tgoto done;\n\t}\n\t \n\tret = 0;\n done:\n\tfree(sig);\n\tsshkey_free(key);\n\treturn ret;\n}\n\nstatic int\nlist_identities(int agent_fd, int do_fp)\n{\n\tchar *fp;\n\tint r;\n\tstruct ssh_identitylist *idlist;\n\tu_int32_t left;\n\tsize_t i;\n\n\tif ((r = ssh_fetch_identitylist(agent_fd, &idlist)) != 0) {\n\t\tif (r != SSH_ERR_AGENT_NO_IDENTITIES)\n\t\t\tfprintf(stderr, \"error fetching identities: %s\\n\",\n\t\t\t    ssh_err(r));\n\t\telse\n\t\t\tprintf(\"The agent has no identities.\\n\");\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < idlist->nkeys; i++) {\n\t\tif (do_fp) {\n\t\t\tfp = sshkey_fingerprint(idlist->keys[i],\n\t\t\t    fingerprint_hash, SSH_FP_DEFAULT);\n\t\t\tprintf(\"%u %s %s (%s)\\n\", sshkey_size(idlist->keys[i]),\n\t\t\t    fp == NULL ? \"(null)\" : fp, idlist->comments[i],\n\t\t\t    sshkey_type(idlist->keys[i]));\n\t\t\tfree(fp);\n\t\t} else {\n\t\t\tif ((r = sshkey_write(idlist->keys[i], stdout)) != 0) {\n\t\t\t\tfprintf(stderr, \"sshkey_write: %s\\n\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfprintf(stdout, \" %s\", idlist->comments[i]);\n\t\t\tleft = sshkey_signatures_left(idlist->keys[i]);\n\t\t\tif (left > 0)\n\t\t\t\tfprintf(stdout,\n\t\t\t\t    \" [signatures left %d]\", left);\n\t\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\t}\n\tssh_free_identitylist(idlist);\n\treturn 0;\n}\n\nstatic int\nlock_agent(int agent_fd, int lock)\n{\n\tchar prompt[100], *p1, *p2;\n\tint r, passok = 1, ret = -1;\n\n\tstrlcpy(prompt, \"Enter lock password: \", sizeof(prompt));\n\tp1 = read_passphrase(prompt, RP_ALLOW_STDIN);\n\tif (lock) {\n\t\tstrlcpy(prompt, \"Again: \", sizeof prompt);\n\t\tp2 = read_passphrase(prompt, RP_ALLOW_STDIN);\n\t\tif (strcmp(p1, p2) != 0) {\n\t\t\tfprintf(stderr, \"Passwords do not match.\\n\");\n\t\t\tpassok = 0;\n\t\t}\n\t\tfreezero(p2, strlen(p2));\n\t}\n\tif (passok) {\n\t\tif ((r = ssh_lock_agent(agent_fd, lock, p1)) == 0) {\n\t\t\tfprintf(stderr, \"Agent %slocked.\\n\", lock ? \"\" : \"un\");\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Failed to %slock agent: %s\\n\",\n\t\t\t    lock ? \"\" : \"un\", ssh_err(r));\n\t\t}\n\t}\n\tfreezero(p1, strlen(p1));\n\treturn (ret);\n}\n\nstatic int\nload_resident_keys(int agent_fd, const char *skprovider, int qflag,\n    struct dest_constraint **dest_constraints, size_t ndest_constraints)\n{\n\tstruct sshsk_resident_key **srks;\n\tsize_t nsrks, i;\n\tstruct sshkey *key;\n\tint r, ok = 0;\n\tchar *fp;\n\n\tpass = read_passphrase(\"Enter PIN for authenticator: \", RP_ALLOW_STDIN);\n\tif ((r = sshsk_load_resident(skprovider, NULL, pass, 0,\n\t    &srks, &nsrks)) != 0) {\n\t\terror_r(r, \"Unable to load resident keys\");\n\t\treturn r;\n\t}\n\tfor (i = 0; i < nsrks; i++) {\n\t\tkey = srks[i]->key;\n\t\tif ((fp = sshkey_fingerprint(key,\n\t\t    fingerprint_hash, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"sshkey_fingerprint failed\");\n\t\tif ((r = ssh_add_identity_constrained(agent_fd, key, \"\",\n\t\t    lifetime, confirm, maxsign, skprovider,\n\t\t    dest_constraints, ndest_constraints)) != 0) {\n\t\t\terror(\"Unable to add key %s %s\",\n\t\t\t    sshkey_type(key), fp);\n\t\t\tfree(fp);\n\t\t\tok = r;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ok == 0)\n\t\t\tok = 1;\n\t\tif (!qflag) {\n\t\t\tfprintf(stderr, \"Resident identity added: %s %s\\n\",\n\t\t\t    sshkey_type(key), fp);\n\t\t\tif (lifetime != 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Lifetime set to %d seconds\\n\", lifetime);\n\t\t\t}\n\t\t\tif (confirm != 0) {\n\t\t\t\tfprintf(stderr, \"The user must confirm \"\n\t\t\t\t    \"each use of the key\\n\");\n\t\t\t}\n\t\t}\n\t\tfree(fp);\n\t}\n\tsshsk_free_resident_keys(srks, nsrks);\n\tif (nsrks == 0)\n\t\treturn SSH_ERR_KEY_NOT_FOUND;\n\treturn ok == 1 ? 0 : ok;\n}\n\nstatic int\ndo_file(int agent_fd, int deleting, int key_only, int cert_only,\n    char *file, int qflag, const char *skprovider,\n    struct dest_constraint **dest_constraints, size_t ndest_constraints)\n{\n\tif (deleting) {\n\t\tif (delete_file(agent_fd, file, key_only,\n\t\t    cert_only, qflag) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tif (add_file(agent_fd, file, key_only, cert_only, qflag,\n\t\t    skprovider, dest_constraints, ndest_constraints) == -1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nstringlist_append(char ***listp, const char *s)\n{\n\tsize_t i = 0;\n\n\tif (*listp == NULL)\n\t\t*listp = xcalloc(2, sizeof(**listp));\n\telse {\n\t\tfor (i = 0; (*listp)[i] != NULL; i++)\n\t\t\t;  \n\t\t*listp = xrecallocarray(*listp, i + 1, i + 2, sizeof(**listp));\n\t}\n\t(*listp)[i] = xstrdup(s);\n}\n\nstatic void\nparse_dest_constraint_hop(const char *s, struct dest_constraint_hop *dch,\n    char **hostkey_files)\n{\n\tchar *user = NULL, *host, *os, *path;\n\tsize_t i;\n\tstruct hostkeys *hostkeys;\n\tconst struct hostkey_entry *hke;\n\tint r, want_ca;\n\n\tmemset(dch, '\\0', sizeof(*dch));\n\tos = xstrdup(s);\n\tif ((host = strchr(os, '@')) == NULL)\n\t\thost = os;\n\telse {\n\t\t*host++ = '\\0';\n\t\tuser = os;\n\t}\n\tcleanhostname(host);\n\t \n\tif (*host == '\\0') {\n\t\tif (user == NULL) {\n\t\t\tfatal(\"Invalid key destination constraint \\\"%s\\\": \"\n\t\t\t    \"does not specify user or host\", s);\n\t\t}\n\t\tdch->user = xstrdup(user);\n\t\t \n\t\tfree(os);\n\t\treturn;\n\t}\n\tif (hostkey_files == NULL)\n\t\tfatal_f(\"no hostkey files\");\n\t \n\thostkeys = init_hostkeys();\n\tfor (i = 0; hostkey_files[i]; i++) {\n\t\tpath = tilde_expand_filename(hostkey_files[i], getuid());\n\t\tdebug2_f(\"looking up host keys for \\\"%s\\\" in %s\", host, path);\n                load_hostkeys(hostkeys, host, path, 0);\n\t\tfree(path);\n\t}\n\tdch->user = user == NULL ? NULL : xstrdup(user);\n\tdch->hostname = xstrdup(host);\n\tfor (i = 0; i < hostkeys->num_entries; i++) {\n\t\thke = hostkeys->entries + i;\n\t\twant_ca = hke->marker == MRK_CA;\n\t\tif (hke->marker != MRK_NONE && !want_ca)\n\t\t\tcontinue;\n\t\tdebug3_f(\"%s%s%s: adding %s %skey from %s:%lu as key %u\",\n\t\t    user == NULL ? \"\": user, user == NULL ? \"\" : \"@\",\n\t\t    host, sshkey_type(hke->key), want_ca ? \"CA \" : \"\",\n\t\t    hke->file, hke->line, dch->nkeys);\n\t\tdch->keys = xrecallocarray(dch->keys, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->keys));\n\t\tdch->key_is_ca = xrecallocarray(dch->key_is_ca, dch->nkeys,\n\t\t    dch->nkeys + 1, sizeof(*dch->key_is_ca));\n\t\tif ((r = sshkey_from_private(hke->key,\n\t\t    &(dch->keys[dch->nkeys]))) != 0)\n\t\t\tfatal_fr(r, \"sshkey_from_private\");\n\t\tdch->key_is_ca[dch->nkeys] = want_ca;\n\t\tdch->nkeys++;\n\t}\n\tif (dch->nkeys == 0)\n\t\tfatal(\"No host keys found for destination \\\"%s\\\"\", host);\n\tfree_hostkeys(hostkeys);\n\tfree(os);\n\treturn;\n}\n\nstatic void\nparse_dest_constraint(const char *s, struct dest_constraint ***dcp,\n    size_t *ndcp, char **hostkey_files)\n{\n\tstruct dest_constraint *dc;\n\tchar *os, *cp;\n\n\tdc = xcalloc(1, sizeof(*dc));\n\tos = xstrdup(s);\n\tif ((cp = strchr(os, '>')) == NULL) {\n\t\t \n\t\tparse_dest_constraint_hop(os, &dc->to, hostkey_files);\n\t} else {\n\t\t \n\t\t*(cp++) = '\\0';\n\t\tparse_dest_constraint_hop(os, &dc->from, hostkey_files);\n\t\tparse_dest_constraint_hop(cp, &dc->to, hostkey_files);\n\t\tif (dc->from.user != NULL) {\n\t\t\tfatal(\"Invalid key constraint %s: cannot specify \"\n\t\t\t    \"user on 'from' host\", os);\n\t\t}\n\t}\n\t \n\tdebug2_f(\"constraint %zu: %s%s%s (%u keys) > %s%s%s (%u keys)\", *ndcp,\n\t    dc->from.user ? dc->from.user : \"\", dc->from.user ? \"@\" : \"\",\n\t    dc->from.hostname ? dc->from.hostname : \"(ORIGIN)\", dc->from.nkeys,\n\t    dc->to.user ? dc->to.user : \"\", dc->to.user ? \"@\" : \"\",\n\t    dc->to.hostname ? dc->to.hostname : \"(ANY)\", dc->to.nkeys);\n\t*dcp = xrecallocarray(*dcp, *ndcp, *ndcp + 1, sizeof(**dcp));\n\t(*dcp)[(*ndcp)++] = dc;\n\tfree(os);\n}\n\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\"usage: ssh-add [-cDdKkLlqvXx] [-E fingerprint_hash] [-H hostkey_file]\\n\"\n\"               [-h destination_constraint] [-S provider] [-t life]\\n\"\n#ifdef WITH_XMSS\n\"               [-M maxsign] [-m minleft]\\n\"\n#endif\n\"               [file ...]\\n\"\n\"       ssh-add -s pkcs11\\n\"\n\"       ssh-add -e pkcs11\\n\"\n\"       ssh-add -T pubkey ...\\n\"\n\t);\n}\n\nint\nmain(int argc, char **argv)\n{\n\textern char *optarg;\n\textern int optind;\n\tint agent_fd;\n\tchar *pkcs11provider = NULL, *skprovider = NULL;\n\tchar **dest_constraint_strings = NULL, **hostkey_files = NULL;\n\tint r, i, ch, deleting = 0, ret = 0, key_only = 0, cert_only = 0;\n\tint do_download = 0, xflag = 0, lflag = 0, Dflag = 0;\n\tint qflag = 0, Tflag = 0;\n\tSyslogFacility log_facility = SYSLOG_FACILITY_AUTH;\n\tLogLevel log_level = SYSLOG_LEVEL_INFO;\n\tstruct sshkey *k, **certs = NULL;\n\tstruct dest_constraint **dest_constraints = NULL;\n\tsize_t ndest_constraints = 0i, ncerts = 0;\n\n\t \n\tsanitise_stdfd();\n\n\t__progname = ssh_get_progname(argv[0]);\n\tseed_rng();\n\n\tlog_init(__progname, log_level, log_facility, 1);\n\n\tsetvbuf(stdout, NULL, _IOLBF, 0);\n\n\t \n\tswitch (r = ssh_get_authentication_socket(&agent_fd)) {\n\tcase 0:\n\t\tbreak;\n\tcase SSH_ERR_AGENT_NOT_PRESENT:\n\t\tfprintf(stderr, \"Could not open a connection to your \"\n\t\t    \"authentication agent.\\n\");\n\t\texit(2);\n\tdefault:\n\t\tfprintf(stderr, \"Error connecting to agent: %s\\n\", ssh_err(r));\n\t\texit(2);\n\t}\n\n\tskprovider = getenv(\"SSH_SK_PROVIDER\");\n\n\twhile ((ch = getopt(argc, argv, \"vkKlLCcdDTxXE:e:h:H:M:m:qs:S:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'v':\n\t\t\tif (log_level == SYSLOG_LEVEL_INFO)\n\t\t\t\tlog_level = SYSLOG_LEVEL_DEBUG1;\n\t\t\telse if (log_level < SYSLOG_LEVEL_DEBUG3)\n\t\t\t\tlog_level++;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tstringlist_append(&hostkey_files, optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tstringlist_append(&dest_constraint_strings, optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkey_only = 1;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcert_only = 1;\n\t\t\tbreak;\n\t\tcase 'K':\n\t\t\tdo_download = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tif (lflag != 0)\n\t\t\t\tfatal(\"-%c flag already specified\", lflag);\n\t\t\tlflag = ch;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tif (xflag != 0)\n\t\t\t\tfatal(\"-%c flag already specified\", xflag);\n\t\t\txflag = ch;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tminleft = (u_int)strtonum(optarg, 1, UINT_MAX, NULL);\n\t\t\tif (minleft == 0) {\n\t\t\t\tusage();\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tmaxsign = (u_int)strtonum(optarg, 1, UINT_MAX, NULL);\n\t\t\tif (maxsign == 0) {\n\t\t\t\tusage();\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdeleting = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tDflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tpkcs11provider = optarg;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tskprovider = optarg;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tdeleting = 1;\n\t\t\tpkcs11provider = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1 ||\n\t\t\t    lifetime < 0 || (u_long)lifetime > UINT32_MAX) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tqflag = 1;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tTflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tlog_init(__progname, log_level, log_facility, 1);\n\n\tif ((xflag != 0) + (lflag != 0) + (Dflag != 0) > 1)\n\t\tfatal(\"Invalid combination of actions\");\n\telse if (xflag) {\n\t\tif (lock_agent(agent_fd, xflag == 'x' ? 1 : 0) == -1)\n\t\t\tret = 1;\n\t\tgoto done;\n\t} else if (lflag) {\n\t\tif (list_identities(agent_fd, lflag == 'l' ? 1 : 0) == -1)\n\t\t\tret = 1;\n\t\tgoto done;\n\t} else if (Dflag) {\n\t\tif (delete_all(agent_fd, qflag) == -1)\n\t\t\tret = 1;\n\t\tgoto done;\n\t}\n\n#ifdef ENABLE_SK_INTERNAL\n\tif (skprovider == NULL)\n\t\tskprovider = \"internal\";\n#endif\n\n\tif (hostkey_files == NULL) {\n\t\t \n\t\tstringlist_append(&hostkey_files, _PATH_SSH_USER_HOSTFILE);\n\t\tstringlist_append(&hostkey_files, _PATH_SSH_USER_HOSTFILE2);\n\t\tstringlist_append(&hostkey_files, _PATH_SSH_SYSTEM_HOSTFILE);\n\t\tstringlist_append(&hostkey_files, _PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (dest_constraint_strings != NULL) {\n\t\tfor (i = 0; dest_constraint_strings[i] != NULL; i++) {\n\t\t\tparse_dest_constraint(dest_constraint_strings[i],\n\t\t\t  &dest_constraints, &ndest_constraints, hostkey_files);\n\t\t}\n\t}\n\n\targc -= optind;\n\targv += optind;\n\tif (Tflag) {\n\t\tif (argc <= 0)\n\t\t\tfatal(\"no keys to test\");\n\t\tfor (r = i = 0; i < argc; i++)\n\t\t\tr |= test_key(agent_fd, argv[i]);\n\t\tret = r == 0 ? 0 : 1;\n\t\tgoto done;\n\t}\n\tif (pkcs11provider != NULL) {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif ((r = sshkey_load_public(argv[i], &k, NULL)) != 0)\n\t\t\t\tfatal_fr(r, \"load certificate %s\", argv[i]);\n\t\t\tcerts = xrecallocarray(certs, ncerts, ncerts + 1,\n\t\t\t    sizeof(*certs));\n\t\t\tdebug2(\"%s: %s\", argv[i], sshkey_ssh_name(k));\n\t\t\tcerts[ncerts++] = k;\n\t\t}\n\t\tdebug2_f(\"loaded %zu certificates\", ncerts);\n\t\tif (update_card(agent_fd, !deleting, pkcs11provider,\n\t\t    qflag, key_only, cert_only,\n\t\t    dest_constraints, ndest_constraints,\n\t\t    certs, ncerts) == -1)\n\t\t\tret = 1;\n\t\tgoto done;\n\t}\n\tif (do_download) {\n\t\tif (skprovider == NULL)\n\t\t\tfatal(\"Cannot download keys without provider\");\n\t\tif (load_resident_keys(agent_fd, skprovider, qflag,\n\t\t    dest_constraints, ndest_constraints) != 0)\n\t\t\tret = 1;\n\t\tgoto done;\n\t}\n\tif (argc == 0) {\n\t\tchar buf[PATH_MAX];\n\t\tstruct passwd *pw;\n\t\tstruct stat st;\n\t\tint count = 0;\n\n\t\tif ((pw = getpwuid(getuid())) == NULL) {\n\t\t\tfprintf(stderr, \"No user found with uid %u\\n\",\n\t\t\t    (u_int)getuid());\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tfor (i = 0; default_files[i]; i++) {\n\t\t\tsnprintf(buf, sizeof(buf), \"%s/%s\", pw->pw_dir,\n\t\t\t    default_files[i]);\n\t\t\tif (stat(buf, &st) == -1)\n\t\t\t\tcontinue;\n\t\t\tif (do_file(agent_fd, deleting, key_only, cert_only,\n\t\t\t    buf, qflag, skprovider,\n\t\t\t    dest_constraints, ndest_constraints) == -1)\n\t\t\t\tret = 1;\n\t\t\telse\n\t\t\t\tcount++;\n\t\t}\n\t\tif (count == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tif (do_file(agent_fd, deleting, key_only, cert_only,\n\t\t\t    argv[i], qflag, skprovider,\n\t\t\t    dest_constraints, ndest_constraints) == -1)\n\t\t\t\tret = 1;\n\t\t}\n\t}\ndone:\n\tclear_pass();\n\tssh_close_authentication_socket(agent_fd);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}