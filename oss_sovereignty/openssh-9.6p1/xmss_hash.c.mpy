{
  "module_name": "xmss_hash.c",
  "hash_id": "a9e7c1f1abb51e00345c5a906b20c00035e0de0e7d39687fce2f1c441c779db2",
  "original_prompt": "Ingested from openssh-9.6p1/xmss_hash.c",
  "human_readable_source": " \n \n\n#include \"includes.h\"\n#ifdef WITH_XMSS\n\n#include \"xmss_hash_address.h\"\n#include \"xmss_commons.h\"\n#include \"xmss_hash.h\"\n\n#include <stddef.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <stdio.h>\n#include <string.h>\n\nint core_hash_SHA2(unsigned char *, const unsigned int, const unsigned char *,\n    unsigned int, const unsigned char *, unsigned long long, unsigned int);\n\nunsigned char* addr_to_byte(unsigned char *bytes, const uint32_t addr[8]){\n#if IS_LITTLE_ENDIAN==1 \n  int i = 0;\n  for(i=0;i<8;i++)\n    to_byte(bytes+i*4, addr[i],4);\n  return bytes;  \n#else\n  memcpy(bytes, addr, 32);\n  return bytes; \n#endif   \n}\n\nint core_hash_SHA2(unsigned char *out, const unsigned int type, const unsigned char *key, unsigned int keylen, const unsigned char *in, unsigned long long inlen, unsigned int n){  \n  unsigned long long i = 0;\n  unsigned char buf[inlen + n + keylen];\n  \n  \n  \n  \n  to_byte(buf, type, n);\n  \n  for (i=0; i < keylen; i++) {\n    buf[i+n] = key[i];\n  }\n  \n  for (i=0; i < inlen; i++) {\n    buf[keylen + n + i] = in[i];\n  }\n\n  if (n == 32) {\n    SHA256(buf, inlen + keylen + n, out);\n    return 0;\n  }\n  else {\n    if (n == 64) {\n      SHA512(buf, inlen + keylen + n, out);\n      return 0;\n    }\n  }\n  return 1;\n}\n\n \nint prf(unsigned char *out, const unsigned char *in, const unsigned char *key, unsigned int keylen)\n{ \n  return core_hash_SHA2(out, 3, key, keylen, in, 32, keylen);\n}\n\n \nint h_msg(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *key, const unsigned int keylen, const unsigned int n)\n{\n  if (keylen != 3*n){\n    \n    return -1;\n  }  \n  return core_hash_SHA2(out, 2, key, keylen, in, inlen, n);\n}\n\n \nint hash_h(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n\n  unsigned char buf[2*n];\n  unsigned char key[n];\n  unsigned char bitmask[2*n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);\n  addr_to_byte(byte_addr, addr);\n  prf(key, byte_addr, pub_seed, n);\n  \n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  setKeyAndMask(addr, 2);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask+n, byte_addr, pub_seed, n);\n  for (i = 0; i < 2*n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 1, key, n, buf, 2*n, n);\n}\n\nint hash_f(unsigned char *out, const unsigned char *in, const unsigned char *pub_seed, uint32_t addr[8], const unsigned int n)\n{\n  unsigned char buf[n];\n  unsigned char key[n];\n  unsigned char bitmask[n];\n  unsigned char byte_addr[32];\n  unsigned int i;\n\n  setKeyAndMask(addr, 0);  \n  addr_to_byte(byte_addr, addr);  \n  prf(key, byte_addr, pub_seed, n);\n  \n  setKeyAndMask(addr, 1);\n  addr_to_byte(byte_addr, addr);\n  prf(bitmask, byte_addr, pub_seed, n);\n  \n  for (i = 0; i < n; i++) {\n    buf[i] = in[i] ^ bitmask[i];\n  }\n  return core_hash_SHA2(out, 0, key, n, buf, n, n);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}