{
  "module_name": "nojobs.c",
  "hash_id": "ede8792f70c6dc0568b279a18058b45edc93f666fcbe1494cf330b6ffe78ab53",
  "original_prompt": "Ingested from bash-5.2.21/nojobs.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include \"filecntl.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n\n#if defined (BUFFERED_INPUT)\n#  include \"input.h\"\n#endif\n\n \n#include \"shtty.h\"\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"jobs.h\"\n#include \"execute_cmd.h\"\n#include \"trap.h\"\n\n#include \"builtins/builtext.h\"\t \n#include \"builtins/common.h\"\n\n#define DEFAULT_CHILD_MAX 4096\n\n#if defined (_POSIX_VERSION) || !defined (HAVE_KILLPG)\n#  define killpg(pg, sig)\t\tkill(-(pg),(sig))\n#endif  \n\n#if !defined (HAVE_SIGINTERRUPT) && !defined (HAVE_POSIX_SIGNALS)\n#  define siginterrupt(sig, code)\n#endif  \n\n#if defined (HAVE_WAITPID)\n#  define WAITPID(pid, statusp, options) waitpid (pid, statusp, options)\n#else\n#  define WAITPID(pid, statusp, options) wait (statusp)\n#endif  \n\n \n#define input_tty() (shell_tty != -1) ? shell_tty : fileno (stderr)\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\nextern void set_original_signal PARAMS((int, SigHandler *));\n\nvolatile pid_t last_made_pid = NO_PID;\nvolatile pid_t last_asynchronous_pid = NO_PID;\n\nstatic int queue_sigchld;\t\t \nint waiting_for_child;\n\n \nint already_making_children = 0;\n\n \nint shell_tty = -1;\n\n \nint check_window_size = CHECKWINSIZE_DEFAULT;\n\n \nint job_control = 0;\n\nint running_in_background = 0;\t \n\n \nstruct proc_status {\n  pid_t pid;\n  int status;\t \n  int flags;\n};\n\n \n#define PROC_RUNNING\t0x01\n#define PROC_NOTIFIED\t0x02\n#define PROC_ASYNC\t0x04\n#define PROC_SIGNALED\t0x10\n\n \n#define PROC_BAD\t -1\n#define PROC_STILL_ALIVE -2\n\nstatic struct proc_status *pid_list = (struct proc_status *)NULL;\nstatic int pid_list_size;\nstatic int wait_sigint_received;\n\nstatic long child_max = -1L;\n\nstatic void alloc_pid_list PARAMS((void));\nstatic int find_proc_slot PARAMS((pid_t));\nstatic int find_index_by_pid PARAMS((pid_t));\nstatic int find_status_by_pid PARAMS((pid_t));\nstatic int process_exit_status PARAMS((WAIT));\nstatic int find_termsig_by_pid PARAMS((pid_t));\nstatic int get_termsig PARAMS((WAIT));\nstatic void set_pid_status PARAMS((pid_t, WAIT));\nstatic void set_pid_flags PARAMS((pid_t, int));\nstatic void unset_pid_flags PARAMS((pid_t, int));\nstatic int get_pid_flags PARAMS((pid_t));\nstatic void add_pid PARAMS((pid_t, int));\nstatic void mark_dead_jobs_as_notified PARAMS((int));\n\nstatic sighandler wait_sigint_handler PARAMS((int));\nstatic char *j_strsignal PARAMS((int));\n\n#if defined (HAVE_WAITPID)\nstatic void reap_zombie_children PARAMS((void));\n#endif\n\n#if !defined (HAVE_SIGINTERRUPT) && defined (HAVE_POSIX_SIGNALS)\nstatic int siginterrupt PARAMS((int, int));\n#endif\n\nstatic void restore_sigint_handler PARAMS((void));\n\n \nstatic void\nalloc_pid_list ()\n{\n  register int i;\n  int old = pid_list_size;\n\n  pid_list_size += 10;\n  pid_list = (struct proc_status *)xrealloc (pid_list, pid_list_size * sizeof (struct proc_status));\n\n   \n  for (i = old; i < pid_list_size; i++)\n    {\n      pid_list[i].pid = NO_PID;\n      pid_list[i].status = pid_list[i].flags = 0;\n    }\n}\n\n \nstatic int\nfind_proc_slot (pid)\n     pid_t pid;\n{\n  register int i;\n\n  for (i = 0; i < pid_list_size; i++)\n    if (pid_list[i].pid == NO_PID || pid_list[i].pid == pid)\n      return (i);\n\n  if (i == pid_list_size)\n    alloc_pid_list ();\n\n  return (i);\n}\n\n \nstatic int\nfind_index_by_pid (pid)\n     pid_t pid;\n{\n  register int i;\n\n  for (i = 0; i < pid_list_size; i++)\n    if (pid_list[i].pid == pid)\n      return (i);\n\n  return (NO_PID);\n}\n\n \nstatic int\nfind_status_by_pid (pid)\n     pid_t pid;\n{\n  int i;\n\n  i = find_index_by_pid (pid);\n  if (i == NO_PID)\n    return (PROC_BAD);\n  if (pid_list[i].flags & PROC_RUNNING)\n    return (PROC_STILL_ALIVE);\n  return (pid_list[i].status);\n}\n\nstatic int\nprocess_exit_status (status)\n     WAIT status;\n{\n  if (WIFSIGNALED (status))\n    return (128 + WTERMSIG (status));\n  else\n    return (WEXITSTATUS (status));\n}\n\n \nstatic int\nfind_termsig_by_pid (pid)\n     pid_t pid;\n{\n  int i;\n\n  i = find_index_by_pid (pid);\n  if (i == NO_PID)\n    return (0);\n  if (pid_list[i].flags & PROC_RUNNING)\n    return (0);\n  return (get_termsig ((WAIT)pid_list[i].status));\n}\n\n \nstatic int\nget_termsig (status)\n     WAIT status;\n{\n  if (WIFSTOPPED (status) == 0 && WIFSIGNALED (status))\n    return (WTERMSIG (status));\n  else\n    return (0);\n}\n\n \nstatic void\nset_pid_status (pid, status)\n     pid_t pid;\n     WAIT status;\n{\n  int slot;\n\n#if defined (COPROCESS_SUPPORT)\n  coproc_pidchk (pid, status);\n#endif\n\n#if defined (PROCESS_SUBSTITUTION)\n  if ((slot = find_procsub_child (pid)) >= 0)\n    set_procsub_status (slot, pid, WSTATUS (status));\n     \n#endif\n\n  slot = find_index_by_pid (pid);\n  if (slot == NO_PID)\n    return;\n\n  pid_list[slot].status = process_exit_status (status);\n  pid_list[slot].flags &= ~PROC_RUNNING;\n  if (WIFSIGNALED (status))\n    pid_list[slot].flags |= PROC_SIGNALED;\n   \n  if ((pid_list[slot].flags & PROC_ASYNC) == 0)\n    pid_list[slot].flags |= PROC_NOTIFIED;\n}\n\n \nstatic void\nset_pid_flags (pid, flags)\n     pid_t pid;\n     int flags;\n{\n  int slot;\n\n  slot = find_index_by_pid (pid);\n  if (slot == NO_PID)\n    return;\n\n  pid_list[slot].flags |= flags;\n}\n\n \nstatic void\nunset_pid_flags (pid, flags)\n     pid_t pid;\n     int flags;\n{\n  int slot;\n\n  slot = find_index_by_pid (pid);\n  if (slot == NO_PID)\n    return;\n\n  pid_list[slot].flags &= ~flags;\n}\n\n \nstatic int\nget_pid_flags (pid)\n     pid_t pid;\n{\n  int slot;\n\n  slot = find_index_by_pid (pid);\n  if (slot == NO_PID)\n    return 0;\n\n  return (pid_list[slot].flags);\n}\n\nstatic void\nadd_pid (pid, async)\n     pid_t pid;\n     int async;\n{\n  int slot;\n\n  slot = find_proc_slot (pid);\n\n  pid_list[slot].pid = pid;\n  pid_list[slot].status = -1;\n  pid_list[slot].flags = PROC_RUNNING;\n  if (async)\n    pid_list[slot].flags |= PROC_ASYNC;\n}\n\nstatic void\nmark_dead_jobs_as_notified (force)\n     int force;\n{\n  register int i, ndead;\n\n   \n  for (i = ndead = 0; force == 0 && i < pid_list_size; i++)\n    {\n      if (pid_list[i].pid == NO_PID)\n\tcontinue;\n      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&\n\t   (pid_list[i].flags & PROC_ASYNC))\n\tndead++;\n    }\n\n  if (child_max < 0)\n    child_max = getmaxchild ();\n  if (child_max < 0)\n    child_max = DEFAULT_CHILD_MAX;\n\n  if (force == 0 && ndead <= child_max)\n    return;\n\n   \n  for (i = 0; i < pid_list_size; i++)\n    {\n      if (pid_list[i].pid == NO_PID)\n\tcontinue;\n      if (((pid_list[i].flags & PROC_RUNNING) == 0) &&\n\t   pid_list[i].pid != last_asynchronous_pid)\n\t{\n\t  pid_list[i].flags |= PROC_NOTIFIED;\n\t  if (force == 0 && (pid_list[i].flags & PROC_ASYNC) && --ndead <= child_max)\n\t    break;\n\t}\n    }\n}\n\n \nint\ncleanup_dead_jobs ()\n{\n  register int i;\n\n#if defined (HAVE_WAITPID)\n  reap_zombie_children ();\n#endif\n\n  for (i = 0; i < pid_list_size; i++)\n    {\n      if (pid_list[i].pid != NO_PID &&\n\t    (pid_list[i].flags & PROC_RUNNING) == 0 &&\n\t    (pid_list[i].flags & PROC_NOTIFIED))\n\tpid_list[i].pid = NO_PID;\n    }\n\n#if defined (COPROCESS_SUPPORT)\n  coproc_reap ();\n#endif\n\n  return 0;\n}\n\nvoid\nreap_dead_jobs ()\n{\n  mark_dead_jobs_as_notified (0);\n  cleanup_dead_jobs ();\n}\n\n \nint\ninitialize_job_control (force)\n     int force;\n{\n  shell_tty = fileno (stderr);\n\n  if (interactive)\n    get_tty_state ();\n  return 0;\n}\n\n \nvoid\ninitialize_job_signals ()\n{\n  set_signal_handler (SIGINT, sigint_sighandler);\n\n   \n  if (login_shell)\n    ignore_tty_job_signals ();\n}\n\n#if defined (HAVE_WAITPID)\n \nstatic void\nreap_zombie_children ()\n{\n#  if defined (WNOHANG)\n  pid_t pid;\n  WAIT status;\n\n  CHECK_TERMSIG;\n  CHECK_WAIT_INTR;\n  while ((pid = waitpid (-1, (int *)&status, WNOHANG)) > 0)\n    set_pid_status (pid, status);\n#  endif  \n  CHECK_TERMSIG;\n  CHECK_WAIT_INTR;\n}\n#endif  \n\n#if !defined (HAVE_SIGINTERRUPT) && defined (HAVE_POSIX_SIGNALS)\n\n#if !defined (SA_RESTART)\n#  define SA_RESTART 0\n#endif\n\nstatic int\nsiginterrupt (sig, flag)\n     int sig, flag;\n{\n  struct sigaction act;\n\n  sigaction (sig, (struct sigaction *)NULL, &act);\n\n  if (flag)\n    act.sa_flags &= ~SA_RESTART;\n  else\n    act.sa_flags |= SA_RESTART;\n\n  return (sigaction (sig, &act, (struct sigaction *)NULL));\n}\n#endif  \n\n \npid_t\nmake_child (command, flags)\n     char *command;\n     int flags;\n{\n  pid_t pid;\n  int async_p, forksleep;\n  sigset_t set, oset;\n\n   \n  if (command)\n    free (command);\n\n  async_p = (flags & FORK_ASYNC);\n  start_pipeline ();\n\n#if defined (BUFFERED_INPUT)\n   \n  if (default_buffered_input != -1 && (!async_p || default_buffered_input > 0))\n    sync_buffered_stream (default_buffered_input);\n#endif  \n\n   \n  if (interactive_shell)\n    {\n      sigemptyset (&set);\n      sigaddset (&set, SIGTERM);\n      sigemptyset (&oset);\n      sigprocmask (SIG_BLOCK, &set, &oset);\n      set_signal_handler (SIGTERM, SIG_DFL);\n    }\n\n   \n  forksleep = 1;\n  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)\n    {\n      sys_error (\"fork: retry\");\n\n#if defined (HAVE_WAITPID)\n       \n      reap_zombie_children ();\n      if (forksleep > 1 && sleep (forksleep) != 0)\n        break;\n#else\n      if (sleep (forksleep) != 0)\n\tbreak;\n#endif  \n      forksleep <<= 1;\n    }\n\n  if (pid != 0)\n    if (interactive_shell)\n      {\n\tset_signal_handler (SIGTERM, SIG_IGN);\n\tsigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);\n      }\n\n  if (pid < 0)\n    {\n      sys_error (\"fork\");\n      last_command_exit_value = EX_NOEXEC;\n      throw_to_top_level ();\n    }\n\n  if (pid == 0)\n    {\n#if defined (BUFFERED_INPUT)\n      unset_bash_input (0);\n#endif  \n\n      CLRINTERRUPT;\t \n\n       \n      restore_sigmask ();\n\n#if 0\n       \n      if (async_p)\n\tlast_asynchronous_pid = getpid ();\n#endif\n\n      subshell_environment |= SUBSHELL_IGNTRAP;\n\n      default_tty_job_signals ();\n    }\n  else\n    {\n       \n\n      last_made_pid = pid;\n\n      if (async_p)\n\tlast_asynchronous_pid = pid;\n\n      add_pid (pid, async_p);\n    }\n  return (pid);\n}\n\nvoid\nignore_tty_job_signals ()\n{\n#if defined (SIGTSTP)\n  set_signal_handler (SIGTSTP, SIG_IGN);\n  set_signal_handler (SIGTTIN, SIG_IGN);\n  set_signal_handler (SIGTTOU, SIG_IGN);\n#endif\n}\n\nvoid\ndefault_tty_job_signals ()\n{\n#if defined (SIGTSTP)\n  if (signal_is_trapped (SIGTSTP) == 0 && signal_is_hard_ignored (SIGTSTP))\n    set_signal_handler (SIGTSTP, SIG_IGN);\n  else\n    set_signal_handler (SIGTSTP, SIG_DFL);\n  if (signal_is_trapped (SIGTTIN) == 0 && signal_is_hard_ignored (SIGTTIN))\n    set_signal_handler (SIGTTIN, SIG_IGN);\n  else\n    set_signal_handler (SIGTTIN, SIG_DFL);\n  if (signal_is_trapped (SIGTTOU) == 0 && signal_is_hard_ignored (SIGTTOU))\n    set_signal_handler (SIGTTOU, SIG_IGN);\n  else\n    set_signal_handler (SIGTTOU, SIG_DFL);\n#endif\n}\n\n \nvoid\nget_original_tty_job_signals ()\n{\n  static int fetched = 0;\n\n  if (fetched == 0)\n    {\n#if defined (SIGTSTP)\n      if (interactive_shell)\n\t{\n\t  set_original_signal (SIGTSTP, SIG_DFL);\n\t  set_original_signal (SIGTTIN, SIG_DFL);\n\t  set_original_signal (SIGTTOU, SIG_DFL);\n\t}\n      else\n\t{\n\t  get_original_signal (SIGTSTP);\n\t  get_original_signal (SIGTTIN);\n\t  get_original_signal (SIGTTOU);\n\t}\n#endif\n      fetched = 1;\n    }\n}\n\n \nint\nwait_for_single_pid (pid, flags)\n     pid_t pid;\n     int flags;\n{\n  pid_t got_pid;\n  WAIT status;\n  int pstatus;\n\n  pstatus = find_status_by_pid (pid);\n\n  if (pstatus == PROC_BAD)\n    {\n      internal_error (_(\"wait: pid %ld is not a child of this shell\"), (long)pid);\n      return (257);\n    }\n\n  if (pstatus != PROC_STILL_ALIVE)\n    {\n      if (pstatus > 128)\n\tlast_command_exit_signal = find_termsig_by_pid (pid);\n      return (pstatus);\n    }\n\n  siginterrupt (SIGINT, 1);\n  while ((got_pid = WAITPID (pid, &status, 0)) != pid)\n    {\n      CHECK_TERMSIG;\n      CHECK_WAIT_INTR;\n      if (got_pid < 0)\n\t{\n\t  if (errno != EINTR && errno != ECHILD)\n\t    {\n\t      siginterrupt (SIGINT, 0);\n\t      sys_error (\"wait\");\n\t    }\n\t  break;\n\t}\n      else if (got_pid > 0)\n\tset_pid_status (got_pid, status);\n    }\n\n  if (got_pid > 0)\n    {\n      set_pid_status (got_pid, status);\n      set_pid_flags (got_pid, PROC_NOTIFIED);\n    }\n\n  siginterrupt (SIGINT, 0);\n  QUIT;\n  CHECK_WAIT_INTR;\n\n  return (got_pid > 0 ? process_exit_status (status) : -1);\n}\n\n \nint\nwait_for_background_pids (ps)\n     struct procstat *ps;\n{\n  pid_t got_pid;\n  WAIT status;\n  int njobs;\n\n   \n\n  njobs = 0;\n  siginterrupt (SIGINT, 1);\n\n   \n  waiting_for_child = 1;\n  while ((got_pid = WAITPID (-1, &status, 0)) != -1)\n    {\n      waiting_for_child = 0;\n      njobs++;\n      set_pid_status (got_pid, status);\n      if (ps)\n\t{\n\t  ps->pid = got_pid;\n\t  ps->status = process_exit_status (status);\n\t}\n      waiting_for_child = 1;\n      CHECK_WAIT_INTR;\n    }\n  waiting_for_child = 0;\n\n  if (errno != EINTR && errno != ECHILD)\n    {\n      siginterrupt (SIGINT, 0);\n      sys_error(\"wait\");\n    }\n\n  siginterrupt (SIGINT, 0);\n  QUIT;\n  CHECK_WAIT_INTR;\n\n  mark_dead_jobs_as_notified (1);\n  cleanup_dead_jobs ();\n\n  return njobs;\n}\n\nvoid\nwait_sigint_cleanup ()\n{\n}\n\n \n#define INVALID_SIGNAL_HANDLER (SigHandler *)wait_for_background_pids\nstatic SigHandler *old_sigint_handler = INVALID_SIGNAL_HANDLER;\n\nstatic void\nrestore_sigint_handler ()\n{\n  if (old_sigint_handler != INVALID_SIGNAL_HANDLER)\n    {\n      set_signal_handler (SIGINT, old_sigint_handler);\n      old_sigint_handler = INVALID_SIGNAL_HANDLER;\n    }\n}\n\n \nstatic sighandler\nwait_sigint_handler (sig)\n     int sig;\n{\n  SigHandler *sigint_handler;\n\n   \n  if (this_shell_builtin && this_shell_builtin == wait_builtin &&\n      signal_is_trapped (SIGINT) &&\n      ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))\n    {\n      last_command_exit_value = 128+SIGINT;\n      restore_sigint_handler ();\n      trap_handler (SIGINT);\t \n      wait_signal_received = SIGINT;\n      SIGRETURN (0);\n    }\n\n  wait_sigint_received = 1;\n\n  SIGRETURN (0);\n}\n\nstatic char *\nj_strsignal (s)\n     int s;\n{\n  static char retcode_name_buffer[64] = { '\\0' };\n  char *x;\n\n  x = strsignal (s);\n  if (x == 0)\n    {\n      x = retcode_name_buffer;\n      sprintf (x, \"Signal %d\", s);\n    }\n  return x;\n}\n\n \nint\nwait_for (pid, flags)\n     pid_t pid;\n     int flags;\n{\n  int return_val, pstatus;\n  pid_t got_pid;\n  WAIT status;\n\n  pstatus = find_status_by_pid (pid);\n\n  if (pstatus == PROC_BAD)\n    return (0);\n\n  if (pstatus != PROC_STILL_ALIVE)\n    {\n      if (pstatus > 128)\n\tlast_command_exit_signal = find_termsig_by_pid (pid);\n      return (pstatus);\n    }\n\n   \n  wait_sigint_received = 0;\n  if (interactive_shell == 0)\n    old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);\n\n  waiting_for_child = 1;  \n  CHECK_WAIT_INTR;\n  while ((got_pid = WAITPID (-1, &status, 0)) != pid)  \n    {\n      waiting_for_child = 0;\n      CHECK_TERMSIG;\n      CHECK_WAIT_INTR;\n      if (got_pid < 0 && errno == ECHILD)\n\t{\n#if !defined (_POSIX_VERSION)\n\t  status.w_termsig = status.w_retcode = 0;\n#else\n\t  status = 0;\n#endif  \n\t  break;\n\t}\n      else if (got_pid < 0 && errno != EINTR)\n\tprogramming_error (\"wait_for(%ld): %s\", (long)pid, strerror(errno));\n      else if (got_pid > 0)\n\tset_pid_status (got_pid, status);\n      waiting_for_child = 1;\n    }\n  waiting_for_child = 0;\n\n  if (got_pid > 0)\n    set_pid_status (got_pid, status);\n\n#if defined (HAVE_WAITPID)\n  if (got_pid >= 0)\n    reap_zombie_children ();\n#endif  \n\n  CHECK_TERMSIG;\n  CHECK_WAIT_INTR;\n\n  if (interactive_shell == 0)\n    {\n      SigHandler *temp_handler;\n\n      temp_handler = old_sigint_handler;\n      restore_sigint_handler ();\n\n       \n      if (WIFSIGNALED (status) && (WTERMSIG (status) == SIGINT))\n\t{\n\n\t  if (maybe_call_trap_handler (SIGINT) == 0)\n\t    {\n\t      if (temp_handler == SIG_DFL)\n\t\ttermsig_handler (SIGINT);\n\t      else if (temp_handler != INVALID_SIGNAL_HANDLER && temp_handler != SIG_IGN)\n\t\t(*temp_handler) (SIGINT);\n\t    }\n\t}\n    }\n\n   \n   \n  return_val = process_exit_status (status);\n  last_command_exit_signal = get_termsig (status);\n\n#if defined (DONT_REPORT_SIGPIPE) && defined (DONT_REPORT_SIGTERM)\n#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGPIPE && (x) != SIGTERM)\n#elif !defined (DONT_REPORT_SIGPIPE) && !defined (DONT_REPORT_SIGTERM)\n#  define REPORTSIG(x) ((x) != SIGINT)\n#elif defined (DONT_REPORT_SIGPIPE)\n#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGPIPE)\n#else\n#  define REPORTSIG(x) ((x) != SIGINT && (x) != SIGTERM)\n#endif\n\n  if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) && REPORTSIG(WTERMSIG (status)))\n    {\n      fprintf (stderr, \"%s\", j_strsignal (WTERMSIG (status)));\n      if (WIFCORED (status))\n\tfprintf (stderr, _(\" (core dumped)\"));\n      fprintf (stderr, \"\\n\");\n    }\n\n  if (interactive_shell && subshell_environment == 0)\n    {\n      if (WIFSIGNALED (status) || WIFSTOPPED (status))\n\tset_tty_state ();\n      else\n\tget_tty_state ();\n    }\n  else if (interactive_shell == 0 && subshell_environment == 0 && check_window_size)\n    get_new_window_size (0, (int *)0, (int *)0);\n\n  return (return_val);\n}\n\n \nint\nkill_pid (pid, signal, group)\n     pid_t pid;\n     int signal, group;\n{\n  int result;\n\n  if (pid < -1)\n    {\n      pid = -pid;\n      group = 1;\n    }\n  result = group ? killpg (pid, signal) : kill (pid, signal);\n  return (result);\n}\n\nstatic TTYSTRUCT shell_tty_info;\nstatic int got_tty_state;\n\n \nint\nget_tty_state ()\n{\n  int tty;\n\n  tty = input_tty ();\n  if (tty != -1)\n    {\n      ttgetattr (tty, &shell_tty_info);\n      got_tty_state = 1;\n      if (check_window_size)\n\tget_new_window_size (0, (int *)0, (int *)0);\n    }\n  return 0;\n}\n\n \nint\nset_tty_state ()\n{\n  int tty;\n\n  tty = input_tty ();\n  if (tty != -1)\n    {\n      if (got_tty_state == 0)\n\treturn 0;\n      ttsetattr (tty, &shell_tty_info);\n    }\n  return 0;\n}\n\n \nint\ngive_terminal_to (pgrp, force)\n     pid_t pgrp;\n     int force;\n{\n  return 0;\n}\n\n \nint\nstop_pipeline (async, ignore)\n     int async;\n     COMMAND *ignore;\n{\n  already_making_children = 0;\n  return 0;\n}\n\nvoid\nstart_pipeline ()\n{\n  already_making_children = 1;\n}\n\nvoid\nstop_making_children ()\n{\n  already_making_children = 0;\n}\n\n \nvoid\nwithout_job_control ()\n{\n  stop_making_children ();\n  last_made_pid = NO_PID;\t \n}\n\nint\nget_job_by_pid (pid, block, ignore)\n     pid_t pid;\n     int block;\n     PROCESS **ignore;\n{\n  int i;\n\n  i = find_index_by_pid (pid);\n  return ((i == NO_PID) ? PROC_BAD : i);\n}\n\n \nvoid\ndescribe_pid (pid)\n     pid_t pid;\n{\n  fprintf (stderr, \"%ld\\n\", (long) pid);\n}\n\nint\nfreeze_jobs_list ()\n{\n  return 0;\n}\n\nvoid\nunfreeze_jobs_list ()\n{\n}\n\nvoid\nset_jobs_list_frozen (s)\n     int s;\n{\n}\n\nint\ncount_all_jobs ()\n{\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}