{
  "module_name": "sig.c",
  "hash_id": "3abb8ebec1d19740df9b370532053682f04344eb08d0f96460a52df3077e9090",
  "original_prompt": "Ingested from bash-5.2.21/sig.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <signal.h>\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#if defined (JOB_CONTROL)\n#include \"jobs.h\"\n#endif  \n#include \"siglist.h\"\n#include \"sig.h\"\n#include \"trap.h\"\n\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\n\n#if defined (READLINE)\n#  include \"bashline.h\"\n#  include <readline/readline.h>\n#endif\n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#endif\n\nextern void initialize_siglist PARAMS((void));\nextern void set_original_signal PARAMS((int, SigHandler *));\n\n#if !defined (JOB_CONTROL)\nextern void initialize_job_signals PARAMS((void));\n#endif\n\n \nvolatile sig_atomic_t interrupt_state = 0;\n\n \nvolatile sig_atomic_t sigwinch_received = 0;\n\n \nvolatile sig_atomic_t sigterm_received = 0;\n\n \nvolatile sig_atomic_t terminating_signal = 0;\n\n \nprocenv_t top_level;\n\n#if defined (JOB_CONTROL) || defined (HAVE_POSIX_SIGNALS)\n \nsigset_t top_level_mask;\n#endif  \n\n \nint interrupt_immediately = 0;\n\n \nint terminate_immediately = 0;\n\n#if defined (SIGWINCH)\nstatic SigHandler *old_winch = (SigHandler *)SIG_DFL;\n#endif\n\nstatic void initialize_shell_signals PARAMS((void));\nstatic void kill_shell PARAMS((int));\n\nvoid\ninitialize_signals (reinit)\n     int reinit;\n{\n  initialize_shell_signals ();\n  initialize_job_signals ();\n#if !defined (HAVE_SYS_SIGLIST) && !defined (HAVE_UNDER_SYS_SIGLIST) && !defined (HAVE_STRSIGNAL)\n  if (reinit == 0)\n    initialize_siglist ();\n#endif  \n}\n\n \nstruct termsig {\n     int signum;\n     SigHandler *orig_handler;\n     int orig_flags;\n     int core_dump;\n};\n\n#define NULL_HANDLER (SigHandler *)SIG_DFL\n\n \nstatic struct termsig terminating_signals[] = {\n#ifdef SIGHUP\n{  SIGHUP, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGINT\n{  SIGINT, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGILL\n{  SIGILL, NULL_HANDLER, 0, 1},\n#endif\n\n#ifdef SIGTRAP\n{  SIGTRAP, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGIOT\n{  SIGIOT, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGDANGER\n{  SIGDANGER, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGEMT\n{  SIGEMT, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGFPE\n{  SIGFPE, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGBUS\n{  SIGBUS, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGSEGV\n{  SIGSEGV, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGSYS\n{  SIGSYS, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGPIPE\n{  SIGPIPE, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGALRM\n{  SIGALRM, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGTERM\n{  SIGTERM, NULL_HANDLER, 0 },\n#endif\n\n \n#ifdef SIGXCPU\n{  SIGXCPU, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGXFSZ\n{  SIGXFSZ, NULL_HANDLER, 0, 1 },\n#endif\n\n#ifdef SIGVTALRM\n{  SIGVTALRM, NULL_HANDLER, 0 },\n#endif\n\n#if 0\n#ifdef SIGPROF\n{  SIGPROF, NULL_HANDLER, 0 },\n#endif\n#endif\n\n#ifdef SIGLOST\n{  SIGLOST, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGUSR1\n{  SIGUSR1, NULL_HANDLER, 0 },\n#endif\n\n#ifdef SIGUSR2\n{  SIGUSR2, NULL_HANDLER, 0 },\n#endif\n};\n\n#define TERMSIGS_LENGTH (sizeof (terminating_signals) / sizeof (struct termsig))\n\n#define XSIG(x) (terminating_signals[x].signum)\n#define XHANDLER(x) (terminating_signals[x].orig_handler)\n#define XSAFLAGS(x) (terminating_signals[x].orig_flags)\n#define XCOREDUMP(x) (terminating_signals[x].core_dump)\n\nstatic int termsigs_initialized = 0;\n\n \nvoid\ninitialize_terminating_signals ()\n{\n  register int i;\n#if defined (HAVE_POSIX_SIGNALS)\n  struct sigaction act, oact;\n#endif\n\n  if (termsigs_initialized)\n    return;\n\n   \n#if defined (HAVE_POSIX_SIGNALS)\n  act.sa_handler = termsig_sighandler;\n  act.sa_flags = 0;\n  sigemptyset (&act.sa_mask);\n  sigemptyset (&oact.sa_mask);\n  for (i = 0; i < TERMSIGS_LENGTH; i++)\n    sigaddset (&act.sa_mask, XSIG (i));\n  for (i = 0; i < TERMSIGS_LENGTH; i++)\n    {\n       \n      if (signal_is_trapped (XSIG (i)))\n\tcontinue;\n\n      sigaction (XSIG (i), &act, &oact);\n      XHANDLER(i) = oact.sa_handler;\n      XSAFLAGS(i) = oact.sa_flags;\n\n#if 0\n      set_original_signal (XSIG(i), XHANDLER(i));\t \n#else\n      set_original_signal (XSIG(i), act.sa_handler);\t \n#endif\n\n       \n       \n      if (interactive_shell == 0 && XHANDLER (i) == SIG_IGN)\n\t{\n\t  sigaction (XSIG (i), &oact, &act);\n\t  set_signal_hard_ignored (XSIG (i));\n\t}\n#if defined (SIGPROF) && !defined (_MINIX)\n      if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)\n\tsigaction (XSIG (i), &oact, (struct sigaction *)NULL);\n#endif  \n    }\n#else  \n\n  for (i = 0; i < TERMSIGS_LENGTH; i++)\n    {\n       \n      if (signal_is_trapped (XSIG (i)))\n\tcontinue;\n\n      XHANDLER(i) = signal (XSIG (i), termsig_sighandler);\n      XSAFLAGS(i) = 0;\n       \n       \n      if (interactive_shell == 0 && XHANDLER (i) == SIG_IGN)\n\t{\n\t  signal (XSIG (i), SIG_IGN);\n\t  set_signal_hard_ignored (XSIG (i));\n\t}\n#ifdef SIGPROF\n      if (XSIG (i) == SIGPROF && XHANDLER (i) != SIG_DFL && XHANDLER (i) != SIG_IGN)\n\tsignal (XSIG (i), XHANDLER (i));\n#endif\n    }\n\n#endif  \n\n  termsigs_initialized = 1;\n}\n\nstatic void\ninitialize_shell_signals ()\n{\n  if (interactive)\n    initialize_terminating_signals ();\n\n#if defined (JOB_CONTROL) || defined (HAVE_POSIX_SIGNALS)\n   \n  sigemptyset (&top_level_mask);\n  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &top_level_mask);\n#  if defined (SIGCHLD)\n  if (sigismember (&top_level_mask, SIGCHLD))\n    {\n      sigdelset (&top_level_mask, SIGCHLD);\n      sigprocmask (SIG_SETMASK, &top_level_mask, (sigset_t *)NULL);\n    }\n#  endif\n#endif  \n\n   \n  set_signal_handler (SIGQUIT, SIG_IGN);\n\n  if (interactive)\n    {\n      set_signal_handler (SIGINT, sigint_sighandler);\n      get_original_signal (SIGTERM);\n      set_signal_handler (SIGTERM, SIG_IGN);\n      set_sigwinch_handler ();\n    }\n}\n\nvoid\nreset_terminating_signals ()\n{\n  register int i;\n#if defined (HAVE_POSIX_SIGNALS)\n  struct sigaction act;\n#endif\n\n  if (termsigs_initialized == 0)\n    return;\n\n#if defined (HAVE_POSIX_SIGNALS)\n  act.sa_flags = 0;\n  sigemptyset (&act.sa_mask);\n  for (i = 0; i < TERMSIGS_LENGTH; i++)\n    {\n       \n      if (signal_is_trapped (XSIG (i)) || signal_is_special (XSIG (i)))\n\tcontinue;\n\n      act.sa_handler = XHANDLER (i);\n      act.sa_flags = XSAFLAGS (i);\n      sigaction (XSIG (i), &act, (struct sigaction *) NULL);\n    }\n#else  \n  for (i = 0; i < TERMSIGS_LENGTH; i++)\n    {\n      if (signal_is_trapped (XSIG (i)) || signal_is_special (XSIG (i)))\n\tcontinue;\n\n      signal (XSIG (i), XHANDLER (i));\n    }\n#endif  \n\n  termsigs_initialized = 0;\n}\n#undef XHANDLER\n\n \nvoid\ntop_level_cleanup ()\n{\n   \n  while (parse_and_execute_level)\n    parse_and_execute_cleanup (-1);\n\n#if defined (PROCESS_SUBSTITUTION)\n  unlink_fifo_list ();\n#endif  \n\n  run_unwind_protects ();\n  loop_level = continuing = breaking = funcnest = 0;\n  executing_list = comsub_ignore_return = return_catch_flag = wait_intr_flag = 0;\n}\n\n \nvoid\nthrow_to_top_level ()\n{\n  int print_newline = 0;\n\n  if (interrupt_state)\n    {\n      if (last_command_exit_value < 128)\n\tlast_command_exit_value = 128 + SIGINT;\n      set_pipestatus_from_exit (last_command_exit_value);\n      print_newline = 1;\n      DELINTERRUPT;\n    }\n\n  if (interrupt_state)\n    return;\n\n  last_command_exit_signal = (last_command_exit_value > 128) ?\n\t\t\t\t(last_command_exit_value - 128) : 0;\n  last_command_exit_value |= 128;\n  set_pipestatus_from_exit (last_command_exit_value);\n\n   \n  if (signal_is_trapped (SIGINT) && signal_is_pending (SIGINT))\n    run_interrupt_trap (1);\n\n   \n  while (parse_and_execute_level)\n    parse_and_execute_cleanup (-1);\n\n  if (running_trap > 0)\n    {\n      run_trap_cleanup (running_trap - 1);\n      running_trap = 0;\n    }\n\n#if defined (JOB_CONTROL)\n  give_terminal_to (shell_pgrp, 0);\n#endif  \n\n   \n  restore_sigmask ();  \n\n  reset_parser ();\n\n#if defined (READLINE)\n  if (interactive)\n    bashline_reset ();\n#endif  \n\n#if defined (PROCESS_SUBSTITUTION)\n  unlink_fifo_list ();\n#endif  \n\n  run_unwind_protects ();\n  loop_level = continuing = breaking = funcnest = 0;\n  executing_list = comsub_ignore_return = return_catch_flag = wait_intr_flag = 0;\n\n  if (interactive && print_newline)\n    {\n      fflush (stdout);\n      fprintf (stderr, \"\\n\");\n      fflush (stderr);\n    }\n\n   \n  if (interactive || (interactive_shell && !shell_initialized) ||\n      (print_newline && signal_is_trapped (SIGINT)))\n    jump_to_top_level (DISCARD);\n  else\n    jump_to_top_level (EXITPROG);\n}\n\n \nvoid\njump_to_top_level (value)\n     int value;\n{\n  sh_longjmp (top_level, value);\n}\n\nvoid\nrestore_sigmask ()\n{\n#if defined (JOB_CONTROL) || defined (HAVE_POSIX_SIGNALS)\n  sigprocmask (SIG_SETMASK, &top_level_mask, (sigset_t *)NULL);\n#endif\n}\n\nstatic int handling_termsig = 0;\n\nsighandler\ntermsig_sighandler (sig)\n     int sig;\n{\n   \n  if (\n#ifdef SIGHUP\n    sig != SIGHUP &&\n#endif\n#ifdef SIGINT\n    sig != SIGINT &&\n#endif\n#ifdef SIGDANGER\n    sig != SIGDANGER &&\n#endif\n#ifdef SIGPIPE\n    sig != SIGPIPE &&\n#endif\n#ifdef SIGALRM\n    sig != SIGALRM &&\n#endif\n#ifdef SIGTERM\n    sig != SIGTERM &&\n#endif\n#ifdef SIGXCPU\n    sig != SIGXCPU &&\n#endif\n#ifdef SIGXFSZ\n    sig != SIGXFSZ &&\n#endif\n#ifdef SIGVTALRM\n    sig != SIGVTALRM &&\n#endif\n#ifdef SIGLOST\n    sig != SIGLOST &&\n#endif\n#ifdef SIGUSR1\n    sig != SIGUSR1 &&\n#endif\n#ifdef SIGUSR2\n   sig != SIGUSR2 &&\n#endif\n   sig == terminating_signal)\n    terminate_immediately = 1;\n\n   \n  if (handling_termsig)\n    kill_shell (sig);\t\t \n\n  terminating_signal = sig;\n\n  if (terminate_immediately)\n    {\n#if defined (HISTORY)\n       \n#  if defined (READLINE)\n      if (interactive_shell == 0 || interactive == 0 || (sig != SIGHUP && sig != SIGTERM) || no_line_editing || (RL_ISSTATE (RL_STATE_READCMD) == 0))\n#  endif\n        history_lines_this_session = 0;\n#endif\n      terminate_immediately = 0;\n      termsig_handler (sig);\n    }\n\n#if defined (READLINE)\n   \n  if (RL_ISSTATE (RL_STATE_SIGHANDLER) || RL_ISSTATE (RL_STATE_TERMPREPPED))\n    bashline_set_event_hook ();\n#endif\n\n  SIGRETURN (0);\n}\n\nvoid\ntermsig_handler (sig)\n     int sig;\n{\n   \n  if (handling_termsig)\n    return;\n\n  handling_termsig = terminating_signal;\t \n  terminating_signal = 0;\t \n\n   \n  if (sig == SIGINT && signal_is_trapped (SIGINT))\n    run_interrupt_trap (0);\n\n#if defined (HISTORY)\n   \n  if (interactive_shell && interactive && (sig == SIGHUP || sig == SIGTERM) && remember_on_history)\n    maybe_save_shell_history ();\n#endif  \n\n  if (this_shell_builtin == read_builtin)\n    read_tty_cleanup ();\n\n#if defined (JOB_CONTROL)\n  if (sig == SIGHUP && (interactive || (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB))))\n    hangup_all_jobs ();\n\n  if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB)) == 0)\n    end_job_control ();\n#endif  \n\n#if defined (PROCESS_SUBSTITUTION)\n  unlink_all_fifos ();\n#  if defined (JOB_CONTROL)\n  procsub_clear ();\n#  endif\n#endif  \n\n   \n  loop_level = continuing = breaking = funcnest = 0;\n  executing_list = comsub_ignore_return = return_catch_flag = wait_intr_flag = 0;\n\n  run_exit_trap ();\t \n\n  kill_shell (sig);\n}\n\nstatic void\nkill_shell (sig)\n     int sig;\n{\n  int i, core;\n  sigset_t mask;\n\n   \n  restore_sigmask ();\n\n  set_signal_handler (sig, SIG_DFL);\n\n  kill (getpid (), sig);\n\n  if (dollar_dollar_pid != 1)\n    exit (128+sig);\t\t \n\n   \n\n   \n  sigprocmask (SIG_SETMASK, (sigset_t *)NULL, &mask);\n  for (i = core = 0; i < TERMSIGS_LENGTH; i++)\n    {\n      set_signal_handler (XSIG (i), SIG_DFL);\n      sigdelset (&mask, XSIG (i));\n      if (sig == XSIG (i))\n\tcore = XCOREDUMP (i);\n    }\n  sigprocmask (SIG_SETMASK, &mask, (sigset_t *)NULL);\n\n  if (core)\n    *((volatile unsigned long *) NULL) = 0xdead0000 + sig;\t \n\n  exit (128+sig);\n}\n#undef XSIG\n\n \nsighandler\nsigint_sighandler (sig)\n     int sig;\n{\n#if defined (MUST_REINSTALL_SIGHANDLERS)\n  signal (sig, sigint_sighandler);\n#endif\n\n   \n  if (interrupt_state == 0)\n    ADDINTERRUPT;\n\n   \n  if (wait_intr_flag)\n    {\n      last_command_exit_value = 128 + sig;\n      set_pipestatus_from_exit (last_command_exit_value);\n      wait_signal_received = sig;\n      SIGRETURN (0);\n    }\n\n   \n  if (signal_is_trapped (sig))\n    set_trap_state (sig);\n\n   \n  if (interrupt_immediately)\n    {\n      interrupt_immediately = 0;\n      set_exit_status (128 + sig);\n      throw_to_top_level ();\n    }\n#if defined (READLINE)\n   \n  else if (RL_ISSTATE (RL_STATE_SIGHANDLER))\n    bashline_set_event_hook ();\n#endif\n\n  SIGRETURN (0);\n}\n\n#if defined (SIGWINCH)\nsighandler\nsigwinch_sighandler (sig)\n     int sig;\n{\n#if defined (MUST_REINSTALL_SIGHANDLERS)\n  set_signal_handler (SIGWINCH, sigwinch_sighandler);\n#endif  \n  sigwinch_received = 1;\n  SIGRETURN (0);\n}\n#endif  \n\nvoid\nset_sigwinch_handler ()\n{\n#if defined (SIGWINCH)\n old_winch = set_signal_handler (SIGWINCH, sigwinch_sighandler);\n#endif\n}\n\nvoid\nunset_sigwinch_handler ()\n{\n#if defined (SIGWINCH)\n  set_signal_handler (SIGWINCH, old_winch);\n#endif\n}\n\nsighandler\nsigterm_sighandler (sig)\n     int sig;\n{\n  sigterm_received = 1;\t\t \n  SIGRETURN (0);\n}\n\n \n#if !defined (HAVE_POSIX_SIGNALS)\n\n \nsigprocmask (operation, newset, oldset)\n     int operation, *newset, *oldset;\n{\n  int old, new;\n\n  if (newset)\n    new = *newset;\n  else\n    new = 0;\n\n  switch (operation)\n    {\n    case SIG_BLOCK:\n      old = sigblock (new);\n      break;\n\n    case SIG_SETMASK:\n      old = sigsetmask (new);\n      break;\n\n    default:\n      internal_error (_(\"sigprocmask: %d: invalid operation\"), operation);\n    }\n\n  if (oldset)\n    *oldset = old;\n}\n\n#else\n\n#if !defined (SA_INTERRUPT)\n#  define SA_INTERRUPT 0\n#endif\n\n#if !defined (SA_RESTART)\n#  define SA_RESTART 0\n#endif\n\nSigHandler *\nset_signal_handler (sig, handler)\n     int sig;\n     SigHandler *handler;\n{\n  struct sigaction act, oact;\n\n  act.sa_handler = handler;\n  act.sa_flags = 0;\n\n   \n   \n#if defined (SIGCHLD)\n  if (sig == SIGCHLD)\n    act.sa_flags |= SA_RESTART;\t\t \n#endif\n   \n#if defined (SIGWINCH)\n  if (sig == SIGWINCH)\n    act.sa_flags |= SA_RESTART;\t\t \n#endif\n   \n  if (sig == SIGTERM && handler == sigterm_sighandler)\n    act.sa_flags |= SA_RESTART;\t\t \n\n  sigemptyset (&act.sa_mask);\n  sigemptyset (&oact.sa_mask);\n  if (sigaction (sig, &act, &oact) == 0)\n    return (oact.sa_handler);\n  else\n    return (SIG_DFL);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}