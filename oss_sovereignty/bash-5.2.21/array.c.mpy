{
  "module_name": "array.c",
  "hash_id": "961da8fb44c827d0071004f53e8a247c45fd485939e888435b5e317a003c7224",
  "original_prompt": "Ingested from bash-5.2.21/array.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (ARRAY_VARS)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"bashansi.h\"\n\n#include \"shell.h\"\n#include \"array.h\"\n#include \"builtins/common.h\"\n\n#define ADD_BEFORE(ae, new) \\\n\tdo { \\\n\t\tae->prev->next = new; \\\n\t\tnew->prev = ae->prev; \\\n\t\tae->prev = new; \\\n\t\tnew->next = ae; \\\n\t} while(0)\n\t\n#define ADD_AFTER(ae, new) \\\n\tdo { \\\n\t\tae->next->prev = new; \\\n\t\tnew->next = ae->next; \\\n\t\tnew->prev = ae; \\\n\t\tae->next = new; \\\n\t} while (0)\n\nstatic char *array_to_string_internal PARAMS((ARRAY_ELEMENT *, ARRAY_ELEMENT *, char *, int));\n\nstatic char *spacesep = \" \";\n\n#define IS_LASTREF(a)\t(a->lastref)\n\n#define LASTREF_START(a, i) \\\n\t(IS_LASTREF(a) && i >= element_index(a->lastref)) ? a->lastref \\\n\t\t\t\t\t\t          : element_forw(a->head)\n\n#define LASTREF(a)\t(a->lastref ? a->lastref : element_forw(a->head))\n\n#define INVALIDATE_LASTREF(a)\ta->lastref = 0\n#define SET_LASTREF(a, e)\ta->lastref = (e)\n#define UNSET_LASTREF(a)\ta->lastref = 0;\n\nARRAY *\narray_create()\n{\n\tARRAY\t*r;\n\tARRAY_ELEMENT\t*head;\n\n\tr = (ARRAY *)xmalloc(sizeof(ARRAY));\n\tr->max_index = -1;\n\tr->num_elements = 0;\n\tr->lastref = (ARRAY_ELEMENT *)0;\n\thead = array_create_element(-1, (char *)NULL);\t \n\thead->prev = head->next = head;\n\tr->head = head;\n\treturn(r);\n}\n\nvoid\narray_flush (a)\nARRAY\t*a;\n{\n\tregister ARRAY_ELEMENT *r, *r1;\n\n\tif (a == 0)\n\t\treturn;\n\tfor (r = element_forw(a->head); r != a->head; ) {\n\t\tr1 = element_forw(r);\n\t\tarray_dispose_element(r);\n\t\tr = r1;\n\t}\n\ta->head->next = a->head->prev = a->head;\n\ta->max_index = -1;\n\ta->num_elements = 0;\n\tINVALIDATE_LASTREF(a);\n}\n\nvoid\narray_dispose(a)\nARRAY\t*a;\n{\n\tif (a == 0)\n\t\treturn;\n\tarray_flush (a);\n\tarray_dispose_element(a->head);\n\tfree(a);\n}\n\nARRAY *\narray_copy(a)\nARRAY\t*a;\n{\n\tARRAY\t*a1;\n\tARRAY_ELEMENT\t*ae, *new;\n\n\tif (a == 0)\n\t\treturn((ARRAY *) NULL);\n\ta1 = array_create();\n\ta1->max_index = a->max_index;\n\ta1->num_elements = a->num_elements;\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {\n\t\tnew = array_create_element(element_index(ae), element_value(ae));\n\t\tADD_BEFORE(a1->head, new);\n\t\tif (ae == LASTREF(a))\n\t\t\tSET_LASTREF(a1, new);\n\t}\n\treturn(a1);\n}\n\n \nARRAY *\narray_slice(array, s, e)\nARRAY\t\t*array;\nARRAY_ELEMENT\t*s, *e;\n{\n\tARRAY\t*a;\n\tARRAY_ELEMENT *p, *n;\n\tint\ti;\n\tarrayind_t mi;\n\n\ta = array_create ();\n\n\tfor (mi = 0, p = s, i = 0; p != e; p = element_forw(p), i++) {\n\t\tn = array_create_element (element_index(p), element_value(p));\n\t\tADD_BEFORE(a->head, n);\n\t\tmi = element_index(n);\n\t}\n\ta->num_elements = i;\n\ta->max_index = mi;\n\treturn a;\n}\n\n \nvoid\narray_walk(a, func, udata)\nARRAY\t*a;\nsh_ae_map_func_t *func;\nvoid\t*udata;\n{\n\tregister ARRAY_ELEMENT *ae;\n\n\tif (a == 0 || array_empty(a))\n\t\treturn;\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae))\n\t\tif ((*func)(ae, udata) < 0)\n\t\t\treturn;\n}\n\n \nARRAY_ELEMENT *\narray_shift(a, n, flags)\nARRAY\t*a;\nint\tn, flags;\n{\n\tregister ARRAY_ELEMENT *ae, *ret;\n\tregister int i;\n\n\tif (a == 0 || array_empty(a) || n <= 0)\n\t\treturn ((ARRAY_ELEMENT *)NULL);\n\n\tINVALIDATE_LASTREF(a);\n\tfor (i = 0, ret = ae = element_forw(a->head); ae != a->head && i < n; ae = element_forw(ae), i++)\n\t\t;\n\tif (ae == a->head) {\n\t\t \n\t\tif (flags & AS_DISPOSE) {\n\t\t\tarray_flush (a);\n\t\t\treturn ((ARRAY_ELEMENT *)NULL);\n\t\t}\n\t\tfor (ae = ret; element_forw(ae) != a->head; ae = element_forw(ae))\n\t\t\t;\n\t\telement_forw(ae) = (ARRAY_ELEMENT *)NULL;\n\t\ta->head->next = a->head->prev = a->head;\n\t\ta->max_index = -1;\n\t\ta->num_elements = 0;\n\t\treturn ret;\n\t}\n\t \n\tae->prev->next = (ARRAY_ELEMENT *)NULL;\t\t \n\n\ta->head->next = ae;\t\t \n\tae->prev = a->head;\n\n\tfor ( ; ae != a->head; ae = element_forw(ae))\n\t\telement_index(ae) -= n;\t \n\n\ta->num_elements -= n;\t\t \n\ta->max_index = element_index(a->head->prev);\n\n\tif (flags & AS_DISPOSE) {\n\t\tfor (ae = ret; ae; ) {\n\t\t\tret = element_forw(ae);\n\t\t\tarray_dispose_element(ae);\n\t\t\tae = ret;\n\t\t}\n\t\treturn ((ARRAY_ELEMENT *)NULL);\n\t}\n\n\treturn ret;\n}\n\n \nint\narray_rshift (a, n, s)\nARRAY\t*a;\nint\tn;\nchar\t*s;\n{\n\tregister ARRAY_ELEMENT\t*ae, *new;\n\n\tif (a == 0 || (array_empty(a) && s == 0))\n\t\treturn 0;\n\telse if (n <= 0)\n\t\treturn (a->num_elements);\n\n\tae = element_forw(a->head);\n\tif (s) {\n\t\tnew = array_create_element(0, s);\n\t\tADD_BEFORE(ae, new);\n\t\ta->num_elements++;\n\t\tif (array_num_elements(a) == 1)\t{\t \n\t\t\ta->max_index = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tfor ( ; ae != a->head; ae = element_forw(ae))\n\t\telement_index(ae) += n;\n\n\ta->max_index = element_index(a->head->prev);\n\n\tINVALIDATE_LASTREF(a);\n\treturn (a->num_elements);\n}\n\nARRAY_ELEMENT *\narray_unshift_element(a)\nARRAY\t*a;\n{\n\treturn (array_shift (a, 1, 0));\n}\n\nint\narray_shift_element(a, v)\nARRAY\t*a;\nchar\t*v;\n{\n\treturn (array_rshift (a, 1, v));\n}\n\nARRAY *\narray_quote(array)\nARRAY\t*array;\n{\n\tARRAY_ELEMENT\t*a;\n\tchar\t*t;\n\n\tif (array == 0 || array_head(array) == 0 || array_empty(array))\n\t\treturn (ARRAY *)NULL;\n\tfor (a = element_forw(array->head); a != array->head; a = element_forw(a)) {\n\t\tt = quote_string (a->value);\n\t\tFREE(a->value);\n\t\ta->value = t;\n\t}\n\treturn array;\n}\n\nARRAY *\narray_quote_escapes(array)\nARRAY\t*array;\n{\n\tARRAY_ELEMENT\t*a;\n\tchar\t*t;\n\n\tif (array == 0 || array_head(array) == 0 || array_empty(array))\n\t\treturn (ARRAY *)NULL;\n\tfor (a = element_forw(array->head); a != array->head; a = element_forw(a)) {\n\t\tt = quote_escapes (a->value);\n\t\tFREE(a->value);\n\t\ta->value = t;\n\t}\n\treturn array;\n}\n\nARRAY *\narray_dequote(array)\nARRAY\t*array;\n{\n\tARRAY_ELEMENT\t*a;\n\tchar\t*t;\n\n\tif (array == 0 || array_head(array) == 0 || array_empty(array))\n\t\treturn (ARRAY *)NULL;\n\tfor (a = element_forw(array->head); a != array->head; a = element_forw(a)) {\n\t\tt = dequote_string (a->value);\n\t\tFREE(a->value);\n\t\ta->value = t;\n\t}\n\treturn array;\n}\n\nARRAY *\narray_dequote_escapes(array)\nARRAY\t*array;\n{\n\tARRAY_ELEMENT\t*a;\n\tchar\t*t;\n\n\tif (array == 0 || array_head(array) == 0 || array_empty(array))\n\t\treturn (ARRAY *)NULL;\n\tfor (a = element_forw(array->head); a != array->head; a = element_forw(a)) {\n\t\tt = dequote_escapes (a->value);\n\t\tFREE(a->value);\n\t\ta->value = t;\n\t}\n\treturn array;\n}\n\nARRAY *\narray_remove_quoted_nulls(array)\nARRAY\t*array;\n{\n\tARRAY_ELEMENT\t*a;\n\n\tif (array == 0 || array_head(array) == 0 || array_empty(array))\n\t\treturn (ARRAY *)NULL;\n\tfor (a = element_forw(array->head); a != array->head; a = element_forw(a))\n\t\ta->value = remove_quoted_nulls (a->value);\n\treturn array;\n}\n\n \nchar *\narray_subrange (a, start, nelem, starsub, quoted, pflags)\nARRAY\t*a;\narrayind_t\tstart, nelem;\nint\tstarsub, quoted, pflags;\n{\n\tARRAY\t\t*a2;\n\tARRAY_ELEMENT\t*h, *p;\n\tarrayind_t\ti;\n\tchar\t\t*t;\n\tWORD_LIST\t*wl;\n\n\tp = a ? array_head (a) : 0;\n\tif (p == 0 || array_empty (a) || start > array_max_index(a))\n\t\treturn ((char *)NULL);\n\n\t \n\tfor (p = element_forw(p); p != array_head(a) && start > element_index(p); p = element_forw(p))\n\t\t;\n\n\tif (p == a->head)\n\t\treturn ((char *)NULL);\n\n\t \n\tfor (i = 0, h = p; p != a->head && i < nelem; i++, p = element_forw(p))\n\t\t;\n\n\ta2 = array_slice(a, h, p);\n\n\twl = array_to_word_list(a2);\n\tarray_dispose(a2);\n\tif (wl == 0)\n\t\treturn (char *)NULL;\n\tt = string_list_pos_params(starsub ? '*' : '@', wl, quoted, pflags);\t \n\tdispose_words(wl);\n\n\treturn t;\n}\n\nchar *\narray_patsub (a, pat, rep, mflags)\nARRAY\t*a;\nchar\t*pat, *rep;\nint\tmflags;\n{\n\tchar\t*t;\n\tint\tpchar, qflags, pflags;\n\tWORD_LIST\t*wl, *save;\n\n\tif (a == 0 || array_head(a) == 0 || array_empty(a))\n\t\treturn ((char *)NULL);\n\n\twl = array_to_word_list(a);\n\tif (wl == 0)\n\t\treturn (char *)NULL;\n\n\tfor (save = wl; wl; wl = wl->next) {\n\t\tt = pat_subst (wl->word->word, pat, rep, mflags);\n\t\tFREE (wl->word->word);\n\t\twl->word->word = t;\n\t}\n\n\tpchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';\n\tqflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;\n\tpflags = (mflags & MATCH_ASSIGNRHS) ? PF_ASSIGNRHS : 0;\n\n\tt = string_list_pos_params (pchar, save, qflags, pflags);\n\tdispose_words(save);\n\n\treturn t;\n}\n\nchar *\narray_modcase (a, pat, modop, mflags)\nARRAY\t*a;\nchar\t*pat;\nint\tmodop;\nint\tmflags;\n{\n\tchar\t*t;\n\tint\tpchar, qflags, pflags;\n\tWORD_LIST\t*wl, *save;\n\n\tif (a == 0 || array_head(a) == 0 || array_empty(a))\n\t\treturn ((char *)NULL);\n\n\twl = array_to_word_list(a);\n\tif (wl == 0)\n\t\treturn ((char *)NULL);\n\n\tfor (save = wl; wl; wl = wl->next) {\n\t\tt = sh_modcase(wl->word->word, pat, modop);\n\t\tFREE(wl->word->word);\n\t\twl->word->word = t;\n\t}\n\n\tpchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';\n\tqflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;\n\tpflags = (mflags & MATCH_ASSIGNRHS) ? PF_ASSIGNRHS : 0;\n\n\tt = string_list_pos_params (pchar, save, qflags, pflags);\n\tdispose_words(save);\n\n\treturn t;\n}\n\n \nARRAY_ELEMENT *\narray_create_element(indx, value)\narrayind_t\tindx;\nchar\t*value;\n{\n\tARRAY_ELEMENT *r;\n\n\tr = (ARRAY_ELEMENT *)xmalloc(sizeof(ARRAY_ELEMENT));\n\tr->ind = indx;\n\tr->value = value ? savestring(value) : (char *)NULL;\n\tr->next = r->prev = (ARRAY_ELEMENT *) NULL;\n\treturn(r);\n}\n\n#ifdef INCLUDE_UNUSED\nARRAY_ELEMENT *\narray_copy_element(ae)\nARRAY_ELEMENT\t*ae;\n{\n\treturn(ae ? array_create_element(element_index(ae), element_value(ae))\n\t\t  : (ARRAY_ELEMENT *) NULL);\n}\n#endif\n\nvoid\narray_dispose_element(ae)\nARRAY_ELEMENT\t*ae;\n{\n\tif (ae) {\n\t\tFREE(ae->value);\n\t\tfree(ae);\n\t}\n}\n\n \nint\narray_insert(a, i, v)\nARRAY\t*a;\narrayind_t\ti;\nchar\t*v;\n{\n\tregister ARRAY_ELEMENT *new, *ae, *start;\n\tarrayind_t startind;\n\tint direction;\n\n\tif (a == 0)\n\t\treturn(-1);\n\tnew = array_create_element(i, v);\n\tif (i > array_max_index(a)) {\n\t\t \n\t\tADD_BEFORE(a->head, new);\n\t\ta->max_index = i;\n\t\ta->num_elements++;\n\t\tSET_LASTREF(a, new);\n\t\treturn(0);\n\t} else if (i < array_first_index(a)) {\n\t\t \n\t\tADD_AFTER(a->head, new);\n\t\ta->num_elements++;\n\t\tSET_LASTREF(a, new);\n\t\treturn(0);\n\t}\n#if OPTIMIZE_SEQUENTIAL_ARRAY_ASSIGNMENT\n\t \n\tstart = LASTREF(a);\n\t \n\tstartind = element_index(start);\n\tif (i < startind/2) {\n\t\tstart = element_forw(a->head);\n\t\tstartind = element_index(start);\n\t\tdirection = 1;\n\t} else if (i >= startind) {\n\t\tdirection = 1;\n\t} else {\n\t\tdirection = -1;\n\t}\n#else\n\tstart = element_forw(ae->head);\n\tstartind = element_index(start);\n\tdirection = 1;\n#endif\n\tfor (ae = start; ae != a->head; ) {\n\t\tif (element_index(ae) == i) {\n\t\t\t \n\t\t\tfree(element_value(ae));\n\t\t\t \n\t\t\tae->value = new->value;\n\t\t\tnew->value = 0;\n\t\t\tarray_dispose_element(new);\n\t\t\tSET_LASTREF(a, ae);\n\t\t\treturn(0);\n\t\t} else if (direction == 1 && element_index(ae) > i) {\n\t\t\tADD_BEFORE(ae, new);\n\t\t\ta->num_elements++;\n\t\t\tSET_LASTREF(a, new);\n\t\t\treturn(0);\n\t\t} else if (direction == -1 && element_index(ae) < i) {\n\t\t\tADD_AFTER(ae, new);\n\t\t\ta->num_elements++;\n\t\t\tSET_LASTREF(a, new);\n\t\t\treturn(0);\n\t\t}\n\t\tae = direction == 1 ? element_forw(ae) : element_back(ae);\n\t}\n\tarray_dispose_element(new);\n\tINVALIDATE_LASTREF(a);\n\treturn (-1);\t\t \n}\n\n \nARRAY_ELEMENT *\narray_remove(a, i)\nARRAY\t*a;\narrayind_t\ti;\n{\n\tregister ARRAY_ELEMENT *ae, *start;\n\tarrayind_t startind;\n\tint direction;\n\n\tif (a == 0 || array_empty(a))\n\t\treturn((ARRAY_ELEMENT *) NULL);\n\tif (i > array_max_index(a) || i < array_first_index(a))\n\t\treturn((ARRAY_ELEMENT *)NULL);\t \n\tstart = LASTREF(a);\n\t \n\tstartind = element_index(start);\n\tif (i < startind/2) {\n\t\tstart = element_forw(a->head);\n\t\tstartind = element_index(start);\n\t\tdirection = 1;\n\t} else if (i >= startind) {\n\t\tdirection = 1;\n\t} else {\n\t\tdirection = -1;\n\t}\n\tfor (ae = start; ae != a->head; ) {\n\t\tif (element_index(ae) == i) {\n\t\t\tae->next->prev = ae->prev;\n\t\t\tae->prev->next = ae->next;\n\t\t\ta->num_elements--;\n\t\t\tif (i == array_max_index(a))\n\t\t\t\ta->max_index = element_index(ae->prev);\n#if 0\n\t\t\tINVALIDATE_LASTREF(a);\n#else\n\t\t\tif (ae->next != a->head)\n\t\t\t\tSET_LASTREF(a, ae->next);\n\t\t\telse if (ae->prev != a->head)\n\t\t\t\tSET_LASTREF(a, ae->prev);\n\t\t\telse\n\t\t\t\tINVALIDATE_LASTREF(a);\n#endif\n\t\t\treturn(ae);\n\t\t}\n\t\tae = (direction == 1) ? element_forw(ae) : element_back(ae);\n\t\tif (direction == 1 && element_index(ae) > i)\n\t\t\tbreak;\n\t\telse if (direction == -1 && element_index(ae) < i)\n\t\t\tbreak;\n\t}\n\treturn((ARRAY_ELEMENT *) NULL);\n}\n\n \nchar *\narray_reference(a, i)\nARRAY\t*a;\narrayind_t\ti;\n{\n\tregister ARRAY_ELEMENT *ae, *start;\n\tarrayind_t startind;\n\tint direction;\n\n\tif (a == 0 || array_empty(a))\n\t\treturn((char *) NULL);\n\tif (i > array_max_index(a) || i < array_first_index(a))\n\t\treturn((char *)NULL);\t \n\tstart = LASTREF(a);\t \n\tstartind = element_index(start);\n\tif (i < startind/2) {\t \n\t\tstart = element_forw(a->head);\n\t\tstartind = element_index(start);\n\t\tdirection = 1;\n\t} else if (i >= startind) {\n\t\tdirection = 1;\n\t} else {\n\t\tdirection = -1;\n\t}\n\tfor (ae = start; ae != a->head; ) {\n\t\tif (element_index(ae) == i) {\n\t\t\tSET_LASTREF(a, ae);\n\t\t\treturn(element_value(ae));\n\t\t}\n\t\tae = (direction == 1) ? element_forw(ae) : element_back(ae);\n\t\t \n\t\t \n\t\tif (direction == 1 && element_index(ae) > i) {\n\t\t\tstart = ae;\t \n\t\t\tbreak;\n\t\t} else if (direction == -1 && element_index(ae) < i) {\n\t\t\tstart = ae;\t \n\t\t\tbreak;\n\t\t}\n\t}\n#if 0\n\tUNSET_LASTREF(a);\n#else\n\tSET_LASTREF(a, start);\n#endif\n\treturn((char *) NULL);\n}\n\n \n\nWORD_LIST *\narray_to_word_list(a)\nARRAY\t*a;\n{\n\tWORD_LIST\t*list;\n\tARRAY_ELEMENT\t*ae;\n\n\tif (a == 0 || array_empty(a))\n\t\treturn((WORD_LIST *)NULL);\n\tlist = (WORD_LIST *)NULL;\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae))\n\t\tlist = make_word_list (make_bare_word(element_value(ae)), list);\n\treturn (REVERSE_LIST(list, WORD_LIST *));\n}\n\nARRAY *\narray_from_word_list (list)\nWORD_LIST\t*list;\n{\n\tARRAY\t*a;\n\n\tif (list == 0)\n\t\treturn((ARRAY *)NULL);\n\ta = array_create();\n\treturn (array_assign_list (a, list));\n}\n\nWORD_LIST *\narray_keys_to_word_list(a)\nARRAY\t*a;\n{\n\tWORD_LIST\t*list;\n\tARRAY_ELEMENT\t*ae;\n\tchar\t\t*t;\n\n\tif (a == 0 || array_empty(a))\n\t\treturn((WORD_LIST *)NULL);\n\tlist = (WORD_LIST *)NULL;\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {\n\t\tt = itos(element_index(ae));\n\t\tlist = make_word_list (make_bare_word(t), list);\n\t\tfree(t);\n\t}\n\treturn (REVERSE_LIST(list, WORD_LIST *));\n}\n\nWORD_LIST *\narray_to_kvpair_list(a)\nARRAY\t*a;\n{\n\tWORD_LIST\t*list;\n\tARRAY_ELEMENT\t*ae;\n\tchar\t\t*k, *v;\n\n\tif (a == 0 || array_empty(a))\n\t\treturn((WORD_LIST *)NULL);\n\tlist = (WORD_LIST *)NULL;\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {\n\t\tk = itos(element_index(ae));\n\t\tv = element_value(ae);\n\t\tlist = make_word_list (make_bare_word(k), list);\n\t\tlist = make_word_list (make_bare_word(v), list);\n\t\tfree(k);\n\t}\n\treturn (REVERSE_LIST(list, WORD_LIST *));\n}\n\nARRAY *\narray_assign_list (array, list)\nARRAY\t*array;\nWORD_LIST\t*list;\n{\n\tregister WORD_LIST *l;\n\tregister arrayind_t i;\n\n\tfor (l = list, i = 0; l; l = l->next, i++)\n\t\tarray_insert(array, i, l->word->word);\n\treturn array;\n}\n\nchar **\narray_to_argv (a, countp)\nARRAY\t*a;\nint\t*countp;\n{\n\tchar\t\t**ret, *t;\n\tint\t\ti;\n\tARRAY_ELEMENT\t*ae;\n\n\tif (a == 0 || array_empty(a)) {\n\t\tif (countp)\n\t\t\t*countp = 0;\n\t\treturn ((char **)NULL);\n\t}\n\tret = strvec_create (array_num_elements (a) + 1);\n\ti = 0;\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {\n\t\tt = element_value (ae);\n\t\tif (t)\n\t\t\tret[i++] = savestring (t);\n\t}\n\tret[i] = (char *)NULL;\n\tif (countp)\n\t\t*countp = i;\n\treturn (ret);\n}\n\nARRAY *\narray_from_argv(a, vec, count)\nARRAY\t*a;\nchar\t**vec;\nint\tcount;\n{\n  arrayind_t\ti;\n  ARRAY_ELEMENT\t*ae;\n  char\t*t;\n\n  if (a == 0 || array_num_elements (a) == 0)\n    {\n      for (i = 0; i < count; i++)\n\tarray_insert (a, i, t);\n      return a;\n    }\n\n   \n  if (array_num_elements (a) == count && count == 1)\n    {\n      ae = element_forw (a->head);\n      t = vec[0] ? savestring (vec[0]) : 0;\n      ARRAY_ELEMENT_REPLACE (ae, t);\n    }\n  else if (array_num_elements (a) <= count)\n    {\n       \n      ae = a->head;\n      for (i = 0; i < array_num_elements (a); i++)\n\t{\n\t  ae = element_forw (ae);\n\t  t = vec[0] ? savestring (vec[0]) : 0;\n\t  ARRAY_ELEMENT_REPLACE (ae, t);\n\t}\n       \n      for ( ; i < count; i++)\n\tarray_insert (a, i, vec[i]);\n    }\n  else\n    {\n       \t  \n      array_flush (a);\n      for (i = 0; i < count; i++)\n\tarray_insert (a, i, vec[i]);\n    }\n\n  return a;\n}\n\t\n \nstatic char *\narray_to_string_internal (start, end, sep, quoted)\nARRAY_ELEMENT\t*start, *end;\nchar\t*sep;\nint\tquoted;\n{\n\tchar\t*result, *t;\n\tARRAY_ELEMENT *ae;\n\tint\tslen, rsize, rlen, reg;\n\n\tif (start == end)\t \n\t\treturn ((char *)NULL);\n\n\tslen = strlen(sep);\n\tresult = NULL;\n\tfor (rsize = rlen = 0, ae = start; ae != end; ae = element_forw(ae)) {\n\t\tif (rsize == 0)\n\t\t\tresult = (char *)xmalloc (rsize = 64);\n\t\tif (element_value(ae)) {\n\t\t\tt = quoted ? quote_string(element_value(ae)) : element_value(ae);\n\t\t\treg = strlen(t);\n\t\t\tRESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),\n\t\t\t\t\t\trsize, rsize);\n\t\t\tstrcpy(result + rlen, t);\n\t\t\trlen += reg;\n\t\t\tif (quoted)\n\t\t\t\tfree(t);\n\t\t\t \n\t\t\tif (element_forw(ae) != end) {\n\t\t\t\tstrcpy(result + rlen, sep);\n\t\t\t\trlen += slen;\n\t\t\t}\n\t\t}\n\t}\n\tif (result)\n\t  result[rlen] = '\\0';\t \n\treturn(result);\n}\n\nchar *\narray_to_kvpair (a, quoted)\nARRAY\t*a;\nint\tquoted;\n{\n\tchar\t*result, *valstr, *is;\n\tchar\tindstr[INT_STRLEN_BOUND(intmax_t) + 1];\n\tARRAY_ELEMENT *ae;\n\tint\trsize, rlen, elen;\n\n\tif (a == 0 || array_empty (a))\n\t\treturn((char *)NULL);\n\n\tresult = (char *)xmalloc (rsize = 128);\n\tresult[rlen = 0] = '\\0';\n\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {\n\t\tis = inttostr (element_index(ae), indstr, sizeof(indstr));\n\t\tvalstr = element_value (ae) ?\n\t\t\t\t(ansic_shouldquote (element_value (ae)) ?\n\t\t\t\t   ansic_quote (element_value(ae), 0, (int *)0) :\n\t\t\t\t   sh_double_quote (element_value (ae)))\n\t\t\t\t\t    : (char *)NULL;\n\t\telen = STRLEN (is) + 8 + STRLEN (valstr);\n\t\tRESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);\n\n\t\tstrcpy (result + rlen, is);\n\t\trlen += STRLEN (is);\n\t\tresult[rlen++] = ' ';\n\t\tif (valstr) {\n\t\t\tstrcpy (result + rlen, valstr);\n\t\t\trlen += STRLEN (valstr);\n\t\t} else {\n\t\t\tstrcpy (result + rlen, \"\\\"\\\"\");\n\t\t\trlen += 2;\n\t\t}\n\n\t\tif (element_forw(ae) != a->head)\n\t\t  result[rlen++] = ' ';\n\n\t\tFREE (valstr);\n\t}\n\tRESIZE_MALLOCED_BUFFER (result, rlen, 1, rsize, 8);\n\tresult[rlen] = '\\0';\n\n\tif (quoted) {\n\t\t \n\t\tvalstr = sh_single_quote (result);\n\t\tfree (result);\n\t\tresult = valstr;\n\t}\n\treturn(result);\n}\n\nchar *\narray_to_assign (a, quoted)\nARRAY\t*a;\nint\tquoted;\n{\n\tchar\t*result, *valstr, *is;\n\tchar\tindstr[INT_STRLEN_BOUND(intmax_t) + 1];\n\tARRAY_ELEMENT *ae;\n\tint\trsize, rlen, elen;\n\n\tif (a == 0 || array_empty (a))\n\t\treturn((char *)NULL);\n\n\tresult = (char *)xmalloc (rsize = 128);\n\tresult[0] = '(';\n\trlen = 1;\n\n\tfor (ae = element_forw(a->head); ae != a->head; ae = element_forw(ae)) {\n\t\tis = inttostr (element_index(ae), indstr, sizeof(indstr));\n\t\tvalstr = element_value (ae) ?\n\t\t\t\t(ansic_shouldquote (element_value (ae)) ?\n\t\t\t\t   ansic_quote (element_value(ae), 0, (int *)0) :\n\t\t\t\t   sh_double_quote (element_value (ae)))\n\t\t\t\t\t    : (char *)NULL;\n\t\telen = STRLEN (is) + 8 + STRLEN (valstr);\n\t\tRESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);\n\n\t\tresult[rlen++] = '[';\n\t\tstrcpy (result + rlen, is);\n\t\trlen += STRLEN (is);\n\t\tresult[rlen++] = ']';\n\t\tresult[rlen++] = '=';\n\t\tif (valstr) {\n\t\t\tstrcpy (result + rlen, valstr);\n\t\t\trlen += STRLEN (valstr);\n\t\t}\n\n\t\tif (element_forw(ae) != a->head)\n\t\t  result[rlen++] = ' ';\n\n\t\tFREE (valstr);\n\t}\n\tRESIZE_MALLOCED_BUFFER (result, rlen, 1, rsize, 8);\n\tresult[rlen++] = ')';\n\tresult[rlen] = '\\0';\n\tif (quoted) {\n\t\t \n\t\tvalstr = sh_single_quote (result);\n\t\tfree (result);\n\t\tresult = valstr;\n\t}\n\treturn(result);\n}\n\nchar *\narray_to_string (a, sep, quoted)\nARRAY\t*a;\nchar\t*sep;\nint\tquoted;\n{\n\tif (a == 0)\n\t\treturn((char *)NULL);\n\tif (array_empty(a))\n\t\treturn(savestring(\"\"));\n\treturn (array_to_string_internal (element_forw(a->head), a->head, sep, quoted));\n}\n\n#if defined (INCLUDE_UNUSED) || defined (TEST_ARRAY)\n \nARRAY *\narray_from_string(s, sep)\nchar\t*s, *sep;\n{\n\tARRAY\t*a;\n\tWORD_LIST *w;\n\n\tif (s == 0)\n\t\treturn((ARRAY *)NULL);\n\tw = list_string (s, sep, 0);\n\tif (w == 0)\n\t\treturn((ARRAY *)NULL);\n\ta = array_from_word_list (w);\n\treturn (a);\n}\n#endif\n\n#if defined (TEST_ARRAY)\n \nint interrupt_immediately = 0;\n\nint\nsignal_is_trapped(s)\nint\ts;\n{\n\treturn 0;\n}\n\nvoid\nfatal_error(const char *s, ...)\n{\n\tfprintf(stderr, \"array_test: fatal memory error\\n\");\n\tabort();\n}\n\nvoid\nprogramming_error(const char *s, ...)\n{\n\tfprintf(stderr, \"array_test: fatal programming error\\n\");\n\tabort();\n}\n\nWORD_DESC *\nmake_bare_word (s)\nconst char\t*s;\n{\n\tWORD_DESC *w;\n\n\tw = (WORD_DESC *)xmalloc(sizeof(WORD_DESC));\n\tw->word = s ? savestring(s) : savestring (\"\");\n\tw->flags = 0;\n\treturn w;\n}\n\nWORD_LIST *\nmake_word_list(x, l)\nWORD_DESC\t*x;\nWORD_LIST\t*l;\n{\n\tWORD_LIST *w;\n\n\tw = (WORD_LIST *)xmalloc(sizeof(WORD_LIST));\n\tw->word = x;\n\tw->next = l;\n\treturn w;\n}\n\nWORD_LIST *\nlist_string(s, t, i)\nchar\t*s, *t;\nint\ti;\n{\n\tchar\t*r, *a;\n\tWORD_LIST\t*wl;\n\n\tif (s == 0)\n\t\treturn (WORD_LIST *)NULL;\n\tr = savestring(s);\n\twl = (WORD_LIST *)NULL;\n\ta = strtok(r, t);\n\twhile (a) {\n\t\twl = make_word_list (make_bare_word(a), wl);\n\t\ta = strtok((char *)NULL, t);\n\t}\n\treturn (REVERSE_LIST (wl, WORD_LIST *));\n}\n\nGENERIC_LIST *\nlist_reverse (list)\nGENERIC_LIST\t*list;\n{\n\tregister GENERIC_LIST *next, *prev;\n\n\tfor (prev = 0; list; ) {\n\t\tnext = list->next;\n\t\tlist->next = prev;\n\t\tprev = list;\n\t\tlist = next;\n\t}\n\treturn prev;\n}\n\nchar *\npat_subst(s, t, u, i)\nchar\t*s, *t, *u;\nint\ti;\n{\n\treturn ((char *)NULL);\n}\n\nchar *\nquote_string(s)\nchar\t*s;\n{\n\treturn savestring(s);\n}\n\nprint_element(ae)\nARRAY_ELEMENT\t*ae;\n{\n\tchar\tlbuf[INT_STRLEN_BOUND (intmax_t) + 1];\n\n\tprintf(\"array[%s] = %s\\n\",\n\t\tinttostr (element_index(ae), lbuf, sizeof (lbuf)),\n\t\telement_value(ae));\n}\n\nprint_array(a)\nARRAY\t*a;\n{\n\tprintf(\"\\n\");\n\tarray_walk(a, print_element, (void *)NULL);\n}\n\nmain()\n{\n\tARRAY\t*a, *new_a, *copy_of_a;\n\tARRAY_ELEMENT\t*ae, *aew;\n\tchar\t*s;\n\n\ta = array_create();\n\tarray_insert(a, 1, \"one\");\n\tarray_insert(a, 7, \"seven\");\n\tarray_insert(a, 4, \"four\");\n\tarray_insert(a, 1029, \"one thousand twenty-nine\");\n\tarray_insert(a, 12, \"twelve\");\n\tarray_insert(a, 42, \"forty-two\");\n\tprint_array(a);\n\ts = array_to_string (a, \" \", 0);\n\tprintf(\"s = %s\\n\", s);\n\tcopy_of_a = array_from_string(s, \" \");\n\tprintf(\"copy_of_a:\");\n\tprint_array(copy_of_a);\n\tarray_dispose(copy_of_a);\n\tprintf(\"\\n\");\n\tfree(s);\n\tae = array_remove(a, 4);\n\tarray_dispose_element(ae);\n\tae = array_remove(a, 1029);\n\tarray_dispose_element(ae);\n\tarray_insert(a, 16, \"sixteen\");\n\tprint_array(a);\n\ts = array_to_string (a, \" \", 0);\n\tprintf(\"s = %s\\n\", s);\n\tcopy_of_a = array_from_string(s, \" \");\n\tprintf(\"copy_of_a:\");\n\tprint_array(copy_of_a);\n\tarray_dispose(copy_of_a);\n\tprintf(\"\\n\");\n\tfree(s);\n\tarray_insert(a, 2, \"two\");\n\tarray_insert(a, 1029, \"new one thousand twenty-nine\");\n\tarray_insert(a, 0, \"zero\");\n\tarray_insert(a, 134, \"\");\n\tprint_array(a);\n\ts = array_to_string (a, \":\", 0);\n\tprintf(\"s = %s\\n\", s);\n\tcopy_of_a = array_from_string(s, \":\");\n\tprintf(\"copy_of_a:\");\n\tprint_array(copy_of_a);\n\tarray_dispose(copy_of_a);\n\tprintf(\"\\n\");\n\tfree(s);\n\tnew_a = array_copy(a);\n\tprint_array(new_a);\n\ts = array_to_string (new_a, \":\", 0);\n\tprintf(\"s = %s\\n\", s);\n\tcopy_of_a = array_from_string(s, \":\");\n\tfree(s);\n\tprintf(\"copy_of_a:\");\n\tprint_array(copy_of_a);\n\tarray_shift(copy_of_a, 2, AS_DISPOSE);\n\tprintf(\"copy_of_a shifted by two:\");\n\tprint_array(copy_of_a);\n\tae = array_shift(copy_of_a, 2, 0);\n\tprintf(\"copy_of_a shifted by two:\");\n\tprint_array(copy_of_a);\n\tfor ( ; ae; ) {\n\t\taew = element_forw(ae);\n\t\tarray_dispose_element(ae);\n\t\tae = aew;\n\t}\n\tarray_rshift(copy_of_a, 1, (char *)0);\n\tprintf(\"copy_of_a rshift by 1:\");\n\tprint_array(copy_of_a);\n\tarray_rshift(copy_of_a, 2, \"new element zero\");\n\tprintf(\"copy_of_a rshift again by 2 with new element zero:\");\n\tprint_array(copy_of_a);\n\ts = array_to_assign(copy_of_a, 0);\n\tprintf(\"copy_of_a=%s\\n\", s);\n\tfree(s);\n\tae = array_shift(copy_of_a, array_num_elements(copy_of_a), 0);\n\tfor ( ; ae; ) {\n\t\taew = element_forw(ae);\n\t\tarray_dispose_element(ae);\n\t\tae = aew;\n\t}\n\tarray_dispose(copy_of_a);\n\tprintf(\"\\n\");\n\tarray_dispose(a);\n\tarray_dispose(new_a);\n}\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}