{
  "module_name": "execute_cmd.c",
  "hash_id": "c3a4289b4c442f9f5e5994f5d2110063cafb52d08833391a8af736e89286fd31",
  "original_prompt": "Ingested from bash-5.2.21/execute_cmd.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if !defined (__GNUC__) && !defined (HAVE_ALLOCA_H) && defined (_AIX)\n  #pragma alloca\n#endif  \n\n#include <stdio.h>\n#include \"chartypes.h\"\n#include \"bashtypes.h\"\n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"filecntl.h\"\n#include \"posixstat.h\"\n#include <signal.h>\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"posixtime.h\"\n\n#if defined (HAVE_SYS_RESOURCE_H) && !defined (RLIMTYPE)\n#  include <sys/resource.h>\n#endif\n\n#if defined (HAVE_SYS_TIMES_H) && defined (HAVE_TIMES)\n#  include <sys/times.h>\n#endif\n\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#define NEED_FPURGE_DECL\n#define NEED_SH_SETLINEBUF_DECL\n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include \"memalloc.h\"\n#include \"shell.h\"\n#include <y.tab.h>\t \n#include \"parser.h\"\n#include \"flags.h\"\n#include \"builtins.h\"\n#include \"hashlib.h\"\n#include \"jobs.h\"\n#include \"execute_cmd.h\"\n#include \"findcmd.h\"\n#include \"redir.h\"\n#include \"trap.h\"\n#include \"pathexp.h\"\n#include \"hashcmd.h\"\n\n#if defined (COND_COMMAND)\n#  include \"test.h\"\n#endif\n\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\t \n\n#include \"builtins/getopt.h\"\n\n#include <glob/strmatch.h>\n#include <tilde/tilde.h>\n\n#if defined (BUFFERED_INPUT)\n#  include \"input.h\"\n#endif\n\n#if defined (ALIAS)\n#  include \"alias.h\"\n#endif\n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#endif\n\n#if defined (HAVE_MBSTR_H) && defined (HAVE_MBSCHR)\n#  include <mbstr.h>\t\t \n#endif\n\nextern int command_string_index;\nextern char *the_printed_command;\nextern time_t shell_start_time;\n#if defined (HAVE_GETTIMEOFDAY)\nextern struct timeval shellstart;\n#endif\n#if 0\nextern char *glob_argv_flags;\n#endif\n\nextern int close PARAMS((int));\n\n \nstatic void close_pipes PARAMS((int, int));\nstatic void do_piping PARAMS((int, int));\nstatic void bind_lastarg PARAMS((char *));\nstatic int shell_control_structure PARAMS((enum command_type));\nstatic void cleanup_redirects PARAMS((REDIRECT *));\n\n#if defined (JOB_CONTROL)\nstatic int restore_signal_mask PARAMS((sigset_t *));\n#endif\n\nstatic int builtin_status PARAMS((int));\n\nstatic int execute_for_command PARAMS((FOR_COM *));\n#if defined (SELECT_COMMAND)\nstatic int displen PARAMS((const char *));\nstatic int print_index_and_element PARAMS((int, int, WORD_LIST *));\nstatic void indent PARAMS((int, int));\nstatic void print_select_list PARAMS((WORD_LIST *, int, int, int));\nstatic char *select_query PARAMS((WORD_LIST *, int, char *, int));\nstatic int execute_select_command PARAMS((SELECT_COM *));\n#endif\n#if defined (DPAREN_ARITHMETIC)\nstatic int execute_arith_command PARAMS((ARITH_COM *));\n#endif\n#if defined (COND_COMMAND)\nstatic int execute_cond_node PARAMS((COND_COM *));\nstatic int execute_cond_command PARAMS((COND_COM *));\n#endif\n#if defined (COMMAND_TIMING)\nstatic int mkfmt PARAMS((char *, int, int, time_t, int));\nstatic void print_formatted_time PARAMS((FILE *, char *,\n\t\t\t\t      time_t, int, time_t, int,\n\t\t\t\t      time_t, int, int));\nstatic int time_command PARAMS((COMMAND *, int, int, int, struct fd_bitmap *));\n#endif\n#if defined (ARITH_FOR_COMMAND)\nstatic intmax_t eval_arith_for_expr PARAMS((WORD_LIST *, int *));\nstatic int execute_arith_for_command PARAMS((ARITH_FOR_COM *));\n#endif\nstatic int execute_case_command PARAMS((CASE_COM *));\nstatic int execute_while_command PARAMS((WHILE_COM *));\nstatic int execute_until_command PARAMS((WHILE_COM *));\nstatic int execute_while_or_until PARAMS((WHILE_COM *, int));\nstatic int execute_if_command PARAMS((IF_COM *));\nstatic int execute_null_command PARAMS((REDIRECT *, int, int, int));\nstatic void fix_assignment_words PARAMS((WORD_LIST *));\nstatic void fix_arrayref_words PARAMS((WORD_LIST *));\nstatic int execute_simple_command PARAMS((SIMPLE_COM *, int, int, int, struct fd_bitmap *));\nstatic int execute_builtin PARAMS((sh_builtin_func_t *, WORD_LIST *, int, int));\nstatic int execute_function PARAMS((SHELL_VAR *, WORD_LIST *, int, struct fd_bitmap *, int, int));\nstatic int execute_builtin_or_function PARAMS((WORD_LIST *, sh_builtin_func_t *,\n\t\t\t\t\t    SHELL_VAR *,\n\t\t\t\t\t    REDIRECT *, struct fd_bitmap *, int));\nstatic void execute_subshell_builtin_or_function PARAMS((WORD_LIST *, REDIRECT *,\n\t\t\t\t\t\t      sh_builtin_func_t *,\n\t\t\t\t\t\t      SHELL_VAR *,\n\t\t\t\t\t\t      int, int, int,\n\t\t\t\t\t\t      struct fd_bitmap *,\n\t\t\t\t\t\t      int));\nstatic int execute_disk_command PARAMS((WORD_LIST *, REDIRECT *, char *,\n\t\t\t\t      int, int, int, struct fd_bitmap *, int));\n\nstatic char *getinterp PARAMS((char *, int, int *));\nstatic void initialize_subshell PARAMS((void));\nstatic int execute_in_subshell PARAMS((COMMAND *, int, int, int, struct fd_bitmap *));\n#if defined (COPROCESS_SUPPORT)\nstatic void coproc_setstatus PARAMS((struct coproc *, int));\nstatic int execute_coproc PARAMS((COMMAND *, int, int, struct fd_bitmap *));\n#endif\n\nstatic int execute_pipeline PARAMS((COMMAND *, int, int, int, struct fd_bitmap *));\n\nstatic int execute_connection PARAMS((COMMAND *, int, int, int, struct fd_bitmap *));\n\nstatic int execute_intern_function PARAMS((WORD_DESC *, FUNCTION_DEF *));\n\n \nint stdin_redir;\n\n \nchar *this_command_name;\n\n \nchar *the_printed_command_except_trap;\n\n \nint return_catch_flag;\nint return_catch_value;\nprocenv_t return_catch;\n\n \nvolatile int last_command_exit_value;\n\n \nint last_command_exit_signal;\n\n \nint builtin_ignoring_errexit = 0;\n\n \nREDIRECT *redirection_undo_list = (REDIRECT *)NULL;\n\n \nREDIRECT *exec_redirection_undo_list = (REDIRECT *)NULL;\n\n \nint executing_builtin = 0;\n\n \nint executing_list = 0;\n\n \nint comsub_ignore_return = 0;\n\n \nint subshell_environment;\n\n \nint subshell_level = 0;\n\n \nSHELL_VAR *this_shell_function;\n\n \nint match_ignore_case = 0;\n\nint executing_command_builtin = 0;\n\nstruct stat SB;\t\t \n\nstatic int special_builtin_failed;\n\nstatic COMMAND *currently_executing_command;\n\n \nstatic int function_line_number;\n\n \nstatic int showing_function_line;\n\nstatic int connection_count;\n\n \nint line_number_for_err_trap;\n\n \n#define SET_LINE_NUMBER(v) \\\ndo { \\\n  line_number = v; \\\n  if (signal_in_progress (ERROR_TRAP) == 0 && running_trap != (ERROR_TRAP + 1)) \\\n    line_number_for_err_trap = line_number; \\\n} while (0)\n\n \n#define GET_LINE_NUMBER() \\\n  (signal_in_progress (ERROR_TRAP) && running_trap == ERROR_TRAP+1) \\\n    ? line_number_for_err_trap \\\n    : executing_line_number ()\n\n \nint funcnest = 0;\nint funcnest_max = 0;\n\nint evalnest = 0;\nint evalnest_max = EVALNEST_MAX;\n\nint sourcenest = 0;\nint sourcenest_max = SOURCENEST_MAX;\n\nvolatile int from_return_trap = 0;\n\nint lastpipe_opt = 0;\n\nstruct fd_bitmap *current_fds_to_close = (struct fd_bitmap *)NULL;\n\n#define FD_BITMAP_DEFAULT_SIZE 32\n\n \nstruct fd_bitmap *\nnew_fd_bitmap (size)\n     int size;\n{\n  struct fd_bitmap *ret;\n\n  ret = (struct fd_bitmap *)xmalloc (sizeof (struct fd_bitmap));\n\n  ret->size = size;\n\n  if (size)\n    {\n      ret->bitmap = (char *)xmalloc (size);\n      memset (ret->bitmap, '\\0', size);\n    }\n  else\n    ret->bitmap = (char *)NULL;\n  return (ret);\n}\n\nvoid\ndispose_fd_bitmap (fdbp)\n     struct fd_bitmap *fdbp;\n{\n  FREE (fdbp->bitmap);\n  free (fdbp);\n}\n\nvoid\nclose_fd_bitmap (fdbp)\n     struct fd_bitmap *fdbp;\n{\n  register int i;\n\n  if (fdbp)\n    {\n      for (i = 0; i < fdbp->size; i++)\n\tif (fdbp->bitmap[i])\n\t  {\n\t    close (i);\n\t    fdbp->bitmap[i] = 0;\n\t  }\n    }\n}\n\n \nint\nexecuting_line_number ()\n{\n  if (executing && showing_function_line == 0 &&\n      (variable_context == 0 || interactive_shell == 0) &&\n      currently_executing_command)\n    {\n#if defined (COND_COMMAND)\n      if (currently_executing_command->type == cm_cond)\n\treturn currently_executing_command->value.Cond->line;\n#endif\n#if defined (DPAREN_ARITHMETIC)\n      if (currently_executing_command->type == cm_arith)\n\treturn currently_executing_command->value.Arith->line;\n#endif\n#if defined (ARITH_FOR_COMMAND)\n      if (currently_executing_command->type == cm_arith_for)\n\treturn currently_executing_command->value.ArithFor->line;\n#endif\n\n      return line_number;\n    }\n  else\n    return line_number;\n}\n\n \nint\nexecute_command (command)\n     COMMAND *command;\n{\n  struct fd_bitmap *bitmap;\n  int result;\n\n  current_fds_to_close = (struct fd_bitmap *)NULL;\n  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);\n  begin_unwind_frame (\"execute-command\");\n  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);\n\n   \n  result = execute_command_internal (command, 0, NO_PIPE, NO_PIPE, bitmap);\n\n  dispose_fd_bitmap (bitmap);\n  discard_unwind_frame (\"execute-command\");\n\n#if defined (PROCESS_SUBSTITUTION)\n   \n  if (variable_context == 0 && executing_list == 0)\n    unlink_fifo_list ();\n#endif  \n\n  QUIT;\n  return (result);\n}\n\n \nstatic int\nshell_control_structure (type)\n     enum command_type type;\n{\n  switch (type)\n    {\n#if defined (ARITH_FOR_COMMAND)\n    case cm_arith_for:\n#endif\n#if defined (SELECT_COMMAND)\n    case cm_select:\n#endif\n#if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n#endif\n#if defined (COND_COMMAND)\n    case cm_cond:\n#endif\n    case cm_case:\n    case cm_while:\n    case cm_until:\n    case cm_if:\n    case cm_for:\n    case cm_group:\n    case cm_function_def:\n      return (1);\n\n    default:\n      return (0);\n    }\n}\n\n \nstatic void\ncleanup_redirects (list)\n     REDIRECT *list;\n{\n  do_redirections (list, RX_ACTIVE);\n  dispose_redirects (list);\n}\n\nvoid\nundo_partial_redirects ()\n{\n  if (redirection_undo_list)\n    {\n      cleanup_redirects (redirection_undo_list);\n      redirection_undo_list = (REDIRECT *)NULL;\n    }\n}\n\n#if 0\n \nstatic void\ncleanup_func_redirects (list)\n     REDIRECT *list;\n{\n  do_redirections (list, RX_ACTIVE);\n}\n#endif\n\nvoid\ndispose_exec_redirects ()\n{\n  if (exec_redirection_undo_list)\n    {\n      dispose_redirects (exec_redirection_undo_list);\n      exec_redirection_undo_list = (REDIRECT *)NULL;\n    }\n}\n\nvoid\ndispose_partial_redirects ()\n{\n  if (redirection_undo_list)\n    {\n      dispose_redirects (redirection_undo_list);\n      redirection_undo_list = (REDIRECT *)NULL;\n    }\n}\n\n#if defined (JOB_CONTROL)\n \nstatic int\nrestore_signal_mask (set)\n     sigset_t *set;\n{\n  return (sigprocmask (SIG_SETMASK, set, (sigset_t *)NULL));\n}\n#endif  \n\n#ifdef DEBUG\n \nvoid\nopen_files (void)\n{\n  register int i;\n  int f, fd_table_size;\n\n  fd_table_size = getdtablesize ();\n\n  fprintf (stderr, \"pid %ld open files:\", (long)getpid ());\n  for (i = 3; i < fd_table_size; i++)\n    {\n      if ((f = fcntl (i, F_GETFD, 0)) != -1)\n\tfprintf (stderr, \" %d (%s)\", i, f ? \"close\" : \"open\");\n    }\n  fprintf (stderr, \"\\n\");\n}\n#endif\n\nvoid\nasync_redirect_stdin ()\n{\n  int fd;\n\n  fd = open (\"/dev/null\", O_RDONLY);\n  if (fd > 0)\n    {\n      dup2 (fd, 0);\n      close (fd);\n    }\n  else if (fd < 0)\n    internal_error (_(\"cannot redirect standard input from /dev/null: %s\"), strerror (errno));\n}\n\n#define DESCRIBE_PID(pid) do { if (interactive) describe_pid (pid); } while (0)\n\n \nint\nexecute_command_internal (command, asynchronous, pipe_in, pipe_out,\n\t\t\t  fds_to_close)\n     COMMAND *command;\n     int asynchronous;\n     int pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int exec_result, user_subshell, invert, ignore_return, was_error_trap, fork_flags;\n  REDIRECT *my_undo_list, *exec_undo_list;\n  char *tcmd;\n  volatile int save_line_number;\n#if defined (PROCESS_SUBSTITUTION)\n  volatile int ofifo, nfifo, osize, saved_fifo;\n  volatile void *ofifo_list;\n#endif\n\n  if (breaking || continuing)\n    return (last_command_exit_value);\n  if (read_but_dont_execute)\n    return (last_command_exit_value);\n  if (command == 0)\n    return (EXECUTION_SUCCESS);\n\n  QUIT;\n  run_pending_traps ();\n\n#if 0\n  if (running_trap == 0)\n#endif\n    currently_executing_command = command;\n\n  invert = (command->flags & CMD_INVERT_RETURN) != 0;\n\n   \n  if (exit_immediately_on_error && invert)\t \n    command->flags |= CMD_IGNORE_RETURN;\t \n\n  exec_result = EXECUTION_SUCCESS;\n\n   \n  if (command->type == cm_subshell && (command->flags & CMD_NO_FORK))\n    return (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));\n\n#if defined (COPROCESS_SUPPORT)\n  if (command->type == cm_coproc)\n    return (last_command_exit_value = execute_coproc (command, pipe_in, pipe_out, fds_to_close));\n#endif\n\n  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);\n\n#if defined (TIME_BEFORE_SUBSHELL)\n  if ((command->flags & CMD_TIME_PIPELINE) && user_subshell && asynchronous == 0)\n    {\n      command->flags |= CMD_FORCE_SUBSHELL;\n      exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n      currently_executing_command = (COMMAND *)NULL;\n      return (exec_result);\n    }\n#endif\n\n  if (command->type == cm_subshell ||\n      (command->flags & (CMD_WANT_SUBSHELL|CMD_FORCE_SUBSHELL)) ||\n      (shell_control_structure (command->type) &&\n       (pipe_out != NO_PIPE || pipe_in != NO_PIPE || asynchronous)))\n    {\n      pid_t paren_pid;\n      int s;\n      char *p;\n\n       \n      save_line_number = line_number;\n      if (command->type == cm_subshell)\n\tSET_LINE_NUMBER (command->value.Subshell->line);\t \n\t \n      tcmd = make_command_string (command);\n      fork_flags = asynchronous ? FORK_ASYNC : 0;\n      paren_pid = make_child (p = savestring (tcmd), fork_flags);\n\n      if (user_subshell && signal_is_trapped (ERROR_TRAP) && \n\t  signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n\t{\n\t  FREE (the_printed_command_except_trap);\n\t  the_printed_command_except_trap = savestring (the_printed_command);\n\t}\n\n      if (paren_pid == 0)\n        {\n#if defined (JOB_CONTROL)\n\t  FREE (p);\t\t \n#endif\n\t   \n\t   \n\t  s = user_subshell == 0 && command->type == cm_group && pipe_in == NO_PIPE && pipe_out == NO_PIPE && asynchronous;\n\t   \n\t   \n\t  s += user_subshell == 0 && command->type == cm_group && (pipe_in != NO_PIPE || pipe_out != NO_PIPE) && asynchronous == 0;\n\n\t  last_command_exit_value = execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n\t  if (s)\n\t    subshell_exit (last_command_exit_value);\n\t  else\n\t    sh_exit (last_command_exit_value);\n\t   \n        }\n      else\n\t{\n\t  close_pipes (pipe_in, pipe_out);\n\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n\t  if (variable_context == 0)\t \n\t    unlink_fifo_list ();\n#endif\n\t   \n\t  if (pipe_out != NO_PIPE)\n\t    return (EXECUTION_SUCCESS);\n\n\t  stop_pipeline (asynchronous, (COMMAND *)NULL);\n\n\t  line_number = save_line_number;\n\n\t  if (asynchronous == 0)\n\t    {\n\t      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n\t      invert = (command->flags & CMD_INVERT_RETURN) != 0;\n\t      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n\t      exec_result = wait_for (paren_pid, 0);\n\n\t       \n\t      if (invert)\n\t\texec_result = ((exec_result == EXECUTION_SUCCESS)\n\t\t\t\t? EXECUTION_FAILURE\n\t\t\t\t: EXECUTION_SUCCESS);\n\n\t      last_command_exit_value = exec_result;\n\t      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t\t{\n\t\t  save_line_number = line_number;\n\t\t  line_number = line_number_for_err_trap;\n\t\t  run_error_trap ();\n\t\t  line_number = save_line_number;\n\t\t}\n\n\t      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t\t{\n\t\t  run_pending_traps ();\n\t\t  jump_to_top_level (ERREXIT);\n\t\t}\n\n\t      return (last_command_exit_value);\n\t    }\n\t  else\n\t    {\n\t      DESCRIBE_PID (paren_pid);\n\n\t      run_pending_traps ();\n\n\t       \n\t      last_command_exit_value = 0;\n\t      return (EXECUTION_SUCCESS);\n\t    }\n\t}\n    }\n\n#if defined (COMMAND_TIMING)\n  if (command->flags & CMD_TIME_PIPELINE)\n    {\n      if (asynchronous)\n\t{\n\t  command->flags |= CMD_FORCE_SUBSHELL;\n\t  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);\n\t}\n      else\n\t{\n\t  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n#if 0\n\t  if (running_trap == 0)\n#endif\n\t    currently_executing_command = (COMMAND *)NULL;\n\t}\n      return (exec_result);\n    }\n#endif  \n\n  if (shell_control_structure (command->type) && command->redirects)\n    stdin_redir = stdin_redirects (command->redirects);\n\n#if defined (PROCESS_SUBSTITUTION)\n#  if !defined (HAVE_DEV_FD)\n  reap_procsubs ();\n#  endif\n\n   \n  if (variable_context != 0 || executing_list)\n    {\n      ofifo = num_fifos ();\n      ofifo_list = copy_fifo_list ((int *)&osize);\n      begin_unwind_frame (\"internal_fifos\");\n      if (ofifo_list)\n\tadd_unwind_protect (xfree, ofifo_list);\n      saved_fifo = 1;\n    }\n  else\n    saved_fifo = 0;\n#endif\n\n   \n  was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n  if (do_redirections (command->redirects, RX_ACTIVE|RX_UNDOABLE) != 0)\n    {\n      undo_partial_redirects ();\n      dispose_exec_redirects ();\n#if defined (PROCESS_SUBSTITUTION)\n      if (saved_fifo)\n\t{\n\t  free ((void *)ofifo_list);\n          discard_unwind_frame (\"internal_fifos\");\n\t}\n#endif\n\n       \n      last_command_exit_value = EXECUTION_FAILURE;\n      if (ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE)\n\t{\n\t  if (was_error_trap)\n\t    {\n\t      save_line_number = line_number;\n\t      line_number = line_number_for_err_trap;\n\t      run_error_trap ();\n\t      line_number = save_line_number;\n\t    }\n\t  if (exit_immediately_on_error)\n\t    {\t  \n\t      run_pending_traps ();\n\t      jump_to_top_level (ERREXIT);\n\t    }\n\t}\n      return (last_command_exit_value);\n    }\n\n  my_undo_list = redirection_undo_list;\n  redirection_undo_list = (REDIRECT *)NULL;\n\n  exec_undo_list = exec_redirection_undo_list;\n  exec_redirection_undo_list = (REDIRECT *)NULL;\n\n  if (my_undo_list || exec_undo_list)\n    begin_unwind_frame (\"loop_redirections\");\n\n  if (my_undo_list)\n    add_unwind_protect ((Function *)cleanup_redirects, my_undo_list);\n\n  if (exec_undo_list)\n    add_unwind_protect ((Function *)dispose_redirects, exec_undo_list);\n\n  QUIT;\n\n  switch (command->type)\n    {\n    case cm_simple:\n      {\n\tsave_line_number = line_number;\n\t \n#if defined (RECYCLES_PIDS)\n\tlast_made_pid = NO_PID;\n#endif\n\twas_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n\n\tif (ignore_return && command->value.Simple)\n\t  command->value.Simple->flags |= CMD_IGNORE_RETURN;\n\tif (command->flags & CMD_STDIN_REDIR)\n\t  command->value.Simple->flags |= CMD_STDIN_REDIR;\n\n\tSET_LINE_NUMBER (command->value.Simple->line);\n\texec_result =\n\t  execute_simple_command (command->value.Simple, pipe_in, pipe_out,\n\t\t\t\t  asynchronous, fds_to_close);\n\tline_number = save_line_number;\n\n\t \n\tdispose_used_env_vars ();\n\n#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)\n\t \n\t(void) alloca (0);\n#endif  \n\n\t \n\n\t \n\tif (already_making_children && pipe_out == NO_PIPE)\n\t  {\n\t    stop_pipeline (asynchronous, (COMMAND *)NULL);\n\n\t    if (asynchronous)\n\t      {\n\t\tDESCRIBE_PID (last_made_pid);\n\t\texec_result = EXECUTION_SUCCESS;\n\t\tinvert = 0;\t\t \n\t      }\n\t    else\n#if !defined (JOB_CONTROL)\n\t       \n\t    if (last_made_pid != NO_PID && last_made_pid != last_asynchronous_pid)\n#else\n\t    if (last_made_pid != NO_PID)\n#endif\n\t     \n\t      exec_result = wait_for (last_made_pid, 0);\n\t  }\n      }\n\n       \n        \n      if (was_error_trap && ignore_return == 0 && invert == 0 &&\n\t    pipe_in == NO_PIPE && pipe_out == NO_PIPE &&\n\t    (command->value.Simple->flags & CMD_COMMAND_BUILTIN) == 0 &&\n\t    exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 &&\n\t  ((posixly_correct && interactive == 0 && special_builtin_failed) ||\n\t   (exit_immediately_on_error && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)))\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\n\t   \n\t  if (exit_immediately_on_error && signal_is_trapped (0) &&\n\t\tunwind_protect_tag_on_stack (\"saved-redirects\"))\n\t    run_unwind_frame (\"saved-redirects\");\n\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n\n    case cm_for:\n      if (ignore_return)\n\tcommand->value.For->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_for_command (command->value.For);\n      break;\n\n#if defined (ARITH_FOR_COMMAND)\n    case cm_arith_for:\n      if (ignore_return)\n\tcommand->value.ArithFor->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_arith_for_command (command->value.ArithFor);\n      break;\n#endif\n\n#if defined (SELECT_COMMAND)\n    case cm_select:\n      if (ignore_return)\n\tcommand->value.Select->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_select_command (command->value.Select);\n      break;\n#endif\n\n    case cm_case:\n      if (ignore_return)\n\tcommand->value.Case->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_case_command (command->value.Case);\n      break;\n\n    case cm_while:\n      if (ignore_return)\n\tcommand->value.While->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_while_command (command->value.While);\n      break;\n\n    case cm_until:\n      if (ignore_return)\n\tcommand->value.While->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_until_command (command->value.While);\n      break;\n\n    case cm_if:\n      if (ignore_return)\n\tcommand->value.If->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_if_command (command->value.If);\n      break;\n\n    case cm_group:\n\n       \n\n      if (asynchronous)\n\t{\n\t  command->flags |= CMD_FORCE_SUBSHELL;\n\t  exec_result =\n\t    execute_command_internal (command, 1, pipe_in, pipe_out,\n\t\t\t\t      fds_to_close);\n\t}\n      else\n\t{\n\t  if (ignore_return && command->value.Group->command)\n\t    command->value.Group->command->flags |= CMD_IGNORE_RETURN;\n\t  exec_result =\n\t    execute_command_internal (command->value.Group->command,\n\t\t\t\t      asynchronous, pipe_in, pipe_out,\n\t\t\t\t      fds_to_close);\n\t}\n      break;\n\n    case cm_connection:\n      exec_result = execute_connection (command, asynchronous,\n\t\t\t\t\tpipe_in, pipe_out, fds_to_close);\n      if (asynchronous)\n\tinvert = 0;\t\t \n\n      break;\n\n#if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n#endif\n#if defined (COND_COMMAND)\n    case cm_cond:\n#endif\n    case cm_function_def:\n      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n#if defined (DPAREN_ARITHMETIC)\n      if (ignore_return && command->type == cm_arith)\n\tcommand->value.Arith->flags |= CMD_IGNORE_RETURN;\n#endif\n#if defined (COND_COMMAND)\n      if (ignore_return && command->type == cm_cond)\n\tcommand->value.Cond->flags |= CMD_IGNORE_RETURN;\n#endif\n\n      line_number_for_err_trap = save_line_number = line_number;\t \n#if defined (DPAREN_ARITHMETIC)\n      if (command->type == cm_arith)\n\texec_result = execute_arith_command (command->value.Arith);\n      else\n#endif\n#if defined (COND_COMMAND)\n      if (command->type == cm_cond)\n\texec_result = execute_cond_command (command->value.Cond);\n      else\n#endif\n      if (command->type == cm_function_def)\n\texec_result = execute_intern_function (command->value.Function_def->name,\n\t\t\t\t\t       command->value.Function_def);\n      line_number = save_line_number;\n\n      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  save_line_number = line_number;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n\n    default:\n      command_error (\"execute_command\", CMDERR_BADTYPE, command->type, 0);\n    }\n\n  if (my_undo_list)\n    cleanup_redirects (my_undo_list);\n\n  if (exec_undo_list)\n    dispose_redirects (exec_undo_list);\n\n  if (my_undo_list || exec_undo_list)\n    discard_unwind_frame (\"loop_redirections\");\n\n#if defined (PROCESS_SUBSTITUTION)\n  if (saved_fifo)\n    {\n      nfifo = num_fifos ();\n      if (nfifo > ofifo)\n\tclose_new_fifos ((void *)ofifo_list, osize);\n      free ((void *)ofifo_list);\n      discard_unwind_frame (\"internal_fifos\");\n    }\n#endif\n\n   \n  if (invert)\n    exec_result = (exec_result == EXECUTION_SUCCESS)\n\t\t    ? EXECUTION_FAILURE\n\t\t    : EXECUTION_SUCCESS;\n\n#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)\n   \n  switch (command->type)\n    {\n#  if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n#  endif\n#  if defined (COND_COMMAND)\n    case cm_cond:\n#  endif\n      set_pipestatus_from_exit (exec_result);\n      break;\n    default:\n      break;\n    }\n#endif\n\n  last_command_exit_value = exec_result;\n  run_pending_traps ();\n  currently_executing_command = (COMMAND *)NULL;\n\n  return (last_command_exit_value);\n}\n\n#if defined (COMMAND_TIMING)\n\n#if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)\nextern struct timeval *difftimeval PARAMS((struct timeval *, struct timeval *, struct timeval *));\nextern struct timeval *addtimeval PARAMS((struct timeval *, struct timeval *, struct timeval *));\nextern int timeval_to_cpu PARAMS((struct timeval *, struct timeval *, struct timeval *));\n#endif\n\n#define POSIX_TIMEFORMAT \"real %2R\\nuser %2U\\nsys %2S\"\n#define BASH_TIMEFORMAT  \"\\nreal\\t%3lR\\nuser\\t%3lU\\nsys\\t%3lS\"\n\nstatic const int precs[] = { 0, 100, 10, 1 };\n\n \nstatic int\nmkfmt (buf, prec, lng, sec, sec_fraction)\n     char *buf;\n     int prec, lng;\n     time_t sec;\n     int sec_fraction;\n{\n  time_t min;\n  char abuf[INT_STRLEN_BOUND(time_t) + 1];\n  int ind, aind;\n\n  ind = 0;\n  abuf[sizeof(abuf) - 1] = '\\0';\n\n   \n  if (lng)\n    {\n      min = sec / 60;\n      sec %= 60;\n      aind = sizeof(abuf) - 2;\n      do\n\tabuf[aind--] = (min % 10) + '0';\n      while (min /= 10);\n      aind++;\n      while (abuf[aind])\n\tbuf[ind++] = abuf[aind++];\n      buf[ind++] = 'm';\n    }\n\n   \n  aind = sizeof (abuf) - 2;\n  do\n    abuf[aind--] = (sec % 10) + '0';\n  while (sec /= 10);\n  aind++;\n  while (abuf[aind])\n    buf[ind++] = abuf[aind++];\n\n   \n  if (prec != 0)\n    {\n      buf[ind++] = locale_decpoint ();\n      for (aind = 1; aind <= prec; aind++)\n\t{\n\t  buf[ind++] = (sec_fraction / precs[aind]) + '0';\n\t  sec_fraction %= precs[aind];\n\t}\n    }\n\n  if (lng)\n    buf[ind++] = 's';\n  buf[ind] = '\\0';\n\n  return (ind);\n}\n\n \nstatic void\nprint_formatted_time (fp, format, rs, rsf, us, usf, ss, ssf, cpu)\n     FILE *fp;\n     char *format;\n     time_t rs;\n     int rsf;\n     time_t us;\n     int usf;\n     time_t ss;\n     int ssf, cpu;\n{\n  int prec, lng, len;\n  char *str, *s, ts[INT_STRLEN_BOUND (time_t) + sizeof (\"mSS.FFFF\")];\n  time_t sum;\n  int sum_frac;\n  int sindex, ssize;\n\n  len = strlen (format);\n  ssize = (len + 64) - (len % 64);\n  str = (char *)xmalloc (ssize);\n  sindex = 0;\n\n  for (s = format; *s; s++)\n    {\n      if (*s != '%' || s[1] == '\\0')\n\t{\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, 1, ssize, 64);\n\t  str[sindex++] = *s;\n\t}\n      else if (s[1] == '%')\n\t{\n\t  s++;\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, 1, ssize, 64);\n\t  str[sindex++] = *s;\n\t}\n      else if (s[1] == 'P')\n\t{\n\t  s++;\n#if 0\n\t   \n\t  if (cpu > 10000)\n\t    cpu = 10000;\n#endif\n\t  sum = cpu / 100;\n\t  sum_frac = (cpu % 100) * 10;\n\t  len = mkfmt (ts, 2, 0, sum, sum_frac);\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);\n\t  strcpy (str + sindex, ts);\n\t  sindex += len;\n\t}\n      else\n\t{\n\t  prec = 3;\t \n\t  lng = 0;\t \n\t  s++;\n\t  if (DIGIT (*s))\t\t \n\t    {\n\t      prec = *s++ - '0';\n\t      if (prec > 3) prec = 3;\n\t    }\n\t  if (*s == 'l')\t\t \n\t    {\n\t      lng = 1;\n\t      s++;\n\t    }\n\t  if (*s == 'R' || *s == 'E')\n\t    len = mkfmt (ts, prec, lng, rs, rsf);\n\t  else if (*s == 'U')\n\t    len = mkfmt (ts, prec, lng, us, usf);\n\t  else if (*s == 'S')\n\t    len = mkfmt (ts, prec, lng, ss, ssf);\n\t  else\n\t    {\n\t      internal_error (_(\"TIMEFORMAT: `%c': invalid format character\"), *s);\n\t      free (str);\n\t      return;\n\t    }\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);\n\t  strcpy (str + sindex, ts);\n\t  sindex += len;\n\t}\n    }\n\n  str[sindex] = '\\0';\n  fprintf (fp, \"%s\\n\", str);\n  fflush (fp);\n\n  free (str);\n}\n\nstatic int\ntime_command (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous, pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int rv, posix_time, old_flags, nullcmd, code;\n  time_t rs, us, ss;\n  int rsf, usf, ssf;\n  int cpu;\n  char *time_format;\n  volatile procenv_t save_top_level;\n  volatile int old_subshell;\n\n#if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)\n  struct timeval real, user, sys;\n  struct timeval before, after;\n#  if defined (HAVE_STRUCT_TIMEZONE)\n  struct timezone dtz;\t\t\t\t \n#  endif\n  struct rusage selfb, selfa, kidsb, kidsa;\t \n#else\n#  if defined (HAVE_TIMES)\n  clock_t tbefore, tafter, real, user, sys;\n  struct tms before, after;\n#  endif\n#endif\n\n#if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)\n#  if defined (HAVE_STRUCT_TIMEZONE)\n  gettimeofday (&before, &dtz);\n#  else\n  gettimeofday (&before, (void *)NULL);\n#  endif  \n  getrusage (RUSAGE_SELF, &selfb);\n  getrusage (RUSAGE_CHILDREN, &kidsb);\n#else\n#  if defined (HAVE_TIMES)\n  tbefore = times (&before);\n#  endif\n#endif\n\n  old_subshell = subshell_environment;\n  posix_time = command && (command->flags & CMD_TIME_POSIX);\n\n  nullcmd = (command == 0) || (command->type == cm_simple && command->value.Simple->words == 0 && command->value.Simple->redirects == 0);\n  if (posixly_correct && nullcmd)\n    {\n#if defined (HAVE_GETRUSAGE)\n      selfb.ru_utime.tv_sec = kidsb.ru_utime.tv_sec = selfb.ru_stime.tv_sec = kidsb.ru_stime.tv_sec = 0;\n      selfb.ru_utime.tv_usec = kidsb.ru_utime.tv_usec = selfb.ru_stime.tv_usec = kidsb.ru_stime.tv_usec = 0;\n      before = shellstart;\n#else\n      before.tms_utime = before.tms_stime = before.tms_cutime = before.tms_cstime = 0;\n      tbefore = shell_start_time;\n#endif\n    }\n\n  old_flags = command->flags;\n  COPY_PROCENV (top_level, save_top_level);\n  command->flags &= ~(CMD_TIME_PIPELINE|CMD_TIME_POSIX);\n  code = setjmp_nosigs (top_level);\n  if (code == NOT_JUMPED)\n    rv = execute_command_internal (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n  COPY_PROCENV (save_top_level, top_level);\n\n  command->flags = old_flags;\n\n   \n  if (code != NOT_JUMPED && subshell_environment && subshell_environment != old_subshell)\n    sh_longjmp (top_level, code);\n\n  rs = us = ss = 0;\n  rsf = usf = ssf = cpu = 0;\n\n#if defined (HAVE_GETRUSAGE) && defined (HAVE_GETTIMEOFDAY)\n#  if defined (HAVE_STRUCT_TIMEZONE)\n  gettimeofday (&after, &dtz);\n#  else\n  gettimeofday (&after, (void *)NULL);\n#  endif  \n  getrusage (RUSAGE_SELF, &selfa);\n  getrusage (RUSAGE_CHILDREN, &kidsa);\n\n  difftimeval (&real, &before, &after);\n  timeval_to_secs (&real, &rs, &rsf);\n\n  addtimeval (&user, difftimeval(&after, &selfb.ru_utime, &selfa.ru_utime),\n\t\t     difftimeval(&before, &kidsb.ru_utime, &kidsa.ru_utime));\n  timeval_to_secs (&user, &us, &usf);\n\n  addtimeval (&sys, difftimeval(&after, &selfb.ru_stime, &selfa.ru_stime),\n\t\t    difftimeval(&before, &kidsb.ru_stime, &kidsa.ru_stime));\n  timeval_to_secs (&sys, &ss, &ssf);\n\n  cpu = timeval_to_cpu (&real, &user, &sys);\n#else\n#  if defined (HAVE_TIMES)\n  tafter = times (&after);\n\n  real = tafter - tbefore;\n  clock_t_to_secs (real, &rs, &rsf);\n\n  user = (after.tms_utime - before.tms_utime) + (after.tms_cutime - before.tms_cutime);\n  clock_t_to_secs (user, &us, &usf);\n\n  sys = (after.tms_stime - before.tms_stime) + (after.tms_cstime - before.tms_cstime);\n  clock_t_to_secs (sys, &ss, &ssf);\n\n  cpu = (real == 0) ? 0 : ((user + sys) * 10000) / real;\n\n#  else\n  rs = us = ss = 0;\n  rsf = usf = ssf = cpu = 0;\n#  endif\n#endif\n\n  if (posix_time)\n    time_format = POSIX_TIMEFORMAT;\n  else if ((time_format = get_string_value (\"TIMEFORMAT\")) == 0)\n    {\n      if (posixly_correct && nullcmd)\n\ttime_format = \"user\\t%2lU\\nsys\\t%2lS\";\n      else\n\ttime_format = BASH_TIMEFORMAT;\n    }\n\n  if (time_format && *time_format)\n    print_formatted_time (stderr, time_format, rs, rsf, us, usf, ss, ssf, cpu);\n\n  if (code)\n    sh_longjmp (top_level, code);\n\n  return rv;\n}\n#endif  \n\n \nstatic int\nexecute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous;\n     int pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  volatile int user_subshell, user_coproc, invert;\n  int return_code, function_value, should_redir_stdin, ois, result;\n  volatile COMMAND *tcom;\n\n  USE_VAR(user_subshell);\n  USE_VAR(user_coproc);\n  USE_VAR(invert);\n  USE_VAR(tcom);\n  USE_VAR(asynchronous);\n\n  subshell_level++;\n  should_redir_stdin = (asynchronous && (command->flags & CMD_STDIN_REDIR) &&\n\t\t\t  pipe_in == NO_PIPE &&\n\t\t\t  stdin_redirects (command->redirects) == 0);\n\n  invert = (command->flags & CMD_INVERT_RETURN) != 0;\n  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);\n  user_coproc = command->type == cm_coproc;\n\n  command->flags &= ~(CMD_FORCE_SUBSHELL | CMD_WANT_SUBSHELL | CMD_INVERT_RETURN);\n\n   \n\n   \n  if (asynchronous)\n    {\n#if defined (JOB_CONTROL)\n       \n      original_pgrp = -1;\n#endif  \n      ois = interactive_shell;\n      interactive_shell = 0;\n       \n      if (ois != interactive_shell)\n\texpand_aliases = expaliases_flag = 0;\n    }\n\n   \n  login_shell = interactive = 0;\n\n   \n  if (shell_compatibility_level > 44)\n    loop_level = 0;\n\n  if (user_subshell)\n    {\n      subshell_environment = SUBSHELL_PAREN;\t \n      if (asynchronous)\n\tsubshell_environment |= SUBSHELL_ASYNC;\n    }\n  else\n    {\n      subshell_environment = 0;\t\t\t \n      if (asynchronous)\n\tsubshell_environment |= SUBSHELL_ASYNC;\n      if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)\n\tsubshell_environment |= SUBSHELL_PIPE;\n      if (user_coproc)\n\tsubshell_environment |= SUBSHELL_COPROC;\n    }\n\n  QUIT;\n  CHECK_TERMSIG;\n\n  reset_terminating_signals ();\t\t \n   \n   \n  clear_pending_traps ();\n  reset_signal_handlers ();\n  subshell_environment |= SUBSHELL_RESETTRAP;\n   \n  subshell_environment &= ~SUBSHELL_IGNTRAP;\n\n   \n   \n  if (running_trap > 0)\n    {\n      run_trap_cleanup (running_trap - 1);\n      running_trap = 0;\t\t \n    }\n\n   \n  if (asynchronous)\n    {\n      setup_async_signals ();\n      asynchronous = 0;\n    }\n  else\n    set_sigint_handler ();\n\n#if defined (JOB_CONTROL)\n  set_sigchld_handler ();\n#endif  \n\n   \n  without_job_control ();\n\n  if (fds_to_close)\n    close_fd_bitmap (fds_to_close);\n\n  do_piping (pipe_in, pipe_out);\n\n#if defined (COPROCESS_SUPPORT)\n  coproc_closeall ();\n#endif\n\n#if defined (PROCESS_SUBSTITUTION)\n  clear_fifo_list ();\t\t \n#endif\n\n   \n  if (user_subshell)\n    {\n      stdin_redir = stdin_redirects (command->redirects) || pipe_in != NO_PIPE;\n#if 0\n      restore_default_signal (EXIT_TRAP);\t \n#endif\n    }\n  else if (shell_control_structure (command->type) && pipe_in != NO_PIPE)\n    stdin_redir = 1;\n\n   \n  if (should_redir_stdin && stdin_redir == 0)\n    async_redirect_stdin ();\n\n#if defined (BUFFERED_INPUT)\n   \n  default_buffered_input = -1;\n#endif\n\n   \n  if (user_subshell && command->type == cm_subshell &&\n      (command->flags & (CMD_TIME_PIPELINE|CMD_INVERT_RETURN)) == 0)\n    optimize_subshell_command (command->value.Subshell->command);\n\n   \n  if (command->redirects)\n    {\n      if (do_redirections (command->redirects, RX_ACTIVE) != 0)\n\texit (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n\n      dispose_redirects (command->redirects);\n      command->redirects = (REDIRECT *)NULL;\n    }\n\n  if (command->type == cm_subshell)\n    tcom = command->value.Subshell->command;\n  else if (user_coproc)\n    tcom = command->value.Coproc->command;\n  else\n    tcom = command;\n\n  if (command->flags & CMD_TIME_PIPELINE)\n    tcom->flags |= CMD_TIME_PIPELINE;\n  if (command->flags & CMD_TIME_POSIX)\n    tcom->flags |= CMD_TIME_POSIX;\n  \n   \n  if ((command->flags & CMD_IGNORE_RETURN) && tcom != command)\n    tcom->flags |= CMD_IGNORE_RETURN;\n\n   \n  if ((user_subshell || user_coproc) && (tcom->type == cm_simple || tcom->type == cm_subshell) &&\n      ((tcom->flags & CMD_TIME_PIPELINE) == 0) &&\n      ((tcom->flags & CMD_INVERT_RETURN) == 0))\n    {\n      tcom->flags |= CMD_NO_FORK;\n      if (tcom->type == cm_simple)\n\ttcom->value.Simple->flags |= CMD_NO_FORK;\n    }\n\n  invert = (tcom->flags & CMD_INVERT_RETURN) != 0;\n  tcom->flags &= ~CMD_INVERT_RETURN;\n\n  result = setjmp_nosigs (top_level);\n\n   \n  function_value = 0;\n  if (return_catch_flag)\n    function_value = setjmp_nosigs (return_catch);\n\n   \n  if (result == EXITPROG || result == EXITBLTIN)\n    invert = 0, return_code = last_command_exit_value;\n  else if (result)\n    return_code = (last_command_exit_value == EXECUTION_SUCCESS) ? EXECUTION_FAILURE : last_command_exit_value;\n  else if (function_value)\n    return_code = return_catch_value;\n  else\n    return_code = execute_command_internal ((COMMAND *)tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);\n\n   \n  if (invert)\n    return_code = (return_code == EXECUTION_SUCCESS) ? EXECUTION_FAILURE\n\t\t\t\t\t\t     : EXECUTION_SUCCESS;\n\n\n   \n  if (user_subshell && signal_is_trapped (0))\n    {\n      last_command_exit_value = return_code;\n      return_code = run_exit_trap ();\n    }\n\n#if 0\n  subshell_level--;\t\t \n#endif\n  return (return_code);\n   \n}\n\n#if defined (COPROCESS_SUPPORT)\n#define COPROC_MAX\t16\n\ntypedef struct cpelement\n  {\n    struct cpelement *next;\n    struct coproc *coproc;\n  }\ncpelement_t;\n    \ntypedef struct cplist\n  {\n    struct cpelement *head;\n    struct cpelement *tail;\n    int ncoproc;\n    int lock;\n  }\ncplist_t;\n\nstatic struct cpelement *cpe_alloc PARAMS((struct coproc *));\nstatic void cpe_dispose PARAMS((struct cpelement *));\nstatic struct cpelement *cpl_add PARAMS((struct coproc *));\nstatic struct cpelement *cpl_delete PARAMS((pid_t));\nstatic void cpl_reap PARAMS((void));\nstatic void cpl_flush PARAMS((void));\nstatic void cpl_closeall PARAMS((void));\nstatic struct cpelement *cpl_search PARAMS((pid_t));\nstatic struct cpelement *cpl_searchbyname PARAMS((const char *));\nstatic void cpl_prune PARAMS((void));\n\nstatic void coproc_free PARAMS((struct coproc *));\n\n \nCoproc sh_coproc = { 0, NO_PID, -1, -1, 0, 0, 0, 0, 0 };\n\ncplist_t coproc_list = {0, 0, 0};\n\n \n\nstatic struct cpelement *\ncpe_alloc (cp)\n     Coproc *cp;\n{\n  struct cpelement *cpe;\n\n  cpe = (struct cpelement *)xmalloc (sizeof (struct cpelement));\n  cpe->coproc = cp;\n  cpe->next = (struct cpelement *)0;\n  return cpe;\n}\n\nstatic void\ncpe_dispose (cpe)\n      struct cpelement *cpe;\n{\n  free (cpe);\n}\n\nstatic struct cpelement *\ncpl_add (cp)\n     Coproc *cp;\n{\n  struct cpelement *cpe;\n\n  cpe = cpe_alloc (cp);\n\n  if (coproc_list.head == 0)\n    {\n      coproc_list.head = coproc_list.tail = cpe;\n      coproc_list.ncoproc = 0;\t\t\t \n    }\n  else\n    {\n      coproc_list.tail->next = cpe;\n      coproc_list.tail = cpe;\n    }\n  coproc_list.ncoproc++;\n\n  return cpe;\n}\n\nstatic struct cpelement *\ncpl_delete (pid)\n     pid_t pid;\n{\n  struct cpelement *prev, *p;\n\n  for (prev = p = coproc_list.head; p; prev = p, p = p->next)\n    if (p->coproc->c_pid == pid)\n      {\n        prev->next = p->next;\t \n        break;\n      }\n\n  if (p == 0)\n    return 0;\t\t \n\n  INTERNAL_DEBUG ((\"cpl_delete: deleting %d\", pid));\n\n   \n  if (p == coproc_list.head)\n    coproc_list.head = coproc_list.head->next;\n  else if (p == coproc_list.tail)\n    coproc_list.tail = prev;\n\n  coproc_list.ncoproc--;\n  if (coproc_list.ncoproc == 0)\n    coproc_list.head = coproc_list.tail = 0;\n  else if (coproc_list.ncoproc == 1)\n    coproc_list.tail = coproc_list.head;\t\t \n\n  return (p);\n}\n\nstatic void\ncpl_reap ()\n{\n  struct cpelement *p, *next, *nh, *nt;\n\n   \n  nh = nt = next = (struct cpelement *)0;\n  for (p = coproc_list.head; p; p = next)\n    {\n      next = p->next;\n      if (p->coproc->c_flags & COPROC_DEAD)\n\t{\n\t  coproc_list.ncoproc--;\t \n\t  INTERNAL_DEBUG ((\"cpl_reap: deleting %d\", p->coproc->c_pid));\n\t  coproc_dispose (p->coproc);\n\t  cpe_dispose (p);\n\t}\n      else if (nh == 0)\n\tnh = nt = p;\n      else\n\t{\n\t  nt->next = p;\n\t  nt = nt->next;\n\t}\n    }\n\n  if (coproc_list.ncoproc == 0)\n    coproc_list.head = coproc_list.tail = 0;\n  else\n    {\n      if (nt)\n        nt->next = 0;\n      coproc_list.head = nh;\n      coproc_list.tail = nt;\n      if (coproc_list.ncoproc == 1)\n\tcoproc_list.tail = coproc_list.head;\t\t   \n    }\n}\n\n \nstatic void\ncpl_flush ()\n{\n  struct cpelement *cpe, *p;\n\n  for (cpe = coproc_list.head; cpe; )\n    {\n      p = cpe;\n      cpe = cpe->next;\n\n      coproc_dispose (p->coproc);\n      cpe_dispose (p);\n    }\n\n  coproc_list.head = coproc_list.tail = 0;\n  coproc_list.ncoproc = 0;\n}\n\nstatic void\ncpl_closeall ()\n{\n  struct cpelement *cpe;\n\n  for (cpe = coproc_list.head; cpe; cpe = cpe->next)\n    coproc_close (cpe->coproc);\n}\n\nstatic void\ncpl_fdchk (fd)\n     int fd;\n{\n  struct cpelement *cpe;\n\n  for (cpe = coproc_list.head; cpe; cpe = cpe->next)\n    coproc_checkfd (cpe->coproc, fd);\n}\n\n \nstatic struct cpelement *\ncpl_search (pid)\n     pid_t pid;\n{\n  struct cpelement *cpe;\n\n  for (cpe = coproc_list.head ; cpe; cpe = cpe->next)\n    if (cpe->coproc->c_pid == pid)\n      return cpe;\n  return (struct cpelement *)NULL;\n}\n\n \nstatic struct cpelement *\ncpl_searchbyname (name)\n     const char *name;\n{\n  struct cpelement *cp;\n\n  for (cp = coproc_list.head ; cp; cp = cp->next)\n    if (STREQ (cp->coproc->c_name, name))\n      return cp;\n  return (struct cpelement *)NULL;\n}\n\nstatic pid_t\ncpl_firstactive ()\n{\n  struct cpelement *cpe;\n\n  for (cpe = coproc_list.head ; cpe; cpe = cpe->next)\n    if ((cpe->coproc->c_flags & COPROC_DEAD) == 0)\n      return cpe->coproc->c_pid;\n  return (pid_t)NO_PID;\n}\n\n#if 0\nstatic void\ncpl_prune ()\n{\n  struct cpelement *cp;\n\n  while (coproc_list.head && coproc_list.ncoproc > COPROC_MAX)\n    {\n      cp = coproc_list.head;\n      coproc_list.head = coproc_list.head->next;\n      coproc_dispose (cp->coproc);\n      cpe_dispose (cp);\n      coproc_list.ncoproc--;\n    }\n}\n#endif\n\n \n\nstruct coproc *\ngetcoprocbypid (pid)\n     pid_t pid;\n{\n#if MULTIPLE_COPROCS\n  struct cpelement *p;\n\n  p = cpl_search (pid);\n  return (p ? p->coproc : 0);\n#else\n  return (pid == sh_coproc.c_pid ? &sh_coproc : 0);\n#endif\n}\n\nstruct coproc *\ngetcoprocbyname (name)\n     const char *name;\n{\n#if MULTIPLE_COPROCS\n  struct cpelement *p;\n\n  p = cpl_searchbyname (name);\n  return (p ? p->coproc : 0);\n#else\n  return ((sh_coproc.c_name && STREQ (sh_coproc.c_name, name)) ? &sh_coproc : 0);\n#endif\n}\n\nvoid\ncoproc_init (cp)\n     struct coproc *cp;\n{\n  cp->c_name = 0;\n  cp->c_pid = NO_PID;\n  cp->c_rfd = cp->c_wfd = -1;\n  cp->c_rsave = cp->c_wsave = -1;\n  cp->c_flags = cp->c_status = cp->c_lock = 0;\n}\n\nstruct coproc *\ncoproc_alloc (name, pid)\n     char *name;\n     pid_t pid;\n{\n  struct coproc *cp;\n\n#if MULTIPLE_COPROCS\n  cp = (struct coproc *)xmalloc (sizeof (struct coproc));\n#else\n  cp = &sh_coproc;\n#endif\n  coproc_init (cp);\n  cp->c_lock = 2;\n\n  cp->c_pid = pid;\n  cp->c_name = savestring (name);\n#if MULTIPLE_COPROCS\n  cpl_add (cp);\n#endif\n  cp->c_lock = 0;\n  return (cp);\n}\n\nstatic void\ncoproc_free (cp)\n     struct coproc *cp;\n{\n  free (cp);\n}\n\nvoid\ncoproc_dispose (cp)\n     struct coproc *cp;\n{\n  sigset_t set, oset;\n\n  if (cp == 0)\n    return;\n\n  BLOCK_SIGNAL (SIGCHLD, set, oset);\n  cp->c_lock = 3;\n  coproc_unsetvars (cp);\n  FREE (cp->c_name);\n  coproc_close (cp);\n#if MULTIPLE_COPROCS\n  coproc_free (cp);\n#else\n  coproc_init (cp);\n  cp->c_lock = 0;\n#endif\n  UNBLOCK_SIGNAL (oset);\n}\n\n \nvoid\ncoproc_flush ()\n{\n#if MULTIPLE_COPROCS\n  cpl_flush ();\n#else\n  coproc_dispose (&sh_coproc);\n#endif\n}\n\nvoid\ncoproc_close (cp)\n     struct coproc *cp;\n{\n  if (cp->c_rfd >= 0)\n    {\n      close (cp->c_rfd);\n      cp->c_rfd = -1;\n    }\n  if (cp->c_wfd >= 0)\n    {\n      close (cp->c_wfd);\n      cp->c_wfd = -1;\n    }\n  cp->c_rsave = cp->c_wsave = -1;\n}\n\nvoid\ncoproc_closeall ()\n{\n#if MULTIPLE_COPROCS\n  cpl_closeall ();\n#else\n  coproc_close (&sh_coproc);\t \n#endif\n}\n\nvoid\ncoproc_reap ()\n{\n#if MULTIPLE_COPROCS\n  cpl_reap ();\n#else\n  struct coproc *cp;\n\n  cp = &sh_coproc;\t\t \n  if (cp && (cp->c_flags & COPROC_DEAD))\n    coproc_dispose (cp);\n#endif\n}\n\nvoid\ncoproc_rclose (cp, fd)\n     struct coproc *cp;\n     int fd;\n{\n  if (cp->c_rfd >= 0 && cp->c_rfd == fd)\n    {\n      close (cp->c_rfd);\n      cp->c_rfd = -1;\n    }\n}\n\nvoid\ncoproc_wclose (cp, fd)\n     struct coproc *cp;\n     int fd;\n{\n  if (cp->c_wfd >= 0 && cp->c_wfd == fd)\n    {\n      close (cp->c_wfd);\n      cp->c_wfd = -1;\n    }\n}\n\nvoid\ncoproc_checkfd (cp, fd)\n     struct coproc *cp;\n     int fd;\n{\n  int update;\n\n  update = 0;\n  if (cp->c_rfd >= 0 && cp->c_rfd == fd)\n    update = cp->c_rfd = -1;\n  if (cp->c_wfd >= 0 && cp->c_wfd == fd)\n    update = cp->c_wfd = -1;\n  if (update)\n    coproc_setvars (cp);\n}\n\nvoid\ncoproc_fdchk (fd)\n     int fd;\n{\n#if MULTIPLE_COPROCS\n  cpl_fdchk (fd);\n#else\n  coproc_checkfd (&sh_coproc, fd);\n#endif\n}\n\nvoid\ncoproc_fdclose (cp, fd)\n     struct coproc *cp;\n     int fd;\n{\n  coproc_rclose (cp, fd);\n  coproc_wclose (cp, fd);\n  coproc_setvars (cp);\n}\n\nvoid\ncoproc_fdsave (cp)\n     struct coproc *cp;\n{\n  cp->c_rsave = cp->c_rfd;\n  cp->c_wsave = cp->c_wfd;\n}\n\nvoid\ncoproc_fdrestore (cp)\n     struct coproc *cp;\n{\n  cp->c_rfd = cp->c_rsave;\n  cp->c_wfd = cp->c_wsave;\n}\n\nstatic void\ncoproc_setstatus (cp, status)\n     struct coproc *cp;\n     int status;\n{\n  cp->c_lock = 4;\n  cp->c_status = status;\n  cp->c_flags |= COPROC_DEAD;\n  cp->c_flags &= ~COPROC_RUNNING;\n   \n  cp->c_lock = 0;\n}\n\nvoid\ncoproc_pidchk (pid, status)\n     pid_t pid;\n     int status;\n{\n  struct coproc *cp;\n\n#if MULTIPLE_COPROCS\n  struct cpelement *cpe;\n\n   \n  cpe = cpl_search (pid);\n  cp = cpe ? cpe->coproc : 0;\n#else\n  cp = getcoprocbypid (pid);\n#endif\n  if (cp)\n    coproc_setstatus (cp, status);\n}\n\npid_t\ncoproc_active ()\n{\n#if MULTIPLE_COPROCS\n  return (cpl_firstactive ());\n#else\n  return ((sh_coproc.c_flags & COPROC_DEAD) ? NO_PID : sh_coproc.c_pid);\n#endif\n}\nvoid\ncoproc_setvars (cp)\n     struct coproc *cp;\n{\n  SHELL_VAR *v;\n  char *namevar, *t;\n  size_t l;\n  WORD_DESC w;\n#if defined (ARRAY_VARS)\n  arrayind_t ind;\n#endif\n\n  if (cp->c_name == 0)\n    return;\n\n   \n  w.word = cp->c_name;\n  w.flags = 0;\n  if (check_identifier (&w, 1) == 0)\n    return;\n\n  l = strlen (cp->c_name);\n  namevar = xmalloc (l + 16);\n\n#if defined (ARRAY_VARS)\n  v = find_variable (cp->c_name);\n\n   \n  if (v == 0)\n    {\n      v = find_variable_nameref_for_create (cp->c_name, 1);\n      if (v == INVALID_NAMEREF_VALUE)\n\t{\n\t  free (namevar);\n\t  return;\n\t}\n      if (v && nameref_p (v))\n\t{\n\t  free (cp->c_name);\n\t  cp->c_name = savestring (nameref_cell (v));\n\t  v = make_new_array_variable (cp->c_name);\t  \n\t}\n    }\n\n  if (v && (readonly_p (v) || noassign_p (v)))\n    {\n      if (readonly_p (v))\n\terr_readonly (cp->c_name);\n      free (namevar);\n      return;\n    }\n  if (v == 0)\n    v = make_new_array_variable (cp->c_name);\n  if (array_p (v) == 0)\n    v = convert_var_to_array (v);\n\n  t = itos (cp->c_rfd);\n  ind = 0;\n  v = bind_array_variable (cp->c_name, ind, t, 0);\n  free (t);\n\n  t = itos (cp->c_wfd);\n  ind = 1;\n  v = bind_array_variable (cp->c_name, ind, t, 0);\n  free (t);\n#else\n  sprintf (namevar, \"%s_READ\", cp->c_name);\n  t = itos (cp->c_rfd);\n  bind_variable (namevar, t, 0);\n  free (t);\n  sprintf (namevar, \"%s_WRITE\", cp->c_name);\n  t = itos (cp->c_wfd);\n  bind_variable (namevar, t, 0);\n  free (t);\n#endif\n\n  sprintf (namevar, \"%s_PID\", cp->c_name);\n  t = itos (cp->c_pid);\n  v = bind_variable (namevar, t, 0);\n  free (t);\n\n  free (namevar);\n}\n\nvoid\ncoproc_unsetvars (cp)\n     struct coproc *cp;\n{\n  int l;\n  char *namevar;\n\n  if (cp->c_name == 0)\n    return;\n\n  l = strlen (cp->c_name);\n  namevar = xmalloc (l + 16);\n\n  sprintf (namevar, \"%s_PID\", cp->c_name);\n  unbind_variable_noref (namevar);  \n\n#if defined (ARRAY_VARS)\n  check_unbind_variable (cp->c_name);\n#else\n  sprintf (namevar, \"%s_READ\", cp->c_name);\n  unbind_variable (namevar);\n  sprintf (namevar, \"%s_WRITE\", cp->c_name);\n  unbind_variable (namevar);\n#endif  \n\n  free (namevar);\n}\n\nstatic int\nexecute_coproc (command, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int rpipe[2], wpipe[2], estat, invert;\n  pid_t coproc_pid;\n  Coproc *cp;\n  char *tcmd, *p, *name;\n  sigset_t set, oset;\n\n   \n#if !MULTIPLE_COPROCS\n  if (sh_coproc.c_pid != NO_PID && (sh_coproc.c_rfd >= 0 || sh_coproc.c_wfd >= 0))\n    internal_warning (_(\"execute_coproc: coproc [%d:%s] still exists\"), sh_coproc.c_pid, sh_coproc.c_name);\n  coproc_init (&sh_coproc);\n#endif\n\n  invert = (command->flags & CMD_INVERT_RETURN) != 0;\n\n   \n  name = expand_string_unsplit_to_string (command->value.Coproc->name, 0);\n   \n  if (legal_identifier (name) == 0)\n    {\n      internal_error (_(\"`%s': not a valid identifier\"), name);\n      free (name);\n      return (invert ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n    }\n  else\n    {\n      free (command->value.Coproc->name);\n      command->value.Coproc->name = name;\n    }\n\n  command_string_index = 0;\n  tcmd = make_command_string (command);\n\n  sh_openpipe ((int *)&rpipe);\t \n  sh_openpipe ((int *)&wpipe);  \n\n  BLOCK_SIGNAL (SIGCHLD, set, oset);\n\n  coproc_pid = make_child (p = savestring (tcmd), FORK_ASYNC);\n\n  if (coproc_pid == 0)\n    {\n      close (rpipe[0]);\n      close (wpipe[1]);\n\n#if defined (JOB_CONTROL)\n      FREE (p);\n#endif\n\n      UNBLOCK_SIGNAL (oset);\n      estat = execute_in_subshell (command, 1, wpipe[0], rpipe[1], fds_to_close);\n\n      fflush (stdout);\n      fflush (stderr);\n\n      exit (estat);\n    }\n\n  close (rpipe[1]);\n  close (wpipe[0]);\n\n  cp = coproc_alloc (command->value.Coproc->name, coproc_pid);\n  cp->c_rfd = rpipe[0];\n  cp->c_wfd = wpipe[1];\n\n  cp->c_flags |= COPROC_RUNNING;\n\n  SET_CLOSE_ON_EXEC (cp->c_rfd);\n  SET_CLOSE_ON_EXEC (cp->c_wfd);\n\n  coproc_setvars (cp);\n\n  UNBLOCK_SIGNAL (oset);\n\n#if 0\n  itrace (\"execute_coproc (%s): [%d] %s\", command->value.Coproc->name, coproc_pid, the_printed_command);\n#endif\n\n  close_pipes (pipe_in, pipe_out);\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n  unlink_fifo_list ();\n#endif\n  stop_pipeline (1, (COMMAND *)NULL);\n  DESCRIBE_PID (coproc_pid);\n  run_pending_traps ();\n\n  return (invert ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n#endif\n\n \nstatic void\nrestore_stdin (s)\n     int s;\n{\n  if (s == -1)\n    close (0);\n  else\n    {\n      dup2 (s, 0);\n      close (s);\n    }\n}\n\n \nstatic void\nlastpipe_cleanup (s)\n     int s;\n{\n  set_jobs_list_frozen (s);\n}\n\nstatic int\nexecute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous, pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;\n  int lstdin, lastpipe_flag, lastpipe_jid, old_frozen, stdin_valid;\n  COMMAND *cmd;\n  struct fd_bitmap *fd_bitmap;\n  pid_t lastpid;\n\n#if defined (JOB_CONTROL)\n  sigset_t set, oset;\n  BLOCK_CHILD (set, oset);\n#endif  \n\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n  stdin_valid = sh_validfd (0);\n\n  prev = pipe_in;\n  cmd = command;\n\n  while (cmd && cmd->type == cm_connection &&\n\t cmd->value.Connection && cmd->value.Connection->connector == '|')\n    {\n       \n      if (pipe (fildes) < 0)\n\t{\n\t  sys_error (_(\"pipe error\"));\n#if defined (JOB_CONTROL)\n\t  terminate_current_pipeline ();\n\t  kill_current_pipeline ();\n\t  UNBLOCK_CHILD (oset);\n#endif  \n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t   \n\t  throw_to_top_level ();\n\t  return (EXECUTION_FAILURE);\t \n\t}\n\n       \n\n       \n      new_bitmap_size = (fildes[0] < fds_to_close->size)\n\t\t\t\t? fds_to_close->size\n\t\t\t\t: fildes[0] + 8;\n\n      fd_bitmap = new_fd_bitmap (new_bitmap_size);\n\n       \n      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);\n\n       \n      fd_bitmap->bitmap[fildes[0]] = 1;\n\n       \n      begin_unwind_frame (\"pipe-file-descriptors\");\n      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);\n      add_unwind_protect (close_fd_bitmap, fd_bitmap);\n      if (prev >= 0)\n\tadd_unwind_protect (close, prev);\n      dummyfd = fildes[1];\n      add_unwind_protect (close, dummyfd);\n\n#if defined (JOB_CONTROL)\n      add_unwind_protect (restore_signal_mask, &oset);\n#endif  \n\n      if (ignore_return && cmd->value.Connection->first)\n\tcmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;\n      execute_command_internal (cmd->value.Connection->first, asynchronous,\n\t\t\t\tprev, fildes[1], fd_bitmap);\n\n      if (prev >= 0)\n\tclose (prev);\n\n      prev = fildes[0];\n      close (fildes[1]);\n\n      dispose_fd_bitmap (fd_bitmap);\n      discard_unwind_frame (\"pipe-file-descriptors\");\n\n      cmd = cmd->value.Connection->second;\n    }\n\n  lastpid = last_made_pid;\n\n   \n  if (ignore_return && cmd)\n    cmd->flags |= CMD_IGNORE_RETURN;\n\n  lastpipe_flag = 0;\n\n  begin_unwind_frame (\"lastpipe-exec\");\n  lstdin = -2;\t\t \n   \n   \n  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev >= 0)\n    {\n       \n      lstdin = (prev > 0 && stdin_valid) ? move_to_high_fd (0, 1, -1) : -1;\n      if (lstdin > 0 || lstdin == -1)\n\t{\n\t  do_piping (prev, pipe_out);\n\t  prev = NO_PIPE;\n\t  add_unwind_protect (restore_stdin, lstdin);\n\t  lastpipe_flag = 1;\n\t  old_frozen = freeze_jobs_list ();\n\t  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);\t \n\t  add_unwind_protect (lastpipe_cleanup, old_frozen);\n#if defined (JOB_CONTROL)\n\t  UNBLOCK_CHILD (oset);\t\t \n#endif\n\t}\n      if (cmd)\n\tcmd->flags |= CMD_LASTPIPE;\n    }\t  \n  if (prev >= 0)\n    add_unwind_protect (close, prev);\n\n  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);\n\n  if (prev >= 0)\n    close (prev);\n\n  if (lstdin > 0 || lstdin == -1)\n    restore_stdin (lstdin);\n\n#if defined (JOB_CONTROL)\n  UNBLOCK_CHILD (oset);\n#endif\n\n  QUIT;\n\n  if (lastpipe_flag)\n    {\n#if defined (JOB_CONTROL)\n      if (INVALID_JOB (lastpipe_jid) == 0)\n        {\n          append_process (savestring (the_printed_command_except_trap), dollar_dollar_pid, exec_result, lastpipe_jid);\n          lstdin = wait_for (lastpid, 0);\n        }\n      else\n\t{\n\t  lstdin = wait_for_single_pid (lastpid, 0);\t\t \n\t  if (lstdin > 256)\t\t \n\t    lstdin = 127;\n\t}\n#else\n      lstdin = wait_for (lastpid, 0);\n#endif\n\n#if defined (JOB_CONTROL)\n       \n      if (INVALID_JOB (lastpipe_jid) == 0)\n\texec_result = job_exit_status (lastpipe_jid);\n      else if (pipefail_opt)\n\texec_result = exec_result | lstdin;\t \n       \n#endif\n\n      set_jobs_list_frozen (old_frozen);\n    }\n\n  discard_unwind_frame (\"lastpipe-exec\");\n\n  return (exec_result);\n}\n\nstatic int\nexecute_connection (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous, pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  COMMAND *tc, *second;\n  int ignore_return, exec_result, was_error_trap, invert;\n  volatile int save_line_number;\n\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n  switch (command->value.Connection->connector)\n    {\n     \n    case '&':\n      tc = command->value.Connection->first;\n      if (tc == 0)\n\treturn (EXECUTION_SUCCESS);\n\n      if (ignore_return)\n\ttc->flags |= CMD_IGNORE_RETURN;\n      tc->flags |= CMD_AMPERSAND;\n\n       \n#if defined (JOB_CONTROL)\n      if ((subshell_environment || !job_control) && !stdin_redir)\n#else\n      if (!stdin_redir)\n#endif  \n\ttc->flags |= CMD_STDIN_REDIR;\n\n      exec_result = execute_command_internal (tc, 1, pipe_in, pipe_out, fds_to_close);\n      QUIT;\n\n      if (tc->flags & CMD_STDIN_REDIR)\n\ttc->flags &= ~CMD_STDIN_REDIR;\n\n      second = command->value.Connection->second;\n      if (second)\n\t{\n\t  if (ignore_return)\n\t    second->flags |= CMD_IGNORE_RETURN;\n\n\t  exec_result = execute_command_internal (second, asynchronous, pipe_in, pipe_out, fds_to_close);\n\t}\n\n      break;\n\n     \n    case ';':\n    case '\\n':\t\t \n      if (ignore_return)\n\t{\n\t  if (command->value.Connection->first)\n\t    command->value.Connection->first->flags |= CMD_IGNORE_RETURN;\n\t  if (command->value.Connection->second)\n\t    command->value.Connection->second->flags |= CMD_IGNORE_RETURN;\n\t}\n      executing_list++;\n      QUIT;\n\n#if 1\n      execute_command (command->value.Connection->first);\n#else\n      execute_command_internal (command->value.Connection->first,\n\t\t\t\t  asynchronous, pipe_in, pipe_out,\n\t\t\t\t  fds_to_close);\n#endif\n\n      QUIT;\n      optimize_connection_fork (command);\t\t\t \n      exec_result = execute_command_internal (command->value.Connection->second,\n\t\t\t\t      asynchronous, pipe_in, pipe_out,\n\t\t\t\t      fds_to_close);\n      executing_list--;\n      break;\n\n    case '|':\n      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n      invert = (command->flags & CMD_INVERT_RETURN) != 0;\n      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n      SET_LINE_NUMBER (line_number);\t \n      exec_result = execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n\n      if (asynchronous)\n\t{\n\t  exec_result = EXECUTION_SUCCESS;\n\t  invert = 0;\n\t}\n\n      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  save_line_number = line_number;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n\n    case AND_AND:\n    case OR_OR:\n      if (asynchronous)\n\t{\n\t   \n\t  command->flags |= CMD_FORCE_SUBSHELL;\n\t  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);\n\t  break;\n\t}\n\n       \n\n      executing_list++;\n      if (command->value.Connection->first)\n\tcommand->value.Connection->first->flags |= CMD_IGNORE_RETURN;\n\n#if 1\n      exec_result = execute_command (command->value.Connection->first);\n#else\n      exec_result = execute_command_internal (command->value.Connection->first, 0, NO_PIPE, NO_PIPE, fds_to_close);\n#endif\n      QUIT;\n      if (((command->value.Connection->connector == AND_AND) &&\n\t   (exec_result == EXECUTION_SUCCESS)) ||\n\t  ((command->value.Connection->connector == OR_OR) &&\n\t   (exec_result != EXECUTION_SUCCESS)))\n\t{\n\t  optimize_connection_fork (command);\n\n\t  second = command->value.Connection->second;\n\t  if (ignore_return && second)\n\t    second->flags |= CMD_IGNORE_RETURN;\n\n\t  exec_result = execute_command (second);\n\t}\n      executing_list--;\n      break;\n\n    default:\n      command_error (\"execute_connection\", CMDERR_BADCONN, command->value.Connection->connector, 0);\n      jump_to_top_level (DISCARD);\n      exec_result = EXECUTION_FAILURE;\n    }\n\n  return exec_result;\n}\n\n \n#define REAP() \\\n  do \\\n    { \\\n      if (job_control == 0 || interactive_shell == 0) \\\n\treap_dead_jobs (); \\\n    } \\\n  while (0)\n\n \nstatic int\nexecute_for_command (for_command)\n     FOR_COM *for_command;\n{\n  register WORD_LIST *releaser, *list;\n  SHELL_VAR *v;\n  char *identifier;\n  int retval, save_line_number;\n#if 0\n  SHELL_VAR *old_value = (SHELL_VAR *)NULL;  \n#endif\n\n  save_line_number = line_number;\n  if (check_identifier (for_command->name, 1) == 0)\n    {\n      if (posixly_correct && interactive_shell == 0)\n\t{\n\t  last_command_exit_value = EX_BADUSAGE;\n\t  jump_to_top_level (ERREXIT);\n\t}\n      return (EXECUTION_FAILURE);\n    }\n\n  loop_level++;\n  identifier = for_command->name->word;\n\n  line_number = for_command->line;\t \n  list = releaser = expand_words_no_vars (for_command->map_list);\n\n  begin_unwind_frame (\"for\");\n  add_unwind_protect (dispose_words, releaser);\n\n#if 0\n  if (lexical_scoping)\n    {\n      old_value = copy_variable (find_variable (identifier));\n      if (old_value)\n\tadd_unwind_protect (dispose_variable, old_value);\n    }\n#endif\n\n  if (for_command->flags & CMD_IGNORE_RETURN)\n    for_command->action->flags |= CMD_IGNORE_RETURN;\n\n  for (retval = EXECUTION_SUCCESS; list; list = list->next)\n    {\n      QUIT;\n\n      line_number = for_command->line;\n\n       \n      command_string_index = 0;\n      print_for_command_head (for_command);\n\n      if (echo_command_at_execute)\n\txtrace_print_for_command_head (for_command);\n\n       \n      if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n\t{\n\t  FREE (the_printed_command_except_trap);\n\t  the_printed_command_except_trap = savestring (the_printed_command);\n\t}\n\n      retval = run_debug_trap ();\n#if defined (DEBUGGER)\n       \n      if (debugging_mode && retval != EXECUTION_SUCCESS)\n        continue;\n#endif\n\n      this_command_name = (char *)NULL;\n       \n      v = find_variable_last_nameref (identifier, 1);\n      if (v && nameref_p (v))\n\t{\n\t  if (valid_nameref_value (list->word->word, 1) == 0)\n\t    {\n\t      sh_invalidid (list->word->word);\n\t      v = 0;\n\t    }\n\t  else if (readonly_p (v))\n\t    err_readonly (name_cell (v));\n\t  else\n\t    v = bind_variable_value (v, list->word->word, ASS_NAMEREF);\n\t}\n      else\n\tv = bind_variable (identifier, list->word->word, 0);\n\n      if (v == 0 || readonly_p (v) || noassign_p (v))\n\t{\n\t  line_number = save_line_number;\n\t  if (v && readonly_p (v) && interactive_shell == 0 && posixly_correct)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      jump_to_top_level (FORCE_EOF);\n\t    }\n\t  else\n\t    {\n\t      dispose_words (releaser);\n\t      discard_unwind_frame (\"for\");\n\t      loop_level--;\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t}\n\n      if (ifsname (identifier))\n\tsetifs (v);\n      else\n\tstupidly_hack_special_variables (identifier);\n\n      retval = execute_command (for_command->action);\n      REAP ();\n      QUIT;\n\n      if (breaking)\n\t{\n\t  breaking--;\n\t  break;\n\t}\n\n      if (continuing)\n\t{\n\t  continuing--;\n\t  if (continuing)\n\t    break;\n\t}\n    }\n\n  loop_level--;\n  line_number = save_line_number;\n\n#if 0\n  if (lexical_scoping)\n    {\n      if (!old_value)\n        unbind_variable (identifier);\n      else\n\t{\n\t  SHELL_VAR *new_value;\n\n\t  new_value = bind_variable (identifier, value_cell (old_value), 0);\n\t  new_value->attributes = old_value->attributes;\n\t  dispose_variable (old_value);\n\t}\n    }\n#endif\n\n  dispose_words (releaser);\n  discard_unwind_frame (\"for\");\n  return (retval);\n}\n\n#if defined (ARITH_FOR_COMMAND)\n \nstatic intmax_t\neval_arith_for_expr (l, okp)\n     WORD_LIST *l;\n     int *okp;\n{\n  WORD_LIST *new;\n  intmax_t expresult;\n  int r, eflag;\n  char *expr, *temp;\n\n  expr = l->next ? string_list (l) : l->word->word;\n  temp = expand_arith_string (expr, Q_DOUBLE_QUOTES|Q_ARITH);\n  if (l->next)\n    free (expr);\n  new = make_word_list (make_word (temp ? temp : \"\"), (WORD_LIST *)NULL);\n  free (temp);\n\n  if (new)\n    {\n      if (echo_command_at_execute)\n\txtrace_print_arith_cmd (new);\n\n      command_string_index = 0;\n      print_arith_command (new);\n      if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n\t{\n\t  FREE (the_printed_command_except_trap);\n\t  the_printed_command_except_trap = savestring (the_printed_command);\n\t}\n\n      r = run_debug_trap ();\n       \n      eflag = (shell_compatibility_level > 51) ? 0 : EXP_EXPANDED;\n      this_command_name = \"((\";\t\t \n      \n#if defined (DEBUGGER)\n      if (debugging_mode == 0 || r == EXECUTION_SUCCESS)\n\texpresult = evalexp (new->word->word, eflag, okp);\n      else\n\t{\n\t  expresult = 0;\n\t  if (okp)\n\t    *okp = 1;\n\t}\n#else\n      expresult = evalexp (new->word->word, eflag, okp);\n#endif\n      dispose_words (new);\n    }\n  else\n    {\n      expresult = 0;\n      if (okp)\n\t*okp = 1;\n    }\n  return (expresult);\n}\n\nstatic int\nexecute_arith_for_command (arith_for_command)\n     ARITH_FOR_COM *arith_for_command;\n{\n  intmax_t expresult;\n  int expok, body_status, arith_lineno, save_lineno;\n\n  body_status = EXECUTION_SUCCESS;\n  loop_level++;\n  save_lineno = line_number;\n\n  if (arith_for_command->flags & CMD_IGNORE_RETURN)\n    arith_for_command->action->flags |= CMD_IGNORE_RETURN;\n\n  this_command_name = \"((\";\t \n\n   \n  line_number = arith_lineno = arith_for_command->line;\n  if (variable_context && interactive_shell && sourcelevel == 0)\n    {\n       \n      line_number -= function_line_number - 1;\n      if (line_number <= 0)\n\tline_number = 1;\n    }\n\n   \n  expresult = eval_arith_for_expr (arith_for_command->init, &expok);\n  if (expok == 0)\n    {\n      line_number = save_lineno;\n      return (EXECUTION_FAILURE);\n    }\n\n  while (1)\n    {\n       \n      line_number = arith_lineno;\n      expresult = eval_arith_for_expr (arith_for_command->test, &expok);\n      line_number = save_lineno;\n\n      if (expok == 0)\n\t{\n\t  body_status = EXECUTION_FAILURE;\n\t  break;\n\t}\n      REAP ();\n      if (expresult == 0)\n\tbreak;\n\n       \n      QUIT;\n      body_status = execute_command (arith_for_command->action);\n      QUIT;\n\n       \n      if (breaking)\n\t{\n\t  breaking--;\n\t  break;\n\t}\n\n      if (continuing)\n\t{\n\t  continuing--;\n\t  if (continuing)\n\t    break;\n\t}\n\n       \n      line_number = arith_lineno;\n      expresult = eval_arith_for_expr (arith_for_command->step, &expok);\n      line_number = save_lineno;\n\n      if (expok == 0)\n\t{\n\t  body_status = EXECUTION_FAILURE;\n\t  break;\n\t}\n    }\n\n  loop_level--;\n  line_number = save_lineno;\n\n  return (body_status);\n}\n#endif\n\n#if defined (SELECT_COMMAND)\nstatic int LINES, COLS, tabsize;\n\n#define RP_SPACE \") \"\n#define RP_SPACE_LEN 2\n\n \n#define NUMBER_LEN(s) \\\n((s < 10) ? 1 \\\n\t  : ((s < 100) ? 2 \\\n\t\t      : ((s < 1000) ? 3 \\\n\t\t\t\t   : ((s < 10000) ? 4 \\\n\t\t\t\t\t\t : ((s < 100000) ? 5 \\\n\t\t\t\t\t\t\t\t: 6)))))\n\nstatic int\ndisplen (s)\n     const char *s;\n{\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t *wcstr;\n  size_t slen;\n  int wclen;\n\n  wcstr = 0;\n  slen = mbstowcs (wcstr, s, 0);\n  if (slen == -1)\n    slen = 0;\n  wcstr = (wchar_t *)xmalloc (sizeof (wchar_t) * (slen + 1));\n  mbstowcs (wcstr, s, slen + 1);\n  wclen = wcswidth (wcstr, slen);\n  free (wcstr);\n  return (wclen < 0 ? STRLEN(s) : wclen);\n#else\n  return (STRLEN (s));\n#endif\n}\n\nstatic int\nprint_index_and_element (len, ind, list)\n      int len, ind;\n      WORD_LIST *list;\n{\n  register WORD_LIST *l;\n  register int i;\n\n  if (list == 0)\n    return (0);\n  for (i = ind, l = list; l && --i; l = l->next)\n    ;\n  if (l == 0)\t\t \n    return (0);\n  fprintf (stderr, \"%*d%s%s\", len, ind, RP_SPACE, l->word->word);\n  return (displen (l->word->word));\n}\n\nstatic void\nindent (from, to)\n     int from, to;\n{\n  while (from < to)\n    {\n      if ((to / tabsize) > (from / tabsize))\n\t{\n\t  putc ('\\t', stderr);\n\t  from += tabsize - from % tabsize;\n\t}\n      else\n\t{\n\t  putc (' ', stderr);\n\t  from++;\n\t}\n    }\n}\n\nstatic void\nprint_select_list (list, list_len, max_elem_len, indices_len)\n     WORD_LIST *list;\n     int list_len, max_elem_len, indices_len;\n{\n  int ind, row, elem_len, pos, cols, rows;\n  int first_column_indices_len, other_indices_len;\n\n  if (list == 0)\n    {\n      putc ('\\n', stderr);\n      return;\n    }\n\n  cols = max_elem_len ? COLS / max_elem_len : 1;\n  if (cols == 0)\n    cols = 1;\n  rows = list_len ? list_len / cols + (list_len % cols != 0) : 1;\n  cols = list_len ? list_len / rows + (list_len % rows != 0) : 1;\n\n  if (rows == 1)\n    {\n      rows = cols;\n      cols = 1;\n    }\n\n  first_column_indices_len = NUMBER_LEN (rows);\n  other_indices_len = indices_len;\n\n  for (row = 0; row < rows; row++)\n    {\n      ind = row;\n      pos = 0;\n      while (1)\n\t{\n\t  indices_len = (pos == 0) ? first_column_indices_len : other_indices_len;\n\t  elem_len = print_index_and_element (indices_len, ind + 1, list);\n\t  elem_len += indices_len + RP_SPACE_LEN;\n\t  ind += rows;\n\t  if (ind >= list_len)\n\t    break;\n\t  indent (pos + elem_len, pos + max_elem_len);\n\t  pos += max_elem_len;\n\t}\n      putc ('\\n', stderr);\n    }\n}\n\n \nstatic char *\nselect_query (list, list_len, prompt, print_menu)\n     WORD_LIST *list;\n     int list_len;\n     char *prompt;\n     int print_menu;\n{\n  int max_elem_len, indices_len, len, r, oe;\n  intmax_t reply;\n  WORD_LIST *l;\n  char *repl_string, *t;\n\n  COLS = default_columns ();\n\n#if 0\n  t = get_string_value (\"TABSIZE\");\n  tabsize = (t && *t) ? atoi (t) : 8;\n  if (tabsize <= 0)\n    tabsize = 8;\n#else\n  tabsize = 8;\n#endif\n\n  max_elem_len = 0;\n  for (l = list; l; l = l->next)\n    {\n      len = displen (l->word->word);\n      if (len > max_elem_len)\n\tmax_elem_len = len;\n    }\n  indices_len = NUMBER_LEN (list_len);\n  max_elem_len += indices_len + RP_SPACE_LEN + 2;\n\n  while (1)\n    {\n      if (print_menu)\n\tprint_select_list (list, list_len, max_elem_len, indices_len);\n      fprintf (stderr, \"%s\", prompt);\n      fflush (stderr);\n      QUIT;\n\n      oe = executing_builtin;\n      executing_builtin = 1;\n      r = read_builtin ((WORD_LIST *)NULL);\n      executing_builtin = oe;\n      if (r != EXECUTION_SUCCESS)\n\t{\n\t  putchar ('\\n');\n\t  return ((char *)NULL);\n\t}\n      repl_string = get_string_value (\"REPLY\");\n      if (repl_string == 0)\n\treturn ((char *)NULL);\n      if (*repl_string == 0)\n\t{\n\t  print_menu = 1;\n\t  continue;\n\t}\n      if (legal_number (repl_string, &reply) == 0)\n\treturn \"\";\n      if (reply < 1 || reply > list_len)\n\treturn \"\";\n\n      for (l = list; l && --reply; l = l->next)\n\t;\n      return (l->word->word);\t\t \n    }\n}\n\n \nstatic int\nexecute_select_command (select_command)\n     SELECT_COM *select_command;\n{\n  WORD_LIST *releaser, *list;\n  SHELL_VAR *v;\n  char *identifier, *ps3_prompt, *selection;\n  int retval, list_len, show_menu, save_line_number;\n\n  if (check_identifier (select_command->name, 1) == 0)\n    return (EXECUTION_FAILURE);\n\n  save_line_number = line_number;\n  line_number = select_command->line;\n\n  command_string_index = 0;\n  print_select_command_head (select_command);\n\n  if (echo_command_at_execute)\n    xtrace_print_select_command_head (select_command);\n\n#if 0\n  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, \"trap\") == 0)))\n#else\n  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n#endif\n    {\n      FREE (the_printed_command_except_trap);\n      the_printed_command_except_trap = savestring (the_printed_command);\n    }\n\n  retval = run_debug_trap ();\n#if defined (DEBUGGER)\n   \n  if (debugging_mode && retval != EXECUTION_SUCCESS)\n    return (EXECUTION_SUCCESS);\n#endif\n\n  this_command_name = (char *)0;\n\n  loop_level++;\n  identifier = select_command->name->word;\n\n   \n  list = releaser = expand_words_no_vars (select_command->map_list);\n  list_len = list_length (list);\n  if (list == 0 || list_len == 0)\n    {\n      if (list)\n\tdispose_words (list);\n      line_number = save_line_number;\n      return (EXECUTION_SUCCESS);\n    }\n\n  begin_unwind_frame (\"select\");\n  add_unwind_protect (dispose_words, releaser);\n\n  if (select_command->flags & CMD_IGNORE_RETURN)\n    select_command->action->flags |= CMD_IGNORE_RETURN;\n\n  retval = EXECUTION_SUCCESS;\n  show_menu = 1;\n\n  while (1)\n    {\n      line_number = select_command->line;\n      ps3_prompt = get_string_value (\"PS3\");\n      if (ps3_prompt == 0)\n\tps3_prompt = \"#? \";\n\n      QUIT;\n      selection = select_query (list, list_len, ps3_prompt, show_menu);\n      QUIT;\n      if (selection == 0)\n\t{\n\t   \n\t  retval = EXECUTION_FAILURE;\n\t  break;\n\t}\n\n      v = bind_variable (identifier, selection, 0);\n      if (v == 0 || readonly_p (v) || noassign_p (v))\n\t{\n\t  if (v && readonly_p (v) && interactive_shell == 0 && posixly_correct)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      jump_to_top_level (FORCE_EOF);\n\t    }\n\t  else\n\t    {\n\t      dispose_words (releaser);\n\t      discard_unwind_frame (\"select\");\n\t      loop_level--;\n\t      line_number = save_line_number;\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t}\n\n      stupidly_hack_special_variables (identifier);\n\n      retval = execute_command (select_command->action);\n\n      REAP ();\n      QUIT;\n\n      if (breaking)\n\t{\n\t  breaking--;\n\t  break;\n\t}\n\n      if (continuing)\n\t{\n\t  continuing--;\n\t  if (continuing)\n\t    break;\n\t}\n\n#if defined (KSH_COMPATIBLE_SELECT)\n      show_menu = 0;\n      selection = get_string_value (\"REPLY\");\n      if (selection && *selection == '\\0')\n        show_menu = 1;\n#endif\n    }\n\n  loop_level--;\n  line_number = save_line_number;\n\n  dispose_words (releaser);\n  discard_unwind_frame (\"select\");\n  return (retval);\n}\n#endif  \n\n \nstatic int\nexecute_case_command (case_command)\n     CASE_COM *case_command;\n{\n  register WORD_LIST *list;\n  WORD_LIST *wlist, *es;\n  PATTERN_LIST *clauses;\n  char *word, *pattern;\n  int retval, match, ignore_return, save_line_number, qflags;\n\n  save_line_number = line_number;\n  line_number = case_command->line;\n\n  command_string_index = 0;\n  print_case_command_head (case_command);\n\n  if (echo_command_at_execute)\n    xtrace_print_case_command_head (case_command);\n\n#if 0\n  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, \"trap\") == 0)))\n#else\n  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n#endif\n    {\n      FREE (the_printed_command_except_trap);\n      the_printed_command_except_trap = savestring (the_printed_command);\n    }\n\n  retval = run_debug_trap();\n#if defined (DEBUGGER)\n   \n  if (debugging_mode && retval != EXECUTION_SUCCESS)\n    {\n      line_number = save_line_number;\n      return (EXECUTION_SUCCESS);\n    }\n#endif\n\n   \n  wlist = expand_word_leave_quoted (case_command->word, 0);\n  if (wlist)\n    {\n      char *t;\n      t = string_list (wlist);\n      word = dequote_string (t);\n      free (t);\n    }\n  else\n    word = savestring (\"\");\n  dispose_words (wlist);\n\n  retval = EXECUTION_SUCCESS;\n  ignore_return = case_command->flags & CMD_IGNORE_RETURN;\n\n  begin_unwind_frame (\"case\");\n  add_unwind_protect (xfree, word);\n\n#define EXIT_CASE()  goto exit_case_command\n\n  for (clauses = case_command->clauses; clauses; clauses = clauses->next)\n    {\n      QUIT;\n      for (list = clauses->patterns; list; list = list->next)\n\t{\n\t  es = expand_word_leave_quoted (list->word, 0);\n\n\t  if (es && es->word && es->word->word && *(es->word->word))\n\t    {\n\t       \n\t      qflags = QGLOB_CVTNULL;\n\n\t       \n\t      qflags |= QGLOB_CTLESC;\n\t      pattern = quote_string_for_globbing (es->word->word, qflags);\n\t    }\n\t  else\n\t    {\n\t      pattern = (char *)xmalloc (1);\n\t      pattern[0] = '\\0';\n\t    }\n\n\t   \n\t  match = strmatch (pattern, word, FNMATCH_EXTFLAG|FNMATCH_IGNCASE) != FNM_NOMATCH;\n\t  free (pattern);\n\n\t  dispose_words (es);\n\t  QUIT;\n\n\t  if (match)\n\t    {\n\t      do\n\t\t{\n\t\t  if (clauses->action && ignore_return)\n\t\t    clauses->action->flags |= CMD_IGNORE_RETURN;\n\t\t  retval = execute_command (clauses->action);\n\t\t}\n\t      while ((clauses->flags & CASEPAT_FALLTHROUGH) && (clauses = clauses->next));\n\t      if (clauses == 0 || (clauses->flags & CASEPAT_TESTNEXT) == 0)\n\t\tEXIT_CASE ();\n\t      else\n\t\tbreak;\n\t    }\n\n\t  QUIT;\n\t}\n    }\n\nexit_case_command:\n  free (word);\n  discard_unwind_frame (\"case\");\n  line_number = save_line_number;\n  return (retval);\n}\n\n#define CMD_WHILE 0\n#define CMD_UNTIL 1\n\n \nstatic int\nexecute_while_command (while_command)\n     WHILE_COM *while_command;\n{\n  return (execute_while_or_until (while_command, CMD_WHILE));\n}\n\n \nstatic int\nexecute_until_command (while_command)\n     WHILE_COM *while_command;\n{\n  return (execute_while_or_until (while_command, CMD_UNTIL));\n}\n\n \nstatic int\nexecute_while_or_until (while_command, type)\n     WHILE_COM *while_command;\n     int type;\n{\n  int return_value, body_status;\n\n  body_status = EXECUTION_SUCCESS;\n  loop_level++;\n\n  while_command->test->flags |= CMD_IGNORE_RETURN;\n  if (while_command->flags & CMD_IGNORE_RETURN)\n    while_command->action->flags |= CMD_IGNORE_RETURN;\n\n  while (1)\n    {\n      return_value = execute_command (while_command->test);\n      REAP ();\n\n       \n      if (type == CMD_WHILE && return_value != EXECUTION_SUCCESS)\n\t{\n\t  if (breaking)\n\t    breaking--;\n\t  if (continuing)\n\t    continuing--;\n\t  break;\n\t}\n      if (type == CMD_UNTIL && return_value == EXECUTION_SUCCESS)\n\t{\n\t  if (breaking)\n\t    breaking--;\n\t  if (continuing)\n\t    continuing--;\n\t  break;\n\t}\n\n      QUIT;\n      body_status = execute_command (while_command->action);\n      QUIT;\n\n      if (breaking)\n\t{\n\t  breaking--;\n\t  break;\n\t}\n\n      if (continuing)\n\t{\n\t  continuing--;\n\t  if (continuing)\n\t    break;\n\t}\n    }\n  loop_level--;\n\n  return (body_status);\n}\n\n \nstatic int\nexecute_if_command (if_command)\n     IF_COM *if_command;\n{\n  int return_value, save_line_number;\n\n  save_line_number = line_number;\n  if_command->test->flags |= CMD_IGNORE_RETURN;\n  return_value = execute_command (if_command->test);\n  line_number = save_line_number;\n\n  if (return_value == EXECUTION_SUCCESS)\n    {\n      QUIT;\n\n      if (if_command->true_case && (if_command->flags & CMD_IGNORE_RETURN))\n\tif_command->true_case->flags |= CMD_IGNORE_RETURN;\n\n      return (execute_command (if_command->true_case));\n    }\n  else\n    {\n      QUIT;\n\n      if (if_command->false_case && (if_command->flags & CMD_IGNORE_RETURN))\n\tif_command->false_case->flags |= CMD_IGNORE_RETURN;\n\n      return (execute_command (if_command->false_case));\n    }\n}\n\n#if defined (DPAREN_ARITHMETIC)\nstatic int\nexecute_arith_command (arith_command)\n     ARITH_COM *arith_command;\n{\n  int expok, save_line_number, retval, eflag;\n  intmax_t expresult;\n  WORD_LIST *new;\n  char *exp, *t;\n\n  expresult = 0;\n\n  save_line_number = line_number;\n  this_command_name = \"((\";\t \n  SET_LINE_NUMBER (arith_command->line);\n   \n  if (variable_context && interactive_shell && sourcelevel == 0)\n    {\n       \n      line_number -= function_line_number - 1;\n      if (line_number <= 0)\n\tline_number = 1;\n    }      \n\n  command_string_index = 0;\n  print_arith_command (arith_command->exp);\n\n  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n    {\n      FREE (the_printed_command_except_trap);\n      the_printed_command_except_trap = savestring (the_printed_command);\n    }\n\n   \n  retval = run_debug_trap ();\n#if defined (DEBUGGER)\n   \n  if (debugging_mode && retval != EXECUTION_SUCCESS)\n    {\n      line_number = save_line_number;\n      return (EXECUTION_SUCCESS);\n    }\n#endif\n\n  this_command_name = \"((\";\t \n  t = (char *)NULL;\n  new = arith_command->exp;\n  exp = (new->next) ? (t = string_list (new)) : new->word->word;\n\n  exp = expand_arith_string (exp, Q_DOUBLE_QUOTES|Q_ARITH);\n  FREE (t);\n\n   \n  if (echo_command_at_execute)\n    {\n      new = make_word_list (make_word (exp ? exp : \"\"), (WORD_LIST *)NULL);\n      xtrace_print_arith_cmd (new);\n      dispose_words (new);\n    }\n\n  if (exp)\n    {\n      eflag = (shell_compatibility_level > 51) ? 0 : EXP_EXPANDED;\n      expresult = evalexp (exp, eflag, &expok);\n      line_number = save_line_number;\n      free (exp);\n    }\n  else\n    {\n      expresult = 0;\n      expok = 1;\n    }\n\n  if (expok == 0)\n    return (EXECUTION_FAILURE);\n\n  return (expresult == 0 ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n#endif  \n\n#if defined (COND_COMMAND)\n\nstatic char * const nullstr = \"\";\n\n \nstatic int\nexecute_cond_node (cond)\n     COND_COM *cond;\n{\n  int result, invert, patmatch, rmatch, arith, mode, mflags, ignore;\n  char *arg1, *arg2, *op;\n#if 0\n  char *t1, *t2;\n#endif\n\n  invert = (cond->flags & CMD_INVERT_RETURN);\n  ignore = (cond->flags & CMD_IGNORE_RETURN);\n  if (ignore)\n    {\n      if (cond->left)\n\tcond->left->flags |= CMD_IGNORE_RETURN;\n      if (cond->right)\n\tcond->right->flags |= CMD_IGNORE_RETURN;\n    }\n      \n  if (cond->type == COND_EXPR)\n    result = execute_cond_node (cond->left);\n  else if (cond->type == COND_OR)\n    {\n      result = execute_cond_node (cond->left);\n      if (result != EXECUTION_SUCCESS)\n\tresult = execute_cond_node (cond->right);\n    }\n  else if (cond->type == COND_AND)\n    {\n      result = execute_cond_node (cond->left);\n      if (result == EXECUTION_SUCCESS)\n\tresult = execute_cond_node (cond->right);\n    }\n  else if (cond->type == COND_UNARY)\n    {\n      int oa, varop, varflag;\n\n      if (ignore)\n\tcomsub_ignore_return++;\n      varop = STREQ (cond->op->word, \"-v\");\n#if defined (ARRAY_VARS)\n      varflag = (varop && valid_array_reference (cond->left->op->word, VA_NOEXPAND)) ? TEST_ARRAYEXP : 0;\n#else\n      varflag = 0;\n#endif\n      arg1 = cond_expand_word (cond->left->op, varop ? 3 : 0);\n      if (ignore)\n\tcomsub_ignore_return--;\n      if (arg1 == 0)\n\targ1 = nullstr;\n      if (echo_command_at_execute)\n\txtrace_print_cond_term (cond->type, invert, cond->op, arg1, (char *)NULL);\n#if defined (ARRAY_VARS)\n      if (varop)\n\toa = set_expand_once (0, 0);\t \n#endif\n      result = unary_test (cond->op->word, arg1, varflag) ? EXECUTION_SUCCESS : EXECUTION_FAILURE;\n#if defined (ARRAY_VARS)\n      if (varop)\n\tassoc_expand_once = oa;\n#endif\n      if (arg1 != nullstr)\n\tfree (arg1);\n    }\n  else if (cond->type == COND_BINARY)\n    {\n      rmatch = 0;\n      op = cond->op->word;\n      mode = 0;\n      patmatch = (((op[1] == '=') && (op[2] == '\\0') &&\n\t\t   (op[0] == '!' || op[0] == '=')) ||\n\t\t  (op[0] == '=' && op[1] == '\\0'));\n#if defined (COND_REGEXP)\n      rmatch = (op[0] == '=' && op[1] == '~' && op[2] == '\\0');\n#endif\n      arith = STREQ (op, \"-eq\") || STREQ (op, \"-ne\") || STREQ (op, \"-lt\") ||\n\t      STREQ (op, \"-le\") || STREQ (op, \"-gt\") || STREQ (op, \"-ge\");\n\n      if (arith)\n\tmode = 3;\n      else if (rmatch && shell_compatibility_level > 31)\n\tmode = 2;\n      else if (patmatch)\n\tmode = 1;\n\n      if (ignore)\n\tcomsub_ignore_return++;\n      arg1 = cond_expand_word (cond->left->op, arith ? mode : 0);\n      if (ignore)\n\tcomsub_ignore_return--;\n      if (arg1 == 0)\n\targ1 = nullstr;\n      if (ignore)\n\tcomsub_ignore_return++;\n      arg2 = cond_expand_word (cond->right->op, mode);\n      if (ignore)\n\tcomsub_ignore_return--;\n      if (arg2 == 0)\n\targ2 = nullstr;\n\n      if (echo_command_at_execute)\n\txtrace_print_cond_term (cond->type, invert, cond->op, arg1, arg2);\n\n#if defined (COND_REGEXP)\n      if (rmatch)\n\t{\n\t  mflags = SHMAT_PWARN;\n#if defined (ARRAY_VARS)\n\t  mflags |= SHMAT_SUBEXP;\n#endif\n\n#if 0\n\t  t1 = strescape(arg1);\n\t  t2 = strescape(arg2);\n\t  itrace(\"execute_cond_node: sh_regmatch on `%s' and `%s'\", t1, t2);\n\t  free(t1);\n\t  free(t2);\n#endif\n\n\t  result = sh_regmatch (arg1, arg2, mflags);\n\t}\n      else\n#endif  \n\t{\n\t  extended_glob = 1;\n\t  result = binary_test (cond->op->word, arg1, arg2, TEST_PATMATCH|TEST_ARITHEXP|TEST_LOCALE)\n\t\t\t\t  ? EXECUTION_SUCCESS\n\t\t\t\t  : EXECUTION_FAILURE;\n\t  extended_glob = extglob_flag;\n\t}\n      if (arg1 != nullstr)\n\tfree (arg1);\n      if (arg2 != nullstr)\n\tfree (arg2);\n    }\n  else\n    {\n      command_error (\"execute_cond_node\", CMDERR_BADTYPE, cond->type, 0);\n      jump_to_top_level (DISCARD);\n      result = EXECUTION_FAILURE;\n    }\n\n  if (invert)\n    result = (result == EXECUTION_SUCCESS) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;\n\n  return result;\n}\n\nstatic int\nexecute_cond_command (cond_command)\n     COND_COM *cond_command;\n{\n  int retval, save_line_number;\n\n  save_line_number = line_number;\n\n  SET_LINE_NUMBER (cond_command->line);\n   \n  if (variable_context && interactive_shell && sourcelevel == 0)\n    {\n       \n      line_number -= function_line_number - 1;\n      if (line_number <= 0)\n\tline_number = 1;\n    }\n  command_string_index = 0;\n  print_cond_command (cond_command);\n\n  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n    {\n      FREE (the_printed_command_except_trap);\n      the_printed_command_except_trap = savestring (the_printed_command);\n    }\n\n   \n  retval = run_debug_trap ();\n#if defined (DEBUGGER)\n   \n  if (debugging_mode && retval != EXECUTION_SUCCESS)\n    {\n      line_number = save_line_number;\n      return (EXECUTION_SUCCESS);\n    }\n#endif\n\n  this_command_name = \"[[\";\t \n\n#if 0\n  debug_print_cond_command (cond_command);\n#endif\n\n  last_command_exit_value = retval = execute_cond_node (cond_command);\n  line_number = save_line_number;\n  return (retval);\n}\n#endif  \n\nstatic void\nbind_lastarg (arg)\n     char *arg;\n{\n  SHELL_VAR *var;\n\n  if (arg == 0)\n    arg = \"\";\n  var = bind_variable (\"_\", arg, 0);\n  if (var)\n    VUNSETATTR (var, att_exported);\n}\n\n \nstatic int\nexecute_null_command (redirects, pipe_in, pipe_out, async)\n     REDIRECT *redirects;\n     int pipe_in, pipe_out, async;\n{\n  int r;\n  int forcefork, fork_flags;\n  REDIRECT *rd;\n\n  for (forcefork = 0, rd = redirects; rd; rd = rd->next)\n    {\n      forcefork += rd->rflags & REDIR_VARASSIGN;\n       \n      forcefork += (rd->redirector.dest == 0 || fd_is_bash_input (rd->redirector.dest)) && (INPUT_REDIRECT (rd->instruction) || TRANSLATE_REDIRECT (rd->instruction) || rd->instruction == r_close_this);\n    }\n\n  if (forcefork || pipe_in != NO_PIPE || pipe_out != NO_PIPE || async)\n    {\n       \n      fork_flags = async ? FORK_ASYNC : 0;\n      if (make_child ((char *)NULL, fork_flags) == 0)\n\t{\n\t   \n\t  restore_original_signals ();\t\t \n\n\t  do_piping (pipe_in, pipe_out);\n\n#if defined (COPROCESS_SUPPORT)\n\t  coproc_closeall ();\n#endif\n\n\t  interactive = 0;\t\t\t \n\n\t  subshell_environment = 0;\n\t  if (async)\n\t    subshell_environment |= SUBSHELL_ASYNC;\n\t  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)\n\t    subshell_environment |= SUBSHELL_PIPE;\n\n\t  if (do_redirections (redirects, RX_ACTIVE) == 0)\n\t    exit (EXECUTION_SUCCESS);\n\t  else\n\t    exit (EXECUTION_FAILURE);\n\t}\n      else\n\t{\n\t  close_pipes (pipe_in, pipe_out);\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n\t  if (pipe_out == NO_PIPE)\n\t    unlink_fifo_list ();\n#endif\n\t  return (EXECUTION_SUCCESS);\n\t}\n    }\n  else\n    {\n       \n\n      r = do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE);\n      cleanup_redirects (redirection_undo_list);\n      redirection_undo_list = (REDIRECT *)NULL;\n\n      if (r != 0)\n\treturn (EXECUTION_FAILURE);\n      else if (last_command_subst_pid != NO_PID)\n\treturn (last_command_exit_value);\n      else\n\treturn (EXECUTION_SUCCESS);\n    }\n}\n\n \nstatic void\nfix_assignment_words (words)\n     WORD_LIST *words;\n{\n  WORD_LIST *w, *wcmd;\n  struct builtin *b;\n  int assoc, global, array, integer;\n\n  if (words == 0)\n    return;\n\n  b = 0;\n  assoc = global = array = integer = 0;\n\n   \n  wcmd = words;\n  for (wcmd = words; wcmd; wcmd = wcmd->next)\n    if ((wcmd->word->flags & W_ASSIGNMENT) == 0)\n      break;\n   \n  while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, \"command\"))\n    wcmd = wcmd->next;\n\n  for (w = wcmd; w; w = w->next)\n    if (w->word->flags & W_ASSIGNMENT)\n      {\n      \t \n\tif (b == 0)\n\t  {\n\t    b = builtin_address_internal (wcmd->word->word, 0);\n\t    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)\n\t      return;\n\t    else if (b && (b->flags & ASSIGNMENT_BUILTIN))\n\t      wcmd->word->flags |= W_ASSNBLTIN;\n\t  }\n\tw->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);\n#if defined (ARRAY_VARS)\n\tif (assoc)\n\t  w->word->flags |= W_ASSIGNASSOC;\n\tif (array)\n\t  w->word->flags |= W_ASSIGNARRAY;\n#endif\n\tif (global)\n\t  w->word->flags |= W_ASSNGLOBAL;\n\n\t \n\tif (b && ((b->flags & (ASSIGNMENT_BUILTIN|LOCALVAR_BUILTIN)) == ASSIGNMENT_BUILTIN))\n\t  w->word->flags |= W_ASSNGLOBAL|W_CHKLOCAL;\n\telse if (b && (b->flags & ASSIGNMENT_BUILTIN) && (b->flags & LOCALVAR_BUILTIN) && variable_context)\n\t  w->word->flags |= W_FORCELOCAL;\n      }\n#if defined (ARRAY_VARS)\n     \n    else if (w->word->word[0] == '-' && (strpbrk (w->word->word+1, \"Aag\") != 0))\n#else\n    else if (w->word->word[0] == '-' && strchr (w->word->word+1, 'g'))\n#endif\n      {\n\tif (b == 0)\n\t  {\n\t    b = builtin_address_internal (wcmd->word->word, 0);\n\t    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)\n\t      return;\n\t    else if (b && (b->flags & ASSIGNMENT_BUILTIN))\n\t      wcmd->word->flags |= W_ASSNBLTIN;\n\t  }\n\tif ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'A'))\n\t  assoc = 1;\n\telse if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'a'))\n\t  array = 1;\n\tif ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'g'))\n\t  global = 1;\n      }\n}\n\n#if defined (ARRAY_VARS)\n \nstatic void\nfix_arrayref_words (words)\n     WORD_LIST *words;\n{\n  WORD_LIST *w, *wcmd;\n  struct builtin *b;\n\n  if (words == 0)\n    return;\n\n  b = 0;\n\n   \n  wcmd = words;\n  for (wcmd = words; wcmd; wcmd = wcmd->next)\n    if ((wcmd->word->flags & W_ASSIGNMENT) == 0)\n      break;\n\n   \n  while (wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, \"command\"))\n    wcmd = wcmd->next;\n\n  if (wcmd == 0)\n    return;\n\n   \n  b = builtin_address_internal (wcmd->word->word, 0);\n  if (b == 0 || (b->flags & ARRAYREF_BUILTIN) == 0)\n    return;\n\n  for (w = wcmd->next; w; w = w->next)\n    {\n      if (w->word && w->word->word && valid_array_reference (w->word->word, 0))\n\tw->word->flags |= W_ARRAYREF;\n    }\n}\n#endif\n\n#ifndef ISOPTION\n#  define ISOPTION(s, c)  (s[0] == '-' && s[1] == c && s[2] == 0)\n#endif\n\n#define RETURN_NOT_COMMAND() \\\n  do { if (typep) *typep = 0; return words; } while (0)\n\n \nstatic WORD_LIST *\ncheck_command_builtin (words, typep)\n     WORD_LIST *words;\n     int *typep;\n{\n  int type;\n  WORD_LIST *w;\n\n  w = words->next;\n  type = 1;\n\n  if (w && ISOPTION (w->word->word, 'p'))\t \n    {\n#if defined (RESTRICTED_SHELL)\n      if (restricted)\n        RETURN_NOT_COMMAND();\n#endif\n      w = w->next;\n      type = 2;\n    }\n\n  if (w && ISOPTION (w->word->word, '-'))\t \n    w = w->next;\n  else if (w && w->word->word[0] == '-')\t \n    RETURN_NOT_COMMAND();\n\n  if (w == 0 || w->word->word == 0)\t\t \n    RETURN_NOT_COMMAND();\n\n  if (typep)\n    *typep = type;\n  return w;\n}\n\n \nstatic int\nis_dirname (pathname)\n     char *pathname;\n{\n  char *temp;\n  int ret;\n\n  temp = search_for_command (pathname, 0);\n  ret = temp ? file_isdir (temp) : file_isdir (pathname);\n  free (temp);\n  return ret;\n}\n\n \nstatic int\nexecute_simple_command (simple_command, pipe_in, pipe_out, async, fds_to_close)\n     SIMPLE_COM *simple_command;\n     int pipe_in, pipe_out, async;\n     struct fd_bitmap *fds_to_close;\n{\n  WORD_LIST *words, *lastword;\n  char *command_line, *lastarg, *temp;\n  int first_word_quoted, result, builtin_is_special, already_forked, dofork;\n  int fork_flags, cmdflags;\n  pid_t old_last_async_pid;\n  sh_builtin_func_t *builtin;\n  SHELL_VAR *func;\n  volatile int old_builtin, old_command_builtin;\n\n  result = EXECUTION_SUCCESS;\n  special_builtin_failed = builtin_is_special = 0;\n  command_line = (char *)0;\n\n  QUIT;\n\n   \n  if (variable_context && interactive_shell && sourcelevel == 0)\n    {\n       \n      line_number -= function_line_number - 1;\n      if (line_number <= 0)\n\tline_number = 1;\n    }\n\n   \n  command_string_index = 0;\n  print_simple_command (simple_command);\n\n#if 0\n  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, \"trap\") == 0)))\n#else\n  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n#endif\n    {\n      FREE (the_printed_command_except_trap);\n      the_printed_command_except_trap = the_printed_command ? savestring (the_printed_command) : (char *)0;\n    }\n\n   \n  result = run_debug_trap ();\n#if defined (DEBUGGER)\n   \n  if (debugging_mode && result != EXECUTION_SUCCESS)\n    return (EXECUTION_SUCCESS);\n#endif\n\n  cmdflags = simple_command->flags;\n\n  first_word_quoted =\n    simple_command->words ? (simple_command->words->word->flags & W_QUOTED) : 0;\n\n  last_command_subst_pid = NO_PID;\n  old_last_async_pid = last_asynchronous_pid;\n\n  already_forked = 0;\n\n   \n  dofork = pipe_in != NO_PIPE || pipe_out != NO_PIPE || async;\n\n   \n  if (dofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE &&\n\tsimple_command->words && simple_command->words->word &&\n\tsimple_command->words->word->word &&\n\t(simple_command->words->word->word[0] == '%'))\n    dofork = 0;\n\n  if (dofork)\n    {\n      char *p;\n\n       \n      maybe_make_export_env ();\n\n       \n      fork_flags = async ? FORK_ASYNC : 0;\n      if (make_child (p = savestring (the_printed_command_except_trap), fork_flags) == 0)\n\t{\n\t  already_forked = 1;\n\t  cmdflags |= CMD_NO_FORK;\n\n\t   \n\t  subshell_environment = SUBSHELL_FORK|SUBSHELL_IGNTRAP;\t \n\t  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)\n\t    subshell_environment |= SUBSHELL_PIPE;\n\t  if (async)\n\t    subshell_environment |= SUBSHELL_ASYNC;\n\n\t   \n\t  if (fds_to_close)\n\t    close_fd_bitmap (fds_to_close);\n\n\t   \n\t  stdin_redir |= pipe_in != NO_PIPE;\n\n\t  do_piping (pipe_in, pipe_out);\n\t  pipe_in = pipe_out = NO_PIPE;\n#if defined (COPROCESS_SUPPORT)\n\t  coproc_closeall ();\n#endif\n\n\t  last_asynchronous_pid = old_last_async_pid;\n\n\t  if (async)\n\t    subshell_level++;\t\t \n\n#if defined (JOB_CONTROL)\n\t  FREE (p);\t\t\t \n#endif\n\t}\n      else\n\t{\n\t   \n\t  if (pipe_out != NO_PIPE)\n\t    result = last_command_exit_value;\n\t  close_pipes (pipe_in, pipe_out);\n\t  command_line = (char *)NULL;       \n\t  return (result);\n\t}\n    }\n\n  QUIT;\t\t \n\n   \n  if ((cmdflags & CMD_INHIBIT_EXPANSION) == 0)\n    {\n      current_fds_to_close = fds_to_close;\n      fix_assignment_words (simple_command->words);\n#if defined (ARRAY_VARS)\n      fix_arrayref_words (simple_command->words);\n#endif\n       \n      if (cmdflags & CMD_IGNORE_RETURN)\t \n\tcomsub_ignore_return++;\n      words = expand_words (simple_command->words);\n      if (cmdflags & CMD_IGNORE_RETURN)\n\tcomsub_ignore_return--;\n      current_fds_to_close = (struct fd_bitmap *)NULL;\n    }\n  else\n    words = copy_word_list (simple_command->words);\n\n   \n  if (words == 0)\n    {\n      this_command_name = 0;\n      result = execute_null_command (simple_command->redirects,\n\t\t\t\t     pipe_in, pipe_out,\n\t\t\t\t     already_forked ? 0 : async);\n      if (already_forked)\n\tsh_exit (result);\n      else\n\t{\n\t  bind_lastarg ((char *)NULL);\n\t  set_pipestatus_from_exit (result);\n\t  return (result);\n\t}\n    }\n\n  lastarg = (char *)NULL;\n\n  begin_unwind_frame (\"simple-command\");\n\n  if (echo_command_at_execute && (cmdflags & CMD_COMMAND_BUILTIN) == 0)\n    xtrace_print_word_list (words, 1);\n\n  builtin = (sh_builtin_func_t *)NULL;\n  func = (SHELL_VAR *)NULL;\n\n   \n  if ((cmdflags & CMD_NO_FUNCTIONS) == 0)\n    {\n       \n      if (posixly_correct)\n\t{\n\t  builtin = find_special_builtin (words->word->word);\n\t  if (builtin)\n\t    builtin_is_special = 1;\n\t}\n      if (builtin == 0)\n\tfunc = find_function (words->word->word);\n    }\n\n   \n  if (posixly_correct && tempenv_assign_error)\n    {\n#if defined (DEBUG)\n       \nitrace(\"execute_simple_command: posix mode tempenv assignment error\");\n#endif\n      last_command_exit_value = EXECUTION_FAILURE;\n#if defined (STRICT_POSIX)\n      jump_to_top_level ((interactive_shell == 0) ? FORCE_EOF : DISCARD);\n#else\n      if (interactive_shell == 0 && builtin_is_special)\n\tjump_to_top_level (FORCE_EOF);\n      else if (interactive_shell == 0)\n\tjump_to_top_level (DISCARD);\t \n      else\n\tjump_to_top_level (DISCARD);\n#endif\n    }\n  tempenv_assign_error = 0;\t \n\n   \n  old_command_builtin = -1;\n  if (builtin == 0 && func == 0)\n    {\n      WORD_LIST *disposer, *l;\n      int cmdtype;\n\n      builtin = find_shell_builtin (words->word->word);\n      while (builtin == command_builtin)\n\t{\n\t  disposer = words;\n\t  cmdtype = 0;\n\t  words = check_command_builtin (words, &cmdtype);\n\t  if (cmdtype > 0)\t \n\t    {\n\t      for (l = disposer; l->next != words; l = l->next)\n\t\t;\n\t      l->next = 0;\n\t      dispose_words (disposer);\n\t      cmdflags |= CMD_COMMAND_BUILTIN | CMD_NO_FUNCTIONS;\n\t      if (cmdtype == 2)\n\t\tcmdflags |= CMD_STDPATH;\n\t      builtin = find_shell_builtin (words->word->word);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (cmdflags & CMD_COMMAND_BUILTIN)\n\t{\n\t  old_command_builtin = executing_command_builtin;\n\t  unwind_protect_int (executing_command_builtin);\n\t  executing_command_builtin |= 1;\n\t}        \n      builtin = 0;\n    }\n\n  add_unwind_protect (dispose_words, words);\n  QUIT;\n\n   \n  for (lastword = words; lastword->next; lastword = lastword->next)\n    ;\n  lastarg = lastword->word->word;\n\n#if defined (JOB_CONTROL)\n   \n  if (words->word->word[0] == '%' && already_forked == 0)\n    {\n      this_command_name = async ? \"bg\" : \"fg\";\n      last_shell_builtin = this_shell_builtin;\n      this_shell_builtin = builtin_address (this_command_name);\n      result = (*this_shell_builtin) (words);\n      goto return_result;\n    }\n\n   \n  if (job_control && already_forked == 0 && async == 0 &&\n\t!first_word_quoted &&\n\t!words->next &&\n\twords->word->word[0] &&\n\t!simple_command->redirects &&\n\tpipe_in == NO_PIPE &&\n\tpipe_out == NO_PIPE &&\n\t(temp = get_string_value (\"auto_resume\")))\n    {\n      int job, jflags, started_status;\n\n      jflags = JM_STOPPED|JM_FIRSTMATCH;\n      if (STREQ (temp, \"exact\"))\n\tjflags |= JM_EXACT;\n      else if (STREQ (temp, \"substring\"))\n\tjflags |= JM_SUBSTRING;\n      else\n\tjflags |= JM_PREFIX;\n      job = get_job_by_name (words->word->word, jflags);\n      if (job != NO_JOB)\n\t{\n\t  run_unwind_frame (\"simple-command\");\n\t  this_command_name = \"fg\";\n\t  last_shell_builtin = this_shell_builtin;\n\t  this_shell_builtin = builtin_address (\"fg\");\n\n\t  started_status = start_job (job, 1);\n\t  return ((started_status < 0) ? EXECUTION_FAILURE : started_status);\n\t}\n    }\n#endif  \n\nrun_builtin:\n   \n  this_command_name = words->word->word;\n\n  QUIT;\n\n   \n  if (func == 0 && builtin == 0)\n    builtin = find_shell_builtin (this_command_name);\n\n  last_shell_builtin = this_shell_builtin;\n  this_shell_builtin = builtin;\n\n  if (builtin || func)\n    {\n      if (builtin)\n        {\n\t  old_builtin = executing_builtin;\n\t  unwind_protect_int (executing_builtin);\t \n\t  if (old_command_builtin == -1)\t \n\t    {\n\t      old_command_builtin = executing_command_builtin;\n\t      unwind_protect_int (executing_command_builtin);\t \n\t    }\n        }\n      if (already_forked)\n\t{\n\t   \t \n\t   \n\t  reset_signal_handlers ();\n\t  subshell_environment |= SUBSHELL_RESETTRAP;\n\t  subshell_environment &= ~SUBSHELL_IGNTRAP;\n\n\t  if (async)\n\t    {\n\t      if ((cmdflags & CMD_STDIN_REDIR) &&\n\t\t    pipe_in == NO_PIPE &&\n\t\t    (stdin_redirects (simple_command->redirects) == 0))\n\t\tasync_redirect_stdin ();\n\t      setup_async_signals ();\n\t    }\n\n\t  if (async == 0)\n\t    subshell_level++;\n\t  execute_subshell_builtin_or_function\n\t    (words, simple_command->redirects, builtin, func,\n\t     pipe_in, pipe_out, async, fds_to_close,\n\t     cmdflags);\n\t  subshell_level--;\n\t}\n      else\n\t{\n\t  result = execute_builtin_or_function\n\t    (words, builtin, func, simple_command->redirects, fds_to_close,\n\t     cmdflags);\n\t  if (builtin)\n\t    {\n\t      if (result > EX_SHERRBASE)\n\t\t{\n\t\t  switch (result)\n\t\t    {\n\t\t    case EX_REDIRFAIL:\n\t\t    case EX_BADASSIGN:\n\t\t    case EX_EXPFAIL:\n\t\t       \n\t\t      if (posixly_correct && builtin_is_special && interactive_shell == 0)\n\t\t\t{\n\t\t\t  last_command_exit_value = EXECUTION_FAILURE;\n\t\t\t  jump_to_top_level (ERREXIT);\n\t\t\t}\n\t\t      break;\n\t\t    case EX_DISKFALLBACK:\n\t\t       \n\t\t      executing_builtin = old_builtin;\n\t\t      executing_command_builtin = old_command_builtin;\n\t\t      builtin = 0;\n\n\t\t       \n\t\t      pipe_in = pipe_out = -1;\n\t\t      goto execute_from_filesystem;\n\t\t    }\n\t\t  result = builtin_status (result);\n\t\t  if (builtin_is_special)\n\t\t    special_builtin_failed = 1;\t \n\t\t}\n\t       \n\t      if (posixly_correct && builtin_is_special && temporary_env)\n\t\tmerge_temporary_env ();\n\t    }\n\t  else\t\t \n\t    {\n\t      if (result == EX_USAGE)\n\t\tresult = EX_BADUSAGE;\n\t      else if (result > EX_SHERRBASE)\n\t\tresult = builtin_status (result);\n\t    }\n\n\t  set_pipestatus_from_exit (result);\n\n\t  goto return_result;\n\t}\n    }\n\n  if (autocd && interactive && words->word && is_dirname (words->word->word))\n    {\n      words = make_word_list (make_word (\"--\"), words);\n      words = make_word_list (make_word (\"cd\"), words);\n      xtrace_print_word_list (words, 0);\n      func = find_function (\"cd\");\n      goto run_builtin;\n    }\n\nexecute_from_filesystem:\n  if (command_line == 0)\n    command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : \"\");\n\n#if defined (PROCESS_SUBSTITUTION)\n   \n  if (already_forked == 0 && (cmdflags & CMD_NO_FORK) && fifos_pending() > 0)\n    cmdflags &= ~CMD_NO_FORK;\n#endif\n  result = execute_disk_command (words, simple_command->redirects, command_line,\n\t\t\tpipe_in, pipe_out, async, fds_to_close,\n\t\t\tcmdflags);\n\n return_result:\n  bind_lastarg (lastarg);\n  FREE (command_line);\n  dispose_words (words);\n  if (builtin)\n    {\n      executing_builtin = old_builtin;\n      executing_command_builtin = old_command_builtin;\n    }\n  discard_unwind_frame (\"simple-command\");\n  this_command_name = (char *)NULL;\t \n  return (result);\n}\n\n \nstatic int\nbuiltin_status (result)\n     int result;\n{\n  int r;\n\n  switch (result)\n    {\n    case EX_USAGE:\n    case EX_BADSYNTAX:\n      r = EX_BADUSAGE;\n      break;\n    case EX_REDIRFAIL:\n    case EX_BADASSIGN:\n    case EX_EXPFAIL:\n      r = EXECUTION_FAILURE;\n      break;\n    default:\n       \n      r = (result > EX_SHERRBASE) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;\n      break;\n    }\n  return (r);\n}\n\nstatic int\nexecute_builtin (builtin, words, flags, subshell)\n     sh_builtin_func_t *builtin;\n     WORD_LIST *words;\n     int flags, subshell;\n{\n  int result, eval_unwind, ignexit_flag;\n  int isbltinenv, should_keep;\n  char *error_trap;\n\n  error_trap = 0;\n  should_keep = 0;\n\n   \n  if (subshell == 0 && (flags & CMD_IGNORE_RETURN) &&\n\t(builtin == eval_builtin || (flags & CMD_COMMAND_BUILTIN) || builtin == source_builtin))\n    {\n      begin_unwind_frame (\"eval_builtin\");\n      unwind_protect_int (exit_immediately_on_error);\n      unwind_protect_int (builtin_ignoring_errexit);\n      error_trap = TRAP_STRING (ERROR_TRAP);\n      if (error_trap)\n\t{\n\t  error_trap = savestring (error_trap);\n\t  add_unwind_protect (xfree, error_trap);\n\t  add_unwind_protect (set_error_trap, error_trap);\n\t  restore_default_signal (ERROR_TRAP);\n\t}\n      exit_immediately_on_error = 0;\n      ignexit_flag = builtin_ignoring_errexit;\n      builtin_ignoring_errexit = 1;\n      eval_unwind = 1;\n    }\n  else\n    eval_unwind = 0;\n\n   \n   \n  isbltinenv = (builtin == source_builtin || builtin == eval_builtin || builtin == unset_builtin || builtin == mapfile_builtin);\n  should_keep = isbltinenv && builtin != mapfile_builtin;\n#if defined (HISTORY) && defined (READLINE)\n  if (builtin == fc_builtin || builtin == read_builtin)\n    {\n      isbltinenv = 1;\n      should_keep = 0;\n    }\n#endif\n\n  if (isbltinenv)\n    {\n      if (subshell == 0)\n\tbegin_unwind_frame (\"builtin_env\");\n\n      if (temporary_env)\n\t{\n\t  push_scope (VC_BLTNENV, temporary_env);\n\t  if (flags & CMD_COMMAND_BUILTIN)\n\t    should_keep = 0;\n\t  if (subshell == 0)\n\t    add_unwind_protect (pop_scope, should_keep ? \"1\" : 0);\n          temporary_env = (HASH_TABLE *)NULL;\t  \n\t}\n    }\n\n  if (subshell == 0 && builtin == eval_builtin)\n    {\n      if (evalnest_max > 0 && evalnest >= evalnest_max)\n\t{\n\t  internal_error (_(\"eval: maximum eval nesting level exceeded (%d)\"), evalnest);\n\t  evalnest = 0;\n\t  jump_to_top_level (DISCARD);\n\t}\n      unwind_protect_int (evalnest);\n       \n      evalnest++;\t \n    }\n  else if (subshell == 0 && builtin == source_builtin)\n    {\n      if (sourcenest_max > 0 && sourcenest >= sourcenest_max)\n\t{\n\t  internal_error (_(\"%s: maximum source nesting level exceeded (%d)\"), this_command_name, sourcenest);\n\t  sourcenest = 0;\n\t  jump_to_top_level (DISCARD);\n\t}\n      unwind_protect_int (sourcenest);\n       \n      sourcenest++;\t \n    }\n\n   \n  if (posixly_correct && subshell == 0 && builtin == return_builtin && (flags & CMD_COMMAND_BUILTIN) == 0 && temporary_env)\n    {\n      begin_unwind_frame (\"return_temp_env\");\n      add_unwind_protect (merge_temporary_env, (char *)NULL);\n    }\n\n  executing_builtin++;\n  executing_command_builtin |= builtin == command_builtin;\n  result = ((*builtin) (words->next));\n\n   \n  if (posixly_correct && subshell == 0 && builtin == return_builtin && temporary_env)\n    discard_unwind_frame (\"return_temp_env\");\n\n  if (subshell == 0 && isbltinenv)\n    run_unwind_frame (\"builtin_env\");\n\n  if (eval_unwind)\n    {\n      builtin_ignoring_errexit = ignexit_flag;\n      exit_immediately_on_error = builtin_ignoring_errexit ? 0 : errexit_flag;\n      if (error_trap)\n\t{\n\t  set_error_trap (error_trap);\n\t  free (error_trap);\n\t}\n      discard_unwind_frame (\"eval_builtin\");\n    }\n\n  return (result);\n}\n\nstatic void\nmaybe_restore_getopt_state (gs)\n     sh_getopt_state_t *gs;\n{\n   \n  if (gs->gs_flags & 1)\n    sh_getopt_restore_istate (gs);\n  else\n    free (gs);\n}\n\n#if defined (ARRAY_VARS)\nvoid\nrestore_funcarray_state (fa)\n     struct func_array_state *fa;\n{\n  SHELL_VAR *nfv;\n  ARRAY *funcname_a;\n\n  array_pop (fa->source_a);\n  array_pop (fa->lineno_a);\n\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", nfv, funcname_a);\n  if (nfv == fa->funcname_v)\n    array_pop (funcname_a);\n\n  free (fa);\n}\n#endif\n\nstatic int\nexecute_function (var, words, flags, fds_to_close, async, subshell)\n     SHELL_VAR *var;\n     WORD_LIST *words;\n     int flags;\n     struct fd_bitmap *fds_to_close;\n     int async, subshell;\n{\n  int return_val, result, lineno;\n  COMMAND *tc, *fc, *save_current;\n  char *debug_trap, *error_trap, *return_trap;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;\n  ARRAY *funcname_a;\n  volatile ARRAY *bash_source_a;\n  volatile ARRAY *bash_lineno_a;\n  struct func_array_state *fa;\n#endif\n  FUNCTION_DEF *shell_fn;\n  char *sfile, *t;\n  sh_getopt_state_t *gs;\n  SHELL_VAR *gv;\n\n  USE_VAR(fc);\n\n  if (funcnest_max > 0 && funcnest >= funcnest_max)\n    {\n      internal_error (_(\"%s: maximum function nesting level exceeded (%d)\"), var->name, funcnest);\n      funcnest = 0;\t \n      jump_to_top_level (DISCARD);\n    }\n\n#if defined (ARRAY_VARS)\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", funcname_v, funcname_a);\n  GET_ARRAY_FROM_VAR (\"BASH_SOURCE\", bash_source_v, bash_source_a);\n  GET_ARRAY_FROM_VAR (\"BASH_LINENO\", bash_lineno_v, bash_lineno_a);\n#endif\n\n  tc = (COMMAND *)copy_command (function_cell (var));\n  if (tc && (flags & CMD_IGNORE_RETURN))\n    tc->flags |= CMD_IGNORE_RETURN;\n\n   \n  if (tc && (flags & CMD_NO_FORK) && (subshell_environment & SUBSHELL_COMSUB))\n    optimize_shell_function (tc);\n\n  gs = sh_getopt_save_istate ();\n  if (subshell == 0)\n    {\n      begin_unwind_frame (\"function_calling\");\n       \n      push_context (var->name, subshell, temporary_env);\n       \n      add_unwind_protect (maybe_restore_getopt_state, gs);\n      add_unwind_protect (pop_context, (char *)NULL);\n      unwind_protect_int (line_number);\n      unwind_protect_int (line_number_for_err_trap);\n      unwind_protect_int (function_line_number);\n      unwind_protect_int (return_catch_flag);\n      unwind_protect_jmp_buf (return_catch);\n      add_unwind_protect (dispose_command, (char *)tc);\n      unwind_protect_pointer (this_shell_function);\n      unwind_protect_int (funcnest);\n      unwind_protect_int (loop_level);\n    }\n  else\n    push_context (var->name, subshell, temporary_env);\t \n\n  temporary_env = (HASH_TABLE *)NULL;\n\n  this_shell_function = var;\n  make_funcname_visible (1);\n\n  debug_trap = TRAP_STRING(DEBUG_TRAP);\n  error_trap = TRAP_STRING(ERROR_TRAP);\n  return_trap = TRAP_STRING(RETURN_TRAP);\n  \n   \n\n   \n  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))\n    {\n      if (subshell == 0)\n\t{\n\t  debug_trap = savestring (debug_trap);\n\t  add_unwind_protect (xfree, debug_trap);\n\t  add_unwind_protect (maybe_set_debug_trap, debug_trap);\n\t}\n      restore_default_signal (DEBUG_TRAP);\n    }\n\n   \n  if (error_trap && error_trace_mode == 0)\n    {\n      if (subshell == 0)\n\t{\n\t  error_trap = savestring (error_trap);\n\t  add_unwind_protect (xfree, error_trap);\n\t  add_unwind_protect (maybe_set_error_trap, error_trap);\n\t}\n      restore_default_signal (ERROR_TRAP);\n    }\n\n   \n  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))\n    {\n      if (subshell == 0)\n\t{\n\t  return_trap = savestring (return_trap);\n\t  add_unwind_protect (xfree, return_trap);\n\t  add_unwind_protect (maybe_set_return_trap, return_trap);\n\t}\n      restore_default_signal (RETURN_TRAP);\n    }\n  \n  funcnest++;\n#if defined (ARRAY_VARS)\n   \n  shell_fn = find_function_def (this_shell_function->name);\n  sfile = shell_fn ? shell_fn->source_file : \"\";\n  array_push ((ARRAY *)funcname_a, this_shell_function->name);\n\n  array_push ((ARRAY *)bash_source_a, sfile);\n  lineno = GET_LINE_NUMBER ();\n  t = itos (lineno);\n  array_push ((ARRAY *)bash_lineno_a, t);\n  free (t);\n#endif\n\n#if defined (ARRAY_VARS)\n  fa = (struct func_array_state *)xmalloc (sizeof (struct func_array_state));\n  fa->source_a = (ARRAY *)bash_source_a;\n  fa->source_v = bash_source_v;\n  fa->lineno_a = (ARRAY *)bash_lineno_a;\n  fa->lineno_v = bash_lineno_v;\n  fa->funcname_a = (ARRAY *)funcname_a;\n  fa->funcname_v = funcname_v;\n  if (subshell == 0)\n    add_unwind_protect (restore_funcarray_state, fa);\n#endif\n\n   \n\n   \n  if (debugging_mode || shell_compatibility_level <= 44)\n    init_bash_argv ();\n\n  remember_args (words->next, 1);\n\n   \n  if (debugging_mode)\n    {\n      push_args (words->next);\n      if (subshell == 0)\n\tadd_unwind_protect (pop_args, 0);\n    }\n\n   \n  line_number = function_line_number = tc->line;\n\n#if defined (JOB_CONTROL)\n  if (subshell)\n    stop_pipeline (async, (COMMAND *)NULL);\n#endif\n\n  if (shell_compatibility_level > 43)\n    loop_level = 0;\n\n  fc = tc;\n\n  from_return_trap = 0;\n\n  return_catch_flag++;\n  return_val = setjmp_nosigs (return_catch);\n\n  if (return_val)\n    {\n      result = return_catch_value;\n       \n      save_current = currently_executing_command;\n      if (from_return_trap == 0)\n\trun_return_trap ();\n      currently_executing_command = save_current;\n    }\n  else\n    {\n       \n      showing_function_line = 1;\n      save_current = currently_executing_command;\n      result = run_debug_trap ();\n#if defined (DEBUGGER)\n       \n      if (debugging_mode == 0 || result == EXECUTION_SUCCESS)\n\t{\n\t  showing_function_line = 0;\n\t  currently_executing_command = save_current;\n\t  result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);\n\n\t   \n\t  save_current = currently_executing_command;\n\t  run_return_trap ();\n\t  currently_executing_command = save_current;\n\t}\n#else\n      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);\n\n      save_current = currently_executing_command;\n      run_return_trap ();\n      currently_executing_command = save_current;\n#endif\n      showing_function_line = 0;\n    }\n\n   \n  gv = find_variable (\"OPTIND\");\n  if (gv && gv->context == variable_context)\n    gs->gs_flags |= 1;\n\n  if (subshell == 0)\n    run_unwind_frame (\"function_calling\");\n#if defined (ARRAY_VARS)\n  else\n    {\n      restore_funcarray_state (fa);\n       \n      if (debugging_mode)\n\tpop_args ();\n    }\n#endif\n\n  if (variable_context == 0 || this_shell_function == 0)\n    {\n      make_funcname_visible (0);\n#if defined (PROCESS_SUBSTITUTION)\n      unlink_fifo_list ();\n#endif\n    }\n\n  return (result);\n}\n\n \nint\nexecute_shell_function (var, words)\n     SHELL_VAR *var;\n     WORD_LIST *words;\n{\n  int ret;\n  struct fd_bitmap *bitmap;\n\n  bitmap = new_fd_bitmap (FD_BITMAP_DEFAULT_SIZE);\n  begin_unwind_frame (\"execute-shell-function\");\n  add_unwind_protect (dispose_fd_bitmap, (char *)bitmap);\n      \n  ret = execute_function (var, words, 0, bitmap, 0, 0);\n\n  dispose_fd_bitmap (bitmap);\n  discard_unwind_frame (\"execute-shell-function\");\n\n  return ret;\n}\n\n \nstatic void\nexecute_subshell_builtin_or_function (words, redirects, builtin, var,\n\t\t\t\t      pipe_in, pipe_out, async, fds_to_close,\n\t\t\t\t      flags)\n     WORD_LIST *words;\n     REDIRECT *redirects;\n     sh_builtin_func_t *builtin;\n     SHELL_VAR *var;\n     int pipe_in, pipe_out, async;\n     struct fd_bitmap *fds_to_close;\n     int flags;\n{\n  int result, r, funcvalue;\n#if defined (JOB_CONTROL)\n  int jobs_hack;\n\n  jobs_hack = (builtin == jobs_builtin) &&\n\t\t((subshell_environment & SUBSHELL_ASYNC) == 0 || pipe_out != NO_PIPE);\n#endif\n\n   \n  login_shell = interactive = 0;\n  if (builtin == eval_builtin)\n    evalnest = 0;\n  else if (builtin == source_builtin)\n    sourcenest = 0;\n\n  if (async)\n    subshell_environment |= SUBSHELL_ASYNC;\n  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)\n    subshell_environment |= SUBSHELL_PIPE;\n\n  maybe_make_export_env ();\t \n\n#if defined (JOB_CONTROL)\n   \n\n   \n  if (jobs_hack)\n    kill_current_pipeline ();\n  else\n    without_job_control ();\n\n  set_sigchld_handler ();\n#else\n  without_job_control ();\n#endif  \n\n  set_sigint_handler ();\n\n  if (fds_to_close)\n    close_fd_bitmap (fds_to_close);\n\n  do_piping (pipe_in, pipe_out);\n\n  if (do_redirections (redirects, RX_ACTIVE) != 0)\n    exit (EXECUTION_FAILURE);\n\n  if (builtin)\n    {\n       \n      result = setjmp_nosigs (top_level);\n\n       \n      funcvalue = 0;\n      if (return_catch_flag && builtin == return_builtin)\n        funcvalue = setjmp_nosigs (return_catch);\n\n      if (result == EXITPROG || result == EXITBLTIN)\n\tsubshell_exit (last_command_exit_value);\n      else if (result)\n\tsubshell_exit (EXECUTION_FAILURE);\n      else if (funcvalue)\n\tsubshell_exit (return_catch_value);\n      else\n\t{\n\t  r = execute_builtin (builtin, words, flags, 1);\n\t  fflush (stdout);\n\t  if (r == EX_USAGE)\n\t    r = EX_BADUSAGE;\n\t   \n\t  else if (r == EX_DISKFALLBACK)\n\t    {\n\t      char *command_line;\n\n\t      command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : \"\");\n\t      r = execute_disk_command (words, (REDIRECT *)0, command_line,\n\t\t  -1, -1, async, (struct fd_bitmap *)0, flags|CMD_NO_FORK);\n\t    }\n\t  subshell_exit (r);\n\t}\n    }\n  else\n    {\n      r = execute_function (var, words, flags, fds_to_close, async, 1);\n      fflush (stdout);\n      subshell_exit (r);\n    }\n}\n\n \nstatic int\nexecute_builtin_or_function (words, builtin, var, redirects,\n\t\t\t     fds_to_close, flags)\n     WORD_LIST *words;\n     sh_builtin_func_t *builtin;\n     SHELL_VAR *var;\n     REDIRECT *redirects;\n     struct fd_bitmap *fds_to_close;\n     int flags;\n{\n  int result;\n  REDIRECT *saved_undo_list;\n#if defined (PROCESS_SUBSTITUTION)\n  int ofifo, nfifo, osize;\n  void *ofifo_list;\n#endif\n\n#if defined (PROCESS_SUBSTITUTION)\n  begin_unwind_frame (\"saved_fifos\");\n   \n  ofifo = num_fifos ();\n  ofifo_list = copy_fifo_list (&osize);\n  if (ofifo_list)\n    add_unwind_protect (xfree, ofifo_list);\n#endif\n\n  if (do_redirections (redirects, RX_ACTIVE|RX_UNDOABLE) != 0)\n    {\n      undo_partial_redirects ();\n      dispose_exec_redirects ();\n#if defined (PROCESS_SUBSTITUTION)\n      free (ofifo_list);\n#endif\n      return (EX_REDIRFAIL);\t \n    }\n\n  saved_undo_list = redirection_undo_list;\n\n   \n  if (builtin == exec_builtin)\n    {\n      dispose_redirects (saved_undo_list);\n      saved_undo_list = exec_redirection_undo_list;\n      exec_redirection_undo_list = (REDIRECT *)NULL;\n    }\n  else\n    dispose_exec_redirects ();\n\n  if (saved_undo_list)\n    {\n      begin_unwind_frame (\"saved-redirects\");\n      add_unwind_protect (cleanup_redirects, (char *)saved_undo_list);\n    }\n\n  redirection_undo_list = (REDIRECT *)NULL;\n\n  if (builtin)\n    result = execute_builtin (builtin, words, flags, 0);\n  else\n    result = execute_function (var, words, flags, fds_to_close, 0, 0);\n\n   \n  fflush (stdout);\n  fpurge (stdout);\n  if (ferror (stdout))\n    clearerr (stdout);  \n\n   \n  if (builtin == command_builtin && this_shell_builtin == exec_builtin)\n    {\n      int discard;\n\n      discard = 0;\n      if (saved_undo_list)\n\t{\n\t  dispose_redirects (saved_undo_list);\n\t  discard = 1;\n\t}\n      redirection_undo_list = exec_redirection_undo_list;\n      saved_undo_list = exec_redirection_undo_list = (REDIRECT *)NULL;      \n      if (discard)\n\tdiscard_unwind_frame (\"saved-redirects\");\n    }\n\n  if (saved_undo_list)\n    {\n      redirection_undo_list = saved_undo_list;\n      discard_unwind_frame (\"saved-redirects\");\n    }\n\n  undo_partial_redirects ();\n\n#if defined (PROCESS_SUBSTITUTION)\n   \n  nfifo = num_fifos ();\n  if (nfifo > ofifo)\n    close_new_fifos (ofifo_list, osize);\n  if (ofifo_list)\n    free (ofifo_list);\n  discard_unwind_frame (\"saved_fifos\");\n#endif\n\n  return (result);\n}\n\nvoid\nsetup_async_signals ()\n{\n#if defined (__BEOS__)\n  set_signal_handler (SIGHUP, SIG_IGN);\t \n#endif\n\n#if defined (JOB_CONTROL)\n  if (job_control == 0)\n#endif\n    {\n       \n      get_original_signal (SIGINT);\n      set_signal_handler (SIGINT, SIG_IGN);\n\n      get_original_signal (SIGQUIT);\n      set_signal_handler (SIGQUIT, SIG_IGN);\n    }\n}\n\n \n\n \n#ifndef NOTFOUND_HOOK\n#  define NOTFOUND_HOOK \"command_not_found_handle\"\n#endif\n\nstatic int\nexecute_disk_command (words, redirects, command_line, pipe_in, pipe_out,\n\t\t      async, fds_to_close, cmdflags)\n     WORD_LIST *words;\n     REDIRECT *redirects;\n     char *command_line;\n     int pipe_in, pipe_out, async;\n     struct fd_bitmap *fds_to_close;\n     int cmdflags;\n{\n  char *pathname, *command, **args, *p;\n  int nofork, stdpath, result, fork_flags;\n  pid_t pid;\n  SHELL_VAR *hookf;\n  WORD_LIST *wl;\n\n  stdpath = (cmdflags & CMD_STDPATH);\t \n  nofork = (cmdflags & CMD_NO_FORK);\t \n  pathname = words->word->word;\n\n  p = 0;\n  result = EXECUTION_SUCCESS;\n#if defined (RESTRICTED_SHELL)\n  command = (char *)NULL;\n  if (restricted && mbschr (pathname, '/'))\n    {\n      internal_error (_(\"%s: restricted: cannot specify `/' in command names\"),\n\t\t    pathname);\n      result = last_command_exit_value = EXECUTION_FAILURE;\n\n       \n      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)\n\texit (last_command_exit_value);\n      else\n\tgoto parent_return;\n    }\n#endif  \n\n   \n  command = search_for_command (pathname, CMDSRCH_HASH|(stdpath ? CMDSRCH_STDPATH : 0));\n  QUIT;\n\n  if (command)\n    {\n       \n      if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE && (subshell_environment & SUBSHELL_PIPE) == 0)\n\tadjust_shell_level (-1);\n\n      maybe_make_export_env ();\n      put_command_name_into_env (command);\n    }\n\n   \n   \n  if (nofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE)\n    pid = 0;\n  else\n    {\n      fork_flags = async ? FORK_ASYNC : 0;\n      pid = make_child (p = savestring (command_line), fork_flags);\n    }\n\n  if (pid == 0)\n    {\n      int old_interactive;\n\n      reset_terminating_signals ();\t \n       \n      restore_original_signals ();\n      subshell_environment &= ~SUBSHELL_IGNTRAP;\n\n#if defined (JOB_CONTROL)\n      FREE (p);\n#endif\n\n       \n      if (async)\n\t{\n\t  if ((cmdflags & CMD_STDIN_REDIR) &&\n\t\tpipe_in == NO_PIPE &&\n\t\t(stdin_redirects (redirects) == 0))\n\t    async_redirect_stdin ();\n\t  setup_async_signals ();\n\t}\n\n       \n      if (fds_to_close)\n\tclose_fd_bitmap (fds_to_close);\n\n      do_piping (pipe_in, pipe_out);\n\n      old_interactive = interactive;\n      if (async)\n\tinteractive = 0;\n\n      subshell_environment |= SUBSHELL_FORK;\t \n\n#if defined (PROCESS_SUBSTITUTION) && !defined (HAVE_DEV_FD)\n      clear_fifo_list ();\t \n#endif\n\n       \n      if (redirects && (do_redirections (redirects, RX_ACTIVE) != 0))\n\t{\n#if defined (PROCESS_SUBSTITUTION)\n\t   \n\t  unlink_all_fifos ();\n#endif  \n\t  exit (EXECUTION_FAILURE);\n\t}\n\n#if defined (PROCESS_SUBSTITUTION) && !defined (HAVE_DEV_FD)\n       \n      unlink_all_fifos ();\n#endif\n\n      if (async)\n\tinteractive = old_interactive;\n\n      if (command == 0)\n\t{\n\t  hookf = find_function (NOTFOUND_HOOK);\n\t  if (hookf == 0)\n\t    {\n\t       \n\t      pathname = printable_filename (pathname, 0);\n\t      internal_error (_(\"%s: command not found\"), pathname);\n\t      exit (EX_NOTFOUND);\t \n\t    }\n\n\t   \n\t  without_job_control ();\n\n#if defined (JOB_CONTROL)\n\t  set_sigchld_handler ();\n#endif\n\n\t  wl = make_word_list (make_word (NOTFOUND_HOOK), words);\n\t  exit (execute_shell_function (hookf, wl));\n\t}\n\n       \n      args = strvec_from_word_list (words, 0, 0, (int *)NULL);\n      exit (shell_execve (command, args, export_env));\n    }\n  else\n    {\nparent_return:\n      QUIT;\n\n       \n      close_pipes (pipe_in, pipe_out);\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n#if 0\n      if (variable_context == 0)\n        unlink_fifo_list ();\n#endif\n#endif\n      FREE (command);\n      return (result);\n    }\n}\n\n \n\n#if !defined (MSDOS)\n#  define STRINGCHAR(ind) \\\n    (ind < sample_len && !whitespace (sample[ind]) && sample[ind] != '\\n')\n#  define WHITECHAR(ind) \\\n    (ind < sample_len && whitespace (sample[ind]))\n#else\t \n#  define STRINGCHAR(ind) \\\n    (ind < sample_len && !whitespace (sample[ind]) && sample[ind] != '\\n' && sample[ind] != '\\r')\n#  define WHITECHAR(ind) \\\n    (ind < sample_len && whitespace (sample[ind]))\n#endif\t \n\nstatic char *\ngetinterp (sample, sample_len, endp)\n     char *sample;\n     int sample_len, *endp;\n{\n  register int i;\n  char *execname;\n  int start;\n\n   \n  for (i = 2; i < sample_len && whitespace (sample[i]); i++)\n    ;\n\n  for (start = i; STRINGCHAR(i); i++)\n    ;\n\n  execname = substring (sample, start, i);\n\n  if (endp)\n    *endp = i;\n  return execname;\n}\n\n#if !defined (HAVE_HASH_BANG_EXEC)\n \n\nstatic int\nexecute_shell_script (sample, sample_len, command, args, env)\n     char *sample;\n     int sample_len;\n     char *command;\n     char **args, **env;\n{\n  char *execname, *firstarg;\n  int i, start, size_increment, larry;\n\n   \n  execname = getinterp (sample, sample_len, &i);\n  size_increment = 1;\n\n   \n  for (firstarg = (char *)NULL, start = i; WHITECHAR(i); i++)\n    ;\n\n   \n\n  if (STRINGCHAR(i))  \n    {\n      for (start = i; STRINGCHAR(i); i++)\n\t;\n      firstarg = substring ((char *)sample, start, i);\n      size_increment = 2;\n    }\n\n  larry = strvec_len (args) + size_increment;\n  args = strvec_resize (args, larry + 1);\n\n  for (i = larry - 1; i; i--)\n    args[i] = args[i - size_increment];\n\n  args[0] = execname;\n  if (firstarg)\n    {\n      args[1] = firstarg;\n      args[2] = command;\n    }\n  else\n    args[1] = command;\n\n  args[larry] = (char *)NULL;\n\n  return (shell_execve (execname, args, env));\n}\n#undef STRINGCHAR\n#undef WHITECHAR\n\n#endif  \n\nstatic void\ninitialize_subshell ()\n{\n#if defined (ALIAS)\n   \n  delete_all_aliases ();\n#endif  \n\n#if defined (HISTORY)\n   \n  history_lines_this_session = 0;\n#endif\n\n   \n  without_job_control ();\n\n#if defined (JOB_CONTROL)\n  set_sigchld_handler ();\n  init_job_stats ();\n#endif  \n\n   \n  reset_shell_flags ();\n  reset_shell_options ();\n  reset_shopt_options ();\n\n   \n  if (vc_isbltnenv (shell_variables))\n    shell_variables = shell_variables->down;\n\n  clear_unwind_protect_list (0);\n   \n  parse_and_execute_level = 0;\t\t \n\n   \n  variable_context = return_catch_flag = funcnest = evalnest = sourcenest = 0;\n\n  executing_list = 0;\t\t \n\n   \n  if (interactive_shell == 0)\n    unset_bash_input (0);\n}\n\n#if defined (HAVE_SETOSTYPE) && defined (_POSIX_SOURCE)\n#  define SETOSTYPE(x)\t__setostype(x)\n#else\n#  define SETOSTYPE(x)\n#endif\n\n#define HASH_BANG_BUFSIZ\t128\n\n#define READ_SAMPLE_BUF(file, buf, len) \\\n  do \\\n    { \\\n      fd = open(file, O_RDONLY); \\\n      if (fd >= 0) \\\n\t{ \\\n\t  len = read (fd, buf, HASH_BANG_BUFSIZ); \\\n\t  close (fd); \\\n\t} \\\n      else \\\n\tlen = -1; \\\n    } \\\n  while (0)\n      \n \nint\nshell_execve (command, args, env)\n     char *command;\n     char **args, **env;\n{\n  int larray, i, fd;\n  char sample[HASH_BANG_BUFSIZ];\n  int sample_len;\n\n  SETOSTYPE (0);\t\t \n  execve (command, args, env);\n  i = errno;\t\t\t \n  CHECK_TERMSIG;\n  SETOSTYPE (1);\n\n   \n  if (i != ENOEXEC)\n    {\n       \n      last_command_exit_value = (i == ENOENT) ?  EX_NOTFOUND : EX_NOEXEC;  \n      if (file_isdir (command))\n#if defined (EISDIR)\n\tinternal_error (_(\"%s: %s\"), command, strerror (EISDIR));\n#else\n\tinternal_error (_(\"%s: is a directory\"), command);\n#endif\n      else if (executable_file (command) == 0)\n\t{\n\t  errno = i;\n\t  file_error (command);\n\t}\n       \n      else if (i == E2BIG || i == ENOMEM)\n\t{\n\t  errno = i;\n\t  file_error (command);\n\t}\n      else if (i == ENOENT)\n\t{\n\t  errno = i;\n\t  internal_error (_(\"%s: cannot execute: required file not found\"), command);\n\t}\n      else\n\t{\n\t   \n#if defined (HAVE_HASH_BANG_EXEC)\n\t  READ_SAMPLE_BUF (command, sample, sample_len);\n\t  if (sample_len > 0)\n\t    sample[sample_len - 1] = '\\0';\n\t  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')\n\t    {\n\t      char *interp;\n\t      int ilen;\n\n\t      interp = getinterp (sample, sample_len, (int *)NULL);\n\t      ilen = strlen (interp);\n\t      errno = i;\n\t      if (interp[ilen - 1] == '\\r')\n\t\t{\n\t\t  interp = xrealloc (interp, ilen + 2);\n\t\t  interp[ilen - 1] = '^';\n\t\t  interp[ilen] = 'M';\n\t\t  interp[ilen + 1] = '\\0';\n\t\t}\n\t      sys_error (_(\"%s: %s: bad interpreter\"), command, interp ? interp : \"\");\n\t      FREE (interp);\n\t      return (EX_NOEXEC);\n\t    }\n#endif\n\t  errno = i;\n\t  file_error (command);\n\t}\n      return (last_command_exit_value);\n    }\n\n   \n  READ_SAMPLE_BUF (command, sample, sample_len);\n\n  if (sample_len == 0)\n    return (EXECUTION_SUCCESS);\n\n   \n  if (sample_len > 0)\n    {\n#if !defined (HAVE_HASH_BANG_EXEC)\n      if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')\n\treturn (execute_shell_script (sample, sample_len, command, args, env));\n      else\n#endif\n      if (check_binary_file (sample, sample_len))\n\t{\n\t  internal_error (_(\"%s: cannot execute binary file: %s\"), command, strerror (i));\n\t  errno = i;\n\t  return (EX_BINARY_FILE);\n\t}\n    }\n\n   \n\n  reset_parser ();\n  initialize_subshell ();\n\n  set_sigint_handler ();\n\n   \n  larray = strvec_len (args) + 1;\n  args = strvec_resize (args, larray + 1);\n\n  for (i = larray - 1; i; i--)\n    args[i] = args[i - 1];\n\n  args[0] = shell_name;\n  args[1] = command;\n  args[larray] = (char *)NULL;\n\n  if (args[0][0] == '-')\n    args[0]++;\n\n#if defined (RESTRICTED_SHELL)\n  if (restricted)\n    change_flag ('r', FLAG_OFF);\n#endif\n\n  if (subshell_argv)\n    {\n       \n      for (i = 1; i < subshell_argc; i++)\n\tfree (subshell_argv[i]);\n      free (subshell_argv);\n    }\n\n  dispose_command (currently_executing_command);\t \n  currently_executing_command = (COMMAND *)NULL;\n\n  subshell_argc = larray;\n  subshell_argv = args;\n  subshell_envp = env;\n\n  unbind_args ();\t \n\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n  clear_fifo_list ();\t \n#endif\n\n  sh_longjmp (subshell_top_level, 1);\n   \n}\n\nstatic int\nexecute_intern_function (name, funcdef)\n     WORD_DESC *name;\n     FUNCTION_DEF *funcdef;\n{\n  SHELL_VAR *var;\n  char *t;\n\n  if (check_identifier (name, posixly_correct) == 0)\n    {\n      if (posixly_correct && interactive_shell == 0)\n\t{\n\t  last_command_exit_value = EX_BADUSAGE;\n\t  jump_to_top_level (ERREXIT);\n\t}\n      return (EXECUTION_FAILURE);\n    }\n\n  if (strchr (name->word, CTLESC))\t \n    {\n      t = dequote_escapes (name->word);\n      free (name->word);\n      name->word = t;\n    }\n\n   \n  if (posixly_correct && find_special_builtin (name->word))\n    {\n      internal_error (_(\"`%s': is a special builtin\"), name->word);\n      last_command_exit_value = EX_BADUSAGE;\n      jump_to_top_level (interactive_shell ? DISCARD : ERREXIT);\n    }\n\n  var = find_function (name->word);\n  if (var && (readonly_p (var) || noassign_p (var)))\n    {\n      if (readonly_p (var))\n\tinternal_error (_(\"%s: readonly function\"), var->name);\n      return (EXECUTION_FAILURE);\n    }\n\n#if defined (DEBUGGER)\n  bind_function_def (name->word, funcdef, 1);\n#endif\n\n  bind_function (name->word, funcdef->command);\n  return (EXECUTION_SUCCESS);\n}\n\n#if defined (INCLUDE_UNUSED)\n#if defined (PROCESS_SUBSTITUTION)\nvoid\nclose_all_files ()\n{\n  register int i, fd_table_size;\n\n  fd_table_size = getdtablesize ();\n  if (fd_table_size > 256)\t \n    fd_table_size = 256;\n\n  for (i = 3; i < fd_table_size; i++)\n    close (i);\n}\n#endif  \n#endif\n\nstatic void\nclose_pipes (in, out)\n     int in, out;\n{\n  if (in >= 0)\n    close (in);\n  if (out >= 0)\n    close (out);\n}\n\nstatic void\ndup_error (oldd, newd)\n     int oldd, newd;\n{\n  sys_error (_(\"cannot duplicate fd %d to fd %d\"), oldd, newd);\n}\n\n \nstatic void\ndo_piping (pipe_in, pipe_out)\n     int pipe_in, pipe_out;\n{\n  if (pipe_in != NO_PIPE)\n    {\n      if (dup2 (pipe_in, 0) < 0)\n\tdup_error (pipe_in, 0);\n      if (pipe_in > 0)\n\tclose (pipe_in);\n#ifdef __CYGWIN__\n       \n      freopen (NULL, \"r\", stdin);\n#endif  \n    }\n  if (pipe_out != NO_PIPE)\n    {\n      if (pipe_out != REDIRECT_BOTH)\n\t{\n\t  if (dup2 (pipe_out, 1) < 0)\n\t    dup_error (pipe_out, 1);\n\t  if (pipe_out == 0 || pipe_out > 1)\n\t    close (pipe_out);\n\t}\n      else\n\t{\n\t  if (dup2 (1, 2) < 0)\n\t    dup_error (1, 2);\n\t}\n#ifdef __CYGWIN__\n       \n      freopen (NULL, \"w\", stdout);\n      sh_setlinebuf (stdout);\n#endif  \n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}