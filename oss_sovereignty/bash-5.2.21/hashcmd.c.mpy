{
  "module_name": "hashcmd.c",
  "hash_id": "ab96683be34a1911b4ef52ff043990cd3b7f560ca4eebec51641f43642b55a44",
  "original_prompt": "Ingested from bash-5.2.21/hashcmd.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"bashtypes.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n\n#include \"shell.h\"\n#include \"flags.h\"\n#include \"findcmd.h\"\n#include \"hashcmd.h\"\n\nHASH_TABLE *hashed_filenames = (HASH_TABLE *)NULL;\n\nstatic void phash_freedata PARAMS((PTR_T));\n\nvoid\nphash_create ()\n{\n  if (hashed_filenames == 0)\n    hashed_filenames = hash_create (FILENAME_HASH_BUCKETS);\n}\n\nstatic void\nphash_freedata (data)\n     PTR_T data;\n{\n  free (((PATH_DATA *)data)->path);\n  free (data);\n}\n\nvoid\nphash_flush ()\n{\n  if (hashed_filenames)\n    hash_flush (hashed_filenames, phash_freedata);\n}\n\n \nint\nphash_remove (filename)\n     const char *filename;\n{\n  register BUCKET_CONTENTS *item;\n\n  if (hashing_enabled == 0 || hashed_filenames == 0)\n    return 0;\n\n  item = hash_remove (filename, hashed_filenames, 0);\n  if (item)\n    {\n      if (item->data)\n\tphash_freedata (item->data);\n      free (item->key);\n      free (item);\n      return 0;\n    }\n  return 1;\n}\n\n \nvoid\nphash_insert (filename, full_path, check_dot, found)\n     char *filename, *full_path;\n     int check_dot, found;\n{\n  register BUCKET_CONTENTS *item;\n\n  if (hashing_enabled == 0)\n    return;\n\n  if (hashed_filenames == 0)\n    phash_create ();\n\n  item = hash_insert (filename, hashed_filenames, 0);\n  if (item->data)\n    free (pathdata(item)->path);\n  else\n    {\n      item->key = savestring (filename);\n      item->data = xmalloc (sizeof (PATH_DATA));\n    }\n  pathdata(item)->path = savestring (full_path);\n  pathdata(item)->flags = 0;\n  if (check_dot)\n    pathdata(item)->flags |= HASH_CHKDOT;\n  if (*full_path != '/')\n    pathdata(item)->flags |= HASH_RELPATH;\n  item->times_found = found;\n}\n\n \nchar *\nphash_search (filename)\n     const char *filename;\n{\n  register BUCKET_CONTENTS *item;\n  char *path, *dotted_filename, *tail;\n  int same;\n\n  if (hashing_enabled == 0 || hashed_filenames == 0)\n    return ((char *)NULL);\n\n  item = hash_search (filename, hashed_filenames, 0);\n\n  if (item == NULL)\n    return ((char *)NULL);\n\n   \n  path = pathdata(item)->path;\n  if (pathdata(item)->flags & (HASH_CHKDOT|HASH_RELPATH))\n    {\n      tail = (pathdata(item)->flags & HASH_RELPATH) ? path : (char *)filename;\t \n       \n      if (tail[0] != '.' || tail[1] != '/')\n\t{\n\t  dotted_filename = (char *)xmalloc (3 + strlen (tail));\n\t  dotted_filename[0] = '.'; dotted_filename[1] = '/';\n\t  strcpy (dotted_filename + 2, tail);\n\t}\n      else\n\tdotted_filename = savestring (tail);\n\n      if (executable_file (dotted_filename))\n\treturn (dotted_filename);\n\n      free (dotted_filename);\n\n#if 0\n      if (pathdata(item)->flags & HASH_RELPATH)\n\treturn ((char *)NULL);\n#endif\n\n       \n\n       \n      if (*path == '.')\n\t{\n\t  same = 0;\n\t  tail = (char *)strrchr (path, '/');\n\n\t  if (tail)\n\t    {\n\t      *tail = '\\0';\n\t      same = same_file (\".\", path, (struct stat *)NULL, (struct stat *)NULL);\n\t      *tail = '/';\n\t    }\n\n\t  return same ? (char *)NULL : savestring (path);\n\t}\n    }\n\n  return (savestring (path));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}