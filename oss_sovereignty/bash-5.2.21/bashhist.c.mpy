{
  "module_name": "bashhist.c",
  "hash_id": "0991047b4cebbd02efd2b0d053c46587f6ce52542e3ef843a44871370141c8c5",
  "original_prompt": "Ingested from bash-5.2.21/bashhist.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (HISTORY)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n #    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"bashtypes.h\"\n#include <stdio.h>\n#include <errno.h>\n#include \"bashansi.h\"\n#include \"posixstat.h\"\n#include \"filecntl.h\"\n\n#include \"bashintl.h\"\n\n#if defined (SYSLOG_HISTORY)\n#  include <syslog.h>\n#endif\n\n#include \"shell.h\"\n#include \"flags.h\"\n#include \"parser.h\"\n#include \"input.h\"\n#include \"parser.h\"\t \n#include \"pathexp.h\"\t \n#include \"bashhist.h\"\t \n#include \"builtins/common.h\"\n\n#include <readline/history.h>\n#include <glob/glob.h>\n#include <glob/strmatch.h>\n\n#if defined (READLINE)\n#  include \"bashline.h\"\nextern int rl_done, rl_dispatching;\t \n#endif\n\n#ifndef HISTSIZE_DEFAULT\n#  define HISTSIZE_DEFAULT \"500\"\n#endif\n\n#if !defined (errno)\nextern int errno;\n#endif\n\nstatic int histignore_item_func PARAMS((struct ign *));\nstatic int check_history_control PARAMS((char *));\nstatic void hc_erasedups PARAMS((char *));\nstatic void really_add_history PARAMS((char *));\n\nstatic struct ignorevar histignore =\n{\n  \"HISTIGNORE\",\n  (struct ign *)0,\n  0,\n  (char *)0,\n  (sh_iv_item_func_t *)histignore_item_func,\n};\n\n#define HIGN_EXPAND 0x01\n\n \n \nint remember_on_history = 0;\nint enable_history_list = -1;\t \n\n \nint history_lines_this_session;\n\n \nint history_lines_in_file;\n\n#if defined (BANG_HISTORY)\n \nint history_expansion_inhibited;\n \nint double_quotes_inhibit_history_expansion = 0;\n#endif\n\n \nint command_oriented_history = 1;\n\n \nint current_command_first_line_saved = 0;\n\n \nint current_command_line_comment = 0;\n\n \nint literal_history;\n\n \nint force_append_history;\n\n \nint history_control;\n\n \nint hist_last_line_added;\n\n \nint hist_last_line_pushed;\n\n#if defined (READLINE)\n \nint history_reediting;\n\n \nint hist_verify;\n\n#endif  \n\n \nint dont_save_function_defs;\n\n#if defined (BANG_HISTORY)\nstatic int bash_history_inhibit_expansion PARAMS((char *, int));\n#endif\n#if defined (READLINE)\nstatic void re_edit PARAMS((char *));\n#endif\nstatic int history_expansion_p PARAMS((char *));\nstatic int shell_comment PARAMS((char *));\nstatic int should_expand PARAMS((char *));\nstatic HIST_ENTRY *last_history_entry PARAMS((void));\nstatic char *expand_histignore_pattern PARAMS((char *));\nstatic int history_should_ignore PARAMS((char *));\n\n#if defined (BANG_HISTORY)\n \nstatic int\nbash_history_inhibit_expansion (string, i)\n     char *string;\n     int i;\n{\n  int t, si;\n  char hx[2];\n\n  hx[0] = history_expansion_char;\n  hx[1] = '\\0';\n\n   \n  if (i > 0 && (string[i - 1] == '[') && member (']', string + i + 1))\n    return (1);\n   \n  else if (i > 1 && string[i - 1] == '{' && string[i - 2] == '$' &&\n\t     member ('}', string + i + 1))\n    return (1);\n   \n  else if (i > 1 && string[i - 1] == '$' && string[i] == '!')\n    return (1);\n#if defined (EXTENDED_GLOB)\n  else if (extended_glob && i > 1 && string[i+1] == '(' && member (')', string + i + 2))\n    return (1);\n#endif\n\n  si = 0;\n   \n  if (history_quoting_state == '\\'')\n    {\n      si = skip_to_delim (string, 0, \"'\", SD_NOJMP|SD_HISTEXP);\n      if (string[si] == 0 || si >= i)\n\treturn (1);\n      si++;\n    }\n\n   \n  if ((t = skip_to_histexp (string, si, hx, SD_NOJMP|SD_HISTEXP)) > 0)\n    {\n       \n      while (t < i)\n\t{\n\t  t = skip_to_histexp (string, t+1, hx, SD_NOJMP|SD_HISTEXP);\n\t  if (t <= 0)\n\t    return 0;\n\t}\n      return (t > i);\n    }\n  else\n    return (0);\n}\n#endif\n\nvoid\nbash_initialize_history ()\n{\n  history_quotes_inhibit_expansion = 1;\n  history_search_delimiter_chars = \";&()|<>\";\n#if defined (BANG_HISTORY)\n  history_inhibit_expansion_function = bash_history_inhibit_expansion;\n  sv_histchars (\"histchars\");\n#endif\n}\n\nvoid\nbash_history_reinit (interact)\n     int interact;\n{\n#if defined (BANG_HISTORY)\n  history_expansion = (interact == 0) ? histexp_flag : HISTEXPAND_DEFAULT;\n  history_expansion_inhibited = (interact == 0) ? 1 - histexp_flag : 0;\t \n  history_inhibit_expansion_function = bash_history_inhibit_expansion;\n#endif\n  remember_on_history = enable_history_list;\n}\n\nvoid\nbash_history_disable ()\n{\n  remember_on_history = 0;\n#if defined (BANG_HISTORY)\n  history_expansion_inhibited = 1;\n#endif\n}\n\nvoid\nbash_history_enable ()\n{\n  remember_on_history = enable_history_list = 1;\n#if defined (BANG_HISTORY)\n  history_expansion_inhibited = 0;\n  history_inhibit_expansion_function = bash_history_inhibit_expansion;\n#endif\n  sv_history_control (\"HISTCONTROL\");\n  sv_histignore (\"HISTIGNORE\");\n}\n\n \nvoid\nload_history ()\n{\n  char *hf;\n\n   \n  set_if_not (\"HISTSIZE\", HISTSIZE_DEFAULT);\n  sv_histsize (\"HISTSIZE\");\n\n  set_if_not (\"HISTFILESIZE\", get_string_value (\"HISTSIZE\"));\n  sv_histsize (\"HISTFILESIZE\");\n\n   \n  hf = get_string_value (\"HISTFILE\");\n\n  if (hf && *hf && file_exists (hf))\n    {\n      read_history (hf);\n       \n      history_lines_in_file = history_lines_read_from_file;\n      using_history ();\n       \n    }\n}\n\nvoid\nbash_clear_history ()\n{\n  clear_history ();\n  history_lines_this_session = 0;\n   \n}\n\n \nint\nbash_delete_histent (i)\n     int i;\n{\n  HIST_ENTRY *discard;\n\n  discard = remove_history (i);\n  if (discard)\n    {\n      free_history_entry (discard);\n      history_lines_this_session--;\n    }\n  return discard != 0;\n}\n\nint\nbash_delete_history_range (first, last)\n     int first, last;\n{\n  register int i;\n  HIST_ENTRY **discard_list;\n\n  discard_list = remove_history_range (first, last);\n  if (discard_list == 0)\n    return 0;\n  for (i = 0; discard_list[i]; i++)\n    free_history_entry (discard_list[i]);\n  free (discard_list);\n  history_lines_this_session -= i;\n\n  return 1;\n}\n\nint\nbash_delete_last_history ()\n{\n  register int i;\n  HIST_ENTRY **hlist, *histent;\n  int r;\n\n  hlist = history_list ();\n  if (hlist == NULL)\n    return 0;\n\n  for (i = 0; hlist[i]; i++)\n    ;\n  i--;\n\n   \n  histent = history_get (history_base + i);\t \n  if (histent == NULL)\n    return 0;\n\n  r = bash_delete_histent (i);\n\n  if (where_history () > history_length)\n    history_set_pos (history_length);\n\n  return r;\n}\n\n#ifdef INCLUDE_UNUSED\n \nvoid\nsave_history ()\n{\n  char *hf;\n  int r;\n\n  hf = get_string_value (\"HISTFILE\");\n  if (hf && *hf && file_exists (hf))\n    {\n       \n      using_history ();\n\n      if (history_lines_this_session <= where_history () || force_append_history)\n\tr = append_history (history_lines_this_session, hf);\n      else\n\tr = write_history (hf);\n      sv_histsize (\"HISTFILESIZE\");\n    }\n}\n#endif\n\nint\nmaybe_append_history (filename)\n     char *filename;\n{\n  int fd, result, histlen;\n  struct stat buf;\n\n  result = EXECUTION_SUCCESS;\n  if (history_lines_this_session > 0)\n    {\n       \n      if (stat (filename, &buf) == -1 && errno == ENOENT)\n\t{\n\t  fd = open (filename, O_WRONLY|O_CREAT, 0600);\n\t  if (fd < 0)\n\t    {\n\t      builtin_error (_(\"%s: cannot create: %s\"), filename, strerror (errno));\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  close (fd);\n\t}\n       \n      histlen = where_history ();\n      if (histlen > 0 && history_lines_this_session > histlen)\n\thistory_lines_this_session = histlen;\t \n      result = append_history (history_lines_this_session, filename);\n       \n      history_lines_in_file += history_lines_this_session;\n      history_lines_this_session = 0;\n    }\n  else\n    history_lines_this_session = 0;\t \n\n  return (result);\n}\n\n \nint\nmaybe_save_shell_history ()\n{\n  int result;\n  char *hf;\n\n  result = 0;\n  if (history_lines_this_session > 0)\n    {\n      hf = get_string_value (\"HISTFILE\");\n\n      if (hf && *hf)\n\t{\n\t   \n\t  if (file_exists (hf) == 0)\n\t    {\n\t      int file;\n\t      file = open (hf, O_CREAT | O_TRUNC | O_WRONLY, 0600);\n\t      if (file != -1)\n\t\tclose (file);\n\t    }\n\n\t   \n\t  using_history ();\n\t  if (history_lines_this_session <= where_history () || force_append_history)\n\t    {\n\t      result = append_history (history_lines_this_session, hf);\n\t      history_lines_in_file += history_lines_this_session;\n\t    }\n\t  else\n\t    {\n\t      result = write_history (hf);\n\t      history_lines_in_file = history_lines_written_to_file;\n\t       \n\t    }\n\t  history_lines_this_session = 0;\n\n\t  sv_histsize (\"HISTFILESIZE\");\n\t}\n    }\n  return (result);\n}\n\n#if defined (READLINE)\n \nstatic void\nre_edit (text)\n     char *text;\n{\n  if (bash_input.type == st_stdin)\n    bash_re_edit (text);\n}\n#endif  \n\n \nstatic int\nhistory_expansion_p (line)\n     char *line;\n{\n  register char *s;\n\n  for (s = line; *s; s++)\n    if (*s == history_expansion_char || *s == history_subst_char)\n      return 1;\n  return 0;\n}\n\n \nchar *\npre_process_line (line, print_changes, addit)\n     char *line;\n     int print_changes, addit;\n{\n  char *history_value;\n  char *return_value;\n  int expanded;\n\n  return_value = line;\n  expanded = 0;\n\n#  if defined (BANG_HISTORY)\n   \n  if (!history_expansion_inhibited && history_expansion && history_expansion_p (line))\n    {\n      int old_len;\n\n       \n      old_len = history_length;\n      if (history_length > 0 && command_oriented_history && current_command_first_line_saved && current_command_line_count > 1)\n        history_length--;\n      expanded = history_expand (line, &history_value);\n      if (history_length >= 0 && command_oriented_history && current_command_first_line_saved && current_command_line_count > 1)\n        history_length = old_len;\n\n      if (expanded)\n\t{\n\t  if (print_changes)\n\t    {\n\t      if (expanded < 0)\n\t\tinternal_error (\"%s\", history_value);\n#if defined (READLINE)\n\t      else if (hist_verify == 0 || expanded == 2)\n#else\n\t      else\n#endif\n\t\tfprintf (stderr, \"%s\\n\", history_value);\n\t    }\n\n\t   \n\t  if (expanded < 0 || expanded == 2)\t \n\t    {\n#    if defined (READLINE)\n\t      if (expanded == 2 && rl_dispatching == 0 && *history_value)\n#    else\t      \n\t      if (expanded == 2 && *history_value)\n#    endif  \n\t\tmaybe_add_history (history_value);\n\n\t      free (history_value);\n\n#    if defined (READLINE)\n\t       \n\t      if (history_reediting && expanded < 0 && rl_done)\n\t\tre_edit (line);\n#    endif  \n\t      return ((char *)NULL);\n\t    }\n\n#    if defined (READLINE)\n\t  if (hist_verify && expanded == 1)\n\t    {\n\t      re_edit (history_value);\n\t      free (history_value);\n\t      return ((char *)NULL);\n\t    }\n#    endif\n\t}\n\n       \n      expanded = 1;\n      return_value = history_value;\n    }\n#  endif  \n\n  if (addit && remember_on_history && *return_value)\n    maybe_add_history (return_value);\n\n#if 0\n  if (expanded == 0)\n    return_value = savestring (line);\n#endif\n\n  return (return_value);\n}\n\n \nstatic int\nshell_comment (line)\n     char *line;\n{\n  char *p;\n  int n;\n\n  if (dstack.delimiter_depth != 0 || (parser_state & PST_HEREDOC))\n    return 0;\n  if (line == 0)\n    return 0;\n  for (p = line; p && *p && whitespace (*p); p++)\n    ;\n  if (p && *p == '#')\n    return 1;\n  n = skip_to_delim (line, p - line, \"#\", SD_NOJMP|SD_GLOB|SD_EXTGLOB|SD_COMPLETE);\n  return (line[n] == '#') ? 2 : 0;\n}\n\n#ifdef INCLUDE_UNUSED\n \nstatic char *\nfilter_comments (line)\n     char *line;\n{\n  char *p;\n\n  for (p = line; p && *p && *p != '#'; p++)\n    ;\n  if (p && *p == '#')\n    *p = '\\0';\n  return (line);\n}\n#endif\n\n \nstatic int\ncheck_history_control (line)\n     char *line;\n{\n  HIST_ENTRY *temp;\n  int r;\n\n  if (history_control == 0)\n    return 1;\n\n   \n  if ((history_control & HC_IGNSPACE) && *line == ' ')\n    return 0;\n\n   \n  if (history_control & HC_IGNDUPS)\n    {\n      using_history ();\n      temp = previous_history ();\n\n      r = (temp == 0 || STREQ (temp->line, line) == 0);\n\n      using_history ();\n\n      if (r == 0)\n\treturn r;\n    }\n\n  return 1;\n}\n\n \nstatic void\nhc_erasedups (line)\n     char *line;\n{\n  HIST_ENTRY *temp;\n  int r;\n\n  using_history ();\n  while (temp = previous_history ())\n    {\n      if (STREQ (temp->line, line))\n\t{\n\t  r = where_history ();\n\t  temp = remove_history (r);\n\t  if (temp)\n\t    free_history_entry (temp);\n\t}\n    }\n  using_history ();\n}\n\n \nvoid\nmaybe_add_history (line)\n     char *line;\n{\n  int is_comment;\n\n  hist_last_line_added = 0;\n  is_comment = shell_comment (line);\n\n   \n  if (current_command_line_count > 1)\n    {\n      if (current_command_first_line_saved &&\n\t  ((parser_state & PST_HEREDOC) || literal_history || dstack.delimiter_depth != 0 || is_comment != 1))\n\tbash_add_history (line);\n      current_command_line_comment = is_comment ? current_command_line_count : -2;\n      return;\n    }\n\n   \n  current_command_line_comment = is_comment ? current_command_line_count : -2;\n  current_command_first_line_saved = check_add_history (line, 0);\n}\n\n \nint\ncheck_add_history (line, force)\n     char *line;\n     int force;\n{\n  if (check_history_control (line) && history_should_ignore (line) == 0)\n    {\n       \n      if (history_control & HC_ERASEDUPS)\n\thc_erasedups (line);\n        \n      if (force)\n\t{\n\t  really_add_history (line);\n\t  using_history ();\n\t}\n      else\n\tbash_add_history (line);\n      return 1;\n    }\n  return 0;\n}\n\n#if defined (SYSLOG_HISTORY)\n#define SYSLOG_MAXMSG\t1024\n#define SYSLOG_MAXLEN\tSYSLOG_MAXMSG\n#define SYSLOG_MAXHDR\t256\n\n#ifndef OPENLOG_OPTS\n#define OPENLOG_OPTS 0\n#endif\n\n#if defined (SYSLOG_SHOPT)\nint syslog_history = SYSLOG_SHOPT;\n#else\nint syslog_history = 1;\n#endif\n\nvoid\nbash_syslog_history (line)\n     const char *line;\n{\n  char trunc[SYSLOG_MAXLEN], *msg;\n  char loghdr[SYSLOG_MAXHDR];\n  char seqbuf[32], *seqnum;\n  int hdrlen, msglen, seqlen, chunks, i;\n  static int first = 1;\n\n  if (first)\n    {\n      openlog (shell_name, OPENLOG_OPTS, SYSLOG_FACILITY);\n      first = 0;\n    }\n\n  hdrlen = snprintf (loghdr, sizeof(loghdr), \"HISTORY: PID=%d UID=%d\", getpid(), current_user.uid);\n  msglen = strlen (line);\n\n  if ((msglen + hdrlen + 1) < SYSLOG_MAXLEN)\n    syslog (SYSLOG_FACILITY|SYSLOG_LEVEL, \"%s %s\", loghdr, line);\n  else\n    {\n      chunks = ((msglen + hdrlen) / SYSLOG_MAXLEN) + 1;\n      for (msg = line, i = 0; i < chunks; i++)\n\t{\n\t  seqnum = inttostr (i + 1, seqbuf, sizeof (seqbuf));\n\t  seqlen = STRLEN (seqnum);\n\n\t   \n\t  strncpy (trunc, msg, SYSLOG_MAXLEN - hdrlen - seqlen - 7 - 1);\n\t  trunc[SYSLOG_MAXLEN - 1] = '\\0';\n\t  syslog (SYSLOG_FACILITY|SYSLOG_LEVEL, \"%s (seq=%s) %s\", loghdr, seqnum, trunc);\n\t  msg += SYSLOG_MAXLEN - hdrlen - seqlen - 8;\n\t}\n    }\n}\n#endif\n     \t\n \nvoid\nbash_add_history (line)\n     char *line;\n{\n  int add_it, offset, curlen, is_comment;\n  HIST_ENTRY *current, *old;\n  char *chars_to_add, *new_line;\n\n  add_it = 1;\n  if (command_oriented_history && current_command_line_count > 1)\n    {\n      is_comment = shell_comment (line);\n\n       \n       \n      if ((parser_state & PST_HEREDOC) && here_doc_first_line == 0 && line[strlen (line) - 1] == '\\n')\n\tchars_to_add = \"\";\n      else if (current_command_line_count == current_command_line_comment+1)\n\tchars_to_add = \"\\n\";\n      else if (literal_history)\n\tchars_to_add = \"\\n\";\n      else\n\tchars_to_add = history_delimiting_chars (line);\n\n      using_history ();\n      current = previous_history ();\n\n      current_command_line_comment = is_comment ? current_command_line_count : -2;\n\n      if (current)\n\t{\n\t   \n\t  curlen = strlen (current->line);\n\n\t  if (dstack.delimiter_depth == 0 && current->line[curlen - 1] == '\\\\' &&\n\t      current->line[curlen - 2] != '\\\\')\n\t    {\n\t      current->line[curlen - 1] = '\\0';\n\t      curlen--;\n\t      chars_to_add = \"\";\n\t    }\n\n\t   \n\t  if (dstack.delimiter_depth == 0 && current->line[curlen - 1] == '\\n' && *chars_to_add == ';')\n\t    chars_to_add++;\n\n\t  new_line = (char *)xmalloc (1\n\t\t\t\t      + curlen\n\t\t\t\t      + strlen (line)\n\t\t\t\t      + strlen (chars_to_add));\n\t  sprintf (new_line, \"%s%s%s\", current->line, chars_to_add, line);\n\t  offset = where_history ();\n\t  old = replace_history_entry (offset, new_line, current->data);\n\t  free (new_line);\n\n\t  if (old)\n\t    free_history_entry (old);\n\n\t  add_it = 0;\n\t}\n    }\n\n  if (add_it && history_is_stifled() && history_length == 0 && history_length == history_max_entries)\n    add_it = 0;\n\n  if (add_it)\n    really_add_history (line);\n\n#if defined (SYSLOG_HISTORY)\n  if (syslog_history)\n    bash_syslog_history (line);\n#endif\n\n  using_history ();\n}\n\nstatic void\nreally_add_history (line)\n     char *line;\n{\n  hist_last_line_added = 1;\n  hist_last_line_pushed = 0;\n  add_history (line);\n  history_lines_this_session++;\n}\n\nint\nhistory_number ()\n{\n  using_history ();\n  return ((remember_on_history || enable_history_list) ? history_base + where_history () : 1);\n}\n\nstatic int\nshould_expand (s)\n     char *s;\n{\n  char *p;\n\n  for (p = s; p && *p; p++)\n    {\n      if (*p == '\\\\')\n\tp++;\n      else if (*p == '&')\n\treturn 1;\n    }\n  return 0;\n}\n\nstatic int\nhistignore_item_func (ign)\n     struct ign *ign;\n{\n  if (should_expand (ign->val))\n    ign->flags |= HIGN_EXPAND;\n  return (0);\n}\n\nvoid\nsetup_history_ignore (varname)\n     char *varname;\n{\n  setup_ignore_patterns (&histignore);\n}\n\nstatic HIST_ENTRY *\nlast_history_entry ()\n{\n  HIST_ENTRY *he;\n\n  using_history ();\n  he = previous_history ();\n  using_history ();\n  return he;\n}\n\nchar *\nlast_history_line ()\n{\n  HIST_ENTRY *he;\n\n  he = last_history_entry ();\n  if (he == 0)\n    return ((char *)NULL);\n  return he->line;\n}\n\nstatic char *\nexpand_histignore_pattern (pat)\n     char *pat;\n{\n  HIST_ENTRY *phe;\n  char *ret;\n\n  phe = last_history_entry ();\n\n  if (phe == (HIST_ENTRY *)0)\n    return (savestring (pat));\n\n  ret = strcreplace (pat, '&', phe->line, 1);\n\n  return ret;\n}\n\n \nstatic int\nhistory_should_ignore (line)\n     char *line;\n{\n  register int i, match;\n  char *npat;\n\n  if (histignore.num_ignores == 0)\n    return 0;\n\n  for (i = match = 0; i < histignore.num_ignores; i++)\n    {\n      if (histignore.ignores[i].flags & HIGN_EXPAND)\n\tnpat = expand_histignore_pattern (histignore.ignores[i].val);\n      else\n\tnpat = histignore.ignores[i].val;\n\n      match = strmatch (npat, line, FNMATCH_EXTFLAG) != FNM_NOMATCH;\n\n      if (histignore.ignores[i].flags & HIGN_EXPAND)\n\tfree (npat);\n\n      if (match)\n\tbreak;\n    }\n\n  return match;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}