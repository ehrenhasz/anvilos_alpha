{
  "module_name": "alias.c",
  "hash_id": "2ad19b6abe0d30eabf6a2ca40286a6e3a4c4a491fa15a93c0cc0fb53fabf9d57",
  "original_prompt": "Ingested from bash-5.2.21/alias.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (ALIAS)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"chartypes.h\"\n#include \"bashansi.h\"\n#include \"command.h\"\n#include \"general.h\"\n#include \"externs.h\"\n#include \"alias.h\"\n\n#if defined (PROGRAMMABLE_COMPLETION)\n#  include \"pcomplete.h\"\n#endif\n\n#if defined (HAVE_MBSTR_H) && defined (HAVE_MBSCHR)\n#  include <mbstr.h>\t\t \n#endif\n\n#define ALIAS_HASH_BUCKETS\t64\t \n\ntypedef int sh_alias_map_func_t PARAMS((alias_t *));\n\nstatic void free_alias_data PARAMS((PTR_T));\nstatic alias_t **map_over_aliases PARAMS((sh_alias_map_func_t *));\nstatic void sort_aliases PARAMS((alias_t **));\nstatic int qsort_alias_compare PARAMS((alias_t **, alias_t **));\n\n#if defined (READLINE)\nstatic int skipquotes PARAMS((char *, int));\nstatic int skipws PARAMS((char *, int));\nstatic int rd_token PARAMS((char *, int));\n#endif\n\n \nint alias_expand_all = 0;\n\n \nHASH_TABLE *aliases = (HASH_TABLE *)NULL;\n\nvoid\ninitialize_aliases ()\n{\n  if (aliases == 0)\n    aliases = hash_create (ALIAS_HASH_BUCKETS);\n}\n\n \nalias_t *\nfind_alias (name)\n     char *name;\n{\n  BUCKET_CONTENTS *al;\n\n  if (aliases == 0)\n    return ((alias_t *)NULL);\n\n  al = hash_search (name, aliases, 0);\n  return (al ? (alias_t *)al->data : (alias_t *)NULL);\n}\n\n \nchar *\nget_alias_value (name)\n     char *name;\n{\n  alias_t *alias;\n\n  if (aliases == 0)\n    return ((char *)NULL);\n\n  alias = find_alias (name);\n  return (alias ? alias->value : (char *)NULL);\n}\n\n \nvoid\nadd_alias (name, value)\n     char *name, *value;\n{\n  BUCKET_CONTENTS *elt;\n  alias_t *temp;\n  int n;\n\n  if (aliases == 0)\n    {\n      initialize_aliases ();\n      temp = (alias_t *)NULL;\n    }\n  else\n    temp = find_alias (name);\n\n  if (temp)\n    {\n      free (temp->value);\n      temp->value = savestring (value);\n      temp->flags &= ~AL_EXPANDNEXT;\n      if (value[0])\n\t{\n\t  n = value[strlen (value) - 1];\n\t  if (n == ' ' || n == '\\t')\n\t    temp->flags |= AL_EXPANDNEXT;\n\t}\n    }\n  else\n    {\n      temp = (alias_t *)xmalloc (sizeof (alias_t));\n      temp->name = savestring (name);\n      temp->value = savestring (value);\n      temp->flags = 0;\n\n      if (value[0])\n\t{\n\t  n = value[strlen (value) - 1];\n\t  if (n == ' ' || n == '\\t')\n\t    temp->flags |= AL_EXPANDNEXT;\n\t}\n\n      elt = hash_insert (savestring (name), aliases, HASH_NOSRCH);\n      elt->data = temp;\n#if defined (PROGRAMMABLE_COMPLETION)\n      set_itemlist_dirty (&it_aliases);\n#endif\n    }\n}\n\n \nstatic void\nfree_alias_data (data)\n     PTR_T data;\n{\n  register alias_t *a;\n\n  a = (alias_t *)data;\n\n  if (a->flags & AL_BEINGEXPANDED)\n    clear_string_list_expander (a);\t \n\n  free (a->value);\n  free (a->name);\n  free (data);\n}\n\n \nint\nremove_alias (name)\n     char *name;\n{\n  BUCKET_CONTENTS *elt;\n\n  if (aliases == 0)\n    return (-1);\n\n  elt = hash_remove (name, aliases, 0);\n  if (elt)\n    {\n      free_alias_data (elt->data);\n      free (elt->key);\t\t \n      free (elt);\t\t \n#if defined (PROGRAMMABLE_COMPLETION)\n      set_itemlist_dirty (&it_aliases);\n#endif\n      return (aliases->nentries);\n    }\n  return (-1);\n}\n\n \nvoid\ndelete_all_aliases ()\n{\n  if (aliases == 0)\n    return;\n\n  hash_flush (aliases, free_alias_data);\n  hash_dispose (aliases);\n  aliases = (HASH_TABLE *)NULL;\n#if defined (PROGRAMMABLE_COMPLETION)\n  set_itemlist_dirty (&it_aliases);\n#endif\n}\n\n \nstatic alias_t **\nmap_over_aliases (function)\n     sh_alias_map_func_t *function;\n{\n  register int i;\n  register BUCKET_CONTENTS *tlist;\n  alias_t *alias, **list;\n  int list_index;\n\n  i = HASH_ENTRIES (aliases);\n  if (i == 0)\n    return ((alias_t **)NULL);\n\n  list = (alias_t **)xmalloc ((i + 1) * sizeof (alias_t *));\n  for (i = list_index = 0; i < aliases->nbuckets; i++)\n    {\n      for (tlist = hash_items (i, aliases); tlist; tlist = tlist->next)\n\t{\n\t  alias = (alias_t *)tlist->data;\n\n\t  if (!function || (*function) (alias))\n\t    {\n\t      list[list_index++] = alias;\n\t      list[list_index] = (alias_t *)NULL;\n\t    }\n\t}\n    }\n  return (list);\n}\n\nstatic void\nsort_aliases (array)\n     alias_t **array;\n{\n  qsort (array, strvec_len ((char **)array), sizeof (alias_t *), (QSFUNC *)qsort_alias_compare);\n}\n\nstatic int\nqsort_alias_compare (as1, as2)\n     alias_t **as1, **as2;\n{\n  int result;\n\n  if ((result = (*as1)->name[0] - (*as2)->name[0]) == 0)\n    result = strcmp ((*as1)->name, (*as2)->name);\n\n  return (result);\n}\n\n \nalias_t **\nall_aliases ()\n{\n  alias_t **list;\n\n  if (aliases == 0 || HASH_ENTRIES (aliases) == 0)\n    return ((alias_t **)NULL);\n\n  list = map_over_aliases ((sh_alias_map_func_t *)NULL);\n  if (list)\n    sort_aliases (list);\n  return (list);\n}\n\nchar *\nalias_expand_word (s)\n     char *s;\n{\n  alias_t *r;\n\n  r = find_alias (s);\n  return (r ? savestring (r->value) : (char *)NULL);\n}\n\n \n\n#if defined (READLINE)\n\n \n#define self_delimiting(character) (member ((character), \" \\t\\n\\r;|&()\"))\n\n \n#define command_separator(character) (member ((character), \"\\r\\n;|&(\"))\n\n \nstatic int command_word;\n\n \n#define quote_char(c)  (((c) == '\\'') || ((c) == '\"'))\n\n \n\nstatic int\nskipquotes (string, start)\n     char *string;\n     int start;\n{\n  register int i;\n  int delimiter = string[start];\n\n   \n  for (i = start + 1 ; string[i] ; i++)\n    {\n      if (string[i] == '\\\\')\n\t{\n\t  i++;\t\t \n\t  if (string[i] == 0)\n\t    break;\n\t  continue;\n\t}\n\n      if (string[i] == delimiter)\n\treturn i;\n    }\n  return (i);\n}\n\n \nstatic int\nskipws (string, start)\n     char *string;\n     int start;\n{\n  register int i;\n  int pass_next, backslash_quoted_word;\n  unsigned char peekc;\n\n   \n  i = backslash_quoted_word = pass_next = 0;\n\n   \n\n  for (i = start; string[i]; i++)\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  continue;\n\t}\n\n      if (whitespace (string[i]))\n\t{\n\t  backslash_quoted_word = 0;  \n\t  continue;\n\t}\n\n      if (string[i] == '\\\\')\n\t{\n\t  peekc = string[i+1];\n\t  if (peekc == 0)\n\t    break;\n\t  if (ISLETTER (peekc))\n\t    backslash_quoted_word++;\t \n\t  else\n\t    pass_next++;\n\t  continue;\n\t}\n\n       \n      if (quote_char(string[i]))\n\t{\n\t  i = skipquotes (string, i);\n\t   \n\t  if (string[i] == '\\0')\n\t    break;\n\n\t  peekc = string[i + 1];\n\t  if (ISLETTER (peekc))\n\t    backslash_quoted_word++;\n\t  continue;\n\t}\n\n       \n      if (backslash_quoted_word)\n\tcontinue;\n\n       \n\n      if (command_separator (string[i]))\n\t{\n\t  command_word++;\n\t  continue;\n\t}\n      break;\n    }\n  return (i);\n}\n\n \n#define token_char(c)\t(!((whitespace (string[i]) || self_delimiting (string[i]))))\n\n \nstatic int\nrd_token (string, start)\n     char *string;\n     int start;\n{\n  register int i;\n\n   \n  for (i = start; string[i] && token_char (string[i]); i++)\n    {\n      if (string[i] == '\\\\')\n\t{\n\t  i++;\t \n\t  if (string[i] == 0)\n\t    break;\n\t  continue;\n\t}\n\n       \n      if (quote_char (string[i]))\n\t{\n\t  i = skipquotes (string, i);\n\t   \n\t  if (string[i] == '\\0')\n\t    break;\n\n\t   \n\t  continue;\n\t}\n    }\n  return (i);\n}\n\n \nchar *\nalias_expand (string)\n     char *string;\n{\n  register int i, j, start;\n  char *line, *token;\n  int line_len, tl, real_start, expand_next, expand_this_token;\n  alias_t *alias;\n\n  line_len = strlen (string) + 1;\n  line = (char *)xmalloc (line_len);\n  token = (char *)xmalloc (line_len);\n\n  line[0] = i = 0;\n  expand_next = 0;\n  command_word = 1;  \n\n   \n\n  for (;;)\n    {\n\n      token[0] = 0;\n      start = i;\n\n       \n      i = skipws (string, start);\n\n      if (start == i && string[i] == '\\0')\n\t{\n\t  free (token);\n\t  return (line);\n\t}\n\n       \n      j = strlen (line);\n      tl = i - start;\t \n      RESIZE_MALLOCED_BUFFER (line, j, (tl + 1), line_len, (tl + 50));\n      strncpy (line + j, string + start, tl);\n      line[j + tl] = '\\0';\n\n      real_start = i;\n\n      command_word = command_word || (command_separator (string[i]));\n      expand_this_token = (command_word || expand_next);\n      expand_next = 0;\n\n       \n      start = i;\n      i = rd_token (string, start);\n\n      tl = i - start;\t \n\n       \n      if (tl == 0 && string[i] != '\\0')\n\t{\n\t  tl = 1;\n\t  i++;\t\t \n\t}\n\n      strncpy (token, string + start, tl);\n      token [tl] = '\\0';\n\n       \n      if (mbschr (token, '\\\\'))\n\texpand_this_token = 0;\n\n       \n\n      if ((token[0]) &&\n\t  (expand_this_token || alias_expand_all) &&\n\t  (alias = find_alias (token)))\n\t{\n\t  char *v;\n\t  int vlen, llen;\n\n\t  v = alias->value;\n\t  vlen = strlen (v);\n\t  llen = strlen (line);\n\n\t   \n\t  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));\n\n\t  strcpy (line + llen, v);\n\n\t  if ((expand_this_token && vlen && whitespace (v[vlen - 1])) ||\n\t      alias_expand_all)\n\t    expand_next = 1;\n\t}\n      else\n\t{\n\t  int llen, tlen;\n\n\t  llen = strlen (line);\n\t  tlen = i - real_start;  \n\n\t  RESIZE_MALLOCED_BUFFER (line, llen, (tlen + 1), line_len, (llen + tlen + 50));\n\n\t  strncpy (line + llen, string + real_start, tlen);\n\t  line[llen + tlen] = '\\0';\n\t}\n      command_word = 0;\n    }\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}