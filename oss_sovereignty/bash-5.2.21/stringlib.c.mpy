{
  "module_name": "stringlib.c",
  "hash_id": "23fcf178f56b5d9911533111061cee5aca14e3e40f5d8bf0458aec1c559f7525",
  "original_prompt": "Ingested from bash-5.2.21/stringlib.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include <stdio.h>\n#include \"chartypes.h\"\n\n#include \"shell.h\"\n#include \"pathexp.h\"\n\n#include <glob/glob.h>\n\n#if defined (EXTENDED_GLOB)\n#  include <glob/strmatch.h>\n#endif\n\n \n \n \n \n \n\n \nint\nfind_string_in_alist (string, alist, flags)\n     char *string;\n     STRING_INT_ALIST *alist;\n     int flags;\n{\n  register int i;\n  int r;\n\n  for (i = r = 0; alist[i].word; i++)\n    {\n#if defined (EXTENDED_GLOB)\n      if (flags)\n\tr = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;\n      else\n#endif\n\tr = STREQ (string, alist[i].word);\n\n      if (r)\n\treturn (alist[i].token);\n    }\n  return -1;\n}\n\n \nchar *\nfind_token_in_alist (token, alist, flags)\n     int token;\n     STRING_INT_ALIST *alist;\n     int flags;\n{\n  register int i;\n\n  for (i = 0; alist[i].word; i++)\n    {\n      if (alist[i].token == token)\n        return (savestring (alist[i].word));\n    }\n  return ((char *)NULL);\n}\n\nint\nfind_index_in_alist (string, alist, flags)\n     char *string;\n     STRING_INT_ALIST *alist;\n     int flags;\n{\n  register int i;\n  int r;\n\n  for (i = r = 0; alist[i].word; i++)\n    {\n#if defined (EXTENDED_GLOB)\n      if (flags)\n\tr = strmatch (alist[i].word, string, FNM_EXTMATCH) != FNM_NOMATCH;\n      else\n#endif\n\tr = STREQ (string, alist[i].word);\n\n      if (r)\n\treturn (i);\n    }\n\n  return -1;\n}\n\n \n \n \n \n \n\n \nchar *\nsubstring (string, start, end)\n     const char *string;\n     int start, end;\n{\n  register int len;\n  register char *result;\n\n  len = end - start;\n  result = (char *)xmalloc (len + 1);\n  memcpy (result, string + start, len);\n  result[len] = '\\0';\n  return (result);\n}\n\n \nchar *\nstrsub (string, pat, rep, global)\n     char *string, *pat, *rep;\n     int global;\n{\n  size_t patlen, replen, templen, tempsize, i;\n  int repl;\n  char *temp, *r;\n\n  patlen = strlen (pat);\n  replen = strlen (rep);\n  for (temp = (char *)NULL, i = templen = tempsize = 0, repl = 1; string[i]; )\n    {\n      if (repl && STREQN (string + i, pat, patlen))\n\t{\n\t  if (replen)\n\t    RESIZE_MALLOCED_BUFFER (temp, templen, replen, tempsize, (replen * 2));\n\n\t  for (r = rep; *r; )\t \n\t    temp[templen++] = *r++;\n\n\t  i += patlen ? patlen : 1;\t \n\t  repl = global != 0;\n\t}\n      else\n\t{\n\t  RESIZE_MALLOCED_BUFFER (temp, templen, 1, tempsize, 16);\n\t  temp[templen++] = string[i++];\n\t}\n    }\n  if (temp)\n    temp[templen] = 0;\n  else\n    temp = savestring (string);\n  return (temp);\n}\n\n \nchar *\nstrcreplace (string, c, text, flags)\n     char *string;\n     int c;\n     const char *text;\n     int flags;\n{\n  char *ret, *p, *r, *t;\n  size_t len, rlen, ind, tlen;\n  int do_glob, escape_backslash;\n\n  do_glob = flags & 1;\n  escape_backslash = flags & 2;\n\n  len = STRLEN (text);\n  rlen = len + strlen (string) + 2;\n  ret = (char *)xmalloc (rlen);\n\n  for (p = string, r = ret; p && *p; )\n    {\n      if (*p == c)\n\t{\n\t  if (len)\n\t    {\n\t      ind = r - ret;\n\t      if (do_glob && (glob_pattern_p (text) || strchr (text, '\\\\')))\n\t\t{\n\t\t  t = quote_globbing_chars (text);\n\t\t  tlen = strlen (t);\n\t\t  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);\n\t\t  r = ret + ind;\t \n\t\t  strcpy (r, t);\n\t\t  r += tlen;\n\t\t  free (t);\n\t\t}\n\t      else\n\t\t{\n\t\t  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);\n\t\t  r = ret + ind;\t \n\t\t  strcpy (r, text);\n\t\t  r += len;\n\t\t}\n\t    }\n\t  p++;\n\t  continue;\n\t}\n\n      if (*p == '\\\\' && p[1] == c)\n\tp++;\n      else if (escape_backslash && *p == '\\\\' && p[1] == '\\\\')\n\tp++;\n\n      ind = r - ret;\n      RESIZE_MALLOCED_BUFFER (ret, ind, 2, rlen, rlen);\n      r = ret + ind;\t\t\t \n      *r++ = *p++;\n    }\n  *r = '\\0';\n\n  return ret;\n}\n\n#ifdef INCLUDE_UNUSED\n \nvoid\nstrip_leading (string)\n     char *string;\n{\n  char *start = string;\n\n  while (*string && (whitespace (*string) || *string == '\\n'))\n    string++;\n\n  if (string != start)\n    {\n      int len = strlen (string);\n      FASTCOPY (string, start, len);\n      start[len] = '\\0';\n    }\n}\n#endif\n\n \nvoid\nstrip_trailing (string, len, newlines_only)\n     char *string;\n     int len;\n     int newlines_only;\n{\n  while (len >= 0)\n    {\n      if ((newlines_only && string[len] == '\\n') ||\n\t  (!newlines_only && whitespace (string[len])))\n\tlen--;\n      else\n\tbreak;\n    }\n  string[len + 1] = '\\0';\n}\n\n \nvoid\nxbcopy (s, d, n)\n     char *s, *d;\n     int n;\n{\n  FASTCOPY (s, d, n);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}