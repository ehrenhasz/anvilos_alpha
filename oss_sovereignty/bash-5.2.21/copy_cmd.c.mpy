{
  "module_name": "copy_cmd.c",
  "hash_id": "fda9cd28bd072542e94ae63d8d2c82daa5421bc2d75031b6d75277ce99a758f5",
  "original_prompt": "Ingested from bash-5.2.21/copy_cmd.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"shell.h\"\n\nstatic PATTERN_LIST *copy_case_clause PARAMS((PATTERN_LIST *));\nstatic PATTERN_LIST *copy_case_clauses PARAMS((PATTERN_LIST *));\nstatic FOR_COM *copy_for_command PARAMS((FOR_COM *));\n#if defined (ARITH_FOR_COMMAND)\nstatic ARITH_FOR_COM *copy_arith_for_command PARAMS((ARITH_FOR_COM *));\n#endif\nstatic GROUP_COM *copy_group_command PARAMS((GROUP_COM *));\nstatic SUBSHELL_COM *copy_subshell_command PARAMS((SUBSHELL_COM *));\nstatic COPROC_COM *copy_coproc_command PARAMS((COPROC_COM *));\nstatic CASE_COM *copy_case_command PARAMS((CASE_COM *));\nstatic WHILE_COM *copy_while_command PARAMS((WHILE_COM *));\nstatic IF_COM *copy_if_command PARAMS((IF_COM *));\n#if defined (DPAREN_ARITHMETIC)\nstatic ARITH_COM *copy_arith_command PARAMS((ARITH_COM *));\n#endif\n#if defined (COND_COMMAND)\nstatic COND_COM *copy_cond_command PARAMS((COND_COM *));\n#endif\nstatic SIMPLE_COM *copy_simple_command PARAMS((SIMPLE_COM *));\n\nWORD_DESC *\ncopy_word (w)\n     WORD_DESC *w;\n{\n  WORD_DESC *new_word;\n\n  new_word = make_bare_word (w->word);\n  new_word->flags = w->flags;\n  return (new_word);\n}\n\n \nWORD_LIST *\ncopy_word_list (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *new_list, *tl;\n\n  for (new_list = tl = (WORD_LIST *)NULL; list; list = list->next)\n    {\n      if (new_list == 0)\n\tnew_list = tl = make_word_list (copy_word (list->word), new_list);\n      else\n\t{\n\t  tl->next = make_word_list (copy_word (list->word), (WORD_LIST *)NULL);\n\t  tl = tl->next;\n\t}\n    }\n\n  return (new_list);\n}\n\nstatic PATTERN_LIST *\ncopy_case_clause (clause)\n     PATTERN_LIST *clause;\n{\n  PATTERN_LIST *new_clause;\n\n  new_clause = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));\n  new_clause->patterns = copy_word_list (clause->patterns);\n  new_clause->action = copy_command (clause->action);\n  new_clause->flags = clause->flags;\n  return (new_clause);\n}\n\nstatic PATTERN_LIST *\ncopy_case_clauses (clauses)\n     PATTERN_LIST *clauses;\n{\n  PATTERN_LIST *new_list, *new_clause;\n\n  for (new_list = (PATTERN_LIST *)NULL; clauses; clauses = clauses->next)\n    {\n      new_clause = copy_case_clause (clauses);\n      new_clause->next = new_list;\n      new_list = new_clause;\n    }\n  return (REVERSE_LIST (new_list, PATTERN_LIST *));\n}\n\n \nREDIRECT *\ncopy_redirect (redirect)\n     REDIRECT *redirect;\n{\n  REDIRECT *new_redirect;\n\n  new_redirect = (REDIRECT *)xmalloc (sizeof (REDIRECT));\n#if 0\n  FASTCOPY ((char *)redirect, (char *)new_redirect, (sizeof (REDIRECT)));\n#else\n  *new_redirect = *redirect;\t \n#endif\n\n  if (redirect->rflags & REDIR_VARASSIGN)\n    new_redirect->redirector.filename = copy_word (redirect->redirector.filename);\n\n  switch (redirect->instruction)\n    {\n    case r_reading_until:\n    case r_deblank_reading_until:\n      new_redirect->here_doc_eof = redirect->here_doc_eof ? savestring (redirect->here_doc_eof) : 0;\n       \n    case r_reading_string:\n    case r_appending_to:\n    case r_output_direction:\n    case r_input_direction:\n    case r_inputa_direction:\n    case r_err_and_out:\n    case r_append_err_and_out:\n    case r_input_output:\n    case r_output_force:\n    case r_duplicating_input_word:\n    case r_duplicating_output_word:\n    case r_move_input_word:\n    case r_move_output_word:\n      new_redirect->redirectee.filename = copy_word (redirect->redirectee.filename);\n      break;\n    case r_duplicating_input:\n    case r_duplicating_output:\n    case r_move_input:\n    case r_move_output:\n    case r_close_this:\n      break;\n    }\n  return (new_redirect);\n}\n\nREDIRECT *\ncopy_redirects (list)\n     REDIRECT *list;\n{\n  REDIRECT *new_list, *temp;\n\n  for (new_list = (REDIRECT *)NULL; list; list = list->next)\n    {\n      temp = copy_redirect (list);\n      temp->next = new_list;\n      new_list = temp;\n    }\n  return (REVERSE_LIST (new_list, REDIRECT *));\n}\n\nstatic FOR_COM *\ncopy_for_command (com)\n     FOR_COM *com;\n{\n  FOR_COM *new_for;\n\n  new_for = (FOR_COM *)xmalloc (sizeof (FOR_COM));\n  new_for->flags = com->flags;\n  new_for->line = com->line;\n  new_for->name = copy_word (com->name);\n  new_for->map_list = copy_word_list (com->map_list);\n  new_for->action = copy_command (com->action);\n  return (new_for);\n}\n\n#if defined (ARITH_FOR_COMMAND)\nstatic ARITH_FOR_COM *\ncopy_arith_for_command (com)\n     ARITH_FOR_COM *com;\n{\n  ARITH_FOR_COM *new_arith_for;\n\n  new_arith_for = (ARITH_FOR_COM *)xmalloc (sizeof (ARITH_FOR_COM));\n  new_arith_for->flags = com->flags;\n  new_arith_for->line = com->line;\n  new_arith_for->init = copy_word_list (com->init);\n  new_arith_for->test = copy_word_list (com->test);\n  new_arith_for->step = copy_word_list (com->step);\n  new_arith_for->action = copy_command (com->action);\n  return (new_arith_for);\n}\n#endif  \n\nstatic GROUP_COM *\ncopy_group_command (com)\n     GROUP_COM *com;\n{\n  GROUP_COM *new_group;\n\n  new_group = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));\n  new_group->command = copy_command (com->command);\n  return (new_group);\n}\n\nstatic SUBSHELL_COM *\ncopy_subshell_command (com)\n     SUBSHELL_COM *com;\n{\n  SUBSHELL_COM *new_subshell;\n\n  new_subshell = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));\n  new_subshell->command = copy_command (com->command);\n  new_subshell->flags = com->flags;\n  new_subshell->line = com->line;\n  return (new_subshell);\n}\n\nstatic COPROC_COM *\ncopy_coproc_command (com)\n     COPROC_COM *com;\n{\n  COPROC_COM *new_coproc;\n\n  new_coproc = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));\n  new_coproc->name = savestring (com->name);\n  new_coproc->command = copy_command (com->command);\n  new_coproc->flags = com->flags;\n  return (new_coproc);\n}\n\nstatic CASE_COM *\ncopy_case_command (com)\n     CASE_COM *com;\n{\n  CASE_COM *new_case;\n\n  new_case = (CASE_COM *)xmalloc (sizeof (CASE_COM));\n  new_case->flags = com->flags;\n  new_case->line = com->line;\n  new_case->word = copy_word (com->word);\n  new_case->clauses = copy_case_clauses (com->clauses);\n  return (new_case);\n}\n\nstatic WHILE_COM *\ncopy_while_command (com)\n     WHILE_COM *com;\n{\n  WHILE_COM *new_while;\n\n  new_while = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));\n  new_while->flags = com->flags;\n  new_while->test = copy_command (com->test);\n  new_while->action = copy_command (com->action);\n  return (new_while);\n}\n\nstatic IF_COM *\ncopy_if_command (com)\n     IF_COM *com;\n{\n  IF_COM *new_if;\n\n  new_if = (IF_COM *)xmalloc (sizeof (IF_COM));\n  new_if->flags = com->flags;\n  new_if->test = copy_command (com->test);\n  new_if->true_case = copy_command (com->true_case);\n  new_if->false_case = com->false_case ? copy_command (com->false_case) : com->false_case;\n  return (new_if);\n}\n\n#if defined (DPAREN_ARITHMETIC)\nstatic ARITH_COM *\ncopy_arith_command (com)\n     ARITH_COM *com;\n{\n  ARITH_COM *new_arith;\n\n  new_arith = (ARITH_COM *)xmalloc (sizeof (ARITH_COM));\n  new_arith->flags = com->flags;\n  new_arith->exp = copy_word_list (com->exp);\n  new_arith->line = com->line;\n\n  return (new_arith);\n}\n#endif\n\n#if defined (COND_COMMAND)\nstatic COND_COM *\ncopy_cond_command (com)\n     COND_COM *com;\n{\n  COND_COM *new_cond;\n\n  new_cond = (COND_COM *)xmalloc (sizeof (COND_COM));\n  new_cond->flags = com->flags;\n  new_cond->line = com->line;\n  new_cond->type = com->type;\n  new_cond->op = com->op ? copy_word (com->op) : com->op;\n  new_cond->left = com->left ? copy_cond_command (com->left) : (COND_COM *)NULL;\n  new_cond->right = com->right ? copy_cond_command (com->right) : (COND_COM *)NULL;\n\n  return (new_cond);\n}\n#endif\n\nstatic SIMPLE_COM *\ncopy_simple_command (com)\n     SIMPLE_COM *com;\n{\n  SIMPLE_COM *new_simple;\n\n  new_simple = (SIMPLE_COM *)xmalloc (sizeof (SIMPLE_COM));\n  new_simple->flags = com->flags;\n  new_simple->words = copy_word_list (com->words);\n  new_simple->redirects = com->redirects ? copy_redirects (com->redirects) : (REDIRECT *)NULL;\n  new_simple->line = com->line;\n  return (new_simple);\n}\n\nFUNCTION_DEF *\ncopy_function_def_contents (old, new_def)\n     FUNCTION_DEF *old, *new_def;\n{\n  new_def->name = copy_word (old->name);\n  new_def->command = old->command ? copy_command (old->command) : old->command;\n  new_def->flags = old->flags;\n  new_def->line = old->line;\n  new_def->source_file = old->source_file ? savestring (old->source_file) : old->source_file;\n  return (new_def);\n}\n\nFUNCTION_DEF *\ncopy_function_def (com)\n     FUNCTION_DEF *com;\n{\n  FUNCTION_DEF *new_def;\n\n  new_def = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));\n  new_def = copy_function_def_contents (com, new_def);\n  return (new_def);\n}\n\n \nCOMMAND *\ncopy_command (command)\n     COMMAND *command;\n{\n  COMMAND *new_command;\n\n  if (command == NULL)\n    return (command);\n\n  new_command = (COMMAND *)xmalloc (sizeof (COMMAND));\n  FASTCOPY ((char *)command, (char *)new_command, sizeof (COMMAND));\n  new_command->flags = command->flags;\n  new_command->line = command->line;\n\n  if (command->redirects)\n    new_command->redirects = copy_redirects (command->redirects);\n\n  switch (command->type)\n    {\n      case cm_for:\n\tnew_command->value.For = copy_for_command (command->value.For);\n\tbreak;\n\n#if defined (ARITH_FOR_COMMAND)\n      case cm_arith_for:\n\tnew_command->value.ArithFor = copy_arith_for_command (command->value.ArithFor);\n\tbreak;\n#endif\n\n#if defined (SELECT_COMMAND)\n      case cm_select:\n\tnew_command->value.Select =\n\t  (SELECT_COM *)copy_for_command ((FOR_COM *)command->value.Select);\n\tbreak;\n#endif\n\n      case cm_group:\n\tnew_command->value.Group = copy_group_command (command->value.Group);\n\tbreak;\n\n      case cm_subshell:\n\tnew_command->value.Subshell = copy_subshell_command (command->value.Subshell);\n\tbreak;\n\n      case cm_coproc:\n\tnew_command->value.Coproc = copy_coproc_command (command->value.Coproc);\n\tbreak;\n\n      case cm_case:\n\tnew_command->value.Case = copy_case_command (command->value.Case);\n\tbreak;\n\n      case cm_until:\n      case cm_while:\n\tnew_command->value.While = copy_while_command (command->value.While);\n\tbreak;\n\n      case cm_if:\n\tnew_command->value.If = copy_if_command (command->value.If);\n\tbreak;\n\n#if defined (DPAREN_ARITHMETIC)\n      case cm_arith:\n\tnew_command->value.Arith = copy_arith_command (command->value.Arith);\n\tbreak;\n#endif\n\n#if defined (COND_COMMAND)\n      case cm_cond:\n\tnew_command->value.Cond = copy_cond_command (command->value.Cond);\n\tbreak;\n#endif\n\n      case cm_simple:\n\tnew_command->value.Simple = copy_simple_command (command->value.Simple);\n\tbreak;\n\n      case cm_connection:\n\t{\n\t  CONNECTION *new_connection;\n\n\t  new_connection = (CONNECTION *)xmalloc (sizeof (CONNECTION));\n\t  new_connection->connector = command->value.Connection->connector;\n\t  new_connection->first = copy_command (command->value.Connection->first);\n\t  new_connection->second = copy_command (command->value.Connection->second);\n\t  new_command->value.Connection = new_connection;\n\t  break;\n\t}\n\n      case cm_function_def:\n\tnew_command->value.Function_def = copy_function_def (command->value.Function_def);\n\tbreak;\n    }\n  return (new_command);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}