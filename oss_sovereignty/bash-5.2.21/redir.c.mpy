{
  "module_name": "redir.c",
  "hash_id": "b86124a86c0f2fc822d49de4d905b5b2e38390cc1737a4c69964ebeba59f112f",
  "original_prompt": "Ingested from bash-5.2.21/redir.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if !defined (__GNUC__) && !defined (HAVE_ALLOCA_H) && defined (_AIX)\n  #pragma alloca\n#endif  \n\n#include <stdio.h>\n#include \"bashtypes.h\"\n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"filecntl.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n#include \"memalloc.h\"\n\n#define NEED_FPURGE_DECL\n\n#include \"shell.h\"\n#include \"flags.h\"\n#include \"execute_cmd.h\"\n#include \"redir.h\"\n#include \"trap.h\"\n\n#if defined (BUFFERED_INPUT)\n#  include \"input.h\"\n#endif\n\n#include \"builtins/pipesize.h\"\n\n \n#if __FreeBSD__ && !defined (HEREDOC_PIPESIZE)\n#  define HEREDOC_PIPESIZE 4096\n#endif\n\n \n#ifndef PIPESIZE\n#  ifdef PIPE_BUF\n#    define PIPESIZE PIPE_BUF\n#  else\n#    define PIPESIZE 4096\n#  endif\n#endif\n\n#ifndef HEREDOC_PIPESIZE\n#  define HEREDOC_PIPESIZE PIPESIZE\n#endif\n\n#if defined (HEREDOC_PIPEMAX)\n#  if HEREDOC_PIPESIZE > HEREDOC_PIPEMAX\n#    define HEREDOC_PIPESIZE HEREDOC_PIPEMAX\n#  endif\n#endif\n\n#define SHELL_FD_BASE\t10\n\nint expanding_redir;\nint varassign_redir_autoclose = 0;\n\nextern REDIRECT *redirection_undo_list;\nextern REDIRECT *exec_redirection_undo_list;\n\n \nstatic void add_exec_redirect PARAMS((REDIRECT *));\nstatic int add_undo_redirect PARAMS((int, enum r_instruction, int));\nstatic int add_undo_close_redirect PARAMS((int));\nstatic int expandable_redirection_filename PARAMS((REDIRECT *));\nstatic int stdin_redirection PARAMS((enum r_instruction, int));\nstatic int undoablefd PARAMS((int));\nstatic int do_redirection_internal PARAMS((REDIRECT *, int, char **));\n\nstatic char *heredoc_expand PARAMS((WORD_DESC *, enum r_instruction, size_t *));\nstatic int heredoc_write PARAMS((int, char *, size_t));\nstatic int here_document_to_fd PARAMS((WORD_DESC *, enum r_instruction));\n\nstatic int redir_special_open PARAMS((int, char *, int, int, enum r_instruction));\nstatic int noclobber_open PARAMS((char *, int, int, enum r_instruction));\nstatic int redir_open PARAMS((char *, int, int, enum r_instruction));\n\nstatic int redir_varassign PARAMS((REDIRECT *, int));\nstatic int redir_varvalue PARAMS((REDIRECT *));\n\n \nstatic REDIRECTEE rd;\n\n \nstatic int heredoc_errno;\n\n#define REDIRECTION_ERROR(r, e, fd) \\\ndo { \\\n  if ((r) < 0) \\\n    { \\\n      if (fd >= 0) \\\n\tclose (fd); \\\n      set_exit_status (EXECUTION_FAILURE);\\\n      return ((e) == 0 ? EINVAL : (e));\\\n    } \\\n} while (0)\n\nvoid\nredirection_error (temp, error, fn)\n     REDIRECT *temp;\n     int error;\n     char *fn;\t\t \n{\n  char *filename, *allocname;\n  int oflags;\n\n  allocname = 0;\n  if ((temp->rflags & REDIR_VARASSIGN) && error < 0)\n    filename = allocname = savestring (temp->redirector.filename->word);\n  else if ((temp->rflags & REDIR_VARASSIGN) == 0 && temp->redirector.dest < 0)\n     \n    filename = _(\"file descriptor out of range\");\n#ifdef EBADF\n   \n  else if (error != NOCLOBBER_REDIRECT && temp->redirector.dest >= 0 && error == EBADF)\n    {\n       \n      switch (temp->instruction)\n        {\n        case r_duplicating_input:\n        case r_duplicating_output:\n        case r_move_input:\n        case r_move_output:\n\t  filename = allocname = itos (temp->redirectee.dest);\n\t  break;\n\tcase r_duplicating_input_word:\n\t  if (temp->redirector.dest == 0)\t \n\t    filename = temp->redirectee.filename->word;\t \n\t  else\n\t    filename = allocname = itos (temp->redirector.dest);\n\t  break;\n\tcase r_duplicating_output_word:\n\t  if (temp->redirector.dest == 1)\t \n\t    filename = temp->redirectee.filename->word;\t \n\t  else\n\t    filename = allocname = itos (temp->redirector.dest);\n\t  break;\n\tdefault:\n\t  filename = allocname = itos (temp->redirector.dest);\n\t  break;\n        }\n    }\n#endif\n  else if (fn)\n    filename = fn;\n  else if (expandable_redirection_filename (temp))\n    {\n      oflags = temp->redirectee.filename->flags;\n      if (posixly_correct && interactive_shell == 0)\n\ttemp->redirectee.filename->flags |= W_NOGLOB;\n      temp->redirectee.filename->flags |= W_NOCOMSUB;\n      filename = allocname = redirection_expand (temp->redirectee.filename);\n      temp->redirectee.filename->flags = oflags;\n      if (filename == 0)\n\tfilename = temp->redirectee.filename->word;\n    }\n  else if (temp->redirectee.dest < 0)\n    filename = _(\"file descriptor out of range\");\n  else\n    filename = allocname = itos (temp->redirectee.dest);\n\n  switch (error)\n    {\n    case AMBIGUOUS_REDIRECT:\n      internal_error (_(\"%s: ambiguous redirect\"), filename);\n      break;\n\n    case NOCLOBBER_REDIRECT:\n      internal_error (_(\"%s: cannot overwrite existing file\"), filename);\n      break;\n\n#if defined (RESTRICTED_SHELL)\n    case RESTRICTED_REDIRECT:\n      internal_error (_(\"%s: restricted: cannot redirect output\"), filename);\n      break;\n#endif  \n\n    case HEREDOC_REDIRECT:\n      internal_error (_(\"cannot create temp file for here-document: %s\"), strerror (heredoc_errno));\n      break;\n\n    case BADVAR_REDIRECT:\n      internal_error (_(\"%s: cannot assign fd to variable\"), filename);\n      break;\n\n    default:\n      internal_error (\"%s: %s\", filename, strerror (error));\n      break;\n    }\n\n  FREE (allocname);\n}\n\n \nint\ndo_redirections (list, flags)\n     REDIRECT *list;\n     int flags;\n{\n  int error;\n  REDIRECT *temp;\n  char *fn;\n\n  if (flags & RX_UNDOABLE)\n    {\n      if (redirection_undo_list)\n\t{\n\t  dispose_redirects (redirection_undo_list);\n\t  redirection_undo_list = (REDIRECT *)NULL;\n\t}\n      if (exec_redirection_undo_list)\n\tdispose_exec_redirects ();\n    }\n\n  for (temp = list; temp; temp = temp->next)\n    {\n      fn = 0;\n      error = do_redirection_internal (temp, flags, &fn);\n      if (error)\n\t{\n\t  redirection_error (temp, error, fn);\n\t  FREE (fn);\n\t  return (error);\n\t}\n      FREE (fn);\n    }\n  return (0);\n}\n\n \nstatic int\nexpandable_redirection_filename (redirect)\n     REDIRECT *redirect;\n{\n  switch (redirect->instruction)\n    {\n    case r_output_direction:\n    case r_appending_to:\n    case r_input_direction:\n    case r_inputa_direction:\n    case r_err_and_out:\n    case r_append_err_and_out:\n    case r_input_output:\n    case r_output_force:\n    case r_duplicating_input_word:\n    case r_duplicating_output_word:\n    case r_move_input_word:\n    case r_move_output_word:\n      return 1;\n\n    default:\n      return 0;\n    }\n}\n\n \nchar *\nredirection_expand (word)\n     WORD_DESC *word;\n{\n  char *result;\n  WORD_LIST *tlist1, *tlist2;\n  WORD_DESC *w;\n  int old;\n\n  w = copy_word (word);\n  if (posixly_correct)\n    w->flags |= W_NOSPLIT;\n\n  tlist1 = make_word_list (w, (WORD_LIST *)NULL);\n  expanding_redir = 1;\n   \n  sv_ifs (\"IFS\");\n  tlist2 = expand_words_no_vars (tlist1);\n  expanding_redir = 0;\n   \n  old = executing_builtin;\n  executing_builtin = 1;\n  sv_ifs (\"IFS\");\n  executing_builtin = old;\n  dispose_words (tlist1);\n\n  if (tlist2 == 0 || tlist2->next)\n    {\n       \n      if (tlist2)\n\tdispose_words (tlist2);\n      return ((char *)NULL);\n    }\n  result = string_list (tlist2);   \n  dispose_words (tlist2);\n  return (result);\n}\n\n \nstatic char *\nheredoc_expand (redirectee, ri, lenp)\n     WORD_DESC *redirectee;\n     enum r_instruction ri;\n     size_t *lenp;\n{\n  char *document;\n  size_t dlen;\n  int old;\n\n  if (redirectee->word == 0 || redirectee->word[0] == '\\0')\n    {\n      if (lenp)\n        *lenp = 0;\n      return (redirectee->word);\n    }\n\n   \n  if (ri != r_reading_string && (redirectee->flags & W_QUOTED))\n    {\n      if (lenp)\n        *lenp = STRLEN (redirectee->word);\n      return (redirectee->word);\n    }\n  \n  expanding_redir = 1;\n   \n  sv_ifs (\"IFS\");\n  document = (ri == r_reading_string) ? expand_assignment_string_to_string (redirectee->word, 0)\n  \t\t\t\t      : expand_string_to_string (redirectee->word, Q_HERE_DOCUMENT);\n  expanding_redir = 0;\n   \n  old = executing_builtin;\n  executing_builtin = 1;\n  sv_ifs (\"IFS\");\n  executing_builtin = old;\n\n  dlen = STRLEN (document);\n   \n  if (ri == r_reading_string)\n    {\n      document = xrealloc (document, dlen + 2);\n      document[dlen++] = '\\n';\n      document[dlen] = '\\0';\n    }\n  if (lenp)\n    *lenp = dlen;    \n\n  return document;\n}\n\n \nstatic int\nheredoc_write (fd, heredoc, herelen)\n     int fd;\n     char *heredoc;\n     size_t herelen;\n{\n  ssize_t nw;\n  int e;\n\n  errno = 0;\n  nw = write (fd, heredoc, herelen);\n  e = errno;\n  if (nw != herelen)\n    {\n      if (e == 0)\n\te = ENOSPC;\n      return e;\n    }\n  return 0;\n}\n\n \nstatic int\nhere_document_to_fd (redirectee, ri)\n     WORD_DESC *redirectee;\n     enum r_instruction ri;\n{\n  char *filename;\n  int r, fd, fd2, herepipe[2];\n  char *document;\n  size_t document_len;\n#if HEREDOC_PARANOID\n  struct stat st1, st2;\n#endif\n\n   \n  document = heredoc_expand (redirectee, ri, &document_len);\n\n   \n  if (document_len == 0)\n    {\n      fd = open (\"/dev/null\", O_RDONLY);\n      r = errno;\n      if (document != redirectee->word)\n\tFREE (document);\n      errno = r;\n      return fd;\n    }\n\n  if (shell_compatibility_level <= 50)\n    goto use_tempfile;\n\n#if HEREDOC_PIPESIZE\n   \n  if (document_len <= HEREDOC_PIPESIZE)\n    {\n      if (pipe (herepipe) < 0)\n\t{\n\t   \n\t  r = errno;\n\t  if (document != redirectee->word)\n\t    free (document);\n\t  errno = r;\n\t  return (-1);\n\t}\n\n#if defined (F_GETPIPE_SZ)\n      if (fcntl (herepipe[1], F_GETPIPE_SZ, 0) < document_len)\n\tgoto use_tempfile;\n#endif\n\n      r = heredoc_write (herepipe[1], document, document_len);\n      if (document != redirectee->word)\n\tfree (document);\n      close (herepipe[1]);\n      if (r)\t\t\t \n\t{\n\t  close (herepipe[0]);\n\t  errno = r;\n\t  return (-1);\n\t}\n      return (herepipe[0]);\n    }\n#endif\n\nuse_tempfile:\n\n  fd = sh_mktmpfd (\"sh-thd\", MT_USERANDOM|MT_USETMPDIR, &filename);\n\n   \n  if (fd < 0)\n    {\n      r = errno;\n      FREE (filename);\n      if (document != redirectee->word)\n\tFREE (document);\n      errno = r;\n      return (fd);\n    }\n\n  fchmod (fd, S_IRUSR | S_IWUSR);\n  SET_CLOSE_ON_EXEC (fd);\n\n  errno = r = 0;\t\t \n  r = heredoc_write (fd, document, document_len);\n  if (document != redirectee->word)\n    FREE (document);\n\n  if (r)\n    {\n      close (fd);\n      unlink (filename);\n      free (filename);\n      errno = r;\n      return (-1);\n    }\n\n   \n   \n  fd2 = open (filename, O_RDONLY|O_BINARY, 0600);\n\n  if (fd2 < 0)\n    {\n      r = errno;\n      unlink (filename);\n      free (filename);\n      close (fd);\n      errno = r;\n      return -1;\n    }\n\n#if HEREDOC_PARANOID\n   \n  if (fstat (fd, &st1) < 0 || S_ISREG (st1.st_mode) == 0 ||\n      fstat (fd2, &st2) < 0 || S_ISREG (st2.st_mode) == 0 ||\n      same_file (filename, filename, &st1, &st2) == 0)\n    {\n      unlink (filename);\n      free (filename);\n      close (fd);\n      close (fd2);\n      errno = EEXIST;\n      return -1;\n    }\n#endif\n\n  close (fd);\n  if (unlink (filename) < 0)\n    {\n      r = errno;\n      close (fd2);\n      free (filename);\n      errno = r;\n      return (-1);\n    }\n\n  free (filename);\n\n  fchmod (fd2, S_IRUSR);\n  return (fd2);\n}\n\n#define RF_DEVFD\t1\n#define RF_DEVSTDERR\t2\n#define RF_DEVSTDIN\t3\n#define RF_DEVSTDOUT\t4\n#define RF_DEVTCP\t5\n#define RF_DEVUDP\t6\n\n \nstatic STRING_INT_ALIST _redir_special_filenames[] = {\n#if !defined (HAVE_DEV_FD)\n  { \"/dev/fd/[0-9]*\", RF_DEVFD },\n#endif\n#if !defined (HAVE_DEV_STDIN)\n  { \"/dev/stderr\", RF_DEVSTDERR },\n  { \"/dev/stdin\", RF_DEVSTDIN },\n  { \"/dev/stdout\", RF_DEVSTDOUT },\n#endif\n#if defined (NETWORK_REDIRECTIONS)\n  { \"/dev/tcp/*/*\", RF_DEVTCP },\n  { \"/dev/udp/*/*\", RF_DEVUDP },\n#endif\n  { (char *)NULL, -1 }\n};\n\nstatic int\nredir_special_open (spec, filename, flags, mode, ri)\n     int spec;\n     char *filename;\n     int flags, mode;\n     enum r_instruction ri;\n{\n  int fd;\n#if !defined (HAVE_DEV_FD)\n  intmax_t lfd;\n#endif\n\n  fd = -1;\n  switch (spec)\n    {\n#if !defined (HAVE_DEV_FD)\n    case RF_DEVFD:\n      if (all_digits (filename+8) && legal_number (filename+8, &lfd) && lfd == (int)lfd)\n\t{\n\t  fd = lfd;\n\t  fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);\n\t}\n      else\n\tfd = AMBIGUOUS_REDIRECT;\n      break;\n#endif\n\n#if !defined (HAVE_DEV_STDIN)\n    case RF_DEVSTDIN:\n      fd = fcntl (0, F_DUPFD, SHELL_FD_BASE);\n      break;\n    case RF_DEVSTDOUT:\n      fd = fcntl (1, F_DUPFD, SHELL_FD_BASE);\n      break;\n    case RF_DEVSTDERR:\n      fd = fcntl (2, F_DUPFD, SHELL_FD_BASE);\n      break;\n#endif\n\n#if defined (NETWORK_REDIRECTIONS)\n    case RF_DEVTCP:\n    case RF_DEVUDP:\n#if defined (RESTRICTED_SHELL)\n      if (restricted)\n\treturn (RESTRICTED_REDIRECT);\n#endif\n#if defined (HAVE_NETWORK)\n      fd = netopen (filename);\n#else\n      internal_warning (_(\"/dev/(tcp|udp)/host/port not supported without networking\"));\n      fd = open (filename, flags, mode);\n#endif\n      break;\n#endif  \n    }\n\n  return fd;\n}\n      \n \nstatic int\nnoclobber_open (filename, flags, mode, ri)\n     char *filename;\n     int flags, mode;\n     enum r_instruction ri;\n{\n  int r, fd;\n  struct stat finfo, finfo2;\n\n   \n  r = stat (filename, &finfo);\n  if (r == 0 && (S_ISREG (finfo.st_mode)))\n    return (NOCLOBBER_REDIRECT);\n\n   \n  flags &= ~O_TRUNC;\n  if (r != 0)\n    {\n      fd = open (filename, flags|O_EXCL, mode);\n      return ((fd < 0 && errno == EEXIST) ? NOCLOBBER_REDIRECT : fd);\n    }\n  fd = open (filename, flags, mode);\n\n   \n  if (fd < 0)\n    return (errno == EEXIST ? NOCLOBBER_REDIRECT : fd);\n\n   \n\n   \n  if ((fstat (fd, &finfo2) == 0) && (S_ISREG (finfo2.st_mode) == 0) &&\n      r == 0 && (S_ISREG (finfo.st_mode) == 0) &&\n      same_file (filename, filename, &finfo, &finfo2))\n    return fd;\n\n   \n  close (fd);  \n  errno = EEXIST;\n  return (NOCLOBBER_REDIRECT);\n}\n\nstatic int\nredir_open (filename, flags, mode, ri)\n     char *filename;\n     int flags, mode;\n     enum r_instruction ri;\n{\n  int fd, r, e;\n\n  r = find_string_in_alist (filename, _redir_special_filenames, 1);\n  if (r >= 0)\n    return (redir_special_open (r, filename, flags, mode, ri));\n\n   \n  if (noclobber && CLOBBERING_REDIRECT (ri))\n    {\n      fd = noclobber_open (filename, flags, mode, ri);\n      if (fd == NOCLOBBER_REDIRECT)\n\treturn (NOCLOBBER_REDIRECT);\n    }\n  else\n    {\n      do\n\t{\n\t  fd = open (filename, flags, mode);\n\t  e = errno;\n\t  if (fd < 0 && e == EINTR)\n\t    {\n\t      QUIT;\n\t      run_pending_traps ();\n\t    }\n\t  errno = e;\n\t}\n      while (fd < 0 && errno == EINTR);\n\n#if defined (AFS)\n      if ((fd < 0) && (errno == EACCES))\n\t{\n\t  fd = open (filename, flags & ~O_CREAT, mode);\n\t  errno = EACCES;\t \n\t}\n#endif  \n    }\n\n  return fd;\n}\n\nstatic int\nundoablefd (fd)\n     int fd;\n{\n  int clexec;\n\n  clexec = fcntl (fd, F_GETFD, 0);\n  if (clexec == -1 || (fd >= SHELL_FD_BASE && clexec == 1))\n    return 0;\n  return 1;\n}\n\n \nstatic int\ndo_redirection_internal (redirect, flags, fnp)\n     REDIRECT *redirect;\n     int flags;\n     char **fnp;\n{\n  WORD_DESC *redirectee;\n  int redir_fd, fd, redirector, r, oflags;\n  intmax_t lfd;\n  char *redirectee_word;\n  enum r_instruction ri;\n  REDIRECT *new_redirect;\n  REDIRECTEE sd;\n\n  redirectee = redirect->redirectee.filename;\n  redir_fd = redirect->redirectee.dest;\n  redirector = redirect->redirector.dest;\n  ri = redirect->instruction;\n\n  if (redirect->flags & RX_INTERNAL)\n    flags |= RX_INTERNAL;\n\n  if (TRANSLATE_REDIRECT (ri))\n    {\n       \n      redirectee_word = redirection_expand (redirectee);\n\n       \n      if ((ri == r_move_input_word || ri == r_move_output_word) && redirectee_word == 0)\n\t{\n\t  sd = redirect->redirector;\n\t  rd.dest = 0;\n\t  new_redirect = make_redirection (sd, r_close_this, rd, 0);\n\t}\n      else if (redirectee_word == 0)\n\treturn (AMBIGUOUS_REDIRECT);\n      else if (redirectee_word[0] == '-' && redirectee_word[1] == '\\0')\n\t{\n\t  sd = redirect->redirector;\n\t  rd.dest = 0;\n\t  new_redirect = make_redirection (sd, r_close_this, rd, 0);\n\t}\n      else if (all_digits (redirectee_word))\n\t{\n\t  sd = redirect->redirector;\n\t  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)\n\t    rd.dest = lfd;\n\t  else\n\t    rd.dest = -1;\t \n\t  switch (ri)\n\t    {\n\t    case r_duplicating_input_word:\n\t      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);\n\t      break;\n\t    case r_duplicating_output_word:\n\t      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);\n\t      break;\n\t    case r_move_input_word:\n\t      new_redirect = make_redirection (sd, r_move_input, rd, 0);\n\t      break;\n\t    case r_move_output_word:\n\t      new_redirect = make_redirection (sd, r_move_output, rd, 0);\n\t      break;\n\t    default:\n\t      break;\t \n\t    }\n\t}\n      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)\n\t{\n\t  sd = redirect->redirector;\n\t  rd.filename = make_bare_word (redirectee_word);\n\t  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);\n\t}\n      else\n\t{\n\t  free (redirectee_word);\n\t  return (AMBIGUOUS_REDIRECT);\n\t}\n\n      free (redirectee_word);\n\n       \n      if (new_redirect->instruction == r_err_and_out)\n\t{\n\t  char *alloca_hack;\n\n\t   \n\t  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));\n\t  xbcopy ((char *)new_redirect->redirectee.filename,\n\t\t (char *)redirectee, sizeof (WORD_DESC));\n\n\t  alloca_hack = (char *)\n\t    alloca (1 + strlen (new_redirect->redirectee.filename->word));\n\t  redirectee->word = alloca_hack;\n\t  strcpy (redirectee->word, new_redirect->redirectee.filename->word);\n\t}\n      else\n\t \n\tredirectee = new_redirect->redirectee.filename;\n\n      redir_fd = new_redirect->redirectee.dest;\n      redirector = new_redirect->redirector.dest;\n      ri = new_redirect->instruction;\n\n       \n      redirect->flags = new_redirect->flags;\n      dispose_redirects (new_redirect);\n    }\n\n  switch (ri)\n    {\n    case r_output_direction:\n    case r_appending_to:\n    case r_input_direction:\n    case r_inputa_direction:\n    case r_err_and_out:\t\t \n    case r_append_err_and_out:\t \n    case r_input_output:\n    case r_output_force:\n      if (posixly_correct && interactive_shell == 0)\n\t{\n\t  oflags = redirectee->flags;\n\t  redirectee->flags |= W_NOGLOB;\n\t}\n      redirectee_word = redirection_expand (redirectee);\n      if (posixly_correct && interactive_shell == 0)\n\tredirectee->flags = oflags;\n\n      if (redirectee_word == 0)\n\treturn (AMBIGUOUS_REDIRECT);\n\n#if defined (RESTRICTED_SHELL)\n      if (restricted && (WRITE_REDIRECT (ri)))\n\t{\n\t  free (redirectee_word);\n\t  return (RESTRICTED_REDIRECT);\n\t}\n#endif  \n\n      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);\n      if (fnp)\n\t*fnp = redirectee_word;\n      else\n\tfree (redirectee_word);\n\n      if (fd == NOCLOBBER_REDIRECT || fd == RESTRICTED_REDIRECT)\n\treturn (fd);\n\n      if (fd < 0)\n\treturn (errno);\n\n      if (flags & RX_ACTIVE)\n\t{\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);\t\t \n\t      r = errno;\n\t      if (redirector < 0)\n\t\tsys_error (_(\"redirection error: cannot duplicate fd\"));\n\t      REDIRECTION_ERROR (redirector, r, fd);\n\t    }\n\n\t  if ((flags & RX_UNDOABLE) && ((redirect->rflags & REDIR_VARASSIGN) == 0 || varassign_redir_autoclose))\n\t    {\n\t       \t\t \n\t      if (fd != redirector && (redirect->rflags & REDIR_VARASSIGN) && varassign_redir_autoclose)\n\t\tr = add_undo_close_redirect (redirector);\t      \n\t      else if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))\n\t\tr = add_undo_redirect (redirector, ri, -1);\n\t      else\n\t\tr = add_undo_close_redirect (redirector);\n\t      REDIRECTION_ERROR (r, errno, fd);\n\t    }\n\n#if defined (BUFFERED_INPUT)\n\t   \n\t  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)\n\t    check_bash_input (redirector);\n#endif\n\n\t   \n\t  if (redirector == 1 && fileno (stdout) == redirector)\n\t    {\n\t      fflush (stdout);\n\t      fpurge (stdout);\n\t    }\n\t  else if (redirector == 2 && fileno (stderr) == redirector)\n\t    {\n\t      fflush (stderr);\n\t      fpurge (stderr);\n\t    }\n\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      if ((r = redir_varassign (redirect, redirector)) < 0)\n\t\t{\n\t\t  close (redirector);\n\t\t  close (fd);\n\t\t  return (r);\t \n\t\t}\n\t    }\n\t  else if ((fd != redirector) && (dup2 (fd, redirector) < 0))\n\t    {\n\t      close (fd);\t \n\t      return (errno);\n\t    }\n\n#if defined (BUFFERED_INPUT)\n\t   \n\t  if (ri == r_input_direction || ri == r_input_output)\n\t    duplicate_buffered_stream (fd, redirector);\n#endif  \n\n\t   \n\t  if ((flags & RX_CLEXEC) && (redirector > 2))\n\t    SET_CLOSE_ON_EXEC (redirector);\n\t}\n\n      if (fd != redirector)\n\t{\n#if defined (BUFFERED_INPUT)\n\t  if (INPUT_REDIRECT (ri))\n\t    close_buffered_fd (fd);\n\t  else\n#endif  \n\t    close (fd);\t\t \n\t}\n\n       \n      if (ri == r_err_and_out || ri == r_append_err_and_out)\n\t{\n\t  if (flags & RX_ACTIVE)\n\t    {\n\t      if (flags & RX_UNDOABLE)\n\t\tadd_undo_redirect (2, ri, -1);\n\t      if (dup2 (1, 2) < 0)\n\t\treturn (errno);\n\t    }\n\t}\n      break;\n\n    case r_reading_until:\n    case r_deblank_reading_until:\n    case r_reading_string:\n       \n      if (redirectee)\n\t{\n\t  fd = here_document_to_fd (redirectee, ri);\n\n\t  if (fd < 0)\n\t    {\n\t      heredoc_errno = errno;\n\t      return (HEREDOC_REDIRECT);\n\t    }\n\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);\t\t \n\t      r = errno;\n\t      if (redirector < 0)\n\t\tsys_error (_(\"redirection error: cannot duplicate fd\"));\n\t      REDIRECTION_ERROR (redirector, r, fd);\n\t    }\n\n\t  if (flags & RX_ACTIVE)\n\t    {\n\t      if ((flags & RX_UNDOABLE) && ((redirect->rflags & REDIR_VARASSIGN) == 0 || varassign_redir_autoclose))\n\t        {\n\t\t   \n\t\t  if (fd != redirector && (redirect->rflags & REDIR_VARASSIGN) && varassign_redir_autoclose)\n\t\t    r = add_undo_close_redirect (redirector);\t      \n\t\t  else if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))\n\t\t    r = add_undo_redirect (redirector, ri, -1);\n\t\t  else\n\t\t    r = add_undo_close_redirect (redirector);\n\t\t  REDIRECTION_ERROR (r, errno, fd);\n\t        }\n\n#if defined (BUFFERED_INPUT)\n\t      check_bash_input (redirector);\n#endif\n\t      if (redirect->rflags & REDIR_VARASSIGN)\n\t\t{\n\t\t  if ((r = redir_varassign (redirect, redirector)) < 0)\n\t\t    {\n\t\t      close (redirector);\n\t\t      close (fd);\n\t\t      return (r);\t \n\t\t    }\n\t\t}\n\t      else if (fd != redirector && dup2 (fd, redirector) < 0)\n\t\t{\n\t\t  r = errno;\n\t\t  close (fd);\n\t\t  return (r);\n\t\t}\n\n#if defined (BUFFERED_INPUT)\n\t      duplicate_buffered_stream (fd, redirector);\n#endif\n\n\t      if ((flags & RX_CLEXEC) && (redirector > 2))\n\t\tSET_CLOSE_ON_EXEC (redirector);\n\t    }\n\n\t  if (fd != redirector)\n#if defined (BUFFERED_INPUT)\n\t    close_buffered_fd (fd);\n#else\n\t    close (fd);\n#endif\n\t}\n      break;\n\n    case r_duplicating_input:\n    case r_duplicating_output:\n    case r_move_input:\n    case r_move_output:\n      if ((flags & RX_ACTIVE) && (redirect->rflags & REDIR_VARASSIGN))\n        {\n\t  redirector = fcntl (redir_fd, F_DUPFD, SHELL_FD_BASE);\t\t \n\t  r = errno;\n\t  if (redirector < 0)\n\t    sys_error (_(\"redirection error: cannot duplicate fd\"));\n\t  REDIRECTION_ERROR (redirector, r, -1);\n        }\n\n      if ((flags & RX_ACTIVE) && (redir_fd != redirector))\n\t{\n\t  if ((flags & RX_UNDOABLE) && ((redirect->rflags & REDIR_VARASSIGN) == 0 || varassign_redir_autoclose))\n\t    {\n\t       \n\t      if ((redirect->rflags & REDIR_VARASSIGN) && varassign_redir_autoclose)\n\t\tr = add_undo_close_redirect (redirector);\t      \n\t      else if (fcntl (redirector, F_GETFD, 0) != -1)\n\t\tr = add_undo_redirect (redirector, ri, redir_fd);\n\t      else\n\t\tr = add_undo_close_redirect (redirector);\n\t      REDIRECTION_ERROR (r, errno, -1);\n\t    }\n\t  if ((flags & RX_UNDOABLE) && (ri == r_move_input || ri == r_move_output))\n\t    {\n\t       \n\t      if (fcntl (redirector, F_GETFD, 0) != -1)\n\t\t{\n\t\t  r = add_undo_redirect (redir_fd, r_close_this, -1);\n\t\t  REDIRECTION_ERROR (r, errno, -1);\n\t\t}\n\t    }\n#if defined (BUFFERED_INPUT)\n\t   \n\t  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)\n\t    check_bash_input (redirector);\n#endif\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      if ((r = redir_varassign (redirect, redirector)) < 0)\n\t\t{\n\t\t  close (redirector);\n\t\t  return (r);\t \n\t\t}\n\t    }\n\t   \n\t  else if (dup2 (redir_fd, redirector) < 0)\n\t    return (errno);\n\n#if defined (BUFFERED_INPUT)\n\t  if (ri == r_duplicating_input || ri == r_move_input)\n\t    duplicate_buffered_stream (redir_fd, redirector);\n#endif  \n\n\t   \n\t   \n#if 0\n\t  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || redir_fd < 2 || (flags & RX_CLEXEC)) &&\n\t       (redirector > 2))\n#else\n\t  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || (redir_fd < 2 && (flags & RX_INTERNAL)) || (flags & RX_CLEXEC)) &&\n\t       (redirector > 2))\n#endif\n\t    SET_CLOSE_ON_EXEC (redirector);\n\n\t   \n\t  if ((redirect->flags & RX_INTERNAL) && (redirect->flags & RX_SAVCLEXEC) && redirector >= 3 && (redir_fd >= SHELL_FD_BASE || (redirect->flags & RX_SAVEFD)))\n\t    SET_OPEN_ON_EXEC (redirector);\n\t    \n\t   \n\t  if (ri == r_move_input || ri == r_move_output)\n\t    {\n\t      xtrace_fdchk (redir_fd);\n\n\t      close (redir_fd);\n#if defined (COPROCESS_SUPPORT)\n\t      coproc_fdchk (redir_fd);\t \n#endif\n\t    }\n\t}\n      break;\n\n    case r_close_this:\n      if (flags & RX_ACTIVE)\n\t{\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      redirector = redir_varvalue (redirect);\n\t      if (redirector < 0)\n\t\treturn AMBIGUOUS_REDIRECT;\n\t    }\n\n\t  r = 0;\n\t  if (flags & RX_UNDOABLE)\n\t    {\n\t      if (fcntl (redirector, F_GETFD, 0) != -1)\n\t\tr = add_undo_redirect (redirector, ri, -1);\n\t      else\n\t\tr = add_undo_close_redirect (redirector);\n\t      REDIRECTION_ERROR (r, errno, redirector);\n\t    }\n\n#if defined (COPROCESS_SUPPORT)\n\t  coproc_fdchk (redirector);\n#endif\n\t  xtrace_fdchk (redirector);\n\n#if defined (BUFFERED_INPUT)\n\t   \n\t  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)\n\t    check_bash_input (redirector);\n\t  r = close_buffered_fd (redirector);\n#else  \n\t  r = close (redirector);\n#endif  \n\n\t  if (r < 0 && (flags & RX_INTERNAL) && (errno == EIO || errno == ENOSPC))\n\t    REDIRECTION_ERROR (r, errno, -1);\n\t}\n      break;\n\n    case r_duplicating_input_word:\n    case r_duplicating_output_word:\n    case r_move_input_word:\n    case r_move_output_word:\n      break;\n    }\n  return (0);\n}\n\n \nstatic int\nadd_undo_redirect (fd, ri, fdbase)\n     int fd;\n     enum r_instruction ri;\n     int fdbase;\n{\n  int new_fd, clexec_flag, savefd_flag;\n  REDIRECT *new_redirect, *closer, *dummy_redirect;\n  REDIRECTEE sd;\n\n  savefd_flag = 0;\n  new_fd = fcntl (fd, F_DUPFD, (fdbase < SHELL_FD_BASE) ? SHELL_FD_BASE : fdbase+1);\n  if (new_fd < 0)\n    new_fd = fcntl (fd, F_DUPFD, SHELL_FD_BASE);\n  if (new_fd < 0)\n    {\n      new_fd = fcntl (fd, F_DUPFD, 0);\n      savefd_flag = 1;\n    }\n\n  if (new_fd < 0)\n    {\n      sys_error (_(\"redirection error: cannot duplicate fd\"));\n      return (-1);\n    }\n\n  clexec_flag = fcntl (fd, F_GETFD, 0);\n\n  sd.dest = new_fd;\n  rd.dest = 0;\n  closer = make_redirection (sd, r_close_this, rd, 0);\n  closer->flags |= RX_INTERNAL;\n  dummy_redirect = copy_redirects (closer);\n\n  sd.dest = fd;\n  rd.dest = new_fd;\n  if (fd == 0)\n    new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);\n  else\n    new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);\n  new_redirect->flags |= RX_INTERNAL;\n  if (savefd_flag)\n    new_redirect->flags |= RX_SAVEFD;\n  if (clexec_flag == 0 && fd >= 3 && (new_fd >= SHELL_FD_BASE || savefd_flag))\n    new_redirect->flags |= RX_SAVCLEXEC;\n  new_redirect->next = closer;\n\n  closer->next = redirection_undo_list;\n  redirection_undo_list = new_redirect;\n\n   \n  add_exec_redirect (dummy_redirect);\n\n   \n  if (fd >= SHELL_FD_BASE && ri != r_close_this && clexec_flag)\n    {\n      sd.dest = fd;\n      rd.dest = new_fd;\n      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);\n      new_redirect->flags |= RX_INTERNAL;\n\n      add_exec_redirect (new_redirect);\n    }\n\n   \n  if (clexec_flag || fd < 3)\n    SET_CLOSE_ON_EXEC (new_fd);\n  else if (redirection_undo_list->flags & RX_SAVCLEXEC)\n    SET_CLOSE_ON_EXEC (new_fd);\n\n  return (0);\n}\n\n \nstatic int\nadd_undo_close_redirect (fd)\n     int fd;\n{\n  REDIRECT *closer;\n  REDIRECTEE sd;\n\n  sd.dest = fd;\n  rd.dest = 0;\n  closer = make_redirection (sd, r_close_this, rd, 0);\n  closer->flags |= RX_INTERNAL;\n  closer->next = redirection_undo_list;\n  redirection_undo_list = closer;\n\n  return 0;\n}\n\nstatic void\nadd_exec_redirect (dummy_redirect)\n     REDIRECT *dummy_redirect;\n{\n  dummy_redirect->next = exec_redirection_undo_list;\n  exec_redirection_undo_list = dummy_redirect;\n}\n\n \nstatic int\nstdin_redirection (ri, redirector)\n     enum r_instruction ri;\n     int redirector;\n{\n  switch (ri)\n    {\n    case r_input_direction:\n    case r_inputa_direction:\n    case r_input_output:\n    case r_reading_until:\n    case r_deblank_reading_until:\n    case r_reading_string:\n      return (1);\n    case r_duplicating_input:\n    case r_duplicating_input_word:\n    case r_close_this:\n      return (redirector == 0);\n    case r_output_direction:\n    case r_appending_to:\n    case r_duplicating_output:\n    case r_err_and_out:\n    case r_append_err_and_out:\n    case r_output_force:\n    case r_duplicating_output_word:\n    case r_move_input:\n    case r_move_output:\n    case r_move_input_word:\n    case r_move_output_word:\n      return (0);\n    }\n  return (0);\n}\n\n \nint\nstdin_redirects (redirs)\n     REDIRECT *redirs;\n{\n  REDIRECT *rp;\n  int n;\n\n  for (n = 0, rp = redirs; rp; rp = rp->next)\n    if ((rp->rflags & REDIR_VARASSIGN) == 0)\n      n += stdin_redirection (rp->instruction, rp->redirector.dest);\n  return n;\n}\n \nstatic int\nredir_varassign (redir, fd)\n     REDIRECT *redir;\n     int fd;\n{\n  WORD_DESC *w;\n  SHELL_VAR *v;\n\n  w = redir->redirector.filename;\n  v = bind_var_to_int (w->word, fd, 0);\n  if (v == 0 || readonly_p (v) || noassign_p (v))\n    return BADVAR_REDIRECT;\n\n  stupidly_hack_special_variables (w->word);\n  return 0;\n}\n\n \nstatic int\nredir_varvalue (redir)\n     REDIRECT *redir;\n{\n  SHELL_VAR *v;\n  char *val, *w;\n  intmax_t vmax;\n  int i;\n#if defined (ARRAY_VARS)\n  char *sub;\n  int len, vr;\n#endif\n\n  w = redir->redirector.filename->word;\t\t \n   \n#if defined (ARRAY_VARS)\n  if (vr = valid_array_reference (w, 0))\n    {\n      v = array_variable_part (w, 0, &sub, &len);\n    }\n  else\n#endif\n    {\n      v = find_variable (w);\n#if defined (ARRAY_VARS)\n      if (v == 0)\n\t{\n\t  v = find_variable_last_nameref (w, 0);\n\t  if (v && nameref_p (v))\n\t    {\n\t      w = nameref_cell (v);\n\t      if (vr = valid_array_reference (w, 0))\n\t\tv = array_variable_part (w, 0, &sub, &len);\n\t      else\n\t        v = find_variable (w);\n\t    }\n\t}\n#endif\n    }\n\t\n  if (v == 0 || invisible_p (v))\n    return -1;\n\n#if defined (ARRAY_VARS)\n   \n  if (vr && (array_p (v) || assoc_p (v)))\n    val = get_array_value (w, 0, (array_eltstate_t *)NULL);\n  else\n#endif\n  val = get_variable_value (v);\n  if (val == 0 || *val == 0)\n    return -1;\n\n  if (legal_number (val, &vmax) < 0)\n    return -1;\n\n  i = vmax;\t \n  return i;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}