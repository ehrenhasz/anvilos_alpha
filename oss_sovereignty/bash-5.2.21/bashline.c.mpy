{
  "module_name": "bashline.c",
  "hash_id": "212083e81a2f4d34429dd7965de426376a84dc7bf4826b1a17d02a48e9af0971",
  "original_prompt": "Ingested from bash-5.2.21/bashline.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (READLINE)\n\n#include \"bashtypes.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_GRP_H)\n#  include <grp.h>\n#endif\n\n#if defined (HAVE_NETDB_H)\n#  include <netdb.h>\n#endif\n\n#include <signal.h>\n\n#include <stdio.h>\n#include \"chartypes.h\"\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"input.h\"\n#include \"parser.h\"\n#include \"builtins.h\"\n#include \"bashhist.h\"\n#include \"bashline.h\"\n#include \"execute_cmd.h\"\n#include \"findcmd.h\"\n#include \"pathexp.h\"\n#include \"shmbutil.h\"\n#include \"trap.h\"\n#include \"flags.h\"\n#include \"timer.h\"\n\n#if defined (HAVE_MBSTR_H) && defined (HAVE_MBSCHR)\n#  include <mbstr.h>\t\t \n#endif\n\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\t\t \n\n#include <readline/rlconf.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n#include <readline/rlmbutil.h>\n\n#include <glob/glob.h>\n\n#if defined (ALIAS)\n#  include \"alias.h\"\n#endif\n\n#if defined (PROGRAMMABLE_COMPLETION)\n#  include \"pcomplete.h\"\n#endif\n\n \n#ifndef EMACS_EDITING_MODE\n#  define NO_EDITING_MODE\t-1\n#  define EMACS_EDITING_MODE\t 1\n#  define VI_EDITING_MODE\t 0\n#endif\n\n \n#ifndef FUNCTION_TO_KEYMAP\n\n#if defined (CRAY)\n#  define FUNCTION_TO_KEYMAP(map, key)\t(Keymap)((int)map[key].function)\n#  define KEYMAP_TO_FUNCTION(data)\t(rl_command_func_t *)((int)(data))\n#else\n#  define FUNCTION_TO_KEYMAP(map, key)\t(Keymap)(map[key].function)\n#  define KEYMAP_TO_FUNCTION(data)\t(rl_command_func_t *)(data)\n#endif\n\n#endif\n\n#define RL_BOOLEAN_VARIABLE_VALUE(s)\t((s)[0] == 'o' && (s)[1] == 'n' && (s)[2] == '\\0')\n\n#if defined (BRACE_COMPLETION)\nextern int bash_brace_completion PARAMS((int, int));\n#endif  \n\n \n#ifdef _MINIX\nextern int tputs PARAMS((const char *string, int nlines, void (*outx)(int)));\n#else\nextern int tputs PARAMS((const char *string, int nlines, int (*outx)(int)));\n#endif\n\n \n\n \nstatic int shell_expand_line PARAMS((int, int));\nstatic int display_shell_version PARAMS((int, int));\n\nstatic int bash_ignore_filenames PARAMS((char **));\nstatic int bash_ignore_everything PARAMS((char **));\nstatic int bash_progcomp_ignore_filenames PARAMS((char **));\n\n#if defined (BANG_HISTORY)\nstatic char *history_expand_line_internal PARAMS((char *));\nstatic int history_expand_line PARAMS((int, int));\nstatic int tcsh_magic_space PARAMS((int, int));\n#endif  \n#ifdef ALIAS\nstatic int alias_expand_line PARAMS((int, int));\n#endif\n#if defined (BANG_HISTORY) && defined (ALIAS)\nstatic int history_and_alias_expand_line PARAMS((int, int));\n#endif\n\nstatic int bash_forward_shellword PARAMS((int, int));\nstatic int bash_backward_shellword PARAMS((int, int));\nstatic int bash_kill_shellword PARAMS((int, int));\nstatic int bash_backward_kill_shellword PARAMS((int, int));\nstatic int bash_transpose_shellwords PARAMS((int, int));\n\nstatic int bash_spell_correct_shellword PARAMS((int, int));\n\n \nstatic char *restore_tilde PARAMS((char *, char *));\nstatic char *maybe_restore_tilde PARAMS((char *, char *));\n\nstatic char *bash_filename_rewrite_hook PARAMS((char *, int));\n\nstatic void bash_directory_expansion PARAMS((char **));\nstatic int bash_filename_stat_hook PARAMS((char **));\nstatic int bash_command_name_stat_hook PARAMS((char **));\nstatic int bash_directory_completion_hook PARAMS((char **));\nstatic int filename_completion_ignore PARAMS((char **));\nstatic int bash_push_line PARAMS((void));\n\nstatic int executable_completion PARAMS((const char *, int));\n\nstatic rl_icppfunc_t *save_directory_hook PARAMS((void));\nstatic void restore_directory_hook PARAMS((rl_icppfunc_t));\n\nstatic int directory_exists PARAMS((const char *, int));\n\nstatic void cleanup_expansion_error PARAMS((void));\nstatic void maybe_make_readline_line PARAMS((char *));\nstatic void set_up_new_line PARAMS((char *));\n\nstatic int check_redir PARAMS((int));\nstatic char **attempt_shell_completion PARAMS((const char *, int, int));\nstatic char *variable_completion_function PARAMS((const char *, int));\nstatic char *hostname_completion_function PARAMS((const char *, int));\nstatic char *command_subst_completion_function PARAMS((const char *, int));\n\nstatic void build_history_completion_array PARAMS((void));\nstatic char *history_completion_generator PARAMS((const char *, int));\nstatic int dynamic_complete_history PARAMS((int, int));\nstatic int bash_dabbrev_expand PARAMS((int, int));\n\nstatic void initialize_hostname_list PARAMS((void));\nstatic void add_host_name PARAMS((char *));\nstatic void snarf_hosts_from_file PARAMS((char *));\nstatic char **hostnames_matching PARAMS((char *));\n\nstatic void _ignore_completion_names PARAMS((char **, sh_ignore_func_t *));\nstatic int name_is_acceptable PARAMS((const char *));\nstatic int test_for_directory PARAMS((const char *));\nstatic int test_for_canon_directory PARAMS((const char *));\nstatic int return_zero PARAMS((const char *));\n\nstatic char *bash_dequote_filename PARAMS((char *, int));\nstatic char *quote_word_break_chars PARAMS((char *));\nstatic int bash_check_expchar PARAMS((char *, int, int *, int *));\nstatic void set_filename_quote_chars PARAMS((int, int, int));\nstatic void set_filename_bstab PARAMS((const char *));\nstatic char *bash_quote_filename PARAMS((char *, int, char *));\n\n#ifdef _MINIX\nstatic void putx PARAMS((int));\n#else\nstatic int putx PARAMS((int));\n#endif\nstatic int readline_get_char_offset PARAMS((int));\nstatic void readline_set_char_offset PARAMS((int, int *));\n\nstatic Keymap get_cmd_xmap_from_edit_mode PARAMS((void));\nstatic Keymap get_cmd_xmap_from_keymap PARAMS((Keymap));\n\nstatic void init_unix_command_map PARAMS((void));\nstatic int isolate_sequence PARAMS((char *, int, int, int *));\n\nstatic int set_saved_history PARAMS((void));\n\n#if defined (ALIAS)\nstatic int posix_edit_macros PARAMS((int, int));\n#endif\n\nstatic int bash_event_hook PARAMS((void));\n\n#if defined (PROGRAMMABLE_COMPLETION)\nstatic int find_cmd_start PARAMS((int));\nstatic int find_cmd_end PARAMS((int));\nstatic char *find_cmd_name PARAMS((int, int *, int *));\nstatic char *prog_complete_return PARAMS((const char *, int));\n\nstatic char **prog_complete_matches;\n#endif\n\nextern int no_symbolic_links;\nextern STRING_INT_ALIST word_token_alist[];\nextern sh_timer *read_timeout;\n\n \n#define SPECIFIC_COMPLETION_FUNCTIONS\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\nstatic int bash_specific_completion PARAMS((int, rl_compentry_func_t *));\n\nstatic int bash_complete_filename_internal PARAMS((int));\nstatic int bash_complete_username_internal PARAMS((int));\nstatic int bash_complete_hostname_internal PARAMS((int));\nstatic int bash_complete_variable_internal PARAMS((int));\nstatic int bash_complete_command_internal PARAMS((int));\n\nstatic int bash_complete_filename PARAMS((int, int));\nstatic int bash_possible_filename_completions PARAMS((int, int));\nstatic int bash_complete_username PARAMS((int, int));\nstatic int bash_possible_username_completions PARAMS((int, int));\nstatic int bash_complete_hostname PARAMS((int, int));\nstatic int bash_possible_hostname_completions PARAMS((int, int));\nstatic int bash_complete_variable PARAMS((int, int));\nstatic int bash_possible_variable_completions PARAMS((int, int));\nstatic int bash_complete_command PARAMS((int, int));\nstatic int bash_possible_command_completions PARAMS((int, int));\n\nstatic int completion_glob_pattern PARAMS((char *));\nstatic char *glob_complete_word PARAMS((const char *, int));\nstatic int bash_glob_completion_internal PARAMS((int));\nstatic int bash_glob_complete_word PARAMS((int, int));\nstatic int bash_glob_expand_word PARAMS((int, int));\nstatic int bash_glob_list_expansions PARAMS((int, int));\n\n#endif  \n\nstatic int edit_and_execute_command PARAMS((int, int, int, char *));\n#if defined (VI_MODE)\nstatic int vi_edit_and_execute_command PARAMS((int, int));\nstatic int bash_vi_complete PARAMS((int, int));\n#endif\nstatic int emacs_edit_and_execute_command PARAMS((int, int));\n\n \nint bash_readline_initialized = 0;\n\n \nint perform_hostname_completion = 1;\n\n \nint no_empty_command_completion;\n\n \nint force_fignore = 1;\n\n \nint dircomplete_spelling = 0;\n\n \n#if DIRCOMPLETE_EXPAND_DEFAULT\nint dircomplete_expand = 1;\nint dircomplete_expand_relpath = 1;\n#else\nint dircomplete_expand = 0;\nint dircomplete_expand_relpath = 0;\n#endif\n\n \nint complete_fullquote = 1;\n\nstatic char *bash_completer_word_break_characters = \" \\t\\n\\\"'@><=;|&(:\";\nstatic char *bash_nohostname_word_break_characters = \" \\t\\n\\\"'><=;|&(:\";\n \n\nstatic const char *default_filename_quote_characters = \" \\t\\n\\\\\\\"'@<>=;|&()#$`?*[!:{~\";\t \nstatic char *custom_filename_quote_characters = 0;\nstatic char filename_bstab[256];\n\nstatic rl_hook_func_t *old_rl_startup_hook = (rl_hook_func_t *)NULL;\n\nstatic int dot_in_path = 0;\n\n \nstatic int dabbrev_expand_active = 0;\n\n \n#define COMPLETE_DQUOTE  1\n#define COMPLETE_SQUOTE  2\n#define COMPLETE_BSQUOTE 3\nstatic int completion_quoting_style = COMPLETE_BSQUOTE;\n\n \n#define DEFCOMP_CMDPOS\t\t1\n\nstatic rl_command_func_t *vi_tab_binding = rl_complete;\n\n \nvoid\nposix_readline_initialize (on_or_off)\n     int on_or_off;\n{\n  static char kseq[2] = { CTRL ('I'), 0 };\t\t \n\n  if (on_or_off)\n    rl_variable_bind (\"comment-begin\", \"#\");\n#if defined (VI_MODE)\n  if (on_or_off)\n    {\n      vi_tab_binding = rl_function_of_keyseq (kseq, vi_insertion_keymap, (int *)NULL);\n      rl_bind_key_in_map (CTRL ('I'), rl_insert, vi_insertion_keymap);\n    }\n  else\n    {\n      if (rl_function_of_keyseq (kseq, vi_insertion_keymap, (int *)NULL) == rl_insert)\n        rl_bind_key_in_map (CTRL ('I'), vi_tab_binding, vi_insertion_keymap);\n    }\n#endif\n}\n\nvoid\nreset_completer_word_break_chars ()\n{\n  rl_completer_word_break_characters = perform_hostname_completion ? savestring (bash_completer_word_break_characters) : savestring (bash_nohostname_word_break_characters);\n}\n\n \nint\nenable_hostname_completion (on_or_off)\n     int on_or_off;\n{\n  int old_value;\n  char *nv, *nval;\n  const char *at;\n\n  old_value = perform_hostname_completion;\n\n  if (on_or_off)\n    {\n      perform_hostname_completion = 1;\n      rl_special_prefixes = \"$@\";\n    }\n  else\n    {\n      perform_hostname_completion = 0;\n      rl_special_prefixes = \"$\";\n    }\n\n   \n\n   \n\n  if (bash_readline_initialized == 0 &&\n      (rl_completer_word_break_characters == 0 || \n       rl_completer_word_break_characters == rl_basic_word_break_characters))\n    {\n      if (on_or_off)\n\trl_completer_word_break_characters = savestring (bash_completer_word_break_characters);\n      else\n\trl_completer_word_break_characters = savestring (bash_nohostname_word_break_characters);\n    }\n  else\n    {\n       \n      at = strchr (rl_completer_word_break_characters, '@');\n      if ((at == 0 && on_or_off == 0) || (at != 0 && on_or_off != 0))\n        return old_value;\n\n       \n      nval = (char *)xmalloc (strlen (rl_completer_word_break_characters) + 1 + on_or_off);\n\n      if (on_or_off == 0)\n\t{\n\t   \n\t  for (nv = nval, at = rl_completer_word_break_characters; *at; )\n\t    if (*at != '@')\n\t      *nv++ = *at++;\n\t    else\n\t      at++;\n\t  *nv = '\\0';\n\t}\n      else\n\t{\n\t  nval[0] = '@';\n\t  strcpy (nval + 1, rl_completer_word_break_characters);\n        }\n\n      free ((void *)rl_completer_word_break_characters);\n      rl_completer_word_break_characters = nval;\n    }\n\n  return (old_value);\n}\n\n \nvoid\ninitialize_readline ()\n{\n  rl_command_func_t *func;\n  char kseq[2];\n\n  if (bash_readline_initialized)\n    return;\n\n  rl_terminal_name = get_string_value (\"TERM\");\n  rl_instream = stdin;\n  rl_outstream = stderr;\n\n   \n  rl_readline_name = \"Bash\";\n\n   \n  rl_add_defun (\"shell-expand-line\", shell_expand_line, -1);\n#ifdef BANG_HISTORY\n  rl_add_defun (\"history-expand-line\", history_expand_line, -1);\n  rl_add_defun (\"magic-space\", tcsh_magic_space, -1);\n#endif\n\n  rl_add_defun (\"shell-forward-word\", bash_forward_shellword, -1);\n  rl_add_defun (\"shell-backward-word\", bash_backward_shellword, -1);\n  rl_add_defun (\"shell-kill-word\", bash_kill_shellword, -1);\n  rl_add_defun (\"shell-backward-kill-word\", bash_backward_kill_shellword, -1);\n  rl_add_defun (\"shell-transpose-words\", bash_transpose_shellwords, -1);\n\n  rl_add_defun (\"spell-correct-word\", bash_spell_correct_shellword, -1);\n  rl_bind_key_if_unbound_in_map ('s', bash_spell_correct_shellword, emacs_ctlx_keymap);\n\n#ifdef ALIAS\n  rl_add_defun (\"alias-expand-line\", alias_expand_line, -1);\n#  ifdef BANG_HISTORY\n  rl_add_defun (\"history-and-alias-expand-line\", history_and_alias_expand_line, -1);\n#  endif\n#endif\n\n   \n  rl_add_defun (\"insert-last-argument\", rl_yank_last_arg, -1);\n\n  rl_add_defun (\"display-shell-version\", display_shell_version, -1);\n  rl_add_defun (\"edit-and-execute-command\", emacs_edit_and_execute_command, -1);\n#if defined (VI_MODE)\n  rl_add_defun (\"vi-edit-and-execute-command\", vi_edit_and_execute_command, -1);\n#endif\n\n#if defined (BRACE_COMPLETION)\n  rl_add_defun (\"complete-into-braces\", bash_brace_completion, -1);\n#endif\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  rl_add_defun (\"complete-filename\", bash_complete_filename, -1);\n  rl_add_defun (\"possible-filename-completions\", bash_possible_filename_completions, -1);\n  rl_add_defun (\"complete-username\", bash_complete_username, -1);\n  rl_add_defun (\"possible-username-completions\", bash_possible_username_completions, -1);\n  rl_add_defun (\"complete-hostname\", bash_complete_hostname, -1);\n  rl_add_defun (\"possible-hostname-completions\", bash_possible_hostname_completions, -1);\n  rl_add_defun (\"complete-variable\", bash_complete_variable, -1);\n  rl_add_defun (\"possible-variable-completions\", bash_possible_variable_completions, -1);\n  rl_add_defun (\"complete-command\", bash_complete_command, -1);\n  rl_add_defun (\"possible-command-completions\", bash_possible_command_completions, -1);\n  rl_add_defun (\"glob-complete-word\", bash_glob_complete_word, -1);\n  rl_add_defun (\"glob-expand-word\", bash_glob_expand_word, -1);\n  rl_add_defun (\"glob-list-expansions\", bash_glob_list_expansions, -1);\n#endif\n\n  rl_add_defun (\"dynamic-complete-history\", dynamic_complete_history, -1);\n  rl_add_defun (\"dabbrev-expand\", bash_dabbrev_expand, -1);\n\n   \n  if (RL_ISSTATE(RL_STATE_INITIALIZED) == 0)\n    rl_initialize ();\n\n   \n  rl_bind_key_if_unbound_in_map (CTRL('E'), shell_expand_line, emacs_meta_keymap);\n\n#ifdef BANG_HISTORY\n  rl_bind_key_if_unbound_in_map ('^', history_expand_line, emacs_meta_keymap);\n#endif\n\n  rl_bind_key_if_unbound_in_map (CTRL ('V'), display_shell_version, emacs_ctlx_keymap);\n\n   \n  kseq[0] = CTRL('J');\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == rl_vi_editing_mode)\n    rl_unbind_key_in_map (CTRL('J'), emacs_meta_keymap);\n  kseq[0] = CTRL('M');\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == rl_vi_editing_mode)\n    rl_unbind_key_in_map (CTRL('M'), emacs_meta_keymap);\n#if defined (VI_MODE)\n  kseq[0] = CTRL('E');\n  func = rl_function_of_keyseq (kseq, vi_movement_keymap, (int *)NULL);\n  if (func == rl_emacs_editing_mode)\n    rl_unbind_key_in_map (CTRL('E'), vi_movement_keymap);\n#endif\n\n#if defined (BRACE_COMPLETION)\n  rl_bind_key_if_unbound_in_map ('{', bash_brace_completion, emacs_meta_keymap);  \n#endif  \n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  rl_bind_key_if_unbound_in_map ('/', bash_complete_filename, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('/', bash_possible_filename_completions, emacs_ctlx_keymap);\n\n   \n  kseq[0] = '~';\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == 0 || func == rl_tilde_expand)\n    rl_bind_keyseq_in_map (kseq, bash_complete_username, emacs_meta_keymap);\n\n  rl_bind_key_if_unbound_in_map ('~', bash_possible_username_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('@', bash_complete_hostname, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('@', bash_possible_hostname_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('$', bash_complete_variable, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('$', bash_possible_variable_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('!', bash_complete_command, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('!', bash_possible_command_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('g', bash_glob_complete_word, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('*', bash_glob_expand_word, emacs_ctlx_keymap);\n  rl_bind_key_if_unbound_in_map ('g', bash_glob_list_expansions, emacs_ctlx_keymap);\n\n#endif  \n\n  kseq[0] = TAB;\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == 0 || func == rl_tab_insert)\n    rl_bind_key_in_map (TAB, dynamic_complete_history, emacs_meta_keymap);\n\n   \n  rl_attempted_completion_function = attempt_shell_completion;\n\n   \n  set_directory_hook ();\n\n  rl_filename_rewrite_hook = bash_filename_rewrite_hook;\n\n  rl_filename_stat_hook = bash_filename_stat_hook;\n\n   \n  rl_ignore_some_completions_function = filename_completion_ignore;\n\n   \n  rl_bind_key_if_unbound_in_map (CTRL ('E'), emacs_edit_and_execute_command, emacs_ctlx_keymap);\n#if defined (VI_MODE)\n  rl_bind_key_if_unbound_in_map ('v', vi_edit_and_execute_command, vi_movement_keymap);\n#  if defined (ALIAS)\n  rl_bind_key_if_unbound_in_map ('@', posix_edit_macros, vi_movement_keymap);\n#  endif\n\n  rl_bind_key_in_map ('\\\\', bash_vi_complete, vi_movement_keymap);\n  rl_bind_key_in_map ('*', bash_vi_complete, vi_movement_keymap);\n  rl_bind_key_in_map ('=', bash_vi_complete, vi_movement_keymap);\n#endif\n\n  rl_completer_quote_characters = \"'\\\"\";\n\n   \n  enable_hostname_completion (perform_hostname_completion);\n\n   \n  rl_filename_quote_characters = default_filename_quote_characters;\n  set_filename_bstab (rl_filename_quote_characters);\n\n  rl_filename_quoting_function = bash_quote_filename;\n  rl_filename_dequoting_function = bash_dequote_filename;\n  rl_char_is_quoted_p = char_is_quoted;\n\n   \n  rl_bind_key_if_unbound_in_map (CTRL('B'), bash_backward_shellword, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map (CTRL('D'), bash_kill_shellword, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map (CTRL('F'), bash_forward_shellword, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map (CTRL('T'), bash_transpose_shellwords, emacs_meta_keymap);\n\n#if 0\n   \n  if (posixly_correct)\n    posix_readline_initialize (1);\n#endif\n\n  bash_readline_initialized = 1;\n}\n\nvoid\nbashline_reinitialize ()\n{\n  bash_readline_initialized = 0;\n}\n\nvoid\nbashline_set_event_hook ()\n{\n  rl_signal_event_hook = bash_event_hook;\n}\n\nvoid\nbashline_reset_event_hook ()\n{\n  rl_signal_event_hook = 0;\n}\n\n \nvoid\nbashline_reset ()\n{\n  tilde_initialize ();\n  rl_attempted_completion_function = attempt_shell_completion;\n  rl_completion_entry_function = NULL;\n  rl_ignore_some_completions_function = filename_completion_ignore;\n\n  complete_fullquote = 1;\n  rl_filename_quote_characters = default_filename_quote_characters;\n  set_filename_bstab (rl_filename_quote_characters);\n\n  set_directory_hook ();\n  rl_filename_stat_hook = bash_filename_stat_hook;\n\n  bashline_reset_event_hook ();\n\n  rl_sort_completion_matches = 1;\n}\n\n \nstatic char *push_to_readline = (char *)NULL;\n\n \nstatic int\nbash_push_line ()\n{\n  if (push_to_readline)\n    {\n      rl_insert_text (push_to_readline);\n      free (push_to_readline);\n      push_to_readline = (char *)NULL;\n      rl_startup_hook = old_rl_startup_hook;\n    }\n  return 0;\n}\n\n \nint\nbash_re_edit (line)\n     char *line;\n{\n  FREE (push_to_readline);\n\n  push_to_readline = savestring (line);\n  old_rl_startup_hook = rl_startup_hook;\n  rl_startup_hook = bash_push_line;\n\n  return (0);\n}\n\nstatic int\ndisplay_shell_version (count, c)\n     int count, c;\n{\n  rl_crlf ();\n  show_shell_version (0);\n  putc ('\\r', rl_outstream);\n  fflush (rl_outstream);\n  rl_on_new_line ();\n  rl_redisplay ();\n  return 0;\n}\n\n \n \n \n \n \n\n \n\n \n \nstatic char **hostname_list = (char **)NULL;\n\n \nstatic int hostname_list_size;\n\n \nstatic int hostname_list_length;\n\n \nint hostname_list_initialized = 0;\n\n \nstatic void\ninitialize_hostname_list ()\n{\n  char *temp;\n\n  temp = get_string_value (\"HOSTFILE\");\n  if (temp == 0)\n    temp = get_string_value (\"hostname_completion_file\");\n  if (temp == 0)\n    temp = DEFAULT_HOSTS_FILE;\n\n  snarf_hosts_from_file (temp);\n\n  if (hostname_list)\n    hostname_list_initialized++;\n}\n\n \nstatic void\nadd_host_name (name)\n     char *name;\n{\n  if (hostname_list_length + 2 > hostname_list_size)\n    {\n      hostname_list_size = (hostname_list_size + 32) - (hostname_list_size % 32);\n      hostname_list = strvec_resize (hostname_list, hostname_list_size);\n    }\n\n  hostname_list[hostname_list_length++] = savestring (name);\n  hostname_list[hostname_list_length] = (char *)NULL;\n}\n\n#define cr_whitespace(c) ((c) == '\\r' || (c) == '\\n' || whitespace(c))\n\nstatic void\nsnarf_hosts_from_file (filename)\n     char *filename;\n{\n  FILE *file;\n  char *temp, buffer[256], name[256];\n  register int i, start;\n\n  file = fopen (filename, \"r\");\n  if (file == 0)\n    return;\n\n  while (temp = fgets (buffer, 255, file))\n    {\n       \n      for (i = 0; buffer[i] && cr_whitespace (buffer[i]); i++)\n\t;\n\n       \n      if (buffer[i] == '\\0' || buffer[i] == '#')\n\tcontinue;\n\n       \n      if (strncmp (buffer + i, \"$include \", 9) == 0)\n\t{\n\t  char *incfile, *t;\n\n\t   \n\t  for (incfile = buffer + i + 9; *incfile && whitespace (*incfile); incfile++)\n\t    ;\n\n\t   \n\t  for (t = incfile; *t && cr_whitespace (*t) == 0; t++)\n\t    ;\n\n\t  *t = '\\0';\n\n\t  snarf_hosts_from_file (incfile);\n\t  continue;\n\t}\n\n       \n      if (DIGIT (buffer[i]))\n\tfor (; buffer[i] && cr_whitespace (buffer[i]) == 0; i++);\n\n       \n      while (buffer[i])\n\t{\n\t  for (; cr_whitespace (buffer[i]); i++)\n\t    ;\n\t  if (buffer[i] == '\\0' || buffer[i] ==  '#')\n\t    break;\n\n\t   \n\t  for (start = i; buffer[i] && cr_whitespace (buffer[i]) == 0; i++)\n\t    ;\n\t  if (i == start)\n\t    continue;\n\t  strncpy (name, buffer + start, i - start);\n\t  name[i - start] = '\\0';\n\t  add_host_name (name);\n\t}\n    }\n  fclose (file);\n}\n\n \nchar **\nget_hostname_list ()\n{\n  if (hostname_list_initialized == 0)\n    initialize_hostname_list ();\n  return (hostname_list);\n}\n\nvoid\nclear_hostname_list ()\n{\n  register int i;\n\n  if (hostname_list_initialized == 0)\n    return;\n  for (i = 0; i < hostname_list_length; i++)\n    free (hostname_list[i]);\n  hostname_list_length = hostname_list_initialized = 0;\n}\n\n \nstatic char **\nhostnames_matching (text)\n     char *text;\n{\n  register int i, len, nmatch, rsize;\n  char **result;\n\n  if (hostname_list_initialized == 0)\n    initialize_hostname_list ();\n\n  if (hostname_list_initialized == 0)\n    return ((char **)NULL);\n\n   \n  if (*text == '\\0')\n    {\n      result = strvec_create (1 + hostname_list_length);\n      for (i = 0; i < hostname_list_length; i++)\n\tresult[i] = hostname_list[i];\n      result[i] = (char *)NULL;\n      return (result);\n    }\n\n   \n  len = strlen (text);\n  result = (char **)NULL;\n  for (i = nmatch = rsize = 0; i < hostname_list_length; i++)\n    {\n      if (STREQN (text, hostname_list[i], len) == 0)\n\tcontinue;\n\n       \n      if (nmatch >= (rsize - 1))\n\t{\n\t  rsize = (rsize + 16) - (rsize % 16);\n\t  result = strvec_resize (result, rsize);\n\t}\n\n      result[nmatch++] = hostname_list[i];\n    }\n  if (nmatch)\n    result[nmatch] = (char *)NULL;\n  return (result);\n}\n\n \n\n#define VI_EDIT_COMMAND\t\t\"fc -e \\\"${VISUAL:-${EDITOR:-vi}}\\\"\"\n#define EMACS_EDIT_COMMAND\t\"fc -e \\\"${VISUAL:-${EDITOR:-emacs}}\\\"\"\n#define POSIX_VI_EDIT_COMMAND\t\"fc -e vi\"\n\nstatic int\nedit_and_execute_command (count, c, editing_mode, edit_command)\n     int count, c, editing_mode;\n     char *edit_command;\n{\n  char *command, *metaval;\n  int r, rrs, metaflag;\n  sh_parser_state_t ps;\n\n  rrs = rl_readline_state;\n  saved_command_line_count = current_command_line_count;\n\n   \n  rl_newline (1, c);\n\n  if (rl_explicit_arg)\n    {\n      command = (char *)xmalloc (strlen (edit_command) + 8);\n      sprintf (command, \"%s %d\", edit_command, count);\n    }\n  else\n    {\n       \n       \n      using_history ();\n      current_command_line_count++;\t \n      bash_add_history (rl_line_buffer);\n      current_command_line_count = 0;\t \n      bash_add_history (\"\");\n      history_lines_this_session++;\n      using_history ();\n      command = savestring (edit_command);\n    }\n\n  metaval = rl_variable_value (\"input-meta\");\n  metaflag = RL_BOOLEAN_VARIABLE_VALUE (metaval);\n  \n  if (rl_deprep_term_function)\n    (*rl_deprep_term_function) ();\n  rl_clear_signals ();\n  save_parser_state (&ps);\n  r = parse_and_execute (command, (editing_mode == VI_EDITING_MODE) ? \"v\" : \"C-xC-e\", SEVAL_NOHIST);\n  restore_parser_state (&ps);\n\n   \n  reset_readahead_token ();\n\n  if (rl_prep_term_function)\n    (*rl_prep_term_function) (metaflag);\n  rl_set_signals ();\n\n  current_command_line_count = saved_command_line_count;\n\n   \n  rl_line_buffer[0] = '\\0';\t \n  rl_point = rl_end = 0;\n  rl_done = 0;\n  rl_readline_state = rrs;\n\n#if defined (VI_MODE)\n  if (editing_mode == VI_EDITING_MODE)\n    rl_vi_insertion_mode (1, c);\n#endif\n\n  rl_forced_update_display ();\n\n  return r;\n}\n\n#if defined (VI_MODE)\nstatic int\nvi_edit_and_execute_command (count, c)\n     int count, c;\n{\n  if (posixly_correct)\n    return (edit_and_execute_command (count, c, VI_EDITING_MODE, POSIX_VI_EDIT_COMMAND));\n  else\n    return (edit_and_execute_command (count, c, VI_EDITING_MODE, VI_EDIT_COMMAND));\n}\n#endif  \n\nstatic int\nemacs_edit_and_execute_command (count, c)\n     int count, c;\n{\n  return (edit_and_execute_command (count, c, EMACS_EDITING_MODE, EMACS_EDIT_COMMAND));\n}\n\n#if defined (ALIAS)\nstatic int\nposix_edit_macros (count, key)\n     int count, key;\n{\n  int c;\n  char alias_name[3], *alias_value, *macro;\n\n  c = rl_read_key ();\n  if (c <= 0)\n    return 0;\n  alias_name[0] = '_';\n  alias_name[1] = c;\n  alias_name[2] = '\\0';\n\n  alias_value = get_alias_value (alias_name);\n  if (alias_value && *alias_value)\n    {\n      macro = savestring (alias_value);\n      rl_push_macro_input (macro);\n    }\n  return 0;\n}\n#endif\n\n \n\n#define WORDDELIM(c)\t(shellmeta(c) || shellblank(c))\n\nstatic int\nbash_forward_shellword (count, key)\n     int count, key;\n{\n  size_t slen;\n  int c, p;\n  DECLARE_MBSTATE;\n\n  if (count < 0)\n    return (bash_backward_shellword (-count, key));\n\n   \n   \n\n  p = rl_point;\n  slen = rl_end;\n\n  while (count)\n    {\n      if (p == rl_end)\n\t{\n\t  rl_point = rl_end;\n\t  return 0;\n\t}\n\n       \n      if (char_is_quoted (rl_line_buffer, p) && p > 0 && rl_line_buffer[p-1] != '\\\\')\n\t{\n\t  do\n\t    ADVANCE_CHAR (rl_line_buffer, slen, p);\n\t  while (p < rl_end && char_is_quoted (rl_line_buffer, p));\n\t  count--;\n\t  continue;\n\t}\n\n       \n       \n      while (p < rl_end && (c = rl_line_buffer[p]) && WORDDELIM (c))\n\t{\n\t  switch (c)\n\t    {\n\t    default:\n\t      ADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      continue;\t\t \n\t    case '\\\\':\n\t      if (p < rl_end && rl_line_buffer[p])\n\t\tADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      break;\n\t    case '\\'':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"'\", SD_NOJMP);\n\t      break;\n\t    case '\"':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"\\\"\", SD_NOJMP);\n\t      break;\n\t    }\n\n\t  if (p < rl_end)\n\t    p++;\n\t}\n\n      if (rl_line_buffer[p] == 0 || p == rl_end)\n        {\n\t  rl_point = rl_end;\n\t  rl_ding ();\n\t  return 0;\n        }\n\t\n       \n      while (p < rl_end && (c = rl_line_buffer[p]) && WORDDELIM (c) == 0)\n\t{\n\t  switch (c)\n\t    {\n\t    default:\n\t      ADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      continue;\t\t \n\t    case '\\\\':\n\t      if (p < rl_end && rl_line_buffer[p])\n\t\tADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      break;\n\t    case '\\'':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"'\", SD_NOJMP);\n\t      break;\n\t    case '\"':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"\\\"\", SD_NOJMP);\n\t      break;\n\t    }\n\n\t  if (p < rl_end)\n\t    p++;\n\t}\n\n      if (p == rl_end || rl_line_buffer[p] == 0)\n\t{\n\t  rl_point = rl_end;\n\t  return (0);\n\t}\n\n      count--;      \n    }\n\n  rl_point = p;\n  return (0);\n}\n\nstatic int\nbash_backward_shellword (count, key)\n     int count, key;\n{\n  size_t slen;\n  int c, p, prev_p;\n  DECLARE_MBSTATE;\n\n  if (count < 0)\n    return (bash_forward_shellword (-count, key));\n\n  p = rl_point;\n  slen = rl_end;\n\n  while (count)\n    {\n      if (p == 0)\n\t{\n\t  rl_point = 0;\n\t  return 0;\n\t}\n\n       \n      BACKUP_CHAR (rl_line_buffer, slen, p);\n      while (p > 0)\n\t{\n\t  c = rl_line_buffer[p];\n\t  if (WORDDELIM (c) == 0 || char_is_quoted (rl_line_buffer, p))\n\t    break;\n\t  BACKUP_CHAR (rl_line_buffer, slen, p);\n\t}\n\n      if (p == 0)\n\t{\n\t  rl_point = 0;\n\t  return 0;\n\t}\n\n       \n      prev_p = p;\n      while (p > 0)\n\t{\n\t  c = rl_line_buffer[p];\n\t  if (WORDDELIM (c) && char_is_quoted (rl_line_buffer, p) == 0)\n\t    {\n\t      p = prev_p;\n\t      break;\n\t    }\n\t  prev_p = p;\n\t  BACKUP_CHAR (rl_line_buffer, slen, p);\n\t}\n\n      count--;\n    }\n\n  rl_point = p;\n  return 0;\n}\n\nstatic int\nbash_kill_shellword (count, key)\n     int count, key;\n{\n  int p;\n\n  if (count < 0)\n    return (bash_backward_kill_shellword (-count, key));\n\n  p = rl_point;\n  bash_forward_shellword (count, key);\n\n  if (rl_point != p)\n    rl_kill_text (p, rl_point);\n\n  rl_point = p;\n  if (rl_editing_mode == EMACS_EDITING_MODE)\t \n    rl_mark = rl_point;\n\n  return 0;\n}\n\nstatic int\nbash_backward_kill_shellword (count, key)\n     int count, key;\n{\n  int p;\n\n  if (count < 0)\n    return (bash_kill_shellword (-count, key));\n\n  p = rl_point;\n  bash_backward_shellword (count, key);\n\n  if (rl_point != p)\n    rl_kill_text (p, rl_point);\n\n  if (rl_editing_mode == EMACS_EDITING_MODE)\t \n    rl_mark = rl_point;\n\n  return 0;\n}\n\nstatic int\nbash_transpose_shellwords (count, key)\n     int count, key;\n{\n  char *word1, *word2;\n  int w1_beg, w1_end, w2_beg, w2_end;\n  int orig_point = rl_point;\n\n  if (count == 0)\n    return 0;\n\n   \n  bash_forward_shellword (count, key);\n  w2_end = rl_point;\n  bash_backward_shellword (1, key);\n  w2_beg = rl_point;\n  bash_backward_shellword (count, key);\n  w1_beg = rl_point;\n  bash_forward_shellword (1, key);\n  w1_end = rl_point;\n\n   \n  if ((w1_beg == w2_beg) || (w2_beg < w1_end))\n    {\n      rl_ding ();\n      rl_point = orig_point;\n      return 1;\n    }\n\n   \n  word1 = rl_copy_text (w1_beg, w1_end);\n  word2 = rl_copy_text (w2_beg, w2_end);\n\n   \n  rl_begin_undo_group ();\n\n   \n  rl_point = w2_beg;\n  rl_delete_text (w2_beg, w2_end);\n  rl_insert_text (word1);\n\n  rl_point = w1_beg;\n  rl_delete_text (w1_beg, w1_end);\n  rl_insert_text (word2);\n\n   \n  rl_point = w2_end;\n\n   \n  rl_end_undo_group ();\n  xfree (word1);\n  xfree (word2);\n\n  return 0;\n}\n\n \nstatic int\nbash_spell_correct_shellword (count, key)\n     int count, key;\n{\n  int opoint, wbeg, wend;\n  char *text, *newdir;\n\n  opoint = rl_point;\n  while (count)\n    {\n      bash_backward_shellword (1, key);\n      wbeg = rl_point;\n      bash_forward_shellword (1, key);\n      wend = rl_point;\n\n      if (wbeg > wend)\n\tbreak;\n\n      text = rl_copy_text (wbeg, wend);\n\n      newdir = dirspell (text);\n      if (newdir)\n\t{\n\t  rl_begin_undo_group ();\n\t  rl_delete_text (wbeg, wend);\n\t  rl_point = wbeg;\n\t  if (*newdir)\n\t    rl_insert_text (newdir);\n\t  rl_mark = wbeg;\n\t  rl_end_undo_group ();\n\t}\n\n      free (text);\n      free (newdir);\n\n      if (rl_point >= rl_end)\n\tbreak;\n\n      count--;\n\n      if (count)\n\tbash_forward_shellword (1, key);\t\t \n    }\n\n  return 0;\n}\n\n \n \n \n \n \n\n#define COMMAND_SEPARATORS \";|&{(`\"\n  \n#define COMMAND_SEPARATORS_PLUS_WS \";|&{(` \\t\"\n  \n\n \nstatic int\ncheck_redir (ti)\n     int ti;\n{\n  register int this_char, prev_char;\n\n   \n  this_char = rl_line_buffer[ti];\n  prev_char = (ti > 0) ? rl_line_buffer[ti - 1] : 0;\n\n  if ((this_char == '&' && (prev_char == '<' || prev_char == '>')) ||\n      (this_char == '|' && prev_char == '>'))\n    return (1);\n  else if (this_char == '{' && prev_char == '$')  \n    return (1);\n#if 0\t \n  else if (this_char == '(' && prev_char == '$')  \n    return (1);\n  else if (this_char == '(' && prev_char == '<')  \n    return (1);\n#if defined (EXTENDED_GLOB)\n  else if (extended_glob && this_char == '(' && prev_char == '!')  \n    return (1);\n#endif\n#endif\n  else if (char_is_quoted (rl_line_buffer, ti))\n    return (1);\n  return (0);\n}\n\n#if defined (PROGRAMMABLE_COMPLETION)\n \nstatic int\nfind_cmd_start (start)\n     int start;\n{\n  register int s, os, ns;\n\n  os = 0;\n   \n  while (((s = skip_to_delim (rl_line_buffer, os, COMMAND_SEPARATORS, SD_NOJMP|SD_COMPLETE )) <= start) &&\n\t rl_line_buffer[s])\n    {\n       \n      if (s > 0 && rl_line_buffer[s] == '|' && rl_line_buffer[s-1] == '>')\n\t{\n\t  ns = skip_to_delim (rl_line_buffer, s+1, COMMAND_SEPARATORS, SD_NOJMP|SD_COMPLETE );\n\t  if (ns > start || rl_line_buffer[ns] == 0)\n\t    return os;\n\t  os = ns+1;\n\t  continue;\n\t}\n       \n      if (s >= os && rl_line_buffer[s] == '{')\n\t{\n\t  int pc, nc;\t \n\t  for (pc = (s > os) ? s - 1 : os; pc > os && whitespace(rl_line_buffer[pc]); pc--)\n\t    ;\n\t  nc = rl_line_buffer[s+1];\n\t   \n\t  if ((pc > os && (rl_line_buffer[s-1] == '{' || strchr (COMMAND_SEPARATORS, rl_line_buffer[pc]) == 0)) ||\n\t      (shellbreak(nc) == 0))\t \n\t    {\n\t       \n\t      ns = skip_to_delim (rl_line_buffer, s+1, COMMAND_SEPARATORS, SD_NOJMP|SD_COMPLETE );\n\t      if (ns > start || rl_line_buffer[ns] == 0)\n\t\treturn os;\n\t      os = ns+1;\n\t      continue;\n\t    }\n\t}\n      os = s+1;\n    }\n  return os;\n}\n\nstatic int\nfind_cmd_end (end)\n     int end;\n{\n  register int e;\n\n  e = skip_to_delim (rl_line_buffer, end, COMMAND_SEPARATORS, SD_NOJMP|SD_COMPLETE);\n  return e;\n}\n\nstatic char *\nfind_cmd_name (start, sp, ep)\n     int start;\n     int *sp, *ep;\n{\n  char *name;\n  register int s, e;\n\n  for (s = start; whitespace (rl_line_buffer[s]); s++)\n    ;\n\n   \n  e = skip_to_delim (rl_line_buffer, s, \"()<>;&| \\t\\n\", SD_NOJMP|SD_COMPLETE);\n\n  name = substring (rl_line_buffer, s, e);\n\n  if (sp)\n    *sp = s;\n  if (ep)\n    *ep = e;\n\n  return (name);\n}\n\nstatic char *\nprog_complete_return (text, matchnum)\n     const char *text;\n     int matchnum;\n{\n  static int ind;\n\n  if (matchnum == 0)\n    ind = 0;\n\n  if (prog_complete_matches == 0 || prog_complete_matches[ind] == 0)\n    return (char *)NULL;\n  return (prog_complete_matches[ind++]);\n}\n\n#endif  \n\n \nstatic int\ninvalid_completion (text, ind)\n     const char *text;\n     int ind;\n{\n  int pind;\n\n   \n  if (ind > 0 && rl_line_buffer[ind] == '(' &&\t \n\t\t member (rl_line_buffer[ind-1], \"$<>\"))\n    return 0;\n\n  pind = ind - 1;\n  while (pind > 0 && whitespace (rl_line_buffer[pind]))\n    pind--;\n   \n  if (ind >= 0 && pind <= 0 && rl_line_buffer[ind] == '(')\t \n    return 0;\n   \n  if (ind > 0 && rl_line_buffer[ind] == '(' &&\t \n\t\t member (rl_line_buffer[pind], COMMAND_SEPARATORS) == 0)\n    return 1;\n\n  return 0;\n}\n\n \nstatic char **\nattempt_shell_completion (text, start, end)\n     const char *text;\n     int start, end;\n{\n  int in_command_position, ti, qc, dflags;\n  char **matches, *command_separator_chars;\n#if defined (PROGRAMMABLE_COMPLETION)\n  int have_progcomps, was_assignment;\n  COMPSPEC *iw_compspec;\n#endif\n\n  command_separator_chars = COMMAND_SEPARATORS;\n  matches = (char **)NULL;\n  rl_ignore_some_completions_function = filename_completion_ignore;\n\n  complete_fullquote = 1;\t\t \n  rl_filename_quote_characters = default_filename_quote_characters;\n  set_filename_bstab (rl_filename_quote_characters);\n  set_directory_hook ();\n  rl_filename_stat_hook = bash_filename_stat_hook;\n\n  rl_sort_completion_matches = 1;\t \n\n   \n  ti = start - 1;\n  qc = -1;\n\n  while ((ti > -1) && (whitespace (rl_line_buffer[ti])))\n    ti--;\n\n#if 1\n   \n  if (ti >= 0 && (rl_line_buffer[ti] == '\"' || rl_line_buffer[ti] == '\\''))\n    {\n      qc = rl_line_buffer[ti];\n      ti--;\n      while (ti > -1 && (whitespace (rl_line_buffer[ti])))\n\tti--;\n    }\n#endif\n      \n  in_command_position = 0;\n  if (ti < 0)\n    {\n       \n      if (current_prompt_string == ps1_prompt)\n\tin_command_position++;\n      else if (parser_in_command_position ())\n\tin_command_position++;\n    }\n  else if (member (rl_line_buffer[ti], command_separator_chars))\n    {\n      in_command_position++;\n\n      if (check_redir (ti) == 1)\n\tin_command_position = -1;\t \n    }\n  else\n    {\n       \n    }\n\n  if (in_command_position > 0 && invalid_completion (text, ti))\n    {\n      rl_attempted_completion_over = 1;\n      return ((char **)NULL);\n    }\n\n   \n  if (in_command_position > 0 && ti >= 0 && rl_line_buffer[ti] == '`' &&\n\t*text != '`' && unclosed_pair (rl_line_buffer, end, \"`\") == 0)\n    in_command_position = -1;\t \n\n   \n  if (*text == '`' && rl_completion_quote_character != '\\'' &&\n\t(in_command_position > 0 || (unclosed_pair (rl_line_buffer, start, \"`\") &&\n\t\t\t\t     unclosed_pair (rl_line_buffer, end, \"`\"))))\n    matches = rl_completion_matches (text, command_subst_completion_function);\n\n#if defined (PROGRAMMABLE_COMPLETION)\n   \n  have_progcomps = prog_completion_enabled && (progcomp_size () > 0);\n  iw_compspec = progcomp_search (INITIALWORD);\n  if (matches == 0 &&\n      (in_command_position == 0 || text[0] == '\\0' || (in_command_position > 0 && iw_compspec)) &&\n      current_prompt_string == ps1_prompt)\n    {\n      int s, e, s1, e1, os, foundcs;\n      char *n;\n\n       \n      if (prog_complete_matches)\n\tfree (prog_complete_matches);\n      prog_complete_matches = (char **)NULL;\n\n      os = start;\n      n = 0;\n      was_assignment = 0;\n      s = find_cmd_start (os);\n      e = find_cmd_end (end);\n      do\n\t{\n\t   \n\t  if (s > rl_end)\n\t    {\n\t      s1 = s = e1;\n\t      break;\n\t    }\n\t   \n\t  else if (was_assignment && s > rl_point)\n\t    {\n\t      s1 = s = e1;\n\t      break;\n\t    }\n\t   \n\t  FREE (n);\n\t  n = find_cmd_name (s, &s1, &e1);\n\t  s = e1 + 1;\n\t}\n      while (was_assignment = assignment (n, 0));\n      s = s1;\t\t \n\n       \n      if (start == 0 && end == 0 && e != 0 && text[0] == '\\0')\t \n        foundcs = 0;\n      else if (start == end && start == s1 && e != 0 && e1 > end)\t \n\tfoundcs = 0;\n      else if (e == 0 && e == s && text[0] == '\\0' && have_progcomps)\t \n        prog_complete_matches = programmable_completions (EMPTYCMD, text, s, e, &foundcs);\n      else if (start == end && text[0] == '\\0' && s1 > start && whitespace (rl_line_buffer[start]))\n        foundcs = 0;\t\t \n      else if (e > s && was_assignment == 0 && e1 == end && rl_line_buffer[e] == 0 && whitespace (rl_line_buffer[e-1]) == 0)\n\t{\n\t   \n\t  foundcs = 0;\n\t  in_command_position = s == start && STREQ (n, text);\t \n\t}\n      else if (e > s && was_assignment == 0 && have_progcomps)\n\t{\n\t  prog_complete_matches = programmable_completions (n, text, s, e, &foundcs);\n\t   \n\t   \n\t  in_command_position = s == start && (iw_compspec || STREQ (n, text));\t \n\t  if (iw_compspec && in_command_position)\n\t    foundcs = 0;\n\t}\n       \n      else if (s >= e && n[0] == '\\0' && text[0] == '\\0' && start > 0 &&\n\t\twas_assignment == 0 && member (rl_line_buffer[start-1], COMMAND_SEPARATORS))\n\t{\n\t  foundcs = 0;\n\t  in_command_position = 1;\n\t}\n      else if (s >= e && n[0] == '\\0' && text[0] == '\\0' && start > 0)\n        {\n          foundcs = 0;\t \n          in_command_position += was_assignment;\n        }\n      else if (s == start && e == end && STREQ (n, text) && start > 0)\n        {\n          foundcs = 0;\t \n          in_command_position = 1;\n        }\n      else\n\tfoundcs = 0;\n\n       \n      if (in_command_position && have_progcomps && foundcs == 0 && iw_compspec)\n\tprog_complete_matches = programmable_completions (INITIALWORD, text, s, e, &foundcs);\n\n      FREE (n);\n       \n      if (foundcs)\n\t{\n\t  pcomp_set_readline_variables (foundcs, 1);\n\t   \n\t  matches = rl_completion_matches (text, prog_complete_return);\n\t  if ((foundcs & COPT_DEFAULT) == 0)\n\t    rl_attempted_completion_over = 1;\t \n\t  if (matches || ((foundcs & COPT_BASHDEFAULT) == 0))\n\t    return (matches);\n\t}\n    }\n#endif\n\n  if (matches == 0)\n    {\n      dflags = 0;\n      if (in_command_position > 0)\n\tdflags |= DEFCOMP_CMDPOS;\n      matches = bash_default_completion (text, start, end, qc, dflags);\n    }\n\n  return matches;\n}\n\nchar **\nbash_default_completion (text, start, end, qc, compflags)\n     const char *text;\n     int start, end, qc, compflags;\n{\n  char **matches, *t;\n\n  matches = (char **)NULL;\n\n   \n  if (*text == '$')\n    {\n      if (qc != '\\'' && text[1] == '(')  \n\tmatches = rl_completion_matches (text, command_subst_completion_function);\n      else\n\t{\n\t  matches = rl_completion_matches (text, variable_completion_function);\n\t   \n\t  if (matches && matches[0] && matches[1] == 0)\n\t    {\n\t      t = savestring (matches[0]);\n\t      bash_filename_stat_hook (&t);\n\t       \n\t      if (file_isdir (t))\n\t\trl_completion_append_character = '/';\n\t      free (t);\n\t    }\n\t}\n    }\n\n   \n  if (matches == 0 && *text == '~' && mbschr (text, '/') == 0)\n    matches = rl_completion_matches (text, rl_username_completion_function);\n\n   \n  if (matches == 0 && perform_hostname_completion && *text == '@')\n    matches = rl_completion_matches (text, hostname_completion_function);\n\n   \n  if (matches == 0 && (compflags & DEFCOMP_CMDPOS))\n    {\n       \n      if (no_empty_command_completion && end == start && text[0] == '\\0')\n\t{\n\t  matches = (char **)NULL;\n\t  rl_ignore_some_completions_function = bash_ignore_everything;\n\t}\n      else\n\t{\n#define CMD_IS_DIR(x)\t(absolute_pathname(x) == 0 && absolute_program(x) == 0 && *(x) != '~' && test_for_directory (x))\n\n\t  dot_in_path = 0;\n\t  matches = rl_completion_matches (text, command_word_completion_function);\n\n\t   \n\t  if (matches == (char **)NULL)\n\t    rl_ignore_some_completions_function = bash_ignore_filenames;\n\t  else if (matches[1] == 0 && CMD_IS_DIR(matches[0]) && dot_in_path == 0)\n\t     \n\t    {\n\t      rl_completion_suppress_append = 1;\n\t      rl_filename_completion_desired = 0;\n\t    }\n\t  else if (matches[0] && matches[1] && STREQ (matches[0], matches[1]) && CMD_IS_DIR (matches[0]))\n\t     \n\t    {\n\t      rl_completion_suppress_append = 1;\n\t      rl_filename_completion_desired = 0;\n\t    }\n\t}\n    }\n\n   \n  if (!matches && completion_glob_pattern ((char *)text))\n    {\n      matches = rl_completion_matches (text, glob_complete_word);\n       \n      if (matches && matches[1] && rl_completion_type == TAB)\n\t{\n\t  strvec_dispose (matches);\n\t  matches = (char **)0;\n\t}\n      else if (matches && matches[1] && rl_completion_type == '!')\n\t{\n\t  rl_completion_suppress_append = 1;\n\t  rl_filename_completion_desired = 0;\n\t}\n    }\n\n  return (matches);\n}\n\nstatic int\nbash_command_name_stat_hook (name)\n     char **name;\n{\n  char *cname, *result;\n\n   \n  if (absolute_program (*name))\n    return (bash_filename_stat_hook (name));\n\n  cname = *name;\n   \n  result = search_for_command (cname, 0);\n  if (result)\n    {\n      *name = result;\n      return 1;\n    }\n  return 0;\n}\n\nstatic int\nexecutable_completion (filename, searching_path)\n     const char *filename;\n     int searching_path;\n{\n  char *f, c;\n  int r;\n\n   \n#if 0\n  f = savestring (filename);\n#else\n  c = 0;\n  f = bash_quote_filename ((char *)filename, SINGLE_MATCH, &c);\n#endif\n  bash_directory_completion_hook (&f);\n  \n  r = searching_path ? executable_file (f) : executable_or_directory (f);\n  free (f);\n  return r;\n}\n\n \nchar *\ncommand_word_completion_function (hint_text, state)\n     const char *hint_text;\n     int state;\n{\n  static char *hint = (char *)NULL;\n  static char *path = (char *)NULL;\n  static char *val = (char *)NULL;\n  static char *filename_hint = (char *)NULL;\n  static char *fnhint = (char *)NULL;\n  static char *dequoted_hint = (char *)NULL;\n  static char *directory_part = (char *)NULL;\n  static char **glob_matches = (char **)NULL;\n  static int path_index, hint_len, istate, igncase;\n  static int mapping_over, local_index, searching_path, hint_is_dir;\n  static int old_glob_ignore_case, globpat;\n  static SHELL_VAR **varlist = (SHELL_VAR **)NULL;\n#if defined (ALIAS)\n  static alias_t **alias_list = (alias_t **)NULL;\n#endif  \n  char *temp, *cval;\n\n   \n  if (state == 0)\n    {\n      rl_filename_stat_hook = bash_command_name_stat_hook;\n\n      if (dequoted_hint && dequoted_hint != hint)\n\tfree (dequoted_hint);\n      if (hint)\n\tfree (hint);\n\n      mapping_over = searching_path = 0;\n      hint_is_dir = CMD_IS_DIR (hint_text);\n      val = (char *)NULL;\n\n      temp = rl_variable_value (\"completion-ignore-case\");\n      igncase = RL_BOOLEAN_VARIABLE_VALUE (temp);\n\n      old_glob_ignore_case = glob_ignore_case;\n\n      if (glob_matches)\n\t{\n\t  free (glob_matches);\n\t  glob_matches = (char **)NULL;\n\t}\n\n      globpat = completion_glob_pattern ((char *)hint_text);\n\n       \n      if (globpat || absolute_program (hint_text))\n\t{\n\t   \n\t  if (*hint_text == '~')\n\t    {\n\t      hint = bash_tilde_expand (hint_text, 0);\n\t      directory_part = savestring (hint_text);\n\t      temp = strchr (directory_part, '/');\n\t      if (temp)\n\t\t*temp = 0;\n\t      else\n\t\t{\n\t\t  free (directory_part);\n\t\t  directory_part = (char *)NULL;\n\t\t}\n\t    }\n\t  else if (dircomplete_expand)\n\t    {\n\t      hint = savestring (hint_text);\n\t      bash_directory_completion_hook (&hint);\n\t    }\n\t  else\n\t    hint = savestring (hint_text);\n\n\t  dequoted_hint = hint;\n\t   \n\t  if (rl_completion_found_quote && rl_completion_quote_character == 0)\n\t    {\n\t      dequoted_hint = bash_dequote_filename (hint, 0);\n\t      free (hint);\n\t      hint = dequoted_hint;\n\t    }\n\t  hint_len = strlen (hint);\n\n\t  if (filename_hint)\n\t    free (filename_hint);\n\n\t  fnhint = filename_hint = savestring (hint);\n\n\t  istate = 0;\n\n\t  if (globpat)\n\t    {\n\t      mapping_over = 5;\n\t      goto globword;\n\t    }\n\t  else\n\t    {\n\t     if (dircomplete_expand && path_dot_or_dotdot (filename_hint))\n\t\t{\n\t\t  dircomplete_expand = 0;\n\t\t  set_directory_hook ();\n\t\t  dircomplete_expand = 1;\n\t\t}\n\t      mapping_over = 4;\n\t      goto inner;\n\t    }\n\t}\n\n      dequoted_hint = hint = savestring (hint_text);\n      hint_len = strlen (hint);\n\n      if (rl_completion_found_quote && rl_completion_quote_character == 0)\n\tdequoted_hint = bash_dequote_filename (hint, 0);\n      \n      path = get_string_value (\"PATH\");\n      path_index = dot_in_path = 0;\n\n       \n      local_index = 0;\n\n      if (varlist)\n\tfree (varlist);\n\n      varlist = all_visible_functions ();\n\n#if defined (ALIAS)\n      if (alias_list)\n\tfree (alias_list);\n\n      alias_list = all_aliases ();\n#endif  \n    }\n\n   \n\n  switch (mapping_over)\n    {\n    case 0:\t\t\t \n#if defined (ALIAS)\n      while (alias_list && alias_list[local_index])\n\t{\n\t  register char *alias;\n\n\t  alias = alias_list[local_index++]->name;\n\n\t  if (igncase == 0 && (STREQN (alias, hint, hint_len)))\n\t    return (savestring (alias));\n\t  else if (igncase && strncasecmp (alias, hint, hint_len) == 0)\n\t    return (savestring (alias));\n\t}\n#endif  \n      local_index = 0;\n      mapping_over++;\n\n    case 1:\t\t\t \n      {\n\twhile (word_token_alist[local_index].word)\n\t  {\n\t    register char *reserved_word;\n\n\t    reserved_word = word_token_alist[local_index++].word;\n\n\t    if (STREQN (reserved_word, hint, hint_len))\n\t      return (savestring (reserved_word));\n\t  }\n\tlocal_index = 0;\n\tmapping_over++;\n      }\n\n    case 2:\t\t\t \n      while (varlist && varlist[local_index])\n\t{\n\t  register char *varname;\n\n\t  varname = varlist[local_index++]->name;\n\n\t   \n\t  if (igncase == 0 && (STREQN (varname, hint, hint_len)))\n\t    return (savestring (varname));\n\t  else if (igncase && strncasecmp (varname, hint, hint_len) == 0)\n\t    return (savestring (varname));\n\t}\n      local_index = 0;\n      mapping_over++;\n\n    case 3:\t\t\t \n      for (; local_index < num_shell_builtins; local_index++)\n\t{\n\t   \n\t  if (!shell_builtins[local_index].function ||\n\t      (shell_builtins[local_index].flags & BUILTIN_ENABLED) == 0)\n\t    continue;\n\n\t  if (STREQN (shell_builtins[local_index].name, hint, hint_len))\n\t    {\n\t      int i = local_index++;\n\n\t      return (savestring (shell_builtins[i].name));\n\t    }\n\t}\n      local_index = 0;\n      mapping_over++;\n    }\n\nglobword:\n   \n  if (globpat)\n    {\n      if (state == 0)\n\t{\n\t  rl_filename_completion_desired = 1;\n\n\t  glob_ignore_case = igncase;\n\t  glob_matches = shell_glob_filename (hint, 0);\n\t  glob_ignore_case = old_glob_ignore_case;\n\n\t  if (GLOB_FAILED (glob_matches) || glob_matches == 0)\n\t    {\n\t      glob_matches = (char **)NULL;\n\t      return ((char *)NULL);\n\t    }\n\n\t  local_index = 0;\n\t\t\n\t  if (glob_matches[1] && rl_completion_type == TAB)\t \n\t    return ((char *)NULL);\n\t}\n\n      while (val = glob_matches[local_index++])\n        {\n\t  if (executable_or_directory (val))\n\t    {\n\t      if (*hint_text == '~' && directory_part)\n\t\t{\n\t\t  temp = maybe_restore_tilde (val, directory_part);\n\t\t  free (val);\n\t\t  val = temp;\n\t\t}\n\t      return (val);\n\t    }\n\t  free (val);\n        }\n\n      glob_ignore_case = old_glob_ignore_case;\n      return ((char *)NULL);\n    }\n\n   \n  if (hint_is_dir)\n    {\n      hint_is_dir = 0;\t \n      return (savestring (hint_text));\n    }\n    \n   \n outer:\n\n  istate = (val != (char *)NULL);\n\n  if (istate == 0)\n    {\n      char *current_path;\n\n       \n      if (path == 0 || path[path_index] == 0 ||\n\t  (current_path = extract_colon_unit (path, &path_index)) == 0)\n\treturn ((char *)NULL);\n\n      searching_path = 1;\n      if (*current_path == 0)\n\t{\n\t  free (current_path);\n\t  current_path = savestring (\".\");\n\t}\n\n      if (*current_path == '~')\n\t{\n\t  char *t;\n\n\t  t = bash_tilde_expand (current_path, 0);\n\t  free (current_path);\n\t  current_path = t;\n\t}\n\n      if (current_path[0] == '.' && current_path[1] == '\\0')\n\tdot_in_path = 1;\n\n      if (fnhint && fnhint != filename_hint)\n\tfree (fnhint);\n      if (filename_hint)\n\tfree (filename_hint);\n\n      filename_hint = sh_makepath (current_path, hint, 0);\n       \n      if (strpbrk (filename_hint, \"\\\"'\\\\\"))\n\tfnhint = sh_backslash_quote (filename_hint, filename_bstab, 0);\n      else\n\tfnhint = filename_hint;\n      free (current_path);\t\t \n    }\n\n inner:\n  val = rl_filename_completion_function (fnhint, istate);\n  if (mapping_over == 4 && dircomplete_expand)\n    set_directory_hook ();\n\n  istate = 1;\n\n  if (val == 0)\n    {\n       \n      if (absolute_program (hint))\n\treturn ((char *)NULL);\n\n      goto outer;\n    }\n  else\n    {\n      int match, freetemp;\n\n      if (absolute_program (hint))\n\t{\n#if 0\n\t  if (igncase == 0)\n\t    match = strncmp (val, hint, hint_len) == 0;\n\t  else\n\t    match = strncasecmp (val, hint, hint_len) == 0;\n#else\n\t   \n\t  match = 1;\n#endif\n\n\t   \n\t  if (*hint_text == '~')\n\t    temp = maybe_restore_tilde (val, directory_part);\n\t  else\n\t    temp = savestring (val);\n\t  freetemp = 1;\n\t}\n      else\n\t{\n\t  temp = strrchr (val, '/');\n\n\t  if (temp)\n\t    {\n\t      temp++;\n\t      if (igncase == 0)\n\t\tfreetemp = match = strncmp (temp, hint, hint_len) == 0;\n\t      else\n\t\tfreetemp = match = strncasecmp (temp, hint, hint_len) == 0;\n\t      if (match)\n\t\ttemp = savestring (temp);\n\t    }\n\t  else\n\t    freetemp = match = 0;\n\t}\n\n       \n#if 0\n       \n       \n      if (match && searching_path == 0 && *val == '.')\n\t{\n\t  char *t, *t1;\n\n\t  t = get_working_directory (\"command-word-completion\");\n\t  t1 = make_absolute (val, t);\n\t  free (t);\n\t  cval = sh_canonpath (t1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\t}\n      else\n#endif\n\tcval = val;\n\n      if (match && executable_completion ((searching_path ? val : cval), searching_path))\n\t{\n\t  if (cval != val)\n\t    free (cval);\n\t  free (val);\n\t  val = \"\";\t\t \n\t  return (temp);\n\t}\n      else\n\t{\n\t  if (freetemp)\n\t    free (temp);\n\t  if (cval != val)\n\t    free (cval);\n\t  free (val);\n\t  goto inner;\n\t}\n    }\n}\n\n \nstatic char *\ncommand_subst_completion_function (text, state)\n     const char *text;\n     int state;\n{\n  static char **matches = (char **)NULL;\n  static const char *orig_start;\n  static char *filename_text = (char *)NULL;\n  static int cmd_index, start_len;\n  char *value;\n\n  if (state == 0)\n    {\n      if (filename_text)\n\tfree (filename_text);\n      orig_start = text;\n      if (*text == '`')\n\ttext++;\n      else if (*text == '$' && text[1] == '(')\t \n\ttext += 2;\n       \n      rl_completion_suppress_quote = 1;\n      start_len = text - orig_start;\n      filename_text = savestring (text);\n      if (matches)\n\tfree (matches);\n\n       \n      for (value = filename_text + strlen (filename_text) - 1; value > filename_text; value--)\n        if (whitespace (*value) || member (*value, COMMAND_SEPARATORS))\n          break;\n      if (value <= filename_text)\n\tmatches = rl_completion_matches (filename_text, command_word_completion_function);\n      else\n\t{\n\t  value++;\n\t  start_len += value - filename_text;\n\t  if (whitespace (value[-1]))\n\t    matches = rl_completion_matches (value, rl_filename_completion_function);\n\t  else\n\t    matches = rl_completion_matches (value, command_word_completion_function);\n\t}\n\n       \n      cmd_index = matches && matches[0] && matches[1];\n\n       \n      if (matches && matches[0] && matches[1] == 0 && test_for_directory (matches[0]))\n\trl_completion_append_character = '/';\n      else\n\trl_completion_suppress_append = 1;\n    }\n\n  if (matches == 0 || matches[cmd_index] == 0)\n    {\n      rl_filename_quoting_desired = 0;\t \n      return ((char *)NULL);\n    }\n  else\n    {\n      value = (char *)xmalloc (1 + start_len + strlen (matches[cmd_index]));\n\n      if (start_len == 1)\n\tvalue[0] = *orig_start;\n      else\n\tstrncpy (value, orig_start, start_len);\n\n      strcpy (value + start_len, matches[cmd_index]);\n\n      cmd_index++;\n      return (value);\n    }\n}\n\n \nstatic char *\nvariable_completion_function (text, state)\n     const char *text;\n     int state;\n{\n  static char **varlist = (char **)NULL;\n  static int varlist_index;\n  static char *varname = (char *)NULL;\n  static int first_char, first_char_loc;\n\n  if (!state)\n    {\n      if (varname)\n\tfree (varname);\n\n      first_char_loc = 0;\n      first_char = text[0];\n\n      if (first_char == '$')\n\tfirst_char_loc++;\n\n      if (text[first_char_loc] == '{')\n\tfirst_char_loc++;\n\n      varname = savestring (text + first_char_loc);\n\n      if (varlist)\n\tstrvec_dispose (varlist);\n\n      varlist = all_variables_matching_prefix (varname);\n      varlist_index = 0;\n    }\n\n  if (!varlist || !varlist[varlist_index])\n    {\n      return ((char *)NULL);\n    }\n  else\n    {\n      char *value;\n\n      value = (char *)xmalloc (4 + strlen (varlist[varlist_index]));\n\n      if (first_char_loc)\n\t{\n\t  value[0] = first_char;\n\t  if (first_char_loc == 2)\n\t    value[1] = '{';\n\t}\n\n      strcpy (value + first_char_loc, varlist[varlist_index]);\n      if (first_char_loc == 2)\n\tstrcat (value, \"}\");\n\n      varlist_index++;\n      return (value);\n    }\n}\n\n \nstatic char *\nhostname_completion_function (text, state)\n     const char *text;\n     int state;\n{\n  static char **list = (char **)NULL;\n  static int list_index = 0;\n  static int first_char, first_char_loc;\n\n   \n  if (state == 0)\n    {\n      FREE (list);\n\n      list = (char **)NULL;\n\n      first_char_loc = 0;\n      first_char = *text;\n\n      if (first_char == '@')\n\tfirst_char_loc++;\n\n      list = hostnames_matching ((char *)text+first_char_loc);\n      list_index = 0;\n    }\n\n  if (list && list[list_index])\n    {\n      char *t;\n\n      t = (char *)xmalloc (2 + strlen (list[list_index]));\n      *t = first_char;\n      strcpy (t + first_char_loc, list[list_index]);\n      list_index++;\n      return (t);\n    }\n\n  return ((char *)NULL);\n}\n\n \nchar *\nbash_servicename_completion_function (text, state)\n     const char *text;\n     int state;\n{\n#if defined (__WIN32__) || defined (__OPENNT) || !defined (HAVE_GETSERVENT)\n  return ((char *)NULL);\n#else\n  static char *sname = (char *)NULL;\n  static struct servent *srvent;\n  static int snamelen;\n  char *value;\n  char **alist, *aentry;\n  int afound;\n\n  if (state == 0)\n    {\n      FREE (sname);\n\n      sname = savestring (text);\n      snamelen = strlen (sname);\n      setservent (0);\n    }\n\n  while (srvent = getservent ())\n    {\n      afound = 0;\n      if (snamelen == 0 || (STREQN (sname, srvent->s_name, snamelen)))\n\tbreak;\n       \n      for (alist = srvent->s_aliases; *alist; alist++)\n\t{\n\t  aentry = *alist;\n\t  if (STREQN (sname, aentry, snamelen))\n\t    {\n\t      afound = 1;\n\t      break;\n\t    }\n\t}\n\n      if (afound)\n\tbreak;\n    }\n\n  if (srvent == 0)\n    {\n      endservent ();\n      return ((char *)NULL);\n    }\n\n  value = afound ? savestring (aentry) : savestring (srvent->s_name);\n  return value;\n#endif\n}\n\n \nchar *\nbash_groupname_completion_function (text, state)\n     const char *text;\n     int state;\n{\n#if defined (__WIN32__) || defined (__OPENNT) || !defined (HAVE_GRP_H)\n  return ((char *)NULL);\n#else\n  static char *gname = (char *)NULL;\n  static struct group *grent;\n  static int gnamelen;\n  char *value;\n\n  if (state == 0)\n    {\n      FREE (gname);\n      gname = savestring (text);\n      gnamelen = strlen (gname);\n\n      setgrent ();\n    }\n\n  while (grent = getgrent ())\n    {\n      if (gnamelen == 0 || (STREQN (gname, grent->gr_name, gnamelen)))\n        break;\n    }\n\n  if (grent == 0)\n    {\n      endgrent ();\n      return ((char *)NULL);\n    }\n\n  value = savestring (grent->gr_name);\n  return (value);\n#endif\n}\n\n \n\n#if defined (BANG_HISTORY)\n \nstatic char *\nhistory_expand_line_internal (line)\n     char *line;\n{\n  char *new_line;\n  int old_verify;\n\n  old_verify = hist_verify;\n  hist_verify = 0;\n  new_line = pre_process_line (line, 0, 0);\n  hist_verify = old_verify;\n\n  return (new_line == line) ? savestring (line) : new_line;\n}\n#endif\n\n \nstatic void\ncleanup_expansion_error ()\n{\n  char *to_free;\n#if defined (BANG_HISTORY)\n  int old_verify;\n\n  old_verify = hist_verify;\n  hist_verify = 0;\n#endif\n\n  fprintf (rl_outstream, \"\\r\\n\");\n  to_free = pre_process_line (rl_line_buffer, 1, 0);\n#if defined (BANG_HISTORY)\n  hist_verify = old_verify;\n#endif\n  if (to_free != rl_line_buffer)\n    FREE (to_free);\n  putc ('\\r', rl_outstream);\n  rl_forced_update_display ();\n}\n\n \nstatic void\nmaybe_make_readline_line (new_line)\n     char *new_line;\n{\n  if (new_line && strcmp (new_line, rl_line_buffer) != 0)\n    {\n      rl_point = rl_end;\n\n      rl_add_undo (UNDO_BEGIN, 0, 0, 0);\n      rl_delete_text (0, rl_point);\n      rl_point = rl_end = rl_mark = 0;\n      rl_insert_text (new_line);\n      rl_add_undo (UNDO_END, 0, 0, 0);\n    }\n}\n\n \nstatic void\nset_up_new_line (new_line)\n     char *new_line;\n{\n  int old_point, at_end;\n\n  old_point = rl_point;\n  at_end = rl_point == rl_end;\n\n   \n  maybe_make_readline_line (new_line);\n  free (new_line);\n\n   \n  if (at_end)\n    rl_point = rl_end;\n  else if (old_point < rl_end)\n    {\n      rl_point = old_point;\n      if (!whitespace (rl_line_buffer[rl_point]))\n\trl_forward_word (1, 0);\n    }\n}\n\n#if defined (ALIAS)\n \nstatic int\nalias_expand_line (count, ignore)\n     int count, ignore;\n{\n  char *new_line;\n\n  new_line = alias_expand (rl_line_buffer);\n\n  if (new_line)\n    {\n      set_up_new_line (new_line);\n      return (0);\n    }\n  else\n    {\n      cleanup_expansion_error ();\n      return (1);\n    }\n}\n#endif\n\n#if defined (BANG_HISTORY)\n \nstatic int\nhistory_expand_line (count, ignore)\n     int count, ignore;\n{\n  char *new_line;\n\n  new_line = history_expand_line_internal (rl_line_buffer);\n\n  if (new_line)\n    {\n      set_up_new_line (new_line);\n      return (0);\n    }\n  else\n    {\n      cleanup_expansion_error ();\n      return (1);\n    }\n}\n\n \nstatic int\ntcsh_magic_space (count, ignore)\n     int count, ignore;\n{\n  int dist_from_end, old_point;\n\n  old_point = rl_point;\n  dist_from_end = rl_end - rl_point;\n  if (history_expand_line (count, ignore) == 0)\n    {\n       \n      rl_point = (old_point == 0) ? old_point : rl_end - dist_from_end;\n      rl_insert (1, ' ');\n      return (0);\n    }\n  else\n    return (1);\n}\n#endif  \n\n \nstatic int\nhistory_and_alias_expand_line (count, ignore)\n     int count, ignore;\n{\n  char *new_line, *t;\n\n  new_line = 0;\n#if defined (BANG_HISTORY)\n  new_line = history_expand_line_internal (rl_line_buffer);\n#endif\n\n#if defined (ALIAS)\n  if (new_line)\n    {\n      char *alias_line;\n\n      alias_line = alias_expand (new_line);\n      free (new_line);\n      new_line = alias_line;\n    }\n#endif  \n\n  if (new_line)\n    {\n      set_up_new_line (new_line);\n      return (0);\n    }\n  else\n    {\n      cleanup_expansion_error ();\n      return (1);\n    }\n}\n\n \nstatic int\nshell_expand_line (count, ignore)\n     int count, ignore;\n{\n  char *new_line, *t;\n  WORD_LIST *expanded_string;\n  WORD_DESC *w;\n\n  new_line = 0;\n#if defined (BANG_HISTORY)\n  new_line = history_expand_line_internal (rl_line_buffer);\n#endif\n\n  t = expand_string_dollar_quote (new_line ? new_line : rl_line_buffer, 0);\n  FREE (new_line);\n  new_line = t;\n\n#if defined (ALIAS)\n  if (new_line)\n    {\n      char *alias_line;\n\n      alias_line = alias_expand (new_line);\n      free (new_line);\n      new_line = alias_line;\n    }\n#endif  \n\n  if (new_line)\n    {\n      int old_point = rl_point;\n      int at_end = rl_point == rl_end;\n\n       \n      maybe_make_readline_line (new_line);\n      free (new_line);\n\n       \n\n#if 1\n      w = alloc_word_desc ();\n      w->word = savestring (rl_line_buffer);\n      w->flags = rl_explicit_arg ? (W_NOPROCSUB|W_NOCOMSUB) : 0;\n      expanded_string = expand_word (w, rl_explicit_arg ? Q_HERE_DOCUMENT : 0);\n      dispose_word (w);\n#else\n      new_line = savestring (rl_line_buffer);\n      expanded_string = expand_string (new_line, 0);\n      FREE (new_line);\n#endif\n\n      if (expanded_string == 0)\n\t{\n\t  new_line = (char *)xmalloc (1);\n\t  new_line[0] = '\\0';\n\t}\n      else\n\t{\n\t  new_line = string_list (expanded_string);\n\t  dispose_words (expanded_string);\n\t}\n\n      maybe_make_readline_line (new_line);\n      free (new_line);\n\n       \n      if (at_end)\n\trl_point = rl_end;\n      else if (old_point < rl_end)\n\t{\n\t  rl_point = old_point;\n\t  if (!whitespace (rl_line_buffer[rl_point]))\n\t    rl_forward_word (1, 0);\n\t}\n      return 0;\n    }\n  else\n    {\n      cleanup_expansion_error ();\n      return 1;\n    }\n}\n\n \n\nstatic struct ignorevar fignore =\n{\n  \"FIGNORE\",\n  (struct ign *)0,\n  0,\n  (char *)0,\n  (sh_iv_item_func_t *) 0,\n};\n\nstatic void\n_ignore_completion_names (names, name_func)\n     char **names;\n     sh_ignore_func_t *name_func;\n{\n  char **newnames;\n  int idx, nidx;\n  char **oldnames;\n  int oidx;\n\n   \n  if (names[1] == (char *)0)\n    {\n      if (force_fignore)\n\tif ((*name_func) (names[0]) == 0)\n\t  {\n\t    free (names[0]);\n\t    names[0] = (char *)NULL;\n\t  }\n\n      return;\n    }\n\n   \n  for (nidx = 1; names[nidx]; nidx++)\n    ;\n  newnames = strvec_create (nidx + 1);\n\n  if (force_fignore == 0)\n    {\n      oldnames = strvec_create (nidx - 1);\n      oidx = 0;\n    }\n\n  newnames[0] = names[0];\n  for (idx = nidx = 1; names[idx]; idx++)\n    {\n      if ((*name_func) (names[idx]))\n\tnewnames[nidx++] = names[idx];\n      else if (force_fignore == 0)\n\toldnames[oidx++] = names[idx];\n      else\n\tfree (names[idx]);\n    }\n\n  newnames[nidx] = (char *)NULL;\n\n   \n  if (nidx == 1)\n    {\n      if (force_fignore)\n\t{\n\t  free (names[0]);\n\t  names[0] = (char *)NULL;\n\t}\n      else\n\tfree (oldnames);\n\n      free (newnames);\n      return;\n    }\n\n  if (force_fignore == 0)\n    {\n      while (oidx)\n\tfree (oldnames[--oidx]);\n      free (oldnames);\n    }\n\n   \n  if (nidx == 2)\n    {\n      free (names[0]);\n      names[0] = newnames[1];\n      names[1] = (char *)NULL;\n      free (newnames);\n      return;\n    }\n\n   \n  for (nidx = 1; newnames[nidx]; nidx++)\n    names[nidx] = newnames[nidx];\n  names[nidx] = (char *)NULL;\n  free (newnames);\n}\n\nstatic int\nname_is_acceptable (name)\n     const char *name;\n{\n  struct ign *p;\n  int nlen;\n\n  for (nlen = strlen (name), p = fignore.ignores; p->val; p++)\n    {\n      if (nlen > p->len && p->len > 0 && STREQ (p->val, &name[nlen - p->len]))\n\treturn (0);\n    }\n\n  return (1);\n}\n\n#if 0\nstatic int\nignore_dot_names (name)\n     char *name;\n{\n  return (name[0] != '.');\n}\n#endif\n\nstatic int\nfilename_completion_ignore (names)\n     char **names;\n{\n#if 0\n  if (glob_dot_filenames == 0)\n    _ignore_completion_names (names, ignore_dot_names);\n#endif\n\n  setup_ignore_patterns (&fignore);\n\n  if (fignore.num_ignores == 0)\n    return 0;\n\n  _ignore_completion_names (names, name_is_acceptable);\n\n  return 0;\n}\n\n \nstatic int\ntest_for_directory (name)\n     const char *name;\n{\n  char *fn;\n  int r;\n\n  fn = bash_tilde_expand (name, 0);\n  r = file_isdir (fn);\n  free (fn);\n\n  return (r);\n}\n\nstatic int\ntest_for_canon_directory (name)\n     const char *name;\n{\n  char *fn;\n  int r;\n\n  fn = (*name == '~') ? bash_tilde_expand (name, 0) : savestring (name);\n  bash_filename_stat_hook (&fn);\n  r = file_isdir (fn);\n  free (fn);\n\n  return (r);\n}\n\n \nstatic int\nbash_ignore_filenames (names)\n     char **names;\n{\n  _ignore_completion_names (names, test_for_directory);\n  return 0;\n}\n\nstatic int\nbash_progcomp_ignore_filenames (names)\n     char **names;\n{\n  _ignore_completion_names (names, test_for_canon_directory);\n  return 0;\n}\n\nstatic int\nreturn_zero (name)\n     const char *name;\n{\n  return 0;\n}\n\nstatic int\nbash_ignore_everything (names)\n     char **names;\n{\n  _ignore_completion_names (names, return_zero);\n  return 0;\n}\n\n \nstatic char *\nrestore_tilde (val, directory_part)\n     char *val, *directory_part;\n{\n  int l, vl, dl2, xl;\n  char *dh2, *expdir, *ret, *v;\n\n  vl = strlen (val);\n\n   \n  dh2 = directory_part ? bash_dequote_filename (directory_part, 0) : 0;\n  bash_directory_expansion (&dh2);\n  dl2 = strlen (dh2);\n\n  expdir = bash_tilde_expand (directory_part, 0);\n  xl = strlen (expdir);\n  if (*directory_part == '~' && STREQ (directory_part, expdir))\n    {\n       \n      v = mbschr (val, '/');\n      vl = STRLEN (v);\n      ret = (char *)xmalloc (xl + vl + 2);\n      strcpy (ret, directory_part);\n      if (v && *v)\n\tstrcpy (ret + xl, v);\n\n      free (dh2);\n      free (expdir);\n\n      return ret;\n    }\n  free (expdir);\n\n   \n  l = (vl - xl) + 1;\n  if (l <= 0)\n    {\n      free (dh2);\n      return (savestring (val));\t\t \n    }\n\n  ret = (char *)xmalloc (dl2 + 2 + l);\n  strcpy (ret, dh2);\n  strcpy (ret + dl2, val + xl);\n\n  free (dh2);\n  return (ret);\n}\n\nstatic char *\nmaybe_restore_tilde (val, directory_part)\n     char *val, *directory_part;\n{\n  rl_icppfunc_t *save;\n  char *ret;\n\n  save = (dircomplete_expand == 0) ? save_directory_hook () : (rl_icppfunc_t *)0;\n  ret = restore_tilde (val, directory_part);\n  if (save)\n    restore_directory_hook (save);\n  return ret;\n}\n\n \nstatic void\nbash_directory_expansion (dirname)\n     char **dirname;\n{\n  char *d, *nd;\n\n  d = savestring (*dirname);\n\n  if ((rl_directory_rewrite_hook) && (*rl_directory_rewrite_hook) (&d))\n    {\n      free (*dirname);\n      *dirname = d;\n    }\n  else if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&d))\n    {\n      free (*dirname);\n      *dirname = d;\n    }\n  else if (rl_completion_found_quote)\n    {\n      nd = bash_dequote_filename (d, rl_completion_quote_character);\n      free (*dirname);\n      free (d);\n      *dirname = nd;\n    }\n  else\n    free (d);\n}\n\n \nstatic char *\nbash_filename_rewrite_hook (fname, fnlen)\n     char *fname;\n     int fnlen;\n{\n  char *conv;\n\n  conv = fnx_fromfs (fname, fnlen);\n  if (conv != fname)\n    conv = savestring (conv);\n  return conv;\n}\n\n \n \nvoid\nset_directory_hook ()\n{\n  if (dircomplete_expand)\n    {\n      rl_directory_completion_hook = bash_directory_completion_hook;\n      rl_directory_rewrite_hook = (rl_icppfunc_t *)0;\n    }\n  else\n    {\n      rl_directory_rewrite_hook = bash_directory_completion_hook;\n      rl_directory_completion_hook = (rl_icppfunc_t *)0;\n    }\n}\n\nstatic rl_icppfunc_t *\nsave_directory_hook ()\n{\n  rl_icppfunc_t *ret;\n\n  if (dircomplete_expand)\n    {\n      ret = rl_directory_completion_hook;\n      rl_directory_completion_hook = (rl_icppfunc_t *)NULL;\n    }\n  else\n    {\n      ret = rl_directory_rewrite_hook;\n      rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;\n    }\n\n  return ret;\n}\n\nstatic void\nrestore_directory_hook (hookf)\n     rl_icppfunc_t *hookf;\n{\n  if (dircomplete_expand)\n    rl_directory_completion_hook = hookf;\n  else\n    rl_directory_rewrite_hook = hookf;\n}\n\n \nstatic int\ndirectory_exists (dirname, should_dequote)\n     const char *dirname;\n     int should_dequote;\n{\n  char *new_dirname;\n  int dirlen, r;\n  struct stat sb;\n\n   \n  new_dirname = should_dequote ? bash_dequote_filename ((char *)dirname, rl_completion_quote_character) : savestring (dirname);\n  dirlen = STRLEN (new_dirname);\n  if (new_dirname[dirlen - 1] == '/')\n    new_dirname[dirlen - 1] = '\\0';\n#if defined (HAVE_LSTAT)\n  r = lstat (new_dirname, &sb) == 0;\n#else\n  r = stat (new_dirname, &sb) == 0;\n#endif\n  free (new_dirname);\n  return (r);\n}\n  \n \nstatic int\nbash_filename_stat_hook (dirname)\n     char **dirname;\n{\n  char *local_dirname, *new_dirname, *t;\n  int should_expand_dirname, return_value;\n  int global_nounset;\n  WORD_LIST *wl;\n\n  local_dirname = *dirname;\n  should_expand_dirname = return_value = 0;\n  if (t = mbschr (local_dirname, '$'))\n    should_expand_dirname = '$';\n  else if (t = mbschr (local_dirname, '`'))\t \n    should_expand_dirname = '`';\n\n  if (should_expand_dirname && directory_exists (local_dirname, 0))\n    should_expand_dirname = 0;\n  \n  if (should_expand_dirname)  \n    {\n      new_dirname = savestring (local_dirname);\n       \n      global_nounset = unbound_vars_is_error;\n      unbound_vars_is_error = 0;\n      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB|W_NOPROCSUB|W_COMPLETE);\t \n      unbound_vars_is_error = global_nounset;\n      if (wl)\n\t{\n\t  free (new_dirname);\n\t  new_dirname = string_list (wl);\n\t   \n\t  if (new_dirname && *new_dirname)\n\t    {\n\t      free (local_dirname);\t \n\t      local_dirname = *dirname = new_dirname;\n\t      return_value = STREQ (local_dirname, *dirname) == 0;\n\t    }\n\t  else\n\t    free (new_dirname);\n\t  dispose_words (wl);\n\t}\n      else\n\tfree (new_dirname);\n    }\t\n\n   \n  if (no_symbolic_links == 0 && (local_dirname[0] != '.' || local_dirname[1]))\n    {\n      char *temp1, *temp2;\n\n      t = get_working_directory (\"symlink-hook\");\n      temp1 = make_absolute (local_dirname, t);\n      free (t);\n      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\n       \n      if (temp2 == 0)\n\t{\n\t  free (temp1);\n\t  return return_value;\n\t}\n\n      free (local_dirname);\n      *dirname = temp2;\n      free (temp1);\n    }\n\n  return (return_value);\n}\n\n \nstatic int\nbash_directory_completion_hook (dirname)\n     char **dirname;\n{\n  char *local_dirname, *new_dirname, *t;\n  int return_value, should_expand_dirname, nextch, closer;\n  WORD_LIST *wl;\n\n  return_value = should_expand_dirname = nextch = closer = 0;\n  local_dirname = *dirname;\n\n  should_expand_dirname = bash_check_expchar (local_dirname, 1, &nextch, &closer);\n\n  if (should_expand_dirname && directory_exists (local_dirname, 1))\n    should_expand_dirname = 0;\n\n  if (should_expand_dirname)  \n    {\n      new_dirname = savestring (local_dirname);\n      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB|W_NOPROCSUB|W_COMPLETE);\t \n      if (wl)\n\t{\n\t  *dirname = string_list (wl);\n\t   \n\t  return_value = STREQ (local_dirname, *dirname) == 0;\n\t  free (local_dirname);\n\t  free (new_dirname);\n\t  dispose_words (wl);\n\t  local_dirname = *dirname;\n\n\t  set_filename_quote_chars (should_expand_dirname, nextch, closer);\n\t}\n      else\n\t{\n\t  free (new_dirname);\n\t  free (local_dirname);\n\t  *dirname = (char *)xmalloc (1);\n\t  **dirname = '\\0';\n\t  return 1;\n\t}\n    }\n  else \n    {\n       \n      new_dirname = bash_dequote_filename (local_dirname, rl_completion_quote_character);\n      return_value = STREQ (local_dirname, new_dirname) == 0;\n      free (local_dirname);\n      local_dirname = *dirname = new_dirname;\n    }\n\n   \n\n   \n  if (no_symbolic_links == 0 && (local_dirname[0] != '.' || local_dirname[1]))\n    {\n      char *temp1, *temp2;\n      int len1, len2;\n\n       \n      t = get_working_directory (\"symlink-hook\");\n      temp1 = make_absolute (local_dirname, t);\n      free (t);\n      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\n       \n      if (temp2 == 0 && dircomplete_spelling && dircomplete_expand)\n\t{\n\t  size_t l1, l2;\n\n\t  temp2 = dirspell (temp1);\n\t  l2 = STRLEN (temp2);\n\t   \n\t  if (temp2 && l2 < strlen (temp1) && STREQN (temp1, temp2, l2))\n\t    {\n\t      free (temp2);\n\t      temp2 = 0;\n\t    }\n\t  if (temp2)\n\t    {\n\t      free (temp1);\n\t      temp1 = temp2;\n\t      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\t      return_value |= temp2 != 0;\n\t    }\n\t}\n       \n      if (temp2 == 0)\n\t{\n\t  free (temp1);\n\t  return return_value;\n\t}\n      len1 = strlen (temp1);\n      if (temp1[len1 - 1] == '/')\n\t{\n\t  len2 = strlen (temp2);\n\t  if (len2 > 2)\t\t \n\t    {\n\t      temp2 = (char *)xrealloc (temp2, len2 + 2);\n\t      temp2[len2] = '/';\n\t      temp2[len2 + 1] = '\\0';\n\t    }\n\t}\n\n       \n      if (dircomplete_expand_relpath || ((local_dirname[0] != '/' && local_dirname[0] != '.') && STREQ (temp1, temp2) == 0))\n\treturn_value |= STREQ (local_dirname, temp2) == 0;\n      free (local_dirname);\n      *dirname = temp2;\n      free (temp1);\n    }\n\n  return (return_value);\n}\n\nstatic char **history_completion_array = (char **)NULL;\nstatic int harry_size;\nstatic int harry_len;\n\nstatic void\nbuild_history_completion_array ()\n{\n  register int i, j;\n  HIST_ENTRY **hlist;\n  char **tokens;\n\n   \n  if (harry_size)\n    {\n      strvec_dispose (history_completion_array);\n      history_completion_array = (char **)NULL;\n      harry_size = 0;\n      harry_len = 0;\n    }\n\n   \n  hlist = history_list ();\n\n  if (hlist)\n    {\n      for (i = 0; hlist[i]; i++)\n\t;\n      for ( --i; i >= 0; i--)\n\t{\n\t   \n\t  tokens = history_tokenize (hlist[i]->line);\n\n\t  for (j = 0; tokens && tokens[j]; j++)\n\t    {\n\t      if (harry_len + 2 > harry_size)\n\t        history_completion_array = strvec_resize (history_completion_array, harry_size += 10);\n\n\t      history_completion_array[harry_len++] = tokens[j];\n\t      history_completion_array[harry_len] = (char *)NULL;\n\t    }\n\t  free (tokens);\n\t}\n\n       \n      if (dabbrev_expand_active == 0)\n        qsort (history_completion_array, harry_len, sizeof (char *), (QSFUNC *)strvec_strcmp);\n    }\n}\n\nstatic char *\nhistory_completion_generator (hint_text, state)\n     const char *hint_text;\n     int state;\n{\n  static int local_index, len;\n  static const char *text;\n\n   \n  if (state == 0)\n    {\n      if (dabbrev_expand_active)\t \n\trl_completion_suppress_append = 1;\n      local_index = 0;\n      build_history_completion_array ();\n      text = hint_text;\n      len = strlen (text);\n    }\n\n  while (history_completion_array && history_completion_array[local_index])\n    {\n       \n      if (strncmp (text, history_completion_array[local_index++], len) == 0)\n\treturn (savestring (history_completion_array[local_index - 1]));\n    }\n  return ((char *)NULL);\n}\n\nstatic int\ndynamic_complete_history (count, key)\n     int count, key;\n{\n  int r;\n  rl_compentry_func_t *orig_func;\n  rl_completion_func_t *orig_attempt_func;\n  rl_compignore_func_t *orig_ignore_func;\n\n  orig_func = rl_completion_entry_function;\n  orig_attempt_func = rl_attempted_completion_function;\n  orig_ignore_func = rl_ignore_some_completions_function;\n\n  rl_completion_entry_function = history_completion_generator;\n  rl_attempted_completion_function = (rl_completion_func_t *)NULL;\n  rl_ignore_some_completions_function = filename_completion_ignore;\n\n   \n  if (rl_last_func == dynamic_complete_history)\n    r = rl_complete_internal ('?');\n  else\n    r = rl_complete_internal (TAB);\n\n  rl_completion_entry_function = orig_func;\n  rl_attempted_completion_function = orig_attempt_func;\n  rl_ignore_some_completions_function = orig_ignore_func;\n\n  return r;\n}\n\nstatic int\nbash_dabbrev_expand (count, key)\n     int count, key;\n{\n  int r, orig_suppress, orig_sort;\n  rl_compentry_func_t *orig_func;\n  rl_completion_func_t *orig_attempt_func;\n  rl_compignore_func_t *orig_ignore_func;\n\n  orig_func = rl_menu_completion_entry_function;\n  orig_attempt_func = rl_attempted_completion_function;\n  orig_ignore_func = rl_ignore_some_completions_function;\n  orig_suppress = rl_completion_suppress_append;\n  orig_sort = rl_sort_completion_matches;\n\n  rl_menu_completion_entry_function = history_completion_generator;\n  rl_attempted_completion_function = (rl_completion_func_t *)NULL;\n  rl_ignore_some_completions_function = filename_completion_ignore;\n  rl_filename_completion_desired = 0;\n  rl_completion_suppress_append = 1;\n  rl_sort_completion_matches = 0;\n\n   \n  dabbrev_expand_active = 1;\n  if (rl_last_func == bash_dabbrev_expand)\n    rl_last_func = rl_menu_complete;\n  r = rl_menu_complete (count, key);\n  dabbrev_expand_active = 0;\n\n  rl_last_func = bash_dabbrev_expand;\n  rl_menu_completion_entry_function = orig_func;\n  rl_attempted_completion_function = orig_attempt_func;\n  rl_ignore_some_completions_function = orig_ignore_func;\n  rl_completion_suppress_append = orig_suppress;\n  rl_sort_completion_matches = orig_sort;\n\n  return r;\n}\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\nstatic int\nbash_complete_username (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_username_internal (rl_completion_mode (bash_complete_username));\n}\n\nstatic int\nbash_possible_username_completions (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_username_internal ('?');\n}\n\nstatic int\nbash_complete_username_internal (what_to_do)\n     int what_to_do;\n{\n  return bash_specific_completion (what_to_do, rl_username_completion_function);\n}\n\nstatic int\nbash_complete_filename (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_filename_internal (rl_completion_mode (bash_complete_filename));\n}\n\nstatic int\nbash_possible_filename_completions (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_filename_internal ('?');\n}\n\nstatic int\nbash_complete_filename_internal (what_to_do)\n     int what_to_do;\n{\n  rl_compentry_func_t *orig_func;\n  rl_completion_func_t *orig_attempt_func;\n  rl_icppfunc_t *orig_dir_func;\n  rl_compignore_func_t *orig_ignore_func;\n  const char *orig_rl_completer_word_break_characters;\n  int r;\n\n  orig_func = rl_completion_entry_function;\n  orig_attempt_func = rl_attempted_completion_function;\n  orig_ignore_func = rl_ignore_some_completions_function;\n  orig_rl_completer_word_break_characters = rl_completer_word_break_characters;\n\n  orig_dir_func = save_directory_hook ();\n\n  rl_completion_entry_function = rl_filename_completion_function;\n  rl_attempted_completion_function = (rl_completion_func_t *)NULL;\n  rl_ignore_some_completions_function = filename_completion_ignore;\n  rl_completer_word_break_characters = \" \\t\\n\\\"\\'\";\n\n  r = rl_complete_internal (what_to_do);\n\n  rl_completion_entry_function = orig_func;\n  rl_attempted_completion_function = orig_attempt_func;\n  rl_ignore_some_completions_function = orig_ignore_func;\n  rl_completer_word_break_characters = orig_rl_completer_word_break_characters;\n\n  restore_directory_hook (orig_dir_func);\n\n  return r;\n}\n\nstatic int\nbash_complete_hostname (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_hostname_internal (rl_completion_mode (bash_complete_hostname));\n}\n\nstatic int\nbash_possible_hostname_completions (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_hostname_internal ('?');\n}\n\nstatic int\nbash_complete_variable (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_variable_internal (rl_completion_mode (bash_complete_variable));\n}\n\nstatic int\nbash_possible_variable_completions (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_variable_internal ('?');\n}\n\nstatic int\nbash_complete_command (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_command_internal (rl_completion_mode (bash_complete_command));\n}\n\nstatic int\nbash_possible_command_completions (ignore, ignore2)\n     int ignore, ignore2;\n{\n  return bash_complete_command_internal ('?');\n}\n\nstatic int\nbash_complete_hostname_internal (what_to_do)\n     int what_to_do;\n{\n  return bash_specific_completion (what_to_do, hostname_completion_function);\n}\n\nstatic int\nbash_complete_variable_internal (what_to_do)\n     int what_to_do;\n{\n  return bash_specific_completion (what_to_do, variable_completion_function);\n}\n\nstatic int\nbash_complete_command_internal (what_to_do)\n     int what_to_do;\n{\n  return bash_specific_completion (what_to_do, command_word_completion_function);\n}\n\nstatic int\ncompletion_glob_pattern (string)\n     char *string;\n{\n  return (glob_pattern_p (string) == 1);\n}\n\nstatic char *globtext;\nstatic char *globorig;\n\nstatic char *\nglob_complete_word (text, state)\n     const char *text;\n     int state;\n{\n  static char **matches = (char **)NULL;\n  static int ind;\n  int glen;\n  char *ret, *ttext;\n\n  if (state == 0)\n    {\n      rl_filename_completion_desired = 1;\n      FREE (matches);\n      if (globorig != globtext)\n\tFREE (globorig);\n      FREE (globtext);\n\n      ttext = bash_tilde_expand (text, 0);\n\n      if (rl_explicit_arg)\n\t{\n\t  globorig = savestring (ttext);\n\t  glen = strlen (ttext);\n\t  globtext = (char *)xmalloc (glen + 2);\n\t  strcpy (globtext, ttext);\n\t  globtext[glen] = '*';\n\t  globtext[glen+1] = '\\0';\n\t}\n      else\n        globtext = globorig = savestring (ttext);\n\n      if (ttext != text)\n\tfree (ttext);\n\n      matches = shell_glob_filename (globtext, 0);\n      if (GLOB_FAILED (matches))\n\tmatches = (char **)NULL;\n      ind = 0;\n    }\n\n  ret = matches ? matches[ind] : (char *)NULL;\n  ind++;\n  return ret;\n}\n\nstatic int\nbash_glob_completion_internal (what_to_do)\n     int what_to_do;\n{\n  return bash_specific_completion (what_to_do, glob_complete_word);\n}\n\n \nstatic char *\nbash_glob_quote_filename (s, rtype, qcp)\n     char *s;\n     int rtype;\n     char *qcp;\n{\n  if (globorig && qcp && *qcp == '\\0' && STREQ (s, globorig))\n    return (savestring (s));\n  else\n    return (bash_quote_filename (s, rtype, qcp));\n}\n\nstatic int\nbash_glob_complete_word (count, key)\n     int count, key;\n{\n  int r;\n  rl_quote_func_t *orig_quoting_function;\n\n  if (rl_editing_mode == EMACS_EDITING_MODE)\n    rl_explicit_arg = 1;\t \n  orig_quoting_function = rl_filename_quoting_function;\n  rl_filename_quoting_function = bash_glob_quote_filename;\n  \n  r = bash_glob_completion_internal (rl_completion_mode (bash_glob_complete_word));\n\n  rl_filename_quoting_function = orig_quoting_function;\n  return r;\n}\n\nstatic int\nbash_glob_expand_word (count, key)\n     int count, key;\n{\n  return bash_glob_completion_internal ('*');\n}\n\nstatic int\nbash_glob_list_expansions (count, key)\n     int count, key;\n{\n  return bash_glob_completion_internal ('?');\n}\n\nstatic int\nbash_specific_completion (what_to_do, generator)\n     int what_to_do;\n     rl_compentry_func_t *generator;\n{\n  rl_compentry_func_t *orig_func;\n  rl_completion_func_t *orig_attempt_func;\n  rl_compignore_func_t *orig_ignore_func;\n  int r;\n\n  orig_func = rl_completion_entry_function;\n  orig_attempt_func = rl_attempted_completion_function;\n  orig_ignore_func = rl_ignore_some_completions_function;\n  rl_completion_entry_function = generator;\n  rl_attempted_completion_function = NULL;\n  rl_ignore_some_completions_function = orig_ignore_func;\n\n  r = rl_complete_internal (what_to_do);\n\n  rl_completion_entry_function = orig_func;\n  rl_attempted_completion_function = orig_attempt_func;\n  rl_ignore_some_completions_function = orig_ignore_func;\n\n  return r;\n}\n\n#endif\t \n\n#if defined (VI_MODE)\n \nstatic int\nbash_vi_complete (count, key)\n     int count, key;\n{\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  int p, r;\n  char *t;\n\n  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))\n    {\n      if (!whitespace (rl_line_buffer[rl_point + 1]))\n\trl_vi_end_word (1, 'E');\n      rl_point++;\n    }\n\n   \n  t = 0;\n  if (rl_point > 0)\n    {\n      p = rl_point;\n      rl_vi_bWord (1, 'B');\n      r = rl_point;\n      rl_point = p;\n      p = r;\n\n      t = substring (rl_line_buffer, p, rl_point);\n    }      \n\n  if (t && completion_glob_pattern (t) == 0)\n    rl_explicit_arg = 1;\t \n  FREE (t);\n\n  if (key == '*')\t \n    r = bash_glob_expand_word (count, key);\n  else if (key == '=')\t \n    r = bash_glob_list_expansions (count, key);\n  else if (key == '\\\\')\t \n    r = bash_glob_complete_word (count, key);\n  else\n    r = rl_complete (0, key);\n\n  if (key == '*' || key == '\\\\')\n    rl_vi_start_inserting (key, 1, 1);\n\n  return (r);\n#else\n  return rl_vi_complete (count, key);\n#endif  \n}\n#endif  \n\n \n \nstatic char *\nbash_dequote_filename (text, quote_char)\n     char *text;\n     int quote_char;\n{\n  char *ret, *p, *r;\n  int l, quoted;\n\n  l = strlen (text);\n  ret = (char *)xmalloc (l + 1);\n  for (quoted = quote_char, p = text, r = ret; p && *p; p++)\n    {\n       \n      if (*p == '\\\\')\n\t{\n\t   \n\t  if (quoted == '\\'')\n\t    *r++ = *p;\n\t   \n\t  else if (quoted == '\"' && ((sh_syntaxtab[(unsigned char)p[1]] & CBSDQUOTE) == 0))\n\t    *r++ = *p;\n\n\t  *r++ = *++p;\n\t  if (*p == '\\0')\n\t    return ret;\t\t \n\t  continue;\n\t}\n       \n      if (quoted && *p == quoted)\n\t{\n\t  quoted = 0;\n\t  continue;\n\t}\n       \n      if (quoted == 0 && (*p == '\\'' || *p == '\"'))\n\t{\n\t  quoted = *p;\n\t  continue;\n\t}\n      *r++ = *p;\n    }\n  *r = '\\0';\n  return ret;\n}\n\n \nstatic char *\nquote_word_break_chars (text)\n     char *text;\n{\n  char *ret, *r, *s;\n  int l;\n\n  l = strlen (text);\n  ret = (char *)xmalloc ((2 * l) + 1);\n  for (s = text, r = ret; *s; s++)\n    {\n       \n      if (*s == '\\\\')\n\t{\n\t  *r++ = '\\\\';\n\t  *r++ = *++s;\n\t  if (*s == '\\0')\n\t    break;\n\t  continue;\n\t}\n       \n      if (mbschr (rl_completer_word_break_characters, *s))\n\t*r++ = '\\\\';\n       \n      if (s == text && *s == '~' && file_exists (text))\n        *r++ = '\\\\';\n      *r++ = *s;\n    }\n  *r = '\\0';\n  return ret;\n}\n\n \nstatic int\nbash_check_expchar (dirname, need_closer, nextp, closerp)\n     char *dirname;\n     int need_closer;\n     int *nextp, *closerp;\n{\n  char *t;\n  int ret, n, c;\n\n  ret = n = c = 0;\n  if (t = mbschr (dirname, '$'))\n    {\n      ret = '$';\n      n = t[1];\n       \n      if (n == '(')\n\tc = ')';\n      else if (n == '{')\n\tc = '}';\n      else\n\tn = 0;\n\n      if (c && need_closer)\t\t \n\t{\n\t  int p;\n\t  char delims[2];\n\n\t  delims[0] = c; delims[1] = 0;\n\t  p = skip_to_delim (t, 1, delims, SD_NOJMP|SD_COMPLETE);\n\t  if (t[p] != c)\n\t    ret = 0;\n\t}\n    }\n  else if (dirname[0] == '~')\n    ret = '~';\n  else\n    {\n      t = mbschr (dirname, '`');\n      if (t)\n\t{\n\t  if (need_closer == 0)\n\t    ret = '`';\n\t  else if (unclosed_pair (dirname, strlen (dirname), \"`\") == 0)\n\t    ret = '`';\n\t}\n    }\n\n  if (nextp)\n    *nextp = n;\n  if (closerp)\n    *closerp = c;\n\n  return ret;\n}\n\n \nstatic void\nset_filename_quote_chars (expchar, nextch, closer)\n     int expchar, nextch, closer;\n{\n  int i, j, c;\n\n  if (rl_filename_quote_characters && *rl_filename_quote_characters)\n    {\n      i = strlen (default_filename_quote_characters);\n      custom_filename_quote_characters = xrealloc (custom_filename_quote_characters, i+1);\n      for (i = j = 0; c = default_filename_quote_characters[i]; i++)\n\t{\n\t  if (c == expchar || c == nextch || c == closer)\n\t    continue;\n\t  custom_filename_quote_characters[j++] = c;\n\t}\n      custom_filename_quote_characters[j] = '\\0';\n      rl_filename_quote_characters = custom_filename_quote_characters;\n      set_filename_bstab (rl_filename_quote_characters);\n    }\n}\n\n \nstatic void\nset_filename_bstab (string)\n     const char *string;\n{\n  const char *s;\n\n  memset (filename_bstab, 0, sizeof (filename_bstab));\n  for (s = string; s && *s; s++)\n    filename_bstab[(unsigned char)*s] = 1;\n}\n\n \nstatic char *\nbash_quote_filename (s, rtype, qcp)\n     char *s;\n     int rtype;\n     char *qcp;\n{\n  char *rtext, *mtext, *ret;\n  int rlen, cs;\n  int expchar, nextch, closer;\n\n  rtext = (char *)NULL;\n\n   \n\n  cs = completion_quoting_style;\n   \n  expchar = nextch = closer = 0;\n  if (*qcp == '\\0' && cs == COMPLETE_BSQUOTE && dircomplete_expand == 0 &&\n      (expchar = bash_check_expchar (s, 0, &nextch, &closer)) &&\n      file_exists (s) == 0)\n    {\n       \n      if (rl_filename_quote_characters != custom_filename_quote_characters)\n\tset_filename_quote_chars (expchar, nextch, closer);\n      complete_fullquote = 0;\n    }\n  else if (*qcp == '\\0' && cs == COMPLETE_BSQUOTE && mbschr (s, '\\n'))\n    cs = COMPLETE_SQUOTE;\n  else if (*qcp == '\"')\n    cs = COMPLETE_DQUOTE;\n  else if (*qcp == '\\'')\n    cs = COMPLETE_SQUOTE;\n#if defined (BANG_HISTORY)\n  else if (*qcp == '\\0' && history_expansion && cs == COMPLETE_DQUOTE &&\n\t   history_expansion_inhibited == 0 && mbschr (s, '!'))\n    cs = COMPLETE_BSQUOTE;\n\n  if (*qcp == '\"' && history_expansion && cs == COMPLETE_DQUOTE &&\n\thistory_expansion_inhibited == 0 && mbschr (s, '!'))\n    {\n      cs = COMPLETE_BSQUOTE;\n      *qcp = '\\0';\n    }\n#endif\n\n   \n  mtext = s;\n  if (mtext[0] == '~' && rtype == SINGLE_MATCH && cs != COMPLETE_BSQUOTE)\n    mtext = bash_tilde_expand (s, 0);\n\n  switch (cs)\n    {\n    case COMPLETE_DQUOTE:\n      rtext = sh_double_quote (mtext);\n      break;\n    case COMPLETE_SQUOTE:\n      rtext = sh_single_quote (mtext);\n      break;\n    case COMPLETE_BSQUOTE:\n      rtext = sh_backslash_quote (mtext, complete_fullquote ? 0 : filename_bstab, 0);\n      break;\n    }\n\n  if (mtext != s)\n    free (mtext);\n\n   \n   \n  if (rtext && cs == COMPLETE_BSQUOTE && rl_completer_word_break_characters)\n    {\n      mtext = quote_word_break_chars (rtext);\n      free (rtext);\n      rtext = mtext;\n    }\n\n   \n  if (rtext)\n    {\n      rlen = strlen (rtext);\n      ret = (char *)xmalloc (rlen + 1);\n      strcpy (ret, rtext);\n    }\n  else\n    {\n      ret = (char *)xmalloc (rlen = 1);\n      ret[0] = '\\0';\n    }\n\n   \n  if (rtype == MULT_MATCH && cs != COMPLETE_BSQUOTE)\n    ret[rlen - 1] = '\\0';\n  free (rtext);\n  return ret;\n}\n\n \n\nstatic Keymap emacs_std_cmd_xmap;\n#if defined (VI_MODE)\nstatic Keymap vi_insert_cmd_xmap;\nstatic Keymap vi_movement_cmd_xmap;\n#endif\n\n#ifdef _MINIX\nstatic void\n#else\nstatic int\n#endif\nputx(c)\n     int c;\n{\n  int x;\n  x = putc (c, rl_outstream);\n#ifndef _MINIX\n  return x;\n#endif\n}\n\nstatic int\nreadline_get_char_offset (ind)\n     int ind;\n{\n  int r, old_ch;\n\n  r = ind;\n#if defined (HANDLE_MULTIBYTE)\n  if (locale_mb_cur_max > 1)\n    {\n      old_ch = rl_line_buffer[ind];\n      rl_line_buffer[ind] = '\\0';\n      r = MB_STRLEN (rl_line_buffer);\n      rl_line_buffer[ind] = old_ch;\n    }\n#endif\n  return r;\n}\n\nstatic void\nreadline_set_char_offset (ind, varp)\n     int ind;\n     int *varp;\n{\n  int i;\n\n  i = ind;\n\n#if defined (HANDLE_MULTIBYTE)\n  if (i > 0 && locale_mb_cur_max > 1)\n    i = _rl_find_next_mbchar (rl_line_buffer, 0, i, 0);\t\t \n#endif\n  if (i != *varp)\n    {\n      if (i > rl_end)\n\ti = rl_end;\n      else if (i < 0)\n\ti = 0;\n      *varp = i;\n    }\n}\n\nint\nbash_execute_unix_command (count, key)\n     int count;\t \n     int key;\n{\n  int type;\n  register int i, r;\n  intmax_t mi;\n  sh_parser_state_t ps;\n  char *cmd, *value, *ce, old_ch;\n  SHELL_VAR *v;\n  char ibuf[INT_STRLEN_BOUND(int) + 1];\n  Keymap cmd_xmap;\n  const char *kseq;\n  size_t kslen;\n\n  kseq = rl_executing_keyseq;\n  kslen = rl_key_sequence_length;\n\n   \n  if (count > 1 || rl_explicit_arg)\n    {\n      i = rl_trim_arg_from_keyseq (rl_executing_keyseq, rl_key_sequence_length, rl_get_keymap ());\n      if (i > 0)\n\t{\n\t kseq = rl_executing_keyseq + i;\n\t kslen = rl_key_sequence_length - i;\n\t}\n    }\n\n   \n  cmd_xmap = get_cmd_xmap_from_keymap (rl_get_keymap ());\n  cmd = (char *)rl_function_of_keyseq_len (kseq, kslen, cmd_xmap, &type);\n\n  if (type == ISKMAP && (type = ((Keymap) cmd)[ANYOTHERKEY].type) == ISMACR)\n    cmd = (char*)((Keymap) cmd)[ANYOTHERKEY].function;\n\n  if (cmd == 0 || type != ISMACR)\n    {\n      rl_crlf ();\n      internal_error (_(\"bash_execute_unix_command: cannot find keymap for command\"));\n      rl_forced_update_display ();\n      return 1;\n    }\n\n  ce = rl_get_termcap (\"ce\");\n  if (ce)\t \n    {\n      rl_clear_visible_line ();\n      fflush (rl_outstream);\n    }\n  else\n    rl_crlf ();\t \n\n  v = bind_variable (\"READLINE_LINE\", rl_line_buffer, 0);\n  if (v)\n    VSETATTR (v, att_exported);\n\n  i = readline_get_char_offset (rl_point);\n  value = inttostr (i, ibuf, sizeof (ibuf));\n  v = bind_int_variable (\"READLINE_POINT\", value, 0);\n  if (v)\n    VSETATTR (v, att_exported);\n\n  i = readline_get_char_offset (rl_mark);\n  value = inttostr (i, ibuf, sizeof (ibuf));\n  v = bind_int_variable (\"READLINE_MARK\", value, 0);\n  if (v)\n    VSETATTR (v, att_exported);\n\n  if (count > 1 || rl_explicit_arg)\n    {\n      value = inttostr (count, ibuf, sizeof (ibuf));\n      v = bind_int_variable (\"READLINE_ARGUMENT\", value, 0);\n      if (v)\n        VSETATTR (v, att_exported);\n    }\n  array_needs_making = 1;\n\n  save_parser_state (&ps);\n  rl_clear_signals ();\n  r = parse_and_execute (savestring (cmd), \"bash_execute_unix_command\", SEVAL_NOHIST);\n  rl_set_signals ();\n  restore_parser_state (&ps);\n\n  v = find_variable (\"READLINE_LINE\");\n  maybe_make_readline_line (v ? value_cell (v) : 0);\n\n  v = find_variable (\"READLINE_POINT\");\n  if (v && legal_number (value_cell (v), &mi))\n    readline_set_char_offset (mi, &rl_point);\n\n  v = find_variable (\"READLINE_MARK\");\n  if (v && legal_number (value_cell (v), &mi))\n    readline_set_char_offset (mi, &rl_mark);\n\n  check_unbind_variable (\"READLINE_LINE\");\n  check_unbind_variable (\"READLINE_POINT\");\n  check_unbind_variable (\"READLINE_MARK\");\n  check_unbind_variable (\"READLINE_ARGUMENT\");\n  array_needs_making = 1;\n\n   \n   \n  if (ce && r != 124)\n    rl_redraw_prompt_last_line ();\n  else\n    rl_forced_update_display ();\n\n  return 0;\n}\n\nint\nprint_unix_command_map ()\n{\n  Keymap save, cmd_xmap;\n\n  save = rl_get_keymap ();\n  cmd_xmap = get_cmd_xmap_from_keymap (save);\n  rl_set_keymap (cmd_xmap);\n  rl_macro_dumper (1);\n  rl_set_keymap (save);\n  return 0;\n}\n\nstatic void\ninit_unix_command_map ()\n{\n  emacs_std_cmd_xmap = rl_make_bare_keymap ();\n\n  emacs_std_cmd_xmap[CTRL('X')].type = ISKMAP;\n  emacs_std_cmd_xmap[CTRL('X')].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap ());\n  emacs_std_cmd_xmap[ESC].type = ISKMAP;\n  emacs_std_cmd_xmap[ESC].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap ());\n\n#if defined (VI_MODE)  \n  vi_insert_cmd_xmap = rl_make_bare_keymap ();\n  vi_movement_cmd_xmap = rl_make_bare_keymap ();\n#endif\n}\n\nstatic Keymap\nget_cmd_xmap_from_edit_mode ()\n{\n  if (emacs_std_cmd_xmap == 0)\n    init_unix_command_map ();\n\n  switch (rl_editing_mode)\n    {\n    case EMACS_EDITING_MODE:\n      return emacs_std_cmd_xmap;\n#if defined (VI_MODE)\n    case VI_EDITING_MODE:\n      return (get_cmd_xmap_from_keymap (rl_get_keymap ()));\n#endif\n    default:\n      return (Keymap)NULL;\n    }\n}\n\nstatic Keymap\nget_cmd_xmap_from_keymap (kmap)\n     Keymap kmap;\n{\n  if (emacs_std_cmd_xmap == 0)\n    init_unix_command_map ();\n\n  if (kmap == emacs_standard_keymap)\n    return emacs_std_cmd_xmap;\n  else if (kmap == emacs_meta_keymap)\n    return (FUNCTION_TO_KEYMAP (emacs_std_cmd_xmap, ESC));\n  else if (kmap == emacs_ctlx_keymap)\n    return (FUNCTION_TO_KEYMAP (emacs_std_cmd_xmap, CTRL('X')));\n#if defined (VI_MODE)\n  else if (kmap == vi_insertion_keymap)\n    return vi_insert_cmd_xmap;\n  else if (kmap == vi_movement_keymap)\n    return vi_movement_cmd_xmap;\n#endif\n  else\n    return (Keymap)NULL;\n}\n\nstatic int\nisolate_sequence (string, ind, need_dquote, startp)\n     char *string;\n     int ind, need_dquote, *startp;\n{\n  register int i;\n  int c, passc, delim;\n\n  for (i = ind; string[i] && whitespace (string[i]); i++)\n    ;\n   \n  if (need_dquote && string[i] != '\"')\n    {\n      builtin_error (_(\"%s: first non-whitespace character is not `\\\"'\"), string);\n      return -1;\n    }\n\n   \n  delim = (string[i] == '\"' || string[i] == '\\'') ? string[i] : 0;\n    \n  if (startp)\n    *startp = delim ? ++i : i;\n\n  for (passc = 0; c = string[i]; i++)\n    {\n      if (passc)\n\t{\n\t  passc = 0;\n\t  continue;\n\t}\n      if (c == '\\\\')\n\t{\n\t  passc++;\n\t  continue;\n\t}\n      if (c == delim)\n\tbreak;\n    }\n\n  if (delim && string[i] != delim)\n    {\n      builtin_error (_(\"no closing `%c' in %s\"), delim, string);\n      return -1;\n    }\n\n  return i;\n}\n\nint\nbind_keyseq_to_unix_command (line)\n     char *line;\n{\n  Keymap kmap, cmd_xmap;\n  char *kseq, *value;\n  int i, kstart;\n\n  kmap = rl_get_keymap ();\n\n   \n  i = isolate_sequence (line, 0, 1, &kstart);\n  if (i < 0)\n    return -1;\n\n   \n  kseq = substring (line, kstart, i);\n\n  for ( ; line[i] && line[i] != ':'; i++)\n    ;\n  if (line[i] != ':')\n    {\n      builtin_error (_(\"%s: missing colon separator\"), line);\n      FREE (kseq);\n      return -1;\n    }\n\n  i = isolate_sequence (line, i + 1, 0, &kstart);\n  if (i < 0)\n    {\n      FREE (kseq);\n      return -1;\n    }\n\n   \n  value = substring (line, kstart, i);\n\n   \n  cmd_xmap = get_cmd_xmap_from_keymap (kmap);\n  rl_generic_bind (ISMACR, kseq, value, cmd_xmap);\n\n   \n  rl_bind_keyseq_in_map (kseq, bash_execute_unix_command, kmap);\n\n  free (kseq);  \n  return 0;\n}\n\nint\nunbind_unix_command (kseq)\n     char *kseq;\n{\n  Keymap cmd_xmap;\n\n  cmd_xmap = get_cmd_xmap_from_keymap (rl_get_keymap ());\n  if (rl_bind_keyseq_in_map (kseq, (rl_command_func_t *)NULL, cmd_xmap) != 0)\n    {\n      builtin_error (_(\"`%s': cannot unbind in command keymap\"), kseq);\n      return 0;\n    }\n  return 1;\n}\n\n \nchar **\nbash_directory_completion_matches (text)\n     const char *text;\n{\n  char **m1;\n  char *dfn;\n  int qc;\n\n  qc = rl_dispatching ? rl_completion_quote_character : 0;  \n   \n  if (rl_dispatching && rl_completion_found_quote == 0)\n    dfn = bash_dequote_filename ((char *)text, qc);\n  else\n    dfn = (char *)text;\n  m1 = rl_completion_matches (dfn, rl_filename_completion_function);\n  if (dfn != text)\n    free (dfn);\n\n  if (m1 == 0 || m1[0] == 0)\n    return m1;\n   \n  (void)bash_progcomp_ignore_filenames (m1);\n  return m1;\n}\n\nchar *\nbash_dequote_text (text)\n     const char *text;\n{\n  char *dtxt;\n  int qc;\n\n  qc = (text[0] == '\"' || text[0] == '\\'') ? text[0] : 0;\n  dtxt = bash_dequote_filename ((char *)text, qc);\n  return (dtxt);\n}\n\n \nstatic int\nbash_event_hook ()\n{\n  int sig;\n\n   \n  if (sigterm_received)\n    {\n       \n      return 0;\n    }\n\n  sig = 0;\n  if (terminating_signal)\n    sig = terminating_signal;\n  else if (interrupt_state)\n    sig = SIGINT;\n  else if (read_timeout && read_timeout->alrmflag)\n    sig = SIGALRM;\n  else if (RL_ISSTATE (RL_STATE_TIMEOUT))\t\t \n    {\n      sig = SIGALRM;\n      if (read_timeout)\n\tread_timeout->alrmflag = 1;\n    }\n  else\n    sig = first_pending_trap ();\n\n   \n  if (terminating_signal || interrupt_state || (read_timeout && read_timeout->alrmflag))\n    rl_cleanup_after_signal ();\n  bashline_reset_event_hook ();\n\n  RL_UNSETSTATE (RL_STATE_TIMEOUT);\t\t\t \n\n   \n  if (posixly_correct && this_shell_builtin == read_builtin && sig == SIGINT)\n    {\n      last_command_exit_value = 128|SIGINT;\n      throw_to_top_level ();\n    }\n\n  check_signals_and_traps ();\t \n  return 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}