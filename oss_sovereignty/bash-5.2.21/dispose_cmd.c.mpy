{
  "module_name": "dispose_cmd.c",
  "hash_id": "670849d4b2fc1ae6f8ff9687d2a15813bd2d151530463f760bed26ea90c8caf3",
  "original_prompt": "Ingested from bash-5.2.21/dispose_cmd.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include \"shell.h\"\n\nextern sh_obj_cache_t wdcache, wlcache;\n\n \nvoid\ndispose_command (command)\n     COMMAND *command;\n{\n  if (command == 0)\n    return;\n\n  if (command->redirects)\n    dispose_redirects (command->redirects);\n\n  switch (command->type)\n    {\n    case cm_for:\n#if defined (SELECT_COMMAND)\n    case cm_select:\n#endif\n      {\n\tregister FOR_COM *c;\n#if defined (SELECT_COMMAND)\n\tif (command->type == cm_select)\n\t  c = (FOR_COM *)command->value.Select;\n\telse\n#endif\n\tc = command->value.For;\n\tdispose_word (c->name);\n\tdispose_words (c->map_list);\n\tdispose_command (c->action);\n\tfree (c);\n\tbreak;\n      }\n\n#if defined (ARITH_FOR_COMMAND)\n    case cm_arith_for:\n      {\n\tregister ARITH_FOR_COM *c;\n\n\tc = command->value.ArithFor;\n\tdispose_words (c->init);\n\tdispose_words (c->test);\n\tdispose_words (c->step);\n\tdispose_command (c->action);\n\tfree (c);\n\tbreak;\n      }\n#endif  \n\n    case cm_group:\n      {\n\tdispose_command (command->value.Group->command);\n\tfree (command->value.Group);\n\tbreak;\n      }\n\n    case cm_subshell:\n      {\n\tdispose_command (command->value.Subshell->command);\n\tfree (command->value.Subshell);\n\tbreak;\n      }\n\n    case cm_coproc:\n      {\n\tfree (command->value.Coproc->name);\n\tdispose_command (command->value.Coproc->command);\n\tfree (command->value.Coproc);\n\tbreak;\n      }\n\n    case cm_case:\n      {\n\tregister CASE_COM *c;\n\tPATTERN_LIST *t, *p;\n\n\tc = command->value.Case;\n\tdispose_word (c->word);\n\n\tfor (p = c->clauses; p; )\n\t  {\n\t    dispose_words (p->patterns);\n\t    dispose_command (p->action);\n\t    t = p;\n\t    p = p->next;\n\t    free (t);\n\t  }\n\tfree (c);\n\tbreak;\n      }\n\n    case cm_until:\n    case cm_while:\n      {\n\tregister WHILE_COM *c;\n\n\tc = command->value.While;\n\tdispose_command (c->test);\n\tdispose_command (c->action);\n\tfree (c);\n\tbreak;\n      }\n\n    case cm_if:\n      {\n\tregister IF_COM *c;\n\n\tc = command->value.If;\n\tdispose_command (c->test);\n\tdispose_command (c->true_case);\n\tdispose_command (c->false_case);\n\tfree (c);\n\tbreak;\n      }\n\n    case cm_simple:\n      {\n\tregister SIMPLE_COM *c;\n\n\tc = command->value.Simple;\n\tdispose_words (c->words);\n\tdispose_redirects (c->redirects);\n\tfree (c);\n\tbreak;\n      }\n\n    case cm_connection:\n      {\n\tregister CONNECTION *c;\n\n\tc = command->value.Connection;\n\tdispose_command (c->first);\n\tdispose_command (c->second);\n\tfree (c);\n\tbreak;\n      }\n\n#if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n      {\n\tregister ARITH_COM *c;\n\n\tc = command->value.Arith;\n\tdispose_words (c->exp);\n\tfree (c);\n\tbreak;\n      }\n#endif  \n\n#if defined (COND_COMMAND)\n    case cm_cond:\n      {\n\tregister COND_COM *c;\n\n\tc = command->value.Cond;\n\tdispose_cond_node (c);\n\tbreak;\n      }\n#endif  \n\n    case cm_function_def:\n      {\n\tregister FUNCTION_DEF *c;\n\n\tc = command->value.Function_def;\n\tdispose_function_def (c);\n\tbreak;\n      }\n\n    default:\n      command_error (\"dispose_command\", CMDERR_BADTYPE, command->type, 0);\n      break;\n    }\n  free (command);\n}\n\n#if defined (COND_COMMAND)\n \nvoid\ndispose_cond_node (cond)\n     COND_COM *cond;\n{\n  if (cond)\n    {\n      if (cond->left)\n\tdispose_cond_node (cond->left);\n      if (cond->right)\n\tdispose_cond_node (cond->right);\n      if (cond->op)\n\tdispose_word (cond->op);\n      free (cond);\n    }\n}\n#endif  \n\nvoid\ndispose_function_def_contents (c)\n     FUNCTION_DEF *c;\n{\n  dispose_word (c->name);\n  dispose_command (c->command);\n  FREE (c->source_file);\n}\n\nvoid\ndispose_function_def (c)\n     FUNCTION_DEF *c;\n{\n  dispose_function_def_contents (c);\n  free (c);\n}\n\n \nvoid\ndispose_word (w)\n     WORD_DESC *w;\n{\n  FREE (w->word);\n  ocache_free (wdcache, WORD_DESC, w);\n}\n\n \nvoid\ndispose_word_desc (w)\n     WORD_DESC *w;\n{\n  w->word = 0;\n  ocache_free (wdcache, WORD_DESC, w);\n}\n\n \nvoid\ndispose_words (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *t;\n\n  while (list)\n    {\n      t = list;\n      list = list->next;\n      dispose_word (t->word);\n#if 0\n      free (t);\n#else\n      ocache_free (wlcache, WORD_LIST, t);\n#endif\n    }\n}\n\n#ifdef INCLUDE_UNUSED\n \nvoid\ndispose_word_array (array)\n     char **array;\n{\n  register int count;\n\n  if (array == 0)\n    return;\n\n  for (count = 0; array[count]; count++)\n    free (array[count]);\n\n  free (array);\n}\n#endif\n\n \nvoid\ndispose_redirects (list)\n     REDIRECT *list;\n{\n  register REDIRECT *t;\n\n  while (list)\n    {\n      t = list;\n      list = list->next;\n\n      if (t->rflags & REDIR_VARASSIGN)\n\tdispose_word (t->redirector.filename);\n\n      switch (t->instruction)\n\t{\n\tcase r_reading_until:\n\tcase r_deblank_reading_until:\n\t  free (t->here_doc_eof);\n\t \n\tcase r_reading_string:\n\tcase r_output_direction:\n\tcase r_input_direction:\n\tcase r_inputa_direction:\n\tcase r_appending_to:\n\tcase r_err_and_out:\n\tcase r_append_err_and_out:\n\tcase r_input_output:\n\tcase r_output_force:\n\tcase r_duplicating_input_word:\n\tcase r_duplicating_output_word:\n\tcase r_move_input_word:\n\tcase r_move_output_word:\n\t  dispose_word (t->redirectee.filename);\n\t   \n\tdefault:\n\t  break;\n\t}\n      free (t);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}