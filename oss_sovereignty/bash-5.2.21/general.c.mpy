{
  "module_name": "general.c",
  "hash_id": "c5e7b4718ffc3ebbc02d2f5680242dfdb77d51a1e07e884c042cddf9d78e4b76",
  "original_prompt": "Ingested from bash-5.2.21/general.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"filecntl.h\"\n#include \"bashansi.h\"\n#include <stdio.h>\n#include \"chartypes.h\"\n#include <errno.h>\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"parser.h\"\n#include \"flags.h\"\n#include \"findcmd.h\"\n#include \"test.h\"\n#include \"trap.h\"\n#include \"pathexp.h\"\n\n#include \"builtins/common.h\"\n\n#if defined (HAVE_MBSTR_H) && defined (HAVE_MBSCHR)\n#  include <mbstr.h>\t\t \n#endif\n\n#include <tilde/tilde.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#ifdef __CYGWIN__\n#  include <sys/cygwin.h>\n#endif\n\nstatic char *bash_special_tilde_expansions PARAMS((char *));\nstatic int unquoted_tilde_word PARAMS((const char *));\nstatic void initialize_group_array PARAMS((void));\n\n \nconst char * const bash_getcwd_errstr = N_(\"getcwd: cannot access parent directories\");\n\n \n\nstatic struct {\n  int *posix_mode_var;\n} posix_vars[] = \n{\n  &interactive_comments,\n  &source_uses_path,\n  &expaliases_flag,\n  &inherit_errexit,\n  &print_shift_error,\n  0\n};\n\nstatic char *saved_posix_vars = 0;\n\nvoid\nposix_initialize (on)\n     int on;\n{\n   \n  if (on != 0)\n    {\n      interactive_comments = source_uses_path = 1;\n      expand_aliases = expaliases_flag = 1;\n      inherit_errexit = 1;\n      source_searches_cwd = 0;\n      print_shift_error = 1;\n    }\n\n   \n  else if (saved_posix_vars)\t\t \n    {\n      set_posix_options (saved_posix_vars);\n      expand_aliases = expaliases_flag;\n      free (saved_posix_vars);\n      saved_posix_vars = 0;\n    }\n  else\t \n    {\n      source_searches_cwd = 1;\n      expand_aliases = expaliases_flag = interactive_shell;\t \n      print_shift_error = 0;\n    }\n}\n\nint\nnum_posix_options ()\n{\n  return ((sizeof (posix_vars) / sizeof (posix_vars[0])) - 1);\n}\n\nchar *\nget_posix_options (bitmap)\n     char *bitmap;\n{\n  register int i;\n\n  if (bitmap == 0)\n    bitmap = (char *)xmalloc (num_posix_options ());\t \n  for (i = 0; posix_vars[i].posix_mode_var; i++)\n    bitmap[i] = *(posix_vars[i].posix_mode_var);\n  return bitmap;\n}\n\n#undef save_posix_options\nvoid\nsave_posix_options ()\n{\n  saved_posix_vars = get_posix_options (saved_posix_vars);\n}\n\nvoid\nset_posix_options (bitmap)\n     const char *bitmap;\n{\n  register int i;\n\n  for (i = 0; posix_vars[i].posix_mode_var; i++)\n    *(posix_vars[i].posix_mode_var) = bitmap[i];\n}\n\n \n \n \n \n \n\n#if defined (RLIMTYPE)\nRLIMTYPE\nstring_to_rlimtype (s)\n     char *s;\n{\n  RLIMTYPE ret;\n  int neg;\n\n  ret = 0;\n  neg = 0;\n  while (s && *s && whitespace (*s))\n    s++;\n  if (s && (*s == '-' || *s == '+'))\n    {\n      neg = *s == '-';\n      s++;\n    }\n  for ( ; s && *s && DIGIT (*s); s++)\n    ret = (ret * 10) + TODIGIT (*s);\n  return (neg ? -ret : ret);\n}\n\nvoid\nprint_rlimtype (n, addnl)\n     RLIMTYPE n;\n     int addnl;\n{\n  char s[INT_STRLEN_BOUND (RLIMTYPE) + 1], *p;\n\n  p = s + sizeof(s);\n  *--p = '\\0';\n\n  if (n < 0)\n    {\n      do\n\t*--p = '0' - n % 10;\n      while ((n /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n\t*--p = '0' + n % 10;\n      while ((n /= 10) != 0);\n    }\n\n  printf (\"%s%s\", p, addnl ? \"\\n\" : \"\");\n}\n#endif  \n\n \n \n \n \n \n\n \nint\nall_digits (string)\n     const char *string;\n{\n  register const char *s;\n\n  for (s = string; *s; s++)\n    if (DIGIT (*s) == 0)\n      return (0);\n\n  return (1);\n}\n\n \nint\nlegal_number (string, result)\n     const char *string;\n     intmax_t *result;\n{\n  intmax_t value;\n  char *ep;\n\n  if (result)\n    *result = 0;\n\n  if (string == 0)\n    return 0;\n\n  errno = 0;\n  value = strtoimax (string, &ep, 10);\n  if (errno || ep == string)\n    return 0;\t \n\n   \n  while (whitespace (*ep))\n    ep++;\n\n   \n  if (*string && *ep == '\\0')\n    {\n      if (result)\n\t*result = value;\n       \n      return 1;\n    }\n    \n  return (0);\n}\n\n \nint\nlegal_identifier (name)\n     const char *name;\n{\n  register const char *s;\n  unsigned char c;\n\n  if (!name || !(c = *name) || (legal_variable_starter (c) == 0))\n    return (0);\n\n  for (s = name + 1; (c = *s) != 0; s++)\n    {\n      if (legal_variable_char (c) == 0)\n\treturn (0);\n    }\n  return (1);\n}\n\n \nint\nvalid_nameref_value (name, flags)\n     const char *name;\n     int flags;\n{\n  if (name == 0 || *name == 0)\n    return 0;\n\n   \n#if defined (ARRAY_VARS)  \n  if (legal_identifier (name) || (flags != 2 && valid_array_reference (name, 0)))\n#else\n  if (legal_identifier (name))\n#endif\n    return 1;\n\n  return 0;\n}\n\nint\ncheck_selfref (name, value, flags)\n     const char *name;\n     char *value;\n     int flags;\n{\n  char *t;\n\n  if (STREQ (name, value))\n    return 1;\n\n#if defined (ARRAY_VARS)\n  if (valid_array_reference (value, 0))\n    {\n      t = array_variable_name (value, 0, (char **)NULL, (int *)NULL);\n      if (t && STREQ (name, t))\n\t{\n\t  free (t);\n\t  return 1;\n\t}\n      free (t);\n    }\n#endif\n\n  return 0;\t \n}\n\n \nint\ncheck_identifier (word, check_word)\n     WORD_DESC *word;\n     int check_word;\n{\n  if (word->flags & (W_HASDOLLAR|W_QUOTED))\t \n    {\n      internal_error (_(\"`%s': not a valid identifier\"), word->word);\n      return (0);\n    }\n  else if (check_word && (all_digits (word->word) || legal_identifier (word->word) == 0))\n    {\n      internal_error (_(\"`%s': not a valid identifier\"), word->word);\n      return (0);\n    }\n  else\n    return (1);\n}\n\n \nint\nimportable_function_name (string, len)\n     const char *string;\n     size_t len;\n{\n  if (absolute_program (string))\t \n    return 0;\n  if (*string == '\\n')\t\t\t \n    return 0;\n  if (shellblank (*string) || shellblank(string[len-1]))\n    return 0;\n  return (posixly_correct ? legal_identifier (string) : 1);\n}\n\nint\nexportable_function_name (string)\n     const char *string;\n{\n  if (absolute_program (string))\n    return 0;\n  if (mbschr (string, '=') != 0)\n    return 0;\n  return 1;\n}\n\n \nint\nlegal_alias_name (string, flags)\n     const char *string;\n     int flags;\n{\n  register const char *s;\n\n  for (s = string; *s; s++)\n    if (shellbreak (*s) || shellxquote (*s) || shellexp (*s) || (*s == '/'))\n      return 0;\n  return 1;\n}\n\n \nint\nassignment (string, flags)\n     const char *string;\n     int flags;\n{\n  register unsigned char c;\n  register int newi, indx;\n\n  c = string[indx = 0];\n\n#if defined (ARRAY_VARS)\n   \n  if ((flags & 1) && c != '[')\t\t \n    return (0);\n  else if ((flags & 1) == 0 && legal_variable_starter (c) == 0)\n#else\n  if (legal_variable_starter (c) == 0)\n#endif\n    return (0);\n\n  while (c = string[indx])\n    {\n       \n      if (c == '=')\n\treturn (indx);\n\n#if defined (ARRAY_VARS)\n      if (c == '[')\n\t{\n\t  newi = skipsubscript (string, indx, (flags & 2) ? 1 : 0);\n\t   \n\t  if (string[newi++] != ']')\n\t    return (0);\n\t  if (string[newi] == '+' && string[newi+1] == '=')\n\t    return (newi + 1);\n\t  return ((string[newi] == '=') ? newi : 0);\n\t}\n#endif  \n\n       \n      if (c == '+' && string[indx+1] == '=')\n\treturn (indx + 1);\n\n       \n      if (legal_variable_char (c) == 0)\n\treturn (0);\n\n      indx++;\n    }\n  return (0);\n}\n\nint\nline_isblank (line)\n     const char *line;\n{\n  register int i;\n\n  if (line == 0)\n    return 0;\t\t \n  for (i = 0; line[i]; i++)\n    if (isblank ((unsigned char)line[i]) == 0)\n      break;\n  return (line[i] == '\\0');  \n}\n\n \n \n \n \n \n\n \n\n#if !defined (O_NDELAY)\n#  if defined (FNDELAY)\n#    define O_NDELAY FNDELAY\n#  endif\n#endif  \n\n \nint\nsh_unset_nodelay_mode (fd)\n     int fd;\n{\n  int flags, bflags;\n\n  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)\n    return -1;\n\n  bflags = 0;\n\n   \n#ifdef O_NONBLOCK\n  bflags |= O_NONBLOCK;\n#endif\n\n#ifdef O_NDELAY\n  bflags |= O_NDELAY;\n#endif\n\n  if (flags & bflags)\n    {\n      flags &= ~bflags;\n      return (fcntl (fd, F_SETFL, flags));\n    }\n\n  return 0;\n}\n\n \nint\nsh_setclexec (fd)\n     int fd;\n{\n  return (SET_CLOSE_ON_EXEC (fd));\n}\n\n \nint\nsh_validfd (fd)\n     int fd;\n{\n  return (fcntl (fd, F_GETFD, 0) >= 0);\n}\n\nint\nfd_ispipe (fd)\n     int fd;\n{\n  errno = 0;\n  return ((lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE));\n}\n\n \n\n#if defined (__BEOS__)\n \n#  undef O_NONBLOCK\n#  define O_NONBLOCK 0\n#endif  \n\nvoid\ncheck_dev_tty ()\n{\n  int tty_fd;\n  char *tty;\n\n  tty_fd = open (\"/dev/tty\", O_RDWR|O_NONBLOCK);\n\n  if (tty_fd < 0)\n    {\n      tty = (char *)ttyname (fileno (stdin));\n      if (tty == 0)\n\treturn;\n      tty_fd = open (tty, O_RDWR|O_NONBLOCK);\n    }\n  if (tty_fd >= 0)\n    close (tty_fd);\n}\n\n \nint\nsame_file (path1, path2, stp1, stp2)\n     const char *path1, *path2;\n     struct stat *stp1, *stp2;\n{\n  struct stat st1, st2;\n\n  if (stp1 == NULL)\n    {\n      if (stat (path1, &st1) != 0)\n\treturn (0);\n      stp1 = &st1;\n    }\n\n  if (stp2 == NULL)\n    {\n      if (stat (path2, &st2) != 0)\n\treturn (0);\n      stp2 = &st2;\n    }\n\n  return ((stp1->st_dev == stp2->st_dev) && (stp1->st_ino == stp2->st_ino));\n}\n\n \nint\nmove_to_high_fd (fd, check_new, maxfd)\n     int fd, check_new, maxfd;\n{\n  int script_fd, nfds, ignore;\n\n  if (maxfd < 20)\n    {\n      nfds = getdtablesize ();\n      if (nfds <= 0)\n\tnfds = 20;\n      if (nfds > HIGH_FD_MAX)\n\tnfds = HIGH_FD_MAX;\t\t \n    }\n  else\n    nfds = maxfd;\n\n  for (nfds--; check_new && nfds > 3; nfds--)\n    if (fcntl (nfds, F_GETFD, &ignore) == -1)\n      break;\n\n  if (nfds > 3 && fd != nfds && (script_fd = dup2 (fd, nfds)) != -1)\n    {\n      if (check_new == 0 || fd != fileno (stderr))\t \n\tclose (fd);\n      return (script_fd);\n    }\n\n   \n  return (fd);\n}\n \n \n\nint\ncheck_binary_file (sample, sample_len)\n     const char *sample;\n     int sample_len;\n{\n  register int i;\n  int nline;\n  unsigned char c;\n\n  if (sample_len >= 4 && sample[0] == 0x7f && sample[1] == 'E' && sample[2] == 'L' && sample[3] == 'F')\n    return 1;\n\n   \n  nline = (sample[0] == '#' && sample[1] == '!') ? 2 : 1;\n\n  for (i = 0; i < sample_len; i++)\n    {\n      c = sample[i];\n      if (c == '\\n' && --nline == 0)\n\treturn (0);\n      if (c == '\\0')\n\treturn (1);\n    }\n\n  return (0);\n}\n\n \n \n \n \n \n\nint\nsh_openpipe (pv)\n     int *pv;\n{\n  int r;\n\n  if ((r = pipe (pv)) < 0)\n    return r;\n\n  pv[0] = move_to_high_fd (pv[0], 1, 64);\n  pv[1] = move_to_high_fd (pv[1], 1, 64);\n\n  return 0;  \n}\n\nint\nsh_closepipe (pv)\n     int *pv;\n{\n  if (pv[0] >= 0)\n    close (pv[0]);\n\n  if (pv[1] >= 0)\n    close (pv[1]);\n\n  pv[0] = pv[1] = -1;\n  return 0;\n}\n\n \n \n \n \n \n\nint\nfile_exists (fn)\n     const char *fn;\n{\n  struct stat sb;\n\n  return (stat (fn, &sb) == 0);\n}\n\nint\nfile_isdir (fn)\n     const char *fn;\n{\n  struct stat sb;\n\n  return ((stat (fn, &sb) == 0) && S_ISDIR (sb.st_mode));\n}\n\nint\nfile_iswdir (fn)\n     const char *fn;\n{\n  return (file_isdir (fn) && sh_eaccess (fn, W_OK) == 0);\n}\n\n \nint\npath_dot_or_dotdot (string)\n     const char *string;\n{\n  if (string == 0 || *string == '\\0' || *string != '.')\n    return (0);\n\n   \n  if (PATHSEP(string[1]) || (string[1] == '.' && PATHSEP(string[2])))\n    return (1);\n\n  return (0);\n}\n\n \nint\nabsolute_pathname (string)\n     const char *string;\n{\n  if (string == 0 || *string == '\\0')\n    return (0);\n\n  if (ABSPATH(string))\n    return (1);\n\n  if (string[0] == '.' && PATHSEP(string[1]))\t \n    return (1);\n\n  if (string[0] == '.' && string[1] == '.' && PATHSEP(string[2]))\t \n    return (1);\n\n  return (0);\n}\n\n \nint\nabsolute_program (string)\n     const char *string;\n{\n  return ((char *)mbschr (string, '/') != (char *)NULL);\n}\n\n \n \n \n \n \n\n \nchar *\nmake_absolute (string, dot_path)\n     const char *string, *dot_path;\n{\n  char *result;\n\n  if (dot_path == 0 || ABSPATH(string))\n#ifdef __CYGWIN__\n    {\n      char pathbuf[PATH_MAX + 1];\n\n       \n      cygwin_conv_path (CCP_WIN_A_TO_POSIX, string, pathbuf, PATH_MAX);\n      result = savestring (pathbuf);\n    }\n#else\n    result = savestring (string);\n#endif\n  else\n    result = sh_makepath (dot_path, string, 0);\n\n  return (result);\n}\n\n \nchar *\nbase_pathname (string)\n     char *string;\n{\n  char *p;\n\n#if 0\n  if (absolute_pathname (string) == 0)\n    return (string);\n#endif\n\n  if (string[0] == '/' && string[1] == 0)\n    return (string);\n\n  p = (char *)strrchr (string, '/');\n  return (p ? ++p : string);\n}\n\n \nchar *\nfull_pathname (file)\n     char *file;\n{\n  char *ret;\n\n  file = (*file == '~') ? bash_tilde_expand (file, 0) : savestring (file);\n\n  if (ABSPATH(file))\n    return (file);\n\n  ret = sh_makepath ((char *)NULL, file, (MP_DOCWD|MP_RMDOT));\n  free (file);\n\n  return (ret);\n}\n\n \nstatic char tdir[PATH_MAX];\n\n \nchar *\npolite_directory_format (name)\n     char *name;\n{\n  char *home;\n  int l;\n\n  home = get_string_value (\"HOME\");\n  l = home ? strlen (home) : 0;\n  if (l > 1 && strncmp (home, name, l) == 0 && (!name[l] || name[l] == '/'))\n    {\n      strncpy (tdir + 1, name + l, sizeof(tdir) - 2);\n      tdir[0] = '~';\n      tdir[sizeof(tdir) - 1] = '\\0';\n      return (tdir);\n    }\n  else\n    return (name);\n}\n\n \nchar *\ntrim_pathname (name, maxlen)\n     char *name;\n     int maxlen;\n{\n  int nlen, ndirs;\n  intmax_t nskip;\n  char *nbeg, *nend, *ntail, *v;\n\n  if (name == 0 || (nlen = strlen (name)) == 0)\n    return name;\n  nend = name + nlen;\n\n  v = get_string_value (\"PROMPT_DIRTRIM\");\n  if (v == 0 || *v == 0)\n    return name;\n  if (legal_number (v, &nskip) == 0 || nskip <= 0)\n    return name;\n\n   \n  nbeg = name;\n  if (name[0] == '~')\n    for (nbeg = name; *nbeg; nbeg++)\n      if (*nbeg == '/')\n\t{\n\t  nbeg++;\n\t  break;\n\t}\n  if (*nbeg == 0)\n    return name;\n\n  for (ndirs = 0, ntail = nbeg; *ntail; ntail++)\n    if (*ntail == '/')\n      ndirs++;\n  if (ndirs < nskip)\n    return name;\n\n  for (ntail = (*nend == '/') ? nend : nend - 1; ntail > nbeg; ntail--)\n    {\n      if (*ntail == '/')\n\tnskip--;\n      if (nskip == 0)\n\tbreak;\n    }\n  if (ntail == nbeg)\n    return name;\n\n   \n  nlen = ntail - nbeg;\n  if (nlen <= 3)\n    return name;\n\n  *nbeg++ = '.';\n  *nbeg++ = '.';\n  *nbeg++ = '.';\n\n  nlen = nend - ntail;\n  memmove (nbeg, ntail, nlen);\n  nbeg[nlen] = '\\0';\n\n  return name;\n}\n\n \nchar *\nprintable_filename (fn, flags)\n     char *fn;\n     int flags;\n{\n  char *newf;\n\n  if (ansic_shouldquote (fn))\n    newf = ansic_quote (fn, 0, NULL);\n  else if (flags && sh_contains_shell_metas (fn))\n    newf = sh_single_quote (fn);\n  else\n    newf = fn;\n\n  return newf;\n}\n\n \nchar *\nextract_colon_unit (string, p_index)\n     char *string;\n     int *p_index;\n{\n  int i, start, len;\n  char *value;\n\n  if (string == 0)\n    return (string);\n\n  len = strlen (string);\n  if (*p_index >= len)\n    return ((char *)NULL);\n\n  i = *p_index;\n\n   \n  if (i && string[i] == ':')\n    i++;\n\n  for (start = i; string[i] && string[i] != ':'; i++)\n    ;\n\n  *p_index = i;\n\n  if (i == start)\n    {\n      if (string[i])\n\t(*p_index)++;\n       \n      value = (char *)xmalloc (1);\n      value[0] = '\\0';\n    }\n  else\n    value = substring (string, start, i);\n\n  return (value);\n}\n\n \n \n \n \n \n\n#if defined (PUSHD_AND_POPD)\nextern char *get_dirstack_from_string PARAMS((char *));\n#endif\n\nstatic char **bash_tilde_prefixes;\nstatic char **bash_tilde_prefixes2;\nstatic char **bash_tilde_suffixes;\nstatic char **bash_tilde_suffixes2;\n\n \nstatic char *\nbash_special_tilde_expansions (text)\n     char *text;\n{\n  char *result;\n\n  result = (char *)NULL;\n\n  if (text[0] == '+' && text[1] == '\\0')\n    result = get_string_value (\"PWD\");\n  else if (text[0] == '-' && text[1] == '\\0')\n    result = get_string_value (\"OLDPWD\");\n#if defined (PUSHD_AND_POPD)\n  else if (DIGIT (*text) || ((*text == '+' || *text == '-') && DIGIT (text[1])))\n    result = get_dirstack_from_string (text);\n#endif\n\n  return (result ? savestring (result) : (char *)NULL);\n}\n\n \nvoid\ntilde_initialize ()\n{\n  static int times_called = 0;\n\n   \n  tilde_expansion_preexpansion_hook = bash_special_tilde_expansions;\n\n   \n  if (times_called++ == 0)\n    {\n      bash_tilde_prefixes = strvec_create (3);\n      bash_tilde_prefixes[0] = \"=~\";\n      bash_tilde_prefixes[1] = \":~\";\n      bash_tilde_prefixes[2] = (char *)NULL;\n\n      bash_tilde_prefixes2 = strvec_create (2);\n      bash_tilde_prefixes2[0] = \":~\";\n      bash_tilde_prefixes2[1] = (char *)NULL;\n\n      tilde_additional_prefixes = bash_tilde_prefixes;\n\n      bash_tilde_suffixes = strvec_create (3);\n      bash_tilde_suffixes[0] = \":\";\n      bash_tilde_suffixes[1] = \"=~\";\t \n      bash_tilde_suffixes[2] = (char *)NULL;\n\n      tilde_additional_suffixes = bash_tilde_suffixes;\n\n      bash_tilde_suffixes2 = strvec_create (2);\n      bash_tilde_suffixes2[0] = \":\";\n      bash_tilde_suffixes2[1] = (char *)NULL;\n    }\n}\n\n \n\n#define TILDE_END(c)\t((c) == '\\0' || (c) == '/' || (c) == ':')\n\nstatic int\nunquoted_tilde_word (s)\n     const char *s;\n{\n  const char *r;\n\n  for (r = s; TILDE_END(*r) == 0; r++)\n    {\n      switch (*r)\n\t{\n\tcase '\\\\':\n\tcase '\\'':\n\tcase '\"':\n\t  return 0;\n\t}\n    }\n  return 1;\n}\n\n \nchar *\nbash_tilde_find_word (s, flags, lenp)\n     const char *s;\n     int flags, *lenp;\n{\n  const char *r;\n  char *ret;\n  int l;\n\n  for (r = s; *r && *r != '/'; r++)\n    {\n       \n      if (*r == '\\\\' || *r == '\\'' || *r == '\"')  \n\t{\n\t  ret = savestring (s);\n\t  if (lenp)\n\t    *lenp = 0;\n\t  return ret;\n\t}\n      else if (flags && *r == ':')\n\tbreak;\n    }\n  l = r - s;\n  ret = xmalloc (l + 1);\n  strncpy (ret, s, l);\n  ret[l] = '\\0';\n  if (lenp)\n    *lenp = l;\n  return ret;\n}\n    \n \nchar *\nbash_tilde_expand (s, assign_p)\n     const char *s;\n     int assign_p;\n{\n  int r;\n  char *ret;\n\n  tilde_additional_prefixes = assign_p == 0 ? (char **)0\n  \t\t\t\t\t    : (assign_p == 2 ? bash_tilde_prefixes2 : bash_tilde_prefixes);\n  if (assign_p == 2)\n    tilde_additional_suffixes = bash_tilde_suffixes2;\n\n  r = (*s == '~') ? unquoted_tilde_word (s) : 1;\n  ret = r ? tilde_expand (s) : savestring (s);\n\n  QUIT;\n\n  return (ret);\n}\n\n \n \n \n \n \n\nstatic int ngroups, maxgroups;\n\n \nstatic GETGROUPS_T *group_array = (GETGROUPS_T *)NULL;\n\n#if !defined (NOGROUP)\n#  define NOGROUP (gid_t) -1\n#endif\n\nstatic void\ninitialize_group_array ()\n{\n  register int i;\n\n  if (maxgroups == 0)\n    maxgroups = getmaxgroups ();\n\n  ngroups = 0;\n  group_array = (GETGROUPS_T *)xrealloc (group_array, maxgroups * sizeof (GETGROUPS_T));\n\n#if defined (HAVE_GETGROUPS)\n  ngroups = getgroups (maxgroups, group_array);\n#endif\n\n   \n  if (ngroups == 0)\n    {\n      group_array[0] = current_user.gid;\n      ngroups = 1;\n    }\n\n   \n  for (i = 0; i < ngroups; i++)\n    if (current_user.gid == (gid_t)group_array[i])\n      break;\n  if (i == ngroups && ngroups < maxgroups)\n    {\n      for (i = ngroups; i > 0; i--)\n\tgroup_array[i] = group_array[i - 1];\n      group_array[0] = current_user.gid;\n      ngroups++;\n    }\n\n   \n  if (group_array[0] != current_user.gid)\n    {\n      for (i = 0; i < ngroups; i++)\n\tif (group_array[i] == current_user.gid)\n\t  break;\n      if (i < ngroups)\n\t{\n\t  group_array[i] = group_array[0];\n\t  group_array[0] = current_user.gid;\n\t}\n    }\n}\n\n \nint\n#if defined (__STDC__) || defined ( _MINIX)\ngroup_member (gid_t gid)\n#else\ngroup_member (gid)\n     gid_t gid;\n#endif  \n{\n#if defined (HAVE_GETGROUPS)\n  register int i;\n#endif\n\n   \n  if (gid == current_user.gid || gid == current_user.egid)\n    return (1);\n\n#if defined (HAVE_GETGROUPS)\n  if (ngroups == 0)\n    initialize_group_array ();\n\n   \n  if (ngroups <= 0)\n    return (0);\n\n   \n  for (i = 0; i < ngroups; i++)\n    if (gid == (gid_t)group_array[i])\n      return (1);\n#endif\n\n  return (0);\n}\n\nchar **\nget_group_list (ngp)\n     int *ngp;\n{\n  static char **group_vector = (char **)NULL;\n  register int i;\n\n  if (group_vector)\n    {\n      if (ngp)\n\t*ngp = ngroups;\n      return group_vector;\n    }\n\n  if (ngroups == 0)\n    initialize_group_array ();\n\n  if (ngroups <= 0)\n    {\n      if (ngp)\n\t*ngp = 0;\n      return (char **)NULL;\n    }\n\n  group_vector = strvec_create (ngroups);\n  for (i = 0; i < ngroups; i++)\n    group_vector[i] = itos (group_array[i]);\n\n  if (ngp)\n    *ngp = ngroups;\n  return group_vector;\n}\n\nint *\nget_group_array (ngp)\n     int *ngp;\n{\n  int i;\n  static int *group_iarray = (int *)NULL;\n\n  if (group_iarray)\n    {\n      if (ngp)\n\t*ngp = ngroups;\n      return (group_iarray);\n    }\n\n  if (ngroups == 0)\n    initialize_group_array ();    \n\n  if (ngroups <= 0)\n    {\n      if (ngp)\n\t*ngp = 0;\n      return (int *)NULL;\n    }\n\n  group_iarray = (int *)xmalloc (ngroups * sizeof (int));\n  for (i = 0; i < ngroups; i++)\n    group_iarray[i] = (int)group_array[i];\n\n  if (ngp)\n    *ngp = ngroups;\n  return group_iarray;\n}\n\n \n \n \n \n \n\n \nchar *\nconf_standard_path ()\n{\n#if defined (_CS_PATH) && defined (HAVE_CONFSTR)\n  char *p;\n  size_t len;\n\n  len = (size_t)confstr (_CS_PATH, (char *)NULL, (size_t)0);\n  if (len > 0)\n    {\n      p = (char *)xmalloc (len + 2);\n      *p = '\\0';\n      confstr (_CS_PATH, p, len);\n      return (p);\n    }\n  else\n    return (savestring (STANDARD_UTILS_PATH));\n#else  \n#  if defined (CS_PATH)\n  return (savestring (CS_PATH));\n#  else\n  return (savestring (STANDARD_UTILS_PATH));\n#  endif  \n#endif  \n}\n\nint\ndefault_columns ()\n{\n  char *v;\n  int c;\n\n  c = -1;\n  v = get_string_value (\"COLUMNS\");\n  if (v && *v)\n    {\n      c = atoi (v);\n      if (c > 0)\n\treturn c;\n    }\n\n  if (check_window_size)\n    get_new_window_size (0, (int *)0, &c);\n\n  return (c > 0 ? c : 80);\n}\n\n  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}