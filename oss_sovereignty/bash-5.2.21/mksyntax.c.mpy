{
  "module_name": "mksyntax.c",
  "hash_id": "d3e353ae51c4e66060a356ef15c2f1b68d648d110900979e1e5e895818df0345",
  "original_prompt": "Ingested from bash-5.2.21/mksyntax.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include <stdio.h>\n#include \"bashansi.h\"\n#include \"chartypes.h\"\n#include <errno.h>\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n\n#include \"syntax.h\"\n\nextern int optind;\nextern char *optarg;\n\n#ifndef errno\nextern int errno;\n#endif\n\n#ifndef HAVE_STRERROR\nextern char *strerror();\n#endif\n\nstruct wordflag {\n\tint\tflag;\n\tchar\t*fstr;\n} wordflags[] = {\n\t{ CWORD,\t\"CWORD\" },\n\t{ CSHMETA,\t\"CSHMETA\" },\n\t{ CSHBRK,\t\"CSHBRK\" },\n\t{ CBACKQ,\t\"CBACKQ\" },\n\t{ CQUOTE,\t\"CQUOTE\" },\n\t{ CSPECL,\t\"CSPECL\" },\n\t{ CEXP,\t\t\"CEXP\" },\n\t{ CBSDQUOTE,\t\"CBSDQUOTE\" },\n\t{ CBSHDOC,\t\"CBSHDOC\" },\n\t{ CGLOB,\t\"CGLOB\" },\n\t{ CXGLOB,\t\"CXGLOB\" },\n\t{ CXQUOTE,\t\"CXQUOTE\" },\n\t{ CSPECVAR,\t\"CSPECVAR\" },\n\t{ CSUBSTOP,\t\"CSUBSTOP\" },\n\t{ CBLANK,\t\"CBLANK\" },\n};\n\t\n#define N_WFLAGS\t(sizeof (wordflags) / sizeof (wordflags[0]))\n#define SYNSIZE\t\t256\n\nint\tlsyntax[SYNSIZE];\nint\tdebug;\nchar\t*progname;\n\nchar\tpreamble[] = \"\\\n \\n\\\n\\n\";\n\nchar\tincludes[] = \"\\\n#include \\\"config.h\\\"\\n\\\n#include \\\"stdc.h\\\"\\n\\\n#include \\\"syntax.h\\\"\\n\\n\";\n\nstatic void\nusage()\n{\n  fprintf (stderr, \"%s: usage: %s [-d] [-o filename]\\n\", progname, progname);\n  exit (2);\n}\n\n#ifdef INCLUDE_UNUSED\nstatic int\ngetcflag (s)\n     char *s;\n{\n  int i;\n\n  for (i = 0; i < N_WFLAGS; i++)\n    if (strcmp (s, wordflags[i].fstr) == 0)\n      return wordflags[i].flag;\n  return -1;\n}\n#endif\n\nstatic char *\ncdesc (i)\n     int i;\n{\n  static char xbuf[16];\n\n  if (i == ' ')\n    return \"SPC\";\n  else if (ISPRINT (i))\n    {\n      xbuf[0] = i;\n      xbuf[1] = '\\0';\n      return (xbuf);\n    }\n  else if (i == CTLESC)\n    return \"CTLESC\";\n  else if (i == CTLNUL)\n    return \"CTLNUL\";\n  else if (i == '\\033')\t\t \n    return \"ESC\";\n\n  xbuf[0] = '\\\\';\n  xbuf[2] = '\\0';\n    \n  switch (i)\n    {\n#ifdef __STDC__\n    case '\\a': xbuf[1] = 'a'; break;\n    case '\\v': xbuf[1] = 'v'; break;\n#else\n    case '\\007': xbuf[1] = 'a'; break;\n    case 0x0B: xbuf[1] = 'v'; break;\n#endif\n    case '\\b': xbuf[1] = 'b'; break;\n    case '\\f': xbuf[1] = 'f'; break;\n    case '\\n': xbuf[1] = 'n'; break;\n    case '\\r': xbuf[1] = 'r'; break;\n    case '\\t': xbuf[1] = 't'; break;\n    default: sprintf (xbuf, \"%d\", i); break;\n    }\n\n  return xbuf;\t\n}\n\nstatic char *\ngetcstr (f)\n     int f;\n{\n  int i;\n\n  for (i = 0; i < N_WFLAGS; i++)\n    if (f == wordflags[i].flag)\n      return (wordflags[i].fstr);\n  return ((char *)NULL);\n}\n\nstatic void\naddcstr (str, flag)\n     char *str;\n     int flag;\n{\n  char *s, *fstr;\n  unsigned char uc;\n\n  for (s = str; s && *s; s++)\n    {\n      uc = *s;\n\n      if (debug)\n\t{\n\t  fstr = getcstr (flag);\n\t  fprintf(stderr, \"added %s for character %s\\n\", fstr, cdesc(uc));\n\t}\n\t\n      lsyntax[uc] |= flag;\n    }\n}\n\nstatic void\naddcchar (c, flag)\n     unsigned char c;\n     int flag;\n{\n  char *fstr;\n\n  if (debug)\n    {\n      fstr = getcstr (flag);\n      fprintf (stderr, \"added %s for character %s\\n\", fstr, cdesc(c));\n    }\n  lsyntax[c] |= flag;\n}\n\nstatic void\naddblanks ()\n{\n  register int i;\n  unsigned char uc;\n\n  for (i = 0; i < SYNSIZE; i++)\n    {\n      uc = i;\n       \n      if (isblank (uc))\n\tlsyntax[uc] |= CBLANK;\n    }\n}\n\n \nstatic void\nload_lsyntax ()\n{\n   \n  addcstr (shell_meta_chars, CSHMETA);\n\n   \n  addcstr (shell_break_chars, CSHBRK);\n\n  addcchar ('`', CBACKQ);\n\n  addcstr (shell_quote_chars, CQUOTE);\n\n  addcchar (CTLESC, CSPECL);\n  addcchar (CTLNUL, CSPECL);\n\n  addcstr (shell_exp_chars, CEXP);\n\n  addcstr (slashify_in_quotes, CBSDQUOTE);\n  addcstr (slashify_in_here_document, CBSHDOC);\n\n  addcstr (shell_glob_chars, CGLOB);\n\n#if defined (EXTENDED_GLOB)\n  addcstr (ext_glob_chars, CXGLOB);\n#endif\n\n  addcstr (shell_quote_chars, CXQUOTE);\n  addcchar ('\\\\', CXQUOTE);\n\n  addcstr (\"@*#?-$!\", CSPECVAR);\t \n\n  addcstr (\"-=?+\", CSUBSTOP);\t\t \n\n  addblanks ();\n}\n\nstatic void\ndump_lflags (fp, ind)\n     FILE *fp;\n     int ind;\n{\n  int xflags, first, i;\n\n  xflags = lsyntax[ind];\n  first = 1;\n\n  if (xflags == 0)\n    fputs (wordflags[0].fstr, fp);\n  else\n    {\n      for (i = 1; i < N_WFLAGS; i++)\n\tif (xflags & wordflags[i].flag)\n\t  {\n\t    if (first)\n\t      first = 0;\n\t    else\n\t      putc ('|', fp);\n\t    fputs (wordflags[i].fstr, fp);\n  \t  }\n    }\n}\n\nstatic void\nwcomment (fp, i)\n     FILE *fp;\n     int i;\n{\n  fputs (\"\\t\\t/* \", fp);\n\n  fprintf (fp, \"%s\", cdesc(i));\n      \n  fputs (\" */\", fp);\n}\n\nstatic void\ndump_lsyntax (fp)\n     FILE *fp;\n{\n  int i;\n\n  fprintf (fp, \"int sh_syntabsiz = %d;\\n\", SYNSIZE);\n  fprintf (fp, \"int sh_syntaxtab[%d] = {\\n\", SYNSIZE);\n\n  for (i = 0; i < SYNSIZE; i++)\n    {\n      putc ('\\t', fp);\n      dump_lflags (fp, i);\n      putc (',', fp);\n      wcomment (fp, i);\n      putc ('\\n', fp);\n    }\n\n  fprintf (fp, \"};\\n\");\n}\n\nint\nmain(argc, argv)\n     int argc;\n     char **argv;\n{\n  int opt, i;\n  char *filename;\n  FILE *fp;\n\n  if ((progname = strrchr (argv[0], '/')) == 0)\n    progname = argv[0];\n  else\n    progname++;\n\n  filename = (char *)NULL;\n  debug = 0;\n\n  while ((opt = getopt (argc, argv, \"do:\")) != EOF)\n    {\n      switch (opt)\n\t{\n\tcase 'd':\n\t  debug = 1;\n\t  break;\n\tcase 'o':\n\t  filename = optarg;\n\t  break;\n\tdefault:\n\t  usage();\n\t}\n    }\n\n  argc -= optind;\n  argv += optind;\n\n  if (filename)\n    {\n      fp = fopen (filename, \"w\");\n      if (fp == 0)\n\t{\n\t  fprintf (stderr, \"%s: %s: cannot open: %s\\n\", progname, filename, strerror(errno));\n\t  exit (1);\n\t}\n    }\n  else\n    {\n      filename = \"stdout\";\n      fp = stdout;\n    }\n\n\n  for (i = 0; i < SYNSIZE; i++)\n    lsyntax[i] = CWORD;\n\n  load_lsyntax ();\n\n  fprintf (fp, \"%s\\n\", preamble);\n  fprintf (fp, \"%s\\n\", includes);\n\n  dump_lsyntax (fp);\n\n  if (fp != stdout)\n    fclose (fp);\n  exit (0);\n}\n\n\n#if !defined (HAVE_STRERROR)\n\n#include <bashtypes.h>\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n \n#if defined (strerror)\n#  undef strerror\n#endif\n\nchar *\nstrerror (e)\n     int e;\n{\n  static char emsg[40];\n#if defined (HAVE_SYS_ERRLIST)\n  extern int sys_nerr;\n  extern char *sys_errlist[];\n\n  if (e > 0 && e < sys_nerr)\n    return (sys_errlist[e]);\n  else\n#endif  \n    {\n      sprintf (emsg, \"Unknown system error %d\", e);\n      return (&emsg[0]);\n    }\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}