{
  "module_name": "error.c",
  "hash_id": "021b32bef04e48a29690468b56bf21449ffd6669f7525714e7d4b2bcfdd3157b",
  "original_prompt": "Ingested from bash-5.2.21/error.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include <fcntl.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (PREFER_STDARG)\n#  include <stdarg.h>\n#else\n#  include <varargs.h>\n#endif\n\n#include <stdio.h>\n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"flags.h\"\n#include \"input.h\"\n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#endif\n\nextern int executing_line_number PARAMS((void));\n\n#if defined (JOB_CONTROL)\nextern pid_t shell_pgrp;\nextern int give_terminal_to PARAMS((pid_t, int));\n#endif  \n\n#if defined (ARRAY_VARS)\nextern const char * const bash_badsub_errmsg;\n#endif\n\nstatic void error_prolog PARAMS((int));\n\n \n#if !defined (MAINTAINER)\n#define MAINTAINER \"bash-maintainers@gnu.org\"\n#endif\n\nconst char * const the_current_maintainer = MAINTAINER;\n\nint gnu_error_format = 0;\n\nstatic void\nerror_prolog (print_lineno)\n     int print_lineno;\n{\n  char *ename;\n  int line;\n\n  ename = get_name_for_error ();\n  line = (print_lineno && interactive_shell == 0) ? executing_line_number () : -1;\n\n  if (line > 0)\n    fprintf (stderr, \"%s:%s%d: \", ename, gnu_error_format ? \"\" : _(\" line \"), line);\n  else\n    fprintf (stderr, \"%s: \", ename);\n}\n\n \nchar *\nget_name_for_error ()\n{\n  char *name;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *bash_source_v;\n  ARRAY *bash_source_a;\n#endif\n\n  name = (char *)NULL;\n  if (interactive_shell == 0)\n    {\n#if defined (ARRAY_VARS)\n      bash_source_v = find_variable (\"BASH_SOURCE\");\n      if (bash_source_v && array_p (bash_source_v) &&\n\t  (bash_source_a = array_cell (bash_source_v)))\n\tname = array_reference (bash_source_a, 0);\n      if (name == 0 || *name == '\\0')\t \n#endif\n\tname = dollar_vars[0];\n    }\n  if (name == 0 && shell_name && *shell_name)\n    name = base_pathname (shell_name);\n  if (name == 0)\n#if defined (PROGRAM)\n    name = PROGRAM;\n#else\n    name = \"bash\";\n#endif\n\n  return (name);\n}\n\n \nvoid\nfile_error (filename)\n     const char *filename;\n{\n  report_error (\"%s: %s\", filename, strerror (errno));\n}\n\nvoid\n#if defined (PREFER_STDARG)\nprogramming_error (const char *format, ...)\n#else\nprogramming_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n  char *h;\n\n#if defined (JOB_CONTROL)\n  give_terminal_to (shell_pgrp, 0);\n#endif  \n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n  va_end (args);\n\n#if defined (HISTORY)\n  if (remember_on_history)\n    {\n      h = last_history_line ();\n      fprintf (stderr, _(\"last command: %s\\n\"), h ? h : \"(null)\");\n    }\n#endif\n\n#if 0\n  fprintf (stderr, \"Report this to %s\\n\", the_current_maintainer);\n#endif\n\n  fprintf (stderr, _(\"Aborting...\"));\n  fflush (stderr);\n\n  abort ();\n}\n\n \nvoid\n#if defined (PREFER_STDARG)\nreport_error (const char *format, ...)\n#else\nreport_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n  if (exit_immediately_on_error)\n    {\n      if (last_command_exit_value == 0)\n\tlast_command_exit_value = EXECUTION_FAILURE;\n      exit_shell (last_command_exit_value);\n    }\n}\n\nvoid\n#if defined (PREFER_STDARG)\nfatal_error (const char *format, ...)\n#else\nfatal_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (0);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n  sh_exit (2);\n}\n\nvoid\n#if defined (PREFER_STDARG)\ninternal_error (const char *format, ...)\n#else\ninternal_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n}\n\nvoid\n#if defined (PREFER_STDARG)\ninternal_warning (const char *format, ...)\n#else\ninternal_warning (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n  fprintf (stderr, _(\"warning: \"));\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n}\n\nvoid\n#if defined (PREFER_STDARG)\ninternal_inform (const char *format, ...)\n#else\ninternal_inform (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n   \n  fprintf (stderr, _(\"INFORM: \"));\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n}\n\nvoid\n#if defined (PREFER_STDARG)\ninternal_debug (const char *format, ...)\n#else\ninternal_debug (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n#ifdef DEBUG\n  va_list args;\n\n  error_prolog (1);\n  fprintf (stderr, _(\"DEBUG warning: \"));\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n#else\n  return;\n#endif\n}\n\nvoid\n#if defined (PREFER_STDARG)\nsys_error (const char *format, ...)\n#else\nsys_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  int e;\n  va_list args;\n\n  e = errno;\n  error_prolog (0);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \": %s\\n\", strerror (e));\n\n  va_end (args);\n}\n\n \nvoid\n#if defined (PREFER_STDARG)\nparser_error (int lineno, const char *format, ...)\n#else\nparser_error (lineno, format, va_alist)\n     int lineno;\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n  char *ename, *iname;\n\n  ename = get_name_for_error ();\n  iname = yy_input_name ();\n\n  if (interactive)\n    fprintf (stderr, \"%s: \", ename);\n  else if (interactive_shell)\n    fprintf (stderr, \"%s: %s:%s%d: \", ename, iname, gnu_error_format ? \"\" : _(\" line \"), lineno);\n  else if (STREQ (ename, iname))\n    fprintf (stderr, \"%s:%s%d: \", ename, gnu_error_format ? \"\" : _(\" line \"), lineno);\n  else\n    fprintf (stderr, \"%s: %s:%s%d: \", ename, iname, gnu_error_format ? \"\" : _(\" line \"), lineno);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n\n  if (exit_immediately_on_error)\n    exit_shell (last_command_exit_value = 2);\n}\n\n#ifdef DEBUG\n \nchar *\nstrescape (str)\n     const char *str;\n{\n  char *r, *result;\n  unsigned char *s;\n\n  r = result = (char *)xmalloc (strlen (str) * 2 + 1);\n\n  for (s = (unsigned char *)str; s && *s; s++)\n    {\n      if (*s < ' ')\n\t{\n\t  *r++ = '^';\n\t  *r++ = *s+64;\n\t}\n      else if (*s == 127)\n\t{\n\t  *r++ = '^';\n\t  *r++ = '?';\n\t}\n     else\n\t*r++ = *s;\n    }\n\n  *r = '\\0';\n  return result;\n}\n\nvoid\n#if defined (PREFER_STDARG)\nitrace (const char *format, ...)\n#else\nitrace (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  fprintf(stderr, \"TRACE: pid %ld: \", (long)getpid());\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n\n  va_end (args);\n\n  fflush(stderr);\n}\n\n \nvoid\n#if defined (PREFER_STDARG)\ntrace (const char *format, ...)\n#else\ntrace (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n  static FILE *tracefp = (FILE *)NULL;\n\n  if (tracefp == NULL)\n    tracefp = fopen(\"/tmp/bash-trace.log\", \"a+\");\n\n  if (tracefp == NULL)\n    tracefp = stderr;\n  else\n    fcntl (fileno (tracefp), F_SETFD, 1);      \n\n  fprintf(tracefp, \"TRACE: pid %ld: \", (long)getpid());\n\n  SH_VA_START (args, format);\n\n  vfprintf (tracefp, format, args);\n  fprintf (tracefp, \"\\n\");\n\n  va_end (args);\n\n  fflush(tracefp);\n}\n\n#endif  \n\n \n \n \n \n \n\n\nstatic const char * const cmd_error_table[] = {\n\tN_(\"unknown command error\"),\t \n\tN_(\"bad command type\"),\t\t \n\tN_(\"bad connector\"),\t\t \n\tN_(\"bad jump\"),\t\t\t \n\t0\n};\n\nvoid\ncommand_error (func, code, e, flags)\n     const char *func;\n     int code, e, flags;\t \n{\n  if (code > CMDERR_LAST)\n    code = CMDERR_DEFAULT;\n\n  programming_error (\"%s: %s: %d\", func, _(cmd_error_table[code]), e);\n}\n\nchar *\ncommand_errstr (code)\n     int code;\n{\n  if (code > CMDERR_LAST)\n    code = CMDERR_DEFAULT;\n\n  return (_(cmd_error_table[code]));\n}\n\n#ifdef ARRAY_VARS\nvoid\nerr_badarraysub (s)\n     const char *s;\n{\n  report_error (\"%s: %s\", s, _(bash_badsub_errmsg));\n}\n#endif\n\nvoid\nerr_unboundvar (s)\n     const char *s;\n{\n  report_error (_(\"%s: unbound variable\"), s);\n}\n\nvoid\nerr_readonly (s)\n     const char *s;\n{\n  report_error (_(\"%s: readonly variable\"), s);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}