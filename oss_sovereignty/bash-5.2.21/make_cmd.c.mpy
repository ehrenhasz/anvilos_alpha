{
  "module_name": "make_cmd.c",
  "hash_id": "25090758477debb2c55ecbf380de52f34a586b4997d20add45c10df6bd382f95",
  "original_prompt": "Ingested from bash-5.2.21/make_cmd.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include <stdio.h>\n#include \"bashtypes.h\"\n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"filecntl.h\"\n#include \"bashansi.h\"\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"parser.h\"\n#include \"flags.h\"\n#include \"input.h\"\n\n#if defined (JOB_CONTROL)\n#include \"jobs.h\"\n#endif\n\n#include \"shmbutil.h\"\n\nint here_doc_first_line = 0;\n\n \nsh_obj_cache_t wdcache = {0, 0, 0};\nsh_obj_cache_t wlcache = {0, 0, 0};\n\n#define WDCACHESIZE\t128\n#define WLCACHESIZE\t128\n\nstatic COMMAND *make_for_or_select PARAMS((enum command_type, WORD_DESC *, WORD_LIST *, COMMAND *, int));\n#if defined (ARITH_FOR_COMMAND)\nstatic WORD_LIST *make_arith_for_expr PARAMS((char *));\n#endif\nstatic COMMAND *make_until_or_while PARAMS((enum command_type, COMMAND *, COMMAND *));\n\nvoid\ncmd_init ()\n{\n  ocache_create (wdcache, WORD_DESC, WDCACHESIZE);\n  ocache_create (wlcache, WORD_LIST, WLCACHESIZE);\n}\n\nWORD_DESC *\nalloc_word_desc ()\n{\n  WORD_DESC *temp;\n\n  ocache_alloc (wdcache, WORD_DESC, temp);\n  temp->flags = 0;\n  temp->word = 0;\n  return temp;\n}\n\nWORD_DESC *\nmake_bare_word (string)\n     const char *string;\n{\n  WORD_DESC *temp;\n\n  temp = alloc_word_desc ();\n\n  if (*string)\n    temp->word = savestring (string);\n  else\n    {\n      temp->word = (char *)xmalloc (1);\n      temp->word[0] = '\\0';\n    }\n\n  return (temp);\n}\n\nWORD_DESC *\nmake_word_flags (w, string)\n     WORD_DESC *w;\n     const char *string;\n{\n  register int i;\n  size_t slen;\n  DECLARE_MBSTATE;\n\n  i = 0;\n  slen = strlen (string);\n  while (i < slen)\n    {\n      switch (string[i])\n\t{\n\tcase '$':\n\t  w->flags |= W_HASDOLLAR;\n\t  break;\n\tcase '\\\\':\n\t  break;\t \n\tcase '\\'':\n\tcase '`':\n\tcase '\"':\n\t  w->flags |= W_QUOTED;\n\t  break;\n\t}\n\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  return (w);\n}\n\nWORD_DESC *\nmake_word (string)\n     const char *string;\n{\n  WORD_DESC *temp;\n\n  temp = make_bare_word (string);\n  return (make_word_flags (temp, string));\n}\n\nWORD_DESC *\nmake_word_from_token (token)\n     int token;\n{\n  char tokenizer[2];\n\n  tokenizer[0] = token;\n  tokenizer[1] = '\\0';\n\n  return (make_word (tokenizer));\n}\n\nWORD_LIST *\nmake_word_list (word, wlink)\n     WORD_DESC *word;\n     WORD_LIST *wlink;\n{\n  WORD_LIST *temp;\n\n  ocache_alloc (wlcache, WORD_LIST, temp);\n\n  temp->word = word;\n  temp->next = wlink;\n  return (temp);\n}\n\nCOMMAND *\nmake_command (type, pointer)\n     enum command_type type;\n     SIMPLE_COM *pointer;\n{\n  COMMAND *temp;\n\n  temp = (COMMAND *)xmalloc (sizeof (COMMAND));\n  temp->type = type;\n  temp->value.Simple = pointer;\n  temp->value.Simple->flags = temp->flags = 0;\n  temp->redirects = (REDIRECT *)NULL;\n  return (temp);\n}\n\nCOMMAND *\ncommand_connect (com1, com2, connector)\n     COMMAND *com1, *com2;\n     int connector;\n{\n  CONNECTION *temp;\n\n  temp = (CONNECTION *)xmalloc (sizeof (CONNECTION));\n  temp->connector = connector;\n  temp->first = com1;\n  temp->second = com2;\n  return (make_command (cm_connection, (SIMPLE_COM *)temp));\n}\n\nstatic COMMAND *\nmake_for_or_select (type, name, map_list, action, lineno)\n     enum command_type type;\n     WORD_DESC *name;\n     WORD_LIST *map_list;\n     COMMAND *action;\n     int lineno;\n{\n  FOR_COM *temp;\n\n  temp = (FOR_COM *)xmalloc (sizeof (FOR_COM));\n  temp->flags = 0;\n  temp->name = name;\n  temp->line = lineno;\n  temp->map_list = map_list;\n  temp->action = action;\n  return (make_command (type, (SIMPLE_COM *)temp));\n}\n\nCOMMAND *\nmake_for_command (name, map_list, action, lineno)\n     WORD_DESC *name;\n     WORD_LIST *map_list;\n     COMMAND *action;\n     int lineno;\n{\n  return (make_for_or_select (cm_for, name, map_list, action, lineno));\n}\n\nCOMMAND *\nmake_select_command (name, map_list, action, lineno)\n     WORD_DESC *name;\n     WORD_LIST *map_list;\n     COMMAND *action;\n     int lineno;\n{\n#if defined (SELECT_COMMAND)\n  return (make_for_or_select (cm_select, name, map_list, action, lineno));\n#else\n  set_exit_status (2);\n  return ((COMMAND *)NULL);\n#endif\n}\n\n#if defined (ARITH_FOR_COMMAND)\nstatic WORD_LIST *\nmake_arith_for_expr (s)\n     char *s;\n{\n  WORD_LIST *result;\n  WORD_DESC *wd;\n\n  if (s == 0 || *s == '\\0')\n    return ((WORD_LIST *)NULL);\n  wd = make_word (s);\n  wd->flags |= W_NOGLOB|W_NOSPLIT|W_QUOTED|W_NOTILDE|W_NOPROCSUB;\t \n  result = make_word_list (wd, (WORD_LIST *)NULL);\n  return result;\n}\n#endif\n\n \nCOMMAND *\nmake_arith_for_command (exprs, action, lineno)\n     WORD_LIST *exprs;\n     COMMAND *action;\n     int lineno;\n{\n#if defined (ARITH_FOR_COMMAND)\n  ARITH_FOR_COM *temp;\n  WORD_LIST *init, *test, *step;\n  char *s, *t, *start;\n  int nsemi, i;\n\n  init = test = step = (WORD_LIST *)NULL;\n   \n  start = t = s = exprs->word->word;\n  for (nsemi = 0; ;)\n    {\n       \n      while (whitespace (*s))\n\ts++;\n      start = s;\n       \n      i = skip_to_delim (start, 0, \";\", SD_NOJMP|SD_NOPROCSUB);\n      s = start + i;\n\n      t = (i > 0) ? substring (start, 0, i) : (char *)NULL;\n\n      nsemi++;\n      switch (nsemi)\n\t{\n\tcase 1:\n\t  init = make_arith_for_expr (t);\n\t  break;\n\tcase 2:\n\t  test = make_arith_for_expr (t);\n\t  break;\n\tcase 3:\n\t  step = make_arith_for_expr (t);\n\t  break;\n\t}\n\n      FREE (t);\n      if (*s == '\\0')\n\tbreak;\n      s++;\t \n    }\n\n  if (nsemi != 3)\n    {\n      if (nsemi < 3)\n\tparser_error (lineno, _(\"syntax error: arithmetic expression required\"));\n      else\n\tparser_error (lineno, _(\"syntax error: `;' unexpected\"));\n      parser_error (lineno, _(\"syntax error: `((%s))'\"), exprs->word->word);\n      free (init);\n      free (test);\n      free (step);\n      set_exit_status (2);\n      return ((COMMAND *)NULL);\n    }\n\n  temp = (ARITH_FOR_COM *)xmalloc (sizeof (ARITH_FOR_COM));\n  temp->flags = 0;\n  temp->line = lineno;\n  temp->init = init ? init : make_arith_for_expr (\"1\");\n  temp->test = test ? test : make_arith_for_expr (\"1\");\n  temp->step = step ? step : make_arith_for_expr (\"1\");\n  temp->action = action;\n\n  dispose_words (exprs);\n  return (make_command (cm_arith_for, (SIMPLE_COM *)temp));\n#else\n  dispose_words (exprs);\n  set_exit_status (2);\n  return ((COMMAND *)NULL);\n#endif  \n}\n\nCOMMAND *\nmake_group_command (command)\n     COMMAND *command;\n{\n  GROUP_COM *temp;\n\n  temp = (GROUP_COM *)xmalloc (sizeof (GROUP_COM));\n  temp->command = command;\n  return (make_command (cm_group, (SIMPLE_COM *)temp));\n}\n\nCOMMAND *\nmake_case_command (word, clauses, lineno)\n     WORD_DESC *word;\n     PATTERN_LIST *clauses;\n     int lineno;\n{\n  CASE_COM *temp;\n\n  temp = (CASE_COM *)xmalloc (sizeof (CASE_COM));\n  temp->flags = 0;\n  temp->line = lineno;\n  temp->word = word;\n  temp->clauses = REVERSE_LIST (clauses, PATTERN_LIST *);\n  return (make_command (cm_case, (SIMPLE_COM *)temp));\n}\n\nPATTERN_LIST *\nmake_pattern_list (patterns, action)\n     WORD_LIST *patterns;\n     COMMAND *action;\n{\n  PATTERN_LIST *temp;\n\n  temp = (PATTERN_LIST *)xmalloc (sizeof (PATTERN_LIST));\n  temp->patterns = REVERSE_LIST (patterns, WORD_LIST *);\n  temp->action = action;\n  temp->next = NULL;\n  temp->flags = 0;\n  return (temp);\n}\n\nCOMMAND *\nmake_if_command (test, true_case, false_case)\n     COMMAND *test, *true_case, *false_case;\n{\n  IF_COM *temp;\n\n  temp = (IF_COM *)xmalloc (sizeof (IF_COM));\n  temp->flags = 0;\n  temp->test = test;\n  temp->true_case = true_case;\n  temp->false_case = false_case;\n  return (make_command (cm_if, (SIMPLE_COM *)temp));\n}\n\nstatic COMMAND *\nmake_until_or_while (which, test, action)\n     enum command_type which;\n     COMMAND *test, *action;\n{\n  WHILE_COM *temp;\n\n  temp = (WHILE_COM *)xmalloc (sizeof (WHILE_COM));\n  temp->flags = 0;\n  temp->test = test;\n  temp->action = action;\n  return (make_command (which, (SIMPLE_COM *)temp));\n}\n\nCOMMAND *\nmake_while_command (test, action)\n     COMMAND *test, *action;\n{\n  return (make_until_or_while (cm_while, test, action));\n}\n\nCOMMAND *\nmake_until_command (test, action)\n     COMMAND *test, *action;\n{\n  return (make_until_or_while (cm_until, test, action));\n}\n\nCOMMAND *\nmake_arith_command (exp)\n     WORD_LIST *exp;\n{\n#if defined (DPAREN_ARITHMETIC)\n  COMMAND *command;\n  ARITH_COM *temp;\n\n  command = (COMMAND *)xmalloc (sizeof (COMMAND));\n  command->value.Arith = temp = (ARITH_COM *)xmalloc (sizeof (ARITH_COM));\n\n  temp->flags = 0;\n  temp->line = line_number;\n  temp->exp = exp;\n\n  command->type = cm_arith;\n  command->redirects = (REDIRECT *)NULL;\n  command->flags = 0;\n\n  return (command);\n#else\n  set_exit_status (2);\n  return ((COMMAND *)NULL);\n#endif\n}\n\n#if defined (COND_COMMAND)\nstruct cond_com *\nmake_cond_node (type, op, left, right)\n     int type;\n     WORD_DESC *op;\n     struct cond_com *left, *right;\n{\n  COND_COM *temp;\n\n  temp = (COND_COM *)xmalloc (sizeof (COND_COM));\n  temp->flags = 0;\n  temp->line = line_number;\n  temp->type = type;\n  temp->op = op;\n  temp->left = left;\n  temp->right = right;\n\n  return (temp);\n}\n#endif\n\nCOMMAND *\nmake_cond_command (cond_node)\n     COND_COM *cond_node;\n{\n#if defined (COND_COMMAND)\n  COMMAND *command;\n\n  command = (COMMAND *)xmalloc (sizeof (COMMAND));\n  command->value.Cond = cond_node;\n\n  command->type = cm_cond;\n  command->redirects = (REDIRECT *)NULL;\n  command->flags = 0;\n  command->line = cond_node ? cond_node->line : 0;\n\n  return (command);\n#else\n  set_exit_status (2);\n  return ((COMMAND *)NULL);\n#endif\n}\n\nCOMMAND *\nmake_bare_simple_command ()\n{\n  COMMAND *command;\n  SIMPLE_COM *temp;\n\n  command = (COMMAND *)xmalloc (sizeof (COMMAND));\n  command->value.Simple = temp = (SIMPLE_COM *)xmalloc (sizeof (SIMPLE_COM));\n\n  temp->flags = 0;\n  temp->line = line_number;\n  temp->words = (WORD_LIST *)NULL;\n  temp->redirects = (REDIRECT *)NULL;\n\n  command->type = cm_simple;\n  command->redirects = (REDIRECT *)NULL;\n  command->flags = 0;\n\n  return (command);\n}\n\n \nCOMMAND *\nmake_simple_command (element, command)\n     ELEMENT element;\n     COMMAND *command;\n{\n   \n  if (command == 0)\n    {\n      command = make_bare_simple_command ();\n      parser_state |= PST_REDIRLIST;\n    }\n\n  if (element.word)\n    {\n      command->value.Simple->words = make_word_list (element.word, command->value.Simple->words);\n      parser_state &= ~PST_REDIRLIST;\n    }\n  else if (element.redirect)\n    {\n      REDIRECT *r = element.redirect;\n       \n      while (r->next)\n\tr = r->next;\n      r->next = command->value.Simple->redirects;\n      command->value.Simple->redirects = element.redirect;\n    }\n\n  return (command);\n}\n\n \nvoid\nmake_here_document (temp, lineno)\n     REDIRECT *temp;\n     int lineno;\n{\n  int kill_leading, redir_len;\n  char *redir_word, *document, *full_line;\n  int document_index, document_size, delim_unquoted;\n\n  if (temp->instruction != r_deblank_reading_until &&\n      temp->instruction != r_reading_until)\n    {\n      internal_error (_(\"make_here_document: bad instruction type %d\"), temp->instruction);\n      return;\n    }\n\n  kill_leading = temp->instruction == r_deblank_reading_until;\n\n  full_line = document = (char *)NULL;\n  document_index = document_size = 0;\n\n  delim_unquoted = (temp->redirectee.filename->flags & W_QUOTED) == 0;\n\n   \n   \n  if (delim_unquoted == 0)\n    redir_word = string_quote_removal (temp->redirectee.filename->word, 0);\n  else\n    redir_word = savestring (temp->redirectee.filename->word);\n\n   \n  if (redir_word)\n    redir_len = strlen (redir_word);\n  else\n    {\n      temp->here_doc_eof = (char *)xmalloc (1);\n      temp->here_doc_eof[0] = '\\0';\n      goto document_done;\n    }\n\n  free (temp->redirectee.filename->word);\n  temp->here_doc_eof = redir_word;\n\n   \n\n   \n  while (full_line = read_secondary_line (delim_unquoted))\n    {\n      register char *line;\n      int len;\n\n      here_doc_first_line = 0;\n      line = full_line;\n      line_number++;\n\n       \n      if (echo_input_at_read)\n\tfprintf (stderr, \"%s\", line);\n\n      if (kill_leading && *line)\n\t{\n\t   \n\t  if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\\n')\n\t    break;\n\n\t  while (*line == '\\t')\n\t    line++;\n\t}\n\n      if (*line == 0)\n\tcontinue;\n\n      if (STREQN (line, redir_word, redir_len) && line[redir_len] == '\\n')\n\tbreak;\n\n       \n      if (STREQN (line, redir_word, redir_len) && (parser_state & PST_EOFTOKEN) && shell_eof_token && strchr (line+redir_len, shell_eof_token))\n\t{\n\t  shell_ungets (line + redir_len);\n\t  full_line = 0;\n\t  break;\n\t}\n\n      len = strlen (line);\n      if (len + document_index >= document_size)\n\t{\n\t  document_size = document_size ? 2 * (document_size + len) : len + 2;\n\t  document = (char *)xrealloc (document, document_size);\n\t}\n\n       \n      FASTCOPY (line, document + document_index, len);\n      document_index += len;\n    }\n\n  if (full_line == 0)\n    internal_warning (_(\"here-document at line %d delimited by end-of-file (wanted `%s')\"), lineno, redir_word);\n\ndocument_done:\n  if (document)\n    document[document_index] = '\\0';\n  else\n    {\n      document = (char *)xmalloc (1);\n      document[0] = '\\0';\n    }\n  temp->redirectee.filename->word = document;\n  here_doc_first_line = 0;\n}\n\n \nREDIRECT *\nmake_redirection (source, instruction, dest_and_filename, flags)\n     REDIRECTEE source;\n     enum r_instruction instruction;\n     REDIRECTEE dest_and_filename;\n     int flags;\n{\n  REDIRECT *temp;\n  WORD_DESC *w;\n  int wlen;\n  intmax_t lfd;\n\n  temp = (REDIRECT *)xmalloc (sizeof (REDIRECT));\n\n   \n  temp->redirector = source;\n  temp->redirectee = dest_and_filename;\n  temp->here_doc_eof = 0;\n  temp->instruction = instruction;\n  temp->flags = 0;\n  temp->rflags = flags;\n  temp->next = (REDIRECT *)NULL;\n\n  switch (instruction)\n    {\n\n    case r_output_direction:\t\t \n    case r_output_force:\t\t \n    case r_err_and_out:\t\t\t \n      temp->flags = O_TRUNC | O_WRONLY | O_CREAT;\n      break;\n\n    case r_appending_to:\t\t \n    case r_append_err_and_out:\t\t \n      temp->flags = O_APPEND | O_WRONLY | O_CREAT;\n      break;\n\n    case r_input_direction:\t\t \n    case r_inputa_direction:\t\t \n      temp->flags = O_RDONLY;\n      break;\n\n    case r_input_output:\t\t \n      temp->flags = O_RDWR | O_CREAT;\n      break;\n\n    case r_deblank_reading_until: \t \n    case r_reading_until:\t\t \n    case r_reading_string:\t\t \n    case r_close_this:\t\t\t \n    case r_duplicating_input:\t\t \n    case r_duplicating_output:\t\t \n      break;\n\n     \n    case r_move_input:\t\t\t \n    case r_move_output:\t\t\t \n    case r_move_input_word:\t\t \n    case r_move_output_word:\t\t \n      break;\n\n     \n    case r_duplicating_input_word:\t \n    case r_duplicating_output_word:\t \n      w = dest_and_filename.filename;\n      wlen = strlen (w->word) - 1;\n      if (w->word[wlen] == '-')\t\t \n        {\n          w->word[wlen] = '\\0';\n\t  if (all_digits (w->word) && legal_number (w->word, &lfd) && lfd == (int)lfd)\n\t    {\n\t      dispose_word (w);\n\t      temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input : r_move_output;\n\t      temp->redirectee.dest = lfd;\n\t    }\n\t  else\n\t    temp->instruction = (instruction == r_duplicating_input_word) ? r_move_input_word : r_move_output_word;\n        }\n          \n      break;\n\n    default:\n      programming_error (_(\"make_redirection: redirection instruction `%d' out of range\"), instruction);\n      abort ();\n      break;\n    }\n  return (temp);\n}\n\nCOMMAND *\nmake_function_def (name, command, lineno, lstart)\n     WORD_DESC *name;\n     COMMAND *command;\n     int lineno, lstart;\n{\n  FUNCTION_DEF *temp;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *bash_source_v;\n  ARRAY *bash_source_a;\n#endif\n\n  temp = (FUNCTION_DEF *)xmalloc (sizeof (FUNCTION_DEF));\n  temp->command = command;\n  temp->name = name;\n  temp->line = lineno;\n  temp->flags = 0;\n  command->line = lstart;\n\n   \n  temp->source_file = 0;\n#if defined (ARRAY_VARS)\n  GET_ARRAY_FROM_VAR (\"BASH_SOURCE\", bash_source_v, bash_source_a);\n  if (bash_source_a && array_num_elements (bash_source_a) > 0)\n    temp->source_file = array_reference (bash_source_a, 0);\n#endif\n   \n  if (temp->source_file == 0)\n    temp->source_file = shell_initialized ? \"main\" : \"environment\";\n\n#if defined (DEBUGGER)\n  bind_function_def (name->word, temp, 0);\n#endif\n\n  temp->source_file = temp->source_file ? savestring (temp->source_file) : 0;\n\n  return (make_command (cm_function_def, (SIMPLE_COM *)temp));\n}\n\nCOMMAND *\nmake_subshell_command (command)\n     COMMAND *command;\n{\n  SUBSHELL_COM *temp;\n\n  temp = (SUBSHELL_COM *)xmalloc (sizeof (SUBSHELL_COM));\n  temp->command = command;\n  temp->flags = CMD_WANT_SUBSHELL;\n  temp->line = line_number;\n  return (make_command (cm_subshell, (SIMPLE_COM *)temp));\n}\n\nCOMMAND *\nmake_coproc_command (name, command)\n     char *name;\n     COMMAND *command;\n{\n  COPROC_COM *temp;\n\n  temp = (COPROC_COM *)xmalloc (sizeof (COPROC_COM));\n  temp->name = savestring (name);\n  temp->command = command;\n  temp->flags = CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;\n  return (make_command (cm_coproc, (SIMPLE_COM *)temp));\n}\n\n \nCOMMAND *\nclean_simple_command (command)\n     COMMAND *command;\n{\n  if (command->type != cm_simple)\n    command_error (\"clean_simple_command\", CMDERR_BADTYPE, command->type, 0);\n  else\n    {\n      command->value.Simple->words =\n\tREVERSE_LIST (command->value.Simple->words, WORD_LIST *);\n      command->value.Simple->redirects =\n\tREVERSE_LIST (command->value.Simple->redirects, REDIRECT *);\n    }\n\n  parser_state &= ~PST_REDIRLIST;\n  return (command);\n}\n\n \nCOMMAND *\nconnect_async_list (command, command2, connector)\n     COMMAND *command, *command2;\n     int connector;\n{\n  COMMAND *t, *t1, *t2;\n\n  t1 = command;\n  t = command->value.Connection->second;\n\n  if (!t || (command->flags & CMD_WANT_SUBSHELL) ||\n      command->value.Connection->connector != ';')\n    {\n      t = command_connect (command, command2, connector);\n      return t;\n    }\n\n   \n  while (((t->flags & CMD_WANT_SUBSHELL) == 0) && t->type == cm_connection &&\n\t t->value.Connection->connector == ';')\n    {\n      t1 = t;\n      t = t->value.Connection->second;\n    }\n   \n  t2 = command_connect (t, command2, connector);\n  t1->value.Connection->second = t2;\n  return command;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}