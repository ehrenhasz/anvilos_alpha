{
  "module_name": "shell.c",
  "hash_id": "f1f9166194335d65ab38f6fb7f1dea1c22fc02df7c3954695532a1c95a28d4e1",
  "original_prompt": "Ingested from bash-5.2.21/shell.c",
  "human_readable_source": " \n\n \n\n \n#define INSTALL_DEBUG_MODE\n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"posixstat.h\"\n#include \"posixtime.h\"\n#include \"bashansi.h\"\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include \"filecntl.h\"\n#if defined (HAVE_PWD_H)\n#  include <pwd.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashintl.h\"\n\n#define NEED_SH_SETLINEBUF_DECL\t\t \n\n#include \"shell.h\"\n#include \"parser.h\"\n#include \"flags.h\"\n#include \"trap.h\"\n#include \"mailcheck.h\"\n#include \"builtins.h\"\n#include \"builtins/common.h\"\n\n#if defined (JOB_CONTROL)\n#include \"jobs.h\"\n#else\nextern int running_in_background;\nextern int initialize_job_control PARAMS((int));\nextern int get_tty_state PARAMS((void));\n#endif  \n\n#include \"input.h\"\n#include \"execute_cmd.h\"\n#include \"findcmd.h\"\n\n#if defined (USING_BASH_MALLOC) && defined (DEBUG) && !defined (DISABLE_MALLOC_WRAPPERS)\n#  include <malloc/shmalloc.h>\n#elif defined (MALLOC_DEBUG) && defined (USING_BASH_MALLOC)\n#  include <malloc/shmalloc.h>\n#endif\n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#  include <readline/history.h>\n#endif\n\n#if defined (READLINE)\n#  include <readline/readline.h>\n#  include \"bashline.h\"\n#endif\n\n#include <tilde/tilde.h>\n#include <glob/strmatch.h>\n\n#if defined (__OPENNT)\n#  include <opennt/opennt.h>\n#endif\n\n#if !defined (HAVE_GETPW_DECLS)\nextern struct passwd *getpwuid ();\n#endif  \n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#if defined (NO_MAIN_ENV_ARG)\nextern char **environ;\t \n#endif\n\nextern int gnu_error_format;\n\n \nint shell_initialized = 0;\nint bash_argv_initialized = 0;\n\nCOMMAND *global_command = (COMMAND *)NULL;\n\n \nstruct user_info current_user =\n{\n  (uid_t)-1, (uid_t)-1, (gid_t)-1, (gid_t)-1,\n  (char *)NULL, (char *)NULL, (char *)NULL\n};\n\n \nchar *current_host_name = (char *)NULL;\n\n \nint login_shell = 0;\n\n \nint interactive = 0;\n\n \nint interactive_shell = 0;\n\n \nint hup_on_exit = 0;\n\n \nint check_jobs_at_exit = 0;\n\n \nint autocd = 0;\n\n \nint startup_state = 0;\nint reading_shell_script = 0;\n\n \nint debugging_login_shell = 0;\n\n \nchar **shell_environment;\n\n \nint executing = 0;\n\n \nint current_command_number = 1;\n\n \nint indirection_level = 0;\n\n \nchar *shell_name = (char *)NULL;\n\n \ntime_t shell_start_time;\nstruct timeval shellstart;\n\n \nint running_under_emacs;\n\n \n#ifdef HAVE_DEV_FD\nint have_devfd = HAVE_DEV_FD;\n#else\nint have_devfd = 0;\n#endif\n\n \nstatic char *bashrc_file = DEFAULT_BASHRC;\n\n \nstatic int act_like_sh;\n\n \nstatic int su_shell;\n\n \nstatic int sourced_env;\n\n \nstatic int running_setuid;\n\n \nstatic int debugging;\t\t\t \nstatic int no_rc;\t\t\t \nstatic int no_profile;\t\t\t \nstatic int do_version;\t\t\t \nstatic int make_login_shell;\t\t \nstatic int want_initial_help;\t\t \n\nint debugging_mode = 0;\t\t \n#if defined (READLINE)\nint no_line_editing = 0;\t \n#else\nint no_line_editing = 1;\t \n#endif\n#if defined (TRANSLATABLE_STRINGS)\nint dump_translatable_strings;\t \nint dump_po_strings;\t\t \n#endif\nint wordexp_only = 0;\t\t \nint protected_mode = 0;\t\t \n\nint pretty_print_mode = 0;\t \n\n#if defined (STRICT_POSIX)\nint posixly_correct = 1;\t \n#else\nint posixly_correct = 0;\t \n#endif\n\n \n#define Int 1\n#define Charp 2\nstatic const struct {\n  const char *name;\n  int type;\n  int *int_value;\n  char **char_value;\n} long_args[] = {\n  { \"debug\", Int, &debugging, (char **)0x0 },\n#if defined (DEBUGGER)\n  { \"debugger\", Int, &debugging_mode, (char **)0x0 },\n#endif\n#if defined (TRANSLATABLE_STRINGS)\n  { \"dump-po-strings\", Int, &dump_po_strings, (char **)0x0 },\n  { \"dump-strings\", Int, &dump_translatable_strings, (char **)0x0 },\n#endif\n  { \"help\", Int, &want_initial_help, (char **)0x0 },\n  { \"init-file\", Charp, (int *)0x0, &bashrc_file },\n  { \"login\", Int, &make_login_shell, (char **)0x0 },\n  { \"noediting\", Int, &no_line_editing, (char **)0x0 },\n  { \"noprofile\", Int, &no_profile, (char **)0x0 },\n  { \"norc\", Int, &no_rc, (char **)0x0 },\n  { \"posix\", Int, &posixly_correct, (char **)0x0 },\n  { \"pretty-print\", Int, &pretty_print_mode, (char **)0x0 },\n#if defined (WORDEXP_OPTION)\n  { \"protected\", Int, &protected_mode, (char **)0x0 },\n#endif\n  { \"rcfile\", Charp, (int *)0x0, &bashrc_file },\n#if defined (RESTRICTED_SHELL)\n  { \"restricted\", Int, &restricted, (char **)0x0 },\n#endif\n  { \"verbose\", Int, &verbose_flag, (char **)0x0 },\n  { \"version\", Int, &do_version, (char **)0x0 },\n#if defined (WORDEXP_OPTION)\n  { \"wordexp\", Int, &wordexp_only, (char **)0x0 },\n#endif\n  { (char *)0x0, Int, (int *)0x0, (char **)0x0 }\n};\n\n \nprocenv_t subshell_top_level;\nint subshell_argc;\nchar **subshell_argv;\nchar **subshell_envp;\n\nchar *exec_argv0;\n\n#if defined (BUFFERED_INPUT)\n \nint default_buffered_input = -1;\n#endif\n\n \nint read_from_stdin;\t\t \nint want_pending_command;\t \n\n \nchar *command_execution_string;\t \nchar *shell_script_filename; \t \n\nint malloc_trace_at_exit = 0;\n\nstatic int shell_reinitialized = 0;\n\nstatic FILE *default_input;\n\nstatic STRING_INT_ALIST *shopt_alist;\nstatic int shopt_ind = 0, shopt_len = 0;\n\nstatic int parse_long_options PARAMS((char **, int, int));\nstatic int parse_shell_options PARAMS((char **, int, int));\nstatic int bind_args PARAMS((char **, int, int, int));\n\nstatic void start_debugger PARAMS((void));\n\nstatic void add_shopt_to_alist PARAMS((char *, int));\nstatic void run_shopt_alist PARAMS((void));\n\nstatic void execute_env_file PARAMS((char *));\nstatic void run_startup_files PARAMS((void));\nstatic int open_shell_script PARAMS((char *));\nstatic void set_bash_input PARAMS((void));\nstatic int run_one_command PARAMS((char *));\n#if defined (WORDEXP_OPTION)\nstatic int run_wordexp PARAMS((char *));\n#endif\n\nstatic int uidget PARAMS((void));\n\nstatic void set_option_defaults PARAMS((void));\nstatic void reset_option_defaults PARAMS((void));\n\nstatic void init_interactive PARAMS((void));\nstatic void init_noninteractive PARAMS((void));\nstatic void init_interactive_script PARAMS((void));\n\nstatic void set_shell_name PARAMS((char *));\nstatic void shell_initialize PARAMS((void));\nstatic void shell_reinitialize PARAMS((void));\n\nstatic void show_shell_usage PARAMS((FILE *, int));\n\n#ifdef __CYGWIN__\nstatic void\n_cygwin32_check_tmp ()\n{\n  struct stat sb;\n\n  if (stat (\"/tmp\", &sb) < 0)\n    internal_warning (_(\"could not find /tmp, please create!\"));\n  else\n    {\n      if (S_ISDIR (sb.st_mode) == 0)\n\tinternal_warning (_(\"/tmp must be a valid directory name\"));\n    }\n}\n#endif  \n\n#if defined (NO_MAIN_ENV_ARG)\n \nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n#else  \nint\nmain (argc, argv, env)\n     int argc;\n     char **argv, **env;\n#endif  \n{\n  register int i;\n  int code, old_errexit_flag;\n#if defined (RESTRICTED_SHELL)\n  int saverst;\n#endif\n  volatile int locally_skip_execution;\n  volatile int arg_index, top_level_arg_index;\n#ifdef __OPENNT\n  char **env;\n\n  env = environ;\n#endif  \n\n  USE_VAR(argc);\n  USE_VAR(argv);\n  USE_VAR(env);\n  USE_VAR(code);\n  USE_VAR(old_errexit_flag);\n#if defined (RESTRICTED_SHELL)\n  USE_VAR(saverst);\n#endif\n\n   \n  code = setjmp_nosigs (top_level);\n  if (code)\n    exit (2);\n\n  xtrace_init ();\n\n#if defined (USING_BASH_MALLOC) && defined (DEBUG) && !defined (DISABLE_MALLOC_WRAPPERS)\n  malloc_set_register (1);\t \n#endif\n\n  check_dev_tty ();\n\n#ifdef __CYGWIN__\n  _cygwin32_check_tmp ();\n#endif  \n\n   \n  while (debugging_login_shell) sleep (3);\n\n  set_default_locale ();\n\n  running_setuid = uidget ();\n\n  if (getenv (\"POSIXLY_CORRECT\") || getenv (\"POSIX_PEDANTIC\"))\n    posixly_correct = 1;\n\n#if defined (USE_GNU_MALLOC_LIBRARY)\n  mcheck (programming_error, (void (*) ())0);\n#endif  \n\n  if (setjmp_sigs (subshell_top_level))\n    {\n      argc = subshell_argc;\n      argv = subshell_argv;\n      env = subshell_envp;\n      sourced_env = 0;\n    }\n\n  shell_reinitialized = 0;\n\n   \n  arg_index = 1;\n  if (arg_index > argc)\n    arg_index = argc;\n  command_execution_string = shell_script_filename = (char *)NULL;\n  want_pending_command = locally_skip_execution = read_from_stdin = 0;\n  default_input = stdin;\n#if defined (BUFFERED_INPUT)\n  default_buffered_input = -1;\n#endif\n\n   \n  login_shell = make_login_shell = 0;\n\n   \n  if (shell_initialized || shell_name)\n    {\n       \n      if (*shell_name == '-')\n\tshell_name++;\n\n      shell_reinitialize ();\n      if (setjmp_nosigs (top_level))\n\texit (2);\n    }\n\n  shell_environment = env;\n  set_shell_name (argv[0]);\n\n  gettimeofday (&shellstart, 0);\n  shell_start_time = shellstart.tv_sec;\n\n   \n\n   \n  arg_index = parse_long_options (argv, arg_index, argc);\n  \n  if (want_initial_help)\n    {\n      show_shell_usage (stdout, 1);\n      exit (EXECUTION_SUCCESS);\n    }\n\n  if (do_version)\n    {\n      show_shell_version (1);\n      exit (EXECUTION_SUCCESS);\n    }\n\n  echo_input_at_read = verbose_flag;\t \n\n   \n  this_command_name = shell_name;\t \n  arg_index = parse_shell_options (argv, arg_index, argc);\n\n   \n  if (make_login_shell)\n    {\n      login_shell++;\n      login_shell = -login_shell;\n    }\n\n  set_login_shell (\"login_shell\", login_shell != 0);\n\n#if defined (TRANSLATABLE_STRINGS)\n  if (dump_po_strings)\n    dump_translatable_strings = 1;\n\n  if (dump_translatable_strings)\n    read_but_dont_execute = 1;\n#endif\n\n  if (running_setuid && privileged_mode == 0)\n    disable_priv_mode ();\n\n   \n  if (want_pending_command)\n    {\n      command_execution_string = argv[arg_index];\n      if (command_execution_string == 0)\n\t{\n\t  report_error (_(\"%s: option requires an argument\"), \"-c\");\n\t  exit (EX_BADUSAGE);\n\t}\n      arg_index++;\n    }\n  this_command_name = (char *)NULL;\n\n   \n\n  if (forced_interactive ||\t\t \n      (!command_execution_string &&\t \n       wordexp_only == 0 &&\t\t \n       ((arg_index == argc) ||\t\t \n\tread_from_stdin) &&\t\t \n       isatty (fileno (stdin)) &&\t \n       isatty (fileno (stderr))))\t \n    init_interactive ();\n  else\n    init_noninteractive ();\n\n   \n  if (login_shell && interactive_shell)\n    {\n      for (i = 3; i < 20; i++)\n\tSET_CLOSE_ON_EXEC (i);\n    }\n\n   \n  if (posixly_correct)\n    {\n      bind_variable (\"POSIXLY_CORRECT\", \"y\", 0);\n      sv_strict_posix (\"POSIXLY_CORRECT\");\n    }\n\n   \n  if (shopt_alist)\n    run_shopt_alist ();\n\n   \n  shell_initialize ();\n\n  set_default_lang ();\n  set_default_locale_vars ();\n\n   \n  if (interactive_shell)\n    {\n      char *term, *emacs, *inside_emacs;\n      int emacs_term, in_emacs;\n\n      term = get_string_value (\"TERM\");\n      emacs = get_string_value (\"EMACS\");\n      inside_emacs = get_string_value (\"INSIDE_EMACS\");\n\n      if (inside_emacs)\n\t{\n\t  emacs_term = strstr (inside_emacs, \",term:\") != 0;\n\t  in_emacs = 1;\n\t}\n      else if (emacs)\n\t{\n\t   \n\t  emacs_term = strstr (emacs, \" (term:\") != 0;\n\t  in_emacs = emacs_term || STREQ (emacs, \"t\");\n\t}\n      else\n\tin_emacs = emacs_term = 0;\n\n       \n      no_line_editing |= STREQ (term, \"emacs\");\n      no_line_editing |= in_emacs && STREQ (term, \"dumb\");\n\n       \n      running_under_emacs = in_emacs || STREQN (term, \"emacs\", 5);\n      running_under_emacs += emacs_term && STREQN (term, \"eterm\", 5);\n\n      if (running_under_emacs)\n\tgnu_error_format = 1;\n    }\n\n  top_level_arg_index = arg_index;\n  old_errexit_flag = exit_immediately_on_error;\n\n   \n  code = setjmp_sigs (top_level);\n  if (code)\n    {\n      if (code == EXITPROG || code == ERREXIT || code == EXITBLTIN)\n\texit_shell (last_command_exit_value);\n      else\n\t{\n#if defined (JOB_CONTROL)\n\t   \n\t  set_job_control (interactive_shell);\n#endif\n\t   \n\t  exit_immediately_on_error += old_errexit_flag;\n\t  locally_skip_execution++;\n\t}\n    }\n\n  arg_index = top_level_arg_index;\n\n   \n\n  if (interactive_shell == 0)\n    {\n      unbind_variable (\"PS1\");\n      unbind_variable (\"PS2\");\n      interactive = 0;\n#if 0\n       \n      expand_aliases = posixly_correct;\n#endif\n    }\n  else\n    {\n      change_flag ('i', FLAG_ON);\n      interactive = 1;\n    }\n\n#if defined (RESTRICTED_SHELL)\n   \n  restricted_shell = shell_is_restricted (shell_name);\n\n   \n  saverst = restricted;\n  restricted = 0;\n#endif\n\n   \n  if (wordexp_only)\n    ;\t\t\t \n  else if (command_execution_string)\n    arg_index = bind_args (argv, arg_index, argc, 0);\t \n  else if (arg_index != argc && read_from_stdin == 0)\n    {\n      shell_script_filename = argv[arg_index++];\n      arg_index = bind_args (argv, arg_index, argc, 1);\t \n    }\n  else\n    arg_index = bind_args (argv, arg_index, argc, 1);\t \n\n   \n  if (locally_skip_execution == 0 && running_setuid == 0)\n    {\n      char *t;\n\n      old_errexit_flag = exit_immediately_on_error;\n      exit_immediately_on_error = 0;\n\n       \n      if (shell_script_filename)\n\t{\n\t  t = dollar_vars[0];\n\t  dollar_vars[0] = exec_argv0 ? savestring (exec_argv0) : savestring (shell_script_filename);\n\t}\n      run_startup_files ();\n      if (shell_script_filename)\n\t{\n\t  free (dollar_vars[0]);\n\t  dollar_vars[0] = t;\n\t}\n      exit_immediately_on_error += old_errexit_flag;\n    }\n\n   \n  if (act_like_sh)\n    {\n      bind_variable (\"POSIXLY_CORRECT\", \"y\", 0);\n      sv_strict_posix (\"POSIXLY_CORRECT\");\n    }\n\n#if defined (RESTRICTED_SHELL)\n   \n  restricted = saverst || restricted;\n  if (shell_reinitialized == 0)\n    maybe_make_restricted (shell_name);\n#endif  \n\n#if defined (WORDEXP_OPTION)\n  if (wordexp_only)\n    {\n      startup_state = 3;\n      last_command_exit_value = run_wordexp (argv[top_level_arg_index]);\n      exit_shell (last_command_exit_value);\n    }\n#endif\n\n  cmd_init ();\t\t \n  uwp_init ();\n\n  if (command_execution_string)\n    {\n      startup_state = 2;\n\n      if (debugging_mode)\n\tstart_debugger ();\n\n#if defined (ONESHOT)\n      executing = 1;\n      run_one_command (command_execution_string);\n      exit_shell (last_command_exit_value);\n#else  \n      with_input_from_string (command_execution_string, \"-c\");\n      goto read_and_execute;\n#endif  \n    }\n\n   \n  if (shell_script_filename)\n    open_shell_script (shell_script_filename);\n  else if (interactive == 0)\n    {\n       \n#if defined (BUFFERED_INPUT)\n      default_buffered_input = fileno (stdin);\t \n#else\n      setbuf (default_input, (char *)NULL);\n#endif  \n      read_from_stdin = 1;\n    }\n  else if (top_level_arg_index == argc)\t\t \n     \n    read_from_stdin = 1;\n\n  set_bash_input ();\n\n  if (debugging_mode && locally_skip_execution == 0 && running_setuid == 0 && (reading_shell_script || interactive_shell == 0))\n    start_debugger ();\n\n   \n  if (interactive_shell)\n    {\n       \n      reset_mail_timer ();\n      init_mail_dates ();\n\n#if defined (HISTORY)\n       \n      bash_initialize_history ();\n       \n      if (shell_initialized == 0 && history_lines_this_session == 0)\n\tload_history ();\n#endif  \n\n       \n      get_tty_state ();\n    }\n\n#if !defined (ONESHOT)\n read_and_execute:\n#endif  \n\n  shell_initialized = 1;\n\n  if (pretty_print_mode && interactive_shell)\n    {\n      internal_warning (_(\"pretty-printing mode ignored in interactive shells\"));\n      pretty_print_mode = 0;\n    }\n  if (pretty_print_mode)\n    exit_shell (pretty_print_loop ());\n\n   \n  reader_loop ();\n  exit_shell (last_command_exit_value);\n}\n\nstatic int\nparse_long_options (argv, arg_start, arg_end)\n     char **argv;\n     int arg_start, arg_end;\n{\n  int arg_index, longarg, i;\n  char *arg_string;\n\n  arg_index = arg_start;\n  while ((arg_index != arg_end) && (arg_string = argv[arg_index]) &&\n\t (*arg_string == '-'))\n    {\n      longarg = 0;\n\n       \n      if (arg_string[1] == '-' && arg_string[2])\n\t{\n\t  longarg = 1;\n\t  arg_string++;\n\t}\n\n      for (i = 0; long_args[i].name; i++)\n\t{\n\t  if (STREQ (arg_string + 1, long_args[i].name))\n\t    {\n\t      if (long_args[i].type == Int)\n\t\t*long_args[i].int_value = 1;\n\t      else if (argv[++arg_index] == 0)\n\t\t{\n\t\t  report_error (_(\"%s: option requires an argument\"), long_args[i].name);\n\t\t  exit (EX_BADUSAGE);\n\t\t}\n\t      else\n\t\t*long_args[i].char_value = argv[arg_index];\n\n\t      break;\n\t    }\n\t}\n      if (long_args[i].name == 0)\n\t{\n\t  if (longarg)\n\t    {\n\t      report_error (_(\"%s: invalid option\"), argv[arg_index]);\n\t      show_shell_usage (stderr, 0);\n\t      exit (EX_BADUSAGE);\n\t    }\n\t  break;\t\t \n\t}\n\n      arg_index++;\n    }\n\n  return (arg_index);\n}\n\nstatic int\nparse_shell_options (argv, arg_start, arg_end)\n     char **argv;\n     int arg_start, arg_end;\n{\n  int arg_index;\n  int arg_character, on_or_off, next_arg, i;\n  char *o_option, *arg_string;\n\n  arg_index = arg_start;\n  while (arg_index != arg_end && (arg_string = argv[arg_index]) &&\n\t (*arg_string == '-' || *arg_string == '+'))\n    {\n       \n      next_arg = arg_index + 1;\n\n       \n      if (arg_string[0] == '-' &&\n\t   (arg_string[1] == '\\0' ||\n\t     (arg_string[1] == '-' && arg_string[2] == '\\0')))\n\treturn (next_arg);\n\n      i = 1;\n      on_or_off = arg_string[0];\n      while (arg_character = arg_string[i++])\n\t{\n\t  switch (arg_character)\n\t    {\n\t    case 'c':\n\t      want_pending_command = 1;\n\t      break;\n\n\t    case 'l':\n\t      make_login_shell = 1;\n\t      break;\n\n\t    case 's':\n\t      read_from_stdin = 1;\n\t      break;\n\n\t    case 'o':\n\t      o_option = argv[next_arg];\n\t      if (o_option == 0)\n\t\t{\n\t\t  set_option_defaults ();\n\t\t  list_minus_o_opts (-1, (on_or_off == '-') ? 0 : 1);\n\t\t  reset_option_defaults ();\n\t\t  break;\n\t\t}\n\t      if (set_minus_o_option (on_or_off, o_option) != EXECUTION_SUCCESS)\n\t\texit (EX_BADUSAGE);\n\t      next_arg++;\n\t      break;\n\n\t    case 'O':\n\t       \n\t      o_option = argv[next_arg];\n\t      if (o_option == 0)\n\t\t{\n\t\t  shopt_listopt (o_option, (on_or_off == '-') ? 0 : 1);\n\t\t  break;\n\t\t}\n\t      add_shopt_to_alist (o_option, on_or_off);\n\t      next_arg++;\n\t      break;\n\n\t    case 'D':\n#if defined (TRANSLATABLE_STRINGS)\n\t      dump_translatable_strings = 1;\n#endif\n\t      break;\n\n\t    default:\n\t      if (change_flag (arg_character, on_or_off) == FLAG_ERROR)\n\t\t{\n\t\t  report_error (_(\"%c%c: invalid option\"), on_or_off, arg_character);\n\t\t  show_shell_usage (stderr, 0);\n\t\t  exit (EX_BADUSAGE);\n\t\t}\n\t    }\n\t}\n       \n      arg_index = next_arg;\n    }\n\n  return (arg_index);\n}\n\n \nvoid\nexit_shell (s)\n     int s;\n{\n  fflush (stdout);\t\t \n  fflush (stderr);\n\n   \n#if defined (READLINE)\n  if (RL_ISSTATE (RL_STATE_TERMPREPPED) && rl_deprep_term_function)\n    (*rl_deprep_term_function) ();\n#endif\n  if (read_tty_modified ())\n    read_tty_cleanup ();\n\n   \n  if (signal_is_trapped (0))\n    s = run_exit_trap ();\n\n#if defined (PROCESS_SUBSTITUTION)\n  unlink_all_fifos ();\n#endif  \n\n#if defined (HISTORY)\n  if (remember_on_history)\n    maybe_save_shell_history ();\n#endif  \n\n#if defined (COPROCESS_SUPPORT)\n  coproc_flush ();\n#endif\n\n#if defined (JOB_CONTROL)\n   \n  if (interactive_shell && login_shell && hup_on_exit)\n    hangup_all_jobs ();\n\n   \n  if (subshell_environment == 0)\n    end_job_control ();\n#endif  \n\n   \n  sh_exit (s);\n}\n\n \nvoid\nsh_exit (s)\n     int s;\n{\n#if defined (MALLOC_DEBUG) && defined (USING_BASH_MALLOC)\n  if (malloc_trace_at_exit && (subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PROCSUB)) == 0)\n    trace_malloc_stats (get_name_for_error (), (char *)NULL);\n   \n#endif\n\n  exit (s);\n}\n\n \nvoid\nsubshell_exit (s)\n     int s;\n{\n  fflush (stdout);\n  fflush (stderr);\n\n   \n  last_command_exit_value = s;\n  if (signal_is_trapped (0))\n    s = run_exit_trap ();\n\n  sh_exit (s);\n}\n\nvoid\nset_exit_status (s)\n     int s;\n{\n  set_pipestatus_from_exit (last_command_exit_value = s);\n}\n\n \n\n \n\nstatic void\nexecute_env_file (env_file)\n      char *env_file;\n{\n  char *fn;\n\n  if (env_file && *env_file)\n    {\n      fn = expand_string_unsplit_to_string (env_file, Q_DOUBLE_QUOTES);\n      if (fn && *fn)\n\tmaybe_execute_file (fn, 1);\n      FREE (fn);\n    }\n}\n\nstatic void\nrun_startup_files ()\n{\n#if defined (JOB_CONTROL)\n  int old_job_control;\n#endif\n  int sourced_login, run_by_ssh;\n\n#if 1\t \n   \n  if (interactive_shell == 0 && no_rc == 0 && login_shell == 0 &&\n      act_like_sh == 0 && command_execution_string)\n    {\n#ifdef SSH_SOURCE_BASHRC\n      run_by_ssh = (find_variable (\"SSH_CLIENT\") != (SHELL_VAR *)0) ||\n\t\t   (find_variable (\"SSH2_CLIENT\") != (SHELL_VAR *)0);\n#else\n      run_by_ssh = 0;\n#endif\n#endif\n\n       \n#if 1\t \n      if ((run_by_ssh || isnetconn (fileno (stdin))) && shell_level < 2)\n#else\n      if (isnetconn (fileno (stdin) && shell_level < 2)\n#endif\n\t{\n#ifdef SYS_BASHRC\n#  if defined (__OPENNT)\n\t  maybe_execute_file (_prefixInstallPath(SYS_BASHRC, NULL, 0), 1);\n#  else\n\t  maybe_execute_file (SYS_BASHRC, 1);\n#  endif\n#endif\n\t  maybe_execute_file (bashrc_file, 1);\n\t  return;\n\t}\n    }\n\n#if defined (JOB_CONTROL)\n   \n  old_job_control = interactive_shell ? set_job_control (0) : 0;\n#endif\n\n  sourced_login = 0;\n\n   \n#if defined (NON_INTERACTIVE_LOGIN_SHELLS)\n  if (login_shell && posixly_correct == 0)\n#else\n  if (login_shell < 0 && posixly_correct == 0)\n#endif\n    {\n       \n      no_rc++;\n\n       \n      if (no_profile == 0)\n\t{\n\t  maybe_execute_file (SYS_PROFILE, 1);\n\n\t  if (act_like_sh)\t \n\t    maybe_execute_file (\"~/.profile\", 1);\n\t  else if ((maybe_execute_file (\"~/.bash_profile\", 1) == 0) &&\n\t\t   (maybe_execute_file (\"~/.bash_login\", 1) == 0))\t \n\t    maybe_execute_file (\"~/.profile\", 1);\n\t}\n\n      sourced_login = 1;\n    }\n\n   \n  if (interactive_shell == 0 && !(su_shell && login_shell))\n    {\n      if (posixly_correct == 0 && act_like_sh == 0 && privileged_mode == 0 &&\n\t    sourced_env++ == 0)\n\texecute_env_file (get_string_value (\"BASH_ENV\"));\n      return;\n    }\n\n   \n  if (posixly_correct == 0)\t\t   \n    {\n      if (login_shell && sourced_login++ == 0)\n\t{\n\t   \n\t  no_rc++;\n\n\t   \n\t  if (no_profile == 0)\n\t    {\n\t      maybe_execute_file (SYS_PROFILE, 1);\n\n\t      if (act_like_sh)\t \n\t\tmaybe_execute_file (\"~/.profile\", 1);\n\t      else if ((maybe_execute_file (\"~/.bash_profile\", 1) == 0) &&\n\t\t       (maybe_execute_file (\"~/.bash_login\", 1) == 0))\t \n\t\tmaybe_execute_file (\"~/.profile\", 1);\n\t    }\n\t}\n\n       \n      if (act_like_sh == 0 && no_rc == 0)\n\t{\n#ifdef SYS_BASHRC\n#  if defined (__OPENNT)\n\t  maybe_execute_file (_prefixInstallPath(SYS_BASHRC, NULL, 0), 1);\n#  else\n\t  maybe_execute_file (SYS_BASHRC, 1);\n#  endif\n#endif\n\t  maybe_execute_file (bashrc_file, 1);\n\t}\n       \n      else if (act_like_sh && privileged_mode == 0 && sourced_env++ == 0)\n\texecute_env_file (get_string_value (\"ENV\"));\n    }\n  else\t\t \n    {\n       \n      if (interactive_shell && privileged_mode == 0 && sourced_env++ == 0)\n\texecute_env_file (get_string_value (\"ENV\"));\n    }\n\n#if defined (JOB_CONTROL)\n  set_job_control (old_job_control);\n#endif\n}\n\n#if defined (RESTRICTED_SHELL)\n \nint\nshell_is_restricted (name)\n     char *name;\n{\n  char *temp;\n\n  if (restricted)\n    return 1;\n  temp = base_pathname (name);\n  if (*temp == '-')\n    temp++;\n  return (STREQ (temp, RESTRICTED_SHELL_NAME));\n}\n\n \nint\nmaybe_make_restricted (name)\n     char *name;\n{\n  char *temp;\n\n  temp = base_pathname (name);\n  if (*temp == '-')\n    temp++;\n  if (restricted || (STREQ (temp, RESTRICTED_SHELL_NAME)))\n    {\n#if defined (RBASH_STATIC_PATH_VALUE)\n      bind_variable (\"PATH\", RBASH_STATIC_PATH_VALUE, 0);\n      stupidly_hack_special_variables (\"PATH\");\t\t \n#endif\n      set_var_read_only (\"PATH\");\n      set_var_read_only (\"SHELL\");\n      set_var_read_only (\"ENV\");\n      set_var_read_only (\"BASH_ENV\");\n      set_var_read_only (\"HISTFILE\");\n      restricted = 1;\n    }\n  return (restricted);\n}\n#endif  \n\n \nstatic int\nuidget ()\n{\n  uid_t u;\n\n  u = getuid ();\n  if (current_user.uid != u)\n    {\n      FREE (current_user.user_name);\n      FREE (current_user.shell);\n      FREE (current_user.home_dir);\n      current_user.user_name = current_user.shell = current_user.home_dir = (char *)NULL;\n    }\n  current_user.uid = u;\n  current_user.gid = getgid ();\n  current_user.euid = geteuid ();\n  current_user.egid = getegid ();\n\n   \n  return (current_user.uid != current_user.euid) ||\n\t   (current_user.gid != current_user.egid);\n}\n\nvoid\ndisable_priv_mode ()\n{\n  int e;\n\n#if HAVE_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}\n\n#if defined (WORDEXP_OPTION)\nstatic int\nrun_wordexp (words)\n     char *words;\n{\n  int code, nw, nb;\n  WORD_LIST *wl, *tl, *result;\n\n  code = setjmp_nosigs (top_level);\n\n  if (code != NOT_JUMPED)\n    {\n      switch (code)\n\t{\n\t   \n\tcase FORCE_EOF:\n\t  return last_command_exit_value = 127;\n\tcase ERREXIT:\n\tcase EXITPROG:\n\tcase EXITBLTIN:\n\t  return last_command_exit_value;\n\tcase DISCARD:\n\t  return last_command_exit_value = 1;\n\tdefault:\n\t  command_error (\"run_wordexp\", CMDERR_BADJUMP, code, 0);\n\t}\n    }\n\n   \n  if (words && *words)\n    {\n      with_input_from_string (words, \"--wordexp\");\n      if (parse_command () != 0)\n\treturn (126);\n      if (global_command == 0)\n\t{\n\t  printf (\"0\\n0\\n\");\n\t  return (0);\n\t}\n      if (global_command->type != cm_simple)\n\treturn (126);\n      wl = global_command->value.Simple->words;\n      if (protected_mode)\n\tfor (tl = wl; tl; tl = tl->next)\n\t  tl->word->flags |= W_NOCOMSUB|W_NOPROCSUB;\n      result = wl ? expand_words_no_vars (wl) : (WORD_LIST *)0;\n    }\n  else\n    result = (WORD_LIST *)0;\n\n  last_command_exit_value = 0;\n\n  if (result == 0)\n    {\n      printf (\"0\\n0\\n\");\n      return (0);\n    }\n\n   \n  for (nw = nb = 0, wl = result; wl; wl = wl->next)\n    {\n      nw++;\n      nb += strlen (wl->word->word);\n    }\n  printf (\"%u\\n%u\\n\", nw, nb);\n   \n  for (wl = result; wl; wl = wl->next)\n    printf (\"%s\\n\", wl->word->word);\n\n  return (0);\n}\n#endif\n\n#if defined (ONESHOT)\n \nstatic int\nrun_one_command (command)\n     char *command;\n{\n  int code;\n\n  code = setjmp_nosigs (top_level);\n\n  if (code != NOT_JUMPED)\n    {\n#if defined (PROCESS_SUBSTITUTION)\n      unlink_fifo_list ();\n#endif  \n      switch (code)\n\t{\n\t   \n\tcase FORCE_EOF:\n\t  return last_command_exit_value = 127;\n\tcase ERREXIT:\n\tcase EXITPROG:\n\tcase EXITBLTIN:\n\t  return last_command_exit_value;\n\tcase DISCARD:\n\t  return last_command_exit_value = 1;\n\tdefault:\n\t  command_error (\"run_one_command\", CMDERR_BADJUMP, code, 0);\n\t}\n    }\n   return (parse_and_execute (savestring (command), \"-c\", SEVAL_NOHIST|SEVAL_RESETLINE));\n}\n#endif  \n\nstatic int\nbind_args (argv, arg_start, arg_end, start_index)\n     char **argv;\n     int arg_start, arg_end, start_index;\n{\n  register int i;\n  WORD_LIST *args, *tl;\n\n  for (i = arg_start, args = tl = (WORD_LIST *)NULL; i < arg_end; i++)\n    {\n      if (args == 0)\n\targs = tl = make_word_list (make_word (argv[i]), args);\n      else\n\t{\n\t  tl->next = make_word_list (make_word (argv[i]), (WORD_LIST *)NULL);\n\t  tl = tl->next;\n\t}\n    }\n\n  if (args)\n    {\n      if (start_index == 0)\t \n\t{\n\t   \n\t  shell_name = savestring (args->word->word);\n\t  FREE (dollar_vars[0]);\n\t  dollar_vars[0] = savestring (args->word->word);\n\t  remember_args (args->next, 1);\n\t  if (debugging_mode)\n\t    {\n\t      push_args (args->next);\t \n\t      bash_argv_initialized = 1;\n\t    }\n\t}\n      else\t\t\t \n        {\n\t  remember_args (args, 1);\n\t   \n\t  if (debugging_mode)\n\t    {\n\t      push_args (args);\t\t \n\t      bash_argv_initialized = 1;\n\t    }\n        }\n\n      dispose_words (args);\n    }\n\n  return (i);\n}\n\nvoid\nunbind_args ()\n{\n  remember_args ((WORD_LIST *)NULL, 1);\n  pop_args ();\t\t\t\t \n}\n\nstatic void\nstart_debugger ()\n{\n#if defined (DEBUGGER) && defined (DEBUGGER_START_FILE)\n  int old_errexit;\n  int r;\n\n  old_errexit = exit_immediately_on_error;\n  exit_immediately_on_error = 0;\n\n  r = force_execute_file (DEBUGGER_START_FILE, 1);\n  if (r < 0)\n    {\n      internal_warning (_(\"cannot start debugger; debugging mode disabled\"));\n      debugging_mode = 0;\n    }\n  error_trace_mode = function_trace_mode = debugging_mode;\n\n  set_shellopts ();\n  set_bashopts ();\n\n  exit_immediately_on_error += old_errexit;\n#endif\n}\n\nstatic int\nopen_shell_script (script_name)\n     char *script_name;\n{\n  int fd, e, fd_is_tty;\n  char *filename, *path_filename, *t;\n  char sample[80];\n  int sample_len;\n  struct stat sb;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;\n  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;\n#endif\n\n  filename = savestring (script_name);\n\n  fd = open (filename, O_RDONLY);\n  if ((fd < 0) && (errno == ENOENT) && (absolute_program (filename) == 0))\n    {\n      e = errno;\n       \n      path_filename = find_path_file (script_name);\n      if (path_filename)\n\t{\n\t  free (filename);\n\t  filename = path_filename;\n\t  fd = open (filename, O_RDONLY);\n\t}\n      else\n\terrno = e;\n    }\n\n  if (fd < 0)\n    {\n      e = errno;\n      file_error (filename);\n#if defined (JOB_CONTROL)\n      end_job_control ();\t \n#endif\n      sh_exit ((e == ENOENT) ? EX_NOTFOUND : EX_NOINPUT);\n    }\n\n  free (dollar_vars[0]);\n  dollar_vars[0] = exec_argv0 ? savestring (exec_argv0) : savestring (script_name);\n  if (exec_argv0)\n    {\n      free (exec_argv0);\n      exec_argv0 = (char *)NULL;\n    }\n\n  if (file_isdir (filename))\n    {\n#if defined (EISDIR)\n      errno = EISDIR;\n#else\n      errno = EINVAL;\n#endif\n      file_error (filename);\n#if defined (JOB_CONTROL)\n      end_job_control ();\t \n#endif\n      sh_exit (EX_NOINPUT);\n    }\n\n#if defined (ARRAY_VARS)\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", funcname_v, funcname_a);\n  GET_ARRAY_FROM_VAR (\"BASH_SOURCE\", bash_source_v, bash_source_a);\n  GET_ARRAY_FROM_VAR (\"BASH_LINENO\", bash_lineno_v, bash_lineno_a);\n\n  array_push (bash_source_a, filename);\n  if (bash_lineno_a)\n    {\n      t = itos (executing_line_number ());\n      array_push (bash_lineno_a, t);\n      free (t);\n    }\n  array_push (funcname_a, \"main\");\n#endif\n\n#ifdef HAVE_DEV_FD\n  fd_is_tty = isatty (fd);\n#else\n  fd_is_tty = 0;\n#endif\n\n   \n  if (fd_is_tty == 0 && (lseek (fd, 0L, 1) != -1))\n    {\n       \n      sample_len = read (fd, sample, sizeof (sample));\n      if (sample_len < 0)\n\t{\n\t  e = errno;\n\t  if ((fstat (fd, &sb) == 0) && S_ISDIR (sb.st_mode))\n\t    {\n#if defined (EISDIR)\n\t      errno = EISDIR;\n\t      file_error (filename);\n#else\t      \n\t      internal_error (_(\"%s: Is a directory\"), filename);\n#endif\n\t    }\n\t  else\n\t    {\n\t      errno = e;\n\t      file_error (filename);\n\t    }\n#if defined (JOB_CONTROL)\n\t  end_job_control ();\t \n#endif\n\t  exit (EX_NOEXEC);\n\t}\n      else if (sample_len > 0 && (check_binary_file (sample, sample_len)))\n\t{\n\t  internal_error (_(\"%s: cannot execute binary file\"), filename);\n#if defined (JOB_CONTROL)\n\t  end_job_control ();\t \n#endif\n\t  exit (EX_BINARY_FILE);\n\t}\n       \n      lseek (fd, 0L, 0);\n    }\n\n   \n  fd = move_to_high_fd (fd, 1, -1);\n\n#if defined (BUFFERED_INPUT)\n  default_buffered_input = fd;\n  SET_CLOSE_ON_EXEC (default_buffered_input);\n#else  \n  default_input = fdopen (fd, \"r\");\n\n  if (default_input == 0)\n    {\n      file_error (filename);\n      exit (EX_NOTFOUND);\n    }\n\n  SET_CLOSE_ON_EXEC (fd);\n  if (fileno (default_input) != fd)\n    SET_CLOSE_ON_EXEC (fileno (default_input));\n#endif  \n\n   \n  if (interactive_shell && fd_is_tty)\n    {\n      dup2 (fd, 0);\n      close (fd);\n      fd = 0;\n#if defined (BUFFERED_INPUT)\n      default_buffered_input = 0;\n#else\n      fclose (default_input);\n      default_input = stdin;\n#endif\n    }\n  else if (forced_interactive && fd_is_tty == 0)\n     \n    init_interactive_script ();\n\n  free (filename);\n\n  reading_shell_script = 1;\n  return (fd);\n}\n\n \nstatic void\nset_bash_input ()\n{\n   \n#if defined (BUFFERED_INPUT)\n  if (interactive == 0)\n    sh_unset_nodelay_mode (default_buffered_input);\n  else\n#endif  \n    sh_unset_nodelay_mode (fileno (stdin));\n\n   \n  if (interactive && no_line_editing == 0)\n    with_input_from_stdin ();\n#if defined (BUFFERED_INPUT)\n  else if (interactive == 0)\n    with_input_from_buffered_stream (default_buffered_input, dollar_vars[0]);\n#endif  \n  else\n    with_input_from_stream (default_input, dollar_vars[0]);\n}\n\n \nvoid\nunset_bash_input (check_zero)\n     int check_zero;\n{\n#if defined (BUFFERED_INPUT)\n  if ((check_zero && default_buffered_input >= 0) ||\n      (check_zero == 0 && default_buffered_input > 0))\n    {\n      close_buffered_fd (default_buffered_input);\n      default_buffered_input = bash_input.location.buffered_fd = -1;\n      bash_input.type = st_none;\t\t \n    }\n#else  \n  if (default_input)\n    {\n      fclose (default_input);\n      default_input = (FILE *)NULL;\n    }\n#endif  \n}\n      \n\n#if !defined (PROGRAM)\n#  define PROGRAM \"bash\"\n#endif\n\nstatic void\nset_shell_name (argv0)\n     char *argv0;\n{\n   \n  shell_name = argv0 ? base_pathname (argv0) : PROGRAM;\n\n  if (argv0 && *argv0 == '-')\n    {\n      if (*shell_name == '-')\n\tshell_name++;\n      login_shell = 1;\n    }\n\n  if (shell_name[0] == 's' && shell_name[1] == 'h' && shell_name[2] == '\\0')\n    act_like_sh++;\n  if (shell_name[0] == 's' && shell_name[1] == 'u' && shell_name[2] == '\\0')\n    su_shell++;\n\n  shell_name = argv0 ? argv0 : PROGRAM;\n  FREE (dollar_vars[0]);\n  dollar_vars[0] = savestring (shell_name);\n\n   \n  if (!shell_name || !*shell_name || (shell_name[0] == '-' && !shell_name[1]))\n    shell_name = PROGRAM;\n}\n\n \n \nstatic void\nset_option_defaults ()\n{\n#if defined (HISTORY)\n  enable_history_list = 0;\n#endif\n}\n\nstatic void\nreset_option_defaults ()\n{\n#if defined (HISTORY)\n  enable_history_list = -1;\n#endif\n}\n\nstatic void\ninit_interactive ()\n{\n  expand_aliases = expaliases_flag = 1;\n  interactive_shell = startup_state = interactive = 1;\n#if defined (HISTORY)\n  if (enable_history_list == -1)\n    enable_history_list = 1;\t\t\t\t \n  remember_on_history = enable_history_list;\n#  if defined (BANG_HISTORY)\n  histexp_flag = history_expansion;\t\t\t \n#  endif\n#endif\n}\n\nstatic void\ninit_noninteractive ()\n{\n#if defined (HISTORY)\n  if (enable_history_list == -1)\t\t\t \n    enable_history_list = 0;\n  bash_history_reinit (0);\n#endif  \n  interactive_shell = startup_state = interactive = 0;\n  expand_aliases = expaliases_flag = posixly_correct;\t \n  no_line_editing = 1;\n#if defined (JOB_CONTROL)\n   \n  set_job_control (forced_interactive||jobs_m_flag);\n#endif  \n}\n\nstatic void\ninit_interactive_script ()\n{\n#if defined (HISTORY)\n  if (enable_history_list == -1)\n    enable_history_list = 1;\n#endif\n  init_noninteractive ();\n  expand_aliases = expaliases_flag = interactive_shell = startup_state = 1;\n#if defined (HISTORY)\n  remember_on_history = enable_history_list;\t \n#endif\n}\n\nvoid\nget_current_user_info ()\n{\n  struct passwd *entry;\n\n   \n  if (current_user.user_name == 0)\n    {\n#if defined (__TANDEM)\n      entry = getpwnam (getlogin ());\n#else\n      entry = getpwuid (current_user.uid);\n#endif\n      if (entry)\n\t{\n\t  current_user.user_name = savestring (entry->pw_name);\n\t  current_user.shell = (entry->pw_shell && entry->pw_shell[0])\n\t\t\t\t? savestring (entry->pw_shell)\n\t\t\t\t: savestring (\"/bin/sh\");\n\t  current_user.home_dir = savestring (entry->pw_dir);\n\t}\n      else\n\t{\n\t  current_user.user_name = _(\"I have no name!\");\n\t  current_user.user_name = savestring (current_user.user_name);\n\t  current_user.shell = savestring (\"/bin/sh\");\n\t  current_user.home_dir = savestring (\"/\");\n\t}\n#if defined (HAVE_GETPWENT)\n      endpwent ();\n#endif\n    }\n}\n\n \nstatic void\nshell_initialize ()\n{\n  char hostname[256];\n  int should_be_restricted;\n\n   \n  if (shell_initialized == 0)\n    {\n      sh_setlinebuf (stderr);\n      sh_setlinebuf (stdout);\n    }\n\n   \n  initialize_shell_builtins ();\n\n   \n  initialize_traps ();\n  initialize_signals (0);\n\n   \n  if (current_host_name == 0)\n    {\n       \n      if (gethostname (hostname, 255) < 0)\n\tcurrent_host_name = \"??host??\";\n      else\n\tcurrent_host_name = savestring (hostname);\n    }\n\n   \n  if (interactive_shell)\n    get_current_user_info ();\n\n   \n  tilde_initialize ();\n\n#if defined (RESTRICTED_SHELL)\n  should_be_restricted = shell_is_restricted (shell_name);\n#endif\n\n   \n#if defined (RESTRICTED_SHELL)\n  initialize_shell_variables (shell_environment, privileged_mode||restricted||should_be_restricted||running_setuid);\n#else\n  initialize_shell_variables (shell_environment, privileged_mode||running_setuid);\n#endif\n\n   \n  initialize_job_control (jobs_m_flag);\n\n   \n  initialize_bash_input ();\n\n  initialize_flags ();\n\n   \n#if defined (RESTRICTED_SHELL)\n  initialize_shell_options (privileged_mode||restricted||should_be_restricted||running_setuid);\n  initialize_bashopts (privileged_mode||restricted||should_be_restricted||running_setuid);\n#else\n  initialize_shell_options (privileged_mode||running_setuid);\n  initialize_bashopts (privileged_mode||running_setuid);\n#endif\n}\n\n \nstatic void\nshell_reinitialize ()\n{\n   \n  primary_prompt = PPROMPT;\n  secondary_prompt = SPROMPT;\n\n   \n  current_command_number = 1;\n\n   \n  no_rc = no_profile = 1;\n\n   \n  login_shell = make_login_shell = interactive = executing = 0;\n  debugging = do_version = line_number = last_command_exit_value = 0;\n  forced_interactive = interactive_shell = 0;\n  subshell_environment = running_in_background = 0;\n  expand_aliases = expaliases_flag = 0;\n  bash_argv_initialized = 0;\n\n   \n\n#if defined (HISTORY)\n  bash_history_reinit (enable_history_list = 0);\n#endif  \n\n#if defined (RESTRICTED_SHELL)\n  restricted = 0;\n#endif  \n\n   \n  bashrc_file = DEFAULT_BASHRC;\n\n   \n  delete_all_contexts (shell_variables);\n  delete_all_variables (shell_functions);\n\n  reinit_special_variables ();\n\n#if defined (READLINE)\n  bashline_reinitialize ();\n#endif\n\n  shell_reinitialized = 1;\n}\n\nstatic void\nshow_shell_usage (fp, extra)\n     FILE *fp;\n     int extra;\n{\n  int i;\n  char *set_opts, *s, *t;\n\n  if (extra)\n    fprintf (fp, _(\"GNU bash, version %s-(%s)\\n\"), shell_version_string (), MACHTYPE);\n  fprintf (fp, _(\"Usage:\\t%s [GNU long option] [option] ...\\n\\t%s [GNU long option] [option] script-file ...\\n\"),\n\t     shell_name, shell_name);\n  fputs (_(\"GNU long options:\\n\"), fp);\n  for (i = 0; long_args[i].name; i++)\n    fprintf (fp, \"\\t--%s\\n\", long_args[i].name);\n\n  fputs (_(\"Shell options:\\n\"), fp);\n  fputs (_(\"\\t-ilrsD or -c command or -O shopt_option\\t\\t(invocation only)\\n\"), fp);\n\n  for (i = 0, set_opts = 0; shell_builtins[i].name; i++)\n    if (STREQ (shell_builtins[i].name, \"set\"))\n      {\n\tset_opts = savestring (shell_builtins[i].short_doc);\n\tbreak;\n      }\n\n  if (set_opts)\n    {\n      s = strchr (set_opts, '[');\n      if (s == 0)\n\ts = set_opts;\n      while (*++s == '-')\n\t;\n      t = strchr (s, ']');\n      if (t)\n\t*t = '\\0';\n      fprintf (fp, _(\"\\t-%s or -o option\\n\"), s);\n      free (set_opts);\n    }\n\n  if (extra)\n    {\n      fprintf (fp, _(\"Type `%s -c \\\"help set\\\"' for more information about shell options.\\n\"), shell_name);\n      fprintf (fp, _(\"Type `%s -c help' for more information about shell builtin commands.\\n\"), shell_name);\n      fprintf (fp, _(\"Use the `bashbug' command to report bugs.\\n\"));\n      fprintf (fp, \"\\n\");\n      fprintf (fp, _(\"bash home page: <http://www.gnu.org/software/bash>\\n\"));\n      fprintf (fp, _(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"));\n    }\n}\n\nstatic void\nadd_shopt_to_alist (opt, on_or_off)\n     char *opt;\n     int on_or_off;\n{\n  if (shopt_ind >= shopt_len)\n    {\n      shopt_len += 8;\n      shopt_alist = (STRING_INT_ALIST *)xrealloc (shopt_alist, shopt_len * sizeof (shopt_alist[0]));\n    }\n  shopt_alist[shopt_ind].word = opt;\n  shopt_alist[shopt_ind].token = on_or_off;\n  shopt_ind++;\n}\n\nstatic void\nrun_shopt_alist ()\n{\n  register int i;\n\n  for (i = 0; i < shopt_ind; i++)\n    if (shopt_setopt (shopt_alist[i].word, (shopt_alist[i].token == '-')) != EXECUTION_SUCCESS)\n      exit (EX_BADUSAGE);\n  free (shopt_alist);\n  shopt_alist = 0;\n  shopt_ind = shopt_len = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}