{
  "module_name": "jobs.h",
  "hash_id": "73f6a0aa7876c72e9ef5781a111a2826c951b220f58ca79f0168042c731fa14a",
  "original_prompt": "Ingested from bash-5.2.21/jobs.h",
  "human_readable_source": " \n\n \n\n#if !defined (_JOBS_H_)\n#  define _JOBS_H_\n\n#include \"quit.h\"\n#include \"siglist.h\"\n\n#include \"stdc.h\"\n\n#include \"posixwait.h\"\n\n \n#define JLIST_STANDARD       0\n#define JLIST_LONG\t     1\n#define JLIST_PID_ONLY\t     2\n#define JLIST_CHANGED_ONLY   3\n#define JLIST_NONINTERACTIVE 4\n\n \n#define LONGEST_SIGNAL_DESC 24\n\n \n#define JWAIT_PERROR\t\t(1 << 0)\n#define JWAIT_FORCE\t\t(1 << 1)\n#define JWAIT_NOWAIT\t\t(1 << 2)  \n#define JWAIT_WAITING\t\t(1 << 3)  \n\n \n#define JWAIT_NOTERM\t\t(1 << 8)  \n\n \n#define FORKSLEEP_MAX\t16\n\n \n\n \n#define PS_DONE\t\t0\n#define PS_RUNNING\t1\n#define PS_STOPPED\t2\n#define PS_RECYCLED\t4\n\n \ntypedef struct process {\n  struct process *next;\t \n  pid_t pid;\t\t \n  WAIT status;\t\t \n  int running;\t\t \n  char *command;\t \n} PROCESS;\n\nstruct pipeline_saver {\n  struct process *pipeline;\n  struct pipeline_saver *next;\n};\n\n \n#define PSTOPPED(p)\t(WIFSTOPPED((p)->status))\n#define PRUNNING(p)\t((p)->running == PS_RUNNING)\n#define PALIVE(p)\t(PRUNNING(p) || PSTOPPED(p))\n\n#define PEXITED(p)\t((p)->running == PS_DONE)\n#if defined (RECYCLES_PIDS)\n#  define PRECYCLED(p)\t((p)->running == PS_RECYCLED)\n#else\n#  define PRECYCLED(p)\t(0)\n#endif\n#define PDEADPROC(p)\t(PEXITED(p) || PRECYCLED(p))\n\n#define get_job_by_jid(ind)\t(jobs[(ind)])\n\n \ntypedef enum { JNONE = -1, JRUNNING = 1, JSTOPPED = 2, JDEAD = 4, JMIXED = 8 } JOB_STATE;\n#define JOBSTATE(job)\t(jobs[(job)]->state)\n#define J_JOBSTATE(j)\t((j)->state)\n\n#define STOPPED(j)\t(jobs[(j)]->state == JSTOPPED)\n#define RUNNING(j)\t(jobs[(j)]->state == JRUNNING)\n#define DEADJOB(j)\t(jobs[(j)]->state == JDEAD)\n\n#define INVALID_JOB(j)\t((j) < 0 || (j) >= js.j_jobslots || get_job_by_jid(j) == 0)\n\n \n#define J_FOREGROUND 0x01  \n#define J_NOTIFIED   0x02  \n#define J_JOBCONTROL 0x04  \n#define J_NOHUP      0x08  \n#define J_STATSAVED  0x10  \n#define J_ASYNC\t     0x20  \n#define J_PIPEFAIL   0x40  \n#define J_WAITING    0x80  \n\n#define IS_FOREGROUND(j)\t((jobs[j]->flags & J_FOREGROUND) != 0)\n#define IS_NOTIFIED(j)\t\t((jobs[j]->flags & J_NOTIFIED) != 0)\n#define IS_JOBCONTROL(j)\t((jobs[j]->flags & J_JOBCONTROL) != 0)\n#define IS_ASYNC(j)\t\t((jobs[j]->flags & J_ASYNC) != 0)\n#define IS_WAITING(j)\t\t((jobs[j]->flags & J_WAITING) != 0)\n\ntypedef struct job {\n  char *wd;\t    \n  PROCESS *pipe;    \n  pid_t pgrp;\t    \n  JOB_STATE state;  \n  int flags;\t    \n#if defined (JOB_CONTROL)\n  COMMAND *deferred;\t \n  sh_vptrfunc_t *j_cleanup;  \n  PTR_T cleanarg;\t \n#endif  \n} JOB;\n\nstruct jobstats {\n   \n  long c_childmax;\n   \n  int c_living;\t\t \n  int c_reaped;\t\t \n  int c_injobs;\t\t \n   \n  int c_totforked;\t \n  int c_totreaped;\t \n   \n  int j_jobslots;\t \n  int j_lastj;\t\t \n  int j_firstj;\t\t \n  int j_njobs;\t\t \n  int j_ndead;\t\t \n   \n  int j_current;\t \n  int j_previous;\t \n   \n  JOB *j_lastmade;\t \n  JOB *j_lastasync;\t \n};\n\n \ntypedef pid_t ps_index_t;\n\nstruct pidstat {\n  ps_index_t bucket_next;\n  ps_index_t bucket_prev;\n\n  pid_t pid;\n  bits16_t status;\t\t \n};\n\nstruct bgpids {\n  struct pidstat *storage;\t \n\n  ps_index_t head;\n  ps_index_t nalloc;\n\n  int npid;\n};\n\n#define NO_PIDSTAT (ps_index_t)-1\n\n \nstruct procstat {\n  pid_t pid;\n  bits16_t status;\n};\n\n \nstruct procchain {\n  PROCESS *head;\n  PROCESS *end;\n  int nproc;\n};\n\n#define NO_JOB  -1\t \n#define DUP_JOB -2\t \n#define BAD_JOBSPEC -3\t \n\n \n#define NO_PID (pid_t)-1\n\n#define ANY_PID (pid_t)-1\n\n \n#define FORK_SYNC\t0\t\t \n#define FORK_ASYNC\t1\t\t \n#define FORK_NOJOB\t2\t\t \n#define FORK_NOTERM\t4\t\t \n\n \n#if !defined (HAVE_UNISTD_H)\nextern pid_t fork (), getpid (), getpgrp ();\n#endif  \n\n \nextern struct jobstats js;\n\nextern pid_t original_pgrp, shell_pgrp, pipeline_pgrp;\nextern volatile pid_t last_made_pid, last_asynchronous_pid;\nextern int asynchronous_notification;\n\nextern int already_making_children;\nextern int running_in_background;\n\nextern PROCESS *last_procsub_child;\n\nextern JOB **jobs;\n\nextern void making_children PARAMS((void));\nextern void stop_making_children PARAMS((void));\nextern void cleanup_the_pipeline PARAMS((void));\nextern void discard_last_procsub_child PARAMS((void));\nextern void save_pipeline PARAMS((int));\nextern PROCESS *restore_pipeline PARAMS((int));\nextern void start_pipeline PARAMS((void));\nextern int stop_pipeline PARAMS((int, COMMAND *));\nextern int discard_pipeline PARAMS((PROCESS *));\nextern void append_process PARAMS((char *, pid_t, int, int));\n\nextern void save_proc_status PARAMS((pid_t, int));\n\nextern PROCESS *procsub_add PARAMS((PROCESS *));\nextern PROCESS *procsub_search PARAMS((pid_t));\nextern PROCESS *procsub_delete PARAMS((pid_t));\nextern int procsub_waitpid PARAMS((pid_t));\nextern void procsub_waitall PARAMS((void));\nextern void procsub_clear PARAMS((void));\nextern void procsub_prune PARAMS((void));\n\nextern void delete_job PARAMS((int, int));\nextern void nohup_job PARAMS((int));\nextern void delete_all_jobs PARAMS((int));\nextern void nohup_all_jobs PARAMS((int));\n\nextern int count_all_jobs PARAMS((void));\n\nextern void terminate_current_pipeline PARAMS((void));\nextern void terminate_stopped_jobs PARAMS((void));\nextern void hangup_all_jobs PARAMS((void));\nextern void kill_current_pipeline PARAMS((void));\n\n#if defined (__STDC__) && defined (pid_t)\nextern int get_job_by_pid PARAMS((int, int, PROCESS **));\nextern void describe_pid PARAMS((int));\n#else\nextern int get_job_by_pid PARAMS((pid_t, int, PROCESS **));\nextern void describe_pid PARAMS((pid_t));\n#endif\n\nextern void list_one_job PARAMS((JOB *, int, int, int));\nextern void list_all_jobs PARAMS((int));\nextern void list_stopped_jobs PARAMS((int));\nextern void list_running_jobs PARAMS((int));\n\nextern pid_t make_child PARAMS((char *, int));\n\nextern int get_tty_state PARAMS((void));\nextern int set_tty_state PARAMS((void));\n\nextern int job_exit_status PARAMS((int));\nextern int job_exit_signal PARAMS((int));\n\nextern int wait_for_single_pid PARAMS((pid_t, int));\nextern int wait_for_background_pids PARAMS((struct procstat *));\nextern int wait_for PARAMS((pid_t, int));\nextern int wait_for_job PARAMS((int, int, struct procstat *));\nextern int wait_for_any_job PARAMS((int, struct procstat *));\n\nextern void wait_sigint_cleanup PARAMS((void));\n\nextern void notify_and_cleanup PARAMS((void));\nextern void reap_dead_jobs PARAMS((void));\nextern int start_job PARAMS((int, int));\nextern int kill_pid PARAMS((pid_t, int, int));\nextern int initialize_job_control PARAMS((int));\nextern void initialize_job_signals PARAMS((void));\nextern int give_terminal_to PARAMS((pid_t, int));\n\nextern void run_sigchld_trap PARAMS((int));\n\nextern int freeze_jobs_list PARAMS((void));\nextern void unfreeze_jobs_list PARAMS((void));\nextern void set_jobs_list_frozen PARAMS((int));\nextern int set_job_control PARAMS((int));\nextern void without_job_control PARAMS((void));\nextern void end_job_control PARAMS((void));\nextern void restart_job_control PARAMS((void));\nextern void set_sigchld_handler PARAMS((void));\nextern void ignore_tty_job_signals PARAMS((void));\nextern void default_tty_job_signals PARAMS((void));\nextern void get_original_tty_job_signals PARAMS((void));\n\nextern void init_job_stats PARAMS((void));\n\nextern void close_pgrp_pipe PARAMS((void));\nextern void save_pgrp_pipe PARAMS((int *, int));\nextern void restore_pgrp_pipe PARAMS((int *));\n\nextern void set_maxchild PARAMS((int));\n\n#ifdef DEBUG\nextern void debug_print_pgrps (void);\n#endif\n\nextern int job_control;\t\t \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}