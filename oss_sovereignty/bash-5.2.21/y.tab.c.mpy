{
  "module_name": "y.tab.c",
  "hash_id": "981623c24fc98d5136c2dee60fb03a6773a9ccd2129fd1dd84bddc75b3fb754b",
  "original_prompt": "Ingested from bash-5.2.21/y.tab.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n \n\n \n#define YYBISON 30802\n\n \n#define YYBISON_VERSION \"3.8.2\"\n\n \n#define YYSKELETON_NAME \"yacc.c\"\n\n \n#define YYPURE 0\n\n \n#define YYPUSH 0\n\n \n#define YYPULL 1\n\n\n\n\n \n#line 21 \"/usr/local/src/chet/src/bash/src/parse.y\"\n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include \"bashansi.h\"\n\n#include \"filecntl.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_LOCALE_H)\n#  include <locale.h>\n#endif\n\n#include <stdio.h>\n#include \"chartypes.h\"\n#include <signal.h>\n\n#include \"memalloc.h\"\n\n#include \"bashintl.h\"\n\n#define NEED_STRFTIME_DECL\t \n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"typemax.h\"\t\t \n#include \"trap.h\"\n#include \"flags.h\"\n#include \"parser.h\"\n#include \"mailcheck.h\"\n#include \"test.h\"\n#include \"builtins.h\"\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\n\n#include \"shmbutil.h\"\n\n#if defined (READLINE)\n#  include \"bashline.h\"\n#  include <readline/readline.h>\n#endif  \n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#  include <readline/history.h>\n#endif  \n\n#if defined (JOB_CONTROL)\n#  include \"jobs.h\"\n#else\nextern int cleanup_dead_jobs PARAMS((void));\n#endif  \n\n#if defined (ALIAS)\n#  include \"alias.h\"\n#else\ntypedef void *alias_t;\n#endif  \n\n#if defined (PROMPT_STRING_DECODE)\n#  ifndef _MINIX\n#    include <sys/param.h>\n#  endif\n#  include <time.h>\n#  if defined (TM_IN_SYS_TIME)\n#    include <sys/types.h>\n#    include <sys/time.h>\n#  endif  \n#  include \"maxpath.h\"\n#endif  \n\n#define RE_READ_TOKEN\t-99\n#define NO_EXPANSION\t-100\n\n#define END_ALIAS\t-2\n\n#ifdef DEBUG\n#  define YYDEBUG 1\n#else\n#  define YYDEBUG 0\n#endif\n\n#if defined (HANDLE_MULTIBYTE)\n#  define last_shell_getc_is_singlebyte \\\n\t((shell_input_line_index > 1) \\\n\t\t? shell_input_line_property[shell_input_line_index - 1] \\\n\t\t: 1)\n#  define MBTEST(x)\t((x) && last_shell_getc_is_singlebyte)\n#else\n#  define last_shell_getc_is_singlebyte\t1\n#  define MBTEST(x)\t((x))\n#endif\n\n#define EXTEND_SHELL_INPUT_LINE_PROPERTY() \\\ndo { \\\n    if (shell_input_line_len + 2 > shell_input_line_propsize) \\\n      { \\\n\tshell_input_line_propsize = shell_input_line_len + 2; \\\n\tshell_input_line_property = (char *)xrealloc (shell_input_line_property, \\\n\t\t\t\t    shell_input_line_propsize); \\\n      } \\\n} while (0)\n\n#if defined (EXTENDED_GLOB)\nextern int extended_glob, extglob_flag;\n#endif\n\n#if defined (TRANSLATABLE_STRINGS)\nextern int dump_translatable_strings, dump_po_strings;\nextern int singlequote_translations;\n#endif  \n\n#if !defined (errno)\nextern int errno;\n#endif\n\n \n \n \n \n \n\n#ifdef DEBUG\nstatic void debug_parser PARAMS((int));\n#endif\n\nstatic int yy_getc PARAMS((void));\nstatic int yy_ungetc PARAMS((int));\n\n#if defined (READLINE)\nstatic int yy_readline_get PARAMS((void));\nstatic int yy_readline_unget PARAMS((int));\n#endif\n\nstatic int yy_string_get PARAMS((void));\nstatic int yy_string_unget PARAMS((int));\nstatic int yy_stream_get PARAMS((void));\nstatic int yy_stream_unget PARAMS((int));\n\nstatic int shell_getc PARAMS((int));\nstatic void shell_ungetc PARAMS((int));\nstatic void discard_until PARAMS((int));\n\nstatic void push_string PARAMS((char *, int, alias_t *));\nstatic void pop_string PARAMS((void));\nstatic void free_string_list PARAMS((void));\n\nstatic char *read_a_line PARAMS((int));\n\nstatic int reserved_word_acceptable PARAMS((int));\nstatic int yylex PARAMS((void));\n\nstatic void push_heredoc PARAMS((REDIRECT *));\nstatic char *mk_alexpansion PARAMS((char *));\nstatic int alias_expand_token PARAMS((char *));\nstatic int time_command_acceptable PARAMS((void));\nstatic int special_case_tokens PARAMS((char *));\nstatic int read_token PARAMS((int));\nstatic char *parse_matched_pair PARAMS((int, int, int, int *, int));\nstatic char *parse_comsub PARAMS((int, int, int, int *, int));\n#if defined (ARRAY_VARS)\nstatic char *parse_compound_assignment PARAMS((int *));\n#endif\n#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)\nstatic int parse_dparen PARAMS((int));\nstatic int parse_arith_cmd PARAMS((char **, int));\n#endif\n#if defined (COND_COMMAND)\nstatic void cond_error PARAMS((void));\nstatic COND_COM *cond_expr PARAMS((void));\nstatic COND_COM *cond_or PARAMS((void));\nstatic COND_COM *cond_and PARAMS((void));\nstatic COND_COM *cond_term PARAMS((void));\nstatic int cond_skip_newlines PARAMS((void));\nstatic COMMAND *parse_cond_command PARAMS((void));\n#endif\n#if defined (ARRAY_VARS)\nstatic int token_is_assignment PARAMS((char *, int));\nstatic int token_is_ident PARAMS((char *, int));\n#endif\nstatic int read_token_word PARAMS((int));\nstatic void discard_parser_constructs PARAMS((int));\n\nstatic char *error_token_from_token PARAMS((int));\nstatic char *error_token_from_text PARAMS((void));\nstatic void print_offending_line PARAMS((void));\nstatic void report_syntax_error PARAMS((char *));\n\nstatic void handle_eof_input_unit PARAMS((void));\nstatic void prompt_again PARAMS((int));\n#if 0\nstatic void reset_readline_prompt PARAMS((void));\n#endif\nstatic void print_prompt PARAMS((void));\n\n#if defined (HANDLE_MULTIBYTE)\nstatic void set_line_mbstate PARAMS((void));\nstatic char *shell_input_line_property = NULL;\nstatic size_t shell_input_line_propsize = 0;\n#else\n#  define set_line_mbstate()\n#endif\n\nextern int yyerror PARAMS((const char *));\n\n#ifdef DEBUG\nextern int yydebug;\n#endif\n\n \nchar *primary_prompt = PPROMPT;\nchar *secondary_prompt = SPROMPT;\n\n \nchar *ps1_prompt, *ps2_prompt;\n\n \nchar *ps0_prompt;\n\n \nchar **prompt_string_pointer = (char **)NULL;\nchar *current_prompt_string;\n\n \nint expand_aliases = 0;\n\n \nint promptvars = 1;\n\n \nint extended_quote = 1;\n\n \nint current_command_line_count;\n\n \nint saved_command_line_count;\n\n \nint shell_eof_token;\n\n \nint current_token;\n\n \nint parser_state;\n\n \nstatic REDIRECT *redir_stack[HEREDOC_MAX];\nint need_here_doc;\n\n \nstatic char *shell_input_line = (char *)NULL;\nstatic size_t shell_input_line_index;\nstatic size_t shell_input_line_size;\t \nstatic size_t shell_input_line_len;\t \n\n \nstatic int shell_input_line_terminator;\n\n \nstatic int function_dstart;\n\n \nstatic int function_bstart;\n\n \nstatic int arith_for_lineno;\n\n \nstatic char *current_decoded_prompt;\n\n \nstatic int last_read_token;\n\n \nstatic int token_before_that;\n\n \nstatic int two_tokens_ago;\n\nstatic int global_extglob;\n\n \n#define MAX_CASE_NEST\t128\nstatic int word_lineno[MAX_CASE_NEST+1];\nstatic int word_top = -1;\n\n \nstatic int token_to_read;\nstatic WORD_DESC *word_desc_to_read;\n\nstatic REDIRECTEE source;\nstatic REDIRECTEE redir;\n\nstatic FILE *yyoutstream;\nstatic FILE *yyerrstream;\n\n#line 388 \"y.tab.c\"\n\n# ifndef YY_CAST\n#  ifdef __cplusplus\n#   define YY_CAST(Type, Val) static_cast<Type> (Val)\n#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)\n#  else\n#   define YY_CAST(Type, Val) ((Type) (Val))\n#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))\n#  endif\n# endif\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n \n#ifndef YY_YY_Y_TAB_H_INCLUDED\n# define YY_YY_Y_TAB_H_INCLUDED\n \n#ifndef YYDEBUG\n# define YYDEBUG 0\n#endif\n#if YYDEBUG\nextern int yydebug;\n#endif\n\n \n#ifndef YYTOKENTYPE\n# define YYTOKENTYPE\n  enum yytokentype\n  {\n    YYEMPTY = -2,\n    YYEOF = 0,                      \n    YYerror = 256,                  \n    YYUNDEF = 257,                  \n    IF = 258,                       \n    THEN = 259,                     \n    ELSE = 260,                     \n    ELIF = 261,                     \n    FI = 262,                       \n    CASE = 263,                     \n    ESAC = 264,                     \n    FOR = 265,                      \n    SELECT = 266,                   \n    WHILE = 267,                    \n    UNTIL = 268,                    \n    DO = 269,                       \n    DONE = 270,                     \n    FUNCTION = 271,                 \n    COPROC = 272,                   \n    COND_START = 273,               \n    COND_END = 274,                 \n    COND_ERROR = 275,               \n    IN = 276,                       \n    BANG = 277,                     \n    TIME = 278,                     \n    TIMEOPT = 279,                  \n    TIMEIGN = 280,                  \n    WORD = 281,                     \n    ASSIGNMENT_WORD = 282,          \n    REDIR_WORD = 283,               \n    NUMBER = 284,                   \n    ARITH_CMD = 285,                \n    ARITH_FOR_EXPRS = 286,          \n    COND_CMD = 287,                 \n    AND_AND = 288,                  \n    OR_OR = 289,                    \n    GREATER_GREATER = 290,          \n    LESS_LESS = 291,                \n    LESS_AND = 292,                 \n    LESS_LESS_LESS = 293,           \n    GREATER_AND = 294,              \n    SEMI_SEMI = 295,                \n    SEMI_AND = 296,                 \n    SEMI_SEMI_AND = 297,            \n    LESS_LESS_MINUS = 298,          \n    AND_GREATER = 299,              \n    AND_GREATER_GREATER = 300,      \n    LESS_GREATER = 301,             \n    GREATER_BAR = 302,              \n    BAR_AND = 303,                  \n    DOLPAREN = 304,                 \n    yacc_EOF = 305                  \n  };\n  typedef enum yytokentype yytoken_kind_t;\n#endif\n \n#define YYEMPTY -2\n#define YYEOF 0\n#define YYerror 256\n#define YYUNDEF 257\n#define IF 258\n#define THEN 259\n#define ELSE 260\n#define ELIF 261\n#define FI 262\n#define CASE 263\n#define ESAC 264\n#define FOR 265\n#define SELECT 266\n#define WHILE 267\n#define UNTIL 268\n#define DO 269\n#define DONE 270\n#define FUNCTION 271\n#define COPROC 272\n#define COND_START 273\n#define COND_END 274\n#define COND_ERROR 275\n#define IN 276\n#define BANG 277\n#define TIME 278\n#define TIMEOPT 279\n#define TIMEIGN 280\n#define WORD 281\n#define ASSIGNMENT_WORD 282\n#define REDIR_WORD 283\n#define NUMBER 284\n#define ARITH_CMD 285\n#define ARITH_FOR_EXPRS 286\n#define COND_CMD 287\n#define AND_AND 288\n#define OR_OR 289\n#define GREATER_GREATER 290\n#define LESS_LESS 291\n#define LESS_AND 292\n#define LESS_LESS_LESS 293\n#define GREATER_AND 294\n#define SEMI_SEMI 295\n#define SEMI_AND 296\n#define SEMI_SEMI_AND 297\n#define LESS_LESS_MINUS 298\n#define AND_GREATER 299\n#define AND_GREATER_GREATER 300\n#define LESS_GREATER 301\n#define GREATER_BAR 302\n#define BAR_AND 303\n#define DOLPAREN 304\n#define yacc_EOF 305\n\n \n#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED\nunion YYSTYPE\n{\n#line 338 \"/usr/local/src/chet/src/bash/src/parse.y\"\n\n  WORD_DESC *word;\t\t \n  int number;\t\t\t \n  WORD_LIST *word_list;\n  COMMAND *command;\n  REDIRECT *redirect;\n  ELEMENT element;\n  PATTERN_LIST *pattern;\n\n#line 551 \"y.tab.c\"\n\n};\ntypedef union YYSTYPE YYSTYPE;\n# define YYSTYPE_IS_TRIVIAL 1\n# define YYSTYPE_IS_DECLARED 1\n#endif\n\n\nextern YYSTYPE yylval;\n\n\nint yyparse (void);\n\n\n#endif  \n \nenum yysymbol_kind_t\n{\n  YYSYMBOL_YYEMPTY = -2,\n  YYSYMBOL_YYEOF = 0,                       \n  YYSYMBOL_YYerror = 1,                     \n  YYSYMBOL_YYUNDEF = 2,                     \n  YYSYMBOL_IF = 3,                          \n  YYSYMBOL_THEN = 4,                        \n  YYSYMBOL_ELSE = 5,                        \n  YYSYMBOL_ELIF = 6,                        \n  YYSYMBOL_FI = 7,                          \n  YYSYMBOL_CASE = 8,                        \n  YYSYMBOL_ESAC = 9,                        \n  YYSYMBOL_FOR = 10,                        \n  YYSYMBOL_SELECT = 11,                     \n  YYSYMBOL_WHILE = 12,                      \n  YYSYMBOL_UNTIL = 13,                      \n  YYSYMBOL_DO = 14,                         \n  YYSYMBOL_DONE = 15,                       \n  YYSYMBOL_FUNCTION = 16,                   \n  YYSYMBOL_COPROC = 17,                     \n  YYSYMBOL_COND_START = 18,                 \n  YYSYMBOL_COND_END = 19,                   \n  YYSYMBOL_COND_ERROR = 20,                 \n  YYSYMBOL_IN = 21,                         \n  YYSYMBOL_BANG = 22,                       \n  YYSYMBOL_TIME = 23,                       \n  YYSYMBOL_TIMEOPT = 24,                    \n  YYSYMBOL_TIMEIGN = 25,                    \n  YYSYMBOL_WORD = 26,                       \n  YYSYMBOL_ASSIGNMENT_WORD = 27,            \n  YYSYMBOL_REDIR_WORD = 28,                 \n  YYSYMBOL_NUMBER = 29,                     \n  YYSYMBOL_ARITH_CMD = 30,                  \n  YYSYMBOL_ARITH_FOR_EXPRS = 31,            \n  YYSYMBOL_COND_CMD = 32,                   \n  YYSYMBOL_AND_AND = 33,                    \n  YYSYMBOL_OR_OR = 34,                      \n  YYSYMBOL_GREATER_GREATER = 35,            \n  YYSYMBOL_LESS_LESS = 36,                  \n  YYSYMBOL_LESS_AND = 37,                   \n  YYSYMBOL_LESS_LESS_LESS = 38,             \n  YYSYMBOL_GREATER_AND = 39,                \n  YYSYMBOL_SEMI_SEMI = 40,                  \n  YYSYMBOL_SEMI_AND = 41,                   \n  YYSYMBOL_SEMI_SEMI_AND = 42,              \n  YYSYMBOL_LESS_LESS_MINUS = 43,            \n  YYSYMBOL_AND_GREATER = 44,                \n  YYSYMBOL_AND_GREATER_GREATER = 45,        \n  YYSYMBOL_LESS_GREATER = 46,               \n  YYSYMBOL_GREATER_BAR = 47,                \n  YYSYMBOL_BAR_AND = 48,                    \n  YYSYMBOL_DOLPAREN = 49,                   \n  YYSYMBOL_50_ = 50,                        \n  YYSYMBOL_51_ = 51,                        \n  YYSYMBOL_52_n_ = 52,                      \n  YYSYMBOL_yacc_EOF = 53,                   \n  YYSYMBOL_54_ = 54,                        \n  YYSYMBOL_55_ = 55,                        \n  YYSYMBOL_56_ = 56,                        \n  YYSYMBOL_57_ = 57,                        \n  YYSYMBOL_58_ = 58,                        \n  YYSYMBOL_59_ = 59,                        \n  YYSYMBOL_60_ = 60,                        \n  YYSYMBOL_61_ = 61,                        \n  YYSYMBOL_YYACCEPT = 62,                   \n  YYSYMBOL_inputunit = 63,                  \n  YYSYMBOL_word_list = 64,                  \n  YYSYMBOL_redirection = 65,                \n  YYSYMBOL_simple_command_element = 66,     \n  YYSYMBOL_redirection_list = 67,           \n  YYSYMBOL_simple_command = 68,             \n  YYSYMBOL_command = 69,                    \n  YYSYMBOL_shell_command = 70,              \n  YYSYMBOL_for_command = 71,                \n  YYSYMBOL_arith_for_command = 72,          \n  YYSYMBOL_select_command = 73,             \n  YYSYMBOL_case_command = 74,               \n  YYSYMBOL_function_def = 75,               \n  YYSYMBOL_function_body = 76,              \n  YYSYMBOL_subshell = 77,                   \n  YYSYMBOL_comsub = 78,                     \n  YYSYMBOL_coproc = 79,                     \n  YYSYMBOL_if_command = 80,                 \n  YYSYMBOL_group_command = 81,              \n  YYSYMBOL_arith_command = 82,              \n  YYSYMBOL_cond_command = 83,               \n  YYSYMBOL_elif_clause = 84,                \n  YYSYMBOL_case_clause = 85,                \n  YYSYMBOL_pattern_list = 86,               \n  YYSYMBOL_case_clause_sequence = 87,       \n  YYSYMBOL_pattern = 88,                    \n  YYSYMBOL_compound_list = 89,              \n  YYSYMBOL_list0 = 90,                      \n  YYSYMBOL_list1 = 91,                      \n  YYSYMBOL_simple_list_terminator = 92,     \n  YYSYMBOL_list_terminator = 93,            \n  YYSYMBOL_newline_list = 94,               \n  YYSYMBOL_simple_list = 95,                \n  YYSYMBOL_simple_list1 = 96,               \n  YYSYMBOL_pipeline_command = 97,           \n  YYSYMBOL_pipeline = 98,                   \n  YYSYMBOL_timespec = 99                    \n};\ntypedef enum yysymbol_kind_t yysymbol_kind_t;\n\n\n\n\n#ifdef short\n# undef short\n#endif\n\n \n\n#ifndef __PTRDIFF_MAX__\n# include <limits.h>  \n# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__\n#  include <stdint.h>  \n#  define YY_STDINT_H\n# endif\n#endif\n\n \n\n#ifdef __INT_LEAST8_MAX__\ntypedef __INT_LEAST8_TYPE__ yytype_int8;\n#elif defined YY_STDINT_H\ntypedef int_least8_t yytype_int8;\n#else\ntypedef signed char yytype_int8;\n#endif\n\n#ifdef __INT_LEAST16_MAX__\ntypedef __INT_LEAST16_TYPE__ yytype_int16;\n#elif defined YY_STDINT_H\ntypedef int_least16_t yytype_int16;\n#else\ntypedef short yytype_int16;\n#endif\n\n \n#  endif\n#  define YYPTRDIFF_T ptrdiff_t\n#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX\n# else\n#  define YYPTRDIFF_T long\n#  define YYPTRDIFF_MAXIMUM LONG_MAX\n# endif\n#endif\n\n#ifndef YYSIZE_T\n# ifdef __SIZE_TYPE__\n#  define YYSIZE_T __SIZE_TYPE__\n# elif defined size_t\n#  define YYSIZE_T size_t\n# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__\n#  include <stddef.h>  \n#  define YYSIZE_T size_t\n# else\n#  define YYSIZE_T unsigned\n# endif\n#endif\n\n#define YYSIZE_MAXIMUM                                  \\\n  YY_CAST (YYPTRDIFF_T,                                 \\\n           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \\\n            ? YYPTRDIFF_MAXIMUM                         \\\n            : YY_CAST (YYSIZE_T, -1)))\n\n#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))\n\n\n \ntypedef yytype_int16 yy_state_t;\n\n \ntypedef int yy_state_fast_t;\n\n#ifndef YY_\n# if defined YYENABLE_NLS && YYENABLE_NLS\n#  if ENABLE_NLS\n#   include <libintl.h>  \n#   define YY_(Msgid) dgettext (\"bison-runtime\", Msgid)\n#  endif\n# endif\n# ifndef YY_\n#  define YY_(Msgid) Msgid\n# endif\n#endif\n\n\n#ifndef YY_ATTRIBUTE_PURE\n# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)\n#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))\n# else\n#  define YY_ATTRIBUTE_PURE\n# endif\n#endif\n\n#ifndef YY_ATTRIBUTE_UNUSED\n# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)\n#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n# else\n#  define YY_ATTRIBUTE_UNUSED\n# endif\n#endif\n\n \n#if ! defined lint || defined __GNUC__\n# define YY_USE(E) ((void) (E))\n#else\n# define YY_USE(E)  \n#endif\n\n \n#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__\n# if __GNUC__ * 100 + __GNUC_MINOR__ < 407\n#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \\\n    _Pragma (\"GCC diagnostic push\")                                     \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")\n# else\n#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \\\n    _Pragma (\"GCC diagnostic push\")                                     \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")              \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wmaybe-uninitialized\\\"\")\n# endif\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \\\n    _Pragma (\"GCC diagnostic pop\")\n#else\n# define YY_INITIAL_VALUE(Value) Value\n#endif\n#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END\n#endif\n#ifndef YY_INITIAL_VALUE\n# define YY_INITIAL_VALUE(Value)  \n#endif\n\n#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__\n# define YY_IGNORE_USELESS_CAST_BEGIN                          \\\n    _Pragma (\"GCC diagnostic push\")                            \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuseless-cast\\\"\")\n# define YY_IGNORE_USELESS_CAST_END            \\\n    _Pragma (\"GCC diagnostic pop\")\n#endif\n#ifndef YY_IGNORE_USELESS_CAST_BEGIN\n# define YY_IGNORE_USELESS_CAST_BEGIN\n# define YY_IGNORE_USELESS_CAST_END\n#endif\n\n\n#define YY_ASSERT(E) ((void) (0 && (E)))\n\n#if !defined yyoverflow\n\n \n\n# ifdef YYSTACK_USE_ALLOCA\n#  if YYSTACK_USE_ALLOCA\n#   ifdef __GNUC__\n#    define YYSTACK_ALLOC __builtin_alloca\n#   elif defined __BUILTIN_VA_ARG_INCR\n#    include <alloca.h>  \n#   elif defined _AIX\n#    define YYSTACK_ALLOC __alloca\n#   elif defined _MSC_VER\n#    include <malloc.h>  \n#    define alloca _alloca\n#   else\n#    define YYSTACK_ALLOC alloca\n#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS\n#     include <stdlib.h>  \n       \n#     ifndef EXIT_SUCCESS\n#      define EXIT_SUCCESS 0\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n\n# ifdef YYSTACK_ALLOC\n    \n#  define YYSTACK_FREE(Ptr) do {  ; } while (0)\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n     \n#   define YYSTACK_ALLOC_MAXIMUM 4032  \n#  endif\n# else\n#  define YYSTACK_ALLOC YYMALLOC\n#  define YYSTACK_FREE YYFREE\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM\n#  endif\n#  if (defined __cplusplus && ! defined EXIT_SUCCESS \\\n       && ! ((defined YYMALLOC || defined malloc) \\\n             && (defined YYFREE || defined free)))\n#   include <stdlib.h>  \n#   ifndef EXIT_SUCCESS\n#    define EXIT_SUCCESS 0\n#   endif\n#  endif\n#  ifndef YYMALLOC\n#   define YYMALLOC malloc\n#   if ! defined malloc && ! defined EXIT_SUCCESS\nvoid *malloc (YYSIZE_T);  \n#   endif\n#  endif\n#  ifndef YYFREE\n#   define YYFREE free\n#   if ! defined free && ! defined EXIT_SUCCESS\nvoid free (void *);  \n#   endif\n#  endif\n# endif\n#endif  \n\n#if (! defined yyoverflow \\\n     && (! defined __cplusplus \\\n         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))\n\n \nunion yyalloc\n{\n  yy_state_t yyss_alloc;\n  YYSTYPE yyvs_alloc;\n};\n\n \n# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)\n\n \n# define YYSTACK_BYTES(N) \\\n     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \\\n      + YYSTACK_GAP_MAXIMUM)\n\n# define YYCOPY_NEEDED 1\n\n \n# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \\\n    do                                                                  \\\n      {                                                                 \\\n        YYPTRDIFF_T yynewbytes;                                         \\\n        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \\\n        Stack = &yyptr->Stack_alloc;                                    \\\n        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \\\n        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \\\n      }                                                                 \\\n    while (0)\n\n#endif\n\n#if defined YYCOPY_NEEDED && YYCOPY_NEEDED\n \n# ifndef YYCOPY\n#  if defined __GNUC__ && 1 < __GNUC__\n#   define YYCOPY(Dst, Src, Count) \\\n      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))\n#  else\n#   define YYCOPY(Dst, Src, Count)              \\\n      do                                        \\\n        {                                       \\\n          YYPTRDIFF_T yyi;                      \\\n          for (yyi = 0; yyi < (Count); yyi++)   \\\n            (Dst)[yyi] = (Src)[yyi];            \\\n        }                                       \\\n      while (0)\n#  endif\n# endif\n#endif  \n\n \n#define YYFINAL  122\n \n#define YYLAST   740\n\n \n#define YYNTOKENS  62\n \n#define YYNNTS  38\n \n#define YYNRULES  175\n \n#define YYNSTATES  350\n\n \n#define YYMAXUTOK   305\n\n\n \n#define YYTRANSLATE(YYX)                                \\\n  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \\\n   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \\\n   : YYSYMBOL_YYUNDEF)\n\n \nstatic const yytype_int8 yytranslate[] =\n{\n       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      52,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,    50,     2,\n      60,    61,     2,     2,     2,    57,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,    51,\n      56,     2,    55,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,    58,    54,    59,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,\n       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,\n      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,\n      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,\n      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,\n      45,    46,    47,    48,    49,    53\n};\n\n#if YYDEBUG\n \nstatic const yytype_int16 yyrline[] =\n{\n       0,   395,   395,   406,   414,   423,   438,   455,   470,   480,\n     482,   486,   492,   498,   504,   510,   516,   522,   528,   534,\n     540,   546,   552,   558,   564,   570,   576,   583,   590,   597,\n     604,   611,   618,   624,   630,   636,   642,   648,   654,   660,\n     666,   672,   678,   684,   690,   696,   702,   708,   714,   720,\n     726,   732,   738,   744,   750,   758,   760,   762,   766,   770,\n     781,   783,   787,   789,   791,   807,   809,   813,   815,   817,\n     819,   821,   823,   825,   827,   829,   831,   833,   837,   842,\n     847,   852,   857,   862,   867,   872,   879,   885,   891,   897,\n     905,   910,   915,   920,   925,   930,   935,   940,   947,   952,\n     957,   964,   966,   968,   970,   974,   976,  1007,  1014,  1018,\n    1024,  1029,  1046,  1051,  1068,  1075,  1077,  1079,  1084,  1088,\n    1092,  1096,  1098,  1100,  1104,  1105,  1109,  1111,  1113,  1115,\n    1119,  1121,  1123,  1125,  1127,  1129,  1133,  1135,  1144,  1150,\n    1156,  1157,  1164,  1168,  1170,  1172,  1179,  1181,  1188,  1192,\n    1193,  1196,  1198,  1200,  1204,  1205,  1214,  1229,  1247,  1264,\n    1266,  1268,  1275,  1278,  1282,  1284,  1290,  1296,  1316,  1339,\n    1341,  1364,  1368,  1370,  1372,  1374\n};\n#endif\n\n \n#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])\n\n#if YYDEBUG || 0\n \nstatic const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;\n\n \nstatic const char *const yytname[] =\n{\n  \"\\\"end of file\\\"\", \"error\", \"\\\"invalid token\\\"\", \"IF\", \"THEN\", \"ELSE\",\n  \"ELIF\", \"FI\", \"CASE\", \"ESAC\", \"FOR\", \"SELECT\", \"WHILE\", \"UNTIL\", \"DO\",\n  \"DONE\", \"FUNCTION\", \"COPROC\", \"COND_START\", \"COND_END\", \"COND_ERROR\",\n  \"IN\", \"BANG\", \"TIME\", \"TIMEOPT\", \"TIMEIGN\", \"WORD\", \"ASSIGNMENT_WORD\",\n  \"REDIR_WORD\", \"NUMBER\", \"ARITH_CMD\", \"ARITH_FOR_EXPRS\", \"COND_CMD\",\n  \"AND_AND\", \"OR_OR\", \"GREATER_GREATER\", \"LESS_LESS\", \"LESS_AND\",\n  \"LESS_LESS_LESS\", \"GREATER_AND\", \"SEMI_SEMI\", \"SEMI_AND\",\n  \"SEMI_SEMI_AND\", \"LESS_LESS_MINUS\", \"AND_GREATER\", \"AND_GREATER_GREATER\",\n  \"LESS_GREATER\", \"GREATER_BAR\", \"BAR_AND\", \"DOLPAREN\", \"'&'\", \"';'\",\n  \"'\\\\n'\", \"yacc_EOF\", \"'|'\", \"'>'\", \"'<'\", \"'-'\", \"'{'\", \"'}'\", \"'('\",\n  \"')'\", \"$accept\", \"inputunit\", \"word_list\", \"redirection\",\n  \"simple_command_element\", \"redirection_list\", \"simple_command\",\n  \"command\", \"shell_command\", \"for_command\", \"arith_for_command\",\n  \"select_command\", \"case_command\", \"function_def\", \"function_body\",\n  \"subshell\", \"comsub\", \"coproc\", \"if_command\", \"group_command\",\n  \"arith_command\", \"cond_command\", \"elif_clause\", \"case_clause\",\n  \"pattern_list\", \"case_clause_sequence\", \"pattern\", \"compound_list\",\n  \"list0\", \"list1\", \"simple_list_terminator\", \"list_terminator\",\n  \"newline_list\", \"simple_list\", \"simple_list1\", \"pipeline_command\",\n  \"pipeline\", \"timespec\", YY_NULLPTR\n};\n\nstatic const char *\nyysymbol_name (yysymbol_kind_t yysymbol)\n{\n  return yytname[yysymbol];\n}\n#endif\n\n#define YYPACT_NINF (-125)\n\n#define yypact_value_is_default(Yyn) \\\n  ((Yyn) == YYPACT_NINF)\n\n#define YYTABLE_NINF (-1)\n\n#define yytable_value_is_error(Yyn) \\\n  0\n\n \nstatic const yytype_int16 yypact[] =\n{\n     329,    27,  -125,     8,    81,    10,  -125,  -125,    16,    38,\n       0,   434,    -5,   -16,  -125,   670,   684,  -125,    33,    43,\n      62,    63,    71,    69,    94,   105,   108,   116,  -125,  -125,\n    -125,   125,   139,  -125,  -125,   111,  -125,  -125,   626,  -125,\n     648,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,\n    -125,  -125,  -125,     5,   -21,  -125,   -15,   434,  -125,  -125,\n    -125,   196,   485,  -125,   157,     2,   180,   207,   222,   227,\n     638,   626,   648,   224,  -125,  -125,  -125,  -125,  -125,   219,\n    -125,   185,   223,   228,   140,   230,   161,   232,   233,   234,\n     236,   241,   248,   249,   162,   250,   163,   251,   254,   256,\n     257,   258,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,\n    -125,  -125,  -125,  -125,  -125,  -125,   225,   380,  -125,  -125,\n     229,   231,  -125,  -125,  -125,  -125,   648,  -125,  -125,  -125,\n    -125,  -125,   536,   536,  -125,  -125,  -125,  -125,  -125,  -125,\n    -125,   214,  -125,    -7,  -125,    85,  -125,  -125,  -125,  -125,\n      89,  -125,  -125,  -125,   235,   648,  -125,   648,   648,  -125,\n    -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,\n    -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,\n    -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,  -125,\n    -125,  -125,  -125,  -125,  -125,   485,   485,   138,   138,   587,\n     587,    17,  -125,  -125,  -125,  -125,  -125,  -125,    88,  -125,\n     122,  -125,   274,   238,   100,   101,  -125,   122,  -125,   276,\n     278,   260,  -125,   648,   648,   260,  -125,  -125,   -15,   -15,\n    -125,  -125,  -125,   287,   485,   485,   485,   485,   485,   290,\n     164,  -125,    26,  -125,  -125,   285,  -125,   131,  -125,   242,\n    -125,  -125,  -125,  -125,  -125,  -125,   288,   131,  -125,   243,\n    -125,  -125,  -125,   260,  -125,   297,   302,  -125,  -125,  -125,\n     152,   152,   152,  -125,  -125,  -125,  -125,   170,    61,  -125,\n    -125,   281,   -36,   293,   252,  -125,  -125,  -125,   102,  -125,\n     298,   255,   300,   262,  -125,  -125,   103,  -125,  -125,  -125,\n    -125,  -125,  -125,  -125,  -125,   -33,   296,  -125,  -125,  -125,\n     110,  -125,  -125,  -125,  -125,  -125,  -125,   112,  -125,  -125,\n     189,  -125,  -125,  -125,   485,  -125,  -125,   310,   267,  -125,\n    -125,   314,   275,  -125,  -125,  -125,   485,   318,   277,  -125,\n    -125,   320,   279,  -125,  -125,  -125,  -125,  -125,  -125,  -125\n};\n\n \nstatic const yytype_uint8 yydefact[] =\n{\n       0,     0,   154,     0,     0,     0,   154,   154,     0,     0,\n       0,     0,   172,    55,    56,     0,     0,   119,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,   154,     4,\n       8,     0,     0,   154,   154,     0,    57,    60,    62,   171,\n      63,    67,    77,    71,    68,    65,    73,     3,    66,    72,\n      74,    75,    76,     0,   156,   163,   164,     0,     7,     5,\n       6,     0,     0,   154,   154,     0,   154,     0,     0,     0,\n      55,   114,   110,     0,   152,   151,   153,   168,   165,   173,\n     174,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,\n       0,     0,    17,    26,    41,    35,    50,    32,    44,    38,\n      47,    29,    53,    54,    23,    20,     0,     0,    11,    12,\n       0,     0,     1,    55,    61,    58,    64,   149,   150,     2,\n     154,   154,   157,   158,   154,   154,   167,   166,   154,   155,\n     138,   139,   148,     0,   154,     0,   154,   154,   154,   154,\n       0,   154,   154,   154,   154,   105,   103,   112,   111,   120,\n     175,   154,    19,    28,    43,    37,    52,    34,    46,    40,\n      49,    31,    25,    22,    15,    16,    18,    27,    42,    36,\n      51,    33,    45,    39,    48,    30,    24,    21,    13,    14,\n     108,   109,   118,   107,    59,     0,     0,   161,   162,     0,\n       0,     0,   154,   154,   154,   154,   154,   154,     0,   154,\n       0,   154,     0,     0,     0,     0,   154,     0,   154,     0,\n       0,     0,   154,   106,   113,     0,   159,   160,   170,   169,\n     154,   154,   115,     0,     0,     0,   141,   142,   140,     0,\n     124,   154,     0,   154,   154,     0,     9,     0,   154,     0,\n      88,    89,   154,   154,   154,   154,     0,     0,   154,     0,\n      69,    70,   104,     0,   101,     0,     0,   117,   143,   144,\n     145,   146,   147,   100,   130,   132,   134,   125,     0,    98,\n     136,     0,     0,     0,     0,    78,    10,   154,     0,    79,\n       0,     0,     0,     0,    90,   154,     0,    91,   102,   116,\n     154,   131,   133,   135,    99,     0,     0,   154,    80,    81,\n       0,   154,   154,    86,    87,    92,    93,     0,   154,   154,\n     121,   154,   137,   126,   127,   154,   154,     0,     0,   154,\n     154,     0,     0,   154,   123,   128,   129,     0,     0,    84,\n      85,     0,     0,    96,    97,   122,    82,    83,    94,    95\n};\n\n \nstatic const yytype_int16 yypgoto[] =\n{\n    -125,  -125,   126,   -25,   -28,   -65,   335,  -125,    -8,  -125,\n    -125,  -125,  -125,  -125,   -96,  -125,  -125,  -125,  -125,  -125,\n    -125,  -125,    28,  -125,   109,  -125,    68,    -2,  -125,   -11,\n    -125,   -54,   -26,  -125,  -124,     6,    34,  -125\n};\n\n \nstatic const yytype_int16 yydefgoto[] =\n{\n       0,    35,   247,    36,    37,   126,    38,    39,    40,    41,\n      42,    43,    44,    45,   156,    46,    47,    48,    49,    50,\n      51,    52,   233,   239,   240,   241,   282,   121,   140,   141,\n     129,    77,    62,    53,    54,   142,    56,    57\n};\n\n \nstatic const yytype_int16 yytable[] =\n{\n      61,    72,   117,   136,    67,    68,    55,   158,   197,   198,\n     124,   148,   130,   131,   207,   125,   146,    78,   306,    79,\n      80,   306,   230,   231,   232,   307,   116,    58,   321,   132,\n     133,   120,    73,   134,    63,   279,    66,   143,   145,   135,\n     150,     2,    69,   124,    81,   139,     3,   125,     4,     5,\n       6,     7,   280,    74,    75,    76,    10,   127,   128,   102,\n     147,   155,   157,   137,    70,    14,    15,    16,    17,   103,\n     304,   226,   227,    18,    19,    20,    21,    22,   139,    59,\n      60,    23,    24,    25,    26,    27,   281,   280,   104,   107,\n     223,   105,   224,    31,    32,   111,    33,   108,    34,   209,\n     109,   194,   243,   216,   195,   196,   210,    64,   199,   200,\n     217,   122,    65,   139,   252,   254,   311,   318,   208,   106,\n     112,   281,   214,   215,   325,   262,   329,   221,   110,   264,\n     125,   113,   125,   194,   114,   225,   201,   139,    55,    55,\n     139,   139,   115,   211,   212,   213,   244,   218,   246,   219,\n     220,   118,   139,   139,   139,   139,   248,   286,   253,   255,\n     312,   319,   139,   258,   139,   119,   164,   298,   326,   165,\n     330,   130,   131,    74,    75,    76,   234,   235,   236,   237,\n     238,   242,    74,    75,    76,   202,   203,   168,   178,   182,\n     169,   179,   183,   287,   333,   231,   263,   166,   194,   194,\n     138,    55,    55,   295,   274,   275,   276,   245,   144,   249,\n     301,   302,   303,   155,   256,   278,   259,   155,   170,   180,\n     184,   151,   288,   268,   269,   270,   271,   272,   265,   266,\n       2,   149,   296,   228,   229,     3,   152,     4,     5,     6,\n       7,   283,   284,   159,   160,    10,   161,   202,   203,   162,\n     290,   291,   292,   293,   163,   155,   167,    17,   171,   172,\n     173,   310,   174,     2,   204,   205,   206,   175,     3,   317,\n       4,     5,     6,     7,   176,   177,   181,   185,    10,   153,\n     186,   324,   187,   188,   189,    33,   190,   154,   192,   250,\n      17,   260,   193,   261,   267,   336,   222,   251,   320,   273,\n     285,   289,   297,   294,   299,   323,   300,   280,   308,   327,\n     328,   309,   139,   313,   314,   315,   331,   332,    33,   335,\n      34,   316,   322,   337,   338,   339,   340,   341,   342,   343,\n       1,   345,     2,   346,   344,   348,   347,     3,   349,     4,\n       5,     6,     7,   257,    71,     8,     9,    10,   334,   305,\n     277,    11,    12,     0,     0,    13,    14,    15,    16,    17,\n       0,     0,     0,     0,    18,    19,    20,    21,    22,     0,\n       0,     0,    23,    24,    25,    26,    27,     0,    28,     0,\n       0,    29,    30,     2,    31,    32,     0,    33,     3,    34,\n       4,     5,     6,     7,     0,     0,     8,     9,    10,     0,\n       0,     0,    11,    12,     0,     0,    13,    14,    15,    16,\n      17,     0,     0,     0,     0,    18,    19,    20,    21,    22,\n       0,     0,     0,    23,    24,    25,    26,    27,     0,     0,\n       0,     0,   139,     0,     0,    31,    32,     2,    33,     0,\n      34,   191,     3,     0,     4,     5,     6,     7,     0,     0,\n       8,     9,    10,     0,     0,     0,    11,    12,     0,     0,\n      13,    14,    15,    16,    17,     0,     0,     0,     0,    18,\n      19,    20,    21,    22,     0,     0,     0,    23,    24,    25,\n      26,    27,     0,     0,     0,    74,    75,    76,     2,    31,\n      32,     0,    33,     3,    34,     4,     5,     6,     7,     0,\n       0,     8,     9,    10,     0,     0,     0,    11,    12,     0,\n       0,    13,    14,    15,    16,    17,     0,     0,     0,     0,\n      18,    19,    20,    21,    22,     0,     0,     0,    23,    24,\n      25,    26,    27,     0,     0,     0,     0,   139,     0,     2,\n      31,    32,     0,    33,     3,    34,     4,     5,     6,     7,\n       0,     0,     8,     9,    10,     0,     0,     0,    11,    12,\n       0,     0,    13,    14,    15,    16,    17,     0,     0,     0,\n       0,    18,    19,    20,    21,    22,     0,     0,     0,    23,\n      24,    25,    26,    27,     0,     0,     0,     0,     0,     0,\n       2,    31,    32,     0,    33,     3,    34,     4,     5,     6,\n       7,     0,     0,     8,     9,    10,     0,     0,     0,     0,\n       0,     0,     0,    13,    14,    15,    16,    17,     0,     0,\n       0,     0,    18,    19,    20,    21,    22,     0,     0,     0,\n      23,    24,    25,    26,    27,     0,     0,     0,     0,   139,\n       0,     2,    31,    32,     0,    33,     3,    34,     4,     5,\n       6,     7,   123,    14,    15,    16,    10,     0,     0,     0,\n       0,    18,    19,    20,    21,    22,     0,     0,    17,    23,\n      24,    25,    26,    27,     0,     0,    15,    16,     0,     0,\n       0,    31,    32,    18,    19,    20,    21,    22,     0,     0,\n       0,    23,    24,    25,    26,    27,    33,     0,    34,     0,\n       0,     0,     0,    31,    32,    82,    83,    84,    85,    86,\n       0,     0,     0,    87,     0,     0,    88,    89,     0,    92,\n      93,    94,    95,    96,     0,    90,    91,    97,     0,     0,\n      98,    99,     0,     0,     0,     0,     0,     0,     0,   100,\n     101\n};\n\nstatic const yytype_int16 yycheck[] =\n{\n       2,     9,    28,    57,     6,     7,     0,    72,   132,   133,\n      38,    65,    33,    34,    21,    40,    14,    11,    54,    24,\n      25,    54,     5,     6,     7,    61,    28,     0,    61,    50,\n      51,    33,    32,    48,    26,     9,    26,    63,    64,    54,\n      66,     3,    26,    71,    60,    52,     8,    72,    10,    11,\n      12,    13,    26,    51,    52,    53,    18,    52,    53,    26,\n      58,    69,    70,    57,    26,    27,    28,    29,    30,    26,\n       9,   195,   196,    35,    36,    37,    38,    39,    52,    52,\n      53,    43,    44,    45,    46,    47,    60,    26,    26,    26,\n     155,    29,   157,    55,    56,    26,    58,    26,    60,    14,\n      29,   126,    14,    14,   130,   131,    21,    26,   134,   135,\n      21,     0,    31,    52,    14,    14,    14,    14,   144,    57,\n      26,    60,   148,   149,    14,   221,    14,   153,    57,   225,\n     155,    26,   157,   158,    26,   161,   138,    52,   132,   133,\n      52,    52,    26,    58,   146,   147,    58,    58,    26,   151,\n     152,    26,    52,    52,    52,    52,   210,    26,    58,    58,\n      58,    58,    52,   217,    52,    26,    26,   263,    58,    29,\n      58,    33,    34,    51,    52,    53,   202,   203,   204,   205,\n     206,   207,    51,    52,    53,    33,    34,    26,    26,    26,\n      29,    29,    29,   247,     5,     6,   222,    57,   223,   224,\n       4,   195,   196,   257,    40,    41,    42,   209,    51,   211,\n      40,    41,    42,   221,   216,   241,   218,   225,    57,    57,\n      57,    14,   248,   234,   235,   236,   237,   238,   230,   231,\n       3,    51,   258,   199,   200,     8,    14,    10,    11,    12,\n      13,   243,   244,    19,    25,    18,    61,    33,    34,    26,\n     252,   253,   254,   255,    26,   263,    26,    30,    26,    26,\n      26,   287,    26,     3,    50,    51,    52,    26,     8,   295,\n      10,    11,    12,    13,    26,    26,    26,    26,    18,    52,\n      26,   307,    26,    26,    26,    58,    61,    60,    59,    15,\n      30,    15,    61,    15,     7,   321,    61,    59,   300,     9,\n      15,    59,    59,    15,     7,   307,     4,    26,    15,   311,\n     312,    59,    52,    15,    59,    15,   318,   319,    58,   321,\n      60,    59,    26,   325,   326,    15,    59,   329,   330,    15,\n       1,   333,     3,    15,    59,    15,    59,     8,    59,    10,\n      11,    12,    13,   217,     9,    16,    17,    18,   320,   281,\n     241,    22,    23,    -1,    -1,    26,    27,    28,    29,    30,\n      -1,    -1,    -1,    -1,    35,    36,    37,    38,    39,    -1,\n      -1,    -1,    43,    44,    45,    46,    47,    -1,    49,    -1,\n      -1,    52,    53,     3,    55,    56,    -1,    58,     8,    60,\n      10,    11,    12,    13,    -1,    -1,    16,    17,    18,    -1,\n      -1,    -1,    22,    23,    -1,    -1,    26,    27,    28,    29,\n      30,    -1,    -1,    -1,    -1,    35,    36,    37,    38,    39,\n      -1,    -1,    -1,    43,    44,    45,    46,    47,    -1,    -1,\n      -1,    -1,    52,    -1,    -1,    55,    56,     3,    58,    -1,\n      60,    61,     8,    -1,    10,    11,    12,    13,    -1,    -1,\n      16,    17,    18,    -1,    -1,    -1,    22,    23,    -1,    -1,\n      26,    27,    28,    29,    30,    -1,    -1,    -1,    -1,    35,\n      36,    37,    38,    39,    -1,    -1,    -1,    43,    44,    45,\n      46,    47,    -1,    -1,    -1,    51,    52,    53,     3,    55,\n      56,    -1,    58,     8,    60,    10,    11,    12,    13,    -1,\n      -1,    16,    17,    18,    -1,    -1,    -1,    22,    23,    -1,\n      -1,    26,    27,    28,    29,    30,    -1,    -1,    -1,    -1,\n      35,    36,    37,    38,    39,    -1,    -1,    -1,    43,    44,\n      45,    46,    47,    -1,    -1,    -1,    -1,    52,    -1,     3,\n      55,    56,    -1,    58,     8,    60,    10,    11,    12,    13,\n      -1,    -1,    16,    17,    18,    -1,    -1,    -1,    22,    23,\n      -1,    -1,    26,    27,    28,    29,    30,    -1,    -1,    -1,\n      -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,    43,\n      44,    45,    46,    47,    -1,    -1,    -1,    -1,    -1,    -1,\n       3,    55,    56,    -1,    58,     8,    60,    10,    11,    12,\n      13,    -1,    -1,    16,    17,    18,    -1,    -1,    -1,    -1,\n      -1,    -1,    -1,    26,    27,    28,    29,    30,    -1,    -1,\n      -1,    -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,\n      43,    44,    45,    46,    47,    -1,    -1,    -1,    -1,    52,\n      -1,     3,    55,    56,    -1,    58,     8,    60,    10,    11,\n      12,    13,    26,    27,    28,    29,    18,    -1,    -1,    -1,\n      -1,    35,    36,    37,    38,    39,    -1,    -1,    30,    43,\n      44,    45,    46,    47,    -1,    -1,    28,    29,    -1,    -1,\n      -1,    55,    56,    35,    36,    37,    38,    39,    -1,    -1,\n      -1,    43,    44,    45,    46,    47,    58,    -1,    60,    -1,\n      -1,    -1,    -1,    55,    56,    35,    36,    37,    38,    39,\n      -1,    -1,    -1,    43,    -1,    -1,    46,    47,    -1,    35,\n      36,    37,    38,    39,    -1,    55,    56,    43,    -1,    -1,\n      46,    47,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    55,\n      56\n};\n\n \nstatic const yytype_int8 yystos[] =\n{\n       0,     1,     3,     8,    10,    11,    12,    13,    16,    17,\n      18,    22,    23,    26,    27,    28,    29,    30,    35,    36,\n      37,    38,    39,    43,    44,    45,    46,    47,    49,    52,\n      53,    55,    56,    58,    60,    63,    65,    66,    68,    69,\n      70,    71,    72,    73,    74,    75,    77,    78,    79,    80,\n      81,    82,    83,    95,    96,    97,    98,    99,     0,    52,\n      53,    89,    94,    26,    26,    31,    26,    89,    89,    26,\n      26,    68,    70,    32,    51,    52,    53,    93,    97,    24,\n      25,    60,    35,    36,    37,    38,    39,    43,    46,    47,\n      55,    56,    35,    36,    37,    38,    39,    43,    46,    47,\n      55,    56,    26,    26,    26,    29,    57,    26,    26,    29,\n      57,    26,    26,    26,    26,    26,    89,    94,    26,    26,\n      89,    89,     0,    26,    66,    65,    67,    52,    53,    92,\n      33,    34,    50,    51,    48,    54,    93,    97,     4,    52,\n      90,    91,    97,    94,    51,    94,    14,    58,    93,    51,\n      94,    14,    14,    52,    60,    70,    76,    70,    67,    19,\n      25,    61,    26,    26,    26,    29,    57,    26,    26,    29,\n      57,    26,    26,    26,    26,    26,    26,    26,    26,    29,\n      57,    26,    26,    29,    57,    26,    26,    26,    26,    26,\n      61,    61,    59,    61,    65,    94,    94,    96,    96,    94,\n      94,    89,    33,    34,    50,    51,    52,    21,    94,    14,\n      21,    58,    89,    89,    94,    94,    14,    21,    58,    89,\n      89,    94,    61,    67,    67,    94,    96,    96,    98,    98,\n       5,     6,     7,    84,    94,    94,    94,    94,    94,    85,\n      86,    87,    94,    14,    58,    89,    26,    64,    93,    89,\n      15,    59,    14,    58,    14,    58,    89,    64,    93,    89,\n      15,    15,    76,    94,    76,    89,    89,     7,    91,    91,\n      91,    91,    91,     9,    40,    41,    42,    86,    94,     9,\n      26,    60,    88,    89,    89,    15,    26,    93,    94,    59,\n      89,    89,    89,    89,    15,    93,    94,    59,    76,     7,\n       4,    40,    41,    42,     9,    88,    54,    61,    15,    59,\n      94,    14,    58,    15,    59,    15,    59,    94,    14,    58,\n      89,    61,    26,    89,    94,    14,    58,    89,    89,    14,\n      58,    89,    89,     5,    84,    89,    94,    89,    89,    15,\n      59,    89,    89,    15,    59,    89,    15,    59,    15,    59\n};\n\n \nstatic const yytype_int8 yyr1[] =\n{\n       0,    62,    63,    63,    63,    63,    63,    63,    63,    64,\n      64,    65,    65,    65,    65,    65,    65,    65,    65,    65,\n      65,    65,    65,    65,    65,    65,    65,    65,    65,    65,\n      65,    65,    65,    65,    65,    65,    65,    65,    65,    65,\n      65,    65,    65,    65,    65,    65,    65,    65,    65,    65,\n      65,    65,    65,    65,    65,    66,    66,    66,    67,    67,\n      68,    68,    69,    69,    69,    69,    69,    70,    70,    70,\n      70,    70,    70,    70,    70,    70,    70,    70,    71,    71,\n      71,    71,    71,    71,    71,    71,    72,    72,    72,    72,\n      73,    73,    73,    73,    73,    73,    73,    73,    74,    74,\n      74,    75,    75,    75,    75,    76,    76,    77,    78,    78,\n      79,    79,    79,    79,    79,    80,    80,    80,    81,    82,\n      83,    84,    84,    84,    85,    85,    86,    86,    86,    86,\n      87,    87,    87,    87,    87,    87,    88,    88,    89,    89,\n      90,    90,    90,    91,    91,    91,    91,    91,    91,    92,\n      92,    93,    93,    93,    94,    94,    95,    95,    95,    96,\n      96,    96,    96,    96,    97,    97,    97,    97,    97,    98,\n      98,    98,    99,    99,    99,    99\n};\n\n \nstatic const yytype_int8 yyr2[] =\n{\n       0,     2,     2,     1,     1,     2,     2,     2,     1,     1,\n       2,     2,     2,     3,     3,     3,     3,     2,     3,     3,\n       2,     3,     3,     2,     3,     3,     2,     3,     3,     2,\n       3,     3,     2,     3,     3,     2,     3,     3,     2,     3,\n       3,     2,     3,     3,     2,     3,     3,     2,     3,     3,\n       2,     3,     3,     2,     2,     1,     1,     1,     1,     2,\n       1,     2,     1,     1,     2,     1,     1,     1,     1,     5,\n       5,     1,     1,     1,     1,     1,     1,     1,     6,     6,\n       7,     7,    10,    10,     9,     9,     7,     7,     5,     5,\n       6,     6,     7,     7,    10,    10,     9,     9,     6,     7,\n       6,     5,     6,     3,     5,     1,     2,     3,     3,     3,\n       2,     3,     3,     4,     2,     5,     7,     6,     3,     1,\n       3,     4,     6,     5,     1,     2,     4,     4,     5,     5,\n       2,     3,     2,     3,     2,     3,     1,     3,     2,     2,\n       3,     3,     3,     4,     4,     4,     4,     4,     1,     1,\n       1,     1,     1,     1,     0,     2,     1,     2,     2,     4,\n       4,     3,     3,     1,     1,     2,     2,     2,     2,     4,\n       4,     1,     1,     2,     2,     3\n};\n\n\nenum { YYENOMEM = -2 };\n\n#define yyerrok         (yyerrstatus = 0)\n#define yyclearin       (yychar = YYEMPTY)\n\n#define YYACCEPT        goto yyacceptlab\n#define YYABORT         goto yyabortlab\n#define YYERROR         goto yyerrorlab\n#define YYNOMEM         goto yyexhaustedlab\n\n\n#define YYRECOVERING()  (!!yyerrstatus)\n\n#define YYBACKUP(Token, Value)                                    \\\n  do                                                              \\\n    if (yychar == YYEMPTY)                                        \\\n      {                                                           \\\n        yychar = (Token);                                         \\\n        yylval = (Value);                                         \\\n        YYPOPSTACK (yylen);                                       \\\n        yystate = *yyssp;                                         \\\n        goto yybackup;                                            \\\n      }                                                           \\\n    else                                                          \\\n      {                                                           \\\n        yyerror (YY_(\"syntax error: cannot back up\")); \\\n        YYERROR;                                                  \\\n      }                                                           \\\n  while (0)\n\n \n#define YYERRCODE YYUNDEF\n\n\n \n#if YYDEBUG\n\n# ifndef YYFPRINTF\n#  include <stdio.h>  \n#  define YYFPRINTF fprintf\n# endif\n\n# define YYDPRINTF(Args)                        \\\ndo {                                            \\\n  if (yydebug)                                  \\\n    YYFPRINTF Args;                             \\\n} while (0)\n\n\n\n\n# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \\\ndo {                                                                      \\\n  if (yydebug)                                                            \\\n    {                                                                     \\\n      YYFPRINTF (stderr, \"%s \", Title);                                   \\\n      yy_symbol_print (stderr,                                            \\\n                  Kind, Value); \\\n      YYFPRINTF (stderr, \"\\n\");                                           \\\n    }                                                                     \\\n} while (0)\n\n\n \n\nstatic void\nyy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  if (!yyvaluep)\n    return;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}\n\n\n \n\nstatic void\nyy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n\n  yy_symbol_value_print (yyo, yykind, yyvaluep);\n  YYFPRINTF (yyo, \")\");\n}\n\n \n\nstatic void\nyy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}\n\n# define YY_STACK_PRINT(Bottom, Top)                            \\\ndo {                                                            \\\n  if (yydebug)                                                  \\\n    yy_stack_print ((Bottom), (Top));                           \\\n} while (0)\n\n\n \n\nstatic void\nyy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,\n                 int yyrule)\n{\n  int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %d):\\n\",\n             yyrule - 1, yylno);\n   \n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),\n                       &yyvsp[(yyi + 1) - (yynrhs)]);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}\n\n# define YY_REDUCE_PRINT(Rule)          \\\ndo {                                    \\\n  if (yydebug)                          \\\n    yy_reduce_print (yyssp, yyvsp, Rule); \\\n} while (0)\n\n \nint yydebug;\n#else  \n# define YYDPRINTF(Args) ((void) 0)\n# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)\n# define YY_STACK_PRINT(Bottom, Top)\n# define YY_REDUCE_PRINT(Rule)\n#endif  \n\n\n \n#ifndef YYINITDEPTH\n# define YYINITDEPTH 200\n#endif\n\n \n\n#ifndef YYMAXDEPTH\n# define YYMAXDEPTH 10000\n#endif\n\n\n\n\n\n\n \n\nstatic void\nyydestruct (const char *yymsg,\n            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)\n{\n  YY_USE (yyvaluep);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}\n\n\n \nint yychar;\n\n \nYYSTYPE yylval;\n \nint yynerrs;\n\n\n\n\n \n\nint\nyyparse (void)\n{\n    yy_state_fast_t yystate = 0;\n     \n    int yyerrstatus = 0;\n\n     \n\n     \n    YYPTRDIFF_T yystacksize = YYINITDEPTH;\n\n     \n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss = yyssa;\n    yy_state_t *yyssp = yyss;\n\n     \n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs = yyvsa;\n    YYSTYPE *yyvsp = yyvs;\n\n  int yyn;\n   \n  int yyresult;\n   \n  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;\n   \n  YYSTYPE yyval;\n\n\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n   \n  int yylen = 0;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yychar = YYEMPTY;  \n\n  goto yysetstate;\n\n\n \nyynewstate:\n   \n  yyssp++;\n\n\n \nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n  YY_STACK_PRINT (yyss, yyssp);\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    YYNOMEM;\n#else\n    {\n       \n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n         \n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n         \n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else  \n       \n      if (YYMAXDEPTH <= yystacksize)\n        YYNOMEM;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          YYNOMEM;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif  \n\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n \nyybackup:\n   \n\n   \n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n   \n\n   \n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token\\n\"));\n      yychar = yylex ();\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = YYEOF;\n      yytoken = YYSYMBOL_YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else if (yychar == YYerror)\n    {\n       \n      yychar = YYUNDEF;\n      yytoken = YYSYMBOL_YYerror;\n      goto yyerrlab1;\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n   \n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n   \n  if (yyerrstatus)\n    yyerrstatus--;\n\n   \n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n   \n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n \nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n \nyyreduce:\n   \n  yylen = yyr2[yyn];\n\n   \n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 2:  \n#line 396 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  global_command = (yyvsp[-1].command);\n\t\t\t  eof_encountered = 0;\n\t\t\t   \n\t\t\t  if (parser_state & PST_CMDSUBST)\n\t\t\t    parser_state |= PST_EOFTOKEN;\n\t\t\t  YYACCEPT;\n\t\t\t}\n#line 1954 \"y.tab.c\"\n    break;\n\n  case 3:  \n#line 407 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  global_command = (yyvsp[0].command);\n\t\t\t  eof_encountered = 0;\n\t\t\t  YYACCEPT;\n\t\t\t}\n#line 1966 \"y.tab.c\"\n    break;\n\n  case 4:  \n#line 415 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  global_command = (COMMAND *)NULL;\n\t\t\t  if (parser_state & PST_CMDSUBST)\n\t\t\t    parser_state |= PST_EOFTOKEN;\n\t\t\t  YYACCEPT;\n\t\t\t}\n#line 1979 \"y.tab.c\"\n    break;\n\n  case 5:  \n#line 424 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  global_command = (COMMAND *)NULL;\n\t\t\t  eof_encountered = 0;\n\t\t\t   \n\t\t\t  if (interactive && parse_and_execute_level == 0)\n\t\t\t    {\n\t\t\t      YYACCEPT;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      YYABORT;\n\t\t\t    }\n\t\t\t}\n#line 1998 \"y.tab.c\"\n    break;\n\n  case 6:  \n#line 439 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  global_command = (COMMAND *)NULL;\n\t\t\t  if (last_command_exit_value == 0)\n\t\t\t    last_command_exit_value = EX_BADUSAGE;\t \n\t\t\t  if (interactive && parse_and_execute_level == 0)\n\t\t\t    {\n\t\t\t      handle_eof_input_unit ();\n\t\t\t      YYACCEPT;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      YYABORT;\n\t\t\t    }\n\t\t\t}\n#line 2019 \"y.tab.c\"\n    break;\n\n  case 7:  \n#line 456 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  global_command = (COMMAND *)NULL;\n\t\t\t  if (last_command_exit_value == 0)\n\t\t\t    last_command_exit_value = EX_BADUSAGE;\t \n\t\t\t  if (interactive && parse_and_execute_level == 0)\n\t\t\t    {\n\t\t\t      handle_eof_input_unit ();\n\t\t\t      YYACCEPT;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      YYABORT;\n\t\t\t    }\n\t\t\t}\n#line 2038 \"y.tab.c\"\n    break;\n\n  case 8:  \n#line 471 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  global_command = (COMMAND *)NULL;\n\t\t\t  handle_eof_input_unit ();\n\t\t\t  YYACCEPT;\n\t\t\t}\n#line 2050 \"y.tab.c\"\n    break;\n\n  case 9:  \n#line 481 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.word_list) = make_word_list ((yyvsp[0].word), (WORD_LIST *)NULL); }\n#line 2056 \"y.tab.c\"\n    break;\n\n  case 10:  \n#line 483 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.word_list) = make_word_list ((yyvsp[0].word), (yyvsp[-1].word_list)); }\n#line 2062 \"y.tab.c\"\n    break;\n\n  case 11:  \n#line 487 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_output_direction, redir, 0);\n\t\t\t}\n#line 2072 \"y.tab.c\"\n    break;\n\n  case 12:  \n#line 493 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_input_direction, redir, 0);\n\t\t\t}\n#line 2082 \"y.tab.c\"\n    break;\n\n  case 13:  \n#line 499 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_output_direction, redir, 0);\n\t\t\t}\n#line 2092 \"y.tab.c\"\n    break;\n\n  case 14:  \n#line 505 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_input_direction, redir, 0);\n\t\t\t}\n#line 2102 \"y.tab.c\"\n    break;\n\n  case 15:  \n#line 511 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_output_direction, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2112 \"y.tab.c\"\n    break;\n\n  case 16:  \n#line 517 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_input_direction, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2122 \"y.tab.c\"\n    break;\n\n  case 17:  \n#line 523 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_appending_to, redir, 0);\n\t\t\t}\n#line 2132 \"y.tab.c\"\n    break;\n\n  case 18:  \n#line 529 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_appending_to, redir, 0);\n\t\t\t}\n#line 2142 \"y.tab.c\"\n    break;\n\n  case 19:  \n#line 535 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_appending_to, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2152 \"y.tab.c\"\n    break;\n\n  case 20:  \n#line 541 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_output_force, redir, 0);\n\t\t\t}\n#line 2162 \"y.tab.c\"\n    break;\n\n  case 21:  \n#line 547 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_output_force, redir, 0);\n\t\t\t}\n#line 2172 \"y.tab.c\"\n    break;\n\n  case 22:  \n#line 553 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_output_force, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2182 \"y.tab.c\"\n    break;\n\n  case 23:  \n#line 559 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_input_output, redir, 0);\n\t\t\t}\n#line 2192 \"y.tab.c\"\n    break;\n\n  case 24:  \n#line 565 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_input_output, redir, 0);\n\t\t\t}\n#line 2202 \"y.tab.c\"\n    break;\n\n  case 25:  \n#line 571 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_input_output, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2212 \"y.tab.c\"\n    break;\n\n  case 26:  \n#line 577 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_reading_until, redir, 0);\n\t\t\t  push_heredoc ((yyval.redirect));\n\t\t\t}\n#line 2223 \"y.tab.c\"\n    break;\n\n  case 27:  \n#line 584 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_reading_until, redir, 0);\n\t\t\t  push_heredoc ((yyval.redirect));\n\t\t\t}\n#line 2234 \"y.tab.c\"\n    break;\n\n  case 28:  \n#line 591 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_reading_until, redir, REDIR_VARASSIGN);\n\t\t\t  push_heredoc ((yyval.redirect));\n\t\t\t}\n#line 2245 \"y.tab.c\"\n    break;\n\n  case 29:  \n#line 598 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_deblank_reading_until, redir, 0);\n\t\t\t  push_heredoc ((yyval.redirect));\n\t\t\t}\n#line 2256 \"y.tab.c\"\n    break;\n\n  case 30:  \n#line 605 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_deblank_reading_until, redir, 0);\n\t\t\t  push_heredoc ((yyval.redirect));\n\t\t\t}\n#line 2267 \"y.tab.c\"\n    break;\n\n  case 31:  \n#line 612 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_deblank_reading_until, redir, REDIR_VARASSIGN);\n\t\t\t  push_heredoc ((yyval.redirect));\n\t\t\t}\n#line 2278 \"y.tab.c\"\n    break;\n\n  case 32:  \n#line 619 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_reading_string, redir, 0);\n\t\t\t}\n#line 2288 \"y.tab.c\"\n    break;\n\n  case 33:  \n#line 625 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_reading_string, redir, 0);\n\t\t\t}\n#line 2298 \"y.tab.c\"\n    break;\n\n  case 34:  \n#line 631 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_reading_string, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2308 \"y.tab.c\"\n    break;\n\n  case 35:  \n#line 637 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.dest = (yyvsp[0].number);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_input, redir, 0);\n\t\t\t}\n#line 2318 \"y.tab.c\"\n    break;\n\n  case 36:  \n#line 643 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.dest = (yyvsp[0].number);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_input, redir, 0);\n\t\t\t}\n#line 2328 \"y.tab.c\"\n    break;\n\n  case 37:  \n#line 649 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.dest = (yyvsp[0].number);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_input, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2338 \"y.tab.c\"\n    break;\n\n  case 38:  \n#line 655 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.dest = (yyvsp[0].number);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_output, redir, 0);\n\t\t\t}\n#line 2348 \"y.tab.c\"\n    break;\n\n  case 39:  \n#line 661 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.dest = (yyvsp[0].number);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_output, redir, 0);\n\t\t\t}\n#line 2358 \"y.tab.c\"\n    break;\n\n  case 40:  \n#line 667 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.dest = (yyvsp[0].number);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_output, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2368 \"y.tab.c\"\n    break;\n\n  case 41:  \n#line 673 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_input_word, redir, 0);\n\t\t\t}\n#line 2378 \"y.tab.c\"\n    break;\n\n  case 42:  \n#line 679 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_input_word, redir, 0);\n\t\t\t}\n#line 2388 \"y.tab.c\"\n    break;\n\n  case 43:  \n#line 685 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_input_word, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2398 \"y.tab.c\"\n    break;\n\n  case 44:  \n#line 691 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_output_word, redir, 0);\n\t\t\t}\n#line 2408 \"y.tab.c\"\n    break;\n\n  case 45:  \n#line 697 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_output_word, redir, 0);\n\t\t\t}\n#line 2418 \"y.tab.c\"\n    break;\n\n  case 46:  \n#line 703 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_duplicating_output_word, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2428 \"y.tab.c\"\n    break;\n\n  case 47:  \n#line 709 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.dest = 0;\n\t\t\t  (yyval.redirect) = make_redirection (source, r_close_this, redir, 0);\n\t\t\t}\n#line 2438 \"y.tab.c\"\n    break;\n\n  case 48:  \n#line 715 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.dest = 0;\n\t\t\t  (yyval.redirect) = make_redirection (source, r_close_this, redir, 0);\n\t\t\t}\n#line 2448 \"y.tab.c\"\n    break;\n\n  case 49:  \n#line 721 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.dest = 0;\n\t\t\t  (yyval.redirect) = make_redirection (source, r_close_this, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2458 \"y.tab.c\"\n    break;\n\n  case 50:  \n#line 727 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 0;\n\t\t\t  redir.dest = 0;\n\t\t\t  (yyval.redirect) = make_redirection (source, r_close_this, redir, 0);\n\t\t\t}\n#line 2468 \"y.tab.c\"\n    break;\n\n  case 51:  \n#line 733 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = (yyvsp[-2].number);\n\t\t\t  redir.dest = 0;\n\t\t\t  (yyval.redirect) = make_redirection (source, r_close_this, redir, 0);\n\t\t\t}\n#line 2478 \"y.tab.c\"\n    break;\n\n  case 52:  \n#line 739 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.filename = (yyvsp[-2].word);\n\t\t\t  redir.dest = 0;\n\t\t\t  (yyval.redirect) = make_redirection (source, r_close_this, redir, REDIR_VARASSIGN);\n\t\t\t}\n#line 2488 \"y.tab.c\"\n    break;\n\n  case 53:  \n#line 745 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_err_and_out, redir, 0);\n\t\t\t}\n#line 2498 \"y.tab.c\"\n    break;\n\n  case 54:  \n#line 751 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  source.dest = 1;\n\t\t\t  redir.filename = (yyvsp[0].word);\n\t\t\t  (yyval.redirect) = make_redirection (source, r_append_err_and_out, redir, 0);\n\t\t\t}\n#line 2508 \"y.tab.c\"\n    break;\n\n  case 55:  \n#line 759 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.element).word = (yyvsp[0].word); (yyval.element).redirect = 0; }\n#line 2514 \"y.tab.c\"\n    break;\n\n  case 56:  \n#line 761 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.element).word = (yyvsp[0].word); (yyval.element).redirect = 0; }\n#line 2520 \"y.tab.c\"\n    break;\n\n  case 57:  \n#line 763 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.element).redirect = (yyvsp[0].redirect); (yyval.element).word = 0; }\n#line 2526 \"y.tab.c\"\n    break;\n\n  case 58:  \n#line 767 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.redirect) = (yyvsp[0].redirect);\n\t\t\t}\n#line 2534 \"y.tab.c\"\n    break;\n\n  case 59:  \n#line 771 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  register REDIRECT *t;\n\n\t\t\t  for (t = (yyvsp[-1].redirect); t->next; t = t->next)\n\t\t\t    ;\n\t\t\t  t->next = (yyvsp[0].redirect);\n\t\t\t  (yyval.redirect) = (yyvsp[-1].redirect);\n\t\t\t}\n#line 2547 \"y.tab.c\"\n    break;\n\n  case 60:  \n#line 782 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_simple_command ((yyvsp[0].element), (COMMAND *)NULL); }\n#line 2553 \"y.tab.c\"\n    break;\n\n  case 61:  \n#line 784 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_simple_command ((yyvsp[0].element), (yyvsp[-1].command)); }\n#line 2559 \"y.tab.c\"\n    break;\n\n  case 62:  \n#line 788 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = clean_simple_command ((yyvsp[0].command)); }\n#line 2565 \"y.tab.c\"\n    break;\n\n  case 63:  \n#line 790 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2571 \"y.tab.c\"\n    break;\n\n  case 64:  \n#line 792 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  COMMAND *tc;\n\n\t\t\t  tc = (yyvsp[-1].command);\n\t\t\t  if (tc && tc->redirects)\n\t\t\t    {\n\t\t\t      register REDIRECT *t;\n\t\t\t      for (t = tc->redirects; t->next; t = t->next)\n\t\t\t\t;\n\t\t\t      t->next = (yyvsp[0].redirect);\n\t\t\t    }\n\t\t\t  else if (tc)\n\t\t\t    tc->redirects = (yyvsp[0].redirect);\n\t\t\t  (yyval.command) = (yyvsp[-1].command);\n\t\t\t}\n#line 2591 \"y.tab.c\"\n    break;\n\n  case 65:  \n#line 808 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2597 \"y.tab.c\"\n    break;\n\n  case 66:  \n#line 810 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2603 \"y.tab.c\"\n    break;\n\n  case 67:  \n#line 814 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2609 \"y.tab.c\"\n    break;\n\n  case 68:  \n#line 816 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2615 \"y.tab.c\"\n    break;\n\n  case 69:  \n#line 818 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_while_command ((yyvsp[-3].command), (yyvsp[-1].command)); }\n#line 2621 \"y.tab.c\"\n    break;\n\n  case 70:  \n#line 820 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_until_command ((yyvsp[-3].command), (yyvsp[-1].command)); }\n#line 2627 \"y.tab.c\"\n    break;\n\n  case 71:  \n#line 822 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2633 \"y.tab.c\"\n    break;\n\n  case 72:  \n#line 824 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2639 \"y.tab.c\"\n    break;\n\n  case 73:  \n#line 826 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2645 \"y.tab.c\"\n    break;\n\n  case 74:  \n#line 828 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2651 \"y.tab.c\"\n    break;\n\n  case 75:  \n#line 830 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2657 \"y.tab.c\"\n    break;\n\n  case 76:  \n#line 832 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2663 \"y.tab.c\"\n    break;\n\n  case 77:  \n#line 834 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2669 \"y.tab.c\"\n    break;\n\n  case 78:  \n#line 838 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-4].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2678 \"y.tab.c\"\n    break;\n\n  case 79:  \n#line 843 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-4].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2687 \"y.tab.c\"\n    break;\n\n  case 80:  \n#line 848 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-5].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2696 \"y.tab.c\"\n    break;\n\n  case 81:  \n#line 853 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-5].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2705 \"y.tab.c\"\n    break;\n\n  case 82:  \n#line 858 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-8].word), REVERSE_LIST ((yyvsp[-5].word_list), WORD_LIST *), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2714 \"y.tab.c\"\n    break;\n\n  case 83:  \n#line 863 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-8].word), REVERSE_LIST ((yyvsp[-5].word_list), WORD_LIST *), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2723 \"y.tab.c\"\n    break;\n\n  case 84:  \n#line 868 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-7].word), (WORD_LIST *)NULL, (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2732 \"y.tab.c\"\n    break;\n\n  case 85:  \n#line 873 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_for_command ((yyvsp[-7].word), (WORD_LIST *)NULL, (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2741 \"y.tab.c\"\n    break;\n\n  case 86:  \n#line 880 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                                {\n\t\t\t\t  (yyval.command) = make_arith_for_command ((yyvsp[-5].word_list), (yyvsp[-1].command), arith_for_lineno);\n\t\t\t\t  if ((yyval.command) == 0) YYERROR;\n\t\t\t\t  if (word_top > 0) word_top--;\n\t\t\t\t}\n#line 2751 \"y.tab.c\"\n    break;\n\n  case 87:  \n#line 886 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                                {\n\t\t\t\t  (yyval.command) = make_arith_for_command ((yyvsp[-5].word_list), (yyvsp[-1].command), arith_for_lineno);\n\t\t\t\t  if ((yyval.command) == 0) YYERROR;\n\t\t\t\t  if (word_top > 0) word_top--;\n\t\t\t\t}\n#line 2761 \"y.tab.c\"\n    break;\n\n  case 88:  \n#line 892 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                                {\n\t\t\t\t  (yyval.command) = make_arith_for_command ((yyvsp[-3].word_list), (yyvsp[-1].command), arith_for_lineno);\n\t\t\t\t  if ((yyval.command) == 0) YYERROR;\n\t\t\t\t  if (word_top > 0) word_top--;\n\t\t\t\t}\n#line 2771 \"y.tab.c\"\n    break;\n\n  case 89:  \n#line 898 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                                {\n\t\t\t\t  (yyval.command) = make_arith_for_command ((yyvsp[-3].word_list), (yyvsp[-1].command), arith_for_lineno);\n\t\t\t\t  if ((yyval.command) == 0) YYERROR;\n\t\t\t\t  if (word_top > 0) word_top--;\n\t\t\t\t}\n#line 2781 \"y.tab.c\"\n    break;\n\n  case 90:  \n#line 906 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-4].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2790 \"y.tab.c\"\n    break;\n\n  case 91:  \n#line 911 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-4].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2799 \"y.tab.c\"\n    break;\n\n  case 92:  \n#line 916 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-5].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2808 \"y.tab.c\"\n    break;\n\n  case 93:  \n#line 921 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-5].word), add_string_to_list (\"\\\"$@\\\"\", (WORD_LIST *)NULL), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2817 \"y.tab.c\"\n    break;\n\n  case 94:  \n#line 926 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-8].word), REVERSE_LIST ((yyvsp[-5].word_list), WORD_LIST *), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2826 \"y.tab.c\"\n    break;\n\n  case 95:  \n#line 931 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-8].word), REVERSE_LIST ((yyvsp[-5].word_list), WORD_LIST *), (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2835 \"y.tab.c\"\n    break;\n\n  case 96:  \n#line 936 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-7].word), (WORD_LIST *)NULL, (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2844 \"y.tab.c\"\n    break;\n\n  case 97:  \n#line 941 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_select_command ((yyvsp[-7].word), (WORD_LIST *)NULL, (yyvsp[-1].command), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2853 \"y.tab.c\"\n    break;\n\n  case 98:  \n#line 948 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_case_command ((yyvsp[-4].word), (PATTERN_LIST *)NULL, word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2862 \"y.tab.c\"\n    break;\n\n  case 99:  \n#line 953 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_case_command ((yyvsp[-5].word), (yyvsp[-2].pattern), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2871 \"y.tab.c\"\n    break;\n\n  case 100:  \n#line 958 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_case_command ((yyvsp[-4].word), (yyvsp[-1].pattern), word_lineno[word_top]);\n\t\t\t  if (word_top > 0) word_top--;\n\t\t\t}\n#line 2880 \"y.tab.c\"\n    break;\n\n  case 101:  \n#line 965 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_function_def ((yyvsp[-4].word), (yyvsp[0].command), function_dstart, function_bstart); }\n#line 2886 \"y.tab.c\"\n    break;\n\n  case 102:  \n#line 967 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_function_def ((yyvsp[-4].word), (yyvsp[0].command), function_dstart, function_bstart); }\n#line 2892 \"y.tab.c\"\n    break;\n\n  case 103:  \n#line 969 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_function_def ((yyvsp[-1].word), (yyvsp[0].command), function_dstart, function_bstart); }\n#line 2898 \"y.tab.c\"\n    break;\n\n  case 104:  \n#line 971 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_function_def ((yyvsp[-3].word), (yyvsp[0].command), function_dstart, function_bstart); }\n#line 2904 \"y.tab.c\"\n    break;\n\n  case 105:  \n#line 975 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 2910 \"y.tab.c\"\n    break;\n\n  case 106:  \n#line 977 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  COMMAND *tc;\n\n\t\t\t  tc = (yyvsp[-1].command);\n\t\t\t   \n\t\t\t   \n\t\t\t  if (tc && tc->redirects)\n\t\t\t    {\n\t\t\t      register REDIRECT *t;\n\t\t\t      for (t = tc->redirects; t->next; t = t->next)\n\t\t\t\t;\n\t\t\t      t->next = (yyvsp[0].redirect);\n\t\t\t    }\n\t\t\t  else if (tc)\n\t\t\t    tc->redirects = (yyvsp[0].redirect);\n\t\t\t  (yyval.command) = (yyvsp[-1].command);\n\t\t\t}\n#line 2943 \"y.tab.c\"\n    break;\n\n  case 107:  \n#line 1008 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_subshell_command ((yyvsp[-1].command));\n\t\t\t  (yyval.command)->flags |= CMD_WANT_SUBSHELL;\n\t\t\t}\n#line 2952 \"y.tab.c\"\n    break;\n\n  case 108:  \n#line 1015 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = (yyvsp[-1].command);\n\t\t\t}\n#line 2960 \"y.tab.c\"\n    break;\n\n  case 109:  \n#line 1019 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = (COMMAND *)NULL;\n\t\t\t}\n#line 2968 \"y.tab.c\"\n    break;\n\n  case 110:  \n#line 1025 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_coproc_command (\"COPROC\", (yyvsp[0].command));\n\t\t\t  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;\n\t\t\t}\n#line 2977 \"y.tab.c\"\n    break;\n\n  case 111:  \n#line 1030 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  COMMAND *tc;\n\n\t\t\t  tc = (yyvsp[-1].command);\n\t\t\t  if (tc && tc->redirects)\n\t\t\t    {\n\t\t\t      register REDIRECT *t;\n\t\t\t      for (t = tc->redirects; t->next; t = t->next)\n\t\t\t\t;\n\t\t\t      t->next = (yyvsp[0].redirect);\n\t\t\t    }\n\t\t\t  else if (tc)\n\t\t\t    tc->redirects = (yyvsp[0].redirect);\n\t\t\t  (yyval.command) = make_coproc_command (\"COPROC\", (yyvsp[-1].command));\n\t\t\t  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;\n\t\t\t}\n#line 2998 \"y.tab.c\"\n    break;\n\n  case 112:  \n#line 1047 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_coproc_command ((yyvsp[-1].word)->word, (yyvsp[0].command));\n\t\t\t  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;\n\t\t\t}\n#line 3007 \"y.tab.c\"\n    break;\n\n  case 113:  \n#line 1052 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  COMMAND *tc;\n\n\t\t\t  tc = (yyvsp[-1].command);\n\t\t\t  if (tc && tc->redirects)\n\t\t\t    {\n\t\t\t      register REDIRECT *t;\n\t\t\t      for (t = tc->redirects; t->next; t = t->next)\n\t\t\t\t;\n\t\t\t      t->next = (yyvsp[0].redirect);\n\t\t\t    }\n\t\t\t  else if (tc)\n\t\t\t    tc->redirects = (yyvsp[0].redirect);\n\t\t\t  (yyval.command) = make_coproc_command ((yyvsp[-2].word)->word, (yyvsp[-1].command));\n\t\t\t  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;\n\t\t\t}\n#line 3028 \"y.tab.c\"\n    break;\n\n  case 114:  \n#line 1069 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = make_coproc_command (\"COPROC\", clean_simple_command ((yyvsp[0].command)));\n\t\t\t  (yyval.command)->flags |= CMD_WANT_SUBSHELL|CMD_COPROC_SUBSHELL;\n\t\t\t}\n#line 3037 \"y.tab.c\"\n    break;\n\n  case 115:  \n#line 1076 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_if_command ((yyvsp[-3].command), (yyvsp[-1].command), (COMMAND *)NULL); }\n#line 3043 \"y.tab.c\"\n    break;\n\n  case 116:  \n#line 1078 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_if_command ((yyvsp[-5].command), (yyvsp[-3].command), (yyvsp[-1].command)); }\n#line 3049 \"y.tab.c\"\n    break;\n\n  case 117:  \n#line 1080 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_if_command ((yyvsp[-4].command), (yyvsp[-2].command), (yyvsp[-1].command)); }\n#line 3055 \"y.tab.c\"\n    break;\n\n  case 118:  \n#line 1085 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_group_command ((yyvsp[-1].command)); }\n#line 3061 \"y.tab.c\"\n    break;\n\n  case 119:  \n#line 1089 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_arith_command ((yyvsp[0].word_list)); }\n#line 3067 \"y.tab.c\"\n    break;\n\n  case 120:  \n#line 1093 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[-1].command); }\n#line 3073 \"y.tab.c\"\n    break;\n\n  case 121:  \n#line 1097 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_if_command ((yyvsp[-2].command), (yyvsp[0].command), (COMMAND *)NULL); }\n#line 3079 \"y.tab.c\"\n    break;\n\n  case 122:  \n#line 1099 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_if_command ((yyvsp[-4].command), (yyvsp[-2].command), (yyvsp[0].command)); }\n#line 3085 \"y.tab.c\"\n    break;\n\n  case 123:  \n#line 1101 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = make_if_command ((yyvsp[-3].command), (yyvsp[-1].command), (yyvsp[0].command)); }\n#line 3091 \"y.tab.c\"\n    break;\n\n  case 125:  \n#line 1106 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyvsp[0].pattern)->next = (yyvsp[-1].pattern); (yyval.pattern) = (yyvsp[0].pattern); }\n#line 3097 \"y.tab.c\"\n    break;\n\n  case 126:  \n#line 1110 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.pattern) = make_pattern_list ((yyvsp[-2].word_list), (yyvsp[0].command)); }\n#line 3103 \"y.tab.c\"\n    break;\n\n  case 127:  \n#line 1112 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.pattern) = make_pattern_list ((yyvsp[-2].word_list), (COMMAND *)NULL); }\n#line 3109 \"y.tab.c\"\n    break;\n\n  case 128:  \n#line 1114 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.pattern) = make_pattern_list ((yyvsp[-2].word_list), (yyvsp[0].command)); }\n#line 3115 \"y.tab.c\"\n    break;\n\n  case 129:  \n#line 1116 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.pattern) = make_pattern_list ((yyvsp[-2].word_list), (COMMAND *)NULL); }\n#line 3121 \"y.tab.c\"\n    break;\n\n  case 130:  \n#line 1120 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.pattern) = (yyvsp[-1].pattern); }\n#line 3127 \"y.tab.c\"\n    break;\n\n  case 131:  \n#line 1122 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyvsp[-1].pattern)->next = (yyvsp[-2].pattern); (yyval.pattern) = (yyvsp[-1].pattern); }\n#line 3133 \"y.tab.c\"\n    break;\n\n  case 132:  \n#line 1124 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyvsp[-1].pattern)->flags |= CASEPAT_FALLTHROUGH; (yyval.pattern) = (yyvsp[-1].pattern); }\n#line 3139 \"y.tab.c\"\n    break;\n\n  case 133:  \n#line 1126 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyvsp[-1].pattern)->flags |= CASEPAT_FALLTHROUGH; (yyvsp[-1].pattern)->next = (yyvsp[-2].pattern); (yyval.pattern) = (yyvsp[-1].pattern); }\n#line 3145 \"y.tab.c\"\n    break;\n\n  case 134:  \n#line 1128 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyvsp[-1].pattern)->flags |= CASEPAT_TESTNEXT; (yyval.pattern) = (yyvsp[-1].pattern); }\n#line 3151 \"y.tab.c\"\n    break;\n\n  case 135:  \n#line 1130 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyvsp[-1].pattern)->flags |= CASEPAT_TESTNEXT; (yyvsp[-1].pattern)->next = (yyvsp[-2].pattern); (yyval.pattern) = (yyvsp[-1].pattern); }\n#line 3157 \"y.tab.c\"\n    break;\n\n  case 136:  \n#line 1134 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.word_list) = make_word_list ((yyvsp[0].word), (WORD_LIST *)NULL); }\n#line 3163 \"y.tab.c\"\n    break;\n\n  case 137:  \n#line 1136 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.word_list) = make_word_list ((yyvsp[0].word), (yyvsp[-2].word_list)); }\n#line 3169 \"y.tab.c\"\n    break;\n\n  case 138:  \n#line 1145 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = (yyvsp[0].command);\n\t\t\t  if (need_here_doc && last_read_token == '\\n')\n\t\t\t    gather_here_documents ();\n\t\t\t }\n#line 3179 \"y.tab.c\"\n    break;\n\n  case 139:  \n#line 1151 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = (yyvsp[0].command);\n\t\t\t}\n#line 3187 \"y.tab.c\"\n    break;\n\n  case 141:  \n#line 1158 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if ((yyvsp[-2].command)->type == cm_connection)\n\t\t\t    (yyval.command) = connect_async_list ((yyvsp[-2].command), (COMMAND *)NULL, '&');\n\t\t\t  else\n\t\t\t    (yyval.command) = command_connect ((yyvsp[-2].command), (COMMAND *)NULL, '&');\n\t\t\t}\n#line 3198 \"y.tab.c\"\n    break;\n\n  case 143:  \n#line 1169 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), AND_AND); }\n#line 3204 \"y.tab.c\"\n    break;\n\n  case 144:  \n#line 1171 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), OR_OR); }\n#line 3210 \"y.tab.c\"\n    break;\n\n  case 145:  \n#line 1173 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if ((yyvsp[-3].command)->type == cm_connection)\n\t\t\t    (yyval.command) = connect_async_list ((yyvsp[-3].command), (yyvsp[0].command), '&');\n\t\t\t  else\n\t\t\t    (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), '&');\n\t\t\t}\n#line 3221 \"y.tab.c\"\n    break;\n\n  case 146:  \n#line 1180 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), ';'); }\n#line 3227 \"y.tab.c\"\n    break;\n\n  case 147:  \n#line 1182 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if (parser_state & PST_CMDSUBST)\n\t\t\t    (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), '\\n');\n\t\t\t  else\n\t\t\t    (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), ';');\n\t\t\t}\n#line 3238 \"y.tab.c\"\n    break;\n\n  case 148:  \n#line 1189 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 3244 \"y.tab.c\"\n    break;\n\n  case 151:  \n#line 1197 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                { (yyval.number) = '\\n'; }\n#line 3250 \"y.tab.c\"\n    break;\n\n  case 152:  \n#line 1199 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                { (yyval.number) = ';'; }\n#line 3256 \"y.tab.c\"\n    break;\n\n  case 153:  \n#line 1201 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                { (yyval.number) = yacc_EOF; }\n#line 3262 \"y.tab.c\"\n    break;\n\n  case 156:  \n#line 1215 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = (yyvsp[0].command);\n\t\t\t  if (need_here_doc)\n\t\t\t    gather_here_documents ();\t \n\t\t\t  if ((parser_state & PST_CMDSUBST) && current_token == shell_eof_token)\n\t\t\t    {\nINTERNAL_DEBUG ((\"LEGACY: parser: command substitution simple_list1 -> simple_list\"));\n\t\t\t      global_command = (yyvsp[0].command);\n\t\t\t      eof_encountered = 0;\n\t\t\t      if (bash_input.type == st_string)\n\t\t\t\trewind_input_string ();\n\t\t\t      YYACCEPT;\n\t\t\t    }\n\t\t\t}\n#line 3281 \"y.tab.c\"\n    break;\n\n  case 157:  \n#line 1230 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if ((yyvsp[-1].command)->type == cm_connection)\n\t\t\t    (yyval.command) = connect_async_list ((yyvsp[-1].command), (COMMAND *)NULL, '&');\n\t\t\t  else\n\t\t\t    (yyval.command) = command_connect ((yyvsp[-1].command), (COMMAND *)NULL, '&');\n\t\t\t  if (need_here_doc)\n\t\t\t    gather_here_documents ();  \n\t\t\t  if ((parser_state & PST_CMDSUBST) && current_token == shell_eof_token)\n\t\t\t    {\nINTERNAL_DEBUG ((\"LEGACY: parser: command substitution simple_list1 '&' -> simple_list\"));\n\t\t\t      global_command = (yyvsp[-1].command);\n\t\t\t      eof_encountered = 0;\n\t\t\t      if (bash_input.type == st_string)\n\t\t\t\trewind_input_string ();\n\t\t\t      YYACCEPT;\n\t\t\t    }\n\t\t\t}\n#line 3303 \"y.tab.c\"\n    break;\n\n  case 158:  \n#line 1248 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  (yyval.command) = (yyvsp[-1].command);\n\t\t\t  if (need_here_doc)\n\t\t\t    gather_here_documents ();\t \n\t\t\t  if ((parser_state & PST_CMDSUBST) && current_token == shell_eof_token)\n\t\t\t    {\nINTERNAL_DEBUG ((\"LEGACY: parser: command substitution simple_list1 ';' -> simple_list\"));\n\t\t\t      global_command = (yyvsp[-1].command);\n\t\t\t      eof_encountered = 0;\n\t\t\t      if (bash_input.type == st_string)\n\t\t\t\trewind_input_string ();\n\t\t\t      YYACCEPT;\n\t\t\t    }\n\t\t\t}\n#line 3322 \"y.tab.c\"\n    break;\n\n  case 159:  \n#line 1265 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), AND_AND); }\n#line 3328 \"y.tab.c\"\n    break;\n\n  case 160:  \n#line 1267 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), OR_OR); }\n#line 3334 \"y.tab.c\"\n    break;\n\n  case 161:  \n#line 1269 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if ((yyvsp[-2].command)->type == cm_connection)\n\t\t\t    (yyval.command) = connect_async_list ((yyvsp[-2].command), (yyvsp[0].command), '&');\n\t\t\t  else\n\t\t\t    (yyval.command) = command_connect ((yyvsp[-2].command), (yyvsp[0].command), '&');\n\t\t\t}\n#line 3345 \"y.tab.c\"\n    break;\n\n  case 162:  \n#line 1276 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-2].command), (yyvsp[0].command), ';'); }\n#line 3351 \"y.tab.c\"\n    break;\n\n  case 163:  \n#line 1279 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 3357 \"y.tab.c\"\n    break;\n\n  case 164:  \n#line 1283 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 3363 \"y.tab.c\"\n    break;\n\n  case 165:  \n#line 1285 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if ((yyvsp[0].command))\n\t\t\t    (yyvsp[0].command)->flags ^= CMD_INVERT_RETURN;\t \n\t\t\t  (yyval.command) = (yyvsp[0].command);\n\t\t\t}\n#line 3373 \"y.tab.c\"\n    break;\n\n  case 166:  \n#line 1291 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  if ((yyvsp[0].command))\n\t\t\t    (yyvsp[0].command)->flags |= (yyvsp[-1].number);\n\t\t\t  (yyval.command) = (yyvsp[0].command);\n\t\t\t}\n#line 3383 \"y.tab.c\"\n    break;\n\n  case 167:  \n#line 1297 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  ELEMENT x;\n\n\t\t\t   \n\t\t\t  x.word = 0;\n\t\t\t  x.redirect = 0;\n\t\t\t  (yyval.command) = make_simple_command (x, (COMMAND *)NULL);\n\t\t\t  (yyval.command)->flags |= (yyvsp[-1].number);\n\t\t\t   \n\t\t\t  if ((yyvsp[0].number) == '\\n')\n\t\t\t    token_to_read = '\\n';\n\t\t\t  else if ((yyvsp[0].number) == ';')\n\t\t\t    token_to_read = ';';\n\t\t\t  parser_state &= ~PST_REDIRLIST;\t \n\t\t\t}\n#line 3407 \"y.tab.c\"\n    break;\n\n  case 168:  \n#line 1317 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t  ELEMENT x;\n\n\t\t\t   \n\t\t\t  x.word = 0;\n\t\t\t  x.redirect = 0;\n\t\t\t  (yyval.command) = make_simple_command (x, (COMMAND *)NULL);\n\t\t\t  (yyval.command)->flags |= CMD_INVERT_RETURN;\n\t\t\t   \n\t\t\t  if ((yyvsp[0].number) == '\\n')\n\t\t\t    token_to_read = '\\n';\n\t\t\t  if ((yyvsp[0].number) == ';')\n\t\t\t    token_to_read = ';';\n\t\t\t  parser_state &= ~PST_REDIRLIST;\t \n\t\t\t}\n#line 3432 \"y.tab.c\"\n    break;\n\n  case 169:  \n#line 1340 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), '|'); }\n#line 3438 \"y.tab.c\"\n    break;\n\n  case 170:  \n#line 1342 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        {\n\t\t\t   \n\t\t\t  COMMAND *tc;\n\t\t\t  REDIRECTEE rd, sd;\n\t\t\t  REDIRECT *r;\n\n\t\t\t  tc = (yyvsp[-3].command)->type == cm_simple ? (COMMAND *)(yyvsp[-3].command)->value.Simple : (yyvsp[-3].command);\n\t\t\t  sd.dest = 2;\n\t\t\t  rd.dest = 1;\n\t\t\t  r = make_redirection (sd, r_duplicating_output, rd, 0);\n\t\t\t  if (tc->redirects)\n\t\t\t    {\n\t\t\t      register REDIRECT *t;\n\t\t\t      for (t = tc->redirects; t->next; t = t->next)\n\t\t\t\t;\n\t\t\t      t->next = r;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    tc->redirects = r;\n\n\t\t\t  (yyval.command) = command_connect ((yyvsp[-3].command), (yyvsp[0].command), '|');\n\t\t\t}\n#line 3465 \"y.tab.c\"\n    break;\n\n  case 171:  \n#line 1365 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.command) = (yyvsp[0].command); }\n#line 3471 \"y.tab.c\"\n    break;\n\n  case 172:  \n#line 1369 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.number) = CMD_TIME_PIPELINE; }\n#line 3477 \"y.tab.c\"\n    break;\n\n  case 173:  \n#line 1371 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.number) = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }\n#line 3483 \"y.tab.c\"\n    break;\n\n  case 174:  \n#line 1373 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.number) = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }\n#line 3489 \"y.tab.c\"\n    break;\n\n  case 175:  \n#line 1375 \"/usr/local/src/chet/src/bash/src/parse.y\"\n                        { (yyval.number) = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }\n#line 3495 \"y.tab.c\"\n    break;\n\n\n#line 3499 \"y.tab.c\"\n\n      default: break;\n    }\n   \n  YY_SYMBOL_PRINT (\"-> $$ =\", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n\n  *++yyvsp = yyval;\n\n   \n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n \nyyerrlab:\n   \n  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);\n   \n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n      yyerror (YY_(\"syntax error\"));\n    }\n\n  if (yyerrstatus == 3)\n    {\n       \n\n      if (yychar <= YYEOF)\n        {\n           \n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval);\n          yychar = YYEMPTY;\n        }\n    }\n\n   \n  goto yyerrlab1;\n\n\n \nyyerrorlab:\n   \n  if (0)\n    YYERROR;\n  ++yynerrs;\n\n   \n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n \nyyerrlab1:\n  yyerrstatus = 3;       \n\n   \n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYSYMBOL_YYerror;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n       \n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  YY_ACCESSING_SYMBOL (yystate), yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n   \n  YY_SYMBOL_PRINT (\"Shifting\", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n \nyyacceptlab:\n  yyresult = 0;\n  goto yyreturnlab;\n\n\n \nyyabortlab:\n  yyresult = 1;\n  goto yyreturnlab;\n\n\n \nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  goto yyreturnlab;\n\n\n \nyyreturnlab:\n  if (yychar != YYEMPTY)\n    {\n       \n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval);\n    }\n   \n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n\n  return yyresult;\n}\n\n#line 1377 \"/usr/local/src/chet/src/bash/src/parse.y\"\n\n\n \n#define TOKEN_DEFAULT_INITIAL_SIZE 496\n#define TOKEN_DEFAULT_GROW_SIZE 512\n\n \n#define SHOULD_PROMPT() \\\n  (interactive && (bash_input.type == st_stdin || bash_input.type == st_stream))\n\n#if defined (ALIAS)\n#  define expanding_alias() (pushed_string_list && pushed_string_list->expander)\n#else\n#  define expanding_alias() 0\n#endif\n\n \nint EOF_Reached = 0;\n\n#ifdef DEBUG\nstatic void\ndebug_parser (i)\n     int i;\n{\n#if YYDEBUG != 0\n  yydebug = i;\n  yyoutstream = stdout;\n  yyerrstream = stderr;\n#endif\n}\n#endif\n\n \n\n \nint\nreturn_EOF ()\n{\n  return (EOF);\n}\n\n \nBASH_INPUT bash_input;\n\n \nvoid\ninitialize_bash_input ()\n{\n  bash_input.type = st_none;\n  FREE (bash_input.name);\n  bash_input.name = (char *)NULL;\n  bash_input.location.file = (FILE *)NULL;\n  bash_input.location.string = (char *)NULL;\n  bash_input.getter = (sh_cget_func_t *)NULL;\n  bash_input.ungetter = (sh_cunget_func_t *)NULL;\n}\n\n \nvoid\ninit_yy_io (get, unget, type, name, location)\n     sh_cget_func_t *get;\n     sh_cunget_func_t *unget;\n     enum stream_type type;\n     const char *name;\n     INPUT_STREAM location;\n{\n  bash_input.type = type;\n  FREE (bash_input.name);\n  bash_input.name = name ? savestring (name) : (char *)NULL;\n\n   \n#if defined (CRAY)\n  memcpy((char *)&bash_input.location.string, (char *)&location.string, sizeof(location));\n#else\n  bash_input.location = location;\n#endif\n  bash_input.getter = get;\n  bash_input.ungetter = unget;\n}\n\nchar *\nyy_input_name ()\n{\n  return (bash_input.name ? bash_input.name : \"stdin\");\n}\n\n \nstatic int\nyy_getc ()\n{\n  return (*(bash_input.getter)) ();\n}\n\n \nstatic int\nyy_ungetc (c)\n     int c;\n{\n  return (*(bash_input.ungetter)) (c);\n}\n\n#if defined (BUFFERED_INPUT)\n#ifdef INCLUDE_UNUSED\nint\ninput_file_descriptor ()\n{\n  switch (bash_input.type)\n    {\n    case st_stream:\n      return (fileno (bash_input.location.file));\n    case st_bstream:\n      return (bash_input.location.buffered_fd);\n    case st_stdin:\n    default:\n      return (fileno (stdin));\n    }\n}\n#endif\n#endif  \n\n \n \n \n \n \n\n#if defined (READLINE)\nchar *current_readline_prompt = (char *)NULL;\nchar *current_readline_line = (char *)NULL;\nint current_readline_line_index = 0;\n\nstatic int\nyy_readline_get ()\n{\n  SigHandler *old_sigint;\n  int line_len;\n  unsigned char c;\n\n  if (current_readline_line == 0)\n    {\n      if (bash_readline_initialized == 0)\n\tinitialize_readline ();\n\n#if defined (JOB_CONTROL)\n      if (job_control)\n\tgive_terminal_to (shell_pgrp, 0);\n#endif  \n\n      old_sigint = IMPOSSIBLE_TRAP_HANDLER;\n      if (signal_is_ignored (SIGINT) == 0)\n\t{\n\t  old_sigint = (SigHandler *)set_signal_handler (SIGINT, sigint_sighandler);\n\t}\n\n      sh_unset_nodelay_mode (fileno (rl_instream));\t \n      current_readline_line = readline (current_readline_prompt ?\n      \t\t\t\t\t  current_readline_prompt : \"\");\n\n      CHECK_TERMSIG;\n      if (signal_is_ignored (SIGINT) == 0)\n\t{\n\t  if (old_sigint != IMPOSSIBLE_TRAP_HANDLER)\n\t    set_signal_handler (SIGINT, old_sigint);\n\t}\n\n#if 0\n       \n      reset_readline_prompt ();\n#endif\n\n      if (current_readline_line == 0)\n\treturn (EOF);\n\n      current_readline_line_index = 0;\n      line_len = strlen (current_readline_line);\n\n      current_readline_line = (char *)xrealloc (current_readline_line, 2 + line_len);\n      current_readline_line[line_len++] = '\\n';\n      current_readline_line[line_len] = '\\0';\n    }\n\n  if (current_readline_line[current_readline_line_index] == 0)\n    {\n      free (current_readline_line);\n      current_readline_line = (char *)NULL;\n      return (yy_readline_get ());\n    }\n  else\n    {\n      c = current_readline_line[current_readline_line_index++];\n      return (c);\n    }\n}\n\nstatic int\nyy_readline_unget (c)\n     int c;\n{\n  if (current_readline_line_index && current_readline_line)\n    current_readline_line[--current_readline_line_index] = c;\n  return (c);\n}\n\nvoid\nwith_input_from_stdin ()\n{\n  INPUT_STREAM location;\n\n  if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)\n    {\n      location.string = current_readline_line;\n      init_yy_io (yy_readline_get, yy_readline_unget,\n\t\t  st_stdin, \"readline stdin\", location);\n    }\n}\n\n \nint\nparser_will_prompt ()\n{\n  return (current_readline_line == 0 || current_readline_line[current_readline_line_index] == 0);\n}\n  \n#else   \n\nvoid\nwith_input_from_stdin ()\n{\n  with_input_from_stream (stdin, \"stdin\");\n}\n#endif\t \n\n \n \n \n \n \n\nstatic int\nyy_string_get ()\n{\n  register char *string;\n  register unsigned char c;\n\n  string = bash_input.location.string;\n\n   \n  if (string && *string)\n    {\n      c = *string++;\n      bash_input.location.string = string;\n      return (c);\n    }\n  else\n    return (EOF);\n}\n\nstatic int\nyy_string_unget (c)\n     int c;\n{\n  *(--bash_input.location.string) = c;\n  return (c);\n}\n\nvoid\nwith_input_from_string (string, name)\n     char *string;\n     const char *name;\n{\n  INPUT_STREAM location;\n\n  location.string = string;\n  init_yy_io (yy_string_get, yy_string_unget, st_string, name, location);\n}\n\n \nvoid\nrewind_input_string ()\n{\n  int xchars;\n\n   \n  xchars = shell_input_line_len - shell_input_line_index;\n  if (bash_input.location.string[-1] == '\\n')\n    xchars++;\n\n   \n\n   \n   \n  bash_input.location.string -= xchars;\n}\n\n \n \n \n \n \n\n \n\nstatic int\nyy_stream_get ()\n{\n  int result;\n\n  result = EOF;\n  if (bash_input.location.file)\n    {\n       \n      result = getc_with_restart (bash_input.location.file);\n    }\n  return (result);\n}\n\nstatic int\nyy_stream_unget (c)\n     int c;\n{\n  return (ungetc_with_restart (c, bash_input.location.file));\n}\n\nvoid\nwith_input_from_stream (stream, name)\n     FILE *stream;\n     const char *name;\n{\n  INPUT_STREAM location;\n\n  location.file = stream;\n  init_yy_io (yy_stream_get, yy_stream_unget, st_stream, name, location);\n}\n\ntypedef struct stream_saver {\n  struct stream_saver *next;\n  BASH_INPUT bash_input;\n  int line;\n#if defined (BUFFERED_INPUT)\n  BUFFERED_STREAM *bstream;\n#endif  \n} STREAM_SAVER;\n\n \nint line_number = 0;\n\n \nint line_number_base = 0;\n\n#if defined (COND_COMMAND)\nstatic int cond_lineno;\nstatic int cond_token;\n#endif\n\nSTREAM_SAVER *stream_list = (STREAM_SAVER *)NULL;\n\nvoid\npush_stream (reset_lineno)\n     int reset_lineno;\n{\n  STREAM_SAVER *saver = (STREAM_SAVER *)xmalloc (sizeof (STREAM_SAVER));\n\n  xbcopy ((char *)&bash_input, (char *)&(saver->bash_input), sizeof (BASH_INPUT));\n\n#if defined (BUFFERED_INPUT)\n  saver->bstream = (BUFFERED_STREAM *)NULL;\n   \n  if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)\n    saver->bstream = set_buffered_stream (bash_input.location.buffered_fd,\n    \t\t\t\t\t  (BUFFERED_STREAM *)NULL);\n#endif  \n\n  saver->line = line_number;\n  bash_input.name = (char *)NULL;\n  saver->next = stream_list;\n  stream_list = saver;\n  EOF_Reached = 0;\n  if (reset_lineno)\n    line_number = 0;\n}\n\nvoid\npop_stream ()\n{\n  if (!stream_list)\n    EOF_Reached = 1;\n  else\n    {\n      STREAM_SAVER *saver = stream_list;\n\n      EOF_Reached = 0;\n      stream_list = stream_list->next;\n\n      init_yy_io (saver->bash_input.getter,\n\t\t  saver->bash_input.ungetter,\n\t\t  saver->bash_input.type,\n\t\t  saver->bash_input.name,\n\t\t  saver->bash_input.location);\n\n#if defined (BUFFERED_INPUT)\n       \n       \n      if (bash_input.type == st_bstream && bash_input.location.buffered_fd >= 0)\n\t{\n\t  if (bash_input_fd_changed)\n\t    {\n\t      bash_input_fd_changed = 0;\n\t      if (default_buffered_input >= 0)\n\t\t{\n\t\t  bash_input.location.buffered_fd = default_buffered_input;\n\t\t  saver->bstream->b_fd = default_buffered_input;\n\t\t  SET_CLOSE_ON_EXEC (default_buffered_input);\n\t\t}\n\t    }\n\t   \n\t  set_buffered_stream (bash_input.location.buffered_fd, saver->bstream);\n\t}\n#endif  \n\n      line_number = saver->line;\n\n      FREE (saver->bash_input.name);\n      free (saver);\n    }\n}\n\n \nint\nstream_on_stack (type)\n     enum stream_type type;\n{\n  register STREAM_SAVER *s;\n\n  for (s = stream_list; s; s = s->next)\n    if (s->bash_input.type == type)\n      return 1;\n  return 0;\n}\n\n \nint *\nsave_token_state ()\n{\n  int *ret;\n\n  ret = (int *)xmalloc (4 * sizeof (int));\n  ret[0] = last_read_token;\n  ret[1] = token_before_that;\n  ret[2] = two_tokens_ago;\n  ret[3] = current_token;\n  return ret;\n}\n\nvoid\nrestore_token_state (ts)\n     int *ts;\n{\n  if (ts == 0)\n    return;\n  last_read_token = ts[0];\n  token_before_that = ts[1];\n  two_tokens_ago = ts[2];\n  current_token = ts[3];\n}\n\n \n\n#define END_OF_ALIAS 0\n\n \n\n \n\n#define PSH_ALIAS\t0x01\n#define PSH_DPAREN\t0x02\n#define PSH_SOURCE\t0x04\n#define PSH_ARRAY\t0x08\n\ntypedef struct string_saver {\n  struct string_saver *next;\n  int expand_alias;   \n  char *saved_line;\n#if defined (ALIAS)\n  alias_t *expander;    \n#endif\n  size_t saved_line_size, saved_line_index, saved_line_len;\n  int saved_line_terminator;\n  int flags;\n} STRING_SAVER;\n\nSTRING_SAVER *pushed_string_list = (STRING_SAVER *)NULL;\n\n \nstatic void\npush_string (s, expand, ap)\n     char *s;\n     int expand;\n     alias_t *ap;\n{\n  STRING_SAVER *temp = (STRING_SAVER *)xmalloc (sizeof (STRING_SAVER));\n\n  temp->expand_alias = expand;\n  temp->saved_line = shell_input_line;\n  temp->saved_line_size = shell_input_line_size;\n  temp->saved_line_len = shell_input_line_len;\n  temp->saved_line_index = shell_input_line_index;\n  temp->saved_line_terminator = shell_input_line_terminator;\n  temp->flags = 0;\n#if defined (ALIAS)\n  temp->expander = ap;\n  if (ap)\n    temp->flags = PSH_ALIAS;\n#endif\n  temp->next = pushed_string_list;\n  pushed_string_list = temp;\n\n#if defined (ALIAS)\n  if (ap)\n    ap->flags |= AL_BEINGEXPANDED;\n#endif\n\n  shell_input_line = s;\n  shell_input_line_size = shell_input_line_len = STRLEN (s);\n  shell_input_line_index = 0;\n  shell_input_line_terminator = '\\0';\n#if 0\n  parser_state &= ~PST_ALEXPNEXT;\t \n#endif\n\n  set_line_mbstate ();\n}\n\n \nstatic void\npop_string ()\n{\n  STRING_SAVER *t;\n\n  FREE (shell_input_line);\n  shell_input_line = pushed_string_list->saved_line;\n  shell_input_line_index = pushed_string_list->saved_line_index;\n  shell_input_line_size = pushed_string_list->saved_line_size;\n  shell_input_line_len = pushed_string_list->saved_line_len;\n  shell_input_line_terminator = pushed_string_list->saved_line_terminator;\n\n#if defined (ALIAS)\n  if (pushed_string_list->expand_alias)\n    parser_state |= PST_ALEXPNEXT;\n  else\n    parser_state &= ~PST_ALEXPNEXT;\n#endif\n\n  t = pushed_string_list;\n  pushed_string_list = pushed_string_list->next;\n\n#if defined (ALIAS)\n  if (t->expander)\n    t->expander->flags &= ~AL_BEINGEXPANDED;\n#endif\n\n  free ((char *)t);\n\n  set_line_mbstate ();\n}\n\nstatic void\nfree_string_list ()\n{\n  register STRING_SAVER *t, *t1;\n\n  for (t = pushed_string_list; t; )\n    {\n      t1 = t->next;\n      FREE (t->saved_line);\n#if defined (ALIAS)\n      if (t->expander)\n\tt->expander->flags &= ~AL_BEINGEXPANDED;\n#endif\n      free ((char *)t);\n      t = t1;\n    }\n  pushed_string_list = (STRING_SAVER *)NULL;\n}\n\nvoid\nfree_pushed_string_input ()\n{\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  free_string_list ();\n#endif\n}\n\nint\nparser_expanding_alias ()\n{\n  return (expanding_alias ());\n}\n\nvoid\nparser_save_alias ()\n{\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  push_string ((char *)NULL, 0, (alias_t *)NULL);\n  pushed_string_list->flags = PSH_SOURCE;\t \n#else\n  ;\n#endif\n}\n\nvoid\nparser_restore_alias ()\n{\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  if (pushed_string_list)\n    pop_string ();\n#else\n  ;\n#endif\n}\n\n#if defined (ALIAS)\n \nvoid\nclear_string_list_expander (ap)\n     alias_t *ap;\n{\n  register STRING_SAVER *t;\n\n  for (t = pushed_string_list; t; t = t->next)\n    {\n      if (t->expander && t->expander == ap)\n\tt->expander = 0;\n    }\n}\n#endif\n\nvoid\nclear_shell_input_line ()\n{\n  if (shell_input_line)\n    shell_input_line[shell_input_line_index = 0] = '\\0';\n}\n\n \nstatic char *\nread_a_line (remove_quoted_newline)\n     int remove_quoted_newline;\n{\n  static char *line_buffer = (char *)NULL;\n  static int buffer_size = 0;\n  int indx, c, peekc, pass_next;\n\n#if defined (READLINE)\n  if (no_line_editing && SHOULD_PROMPT ())\n#else\n  if (SHOULD_PROMPT ())\n#endif\n    print_prompt ();\n\n  pass_next = indx = 0;\n  while (1)\n    {\n       \n      QUIT;\n\n      c = yy_getc ();\n\n       \n      if (c == 0)\n\tcontinue;\n\n       \n      if (c == EOF)\n\t{\n\t  if (interactive && bash_input.type == st_stream)\n\t    clearerr (stdin);\n\t  if (indx == 0)\n\t    return ((char *)NULL);\n\t  c = '\\n';\n\t}\n\n       \n      RESIZE_MALLOCED_BUFFER (line_buffer, indx, 2, buffer_size, 128);\n\n       \n      if (pass_next)\n\t{\n\t  line_buffer[indx++] = c;\n\t  pass_next = 0;\n\t}\n      else if (c == '\\\\' && remove_quoted_newline)\n\t{\n\t  QUIT;\n\t  peekc = yy_getc ();\n\t  if (peekc == '\\n')\n\t    {\n\t      line_number++;\n\t      continue;\t \n\t    }\n\t  else\n\t    {\n\t      yy_ungetc (peekc);\n\t      pass_next = 1;\n\t      line_buffer[indx++] = c;\t\t \n\t    }\n\t}\n      else\n\t{\n\t   \n\t  if (remove_quoted_newline && (c == CTLESC || c == CTLNUL))\n\t    line_buffer[indx++] = CTLESC;\n\t  line_buffer[indx++] = c;\n\t}\n\n      if (c == '\\n')\n\t{\n\t  line_buffer[indx] = '\\0';\n\t  return (line_buffer);\n\t}\n    }\n}\n\n \nchar *\nread_secondary_line (remove_quoted_newline)\n     int remove_quoted_newline;\n{\n  char *ret;\n  int n, c;\n\n  prompt_string_pointer = &ps2_prompt;\n  if (SHOULD_PROMPT ())\n    prompt_again (0);\n  ret = read_a_line (remove_quoted_newline);\n#if defined (HISTORY)\n  if (ret && remember_on_history && (parser_state & PST_HEREDOC))\n    {\n       \n\n      current_command_line_count++;\n      maybe_add_history (ret);\n    }\n#endif  \n  return ret;\n}\n\n \n \n \n \n \n\n \nSTRING_INT_ALIST word_token_alist[] = {\n  { \"if\", IF },\n  { \"then\", THEN },\n  { \"else\", ELSE },\n  { \"elif\", ELIF },\n  { \"fi\", FI },\n  { \"case\", CASE },\n  { \"esac\", ESAC },\n  { \"for\", FOR },\n#if defined (SELECT_COMMAND)\n  { \"select\", SELECT },\n#endif\n  { \"while\", WHILE },\n  { \"until\", UNTIL },\n  { \"do\", DO },\n  { \"done\", DONE },\n  { \"in\", IN },\n  { \"function\", FUNCTION },\n#if defined (COMMAND_TIMING)\n  { \"time\", TIME },\n#endif\n  { \"{\", '{' },\n  { \"}\", '}' },\n  { \"!\", BANG },\n#if defined (COND_COMMAND)\n  { \"[[\", COND_START },\n  { \"]]\", COND_END },\n#endif\n#if defined (COPROCESS_SUPPORT)\n  { \"coproc\", COPROC },\n#endif\n  { (char *)NULL, 0}\n};\n\n \nSTRING_INT_ALIST other_token_alist[] = {\n   \n  { \"--\", TIMEIGN },\n  { \"-p\", TIMEOPT },\n  { \"&&\", AND_AND },\n  { \"||\", OR_OR },\n  { \">>\", GREATER_GREATER },\n  { \"<<\", LESS_LESS },\n  { \"<&\", LESS_AND },\n  { \">&\", GREATER_AND },\n  { \";;\", SEMI_SEMI },\n  { \";&\", SEMI_AND },\n  { \";;&\", SEMI_SEMI_AND },\n  { \"<<-\", LESS_LESS_MINUS },\n  { \"<<<\", LESS_LESS_LESS },\n  { \"&>\", AND_GREATER },\n  { \"&>>\", AND_GREATER_GREATER },\n  { \"<>\", LESS_GREATER },\n  { \">|\", GREATER_BAR },\n  { \"|&\", BAR_AND },\n  { \"EOF\", yacc_EOF },\n   \n  { \">\", '>' },\n  { \"<\", '<' },\n  { \"-\", '-' },\n  { \"{\", '{' },\n  { \"}\", '}' },\n  { \";\", ';' },\n  { \"(\", '(' },\n  { \")\", ')' },\n  { \"|\", '|' },\n  { \"&\", '&' },\n  { \"newline\", '\\n' },\n  { (char *)NULL, 0}\n};\n\n \n\n \n\n \nstruct dstack dstack = {  (char *)NULL, 0, 0 };\n\n \nstatic struct dstack temp_dstack = { (char *)NULL, 0, 0 };\n\n \n#define current_delimiter(ds) \\\n  (ds.delimiter_depth ? ds.delimiters[ds.delimiter_depth - 1] : 0)\n\n#define push_delimiter(ds, character) \\\n  do \\\n    { \\\n      if (ds.delimiter_depth + 2 > ds.delimiter_space) \\\n\tds.delimiters = (char *)xrealloc \\\n\t  (ds.delimiters, (ds.delimiter_space += 10) * sizeof (char)); \\\n      ds.delimiters[ds.delimiter_depth] = character; \\\n      ds.delimiter_depth++; \\\n    } \\\n  while (0)\n\n#define pop_delimiter(ds)\tds.delimiter_depth--\n\n \n\n \nstatic int eol_ungetc_lookahead = 0;\n\nstatic int unquoted_backslash = 0;\n\nstatic int\nshell_getc (remove_quoted_newline)\n     int remove_quoted_newline;\n{\n  register int i;\n  int c, truncating, last_was_backslash;\n  unsigned char uc;\n\n  QUIT;\n\n  last_was_backslash = 0;\n  if (sigwinch_received)\n    {\n      sigwinch_received = 0;\n      get_new_window_size (0, (int *)0, (int *)0);\n    }\n      \n  if (eol_ungetc_lookahead)\n    {\n      c = eol_ungetc_lookahead;\n      eol_ungetc_lookahead = 0;\n      return (c);\n    }\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n   \n\n  if (!shell_input_line || ((!shell_input_line[shell_input_line_index]) &&\n\t\t\t    (pushed_string_list == (STRING_SAVER *)NULL)))\n#else  \n  if (!shell_input_line || !shell_input_line[shell_input_line_index])\n#endif  \n    {\n      line_number++;\n\n       \n      if (shell_input_line && shell_input_line_size >= 32768)\n\t{\n\t  free (shell_input_line);\n\t  shell_input_line = 0;\n\t  shell_input_line_size = 0;\n\t}\n\n    restart_read:\n\n       \n      QUIT;\n\n      i = truncating = 0;\n      shell_input_line_terminator = 0;\n\n       \n      if (interactive_shell == 0 || SHOULD_PROMPT())\n\t{\n#if defined (JOB_CONTROL)\n       \n\t  notify_and_cleanup ();\n#else  \n\t  cleanup_dead_jobs ();\n#endif  \n\t}\n\n#if defined (READLINE)\n      if (no_line_editing && SHOULD_PROMPT())\n#else\n      if (SHOULD_PROMPT())\n#endif\n\tprint_prompt ();\n\n      if (bash_input.type == st_stream)\n\tclearerr (stdin);\n\n      while (1)\n\t{\n\t  c = yy_getc ();\n\n\t   \n\t  QUIT;\n\n\t  if (c == '\\0')\n\t    {\n\t       \n\t      if (bash_input.type == st_string)\n\t\t{\n\t\t  if (i == 0)\n\t\t    shell_input_line_terminator = EOF;\n\t\t  shell_input_line[i] = '\\0';\n\t\t  c = EOF;\n\t\t  break;\n\t\t}\n\t      continue;\n\t    }\n\n\t   \n\t   \n\t   \n\t  if (shell_input_line_size > (SIZE_MAX - 256))\n\t    {\n\t      size_t n;\n\n\t      n = SIZE_MAX - i;\t \n\t      if (n <= 2)\t \n\t\t{\n\t\t  if (truncating == 0)\n\t\t    internal_warning(_(\"shell_getc: shell_input_line_size (%zu) exceeds SIZE_MAX (%lu): line truncated\"), shell_input_line_size, (unsigned long)SIZE_MAX);\n\t\t  shell_input_line[i] = '\\0';\n\t\t  truncating = 1;\n\t\t}\n\t      if (shell_input_line_size < SIZE_MAX)\n\t\t{\n\t\t  shell_input_line_size = SIZE_MAX;\n\t\t  shell_input_line = xrealloc (shell_input_line, shell_input_line_size);\n\t\t}\n\t    }\n\t  else\n\t    RESIZE_MALLOCED_BUFFER (shell_input_line, i, 2, shell_input_line_size, 256);\n\n\t  if (c == EOF)\n\t    {\n\t      if (bash_input.type == st_stream)\n\t\tclearerr (stdin);\n\n\t      if (i == 0)\n\t\tshell_input_line_terminator = EOF;\n\n\t      shell_input_line[i] = '\\0';\n\t      break;\n\t    }\n\n\t  if (truncating == 0 || c == '\\n')\n\t    shell_input_line[i++] = c;\n\n\t  if (c == '\\n')\n\t    {\n\t      shell_input_line[--i] = '\\0';\n\t      current_command_line_count++;\n\t      break;\n\t    }\n\n\t  last_was_backslash = last_was_backslash == 0 && c == '\\\\';\n\t}\n\n      shell_input_line_index = 0;\n      shell_input_line_len = i;\t\t \n\n      set_line_mbstate ();\n\n#if defined (HISTORY)\n      if (remember_on_history && shell_input_line && shell_input_line[0])\n\t{\n\t  char *expansions;\n#  if defined (BANG_HISTORY)\n\t   \n\t  if (current_delimiter (dstack) == '\\'')\n\t    history_quoting_state = '\\'';\n\t  else if (current_delimiter (dstack) == '\"')\n\t    history_quoting_state = '\"';\n\t  else\n\t    history_quoting_state = 0;\n#  endif\n\t   \n\t  expansions = pre_process_line (shell_input_line, 1, 1);\n#  if defined (BANG_HISTORY)\n\t  history_quoting_state = 0;\n#  endif\n\t  if (expansions != shell_input_line)\n\t    {\n\t      free (shell_input_line);\n\t      shell_input_line = expansions;\n\t      shell_input_line_len = shell_input_line ?\n\t\t\t\t\tstrlen (shell_input_line) : 0;\n\t      if (shell_input_line_len == 0)\n\t\tcurrent_command_line_count--;\n\n\t       \n\t      shell_input_line_size = shell_input_line_len;\n\n\t      set_line_mbstate ();\n\t    }\n\t}\n       \n      else if (remember_on_history && shell_input_line &&\n\t       shell_input_line[0] == '\\0' &&\n\t       current_command_line_count > 1)\n\t{\n\t  if (current_delimiter (dstack))\n\t     \n\t    maybe_add_history (shell_input_line);\n\t  else\n\t    {\n\t      char *hdcs;\n\t      hdcs = history_delimiting_chars (shell_input_line);\n\t      if (hdcs && hdcs[0] == ';')\n\t\tmaybe_add_history (shell_input_line);\n\t    }\n\t}\n\n#endif  \n\n      if (shell_input_line)\n\t{\n\t   \n\t  if (echo_input_at_read && (shell_input_line[0] ||\n\t\t\t\t       shell_input_line_terminator != EOF) &&\n\t\t\t\t     shell_eof_token == 0)\n\t    fprintf (stderr, \"%s\\n\", shell_input_line);\n\t}\n      else\n\t{\n\t  shell_input_line_size = 0;\n\t  prompt_string_pointer = &current_prompt_string;\n\t  if (SHOULD_PROMPT ())\n\t    prompt_again (0);\n\t  goto restart_read;\n\t}\n\n       \n      if (shell_input_line_terminator != EOF)\n\t{\n\t  if (shell_input_line_size < SIZE_MAX-3 && (shell_input_line_len+3 > shell_input_line_size))\n\t    shell_input_line = (char *)xrealloc (shell_input_line,\n\t\t\t\t\t1 + (shell_input_line_size += 2));\n\n\t   \n\t  if (bash_input.type == st_string && expanding_alias() == 0 && last_was_backslash && c == EOF && remove_quoted_newline)\n\t    shell_input_line[shell_input_line_len] = '\\\\';\n\t  else\n\t    shell_input_line[shell_input_line_len] = '\\n';\n\t  shell_input_line[shell_input_line_len + 1] = '\\0';\n\n#if defined (HANDLE_MULTIBYTE)\n\t   \n\t  EXTEND_SHELL_INPUT_LINE_PROPERTY();\n\t  shell_input_line_property[shell_input_line_len] = 1;\n#endif\n\t}\n    }\n\nnext_alias_char:\n  if (shell_input_line_index == 0)\n    unquoted_backslash = 0;\n\n  uc = shell_input_line[shell_input_line_index];\n\n  if (uc)\n    {\n      unquoted_backslash = unquoted_backslash == 0 && uc == '\\\\';\n      shell_input_line_index++;\n    }\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n   \n   \n\n   \n#ifndef OLD_ALIAS_HACK\n  if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE &&\n      pushed_string_list->flags != PSH_DPAREN &&\n      (parser_state & PST_COMMENT) == 0 &&\n      (parser_state & PST_ENDALIAS) == 0 &&\t \n      shell_input_line_index > 0 &&\n      shellblank (shell_input_line[shell_input_line_index-1]) == 0 &&\n      shell_input_line[shell_input_line_index-1] != '\\n' &&\n      unquoted_backslash == 0 &&\n      shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&\n      (current_delimiter (dstack) != '\\'' && current_delimiter (dstack) != '\"'))\n    {\n      parser_state |= PST_ENDALIAS;\n       \n      if (shell_input_line_index == shell_input_line_len && last_shell_getc_is_singlebyte == 0)\n\t{\n#if 0\n\t  EXTEND_SHELL_INPUT_LINE_PROPERTY();\n\t  shell_input_line_property[shell_input_line_len++] = 1;\n\t   \n\t  RESIZE_MALLOCED_BUFFER (shell_input_line, shell_input_line_index, 2, shell_input_line_size, 16);\n          shell_input_line[++shell_input_line_index] = '\\0';\t \n#else\n\t  shell_input_line_property[shell_input_line_index - 1] = 1;\n#endif\n\t}\n      return ' ';\t \n    }\n#endif\n\npop_alias:\n#endif  \n   \n  if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE)\n    {\n      parser_state &= ~PST_ENDALIAS;\n      pop_string ();\n      uc = shell_input_line[shell_input_line_index];\n      if (uc)\n\tshell_input_line_index++;\n    }\n\n  if MBTEST(uc == '\\\\' && remove_quoted_newline && shell_input_line[shell_input_line_index] == '\\n')\n    {\n\tif (SHOULD_PROMPT ())\n\t  prompt_again (0);\n\tline_number++;\n\n\t \n#if defined (ALIAS)\n\tif (expanding_alias () && shell_input_line[shell_input_line_index+1] == '\\0')\n\t  {\n\t    uc = 0;\n\t    goto pop_alias;\n\t  }\n\telse if (expanding_alias () && shell_input_line[shell_input_line_index+1] != '\\0')\n\t  {\n\t    shell_input_line_index++;\t \n\t    goto next_alias_char;\t \n\t  }\n\telse\n#endif \n\t  goto restart_read;\n    }\n\n  if (uc == 0 && shell_input_line_terminator == EOF)\n    return ((shell_input_line_index != 0) ? '\\n' : EOF);\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n   \n  if (uc == 0 && bash_input.type == st_string && *bash_input.location.string &&\n      pushed_string_list && pushed_string_list->flags == PSH_SOURCE &&\n      shell_input_line_terminator == 0)\n    {\n      shell_input_line_index = 0;\n      goto restart_read;\n    }\n#endif\n\n  return (uc);\n}\n\n \nstatic void\nshell_ungetc (c)\n     int c;\n{\n  if (shell_input_line && shell_input_line_index)\n    shell_input_line[--shell_input_line_index] = c;\n  else\n    eol_ungetc_lookahead = c;\n}\n\n \nvoid\nshell_ungets (s)\n     char *s;\n{\n  size_t slen, chars_left;\n\n  slen = strlen (s);\n\n  if (shell_input_line[shell_input_line_index] == '\\0')\n    {\n       \n      if (shell_input_line_size <= slen)\n\tRESIZE_MALLOCED_BUFFER (shell_input_line, shell_input_line_index, slen + 1, shell_input_line_size, 64);\n      strcpy (shell_input_line, s);\n      shell_input_line_index = 0;\n      shell_input_line_len = slen;\n      shell_input_line_terminator = 0;\n    }\n  else if (shell_input_line_index >= slen)\n    {\n       \n      while (slen > 0)\n        shell_input_line[--shell_input_line_index] = s[--slen];\n    }\n  else if (s[slen - 1] == '\\n')\n    {\n      push_string (savestring (s), 0, (alias_t *)NULL);\n       \n      return;\n    }\n  else\n    {\n       \n      INTERNAL_DEBUG ((\"shell_ungets: not at end of shell_input_line\"));\n\n      chars_left = shell_input_line_len - shell_input_line_index;\n      if (shell_input_line_size <= (slen + chars_left))\n\tRESIZE_MALLOCED_BUFFER (shell_input_line, shell_input_line_index, chars_left + slen + 1, shell_input_line_size, 64);\n      memmove (shell_input_line + slen, shell_input_line + shell_input_line_index, shell_input_line_len - shell_input_line_index);\n      strcpy (shell_input_line, s);\n      shell_input_line_index = 0;\n      shell_input_line_len = strlen (shell_input_line);\t \n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  set_line_mbstate ();\t \n#endif\n}\n\nchar *\nparser_remaining_input ()\n{\n  if (shell_input_line == 0)\n    return 0;\n  if ((int)shell_input_line_index < 0 || shell_input_line_index >= shell_input_line_len)\n    return \"\";\t \n  return (shell_input_line + shell_input_line_index);\n}\n\n#ifdef INCLUDE_UNUSED\n \nstatic void\nshell_ungetchar ()\n{\n  if (shell_input_line && shell_input_line_index)\n    shell_input_line_index--;\n}\n#endif\n\n \nstatic void\ndiscard_until (character)\n     int character;\n{\n  int c;\n\n  while ((c = shell_getc (0)) != EOF && c != character)\n    ;\n\n  if (c != EOF)\n    shell_ungetc (c);\n}\n\nvoid\nexecute_variable_command (command, vname)\n     char *command, *vname;\n{\n  char *last_lastarg;\n  sh_parser_state_t ps;\n\n  save_parser_state (&ps);\n  last_lastarg = get_string_value (\"_\");\n  if (last_lastarg)\n    last_lastarg = savestring (last_lastarg);\n\n  parse_and_execute (savestring (command), vname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOOPTIMIZE);\n\n  restore_parser_state (&ps);\n  bind_variable (\"_\", last_lastarg, 0);\n  FREE (last_lastarg);\n\n  if (token_to_read == '\\n')\t \n    token_to_read = 0;\n}\n\nvoid\npush_token (x)\n     int x;\n{\n  two_tokens_ago = token_before_that;\n  token_before_that = last_read_token;\n  last_read_token = current_token;\n\n  current_token = x;\n}\n\n \nstatic char *token = (char *)NULL;\n\n \nstatic size_t token_buffer_size;\n\n \n#define READ 0\n#define RESET 1\n#define prompt_is_ps1 \\\n      (!prompt_string_pointer || prompt_string_pointer == &ps1_prompt)\n\n \nstatic int\nyylex ()\n{\n  if (interactive && (current_token == 0 || current_token == '\\n'))\n    {\n       \n      if (prompt_is_ps1 && parse_and_execute_level == 0 && time_to_check_mail ())\n\t{\n\t  check_mail ();\n\t  reset_mail_timer ();\n\t}\n\n       \n      if (token_to_read == 0 && SHOULD_PROMPT ())\n\tprompt_again (0);\n    }\n\n  two_tokens_ago = token_before_that;\n  token_before_that = last_read_token;\n  last_read_token = current_token;\n  current_token = read_token (READ);\n\n  if ((parser_state & PST_EOFTOKEN) && current_token == shell_eof_token)\n    {\n       \n      return (current_token);\n    }\n\n  if (current_token < 0)\n#if defined (YYERRCODE) && !defined (YYUNDEF)\n    current_token = EOF_Reached ? YYEOF : YYERRCODE;\n#else\n    current_token = EOF_Reached ? YYEOF : YYUNDEF;\n#endif\n\n  return (current_token);\n}\n\n \nstatic int esacs_needed_count;\n\n \nstatic int expecting_in_token;\n\nstatic void\npush_heredoc (r)\n     REDIRECT *r;\n{\n  if (need_here_doc >= HEREDOC_MAX)\n    {\n      last_command_exit_value = EX_BADUSAGE;\n      need_here_doc = 0;\n      report_syntax_error (_(\"maximum here-document count exceeded\"));\n      reset_parser ();\n      exit_shell (last_command_exit_value);\n    }\n  redir_stack[need_here_doc++] = r;\n}\n\nvoid\ngather_here_documents ()\n{\n  int r;\n\n  r = 0;\n  here_doc_first_line = 1;\n  while (need_here_doc > 0)\n    {\n      parser_state |= PST_HEREDOC;\n      make_here_document (redir_stack[r++], line_number);\n      parser_state &= ~PST_HEREDOC;\n      need_here_doc--;\n      redir_stack[r - 1] = 0;\t\t \n    }\n  here_doc_first_line = 0;\t\t \n}\n\n \nstatic int open_brace_count;\n\n \n\n \n#define parsing_redirection(token) \\\n  (token == '<' || token == '>' || \\\n   token == GREATER_GREATER || token == GREATER_BAR || \\\n   token == LESS_GREATER || token == LESS_LESS_MINUS || \\\n   token == LESS_LESS || token == LESS_LESS_LESS || \\\n   token == LESS_AND || token == GREATER_AND || token == AND_GREATER)\n\n \n#define command_token_position(token) \\\n  (((token) == ASSIGNMENT_WORD) || \\\n   ((parser_state&PST_REDIRLIST) && parsing_redirection(token) == 0) || \\\n   ((token) != SEMI_SEMI && (token) != SEMI_AND && (token) != SEMI_SEMI_AND && reserved_word_acceptable(token)))\n\n \n#define assignment_acceptable(token) \\\n  (command_token_position(token) && ((parser_state & PST_CASEPAT) == 0))\n\n \n#define CHECK_FOR_RESERVED_WORD(tok) \\\n  do { \\\n    if (!dollar_present && !quoted && \\\n\treserved_word_acceptable (last_read_token)) \\\n      { \\\n\tint i; \\\n\tfor (i = 0; word_token_alist[i].word != (char *)NULL; i++) \\\n\t  if (STREQ (tok, word_token_alist[i].word)) \\\n\t    { \\\n\t      if ((parser_state & PST_CASEPAT) && (word_token_alist[i].token != ESAC)) \\\n\t\tbreak; \\\n\t      if (word_token_alist[i].token == TIME && time_command_acceptable () == 0) \\\n\t\tbreak; \\\n\t      if ((parser_state & PST_CASEPAT) && last_read_token == '|' && word_token_alist[i].token == ESAC) \\\n\t\tbreak;   \\\n\t      if ((parser_state & PST_CASEPAT) && last_read_token == '(' && word_token_alist[i].token == ESAC)   \\\n\t\tbreak;   \\\n\t      if (word_token_alist[i].token == ESAC) { \\\n\t\tparser_state &= ~(PST_CASEPAT|PST_CASESTMT); \\\n\t\tesacs_needed_count--; \\\n\t      } else if (word_token_alist[i].token == CASE) \\\n\t\tparser_state |= PST_CASESTMT; \\\n\t      else if (word_token_alist[i].token == COND_END) \\\n\t\tparser_state &= ~(PST_CONDCMD|PST_CONDEXPR); \\\n\t      else if (word_token_alist[i].token == COND_START) \\\n\t\tparser_state |= PST_CONDCMD; \\\n\t      else if (word_token_alist[i].token == '{') \\\n\t\topen_brace_count++; \\\n\t      else if (word_token_alist[i].token == '}' && open_brace_count) \\\n\t\topen_brace_count--; \\\n\t      return (word_token_alist[i].token); \\\n\t    } \\\n      } \\\n  } while (0)\n\n#if defined (ALIAS)\n\n     \n\nstatic char *\nmk_alexpansion (s)\n     char *s;\n{\n  int l;\n  char *r;\n\n  l = strlen (s);\n  r = xmalloc (l + 2);\n  strcpy (r, s);\n#ifdef OLD_ALIAS_HACK\n   \n   \n  if (l > 0 && r[l - 1] != ' ' && r[l - 1] != '\\n' && shellmeta(r[l - 1]) == 0)\n    r[l++] = ' ';\n#endif\n  r[l] = '\\0';\n  return r;\n}\n\nstatic int\nalias_expand_token (tokstr)\n     char *tokstr;\n{\n  char *expanded;\n  alias_t *ap;\n\n#if 0\n  if (((parser_state & PST_ALEXPNEXT) || command_token_position (last_read_token)) &&\n\t(parser_state & PST_CASEPAT) == 0)\n#else\n  if ((parser_state & PST_ALEXPNEXT) || assignment_acceptable (last_read_token))\n#endif\n    {\n      ap = find_alias (tokstr);\n\n       \n      if (ap && (ap->flags & AL_BEINGEXPANDED))\n\treturn (NO_EXPANSION);\n\n#ifdef OLD_ALIAS_HACK\n       \n#endif\n      expanded = ap ? mk_alexpansion (ap->value) : (char *)NULL;\n\n      if (expanded)\n\t{\n\t  push_string (expanded, ap->flags & AL_EXPANDNEXT, ap);\n\t  return (RE_READ_TOKEN);\n\t}\n      else\n\t \n\treturn (NO_EXPANSION);\n    }\n  return (NO_EXPANSION);\n}\n#endif  \n\nstatic int\ntime_command_acceptable ()\n{\n#if defined (COMMAND_TIMING)\n  int i;\n\n  if (posixly_correct && shell_compatibility_level > 41)\n    {\n       \n      i = shell_input_line_index;\n      while (i < shell_input_line_len && (shell_input_line[i] == ' ' || shell_input_line[i] == '\\t'))\n        i++;\n      if (shell_input_line[i] == '-')\n\treturn 0;\n    }\n\n  switch (last_read_token)\n    {\n    case 0:\n    case ';':\n    case '\\n':\n      if (token_before_that == '|')\n\treturn (0);\n       \n    case AND_AND:\n    case OR_OR:\n    case '&':\n    case WHILE:\n    case DO:\n    case UNTIL:\n    case IF:\n    case THEN:\n    case ELIF:\n    case ELSE:\n    case '{':\t\t \n    case '(':\t\t \n    case ')':\t\t \n    case BANG:\t\t \n    case TIME:\t\t \n    case TIMEOPT:\t \n    case TIMEIGN:\t \n    case DOLPAREN:\n      return 1;\n    default:\n      return 0;\n    }\n#else\n  return 0;\n#endif  \n}\n\n \n\nstatic int\nspecial_case_tokens (tokstr)\n     char *tokstr;\n{\n   \n  if ((last_read_token == WORD) &&\n#if defined (SELECT_COMMAND)\n      ((token_before_that == FOR) || (token_before_that == CASE) || (token_before_that == SELECT)) &&\n#else\n      ((token_before_that == FOR) || (token_before_that == CASE)) &&\n#endif\n      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))\n    {\n      if (token_before_that == CASE)\n\t{\n\t  parser_state |= PST_CASEPAT;\n\t  esacs_needed_count++;\n\t}\n      if (expecting_in_token)\n\texpecting_in_token--;\n      return (IN);\n    }\n\n   \n   \n  if (expecting_in_token && (last_read_token == WORD || last_read_token == '\\n') &&\n      (tokstr[0] == 'i' && tokstr[1] == 'n' && tokstr[2] == 0))\n    {\n      if (parser_state & PST_CASESTMT)\n\t{\n\t  parser_state |= PST_CASEPAT;\n\t  esacs_needed_count++;\n\t}\n      expecting_in_token--;\n      return (IN);\n    }\n   \n  else if (expecting_in_token && (last_read_token == '\\n' || last_read_token == ';') &&\n    (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\\0'))\n    {\n      expecting_in_token--;\n      return (DO);\n    }\n\n   \n  if (last_read_token == WORD &&\n#if defined (SELECT_COMMAND)\n      (token_before_that == FOR || token_before_that == SELECT) &&\n#else\n      (token_before_that == FOR) &&\n#endif\n      (tokstr[0] == 'd' && tokstr[1] == 'o' && tokstr[2] == '\\0'))\n    {\n      if (expecting_in_token)\n\texpecting_in_token--;\n      return (DO);\n    }\n\n   \n  if (esacs_needed_count)\n    {\n      if (last_read_token == IN && STREQ (tokstr, \"esac\"))\n\t{\n\t  esacs_needed_count--;\n\t  parser_state &= ~PST_CASEPAT;\n\t  return (ESAC);\n\t}\n    }\n\n   \n  if (parser_state & PST_ALLOWOPNBRC)\n    {\n      parser_state &= ~PST_ALLOWOPNBRC;\n      if (tokstr[0] == '{' && tokstr[1] == '\\0')\t\t \n\t{\n\t  open_brace_count++;\n\t  function_bstart = line_number;\n\t  return ('{');\t\t\t\t\t \n\t}\n    }\n\n   \n  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == 'd' && tokstr[1] == 'o' && !tokstr[2])\n    return (DO);\n  if (last_read_token == ARITH_FOR_EXPRS && tokstr[0] == '{' && tokstr[1] == '\\0')\t \n    {\n      open_brace_count++;\n      return ('{');\t\t\t \n    }\n\n  if (open_brace_count && reserved_word_acceptable (last_read_token) && tokstr[0] == '}' && !tokstr[1])\n    {\n      open_brace_count--;\t\t \n      return ('}');\n    }\n\n#if defined (COMMAND_TIMING)\n   \n  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == 'p' && !tokstr[2])\n    return (TIMEOPT);\n   \n  if (last_read_token == TIME && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])\n    return (TIMEIGN);\n   \n  if (last_read_token == TIMEOPT && tokstr[0] == '-' && tokstr[1] == '-' && !tokstr[2])\n    return (TIMEIGN);\n#endif\n\n#if defined (COND_COMMAND)  \n  if ((parser_state & PST_CONDEXPR) && tokstr[0] == ']' && tokstr[1] == ']' && tokstr[2] == '\\0')\n    return (COND_END);\n#endif\n\n  return (-1);\n}\n\n \nvoid\nreset_parser ()\n{\n  dstack.delimiter_depth = 0;\t \n  open_brace_count = 0;\n\n#if defined (EXTENDED_GLOB)\n   \n  if (parser_state & (PST_EXTPAT|PST_CMDSUBST))\n    extended_glob = extglob_flag;\n#endif\n  if (parser_state & (PST_CMDSUBST|PST_STRING))\n    expand_aliases = expaliases_flag;\n\n  parser_state = 0;\n  here_doc_first_line = 0;\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  if (pushed_string_list)\n    free_string_list ();\n#endif  \n\n   \n  if (shell_input_line)\n    {\n      free (shell_input_line);\n      shell_input_line = (char *)NULL;\n      shell_input_line_size = shell_input_line_index = 0;\n    }\n\n  FREE (word_desc_to_read);\n  word_desc_to_read = (WORD_DESC *)NULL;\n\n  eol_ungetc_lookahead = 0;\n\n   \n  need_here_doc = 0;\n  redir_stack[0] = 0;\n  esacs_needed_count = expecting_in_token = 0;\n\n  current_token = '\\n';\t\t \n  last_read_token = '\\n';\n  token_to_read = '\\n';\n}\n\nvoid\nreset_readahead_token ()\n{\n  if (token_to_read == '\\n')\n    token_to_read = 0;\n}\n\n \nstatic int\nread_token (command)\n     int command;\n{\n  int character;\t\t \n  int peek_char;\t\t \n  int result;\t\t\t \n\n  if (command == RESET)\n    {\n      reset_parser ();\n      return ('\\n');\n    }\n\n  if (token_to_read)\n    {\n      result = token_to_read;\n      if (token_to_read == WORD || token_to_read == ASSIGNMENT_WORD)\n\t{\n\t  yylval.word = word_desc_to_read;\n\t  word_desc_to_read = (WORD_DESC *)NULL;\n\t}\n      token_to_read = 0;\n      return (result);\n    }\n\n#if defined (COND_COMMAND)\n  if ((parser_state & (PST_CONDCMD|PST_CONDEXPR)) == PST_CONDCMD)\n    {\n      cond_lineno = line_number;\n      parser_state |= PST_CONDEXPR;\n      yylval.command = parse_cond_command ();\n      if (cond_token != COND_END)\n\t{\n\t  cond_error ();\n\t  return (-1);\n\t}\n      token_to_read = COND_END;\n      parser_state &= ~(PST_CONDEXPR|PST_CONDCMD);\n      return (COND_CMD);\n    }\n#endif\n\n#if defined (ALIAS)\n   \n re_read_token:\n#endif  \n\n   \n  while ((character = shell_getc (1)) != EOF && shellblank (character))\n    ;\n\n  if (character == EOF)\n    {\n      EOF_Reached = 1;\n      return (yacc_EOF);\n    }\n\n   \n  if (character == '\\0' && bash_input.type == st_string && expanding_alias() == 0)\n    {\n      INTERNAL_DEBUG ((\"shell_getc: bash_input.location.string = `%s'\", bash_input.location.string));\n      EOF_Reached = 1;\n      return (yacc_EOF);\n    }\n\n  if MBTEST(character == '#' && (!interactive || interactive_comments))\n    {\n       \n      parser_state |= PST_COMMENT;\n      discard_until ('\\n');\n      shell_getc (0);\n      parser_state &= ~PST_COMMENT;\n      character = '\\n';\t \n    }\n\n  if MBTEST(character == '\\n')\n    {\n       \n      if (need_here_doc)\n\tgather_here_documents ();\n\n#if defined (ALIAS)\n      parser_state &= ~PST_ALEXPNEXT;\n#endif  \n\n      parser_state &= ~PST_ASSIGNOK;\n\n      return (character);\n    }\n\n  if (parser_state & PST_REGEXP)\n    goto tokword;\n\n   \n  if MBTEST(shellmeta (character))\n    {\n#if defined (ALIAS)\n       \n      if (character == '<' || character == '>')\n\tparser_state &= ~PST_ALEXPNEXT;\n#endif  \n\n      parser_state &= ~PST_ASSIGNOK;\n\n       \n      if ((parser_state & PST_CMDSUBST) && character == shell_eof_token)\n\tpeek_char = shell_getc (0);\n      else\n\tpeek_char = shell_getc (1);\n\n      if MBTEST(character == peek_char)\n\t{\n\t  switch (character)\n\t    {\n\t    case '<':\n\t       \n\t      peek_char = shell_getc (1);\n\t      if MBTEST(peek_char == '-')\n\t\treturn (LESS_LESS_MINUS);\n\t      else if MBTEST(peek_char == '<')\n\t\treturn (LESS_LESS_LESS);\n\t      else\n\t\t{\n\t\t  shell_ungetc (peek_char);\n\t\t  return (LESS_LESS);\n\t\t}\n\n\t    case '>':\n\t      return (GREATER_GREATER);\n\n\t    case ';':\n\t      parser_state |= PST_CASEPAT;\n#if defined (ALIAS)\n\t      parser_state &= ~PST_ALEXPNEXT;\n#endif  \n\n\t      peek_char = shell_getc (1);\n\t      if MBTEST(peek_char == '&')\n\t\treturn (SEMI_SEMI_AND);\n\t      else\n\t\t{\n\t\t  shell_ungetc (peek_char);\n\t\t  return (SEMI_SEMI);\n\t\t}\n\n\t    case '&':\n\t      return (AND_AND);\n\n\t    case '|':\n\t      return (OR_OR);\n\n#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)\n\t    case '(':\t\t \n\t      result = parse_dparen (character);\n\t      if (result == -2)\n\t        break;\n\t      else\n\t        return result;\n#endif\n\t    }\n\t}\n      else if MBTEST(character == '<' && peek_char == '&')\n\treturn (LESS_AND);\n      else if MBTEST(character == '>' && peek_char == '&')\n\treturn (GREATER_AND);\n      else if MBTEST(character == '<' && peek_char == '>')\n\treturn (LESS_GREATER);\n      else if MBTEST(character == '>' && peek_char == '|')\n\treturn (GREATER_BAR);\n      else if MBTEST(character == '&' && peek_char == '>')\n\t{\n\t  peek_char = shell_getc (1);\n\t  if MBTEST(peek_char == '>')\n\t    return (AND_GREATER_GREATER);\n\t  else\n\t    {\n\t      shell_ungetc (peek_char);\n\t      return (AND_GREATER);\n\t    }\n\t}\n      else if MBTEST(character == '|' && peek_char == '&')\n\treturn (BAR_AND);\n      else if MBTEST(character == ';' && peek_char == '&')\n\t{\n\t  parser_state |= PST_CASEPAT;\n#if defined (ALIAS)\n\t  parser_state &= ~PST_ALEXPNEXT;\n#endif  \n\t  return (SEMI_AND);\n\t}\n\n      shell_ungetc (peek_char);\n\n       \n      if MBTEST(character == ')' && last_read_token == '(' && token_before_that == WORD)\n\t{\n\t  parser_state |= PST_ALLOWOPNBRC;\n#if defined (ALIAS)\n\t  parser_state &= ~PST_ALEXPNEXT;\n#endif  \n\t  function_dstart = line_number;\n\t}\n\n       \n      if MBTEST(character == '(' && (parser_state & PST_CASEPAT) == 0)  \n\tparser_state |= PST_SUBSHELL;\n       \n      else if MBTEST((parser_state & PST_CASEPAT) && character == ')')\n\tparser_state &= ~PST_CASEPAT;\n       \n      else if MBTEST((parser_state & PST_SUBSHELL) && character == ')')\n\tparser_state &= ~PST_SUBSHELL;\n\n#if defined (PROCESS_SUBSTITUTION)\n       \n      if MBTEST((character != '>' && character != '<') || peek_char != '(')  \n#endif  \n\treturn (character);\n    }\n\n   \n  if MBTEST(character == '-' && (last_read_token == LESS_AND || last_read_token == GREATER_AND))\n    return (character);\n\ntokword:\n   \n  result = read_token_word (character);\n#if defined (ALIAS)\n  if (result == RE_READ_TOKEN)\n    goto re_read_token;\n#endif\n  return result;\n}\n\n \n#define P_FIRSTCLOSE\t0x0001\n#define P_ALLOWESC\t0x0002\n#define P_DQUOTE\t0x0004\n#define P_COMMAND\t0x0008\t \n#define P_BACKQUOTE\t0x0010\t \n#define P_ARRAYSUB\t0x0020\t \n#define P_DOLBRACE\t0x0040\t \n#define P_ARITH\t\t0x0080\t \n\n \n#define LEX_WASDOL\t0x0001\n#define LEX_CKCOMMENT\t0x0002\n#define LEX_INCOMMENT\t0x0004\n#define LEX_PASSNEXT\t0x0008\n#define LEX_RESWDOK\t0x0010\n#define LEX_CKCASE\t0x0020\n#define LEX_INCASE\t0x0040\n#define LEX_INHEREDOC\t0x0080\n#define LEX_HEREDELIM\t0x0100\t\t \n#define LEX_STRIPDOC\t0x0200\t\t \n#define LEX_QUOTEDDOC\t0x0400\t\t \n#define LEX_INWORD\t0x0800\n#define LEX_GTLT\t0x1000\n#define LEX_CKESAC\t0x2000\t\t \n#define LEX_CASEWD\t0x4000\t\t \n#define LEX_PATLIST\t0x8000\t\t \n\n#define COMSUB_META(ch)\t\t((ch) == ';' || (ch) == '&' || (ch) == '|')\n\n#define CHECK_NESTRET_ERROR() \\\n  do { \\\n    if (nestret == &matched_pair_error) \\\n      { \\\n\tfree (ret); \\\n\treturn &matched_pair_error; \\\n      } \\\n  } while (0)\n\n#define APPEND_NESTRET() \\\n  do { \\\n    if (nestlen) \\\n      { \\\n\tRESIZE_MALLOCED_BUFFER (ret, retind, nestlen, retsize, 64); \\\n\tstrcpy (ret + retind, nestret); \\\n\tretind += nestlen; \\\n      } \\\n  } while (0)\n\nstatic char matched_pair_error;\n\nstatic char *\nparse_matched_pair (qc, open, close, lenp, flags)\n     int qc;\t \n     int open, close;\n     int *lenp, flags;\n{\n  int count, ch, prevch, tflags;\n  int nestlen, ttranslen, start_lineno;\n  char *ret, *nestret, *ttrans;\n  int retind, retsize, rflags;\n  int dolbrace_state;\n\n  dolbrace_state = (flags & P_DOLBRACE) ? DOLBRACE_PARAM : 0;\n\n \n  count = 1;\n  tflags = 0;\n\n  if ((flags & P_COMMAND) && qc != '`' && qc != '\\'' && qc != '\"' && (flags & P_DQUOTE) == 0)\n    tflags |= LEX_CKCOMMENT;\n\n   \n  rflags = (qc == '\"') ? P_DQUOTE : (flags & P_DQUOTE);\n\n  ret = (char *)xmalloc (retsize = 64);\n  retind = 0;\n\n  start_lineno = line_number;\n  ch = EOF;\t\t \n  while (count)\n    {\n      prevch = ch;\n      ch = shell_getc (qc != '\\'' && (tflags & (LEX_PASSNEXT)) == 0);\n\n      if (ch == EOF)\n\t{\n\t  free (ret);\n\t  parser_error (start_lineno, _(\"unexpected EOF while looking for matching `%c'\"), close);\n\t  EOF_Reached = 1;\t \n\t  parser_state |= PST_NOERROR;   \n\t  return (&matched_pair_error);\n\t}\n\n       \n      if MBTEST(ch == '\\n' && SHOULD_PROMPT ())\n\tprompt_again (0);\n\n       \n      if (tflags & LEX_INCOMMENT)\n\t{\n\t   \n\t  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);\n\t  ret[retind++] = ch;\n\n\t  if MBTEST(ch == '\\n')\n\t    tflags &= ~LEX_INCOMMENT;\n\n\t  continue;\n\t}\n\n       \n      else if MBTEST((tflags & LEX_CKCOMMENT) && (tflags & LEX_INCOMMENT) == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\\n' || shellblank (ret[retind - 1])))\n\ttflags |= LEX_INCOMMENT;\n\n      if (tflags & LEX_PASSNEXT)\t\t \n\t{\n\t  tflags &= ~LEX_PASSNEXT;\n\t   \n\t  if MBTEST(qc != '\\'' && ch == '\\n')\t \n\t    {\n\t      if (retind > 0)\n\t\tretind--;\t \n\t      continue;\n\t    }\n\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);\n\t  if MBTEST(ch == CTLESC)\n\t    ret[retind++] = CTLESC;\n\t  ret[retind++] = ch;\n\t  continue;\n\t}\n       \n      else if MBTEST((parser_state & PST_REPARSE) && open == '\\'' && (ch == CTLESC || ch == CTLNUL))\n\t{\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);\n\t  ret[retind++] = ch;\n\t  continue;\n\t}\n      else if MBTEST(ch == CTLESC || ch == CTLNUL)\t \n\t{\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 64);\n\t  ret[retind++] = CTLESC;\n\t  ret[retind++] = ch;\n\t  continue;\n\t}\n      else if MBTEST(ch == close)\t\t \n\tcount--;\n       \n      else if MBTEST(open != close && (tflags & LEX_WASDOL) && open == '{' && ch == open)  \n\tcount++;\n      else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)\t \n\tcount++;\n\n       \n      RESIZE_MALLOCED_BUFFER (ret, retind, 1, retsize, 64);\n      ret[retind++] = ch;\n\n       \n      if (count == 0)\n\tbreak;\n\n      if (open == '\\'')\t\t\t \n\t{\n\t  if MBTEST((flags & P_ALLOWESC) && ch == '\\\\')\n\t    tflags |= LEX_PASSNEXT;\n\t  continue;\n\t}\n\n      if MBTEST(ch == '\\\\')\t\t\t \n\ttflags |= LEX_PASSNEXT;\n\n       \n       \n      if (flags & P_DOLBRACE)\n        {\n           \n\t  if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '%' && retind > 1)\n\t    dolbrace_state = DOLBRACE_QUOTE;\n           \n\t  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '#' && retind > 1)\n\t    dolbrace_state = DOLBRACE_QUOTE;\n           \n\t  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '/' && retind > 1)\n\t    dolbrace_state = DOLBRACE_QUOTE2;\t \n           \n\t  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == '^' && retind > 1)\n\t    dolbrace_state = DOLBRACE_QUOTE;\n           \n\t  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && ch == ',' && retind > 1)\n\t    dolbrace_state = DOLBRACE_QUOTE;\n\t  else if MBTEST(dolbrace_state == DOLBRACE_PARAM && strchr (\"#%^,~:-=?+/\", ch) != 0)\n\t    dolbrace_state = DOLBRACE_OP;\n\t  else if MBTEST(dolbrace_state == DOLBRACE_OP && strchr (\"#%^,~:-=?+/\", ch) == 0)\n\t    dolbrace_state = DOLBRACE_WORD;\n        }\n\n       \n       \n      if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2 && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\\'')\n\tcontinue;\n\n       \n      if (open != close)\t\t \n\t{\n\t  if MBTEST(shellquote (ch))\n\t    {\n\t       \n\t      push_delimiter (dstack, ch);\n\t      if MBTEST((tflags & LEX_WASDOL) && ch == '\\'')\t \n\t\tnestret = parse_matched_pair (ch, ch, ch, &nestlen, P_ALLOWESC|rflags);\n\t      else\n\t\tnestret = parse_matched_pair (ch, ch, ch, &nestlen, rflags);\n\t      pop_delimiter (dstack);\n\t      CHECK_NESTRET_ERROR ();\n\n\t      if MBTEST((tflags & LEX_WASDOL) && ch == '\\'' && (extended_quote || (rflags & P_DQUOTE) == 0 || dolbrace_state == DOLBRACE_QUOTE || dolbrace_state == DOLBRACE_QUOTE2))\n\t\t{\n\t\t   \n\t\t   \n\t\t  ttrans = ansiexpand (nestret, 0, nestlen - 1, &ttranslen);\n\t\t  free (nestret);\n\n\t\t   \n\t\t   \n\t\t  if ((shell_compatibility_level > 42) && (rflags & P_DQUOTE) && (dolbrace_state == DOLBRACE_QUOTE2 || dolbrace_state == DOLBRACE_QUOTE) && (flags & P_DOLBRACE))\n\t\t    {\n\t\t      nestret = sh_single_quote (ttrans);\n\t\t      free (ttrans);\n\t\t      nestlen = strlen (nestret);\n\t\t    }\n#if 0  \n\t\t   \n\t\t  else if ((rflags & P_DQUOTE) && (dolbrace_state == DOLBRACE_PARAM) && (flags & P_DOLBRACE))\n\t\t    {\n\t\t      nestret = sh_single_quote (ttrans);\n\t\t      free (ttrans);\n\t\t      nestlen = strlen (nestret);\n\t\t    }\n#endif\n\t\t  else if ((rflags & P_DQUOTE) == 0)\n\t\t    {\n\t\t      nestret = sh_single_quote (ttrans);\n\t\t      free (ttrans);\n\t\t      nestlen = strlen (nestret);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t       \n\t\t      nestret = ttrans;\n\t\t      nestlen = ttranslen;\n\t\t    }\n\t\t  retind -= 2;\t\t \n\t\t}\n#if defined (TRANSLATABLE_STRINGS)\n\t      else if MBTEST((tflags & LEX_WASDOL) && ch == '\"' && (extended_quote || (rflags & P_DQUOTE) == 0))\n\t\t{\n\t\t   \n\t\t   \n\t\t  ttrans = locale_expand (nestret, 0, nestlen - 1, start_lineno, &ttranslen);\n\t\t  free (nestret);\n\n\t\t   \n\t\t  if (singlequote_translations &&\n\t\t        ((nestlen - 1) != ttranslen || STREQN (nestret, ttrans, ttranslen) == 0))\n\t\t    {\n\t\t      if ((rflags & P_DQUOTE) == 0)\n\t\t\tnestret = sh_single_quote (ttrans);\n\t\t      else if ((rflags & P_DQUOTE) && (dolbrace_state == DOLBRACE_QUOTE2) && (flags & P_DOLBRACE))\n\t\t\tnestret = sh_single_quote (ttrans);\n\t\t      else\n\t\t\t \n\t\t\tnestret = sh_backslash_quote_for_double_quotes (ttrans, 0);\n\t\t    }\n\t\t  else\n\t\t    nestret = sh_mkdoublequoted (ttrans, ttranslen, 0);\n\t\t  free (ttrans);\n\t\t  nestlen = strlen (nestret);\n\t\t  retind -= 2;\t\t \n\t\t}\n#endif  \n\n\t      APPEND_NESTRET ();\n\t      FREE (nestret);\n\t    }\n\t  else if ((flags & (P_ARRAYSUB|P_DOLBRACE)) && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))\t \n\t    goto parse_dollar_word;\n\t  else if ((flags & P_ARITH) && (tflags & LEX_WASDOL) && ch == '(')  \n\t     \n\t    goto parse_dollar_word;\n#if defined (PROCESS_SUBSTITUTION)\n\t   \n\t  else if ((flags & (P_ARRAYSUB|P_DOLBRACE)) && (tflags & LEX_GTLT) && (ch == '('))\t \n\t    goto parse_dollar_word;\n#endif\n\t}\n       \n       \n      else if MBTEST(open == '\"' && ch == '`')\n\t{\n\t  nestret = parse_matched_pair (0, '`', '`', &nestlen, rflags);\n\n\t  CHECK_NESTRET_ERROR ();\n\t  APPEND_NESTRET ();\n\n\t  FREE (nestret);\n\t}\n      else if MBTEST(open != '`' && (tflags & LEX_WASDOL) && (ch == '(' || ch == '{' || ch == '['))\t \n\t \n\t{\nparse_dollar_word:\n\t  if (open == ch)\t \n\t    count--;\n\t  if (ch == '(')\t\t \n\t    nestret = parse_comsub (0, '(', ')', &nestlen, (rflags|P_COMMAND) & ~P_DQUOTE);\n\t  else if (ch == '{')\t\t \n\t    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|P_DOLBRACE|rflags);\n\t  else if (ch == '[')\t\t \n\t    nestret = parse_matched_pair (0, '[', ']', &nestlen, rflags|P_ARITH);\n\n\t  CHECK_NESTRET_ERROR ();\n\t  APPEND_NESTRET ();\n\n\t  FREE (nestret);\n\t}\n#if defined (PROCESS_SUBSTITUTION)\n      if MBTEST((ch == '<' || ch == '>') && (tflags & LEX_GTLT) == 0)\n\ttflags |= LEX_GTLT;\n      else\n\ttflags &= ~LEX_GTLT;\n#endif\n      if MBTEST(ch == '$' && (tflags & LEX_WASDOL) == 0)\n\ttflags |= LEX_WASDOL;\n      else\n\ttflags &= ~LEX_WASDOL;\n    }\n\n  ret[retind] = '\\0';\n  if (lenp)\n    *lenp = retind;\n \n  return ret;\n}\n\n#if defined (DEBUG)\nstatic void\ndump_tflags (flags)\n     int flags;\n{\n  int f;\n\n  f = flags;\n  fprintf (stderr, \"%d -> \", f);\n  if (f & LEX_WASDOL)\n    {\n      f &= ~LEX_WASDOL;\n      fprintf (stderr, \"LEX_WASDOL%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_CKCOMMENT)\n    {\n      f &= ~LEX_CKCOMMENT;\n      fprintf (stderr, \"LEX_CKCOMMENT%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_INCOMMENT)\n    {\n      f &= ~LEX_INCOMMENT;\n      fprintf (stderr, \"LEX_INCOMMENT%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_PASSNEXT)\n    {\n      f &= ~LEX_PASSNEXT;\n      fprintf (stderr, \"LEX_PASSNEXT%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_RESWDOK)\n    {\n      f &= ~LEX_RESWDOK;\n      fprintf (stderr, \"LEX_RESWDOK%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_CKCASE)\n    {\n      f &= ~LEX_CKCASE;\n      fprintf (stderr, \"LEX_CKCASE%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_CKESAC)\n    {\n      f &= ~LEX_CKESAC;\n      fprintf (stderr, \"LEX_CKESAC%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_INCASE)\n    {\n      f &= ~LEX_INCASE;\n      fprintf (stderr, \"LEX_INCASE%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_CASEWD)\n    {\n      f &= ~LEX_CASEWD;\n      fprintf (stderr, \"LEX_CASEWD%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_PATLIST)\n    {\n      f &= ~LEX_PATLIST;\n      fprintf (stderr, \"LEX_PATLIST%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_INHEREDOC)\n    {\n      f &= ~LEX_INHEREDOC;\n      fprintf (stderr, \"LEX_INHEREDOC%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_HEREDELIM)\n    {\n      f &= ~LEX_HEREDELIM;\n      fprintf (stderr, \"LEX_HEREDELIM%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_STRIPDOC)\n    {\n      f &= ~LEX_STRIPDOC;\n      fprintf (stderr, \"LEX_WASDOL%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_QUOTEDDOC)\n    {\n      f &= ~LEX_QUOTEDDOC;\n      fprintf (stderr, \"LEX_QUOTEDDOC%s\", f ? \"|\" : \"\");\n    }\n  if (f & LEX_INWORD)\n    {\n      f &= ~LEX_INWORD;\n      fprintf (stderr, \"LEX_INWORD%s\", f ? \"|\" : \"\");\n    }\n\n  fprintf (stderr, \"\\n\");\n  fflush (stderr);\n}\n#endif\n\n \nstatic char *\nparse_comsub (qc, open, close, lenp, flags)\n     int qc;\t \n     int open, close;\n     int *lenp, flags;\n{\n  int peekc, r;\n  int start_lineno, local_extglob, was_extpat;\n  char *ret, *tcmd;\n  int retlen;\n  sh_parser_state_t ps;\n  STRING_SAVER *saved_strings;\n  COMMAND *saved_global, *parsed_command;\n\n   \n  if (open == '(')\t\t \n    {\n      peekc = shell_getc (1);\n      shell_ungetc (peekc);\n      if (peekc == '(')\t\t \n\treturn (parse_matched_pair (qc, open, close, lenp, P_ARITH));\n    }\n\n \n\n   \n  start_lineno = line_number;\n\n  save_parser_state (&ps);\n\n  was_extpat = (parser_state & PST_EXTPAT);\n\n   \n  parser_state &= ~(PST_REGEXP|PST_EXTPAT|PST_CONDCMD|PST_CONDEXPR|PST_COMPASSIGN);\n   \n  parser_state &= ~(PST_CASEPAT|PST_ALEXPNEXT|PST_SUBSHELL|PST_REDIRLIST);\n   \n  parser_state |= PST_CMDSUBST|PST_EOFTOKEN|PST_NOEXPAND;\n\n   \n  shell_eof_token = close;\n\n  saved_global = global_command;\t\t \n  global_command = (COMMAND *)NULL;\n\n   \n  need_here_doc = 0;\n  esacs_needed_count = expecting_in_token = 0;\n\n   \n  if (expand_aliases)\n    expand_aliases = posixly_correct != 0;\n#if defined (EXTENDED_GLOB)\n   \n  if (shell_compatibility_level <= 51 && was_extpat == 0)\n    {\n      local_extglob = extended_glob;\n      extended_glob = 1;\n    }\n#endif\n\n  current_token = '\\n';\t\t\t\t \n  token_to_read = DOLPAREN;\t\t\t \n\n  r = yyparse ();\n\n  if (need_here_doc > 0)\n    {\n      internal_warning (\"command substitution: %d unterminated here-document%s\", need_here_doc, (need_here_doc == 1) ? \"\" : \"s\");\n      gather_here_documents ();\t \n    }\n\n#if defined (EXTENDED_GLOB)\n  if (shell_compatibility_level <= 51 && was_extpat == 0)\n    extended_glob = local_extglob;\n#endif\n\n  parsed_command = global_command;\n\n  if (EOF_Reached)\n    {\n      shell_eof_token = ps.eof_token;\n      expand_aliases = ps.expand_aliases;\n\n       \n      parser_state |= PST_NOERROR;\n      return (&matched_pair_error);\n    }\n  else if (r != 0)\n    {\n       \n       \n      if (last_command_exit_value == 0)\n\tlast_command_exit_value = EXECUTION_FAILURE;\n      set_exit_status (last_command_exit_value);\n      if (interactive_shell == 0)\n\tjump_to_top_level (FORCE_EOF);\t \n      else\n\t{\n\t  shell_eof_token = ps.eof_token;\n\t  expand_aliases = ps.expand_aliases;\n\n\t  jump_to_top_level (DISCARD);\t \n\t}\n    }\n\n  if (current_token != shell_eof_token)\n    {\nINTERNAL_DEBUG((\"current_token (%d) != shell_eof_token (%c)\", current_token, shell_eof_token));\n      token_to_read = current_token;\n\n       \n      shell_eof_token = ps.eof_token;\n      expand_aliases = ps.expand_aliases;\n\n      return (&matched_pair_error);\n    }\n\n   \n  saved_strings = pushed_string_list;\n  restore_parser_state (&ps);\n  pushed_string_list = saved_strings;\n\n  tcmd = print_comsub (parsed_command);\t\t \n  retlen = strlen (tcmd);\n  if (tcmd[0] == '(')\t\t\t \n    retlen++;\n  ret = xmalloc (retlen + 2);\n  if (tcmd[0] == '(')\t\t\t \n    {\n      ret[0] = ' ';\n      strcpy (ret + 1, tcmd);\n    }\n  else\n    strcpy (ret, tcmd);\n  ret[retlen++] = ')';\n  ret[retlen] = '\\0';\n\n  dispose_command (parsed_command);\n  global_command = saved_global;\n\n  if (lenp)\n    *lenp = retlen;\n\n \n  return ret;\n}\n\n \nchar *\nxparse_dolparen (base, string, indp, flags)\n     char *base;\n     char *string;\n     int *indp;\n     int flags;\n{\n  sh_parser_state_t ps;\n  sh_input_line_state_t ls;\n  int orig_ind, nc, sflags, start_lineno, local_extglob;\n  char *ret, *ep, *ostring;\n\n \n  orig_ind = *indp;\n  ostring = string;\n  start_lineno = line_number;\n\n  if (*string == 0)\n    {\n      if (flags & SX_NOALLOC) \n\treturn (char *)NULL;\n\n      ret = xmalloc (1);\n      ret[0] = '\\0';\n      return ret;\n    }\n\n \n\n  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;\n  if (flags & SX_NOLONGJMP)\n    sflags |= SEVAL_NOLONGJMP;\n\n  save_parser_state (&ps);\n  save_input_line_state (&ls);\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  pushed_string_list = (STRING_SAVER *)NULL;\n#endif\n   \n  parser_state |= PST_CMDSUBST|PST_EOFTOKEN;\t   \n  shell_eof_token = ')';\n  if (flags & SX_COMPLETE)\n    parser_state |= PST_NOERROR;\n\n   \n  expand_aliases = 0;\n#if defined (EXTENDED_GLOB)\n  local_extglob = extended_glob;\n#endif\n\n  token_to_read = DOLPAREN;\t\t\t \n\n  nc = parse_string (string, \"command substitution\", sflags, (COMMAND **)NULL, &ep);\n\n   \n  if (current_token == shell_eof_token)\n    yyclearin;\t\t \n\n  reset_parser ();\t \n   \n  restore_input_line_state (&ls);\n  restore_parser_state (&ps);\n\n#if defined (EXTENDED_GLOB)\n  extended_glob = local_extglob;\n#endif\n  token_to_read = 0;\n\n   \n  if (nc < 0)\n    {\n      clear_shell_input_line ();\t \n      if (bash_input.type != st_string)\t \n\tparser_state &= ~(PST_CMDSUBST|PST_EOFTOKEN);\n      if ((flags & SX_NOLONGJMP) == 0)\n\tjump_to_top_level (-nc);\t \n    }\n\n   \n\n   \n  if (ep[-1] != ')')\n    {\n#if 0\n      if (ep[-1] != '\\n')\n\titrace(\"xparse_dolparen:%d: ep[-1] != RPAREN (%d), ep = `%s'\", line_number, ep[-1], ep);\n#endif\n\n      while (ep > ostring && ep[-1] == '\\n') ep--;\n    }\n\n  nc = ep - ostring;\n  *indp = ep - base - 1;\n\n   \n#if 0\n  if (base[*indp] != ')')\n    itrace(\"xparse_dolparen:%d: base[%d] != RPAREN (%d), base = `%s'\", line_number, *indp, base[*indp], base);\n  if (*indp < orig_ind)\n    itrace(\"xparse_dolparen:%d: *indp (%d) < orig_ind (%d), orig_string = `%s'\", line_number, *indp, orig_ind, ostring);\n#endif\n\n  if (base[*indp] != ')' && (flags & SX_NOLONGJMP) == 0)\n    {\n       \n      if ((flags & SX_NOERROR) == 0)\n\tparser_error (start_lineno, _(\"unexpected EOF while looking for matching `%c'\"), ')');\n      jump_to_top_level (DISCARD);\n    }\n\n  if (flags & SX_NOALLOC) \n    return (char *)NULL;\n\n  if (nc == 0)\n    {\n      ret = xmalloc (1);\n      ret[0] = '\\0';\n    }\n  else\n    ret = substring (ostring, 0, nc - 1);\n\n  return ret;\n}\n\n \nCOMMAND *\nparse_string_to_command (string, flags)\n     char *string;\n     int flags;\n{\n  sh_parser_state_t ps;\n  sh_input_line_state_t ls;\n  int nc, sflags;\n  size_t slen;\n  char *ret, *ep;\n  COMMAND *cmd;\n\n  if (*string == 0)\n    return (COMMAND *)NULL;\n\n  ep = string;\n  slen = STRLEN (string);\n\n \n\n  sflags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOFREE;\n  if (flags & SX_NOLONGJMP)\n    sflags |= SEVAL_NOLONGJMP;\n\n  save_parser_state (&ps);\n  save_input_line_state (&ls);\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  pushed_string_list = (STRING_SAVER *)NULL;\n#endif\n  if (flags & SX_COMPLETE)\n    parser_state |= PST_NOERROR;\n\n  parser_state |= PST_STRING;\n  expand_aliases = 0;\n\n  cmd = 0;\n  nc = parse_string (string, \"command substitution\", sflags, &cmd, &ep);\n\n  reset_parser ();\n   \n  restore_input_line_state (&ls);\n  restore_parser_state (&ps);\n\n   \n  if (nc < 0)\n    {\n      clear_shell_input_line ();\t \n      if ((flags & SX_NOLONGJMP) == 0)\n        jump_to_top_level (-nc);\t \n    }\n\n   \n  if (nc < slen)\n    {\n      dispose_command (cmd);\n      return (COMMAND *)NULL;\n    }\n\n  return cmd;\n}\n\n#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)\n \nstatic int\nparse_dparen (c)\n     int c;\n{\n  int cmdtyp, sline;\n  char *wval;\n  WORD_DESC *wd;\n\n#if defined (ARITH_FOR_COMMAND)\n  if (last_read_token == FOR)\n    {\n      if (word_top < MAX_CASE_NEST)\n\tword_top++;\n      arith_for_lineno = word_lineno[word_top] = line_number;\n      cmdtyp = parse_arith_cmd (&wval, 0);\n      if (cmdtyp == 1)\n\t{\n\t  wd = alloc_word_desc ();\n\t  wd->word = wval;\n\t  yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);\n\t  return (ARITH_FOR_EXPRS);\n\t}\n      else\n\treturn -1;\t\t \n    }\n#endif\n\n#if defined (DPAREN_ARITHMETIC)\n  if (reserved_word_acceptable (last_read_token))\n    {\n      sline = line_number;\n\n      cmdtyp = parse_arith_cmd (&wval, 0);\n      if (cmdtyp == 1)\t \n\t{\n\t  wd = alloc_word_desc ();\n\t  wd->word = wval;\n\t  wd->flags = W_QUOTED|W_NOSPLIT|W_NOGLOB|W_NOTILDE|W_NOPROCSUB;\n\t  yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);\n\t  return (ARITH_CMD);\n\t}\n      else if (cmdtyp == 0)\t \n\t{\n\t  push_string (wval, 0, (alias_t *)NULL);\n\t  pushed_string_list->flags = PSH_DPAREN;\n\t  if ((parser_state & PST_CASEPAT) == 0)\n\t    parser_state |= PST_SUBSHELL;\n\t  return (c);\n\t}\n      else\t\t\t \n\treturn -1;\n    }\n#endif\n\n  return -2;\t\t\t \n}\n\n \nstatic int\nparse_arith_cmd (ep, adddq)\n     char **ep;\n     int adddq;\n{\n  int exp_lineno, rval, c;\n  char *ttok, *tokstr;\n  int ttoklen;\n\n  exp_lineno = line_number;\n  ttok = parse_matched_pair (0, '(', ')', &ttoklen, P_ARITH);\n  rval = 1;\n  if (ttok == &matched_pair_error)\n    return -1;\n   \n  c = shell_getc (0);\n  if MBTEST(c != ')')\n    rval = 0;\n\n  tokstr = (char *)xmalloc (ttoklen + 4);\n\n   \n  if (rval == 1 && adddq)\t \n    {\n      tokstr[0] = '\"';\n      strncpy (tokstr + 1, ttok, ttoklen - 1);\n      tokstr[ttoklen] = '\"';\n      tokstr[ttoklen+1] = '\\0';\n    }\n  else if (rval == 1)\t\t \n    {\n      strncpy (tokstr, ttok, ttoklen - 1);\n      tokstr[ttoklen-1] = '\\0';\n    }\n  else\t\t\t\t \n    {\n      tokstr[0] = '(';\n      strncpy (tokstr + 1, ttok, ttoklen - 1);\n      tokstr[ttoklen] = ')';\n      tokstr[ttoklen+1] = c;\n      tokstr[ttoklen+2] = '\\0';\n    }\n\n  *ep = tokstr;\n  FREE (ttok);\n  return rval;\n}\n#endif  \n\n#if defined (COND_COMMAND)\nstatic void\ncond_error ()\n{\n  char *etext;\n\n  if (EOF_Reached && cond_token != COND_ERROR)\t\t \n    parser_error (cond_lineno, _(\"unexpected EOF while looking for `]]'\"));\n  else if (cond_token != COND_ERROR)\n    {\n      if (etext = error_token_from_token (cond_token))\n\t{\n\t  parser_error (cond_lineno, _(\"syntax error in conditional expression: unexpected token `%s'\"), etext);\n\t  free (etext);\n\t}\n      else\n\tparser_error (cond_lineno, _(\"syntax error in conditional expression\"));\n    }\n}\n\nstatic COND_COM *\ncond_expr ()\n{\n  return (cond_or ());  \n}\n\nstatic COND_COM *\ncond_or ()\n{\n  COND_COM *l, *r;\n\n  l = cond_and ();\n  if (cond_token == OR_OR)\n    {\n      r = cond_or ();\n      l = make_cond_node (COND_OR, (WORD_DESC *)NULL, l, r);\n    }\n  return l;\n}\n\nstatic COND_COM *\ncond_and ()\n{\n  COND_COM *l, *r;\n\n  l = cond_term ();\n  if (cond_token == AND_AND)\n    {\n      r = cond_and ();\n      l = make_cond_node (COND_AND, (WORD_DESC *)NULL, l, r);\n    }\n  return l;\n}\n\nstatic int\ncond_skip_newlines ()\n{\n  while ((cond_token = read_token (READ)) == '\\n')\n    {\n      if (SHOULD_PROMPT ())\n\tprompt_again (0);\n    }\n  return (cond_token);\n}\n\n#define COND_RETURN_ERROR() \\\n  do { cond_token = COND_ERROR; return ((COND_COM *)NULL); } while (0)\n\nstatic COND_COM *\ncond_term ()\n{\n  WORD_DESC *op;\n  COND_COM *term, *tleft, *tright;\n  int tok, lineno, local_extglob;\n  char *etext;\n\n   \n  tok = cond_skip_newlines ();\n  lineno = line_number;\n  if (tok == COND_END)\n    {\n      COND_RETURN_ERROR ();\n    }\n  else if (tok == '(')\n    {\n      term = cond_expr ();\n      if (cond_token != ')')\n\t{\n\t  if (term)\n\t    dispose_cond_node (term);\t\t \n\t  if (etext = error_token_from_token (cond_token))\n\t    {\n\t      parser_error (lineno, _(\"unexpected token `%s', expected `)'\"), etext);\n\t      free (etext);\n\t    }\n\t  else\n\t    parser_error (lineno, _(\"expected `)'\"));\n\t  COND_RETURN_ERROR ();\n\t}\n      term = make_cond_node (COND_EXPR, (WORD_DESC *)NULL, term, (COND_COM *)NULL);\n      (void)cond_skip_newlines ();\n    }\n  else if (tok == BANG || (tok == WORD && (yylval.word->word[0] == '!' && yylval.word->word[1] == '\\0')))\n    {\n      if (tok == WORD)\n\tdispose_word (yylval.word);\t \n      term = cond_term ();\n      if (term)\n\tterm->flags ^= CMD_INVERT_RETURN;\n    }\n  else if (tok == WORD && yylval.word->word[0] == '-' && yylval.word->word[1] && yylval.word->word[2] == 0 && test_unop (yylval.word->word))\n    {\n      op = yylval.word;\n      tok = read_token (READ);\n      if (tok == WORD)\n\t{\n\t  tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);\n\t  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);\n\t}\n      else\n\t{\n\t  dispose_word (op);\n\t  if (etext = error_token_from_token (tok))\n\t    {\n\t      parser_error (line_number, _(\"unexpected argument `%s' to conditional unary operator\"), etext);\n\t      free (etext);\n\t    }\n\t  else\n\t    parser_error (line_number, _(\"unexpected argument to conditional unary operator\"));\n\t  COND_RETURN_ERROR ();\n\t}\n\n      (void)cond_skip_newlines ();\n    }\n  else if (tok == WORD)\t\t \n    {\n       \n      tleft = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);\n\n       \n       \n      tok = read_token (READ);\n      if (tok == WORD && test_binop (yylval.word->word))\n\t{\n\t  op = yylval.word;\n\t  if (op->word[0] == '=' && (op->word[1] == '\\0' || (op->word[1] == '=' && op->word[2] == '\\0')))\n\t    parser_state |= PST_EXTPAT;\n\t  else if (op->word[0] == '!' && op->word[1] == '=' && op->word[2] == '\\0')\n\t    parser_state |= PST_EXTPAT;\n\t}\n#if defined (COND_REGEXP)\n      else if (tok == WORD && STREQ (yylval.word->word, \"=~\"))\n\t{\n\t  op = yylval.word;\n\t  parser_state |= PST_REGEXP;\n\t}\n#endif\n      else if (tok == '<' || tok == '>')\n\top = make_word_from_token (tok);   \n       \n      else if (tok == COND_END || tok == AND_AND || tok == OR_OR || tok == ')')\n\t{\n\t   \n\t  op = make_word (\"-n\");\n\t  term = make_cond_node (COND_UNARY, op, tleft, (COND_COM *)NULL);\n\t  cond_token = tok;\n\t  return (term);\n\t}\n      else\n\t{\n\t  if (etext = error_token_from_token (tok))\n\t    {\n\t      parser_error (line_number, _(\"unexpected token `%s', conditional binary operator expected\"), etext);\n\t      free (etext);\n\t    }\n\t  else\n\t    parser_error (line_number, _(\"conditional binary operator expected\"));\n\t  dispose_cond_node (tleft);\n\t  COND_RETURN_ERROR ();\n\t}\n\n       \n#if defined (EXTENDED_GLOB)\n      local_extglob = extended_glob;\n      if (parser_state & PST_EXTPAT)\n\textended_glob = 1;\n#endif\n      tok = read_token (READ);\n#if defined (EXTENDED_GLOB)\n      if (parser_state & PST_EXTPAT)\n\textended_glob = local_extglob;\n#endif\n      parser_state &= ~(PST_REGEXP|PST_EXTPAT);\n\n      if (tok == WORD)\n\t{\n\t  tright = make_cond_node (COND_TERM, yylval.word, (COND_COM *)NULL, (COND_COM *)NULL);\n\t  term = make_cond_node (COND_BINARY, op, tleft, tright);\n\t}\n      else\n\t{\n\t  if (etext = error_token_from_token (tok))\n\t    {\n\t      parser_error (line_number, _(\"unexpected argument `%s' to conditional binary operator\"), etext);\n\t      free (etext);\n\t    }\n\t  else\n\t    parser_error (line_number, _(\"unexpected argument to conditional binary operator\"));\n\t  dispose_cond_node (tleft);\n\t  dispose_word (op);\n\t  COND_RETURN_ERROR ();\n\t}\n\n      (void)cond_skip_newlines ();\n    }\n  else\n    {\n      if (tok < 256)\n\tparser_error (line_number, _(\"unexpected token `%c' in conditional command\"), tok);\n      else if (etext = error_token_from_token (tok))\n\t{\n\t  parser_error (line_number, _(\"unexpected token `%s' in conditional command\"), etext);\n\t  free (etext);\n\t}\n      else\n\tparser_error (line_number, _(\"unexpected token %d in conditional command\"), tok);\n      COND_RETURN_ERROR ();\n    }\n  return (term);\n}      \n\n \nstatic COMMAND *\nparse_cond_command ()\n{\n  COND_COM *cexp;\n\n  cexp = cond_expr ();\n  return (make_cond_command (cexp));\n}\n#endif\n\n#if defined (ARRAY_VARS)\n \nstatic int\ntoken_is_assignment (t, i)\n     char *t;\n     int i;\n{\n  int r;\n  char *atoken;\n\n  atoken = xmalloc (i + 3);\n  memcpy (atoken, t, i);\n  atoken[i] = '=';\n  atoken[i+1] = '\\0';\n\n  r = assignment (atoken, (parser_state & PST_COMPASSIGN) != 0);\n\n  free (atoken);\n\n   \n  return (r > 0 && r == i);\n}\n\n \nstatic int\ntoken_is_ident (t, i)\n     char *t;\n     int i;\n{\n  unsigned char c;\n  int r;\n\n  c = t[i];\n  t[i] = '\\0';\n  r = legal_identifier (t);\n  t[i] = c;\n  return r;\n}\n#endif\n\nstatic int\nread_token_word (character)\n     int character;\n{\n   \n  WORD_DESC *the_word;\n\n   \n  int token_index;\n\n   \n  int all_digit_token;\n\n   \n  int dollar_present;\n\n   \n  int compound_assignment;\n\n   \n  int quoted;\n\n   \n  int pass_next_character;\n\n   \n  int cd;\n  int result, peek_char;\n  char *ttok, *ttrans;\n  int ttoklen, ttranslen;\n  intmax_t lvalue;\n\n  if (token_buffer_size < TOKEN_DEFAULT_INITIAL_SIZE)\n    token = (char *)xrealloc (token, token_buffer_size = TOKEN_DEFAULT_INITIAL_SIZE);\n\n  token_index = 0;\n  all_digit_token = DIGIT (character);\n  dollar_present = quoted = pass_next_character = compound_assignment = 0;\n\n  for (;;)\n    {\n      if (character == EOF)\n\tgoto got_token;\n\n      if (pass_next_character)\n\t{\n\t  pass_next_character = 0;\n\t  goto got_escaped_character;\n\t}\n\n      cd = current_delimiter (dstack);\n\n       \n      if MBTEST(character == '\\\\')\n\t{\n\t  if (parser_state & PST_NOEXPAND)\n\t    {\n\t      pass_next_character++;\n\t      quoted = 1;\n\t      goto got_character;\n\t    }\n\t      \n\t  peek_char = shell_getc (0);\n\n\t   \n\t  if MBTEST(peek_char == '\\n')\n\t    {\n\t      character = '\\n';\n\t      goto next_character;\n\t    }\n\t  else\n\t    {\n\t      shell_ungetc (peek_char);\n\n\t       \n\t      if MBTEST(cd == 0 || cd == '`' ||\n\t\t  (cd == '\"' && peek_char >= 0 && (sh_syntaxtab[peek_char] & CBSDQUOTE)))\n\t\tpass_next_character++;\n\n\t      quoted = 1;\n\t      goto got_character;\n\t    }\n\t}\n\n       \n      if MBTEST(shellquote (character))\n\t{\n\t  push_delimiter (dstack, character);\n\t  ttok = parse_matched_pair (character, character, character, &ttoklen, (character == '`') ? P_COMMAND : 0);\n\t  pop_delimiter (dstack);\n\t  if (ttok == &matched_pair_error)\n\t    return -1;\t\t \n\t  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,\n\t\t\t\t  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);\n\t  token[token_index++] = character;\n\t  strcpy (token + token_index, ttok);\n\t  token_index += ttoklen;\n\t  all_digit_token = 0;\n\t  if (character != '`')\n\t    quoted = 1;\n\t  dollar_present |= (character == '\"' && strchr (ttok, '$') != 0);\n\t  FREE (ttok);\n\t  goto next_character;\n\t}\n\n#ifdef COND_REGEXP\n         \n      if MBTEST((parser_state & PST_REGEXP) && (character == '(' || character == '|'))\t\t \n\t{\n\t  if (character == '|')\n\t    goto got_character;\n\n\t  push_delimiter (dstack, character);\n\t  ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);\n\t  pop_delimiter (dstack);\n\t  if (ttok == &matched_pair_error)\n\t    return -1;\t\t \n\t  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,\n\t\t\t\t  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);\n\t  token[token_index++] = character;\n\t  strcpy (token + token_index, ttok);\n\t  token_index += ttoklen;\n\t  FREE (ttok);\n\t  dollar_present = all_digit_token = 0;\n\t  goto next_character;\n\t}\n#endif  \n\n#ifdef EXTENDED_GLOB\n       \n      if MBTEST(extended_glob && PATTERN_CHAR (character))\n\t{\n\t  peek_char = shell_getc (1);\n\t  if MBTEST(peek_char == '(')\t\t \n\t    {\n\t      push_delimiter (dstack, peek_char);\n\t      ttok = parse_matched_pair (cd, '(', ')', &ttoklen, 0);\n\t      pop_delimiter (dstack);\n\t      if (ttok == &matched_pair_error)\n\t\treturn -1;\t\t \n\t      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 3,\n\t\t\t\t      token_buffer_size,\n\t\t\t\t      TOKEN_DEFAULT_GROW_SIZE);\n\t      token[token_index++] = character;\n\t      token[token_index++] = peek_char;\n\t      strcpy (token + token_index, ttok);\n\t      token_index += ttoklen;\n\t      FREE (ttok);\n\t      dollar_present = all_digit_token = 0;\n\t      goto next_character;\n\t    }\n\t  else\n\t    shell_ungetc (peek_char);\n\t}\n#endif  \n\n       \n      if MBTEST(shellexp (character))\n\t{\n\t  peek_char = shell_getc (1);\n\t   \n\t  if MBTEST(peek_char == '(' ||\n\t\t((peek_char == '{' || peek_char == '[') && character == '$'))\t \n\t    {\n\t      if (peek_char == '{')\t\t \n\t\tttok = parse_matched_pair (cd, '{', '}', &ttoklen, P_FIRSTCLOSE|P_DOLBRACE);\n\t      else if (peek_char == '(')\t\t \n\t\t{\n\t\t   \n\t\t  push_delimiter (dstack, peek_char);\n\t\t  ttok = parse_comsub (cd, '(', ')', &ttoklen, P_COMMAND);\n\t\t  pop_delimiter (dstack);\n\t\t}\n\t      else\n\t\tttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARITH);\n\t      if (ttok == &matched_pair_error)\n\t\treturn -1;\t\t \n\t      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 3,\n\t\t\t\t      token_buffer_size,\n\t\t\t\t      TOKEN_DEFAULT_GROW_SIZE);\n\t      token[token_index++] = character;\n\t      token[token_index++] = peek_char;\n\t      strcpy (token + token_index, ttok);\n\t      token_index += ttoklen;\n\t      FREE (ttok);\n\t      dollar_present = 1;\n\t      all_digit_token = 0;\n\t      goto next_character;\n\t    }\n\t   \n#if defined (TRANSLATABLE_STRINGS)\n\t  else if MBTEST(character == '$' && (peek_char == '\\'' || peek_char == '\"'))\n#else\n\t  else if MBTEST(character == '$' && peek_char == '\\'')\n#endif\n\t    {\n\t      int first_line;\n\n\t      first_line = line_number;\n\t      push_delimiter (dstack, peek_char);\n\t      ttok = parse_matched_pair (peek_char, peek_char, peek_char,\n\t\t\t\t\t &ttoklen,\n\t\t\t\t\t (peek_char == '\\'') ? P_ALLOWESC : 0);\n\t      pop_delimiter (dstack);\n\t      if (ttok == &matched_pair_error)\n\t\treturn -1;\n\t      if (peek_char == '\\'')\n\t\t{\n\t\t   \n\t\t  ttrans = ansiexpand (ttok, 0, ttoklen - 1, &ttranslen);\n\t\t  free (ttok);\n\n\t\t   \n\t\t  ttok = sh_single_quote (ttrans);\n\t\t  free (ttrans);\n\t\t  ttranslen = strlen (ttok);\n\t\t  ttrans = ttok;\n\t\t}\n#if defined (TRANSLATABLE_STRINGS)\n\t      else\n\t\t{\n\t\t   \n\t\t   \n\t\t  ttrans = locale_expand (ttok, 0, ttoklen - 1, first_line, &ttranslen);\n\t\t  free (ttok);\n\n\t\t   \n\t\t  if (singlequote_translations &&\n\t\t        ((ttoklen - 1) != ttranslen || STREQN (ttok, ttrans, ttranslen) == 0))\n\t\t    ttok = sh_single_quote (ttrans);\n\t\t  else\n\t\t    ttok = sh_mkdoublequoted (ttrans, ttranslen, 0);\n\n\t\t  free (ttrans);\n\t\t  ttrans = ttok;\n\t\t  ttranslen = strlen (ttrans);\n\t\t}\n#endif  \n\n\t      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,\n\t\t\t\t      token_buffer_size,\n\t\t\t\t      TOKEN_DEFAULT_GROW_SIZE);\n\t      strcpy (token + token_index, ttrans);\n\t      token_index += ttranslen;\n\t      FREE (ttrans);\n\t      quoted = 1;\n\t      all_digit_token = 0;\n\t      goto next_character;\n\t    }\n\t   \n\t  else if MBTEST(character == '$' && peek_char == '$')\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (token, token_index, 3,\n\t\t\t\t      token_buffer_size,\n\t\t\t\t      TOKEN_DEFAULT_GROW_SIZE);\n\t      token[token_index++] = '$';\n\t      token[token_index++] = peek_char;\n\t      dollar_present = 1;\n\t      all_digit_token = 0;\n\t      goto next_character;\n\t    }\n\t  else\n\t    shell_ungetc (peek_char);\n\t}\n\n#if defined (ARRAY_VARS)\n       \n      else if MBTEST(character == '[' &&\t\t \n\t\t     ((token_index > 0 && assignment_acceptable (last_read_token) && token_is_ident (token, token_index)) ||\n\t\t      (token_index == 0 && (parser_state&PST_COMPASSIGN))))\n        {\n\t  ttok = parse_matched_pair (cd, '[', ']', &ttoklen, P_ARRAYSUB);\n\t  if (ttok == &matched_pair_error)\n\t    return -1;\t\t \n\t  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,\n\t\t\t\t  token_buffer_size,\n\t\t\t\t  TOKEN_DEFAULT_GROW_SIZE);\n\t  token[token_index++] = character;\n\t  strcpy (token + token_index, ttok);\n\t  token_index += ttoklen;\n\t  FREE (ttok);\n\t  all_digit_token = 0;\n\t  goto next_character;\n        }\n       \n      else if MBTEST(character == '=' && token_index > 0 && (assignment_acceptable (last_read_token) || (parser_state & PST_ASSIGNOK)) && token_is_assignment (token, token_index))\n\t{\n\t  peek_char = shell_getc (1);\n\t  if MBTEST(peek_char == '(')\t\t \n\t    {\n\t      ttok = parse_compound_assignment (&ttoklen);\n\n\t      RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 4,\n\t\t\t\t      token_buffer_size,\n\t\t\t\t      TOKEN_DEFAULT_GROW_SIZE);\n\n\t      token[token_index++] = '=';\n\t      token[token_index++] = '(';\n\t      if (ttok)\n\t\t{\n\t\t  strcpy (token + token_index, ttok);\n\t\t  token_index += ttoklen;\n\t\t}\n\t      token[token_index++] = ')';\n\t      FREE (ttok);\n\t      all_digit_token = 0;\n\t      compound_assignment = 1;\n#if 1\n\t      goto next_character;\n#else\n\t      goto got_token;\t\t \n#endif\n\t    }\n\t  else\n\t    shell_ungetc (peek_char);\n\t}\n#endif\n\n       \n      if MBTEST(shellbreak (character))\n\t{\n\t  shell_ungetc (character);\n\t  goto got_token;\n\t}\n\ngot_character:\n      if MBTEST(character == CTLESC || character == CTLNUL)\n\t{\n\t  RESIZE_MALLOCED_BUFFER (token, token_index, 2, token_buffer_size,\n\t\t\t\t  TOKEN_DEFAULT_GROW_SIZE);\n\t  token[token_index++] = CTLESC;\n\t}\n      else\ngot_escaped_character:\n\tRESIZE_MALLOCED_BUFFER (token, token_index, 1, token_buffer_size,\n\t\t\t\tTOKEN_DEFAULT_GROW_SIZE);\n\n      token[token_index++] = character;\n\n      all_digit_token &= DIGIT (character);\n      dollar_present |= character == '$';\n\n    next_character:\n      if (character == '\\n' && SHOULD_PROMPT ())\n\tprompt_again (0);\n\n       \n      cd = current_delimiter (dstack);\n      character = shell_getc (cd != '\\'' && pass_next_character == 0);\n    }\t \n\ngot_token:\n\n   \n  token[token_index] = '\\0';\n\n   \n  if MBTEST(all_digit_token && (character == '<' || character == '>' ||\n\t\t    last_read_token == LESS_AND ||\n\t\t    last_read_token == GREATER_AND))\n      {\n\tif (legal_number (token, &lvalue) && (int)lvalue == lvalue)\n\t  {\n\t    yylval.number = lvalue;\n\t    return (NUMBER);\n\t  }\n      }\n\n   \n  result = (last_shell_getc_is_singlebyte) ? special_case_tokens (token) : -1;\n  if (result >= 0)\n    return result;\n\n#if defined (ALIAS)\n   \n  if MBTEST(posixly_correct)\n    CHECK_FOR_RESERVED_WORD (token);\n\n   \n  if (expand_aliases && quoted == 0)\n    {\n      result = alias_expand_token (token);\n      if (result == RE_READ_TOKEN)\n\treturn (RE_READ_TOKEN);\n      else if (result == NO_EXPANSION)\n\tparser_state &= ~PST_ALEXPNEXT;\n    }\n\n   \n  if MBTEST(posixly_correct == 0)\n#endif\n    CHECK_FOR_RESERVED_WORD (token);\n\n  the_word = alloc_word_desc ();\n  the_word->word = (char *)xmalloc (1 + token_index);\n  the_word->flags = 0;\n  strcpy (the_word->word, token);\n  if (dollar_present)\n    the_word->flags |= W_HASDOLLAR;\n  if (quoted)\n    the_word->flags |= W_QUOTED;\t\t \n  if (compound_assignment && token[token_index-1] == ')')\n    the_word->flags |= W_COMPASSIGN;\n   \n  if (assignment (token, (parser_state & PST_COMPASSIGN) != 0))\n    {\n      the_word->flags |= W_ASSIGNMENT;\n       \n      if (assignment_acceptable (last_read_token) || (parser_state & PST_COMPASSIGN) != 0)\n\t{\n\t  the_word->flags |= W_NOSPLIT;\n\t  if (parser_state & PST_COMPASSIGN)\n\t    the_word->flags |= W_NOGLOB;\t \n\t}\n    }\n\n  if (command_token_position (last_read_token))\n    {\n      struct builtin *b;\n      b = builtin_address_internal (token, 0);\n      if (b && (b->flags & ASSIGNMENT_BUILTIN))\n\tparser_state |= PST_ASSIGNOK;\n      else if (STREQ (token, \"eval\") || STREQ (token, \"let\"))\n\tparser_state |= PST_ASSIGNOK;\n    }\n\n  yylval.word = the_word;\n\n   \n  if MBTEST(token[0] == '{' && token[token_index-1] == '}' &&\n      (character == '<' || character == '>'))\n    {\n       \n      token[token_index-1] = '\\0';\n#if defined (ARRAY_VARS)\n      if (legal_identifier (token+1) || valid_array_reference (token+1, 0))\n#else\n      if (legal_identifier (token+1))\n#endif\n\t{\n\t  strcpy (the_word->word, token+1);\n \n\t  yylval.word = the_word;\t \n\t  return (REDIR_WORD);\n\t}\n      else\n         \n        yylval.word = the_word;\n    }\n\n  result = ((the_word->flags & (W_ASSIGNMENT|W_NOSPLIT)) == (W_ASSIGNMENT|W_NOSPLIT))\n\t\t? ASSIGNMENT_WORD : WORD;\n\n  switch (last_read_token)\n    {\n    case FUNCTION:\n      parser_state |= PST_ALLOWOPNBRC;\n      function_dstart = line_number;\n      break;\n    case CASE:\n    case SELECT:\n    case FOR:\n      if (word_top < MAX_CASE_NEST)\n\tword_top++;\n      word_lineno[word_top] = line_number;\n      expecting_in_token++;\n      break;\n    }\n\n  return (result);\n}\n\n \nstatic int\nreserved_word_acceptable (toksym)\n     int toksym;\n{\n  switch (toksym)\n    {\n    case '\\n':\n    case ';':\n    case '(':\n    case ')':\n    case '|':\n    case '&':\n    case '{':\n    case '}':\t\t \n    case AND_AND:\n    case ARITH_CMD:\n    case BANG:\n    case BAR_AND:\n    case COND_END:\n    case DO:\n    case DONE:\n    case ELIF:\n    case ELSE:\n    case ESAC:\n    case FI:\n    case IF:\n    case OR_OR:\n    case SEMI_SEMI:\n    case SEMI_AND:\n    case SEMI_SEMI_AND:\n    case THEN:\n    case TIME:\n    case TIMEOPT:\n    case TIMEIGN:\n    case COPROC:\n    case UNTIL:\n    case WHILE:\n    case 0:\n    case DOLPAREN:\n      return 1;\n    default:\n#if defined (COPROCESS_SUPPORT)\n      if (last_read_token == WORD && token_before_that == COPROC)\n\treturn 1;\n#endif\n      if (last_read_token == WORD && token_before_that == FUNCTION)\n\treturn 1;\n      return 0;\n    }\n}\n    \n \nint\nfind_reserved_word (tokstr)\n     char *tokstr;\n{\n  int i;\n  for (i = 0; word_token_alist[i].word; i++)\n    if (STREQ (tokstr, word_token_alist[i].word))\n      return i;\n  return -1;\n}\n\n \nint\nparser_in_command_position ()\n{\n  return (command_token_position (last_read_token));\n}\n\n#if 0\n#if defined (READLINE)\n \nstatic void\nreset_readline_prompt ()\n{\n  char *temp_prompt;\n\n  if (prompt_string_pointer)\n    {\n      temp_prompt = (*prompt_string_pointer)\n\t\t\t? decode_prompt_string (*prompt_string_pointer)\n\t\t\t: (char *)NULL;\n\n      if (temp_prompt == 0)\n\t{\n\t  temp_prompt = (char *)xmalloc (1);\n\t  temp_prompt[0] = '\\0';\n\t}\n\n      FREE (current_readline_prompt);\n      current_readline_prompt = temp_prompt;\n    }\n}\n#endif  \n#endif  \n\n#if defined (HISTORY)\n \nstatic const int no_semi_successors[] = {\n  '\\n', '{', '(', ')', ';', '&', '|',\n  CASE, DO, ELSE, IF, SEMI_SEMI, SEMI_AND, SEMI_SEMI_AND, THEN, UNTIL,\n  WHILE, AND_AND, OR_OR, IN,\n  0\n};\n\n \nchar *\nhistory_delimiting_chars (line)\n     const char *line;\n{\n  static int last_was_heredoc = 0;\t \n  register int i;\n\n  if ((parser_state & PST_HEREDOC) == 0)\n    last_was_heredoc = 0;\n\n  if (dstack.delimiter_depth != 0)\n    return (\"\\n\");\n\n   \n  if (parser_state & PST_HEREDOC)\n    {\n      if (last_was_heredoc)\n\t{\n\t  last_was_heredoc = 0;\n\t  return \"\\n\";\n\t}\n      return (here_doc_first_line ? \"\\n\" : \"\");\n    }\n\n  if (parser_state & PST_COMPASSIGN)\n    return (\" \");\n\n   \n   \n   \n   \n  if (token_before_that == ')')\n    {\n      if (two_tokens_ago == '(')\t \t \n\treturn \" \";\n       \n      else if (parser_state & PST_CASESTMT)\t \n\treturn \" \";\n      else\n\treturn \"; \";\t\t\t\t \n    }\n  else if (token_before_that == WORD && two_tokens_ago == FUNCTION)\n    return \" \";\t\t \n\n   \n  else if ((parser_state & PST_HEREDOC) == 0 && current_command_line_count > 1 && last_read_token == '\\n' && strstr (line, \"<<\"))\n    {\n      last_was_heredoc = 1;\n      return \"\\n\";\n    }\n  else if ((parser_state & PST_HEREDOC) == 0 && current_command_line_count > 1 && need_here_doc > 0)\n    return \"\\n\";\n  else if (token_before_that == WORD && two_tokens_ago == FOR)\n    {\n       \n      for (i = shell_input_line_index; whitespace (shell_input_line[i]); i++)\n\t;\n      if (shell_input_line[i] && shell_input_line[i] == 'i' && shell_input_line[i+1] == 'n')\n\treturn \" \";\n      return \";\";\n    }\n  else if (two_tokens_ago == CASE && token_before_that == WORD && (parser_state & PST_CASESTMT))\n    return \" \";\n\n  for (i = 0; no_semi_successors[i]; i++)\n    {\n      if (token_before_that == no_semi_successors[i])\n\treturn (\" \");\n    }\n\n   \n  if (line_isblank (line))\n    return (current_command_line_count > 1 && last_read_token == '\\n' && token_before_that != '\\n') ? \"; \" : \"\";\n\n  return (\"; \");\n}\n#endif  \n\n \nstatic void\nprompt_again (force)\n     int force;\n{\n  char *temp_prompt;\n\n  if (interactive == 0 || expanding_alias ())\t \n    return;\n\n  ps1_prompt = get_string_value (\"PS1\");\n  ps2_prompt = get_string_value (\"PS2\");\n\n  ps0_prompt = get_string_value (\"PS0\");\n\n  if (!prompt_string_pointer)\n    prompt_string_pointer = &ps1_prompt;\n\n  temp_prompt = *prompt_string_pointer\n\t\t\t? decode_prompt_string (*prompt_string_pointer)\n\t\t\t: (char *)NULL;\n\n  if (temp_prompt == 0)\n    {\n      temp_prompt = (char *)xmalloc (1);\n      temp_prompt[0] = '\\0';\n    }\n\n  current_prompt_string = *prompt_string_pointer;\n  prompt_string_pointer = &ps2_prompt;\n\n#if defined (READLINE)\n  if (!no_line_editing)\n    {\n      FREE (current_readline_prompt);\n      current_readline_prompt = temp_prompt;\n    }\n  else\n#endif\t \n    {\n      FREE (current_decoded_prompt);\n      current_decoded_prompt = temp_prompt;\n    }\n}\n\nint\nget_current_prompt_level ()\n{\n  return ((current_prompt_string && current_prompt_string == ps2_prompt) ? 2 : 1);\n}\n\nvoid\nset_current_prompt_level (x)\n     int x;\n{\n  prompt_string_pointer = (x == 2) ? &ps2_prompt : &ps1_prompt;\n  current_prompt_string = *prompt_string_pointer;\n}\n      \nstatic void\nprint_prompt ()\n{\n  fprintf (stderr, \"%s\", current_decoded_prompt);\n  fflush (stderr);\n}\n\n#if defined (HISTORY)\n   \nstatic int\nprompt_history_number (pmt)\n     char *pmt;\n{\n  int ret;\n\n  ret = history_number ();\n  if (ret == 1)\n    return ret;\n\n  if (pmt == ps1_prompt)\t \n    return ret;\n  else if (pmt == ps2_prompt && command_oriented_history == 0)\n    return ret;\t\t\t \n  else if (pmt == ps2_prompt && command_oriented_history && current_command_first_line_saved)\n    return ret - 1;\n  else\n    return ret - 1;\t\t \n}\n#endif\n\n \n#define PROMPT_GROWTH 48\nchar *\ndecode_prompt_string (string)\n     char *string;\n{\n  WORD_LIST *list;\n  char *result, *t, *orig_string;\n  struct dstack save_dstack;\n  int last_exit_value, last_comsub_pid;\n#if defined (PROMPT_STRING_DECODE)\n  size_t result_size;\n  size_t result_index;\n  int c, n, i;\n  char *temp, *t_host, octal_string[4];\n  struct tm *tm;  \n  time_t the_time;\n  char timebuf[128];\n  char *timefmt;\n\n  result = (char *)xmalloc (result_size = PROMPT_GROWTH);\n  result[result_index = 0] = 0;\n  temp = (char *)NULL;\n  orig_string = string;\n\n  while (c = *string++)\n    {\n      if (posixly_correct && c == '!')\n\t{\n\t  if (*string == '!')\n\t    {\n\t      temp = savestring (\"!\");\n\t      goto add_string;\n\t    }\n\t  else\n\t    {\n#if !defined (HISTORY)\n\t\ttemp = savestring (\"1\");\n#else  \n\t\ttemp = itos (prompt_history_number (orig_string));\n#endif  \n\t\tstring--;\t \n\t\tgoto add_string;\n\t    }\n\t}\n      if (c == '\\\\')\n\t{\n\t  c = *string;\n\n\t  switch (c)\n\t    {\n\t    case '0':\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t      strncpy (octal_string, string, 3);\n\t      octal_string[3] = '\\0';\n\n\t      n = read_octal (octal_string);\n\t      temp = (char *)xmalloc (3);\n\n\t      if (n == CTLESC || n == CTLNUL)\n\t\t{\n\t\t  temp[0] = CTLESC;\n\t\t  temp[1] = n;\n\t\t  temp[2] = '\\0';\n\t\t}\n\t      else if (n == -1)\n\t\t{\n\t\t  temp[0] = '\\\\';\n\t\t  temp[1] = '\\0';\n\t\t}\n\t      else\n\t\t{\n\t\t  temp[0] = n;\n\t\t  temp[1] = '\\0';\n\t\t}\n\n\t      for (c = 0; n != -1 && c < 3 && ISOCTAL (*string); c++)\n\t\tstring++;\n\n\t      c = 0;\t\t \n\t      goto add_string;\n\n\t    case 'd':\n\t    case 't':\n\t    case 'T':\n\t    case '@':\n\t    case 'A':\n\t       \n\t      (void) time (&the_time);\n#if defined (HAVE_TZSET)\n\t      sv_tz (\"TZ\");\t\t \n#endif\n\t      tm = localtime (&the_time);\n\n\t      if (c == 'd')\n\t\tn = strftime (timebuf, sizeof (timebuf), \"%a %b %d\", tm);\n\t      else if (c == 't')\n\t\tn = strftime (timebuf, sizeof (timebuf), \"%H:%M:%S\", tm);\n\t      else if (c == 'T')\n\t\tn = strftime (timebuf, sizeof (timebuf), \"%I:%M:%S\", tm);\n\t      else if (c == '@')\n\t\tn = strftime (timebuf, sizeof (timebuf), \"%I:%M %p\", tm);\n\t      else if (c == 'A')\n\t\tn = strftime (timebuf, sizeof (timebuf), \"%H:%M\", tm);\n\n\t      if (n == 0)\n\t\ttimebuf[0] = '\\0';\n\t      else\n\t\ttimebuf[sizeof(timebuf) - 1] = '\\0';\n\n\t      temp = savestring (timebuf);\n\t      goto add_string;\n\n\t    case 'D':\t\t \n\t      if (string[1] != '{')\t\t \n\t\tgoto not_escape;\n\n\t      (void) time (&the_time);\n\t      tm = localtime (&the_time);\n\t      string += 2;\t\t\t \n\t      timefmt = xmalloc (strlen (string) + 3);\n\t      for (t = timefmt; *string && *string != '}'; )\n\t\t*t++ = *string++;\n\t      *t = '\\0';\n\t      c = *string;\t \n\t      if (timefmt[0] == '\\0')\n\t\t{\n\t\t  timefmt[0] = '%';\n\t\t  timefmt[1] = 'X';\t \n\t\t  timefmt[2] = '\\0';\n\t\t}\n\t      n = strftime (timebuf, sizeof (timebuf), timefmt, tm);\n\t      free (timefmt);\n\n\t      if (n == 0)\n\t\ttimebuf[0] = '\\0';\n\t      else\n\t\ttimebuf[sizeof(timebuf) - 1] = '\\0';\n\n\t      if (promptvars || posixly_correct)\n\t\t \n\t\ttemp = sh_backslash_quote_for_double_quotes (timebuf, 0);\n\t      else\n\t\ttemp = savestring (timebuf);\n\t      goto add_string;\n\t      \n\t    case 'n':\n\t      temp = (char *)xmalloc (3);\n\t      temp[0] = no_line_editing ? '\\n' : '\\r';\n\t      temp[1] = no_line_editing ? '\\0' : '\\n';\n\t      temp[2] = '\\0';\n\t      goto add_string;\n\n\t    case 's':\n\t      temp = base_pathname (shell_name);\n\t       \n\t      if (promptvars || posixly_correct)\n\t\t{\n\t\t  char *t;\n\t\t  t = sh_strvis (temp);\n\t\t  temp = sh_backslash_quote_for_double_quotes (t, 0);\n\t\t  free (t);\n\t\t}\n\t      else\n\t\ttemp = sh_strvis (temp);\n\t      goto add_string;\n\n\t    case 'v':\n\t    case 'V':\n\t      temp = (char *)xmalloc (16);\n\t      if (c == 'v')\n\t\tstrcpy (temp, dist_version);\n\t      else\n\t\tsprintf (temp, \"%s.%d\", dist_version, patch_level);\n\t      goto add_string;\n\n\t    case 'w':\n\t    case 'W':\n\t      {\n\t\t \n\t\tchar t_string[PATH_MAX];\n\t\tint tlen;\n\n\t\ttemp = get_string_value (\"PWD\");\n\n\t\tif (temp == 0)\n\t\t  {\n\t\t    if (getcwd (t_string, sizeof(t_string)) == 0)\n\t\t      {\n\t\t\tt_string[0] = '.';\n\t\t\ttlen = 1;\n\t\t      }\n\t\t    else\n\t\t      tlen = strlen (t_string);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    tlen = sizeof (t_string) - 1;\n\t\t    strncpy (t_string, temp, tlen);\n\t\t  }\n\t\tt_string[tlen] = '\\0';\n\n#if defined (MACOSX)\n\t\t \n\t\ttemp = fnx_fromfs (t_string, strlen (t_string));\n\t\tif (temp != t_string)\n\t\t  strcpy (t_string, temp);\n#endif\n\n#define ROOT_PATH(x)\t((x)[0] == '/' && (x)[1] == 0)\n#define DOUBLE_SLASH_ROOT(x)\t((x)[0] == '/' && (x)[1] == '/' && (x)[2] == 0)\n\t\t \n\t\tif (c == 'W' && (((t = get_string_value (\"HOME\")) == 0) || STREQ (t, t_string) == 0))\n\t\t  {\n\t\t    if (ROOT_PATH (t_string) == 0 && DOUBLE_SLASH_ROOT (t_string) == 0)\n\t\t      {\n\t\t\tt = strrchr (t_string, '/');\n\t\t\tif (t)\n\t\t\t  memmove (t_string, t + 1, strlen (t));\t \n\t\t      }\n\t\t  }\n#undef ROOT_PATH\n#undef DOUBLE_SLASH_ROOT\n\t\telse\n\t\t  {\n\t\t     \n\t\t    temp = polite_directory_format (t_string);\n\t\t    if (temp != t_string)\n\t\t      strcpy (t_string, temp);\n\t\t  }\n\n\t\ttemp = trim_pathname (t_string, PATH_MAX - 1);\n\t\t \n\t\tif (promptvars || posixly_correct)\n\t\t   \n\t\t  {\n\t\t    char *t;\n\t\t    t = sh_strvis (t_string);\n\t\t    temp = sh_backslash_quote_for_double_quotes (t, 0);\n\t\t    free (t);\n\t\t  }\n\t\telse\n\t\t  temp = sh_strvis (t_string);\n\n\t\tgoto add_string;\n\t      }\n\n\t    case 'u':\n\t      if (current_user.user_name == 0)\n\t\tget_current_user_info ();\n\t      temp = savestring (current_user.user_name);\n\t      goto add_string;\n\n\t    case 'h':\n\t    case 'H':\n\t      t_host = savestring (current_host_name);\n\t      if (c == 'h' && (t = (char *)strchr (t_host, '.')))\n\t\t*t = '\\0';\n\t      if (promptvars || posixly_correct)\n\t\t \n\t\ttemp = sh_backslash_quote_for_double_quotes (t_host, 0);\n\t      else\n\t\ttemp = savestring (t_host);\n\t      free (t_host);\n\t      goto add_string;\n\n\t    case '#':\n\t      n = current_command_number;\n\t       \n\t      if (orig_string != ps0_prompt && orig_string != ps1_prompt && orig_string != ps2_prompt)\n\t\tn--;\n\t      temp = itos (n);\n\t      goto add_string;\n\n\t    case '!':\n#if !defined (HISTORY)\n\t      temp = savestring (\"1\");\n#else  \n\t      temp = itos (prompt_history_number (orig_string));\n#endif  \n\t      goto add_string;\n\n\t    case '$':\n\t      t = temp = (char *)xmalloc (3);\n\t      if ((promptvars || posixly_correct) && (current_user.euid != 0))\n\t\t*t++ = '\\\\';\n\t      *t++ = current_user.euid == 0 ? '#' : '$';\n\t      *t = '\\0';\n\t      goto add_string;\n\n\t    case 'j':\n\t      temp = itos (count_all_jobs ());\n\t      goto add_string;\n\n\t    case 'l':\n#if defined (HAVE_TTYNAME)\n\t      temp = (char *)ttyname (fileno (stdin));\n\t      t = temp ? base_pathname (temp) : \"tty\";\n\t      temp = savestring (t);\n#else\n\t      temp = savestring (\"tty\");\n#endif  \n\t      goto add_string;\n\n#if defined (READLINE)\n\t    case '[':\n\t    case ']':\n\t      if (no_line_editing)\n\t\t{\n\t\t  string++;\n\t\t  break;\n\t\t}\n\t      temp = (char *)xmalloc (3);\n\t      n = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;\n\t      i = 0;\n\t      if (n == CTLESC || n == CTLNUL)\n\t\ttemp[i++] = CTLESC;\n\t      temp[i++] = n;\n\t      temp[i] = '\\0';\n\t      goto add_string;\n#endif  \n\n\t    case '\\\\':\n\t    case 'a':\n\t    case 'e':\n\t    case 'r':\n\t      temp = (char *)xmalloc (2);\n\t      if (c == 'a')\n\t\ttemp[0] = '\\07';\n\t      else if (c == 'e')\n\t\ttemp[0] = '\\033';\n\t      else if (c == 'r')\n\t\ttemp[0] = '\\r';\n\t      else\t\t\t \n\t        temp[0] = c;\n\t      temp[1] = '\\0';\n\t      goto add_string;\n\n\t    default:\nnot_escape:\n\t      temp = (char *)xmalloc (3);\n\t      temp[0] = '\\\\';\n\t      temp[1] = c;\n\t      temp[2] = '\\0';\n\n\t    add_string:\n\t      if (c)\n\t\tstring++;\n\t      result =\n\t\tsub_append_string (temp, result, &result_index, &result_size);\n\t      temp = (char *)NULL;  \n\t      result[result_index] = '\\0';\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, PROMPT_GROWTH);\n\t   \n\t  if (c == CTLESC || c == CTLNUL)\n\t    result[result_index++] = CTLESC;\n\t  result[result_index++] = c;\n\t  result[result_index] = '\\0';\n\t}\n    }\n#else  \n  result = savestring (string);\n#endif  \n\n   \n  save_dstack = dstack;\n  dstack = temp_dstack;\n  dstack.delimiter_depth = 0;\n\n   \n  if (promptvars || posixly_correct)\n    {\n      last_exit_value = last_command_exit_value;\n      last_comsub_pid = last_command_subst_pid;\n      list = expand_prompt_string (result, Q_DOUBLE_QUOTES, 0);\n      free (result);\n      result = string_list (list);\n      dispose_words (list);\n      last_command_exit_value = last_exit_value;\n      last_command_subst_pid = last_comsub_pid;\n    }\n  else\n    {\n      t = dequote_string (result);\n      free (result);\n      result = t;\n    }\n\n  dstack = save_dstack;\n\n  return (result);\n}\n\n \n\n \nint\nyyerror (msg)\n     const char *msg;\n{\n  if ((parser_state & PST_NOERROR) == 0)\n    report_syntax_error ((char *)NULL);\n  reset_parser ();\n  return (0);\n}\n\nstatic char *\nerror_token_from_token (tok)\n     int tok;\n{\n  char *t;\n\n  if (t = find_token_in_alist (tok, word_token_alist, 0))\n    return t;\n\n  if (t = find_token_in_alist (tok, other_token_alist, 0))\n    return t;\n\n  t = (char *)NULL;\n   \n  switch (current_token)\n    {\n    case WORD:\n    case ASSIGNMENT_WORD:\n      if (yylval.word)\n\tt = savestring (yylval.word->word);\n      break;\n    case NUMBER:\n      t = itos (yylval.number);\n      break;\n    case ARITH_CMD:\n      if (yylval.word_list)\n        t = string_list (yylval.word_list);\n      break;\n    case ARITH_FOR_EXPRS:\n      if (yylval.word_list)\n\tt = string_list_internal (yylval.word_list, \" ; \");\n      break;\n    case COND_CMD:\n      t = (char *)NULL;\t\t \n      break;\n    }\n\n  return t;\n}\n\nstatic char *\nerror_token_from_text ()\n{\n  char *msg, *t;\n  int token_end, i;\n\n  t = shell_input_line;\n  i = shell_input_line_index;\n  token_end = 0;\n  msg = (char *)NULL;\n\n  if (i && t[i] == '\\0')\n    i--;\n\n  while (i && (whitespace (t[i]) || t[i] == '\\n'))\n    i--;\n\n  if (i)\n    token_end = i + 1;\n\n  while (i && (member (t[i], \" \\n\\t;|&\") == 0))\n    i--;\n\n  while (i != token_end && (whitespace (t[i]) || t[i] == '\\n'))\n    i++;\n\n   \n  if (token_end || (i == 0 && token_end == 0))\n    {\n      if (token_end)\n\tmsg = substring (t, i, token_end);\n      else\t \n\t{\n\t  msg = (char *)xmalloc (2);\n\t  msg[0] = t[i];\n\t  msg[1] = '\\0';\n\t}\n    }\n\n  return (msg);\n}\n\nstatic void\nprint_offending_line ()\n{\n  char *msg;\n  int token_end;\n\n  msg = savestring (shell_input_line);\n  token_end = strlen (msg);\n  while (token_end && msg[token_end - 1] == '\\n')\n    msg[--token_end] = '\\0';\n\n  parser_error (line_number, \"`%s'\", msg);\n  free (msg);\n}\n\n \nstatic void\nreport_syntax_error (message)\n     char *message;\n{\n  char *msg, *p;\n\n  if (message)\n    {\n      parser_error (line_number, \"%s\", message);\n      if (interactive && EOF_Reached)\n\tEOF_Reached = 0;\n      last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;\n      set_pipestatus_from_exit (last_command_exit_value);\n      return;\n    }\n\n   \n  if (current_token != 0 && EOF_Reached == 0 && (msg = error_token_from_token (current_token)))\n    {\n      if (ansic_shouldquote (msg))\n\t{\n\t  p = ansic_quote (msg, 0, NULL);\n\t  free (msg);\n\t  msg = p;\n\t}\n      parser_error (line_number, _(\"syntax error near unexpected token `%s'\"), msg);\n      free (msg);\n\n      if (interactive == 0)\n\tprint_offending_line ();\n\n      last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;\n      set_pipestatus_from_exit (last_command_exit_value);\n      return;\n    }\n\n   \n  if (shell_input_line && *shell_input_line)\n    {\n      msg = error_token_from_text ();\n      if (msg)\n\t{\n\t  parser_error (line_number, _(\"syntax error near `%s'\"), msg);\n\t  free (msg);\n\t}\n\n       \n      if (interactive == 0)\n        print_offending_line ();\n    }\n  else\n    {\n      if (EOF_Reached && shell_eof_token && current_token != shell_eof_token)\n\tparser_error (line_number, _(\"unexpected EOF while looking for matching `%c'\"), shell_eof_token);\n      else\n\t{\n\t  msg = EOF_Reached ? _(\"syntax error: unexpected end of file\") : _(\"syntax error\");\n\t  parser_error (line_number, \"%s\", msg);\n\t}\n\n       \n      if (interactive && EOF_Reached)\n\tEOF_Reached = 0;\n    }\n\n  last_command_exit_value = (executing_builtin && parse_and_execute_level) ? EX_BADSYNTAX : EX_BADUSAGE;\n  set_pipestatus_from_exit (last_command_exit_value);\n}\n\n \nstatic void\ndiscard_parser_constructs (error_p)\n     int error_p;\n{\n}\n\n \n\n \n\n \nint ignoreeof = 0;\n\n \nint eof_encountered = 0;\n\n \nint eof_encountered_limit = 10;\n\n \nstatic void\nhandle_eof_input_unit ()\n{\n  if (interactive)\n    {\n       \n      if (EOF_Reached)\n\tEOF_Reached = 0;\n\n       \n      if (ignoreeof)\n\t{\n\t  if (eof_encountered < eof_encountered_limit)\n\t    {\n\t      fprintf (stderr, _(\"Use \\\"%s\\\" to leave the shell.\\n\"),\n\t\t       login_shell ? \"logout\" : \"exit\");\n\t      eof_encountered++;\n\t       \n\t      last_read_token = current_token = '\\n';\n\t       \n\t      prompt_string_pointer = (char **)NULL;\n\t      prompt_again (0);\n\t      return;\n\t    }\n\t}\n\n       \n      reset_parser ();\n\n      last_shell_builtin = this_shell_builtin;\n      this_shell_builtin = exit_builtin;\n      exit_builtin ((WORD_LIST *)NULL);\n    }\n  else\n    {\n       \n      EOF_Reached = 1;\n    }\n}\n\n \n\n \n\nstatic WORD_LIST parse_string_error;\n\n \nWORD_LIST *\nparse_string_to_word_list (s, flags, whom)\n     char *s;\n     int flags;\n     const char *whom;\n{\n  WORD_LIST *wl;\n  int tok, orig_current_token, orig_line_number;\n  int orig_parser_state;\n  sh_parser_state_t ps;\n  int ea;\n\n  orig_line_number = line_number;\n  save_parser_state (&ps);\n\n#if defined (HISTORY)\n  bash_history_disable ();\n#endif\n\n  push_stream (1);\n  if (ea = expanding_alias ())\n    parser_save_alias ();\n\n   \n  last_read_token = WORD;\n\n  current_command_line_count = 0;\n  echo_input_at_read = expand_aliases = 0;\n\n  with_input_from_string (s, whom);\n  wl = (WORD_LIST *)NULL;\n\n  if (flags & 1)\n    {\n      orig_parser_state = parser_state;\t\t \n       \n      parser_state &= ~PST_NOEXPAND;\t \n       \n      parser_state |= PST_COMPASSIGN|PST_REPARSE|PST_STRING;\n    }\n\n  while ((tok = read_token (READ)) != yacc_EOF)\n    {\n      if (tok == '\\n' && *bash_input.location.string == '\\0')\n\tbreak;\n      if (tok == '\\n')\t\t \n\tcontinue;\n      if (tok != WORD && tok != ASSIGNMENT_WORD)\n\t{\n\t  line_number = orig_line_number + line_number - 1;\n\t  orig_current_token = current_token;\n\t  current_token = tok;\n\t  yyerror (NULL);\t \n\t  current_token = orig_current_token;\n\t  if (wl)\n\t    dispose_words (wl);\n\t  wl = &parse_string_error;\n\t  break;\n\t}\n      wl = make_word_list (yylval.word, wl);\n    }\n  \n  last_read_token = '\\n';\n  pop_stream ();\n\n  if (ea)\n    parser_restore_alias ();\n\n  restore_parser_state (&ps);\n\n  if (flags & 1)\n    parser_state = orig_parser_state;\t \n\n  if (wl == &parse_string_error)\n    {\n      set_exit_status (EXECUTION_FAILURE);\n      if (interactive_shell == 0 && posixly_correct)\n\tjump_to_top_level (FORCE_EOF);\n      else\n\tjump_to_top_level (DISCARD);\n    }\n\n  return (REVERSE_LIST (wl, WORD_LIST *));\n}\n\nstatic char *\nparse_compound_assignment (retlenp)\n     int *retlenp;\n{\n  WORD_LIST *wl, *rl;\n  int tok, orig_line_number, assignok;\n  sh_parser_state_t ps;\n  char *ret;\n\n  orig_line_number = line_number;\n  save_parser_state (&ps);\n\n   \n  last_read_token = WORD;\n\n  token = (char *)NULL;\n  token_buffer_size = 0;\n  wl = (WORD_LIST *)NULL;\t \n\n  assignok = parser_state&PST_ASSIGNOK;\t\t \n\n   \n  parser_state &= ~(PST_NOEXPAND|PST_CONDCMD|PST_CONDEXPR|PST_REGEXP|PST_EXTPAT);\n   \n  parser_state |= PST_COMPASSIGN;\n\n  esacs_needed_count = expecting_in_token = 0;\n\n  while ((tok = read_token (READ)) != ')')\n    {\n      if (tok == '\\n')\t\t\t \n\t{\n\t  if (SHOULD_PROMPT ())\n\t    prompt_again (0);\n\t  continue;\n\t}\n      if (tok != WORD && tok != ASSIGNMENT_WORD)\n\t{\n\t  current_token = tok;\t \n\t  if (tok == yacc_EOF)\t \n\t    parser_error (orig_line_number, _(\"unexpected EOF while looking for matching `)'\"));\n\t  else\n\t    yyerror(NULL);\t \n\t  if (wl)\n\t    dispose_words (wl);\n\t  wl = &parse_string_error;\n\t  break;\n\t}\n      wl = make_word_list (yylval.word, wl);\n    }\n\n  restore_parser_state (&ps);\n\n  if (wl == &parse_string_error)\n    {\n      set_exit_status (EXECUTION_FAILURE);\n      last_read_token = '\\n';\t \n      if (interactive_shell == 0 && posixly_correct)\n\tjump_to_top_level (FORCE_EOF);\n      else\n\tjump_to_top_level (DISCARD);\n    }\n\n  if (wl)\n    {\n      rl = REVERSE_LIST (wl, WORD_LIST *);\n      ret = string_list (rl);\n      dispose_words (rl);\n    }\n  else\n    ret = (char *)NULL;\n\n  if (retlenp)\n    *retlenp = (ret && *ret) ? strlen (ret) : 0;\n\n  if (assignok)\n    parser_state |= PST_ASSIGNOK;\n\n  return ret;\n}\n\n \n\nsh_parser_state_t *\nsave_parser_state (ps)\n     sh_parser_state_t *ps;\n{\n  if (ps == 0)\n    ps = (sh_parser_state_t *)xmalloc (sizeof (sh_parser_state_t));\n  if (ps == 0)\n    return ((sh_parser_state_t *)NULL);\n\n  ps->parser_state = parser_state;\n  ps->token_state = save_token_state ();\n\n  ps->input_line_terminator = shell_input_line_terminator;\n  ps->eof_encountered = eof_encountered;\n  ps->eol_lookahead = eol_ungetc_lookahead;\n\n  ps->prompt_string_pointer = prompt_string_pointer;\n\n  ps->current_command_line_count = current_command_line_count;\n\n#if defined (HISTORY)\n  ps->remember_on_history = remember_on_history;\n#  if defined (BANG_HISTORY)\n  ps->history_expansion_inhibited = history_expansion_inhibited;\n#  endif\n#endif\n\n  ps->last_command_exit_value = last_command_exit_value;\n#if defined (ARRAY_VARS)\n  ps->pipestatus = save_pipestatus_array ();\n#endif\n    \n  ps->last_shell_builtin = last_shell_builtin;\n  ps->this_shell_builtin = this_shell_builtin;\n\n  ps->expand_aliases = expand_aliases;\n  ps->echo_input_at_read = echo_input_at_read;\n  ps->need_here_doc = need_here_doc;\n  ps->here_doc_first_line = here_doc_first_line;\n\n  ps->esacs_needed = esacs_needed_count;\n  ps->expecting_in = expecting_in_token;\n\n  if (need_here_doc == 0)\n    ps->redir_stack[0] = 0;\n  else\n    memcpy (ps->redir_stack, redir_stack, sizeof (redir_stack[0]) * HEREDOC_MAX);\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  ps->pushed_strings = pushed_string_list;\n#endif\n\n  ps->eof_token = shell_eof_token;\n  ps->token = token;\n  ps->token_buffer_size = token_buffer_size;\n   \n  token = 0;\n  token_buffer_size = 0;\n\n  return (ps);\n}\n\nvoid\nrestore_parser_state (ps)\n     sh_parser_state_t *ps;\n{\n  int i;\n\n  if (ps == 0)\n    return;\n\n  parser_state = ps->parser_state;\n  if (ps->token_state)\n    {\n      restore_token_state (ps->token_state);\n      free (ps->token_state);\n    }\n\n  shell_input_line_terminator = ps->input_line_terminator;\n  eof_encountered = ps->eof_encountered;\n  eol_ungetc_lookahead = ps->eol_lookahead;\n\n  prompt_string_pointer = ps->prompt_string_pointer;\n\n  current_command_line_count = ps->current_command_line_count;\n\n#if defined (HISTORY)\n  remember_on_history = ps->remember_on_history;\n#  if defined (BANG_HISTORY)\n  history_expansion_inhibited = ps->history_expansion_inhibited;\n#  endif\n#endif\n\n  last_command_exit_value = ps->last_command_exit_value;\n#if defined (ARRAY_VARS)\n  restore_pipestatus_array (ps->pipestatus);\n#endif\n\n  last_shell_builtin = ps->last_shell_builtin;\n  this_shell_builtin = ps->this_shell_builtin;\n\n  expand_aliases = ps->expand_aliases;\n  echo_input_at_read = ps->echo_input_at_read;\n  need_here_doc = ps->need_here_doc;\n  here_doc_first_line = ps->here_doc_first_line;\n\n  esacs_needed_count = ps->esacs_needed;\n  expecting_in_token = ps->expecting_in;\n\n#if 0\n  for (i = 0; i < HEREDOC_MAX; i++)\n    redir_stack[i] = ps->redir_stack[i];\n#else\n  if (need_here_doc == 0)\n    redir_stack[0] = 0;\n  else\n    memcpy (redir_stack, ps->redir_stack, sizeof (redir_stack[0]) * HEREDOC_MAX);\n#endif\n\n#if defined (ALIAS) || defined (DPAREN_ARITHMETIC)\n  pushed_string_list = (STRING_SAVER *)ps->pushed_strings;\n#endif\n\n  FREE (token);\n  token = ps->token;\n  token_buffer_size = ps->token_buffer_size;\n  shell_eof_token = ps->eof_token;\n}\n\nsh_input_line_state_t *\nsave_input_line_state (ls)\n     sh_input_line_state_t *ls;\n{\n  if (ls == 0)\n    ls = (sh_input_line_state_t *)xmalloc (sizeof (sh_input_line_state_t));\n  if (ls == 0)\n    return ((sh_input_line_state_t *)NULL);\n\n  ls->input_line = shell_input_line;\n  ls->input_line_size = shell_input_line_size;\n  ls->input_line_len = shell_input_line_len;\n  ls->input_line_index = shell_input_line_index;\n\n#if defined (HANDLE_MULTIBYTE)\n  ls->input_property = shell_input_line_property;\n  ls->input_propsize = shell_input_line_propsize;\n#endif\n\n   \n  shell_input_line = 0;\n  shell_input_line_size = shell_input_line_len = shell_input_line_index = 0;\n\n#if defined (HANDLE_MULTIBYTE)\n  shell_input_line_property = 0;\n  shell_input_line_propsize = 0;\n#endif\n\n  return ls;\n}\n\nvoid\nrestore_input_line_state (ls)\n     sh_input_line_state_t *ls;\n{\n  FREE (shell_input_line);\n  shell_input_line = ls->input_line;\n  shell_input_line_size = ls->input_line_size;\n  shell_input_line_len = ls->input_line_len;\n  shell_input_line_index = ls->input_line_index;\n\n#if defined (HANDLE_MULTIBYTE)\n  FREE (shell_input_line_property);\n  shell_input_line_property = ls->input_property;\n  shell_input_line_propsize = ls->input_propsize;\n#endif\n\n#if 0\n  set_line_mbstate ();\n#endif\n}\n\n \n\n#if defined (HANDLE_MULTIBYTE)\n\n \n#define MAX_PROPSIZE 32768\n\nstatic void\nset_line_mbstate ()\n{\n  int c;\n  size_t i, previ, len;\n  mbstate_t mbs, prevs;\n  size_t mbclen;\n  int ilen;\n\n  if (shell_input_line == NULL)\n    return;\n  len = STRLEN (shell_input_line);\t \n  if (len == 0)\n    return;\n  if (shell_input_line_propsize >= MAX_PROPSIZE && len < MAX_PROPSIZE>>1)\n    {\n      free (shell_input_line_property);\n      shell_input_line_property = 0;\n      shell_input_line_propsize = 0;\n    }\n  if (len+1 > shell_input_line_propsize)\n    {\n      shell_input_line_propsize = len + 1;\n      shell_input_line_property = (char *)xrealloc (shell_input_line_property, shell_input_line_propsize);\n    }\n\n  if (locale_mb_cur_max == 1)\n    {\n      memset (shell_input_line_property, 1, len);\n      return;\n    }\n\n   \n  if (locale_utf8locale == 0)\n    memset (&prevs, '\\0', sizeof (mbstate_t));\n\n  for (i = previ = 0; i < len; i++)\n    {\n      if (locale_utf8locale == 0)\n\tmbs = prevs;\n\n      c = shell_input_line[i];\n      if (c == EOF)\n\t{\n\t  size_t j;\n\t  for (j = i; j < len; j++)\n\t    shell_input_line_property[j] = 1;\n\t  break;\n\t}\n\n      if (locale_utf8locale)\n\t{\n\t  if ((unsigned char)shell_input_line[previ] < 128)\t \n\t    mbclen = 1;\n\t  else\n\t    {\n\t      ilen = utf8_mblen (shell_input_line + previ, i - previ + 1);\n\t      mbclen = (ilen == -1) ? (size_t)-1\n\t\t\t\t    : ((ilen == -2) ? (size_t)-2 : (size_t)ilen);\n\t    }\n\t}\n      else\n\tmbclen = mbrlen (shell_input_line + previ, i - previ + 1, &mbs);\n\n      if (mbclen == 1 || mbclen == (size_t)-1)\n\t{\n\t  mbclen = 1;\n\t  previ = i + 1;\n\t}\n      else if (mbclen == (size_t)-2)\n        mbclen = 0;\n      else if (mbclen > 1)\n\t{\n\t  mbclen = 0;\n\t  previ = i + 1;\n\t  if (locale_utf8locale == 0)\n\t    prevs = mbs;\n\t}\n      else\n\t{\n\t  size_t j;\n\t  for (j = i; j < len; j++)\n\t    shell_input_line_property[j] = 1;\n\t  break;\n\t}\n\n      shell_input_line_property[i] = mbclen;\n    }\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}