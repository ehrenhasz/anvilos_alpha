{
  "module_name": "flags.c",
  "hash_id": "14f16d058b0ae8d3412913e45d6d63f7bf641ed158a25b4ea69be73f6ae40722",
  "original_prompt": "Ingested from bash-5.2.21/flags.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"flags.h\"\n\n#if defined (BANG_HISTORY)\n#  include \"bashhist.h\"\n#endif\n\n#if defined (JOB_CONTROL)\nextern int set_job_control PARAMS((int));\n#endif\n\n \n \n \n \n \n\n \nint mark_modified_vars = 0;\n\n \nint asynchronous_notification = 0;\n\n \nint errexit_flag = 0;\nint exit_immediately_on_error = 0;\n\n \nint disallow_filename_globbing = 0;\n\n \nint place_keywords_in_env = 0;\n\n \nint read_but_dont_execute = 0;\n\n \nint just_one_command = 0;\n\n \nint noclobber = 0;\n\n \nint unbound_vars_is_error = 0;\n\n \nint echo_input_at_read = 0;\nint verbose_flag = 0;\n\n \nint echo_command_at_execute = 0;\n\n \nint jobs_m_flag = 0;\n\n \nint forced_interactive = 0;\n\n \nint no_symbolic_links = 0;\n\n \n \n \n \n \n\n#if 0\n \nint lexical_scoping = 0;\n#endif\n\n \nint hashing_enabled = 1;\n\n#if defined (BANG_HISTORY)\n \nint history_expansion = HISTEXPAND_DEFAULT;\nint histexp_flag = 0;\n#endif  \n\n \nint interactive_comments = 1;\n\n#if defined (RESTRICTED_SHELL)\n \nint restricted = 0;\t\t \nint restricted_shell = 0;\t \n#endif  \n\n \nint privileged_mode = 0;\n\n#if defined (BRACE_EXPANSION)\n \nint brace_expansion = 1;\n#endif\n\n \nint function_trace_mode = 0;\n\n \nint error_trace_mode = 0;\n\n \nint pipefail_opt = 0;\n\n \n \n \n \n \n\nconst struct flags_alist shell_flags[] = {\n   \n  { 'a', &mark_modified_vars },\n#if defined (JOB_CONTROL)\n  { 'b', &asynchronous_notification },\n#endif  \n  { 'e', &errexit_flag },\n  { 'f', &disallow_filename_globbing },\n  { 'h', &hashing_enabled },\n  { 'i', &forced_interactive },\n  { 'k', &place_keywords_in_env },\n#if defined (JOB_CONTROL)\n  { 'm', &jobs_m_flag },\n#endif  \n  { 'n', &read_but_dont_execute },\n  { 'p', &privileged_mode },\n#if defined (RESTRICTED_SHELL)\n  { 'r', &restricted },\n#endif  \n  { 't', &just_one_command },\n  { 'u', &unbound_vars_is_error },\n  { 'v', &verbose_flag },\n  { 'x', &echo_command_at_execute },\n\n   \n#if 0\n  { 'l', &lexical_scoping },\n#endif\n#if defined (BRACE_EXPANSION)\n  { 'B', &brace_expansion },\n#endif\n  { 'C', &noclobber },\n  { 'E', &error_trace_mode },\n#if defined (BANG_HISTORY)\n  { 'H', &histexp_flag },\n#endif  \n  { 'P', &no_symbolic_links },\n  { 'T', &function_trace_mode },\n  {0, (int *)NULL}\n};\n\n#define NUM_SHELL_FLAGS (sizeof (shell_flags) / sizeof (struct flags_alist))\n\nchar optflags[NUM_SHELL_FLAGS+4] = { '+' };\n\nint *\nfind_flag (name)\n     int name;\n{\n  int i;\n  for (i = 0; shell_flags[i].name; i++)\n    {\n      if (shell_flags[i].name == name)\n\treturn (shell_flags[i].value);\n    }\n  return (FLAG_UNKNOWN);\n}\n\n \nint\nchange_flag (flag, on_or_off)\n  int flag;\n  int on_or_off;\n{\n  int *value, old_value;\n\n#if defined (RESTRICTED_SHELL)\n   \n  if (restricted && flag == 'r' && on_or_off == FLAG_OFF)\n    return (FLAG_ERROR);\n#endif  \n\n  value = find_flag (flag);\n\n  if ((value == (int *)FLAG_UNKNOWN) || (on_or_off != FLAG_ON && on_or_off != FLAG_OFF))\n    return (FLAG_ERROR);\n\n  old_value = *value;\n  *value = (on_or_off == FLAG_ON) ? 1 : 0;\n\n   \n  switch (flag)\n    {\n#if defined (BANG_HISTORY)\n    case 'H':\n      history_expansion = histexp_flag;\n      if (on_or_off == FLAG_ON)\n\tbash_initialize_history ();\n      break;\n#endif\n\n#if defined (JOB_CONTROL)\n    case 'm':\n      set_job_control (on_or_off == FLAG_ON);\n      break;\n#endif  \n\n    case 'e':\n      if (builtin_ignoring_errexit == 0)\n\texit_immediately_on_error = errexit_flag;\n      break;\n\n    case 'n':\n      if (interactive_shell)\n\tread_but_dont_execute = 0;\n      break;\n\n    case 'p':\n      if (on_or_off == FLAG_OFF)\n\tdisable_priv_mode ();\n      break;\n\n#if defined (RESTRICTED_SHELL)\n    case 'r':\n      if (on_or_off == FLAG_ON && shell_initialized)\n\tmaybe_make_restricted (shell_name);\n      break;\n#endif\n\n    case 'v':\n      echo_input_at_read = verbose_flag;\n      break;\n    }\n\n  return (old_value);\n}\n\n \nchar *\nwhich_set_flags ()\n{\n  char *temp;\n  int i, string_index;\n\n  temp = (char *)xmalloc (1 + NUM_SHELL_FLAGS + read_from_stdin + want_pending_command);\n  for (i = string_index = 0; shell_flags[i].name; i++)\n    if (*(shell_flags[i].value))\n      temp[string_index++] = shell_flags[i].name;\n\n  if (want_pending_command)\n    temp[string_index++] = 'c';\n  if (read_from_stdin)\n    temp[string_index++] = 's';\n\n  temp[string_index] = '\\0';\n  return (temp);\n}\n\nchar *\nget_current_flags ()\n{\n  char *temp;\n  int i;\n\n  temp = (char *)xmalloc (1 + NUM_SHELL_FLAGS);\n  for (i = 0; shell_flags[i].name; i++)\n    temp[i] = *(shell_flags[i].value);\n  temp[i] = '\\0';\n  return (temp);\n}\n\nvoid\nset_current_flags (bitmap)\n     const char *bitmap;\n{\n  int i;\n\n  if (bitmap == 0)\n    return;\n  for (i = 0; shell_flags[i].name; i++)\n    *(shell_flags[i].value) = bitmap[i];\n}\n\nvoid\nreset_shell_flags ()\n{\n  mark_modified_vars = disallow_filename_globbing = 0;\n  place_keywords_in_env = read_but_dont_execute = just_one_command = 0;\n  noclobber = unbound_vars_is_error = 0;\n  echo_command_at_execute = jobs_m_flag = forced_interactive = 0;\n  no_symbolic_links = 0;\n  privileged_mode = pipefail_opt = 0;\n\n  error_trace_mode = function_trace_mode = 0;\n\n  exit_immediately_on_error = errexit_flag = 0;\n  echo_input_at_read = verbose_flag = 0;\n\n  hashing_enabled = interactive_comments = 1;\n\n#if defined (JOB_CONTROL)\n  asynchronous_notification = 0;\n#endif\n\n#if defined (BANG_HISTORY)\n  histexp_flag = 0;\n#endif\n\n#if defined (BRACE_EXPANSION)\n  brace_expansion = 1;\n#endif\n\n#if defined (RESTRICTED_SHELL)\n  restricted = 0;\n#endif\n}\n\nvoid\ninitialize_flags ()\n{\n  register int i;\n\n  for (i = 0; shell_flags[i].name; i++)\n    optflags[i+1] = shell_flags[i].name;\n  optflags[++i] = 'o';\n  optflags[++i] = ';';\n  optflags[i+1] = '\\0';\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}