{
  "module_name": "variables.h",
  "hash_id": "87267789adce498127651d6a832dedf8c4d89828380dd989c2e297a40fff216f",
  "original_prompt": "Ingested from bash-5.2.21/variables.h",
  "human_readable_source": " \n\n \n\n#if !defined (_VARIABLES_H_)\n#define _VARIABLES_H_\n\n#include \"stdc.h\"\n#include \"array.h\"\n#include \"assoc.h\"\n\n \n#include \"hashlib.h\"\n\n#include \"conftypes.h\"\n\n \ntypedef struct var_context {\n  char *name;\t\t \n  int scope;\t\t \n  int flags;\n  struct var_context *up;\t \n  struct var_context *down;\t \n  HASH_TABLE *table;\t\t \n} VAR_CONTEXT;\n\n \n#define VC_HASLOCAL\t0x01\n#define VC_HASTMPVAR\t0x02\n#define VC_FUNCENV\t0x04\t \n#define VC_BLTNENV\t0x08\t \n#define VC_TEMPENV\t0x10\t \n\n#define VC_TEMPFLAGS\t(VC_FUNCENV|VC_BLTNENV|VC_TEMPENV)\n\n \n#define vc_isfuncenv(vc)\t(((vc)->flags & VC_FUNCENV) != 0)\n#define vc_isbltnenv(vc)\t(((vc)->flags & VC_BLTNENV) != 0)\n#define vc_istempenv(vc)\t(((vc)->flags & (VC_TEMPFLAGS)) == VC_TEMPENV)\n\n#define vc_istempscope(vc)\t(((vc)->flags & (VC_TEMPENV|VC_BLTNENV)) != 0)\n\n#define vc_haslocals(vc)\t(((vc)->flags & VC_HASLOCAL) != 0)\n#define vc_hastmpvars(vc)\t(((vc)->flags & VC_HASTMPVAR) != 0)\n\n \n\ntypedef struct variable *sh_var_value_func_t PARAMS((struct variable *));\ntypedef struct variable *sh_var_assign_func_t PARAMS((struct variable *, char *, arrayind_t, char *));\n\n \nunion _value {\n  char *s;\t\t\t \n  intmax_t i;\t\t\t \n  COMMAND *f;\t\t\t \n  ARRAY *a;\t\t\t \n  HASH_TABLE *h;\t\t \n  double d;\t\t\t \n#if defined (HAVE_LONG_DOUBLE)\n  long double ld;\t\t \n#endif\n  struct variable *v;\t\t \n  void *opaque;\t\t\t \n};\n\ntypedef struct variable {\n  char *name;\t\t\t \n  char *value;\t\t\t \n  char *exportstr;\t\t \n  sh_var_value_func_t *dynamic_value;\t \n  sh_var_assign_func_t *assign_func;  \n  int attributes;\t\t \n  int context;\t\t\t \n} SHELL_VAR;\n\ntypedef struct _vlist {\n  SHELL_VAR **list;\n  int list_size;\t \n  int list_len;\t\t \n} VARLIST;\n\n \n \n#define att_exported\t0x0000001\t \n#define att_readonly\t0x0000002\t \n#define att_array\t0x0000004\t \n#define att_function\t0x0000008\t \n#define att_integer\t0x0000010\t \n#define att_local\t0x0000020\t \n#define att_assoc\t0x0000040\t \n#define att_trace\t0x0000080\t \n#define att_uppercase\t0x0000100\t \n#define att_lowercase\t0x0000200\t \n#define att_capcase\t0x0000400\t \n#define att_nameref\t0x0000800\t \n\n#define user_attrs\t(att_exported|att_readonly|att_integer|att_local|att_trace|att_uppercase|att_lowercase|att_capcase|att_nameref)\n\n#define attmask_user\t0x0000fff\n\n \n#define att_invisible\t0x0001000\t \n#define att_nounset\t0x0002000\t \n#define att_noassign\t0x0004000\t \n#define att_imported\t0x0008000\t \n#define att_special\t0x0010000\t \n#define att_nofree\t0x0020000\t \n#define att_regenerate\t0x0040000\t \n\n#define\tattmask_int\t0x00ff000\n\n \n#define att_tempvar\t0x0100000\t \n#define att_propagate\t0x0200000\t \n\n#define attmask_scope\t0x0f00000\n\n#define exported_p(var)\t\t((((var)->attributes) & (att_exported)))\n#define readonly_p(var)\t\t((((var)->attributes) & (att_readonly)))\n#define array_p(var)\t\t((((var)->attributes) & (att_array)))\n#define function_p(var)\t\t((((var)->attributes) & (att_function)))\n#define integer_p(var)\t\t((((var)->attributes) & (att_integer)))\n#define local_p(var)\t\t((((var)->attributes) & (att_local)))\n#define assoc_p(var)\t\t((((var)->attributes) & (att_assoc)))\n#define trace_p(var)\t\t((((var)->attributes) & (att_trace)))\n#define uppercase_p(var)\t((((var)->attributes) & (att_uppercase)))\n#define lowercase_p(var)\t((((var)->attributes) & (att_lowercase)))\n#define capcase_p(var)\t\t((((var)->attributes) & (att_capcase)))\n#define nameref_p(var)\t\t((((var)->attributes) & (att_nameref)))\n\n#define invisible_p(var)\t((((var)->attributes) & (att_invisible)))\n#define non_unsettable_p(var)\t((((var)->attributes) & (att_nounset)))\n#define noassign_p(var)\t\t((((var)->attributes) & (att_noassign)))\n#define imported_p(var)\t\t((((var)->attributes) & (att_imported)))\n#define specialvar_p(var)\t((((var)->attributes) & (att_special)))\n#define nofree_p(var)\t\t((((var)->attributes) & (att_nofree)))\n#define regen_p(var)\t\t((((var)->attributes) & (att_regenerate)))\n\n#define tempvar_p(var)\t\t((((var)->attributes) & (att_tempvar)))\n#define propagate_p(var)\t((((var)->attributes) & (att_propagate)))\n\n \n#define name_cell(var)\t\t((var)->name)\n\n \n#define value_cell(var)\t\t((var)->value)\n#define function_cell(var)\t(COMMAND *)((var)->value)\n#define array_cell(var)\t\t(ARRAY *)((var)->value)\n#define assoc_cell(var)\t\t(HASH_TABLE *)((var)->value)\n#define nameref_cell(var)\t((var)->value)\t\t \n\n#define NAMEREF_MAX\t8\t \n\n#define var_isset(var)\t\t((var)->value != 0)\n#define var_isunset(var)\t((var)->value == 0)\n#define var_isnull(var)\t\t((var)->value && *(var)->value == 0)\n\n \n#define var_setvalue(var, str)\t((var)->value = (str))\n#define var_setfunc(var, func)\t((var)->value = (char *)(func))\n#define var_setarray(var, arr)\t((var)->value = (char *)(arr))\n#define var_setassoc(var, arr)\t((var)->value = (char *)(arr))\n#define var_setref(var, str)\t((var)->value = (str))\n\n \n#define set_auto_export(var) \\\n  do { (var)->attributes |= att_exported; array_needs_making = 1; } while (0)\n\n#define SETVARATTR(var, attr, undo) \\\n\t((undo == 0) ? ((var)->attributes |= (attr)) \\\n\t\t     : ((var)->attributes &= ~(attr)))\n\n#define VSETATTR(var, attr)\t((var)->attributes |= (attr))\n#define VUNSETATTR(var, attr)\t((var)->attributes &= ~(attr))\n\n#define VGETFLAGS(var)\t\t((var)->attributes)\n\n#define VSETFLAGS(var, flags)\t((var)->attributes = (flags))\n#define VCLRFLAGS(var)\t\t((var)->attributes = 0)\n\n \n#define CLEAR_EXPORTSTR(var)\t(var)->exportstr = (char *)NULL\n#define COPY_EXPORTSTR(var)\t((var)->exportstr) ? savestring ((var)->exportstr) : (char *)NULL\n#define SET_EXPORTSTR(var, value)  (var)->exportstr = (value)\n#define SAVE_EXPORTSTR(var, value) (var)->exportstr = (value) ? savestring (value) : (char *)NULL\n\n#define FREE_EXPORTSTR(var) \\\n\tdo { if ((var)->exportstr) free ((var)->exportstr); } while (0)\n\n#define CACHE_IMPORTSTR(var, value) \\\n\t(var)->exportstr = savestring (value)\n\n#define INVALIDATE_EXPORTSTR(var) \\\n\tdo { \\\n\t  if ((var)->exportstr) \\\n\t    { \\\n\t      free ((var)->exportstr); \\\n\t      (var)->exportstr = (char *)NULL; \\\n\t    } \\\n\t} while (0)\n\n#define ifsname(s)\t((s)[0] == 'I' && (s)[1] == 'F' && (s)[2] == 'S' && (s)[3] == '\\0')\n\n \n#define MKLOC_ASSOCOK\t\t0x01\n#define MKLOC_ARRAYOK\t\t0x02\n#define MKLOC_INHERIT\t\t0x04\n\n \nextern SHELL_VAR nameref_invalid_value;\n#define INVALID_NAMEREF_VALUE\t(void *)&nameref_invalid_value\n\t\n \ntypedef int sh_var_map_func_t PARAMS((SHELL_VAR *));\n\n \nextern VAR_CONTEXT *global_variables;\nextern VAR_CONTEXT *shell_variables;\n\nextern HASH_TABLE *shell_functions;\nextern HASH_TABLE *temporary_env;\n\nextern int variable_context;\nextern char *dollar_vars[];\nextern char **export_env;\n\nextern int tempenv_assign_error;\nextern int array_needs_making;\nextern int shell_level;\n\n \nextern WORD_LIST *rest_of_args;\nextern int posparam_count;\nextern pid_t dollar_dollar_pid;\n\nextern int localvar_inherit;\t\t \n\nextern void initialize_shell_variables PARAMS((char **, int));\n\nextern int validate_inherited_value PARAMS((SHELL_VAR *, int));\n\nextern SHELL_VAR *set_if_not PARAMS((char *, char *));\n\nextern void sh_set_lines_and_columns PARAMS((int, int));\nextern void set_pwd PARAMS((void));\nextern void set_ppid PARAMS((void));\nextern void make_funcname_visible PARAMS((int));\n\nextern SHELL_VAR *var_lookup PARAMS((const char *, VAR_CONTEXT *));\n\nextern SHELL_VAR *find_function PARAMS((const char *));\nextern FUNCTION_DEF *find_function_def PARAMS((const char *));\nextern SHELL_VAR *find_variable PARAMS((const char *));\nextern SHELL_VAR *find_variable_noref PARAMS((const char *));\nextern SHELL_VAR *find_variable_last_nameref PARAMS((const char *, int));\nextern SHELL_VAR *find_global_variable_last_nameref PARAMS((const char *, int));\nextern SHELL_VAR *find_variable_nameref PARAMS((SHELL_VAR *));\nextern SHELL_VAR *find_variable_nameref_for_create PARAMS((const char *, int));\nextern SHELL_VAR *find_variable_nameref_for_assignment PARAMS((const char *, int));\n \nextern SHELL_VAR *find_variable_tempenv PARAMS((const char *));\nextern SHELL_VAR *find_variable_notempenv PARAMS((const char *));\nextern SHELL_VAR *find_global_variable PARAMS((const char *));\nextern SHELL_VAR *find_global_variable_noref PARAMS((const char *));\nextern SHELL_VAR *find_shell_variable PARAMS((const char *));\nextern SHELL_VAR *find_tempenv_variable PARAMS((const char *));\nextern SHELL_VAR *find_variable_no_invisible PARAMS((const char *));\nextern SHELL_VAR *find_variable_for_assignment PARAMS((const char *));\nextern char *nameref_transform_name PARAMS((char *, int));\nextern SHELL_VAR *copy_variable PARAMS((SHELL_VAR *));\nextern SHELL_VAR *make_local_variable PARAMS((const char *, int));\nextern SHELL_VAR *bind_variable PARAMS((const char *, char *, int));\nextern SHELL_VAR *bind_global_variable PARAMS((const char *, char *, int));\nextern SHELL_VAR *bind_function PARAMS((const char *, COMMAND *));\n\nextern void bind_function_def PARAMS((const char *, FUNCTION_DEF *, int));\n\nextern SHELL_VAR **map_over PARAMS((sh_var_map_func_t *, VAR_CONTEXT *));\nSHELL_VAR **map_over_funcs PARAMS((sh_var_map_func_t *));\n     \nextern SHELL_VAR **all_shell_variables PARAMS((void));\nextern SHELL_VAR **all_shell_functions PARAMS((void));\nextern SHELL_VAR **all_visible_variables PARAMS((void));\nextern SHELL_VAR **all_visible_functions PARAMS((void));\nextern SHELL_VAR **all_exported_variables PARAMS((void));\nextern SHELL_VAR **local_exported_variables PARAMS((void));\nextern SHELL_VAR **all_local_variables PARAMS((int));\n#if defined (ARRAY_VARS)\nextern SHELL_VAR **all_array_variables PARAMS((void));\n#endif\nextern char **all_variables_matching_prefix PARAMS((const char *));\n\nextern char **make_var_array PARAMS((HASH_TABLE *));\nextern char **add_or_supercede_exported_var PARAMS((char *, int));\n\nextern char *get_variable_value PARAMS((SHELL_VAR *));\nextern char *get_string_value PARAMS((const char *));\nextern char *sh_get_env_value PARAMS((const char *));\nextern char *make_variable_value PARAMS((SHELL_VAR *, char *, int));\n\nextern SHELL_VAR *bind_variable_value PARAMS((SHELL_VAR *, char *, int));\nextern SHELL_VAR *bind_int_variable PARAMS((char *, char *, int));\nextern SHELL_VAR *bind_var_to_int PARAMS((char *, intmax_t, int));\n\nextern int assign_in_env PARAMS((WORD_DESC *, int));\n\nextern int unbind_variable PARAMS((const char *));\nextern int check_unbind_variable PARAMS((const char *));\nextern int unbind_nameref PARAMS((const char *));\nextern int unbind_variable_noref PARAMS((const char *));\nextern int unbind_global_variable PARAMS((const char *));\nextern int unbind_global_variable_noref PARAMS((const char *));\nextern int unbind_func PARAMS((const char *));\nextern int unbind_function_def PARAMS((const char *));\nextern int delete_var PARAMS((const char *, VAR_CONTEXT *));\nextern int makunbound PARAMS((const char *, VAR_CONTEXT *));\nextern int kill_local_variable PARAMS((const char *));\n\nextern void delete_all_variables PARAMS((HASH_TABLE *));\nextern void delete_all_contexts PARAMS((VAR_CONTEXT *));\nextern void reset_local_contexts PARAMS((void));\n\nextern VAR_CONTEXT *new_var_context PARAMS((char *, int));\nextern void dispose_var_context PARAMS((VAR_CONTEXT *));\nextern VAR_CONTEXT *push_var_context PARAMS((char *, int, HASH_TABLE *));\nextern void pop_var_context PARAMS((void));\nextern VAR_CONTEXT *push_scope PARAMS((int, HASH_TABLE *));\nextern void pop_scope PARAMS((int));\n\nextern void clear_dollar_vars PARAMS((void));\n\nextern void push_context PARAMS((char *, int, HASH_TABLE *));\nextern void pop_context PARAMS((void));\nextern void push_dollar_vars PARAMS((void));\nextern void pop_dollar_vars PARAMS((void));\nextern void dispose_saved_dollar_vars PARAMS((void));\n\nextern void init_bash_argv PARAMS((void));\nextern void save_bash_argv PARAMS((void));\nextern void push_args PARAMS((WORD_LIST *));\nextern void pop_args PARAMS((void));\n\nextern void adjust_shell_level PARAMS((int));\nextern void non_unsettable PARAMS((char *));\nextern void dispose_variable PARAMS((SHELL_VAR *));\nextern void dispose_used_env_vars PARAMS((void));\nextern void dispose_function_env PARAMS((void));\nextern void dispose_builtin_env PARAMS((void));\nextern void merge_temporary_env PARAMS((void));\nextern void flush_temporary_env PARAMS((void));\nextern void merge_builtin_env PARAMS((void));\nextern void kill_all_local_variables PARAMS((void));\n\nextern void set_var_read_only PARAMS((char *));\nextern void set_func_read_only PARAMS((const char *));\nextern void set_var_auto_export PARAMS((char *));\nextern void set_func_auto_export PARAMS((const char *));\n\nextern void sort_variables PARAMS((SHELL_VAR **));\n\nextern int chkexport PARAMS((char *));\nextern void maybe_make_export_env PARAMS((void));\nextern void update_export_env_inplace PARAMS((char *, int, char *));\nextern void put_command_name_into_env PARAMS((char *));\nextern void put_gnu_argv_flags_into_env PARAMS((intmax_t, char *));\n\nextern void print_var_list PARAMS((SHELL_VAR **));\nextern void print_func_list PARAMS((SHELL_VAR **));\nextern void print_assignment PARAMS((SHELL_VAR *));\nextern void print_var_value PARAMS((SHELL_VAR *, int));\nextern void print_var_function PARAMS((SHELL_VAR *));\n\n#if defined (ARRAY_VARS)\nextern SHELL_VAR *make_new_array_variable PARAMS((char *));\nextern SHELL_VAR *make_local_array_variable PARAMS((char *, int));\n\nextern SHELL_VAR *make_new_assoc_variable PARAMS((char *));\nextern SHELL_VAR *make_local_assoc_variable PARAMS((char *, int));\n\nextern void set_pipestatus_array PARAMS((int *, int));\nextern ARRAY *save_pipestatus_array PARAMS((void));\nextern void restore_pipestatus_array PARAMS((ARRAY *));\n#endif\n\nextern void set_pipestatus_from_exit PARAMS((int));\n\n \nextern void stupidly_hack_special_variables PARAMS((char *));\n\n \nextern void reinit_special_variables PARAMS((void));\n\nextern int get_random_number PARAMS((void));\n\n \nextern void sv_ifs PARAMS((char *));\nextern void sv_path PARAMS((char *));\nextern void sv_mail PARAMS((char *));\nextern void sv_funcnest PARAMS((char *));\nextern void sv_execignore PARAMS((char *));\nextern void sv_globignore PARAMS((char *));\nextern void sv_ignoreeof PARAMS((char *));\nextern void sv_strict_posix PARAMS((char *));\nextern void sv_optind PARAMS((char *));\nextern void sv_opterr PARAMS((char *));\nextern void sv_locale PARAMS((char *));\nextern void sv_xtracefd PARAMS((char *));\nextern void sv_shcompat PARAMS((char *));\n\n#if defined (READLINE)\nextern void sv_comp_wordbreaks PARAMS((char *));\nextern void sv_terminal PARAMS((char *));\nextern void sv_hostfile PARAMS((char *));\nextern void sv_winsize PARAMS((char *));\n#endif\n\n#if defined (__CYGWIN__)\nextern void sv_home PARAMS((char *));\n#endif\n\n#if defined (HISTORY)\nextern void sv_histsize PARAMS((char *));\nextern void sv_histignore PARAMS((char *));\nextern void sv_history_control PARAMS((char *));\n#  if defined (BANG_HISTORY)\nextern void sv_histchars PARAMS((char *));\n#  endif\nextern void sv_histtimefmt PARAMS((char *));\n#endif  \n\n#if defined (HAVE_TZSET)\nextern void sv_tz PARAMS((char *));\n#endif\n\n#if defined (JOB_CONTROL)\nextern void sv_childmax PARAMS((char *));\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}