{
  "module_name": "plural.y",
  "hash_id": "acea0e2a783d8ce8fd4490986c0a4a111b09a85eaebf76b96720100b9c5b5abe",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/plural.y",
  "human_readable_source": "%{\n/* plural.y - Expression parsing for plural form selection. */\n\n/* Copyright (C) 2000, 2001, 2005-2009 Free Software Foundation, Inc.\n   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.\n\n   This file is part of GNU Bash.\n\n   Bash is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   Bash is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with Bash.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* The bison generated parser uses alloca.  AIX 3 forces us to put this\n   declaration at the beginning of the file.  The declaration in bison's\n   skeleton file comes too late.  This must come before <config.h>\n   because <config.h> may include arbitrary system headers.  */\n#if defined _AIX && !defined __GNUC__\n #pragma alloca\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stddef.h>\n#include <stdlib.h>\n#include \"plural-exp.h\"\n\n/* The main function generated by the parser is called __gettextparse,\n   but we want it to be called PLURAL_PARSE.  */\n#ifndef _LIBC\n# define __gettextparse PLURAL_PARSE\n#endif\n\n#define YYLEX_PARAM\t&((struct parse_args *) arg)->cp\n#define YYPARSE_PARAM\targ\n%}\n%pure_parser\n%expect 7\n\n%union {\n  unsigned long int num;\n  enum operator op;\n  struct expression *exp;\n}\n\n%{\n/* Prototypes for local functions.  */\nstatic struct expression *new_exp PARAMS ((int nargs, enum operator op,\n\t\t\t\t\t   struct expression * const *args));\nstatic inline struct expression *new_exp_0 PARAMS ((enum operator op));\nstatic inline struct expression *new_exp_1 PARAMS ((enum operator op,\n\t\t\t\t\t\t   struct expression *right));\nstatic struct expression *new_exp_2 PARAMS ((enum operator op,\n\t\t\t\t\t     struct expression *left,\n\t\t\t\t\t     struct expression *right));\nstatic inline struct expression *new_exp_3 PARAMS ((enum operator op,\n\t\t\t\t\t\t   struct expression *bexp,\n\t\t\t\t\t\t   struct expression *tbranch,\n\t\t\t\t\t\t   struct expression *fbranch));\nstatic int yylex PARAMS ((YYSTYPE *lval, const char **pexp));\nstatic void yyerror PARAMS ((const char *str));\n\n/* Allocation of expressions.  */\n\nstatic struct expression *\nnew_exp (nargs, op, args)\n     int nargs;\n     enum operator op;\n     struct expression * const *args;\n{\n  int i;\n  struct expression *newp;\n\n  /* If any of the argument could not be malloc'ed, just return NULL.  */\n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n  /* Allocate a new expression.  */\n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}\n\nstatic inline struct expression *\nnew_exp_0 (op)\n     enum operator op;\n{\n  return new_exp (0, op, NULL);\n}\n\nstatic inline struct expression *\nnew_exp_1 (op, right)\n     enum operator op;\n     struct expression *right;\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}\n\nstatic struct expression *\nnew_exp_2 (op, left, right)\n     enum operator op;\n     struct expression *left;\n     struct expression *right;\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}\n\nstatic inline struct expression *\nnew_exp_3 (op, bexp, tbranch, fbranch)\n     enum operator op;\n     struct expression *bexp;\n     struct expression *tbranch;\n     struct expression *fbranch;\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}\n\n%}\n\n/* This declares that all operators have the same associativity and the\n   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].\n   There is no unary minus and no bitwise operators.\n   Operators with the same syntactic behaviour have been merged into a single\n   token, to save space in the array generated by bison.  */\n%right '?'\t\t/*   ?\t\t*/\n%left '|'\t\t/*   ||\t\t*/\n%left '&'\t\t/*   &&\t\t*/\n%left EQUOP2\t\t/*   == !=\t*/\n%left CMPOP2\t\t/*   < > <= >=\t*/\n%left ADDOP2\t\t/*   + -\t*/\n%left MULOP2\t\t/*   * / %\t*/\n%right '!'\t\t/*   !\t\t*/\n\n%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2\n%token <num> NUMBER\n%type <exp> exp\n\n%%\n\nstart:\t  exp\n\t  {\n\t    if ($1 == NULL)\n\t      YYABORT;\n\t    ((struct parse_args *) arg)->res = $1;\n\t  }\n\t;\n\nexp:\t  exp '?' exp ':' exp\n\t  {\n\t    $$ = new_exp_3 (qmop, $1, $3, $5);\n\t  }\n\t| exp '|' exp\n\t  {\n\t    $$ = new_exp_2 (lor, $1, $3);\n\t  }\n\t| exp '&' exp\n\t  {\n\t    $$ = new_exp_2 (land, $1, $3);\n\t  }\n\t| exp EQUOP2 exp\n\t  {\n\t    $$ = new_exp_2 ($2, $1, $3);\n\t  }\n\t| exp CMPOP2 exp\n\t  {\n\t    $$ = new_exp_2 ($2, $1, $3);\n\t  }\n\t| exp ADDOP2 exp\n\t  {\n\t    $$ = new_exp_2 ($2, $1, $3);\n\t  }\n\t| exp MULOP2 exp\n\t  {\n\t    $$ = new_exp_2 ($2, $1, $3);\n\t  }\n\t| '!' exp\n\t  {\n\t    $$ = new_exp_1 (lnot, $2);\n\t  }\n\t| 'n'\n\t  {\n\t    $$ = new_exp_0 (var);\n\t  }\n\t| NUMBER\n\t  {\n\t    if (($$ = new_exp_0 (num)) != NULL)\n\t      $$->val.num = $1;\n\t  }\n\t| '(' exp ')'\n\t  {\n\t    $$ = $2;\n\t  }\n\t;\n\n%%\n\nvoid\ninternal_function\nFREE_EXPRESSION (exp)\n     struct expression *exp;\n{\n  if (exp == NULL)\n    return;\n\n  /* Handle the recursive case.  */\n  switch (exp->nargs)\n    {\n    case 3:\n      FREE_EXPRESSION (exp->val.args[2]);\n      /* FALLTHROUGH */\n    case 2:\n      FREE_EXPRESSION (exp->val.args[1]);\n      /* FALLTHROUGH */\n    case 1:\n      FREE_EXPRESSION (exp->val.args[0]);\n      /* FALLTHROUGH */\n    default:\n      break;\n    }\n\n  free (exp);\n}\n\n\nstatic int\nyylex (lval, pexp)\n     YYSTYPE *lval;\n     const char **pexp;\n{\n  const char *exp = *pexp;\n  int result;\n\n  while (1)\n    {\n      if (exp[0] == '\\0')\n\t{\n\t  *pexp = exp;\n\t  return YYEOF;\n\t}\n\n      if (exp[0] != ' ' && exp[0] != '\\t')\n\tbreak;\n\n      ++exp;\n    }\n\n  result = *exp++;\n  switch (result)\n    {\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      {\n\tunsigned long int n = result - '0';\n\twhile (exp[0] >= '0' && exp[0] <= '9')\n\t  {\n\t    n *= 10;\n\t    n += exp[0] - '0';\n\t    ++exp;\n\t  }\n\tlval->num = n;\n\tresult = NUMBER;\n      }\n      break;\n\n    case '=':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = equal;\n\t  result = EQUOP2;\n\t}\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '!':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = not_equal;\n\t  result = EQUOP2;\n\t}\n      break;\n\n    case '&':\n    case '|':\n      if (exp[0] == result)\n\t++exp;\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '<':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = less_or_equal;\n\t}\n      else\n\tlval->op = less_than;\n      result = CMPOP2;\n      break;\n\n    case '>':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = greater_or_equal;\n\t}\n      else\n\tlval->op = greater_than;\n      result = CMPOP2;\n      break;\n\n    case '*':\n      lval->op = mult;\n      result = MULOP2;\n      break;\n\n    case '/':\n      lval->op = divide;\n      result = MULOP2;\n      break;\n\n    case '%':\n      lval->op = module;\n      result = MULOP2;\n      break;\n\n    case '+':\n      lval->op = plus;\n      result = ADDOP2;\n      break;\n\n    case '-':\n      lval->op = minus;\n      result = ADDOP2;\n      break;\n\n    case 'n':\n    case '?':\n    case ':':\n    case '(':\n    case ')':\n      /* Nothing, just return the character.  */\n      break;\n\n    case ';':\n    case '\\n':\n    case '\\0':\n      /* Be safe and let the user call this function again.  */\n      --exp;\n      result = YYEOF;\n      break;\n\n    default:\n      result = YYERRCODE;\n#if YYDEBUG != 0\n      --exp;\n#endif\n      break;\n    }\n\n  *pexp = exp;\n\n  return result;\n}\n\n\nstatic void\nyyerror (str)\n     const char *str;\n{\n  /* Do nothing.  We don't print error messages here.  */\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}