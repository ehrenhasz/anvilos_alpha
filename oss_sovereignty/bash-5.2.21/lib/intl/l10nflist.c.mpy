{
  "module_name": "l10nflist.c",
  "hash_id": "824e1fb5703b3a70c6456fe5a8409a7f41dd590610bd6ba6374add713fff93a1",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/l10nflist.c",
  "human_readable_source": " \n\n \n\n \n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\t1\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <string.h>\n\n#if defined _LIBC || defined HAVE_ARGZ_H\n# include <argz.h>\n#endif\n#include <ctype.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\n#include \"loadinfo.h\"\n\n \n#ifndef NULL\n# if defined __STDC__ && __STDC__\n#  define NULL ((void *) 0)\n# else\n#  define NULL 0\n# endif\n#endif\n\n \n\n#ifdef _LIBC\n \n# ifndef stpcpy\n#  define stpcpy(dest, src) __stpcpy(dest, src)\n# endif\n#else\n# ifndef HAVE_STPCPY\nstatic char *stpcpy PARAMS ((char *dest, const char *src));\n# endif\n#endif\n\n \n#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__\n   \n# define ISSLASH(C) ((C) == '/' || (C) == '\\\\')\n# define HAS_DEVICE(P) \\\n    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \\\n     && (P)[1] == ':')\n# define IS_ABSOLUTE_PATH(P) (ISSLASH ((P)[0]) || HAS_DEVICE (P))\n#else\n   \n# define ISSLASH(C) ((C) == '/')\n# define IS_ABSOLUTE_PATH(P) ISSLASH ((P)[0])\n#endif\n\n \n\n#if !defined _LIBC && !defined HAVE___ARGZ_COUNT\n \nstatic size_t argz_count__ PARAMS ((const char *argz, size_t len));\n\nstatic size_t\nargz_count__ (argz, len)\n     const char *argz;\n     size_t len;\n{\n  size_t count = 0;\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len + 1;\n      len -= part_len + 1;\n      count++;\n    }\n  return count;\n}\n# undef __argz_count\n# define __argz_count(argz, len) argz_count__ (argz, len)\n#else\n# ifdef _LIBC\n#  define __argz_count(argz, len) INTUSE(__argz_count) (argz, len)\n# endif\n#endif\t \n\n#if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY\n \nstatic void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));\n\nstatic void\nargz_stringify__ (argz, len, sep)\n     char *argz;\n     size_t len;\n     int sep;\n{\n  while (len > 0)\n    {\n      size_t part_len = strlen (argz);\n      argz += part_len;\n      len -= part_len + 1;\n      if (len > 0)\n\t*argz++ = sep;\n    }\n}\n# undef __argz_stringify\n# define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)\n#else\n# ifdef _LIBC\n#  define __argz_stringify(argz, len, sep) \\\n  INTUSE(__argz_stringify) (argz, len, sep)\n# endif\n#endif\t \n\n#if !defined _LIBC && !defined HAVE___ARGZ_NEXT\nstatic char *argz_next__ PARAMS ((char *argz, size_t argz_len,\n\t\t\t\t  const char *entry));\n\nstatic char *\nargz_next__ (argz, argz_len, entry)\n     char *argz;\n     size_t argz_len;\n     const char *entry;\n{\n  if (entry)\n    {\n      if (entry < argz + argz_len)\n        entry = strchr (entry, '\\0') + 1;\n\n      return entry >= argz + argz_len ? NULL : (char *) entry;\n    }\n  else\n    if (argz_len > 0)\n      return argz;\n    else\n      return 0;\n}\n# undef __argz_next\n# define __argz_next(argz, len, entry) argz_next__ (argz, len, entry)\n#endif\t \n\n\n \nstatic int pop PARAMS ((int x));\n\nstatic inline int\npop (x)\n     int x;\n{\n   \n  x = ((x & ~0x5555) >> 1) + (x & 0x5555);\n  x = ((x & ~0x3333) >> 2) + (x & 0x3333);\n  x = ((x >> 4) + x) & 0x0f0f;\n  x = ((x >> 8) + x) & 0xff;\n\n  return x;\n}\n\n\f\nstruct loaded_l10nfile *\n_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,\n\t\t    territory, codeset, normalized_codeset, modifier, special,\n\t\t    sponsor, revision, filename, do_allocate)\n     struct loaded_l10nfile **l10nfile_list;\n     const char *dirlist;\n     size_t dirlist_len;\n     int mask;\n     const char *language;\n     const char *territory;\n     const char *codeset;\n     const char *normalized_codeset;\n     const char *modifier;\n     const char *special;\n     const char *sponsor;\n     const char *revision;\n     const char *filename;\n     int do_allocate;\n{\n  char *abs_filename;\n  struct loaded_l10nfile **lastp;\n  struct loaded_l10nfile *retval;\n  char *cp;\n  size_t dirlist_count;\n  size_t entries;\n  int cnt;\n\n   \n  if (IS_ABSOLUTE_PATH (language))\n    dirlist_len = 0;\n\n   \n  abs_filename = (char *) malloc (dirlist_len\n\t\t\t\t  + strlen (language)\n\t\t\t\t  + ((mask & TERRITORY) != 0\n\t\t\t\t     ? strlen (territory) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_CODESET) != 0\n\t\t\t\t     ? strlen (codeset) + 1 : 0)\n\t\t\t\t  + ((mask & XPG_NORM_CODESET) != 0\n\t\t\t\t     ? strlen (normalized_codeset) + 1 : 0)\n\t\t\t\t  + (((mask & XPG_MODIFIER) != 0\n\t\t\t\t      || (mask & CEN_AUDIENCE) != 0)\n\t\t\t\t     ? strlen (modifier) + 1 : 0)\n\t\t\t\t  + ((mask & CEN_SPECIAL) != 0\n\t\t\t\t     ? strlen (special) + 1 : 0)\n\t\t\t\t  + (((mask & CEN_SPONSOR) != 0\n\t\t\t\t      || (mask & CEN_REVISION) != 0)\n\t\t\t\t     ? (1 + ((mask & CEN_SPONSOR) != 0\n\t\t\t\t\t     ? strlen (sponsor) : 0)\n\t\t\t\t\t+ ((mask & CEN_REVISION) != 0\n\t\t\t\t\t   ? strlen (revision) + 1 : 0)) : 0)\n\t\t\t\t  + 1 + strlen (filename) + 1);\n\n  if (abs_filename == NULL)\n    return NULL;\n\n   \n  cp = abs_filename;\n  if (dirlist_len > 0)\n    {\n      memcpy (cp, dirlist, dirlist_len);\n      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);\n      cp += dirlist_len;\n      cp[-1] = '/';\n    }\n\n  cp = stpcpy (cp, language);\n\n  if ((mask & TERRITORY) != 0)\n    {\n      *cp++ = '_';\n      cp = stpcpy (cp, territory);\n    }\n  if ((mask & XPG_CODESET) != 0)\n    {\n      *cp++ = '.';\n      cp = stpcpy (cp, codeset);\n    }\n  if ((mask & XPG_NORM_CODESET) != 0)\n    {\n      *cp++ = '.';\n      cp = stpcpy (cp, normalized_codeset);\n    }\n  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)\n    {\n       \n      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';\n      cp = stpcpy (cp, modifier);\n    }\n  if ((mask & CEN_SPECIAL) != 0)\n    {\n      *cp++ = '+';\n      cp = stpcpy (cp, special);\n    }\n  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)\n    {\n      *cp++ = ',';\n      if ((mask & CEN_SPONSOR) != 0)\n\tcp = stpcpy (cp, sponsor);\n      if ((mask & CEN_REVISION) != 0)\n\t{\n\t  *cp++ = '_';\n\t  cp = stpcpy (cp, revision);\n\t}\n    }\n\n  *cp++ = '/';\n  stpcpy (cp, filename);\n\n   \n  lastp = l10nfile_list;\n  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)\n    if (retval->filename != NULL)\n      {\n\tint compare = strcmp (retval->filename, abs_filename);\n\tif (compare == 0)\n\t   \n\t  break;\n\tif (compare < 0)\n\t  {\n\t     \n\t    retval = NULL;\n\t    break;\n\t  }\n\n\tlastp = &retval->next;\n      }\n\n  if (retval != NULL || do_allocate == 0)\n    {\n      free (abs_filename);\n      return retval;\n    }\n\n  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);\n\n   \n  retval =\n    (struct loaded_l10nfile *)\n    malloc (sizeof (*retval)\n\t    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))\n\t       * sizeof (struct loaded_l10nfile *)));\n  if (retval == NULL)\n    {\n      free (abs_filename);\n      return NULL;\n    }\n\n  retval->filename = abs_filename;\n\n   \n  retval->decided = (dirlist_count > 1\n\t\t     || ((mask & XPG_CODESET) != 0\n\t\t\t && (mask & XPG_NORM_CODESET) != 0));\n  retval->data = NULL;\n\n  retval->next = *lastp;\n  *lastp = retval;\n\n  entries = 0;\n   \n  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)\n    if ((cnt & ~mask) == 0\n\t&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)\n\t&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))\n      {\n\tif (dirlist_count > 1)\n\t  {\n\t     \n\t    char *dir = NULL;\n\n\t    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))\n\t\t   != NULL)\n\t      retval->successor[entries++]\n\t\t= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,\n\t\t\t\t      cnt, language, territory, codeset,\n\t\t\t\t      normalized_codeset, modifier, special,\n\t\t\t\t      sponsor, revision, filename, 1);\n\t  }\n\telse\n\t  retval->successor[entries++]\n\t    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,\n\t\t\t\t  cnt, language, territory, codeset,\n\t\t\t\t  normalized_codeset, modifier, special,\n\t\t\t\t  sponsor, revision, filename, 1);\n      }\n  retval->successor[entries] = NULL;\n\n  return retval;\n}\n\f\n \nconst char *\n_nl_normalize_codeset (codeset, name_len)\n     const char *codeset;\n     size_t name_len;\n{\n  int len = 0;\n  int only_digit = 1;\n  char *retval;\n  char *wp;\n  size_t cnt;\n\n  for (cnt = 0; cnt < name_len; ++cnt)\n    if (isalnum ((unsigned char) codeset[cnt]))\n      {\n\t++len;\n\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  only_digit = 0;\n      }\n\n  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);\n\n  if (retval != NULL)\n    {\n      if (only_digit)\n\twp = stpcpy (retval, \"iso\");\n      else\n\twp = retval;\n\n      for (cnt = 0; cnt < name_len; ++cnt)\n\tif (isalpha ((unsigned char) codeset[cnt]))\n\t  *wp++ = tolower ((unsigned char) codeset[cnt]);\n\telse if (isdigit ((unsigned char) codeset[cnt]))\n\t  *wp++ = codeset[cnt];\n\n      *wp = '\\0';\n    }\n\n  return (const char *) retval;\n}\n\n\n \n\n \n#if !_LIBC && !HAVE_STPCPY\nstatic char *\nstpcpy (dest, src)\n     char *dest;\n     const char *src;\n{\n  while ((*dest++ = *src++) != '\\0')\n      ;\n  return dest - 1;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}