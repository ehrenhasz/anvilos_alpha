{
  "module_name": "plural-exp.c",
  "hash_id": "c1063a251808a403e369a79be9de313b8c44cea0a4a8de827d4a8195fd5ee120",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/plural-exp.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"plural-exp.h\"\n\n#if (defined __GNUC__ && !defined __APPLE_CC__) \\\n    || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n\n \nstatic const struct expression plvar =\n{\n  .nargs = 0,\n  .operation = var,\n};\nstatic const struct expression plone =\n{\n  .nargs = 0,\n  .operation = num,\n  .val =\n  {\n    .num = 1\n  }\n};\nstruct expression GERMANIC_PLURAL =\n{\n  .nargs = 2,\n  .operation = not_equal,\n  .val =\n  {\n    .args =\n    {\n      [0] = (struct expression *) &plvar,\n      [1] = (struct expression *) &plone\n    }\n  }\n};\n\n# define INIT_GERMANIC_PLURAL()\n\n#else\n\n \n\nstatic struct expression plvar;\nstatic struct expression plone;\nstruct expression GERMANIC_PLURAL;\n\nstatic void\ninit_germanic_plural ()\n{\n  if (plone.val.num == 0)\n    {\n      plvar.nargs = 0;\n      plvar.operation = var;\n\n      plone.nargs = 0;\n      plone.operation = num;\n      plone.val.num = 1;\n\n      GERMANIC_PLURAL.nargs = 2;\n      GERMANIC_PLURAL.operation = not_equal;\n      GERMANIC_PLURAL.val.args[0] = &plvar;\n      GERMANIC_PLURAL.val.args[1] = &plone;\n    }\n}\n\n# define INIT_GERMANIC_PLURAL() init_germanic_plural ()\n\n#endif\n\nvoid\ninternal_function\nEXTRACT_PLURAL_EXPRESSION (nullentry, pluralp, npluralsp)\n     const char *nullentry;\n     struct expression **pluralp;\n     unsigned long int *npluralsp;\n{\n  if (nullentry != NULL)\n    {\n      const char *plural;\n      const char *nplurals;\n\n      plural = strstr (nullentry, \"plural=\");\n      nplurals = strstr (nullentry, \"nplurals=\");\n      if (plural == NULL || nplurals == NULL)\n\tgoto no_plural;\n      else\n\t{\n\t  char *endp;\n\t  unsigned long int n;\n\t  struct parse_args args;\n\n\t   \n\t  nplurals += 9;\n\t  while (*nplurals != '\\0' && isspace ((unsigned char) *nplurals))\n\t    ++nplurals;\n\t  if (!(*nplurals >= '0' && *nplurals <= '9'))\n\t    goto no_plural;\n#if defined HAVE_STRTOUL || defined _LIBC\n\t  n = strtoul (nplurals, &endp, 10);\n#else\n\t  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)\n\t    n = n * 10 + (*endp - '0');\n#endif\n\t  if (nplurals == endp)\n\t    goto no_plural;\n\t  *npluralsp = n;\n\n\t   \n\t  plural += 7;\n\t  args.cp = plural;\n\t  if (PLURAL_PARSE (&args) != 0)\n\t    goto no_plural;\n\t  *pluralp = args.res;\n\t}\n    }\n  else\n    {\n       \n    no_plural:\n      INIT_GERMANIC_PLURAL ();\n      *pluralp = &GERMANIC_PLURAL;\n      *npluralsp = 2;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}