{
  "module_name": "loadmsgcat.c",
  "hash_id": "b627a946e3cc9145a19382c2b57f3654adcdd16cf59167dc081c6d482bc995de",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/loadmsgcat.c",
  "human_readable_source": " \n\n \n\n \n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE    1\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#ifdef __GNUC__\n# undef  alloca\n# define alloca __builtin_alloca\n# define HAVE_ALLOCA 1\n#else\n# ifdef _MSC_VER\n#  include <malloc.h>\n#  define alloca _alloca\n# else\n#  if defined HAVE_ALLOCA_H || defined _LIBC\n#   include <alloca.h>\n#  else\n#   ifdef _AIX\n #pragma alloca\n#   else\n#    ifndef alloca\nchar *alloca ();\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined HAVE_UNISTD_H || defined _LIBC\n# include <unistd.h>\n#endif\n\n#ifdef _LIBC\n# include <langinfo.h>\n# include <locale.h>\n#endif\n\n#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \\\n    || (defined _LIBC && defined _POSIX_MAPPED_FILES)\n# include <sys/mman.h>\n# undef HAVE_MMAP\n# define HAVE_MMAP\t1\n#else\n# undef HAVE_MMAP\n#endif\n\n#if defined HAVE_STDINT_H_WITH_UINTMAX || defined _LIBC\n# include <stdint.h>\n#endif\n#if defined HAVE_INTTYPES_H || defined _LIBC\n# include <inttypes.h>\n#endif\n\n#include \"gmo.h\"\n#include \"gettextP.h\"\n#include \"hash-string.h\"\n#include \"plural-exp.h\"\n\n#ifdef _LIBC\n# include \"../locale/localeinfo.h\"\n#endif\n\n \n#if !defined PRId8 || PRI_MACROS_BROKEN\n# undef PRId8\n# define PRId8 \"d\"\n#endif\n#if !defined PRIi8 || PRI_MACROS_BROKEN\n# undef PRIi8\n# define PRIi8 \"i\"\n#endif\n#if !defined PRIo8 || PRI_MACROS_BROKEN\n# undef PRIo8\n# define PRIo8 \"o\"\n#endif\n#if !defined PRIu8 || PRI_MACROS_BROKEN\n# undef PRIu8\n# define PRIu8 \"u\"\n#endif\n#if !defined PRIx8 || PRI_MACROS_BROKEN\n# undef PRIx8\n# define PRIx8 \"x\"\n#endif\n#if !defined PRIX8 || PRI_MACROS_BROKEN\n# undef PRIX8\n# define PRIX8 \"X\"\n#endif\n#if !defined PRId16 || PRI_MACROS_BROKEN\n# undef PRId16\n# define PRId16 \"d\"\n#endif\n#if !defined PRIi16 || PRI_MACROS_BROKEN\n# undef PRIi16\n# define PRIi16 \"i\"\n#endif\n#if !defined PRIo16 || PRI_MACROS_BROKEN\n# undef PRIo16\n# define PRIo16 \"o\"\n#endif\n#if !defined PRIu16 || PRI_MACROS_BROKEN\n# undef PRIu16\n# define PRIu16 \"u\"\n#endif\n#if !defined PRIx16 || PRI_MACROS_BROKEN\n# undef PRIx16\n# define PRIx16 \"x\"\n#endif\n#if !defined PRIX16 || PRI_MACROS_BROKEN\n# undef PRIX16\n# define PRIX16 \"X\"\n#endif\n#if !defined PRId32 || PRI_MACROS_BROKEN\n# undef PRId32\n# define PRId32 \"d\"\n#endif\n#if !defined PRIi32 || PRI_MACROS_BROKEN\n# undef PRIi32\n# define PRIi32 \"i\"\n#endif\n#if !defined PRIo32 || PRI_MACROS_BROKEN\n# undef PRIo32\n# define PRIo32 \"o\"\n#endif\n#if !defined PRIu32 || PRI_MACROS_BROKEN\n# undef PRIu32\n# define PRIu32 \"u\"\n#endif\n#if !defined PRIx32 || PRI_MACROS_BROKEN\n# undef PRIx32\n# define PRIx32 \"x\"\n#endif\n#if !defined PRIX32 || PRI_MACROS_BROKEN\n# undef PRIX32\n# define PRIX32 \"X\"\n#endif\n#if !defined PRId64 || PRI_MACROS_BROKEN\n# undef PRId64\n# define PRId64 (sizeof (long) == 8 ? \"ld\" : \"lld\")\n#endif\n#if !defined PRIi64 || PRI_MACROS_BROKEN\n# undef PRIi64\n# define PRIi64 (sizeof (long) == 8 ? \"li\" : \"lli\")\n#endif\n#if !defined PRIo64 || PRI_MACROS_BROKEN\n# undef PRIo64\n# define PRIo64 (sizeof (long) == 8 ? \"lo\" : \"llo\")\n#endif\n#if !defined PRIu64 || PRI_MACROS_BROKEN\n# undef PRIu64\n# define PRIu64 (sizeof (long) == 8 ? \"lu\" : \"llu\")\n#endif\n#if !defined PRIx64 || PRI_MACROS_BROKEN\n# undef PRIx64\n# define PRIx64 (sizeof (long) == 8 ? \"lx\" : \"llx\")\n#endif\n#if !defined PRIX64 || PRI_MACROS_BROKEN\n# undef PRIX64\n# define PRIX64 (sizeof (long) == 8 ? \"lX\" : \"llX\")\n#endif\n#if !defined PRIdLEAST8 || PRI_MACROS_BROKEN\n# undef PRIdLEAST8\n# define PRIdLEAST8 \"d\"\n#endif\n#if !defined PRIiLEAST8 || PRI_MACROS_BROKEN\n# undef PRIiLEAST8\n# define PRIiLEAST8 \"i\"\n#endif\n#if !defined PRIoLEAST8 || PRI_MACROS_BROKEN\n# undef PRIoLEAST8\n# define PRIoLEAST8 \"o\"\n#endif\n#if !defined PRIuLEAST8 || PRI_MACROS_BROKEN\n# undef PRIuLEAST8\n# define PRIuLEAST8 \"u\"\n#endif\n#if !defined PRIxLEAST8 || PRI_MACROS_BROKEN\n# undef PRIxLEAST8\n# define PRIxLEAST8 \"x\"\n#endif\n#if !defined PRIXLEAST8 || PRI_MACROS_BROKEN\n# undef PRIXLEAST8\n# define PRIXLEAST8 \"X\"\n#endif\n#if !defined PRIdLEAST16 || PRI_MACROS_BROKEN\n# undef PRIdLEAST16\n# define PRIdLEAST16 \"d\"\n#endif\n#if !defined PRIiLEAST16 || PRI_MACROS_BROKEN\n# undef PRIiLEAST16\n# define PRIiLEAST16 \"i\"\n#endif\n#if !defined PRIoLEAST16 || PRI_MACROS_BROKEN\n# undef PRIoLEAST16\n# define PRIoLEAST16 \"o\"\n#endif\n#if !defined PRIuLEAST16 || PRI_MACROS_BROKEN\n# undef PRIuLEAST16\n# define PRIuLEAST16 \"u\"\n#endif\n#if !defined PRIxLEAST16 || PRI_MACROS_BROKEN\n# undef PRIxLEAST16\n# define PRIxLEAST16 \"x\"\n#endif\n#if !defined PRIXLEAST16 || PRI_MACROS_BROKEN\n# undef PRIXLEAST16\n# define PRIXLEAST16 \"X\"\n#endif\n#if !defined PRIdLEAST32 || PRI_MACROS_BROKEN\n# undef PRIdLEAST32\n# define PRIdLEAST32 \"d\"\n#endif\n#if !defined PRIiLEAST32 || PRI_MACROS_BROKEN\n# undef PRIiLEAST32\n# define PRIiLEAST32 \"i\"\n#endif\n#if !defined PRIoLEAST32 || PRI_MACROS_BROKEN\n# undef PRIoLEAST32\n# define PRIoLEAST32 \"o\"\n#endif\n#if !defined PRIuLEAST32 || PRI_MACROS_BROKEN\n# undef PRIuLEAST32\n# define PRIuLEAST32 \"u\"\n#endif\n#if !defined PRIxLEAST32 || PRI_MACROS_BROKEN\n# undef PRIxLEAST32\n# define PRIxLEAST32 \"x\"\n#endif\n#if !defined PRIXLEAST32 || PRI_MACROS_BROKEN\n# undef PRIXLEAST32\n# define PRIXLEAST32 \"X\"\n#endif\n#if !defined PRIdLEAST64 || PRI_MACROS_BROKEN\n# undef PRIdLEAST64\n# define PRIdLEAST64 PRId64\n#endif\n#if !defined PRIiLEAST64 || PRI_MACROS_BROKEN\n# undef PRIiLEAST64\n# define PRIiLEAST64 PRIi64\n#endif\n#if !defined PRIoLEAST64 || PRI_MACROS_BROKEN\n# undef PRIoLEAST64\n# define PRIoLEAST64 PRIo64\n#endif\n#if !defined PRIuLEAST64 || PRI_MACROS_BROKEN\n# undef PRIuLEAST64\n# define PRIuLEAST64 PRIu64\n#endif\n#if !defined PRIxLEAST64 || PRI_MACROS_BROKEN\n# undef PRIxLEAST64\n# define PRIxLEAST64 PRIx64\n#endif\n#if !defined PRIXLEAST64 || PRI_MACROS_BROKEN\n# undef PRIXLEAST64\n# define PRIXLEAST64 PRIX64\n#endif\n#if !defined PRIdFAST8 || PRI_MACROS_BROKEN\n# undef PRIdFAST8\n# define PRIdFAST8 \"d\"\n#endif\n#if !defined PRIiFAST8 || PRI_MACROS_BROKEN\n# undef PRIiFAST8\n# define PRIiFAST8 \"i\"\n#endif\n#if !defined PRIoFAST8 || PRI_MACROS_BROKEN\n# undef PRIoFAST8\n# define PRIoFAST8 \"o\"\n#endif\n#if !defined PRIuFAST8 || PRI_MACROS_BROKEN\n# undef PRIuFAST8\n# define PRIuFAST8 \"u\"\n#endif\n#if !defined PRIxFAST8 || PRI_MACROS_BROKEN\n# undef PRIxFAST8\n# define PRIxFAST8 \"x\"\n#endif\n#if !defined PRIXFAST8 || PRI_MACROS_BROKEN\n# undef PRIXFAST8\n# define PRIXFAST8 \"X\"\n#endif\n#if !defined PRIdFAST16 || PRI_MACROS_BROKEN\n# undef PRIdFAST16\n# define PRIdFAST16 \"d\"\n#endif\n#if !defined PRIiFAST16 || PRI_MACROS_BROKEN\n# undef PRIiFAST16\n# define PRIiFAST16 \"i\"\n#endif\n#if !defined PRIoFAST16 || PRI_MACROS_BROKEN\n# undef PRIoFAST16\n# define PRIoFAST16 \"o\"\n#endif\n#if !defined PRIuFAST16 || PRI_MACROS_BROKEN\n# undef PRIuFAST16\n# define PRIuFAST16 \"u\"\n#endif\n#if !defined PRIxFAST16 || PRI_MACROS_BROKEN\n# undef PRIxFAST16\n# define PRIxFAST16 \"x\"\n#endif\n#if !defined PRIXFAST16 || PRI_MACROS_BROKEN\n# undef PRIXFAST16\n# define PRIXFAST16 \"X\"\n#endif\n#if !defined PRIdFAST32 || PRI_MACROS_BROKEN\n# undef PRIdFAST32\n# define PRIdFAST32 \"d\"\n#endif\n#if !defined PRIiFAST32 || PRI_MACROS_BROKEN\n# undef PRIiFAST32\n# define PRIiFAST32 \"i\"\n#endif\n#if !defined PRIoFAST32 || PRI_MACROS_BROKEN\n# undef PRIoFAST32\n# define PRIoFAST32 \"o\"\n#endif\n#if !defined PRIuFAST32 || PRI_MACROS_BROKEN\n# undef PRIuFAST32\n# define PRIuFAST32 \"u\"\n#endif\n#if !defined PRIxFAST32 || PRI_MACROS_BROKEN\n# undef PRIxFAST32\n# define PRIxFAST32 \"x\"\n#endif\n#if !defined PRIXFAST32 || PRI_MACROS_BROKEN\n# undef PRIXFAST32\n# define PRIXFAST32 \"X\"\n#endif\n#if !defined PRIdFAST64 || PRI_MACROS_BROKEN\n# undef PRIdFAST64\n# define PRIdFAST64 PRId64\n#endif\n#if !defined PRIiFAST64 || PRI_MACROS_BROKEN\n# undef PRIiFAST64\n# define PRIiFAST64 PRIi64\n#endif\n#if !defined PRIoFAST64 || PRI_MACROS_BROKEN\n# undef PRIoFAST64\n# define PRIoFAST64 PRIo64\n#endif\n#if !defined PRIuFAST64 || PRI_MACROS_BROKEN\n# undef PRIuFAST64\n# define PRIuFAST64 PRIu64\n#endif\n#if !defined PRIxFAST64 || PRI_MACROS_BROKEN\n# undef PRIxFAST64\n# define PRIxFAST64 PRIx64\n#endif\n#if !defined PRIXFAST64 || PRI_MACROS_BROKEN\n# undef PRIXFAST64\n# define PRIXFAST64 PRIX64\n#endif\n#if !defined PRIdMAX || PRI_MACROS_BROKEN\n# undef PRIdMAX\n# define PRIdMAX (sizeof (uintmax_t) == sizeof (long) ? \"ld\" : \"lld\")\n#endif\n#if !defined PRIiMAX || PRI_MACROS_BROKEN\n# undef PRIiMAX\n# define PRIiMAX (sizeof (uintmax_t) == sizeof (long) ? \"li\" : \"lli\")\n#endif\n#if !defined PRIoMAX || PRI_MACROS_BROKEN\n# undef PRIoMAX\n# define PRIoMAX (sizeof (uintmax_t) == sizeof (long) ? \"lo\" : \"llo\")\n#endif\n#if !defined PRIuMAX || PRI_MACROS_BROKEN\n# undef PRIuMAX\n# define PRIuMAX (sizeof (uintmax_t) == sizeof (long) ? \"lu\" : \"llu\")\n#endif\n#if !defined PRIxMAX || PRI_MACROS_BROKEN\n# undef PRIxMAX\n# define PRIxMAX (sizeof (uintmax_t) == sizeof (long) ? \"lx\" : \"llx\")\n#endif\n#if !defined PRIXMAX || PRI_MACROS_BROKEN\n# undef PRIXMAX\n# define PRIXMAX (sizeof (uintmax_t) == sizeof (long) ? \"lX\" : \"llX\")\n#endif\n#if !defined PRIdPTR || PRI_MACROS_BROKEN\n# undef PRIdPTR\n# define PRIdPTR \\\n  (sizeof (void *) == sizeof (long) ? \"ld\" : \\\n   sizeof (void *) == sizeof (int) ? \"d\" : \\\n   \"lld\")\n#endif\n#if !defined PRIiPTR || PRI_MACROS_BROKEN\n# undef PRIiPTR\n# define PRIiPTR \\\n  (sizeof (void *) == sizeof (long) ? \"li\" : \\\n   sizeof (void *) == sizeof (int) ? \"i\" : \\\n   \"lli\")\n#endif\n#if !defined PRIoPTR || PRI_MACROS_BROKEN\n# undef PRIoPTR\n# define PRIoPTR \\\n  (sizeof (void *) == sizeof (long) ? \"lo\" : \\\n   sizeof (void *) == sizeof (int) ? \"o\" : \\\n   \"llo\")\n#endif\n#if !defined PRIuPTR || PRI_MACROS_BROKEN\n# undef PRIuPTR\n# define PRIuPTR \\\n  (sizeof (void *) == sizeof (long) ? \"lu\" : \\\n   sizeof (void *) == sizeof (int) ? \"u\" : \\\n   \"llu\")\n#endif\n#if !defined PRIxPTR || PRI_MACROS_BROKEN\n# undef PRIxPTR\n# define PRIxPTR \\\n  (sizeof (void *) == sizeof (long) ? \"lx\" : \\\n   sizeof (void *) == sizeof (int) ? \"x\" : \\\n   \"llx\")\n#endif\n#if !defined PRIXPTR || PRI_MACROS_BROKEN\n# undef PRIXPTR\n# define PRIXPTR \\\n  (sizeof (void *) == sizeof (long) ? \"lX\" : \\\n   sizeof (void *) == sizeof (int) ? \"X\" : \\\n   \"llX\")\n#endif\n\n \n\n#ifdef _LIBC\n \n# define open   __open\n# define close  __close\n# define read   __read\n# define mmap   __mmap\n# define munmap __munmap\n#endif\n\n \n#ifdef HAVE_ALLOCA\n# define freea(p)  \n#else\n# define alloca(n) malloc (n)\n# define freea(p) free (p)\n#endif\n\n \n#if !defined O_BINARY && defined _O_BINARY\n   \n# define O_BINARY _O_BINARY\n# define O_TEXT _O_TEXT\n#endif\n#ifdef __BEOS__\n   \n# undef O_BINARY\n# undef O_TEXT\n#endif\n \n#ifndef O_BINARY\n# define O_BINARY 0\n#endif\n\n\n \nstatic const char *get_sysdep_segment_value PARAMS ((const char *name));\n\n\n \nint _nl_msg_cat_cntr;\n\n\n \nstatic const char *\nget_sysdep_segment_value (name)\n     const char *name;\n{\n   \n   \n  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')\n    {\n      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'\n\t  || name[3] == 'x' || name[3] == 'X')\n\t{\n\t  if (name[4] == '8' && name[5] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId8;\n\t      if (name[3] == 'i')\n\t\treturn PRIi8;\n\t      if (name[3] == 'o')\n\t\treturn PRIo8;\n\t      if (name[3] == 'u')\n\t\treturn PRIu8;\n\t      if (name[3] == 'x')\n\t\treturn PRIx8;\n\t      if (name[3] == 'X')\n\t\treturn PRIX8;\n\t      abort ();\n\t    }\n\t  if (name[4] == '1' && name[5] == '6' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId16;\n\t      if (name[3] == 'i')\n\t\treturn PRIi16;\n\t      if (name[3] == 'o')\n\t\treturn PRIo16;\n\t      if (name[3] == 'u')\n\t\treturn PRIu16;\n\t      if (name[3] == 'x')\n\t\treturn PRIx16;\n\t      if (name[3] == 'X')\n\t\treturn PRIX16;\n\t      abort ();\n\t    }\n\t  if (name[4] == '3' && name[5] == '2' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId32;\n\t      if (name[3] == 'i')\n\t\treturn PRIi32;\n\t      if (name[3] == 'o')\n\t\treturn PRIo32;\n\t      if (name[3] == 'u')\n\t\treturn PRIu32;\n\t      if (name[3] == 'x')\n\t\treturn PRIx32;\n\t      if (name[3] == 'X')\n\t\treturn PRIX32;\n\t      abort ();\n\t    }\n\t  if (name[4] == '6' && name[5] == '4' && name[6] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRId64;\n\t      if (name[3] == 'i')\n\t\treturn PRIi64;\n\t      if (name[3] == 'o')\n\t\treturn PRIo64;\n\t      if (name[3] == 'u')\n\t\treturn PRIu64;\n\t      if (name[3] == 'x')\n\t\treturn PRIx64;\n\t      if (name[3] == 'X')\n\t\treturn PRIX64;\n\t      abort ();\n\t    }\n\t  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'\n\t      && name[7] == 'S' && name[8] == 'T')\n\t    {\n\t      if (name[9] == '8' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST8;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST8;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST8;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST8;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST8;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST8;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '1' && name[10] == '6' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST16;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST16;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST16;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST16;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST16;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST16;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '3' && name[10] == '2' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST32;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST32;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST32;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST32;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST32;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST32;\n\t\t  abort ();\n\t\t}\n\t      if (name[9] == '6' && name[10] == '4' && name[11] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdLEAST64;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiLEAST64;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoLEAST64;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuLEAST64;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxLEAST64;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXLEAST64;\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'\n\t      && name[7] == 'T')\n\t    {\n\t      if (name[8] == '8' && name[9] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST8;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST8;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST8;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST8;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST8;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST8;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '1' && name[9] == '6' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST16;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST16;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST16;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST16;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST16;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST16;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '3' && name[9] == '2' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST32;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST32;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST32;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST32;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST32;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST32;\n\t\t  abort ();\n\t\t}\n\t      if (name[8] == '6' && name[9] == '4' && name[10] == '\\0')\n\t\t{\n\t\t  if (name[3] == 'd')\n\t\t    return PRIdFAST64;\n\t\t  if (name[3] == 'i')\n\t\t    return PRIiFAST64;\n\t\t  if (name[3] == 'o')\n\t\t    return PRIoFAST64;\n\t\t  if (name[3] == 'u')\n\t\t    return PRIuFAST64;\n\t\t  if (name[3] == 'x')\n\t\t    return PRIxFAST64;\n\t\t  if (name[3] == 'X')\n\t\t    return PRIXFAST64;\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'\n\t      && name[7] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRIdMAX;\n\t      if (name[3] == 'i')\n\t\treturn PRIiMAX;\n\t      if (name[3] == 'o')\n\t\treturn PRIoMAX;\n\t      if (name[3] == 'u')\n\t\treturn PRIuMAX;\n\t      if (name[3] == 'x')\n\t\treturn PRIxMAX;\n\t      if (name[3] == 'X')\n\t\treturn PRIXMAX;\n\t      abort ();\n\t    }\n\t  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'\n\t      && name[7] == '\\0')\n\t    {\n\t      if (name[3] == 'd')\n\t\treturn PRIdPTR;\n\t      if (name[3] == 'i')\n\t\treturn PRIiPTR;\n\t      if (name[3] == 'o')\n\t\treturn PRIoPTR;\n\t      if (name[3] == 'u')\n\t\treturn PRIuPTR;\n\t      if (name[3] == 'x')\n\t\treturn PRIxPTR;\n\t      if (name[3] == 'X')\n\t\treturn PRIXPTR;\n\t      abort ();\n\t    }\n\t}\n    }\n   \n  return NULL;\n}\n\n \nconst char *\ninternal_function\n_nl_init_domain_conv (domain_file, domain, domainbinding)\n     struct loaded_l10nfile *domain_file;\n     struct loaded_domain *domain;\n     struct binding *domainbinding;\n{\n   \n  char *nullentry;\n  size_t nullentrylen;\n\n   \n  domain->codeset_cntr =\n    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);\n#ifdef _LIBC\n  domain->conv = (__gconv_t) -1;\n#else\n# if HAVE_ICONV\n  domain->conv = (iconv_t) -1;\n# endif\n#endif\n  domain->conv_tab = NULL;\n\n   \n  nullentry = _nl_find_msg (domain_file, domainbinding, \"\", &nullentrylen);\n\n  if (nullentry != NULL)\n    {\n#if defined _LIBC || HAVE_ICONV\n      const char *charsetstr;\n\n      charsetstr = strstr (nullentry, \"charset=\");\n      if (charsetstr != NULL)\n\t{\n\t  size_t len;\n\t  char *charset;\n\t  const char *outcharset;\n\n\t  charsetstr += strlen (\"charset=\");\n\t  len = strcspn (charsetstr, \" \\t\\n\");\n\n\t  charset = (char *) alloca (len + 1);\n# if defined _LIBC || HAVE_MEMPCPY\n\t  *((char *) mempcpy (charset, charsetstr, len)) = '\\0';\n# else\n\t  memcpy (charset, charsetstr, len);\n\t  charset[len] = '\\0';\n# endif\n\n\t   \n\t  if (domainbinding != NULL && domainbinding->codeset != NULL)\n\t    outcharset = domainbinding->codeset;\n\t  else\n\t    {\n\t      outcharset = getenv (\"OUTPUT_CHARSET\");\n\t      if (outcharset == NULL || outcharset[0] == '\\0')\n\t\t{\n# ifdef _LIBC\n\t\t  outcharset = _NL_CURRENT (LC_CTYPE, CODESET);\n# else\n#  if HAVE_ICONV\n\t\t  extern const char *locale_charset PARAMS ((void));\n\t\t  outcharset = locale_charset ();\n#  endif\n# endif\n\t\t}\n\t    }\n\n# ifdef _LIBC\n\t   \n\t  outcharset = norm_add_slashes (outcharset, \"TRANSLIT\");\n\t  charset = norm_add_slashes (charset, NULL);\n\t  if (__gconv_open (outcharset, charset, &domain->conv,\n\t\t\t    GCONV_AVOID_NOCONV)\n\t      != __GCONV_OK)\n\t    domain->conv = (__gconv_t) -1;\n# else\n#  if HAVE_ICONV\n\t   \n#   if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2 \\\n       || _LIBICONV_VERSION >= 0x0105\n\t  if (strchr (outcharset, '/') == NULL)\n\t    {\n\t      char *tmp;\n\n\t      len = strlen (outcharset);\n\t      tmp = (char *) alloca (len + 10 + 1);\n\t      memcpy (tmp, outcharset, len);\n\t      memcpy (tmp + len, \"//TRANSLIT\", 10 + 1);\n\t      outcharset = tmp;\n\n\t      domain->conv = iconv_open (outcharset, charset);\n\n\t      freea (outcharset);\n\t    }\n\t  else\n#   endif\n\t    domain->conv = iconv_open (outcharset, charset);\n#  endif\n# endif\n\n\t  freea (charset);\n\t}\n#endif  \n    }\n\n  return nullentry;\n}\n\n \nvoid\ninternal_function\n_nl_free_domain_conv (domain)\n     struct loaded_domain *domain;\n{\n  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)\n    free (domain->conv_tab);\n\n#ifdef _LIBC\n  if (domain->conv != (__gconv_t) -1)\n    __gconv_close (domain->conv);\n#else\n# if HAVE_ICONV\n  if (domain->conv != (iconv_t) -1)\n    iconv_close (domain->conv);\n# endif\n#endif\n}\n\n \nvoid\ninternal_function\n_nl_load_domain (domain_file, domainbinding)\n     struct loaded_l10nfile *domain_file;\n     struct binding *domainbinding;\n{\n  int fd;\n  size_t size;\n#ifdef _LIBC\n  struct stat64 st;\n#else\n  struct stat st;\n#endif\n  struct mo_file_header *data = (struct mo_file_header *) -1;\n  int use_mmap = 0;\n  struct loaded_domain *domain;\n  int revision;\n  const char *nullentry;\n\n  domain_file->decided = 1;\n  domain_file->data = NULL;\n\n   \n\n   \n  if (domain_file->filename == NULL)\n    return;\n\n   \n  fd = open (domain_file->filename, O_RDONLY | O_BINARY);\n  if (fd == -1)\n    return;\n\n   \n  if (\n#ifdef _LIBC\n      __builtin_expect (fstat64 (fd, &st) != 0, 0)\n#else\n      __builtin_expect (fstat (fd, &st) != 0, 0)\n#endif\n      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)\n      || __builtin_expect (size < sizeof (struct mo_file_header), 0))\n    {\n       \n      close (fd);\n      return;\n    }\n\n#ifdef HAVE_MMAP\n   \n  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,\n\t\t\t\t\t MAP_PRIVATE, fd, 0);\n\n  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))\n    {\n       \n      close (fd);\n      use_mmap = 1;\n    }\n#endif\n\n   \n  if (data == (struct mo_file_header *) -1)\n    {\n      size_t to_read;\n      char *read_ptr;\n\n      data = (struct mo_file_header *) malloc (size);\n      if (data == NULL)\n\t{\n\t  if (use_mmap == 0)\n\t    close (fd);\n\t  return;\n\t}\n\n      to_read = size;\n      read_ptr = (char *) data;\n      do\n\t{\n\t  long int nb = (long int) read (fd, read_ptr, to_read);\n\t  if (nb <= 0)\n\t    {\n#ifdef EINTR\n\t      if (nb == -1 && errno == EINTR)\n\t\tcontinue;\n#endif\n\t      close (fd);\n\t      return;\n\t    }\n\t  read_ptr += nb;\n\t  to_read -= nb;\n\t}\n      while (to_read > 0);\n\n      close (fd);\n    }\n\n   \n  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,\n\t\t\t0))\n    {\n       \n#ifdef HAVE_MMAP\n      if (use_mmap)\n\tmunmap ((caddr_t) data, size);\n      else\n#endif\n\tfree (data);\n      return;\n    }\n\n  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));\n  if (domain == NULL)\n    {\n#ifdef HAVE_MMAP\n      if (use_mmap)\n\tmunmap ((caddr_t) data, size);\n      else\n#endif\n\tfree (data);\n      return;\n    }\n  domain_file->data = domain;\n\n  domain->data = (char *) data;\n  domain->use_mmap = use_mmap;\n  domain->mmap_size = size;\n  domain->must_swap = data->magic != _MAGIC;\n  domain->malloced = NULL;\n\n   \n  revision = W (domain->must_swap, data->revision);\n   \n  switch (revision >> 16)\n    {\n    case 0:\n      domain->nstrings = W (domain->must_swap, data->nstrings);\n      domain->orig_tab = (const struct string_desc *)\n\t((char *) data + W (domain->must_swap, data->orig_tab_offset));\n      domain->trans_tab = (const struct string_desc *)\n\t((char *) data + W (domain->must_swap, data->trans_tab_offset));\n      domain->hash_size = W (domain->must_swap, data->hash_tab_size);\n      domain->hash_tab =\n\t(domain->hash_size > 2\n\t ? (const nls_uint32 *)\n\t   ((char *) data + W (domain->must_swap, data->hash_tab_offset))\n\t : NULL);\n      domain->must_swap_hash_tab = domain->must_swap;\n\n       \n      switch (revision & 0xffff)\n\t{\n\tcase 0:\n\t  domain->n_sysdep_strings = 0;\n\t  domain->orig_sysdep_tab = NULL;\n\t  domain->trans_sysdep_tab = NULL;\n\t  break;\n\tcase 1:\n\tdefault:\n\t  {\n\t    nls_uint32 n_sysdep_strings;\n\n\t    if (domain->hash_tab == NULL)\n\t       \n\t      goto invalid;\n\n\t    n_sysdep_strings =\n\t      W (domain->must_swap, data->n_sysdep_strings);\n\t    if (n_sysdep_strings > 0)\n\t      {\n\t\tnls_uint32 n_sysdep_segments;\n\t\tconst struct sysdep_segment *sysdep_segments;\n\t\tconst char **sysdep_segment_values;\n\t\tconst nls_uint32 *orig_sysdep_tab;\n\t\tconst nls_uint32 *trans_sysdep_tab;\n\t\tsize_t memneed;\n\t\tchar *mem;\n\t\tstruct sysdep_string_desc *inmem_orig_sysdep_tab;\n\t\tstruct sysdep_string_desc *inmem_trans_sysdep_tab;\n\t\tnls_uint32 *inmem_hash_tab;\n\t\tunsigned int i;\n\n\t\t \n\t\tn_sysdep_segments =\n\t\t  W (domain->must_swap, data->n_sysdep_segments);\n\t\tsysdep_segments = (const struct sysdep_segment *)\n\t\t  ((char *) data\n\t\t   + W (domain->must_swap, data->sysdep_segments_offset));\n\t\tsysdep_segment_values =\n\t\t  alloca (n_sysdep_segments * sizeof (const char *));\n\t\tfor (i = 0; i < n_sysdep_segments; i++)\n\t\t  {\n\t\t    const char *name =\n\t\t      (char *) data\n\t\t      + W (domain->must_swap, sysdep_segments[i].offset);\n\t\t    nls_uint32 namelen =\n\t\t      W (domain->must_swap, sysdep_segments[i].length);\n\n\t\t    if (!(namelen > 0 && name[namelen - 1] == '\\0'))\n\t\t      {\n\t\t\tfreea (sysdep_segment_values);\n\t\t\tgoto invalid;\n\t\t      }\n\n\t\t    sysdep_segment_values[i] = get_sysdep_segment_value (name);\n\t\t  }\n\n\t\torig_sysdep_tab = (const nls_uint32 *)\n\t\t  ((char *) data\n\t\t   + W (domain->must_swap, data->orig_sysdep_tab_offset));\n\t\ttrans_sysdep_tab = (const nls_uint32 *)\n\t\t  ((char *) data\n\t\t   + W (domain->must_swap, data->trans_sysdep_tab_offset));\n\n\t\t \n\t\tmemneed = 2 * n_sysdep_strings\n\t\t\t  * sizeof (struct sysdep_string_desc)\n\t\t\t  + domain->hash_size * sizeof (nls_uint32);\n\t\tfor (i = 0; i < 2 * n_sysdep_strings; i++)\n\t\t  {\n\t\t    const struct sysdep_string *sysdep_string =\n\t\t      (const struct sysdep_string *)\n\t\t      ((char *) data\n\t\t       + W (domain->must_swap,\n\t\t\t    i < n_sysdep_strings\n\t\t\t    ? orig_sysdep_tab[i]\n\t\t\t    : trans_sysdep_tab[i - n_sysdep_strings]));\n\t\t    size_t need = 0;\n\t\t    const struct segment_pair *p = sysdep_string->segments;\n\n\t\t    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)\n\t\t      for (p = sysdep_string->segments;; p++)\n\t\t\t{\n\t\t\t  nls_uint32 sysdepref;\n\n\t\t\t  need += W (domain->must_swap, p->segsize);\n\n\t\t\t  sysdepref = W (domain->must_swap, p->sysdepref);\n\t\t\t  if (sysdepref == SEGMENTS_END)\n\t\t\t    break;\n\n\t\t\t  if (sysdepref >= n_sysdep_segments)\n\t\t\t    {\n\t\t\t       \n\t\t\t      freea (sysdep_segment_values);\n\t\t\t      goto invalid;\n\t\t\t    }\n\n\t\t\t  need += strlen (sysdep_segment_values[sysdepref]);\n\t\t\t}\n\n\t\t    memneed += need;\n\t\t  }\n\n\t\t \n\t\tmem = (char *) malloc (memneed);\n\t\tif (mem == NULL)\n\t\t  goto invalid;\n\n\t\tdomain->malloced = mem;\n\t\tinmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;\n\t\tmem += n_sysdep_strings * sizeof (struct sysdep_string_desc);\n\t\tinmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;\n\t\tmem += n_sysdep_strings * sizeof (struct sysdep_string_desc);\n\t\tinmem_hash_tab = (nls_uint32 *) mem;\n\t\tmem += domain->hash_size * sizeof (nls_uint32);\n\n\t\t \n\t\tfor (i = 0; i < 2 * n_sysdep_strings; i++)\n\t\t  {\n\t\t    const struct sysdep_string *sysdep_string =\n\t\t      (const struct sysdep_string *)\n\t\t      ((char *) data\n\t\t       + W (domain->must_swap,\n\t\t\t    i < n_sysdep_strings\n\t\t\t    ? orig_sysdep_tab[i]\n\t\t\t    : trans_sysdep_tab[i - n_sysdep_strings]));\n\t\t    const char *static_segments =\n\t\t      (char *) data\n\t\t      + W (domain->must_swap, sysdep_string->offset);\n\t\t    const struct segment_pair *p = sysdep_string->segments;\n\n\t\t     \n\n\t\t    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)\n\t\t      {\n\t\t\t \n\t\t\tinmem_orig_sysdep_tab[i].length =\n\t\t\t  W (domain->must_swap, p->segsize);\n\t\t\tinmem_orig_sysdep_tab[i].pointer = static_segments;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tinmem_orig_sysdep_tab[i].pointer = mem;\n\n\t\t\tfor (p = sysdep_string->segments;; p++)\n\t\t\t  {\n\t\t\t    nls_uint32 segsize =\n\t\t\t      W (domain->must_swap, p->segsize);\n\t\t\t    nls_uint32 sysdepref =\n\t\t\t      W (domain->must_swap, p->sysdepref);\n\t\t\t    size_t n;\n\n\t\t\t    if (segsize > 0)\n\t\t\t      {\n\t\t\t\tmemcpy (mem, static_segments, segsize);\n\t\t\t\tmem += segsize;\n\t\t\t\tstatic_segments += segsize;\n\t\t\t      }\n\n\t\t\t    if (sysdepref == SEGMENTS_END)\n\t\t\t      break;\n\n\t\t\t    n = strlen (sysdep_segment_values[sysdepref]);\n\t\t\t    memcpy (mem, sysdep_segment_values[sysdepref], n);\n\t\t\t    mem += n;\n\t\t\t  }\n\n\t\t\tinmem_orig_sysdep_tab[i].length =\n\t\t\t  mem - inmem_orig_sysdep_tab[i].pointer;\n\t\t      }\n\t\t  }\n\n\t\t \n\t\tfor (i = 0; i < domain->hash_size; i++)\n\t\t  inmem_hash_tab[i] =\n\t\t    W (domain->must_swap_hash_tab, domain->hash_tab[i]);\n\t\tfor (i = 0; i < n_sysdep_strings; i++)\n\t\t  {\n\t\t    const char *msgid = inmem_orig_sysdep_tab[i].pointer;\n\t\t    nls_uint32 hash_val = hash_string (msgid);\n\t\t    nls_uint32 idx = hash_val % domain->hash_size;\n\t\t    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));\n\n\t\t    for (;;)\n\t\t      {\n\t\t\tif (inmem_hash_tab[idx] == 0)\n\t\t\t  {\n\t\t\t     \n\t\t\t    inmem_hash_tab[idx] = 1 + domain->nstrings + i;\n\t\t\t    break;\n\t\t\t  }\n\n\t\t\tif (idx >= domain->hash_size - incr)\n\t\t\t  idx -= domain->hash_size - incr;\n\t\t\telse\n\t\t\t  idx += incr;\n\t\t      }\n\t\t  }\n\n\t\tfreea (sysdep_segment_values);\n\n\t\tdomain->n_sysdep_strings = n_sysdep_strings;\n\t\tdomain->orig_sysdep_tab = inmem_orig_sysdep_tab;\n\t\tdomain->trans_sysdep_tab = inmem_trans_sysdep_tab;\n\n\t\tdomain->hash_tab = inmem_hash_tab;\n\t\tdomain->must_swap_hash_tab = 0;\n\t      }\n\t    else\n\t      {\n\t\tdomain->n_sysdep_strings = 0;\n\t\tdomain->orig_sysdep_tab = NULL;\n\t\tdomain->trans_sysdep_tab = NULL;\n\t      }\n\t  }\n\t  break;\n\t}\n      break;\n    default:\n       \n    invalid:\n       \n      if (domain->malloced)\n\tfree (domain->malloced);\n#ifdef HAVE_MMAP\n      if (use_mmap)\n\tmunmap ((caddr_t) data, size);\n      else\n#endif\n\tfree (data);\n      free (domain);\n      domain_file->data = NULL;\n      return;\n    }\n\n   \n  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);\n\n   \n  EXTRACT_PLURAL_EXPRESSION (nullentry, &domain->plural, &domain->nplurals);\n}\n\n\n#ifdef _LIBC\nvoid\ninternal_function\n_nl_unload_domain (domain)\n     struct loaded_domain *domain;\n{\n  if (domain->plural != &__gettext_germanic_plural)\n    __gettext_free_exp (domain->plural);\n\n  _nl_free_domain_conv (domain);\n\n  if (domain->malloced)\n    free (domain->malloced);\n\n# ifdef _POSIX_MAPPED_FILES\n  if (domain->use_mmap)\n    munmap ((caddr_t) domain->data, domain->mmap_size);\n  else\n# endif\t \n    free ((void *) domain->data);\n\n  free (domain);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}