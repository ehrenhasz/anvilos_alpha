{
  "module_name": "localealias.c",
  "hash_id": "97f4b0395f8f37eac5f2c102aa952895131e8a8ebb12209bfc4b5af77a589b58",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/localealias.c",
  "human_readable_source": " \n\n \n\n \n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE    1\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#if defined _LIBC || defined HAVE___FSETLOCKING\n# include <stdio_ext.h>\n#endif\n#include <sys/types.h>\n\n#ifdef __GNUC__\n# undef alloca\n# define alloca __builtin_alloca\n# define HAVE_ALLOCA 1\n#else\n# ifdef _MSC_VER\n#  include <malloc.h>\n#  define alloca _alloca\n# else\n#  if defined HAVE_ALLOCA_H || defined _LIBC\n#   include <alloca.h>\n#  else\n#   ifdef _AIX\n #pragma alloca\n#   else\n#    ifndef alloca\nchar *alloca ();\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gettextP.h\"\n\n#if ENABLE_RELOCATABLE\n# include \"relocatable.h\"\n#else\n# define relocate(pathname) (pathname)\n#endif\n\n \n\n#ifdef _LIBC\n \n# define strcasecmp __strcasecmp\n\n# ifndef mempcpy\n#  define mempcpy __mempcpy\n# endif\n# define HAVE_MEMPCPY\t1\n# define HAVE___FSETLOCKING\t1\n\n \n# include <bits/libc-lock.h>\n\n__libc_lock_define_initialized (static, lock);\n#endif\n\n#ifndef internal_function\n# define internal_function\n#endif\n\n \n#ifdef _LIBC\n# define FEOF(fp)\t\tfeof_unlocked (fp)\n# define FGETS(buf, n, fp)\tfgets_unlocked (buf, n, fp)\n#else\n# define FEOF(fp)\t\tfeof (fp)\n# define FGETS(buf, n, fp)\tfgets (buf, n, fp)\n#endif\n\n \n#ifdef HAVE_ALLOCA\n# define freea(p)  \n#else\n# define alloca(n) malloc (n)\n# define freea(p) free (p)\n#endif\n\n#if defined _LIBC_REENTRANT || defined HAVE_FGETS_UNLOCKED\n# undef fgets\n# define fgets(buf, len, s) fgets_unlocked (buf, len, s)\n#endif\n#if defined _LIBC_REENTRANT || defined HAVE_FEOF_UNLOCKED\n# undef feof\n# define feof(s) feof_unlocked (s)\n#endif\n\n\nstruct alias_map\n{\n  const char *alias;\n  const char *value;\n};\n\n\n#ifndef _LIBC\n# define libc_freeres_ptr(decl) decl\n#endif\n\nlibc_freeres_ptr (static char *string_space);\nstatic size_t string_space_act;\nstatic size_t string_space_max;\nlibc_freeres_ptr (static struct alias_map *map);\nstatic size_t nmap;\nstatic size_t maxmap;\n\n\n \nstatic size_t read_alias_file PARAMS ((const char *fname, int fname_len))\n     internal_function;\nstatic int extend_alias_table PARAMS ((void));\nstatic int alias_compare PARAMS ((const struct alias_map *map1,\n\t\t\t\t  const struct alias_map *map2));\n\n\nconst char *\n_nl_expand_alias (name)\n    const char *name;\n{\n  static const char *locale_alias_path;\n  struct alias_map *retval;\n  const char *result = NULL;\n  size_t added;\n\n#ifdef _LIBC\n  __libc_lock_lock (lock);\n#endif\n\n  if (locale_alias_path == NULL)\n    locale_alias_path = LOCALE_ALIAS_PATH;\n\n  do\n    {\n      struct alias_map item;\n\n      item.alias = name;\n\n      if (nmap > 0)\n\tretval = (struct alias_map *) bsearch (&item, map, nmap,\n\t\t\t\t\t       sizeof (struct alias_map),\n\t\t\t\t\t       (int (*) PARAMS ((const void *,\n\t\t\t\t\t\t\t\t const void *))\n\t\t\t\t\t\t) alias_compare);\n      else\n\tretval = NULL;\n\n       \n      if (retval != NULL)\n\t{\n\t  result = retval->value;\n\t  break;\n\t}\n\n       \n      added = 0;\n      while (added == 0 && locale_alias_path[0] != '\\0')\n\t{\n\t  const char *start;\n\n\t  while (locale_alias_path[0] == PATH_SEPARATOR)\n\t    ++locale_alias_path;\n\t  start = locale_alias_path;\n\n\t  while (locale_alias_path[0] != '\\0'\n\t\t && locale_alias_path[0] != PATH_SEPARATOR)\n\t    ++locale_alias_path;\n\n\t  if (start < locale_alias_path)\n\t    added = read_alias_file (start, locale_alias_path - start);\n\t}\n    }\n  while (added != 0);\n\n#ifdef _LIBC\n  __libc_lock_unlock (lock);\n#endif\n\n  return result;\n}\n\n\nstatic size_t\ninternal_function\nread_alias_file (fname, fname_len)\n     const char *fname;\n     int fname_len;\n{\n  FILE *fp;\n  char *full_fname;\n  size_t added;\n  static const char aliasfile[] = \"/locale.alias\";\n\n  full_fname = (char *) alloca (fname_len + sizeof aliasfile);\n#ifdef HAVE_MEMPCPY\n  mempcpy (mempcpy (full_fname, fname, fname_len),\n\t   aliasfile, sizeof aliasfile);\n#else\n  memcpy (full_fname, fname, fname_len);\n  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);\n#endif\n\n  fp = fopen (relocate (full_fname), \"r\");\n  freea (full_fname);\n  if (fp == NULL)\n    return 0;\n\n#ifdef HAVE___FSETLOCKING\n   \n  __fsetlocking (fp, FSETLOCKING_BYCALLER);\n#endif\n\n  added = 0;\n  while (!FEOF (fp))\n    {\n       \n      char buf[400];\n      char *alias;\n      char *value;\n      char *cp;\n\n      if (FGETS (buf, sizeof buf, fp) == NULL)\n\t \n\tbreak;\n\n      cp = buf;\n       \n      while (isspace ((unsigned char) cp[0]))\n\t++cp;\n\n       \n      if (cp[0] != '\\0' && cp[0] != '#')\n\t{\n\t  alias = cp++;\n\t  while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n\t    ++cp;\n\t   \n\t  if (cp[0] != '\\0')\n\t    *cp++ = '\\0';\n\n\t   \n\t  while (isspace ((unsigned char) cp[0]))\n\t    ++cp;\n\n\t  if (cp[0] != '\\0')\n\t    {\n\t      size_t alias_len;\n\t      size_t value_len;\n\n\t      value = cp++;\n\t      while (cp[0] != '\\0' && !isspace ((unsigned char) cp[0]))\n\t\t++cp;\n\t       \n\t      if (cp[0] == '\\n')\n\t\t{\n\t\t   \n\t\t  *cp++ = '\\0';\n\t\t  *cp = '\\n';\n\t\t}\n\t      else if (cp[0] != '\\0')\n\t\t*cp++ = '\\0';\n\n\t      if (nmap >= maxmap)\n\t\tif (__builtin_expect (extend_alias_table (), 0))\n\t\t  {\n\t\t    fclose (fp);\n\t\t    return added;\n\t\t  }\n\n\t      alias_len = strlen (alias) + 1;\n\t      value_len = strlen (value) + 1;\n\n\t      if (string_space_act + alias_len + value_len > string_space_max)\n\t\t{\n\t\t   \n\t\t  size_t new_size = (string_space_max\n\t\t\t\t     + (alias_len + value_len > 1024\n\t\t\t\t\t? alias_len + value_len : 1024));\n\t\t  char *new_pool = (char *) realloc (string_space, new_size);\n\t\t  if (new_pool == NULL)\n\t\t    {\n\t\t      fclose (fp);\n\t\t      return added;\n\t\t    }\n\n\t\t  if (__builtin_expect (string_space != new_pool, 0))\n\t\t    {\n\t\t      size_t i;\n\n\t\t      for (i = 0; i < nmap; i++)\n\t\t\t{\n\t\t\t  map[i].alias += new_pool - string_space;\n\t\t\t  map[i].value += new_pool - string_space;\n\t\t\t}\n\t\t    }\n\n\t\t  string_space = new_pool;\n\t\t  string_space_max = new_size;\n\t\t}\n\n\t      map[nmap].alias = memcpy (&string_space[string_space_act],\n\t\t\t\t\talias, alias_len);\n\t      string_space_act += alias_len;\n\n\t      map[nmap].value = memcpy (&string_space[string_space_act],\n\t\t\t\t\tvalue, value_len);\n\t      string_space_act += value_len;\n\n\t      ++nmap;\n\t      ++added;\n\t    }\n\t}\n\n       \n      while (strchr (buf, '\\n') == NULL)\n\tif (FGETS (buf, sizeof buf, fp) == NULL)\n\t   \n\t  break;\n    }\n\n   \n  fclose (fp);\n\n  if (added > 0)\n    qsort (map, nmap, sizeof (struct alias_map),\n\t   (int (*) PARAMS ((const void *, const void *))) alias_compare);\n\n  return added;\n}\n\n\nstatic int\nextend_alias_table ()\n{\n  size_t new_size;\n  struct alias_map *new_map;\n\n  new_size = maxmap == 0 ? 100 : 2 * maxmap;\n  new_map = (struct alias_map *) realloc (map, (new_size\n\t\t\t\t\t\t* sizeof (struct alias_map)));\n  if (new_map == NULL)\n     \n    return -1;\n\n  map = new_map;\n  maxmap = new_size;\n  return 0;\n}\n\n\nstatic int\nalias_compare (map1, map2)\n     const struct alias_map *map1;\n     const struct alias_map *map2;\n{\n#if defined _LIBC || defined HAVE_STRCASECMP\n  return strcasecmp (map1->alias, map2->alias);\n#else\n  const unsigned char *p1 = (const unsigned char *) map1->alias;\n  const unsigned char *p2 = (const unsigned char *) map2->alias;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n       \n      c1 = isupper (*p1) ? tolower (*p1) : *p1;\n      c2 = isupper (*p2) ? tolower (*p2) : *p2;\n      if (c1 == '\\0')\n\tbreak;\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  return c1 - c2;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}