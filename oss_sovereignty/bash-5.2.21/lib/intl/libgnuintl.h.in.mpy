{
  "module_name": "libgnuintl.h.in",
  "hash_id": "a59f98f4367e05a03ce866546d5ee75f465a1b242504246d4e4409900231ab24",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/libgnuintl.h.in",
  "human_readable_source": "/* libgnuintl.h - Message catalogs for internationalization. */\n\n/* Copyright (C) 1995-1997, 2000-2003, 2004-2009 Free Software Foundation, Inc.\n\n   This file is part of GNU Bash.\n\n   Bash is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   Bash is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with Bash.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _LIBINTL_H\n#define _LIBINTL_H\t1\n\n#include <locale.h>\n\n/* The LC_MESSAGES locale category is the category used by the functions\n   gettext() and dgettext().  It is specified in POSIX, but not in ANSI C.\n   On systems that don't define it, use an arbitrary value instead.\n   On Solaris, <locale.h> defines __LOCALE_H (or _LOCALE_H in Solaris 2.5)\n   then includes <libintl.h> (i.e. this file!) and then only defines\n   LC_MESSAGES.  To avoid a redefinition warning, don't define LC_MESSAGES\n   in this case.  */\n#if !defined LC_MESSAGES && !(defined __LOCALE_H || (defined _LOCALE_H && defined __sun))\n# define LC_MESSAGES 1729\n#endif\n\n/* We define an additional symbol to signal that we use the GNU\n   implementation of gettext.  */\n#define __USE_GNU_GETTEXT 1\n\n/* Provide information about the supported file formats.  Returns the\n   maximum minor revision number supported for a given major revision.  */\n#define __GNU_GETTEXT_SUPPORTED_REVISION(major) \\\n  ((major) == 0 ? 1 : -1)\n\n/* Resolve a platform specific conflict on DJGPP.  GNU gettext takes\n   precedence over _conio_gettext.  */\n#ifdef __DJGPP__\n# undef gettext\n#endif\n\n/* Use _INTL_PARAMS, not PARAMS, in order to avoid clashes with identifiers\n   used by programs.  Similarly, test __PROTOTYPES, not PROTOTYPES.  */\n#ifndef _INTL_PARAMS\n# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES\n#  define _INTL_PARAMS(args) args\n# else\n#  define _INTL_PARAMS(args) ()\n# endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* We redirect the functions to those prefixed with \"libintl_\".  This is\n   necessary, because some systems define gettext/textdomain/... in the C\n   library (namely, Solaris 2.4 and newer, and GNU libc 2.0 and newer).\n   If we used the unprefixed names, there would be cases where the\n   definition in the C library would override the one in the libintl.so\n   shared library.  Recall that on ELF systems, the symbols are looked\n   up in the following order:\n     1. in the executable,\n     2. in the shared libraries specified on the link command line, in order,\n     3. in the dependencies of the shared libraries specified on the link\n        command line,\n     4. in the dlopen()ed shared libraries, in the order in which they were\n        dlopen()ed.\n   The definition in the C library would override the one in libintl.so if\n   either\n     * -lc is given on the link command line and -lintl isn't, or\n     * -lc is given on the link command line before -lintl, or\n     * libintl.so is a dependency of a dlopen()ed shared library but not\n       linked to the executable at link time.\n   Since Solaris gettext() behaves differently than GNU gettext(), this\n   would be unacceptable.\n\n   The redirection happens by default through macros in C, so that &gettext\n   is independent of the compilation unit, but through inline functions in\n   C++, in order not to interfere with the name mangling of class fields or\n   class methods called 'gettext'.  */\n\n/* The user can define _INTL_REDIRECT_INLINE or _INTL_REDIRECT_MACROS.\n   If he doesn't, we choose the method.  A third possible method is\n   _INTL_REDIRECT_ASM, supported only by GCC.  */\n#if !(defined _INTL_REDIRECT_INLINE || defined _INTL_REDIRECT_MACROS)\n# if __GNUC__ >= 2 && !defined __APPLE_CC__ && (defined __STDC__ || defined __cplusplus)\n#  define _INTL_REDIRECT_ASM\n# else\n#  ifdef __cplusplus\n#   define _INTL_REDIRECT_INLINE\n#  else\n#   define _INTL_REDIRECT_MACROS\n#  endif\n# endif\n#endif\n/* Auxiliary macros.  */\n#ifdef _INTL_REDIRECT_ASM\n# define _INTL_ASM(cname) __asm__ (_INTL_ASMNAME (__USER_LABEL_PREFIX__, #cname))\n# define _INTL_ASMNAME(prefix,cnamestring) _INTL_STRINGIFY (prefix) cnamestring\n# define _INTL_STRINGIFY(prefix) #prefix\n#else\n# define _INTL_ASM(cname)\n#endif\n\n/* Look up MSGID in the current default message catalog for the current\n   LC_MESSAGES locale.  If not found, returns MSGID itself (the default\n   text).  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_gettext (const char *__msgid);\nstatic inline char *gettext (const char *__msgid)\n{\n  return libintl_gettext (__msgid);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define gettext libintl_gettext\n#endif\nextern char *gettext _INTL_PARAMS ((const char *__msgid))\n       _INTL_ASM (libintl_gettext);\n#endif\n\n/* Look up MSGID in the DOMAINNAME message catalog for the current\n   LC_MESSAGES locale.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_dgettext (const char *__domainname, const char *__msgid);\nstatic inline char *dgettext (const char *__domainname, const char *__msgid)\n{\n  return libintl_dgettext (__domainname, __msgid);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define dgettext libintl_dgettext\n#endif\nextern char *dgettext _INTL_PARAMS ((const char *__domainname,\n\t\t\t\t     const char *__msgid))\n       _INTL_ASM (libintl_dgettext);\n#endif\n\n/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY\n   locale.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_dcgettext (const char *__domainname, const char *__msgid,\n\t\t\t\tint __category);\nstatic inline char *dcgettext (const char *__domainname, const char *__msgid,\n\t\t\t       int __category)\n{\n  return libintl_dcgettext (__domainname, __msgid, __category);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define dcgettext libintl_dcgettext\n#endif\nextern char *dcgettext _INTL_PARAMS ((const char *__domainname,\n\t\t\t\t      const char *__msgid,\n\t\t\t\t      int __category))\n       _INTL_ASM (libintl_dcgettext);\n#endif\n\n\n/* Similar to `gettext' but select the plural form corresponding to the\n   number N.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_ngettext (const char *__msgid1, const char *__msgid2,\n\t\t\t       unsigned long int __n);\nstatic inline char *ngettext (const char *__msgid1, const char *__msgid2,\n\t\t\t      unsigned long int __n)\n{\n  return libintl_ngettext (__msgid1, __msgid2, __n);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define ngettext libintl_ngettext\n#endif\nextern char *ngettext _INTL_PARAMS ((const char *__msgid1,\n\t\t\t\t     const char *__msgid2,\n\t\t\t\t     unsigned long int __n))\n       _INTL_ASM (libintl_ngettext);\n#endif\n\n/* Similar to `dgettext' but select the plural form corresponding to the\n   number N.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_dngettext (const char *__domainname, const char *__msgid1,\n\t\t\t\tconst char *__msgid2, unsigned long int __n);\nstatic inline char *dngettext (const char *__domainname, const char *__msgid1,\n\t\t\t       const char *__msgid2, unsigned long int __n)\n{\n  return libintl_dngettext (__domainname, __msgid1, __msgid2, __n);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define dngettext libintl_dngettext\n#endif\nextern char *dngettext _INTL_PARAMS ((const char *__domainname,\n\t\t\t\t      const char *__msgid1,\n\t\t\t\t      const char *__msgid2,\n\t\t\t\t      unsigned long int __n))\n       _INTL_ASM (libintl_dngettext);\n#endif\n\n/* Similar to `dcgettext' but select the plural form corresponding to the\n   number N.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_dcngettext (const char *__domainname,\n\t\t\t\t const char *__msgid1, const char *__msgid2,\n\t\t\t\t unsigned long int __n, int __category);\nstatic inline char *dcngettext (const char *__domainname,\n\t\t\t\tconst char *__msgid1, const char *__msgid2,\n\t\t\t\tunsigned long int __n, int __category)\n{\n  return libintl_dcngettext (__domainname, __msgid1, __msgid2, __n, __category);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define dcngettext libintl_dcngettext\n#endif\nextern char *dcngettext _INTL_PARAMS ((const char *__domainname,\n\t\t\t\t       const char *__msgid1,\n\t\t\t\t       const char *__msgid2,\n\t\t\t\t       unsigned long int __n,\n\t\t\t\t       int __category))\n       _INTL_ASM (libintl_dcngettext);\n#endif\n\n\n/* Set the current default message catalog to DOMAINNAME.\n   If DOMAINNAME is null, return the current default.\n   If DOMAINNAME is \"\", reset to the default of \"messages\".  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_textdomain (const char *__domainname);\nstatic inline char *textdomain (const char *__domainname)\n{\n  return libintl_textdomain (__domainname);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define textdomain libintl_textdomain\n#endif\nextern char *textdomain _INTL_PARAMS ((const char *__domainname))\n       _INTL_ASM (libintl_textdomain);\n#endif\n\n/* Specify that the DOMAINNAME message catalog will be found\n   in DIRNAME rather than in the system locale data base.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_bindtextdomain (const char *__domainname,\n\t\t\t\t     const char *__dirname);\nstatic inline char *bindtextdomain (const char *__domainname,\n\t\t\t\t    const char *__dirname)\n{\n  return libintl_bindtextdomain (__domainname, __dirname);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define bindtextdomain libintl_bindtextdomain\n#endif\nextern char *bindtextdomain _INTL_PARAMS ((const char *__domainname,\n\t\t\t\t\t   const char *__dirname))\n       _INTL_ASM (libintl_bindtextdomain);\n#endif\n\n/* Specify the character encoding in which the messages from the\n   DOMAINNAME message catalog will be returned.  */\n#ifdef _INTL_REDIRECT_INLINE\nextern char *libintl_bind_textdomain_codeset (const char *__domainname,\n\t\t\t\t\t      const char *__codeset);\nstatic inline char *bind_textdomain_codeset (const char *__domainname,\n\t\t\t\t\t     const char *__codeset)\n{\n  return libintl_bind_textdomain_codeset (__domainname, __codeset);\n}\n#else\n#ifdef _INTL_REDIRECT_MACROS\n# define bind_textdomain_codeset libintl_bind_textdomain_codeset\n#endif\nextern char *bind_textdomain_codeset _INTL_PARAMS ((const char *__domainname,\n\t\t\t\t\t\t    const char *__codeset))\n       _INTL_ASM (libintl_bind_textdomain_codeset);\n#endif\n\n\n/* Support for relocatable packages.  */\n\n/* Sets the original and the current installation prefix of the package.\n   Relocation simply replaces a pathname starting with the original prefix\n   by the corresponding pathname with the current prefix instead.  Both\n   prefixes should be directory names without trailing slash (i.e. use \"\"\n   instead of \"/\").  */\n#define libintl_set_relocation_prefix libintl_set_relocation_prefix\nextern void\n       libintl_set_relocation_prefix _INTL_PARAMS ((const char *orig_prefix,\n\t\t\t\t\t\t    const char *curr_prefix));\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* libintl.h */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}