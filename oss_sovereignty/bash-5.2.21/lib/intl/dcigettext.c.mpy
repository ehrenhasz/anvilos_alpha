{
  "module_name": "dcigettext.c",
  "hash_id": "33b81113e145e5c30d619e2feebfca895cbb8f3b761c2f8e780a692269e4daaa",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/dcigettext.c",
  "human_readable_source": " \n\n \n\n \n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\t1\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <sys/types.h>\n\n#ifdef __GNUC__\n# define alloca __builtin_alloca\n# define HAVE_ALLOCA 1\n#else\n# ifdef _MSC_VER\n#  include <malloc.h>\n#  define alloca _alloca\n# else\n#  if defined HAVE_ALLOCA_H || defined _LIBC\n#   include <alloca.h>\n#  else\n#   ifdef _AIX\n #pragma alloca\n#   else\n#    ifndef alloca\nchar *alloca ();\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n\n#include <errno.h>\n#ifndef errno\nextern int errno;\n#endif\n#ifndef __set_errno\n# define __set_errno(val) errno = (val)\n#endif\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if defined HAVE_UNISTD_H || defined _LIBC\n# include <unistd.h>\n#endif\n\n#include <locale.h>\n\n#ifdef _LIBC\n   \n# if defined __alpha__ || defined __arm__ || defined __i386__ \\\n     || defined __m68k__ || defined __s390__\n#  define INTDIV0_RAISES_SIGFPE 1\n# else\n#  define INTDIV0_RAISES_SIGFPE 0\n# endif\n#endif\n#if !INTDIV0_RAISES_SIGFPE\n# include <signal.h>\n#endif\n\n#if defined HAVE_SYS_PARAM_H || defined _LIBC\n# include <sys/param.h>\n#endif\n\n#include \"gettextP.h\"\n#include \"plural-exp.h\"\n#ifdef _LIBC\n# include <libintl.h>\n#else\n# include \"libgnuintl.h\"\n#endif\n#include \"hash-string.h\"\n\n \n#ifdef _LIBC\n# include <bits/libc-lock.h>\n#else\n \n# define __libc_lock_define_initialized(CLASS, NAME)\n# define __libc_lock_lock(NAME)\n# define __libc_lock_unlock(NAME)\n# define __libc_rwlock_define_initialized(CLASS, NAME)\n# define __libc_rwlock_rdlock(NAME)\n# define __libc_rwlock_unlock(NAME)\n#endif\n\n \n#if defined __GNUC__ && __GNUC__ >= 2\n# define alignof(TYPE) __alignof__ (TYPE)\n#else\n# define alignof(TYPE) \\\n    ((int) &((struct { char dummy1; TYPE dummy2; } *) 0)->dummy2)\n#endif\n\n \n#if !defined _LIBC\n# define _nl_default_default_domain libintl_nl_default_default_domain\n# define _nl_current_default_domain libintl_nl_current_default_domain\n# define _nl_default_dirname libintl_nl_default_dirname\n# define _nl_domain_bindings libintl_nl_domain_bindings\n#endif\n\n \n#ifndef offsetof\n# define offsetof(type,ident) ((size_t)&(((type*)0)->ident))\n#endif\n\n \n\n#if defined (SHELL) && !defined (HAVE_GETCWD)\n#  define HAVE_GETCWD\n#endif\n\n#ifdef _LIBC\n \n# define getcwd __getcwd\n# ifndef stpcpy\n#  define stpcpy __stpcpy\n# endif\n# define tfind __tfind\n#else\n# if !defined HAVE_GETCWD\nchar *getwd ();\n#  define getcwd(buf, max) getwd (buf)\n# else\nchar *getcwd ();\n# endif\n# ifndef HAVE_STPCPY\nstatic char *stpcpy PARAMS ((char *dest, const char *src));\n# endif\n# ifndef HAVE_MEMPCPY\nstatic void *mempcpy PARAMS ((void *dest, const void *src, size_t n));\n# endif\n#endif\n\n \n#define PATH_INCR 32\n\n \n \n#if defined _POSIX_VERSION || (defined HAVE_LIMITS_H && !defined __GNUC__)\n# include <limits.h>\n#endif\n\n#ifndef _POSIX_PATH_MAX\n# define _POSIX_PATH_MAX 255\n#endif\n\n#if !defined PATH_MAX && defined _PC_PATH_MAX\n# define PATH_MAX (pathconf (\"/\", _PC_PATH_MAX) < 1 ? 1024 : pathconf (\"/\", _PC_PATH_MAX))\n#endif\n\n \n#if defined HAVE_SYS_PARAM_H && !defined PATH_MAX && !defined MAXPATHLEN\n# include <sys/param.h>\n#endif\n\n#if !defined PATH_MAX && defined MAXPATHLEN\n# define PATH_MAX MAXPATHLEN\n#endif\n\n#ifndef PATH_MAX\n# define PATH_MAX _POSIX_PATH_MAX\n#endif\n\n \n#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__\n   \n# define ISSLASH(C) ((C) == '/' || (C) == '\\\\')\n# define HAS_DEVICE(P) \\\n    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \\\n     && (P)[1] == ':')\n# define IS_ABSOLUTE_PATH(P) (ISSLASH ((P)[0]) || HAS_DEVICE (P))\n# define IS_PATH_WITH_DIR(P) \\\n    (strchr (P, '/') != NULL || strchr (P, '\\\\') != NULL || HAS_DEVICE (P))\n#else\n   \n# define ISSLASH(C) ((C) == '/')\n# define IS_ABSOLUTE_PATH(P) ISSLASH ((P)[0])\n# define IS_PATH_WITH_DIR(P) (strchr (P, '/') != NULL)\n#endif\n\n \nstruct known_translation_t\n{\n   \n  char *domainname;\n\n   \n  int category;\n\n   \n  int counter;\n\n   \n  struct loaded_l10nfile *domain;\n\n   \n  const char *translation;\n  size_t translation_length;\n\n   \n  char msgid[ZERO];\n};\n\n \n#if defined HAVE_TSEARCH || defined _LIBC\n# include <search.h>\n\nstatic void *root;\n\n# ifdef _LIBC\n#  define tsearch __tsearch\n# endif\n\n \nstatic int transcmp PARAMS ((const void *p1, const void *p2));\nstatic int\ntranscmp (p1, p2)\n     const void *p1;\n     const void *p2;\n{\n  const struct known_translation_t *s1;\n  const struct known_translation_t *s2;\n  int result;\n\n  s1 = (const struct known_translation_t *) p1;\n  s2 = (const struct known_translation_t *) p2;\n\n  result = strcmp (s1->msgid, s2->msgid);\n  if (result == 0)\n    {\n      result = strcmp (s1->domainname, s2->domainname);\n      if (result == 0)\n\t \n\tresult = s1->category - s2->category;\n    }\n\n  return result;\n}\n#endif\n\n#ifndef INTVARDEF\n# define INTVARDEF(name)\n#endif\n#ifndef INTUSE\n# define INTUSE(name) name\n#endif\n\n \nconst char _nl_default_default_domain[] attribute_hidden = \"messages\";\n\n \nconst char *_nl_current_default_domain attribute_hidden\n     = _nl_default_default_domain;\n\n \n#if defined __EMX__\nextern const char _nl_default_dirname[];\n#else\nconst char _nl_default_dirname[] = LOCALEDIR;\nINTVARDEF (_nl_default_dirname)\n#endif\n\n \nstruct binding *_nl_domain_bindings;\n\n \nstatic char *plural_lookup PARAMS ((struct loaded_l10nfile *domain,\n\t\t\t\t    unsigned long int n,\n\t\t\t\t    const char *translation,\n\t\t\t\t    size_t translation_len))\n     internal_function;\nstatic const char *guess_category_value PARAMS ((int category,\n\t\t\t\t\t\t const char *categoryname))\n     internal_function;\n#ifdef _LIBC\n# include \"../locale/localeinfo.h\"\n# define category_to_name(category)\t_nl_category_names[category]\n#else\nstatic const char *category_to_name PARAMS ((int category)) internal_function;\n#endif\n\n\n \n#ifdef HAVE_ALLOCA\n \n# define freea(p)  \n# define ADD_BLOCK(list, address)  \n# define FREE_BLOCKS(list)  \n#else\nstruct block_list\n{\n  void *address;\n  struct block_list *next;\n};\n# define ADD_BLOCK(list, addr)\t\t\t\t\t\t      \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \\\n     \t\t\t\t\t\t\t      \\\n    if (newp != NULL) {\t\t\t\t\t\t\t      \\\n      newp->address = (addr);\t\t\t\t\t\t      \\\n      newp->next = (list);\t\t\t\t\t\t      \\\n      (list) = newp;\t\t\t\t\t\t\t      \\\n    }\t\t\t\t\t\t\t\t\t      \\\n  } while (0)\n# define FREE_BLOCKS(list)\t\t\t\t\t\t      \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    while (list != NULL) {\t\t\t\t\t\t      \\\n      struct block_list *old = list;\t\t\t\t\t      \\\n      list = list->next;\t\t\t\t\t\t      \\\n      free (old->address);\t\t\t\t\t\t      \\\n      free (old);\t\t\t\t\t\t\t      \\\n    }\t\t\t\t\t\t\t\t\t      \\\n  } while (0)\n# undef alloca\n# define alloca(size) (malloc (size))\n# define freea(p) free (p)\n#endif\t \n\n\n#ifdef _LIBC\n \ntypedef struct transmem_list\n{\n  struct transmem_list *next;\n  char data[ZERO];\n} transmem_block_t;\nstatic struct transmem_list *transmem_list;\n#else\ntypedef unsigned char transmem_block_t;\n#endif\n\n\n \n#ifdef _LIBC\n# define DCIGETTEXT __dcigettext\n#else\n# define DCIGETTEXT libintl_dcigettext\n#endif\n\n \n#ifdef _LIBC\n__libc_rwlock_define_initialized (, _nl_state_lock attribute_hidden)\n#endif\n\n \n#ifdef _LIBC\n# define ENABLE_SECURE __libc_enable_secure\n# define DETERMINE_SECURE\n#else\n# ifndef HAVE_GETUID\n#  define getuid() 0\n# endif\n# ifndef HAVE_GETGID\n#  define getgid() 0\n# endif\n# ifndef HAVE_GETEUID\n#  define geteuid() getuid()\n# endif\n# ifndef HAVE_GETEGID\n#  define getegid() getgid()\n# endif\nstatic int enable_secure;\n# define ENABLE_SECURE (enable_secure == 1)\n# define DETERMINE_SECURE \\\n  if (enable_secure == 0)\t\t\t\t\t\t      \\\n    {\t\t\t\t\t\t\t\t\t      \\\n      if (getuid () != geteuid () || getgid () != getegid ())\t\t      \\\n\tenable_secure = 1;\t\t\t\t\t\t      \\\n      else\t\t\t\t\t\t\t\t      \\\n\tenable_secure = -1;\t\t\t\t\t\t      \\\n    }\n#endif\n\n#ifndef HAVE_RAISE\n#  define raise(x)\tkill (getpid (), (x))\n#endif\n\n \n#include \"eval-plural.h\"\n\n \nchar *\nDCIGETTEXT (domainname, msgid1, msgid2, plural, n, category)\n     const char *domainname;\n     const char *msgid1;\n     const char *msgid2;\n     int plural;\n     unsigned long int n;\n     int category;\n{\n#ifndef HAVE_ALLOCA\n  struct block_list *block_list = NULL;\n#endif\n  struct loaded_l10nfile *domain;\n  struct binding *binding;\n  const char *categoryname;\n  const char *categoryvalue;\n  char *dirname, *xdomainname;\n  char *single_locale;\n  char *retval;\n  size_t retlen;\n  int saved_errno;\n#if defined HAVE_TSEARCH || defined _LIBC\n  struct known_translation_t *search;\n  struct known_translation_t **foundp = NULL;\n  size_t msgid_len;\n#endif\n  size_t domainname_len;\n\n   \n  if (msgid1 == NULL)\n    return NULL;\n\n#ifdef _LIBC\n  if (category < 0 || category >= __LC_LAST || category == LC_ALL)\n     \n    return (plural == 0\n\t    ? (char *) msgid1\n\t     \n\t    : n == 1 ? (char *) msgid1 : (char *) msgid2);\n#endif\n\n  __libc_rwlock_rdlock (_nl_state_lock);\n\n   \n  if (domainname == NULL)\n    domainname = _nl_current_default_domain;\n\n   \n#ifdef LC_MESSAGES_COMPAT\n  if (category == LC_MESSAGES_COMPAT)\n    category = LC_MESSAGES;\n#endif\n\n#if defined HAVE_TSEARCH || defined _LIBC\n  msgid_len = strlen (msgid1) + 1;\n\n   \n  search = (struct known_translation_t *)\n\t   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);\n  memcpy (search->msgid, msgid1, msgid_len);\n  search->domainname = (char *) domainname;\n  search->category = category;\n\n  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);\n  freea (search);\n  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)\n    {\n       \n      if (plural)\n\tretval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,\n\t\t\t\t(*foundp)->translation_length);\n      else\n\tretval = (char *) (*foundp)->translation;\n\n      __libc_rwlock_unlock (_nl_state_lock);\n      return retval;\n    }\n#endif\n\n   \n  saved_errno = errno;\n\n   \n  DETERMINE_SECURE;\n\n   \n  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)\n    {\n      int compare = strcmp (domainname, binding->domainname);\n      if (compare == 0)\n\t \n\tbreak;\n      if (compare < 0)\n\t{\n\t   \n\t  binding = NULL;\n\t  break;\n\t}\n    }\n\n  if (binding == NULL)\n    dirname = (char *) INTUSE(_nl_default_dirname);\n  else if (IS_ABSOLUTE_PATH (binding->dirname))\n    dirname = binding->dirname;\n  else\n    {\n       \n      size_t dirname_len = strlen (binding->dirname) + 1;\n      size_t path_max;\n      char *ret;\n\n      path_max = (unsigned int) PATH_MAX;\n      path_max += 2;\t\t \n\n      for (;;)\n\t{\n\t  dirname = (char *) alloca (path_max + dirname_len);\n\t  ADD_BLOCK (block_list, dirname);\n\n\t  __set_errno (0);\n\t  ret = getcwd (dirname, path_max);\n\t  if (ret != NULL || errno != ERANGE)\n\t    break;\n\n\t  path_max += path_max / 2;\n\t  path_max += PATH_INCR;\n\t}\n\n      if (ret == NULL)\n\t \n\tgoto return_untranslated;\n\n      stpcpy (stpcpy (strchr (dirname, '\\0'), \"/\"), binding->dirname);\n    }\n\n   \n  categoryname = category_to_name (category);\n  categoryvalue = guess_category_value (category, categoryname);\n\n  domainname_len = strlen (domainname);\n  xdomainname = (char *) alloca (strlen (categoryname)\n\t\t\t\t + domainname_len + 5);\n  ADD_BLOCK (block_list, xdomainname);\n\n  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), \"/\"),\n\t\t  domainname, domainname_len),\n\t  \".mo\");\n\n   \n  single_locale = (char *) alloca (strlen (categoryvalue) + 1);\n  ADD_BLOCK (block_list, single_locale);\n\n\n   \n  while (1)\n    {\n       \n      while (categoryvalue[0] != '\\0' && categoryvalue[0] == ':')\n\t++categoryvalue;\n      if (categoryvalue[0] == '\\0')\n\t{\n\t   \n\t  single_locale[0] = 'C';\n\t  single_locale[1] = '\\0';\n\t}\n      else\n\t{\n\t  char *cp = single_locale;\n\t  while (categoryvalue[0] != '\\0' && categoryvalue[0] != ':')\n\t    *cp++ = *categoryvalue++;\n\t  *cp = '\\0';\n\n\t   \n\t  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))\n\t     \n\t    continue;\n\t}\n\n       \n      if (strcmp (single_locale, \"C\") == 0\n\t  || strcmp (single_locale, \"POSIX\") == 0)\n\tbreak;\n\n       \n      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);\n\n      if (domain != NULL)\n\t{\n\t  retval = _nl_find_msg (domain, binding, msgid1, &retlen);\n\n\t  if (retval == NULL)\n\t    {\n\t      int cnt;\n\n\t      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)\n\t\t{\n\t\t  retval = _nl_find_msg (domain->successor[cnt], binding,\n\t\t\t\t\t msgid1, &retlen);\n\n\t\t  if (retval != NULL)\n\t\t    {\n\t\t      domain = domain->successor[cnt];\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (retval != NULL)\n\t    {\n\t       \n\t      FREE_BLOCKS (block_list);\n#if defined HAVE_TSEARCH || defined _LIBC\n\t      if (foundp == NULL)\n\t\t{\n\t\t   \n\t\t  struct known_translation_t *newp;\n\n\t\t  newp = (struct known_translation_t *)\n\t\t    malloc (offsetof (struct known_translation_t, msgid)\n\t\t\t    + msgid_len + domainname_len + 1);\n\t\t  if (newp != NULL)\n\t\t    {\n\t\t      newp->domainname =\n\t\t\tmempcpy (newp->msgid, msgid1, msgid_len);\n\t\t      memcpy (newp->domainname, domainname, domainname_len + 1);\n\t\t      newp->category = category;\n\t\t      newp->counter = _nl_msg_cat_cntr;\n\t\t      newp->domain = domain;\n\t\t      newp->translation = retval;\n\t\t      newp->translation_length = retlen;\n\n\t\t       \n\t\t      foundp = (struct known_translation_t **)\n\t\t\ttsearch (newp, &root, transcmp);\n\t\t      if (foundp == NULL\n\t\t\t  || __builtin_expect (*foundp != newp, 0))\n\t\t\t \n\t\t\tfree (newp);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t   \n\t\t  (*foundp)->counter = _nl_msg_cat_cntr;\n\t\t  (*foundp)->domain = domain;\n\t\t  (*foundp)->translation = retval;\n\t\t  (*foundp)->translation_length = retlen;\n\t\t}\n#endif\n\t      __set_errno (saved_errno);\n\n\t       \n\t      if (plural)\n\t\tretval = plural_lookup (domain, n, retval, retlen);\n\n\t      __libc_rwlock_unlock (_nl_state_lock);\n\t      return retval;\n\t    }\n\t}\n    }\n\n return_untranslated:\n   \n  FREE_BLOCKS (block_list);\n  __libc_rwlock_unlock (_nl_state_lock);\n#ifndef _LIBC\n  if (!ENABLE_SECURE)\n    {\n      extern void _nl_log_untranslated PARAMS ((const char *logfilename,\n\t\t\t\t\t\tconst char *domainname,\n\t\t\t\t\t\tconst char *msgid1,\n\t\t\t\t\t\tconst char *msgid2,\n\t\t\t\t\t\tint plural));\n      const char *logfilename = getenv (\"GETTEXT_LOG_UNTRANSLATED\");\n\n      if (logfilename != NULL && logfilename[0] != '\\0')\n\t_nl_log_untranslated (logfilename, domainname, msgid1, msgid2, plural);\n    }\n#endif\n  __set_errno (saved_errno);\n  return (plural == 0\n\t  ? (char *) msgid1\n\t   \n\t  : n == 1 ? (char *) msgid1 : (char *) msgid2);\n}\n\n\nchar *\ninternal_function\n_nl_find_msg (domain_file, domainbinding, msgid, lengthp)\n     struct loaded_l10nfile *domain_file;\n     struct binding *domainbinding;\n     const char *msgid;\n     size_t *lengthp;\n{\n  struct loaded_domain *domain;\n  nls_uint32 nstrings;\n  size_t act;\n  char *result;\n  size_t resultlen;\n\n  if (domain_file->decided == 0)\n    _nl_load_domain (domain_file, domainbinding);\n\n  if (domain_file->data == NULL)\n    return NULL;\n\n  domain = (struct loaded_domain *) domain_file->data;\n\n  nstrings = domain->nstrings;\n\n   \n  if (domain->hash_tab != NULL)\n    {\n       \n      nls_uint32 len = strlen (msgid);\n      nls_uint32 hash_val = hash_string (msgid);\n      nls_uint32 idx = hash_val % domain->hash_size;\n      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));\n\n      while (1)\n\t{\n\t  nls_uint32 nstr =\n\t    W (domain->must_swap_hash_tab, domain->hash_tab[idx]);\n\n\t  if (nstr == 0)\n\t     \n\t    return NULL;\n\n\t  nstr--;\n\n\t   \n\t  if (nstr < nstrings\n\t      ? W (domain->must_swap, domain->orig_tab[nstr].length) >= len\n\t\t&& (strcmp (msgid,\n\t\t\t    domain->data + W (domain->must_swap,\n\t\t\t\t\t      domain->orig_tab[nstr].offset))\n\t\t    == 0)\n\t      : domain->orig_sysdep_tab[nstr - nstrings].length > len\n\t\t&& (strcmp (msgid,\n\t\t\t    domain->orig_sysdep_tab[nstr - nstrings].pointer)\n\t\t    == 0))\n\t    {\n\t      act = nstr;\n\t      goto found;\n\t    }\n\n\t  if (idx >= domain->hash_size - incr)\n\t    idx -= domain->hash_size - incr;\n\t  else\n\t    idx += incr;\n\t}\n       \n    }\n  else\n    {\n       \n      size_t top, bottom;\n\n      bottom = 0;\n      top = nstrings;\n      while (bottom < top)\n\t{\n\t  int cmp_val;\n\n\t  act = (bottom + top) / 2;\n\t  cmp_val = strcmp (msgid, (domain->data\n\t\t\t\t    + W (domain->must_swap,\n\t\t\t\t\t domain->orig_tab[act].offset)));\n\t  if (cmp_val < 0)\n\t    top = act;\n\t  else if (cmp_val > 0)\n\t    bottom = act + 1;\n\t  else\n\t    goto found;\n\t}\n       \n      return NULL;\n    }\n\n found:\n   \n  if (act < nstrings)\n    {\n      result = (char *)\n\t(domain->data + W (domain->must_swap, domain->trans_tab[act].offset));\n      resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;\n    }\n  else\n    {\n      result = (char *) domain->trans_sysdep_tab[act - nstrings].pointer;\n      resultlen = domain->trans_sysdep_tab[act - nstrings].length;\n    }\n\n#if defined _LIBC || HAVE_ICONV\n  if (domain->codeset_cntr\n      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))\n    {\n       \n      _nl_free_domain_conv (domain);\n      _nl_init_domain_conv (domain_file, domain, domainbinding);\n    }\n\n  if (\n# ifdef _LIBC\n      domain->conv != (__gconv_t) -1\n# else\n#  if HAVE_ICONV\n      domain->conv != (iconv_t) -1\n#  endif\n# endif\n      )\n    {\n       \n\n      if (domain->conv_tab == NULL\n\t  && ((domain->conv_tab =\n\t\t (char **) calloc (nstrings + domain->n_sysdep_strings,\n\t\t\t\t   sizeof (char *)))\n\t      == NULL))\n\t \n\tdomain->conv_tab = (char **) -1;\n\n      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))\n\t \n\tgoto converted;\n\n      if (domain->conv_tab[act] == NULL)\n\t{\n\t   \n\t   \n\t  __libc_lock_define_initialized (static, lock)\n# define INITIAL_BLOCK_SIZE\t4080\n\t  static unsigned char *freemem;\n\t  static size_t freemem_size;\n\n\t  const unsigned char *inbuf;\n\t  unsigned char *outbuf;\n\t  int malloc_count;\n# ifndef _LIBC\n\t  transmem_block_t *transmem_list = NULL;\n# endif\n\n\t  __libc_lock_lock (lock);\n\n\t  inbuf = (const unsigned char *) result;\n\t  outbuf = freemem + sizeof (size_t);\n\n\t  malloc_count = 0;\n\t  while (1)\n\t    {\n\t      transmem_block_t *newmem;\n# ifdef _LIBC\n\t      size_t non_reversible;\n\t      int res;\n\n\t      if (freemem_size < sizeof (size_t))\n\t\tgoto resize_freemem;\n\n\t      res = __gconv (domain->conv,\n\t\t\t     &inbuf, inbuf + resultlen,\n\t\t\t     &outbuf,\n\t\t\t     outbuf + freemem_size - sizeof (size_t),\n\t\t\t     &non_reversible);\n\n\t      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)\n\t\tbreak;\n\n\t      if (res != __GCONV_FULL_OUTPUT)\n\t\t{\n\t\t  __libc_lock_unlock (lock);\n\t\t  goto converted;\n\t\t}\n\n\t      inbuf = result;\n# else\n#  if HAVE_ICONV\n\t      const char *inptr = (const char *) inbuf;\n\t      size_t inleft = resultlen;\n\t      char *outptr = (char *) outbuf;\n\t      size_t outleft;\n\n\t      if (freemem_size < sizeof (size_t))\n\t\tgoto resize_freemem;\n\n\t      outleft = freemem_size - sizeof (size_t);\n\t      if (iconv (domain->conv,\n\t\t\t (ICONV_CONST char **) &inptr, &inleft,\n\t\t\t &outptr, &outleft)\n\t\t  != (size_t) (-1))\n\t\t{\n\t\t  outbuf = (unsigned char *) outptr;\n\t\t  break;\n\t\t}\n\t      if (errno != E2BIG)\n\t\t{\n\t\t  __libc_lock_unlock (lock);\n\t\t  goto converted;\n\t\t}\n#  endif\n# endif\n\n\t    resize_freemem:\n\t       \n\t      if (malloc_count > 0)\n\t\t{\n\t\t  ++malloc_count;\n\t\t  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;\n\t\t  newmem = (transmem_block_t *) realloc (transmem_list,\n\t\t\t\t\t\t\t freemem_size);\n# ifdef _LIBC\n\t\t  if (newmem != NULL)\n\t\t    transmem_list = transmem_list->next;\n\t\t  else\n\t\t    {\n\t\t      struct transmem_list *old = transmem_list;\n\n\t\t      transmem_list = transmem_list->next;\n\t\t      free (old);\n\t\t    }\n# endif\n\t\t}\n\t      else\n\t\t{\n\t\t  malloc_count = 1;\n\t\t  freemem_size = INITIAL_BLOCK_SIZE;\n\t\t  newmem = (transmem_block_t *) malloc (freemem_size);\n\t\t}\n\t      if (__builtin_expect (newmem == NULL, 0))\n\t\t{\n\t\t  freemem = NULL;\n\t\t  freemem_size = 0;\n\t\t  __libc_lock_unlock (lock);\n\t\t  goto converted;\n\t\t}\n\n# ifdef _LIBC\n\t       \n\t      newmem->next = transmem_list;\n\t      transmem_list = newmem;\n\n\t      freemem = newmem->data;\n\t      freemem_size -= offsetof (struct transmem_list, data);\n# else\n\t      transmem_list = newmem;\n\t      freemem = newmem;\n# endif\n\n\t      outbuf = freemem + sizeof (size_t);\n\t    }\n\n\t   \n\t  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);\n\t  domain->conv_tab[act] = (char *) freemem;\n\t   \n\t  freemem_size -= outbuf - freemem;\n\t  freemem = outbuf;\n\t  freemem += freemem_size & (alignof (size_t) - 1);\n\t  freemem_size = freemem_size & ~ (alignof (size_t) - 1);\n\n\t  __libc_lock_unlock (lock);\n\t}\n\n       \n      result = domain->conv_tab[act] + sizeof (size_t);\n      resultlen = *(size_t *) domain->conv_tab[act];\n    }\n\n converted:\n   \n\n#endif  \n\n  *lengthp = resultlen;\n  return result;\n}\n\n\n \nstatic char *\ninternal_function\nplural_lookup (domain, n, translation, translation_len)\n     struct loaded_l10nfile *domain;\n     unsigned long int n;\n     const char *translation;\n     size_t translation_len;\n{\n  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;\n  unsigned long int index;\n  const char *p;\n\n  index = plural_eval (domaindata->plural, n);\n  if (index >= domaindata->nplurals)\n     \n    index = 0;\n\n   \n  p = translation;\n  while (index-- > 0)\n    {\n#ifdef _LIBC\n      p = __rawmemchr (p, '\\0');\n#else\n      p = strchr (p, '\\0');\n#endif\n       \n      p++;\n\n      if (p >= translation + translation_len)\n\t \n\treturn (char *) translation;\n    }\n  return (char *) p;\n}\n\n#ifndef _LIBC\n \nstatic const char *\ninternal_function\ncategory_to_name (category)\n     int category;\n{\n  const char *retval;\n\n  switch (category)\n  {\n#ifdef LC_COLLATE\n  case LC_COLLATE:\n    retval = \"LC_COLLATE\";\n    break;\n#endif\n#ifdef LC_CTYPE\n  case LC_CTYPE:\n    retval = \"LC_CTYPE\";\n    break;\n#endif\n#ifdef LC_MONETARY\n  case LC_MONETARY:\n    retval = \"LC_MONETARY\";\n    break;\n#endif\n#ifdef LC_NUMERIC\n  case LC_NUMERIC:\n    retval = \"LC_NUMERIC\";\n    break;\n#endif\n#ifdef LC_TIME\n  case LC_TIME:\n    retval = \"LC_TIME\";\n    break;\n#endif\n#ifdef LC_MESSAGES\n  case LC_MESSAGES:\n    retval = \"LC_MESSAGES\";\n    break;\n#endif\n#ifdef LC_RESPONSE\n  case LC_RESPONSE:\n    retval = \"LC_RESPONSE\";\n    break;\n#endif\n#ifdef LC_ALL\n  case LC_ALL:\n     \n    retval = \"LC_ALL\";\n    break;\n#endif\n  default:\n     \n    retval = \"LC_XXX\";\n  }\n\n  return retval;\n}\n#endif\n\n \nstatic const char *\ninternal_function\nguess_category_value (category, categoryname)\n     int category;\n     const char *categoryname;\n{\n  const char *language;\n  const char *retval;\n\n   \n  language = getenv (\"LANGUAGE\");\n  if (language != NULL && language[0] == '\\0')\n    language = NULL;\n\n   \n#ifdef _LIBC\n  retval = __current_locale_name (category);\n#else\n  retval = _nl_locale_name (category, categoryname);\n#endif\n\n   \n  return language != NULL && strcmp (retval, \"C\") != 0 ? language : retval;\n}\n\n \n\n \n#if !_LIBC && !HAVE_STPCPY\nstatic char *\nstpcpy (dest, src)\n     char *dest;\n     const char *src;\n{\n  while ((*dest++ = *src++) != '\\0')\n      ;\n  return dest - 1;\n}\n#endif\n\n#if !_LIBC && !HAVE_MEMPCPY\nstatic void *\nmempcpy (dest, src, n)\n     void *dest;\n     const void *src;\n     size_t n;\n{\n  return (void *) ((char *) memcpy (dest, src, n) + n);\n}\n#endif\n\n\n#ifdef _LIBC\n \nlibc_freeres_fn (free_mem)\n{\n  void *old;\n\n  while (_nl_domain_bindings != NULL)\n    {\n      struct binding *oldp = _nl_domain_bindings;\n      _nl_domain_bindings = _nl_domain_bindings->next;\n      if (oldp->dirname != INTUSE(_nl_default_dirname))\n\t \n\tfree (oldp->dirname);\n      free (oldp->codeset);\n      free (oldp);\n    }\n\n  if (_nl_current_default_domain != _nl_default_default_domain)\n     \n    free ((char *) _nl_current_default_domain);\n\n   \n  __tdestroy (root, free);\n  root = NULL;\n\n  while (transmem_list != NULL)\n    {\n      old = transmem_list;\n      transmem_list = transmem_list->next;\n      free (old);\n    }\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}