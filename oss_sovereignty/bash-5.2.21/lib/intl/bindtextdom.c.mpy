{
  "module_name": "bindtextdom.c",
  "hash_id": "745b319812ed58491d39e4de88da3104e3910e472658105b208c810917a42ec1",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/bindtextdom.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _LIBC\n# include <libintl.h>\n#else\n# include \"libgnuintl.h\"\n#endif\n#include \"gettextP.h\"\n\n#ifdef _LIBC\n \n# include <bits/libc-lock.h>\n#else\n \n# define __libc_rwlock_define(CLASS, NAME)\n# define __libc_rwlock_wrlock(NAME)\n# define __libc_rwlock_unlock(NAME)\n#endif\n\n \n#if !defined _LIBC\n# define _nl_default_dirname libintl_nl_default_dirname\n# define _nl_domain_bindings libintl_nl_domain_bindings\n#endif\n\n \n#ifndef offsetof\n# define offsetof(type,ident) ((size_t)&(((type*)0)->ident))\n#endif\n\n \n\n \nextern const char _nl_default_dirname[];\n#ifdef _LIBC\nextern const char _nl_default_dirname_internal[] attribute_hidden;\n#else\n# define INTUSE(name) name\n#endif\n\n \nextern struct binding *_nl_domain_bindings;\n\n \n__libc_rwlock_define (extern, _nl_state_lock attribute_hidden)\n\n\n \n#ifdef _LIBC\n# define BINDTEXTDOMAIN __bindtextdomain\n# define BIND_TEXTDOMAIN_CODESET __bind_textdomain_codeset\n# ifndef strdup\n#  define strdup(str) __strdup (str)\n# endif\n#else\n# define BINDTEXTDOMAIN libintl_bindtextdomain\n# define BIND_TEXTDOMAIN_CODESET libintl_bind_textdomain_codeset\n#endif\n\n \nstatic void set_binding_values PARAMS ((const char *domainname,\n\t\t\t\t\tconst char **dirnamep,\n\t\t\t\t\tconst char **codesetp));\n\n \nstatic void\nset_binding_values (domainname, dirnamep, codesetp)\n     const char *domainname;\n     const char **dirnamep;\n     const char **codesetp;\n{\n  struct binding *binding;\n  int modified;\n\n   \n  if (domainname == NULL || domainname[0] == '\\0')\n    {\n      if (dirnamep)\n\t*dirnamep = NULL;\n      if (codesetp)\n\t*codesetp = NULL;\n      return;\n    }\n\n  __libc_rwlock_wrlock (_nl_state_lock);\n\n  modified = 0;\n\n  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)\n    {\n      int compare = strcmp (domainname, binding->domainname);\n      if (compare == 0)\n\t \n\tbreak;\n      if (compare < 0)\n\t{\n\t   \n\t  binding = NULL;\n\t  break;\n\t}\n    }\n\n  if (binding != NULL)\n    {\n      if (dirnamep)\n\t{\n\t  const char *dirname = *dirnamep;\n\n\t  if (dirname == NULL)\n\t     \n\t    *dirnamep = binding->dirname;\n\t  else\n\t    {\n\t       \n\t      char *result = binding->dirname;\n\t      if (strcmp (dirname, result) != 0)\n\t\t{\n\t\t  if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)\n\t\t    result = (char *) INTUSE(_nl_default_dirname);\n\t\t  else\n\t\t    {\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t      result = strdup (dirname);\n#else\n\t\t      size_t len = strlen (dirname) + 1;\n\t\t      result = (char *) malloc (len);\n\t\t      if (__builtin_expect (result != NULL, 1))\n\t\t\tmemcpy (result, dirname, len);\n#endif\n\t\t    }\n\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    {\n\t\t      if (binding->dirname != INTUSE(_nl_default_dirname))\n\t\t\tfree (binding->dirname);\n\n\t\t      binding->dirname = result;\n\t\t      modified = 1;\n\t\t    }\n\t\t}\n\t      *dirnamep = result;\n\t    }\n\t}\n\n      if (codesetp)\n\t{\n\t  const char *codeset = *codesetp;\n\n\t  if (codeset == NULL)\n\t     \n\t    *codesetp = binding->codeset;\n\t  else\n\t    {\n\t       \n\t      char *result = binding->codeset;\n\t      if (result == NULL || strcmp (codeset, result) != 0)\n\t\t{\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t  result = strdup (codeset);\n#else\n\t\t  size_t len = strlen (codeset) + 1;\n\t\t  result = (char *) malloc (len);\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    memcpy (result, codeset, len);\n#endif\n\n\t\t  if (__builtin_expect (result != NULL, 1))\n\t\t    {\n\t\t      if (binding->codeset != NULL)\n\t\t\tfree (binding->codeset);\n\n\t\t      binding->codeset = result;\n\t\t      binding->codeset_cntr++;\n\t\t      modified = 1;\n\t\t    }\n\t\t}\n\t      *codesetp = result;\n\t    }\n\t}\n    }\n  else if ((dirnamep == NULL || *dirnamep == NULL)\n\t   && (codesetp == NULL || *codesetp == NULL))\n    {\n       \n      if (dirnamep)\n\t*dirnamep = INTUSE(_nl_default_dirname);\n      if (codesetp)\n\t*codesetp = NULL;\n    }\n  else\n    {\n       \n      size_t len = strlen (domainname) + 1;\n      struct binding *new_binding =\n\t(struct binding *) malloc (offsetof (struct binding, domainname) + len);\n\n      if (__builtin_expect (new_binding == NULL, 0))\n\tgoto failed;\n\n      memcpy (new_binding->domainname, domainname, len);\n\n      if (dirnamep)\n\t{\n\t  const char *dirname = *dirnamep;\n\n\t  if (dirname == NULL)\n\t     \n\t    dirname = INTUSE(_nl_default_dirname);\n\t  else\n\t    {\n\t      if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)\n\t\tdirname = INTUSE(_nl_default_dirname);\n\t      else\n\t\t{\n\t\t  char *result;\n#if defined _LIBC || defined HAVE_STRDUP\n\t\t  result = strdup (dirname);\n\t\t  if (__builtin_expect (result == NULL, 0))\n\t\t    goto failed_dirname;\n#else\n\t\t  size_t len = strlen (dirname) + 1;\n\t\t  result = (char *) malloc (len);\n\t\t  if (__builtin_expect (result == NULL, 0))\n\t\t    goto failed_dirname;\n\t\t  memcpy (result, dirname, len);\n#endif\n\t\t  dirname = result;\n\t\t}\n\t    }\n\t  *dirnamep = dirname;\n\t  new_binding->dirname = (char *) dirname;\n\t}\n      else\n\t \n\tnew_binding->dirname = (char *) INTUSE(_nl_default_dirname);\n\n      new_binding->codeset_cntr = 0;\n\n      if (codesetp)\n\t{\n\t  const char *codeset = *codesetp;\n\n\t  if (codeset != NULL)\n\t    {\n\t      char *result;\n\n#if defined _LIBC || defined HAVE_STRDUP\n\t      result = strdup (codeset);\n\t      if (__builtin_expect (result == NULL, 0))\n\t\tgoto failed_codeset;\n#else\n\t      size_t len = strlen (codeset) + 1;\n\t      result = (char *) malloc (len);\n\t      if (__builtin_expect (result == NULL, 0))\n\t\tgoto failed_codeset;\n\t      memcpy (result, codeset, len);\n#endif\n\t      codeset = result;\n\t      new_binding->codeset_cntr++;\n\t    }\n\t  *codesetp = codeset;\n\t  new_binding->codeset = (char *) codeset;\n\t}\n      else\n\tnew_binding->codeset = NULL;\n\n       \n      if (_nl_domain_bindings == NULL\n\t  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)\n\t{\n\t  new_binding->next = _nl_domain_bindings;\n\t  _nl_domain_bindings = new_binding;\n\t}\n      else\n\t{\n\t  binding = _nl_domain_bindings;\n\t  while (binding->next != NULL\n\t\t && strcmp (domainname, binding->next->domainname) > 0)\n\t    binding = binding->next;\n\n\t  new_binding->next = binding->next;\n\t  binding->next = new_binding;\n\t}\n\n      modified = 1;\n\n       \n      if (0)\n\t{\n\tfailed_codeset:\n\t  if (new_binding->dirname != INTUSE(_nl_default_dirname))\n\t    free (new_binding->dirname);\n\tfailed_dirname:\n\t  free (new_binding);\n\tfailed:\n\t  if (dirnamep)\n\t    *dirnamep = NULL;\n\t  if (codesetp)\n\t    *codesetp = NULL;\n\t}\n    }\n\n   \n  if (modified)\n    ++_nl_msg_cat_cntr;\n\n  __libc_rwlock_unlock (_nl_state_lock);\n}\n\n \nchar *\nBINDTEXTDOMAIN (domainname, dirname)\n     const char *domainname;\n     const char *dirname;\n{\n  set_binding_values (domainname, &dirname, NULL);\n  return (char *) dirname;\n}\n\n \nchar *\nBIND_TEXTDOMAIN_CODESET (domainname, codeset)\n     const char *domainname;\n     const char *codeset;\n{\n  set_binding_values (domainname, NULL, &codeset);\n  return (char *) codeset;\n}\n\n#ifdef _LIBC\n \nweak_alias (__bindtextdomain, bindtextdomain);\nweak_alias (__bind_textdomain_codeset, bind_textdomain_codeset);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}