{
  "module_name": "plural.c",
  "hash_id": "1423c475090b80a3139b7522b267fdad907a6d142d7061c6423dccfabbd01d93",
  "original_prompt": "Ingested from bash-5.2.21/lib/intl/plural.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n \n\n \n#define YYBISON 1\n\n \n#define YYSKELETON_NAME \"yacc.c\"\n\n \n#define YYPURE 1\n\n \n#define YYLSP_NEEDED 0\n\n \n#define yyparse __gettextparse\n#define yylex   __gettextlex\n#define yyerror __gettexterror\n#define yylval  __gettextlval\n#define yychar  __gettextchar\n#define yydebug __gettextdebug\n#define yynerrs __gettextnerrs\n\n\n \n#ifndef YYTOKENTYPE\n# define YYTOKENTYPE\n    \n   enum yytokentype {\n     EQUOP2 = 258,\n     CMPOP2 = 259,\n     ADDOP2 = 260,\n     MULOP2 = 261,\n     NUMBER = 262\n   };\n#endif\n#define EQUOP2 258\n#define CMPOP2 259\n#define ADDOP2 260\n#define MULOP2 261\n#define NUMBER 262\n\n\n\n\n \n#line 1 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n\n \n\n \n\n \n#if defined _AIX && !defined __GNUC__\n #pragma alloca\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stddef.h>\n#include <stdlib.h>\n#include \"plural-exp.h\"\n\n \n#ifndef _LIBC\n# define __gettextparse PLURAL_PARSE\n#endif\n\n#define YYLEX_PARAM\t&((struct parse_args *) arg)->cp\n#define YYPARSE_PARAM\targ\n\n\n \n#ifndef YYDEBUG\n# define YYDEBUG 0\n#endif\n\n \n#ifdef YYERROR_VERBOSE\n# undef YYERROR_VERBOSE\n# define YYERROR_VERBOSE 1\n#else\n# define YYERROR_VERBOSE 0\n#endif\n\n#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)\n#line 51 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\ntypedef union YYSTYPE {\n  unsigned long int num;\n  enum operator op;\n  struct expression *exp;\n} YYSTYPE;\n \n#line 152 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.c\"\n# define yystype YYSTYPE  \n# define YYSTYPE_IS_DECLARED 1\n# define YYSTYPE_IS_TRIVIAL 1\n#endif\n\n\n\n \n#line 57 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n\n \nstatic struct expression *new_exp PARAMS ((int nargs, enum operator op,\n\t\t\t\t\t   struct expression * const *args));\nstatic inline struct expression *new_exp_0 PARAMS ((enum operator op));\nstatic inline struct expression *new_exp_1 PARAMS ((enum operator op,\n\t\t\t\t\t\t   struct expression *right));\nstatic struct expression *new_exp_2 PARAMS ((enum operator op,\n\t\t\t\t\t     struct expression *left,\n\t\t\t\t\t     struct expression *right));\nstatic inline struct expression *new_exp_3 PARAMS ((enum operator op,\n\t\t\t\t\t\t   struct expression *bexp,\n\t\t\t\t\t\t   struct expression *tbranch,\n\t\t\t\t\t\t   struct expression *fbranch));\nstatic int yylex PARAMS ((YYSTYPE *lval, const char **pexp));\nstatic void yyerror PARAMS ((const char *str));\n\n \n\nstatic struct expression *\nnew_exp (nargs, op, args)\n     int nargs;\n     enum operator op;\n     struct expression * const *args;\n{\n  int i;\n  struct expression *newp;\n\n   \n  for (i = nargs - 1; i >= 0; i--)\n    if (args[i] == NULL)\n      goto fail;\n\n   \n  newp = (struct expression *) malloc (sizeof (*newp));\n  if (newp != NULL)\n    {\n      newp->nargs = nargs;\n      newp->operation = op;\n      for (i = nargs - 1; i >= 0; i--)\n\tnewp->val.args[i] = args[i];\n      return newp;\n    }\n\n fail:\n  for (i = nargs - 1; i >= 0; i--)\n    FREE_EXPRESSION (args[i]);\n\n  return NULL;\n}\n\nstatic inline struct expression *\nnew_exp_0 (op)\n     enum operator op;\n{\n  return new_exp (0, op, NULL);\n}\n\nstatic inline struct expression *\nnew_exp_1 (op, right)\n     enum operator op;\n     struct expression *right;\n{\n  struct expression *args[1];\n\n  args[0] = right;\n  return new_exp (1, op, args);\n}\n\nstatic struct expression *\nnew_exp_2 (op, left, right)\n     enum operator op;\n     struct expression *left;\n     struct expression *right;\n{\n  struct expression *args[2];\n\n  args[0] = left;\n  args[1] = right;\n  return new_exp (2, op, args);\n}\n\nstatic inline struct expression *\nnew_exp_3 (op, bexp, tbranch, fbranch)\n     enum operator op;\n     struct expression *bexp;\n     struct expression *tbranch;\n     struct expression *fbranch;\n{\n  struct expression *args[3];\n\n  args[0] = bexp;\n  args[1] = tbranch;\n  args[2] = fbranch;\n  return new_exp (3, op, args);\n}\n\n\n\n \n#line 262 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.c\"\n\n#if ! defined (yyoverflow) || YYERROR_VERBOSE\n\n# ifndef YYFREE\n#  define YYFREE free\n# endif\n# ifndef YYMALLOC\n#  define YYMALLOC malloc\n# endif\n\n \n\n# ifdef YYSTACK_USE_ALLOCA\n#  if YYSTACK_USE_ALLOCA\n#   ifdef __GNUC__\n#    define YYSTACK_ALLOC __builtin_alloca\n#   else\n#    define YYSTACK_ALLOC alloca\n#   endif\n#  endif\n# endif\n\n# ifdef YYSTACK_ALLOC\n    \n#  define YYSTACK_FREE(Ptr) do {  ; } while (0)\n# else\n#  if defined (__STDC__) || defined (__cplusplus)\n#   include <stdlib.h>  \n#   define YYSIZE_T size_t\n#  endif\n#  define YYSTACK_ALLOC YYMALLOC\n#  define YYSTACK_FREE YYFREE\n# endif\n#endif  \n\n\n#if (! defined (yyoverflow) \\\n     && (! defined (__cplusplus) \\\n\t || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))\n\n \nunion yyalloc\n{\n  short int yyss;\n  YYSTYPE yyvs;\n  };\n\n \n# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)\n\n \n# define YYSTACK_BYTES(N) \\\n     ((N) * (sizeof (short int) + sizeof (YYSTYPE))\t\t\t\\\n      + YYSTACK_GAP_MAXIMUM)\n\n \n# ifndef YYCOPY\n#  if defined (__GNUC__) && 1 < __GNUC__\n#   define YYCOPY(To, From, Count) \\\n      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))\n#  else\n#   define YYCOPY(To, From, Count)\t\t\\\n      do\t\t\t\t\t\\\n\t{\t\t\t\t\t\\\n\t  register YYSIZE_T yyi;\t\t\\\n\t  for (yyi = 0; yyi < (Count); yyi++)\t\\\n\t    (To)[yyi] = (From)[yyi];\t\t\\\n\t}\t\t\t\t\t\\\n      while (0)\n#  endif\n# endif\n\n \n# define YYSTACK_RELOCATE(Stack)\t\t\t\t\t\\\n    do\t\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tYYSIZE_T yynewbytes;\t\t\t\t\t\t\\\n\tYYCOPY (&yyptr->Stack, Stack, yysize);\t\t\t\t\\\n\tStack = &yyptr->Stack;\t\t\t\t\t\t\\\n\tyynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \\\n\tyyptr += yynewbytes / sizeof (*yyptr);\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    while (0)\n\n#endif\n\n#if defined (__STDC__) || defined (__cplusplus)\n   typedef signed char yysigned_char;\n#else\n   typedef short int yysigned_char;\n#endif\n\n \n#define YYFINAL  9\n \n#define YYLAST   54\n\n \n#define YYNTOKENS  16\n \n#define YYNNTS  3\n \n#define YYNRULES  13\n \n#define YYNSTATES  27\n\n \n#define YYUNDEFTOK  2\n#define YYMAXUTOK   262\n\n#define YYTRANSLATE(YYX) \t\t\t\t\t\t\\\n  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)\n\n \nstatic const unsigned char yytranslate[] =\n{\n       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,    10,     2,     2,     2,     2,     5,     2,\n      14,    15,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,    12,     2,\n       2,     2,     2,     3,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      13,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     4,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     1,     2,     6,     7,\n       8,     9,    11\n};\n\n#if YYDEBUG\n \nstatic const unsigned char yyprhs[] =\n{\n       0,     0,     3,     5,    11,    15,    19,    23,    27,    31,\n      35,    38,    40,    42\n};\n\n \nstatic const yysigned_char yyrhs[] =\n{\n      17,     0,    -1,    18,    -1,    18,     3,    18,    12,    18,\n      -1,    18,     4,    18,    -1,    18,     5,    18,    -1,    18,\n       6,    18,    -1,    18,     7,    18,    -1,    18,     8,    18,\n      -1,    18,     9,    18,    -1,    10,    18,    -1,    13,    -1,\n      11,    -1,    14,    18,    15,    -1\n};\n\n \nstatic const unsigned char yyrline[] =\n{\n       0,   176,   176,   184,   188,   192,   196,   200,   204,   208,\n     212,   216,   220,   225\n};\n#endif\n\n#if YYDEBUG || YYERROR_VERBOSE\n \nstatic const char *const yytname[] =\n{\n  \"$end\", \"error\", \"$undefined\", \"'?'\", \"'|'\", \"'&'\", \"EQUOP2\", \"CMPOP2\",\n  \"ADDOP2\", \"MULOP2\", \"'!'\", \"NUMBER\", \"':'\", \"'n'\", \"'('\", \"')'\",\n  \"$accept\", \"start\", \"exp\", 0\n};\n#endif\n\n# ifdef YYPRINT\n \nstatic const unsigned short int yytoknum[] =\n{\n       0,   256,   257,    63,   124,    38,   258,   259,   260,   261,\n      33,   262,    58,   110,    40,    41\n};\n# endif\n\n \nstatic const unsigned char yyr1[] =\n{\n       0,    16,    17,    18,    18,    18,    18,    18,    18,    18,\n      18,    18,    18,    18\n};\n\n \nstatic const unsigned char yyr2[] =\n{\n       0,     2,     1,     5,     3,     3,     3,     3,     3,     3,\n       2,     1,     1,     3\n};\n\n \nstatic const unsigned char yydefact[] =\n{\n       0,     0,    12,    11,     0,     0,     2,    10,     0,     1,\n       0,     0,     0,     0,     0,     0,     0,    13,     0,     4,\n       5,     6,     7,     8,     9,     0,     3\n};\n\n \nstatic const yysigned_char yydefgoto[] =\n{\n      -1,     5,     6\n};\n\n \n#define YYPACT_NINF -10\nstatic const yysigned_char yypact[] =\n{\n      -9,    -9,   -10,   -10,    -9,     8,    36,   -10,    13,   -10,\n      -9,    -9,    -9,    -9,    -9,    -9,    -9,   -10,    26,    41,\n      45,    18,    -2,    14,   -10,    -9,    36\n};\n\n \nstatic const yysigned_char yypgoto[] =\n{\n     -10,   -10,    -1\n};\n\n \n#define YYTABLE_NINF -1\nstatic const unsigned char yytable[] =\n{\n       7,     1,     2,     8,     3,     4,    15,    16,     9,    18,\n      19,    20,    21,    22,    23,    24,    10,    11,    12,    13,\n      14,    15,    16,    16,    26,    14,    15,    16,    17,    10,\n      11,    12,    13,    14,    15,    16,     0,     0,    25,    10,\n      11,    12,    13,    14,    15,    16,    12,    13,    14,    15,\n      16,    13,    14,    15,    16\n};\n\nstatic const yysigned_char yycheck[] =\n{\n       1,    10,    11,     4,    13,    14,     8,     9,     0,    10,\n      11,    12,    13,    14,    15,    16,     3,     4,     5,     6,\n       7,     8,     9,     9,    25,     7,     8,     9,    15,     3,\n       4,     5,     6,     7,     8,     9,    -1,    -1,    12,     3,\n       4,     5,     6,     7,     8,     9,     5,     6,     7,     8,\n       9,     6,     7,     8,     9\n};\n\n \nstatic const unsigned char yystos[] =\n{\n       0,    10,    11,    13,    14,    17,    18,    18,    18,     0,\n       3,     4,     5,     6,     7,     8,     9,    15,    18,    18,\n      18,    18,    18,    18,    18,    12,    18\n};\n\n#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)\n# define YYSIZE_T __SIZE_TYPE__\n#endif\n#if ! defined (YYSIZE_T) && defined (size_t)\n# define YYSIZE_T size_t\n#endif\n#if ! defined (YYSIZE_T)\n# if defined (__STDC__) || defined (__cplusplus)\n#  include <stddef.h>  \n#  define YYSIZE_T size_t\n# endif\n#endif\n#if ! defined (YYSIZE_T)\n# define YYSIZE_T unsigned int\n#endif\n\n#define yyerrok\t\t(yyerrstatus = 0)\n#define yyclearin\t(yychar = YYEMPTY)\n#define YYEMPTY\t\t(-2)\n#define YYEOF\t\t0\n\n#define YYACCEPT\tgoto yyacceptlab\n#define YYABORT\t\tgoto yyabortlab\n#define YYERROR\t\tgoto yyerrorlab\n\n\n \n\n#define YYFAIL\t\tgoto yyerrlab\n\n#define YYRECOVERING()  (!!yyerrstatus)\n\n#define YYBACKUP(Token, Value)\t\t\t\t\t\\\ndo\t\t\t\t\t\t\t\t\\\n  if (yychar == YYEMPTY && yylen == 1)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n      yychar = (Token);\t\t\t\t\t\t\\\n      yylval = (Value);\t\t\t\t\t\t\\\n      yytoken = YYTRANSLATE (yychar);\t\t\t\t\\\n      YYPOPSTACK;\t\t\t\t\t\t\\\n      goto yybackup;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\\\n    { \t\t\t\t\t\t\t\t\\\n      yyerror (\"syntax error: cannot back up\");\\\n      YYERROR;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\nwhile (0)\n\n\n#define YYTERROR\t1\n#define YYERRCODE\t256\n\n\n \n\n#define YYRHSLOC(Rhs, K) ((Rhs)[K])\n#ifndef YYLLOC_DEFAULT\n# define YYLLOC_DEFAULT(Current, Rhs, N)\t\t\t\t\\\n    do\t\t\t\t\t\t\t\t\t\\\n      if (N)\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;\t\\\n\t  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;\t\\\n\t  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;\t\t\\\n\t  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  (Current).first_line   = (Current).last_line   =\t\t\\\n\t    YYRHSLOC (Rhs, 0).last_line;\t\t\t\t\\\n\t  (Current).first_column = (Current).last_column =\t\t\\\n\t    YYRHSLOC (Rhs, 0).last_column;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    while (0)\n#endif\n\n\n \n\n#ifndef YY_LOCATION_PRINT\n# if YYLTYPE_IS_TRIVIAL\n#  define YY_LOCATION_PRINT(File, Loc)\t\t\t\\\n     fprintf (File, \"%d.%d-%d.%d\",\t\t\t\\\n              (Loc).first_line, (Loc).first_column,\t\\\n              (Loc).last_line,  (Loc).last_column)\n# else\n#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)\n# endif\n#endif\n\n\n \n\n#ifdef YYLEX_PARAM\n# define YYLEX yylex (&yylval, YYLEX_PARAM)\n#else\n# define YYLEX yylex (&yylval)\n#endif\n\n \n#if YYDEBUG\n\n# ifndef YYFPRINTF\n#  include <stdio.h>  \n#  define YYFPRINTF fprintf\n# endif\n\n# define YYDPRINTF(Args)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (yydebug)\t\t\t\t\t\\\n    YYFPRINTF Args;\t\t\t\t\\\n} while (0)\n\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n  if (yydebug)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n      YYFPRINTF (stderr, \"%s \", Title);\t\t\t\t\\\n      yysymprint (stderr, \t\t\t\t\t\\\n                  Type, Value);\t\\\n      YYFPRINTF (stderr, \"\\n\");\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n\n#if defined (__STDC__) || defined (__cplusplus)\nstatic void\nyy_stack_print (short int *bottom, short int *top)\n#else\nstatic void\nyy_stack_print (bottom, top)\n    short int *bottom;\n    short int *top;\n#endif\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for ( ; bottom <= top; ++bottom)\n    YYFPRINTF (stderr, \" %d\", *bottom);\n  YYFPRINTF (stderr, \"\\n\");\n}\n\n# define YY_STACK_PRINT(Bottom, Top)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n  if (yydebug)\t\t\t\t\t\t\t\\\n    yy_stack_print ((Bottom), (Top));\t\t\t\t\\\n} while (0)\n\n\n \n\n#if defined (__STDC__) || defined (__cplusplus)\nstatic void\nyy_reduce_print (int yyrule)\n#else\nstatic void\nyy_reduce_print (yyrule)\n    int yyrule;\n#endif\n{\n  int yyi;\n  unsigned int yylno = yyrline[yyrule];\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %u), \",\n             yyrule - 1, yylno);\n   \n  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)\n    YYFPRINTF (stderr, \"%s \", yytname [yyrhs[yyi]]);\n  YYFPRINTF (stderr, \"-> %s\\n\", yytname [yyr1[yyrule]]);\n}\n\n# define YY_REDUCE_PRINT(Rule)\t\t\\\ndo {\t\t\t\t\t\\\n  if (yydebug)\t\t\t\t\\\n    yy_reduce_print (Rule);\t\t\\\n} while (0)\n\n \nint yydebug;\n#else  \n# define YYDPRINTF(Args)\n# define YY_SYMBOL_PRINT(Title, Type, Value, Location)\n# define YY_STACK_PRINT(Bottom, Top)\n# define YY_REDUCE_PRINT(Rule)\n#endif  \n\n\n \n#ifndef\tYYINITDEPTH\n# define YYINITDEPTH 200\n#endif\n\n \n\n#ifndef YYMAXDEPTH\n# define YYMAXDEPTH 10000\n#endif\n\n\f\n\n#if YYERROR_VERBOSE\n\n# ifndef yystrlen\n#  if defined (__GLIBC__) && defined (_STRING_H)\n#   define yystrlen strlen\n#  else\n \nstatic YYSIZE_T\n#   if defined (__STDC__) || defined (__cplusplus)\nyystrlen (const char *yystr)\n#   else\nyystrlen (yystr)\n     const char *yystr;\n#   endif\n{\n  register const char *yys = yystr;\n\n  while (*yys++ != '\\0')\n    continue;\n\n  return yys - yystr - 1;\n}\n#  endif\n# endif\n\n# ifndef yystpcpy\n#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)\n#   define yystpcpy stpcpy\n#  else\n \nstatic char *\n#   if defined (__STDC__) || defined (__cplusplus)\nyystpcpy (char *yydest, const char *yysrc)\n#   else\nyystpcpy (yydest, yysrc)\n     char *yydest;\n     const char *yysrc;\n#   endif\n{\n  register char *yyd = yydest;\n  register const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}\n#  endif\n# endif\n\n#endif  \n\n\f\n\n#if YYDEBUG\n \n\n#if defined (__STDC__) || defined (__cplusplus)\nstatic void\nyysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)\n#else\nstatic void\nyysymprint (yyoutput, yytype, yyvaluep)\n    FILE *yyoutput;\n    int yytype;\n    YYSTYPE *yyvaluep;\n#endif\n{\n   \n  (void) yyvaluep;\n\n  if (yytype < YYNTOKENS)\n    YYFPRINTF (yyoutput, \"token %s (\", yytname[yytype]);\n  else\n    YYFPRINTF (yyoutput, \"nterm %s (\", yytname[yytype]);\n\n\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  switch (yytype)\n    {\n      default:\n        break;\n    }\n  YYFPRINTF (yyoutput, \")\");\n}\n\n#endif  \n \n\n#if defined (__STDC__) || defined (__cplusplus)\nstatic void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n#else\nstatic void\nyydestruct (yymsg, yytype, yyvaluep)\n    const char *yymsg;\n    int yytype;\n    YYSTYPE *yyvaluep;\n#endif\n{\n   \n  (void) yyvaluep;\n\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  switch (yytype)\n    {\n\n      default:\n        break;\n    }\n}\n\f\n\n \n\n#ifdef YYPARSE_PARAM\n# if defined (__STDC__) || defined (__cplusplus)\nint yyparse (void *YYPARSE_PARAM);\n# else\nint yyparse ();\n# endif\n#else  \n#if defined (__STDC__) || defined (__cplusplus)\nint yyparse (void);\n#else\nint yyparse ();\n#endif\n#endif  \n\n\n\n\n\n\n \n\n#ifdef YYPARSE_PARAM\n# if defined (__STDC__) || defined (__cplusplus)\nint yyparse (void *YYPARSE_PARAM)\n# else\nint yyparse (YYPARSE_PARAM)\n  void *YYPARSE_PARAM;\n# endif\n#else  \n#if defined (__STDC__) || defined (__cplusplus)\nint\nyyparse (void)\n#else\nint\nyyparse ()\n\n#endif\n#endif\n{\n   \nint yychar;\n\n \nYYSTYPE yylval;\n\n \nint yynerrs;\n\n  register int yystate;\n  register int yyn;\n  int yyresult;\n   \n  int yyerrstatus;\n   \n  int yytoken = 0;\n\n   \n\n   \n  short int yyssa[YYINITDEPTH];\n  short int *yyss = yyssa;\n  register short int *yyssp;\n\n   \n  YYSTYPE yyvsa[YYINITDEPTH];\n  YYSTYPE *yyvs = yyvsa;\n  register YYSTYPE *yyvsp;\n\n\n\n#define YYPOPSTACK   (yyvsp--, yyssp--)\n\n  YYSIZE_T yystacksize = YYINITDEPTH;\n\n   \n  YYSTYPE yyval;\n\n\n   \n  int yylen;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY;\t\t \n\n   \n\n  yyssp = yyss;\n  yyvsp = yyvs;\n\n\n  yyvsp[0] = yylval;\n\n  goto yysetstate;\n\n \n yynewstate:\n   \n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n       \n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t \n\tYYSTYPE *yyvs1 = yyvs;\n\tshort int *yyss1 = yyss;\n\n\n\t \n\tyyoverflow (\"parser stack overflow\",\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n\t\t    &yyvs1, yysize * sizeof (*yyvsp),\n\n\t\t    &yystacksize);\n\n\tyyss = yyss1;\n\tyyvs = yyvs1;\n      }\n#else  \n# ifndef YYSTACK_RELOCATE\n      goto yyoverflowlab;\n# else\n       \n      if (YYMAXDEPTH <= yystacksize)\n\tgoto yyoverflowlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n\tyystacksize = YYMAXDEPTH;\n\n      {\n\tshort int *yyss1 = yyss;\n\tunion yyalloc *yyptr =\n\t  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n\tif (! yyptr)\n\t  goto yyoverflowlab;\n\tYYSTACK_RELOCATE (yyss);\n\tYYSTACK_RELOCATE (yyvs);\n\n#  undef YYSTACK_RELOCATE\n\tif (yyss1 != yyssa)\n\t  YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif  \n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n\t\t  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n\tYYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  goto yybackup;\n\n \nyybackup:\n\n \n \n \n\n   \n\n  yyn = yypact[yystate];\n  if (yyn == YYPACT_NINF)\n    goto yydefault;\n\n   \n\n   \n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = YYLEX;\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n   \n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yyn == 0 || yyn == YYTABLE_NINF)\n\tgoto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  if (yyn == YYFINAL)\n    YYACCEPT;\n\n   \n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n   \n  if (yychar != YYEOF)\n    yychar = YYEMPTY;\n\n  *++yyvsp = yylval;\n\n\n   \n  if (yyerrstatus)\n    yyerrstatus--;\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n \nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n \nyyreduce:\n   \n  yylen = yyr2[yyn];\n\n   \n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 2:\n#line 177 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    if ((yyvsp[0].exp) == NULL)\n\t      YYABORT;\n\t    ((struct parse_args *) arg)->res = (yyvsp[0].exp);\n\t  }\n    break;\n\n  case 3:\n#line 185 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_3 (qmop, (yyvsp[-4].exp), (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 4:\n#line 189 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_2 (lor, (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 5:\n#line 193 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_2 (land, (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 6:\n#line 197 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 7:\n#line 201 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 8:\n#line 205 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 9:\n#line 209 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 10:\n#line 213 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_1 (lnot, (yyvsp[0].exp));\n\t  }\n    break;\n\n  case 11:\n#line 217 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = new_exp_0 (var);\n\t  }\n    break;\n\n  case 12:\n#line 221 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    if (((yyval.exp) = new_exp_0 (num)) != NULL)\n\t      (yyval.exp)->val.num = (yyvsp[0].num);\n\t  }\n    break;\n\n  case 13:\n#line 226 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n    {\n\t    (yyval.exp) = (yyvsp[-1].exp);\n\t  }\n    break;\n\n\n    }\n\n \n#line 1270 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.c\"\n\f\n  yyvsp -= yylen;\n  yyssp -= yylen;\n\n\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n\n   \n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n \nyyerrlab:\n   \n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if YYERROR_VERBOSE\n      yyn = yypact[yystate];\n\n      if (YYPACT_NINF < yyn && yyn < YYLAST)\n\t{\n\t  YYSIZE_T yysize = 0;\n\t  int yytype = YYTRANSLATE (yychar);\n\t  const char* yyprefix;\n\t  char *yymsg;\n\t  int yyx;\n\n\t   \n\t  int yyxbegin = yyn < 0 ? -yyn : 0;\n\n\t   \n\t  int yychecklim = YYLAST - yyn;\n\t  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n\t  int yycount = 0;\n\n\t  yyprefix = \", expecting \";\n\t  for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\t    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t      {\n\t\tyysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);\n\t\tyycount += 1;\n\t\tif (yycount == 5)\n\t\t  {\n\t\t    yysize = 0;\n\t\t    break;\n\t\t  }\n\t      }\n\t  yysize += (sizeof (\"syntax error, unexpected \")\n\t\t     + yystrlen (yytname[yytype]));\n\t  yymsg = (char *) YYSTACK_ALLOC (yysize);\n\t  if (yymsg != 0)\n\t    {\n\t      char *yyp = yystpcpy (yymsg, \"syntax error, unexpected \");\n\t      yyp = yystpcpy (yyp, yytname[yytype]);\n\n\t      if (yycount < 5)\n\t\t{\n\t\t  yyprefix = \", expecting \";\n\t\t  for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n\t\t    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)\n\t\t      {\n\t\t\tyyp = yystpcpy (yyp, yyprefix);\n\t\t\tyyp = yystpcpy (yyp, yytname[yyx]);\n\t\t\tyyprefix = \" or \";\n\t\t      }\n\t\t}\n\t      yyerror (yymsg);\n\t      YYSTACK_FREE (yymsg);\n\t    }\n\t  else\n\t    yyerror (\"syntax error; also virtual memory exhausted\");\n\t}\n      else\n#endif  \n\tyyerror (\"syntax error\");\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n       \n\n      if (yychar <= YYEOF)\n        {\n           \n\t  if (yychar == YYEOF)\n\t     for (;;)\n\t       {\n\n\t\t YYPOPSTACK;\n\t\t if (yyssp == yyss)\n\t\t   YYABORT;\n\t\t yydestruct (\"Error: popping\",\n                             yystos[*yyssp], yyvsp);\n\t       }\n        }\n      else\n\t{\n\t  yydestruct (\"Error: discarding\", yytoken, &yylval);\n\t  yychar = YYEMPTY;\n\t}\n    }\n\n   \n  goto yyerrlab1;\n\n\n \nyyerrorlab:\n\n#ifdef __GNUC__\n   \n  if (0)\n     goto yyerrorlab;\n#endif\n\nyyvsp -= yylen;\n  yyssp -= yylen;\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n \nyyerrlab1:\n  yyerrstatus = 3;\t \n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (yyn != YYPACT_NINF)\n\t{\n\t  yyn += YYTERROR;\n\t  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n\t    {\n\t      yyn = yytable[yyn];\n\t      if (0 < yyn)\n\t\tbreak;\n\t    }\n\t}\n\n       \n      if (yyssp == yyss)\n\tYYABORT;\n\n\n      yydestruct (\"Error: popping\", yystos[yystate], yyvsp);\n      YYPOPSTACK;\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  if (yyn == YYFINAL)\n    YYACCEPT;\n\n  *++yyvsp = yylval;\n\n\n   \n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n \nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n \nyyabortlab:\n  yydestruct (\"Error: discarding lookahead\",\n              yytoken, &yylval);\n  yychar = YYEMPTY;\n  yyresult = 1;\n  goto yyreturn;\n\n#ifndef yyoverflow\n \nyyoverflowlab:\n  yyerror (\"parser stack overflow\");\n  yyresult = 2;\n   \n#endif\n\nyyreturn:\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n  return yyresult;\n}\n\n\n#line 231 \"/usr/src/local/bash/bash-20080814/lib/intl/plural.y\"\n\n\nvoid\ninternal_function\nFREE_EXPRESSION (exp)\n     struct expression *exp;\n{\n  if (exp == NULL)\n    return;\n\n   \n  switch (exp->nargs)\n    {\n    case 3:\n      FREE_EXPRESSION (exp->val.args[2]);\n       \n    case 2:\n      FREE_EXPRESSION (exp->val.args[1]);\n       \n    case 1:\n      FREE_EXPRESSION (exp->val.args[0]);\n       \n    default:\n      break;\n    }\n\n  free (exp);\n}\n\n\nstatic int\nyylex (lval, pexp)\n     YYSTYPE *lval;\n     const char **pexp;\n{\n  const char *exp = *pexp;\n  int result;\n\n  while (1)\n    {\n      if (exp[0] == '\\0')\n\t{\n\t  *pexp = exp;\n\t  return YYEOF;\n\t}\n\n      if (exp[0] != ' ' && exp[0] != '\\t')\n\tbreak;\n\n      ++exp;\n    }\n\n  result = *exp++;\n  switch (result)\n    {\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n      {\n\tunsigned long int n = result - '0';\n\twhile (exp[0] >= '0' && exp[0] <= '9')\n\t  {\n\t    n *= 10;\n\t    n += exp[0] - '0';\n\t    ++exp;\n\t  }\n\tlval->num = n;\n\tresult = NUMBER;\n      }\n      break;\n\n    case '=':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = equal;\n\t  result = EQUOP2;\n\t}\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '!':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = not_equal;\n\t  result = EQUOP2;\n\t}\n      break;\n\n    case '&':\n    case '|':\n      if (exp[0] == result)\n\t++exp;\n      else\n\tresult = YYERRCODE;\n      break;\n\n    case '<':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = less_or_equal;\n\t}\n      else\n\tlval->op = less_than;\n      result = CMPOP2;\n      break;\n\n    case '>':\n      if (exp[0] == '=')\n\t{\n\t  ++exp;\n\t  lval->op = greater_or_equal;\n\t}\n      else\n\tlval->op = greater_than;\n      result = CMPOP2;\n      break;\n\n    case '*':\n      lval->op = mult;\n      result = MULOP2;\n      break;\n\n    case '/':\n      lval->op = divide;\n      result = MULOP2;\n      break;\n\n    case '%':\n      lval->op = module;\n      result = MULOP2;\n      break;\n\n    case '+':\n      lval->op = plus;\n      result = ADDOP2;\n      break;\n\n    case '-':\n      lval->op = minus;\n      result = ADDOP2;\n      break;\n\n    case 'n':\n    case '?':\n    case ':':\n    case '(':\n    case ')':\n       \n      break;\n\n    case ';':\n    case '\\n':\n    case '\\0':\n       \n      --exp;\n      result = YYEOF;\n      break;\n\n    default:\n      result = YYERRCODE;\n#if YYDEBUG != 0\n      --exp;\n#endif\n      break;\n    }\n\n  *pexp = exp;\n\n  return result;\n}\n\n\nstatic void\nyyerror (str)\n     const char *str;\n{\n   \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}