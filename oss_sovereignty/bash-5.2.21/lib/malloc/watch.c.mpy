{
  "module_name": "watch.c",
  "hash_id": "109f4c02ed09d468e1825067706ba329bf6cfdf3854842664c32fb3db136cb12",
  "original_prompt": "Ingested from bash-5.2.21/lib/malloc/watch.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n#include \"imalloc.h\"\n\n#ifdef MALLOC_WATCH\n#include \"watch.h\"\n\n#define WATCH_MAX\t32\n\nint\t\t_malloc_nwatch;\nstatic PTR_T\t_malloc_watch_list[WATCH_MAX];\n\nstatic void\nwatch_warn (addr, file, line, type, data)\n     PTR_T addr;\n     const char *file;\n     int line, type;\n     unsigned long data;\n{\n  char *tag;\n\n  if (type == W_ALLOC)\n    tag = \"allocated\";\n  else if (type == W_FREE)\n    tag = \"freed\";\n  else if (type == W_REALLOC)\n    tag = \"requesting resize\";\n  else if (type == W_RESIZED)\n    tag = \"just resized\";\n  else\n    tag = \"bug: unknown operation\";\n\n  fprintf (stderr, \"malloc: watch alert: %p %s \", addr, tag);\n  if (data != (unsigned long)-1)\n    fprintf (stderr, \"(size %lu) \", data);\n  fprintf (stderr, \"from '%s:%d'\\n\", file ? file : \"unknown\", line);\n}\n\nvoid\n_malloc_ckwatch (addr, file, line, type, data)\n     PTR_T addr;\n     const char *file;\n     int line, type;\n     unsigned long data;\n{\n  register int i;\n\n  for (i = _malloc_nwatch - 1; i >= 0; i--)\n    {\n      if (_malloc_watch_list[i] == addr)\n\t{\n\t  watch_warn (addr, file, line, type, data);\n\t  return;\n\t}\n    }\n}\n#endif  \n\nPTR_T\nmalloc_watch (addr)\n     PTR_T addr;\n{\n  register int i;\n  PTR_T ret;\n\n  if (addr == 0)\n    return addr;\n  ret = (PTR_T)0;\n\n#ifdef MALLOC_WATCH\n  for (i = _malloc_nwatch - 1; i >= 0; i--)\n    {\n      if (_malloc_watch_list[i] == addr)\n        break;\n    }\n  if (i < 0)\n    {\n      if (_malloc_nwatch == WATCH_MAX)\t \n\t{\n\t  ret = _malloc_watch_list[0];\n\t  _malloc_nwatch--;\n\t  for (i = 0; i < _malloc_nwatch; i++)\n\t    _malloc_watch_list[i] = _malloc_watch_list[i+1];\n\t}\n      _malloc_watch_list[_malloc_nwatch++] = addr;\n    }\n#endif\n\n  return ret;  \n}\n\n \nPTR_T\nmalloc_unwatch (addr)\n     PTR_T addr;\n{\n#ifdef MALLOC_WATCH\n  register int i;\n\n  if (addr == 0)\n    {\n      for (i = 0; i < _malloc_nwatch; i++)\n        _malloc_watch_list[i] = (PTR_T)0;\n      _malloc_nwatch = 0;\n      return ((PTR_T)0);\n    }\n  else\n    {\n      for (i = 0; i < _malloc_nwatch; i++)\n\t{\n\t  if (_malloc_watch_list[i] == addr)\n\t    break;\n\t}\n      if (i == _malloc_nwatch)\n        return ((PTR_T)0);\t\t \n       \n      _malloc_nwatch--;\n      for ( ; i < _malloc_nwatch; i++)\n        _malloc_watch_list[i] = _malloc_watch_list[i+1];\n      return addr;\n    }\n#else\n  return ((PTR_T)0);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}