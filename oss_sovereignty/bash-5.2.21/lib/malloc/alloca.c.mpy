{
  "module_name": "alloca.c",
  "hash_id": "69c7fe11592a9dff4a5d497625023f9655e9902ea9cdf052eb7975a98023088c",
  "original_prompt": "Ingested from bash-5.2.21/lib/malloc/alloca.c",
  "human_readable_source": " \n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n \n#if !defined (__GNUC__) || __GNUC__ < 2\n\n#include <bashtypes.h>\t\t \n\n \n#ifndef alloca\n\n#ifdef emacs\n#ifdef static\n \n#ifndef STACK_DIRECTION\nyou\nlose\n-- must know STACK_DIRECTION at compile-time\n#endif  \n#endif  \n#endif  \n\n \n\n#if defined (CRAY) && defined (CRAY_STACKSEG_END)\nlong i00afunc ();\n#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))\n#else\n#define ADDRESS_FUNCTION(arg) &(arg)\n#endif  \n\n#if __STDC__\ntypedef void *pointer;\n#else\ntypedef char *pointer;\n#endif\n\n#define\tNULL\t0\n\n \n\n#ifndef emacs\n#define malloc xmalloc\nextern pointer xmalloc ();\n#endif\n\n \n\n#ifndef STACK_DIRECTION\n#define\tSTACK_DIRECTION\t0\t \n#endif\n\n#if STACK_DIRECTION != 0\n\n#define\tSTACK_DIR\tSTACK_DIRECTION\t \n\n#else  \n\nstatic int stack_dir;\t\t \n#define\tSTACK_DIR\tstack_dir\n\nstatic void\nfind_stack_direction ()\n{\n  static char *addr = NULL;\t \n  auto char dummy;\t\t \n\n  if (addr == NULL)\n    {\t\t\t\t \n      addr = ADDRESS_FUNCTION (dummy);\n\n      find_stack_direction ();\t \n    }\n  else\n    {\n       \n      if (ADDRESS_FUNCTION (dummy) > addr)\n\tstack_dir = 1;\t\t \n      else\n\tstack_dir = -1;\t\t \n    }\n}\n\n#endif  \n\n \n\n#ifndef\tALIGN_SIZE\n#define\tALIGN_SIZE\tsizeof(double)\n#endif\n\ntypedef union hdr\n{\n  char align[ALIGN_SIZE];\t \n  struct\n    {\n      union hdr *next;\t\t \n      char *deep;\t\t \n    } h;\n} header;\n\nstatic header *last_alloca_header = NULL;\t \n\n \n\npointer\nalloca (size)\n     size_t size;\n{\n  auto char probe;\t\t \n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)\t\t \n    find_stack_direction ();\n#endif\n\n   \n\n  {\n    register header *hp;\t \n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n\t  || (STACK_DIR < 0 && hp->h.deep < depth))\n\t{\n\t  register header *np = hp->h.next;\n\n\t  free ((pointer) hp);\t \n\n\t  hp = np;\t\t \n\t}\n      else\n\tbreak;\t\t\t \n\n    last_alloca_header = hp;\t \n  }\n\n  if (size == 0)\n    return NULL;\t\t \n\n   \n\n  {\n    register pointer new = malloc (sizeof (header) + size);\n     \n\n    ((header *) new)->h.next = last_alloca_header;\n    ((header *) new)->h.deep = depth;\n\n    last_alloca_header = (header *) new;\n\n     \n\n    return (pointer) ((char *) new + sizeof (header));\n  }\n}\n\n#if defined (CRAY) && defined (CRAY_STACKSEG_END)\n\n#ifdef DEBUG_I00AFUNC\n#include <stdio.h>\n#endif\n\n#ifndef CRAY_STACK\n#define CRAY_STACK\n#ifndef CRAY2\n \nstruct stack_control_header\n  {\n    long shgrow:32;\t\t \n    long shaseg:32;\t\t \n    long shhwm:32;\t\t \n    long shsize:32;\t\t \n  };\n\n \n\nstruct stack_segment_linkage\n  {\n    long ss[0200];\t\t \n    long sssize:32;\t\t \n    long ssbase:32;\t\t \n    long:32;\n    long sspseg:32;\t\t \n    long:32;\n    long sstcpt:32;\t\t \n    long sscsnm;\t\t \n    long ssusr1;\t\t \n    long ssusr2;\t\t \n    long sstpid;\t\t \n    long ssgvup;\t\t \n    long sscray[7];\t\t \n    long ssa0;\n    long ssa1;\n    long ssa2;\n    long ssa3;\n    long ssa4;\n    long ssa5;\n    long ssa6;\n    long ssa7;\n    long sss0;\n    long sss1;\n    long sss2;\n    long sss3;\n    long sss4;\n    long sss5;\n    long sss6;\n    long sss7;\n  };\n\n#else  \n \nstruct stk_stat\n  {\n    long now;\t\t\t \n    long maxc;\t\t\t \n    long high_water;\t\t \n    long overflows;\t\t \n    long hits;\t\t\t \n    long extends;\t\t \n    long stko_mallocs;\t\t \n    long underflows;\t\t \n    long stko_free;\t\t \n    long stkm_free;\t\t \n    long segments;\t\t \n    long maxs;\t\t\t \n    long pad_size;\t\t \n    long current_address;\t \n    long current_size;\t\t \n    long initial_address;\t \n    long initial_size;\t\t \n  };\n\n \n\nstruct stk_trailer\n  {\n    long this_address;\t\t \n    long this_size;\t\t \n    long unknown2;\n    long unknown3;\n    long link;\t\t\t \n    long unknown5;\n    long unknown6;\n    long unknown7;\n    long unknown8;\n    long unknown9;\n    long unknown10;\n    long unknown11;\n    long unknown12;\n    long unknown13;\n    long unknown14;\n  };\n\n#endif  \n#endif  \n\n#ifdef CRAY2\n \n\nstatic long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n   \n\n  STKSTAT (&status);\n\n   \n\n  trailer = (struct stk_trailer *) (status.current_address\n\t\t\t\t    + status.current_size\n\t\t\t\t    - 15);\n\n   \n\n  if (trailer == 0)\n    abort ();\n\n   \n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n\tabort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n\tbreak;\n    }\n\n   \n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n\tabort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n   \n\n  return (result);\n}\n\n#else  \n \n\nstatic long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n   \n\n   \n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n   \n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n   \n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#endif\n      if (pseg == 0)\n\tbreak;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n   \n\n  while (pseg != 0)\n    {\n#ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}\n\n#endif  \n#endif  \n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}