{
  "module_name": "stats.c",
  "hash_id": "2fe57b290a39099edf0f53db2e0e86f8fc43ce4f849eda9cd7f8df29a00b92fc",
  "original_prompt": "Ingested from bash-5.2.21/lib/malloc/stats.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include \"imalloc.h\"\n\n#ifdef MALLOC_STATS\n\n#include <stdio.h>\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n#include <string.h>\n\n#include \"mstats.h\"\n\nextern int malloc_free_blocks PARAMS((int));\n\nextern int malloc_mmap_threshold;\n\nextern struct _malstats _mstats;\n\nextern FILE *_imalloc_fopen PARAMS((char *, char *, char *, char *, size_t));\n\nstruct bucket_stats\nmalloc_bucket_stats (size)\n     int size;\n{\n  struct bucket_stats v;\n\n  v.nfree = 0;\n\n  if (size < 0 || size >= NBUCKETS)\n    {\n      v.blocksize = 0;\n      v.nused = v.nmal = v.nmorecore = v.nlesscore = v.nsplit = 0;\n      return v;\n    }\n\n  v.blocksize = 1 << (size + 3);\n  v.nused = _mstats.nmalloc[size];\n  v.nmal = _mstats.tmalloc[size];\n  v.nmorecore = _mstats.nmorecore[size];\n  v.nlesscore = _mstats.nlesscore[size];\n  v.nsplit = _mstats.nsplit[size];\n  v.ncoalesce = _mstats.ncoalesce[size];\n\n  v.nfree = malloc_free_blocks (size);\t \n\n  return v;\n}\n\n \nstruct _malstats\nmalloc_stats ()\n{\n  struct _malstats result;\n  struct bucket_stats v;\n  register int i;\n\n  result = _mstats;\n  result.bytesused = result.bytesfree = 0;\n  for (i = 0; i < NBUCKETS; i++)\n    {\n      v = malloc_bucket_stats (i);\n      result.bytesfree += v.nfree * v.blocksize;\n      result.bytesused += v.nused * v.blocksize;\n    }\n  return (result);\n}\n\nstatic void\n_print_malloc_stats (s, fp)\n     char *s;\n     FILE *fp;\n{\n  register int i;\n  unsigned long totused, totfree;\n  struct bucket_stats v;\n\n  fprintf (fp, \"Memory allocation statistics: %s\\n    size\\tfree\\tin use\\ttotal\\tmorecore lesscore split\\tcoalesce\\n\", s ? s : \"\");\n  for (i = totused = totfree = 0; i < NBUCKETS; i++)\n    {\n      v = malloc_bucket_stats (i);\n       \n      if (i == malloc_mmap_threshold+1)\n\tfprintf (fp, \"--------\\n\");\n      if (v.nmal > 0)\n\tfprintf (fp, \"%8lu\\t%4d\\t%6d\\t%5d%8d\\t%8d %5d %8d\\n\", (unsigned long)v.blocksize, v.nfree, v.nused, v.nmal, v.nmorecore, v.nlesscore, v.nsplit, v.ncoalesce);\n      totfree += v.nfree * v.blocksize;\n      totused += v.nused * v.blocksize;\n    }\n  fprintf (fp, \"\\nTotal bytes in use: %lu, total bytes free: %lu\\n\",\n\t   totused, totfree);\n  fprintf (fp, \"\\nTotal bytes requested by application: %lu\\n\", (unsigned long)_mstats.bytesreq);\n  fprintf (fp, \"Total mallocs: %d, total frees: %d, total reallocs: %d (%d copies)\\n\",\n\t   _mstats.nmal, _mstats.nfre, _mstats.nrealloc, _mstats.nrcopy);\n  fprintf (fp, \"Total sbrks: %d, total bytes via sbrk: %d\\n\",\n  \t   _mstats.nsbrk, _mstats.tsbrk);\n  fprintf (fp, \"Total mmaps: %d, total bytes via mmap: %d\\n\",\n  \t   _mstats.nmmap, _mstats.tmmap);\n  fprintf (fp, \"Total blocks split: %d, total block coalesces: %d\\n\",\n  \t   _mstats.tbsplit, _mstats.tbcoalesce);\n}\n\nvoid\nprint_malloc_stats (s)\n     char *s;\n{\n  _print_malloc_stats (s, stderr);\n}\n\nvoid\nfprint_malloc_stats (s, fp)\n     char *s;\n     FILE *fp;\n{\n  _print_malloc_stats (s, fp);\n}\n\n#define TRACEROOT \"/var/tmp/maltrace/stats.\"\n\nvoid\ntrace_malloc_stats (s, fn)\n     char *s, *fn;\n{\n  FILE *fp;\n  char defname[sizeof (TRACEROOT) + 64];\n  static char mallbuf[1024];\n\n  fp = _imalloc_fopen (s, fn, TRACEROOT, defname, sizeof (defname));\n  if (fp)\n    {\n      setvbuf (fp, mallbuf, _IOFBF, sizeof (mallbuf));\n      _print_malloc_stats (s, fp);\n      fflush(fp);\n      fclose(fp);\n    }\n}\n\n#endif  \n\n#if defined (MALLOC_STATS) || defined (MALLOC_TRACE)\nFILE *\n_imalloc_fopen (s, fn, def, defbuf, defsiz)\n     char *s;\n     char *fn;\n     char *def;\n     char *defbuf;\n     size_t defsiz;\n{\n  char fname[1024];\n  long l;\n  FILE *fp;\n\n  l = (long)getpid ();\n  if (fn == 0)\n    {\n      sprintf (defbuf, \"%s%ld\", def, l);\n      fp = fopen(defbuf, \"w\");\n    }\n  else\n    {\n      char *p, *q, *r;\n      char pidbuf[32];\n      int sp;\n\n      sprintf (pidbuf, \"%ld\", l);\n      if ((strlen (pidbuf) + strlen (fn) + 2) >= sizeof (fname))\n\treturn ((FILE *)0);\n      for (sp = 0, p = fname, q = fn; *q; )\n\t{\n\t  if (sp == 0 && *q == '%' && q[1] == 'p')\n\t    {\n\t      sp = 1;\n\t      for (r = pidbuf; *r; )\n\t\t*p++ = *r++;\n\t      q += 2;\n\t    }\n\t  else\n\t    *p++ = *q++;\n\t}\n      *p = '\\0';\n      fp = fopen (fname, \"w\");\n    }\n\n  return fp;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}