{
  "module_name": "table.c",
  "hash_id": "c616a3d9b510fadf2bddfc97501236ea11cee15f48d3c9c943def5d4bc97c7af",
  "original_prompt": "Ingested from bash-5.2.21/lib/malloc/table.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"imalloc.h\"\n#include \"table.h\"\n\n#ifdef SHELL\nextern int running_trap;\nextern int signal_is_trapped PARAMS((int));\n#endif\n\nextern int malloc_register;\n\n#ifdef MALLOC_REGISTER\n\nextern FILE *_imalloc_fopen PARAMS((char *, char *, char *, char *, size_t));\n\n#define FIND_ALLOC\t0x01\t \n#define FIND_EXIST\t0x02\t \n\nstatic int table_count = 0;\nstatic int table_allocated = 0;\nstatic int table_bucket_index = REG_TABLE_SIZE-1;\nstatic mr_table_t mem_table[REG_TABLE_SIZE];\nstatic mr_table_t mem_overflow;\n\n#ifndef STREQ\n#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)\n#endif\n\nstatic int location_table_index = 0;\nstatic int location_table_count = 0;\nstatic ma_table_t mlocation_table[REG_TABLE_SIZE];\n\n \nstatic unsigned int\nmt_hash (key)\n     const PTR_T key;\n{\n  unsigned int a, b, c;\n  unsigned long x;\n\n   \n  a = 0x9e3779b9;\t \n  x = (unsigned long)key;\t\t \n  b = x >> 8;\n  c = x >> 3;\t\t\t\t \n\n  HASH_MIX(a, b, c);\n  return c;\n}\n\n#if 0\nstatic unsigned int\nwhich_bucket (mem)\n     PTR_T mem;\n{\n  return (mt_hash ((unsigned char *)mem) & (REG_TABLE_SIZE-1));\n}\n\n#else\n#define which_bucket(mem) (mt_hash ((unsigned char *)(mem)) & (REG_TABLE_SIZE-1));\n\n#define next_bucket()\t((table_bucket_index + 1) & (REG_TABLE_SIZE-1))\n#define next_entry(mem)\t((mem == mem_table + REG_TABLE_SIZE - 1) ? mem_table : ++mem)\n\n#define prev_bucket()\t(table_bucket_index == 0 ? REG_TABLE_SIZE-1 : table_bucket_index-1)\n#define prev_entry(mem)\t((mem == mem_table) ? mem_table + REG_TABLE_SIZE - 1 : mem - 1)\n#endif\n\nstatic mr_table_t *\nfind_entry (mem, flags)\n     PTR_T mem;\n     int flags;\n{\n  unsigned int bucket;\n  register mr_table_t *tp;\n  mr_table_t *endp;\n\n  if (mem_overflow.mem == mem)\n    return (&mem_overflow);\n\n   \n  if (flags & FIND_ALLOC)\n    {\n      table_bucket_index = next_bucket();\n      table_count++;\n      tp = mem_table + table_bucket_index;\n      memset(tp, 0, sizeof (mr_table_t));\t \n      return tp;\n    }\n    \n  tp = endp = mem_table + table_bucket_index;\n\n   \n  while (1)\n    {\n      if (tp->mem == mem)\n\treturn (tp);\n\n      tp = prev_entry (tp);\n\n       \n      if (tp == endp)\n        return ((mr_table_t *)NULL);\n    }\n\n  return (mr_table_t *)NULL;\n}\n\nmr_table_t *\nmr_table_entry (mem)\n     PTR_T mem;\n{\n  return (find_entry (mem, FIND_EXIST));\n}\n\nvoid\nmregister_describe_mem (mem, fp)\n     PTR_T mem;\n     FILE *fp;\n{\n  mr_table_t *entry;\n\n  entry = find_entry (mem, FIND_EXIST);\n  if (entry == 0)\n    return;\n  fprintf (fp, \"malloc: %p: %s: last %s from %s:%d\\n\",\n  \t\tmem,\n\t\t(entry->flags & MT_ALLOC) ? \"allocated\" : \"free\",\n\t\t(entry->flags & MT_ALLOC) ? \"allocated\" : \"freed\",\n\t\tentry->file ? entry->file : \"unknown\",\n\t\tentry->line);\n}\n\nvoid\nmregister_alloc (tag, mem, size, file, line)\n     const char *tag;\n     PTR_T mem;\n     size_t size;\n     const char *file;\n     int line;\n{\n  mr_table_t *tentry;\n  sigset_t set, oset;\n  int blocked_sigs;\n\n   \n  blocked_sigs = 0;\n#ifdef SHELL\n  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))\n#endif\n    {\n      _malloc_block_signals (&set, &oset);\n      blocked_sigs = 1;\n    }\n\n  mlocation_register_alloc (file, line);\n\n  tentry = find_entry (mem, FIND_ALLOC);\n\n  if (tentry == 0)\n    {\n       \n      fprintf (stderr, _(\"register_alloc: alloc table is full with FIND_ALLOC?\\n\"));\n      if (blocked_sigs)\n\t_malloc_unblock_signals (&set, &oset);\n      return;\n    }\n  \n  if (tentry->flags & MT_ALLOC)\n    {\n       \n      fprintf (stderr, _(\"register_alloc: %p already in table as allocated?\\n\"), mem);\n    }\n\n  tentry->mem = mem;\n  tentry->size = size;\n  tentry->func = tag;\n  tentry->flags = MT_ALLOC;\n  tentry->file = file;\n  tentry->line = line;\n  tentry->nalloc++;\n\n  if (tentry != &mem_overflow)\n    table_allocated++;\n\n  if (blocked_sigs)\n    _malloc_unblock_signals (&set, &oset);\n}\n\nvoid\nmregister_free (mem, size, file, line)\n     PTR_T mem;\n     int size;\n     const char *file;\n     int line;\n{\n  mr_table_t *tentry;\n  sigset_t set, oset;\n  int blocked_sigs;\n\n   \n  blocked_sigs = 0;\n#ifdef SHELL\n  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))\n#endif\n    {\n      _malloc_block_signals (&set, &oset);\n      blocked_sigs = 1;\n    }\n\n  tentry = find_entry (mem, FIND_EXIST);\n  if (tentry == 0)\n    {\n       \n#if 0\n      fprintf (stderr, \"register_free: %p not in allocation table?\\n\", mem);\n#endif\n      if (blocked_sigs)\n\t_malloc_unblock_signals (&set, &oset);\n      return;\n    }\n  if (tentry->flags & MT_FREE)\n    {\n       \n      fprintf (stderr, _(\"register_free: %p already in table as free?\\n\"), mem);\n    }\n    \t\n  tentry->flags = MT_FREE;\n  tentry->func = \"free\";\n  tentry->file = file;\n  tentry->line = line;\n  tentry->nfree++;\n\n  if (tentry != &mem_overflow)\n    table_allocated--;\n\n  if (blocked_sigs)\n    _malloc_unblock_signals (&set, &oset);\n}\n\n \nstatic char *\n_entry_flags(x)\n     int x;\n{\n  if (x & MT_FREE)\n    return \"free\";\n  else if (x & MT_ALLOC)\n    return \"allocated\";\n  else\n    return \"undetermined?\";\n}\n\nstatic void\n_register_dump_table(fp)\n     FILE *fp;\n{\n  register int i;\n  mr_table_t entry;\n\n  for (i = 0; i < REG_TABLE_SIZE; i++)\n    {\n      entry = mem_table[i];\n      if (entry.mem)\n\tfprintf (fp, \"%s[%d] %p:%zu:%s:%s:%s:%d:%d:%d\\n\",\n\t\t\t\t\t\t(i == table_bucket_index) ? \"*\" : \"\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tentry.mem, entry.size,\n\t\t\t\t\t\t_entry_flags(entry.flags),\n\t\t\t\t\t\tentry.func ? entry.func : \"unknown\",\n\t\t\t\t\t\tentry.file ? entry.file : \"unknown\",\n\t\t\t\t\t\tentry.line,\n\t\t\t\t\t\tentry.nalloc, entry.nfree);\n    }\n}\n \nvoid\nmregister_dump_table()\n{\n  _register_dump_table (stderr);\n}\n\nvoid\nmregister_table_init ()\n{\n  memset (mem_table, 0, sizeof(mr_table_t) * REG_TABLE_SIZE);\n  memset (&mem_overflow, 0, sizeof (mr_table_t));\n  table_count = 0;\n}\n\n \n\nstatic ma_table_t *\nfind_location_entry (file, line)\n     const char *file;\n     int line;\n{\n  register ma_table_t *tp, *endp;\n\n  endp = mlocation_table + location_table_count;\n  for (tp = mlocation_table; tp <= endp; tp++)\n    {\n      if (tp->line == line && STREQ (file, tp->file))\n        return tp;\n    }\n  return (ma_table_t *)NULL;\n}\n\nvoid\nmlocation_register_alloc (file, line)\n     const char *file;\n     int line;\n{\n  ma_table_t *lentry;\n  const char *nfile;\n\n  if (file == 0)\n    {\n      mlocation_table[0].nalloc++;\n      return;\n    }\n\n  nfile = strrchr (file, '/');\n  if (nfile)\n    nfile++;\n  else\n    nfile = file;\n\n  lentry = find_location_entry (nfile, line);\n  if (lentry == 0)\n    {\n      location_table_index++;\n      if (location_table_index == REG_TABLE_SIZE)\n        location_table_index = 1;\t \n      lentry = mlocation_table + location_table_index;\n      lentry->file = nfile;\n      lentry->line = line;\n      lentry->nalloc = 1;\n      if (location_table_count < REG_TABLE_SIZE)\n\tlocation_table_count++;\t\t \n    }\n  else\n    lentry->nalloc++;\n}\n\nstatic void\n_location_dump_table (fp)\n     FILE *fp;\n{\n  register ma_table_t *tp, *endp;\n\n  endp = mlocation_table + location_table_count;\n  for (tp = mlocation_table; tp < endp; tp++)\n    fprintf (fp, \"%s:%d\\t%d\\n\", tp->file ? tp->file : \"unknown\",\n\t\t\t\ttp->line ? tp->line : 0,\n\t\t\t\ttp->nalloc);\n}\n\nvoid\nmlocation_dump_table ()\n{\n  _location_dump_table (stderr);\n}\n\n#define LOCROOT \"/var/tmp/maltrace/locations.\"\n\nvoid\nmlocation_write_table ()\n{\n  FILE *fp;\n  char defname[sizeof (LOCROOT) + 64];\n\n  fp = _imalloc_fopen ((char *)NULL, (char *)NULL, LOCROOT, defname, sizeof (defname));\n  if (fp == 0)\n    return;\t\t \n  _location_dump_table (fp);\n  fclose (fp);\n}\n\nvoid\nmlocation_table_init ()\n{\n  memset (mlocation_table, 0, sizeof (ma_table_t) * REG_TABLE_SIZE);\n  mlocation_table[0].file = \"\";\t\t \n  mlocation_table[0].line = 0;\n  mlocation_table[0].nalloc = 0;\n  location_table_count = 1;\n}\n\n#endif  \n\nint\nmalloc_set_register(n)\n     int n;\n{\n  int old;\n\n  old = malloc_register;\n  malloc_register = n;\n  return old;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}