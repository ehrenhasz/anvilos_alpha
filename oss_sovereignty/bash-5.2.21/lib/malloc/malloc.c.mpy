{
  "module_name": "malloc.c",
  "hash_id": "d38524681270a32f31d8ef0290e18a693405034588a171800b6d6ff0d164ed08",
  "original_prompt": "Ingested from bash-5.2.21/lib/malloc/malloc.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n \n\n \n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif  \n\n#if defined (SHELL)\n#  include \"bashtypes.h\"\n#  include \"stdc.h\"\n#else\n#  include <sys/types.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n \n#include <signal.h>\n\n#if defined (HAVE_STRING_H)\n#  include <string.h>\n#else\n#  include <strings.h>\n#endif\n#include <errno.h>\n#include <stdio.h>\n\n#if !defined (botch)\n#include <stdlib.h>\n#endif\n\n#if defined (HAVE_MMAP)\n#include <sys/mman.h>\n#endif\n\n \n#ifndef HAVE_GETPAGESIZE\n#  include \"getpagesize.h\"\n#endif\n\n#include \"imalloc.h\"\n#ifdef MALLOC_STATS\n#  include \"mstats.h\"\n#endif\n#ifdef MALLOC_REGISTER\n#  include \"table.h\"\n#endif\n#ifdef MALLOC_WATCH\n#  include \"watch.h\"\n#endif\n\n#ifdef powerof2\n#  undef powerof2\n#endif\n \n#define powerof2(x)\t((((x) - 1) & (x)) == 0)\n\n \n#ifdef HPUX\n#  define NO_VALLOC\n#endif\n\n#define MALLOC_PAGESIZE_MIN\t4096\n#define MALLOC_INCR_PAGES\t8192\n\n#define ISALLOC ((char) 0xf7)\t \n#define ISFREE ((char) 0x54)\t \n\t\t\t\t \n#define ISMEMALIGN ((char) 0xd6)   \n\n\n \nunion mhead {\n  bits64_t mh_align[2];\t\t\t\t\t\t \n  struct {\n    char mi_alloc; \t\t \t\t \n    char mi_index;\t\t \t\t \n     \n    u_bits16_t mi_magic2;\t \t \n    u_bits32_t mi_nbytes;\t \t \n    char mi_magic8[8];\t\t \t \n  } minfo;\n};\n#define mh_alloc\tminfo.mi_alloc\n#define mh_index\tminfo.mi_index\n#define mh_nbytes\tminfo.mi_nbytes\n#define mh_magic2\tminfo.mi_magic2\n#define mh_magic8\tminfo.mi_magic8\n\n#define MAGIC8_NUMBYTES\t8\n#define MALLOC_SIZE_T\t\tu_bits32_t\n\n#define MOVERHEAD\tsizeof(union mhead)\n\n#define MALIGN_MASK\t15\t\t \n\n \ntypedef union _malloc_guard {\n  char s[4];\n  u_bits32_t i;\n} mguard_t;\n\n \n \n\n \n#define CHAIN(a) \\\n  (*(union mhead **) (sizeof (char *) + (char *) (a)))\n\n \n\n \n#define MAGIC1 0x55\n#define MAGIC2 0x5555\n\n#define MSLOP  4\t\t \n\n \n#define ALLOCATED_BYTES(n) \\\n\t(((n) + MOVERHEAD + MSLOP + MALIGN_MASK) & ~MALIGN_MASK)\n\n#define ASSERT(p) \\\n  do \\\n    { \\\n      if (!(p)) xbotch((PTR_T)0, ERR_ASSERT_FAILED, CPP_STRING(p), file, line); \\\n    } \\\n  while (0)\n\n \n#define SPLIT_MIN\t1\t\t \n#define SPLIT_MID\t9\t\t \n#define SPLIT_MAX\t12\t\t \n\n \n#define COMBINE_MIN\t1\t\t \n#define COMBINE_MAX\t(pagebucket - 1)\t \n\n#define LESSCORE_MIN\t8\t\t \n#define LESSCORE_FRC\t11\t\t \n\n \n#define PREPOP_BIN\t1\n#define PREPOP_SIZE\t64\n\n#define STARTBUCK\t0\n\n \n#if defined (HAVE_MMAP)\n#  if defined (MAP_ANON) && !defined (MAP_ANONYMOUS)\n#    define MAP_ANONYMOUS MAP_ANON\n#  endif\n#endif\n\n#if defined (HAVE_MMAP) && defined (MAP_ANONYMOUS)\n#  define USE_MMAP\t1\n#endif\n\n#if defined (USE_MMAP)\n#  define MMAP_THRESHOLD\t12\t \n#else\n#  define MMAP_THRESHOLD\t(8 * SIZEOF_LONG)\n#endif\n\n \n#if USE_MMAP == 1 && defined (HAVE_MREMAP) && defined (MREMAP_MAYMOVE)\n#  define USE_MREMAP 1\n#endif\n\n \n\n#define NBUCKETS\t28\n\n \n#define MALLOC_WRAPPER\t0x01\t \n#define MALLOC_INTERNAL\t0x02\t \n#define MALLOC_NOTRACE\t0x04\t \n#define MALLOC_NOREG\t0x08\t \n\n \n#define ERR_DUPFREE\t\t0x01\n#define ERR_UNALLOC\t\t0x02\n#define ERR_UNDERFLOW\t\t0x04\t\n#define ERR_ASSERT_FAILED\t0x08\n\n \n#define IN_BUCKET(nb, nu)\t((nb) <= binsizes[(nu)])\n\n \n#define RIGHT_BUCKET(nb, nu) \\\n\t(((nb) > binsizes[(nu)-1]) && ((nb) <= binsizes[(nu)]))\n\n \n\nstatic union mhead *nextf[NBUCKETS];\n\n \n\nstatic char busy[NBUCKETS];\n\nstatic int pagesz;\t \nstatic int pagebucket;\t \nstatic int maxbuck;\t \n\nstatic char *memtop;\t \n\nstatic const unsigned long binsizes[NBUCKETS] = {\n\t32UL, 64UL, 128UL, 256UL, 512UL, 1024UL, 2048UL, 4096UL,\n\t8192UL, 16384UL, 32768UL, 65536UL, 131072UL, 262144UL, 524288UL,\n\t1048576UL, 2097152UL, 4194304UL, 8388608UL, 16777216UL, 33554432UL,\n\t67108864UL, 134217728UL, 268435456UL, 536870912UL, 1073741824UL,\n\t2147483648UL, 4294967295UL\n};\n\n \n#define binsize(x)\tbinsizes[(x)]\n\n#define MAXALLOC_SIZE\tbinsizes[NBUCKETS-1]\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n \nstatic PTR_T internal_malloc PARAMS((size_t, const char *, int, int));\nstatic PTR_T internal_realloc PARAMS((PTR_T, size_t, const char *, int, int));\nstatic void internal_free PARAMS((PTR_T, const char *, int, int));\nstatic PTR_T internal_memalign PARAMS((size_t, size_t, const char *, int, int));\n#ifndef NO_CALLOC\nstatic PTR_T internal_calloc PARAMS((size_t, size_t, const char *, int, int));\nstatic void internal_cfree PARAMS((PTR_T, const char *, int, int));\n#endif\n#ifndef NO_VALLOC\nstatic PTR_T internal_valloc PARAMS((size_t, const char *, int, int));\n#endif\nstatic PTR_T internal_remap PARAMS((PTR_T, size_t, int, int));\n\n#if defined (botch)\nextern void botch ();\n#else\nstatic void botch PARAMS((const char *, const char *, int));\n#endif\nstatic void xbotch PARAMS((PTR_T, int, const char *, const char *, int));\n\n#if !HAVE_DECL_SBRK\nextern char *sbrk ();\n#endif  \n\n#ifdef SHELL\nextern int running_trap;\nextern int signal_is_trapped PARAMS((int));\n#endif\n\n#ifdef MALLOC_STATS\nstruct _malstats _mstats;\n#endif  \n\n \nint malloc_flags = 0;\t \nint malloc_trace = 0;\t \nint malloc_register = 0;\t \n\n \nint malloc_mmap_threshold = MMAP_THRESHOLD;\n\n#ifdef MALLOC_TRACE\nchar _malloc_trace_buckets[NBUCKETS];\n\n \nextern void mtrace_alloc PARAMS((const char *, PTR_T, size_t, const char *, int));\nextern void mtrace_free PARAMS((PTR_T, int, const char *, int));\n#endif\n\n#if !defined (botch)\nstatic void\nbotch (s, file, line)\n     const char *s;\n     const char *file;\n     int line;\n{\n  fprintf (stderr, _(\"malloc: failed assertion: %s\\n\"), s);\n  (void)fflush (stderr);\n  abort ();\n}\n#endif\n\n \nstatic void\nxbotch (mem, e, s, file, line)\n     PTR_T mem;\n     int e;\n     const char *s;\n     const char *file;\n     int line;\n{\n  fprintf (stderr, _(\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\"),\n\t\t\tfile ? file : _(\"unknown\"), line);\n#ifdef MALLOC_REGISTER\n  if (mem != NULL && malloc_register)\n    mregister_describe_mem (mem, stderr);\n#endif\n  (void)fflush (stderr);\n  botch(s, file, line);\n}\n\n \nstatic void\nbcoalesce (nu)\n     register int nu;\n{\n  register union mhead *mp, *mp1, *mp2;\n  register int nbuck;\n  unsigned long siz;\n\n  nbuck = nu - 1;\n  if (nextf[nbuck] == 0 || busy[nbuck])\n    return;\n\n  busy[nbuck] = 1;\n  siz = binsize (nbuck);\n\n  mp2 = mp1 = nextf[nbuck];\n  mp = CHAIN (mp1);\n  while (mp && mp != (union mhead *)((char *)mp1 + siz))\n    {\n      mp2 = mp1;\n      mp1 = mp;\n      mp = CHAIN (mp);\n    }\n\n  if (mp == 0)\n    {\n      busy[nbuck] = 0;\n      return;\n    }\n\n   \n  if (mp2 != mp1 && CHAIN(mp2) != mp1)\n    {\n      busy[nbuck] = 0;\n      xbotch ((PTR_T)0, 0, \"bcoalesce: CHAIN(mp2) != mp1\", (char *)NULL, 0);\n    }\n\n#ifdef MALLOC_DEBUG\n  if (CHAIN (mp1) != (union mhead *)((char *)mp1 + siz))\n    {\n      busy[nbuck] = 0;\n      return;\t \n    }\n#endif\n\n   \n  if (mp1 == nextf[nbuck])\n    nextf[nbuck] = CHAIN (mp);\n  else\n    CHAIN (mp2) = CHAIN (mp);\n  busy[nbuck] = 0;\n\n#ifdef MALLOC_STATS\n  _mstats.tbcoalesce++;\n  _mstats.ncoalesce[nbuck]++;\n#endif\n\n   \n  mp1->mh_alloc = ISFREE;\n  mp1->mh_index = nu;\n  CHAIN (mp1) = nextf[nu];\n  nextf[nu] = mp1;\n}\n\n \nstatic void\nbsplit (nu)\n     register int nu;\n{\n  register union mhead *mp;\n  int nbuck, nblks, split_max;\n  unsigned long siz;\n\n  split_max = (maxbuck > SPLIT_MAX) ? maxbuck : SPLIT_MAX;\n\n  if (nu >= SPLIT_MID)\n    {\n      for (nbuck = split_max; nbuck > nu; nbuck--)\n\t{\n\t  if (busy[nbuck] || nextf[nbuck] == 0)\n\t    continue;\n\t  break;\n\t}\n    }\n  else\n    {\n      for (nbuck = nu + 1; nbuck <= split_max; nbuck++)\n\t{\n\t  if (busy[nbuck] || nextf[nbuck] == 0)\n\t    continue;\n\t  break;\n\t}\n    }\n\n  if (nbuck > split_max || nbuck <= nu)\n    return;\n\n   \n\n   \n  busy[nbuck] = 1;\n  mp = nextf[nbuck];\n  nextf[nbuck] = CHAIN (mp);\n  busy[nbuck] = 0;\n\n#ifdef MALLOC_STATS\n  _mstats.tbsplit++;\n  _mstats.nsplit[nbuck]++;\n#endif\n\n   \n  siz = binsize (nu);\n  nblks = binsize (nbuck) / siz;\n\n   \n  nextf[nu] = mp;\n  while (1)\n    {\n      mp->mh_alloc = ISFREE;\n      mp->mh_index = nu;\n      if (--nblks <= 0) break;\n      CHAIN (mp) = (union mhead *)((char *)mp + siz);\n      mp = (union mhead *)((char *)mp + siz);\n    }\n  CHAIN (mp) = 0;\n}\n\n \nstatic void\nxsplit (mp, nu)\n     union mhead *mp;\n     int nu;\n{\n  union mhead *nh;\n  int nbuck, nblks, split_max;\n  unsigned long siz;\n\n  nbuck = nu - 1;\n  while (nbuck >= SPLIT_MIN && busy[nbuck])\n    nbuck--;\n  if (nbuck < SPLIT_MIN)\n    return;\n\n#ifdef MALLOC_STATS\n  _mstats.tbsplit++;\n  _mstats.nsplit[nu]++;\n#endif\n\n   \n  siz = binsize (nu);\t\t\t \n  nblks = siz / binsize (nbuck);\t \n\n   \n  siz = binsize (nbuck);\t\t \n  nh = mp;\n  while (1)\n    {\n      mp->mh_alloc = ISFREE;\n      mp->mh_index = nbuck;\n      if (--nblks <= 0) break;\n      CHAIN (mp) = (union mhead *)((char *)mp + siz);\n      mp = (union mhead *)((char *)mp + siz);\n    }\n  busy[nbuck] = 1;\n  CHAIN (mp) = nextf[nbuck];\n  nextf[nbuck] = nh;\n  busy[nbuck] = 0;\n}\n\nvoid\n_malloc_block_signals (setp, osetp)\n     sigset_t *setp, *osetp;\n{\n#ifdef HAVE_POSIX_SIGNALS\n  sigfillset (setp);\n  sigemptyset (osetp);\n  sigprocmask (SIG_BLOCK, setp, osetp);\n#else\n#  if defined (HAVE_BSD_SIGNALS)\n  *osetp = sigsetmask (-1);\n#  endif\n#endif\n}\n\nvoid\n_malloc_unblock_signals (setp, osetp)\n     sigset_t *setp, *osetp;\n{\n#ifdef HAVE_POSIX_SIGNALS\n  sigprocmask (SIG_SETMASK, osetp, (sigset_t *)NULL);\n#else\n#  if defined (HAVE_BSD_SIGNALS)\n  sigsetmask (*osetp);\n#  endif\n#endif\n}\n\n#if defined (USE_LESSCORE)\n   \nstatic void\nlesscore (nu)\t\t\t \n     register int nu;\t\t \n{\n  long siz;\n\n  siz = binsize (nu);\n   \n  sbrk (-siz);\n  memtop -= siz;\n\n#ifdef MALLOC_STATS\n  _mstats.nsbrk++;\n  _mstats.tsbrk -= siz;\n  _mstats.nlesscore[nu]++;\n#endif\n}\n#endif  \n\n   \nstatic void\nmorecore (nu)\n     register int nu;\t\t \n{\n  register union mhead *mp;\n  register int nblks;\n  register long siz;\n  long sbrk_amt;\t\t \n  sigset_t set, oset;\n  int blocked_sigs;\n\n   \n  blocked_sigs = 0;\n#ifdef SHELL\n#  if defined (SIGCHLD)\n  if (running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))\n#  else\n  if (running_trap || signal_is_trapped (SIGINT))\n#  endif\n#endif\n    {\n      _malloc_block_signals (&set, &oset);\n      blocked_sigs = 1;\n    }\n\n  siz = binsize (nu);\t \n\n  if (siz < 0)\n    goto morecore_done;\t\t \n\n#ifdef MALLOC_STATS\n  _mstats.nmorecore[nu]++;\n#endif\n\n   \n  if (nu >= SPLIT_MIN && nu <= malloc_mmap_threshold)\n    {\n      bsplit (nu);\n      if (nextf[nu] != 0)\n\tgoto morecore_done;\n    }\n\n   \n  if (nu >= COMBINE_MIN && nu < COMBINE_MAX && nu <= malloc_mmap_threshold && busy[nu - 1] == 0 && nextf[nu - 1])\n    {\n      bcoalesce (nu);\n      if (nextf[nu] != 0)\n\tgoto morecore_done;\n    }\n\n   \n  if (siz <= pagesz)\n    {\n      sbrk_amt = pagesz;\n      nblks = sbrk_amt / siz;\n    }\n  else\n    {\n       \n      sbrk_amt = siz & (pagesz - 1);\n      if (sbrk_amt == 0)\n\tsbrk_amt = siz;\n      else\n\tsbrk_amt = siz + pagesz - sbrk_amt;\n      nblks = 1;\n    }\n\n#if defined (USE_MMAP)\n  if (nu > malloc_mmap_threshold)\n    {\n      mp = (union mhead *)mmap (0, sbrk_amt, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n      if ((void *)mp == MAP_FAILED)\n\tgoto morecore_done;\n      nextf[nu] = mp;\n      mp->mh_alloc = ISFREE;\n      mp->mh_index = nu;\n      CHAIN (mp) = 0;\n#ifdef MALLOC_STATS\n      _mstats.nmmap++;\n      _mstats.tmmap += sbrk_amt;\n#endif\n      goto morecore_done;\n    }\n#endif\n\t\n\n#ifdef MALLOC_STATS\n  _mstats.nsbrk++;\n  _mstats.tsbrk += sbrk_amt;\n#endif\n\n  mp = (union mhead *) sbrk (sbrk_amt);\n\n   \n  if ((long)mp == -1)\n    goto morecore_done;\n\n  memtop += sbrk_amt;\n\n   \n  if ((long)mp & MALIGN_MASK)\n    {\n      mp = (union mhead *) (((long)mp + MALIGN_MASK) & ~MALIGN_MASK);\n      nblks--;\n    }\n\n   \n  nextf[nu] = mp;\n  while (1)\n    {\n      mp->mh_alloc = ISFREE;\n      mp->mh_index = nu;\n      if (--nblks <= 0) break;\n      CHAIN (mp) = (union mhead *)((char *)mp + siz);\n      mp = (union mhead *)((char *)mp + siz);\n    }\n  CHAIN (mp) = 0;\n\nmorecore_done:\n  if (blocked_sigs)\n    _malloc_unblock_signals (&set, &oset);\n}\n\nstatic void\nmalloc_debug_dummy ()\n{\n  write (1, \"malloc_debug_dummy\\n\", 19);\n}\n\nstatic int\npagealign ()\n{\n  register int nunits;\n  register union mhead *mp;\n  long sbrk_needed;\n  char *curbrk;\n\n  pagesz = getpagesize ();\n  if (pagesz < MALLOC_PAGESIZE_MIN)\n    pagesz = MALLOC_PAGESIZE_MIN;\n\n   \n  memtop = curbrk = sbrk (0);\n  sbrk_needed = pagesz - ((long)curbrk & (pagesz - 1));\t \n  if (sbrk_needed < 0)\n    sbrk_needed += pagesz;\n\n   \n  if (sbrk_needed)\n    {\n#ifdef MALLOC_STATS\n      _mstats.nsbrk++;\n      _mstats.tsbrk += sbrk_needed;\n#endif\n      curbrk = sbrk (sbrk_needed);\n      if ((long)curbrk == -1)\n\treturn -1;\n      memtop += sbrk_needed;\n\n       \n      curbrk += sbrk_needed & (PREPOP_SIZE - 1);\n      sbrk_needed -= sbrk_needed & (PREPOP_SIZE - 1);\n      nunits = sbrk_needed / PREPOP_SIZE;\n\n      if (nunits > 0)\n\t{\n\t  mp = (union mhead *)curbrk;\n\n\t  nextf[PREPOP_BIN] = mp;\n\t  while (1)\n\t    {\n\t      mp->mh_alloc = ISFREE;\n\t      mp->mh_index = PREPOP_BIN;\n\t      if (--nunits <= 0) break;\n\t      CHAIN(mp) = (union mhead *)((char *)mp + PREPOP_SIZE);\n\t      mp = (union mhead *)((char *)mp + PREPOP_SIZE);\n\t    }\n\t  CHAIN(mp) = 0;\n\t}\n    }\n\n   \n  for (nunits = 7; nunits < NBUCKETS; nunits++)\n    if (pagesz <= binsize(nunits))\n      break;\n  pagebucket = nunits;\n\n  return 0;\n}\n    \nstatic PTR_T\ninternal_malloc (n, file, line, flags)\t\t \n     size_t n;\n     const char *file;\n     int line, flags;\n{\n  register union mhead *p;\n  register int nunits;\n  register char *m, *z;\n  MALLOC_SIZE_T nbytes;\n  mguard_t mg;\n\n   \n  if (pagesz == 0)\n    if (pagealign () < 0)\n      return ((PTR_T)NULL);\n \n   \n#if SIZEOF_SIZE_T == 8\n  if (ALLOCATED_BYTES(n) > MAXALLOC_SIZE)\n    return ((PTR_T) NULL);\n#endif\n  nbytes = ALLOCATED_BYTES(n);\n  nunits = (nbytes <= (pagesz >> 1)) ? STARTBUCK : pagebucket;\n  for ( ; nunits < NBUCKETS; nunits++)\n    if (nbytes <= binsize(nunits))\n      break;\n\n   \n  if (nunits >= NBUCKETS)\n    return ((PTR_T) NULL);\n\n   \n#ifdef MALLOC_STATS\n  if (busy[nunits]) _mstats.nrecurse++;\n#endif\n  while (busy[nunits]) nunits++;\n  busy[nunits] = 1;\n\n  if (nunits > maxbuck)\n    maxbuck = nunits;\n\n   \n  if (nextf[nunits] == 0)\n    morecore (nunits);\n\n   \n  if ((p = nextf[nunits]) == NULL)\n    {\n      busy[nunits] = 0;\n      return NULL;\n    }\n  nextf[nunits] = CHAIN (p);\n  busy[nunits] = 0;\n\n   \n   \n  if (p->mh_alloc != ISFREE || p->mh_index != nunits)\n    xbotch ((PTR_T)(p+1), 0, _(\"malloc: block on free list clobbered\"), file, line);\n\n   \n  p->mh_alloc = ISALLOC;\n  p->mh_magic2 = MAGIC2;\n  p->mh_nbytes = n;\n\n   \n  MALLOC_MEMSET ((char *)p->mh_magic8, MAGIC1, MAGIC8_NUMBYTES);\n\n   \n  mg.i = n;\n  z = mg.s;\n  m = (char *) (p + 1) + n;\n  *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;\n\n#ifdef MEMSCRAMBLE\n  if (n)\n    MALLOC_MEMSET ((char *)(p + 1), 0xdf, n);\t \n#endif\n#ifdef MALLOC_STATS\n  _mstats.nmalloc[nunits]++;\n  _mstats.tmalloc[nunits]++;\n  _mstats.nmal++;\n  _mstats.bytesreq += n;\n#endif  \n\n#ifdef MALLOC_TRACE\n  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)\n    mtrace_alloc (\"malloc\", p + 1, n, file, line);\n  else if (_malloc_trace_buckets[nunits])\n    mtrace_alloc (\"malloc\", p + 1, n, file, line);\n#endif\n\n#ifdef MALLOC_REGISTER\n  if (malloc_register && (flags & MALLOC_NOREG) == 0)\n    mregister_alloc (\"malloc\", p + 1, n, file, line);\n#endif\n\n#ifdef MALLOC_WATCH\n  if (_malloc_nwatch > 0)\n    _malloc_ckwatch (p + 1, file, line, W_ALLOC, n);\n#endif\n\n#if defined (MALLOC_DEBUG)\n  z = (char *) (p + 1);\n   \n  if ((unsigned long)z & MALIGN_MASK)\n    fprintf (stderr, \"malloc: %s:%d: warning: request for %d bytes not aligned on %d byte boundary\\r\\n\",\n\tfile ? file : _(\"unknown\"), line, p->mh_nbytes, MALIGN_MASK+1);\n#endif\n\n  return (PTR_T) (p + 1);\n}\n\nstatic void\ninternal_free (mem, file, line, flags)\n     PTR_T mem;\n     const char *file;\n     int line, flags;\n{\n  register union mhead *p;\n  register char *ap, *z;\n  register int nunits;\n  register MALLOC_SIZE_T nbytes;\n  MALLOC_SIZE_T ubytes;\t\t \n  mguard_t mg;\n\n  if ((ap = (char *)mem) == 0)\n    return;\n\n  p = (union mhead *) ap - 1;\n\n  if (p->mh_alloc == ISMEMALIGN)\n    {\n      ap -= p->mh_nbytes;\n      p = (union mhead *) ap - 1;\n    }\n\n#if defined (MALLOC_TRACE) || defined (MALLOC_REGISTER) || defined (MALLOC_WATCH)\n  if (malloc_trace || malloc_register || _malloc_nwatch > 0)\n    ubytes = p->mh_nbytes;\n#endif\n\n  if (p->mh_alloc != ISALLOC)\n    {\n      if (p->mh_alloc == ISFREE)\n\txbotch (mem, ERR_DUPFREE,\n\t\t_(\"free: called with already freed block argument\"), file, line);\n      else\n\txbotch (mem, ERR_UNALLOC,\n\t\t_(\"free: called with unallocated block argument\"), file, line);\n    }\n\n  ASSERT (p->mh_magic2 == MAGIC2);\n\n  nunits = p->mh_index;\n  nbytes = ALLOCATED_BYTES(p->mh_nbytes);\n   \n\n  if (IN_BUCKET(nbytes, nunits) == 0)\n    xbotch (mem, ERR_UNDERFLOW,\n\t    _(\"free: underflow detected; mh_nbytes out of range\"), file, line);\n  {\n    int i;\n    for (i = 0, z = p->mh_magic8; i < MAGIC8_NUMBYTES; i++)\n      if (*z++ != MAGIC1)\n\txbotch (mem, ERR_UNDERFLOW,\n\t\t_(\"free: underflow detected; magic8 corrupted\"), file, line);\n  }\n\n  ap += p->mh_nbytes;\n  z = mg.s;\n  *z++ = *ap++, *z++ = *ap++, *z++ = *ap++, *z++ = *ap++;  \n  if (mg.i != p->mh_nbytes)\n    xbotch (mem, ERR_ASSERT_FAILED, _(\"free: start and end chunk sizes differ\"), file, line);\n\n#if defined (USE_MMAP)\n  if (nunits > malloc_mmap_threshold)\n    {\n      munmap (p, binsize (nunits));\n#if defined (MALLOC_STATS)\n      _mstats.nlesscore[nunits]++;\n#endif\n      goto free_return;\n    }\n#endif\n\n#if defined (USE_LESSCORE)\n   \n  if (nunits >= LESSCORE_MIN && ((char *)p + binsize(nunits) == memtop))\n    {\n       \n      if ((nunits >= LESSCORE_FRC) || busy[nunits] || nextf[nunits] != 0)\n\t{\n\t  lesscore (nunits);\n\t   \n\t  goto free_return;\n\t}\n    }\n#endif  \n\n#ifdef MEMSCRAMBLE\n  if (p->mh_nbytes)\n    MALLOC_MEMSET (mem, 0xcf, p->mh_nbytes);\n#endif\n\n  ASSERT (nunits < NBUCKETS);\n\n  if (busy[nunits] == 1)\n    {\n      xsplit (p, nunits);\t \n      goto free_return;\n    }\n\n  p->mh_alloc = ISFREE;\n   \n  busy[nunits] = 1;\n   \n  CHAIN (p) = nextf[nunits];\n  nextf[nunits] = p;\n  busy[nunits] = 0;\n\nfree_return:\n  ;\t\t \n\n#ifdef MALLOC_STATS\n  _mstats.nmalloc[nunits]--;\n  _mstats.nfre++;\n#endif  \n\n#ifdef MALLOC_TRACE\n  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)\n    mtrace_free (mem, ubytes, file, line);\n  else if (_malloc_trace_buckets[nunits])\n    mtrace_free (mem, ubytes, file, line);\n#endif\n\n#ifdef MALLOC_REGISTER\n  if (malloc_register && (flags & MALLOC_NOREG) == 0)\n    mregister_free (mem, ubytes, file, line);\n#endif\n\n#ifdef MALLOC_WATCH\n  if (_malloc_nwatch > 0)\n    _malloc_ckwatch (mem, file, line, W_FREE, ubytes);\n#endif\n}\n\n#if USE_MREMAP == 1\n \nstatic PTR_T\ninternal_remap (mem, n, nunits, flags)\n     PTR_T mem;\n     register size_t n;\n     int nunits;\n     int flags;\n{\n  register union mhead *p, *np;\n  char *m, *z;\n  mguard_t mg;\n  MALLOC_SIZE_T nbytes;\n\n  if (nunits >= NBUCKETS)\t \n    return ((PTR_T) NULL);\n\n  p = (union mhead *)mem - 1;\n\n  m = (char *)mem + p->mh_nbytes;\n  z = mg.s;\n  *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;\t \n\n  nbytes = ALLOCATED_BYTES(n);\n\n  busy[nunits] = 1;\n  np = (union mhead *)mremap (p, binsize (p->mh_index), binsize (nunits), MREMAP_MAYMOVE);\n  busy[nunits] = 0;\n  if (np == MAP_FAILED)\n    return (PTR_T)NULL;\n\n  if (np != p)\n    {\n      np->mh_alloc = ISALLOC;\n      np->mh_magic2 = MAGIC2;\n      MALLOC_MEMSET ((char *)np->mh_magic8, MAGIC1, MAGIC8_NUMBYTES);\n    }\n  np->mh_index = nunits;\n  np->mh_nbytes = n;\n\n  mg.i = n;\n  z = mg.s;\n  m = (char *)(np + 1) + n;\n  *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;\n\n  return ((PTR_T)(np + 1));\n}\n#endif\n\nstatic PTR_T\ninternal_realloc (mem, n, file, line, flags)\n     PTR_T mem;\n     register size_t n;\n     const char *file;\n     int line, flags;\n{\n  register union mhead *p;\n  register MALLOC_SIZE_T tocopy;\n  register MALLOC_SIZE_T nbytes;\n  register int newunits, nunits;\n  register char *m, *z;\n  mguard_t mg;\n\n#ifdef MALLOC_STATS\n  _mstats.nrealloc++;\n#endif\n\n  if (n == 0)\n    {\n      internal_free (mem, file, line, MALLOC_INTERNAL);\n      return (NULL);\n    }\n  if ((p = (union mhead *) mem) == 0)\n    return internal_malloc (n, file, line, MALLOC_INTERNAL);\n\n  p--;\n  nunits = p->mh_index;\n  ASSERT (nunits < NBUCKETS);\n\n  if (p->mh_alloc != ISALLOC)\n    xbotch (mem, ERR_UNALLOC,\n\t    _(\"realloc: called with unallocated block argument\"), file, line);\n\n  ASSERT (p->mh_magic2 == MAGIC2);\n  nbytes = ALLOCATED_BYTES(p->mh_nbytes);\n   \n  if (IN_BUCKET(nbytes, nunits) == 0)\n    xbotch (mem, ERR_UNDERFLOW,\n\t    _(\"realloc: underflow detected; mh_nbytes out of range\"), file, line);\n  {\n    int i;\n    for (i = 0, z = p->mh_magic8; i < MAGIC8_NUMBYTES; i++)\n      if (*z++ != MAGIC1)\n\txbotch (mem, ERR_UNDERFLOW,\n\t\t_(\"realloc: underflow detected; magic8 corrupted\"), file, line);\n\n  }\n\n  m = (char *)mem + (tocopy = p->mh_nbytes);\n  z = mg.s;\n  *z++ = *m++, *z++ = *m++, *z++ = *m++, *z++ = *m++;\n  if (mg.i != p->mh_nbytes)\n    xbotch (mem, ERR_ASSERT_FAILED, _(\"realloc: start and end chunk sizes differ\"), file, line);\n\n#ifdef MALLOC_WATCH\n  if (_malloc_nwatch > 0)\n    _malloc_ckwatch (p + 1, file, line, W_REALLOC, n);\n#endif\n#ifdef MALLOC_STATS\n  _mstats.bytesreq += (n < tocopy) ? 0 : n - tocopy;\n#endif\n\n   \n  if (n == p->mh_nbytes)\n    return mem;\n\n#if SIZEOF_SIZE_T == 8\n  if (ALLOCATED_BYTES(n) > MAXALLOC_SIZE)\n    return ((PTR_T) NULL);\n#endif\n   \n  nbytes = ALLOCATED_BYTES(n);\n\n   \n  if (RIGHT_BUCKET(nbytes, nunits) || RIGHT_BUCKET(nbytes, nunits-1))\n    {\n       \n      m -= 4;\n\n      *m++ = 0;  *m++ = 0;  *m++ = 0;  *m++ = 0;\n      m = (char *)mem + (p->mh_nbytes = n);\n\n      mg.i = n;\n      z = mg.s;\n      *m++ = *z++, *m++ = *z++, *m++ = *z++, *m++ = *z++;      \n\n      return mem;\n    }\n\n  if (n < tocopy)\n    tocopy = n;\n\n#ifdef MALLOC_STATS\n  _mstats.nrcopy++;\n#endif\n\n#if USE_MREMAP == 1\n   \n  if (nbytes > p->mh_nbytes)\n    newunits = nunits;\n  else\n    newunits = (nbytes <= (pagesz >> 1)) ? STARTBUCK : pagebucket;\n  for ( ; newunits < NBUCKETS; newunits++)\n    if (nbytes <= binsize(newunits))\n     break;\n\n  if (nunits > malloc_mmap_threshold && newunits > malloc_mmap_threshold)\n    {\n      m = internal_remap (mem, n, newunits, MALLOC_INTERNAL);\n      if (m == 0)\n        return 0;\n    }\n  else\n#endif  \n    {\n  if ((m = internal_malloc (n, file, line, MALLOC_INTERNAL|MALLOC_NOTRACE|MALLOC_NOREG)) == 0)\n    return 0;\n  FASTCOPY (mem, m, tocopy);\n  internal_free (mem, file, line, MALLOC_INTERNAL);\n    }\n\n#ifdef MALLOC_TRACE\n  if (malloc_trace && (flags & MALLOC_NOTRACE) == 0)\n    mtrace_alloc (\"realloc\", m, n, file, line);\n  else if (_malloc_trace_buckets[nunits])\n    mtrace_alloc (\"realloc\", m, n, file, line);\n#endif\n\n#ifdef MALLOC_REGISTER\n  if (malloc_register && (flags & MALLOC_NOREG) == 0)\n    mregister_alloc (\"realloc\", m, n, file, line);\n#endif\n\n#ifdef MALLOC_WATCH\n  if (_malloc_nwatch > 0)\n    _malloc_ckwatch (m, file, line, W_RESIZED, n);\n#endif\n\n  return m;\n}\n\nstatic PTR_T\ninternal_memalign (alignment, size, file, line, flags)\n     size_t alignment;\n     size_t size;\n     const char *file;\n     int line, flags;\n{\n  register char *ptr;\n  register char *aligned;\n  register union mhead *p;\n\n  ptr = internal_malloc (size + alignment, file, line, MALLOC_INTERNAL);\n\n  if (ptr == 0)\n    return 0;\n   \n  if (((long) ptr & (alignment - 1)) == 0)\n    return ptr;\n   \n  aligned = (char *) (((long) ptr + alignment - 1) & (~alignment + 1));\n\n   \n  p = (union mhead *) aligned - 1;\n  p->mh_nbytes = aligned - ptr;\n  p->mh_alloc = ISMEMALIGN;\n\n  return aligned;\n}\n\nint\nposix_memalign (memptr, alignment, size)\n     void **memptr;\n     size_t alignment, size;\n{\n  void *mem;\n\n   \n  if ((alignment % sizeof (void *) != 0) || alignment == 0)\n    return EINVAL;\n  else if (powerof2 (alignment) == 0)\n    return EINVAL;\n\n  mem = internal_memalign (alignment, size, (char *)0, 0, 0);\n  if (mem != 0)\n    {\n      *memptr = mem;\n      return 0;\n    }\n  return ENOMEM;\n}\n\nsize_t\nmalloc_usable_size (mem)\n     void *mem;\n{\n  register union mhead *p;\n  register char *ap;\n\n  if ((ap = (char *)mem) == 0)\n    return 0;\n\n   \n  p = (union mhead *) ap - 1;\n\n  if (p->mh_alloc == ISMEMALIGN)\n    {\n      ap -= p->mh_nbytes;\n      p = (union mhead *) ap - 1;\n    }\n\n   \n  if (p->mh_alloc == ISFREE)\n    return 0;\n  \n   \n  return (p->mh_nbytes);\n}\n\n#if !defined (NO_VALLOC)\n \nstatic PTR_T\ninternal_valloc (size, file, line, flags)\n     size_t size;\n     const char *file;\n     int line, flags;\n{\n  return internal_memalign (getpagesize (), size, file, line, flags|MALLOC_INTERNAL);\n}\n#endif  \n\n#ifndef NO_CALLOC\nstatic PTR_T\ninternal_calloc (n, s, file, line, flags)\n     size_t n, s;\n     const char *file;\n     int line, flags;\n{\n  size_t total;\n  PTR_T result;\n\n  total = n * s;\n  result = internal_malloc (total, file, line, flags|MALLOC_INTERNAL);\n  if (result)\n    memset (result, 0, total);\n  return result;  \n}\n\nstatic void\ninternal_cfree (p, file, line, flags)\n     PTR_T p;\n     const char *file;\n     int line, flags;\n{\n  internal_free (p, file, line, flags|MALLOC_INTERNAL);\n}\n#endif  \n\n#ifdef MALLOC_STATS\nint\nmalloc_free_blocks (size)\n     int size;\n{\n  int nfree;\n  register union mhead *p;\n\n  nfree = 0;\n  for (p = nextf[size]; p; p = CHAIN (p))\n    nfree++;\n\n  return nfree;\n}\n#endif\n\n#if defined (MALLOC_WRAPFUNCS)\nPTR_T\nsh_malloc (bytes, file, line)\n     size_t bytes;\n     const char *file;\n     int line;\n{\n  return internal_malloc (bytes, file, line, MALLOC_WRAPPER);\n}\n\nPTR_T\nsh_realloc (ptr, size, file, line)\n     PTR_T ptr;\n     size_t size;\n     const char *file;\n     int line;\n{\n  return internal_realloc (ptr, size, file, line, MALLOC_WRAPPER);\n}\n\nvoid\nsh_free (mem, file, line)\n     PTR_T mem;\n     const char *file;\n     int line;\n{\n  internal_free (mem, file, line, MALLOC_WRAPPER);\n}\n\nPTR_T\nsh_memalign (alignment, size, file, line)\n     size_t alignment;\n     size_t size;\n     const char *file;\n     int line;\n{\n  return internal_memalign (alignment, size, file, line, MALLOC_WRAPPER);\n}\n\n#ifndef NO_CALLOC\nPTR_T\nsh_calloc (n, s, file, line)\n     size_t n, s;\n     const char *file;\n     int line;\n{\n  return internal_calloc (n, s, file, line, MALLOC_WRAPPER);\n}\n\nvoid\nsh_cfree (mem, file, line)\n     PTR_T mem;\n     const char *file;\n     int line;\n{\n  internal_cfree (mem, file, line, MALLOC_WRAPPER);\n}\n#endif\n\n#ifndef NO_VALLOC\nPTR_T\nsh_valloc (size, file, line)\n     size_t size;\n     const char *file;\n     int line;\n{\n  return internal_valloc (size, file, line, MALLOC_WRAPPER);\n}\n#endif  \n\n#endif  \n\n \n\nPTR_T\nmalloc (size)\n     size_t size;\n{\n  return internal_malloc (size, (char *)NULL, 0, 0);\n}\n\nPTR_T\nrealloc (mem, nbytes)\n     PTR_T mem;\n     size_t nbytes;\n{\n  return internal_realloc (mem, nbytes, (char *)NULL, 0, 0);\n}\n\nvoid\nfree (mem)\n     PTR_T mem;\n{\n  internal_free (mem,  (char *)NULL, 0, 0);\n}\n\nPTR_T\nmemalign (alignment, size)\n     size_t alignment;\n     size_t size;\n{\n  return internal_memalign (alignment, size, (char *)NULL, 0, 0);\n}\n\n#ifndef NO_VALLOC\nPTR_T\nvalloc (size)\n     size_t size;\n{\n  return internal_valloc (size, (char *)NULL, 0, 0);\n}\n#endif\n\n#ifndef NO_CALLOC\nPTR_T\ncalloc (n, s)\n     size_t n, s;\n{\n  return internal_calloc (n, s, (char *)NULL, 0, 0);\n}\n\nvoid\ncfree (mem)\n     PTR_T mem;\n{\n  internal_cfree (mem, (char *)NULL, 0, 0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}