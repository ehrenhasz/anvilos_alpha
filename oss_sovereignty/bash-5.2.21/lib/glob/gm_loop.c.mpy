{
  "module_name": "gm_loop.c",
  "hash_id": "c2e400709902325109816d88448cc9a5060f68b29cb15dc047868bffd4aff36d",
  "original_prompt": "Ingested from bash-5.2.21/lib/glob/gm_loop.c",
  "human_readable_source": " \n\n#if EXTENDED_GLOB\nint\nEXTGLOB_PATTERN_P (pat)\n     const CHAR *pat;\n{\n  switch (pat[0])\n    {\n    case L('*'):\n    case L('+'):\n    case L('!'):\n    case L('@'):\n    case L('?'):\n      return (pat[1] == L('('));\t \n    default:\n      return 0;\n    }\n    \n  return 0;\n}\n#endif\n\n \nint\nMATCH_PATTERN_CHAR (pat, string, flags)\n     CHAR *pat, *string;\n     int flags;\n{\n  CHAR c;\n\n  if (*string == 0)\n    return (*pat == L('*'));\t \n\n  switch (c = *pat++)\n    {\n    default:\n      return (FOLD(*string) == FOLD(c));\n    case L('\\\\'):\n      return (FOLD(*string) == FOLD(*pat));\n    case L('?'):\n      return (*pat == L('(') ? 1 : (*string != L'\\0'));\n    case L('*'):\n      return (1);\n    case L('+'):\n    case L('!'):\n    case L('@'):\n      return (*pat ==  L('(') ? 1 : (FOLD(*string) == FOLD(c)));\n    case L('['):\n      return (*string != L('\\0'));\n    }\n}\n\nint\nMATCHLEN (pat, max)\n     CHAR *pat;\n     size_t max;\n{\n  CHAR c;\n  int matlen, bracklen, t, in_cclass, in_collsym, in_equiv;\n\n  if (*pat == 0)\n    return (0);\n\n  matlen = in_cclass = in_collsym = in_equiv = 0;\n  while (c = *pat++)\n    {\n      switch (c)\n\t{\n\tdefault:\n\t  matlen++;\n\t  break;\n\tcase L('\\\\'):\n\t  if (*pat == 0)\n\t    return ++matlen;\n\t  else\n\t    {\n\t      matlen++;\n\t      pat++;\n\t    }\n\t  break;\n\tcase L('?'):\n\t  if (*pat == LPAREN)\n\t    return (matlen = -1);\t\t \n\t  else\n\t    matlen++;\n\t  break;\n\tcase L('*'):\n\t  return (matlen = -1);\n\tcase L('+'):\n\tcase L('!'):\n\tcase L('@'):\n\t  if (*pat == LPAREN)\n\t    return (matlen = -1);\t\t \n\t  else\n\t    matlen++;\n\t  break;\n\tcase L('['):\n\t   \n\t  bracklen = 1;\n\t  c = *pat++;\n\t  do\n\t    {\n\t      if (c == 0)\n\t\t{\n\t\t  pat--;\t\t\t \n\t          matlen += bracklen;\n\t          goto bad_bracket;\n\t        }\n\t      else if (c == L('\\\\'))\n\t\t{\n\t\t   \n\t\t  bracklen++;\n\t\t   \n\t\t  if (*pat == 0 || *++pat == 0)\n\t\t    {\n\t\t      matlen += bracklen;\n\t\t      goto bad_bracket;\n\t\t    }\n\t\t}\n\t      else if (c == L('[') && *pat == L(':'))\t \n\t\t{\n\t\t  pat++;\n\t\t  bracklen++;\n\t\t  in_cclass = 1;\n\t\t}\n\t      else if (in_cclass && c == L(':') && *pat == L(']'))\n\t\t{\n\t\t  pat++;\n\t\t  bracklen++;\n\t\t  in_cclass = 0;\n\t\t}\n\t      else if (c == L('[') && *pat == L('.'))\t \n\t\t{\n\t\t  pat++;\n\t\t  bracklen++;\n\t\t  if (*pat == L(']'))\t \n\t\t    {\n\t\t      pat++;\n\t\t      bracklen++;\n\t\t    }\n\t\t  in_collsym = 1;\n\t\t}\n\t      else if (in_collsym && c == L('.') && *pat == L(']'))\n\t\t{\n\t\t  pat++;\n\t\t  bracklen++;\n\t\t  in_collsym = 0;\n\t\t}\n\t      else if (c == L('[') && *pat == L('='))\t \n\t\t{\n\t\t  pat++;\n\t\t  bracklen++;\n\t\t  if (*pat == L(']'))\t \n\t\t    {\n\t\t      pat++;\n\t\t      bracklen++;\n\t\t    }\n\t\t  in_equiv = 1;\n\t\t}\n\t      else if (in_equiv && c == L('=') && *pat == L(']'))\n\t\t{\n\t\t  pat++;\n\t\t  bracklen++;\n\t\t  in_equiv = 0;\n\t\t}\n\t      else\n\t\tbracklen++;\n\t    }\n\t  while ((c = *pat++) != L(']'));\n\t  matlen++;\t\t \nbad_bracket:\n\t  break;\n\t}\n    }\n\n  return matlen;\n}\n\n#undef EXTGLOB_PATTERN_P\n#undef MATCH_PATTERN_CHAR\n#undef MATCHLEN\n#undef FOLD\n#undef L\n#undef LPAREN\n#undef RPAREN\n#undef INT\n#undef CHAR\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}