{
  "module_name": "smatch.c",
  "hash_id": "cc4671ab95ce587bcc2349523c9c2bb93526eed89bb1f2ab7fa0a813ee37c33a",
  "original_prompt": "Ingested from bash-5.2.21/lib/glob/smatch.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <stdio.h>\t \n\t\t\t\t\n#include \"strmatch.h\"\n#include <chartypes.h>\n\n#include \"bashansi.h\"\n#include \"shmbutil.h\"\n#include \"xmalloc.h\"\n\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#if FNMATCH_EQUIV_FALLBACK\n \nextern int fnmatch (const char *, const char *, int);\n#endif\n\n \n#define CHAR\tunsigned char\n#define U_CHAR\tunsigned char\n#define XCHAR\tchar\n#define INT\tint\n#define L(CS)\tCS\n#define INVALID\t-1\n\n#undef STREQ\n#undef STREQN\n#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)\n#define STREQN(a, b, n) ((a)[0] == (b)[0] && strncmp(a, b, n) == 0)\n\n#ifndef GLOBASCII_DEFAULT\n#  define GLOBASCII_DEFAULT 0\n#endif\n\nint glob_asciirange = GLOBASCII_DEFAULT;\n\n#if FNMATCH_EQUIV_FALLBACK\n \nstatic int\n_fnmatch_fallback (s, p)\n     int s, p;\t\t\t \n{\n  char s1[2];\t\t\t \n  char s2[8];\t\t\t \n\n  s1[0] = (unsigned char)s;\n  s1[1] = '\\0';\n\n   \n  s2[0] = s2[1] = '[';\n  s2[2] = '=';\n  s2[3] = (unsigned char)p;\n  s2[4] = '=';\n  s2[5] = s2[6] = ']';\n  s2[7] = '\\0';\n\n  return (fnmatch ((const char *)s2, (const char *)s1, 0));\n}\n#endif\n\n \n\n#if defined (HAVE_STRCOLL)\n \n\n \nstatic int\ncharcmp (c1, c2, forcecoll)\n     int c1, c2;\n     int forcecoll;\n{\n  static char s1[2] = { ' ', '\\0' };\n  static char s2[2] = { ' ', '\\0' };\n  int ret;\n\n   \n  c1 &= 0xFF;\n  c2 &= 0xFF;\n\n  if (c1 == c2)\n    return (0);\n\n  if (forcecoll == 0 && glob_asciirange)\n    return (c1 - c2);\n\n  s1[0] = c1;\n  s2[0] = c2;\n\n  return (strcoll (s1, s2));\n}\n\nstatic int\nrangecmp (c1, c2, forcecoll)\n     int c1, c2;\n     int forcecoll;\n{\n  int r;\n\n  r = charcmp (c1, c2, forcecoll);\n\n   \n  if (r != 0)\n    return r;\n  return (c1 - c2);\t\t \n}\n#else  \n#  define rangecmp(c1, c2, f)\t((int)(c1) - (int)(c2))\n#endif  \n\n#if defined (HAVE_STRCOLL)\n \nstatic int\ncollequiv (c, equiv)\n     int c, equiv;\n{\n  if (charcmp (c, equiv, 1) == 0)\n    return 1;\n\n#if FNMATCH_EQUIV_FALLBACK\n  return (_fnmatch_fallback (c, equiv) == 0);\n#else\n  return 0;\n#endif\n  \n}\n#else\n#  define collequiv(c, equiv)\t((c) == (equiv))\n#endif\n\n#define _COLLSYM\t_collsym\n#define __COLLSYM\t__collsym\n#define POSIXCOLL\tposix_collsyms\n#include \"collsyms.h\"\n\nstatic int\ncollsym (s, len)\n     CHAR *s;\n     int len;\n{\n  register struct _collsym *csp;\n  char *x;\n\n  x = (char *)s;\n  for (csp = posix_collsyms; csp->name; csp++)\n    {\n      if (STREQN(csp->name, x, len) && csp->name[len] == '\\0')\n\treturn (csp->code);\n    }\n  if (len == 1)\n    return s[0];\n  return INVALID;\n}\n\n \n#if !defined (isascii) && !defined (HAVE_ISASCII)\n#  define isascii(c)\t((unsigned int)(c) <= 0177)\n#endif\n\nenum char_class\n  {\n    CC_NO_CLASS = 0,\n    CC_ASCII, CC_ALNUM, CC_ALPHA, CC_BLANK, CC_CNTRL, CC_DIGIT, CC_GRAPH,\n    CC_LOWER, CC_PRINT, CC_PUNCT, CC_SPACE, CC_UPPER, CC_WORD, CC_XDIGIT\n  };\n\nstatic char const *const cclass_name[] =\n  {\n    \"\",\n    \"ascii\", \"alnum\", \"alpha\", \"blank\", \"cntrl\", \"digit\", \"graph\",\n    \"lower\", \"print\", \"punct\", \"space\", \"upper\", \"word\", \"xdigit\"\n  };\n\n#define N_CHAR_CLASS (sizeof(cclass_name) / sizeof (cclass_name[0]))\n\nstatic enum char_class\nis_valid_cclass (name)\n     const char *name;\n{\n  enum char_class ret;\n  int i;\n\n  ret = CC_NO_CLASS;\n\n  for (i = 1; i < N_CHAR_CLASS; i++)\n    {\n      if (STREQ (name, cclass_name[i]))\n\t{\n\t  ret = (enum char_class)i;\n\t  break;\n\t}\n    }\n\n  return ret;\n}\n\nstatic int\ncclass_test (c, char_class)\n     int c;\n     enum char_class char_class;\n{\n  int result;\n\n  switch (char_class)\n    {\n      case CC_ASCII:\n\tresult = isascii (c);\n\tbreak;\n      case CC_ALNUM:\n\tresult = ISALNUM (c);\n\tbreak;\n      case CC_ALPHA:\n\tresult = ISALPHA (c);\n\tbreak;\n      case CC_BLANK:  \n\tresult = ISBLANK (c);\n\tbreak;\n      case CC_CNTRL:\n\tresult = ISCNTRL (c);\n\tbreak;\n      case CC_DIGIT:\n\tresult = ISDIGIT (c);\n\tbreak;\n      case CC_GRAPH:\n\tresult = ISGRAPH (c);\n\tbreak;\n      case CC_LOWER:\n\tresult = ISLOWER (c);\n\tbreak;\n      case CC_PRINT: \n\tresult = ISPRINT (c);\n\tbreak;\n      case CC_PUNCT:\n\tresult = ISPUNCT (c);\n\tbreak;\n      case CC_SPACE:\n\tresult = ISSPACE (c);\n\tbreak;\n      case CC_UPPER:\n\tresult = ISUPPER (c);\n\tbreak;\n      case CC_WORD:\n        result = (ISALNUM (c) || c == '_');\n\tbreak;\n      case CC_XDIGIT:\n\tresult = ISXDIGIT (c);\n\tbreak;\n      default:\n\tresult = -1;\n\tbreak;\n    }\n\n  return result;  \n}\n\t\nstatic int\nis_cclass (c, name)\n     int c;\n     const char *name;\n{\n  enum char_class char_class;\n  int result;\n\n  char_class = is_valid_cclass (name);\n  if (char_class == CC_NO_CLASS)\n    return -1;\n\n  result = cclass_test (c, char_class);\n  return (result);\n}\n\n \n \n# define FOLD(c) ((flags & FNM_CASEFOLD) \\\n\t? TOLOWER ((unsigned char)c) \\\n\t: ((unsigned char)c))\n\n#if !defined (__CYGWIN__)\n#  define ISDIRSEP(c)\t((c) == '/')\n#else\n#  define ISDIRSEP(c)\t((c) == '/' || (c) == '\\\\')\n#endif  \n#define PATHSEP(c)\t(ISDIRSEP(c) || (c) == 0)\n\n#  define PDOT_OR_DOTDOT(s)\t(s[0] == '.' && (PATHSEP (s[1]) || (s[1] == '.' && PATHSEP (s[2]))))\n#  define SDOT_OR_DOTDOT(s)\t(s[0] == '.' && (s[1] == 0 || (s[1] == '.' && s[2] == 0)))\n\n#define FCT\t\t\tinternal_strmatch\n#define GMATCH\t\t\tgmatch\n#define COLLSYM\t\t\tcollsym\n#define PARSE_COLLSYM\t\tparse_collsym\n#define BRACKMATCH\t\tbrackmatch\n#define PATSCAN\t\t\tglob_patscan\n#define STRCOMPARE\t\tstrcompare\n#define EXTMATCH\t\textmatch\n#define DEQUOTE_PATHNAME\tudequote_pathname\n#define STRUCT\t\t\tsmat_struct\n#define STRCHR(S, C)\t\tstrchr((S), (C))\n#define MEMCHR(S, C, N)\t\tmemchr((S), (C), (N))\n#define STRCOLL(S1, S2)\t\tstrcoll((S1), (S2))\n#define STRLEN(S)\t\tstrlen(S)\n#define STRCMP(S1, S2)\t\tstrcmp((S1), (S2))\n#define RANGECMP(C1, C2, F)\trangecmp((C1), (C2), (F))\n#define COLLEQUIV(C1, C2)\tcollequiv((C1), (C2))\n#define CTYPE_T\t\t\tenum char_class\n#define IS_CCLASS(C, S)\t\tis_cclass((C), (S))\n#include \"sm_loop.c\"\n\n#if HANDLE_MULTIBYTE\n\n#  define CHAR\t\twchar_t\n#  define U_CHAR\twint_t\n#  define XCHAR\t\twchar_t\n#  define INT\t\twint_t\n#  define L(CS)\t\tL##CS\n#  define INVALID\tWEOF\n\n#  undef STREQ\n#  undef STREQN\n#  define STREQ(s1, s2) ((wcscmp (s1, s2) == 0))\n#  define STREQN(a, b, n) ((a)[0] == (b)[0] && wcsncmp(a, b, n) == 0)\n\nextern char *mbsmbchar PARAMS((const char *));\n\n#if FNMATCH_EQUIV_FALLBACK\n \nstatic int\n_fnmatch_fallback_wc (c1, c2)\n     wchar_t c1, c2;\t\t\t \n{\n  char w1[MB_LEN_MAX+1];\t\t \n  char w2[MB_LEN_MAX+8];\t\t \n  int l1, l2;\n\n  l1 = wctomb (w1, c1);\n  if (l1 == -1)\n    return (2);\n  w1[l1] = '\\0';\n\n   \n  w2[0] = w2[1] = '[';\n  w2[2] = '=';\n  l2 = wctomb (w2+3, c2);\n  if (l2 == -1)\n    return (2);\n  w2[l2+3] = '=';\n  w2[l2+4] = w2[l2+5] = ']';\n  w2[l2+6] = '\\0';\n\n  return (fnmatch ((const char *)w2, (const char *)w1, 0));\n}\n#endif\n\nstatic int\ncharcmp_wc (c1, c2, forcecoll)\n     wint_t c1, c2;\n     int forcecoll;\n{\n  static wchar_t s1[2] = { L' ', L'\\0' };\n  static wchar_t s2[2] = { L' ', L'\\0' };\n  int r;\n\n  if (c1 == c2)\n    return 0;\n\n  if (forcecoll == 0 && glob_asciirange && c1 <= UCHAR_MAX && c2 <= UCHAR_MAX)\n    return ((int)(c1 - c2));\n\n  s1[0] = c1;\n  s2[0] = c2;\n\n  return (wcscoll (s1, s2));\n}\n\nstatic int\nrangecmp_wc (c1, c2, forcecoll)\n     wint_t c1, c2;\n     int forcecoll;\n{\n  int r;\n\n  r = charcmp_wc (c1, c2, forcecoll);\n\n   \n  if (r != 0 || forcecoll)\n    return r;\n  return ((int)(c1 - c2));\t\t \n}\n\n \nstatic int\ncollequiv_wc (c, equiv)\n     wint_t c, equiv;\n{\n  wchar_t s, p;\n\n  if (charcmp_wc (c, equiv, 1) == 0)\n    return 1;\n\n#if FNMATCH_EQUIV_FALLBACK\n \n\n  s = c;\n  p = equiv;\n  return (_fnmatch_fallback_wc (s, p) == 0);\n#else\n  return 0;\n#endif\n}\n\n \n#  define _COLLSYM\t_collwcsym\n#  define __COLLSYM\t__collwcsym\n#  define POSIXCOLL\tposix_collwcsyms\n#  include \"collsyms.h\"\n\nstatic wint_t\ncollwcsym (s, len)\n     wchar_t *s;\n     int len;\n{\n  register struct _collwcsym *csp;\n\n  for (csp = posix_collwcsyms; csp->name; csp++)\n    {\n      if (STREQN(csp->name, s, len) && csp->name[len] == L'\\0')\n\treturn (csp->code);\n    }\n  if (len == 1)\n    return s[0];\n  return INVALID;\n}\n\nstatic int\nis_wcclass (wc, name)\n     wint_t wc;\n     wchar_t *name;\n{\n  char *mbs;\n  mbstate_t state;\n  size_t mbslength;\n  wctype_t desc;\n  int want_word;\n\n  if ((wctype (\"ascii\") == (wctype_t)0) && (wcscmp (name, L\"ascii\") == 0))\n    {\n      int c;\n\n      if ((c = wctob (wc)) == EOF)\n\treturn 0;\n      else\n        return (c <= 0x7F);\n    }\n\n  want_word = (wcscmp (name, L\"word\") == 0);\n  if (want_word)\n    name = L\"alnum\";\n\n  memset (&state, '\\0', sizeof (mbstate_t));\n  mbs = (char *) malloc (wcslen(name) * MB_CUR_MAX + 1);\n  if (mbs == 0)\n    return -1;\n  mbslength = wcsrtombs (mbs, (const wchar_t **)&name, (wcslen(name) * MB_CUR_MAX + 1), &state);\n\n  if (mbslength == (size_t)-1 || mbslength == (size_t)-2)\n    {\n      free (mbs);\n      return -1;\n    }\n  desc = wctype (mbs);\n  free (mbs);\n\n  if (desc == (wctype_t)0)\n    return -1;\n\n  if (want_word)\n    return (iswctype (wc, desc) || wc == L'_');\n  else\n    return (iswctype (wc, desc));\n}\n\n \nstatic int\nposix_cclass_only (pattern)\n     char *pattern;\n{\n  char *p, *p1;\n  char cc[16];\t\t \n  enum char_class valid;\n\n  p = pattern;\n  while (p = strchr (p, '['))\n    {\n      if (p[1] != ':')\n\t{\n\t  p++;\n\t  continue;\n        }\n      p += 2;\t\t \n       \n      for (p1 = p; *p1;  p1++)\n\tif (*p1 == ':' && p1[1] == ']')\n\t  break;\n      if (*p1 == 0)\t \n\tbreak;\n       \n      if ((p1 - p) >= sizeof (cc))\n\treturn 0;\n      bcopy (p, cc, p1 - p);\n      cc[p1 - p] = '\\0';\n      valid = is_valid_cclass (cc);\n      if (valid == CC_NO_CLASS)\n\treturn 0;\t\t \n\n      p = p1 + 2;\t\t \n    }\n    \n  return 1;\t\t\t \n}      \n\n \n#define FOLD(c) ((flags & FNM_CASEFOLD) && iswupper (c) ? towlower (c) : (c))\n\n#  if !defined (__CYGWIN__)\n#    define ISDIRSEP(c)\t((c) == L'/')\n#  else\n#    define ISDIRSEP(c)\t((c) == L'/' || (c) == L'\\\\')\n#  endif  \n#  define PATHSEP(c)\t(ISDIRSEP(c) || (c) == L'\\0')\n\n#  define PDOT_OR_DOTDOT(w)\t(w[0] == L'.' && (PATHSEP(w[1]) || (w[1] == L'.' && PATHSEP(w[2]))))\n#  define SDOT_OR_DOTDOT(w)\t(w[0] == L'.' && (w[1] == L'\\0' || (w[1] == L'.' && w[2] == L'\\0')))\n\n#define FCT\t\t\tinternal_wstrmatch\n#define GMATCH\t\t\tgmatch_wc\n#define COLLSYM\t\t\tcollwcsym\n#define PARSE_COLLSYM\t\tparse_collwcsym\n#define BRACKMATCH\t\tbrackmatch_wc\n#define PATSCAN\t\t\tglob_patscan_wc\n#define STRCOMPARE\t\twscompare\n#define EXTMATCH\t\textmatch_wc\n#define DEQUOTE_PATHNAME\twcdequote_pathname\n#define STRUCT\t\t\twcsmat_struct\n#define STRCHR(S, C)\t\twcschr((S), (C))\n#define MEMCHR(S, C, N)\t\twmemchr((S), (C), (N))\n#define STRCOLL(S1, S2)\t\twcscoll((S1), (S2))\n#define STRLEN(S)\t\twcslen(S)\n#define STRCMP(S1, S2)\t\twcscmp((S1), (S2))\n#define RANGECMP(C1, C2, F)\trangecmp_wc((C1), (C2), (F))\n#define COLLEQUIV(C1, C2)\tcollequiv_wc((C1), (C2))\n#define CTYPE_T\t\t\tenum char_class\n#define IS_CCLASS(C, S)\t\tis_wcclass((C), (S))\n#include \"sm_loop.c\"\n\n#endif  \n\nint\nxstrmatch (pattern, string, flags)\n     char *pattern;\n     char *string;\n     int flags;\n{\n#if HANDLE_MULTIBYTE\n  int ret;\n  size_t n;\n  wchar_t *wpattern, *wstring;\n  size_t plen, slen, mplen, mslen;\n\n  if (MB_CUR_MAX == 1)\n    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));\n\n  if (mbsmbchar (string) == 0 && mbsmbchar (pattern) == 0 && posix_cclass_only (pattern))\n    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));\n\n  n = xdupmbstowcs (&wpattern, NULL, pattern);\n  if (n == (size_t)-1 || n == (size_t)-2)\n    return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));\n\n  n = xdupmbstowcs (&wstring, NULL, string);\n  if (n == (size_t)-1 || n == (size_t)-2)\n    {\n      free (wpattern);\n      return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));\n    }\n\n  ret = internal_wstrmatch (wpattern, wstring, flags);\n\n  free (wpattern);\n  free (wstring);\n\n  return ret;\n#else\n  return (internal_strmatch ((unsigned char *)pattern, (unsigned char *)string, flags));\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}