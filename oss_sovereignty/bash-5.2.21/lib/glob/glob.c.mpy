{
  "module_name": "glob.c",
  "hash_id": "4b67dfe3903127d0bde61c2c68990d19371823a7b51484137dd58bdc920324d4",
  "original_prompt": "Ingested from bash-5.2.21/lib/glob/glob.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if !defined (__GNUC__) && !defined (HAVE_ALLOCA_H) && defined (_AIX)\n  #pragma alloca\n#endif  \n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include \"posixdir.h\"\n#include \"posixstat.h\"\n#include \"shmbutil.h\"\n#include \"xmalloc.h\"\n\n#include \"filecntl.h\"\n#if !defined (F_OK)\n#  define F_OK 0\n#endif\n\n#include \"stdc.h\"\n#include \"memalloc.h\"\n\n#include <signal.h>\n\n#include \"shell.h\"\n#include \"general.h\"\n\n#include \"glob.h\"\n#include \"strmatch.h\"\n\n#if !defined (HAVE_BCOPY) && !defined (bcopy)\n#  define bcopy(s, d, n) ((void) memcpy ((d), (s), (n)))\n#endif  \n\n#if !defined (NULL)\n#  if defined (__STDC__)\n#    define NULL ((void *) 0)\n#  else\n#    define NULL 0x0\n#  endif  \n#endif  \n\n#if !defined (FREE)\n#  define FREE(x)\tif (x) free (x)\n#endif\n\n \n#ifndef ALLOCA_MAX\n#  define ALLOCA_MAX\t100000\n#endif\n\nstruct globval\n  {\n    struct globval *next;\n    char *name;\n  };\n\nextern void throw_to_top_level PARAMS((void));\nextern int sh_eaccess PARAMS((const char *, int));\nextern char *sh_makepath PARAMS((const char *, const char *, int));\nextern int signal_is_pending PARAMS((int));\nextern void run_pending_traps PARAMS((void));\n\nextern int extended_glob;\n\n \nint noglob_dot_filenames = 1;\n\n \nint glob_ignore_case = 0;\n\n \nint glob_always_skip_dot_and_dotdot = 1;\n\n \nchar *glob_error_return;\n\nstatic struct globval finddirs_error_return;\n\n \nstatic int skipname PARAMS((char *, char *, int));\n#if HANDLE_MULTIBYTE\nstatic int mbskipname PARAMS((char *, char *, int));\n#endif\nvoid udequote_pathname PARAMS((char *));\n#if HANDLE_MULTIBYTE\nvoid wcdequote_pathname PARAMS((wchar_t *));\nstatic void wdequote_pathname PARAMS((char *));\nstatic void dequote_pathname PARAMS((char *));\n#else\n#  define dequote_pathname(p) udequote_pathname(p)\n#endif\nstatic int glob_testdir PARAMS((char *, int));\nstatic char **glob_dir_to_array PARAMS((char *, char **, int));\n\n \nextern char *glob_patscan PARAMS((char *, char *, int));\nextern wchar_t *glob_patscan_wc PARAMS((wchar_t *, wchar_t *, int));\n\n \nextern int wextglob_pattern_p PARAMS((wchar_t *));\n\nextern char *glob_dirscan PARAMS((char *, int));\n\n \n#define GCHAR\tunsigned char\n#define CHAR\tchar\n#define INT\tint\n#define L(CS)\tCS\n#define INTERNAL_GLOB_PATTERN_P internal_glob_pattern_p\n#include \"glob_loop.c\"\n\n \n#if HANDLE_MULTIBYTE\n\n#define GCHAR\twchar_t\n#define CHAR\twchar_t\n#define INT\twint_t\n#define L(CS)\tL##CS\n#define INTERNAL_GLOB_PATTERN_P internal_glob_wpattern_p\n#include \"glob_loop.c\"\n\n#endif  \n\n \nint\nglob_pattern_p (pattern)\n     const char *pattern;\n{\n#if HANDLE_MULTIBYTE\n  size_t n;\n  wchar_t *wpattern;\n  int r;\n\n  if (MB_CUR_MAX == 1 || mbsmbchar (pattern) == 0)\n    return (internal_glob_pattern_p ((unsigned char *)pattern));\n\n   \n  n = xdupmbstowcs (&wpattern, NULL, pattern);\n  if (n == (size_t)-1)\n     \n    return (internal_glob_pattern_p ((unsigned char *)pattern));\n\n  r = internal_glob_wpattern_p (wpattern);\n  free (wpattern);\n\n  return r;\n#else\n  return (internal_glob_pattern_p ((unsigned char *)pattern));\n#endif\n}\n\n#if EXTENDED_GLOB\n\n#if defined (HANDLE_MULTIBYTE)\n#  define XSKIPNAME(p, d, f)\tmbskipname(p, d, f)\n#else\n#  define XSKIPNAME(p, d, f)\tskipname(p, d, f)\n#endif\n\n \nstatic int\nextglob_skipname (pat, dname, flags)\n     char *pat, *dname;\n     int flags;\n{\n  char *pp, *pe, *t, *se;\n  int n, r, negate, wild, nullpat, xflags;\n\n  negate = *pat == '!';\n  wild = *pat == '*' || *pat == '?';\n  pp = pat + 2;\n  se = pp + strlen (pp);\t\t \n  pe = glob_patscan (pp, se, 0);\t \n\n   \n  if (pe == 0)\n    return 0;\n\n  xflags = flags | ( negate ? GX_NEGATE : 0);\n\n   \n  if (pe == se && *pe == 0 && pe[-1] == ')' && (t = strchr (pp, '|')) == 0)\n    {\n      pe[-1] = '\\0';\n       \n      r = XSKIPNAME (pp, dname, xflags);  \n      pe[-1] = ')';\n      return r;\n    }\n\n   \n  nullpat = pe >= (pat + 2) && pe[-2] == '(' && pe[-1] == ')';\n\n   \n  while (t = glob_patscan (pp, pe, '|'))\n    {\n       \n      n = t[-1];\t \n      if (extglob_pattern_p (pp) && n == ')')\t\t \n\tt[-1] = n;\t \n      else\n\tt[-1] = '\\0';\n      r = XSKIPNAME (pp, dname, xflags);\n      t[-1] = n;\n      if (r == 0)\t \n        return r;\n      pp = t;\n      if (pp == pe)\n\tbreak;\n    }\n\n   \n  if (pp == se)\n    return r;\n\n   \n  if (wild && *pe)\t \n    return (XSKIPNAME (pe, dname, flags));\n\n  return 1;\n}\n#endif\n\n \nstatic int\nskipname (pat, dname, flags)\n     char *pat;\n     char *dname;\n     int flags;\n{\n  int i;\n\n#if EXTENDED_GLOB\n  if (extglob_pattern_p (pat))\t\t \n    return (extglob_skipname (pat, dname, flags));\n#endif\n\n  if (glob_always_skip_dot_and_dotdot && DOT_OR_DOTDOT (dname))\n    return 1;\n\n   \n  if (noglob_dot_filenames == 0 && pat[0] != '.' &&\n\t(pat[0] != '\\\\' || pat[1] != '.') &&\n\tDOT_OR_DOTDOT (dname))\n    return 1;\n\n#if 0\n   \n  else if ((flags & GX_NEGATE) && noglob_dot_filenames == 0 &&\n\tdname[0] == '.' &&\n\t(pat[0] == '.' || (pat[0] == '\\\\' && pat[1] == '.')))\n    return 0;\n#endif\n\n   \n  else if (noglob_dot_filenames && dname[0] == '.' &&\n \t   pat[0] != '.' && (pat[0] != '\\\\' || pat[1] != '.'))\n    return 1;\n\n  return 0;\n}\n\n#if HANDLE_MULTIBYTE\n\nstatic int\nwskipname (pat, dname, flags)\n     wchar_t *pat, *dname;\n     int flags;\n{\n  int i;\n\n  if (glob_always_skip_dot_and_dotdot && WDOT_OR_DOTDOT (dname))\n    return 1;\n\n   \n  if (noglob_dot_filenames == 0 && pat[0] != L'.' &&\n\t(pat[0] != L'\\\\' || pat[1] != L'.') &&\n\tWDOT_OR_DOTDOT (dname))\n    return 1;\n\n#if 0\n   \n  else if ((flags & GX_NEGATE) && noglob_dot_filenames == 0 &&\n\tdname[0] == L'.' &&\n\t(pat[0] == L'.' || (pat[0] == L'\\\\' && pat[1] == L'.')))\n    return 0;\n#endif\n\n   \n  else if (noglob_dot_filenames && dname[0] == L'.' &&\n\tpat[0] != L'.' && (pat[0] != L'\\\\' || pat[1] != L'.'))\n    return 1;\n\n  return 0;\n}\n\nstatic int\nwextglob_skipname (pat, dname, flags)\n     wchar_t *pat, *dname;\n     int flags;\n{\n#if EXTENDED_GLOB\n  wchar_t *pp, *pe, *t, *se, n;\n  int r, negate, wild, nullpat, xflags;\n\n  negate = *pat == L'!';\n  wild = *pat == L'*' || *pat == L'?';\n  pp = pat + 2;\n  se = pp + wcslen (pp);\n  pe = glob_patscan_wc (pp, se, 0);\n\n   \n  if (pe == 0)\n    return 0;\n\n  xflags = flags | ( negate ? GX_NEGATE : 0);\n\n   \n  if (pe == se && *pe == L'\\0' && pe[-1] == L')' && (t = wcschr (pp, L'|')) == 0)\n    {\n      pe[-1] = L'\\0';\n      r = wskipname (pp, dname, xflags);  \n      pe[-1] = L')';\n      return r;\n    }\n\n   \n  nullpat = pe >= (pat + 2) && pe[-2] == L'(' && pe[-1] == L')';\n\n   \n  while (t = glob_patscan_wc (pp, pe, '|'))\n    {\n      n = t[-1];\t \n      if (wextglob_pattern_p (pp) && n == L')')\t\t \n\tt[-1] = n;\t \n      else\n\tt[-1] = L'\\0';\n      r = wskipname (pp, dname, xflags);\n      t[-1] = n;\n      if (r == 0)\n\treturn 0;\n      pp = t;\n      if (pp == pe)\n\tbreak;\n    }\n\n   \n  if (pp == se)\n    return r;\n\n   \n  if (wild && *pe != L'\\0')\n    return (wskipname (pe, dname, flags));\n\n  return 1;\n#else\n  return (wskipname (pat, dname, flags));\n#endif\n}\n\n \nstatic int\nmbskipname (pat, dname, flags)\n     char *pat, *dname;\n     int flags;\n{\n  int ret, ext;\n  wchar_t *pat_wc, *dn_wc;\n  size_t pat_n, dn_n;\n\n  if (mbsmbchar (dname) == 0 && mbsmbchar (pat) == 0)\n    return (skipname (pat, dname, flags));\n\n  ext = 0;\n#if EXTENDED_GLOB\n  ext = extglob_pattern_p (pat);\n#endif\n\n  pat_wc = dn_wc = (wchar_t *)NULL;\n\n  pat_n = xdupmbstowcs (&pat_wc, NULL, pat);\n  if (pat_n != (size_t)-1)\n    dn_n = xdupmbstowcs (&dn_wc, NULL, dname);\n\n  ret = 0;\n  if (pat_n != (size_t)-1 && dn_n !=(size_t)-1)\n    ret = ext ? wextglob_skipname (pat_wc, dn_wc, flags) : wskipname (pat_wc, dn_wc, flags);\n  else\n    ret = skipname (pat, dname, flags);\n\n  FREE (pat_wc);\n  FREE (dn_wc);\n\n  return ret;\n}\n#endif  \n\n \nvoid\nudequote_pathname (pathname)\n     char *pathname;\n{\n  register int i, j;\n\n  for (i = j = 0; pathname && pathname[i]; )\n    {\n      if (pathname[i] == '\\\\')\n\ti++;\n\n      pathname[j++] = pathname[i++];\n\n      if (pathname[i - 1] == 0)\n\tbreak;\n    }\n  if (pathname)\n    pathname[j] = '\\0';\n}\n\n#if HANDLE_MULTIBYTE\n \nvoid\nwcdequote_pathname (wpathname)\n     wchar_t *wpathname;\n{\n  int i, j;\n\n  for (i = j = 0; wpathname && wpathname[i]; )\n    {\n      if (wpathname[i] == L'\\\\')\n\ti++;\n\n      wpathname[j++] = wpathname[i++];\n\n      if (wpathname[i - 1] == L'\\0')\n\tbreak;\n    }\n  if (wpathname)\n    wpathname[j] = L'\\0';\n}\n\nstatic void\nwdequote_pathname (pathname)\n     char *pathname;\n{\n  mbstate_t ps;\n  size_t len, n;\n  wchar_t *wpathname;\n  int i, j;\n  wchar_t *orig_wpathname;\n\n  if (mbsmbchar (pathname) == 0)\n    {\n      udequote_pathname (pathname);\n      return;\n    }\n\n  len = strlen (pathname);\n   \n  n = xdupmbstowcs (&wpathname, NULL, pathname);\n  if (n == (size_t) -1)\n    {\n       \n      udequote_pathname (pathname);\n      return;\n    }\n  orig_wpathname = wpathname;\n\n  wcdequote_pathname (wpathname);\n\n   \n  memset (&ps, '\\0', sizeof(mbstate_t));\n  n = wcsrtombs(pathname, (const wchar_t **)&wpathname, len, &ps);\n  if (n == (size_t)-1 || (wpathname && *wpathname != 0))\t \n    {\n      wpathname = orig_wpathname;\n      memset (&ps, '\\0', sizeof(mbstate_t));\n      n = xwcsrtombs (pathname, (const wchar_t **)&wpathname, len, &ps);\n    }\n  pathname[len] = '\\0';\n\n   \n  free (orig_wpathname);\n}\n\nstatic void\ndequote_pathname (pathname)\n     char *pathname;\n{\n  if (MB_CUR_MAX > 1)\n    wdequote_pathname (pathname);\n  else\n    udequote_pathname (pathname);\n}\n#endif  \n\n \n\n#if defined (HAVE_LSTAT)\n#  define GLOB_TESTNAME(name)  (lstat (name, &finfo))\n#else  \n#  if !defined (AFS)\n#    define GLOB_TESTNAME(name)  (sh_eaccess (name, F_OK))\n#  else  \n#    define GLOB_TESTNAME(name)  (access (name, F_OK))\n#  endif  \n#endif  \n\n \nstatic int\nglob_testdir (dir, flags)\n     char *dir;\n     int flags;\n{\n  struct stat finfo;\n  int r;\n\n \n#if defined (HAVE_LSTAT)\n  r = (flags & GX_ALLDIRS) ? lstat (dir, &finfo) : stat (dir, &finfo);\n#else\n  r = stat (dir, &finfo);\n#endif\n  if (r < 0)\n    return (-1);\n\n#if defined (S_ISLNK)\n  if (S_ISLNK (finfo.st_mode))\n    return (-2);\n#endif\n\n  if (S_ISDIR (finfo.st_mode) == 0)\n    return (-1);\n\n  return (0);\n}\n\n \nstatic struct globval *\nfinddirs (pat, sdir, flags, ep, np)\n     char *pat;\n     char *sdir;\n     int flags;\n     struct globval **ep;\n     int *np;\n{\n  char **r, *n;\n  int ndirs;\n  struct globval *ret, *e, *g;\n\n \n  e = ret = 0;\n  r = glob_vector (pat, sdir, flags);\n  if (r == 0 || r[0] == 0)\n    {\n      if (np)\n\t*np = 0;\n      if (ep)\n        *ep = 0;\n      if (r && r != &glob_error_return)\n\tfree (r);\n      return (struct globval *)0;\n    }\n  for (ndirs = 0; r[ndirs] != 0; ndirs++)\n    {\n      g = (struct globval *) malloc (sizeof (struct globval));\n      if (g == 0)\n\t{\n\t  while (ret)\t\t \n\t    {\n\t      g = ret->next;\n\t      free (ret);\n\t      ret = g;\n\t    }\n\n\t  free (r);\n\t  if (np)\n\t    *np = 0;\n\t  if (ep)\n\t    *ep = 0;\n\t  return (&finddirs_error_return);\n\t}\n      if (e == 0)\n\te = g;\n\n      g->next = ret;\n      ret = g;\n\n      g->name = r[ndirs];\n    }\n\n  free (r);\n  if (ep)\n    *ep = e;\n  if (np)\n    *np = ndirs;\n\n  return ret;\n}\n     \t\n \n\nchar **\nglob_vector (pat, dir, flags)\n     char *pat;\n     char *dir;\n     int flags;\n{\n  DIR *d;\n  register struct dirent *dp;\n  struct globval *lastlink, *e, *dirlist;\n  register struct globval *nextlink;\n  register char *nextname, *npat, *subdir;\n  unsigned int count;\n  int lose, skip, ndirs, isdir, sdlen, add_current, patlen;\n  register char **name_vector;\n  register unsigned int i;\n  int mflags;\t\t \n  int pflags;\t\t \n  int hasglob;\t\t \n  int nalloca;\n  struct globval *firstmalloc, *tmplink;\n  char *convfn;\n\n  lastlink = 0;\n  count = lose = skip = add_current = 0;\n\n  firstmalloc = 0;\n  nalloca = 0;\n\n  name_vector = NULL;\n\n \n   \n  if (pat == 0 || *pat == '\\0')\n    {\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n\n      nextlink = (struct globval *)alloca (sizeof (struct globval));\n      if (nextlink == NULL)\n\treturn ((char **) NULL);\n\n      nextlink->next = (struct globval *)0;\n      nextname = (char *) malloc (1);\n      if (nextname == 0)\n\tlose = 1;\n      else\n\t{\n\t  lastlink = nextlink;\n\t  nextlink->name = nextname;\n\t  nextname[0] = '\\0';\n\t  count = 1;\n\t}\n\n      skip = 1;\n    }\n\n  patlen = (pat && *pat) ? strlen (pat) : 0;\n\n   \n  hasglob = 0;\n  if (skip == 0 && ((hasglob = glob_pattern_p (pat)) == 0 || hasglob == 2))\n    {\n      int dirlen;\n      struct stat finfo;\n\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n\n      dirlen = strlen (dir);\n      nextname = (char *)malloc (dirlen + patlen + 2);\n      npat = (char *)malloc (patlen + 1);\n      if (nextname == 0 || npat == 0)\n\t{\n\t  FREE (nextname);\n\t  FREE (npat);\n\t  lose = 1;\n\t}\n      else\n\t{\n\t  strcpy (npat, pat);\n\t  dequote_pathname (npat);\n\n\t  strcpy (nextname, dir);\n\t  nextname[dirlen++] = '/';\n\t  strcpy (nextname + dirlen, npat);\n\n\t  if (GLOB_TESTNAME (nextname) >= 0)\n\t    {\n\t      free (nextname);\n\t      nextlink = (struct globval *)alloca (sizeof (struct globval));\n\t      if (nextlink)\n\t\t{\n\t\t  nextlink->next = (struct globval *)0;\n\t\t  lastlink = nextlink;\n\t\t  nextlink->name = npat;\n\t\t  count = 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  free (npat);\n\t\t  lose = 1;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      free (nextname);\n\t      free (npat);\n\t    }\n\t}\n\n      skip = 1;\n    }\n\n  if (skip == 0)\n    {\n       \n#if defined (OPENDIR_NOT_ROBUST)\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n#endif\n\n      d = opendir (dir);\n      if (d == NULL)\n\treturn ((char **) &glob_error_return);\n\n       \n      mflags = (noglob_dot_filenames ? FNM_PERIOD : FNM_DOTDOT) | FNM_PATHNAME;\n\n#ifdef FNM_CASEFOLD\n      if (glob_ignore_case)\n\tmflags |= FNM_CASEFOLD;\n#endif\n\n      if (extended_glob)\n\tmflags |= FNM_EXTMATCH;\n\n      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));\n\n       \n      while (1)\n\t{\n\t   \n\t  if (interrupt_state || terminating_signal)\n\t    {\n\t      lose = 1;\n\t      break;\n\t    }\n\t  else if (signal_is_pending (SIGINT))\t \n\t    {\n\t      lose = 1;\n\t      break;\n\t    }\n\n\t  dp = readdir (d);\n\t  if (dp == NULL)\n\t    break;\n\n\t   \n\t  if (REAL_DIR_ENTRY (dp) == 0)\n\t    continue;\n\n#if 0\n\t  if (dp->d_name == 0 || *dp->d_name == 0)\n\t    continue;\n#endif\n\n#if HANDLE_MULTIBYTE\n\t  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))\n\t    continue;\n\t  else\n#endif\n\t  if (skipname (pat, dp->d_name, flags))\n\t    continue;\n\n\t   \n\t  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))\n\t    {\n\t      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;\n\t      if (flags & GX_NULLDIR)\n\t\tpflags |= MP_IGNDOT;\n\t      subdir = sh_makepath (dir, dp->d_name, pflags);\n\t      isdir = glob_testdir (subdir, flags);\n\t      if (isdir < 0 && (flags & GX_MATCHDIRS))\n\t\t{\n\t\t  free (subdir);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  if (flags & GX_ALLDIRS)\n\t    {\n\t      if (isdir == 0)\n\t\t{\n\t\t  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);\n\t\t  if (dirlist == &finddirs_error_return)\n\t\t    {\n\t\t      free (subdir);\n\t\t      lose = 1;\n\t\t      break;\n\t\t    }\n\t\t  if (ndirs)\t\t \n\t\t    {\n\t\t      if (firstmalloc == 0)\n\t\t        firstmalloc = e;\n\t\t      e->next = lastlink;\n\t\t      lastlink = dirlist;\n\t\t      count += ndirs;\n\t\t    }\n\t\t}\n\n\t       \n\t      nextlink = (struct globval *) malloc (sizeof (struct globval));\n\t      if (firstmalloc == 0)\n\t\tfirstmalloc = nextlink;\n\t      sdlen = strlen (subdir);\n\t      nextname = (char *) malloc (sdlen + 1);\n\t      if (nextlink == 0 || nextname == 0)\n\t\t{\n\t\t  if (firstmalloc && firstmalloc == nextlink)\n\t\t    firstmalloc = 0;\n\t\t   \n\t\t  FREE (nextlink);\n\t\t  FREE (nextname);\n\t\t  free (subdir);\n\t\t  lose = 1;\n\t\t  break;\n\t\t}\n\t      nextlink->next = lastlink;\n\t      lastlink = nextlink;\n\t      nextlink->name = nextname;\n\t      bcopy (subdir, nextname, sdlen + 1);\n\t      free (subdir);\n\t      ++count;\n\t      continue;\n\t    }\n\t  else if (flags & GX_MATCHDIRS)\n\t    free (subdir);\n\n\t  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));\n\t  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)\n\t    {\n\t      if (nalloca < ALLOCA_MAX)\n\t\t{\n\t\t  nextlink = (struct globval *) alloca (sizeof (struct globval));\n\t\t  nalloca += sizeof (struct globval);\n\t\t}\n\t      else\n\t\t{\n\t\t  nextlink = (struct globval *) malloc (sizeof (struct globval));\n\t\t  if (firstmalloc == 0)\n\t\t    firstmalloc = nextlink;\n\t\t}\n\n\t      nextname = (char *) malloc (D_NAMLEN (dp) + 1);\n\t      if (nextlink == 0 || nextname == 0)\n\t\t{\n\t\t   \n\t\t  if (firstmalloc)\n\t\t    {\n\t\t      if (firstmalloc == nextlink)\n\t\t\tfirstmalloc = 0;\n\t\t      FREE (nextlink);\n\t\t    }\n\t\t  FREE (nextname);\n\t\t  lose = 1;\n\t\t  break;\n\t\t}\n\t      nextlink->next = lastlink;\n\t      lastlink = nextlink;\n\t      nextlink->name = nextname;\n\t      bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1);\n\t      ++count;\n\t    }\n\t}\n\n      (void) closedir (d);\n    }\n\n   \n  if (add_current && lose == 0)\n    {\n      sdlen = strlen (dir);\n      nextname = (char *)malloc (sdlen + 1);\n      nextlink = (struct globval *) malloc (sizeof (struct globval));\n      if (nextlink == 0 || nextname == 0)\n\t{\n\t  FREE (nextlink);\n\t  FREE (nextname);\n\t  lose = 1;\n\t}\n      else\n\t{\n\t  nextlink->name = nextname;\n\t  nextlink->next = lastlink;\n\t  lastlink = nextlink;\n\t  if (flags & GX_NULLDIR)\n\t    nextname[0] = '\\0';\n\t  else\n\t    bcopy (dir, nextname, sdlen + 1);\n\t  ++count;\n\t}\n    }\n\n  if (lose == 0)\n    {\n      name_vector = (char **) malloc ((count + 1) * sizeof (char *));\n      lose |= name_vector == NULL;\n    }\n\n   \n  if (lose)\n    {\n      tmplink = 0;\n\n       \n      while (lastlink)\n\t{\n\t   \n\t  if (firstmalloc)\n\t    {\n\t      if (lastlink == firstmalloc)\n\t\tfirstmalloc = 0;\n\t      tmplink = lastlink;\n\t    }\n\t  else\n\t    tmplink = 0;\n\t  free (lastlink->name);\n\t  lastlink = lastlink->next;\n\t  FREE (tmplink);\n\t}\n\n       \n\n      return ((char **)NULL);\n    }\n\n   \n  for (tmplink = lastlink, i = 0; i < count; ++i)\n    {\n      name_vector[i] = tmplink->name;\n      tmplink = tmplink->next;\n    }\n\n  name_vector[count] = NULL;\n\n   \n  if (firstmalloc)\n    {\n      tmplink = 0;\n      while (lastlink)\n\t{\n\t  tmplink = lastlink;\n\t  if (lastlink == firstmalloc)\n\t    lastlink = firstmalloc = 0;\n\t  else\n\t    lastlink = lastlink->next;\n\t  free (tmplink);\n\t}\n    }\n\n  return (name_vector);\n}\n\n \nstatic char **\nglob_dir_to_array (dir, array, flags)\n     char *dir, **array;\n     int flags;\n{\n  register unsigned int i, l;\n  int add_slash;\n  char **result, *new;\n  struct stat sb;\n\n  l = strlen (dir);\n  if (l == 0)\n    {\n      if (flags & GX_MARKDIRS)\n\tfor (i = 0; array[i]; i++)\n\t  {\n\t    if ((stat (array[i], &sb) == 0) && S_ISDIR (sb.st_mode))\n\t      {\n\t\tl = strlen (array[i]);\n\t\tnew = (char *)realloc (array[i], l + 2);\n\t\tif (new == 0)\n\t\t  return NULL;\n\t\tnew[l] = '/';\n\t\tnew[l+1] = '\\0';\n\t\tarray[i] = new;\n\t      }\n\t  }\n      return (array);\n    }\n\n  add_slash = dir[l - 1] != '/';\n\n  i = 0;\n  while (array[i] != NULL)\n    ++i;\n\n  result = (char **) malloc ((i + 1) * sizeof (char *));\n  if (result == NULL)\n    return (NULL);\n\n  for (i = 0; array[i] != NULL; i++)\n    {\n       \n      result[i] = (char *) malloc (l + strlen (array[i]) + 3);\n\n      if (result[i] == NULL)\n\t{\n\t  int ind;\n\t  for (ind = 0; ind < i; ind++)\n\t    free (result[ind]);\n\t  free (result);\n\t  return (NULL);\n\t}\n\n      strcpy (result[i], dir);\n      if (add_slash)\n\tresult[i][l] = '/';\n      if (array[i][0])\n\t{\n\t  strcpy (result[i] + l + add_slash, array[i]);\n\t  if (flags & GX_MARKDIRS)\n\t    {\n\t      if ((stat (result[i], &sb) == 0) && S_ISDIR (sb.st_mode))\n\t\t{\n\t\t  size_t rlen;\n\t\t  rlen = strlen (result[i]);\n\t\t  result[i][rlen] = '/';\n\t\t  result[i][rlen+1] = '\\0';\n\t\t}\n\t    }\n\t}\n      else\n        result[i][l+add_slash] = '\\0';\n    }\n  result[i] = NULL;\n\n   \n  for (i = 0; array[i] != NULL; i++)\n    free (array[i]);\n  free ((char *) array);\n\n  return (result);\n}\n\n \nchar **\nglob_filename (pathname, flags)\n     char *pathname;\n     int flags;\n{\n  char **result, **new_result;\n  unsigned int result_size;\n  char *directory_name, *filename, *dname, *fn;\n  unsigned int directory_len;\n  int free_dirname;\t\t\t \n  int dflags, hasglob;\n\n  result = (char **) malloc (sizeof (char *));\n  result_size = 1;\n  if (result == NULL)\n    return (NULL);\n\n  result[0] = NULL;\n\n  directory_name = NULL;\n\n   \n  filename = strrchr (pathname, '/');\n#if defined (EXTENDED_GLOB)\n  if (filename && extended_glob)\n    {\n      fn = glob_dirscan (pathname, '/');\n#if DEBUG_MATCHING\n      if (fn != filename)\n\tfprintf (stderr, \"glob_filename: glob_dirscan: fn (%s) != filename (%s)\\n\", fn ? fn : \"(null)\", filename);\n#endif\n      filename = fn;\n    }\n#endif\n\n  if (filename == NULL)\n    {\n      filename = pathname;\n      directory_name = \"\";\n      directory_len = 0;\n      free_dirname = 0;\n    }\n  else\n    {\n      directory_len = (filename - pathname) + 1;\n      directory_name = (char *) malloc (directory_len + 1);\n\n      if (directory_name == 0)\t\t \n\t{\n\t  free (result);\n\t  return (NULL);\n\t}\n\n      bcopy (pathname, directory_name, directory_len);\n      directory_name[directory_len] = '\\0';\n      ++filename;\n      free_dirname = 1;\n    }\n\n  hasglob = 0;\n   \n  if (directory_len > 0 && (hasglob = glob_pattern_p (directory_name)) == 1)\n    {\n      char **directories, *d, *p;\n      register unsigned int i;\n      int all_starstar, last_starstar;\n\n      all_starstar = last_starstar = 0;\n      d = directory_name;\n      dflags = flags & ~GX_MARKDIRS;\n       \n      if ((flags & GX_GLOBSTAR) && d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\\0'))\n\t{\n\t  p = d;\n\t  while (d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\\0'))\n\t    {\n\t      p = d;\n\t      if (d[2])\n\t\t{\n\t\t  d += 3;\n\t\t  while (*d == '/')\n\t\t    d++;\n\t\t  if (*d == 0)\n\t\t    break;\n\t\t}\n\t    }\n\t  if (*d == 0)\n\t    all_starstar = 1;\n\t  d = p;\n\t  dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n\t  directory_len = strlen (d);\n\t}\n\n       \n      if ((flags & GX_GLOBSTAR) && all_starstar == 0)\n\t{\n\t  int dl, prev;\n\t  prev = dl = directory_len;\n\t  while (dl >= 4 && d[dl - 1] == '/' &&\n\t\t\t   d[dl - 2] == '*' &&\n\t\t\t   d[dl - 3] == '*' &&\n\t\t\t   d[dl - 4] == '/')\n\t    prev = dl, dl -= 3;\n\t  if (dl != directory_len)\n\t    last_starstar = 1;\n\t  directory_len = prev;\n\t}\n\n       \n      if (last_starstar && directory_len > 4 &&\n\t    filename[0] == '*' && filename[1] == '*' && filename[2] == 0)\n\t{\n\t  directory_len -= 3;\n\t}\n\n      if (d[directory_len - 1] == '/')\n\td[directory_len - 1] = '\\0';\n\n      directories = glob_filename (d, dflags|GX_RECURSE);\n\n      if (free_dirname)\n\t{\n\t  free (directory_name);\n\t  directory_name = NULL;\n\t}\n\n      if (directories == NULL)\n\tgoto memory_error;\n      else if (directories == (char **)&glob_error_return)\n\t{\n\t  free ((char *) result);\n\t  return ((char **) &glob_error_return);\n\t}\n      else if (*directories == NULL)\n\t{\n\t  free ((char *) directories);\n\t  free ((char *) result);\n\t  return ((char **) &glob_error_return);\n\t}\n\n       \n      if (all_starstar && filename[0] == '*' && filename[1] == '*' && filename[2] == 0)\n\t{\n\t  free ((char *) directories);\n\t  free (directory_name);\n\t  directory_name = NULL;\n\t  directory_len = 0;\n\t  goto only_filename;\n\t}\n\n       \n      for (i = 0; directories[i] != NULL; ++i)\n\t{\n\t  char **temp_results;\n\t  int shouldbreak;\n\n\t  shouldbreak = 0;\n\t   \n\t   \n\t  dname = directories[i];\n\t  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);\n\t   \n\t  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t    dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n\t  if (dname[0] == '\\0' && filename[0])\n\t    {\n\t      dflags |= GX_NULLDIR;\n\t      dname = \".\";\t \n\t    }\n\n\t   \n\t  if (all_starstar && (dflags & GX_NULLDIR) == 0)\n\t    {\n\t      int dlen;\n\n\t       \n\t      if (glob_testdir (dname, flags|GX_ALLDIRS) == -2 && glob_testdir (dname, 0) == 0)\n\t\t{\n\t\t  if (filename[0] != 0)\n\t\t    temp_results = (char **)&glob_error_return;\t\t \n\t\t  else\n\t\t    {\n\t\t       \n\t\t      temp_results = (char **)malloc (2 * sizeof (char *));\n\t\t      if (temp_results == NULL)\n\t\t\tgoto memory_error;\n\t\t      temp_results[0] = (char *)malloc (1);\n\t\t      if (temp_results[0] == 0)\n\t\t\t{\n\t\t\t  free (temp_results);\n\t\t\t  goto memory_error;\n\t\t\t}\n\t\t      **temp_results = '\\0';\n\t\t      temp_results[1] = NULL;\n\t\t      dflags |= GX_SYMLINK;\t \n\t\t    }\n\t\t}\n\t      else\n\t\ttemp_results = glob_vector (filename, dname, dflags);\n\t    }\n\t  else\n\t    temp_results = glob_vector (filename, dname, dflags);\n\n\t   \n\t  if (temp_results == NULL)\n\t    goto memory_error;\n\t  else if (temp_results == (char **)&glob_error_return)\n\t     \n\t    ;\n\t  else\n\t    {\n\t      char **array;\n\t      register unsigned int l;\n\n\t       \n\t      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && (filename[2] == '\\0' || filename[2] == '/'))\n\t\t{\n\t\t   \n\t\t   \n\t\t   \n#define NULL_PLACEHOLDER(x)\t((x) && *(x) && **(x) == 0)\n\t\t  if ((dflags & GX_NULLDIR) && (flags & GX_NULLDIR) == 0 &&\n\t\t\tNULL_PLACEHOLDER (temp_results))\n#undef NULL_PLACEHOLDER\n\t\t    {\n\t\t      register int i, n;\n\t\t      for (n = 0; temp_results[n] && *temp_results[n] == 0; n++)\n\t\t\t;\n\t\t      i = n;\n\t\t      do\n\t\t\ttemp_results[i - n] = temp_results[i];\n\t\t      while (temp_results[i++] != 0);\n\t\t      array = temp_results;\n\t\t      shouldbreak = 1;\n\t\t    }\n\t          else\n\t\t    array = temp_results;\n\t\t}\n\t      else if (dflags & GX_SYMLINK)\n\t\tarray = glob_dir_to_array (directories[i], temp_results, flags);\n\t      else\n\t\tarray = glob_dir_to_array (directories[i], temp_results, flags);\n\t      l = 0;\n\t      while (array[l] != NULL)\n\t\t++l;\n\n\t      new_result = (char **)realloc (result, (result_size + l) * sizeof (char *));\n\n\t      if (new_result == NULL)\n\t\t{\n\t\t  for (l = 0; array[l]; ++l)\n\t\t    free (array[l]);\n\t\t  free ((char *)array);\n\t\t  goto memory_error;\n\t\t}\n\t      result = new_result;\n\n\t      for (l = 0; array[l] != NULL; ++l)\n\t\tresult[result_size++ - 1] = array[l];\n\n\t      result[result_size - 1] = NULL;\n\n\t       \n\t      if (array != temp_results)\n\t\tfree ((char *) array);\n\t      else if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t\tfree (temp_results);\t \n\n\t      if (shouldbreak)\n\t\tbreak;\n\t    }\n\t}\n       \n      for (i = 0; directories[i]; i++)\n\tfree (directories[i]);\n\n      free ((char *) directories);\n\n      return (result);\n    }\n\nonly_filename:\n   \n  if (*filename == '\\0')\n    {\n      result = (char **) realloc ((char *) result, 2 * sizeof (char *));\n      if (result == NULL)\n\t{\n\t  if (free_dirname)\n\t    free (directory_name);\n\t  return (NULL);\n\t}\n       \n      if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) != 0)\n\t{\n\t  dequote_pathname (directory_name);\n\t  directory_len = strlen (directory_name);\n\t}\n\n       \n\n      if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) == 0)\n\t{\n\t  dequote_pathname (directory_name);\n\t  if (glob_testdir (directory_name, 0) < 0)\n\t    {\n\t      if (free_dirname)\n\t\tfree (directory_name);\n\t      free ((char *) result);\n\t      return ((char **)&glob_error_return);\n\t    }\n\t}\n\n       \n      result[0] = (char *) malloc (directory_len + 1);\n      if (result[0] == NULL)\n\tgoto memory_error;\n      bcopy (directory_name, result[0], directory_len + 1);\n      if (free_dirname)\n\tfree (directory_name);\n      result[1] = NULL;\n      return (result);\n    }\n  else\n    {\n      char **temp_results;\n\n       \n      if (directory_len > 0)\n\tdequote_pathname (directory_name);\n\n       \n      free (result);\n\n       \n       \n      dflags = flags & ~GX_MARKDIRS;\n      if (directory_len == 0)\n\tdflags |= GX_NULLDIR;\n      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t{\n\t  dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n#if 0\n\t   \n#endif\n\t  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)\n\t    dflags &= ~GX_ADDCURDIR;\n\t}\n      temp_results = glob_vector (filename,\n\t\t\t\t  (directory_len == 0 ? \".\" : directory_name),\n\t\t\t\t  dflags);\n\n      if (temp_results == NULL || temp_results == (char **)&glob_error_return)\n\t{\n\t  if (free_dirname)\n\t    free (directory_name);\n\t  QUIT;\t\t\t \n\t  run_pending_traps ();\n\t  return (temp_results);\n\t}\n\n      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? \"\" : directory_name, temp_results, flags);\n\n      if (free_dirname)\n\tfree (directory_name);\n      return (result);\n    }\n\n   \n memory_error:\n  if (result != NULL)\n    {\n      register unsigned int i;\n      for (i = 0; result[i] != NULL; ++i)\n\tfree (result[i]);\n      free ((char *) result);\n    }\n\n  if (free_dirname && directory_name)\n    free (directory_name);\n\n  QUIT;\n  run_pending_traps ();\n\n  return (NULL);\n}\n\n#if defined (TEST)\n\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  unsigned int i;\n\n  for (i = 1; i < argc; ++i)\n    {\n      char **value = glob_filename (argv[i], 0);\n      if (value == NULL)\n\tputs (\"Out of memory.\");\n      else if (value == &glob_error_return)\n\tperror (argv[i]);\n      else\n\tfor (i = 0; value[i] != NULL; i++)\n\t  puts (value[i]);\n    }\n\n  exit (0);\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}