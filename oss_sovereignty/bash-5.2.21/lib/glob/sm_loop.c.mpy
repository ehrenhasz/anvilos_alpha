{
  "module_name": "sm_loop.c",
  "hash_id": "92c22ce3a72f6fd91e4822be0c59fc1c99ac8603d2913d13e6d4f6f9e0a28c29",
  "original_prompt": "Ingested from bash-5.2.21/lib/glob/sm_loop.c",
  "human_readable_source": " \n\nextern int interrupt_state, terminating_signal;\n\nstruct STRUCT\n{\n  CHAR *pattern;\n  CHAR *string;\n};\n\nint FCT PARAMS((CHAR *, CHAR *, int));\n\nstatic int GMATCH PARAMS((CHAR *, CHAR *, CHAR *, CHAR *, struct STRUCT *, int));\nstatic CHAR *PARSE_COLLSYM PARAMS((CHAR *, INT *));\nstatic CHAR *BRACKMATCH PARAMS((CHAR *, U_CHAR, int));\nstatic int EXTMATCH PARAMS((INT, CHAR *, CHAR *, CHAR *, CHAR *, int));\n\nextern void DEQUOTE_PATHNAME PARAMS((CHAR *));\n\n  CHAR *PATSCAN PARAMS((CHAR *, CHAR *, INT));\n\nint\nFCT (pattern, string, flags)\n     CHAR *pattern;\n     CHAR *string;\n     int flags;\n{\n  CHAR *se, *pe;\n\n  if (string == 0 || pattern == 0)\n    return FNM_NOMATCH;\n\n  se = string + STRLEN ((XCHAR *)string);\n  pe = pattern + STRLEN ((XCHAR *)pattern);\n\n  return (GMATCH (string, se, pattern, pe, (struct  STRUCT *)NULL, flags));\n}\n\n \nstatic int\nGMATCH (string, se, pattern, pe, ends, flags)\n     CHAR *string, *se;\n     CHAR *pattern, *pe;\n     struct STRUCT *ends;\n     int flags;\n{\n  CHAR *p, *n;\t\t \n  INT c;\t\t \n  INT sc;\t\t \n\n  p = pattern;\n  n = string;\n\n  if (string == 0 || pattern == 0)\n    return FNM_NOMATCH;\n\n#if DEBUG_MATCHING\nfprintf(stderr, \"gmatch: string = %s; se = %s\\n\", string, se);\nfprintf(stderr, \"gmatch: pattern = %s; pe = %s\\n\", pattern, pe);\n#endif\n\n  while (p < pe)\n    {\n      c = *p++;\n      c = FOLD (c);\n\n      sc = n < se ? *n : '\\0';\n\n      if (interrupt_state || terminating_signal)\n\treturn FNM_NOMATCH;\n\n#ifdef EXTENDED_GLOB\n       \n      if ((flags & FNM_EXTMATCH) && *p == L('(') &&\n\t  (c == L('+') || c == L('*') || c == L('?') || c == L('@') || c == L('!')))  \n\t{\n\t  int lflags;\n\t   \n\t  lflags = (n == string) ? flags : (flags & ~(FNM_PERIOD|FNM_DOTDOT));\n\t  return (EXTMATCH (c, n, se, p, pe, lflags));\n\t}\n#endif  \n\n      switch (c)\n\t{\n\tcase L('?'):\t\t \n\t  if (sc == '\\0')\n\t    return FNM_NOMATCH;\n\t  else if ((flags & FNM_PATHNAME) && sc == L('/'))\n\t     \n\t    return FNM_NOMATCH;\n\t  else if ((flags & FNM_PERIOD) && sc == L('.') &&\n\t\t   (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))\n\t     \n\t    return FNM_NOMATCH;\n\n\t   \n\t  if ((flags & FNM_DOTDOT) &&\n\t      ((n == string && SDOT_OR_DOTDOT(n)) ||\n\t       ((flags & FNM_PATHNAME) && n[-1] == L('/') && PDOT_OR_DOTDOT(n))))\n\t    return FNM_NOMATCH;\n\n\t  break;\n\n\tcase L('\\\\'):\t\t \n\t  if (p == pe && sc == '\\\\' && (n+1 == se))\n\t    break;\n\n\t  if (p == pe)\n\t    return FNM_NOMATCH;\n\n\t  if ((flags & FNM_NOESCAPE) == 0)\n\t    {\n\t      c = *p++;\n\t       \n\t      if (p > pe)\n\t\treturn FNM_NOMATCH;\n\t      c = FOLD (c);\n\t    }\n\t  if (FOLD (sc) != (U_CHAR)c)\n\t    return FNM_NOMATCH;\n\t  break;\n\n\tcase L('*'):\t\t \n\t   \n\t  if (ends != NULL)\n\t    {\n\t      ends->pattern = p - 1;\n\t      ends->string = n;\n\t      return (0);\n\t    }\n\n\t  if ((flags & FNM_PERIOD) && sc == L('.') &&\n\t      (n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))\n\t     \n\t    return FNM_NOMATCH;\n\n\t   \n\t  if ((flags & FNM_DOTDOT) &&\n\t      ((n == string && SDOT_OR_DOTDOT(n)) ||\n\t       ((flags & FNM_PATHNAME) && n[-1] == L('/') && PDOT_OR_DOTDOT(n))))\n\t    return FNM_NOMATCH;\n\n\t  if (p == pe)\n\t    return 0;\n\n\t   \n\t  for (c = *p++; (c == L('?') || c == L('*')); c = *p++)\n\t    {\n\t      if ((flags & FNM_PATHNAME) && sc == L('/'))\n\t\t \n\t\treturn FNM_NOMATCH;\n#ifdef EXTENDED_GLOB\n\t      else if ((flags & FNM_EXTMATCH) && c == L('?') && *p == L('('))  \n\t\t{\n\t\t  CHAR *newn;\n\n\t\t   \n\t\t  if (EXTMATCH (c, n, se, p, pe, flags) == 0)\n\t\t    return (0);\n\n\t\t   \n\t\t  newn = PATSCAN (p + 1, pe, 0);\n\t\t   \n\t\t  p = newn ? newn : pe;\n\t\t}\n#endif\n\t      else if (c == L('?'))\n\t\t{\n\t\t  if (sc == L('\\0'))\n\t\t    return FNM_NOMATCH;\n\t\t   \n\t\t  n++;\n\t\t  sc = n < se ? *n : '\\0';\n\t\t}\n\n#ifdef EXTENDED_GLOB\n\t       \n\t      if ((flags & FNM_EXTMATCH) && c == L('*') && *p == L('('))   \n\t\t{\n\t\t  CHAR *newn;\n\t\t   \n\t\t  for (newn = n; newn < se; ++newn)\n\t\t    {\n\t\t      if (EXTMATCH (c, newn, se, p, pe, flags) == 0)\n\t\t\treturn (0);\n\t\t    }\n\t\t   \n\t\t  newn = PATSCAN (p + 1, pe, 0);\n\t\t   \n\t\t  p = newn ? newn : pe;\n\t\t}\n#endif\n\t      if (p == pe)\n\t\tbreak;\n\t    }\n\n\t   \n\t  if (c == L('\\0'))\n\t    {\n\t      int r = (flags & FNM_PATHNAME) == 0 ? 0 : FNM_NOMATCH;\n\t      if (flags & FNM_PATHNAME)\n\t\t{\n\t\t  if (flags & FNM_LEADING_DIR)\n\t\t    r = 0;\n\t\t  else if (MEMCHR (n, L('/'), se - n) == NULL)\n\t\t    r = 0;\n\t\t}\n\t      return r;\n\t    }\n\n\t   \n\t  if (p == pe && (c == L('?') || c == L('*')))\n\t    return (0);\n\n\t   \n#if defined (EXTENDED_GLOB)\n\t  if (n == se && ((flags & FNM_EXTMATCH) && (c == L('!') || c == L('?')) && *p == L('(')))\n\t    {\n\t      --p;\n\t      if (EXTMATCH (c, n, se, p, pe, flags) == 0)\n\t\treturn (c == L('!') ? FNM_NOMATCH : 0);\n\t      return (c == L('!') ? 0 : FNM_NOMATCH);\n\t    }\n#endif\n\n\t   \n\t  if (c == L('/') && (flags & FNM_PATHNAME))\n\t    {\n\t      while (n < se && *n != L('/'))\n\t\t++n;\n\t      if (n < se && *n == L('/') && (GMATCH (n+1, se, p, pe, NULL, flags) == 0))\n\t\treturn 0;\n\t      return FNM_NOMATCH;\t \n\t    }\n\n\t   \n\t  {\n\t    U_CHAR c1;\n\t    const CHAR *endp;\n\t    struct STRUCT end;\n\n\t    end.pattern = NULL;\n\t    endp = MEMCHR (n, (flags & FNM_PATHNAME) ? L('/') : L('\\0'), se - n);\n\t    if (endp == 0)\n\t      endp = se;\n\n\t    c1 = ((flags & FNM_NOESCAPE) == 0 && c == L('\\\\')) ? *p : c;\n\t    c1 = FOLD (c1);\n\t    for (--p; n < endp; ++n)\n\t      {\n\t\t \n\t\tif ((flags & FNM_EXTMATCH) == 0 && c != L('[') && FOLD (*n) != c1)  \n\t\t  continue;\n\n\t\t \n\t\tif ((flags & FNM_EXTMATCH) && p[1] != L('(') &&  \n\t\t    STRCHR (L(\"?*+@!\"), *p) == 0 && c != L('[') && FOLD (*n) != c1)  \n\t\t  continue;\n\n\t\t \n\t\tif (GMATCH (n, se, p, pe, &end, flags & ~(FNM_PERIOD|FNM_DOTDOT)) == 0)\n\t\t  {\n\t\t    if (end.pattern == NULL)\n\t\t      return (0);\n\t\t    break;\n\t\t  }\n\t      }\n\t      \n\t    if (end.pattern != NULL)\n\t      {\n\t\tp = end.pattern;\n\t\tn = end.string;\n\t\tcontinue;\n\t      }\n\n\t    return FNM_NOMATCH;\n\t  }\n\n\tcase L('['):\n\t  {\n\t    if (sc == L('\\0') || n == se)\n\t      return FNM_NOMATCH;\n\n\t     \n\t    if ((flags & FNM_PERIOD) && sc == L('.') &&\n\t\t(n == string || ((flags & FNM_PATHNAME) && n[-1] == L('/'))))\n\t      return (FNM_NOMATCH);\n\n\t     \n\t    if ((flags & FNM_DOTDOT) &&\n\t\t((n == string && SDOT_OR_DOTDOT(n)) ||\n\t\t((flags & FNM_PATHNAME) && n[-1] == L('/') && PDOT_OR_DOTDOT(n))))\n\t      return FNM_NOMATCH;\n\n\t    p = BRACKMATCH (p, sc, flags);\n\t    if (p == 0)\n\t      return FNM_NOMATCH;\n\t  }\n\t  break;\n\n\tdefault:\n\t  if ((U_CHAR)c != FOLD (sc))\n\t    return (FNM_NOMATCH);\n\t}\n\n      ++n;\n    }\n\n  if (n == se)\n    return (0);\n\n  if ((flags & FNM_LEADING_DIR) && *n == L('/'))\n     \n    return 0;\n\t  \n  return (FNM_NOMATCH);\n}\n\n \nstatic CHAR *\nPARSE_COLLSYM (p, vp)\n     CHAR *p;\n     INT *vp;\n{\n  register int pc;\n  INT val;\n\n  p++;\t\t\t\t \n\t  \n  for (pc = 0; p[pc]; pc++)\n    if (p[pc] == L('.') && p[pc+1] == L(']'))\n      break;\n   if (p[pc] == 0)\n    {\n      if (vp)\n\t*vp = INVALID;\n      return (p + pc);\n    }\n   val = COLLSYM (p, pc);\n   if (vp)\n     *vp = val;\n   return (p + pc + 2);\n}\n\n \nstatic CHAR *\n#if defined (PROTOTYPES)\nBRACKMATCH (CHAR *p, U_CHAR test, int flags)\n#else\nBRACKMATCH (p, test, flags)\n     CHAR *p;\n     U_CHAR test;\n     int flags;\n#endif\n{\n  register CHAR cstart, cend, c;\n  register int not;     \n  int brcnt, forcecoll, isrange;\n  INT pc;\n  CHAR *savep;\n  CHAR *brchrp;\n  U_CHAR orig_test;\n\n  orig_test = test;\n  test = FOLD (orig_test);\n\n  savep = p;\n\n   \n  if (not = (*p == L('!') || *p == L('^')))\n    ++p;\n\n  c = *p++;\n  for (;;)\n    {\n       \n      cstart = cend = c;\n      forcecoll = 0;\n\n       \n      if (c == L('[') && *p == L('=') && p[2] == L('=') && p[3] == L(']'))\n\t{\n\t  pc = FOLD (p[1]);\n\t  p += 4;\n\t  if (COLLEQUIV (test, pc))\n\t    {\n \t       \n\t      p++;\n\t      goto matched;\n\t    }\n\t  else\n\t    {\n\t      c = *p++;\n\t      if (c == L('\\0'))\n\t\treturn ((test == L('[')) ? savep : (CHAR *)0);  \n\t      c = FOLD (c);\n\t      continue;\n\t    }\n\t}\n\n       \n      if (c == L('[') && *p == L(':'))\n\t{\n\t  CHAR *close, *ccname;\n\n\t  pc = 0;\t \n\t   \n\t  for (close = p + 1; *close != '\\0'; close++)\n\t    if (*close == L(':') && *(close+1) == L(']'))\n\t      break;\n\n\t  if (*close != L('\\0'))\n\t    {\n\t      ccname = (CHAR *)malloc ((close - p) * sizeof (CHAR));\n\t      if (ccname == 0)\n\t\tpc = 0;\n\t      else\n\t\t{\n\t\t  bcopy (p + 1, ccname, (close - p - 1) * sizeof (CHAR));\n\t\t  *(ccname + (close - p - 1)) = L('\\0');\n\t\t   \n\t\t  DEQUOTE_PATHNAME (ccname);\n\t\t  pc = IS_CCLASS (orig_test, (XCHAR *)ccname);\n\t\t}\n\t      if (pc == -1)\n\t\t{\n\t\t   \n\t\t  pc = 0;\n\t\t  p = close + 2;\n\t\t}\n\t      else\n\t\tp = close + 2;\t\t \n\n\t      free (ccname);\n\t    }\n\t    \n\t  if (pc)\n\t    {\n \t       \n\t      p++;\n\t      goto matched;\n\t    }\n\t  else\n\t    {\n\t       \n\t      c = *p++;\n\t      if (c == L('\\0'))\n\t\treturn ((test == L('[')) ? savep : (CHAR *)0);\n\t      else if (c == L(']'))\n\t\tbreak;\n\t      c = FOLD (c);\n\t      continue;\n\t    }\n\t}\n \n       \n      if (c == L('[') && *p == L('.'))\n\t{\n\t  p = PARSE_COLLSYM (p, &pc);\n\t   \n\t  cstart = (pc == INVALID) ? test + 1 : pc;\n\t  forcecoll = 1;\n\t}\n\n      if (!(flags & FNM_NOESCAPE) && c == L('\\\\'))\n\t{\n\t  if (*p == '\\0')\n\t    return (CHAR *)0;\n\t  cstart = cend = *p++;\n\t}\n\n      cstart = cend = FOLD (cstart);\n      isrange = 0;\n\n       \n      if (c == L('\\0'))\n\treturn ((test == L('[')) ? savep : (CHAR *)0);\n\n      c = *p++;\n      c = FOLD (c);\n\n      if (c == L('\\0'))\n\treturn ((test == L('[')) ? savep : (CHAR *)0);\n\n      if ((flags & FNM_PATHNAME) && c == L('/'))\n\t \n\treturn (CHAR *)0;\n\n       \n      if (c == L('-') && *p != L(']'))\n\t{\n\t  cend = *p++;\n\t  if (!(flags & FNM_NOESCAPE) && cend == L('\\\\'))\n\t    cend = *p++;\n\t  if (cend == L('\\0'))\n\t    return (CHAR *)0;\n\t  if (cend == L('[') && *p == L('.'))\n\t    {\n\t      p = PARSE_COLLSYM (p, &pc);\n\t       \n\t      cend = (pc == INVALID) ? test - 1 : pc;\n\t      forcecoll = 1;\n\t    }\n\t  cend = FOLD (cend);\n\n\t  c = *p++;\n\n\t   \n\t  if (RANGECMP (cstart, cend, forcecoll) > 0)\n\t    {\n\t      if (c == L(']'))\n\t\tbreak;\n\t      c = FOLD (c);\n\t      continue;\n\t    }\n\t  isrange = 1;\n\t}\n\n      if (isrange == 0 && test == cstart)\n        goto matched;\n      if (isrange && RANGECMP (test, cstart, forcecoll) >= 0 && RANGECMP (test, cend, forcecoll) <= 0)\n\tgoto matched;\n\n      if (c == L(']'))\n\tbreak;\n    }\n   \n  return (!not ? (CHAR *)0 : p);\n\nmatched:\n   \n  c = *--p;\n  brcnt = 1;\n  brchrp = 0;\n  while (brcnt > 0)\n    {\n      int oc;\n\n       \n      if (c == L('\\0'))\n\treturn ((test == L('[')) ? savep : (CHAR *)0);\n\n      oc = c;\n      c = *p++;\n      if (c == L('[') && (*p == L('=') || *p == L(':') || *p == L('.')))\n\t{\n\t  brcnt++;\n\t  brchrp = p++;\t\t \n\t  if ((c = *p) == L('\\0'))\n\t    return ((test == L('[')) ? savep : (CHAR *)0);\n\t   \n\t}\n       \n      else if (c == L(']') && brcnt > 1 && brchrp != 0 && oc == *brchrp)\n\t{\n\t  brcnt--;\n\t  brchrp = 0;\t\t \n\t}\n       \n      else if (c == L(']') && (brchrp == 0 || *brchrp != L('.')) && brcnt >= 1)\n\tbrcnt = 0;\n      else if (!(flags & FNM_NOESCAPE) && c == L('\\\\'))\n\t{\n\t  if (*p == '\\0')\n\t    return (CHAR *)0;\n\t   \n\t  ++p;\n\t}\n    }\n  return (not ? (CHAR *)0 : p);\n}\n\n#if defined (EXTENDED_GLOB)\n \n\n \n  CHAR *\nPATSCAN (string, end, delim)\n     CHAR *string, *end;\n     INT delim;\n{\n  int pnest, bnest, skip;\n  INT cchar;\n  CHAR *s, c, *bfirst;\n\n  pnest = bnest = skip = 0;\n  cchar = 0;\n  bfirst = NULL;\n\n  if (string == end)\n    return (NULL);\n\n  for (s = string; c = *s; s++)\n    {\n      if (s >= end)\n\treturn (s);\n      if (skip)\n\t{\n\t  skip = 0;\n\t  continue;\n\t}\n      switch (c)\n\t{\n\tcase L('\\\\'):\n\t  skip = 1;\n\t  break;\n\n\tcase L('\\0'):\n\t  return ((CHAR *)NULL);\n\n\t \n\tcase L('['):\n\t  if (bnest == 0)\n\t    {\n\t      bfirst = s + 1;\n\t      if (*bfirst == L('!') || *bfirst == L('^'))\n\t\tbfirst++;\n\t      bnest++;\n\t    }\n\t  else if (s[1] == L(':') || s[1] == L('.') || s[1] == L('='))\n\t    cchar = s[1];\n\t  break;\n\n\t \n\tcase L(']'):\n\t  if (bnest)\n\t    {\n\t      if (cchar && s[-1] == cchar)\n\t\tcchar = 0;\n\t      else if (s != bfirst)\n\t\t{\n\t\t  bnest--;\n\t\t  bfirst = 0;\n\t\t}\n\t    }\n\t  break;\n\n\tcase L('('):\n\t  if (bnest == 0)\n\t    pnest++;\n\t  break;\n\n\tcase L(')'):\n\t  if (bnest == 0 && pnest-- <= 0)\n\t    return ++s;\n\t  break;\n\n\tcase L('|'):\n\t  if (bnest == 0 && pnest == 0 && delim == L('|'))\n\t    return ++s;\n\t  break;\n\t}\n    }\n\n  return (NULL);\n}\n\n \nstatic int\nSTRCOMPARE (p, pe, s, se)\n     CHAR *p, *pe, *s, *se;\n{\n  int ret;\n  CHAR c1, c2;\n  int l1, l2;\n\n  l1 = pe - p;\n  l2 = se - s;\n\n  if (l1 != l2)\n    return (FNM_NOMATCH);\t \n  \n  c1 = *pe;\n  c2 = *se;\n\n  if (c1 != 0)\n    *pe = '\\0';\n  if (c2 != 0)\n    *se = '\\0';\n    \n#if HAVE_MULTIBYTE || defined (HAVE_STRCOLL)\n  ret = STRCOLL ((XCHAR *)p, (XCHAR *)s);\n#else\n  ret = STRCMP ((XCHAR *)p, (XCHAR *)s);\n#endif\n\n  if (c1 != 0)\n    *pe = c1;\n  if (c2 != 0)\n    *se = c2;\n\n  return (ret == 0 ? ret : FNM_NOMATCH);\n}\n\n \nstatic int\nEXTMATCH (xc, s, se, p, pe, flags)\n     INT xc;\t\t \n     CHAR *s, *se;\n     CHAR *p, *pe;\n     int flags;\n{\n  CHAR *prest;\t\t\t \n  CHAR *psub;\t\t\t \n  CHAR *pnext;\t\t\t \n  CHAR *srest;\t\t\t \n  int m1, m2, xflags;\t\t \n\n#if DEBUG_MATCHING\nfprintf(stderr, \"extmatch: xc = %c\\n\", xc);\nfprintf(stderr, \"extmatch: s = %s; se = %s\\n\", s, se);\nfprintf(stderr, \"extmatch: p = %s; pe = %s\\n\", p, pe);\nfprintf(stderr, \"extmatch: flags = %d\\n\", flags);\n#endif\n\n  prest = PATSCAN (p + (*p == L('(')), pe, 0);  \n  if (prest == 0)\n     \n    return (STRCOMPARE (p - 1, pe, s, se));\n\n  switch (xc)\n    {\n    case L('+'):\t\t \n    case L('*'):\t\t \n       \n      if (xc == L('*') && (GMATCH (s, se, prest, pe, NULL, flags) == 0))\n\treturn 0;\n\n       \n      for (psub = p + 1; ; psub = pnext)\n\t{\n\t  pnext = PATSCAN (psub, pe, L('|'));\n\t  for (srest = s; srest <= se; srest++)\n\t    {\n\t       \n\t      m1 = GMATCH (s, srest, psub, pnext - 1, NULL, flags) == 0;\n\t       \n\t      if (m1)\n\t\t{\n\t\t   \n\t\t  xflags = (srest > s) ? (flags & ~(FNM_PERIOD|FNM_DOTDOT)) : flags;\n\t\t  m2 = (GMATCH (srest, se, prest, pe, NULL, xflags) == 0) ||\n\t\t\t(s != srest && GMATCH (srest, se, p - 1, pe, NULL, xflags) == 0);\n\t\t}\n\t      if (m1 && m2)\n\t\treturn (0);\n\t    }\n\t  if (pnext == prest)\n\t    break;\n\t}\n      return (FNM_NOMATCH);\n\n    case L('?'):\t\t \n    case L('@'):\t\t \n       \n      if (xc == L('?') && (GMATCH (s, se, prest, pe, NULL, flags) == 0))\n\treturn 0;\n\n       \n      for (psub = p + 1; ; psub = pnext)\n\t{\n\t  pnext = PATSCAN (psub, pe, L('|'));\n\t  srest = (prest == pe) ? se : s;\n\t  for ( ; srest <= se; srest++)\n\t    {\n\t       \n\t      xflags = (srest > s) ? (flags & ~(FNM_PERIOD|FNM_DOTDOT)) : flags;\n\t      if (GMATCH (s, srest, psub, pnext - 1, NULL, flags) == 0 &&\n\t\t  GMATCH (srest, se, prest, pe, NULL, xflags) == 0)\n\t\treturn (0);\n\t    }\n\t  if (pnext == prest)\n\t    break;\n\t}\n      return (FNM_NOMATCH);\n\n    case '!':\t\t \n      for (srest = s; srest <= se; srest++)\n\t{\n\t  m1 = 0;\n\t  for (psub = p + 1; ; psub = pnext)\n\t    {\n\t      pnext = PATSCAN (psub, pe, L('|'));\n\t       \n\t      if (m1 = (GMATCH (s, srest, psub, pnext - 1, NULL, flags) == 0))\n\t\tbreak;\n\t      if (pnext == prest)\n\t\tbreak;\n\t    }\n\n\t   \n\t  if (m1 == 0 && (flags & FNM_PERIOD) && *s == '.')\n\t    return (FNM_NOMATCH);\n\n\t  if (m1 == 0 && (flags & FNM_DOTDOT) &&\n\t      (SDOT_OR_DOTDOT (s) ||\n\t       ((flags & FNM_PATHNAME) && s[-1] == L('/') && PDOT_OR_DOTDOT(s))))\n\t    return (FNM_NOMATCH);\n\n\t   \n\t  xflags = (srest > s) ? (flags & ~(FNM_PERIOD|FNM_DOTDOT)) : flags;\n\t  if (m1 == 0 && GMATCH (srest, se, prest, pe, NULL, xflags) == 0)\n\t    return (0);\n\t}\n      return (FNM_NOMATCH);\n    }\n\n  return (FNM_NOMATCH);\n}\n#endif  \n\n#undef IS_CCLASS\n#undef FOLD\n#undef CHAR\n#undef U_CHAR\n#undef XCHAR\n#undef INT\n#undef INVALID\n#undef FCT\n#undef GMATCH\n#undef COLLSYM\n#undef PARSE_COLLSYM\n#undef PATSCAN\n#undef STRCOMPARE\n#undef EXTMATCH\n#undef DEQUOTE_PATHNAME\n#undef STRUCT\n#undef BRACKMATCH\n#undef STRCHR\n#undef STRCOLL\n#undef STRLEN\n#undef STRCMP\n#undef MEMCHR\n#undef COLLEQUIV\n#undef RANGECMP\n#undef ISDIRSEP\n#undef PATHSEP\n#undef PDOT_OR_DOTDOT\n#undef SDOT_OR_DOTDOT\n#undef L\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}