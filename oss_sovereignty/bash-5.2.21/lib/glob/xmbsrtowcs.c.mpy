{
  "module_name": "xmbsrtowcs.c",
  "hash_id": "10c41919198ec03c3514b44abebaaa5408ab624e7853666439d9240334b65762",
  "original_prompt": "Ingested from bash-5.2.21/lib/glob/xmbsrtowcs.c",
  "human_readable_source": " \n\n \n\n \n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE 1\n#endif\n\n#include <config.h>\n\n#include <bashansi.h>\n\n \n#include <shmbutil.h>\n\n#if HANDLE_MULTIBYTE\n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif\n\n#define WSBUF_INC 32\n\n#ifndef FREE\n#  define FREE(x)\tdo { if (x) free (x); } while (0)\n#endif\n\n#if ! HAVE_STRCHRNUL\nextern char *strchrnul PARAMS((const char *, int));\n#endif\n\n \n\nstatic mbstate_t local_state;\nstatic int local_state_use = 0;\n\nsize_t\nxmbsrtowcs (dest, src, len, pstate)\n    wchar_t *dest;\n    const char **src;\n    size_t len;\n    mbstate_t *pstate;\n{\n  mbstate_t *ps;\n  size_t mblength, wclength, n;\n\n  ps = pstate;\n  if (pstate == NULL)\n    {\n      if (!local_state_use)\n\t{\n\t  memset (&local_state, '\\0', sizeof(mbstate_t));\n\t  local_state_use = 1;\n\t}\n      ps = &local_state;\n    }\n\n  n = strlen (*src);\n\n  if (dest == NULL)\n    {\n      wchar_t *wsbuf;\n      const char *mbs;\n      mbstate_t psbuf;\n\n       \n      wsbuf = (wchar_t *) malloc ((n + 1) * sizeof(wchar_t));\n      mbs = *src;\n      psbuf = *ps;\n\n      wclength = mbsrtowcs (wsbuf, &mbs, n, &psbuf);\n\n      if (wsbuf)\n\tfree (wsbuf);\n      return wclength;\n    }\n      \n  for (wclength = 0; wclength < len; wclength++, dest++)\n    {\n      if (mbsinit(ps))\n\t{\n\t  if (**src == '\\0')\n\t    {\n\t      *dest = L'\\0';\n\t      *src = NULL;\n\t      return (wclength);\n\t    }\n\t  else if (**src == '\\\\')\n\t    {\n\t      *dest = L'\\\\';\n\t      mblength = 1;\n\t    }\n\t  else\n\t    mblength = mbrtowc(dest, *src, n, ps);\n\t}\n      else\n\tmblength = mbrtowc(dest, *src, n, ps);\n\n       \n      if (mblength == (size_t)-1 || mblength == (size_t)-2)\n\treturn (size_t)-1;\n\n      *src += mblength;\n      n -= mblength;\n\n       \n      if (*dest == L'\\0')\n\t{\n\t  *src = NULL;\n\t  break;\n\t}\n    }\n\n    return (wclength);\n}\n\n#if HAVE_MBSNRTOWCS\n \n\nstatic size_t\nxdupmbstowcs2 (destp, src)\n    wchar_t **destp;\t \n    const char *src;\t \n{\n  const char *p;\t \n  wchar_t *wsbuf;\t \n  size_t wsbuf_size;\t \n  size_t wcnum;\t\t \n  mbstate_t state;\t \n  size_t n, wcslength;\t \n  const char *end_or_backslash;\n  size_t nms;\t \n  mbstate_t tmp_state;\n  const char *tmp_p;\n\n  memset (&state, '\\0', sizeof(mbstate_t));\n\n  wsbuf_size = 0;\n  wsbuf = NULL;\n\n  p = src;\n  wcnum = 0;\n  do\n    {\n      end_or_backslash = strchrnul(p, '\\\\');\n      nms = end_or_backslash - p;\n      if (*end_or_backslash == '\\0')\n\tnms++;\n\n       \n      tmp_p = p;\n      tmp_state = state;\n\n      if (nms == 0 && *p == '\\\\')\t \n\tnms = wcslength = 1;\n      else\n\twcslength = mbsnrtowcs (NULL, &tmp_p, nms, 0, &tmp_state);\n\n      if (wcslength == 0)\n\t{\n\t  tmp_p = p;\t\t \n\t  tmp_state = state;\n\t  wcslength = 1;\t \n\t}\n\n       \n      if (wcslength == (size_t)-1)\n\t{\n\t  free (wsbuf);\n\t  *destp = NULL;\n\t  return (size_t)-1;\n\t}\n\n       \n      if (wsbuf_size < wcnum+wcslength+1)\t \n\t{\n\t  wchar_t *wstmp;\n\n\t  while (wsbuf_size < wcnum+wcslength+1)  \n\t    wsbuf_size += WSBUF_INC;\n\n\t  wstmp = (wchar_t *) realloc (wsbuf, wsbuf_size * sizeof (wchar_t));\n\t  if (wstmp == NULL)\n\t    {\n\t      free (wsbuf);\n\t      *destp = NULL;\n\t      return (size_t)-1;\n\t    }\n\t  wsbuf = wstmp;\n\t}\n\n       \n      n = mbsnrtowcs(wsbuf+wcnum, &p, nms, wsbuf_size-wcnum, &state);\n\n      if (n == 0 && p == 0)\n\t{\n\t  wsbuf[wcnum] = L'\\0';\n\t  break;\n\t}\n\n       \n      if (wcslength == 1 && (n == 0 || n == (size_t)-1))\n\t{\n\t  state = tmp_state;\n\t  p = tmp_p;\n\t  wsbuf[wcnum] = *p;\n\t  if (*p == 0)\n\t    break;\n\t  else\n\t    {\n\t      wcnum++; p++;\n\t    }\n\t}\n      else\n        wcnum += wcslength;\n\n      if (mbsinit (&state) && (p != NULL) && (*p == '\\\\'))\n\t{\n\t  wsbuf[wcnum++] = L'\\\\';\n\t  p++;\n\t}\n    }\n  while (p != NULL);\n\n  *destp = wsbuf;\n\n   \n  return wcnum;\n}\n#endif  \n\n \n\nsize_t\nxdupmbstowcs (destp, indicesp, src)\n    wchar_t **destp;\t \n    char ***indicesp;\t \n    const char *src;\t \n{\n  const char *p;\t \n  wchar_t wc;\t\t \n  wchar_t *wsbuf;\t \n  char **indices; \t \n  size_t wsbuf_size;\t \n  size_t wcnum;\t\t \n  mbstate_t state;\t \n\n   \n  if (src == NULL || destp == NULL)\n    {\n      if (destp)\n\t*destp = NULL;\n      if (indicesp)\n\t*indicesp = NULL;\n      return (size_t)-1;\n    }\n\n#if HAVE_MBSNRTOWCS\n  if (indicesp == NULL)\n    return (xdupmbstowcs2 (destp, src));\n#endif\n\n  memset (&state, '\\0', sizeof(mbstate_t));\n  wsbuf_size = WSBUF_INC;\n\n  wsbuf = (wchar_t *) malloc (wsbuf_size * sizeof(wchar_t));\n  if (wsbuf == NULL)\n    {\n      *destp = NULL;\n      if (indicesp)\n        *indicesp = NULL;\n      return (size_t)-1;\n    }\n\n  indices = NULL;\n  if (indicesp)\n    {\n      indices = (char **) malloc (wsbuf_size * sizeof(char *));\n      if (indices == NULL)\n\t{\n\t  free (wsbuf);\n\t  *destp = NULL;\n\t  *indicesp = NULL;\n\t  return (size_t)-1;\n\t}\n    }\n\n  p = src;\n  wcnum = 0;\n  do\n    {\n      size_t mblength;\t \n\n      if (mbsinit (&state))\n\t{\n\t  if (*p == '\\0')\n\t    {\n\t      wc = L'\\0';\n\t      mblength = 1;\n\t    }\n\t  else if (*p == '\\\\')\n\t    {\n\t      wc = L'\\\\';\n\t      mblength = 1;\n\t    }\n\t  else\n\t    mblength = mbrtowc(&wc, p, MB_LEN_MAX, &state);\n\t}\n      else\n\tmblength = mbrtowc(&wc, p, MB_LEN_MAX, &state);\n\n       \n      if (MB_INVALIDCH (mblength))\n\t{\n\t  free (wsbuf);\n\t  FREE (indices);\n\t  *destp = NULL;\n\t  if (indicesp)\n\t    *indicesp = NULL;\n\t  return (size_t)-1;\n\t}\n\n      ++wcnum;\n\n       \n      if (wsbuf_size < wcnum)\n\t{\n\t  wchar_t *wstmp;\n\t  char **idxtmp;\n\n\t  wsbuf_size += WSBUF_INC;\n\n\t  wstmp = (wchar_t *) realloc (wsbuf, wsbuf_size * sizeof (wchar_t));\n\t  if (wstmp == NULL)\n\t    {\n\t      free (wsbuf);\n\t      FREE (indices);\n\t      *destp = NULL;\n\t      if (indicesp)\n\t\t*indicesp = NULL;\n\t      return (size_t)-1;\n\t    }\n\t  wsbuf = wstmp;\n\n\t  if (indicesp)\n\t    {\n\t      idxtmp = (char **) realloc (indices, wsbuf_size * sizeof (char *));\n\t      if (idxtmp == NULL)\n\t\t{\n\t\t  free (wsbuf);\n\t\t  free (indices);\n\t\t  *destp = NULL;\n\t\t  if (indicesp)\n\t\t    *indicesp = NULL;\n\t\t  return (size_t)-1;\n\t\t}\n\t      indices = idxtmp;\n\t    }\n\t}\n\n      wsbuf[wcnum - 1] = wc;\n      if (indices)\n        indices[wcnum - 1] = (char *)p;\n      p += mblength;\n    }\n  while (MB_NULLWCH (wc) == 0);\n\n   \n  *destp = wsbuf;\n  if (indicesp != NULL)\n    *indicesp = indices;\n\n  return (wcnum - 1);\n}\n\n \n\n \nsize_t\nxwcsrtombs (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)\n{\n  const wchar_t *src;\n  size_t cur_max;\t\t\t \n  char buf[64], *destptr, *tmp_dest;\n  unsigned char uc;\n  mbstate_t prev_state;\n\n  cur_max = MB_CUR_MAX;\n  if (cur_max > sizeof (buf))\t\t \n    return (size_t)-1;\n\n  src = *srcp;\n\n  if (dest != NULL)\n    {\n      destptr = dest;\n\n      for (; len > 0; src++)\n\t{\n\t  wchar_t wc;\n\t  size_t ret;\n\n\t  wc = *src;\n\t   \n\t  tmp_dest = destptr;\n\t  ret = wcrtomb (len >= cur_max ? destptr : buf, wc, ps);\n\n\t  if (ret == (size_t)(-1))\t\t \n\t    {\n\t       \nhandle_byte:\n\t      destptr = tmp_dest;\t \n\t      uc = wc;\n\t      ret = 1;\n\t      if (len >= cur_max)\n\t\t*destptr = uc;\n\t      else\n\t\tbuf[0] = uc;\n\t      if (ps)\n\t\tmemset (ps, 0, sizeof (mbstate_t));\n\t    }\n\n\t  if (ret > cur_max)\t\t \n\t    goto bad_input;\n\n\t  if (len < ret)\n\t    break;\n\n\t  if (len < cur_max)\n\t    memcpy (destptr, buf, ret);\n\n\t  if (wc == 0)\n\t    {\n\t      src = NULL;\n\t       \n\t      break;\n\t    }\n\t  destptr += ret;\n\t  len -= ret;\n\t}\n      *srcp = src;\n      return destptr - dest;\n    }\n  else\n    {\n       \n      mbstate_t state = *ps;\n      size_t totalcount = 0;\n\n      for (;; src++)\n\t{\n\t  wchar_t wc;\n\t  size_t ret;\n\n\t  wc = *src;\n\t  ret = wcrtomb (buf, wc, &state);\n\n\t  if (ret == (size_t)(-1))\n\t    goto bad_input2;\n\t  if (wc == 0)\n\t    {\n\t       \n\t      break;\n\t    }\n\t  totalcount += ret;\n\t}\n      return totalcount;\n    }\n\nbad_input:\n  *srcp = src;\nbad_input2:\n  errno = EILSEQ;\n  return (size_t)(-1);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}