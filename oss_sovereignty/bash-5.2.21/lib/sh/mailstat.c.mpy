{
  "module_name": "mailstat.c",
  "hash_id": "0693f27e20106b3baf48b98ff2961cac63532d07177c8761db038ce97996b242",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/mailstat.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n \n#include <stdio.h>\n#include <errno.h>\n\n#include <bashtypes.h>\n#include <posixstat.h>\n#include <posixdir.h>\n#include <bashansi.h>\n\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#include <maxpath.h>\n\n \n\nint\nmailstat(path, st)\n     const char *path;\n     struct stat *st;\n{\n  static struct stat st_new_last, st_ret_last;\n  struct stat st_ret, st_tmp;\n  DIR *dd;\n  struct dirent *fn;\n  char dir[PATH_MAX * 2], file[PATH_MAX * 2 + 1];\n  int i, l;\n  time_t atime, mtime;\n\n  atime = mtime = 0;\n\n   \n  if ((i = stat(path, st)) != 0 || S_ISDIR(st->st_mode) == 0)\n    return i;\n\n  if (strlen(path) > sizeof(dir) - 5)\n    {\n#ifdef ENAMETOOLONG\n      errno = ENAMETOOLONG;\n#else\n      errno = EINVAL;\n#endif\n      return -1;\n    }\n\n  st_ret = *st;\n  st_ret.st_nlink = 1;\n  st_ret.st_size  = 0;\n#ifdef HAVE_STRUCT_STAT_ST_BLOCKS\n  st_ret.st_blocks  = 0;\n#else\n  st_ret.st_nlink = 0;\n#endif\n  st_ret.st_mode  &= ~S_IFDIR;\n  st_ret.st_mode  |= S_IFREG;\n\n   \n  sprintf(dir, \"%s/cur\", path);\n  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)\n    return 0;\n  st_ret.st_atime = st_tmp.st_atime;\n\n   \n  sprintf(dir, \"%s/tmp\", path);\n  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)\n    return 0;\n  st_ret.st_mtime = st_tmp.st_mtime;\n\n   \n  sprintf(dir, \"%s/new\", path);\n  if (stat(dir, &st_tmp) || S_ISDIR(st_tmp.st_mode) == 0)\n    return 0;\n  st_ret.st_mtime = st_tmp.st_mtime;\n\n   \n  if (st_tmp.st_dev == st_new_last.st_dev &&\n      st_tmp.st_ino == st_new_last.st_ino &&\n      st_tmp.st_atime == st_new_last.st_atime &&\n      st_tmp.st_mtime == st_new_last.st_mtime)\n    {\n      *st = st_ret_last;\n      return 0;\n    }\n  st_new_last = st_tmp;\n\n   \n  for (i = 0; i < 2; i++)\n    {\n      sprintf(dir, \"%s/%s\", path, i ? \"cur\" : \"new\");\n      sprintf(file, \"%s/\", dir);\n      l = strlen(file);\n      if ((dd = opendir(dir)) == NULL)\n\treturn 0;\n      while ((fn = readdir(dd)) != NULL)\n\t{\n\t  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))\n\t    continue;\n\t  strcpy(file + l, fn->d_name);\n\t  if (stat(file, &st_tmp) != 0)\n\t    continue;\n\t  st_ret.st_size += st_tmp.st_size;\n#ifdef HAVE_STRUCT_STAT_ST_BLOCKS\n\t  st_ret.st_blocks++;\n#else\n\t  st_ret.st_nlink++;\n#endif\n\t  if (st_tmp.st_atime != st_tmp.st_mtime && st_tmp.st_atime > atime)\n\t    atime = st_tmp.st_atime;\n\t  if (st_tmp.st_mtime > mtime)\n\t    mtime = st_tmp.st_mtime;\n\t}\n      closedir(dd);\n    }\n\n \t \n      st_ret.st_atime = atime;\n    if (mtime)\n      st_ret.st_mtime = mtime;\n\n    *st = st_ret_last = st_ret;\n    return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}