{
  "module_name": "eaccess.c",
  "hash_id": "ceb4bdc8ecfc97f6600f732fa2246d7cf212f08a4842585a08af4c77250c9988",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/eaccess.c",
  "human_readable_source": " \n\n \n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#if !defined (_POSIX_VERSION) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif  \n#include \"posixstat.h\"\n#include \"filecntl.h\"\n\n#include \"shell.h\"\n\n#if !defined (R_OK)\n#define R_OK 4\n#define W_OK 2\n#define X_OK 1\n#define F_OK 0\n#endif  \n\nstatic int path_is_devfd PARAMS((const char *));\nstatic int sh_stataccess PARAMS((const char *, int));\n#if HAVE_DECL_SETREGID\nstatic int sh_euidaccess PARAMS((const char *, int));\n#endif\n\nstatic int\npath_is_devfd (path)\n     const char *path;\n{\n  if (path[0] == '/' && path[1] == 'd' && strncmp (path, \"/dev/fd/\", 8) == 0)\n    return 1;\n  else if (STREQN (path, \"/dev/std\", 8))\n    {\n      if (STREQ (path+8, \"in\") || STREQ (path+8, \"out\") || STREQ (path+8, \"err\"))\n\treturn 1;\n      else\n\treturn 0;\n    }\n  else\n    return 0;\n}\n\n \nint\nsh_stat (path, finfo)\n     const char *path;\n     struct stat *finfo;\n{\n  static char *pbuf = 0;\n\n  if (*path == '\\0')\n    {\n      errno = ENOENT;\n      return (-1);\n    }\n  if (path[0] == '/' && path[1] == 'd' && strncmp (path, \"/dev/fd/\", 8) == 0)\n    {\n       \n#if !defined (HAVE_DEV_FD) || defined (DEV_FD_STAT_BROKEN)\n      intmax_t fd;\n      int r;\n\n      if (legal_number (path + 8, &fd) && fd == (int)fd)\n        {\n          r = fstat ((int)fd, finfo);\n          if (r == 0 || errno != EBADF)\n            return (r);\n        }\n      errno = ENOENT;\n      return (-1);\n#else\n   \n      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));\n      strcpy (pbuf, DEV_FD_PREFIX);\n      strcat (pbuf, path + 8);\n      return (stat (pbuf, finfo));\n#endif  \n    }\n#if !defined (HAVE_DEV_STDIN)\n  else if (STREQN (path, \"/dev/std\", 8))\n    {\n      if (STREQ (path+8, \"in\"))\n\treturn (fstat (0, finfo));\n      else if (STREQ (path+8, \"out\"))\n\treturn (fstat (1, finfo));\n      else if (STREQ (path+8, \"err\"))\n\treturn (fstat (2, finfo));\n      else\n\treturn (stat (path, finfo));\n    }\n#endif  \n  return (stat (path, finfo));\n}\n\n \nstatic int\nsh_stataccess (path, mode)\n     const char *path;\n     int mode;\n{\n  struct stat st;\n\n  if (sh_stat (path, &st) < 0)\n    return (-1);\n\n  if (current_user.euid == 0)\n    {\n       \n      if ((mode & X_OK) == 0)\n\treturn (0);\n\n       \n      if (st.st_mode & S_IXUGO)\n\treturn (0);\n    }\n\n  if (st.st_uid == current_user.euid)\t \n    mode <<= 6;\n  else if (group_member (st.st_gid))\n    mode <<= 3;\n\n  if (st.st_mode & mode)\n    return (0);\n\n  errno = EACCES;\n  return (-1);\n}\n\n#if HAVE_DECL_SETREGID\n \nstatic int\nsh_euidaccess (path, mode)\n     const char *path;\n     int mode;\n{\n  int r, e;\n\n  if (current_user.uid != current_user.euid)\n    setreuid (current_user.euid, current_user.uid);\n  if (current_user.gid != current_user.egid)\n    setregid (current_user.egid, current_user.gid);\n\n  r = access (path, mode);\n  e = errno;\n\n  if (current_user.uid != current_user.euid)\n    setreuid (current_user.uid, current_user.euid);\n  if (current_user.gid != current_user.egid)\n    setregid (current_user.gid, current_user.egid);\n\n  errno = e;\n  return r;  \n}\n#endif\n\nint\nsh_eaccess (path, mode)\n     const char *path;\n     int mode;\n{\n  int ret;\n\n  if (path_is_devfd (path))\n    return (sh_stataccess (path, mode));\n\n#if (defined (HAVE_FACCESSAT) && defined (AT_EACCESS)) || defined (HAVE_EACCESS)\n#  if defined (HAVE_FACCESSAT) && defined (AT_EACCESS)\n  ret = faccessat (AT_FDCWD, path, mode, AT_EACCESS);\n#  else\t\t \t \n  ret = eaccess (path, mode);\t \n#  endif\t \n#  if defined (__FreeBSD__) || defined (SOLARIS) || defined (_AIX)\n  if (ret == 0 && current_user.euid == 0 && mode == X_OK)\n    return (sh_stataccess (path, mode));\n#  endif\t \n  return ret;\n#elif defined (EFF_ONLY_OK)\t\t \n  return access (path, mode|EFF_ONLY_OK);\n#else\n  if (mode == F_OK)\n    return (sh_stataccess (path, mode));\n    \n#  if HAVE_DECL_SETREGID\n  if (current_user.uid != current_user.euid || current_user.gid != current_user.egid)\n    return (sh_euidaccess (path, mode));\n#  endif\n\n  if (current_user.uid == current_user.euid && current_user.gid == current_user.egid)\n    {\n      ret = access (path, mode);\n#if defined (__FreeBSD__) || defined (SOLARIS)\n      if (ret == 0 && current_user.euid == 0 && mode == X_OK)\n\treturn (sh_stataccess (path, mode));\n#endif\n      return ret;\n    }\n\n  return (sh_stataccess (path, mode));\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}