{
  "module_name": "mktime.c",
  "hash_id": "10979a7c9f0799b3151cbddba799d347e66e2233d7d4a6e187250e9b4232ef42",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/mktime.c",
  "human_readable_source": " \n\n \n \n \n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef _LIBC\n# define HAVE_LIMITS_H 1\n# define HAVE_LOCALTIME_R 1\n# define STDC_HEADERS 1\n#endif\n\n \n#ifndef LEAP_SECONDS_POSSIBLE\n#define LEAP_SECONDS_POSSIBLE 1\n#endif\n\n#ifndef VMS\n#include <sys/types.h>\t\t \n#endif\n#include <time.h>\n\n#if HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#include \"bashansi.h\"\n\n#if DEBUG_MKTIME\n#include <stdio.h>\n \n#define mktime my_mktime\n#endif  \n\n#ifndef PARAMS\n#if defined (__GNUC__) || (defined (__STDC__) && __STDC__)\n#define PARAMS(args) args\n#else\n#define PARAMS(args) ()\n#endif   \n#endif   \n\n#ifndef CHAR_BIT\n#define CHAR_BIT 8\n#endif\n\n#ifndef INT_MIN\n#define INT_MIN (~0 << (sizeof (int) * CHAR_BIT - 1))\n#endif\n#ifndef INT_MAX\n#define INT_MAX (~0 - INT_MIN)\n#endif\n\n \n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n \n#define TYPE_MINIMUM(t) \\\n  ((t) (! TYPE_SIGNED (t) \\\n\t? (t) 0 \\\n\t: ~ TYPE_MAXIMUM (t)))\n#define TYPE_MAXIMUM(t) \\\n  ((t) (! TYPE_SIGNED (t) \\\n\t? (t) -1 \\\n\t: ((((t) 1 << (sizeof (t) * CHAR_BIT - 2)) - 1) * 2 + 1)))\n                  \n#ifndef TIME_T_MIN\n# define TIME_T_MIN TYPE_MINIMUM (time_t)\n#endif\n#ifndef TIME_T_MAX\n# define TIME_T_MAX TYPE_MAXIMUM (time_t)\n#endif\n\n#define TM_YEAR_BASE 1900\n#define EPOCH_YEAR 1970\n\n#ifndef __isleap\n \n#define\t__isleap(year)\t\\\n  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))\n#endif\n\n \nconst unsigned short int __mon_yday[2][13] =\n  {\n     \n    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },\n     \n    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }\n  };\n\nstatic time_t ydhms_tm_diff PARAMS ((int, int, int, int, int, const struct tm *));\ntime_t __mktime_internal PARAMS ((struct tm *,\n\t\t\t       struct tm *(*) (const time_t *, struct tm *),\n\t\t\t       time_t *));\n\n\nstatic struct tm *my_localtime_r PARAMS ((const time_t *, struct tm *));\nstatic struct tm *\nmy_localtime_r (t, tp)\n     const time_t *t;\n     struct tm *tp;\n{\n  struct tm *l = localtime (t);\n  if (! l)\n    return 0;\n  *tp = *l;\n  return tp;\n}\n\n\n \nstatic time_t\nydhms_tm_diff (year, yday, hour, min, sec, tp)\n     int year, yday, hour, min, sec;\n     const struct tm *tp;\n{\n   \n  int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);\n  int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = a100 >> 2;\n  int b400 = b100 >> 2;\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  time_t years = year - (time_t) tp->tm_year;\n  time_t days = (365 * years + intervening_leap_days\n\t\t + (yday - tp->tm_yday));\n  return (60 * (60 * (24 * days + (hour - tp->tm_hour))\n\t\t+ (min - tp->tm_min))\n\t  + (sec - tp->tm_sec));\n}\n\n\nstatic time_t localtime_offset;\n\n \ntime_t\nmktime (tp)\n     struct tm *tp;\n{\n#ifdef _LIBC\n   \n  __tzset ();\n#endif\n\n  return __mktime_internal (tp, my_localtime_r, &localtime_offset);\n}\n\n \ntime_t\n__mktime_internal (tp, convert, offset)\n     struct tm *tp;\n     struct tm *(*convert) PARAMS ((const time_t *, struct tm *));\n     time_t *offset;\n{\n  time_t t, dt, t0;\n  struct tm tm;\n\n   \n  int remaining_probes = 4;\n\n   \n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n   \n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  int year = year_requested + mon_years;\n\n   \n\n   \n  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]\n\t       [mon_remainder + 12 * negative_mon_remainder])\n\t      + mday - 1);\n\n#if LEAP_SECONDS_POSSIBLE\n   \n  int sec_requested = sec;\n  if (sec < 0)\n    sec = 0;\n  if (59 < sec)\n    sec = 59;\n#endif\n\n   \n\n  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;\n  tm.tm_yday = tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);\n\n  for (t = t0 + *offset;\n       (dt = ydhms_tm_diff (year, yday, hour, min, sec, (*convert) (&t, &tm)));\n       t += dt)\n    if (--remaining_probes == 0)\n      return -1;\n\n   \n  if (0 <= isdst && 0 <= tm.tm_isdst)\n    {\n      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);\n      if (dst_diff)\n\t{\n\t   \n\t  time_t ot = t - 2 * 60 * 60 * dst_diff;\n\t  while (--remaining_probes != 0)\n\t    {\n\t      struct tm otm;\n\t      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,\n\t\t\t\t\t (*convert) (&ot, &otm))))\n\t\t{\n\t\t  t = ot;\n\t\t  tm = otm;\n\t\t  break;\n\t\t}\n\t      if ((ot += dt) == t)\n\t\tbreak;   \n\t    }\n\t}\n    }\n\n  *offset = t - t0;\n\n#if LEAP_SECONDS_POSSIBLE\n  if (sec_requested != tm.tm_sec)\n    {\n       \n      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);\n      (*convert) (&t, &tm);\n    }\n#endif\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n       \n\n      double dyear = (double) year_requested + mon_years - tm.tm_year;\n      double dday = 366 * dyear + mday;\n      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;\n\n      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))\n\treturn -1;\n    }\n\n  *tp = tm;\n  return t;\n}\n\n#ifdef weak_alias\nweak_alias (mktime, timelocal)\n#endif\n\f\n#if DEBUG_MKTIME\n\nstatic int\nnot_equal_tm (a, b)\n     struct tm *a;\n     struct tm *b;\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | (a->tm_isdst ^ b->tm_isdst));\n}\n\nstatic void\nprint_tm (tp)\n     struct tm *tp;\n{\n  printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t  tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t  tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t  tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n}\n\nstatic int\ncheck_result (tk, tmk, tl, tml)\n     time_t tk;\n     struct tm tmk;\n     time_t tl;\n     struct tm tml;\n{\n  if (tk != tl || not_equal_tm (&tmk, &tml))\n    {\n      printf (\"mktime (\");\n      print_tm (&tmk);\n      printf (\")\\nyields (\");\n      print_tm (&tml);\n      printf (\") == %ld, should be %ld\\n\", (long) tl, (long) tk);\n      return 1;\n    }\n\n  return 0;\n}\n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  time_t tk, tl;\n  char trailer;\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      tml = *localtime (&tl);\n      printf (\"mktime returns %ld == \", (long) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, tml);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; tl <= to; tl += by)\n\t  {\n\t    tml = *localtime (&tl);\n\t    tmk = tml;\n\t    tk = mktime (&tmk);\n\t    status |= check_result (tk, tmk, tl, tml);\n\t  }\n      else\n\tfor (tl = from; tl <= to; tl += by)\n\t  {\n\t     \n\t    tml = *localtime (&tl);\n\t    tmk = tml;\n\t    tk = tl;\n\t    status |= check_result (tk, tmk, tl, tml);\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}\n\n#endif /* DEBUG_MKTIME */\n\f\n/*\nLocal Variables:\ncompile-command: \"gcc -DDEBUG=1 -Wall -O -g mktime.c -o mktime\"\nEnd:\n*/\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}