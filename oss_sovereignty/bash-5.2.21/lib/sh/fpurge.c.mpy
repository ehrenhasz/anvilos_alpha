{
  "module_name": "fpurge.c",
  "hash_id": "c79f2ef3a1359142d1fa63da4af299a9b8bdc26b2806ea256e4c603010ee9020",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/fpurge.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"stdc.h\"\n\n#include <stdio.h>\n\n \n#define NEED_FPURGE_DECL\n#if HAVE_FPURGE\n#  define fpurge _bash_fpurge\n#endif\nextern int fpurge PARAMS((FILE *stream));\n\n#if HAVE___FPURGE                    \n# include <stdio_ext.h>\n#endif\n#include <stdlib.h>\n\n \n\n \n\n \n\n#if defined __NetBSD__                          \n \n# include <sys/param.h>\n#endif\n\n#if defined __sferror || defined __DragonFly__  \n\n# if defined __DragonFly__           \n    \\\n                       } *) fp)\n   \n   \n       \n    };\n#  define fp_ub ((struct __sfileext *) fp->_ext._base)->_ub\n# else                                          \n#  define fp_ub fp_->_ub\n# endif\n\n# define HASUB(fp) (fp_ub._base != NULL)\n\n#endif\n\n \n\n#if defined _IOERR\n\n# if defined __sun && defined _LP64  \n#  define fp_ ((struct { unsigned char *_ptr; \\\n                         unsigned char *_base; \\\n                         unsigned char *_end; \\\n                         long _cnt; \\\n                         int _file; \\\n                         unsigned int _flag; \\\n                       } *) fp)\n# else\n#  define fp_ fp\n# endif\n\n# if defined _SCO_DS                 \n#  define _cnt __cnt\n#  define _ptr __ptr\n#  define _base __base\n#  define _flag __flag\n# endif\n\n#endif\n\nint\nfpurge (FILE *fp)\n{\n#if HAVE___FPURGE                    \n\n  __fpurge (fp);\n   \n  return 0;\n\n#elif HAVE_FPURGE                    \n\n   \n# undef fpurge\n# if !HAVE_DECL_FPURGE\n  extern int fpurge (FILE *);\n# endif\n  int result = fpurge (fp);\n# if defined __sferror || defined __DragonFly__  \n  if (result == 0)\n     \n    if ((fp_->_flags & __SRD) != 0)\n      fp_->_w = 0;\n# endif\n  return result;\n\n#else\n\n   \n# if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1  \n  fp->_IO_read_end = fp->_IO_read_ptr;\n  fp->_IO_write_ptr = fp->_IO_write_base;\n   \n  if (fp->_IO_save_base != NULL)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n  return 0;\n# elif defined __sferror || defined __DragonFly__  \n  fp_->_p = fp_->_bf._base;\n  fp_->_r = 0;\n  fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0  \n\t     ? fp_->_bf._size\n\t     : 0);\n   \n  if (fp_ub._base != NULL)\n    {\n      if (fp_ub._base != fp_->_ubuf)\n\tfree (fp_ub._base);\n      fp_ub._base = NULL;\n    }\n  return 0;\n# elif defined __EMX__               \n  fp->_ptr = fp->_buffer;\n  fp->_rcount = 0;\n  fp->_wcount = 0;\n  fp->_ungetc_count = 0;\n  return 0;\n# elif defined _IOERR || defined __TANDEM     \n  fp->_ptr = fp->_base;\n  if (fp->_ptr != NULL)\n    fp->_cnt = 0;\n  return 0;\n# elif defined __UCLIBC__            \n#  ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    fp->__bufpos = fp->__bufstart;\n  else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n    fp->__bufpos = fp->__bufread;\n#  endif\n  return 0;\n# elif defined __QNX__               \n  fp->_Rback = fp->_Back + sizeof (fp->_Back);\n  fp->_Rsave = NULL;\n  if (fp->_Mode & 0x2000  )\n     \n    fp->_Next = fp->_Buf;\n  else\n     \n    fp->_Rend = fp->_Next;\n  return 0;\n# elif defined __MINT__              \n  if (fp->__pushed_back)\n    {\n      fp->__bufp = fp->__pushback_bufp;\n      fp->__pushed_back = 0;\n    }\n   \n  if (fp->__target != -1)\n    fp->__target += fp->__bufp - fp->__buffer;\n  fp->__bufp = fp->__buffer;\n   \n  fp->__get_limit = fp->__bufp;\n   \n  fp->__put_limit = fp->__buffer;\n  return 0;\n# else\n# warning \"Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.\"\n  return 0;\n# endif\n\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}