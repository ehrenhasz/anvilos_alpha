{
  "module_name": "zread.c",
  "hash_id": "0ec986615c56664238fdf8cf2373cf317be13aa52dee9a20dee138a1e9452137",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/zread.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <signal.h>\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#ifndef SEEK_CUR\n#  define SEEK_CUR 1\n#endif\n\n#ifndef ZBUFSIZ\n#  define ZBUFSIZ 4096\n#endif\n\nextern int executing_builtin;\n\nextern void check_signals_and_traps (void);\nextern void check_signals (void);\nextern int signal_is_trapped (int);\nextern int read_builtin_timeout (int);\n\n \nssize_t\nzread (fd, buf, len)\n     int fd;\n     char *buf;\n     size_t len;\n{\n  ssize_t r;\n\n  check_signals ();\t \n   \n  while (((r = read_builtin_timeout (fd)) < 0 || (r = read (fd, buf, len)) < 0) &&\n\t     errno == EINTR)\n    {\n      int t;\n      t = errno;\n       \n       \n      if (executing_builtin)\n\tcheck_signals_and_traps ();\t \n      else\n\tcheck_signals ();\n      errno = t;\n    }\n\n  return r;\n}\n\n \n\n#ifdef NUM_INTR\n#  undef NUM_INTR\n#endif\n#define NUM_INTR 3\n\nssize_t\nzreadretry (fd, buf, len)\n     int fd;\n     char *buf;\n     size_t len;\n{\n  ssize_t r;\n  int nintr;\n\n  for (nintr = 0; ; )\n    {\n      r = read (fd, buf, len);\n      if (r >= 0)\n\treturn r;\n      if (r == -1 && errno == EINTR)\n\t{\n\t  if (++nintr >= NUM_INTR)\n\t    return -1;\n\t  continue;\n\t}\n      return r;\n    }\n}\n\n \nssize_t\nzreadintr (fd, buf, len)\n     int fd;\n     char *buf;\n     size_t len;\n{\n  check_signals ();\n  return (read (fd, buf, len));\n}\n\n \n\nstatic char lbuf[ZBUFSIZ];\nstatic size_t lind, lused;\n\nssize_t\nzreadc (fd, cp)\n     int fd;\n     char *cp;\n{\n  ssize_t nr;\n\n  if (lind == lused || lused == 0)\n    {\n      nr = zread (fd, lbuf, sizeof (lbuf));\n      lind = 0;\n      if (nr <= 0)\n\t{\n\t  lused = 0;\n\t  return nr;\n\t}\n      lused = nr;\n    }\n  if (cp)\n    *cp = lbuf[lind++];\n  return 1;\n}\n\n \nssize_t\nzreadcintr (fd, cp)\n     int fd;\n     char *cp;\n{\n  ssize_t nr;\n\n  if (lind == lused || lused == 0)\n    {\n      nr = zreadintr (fd, lbuf, sizeof (lbuf));\n      lind = 0;\n      if (nr <= 0)\n\t{\n\t  lused = 0;\n\t  return nr;\n\t}\n      lused = nr;\n    }\n  if (cp)\n    *cp = lbuf[lind++];\n  return 1;\n}\n\n \nssize_t\nzreadn (fd, cp, len)\n     int fd;\n     char *cp;\n     size_t len;\n{\n  ssize_t nr;\n\n  if (lind == lused || lused == 0)\n    {\n      if (len > sizeof (lbuf))\n\tlen = sizeof (lbuf);\n      nr = zread (fd, lbuf, len);\n      lind = 0;\n      if (nr <= 0)\n\t{\n\t  lused = 0;\n\t  return nr;\n\t}\n      lused = nr;\n    }\n  if (cp)\n    *cp = lbuf[lind++];\n  return 1;\n}\n\nvoid\nzreset ()\n{\n  lind = lused = 0;\n}\n\n \nvoid\nzsyncfd (fd)\n     int fd;\n{\n  off_t off, r;\n\n  off = lused - lind;\n  r = 0;\n  if (off > 0)\n    r = lseek (fd, -off, SEEK_CUR);\n\n  if (r != -1)\n    lused = lind = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}