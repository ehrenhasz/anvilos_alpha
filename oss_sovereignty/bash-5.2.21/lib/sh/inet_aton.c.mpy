{
  "module_name": "inet_aton.c",
  "hash_id": "1581feab2cb7c42608a80d15f8e25fc33856f0698fa89c4e7998d91232b97af0",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/inet_aton.c",
  "human_readable_source": " \n\n \n\n \n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)inet_addr.c\t8.1 (Berkeley) 6/17/93\";\nstatic char rcsid[] = \"$Id: inet_addr.c,v 1.5 1996/08/14 03:48:37 drepper Exp $\";\n#endif  \n\n#include <config.h>\n\n#if !defined (HAVE_INET_ATON) && defined (HAVE_NETWORK) && defined (HAVE_NETINET_IN_H) && defined (HAVE_ARPA_INET_H)\n\n#include <sys/types.h>\n#if defined (HAVE_SYS_PARAM_H)\n#include <sys/param.h>\n#endif\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n\n#include <bashansi.h>\n#include <ctype.h>\n#include <stdc.h>\n\n#ifndef INADDR_NONE\n#  define INADDR_NONE 0xffffffff\n#endif\n\n \n\n#if 0\n \n \nu_long\ninet_addr(cp)\n\tregister const char *cp;\n{\n\tstruct in_addr val;\n\n\tif (inet_aton(cp, &val))\n\t\treturn (val.s_addr);\n\treturn (INADDR_NONE);\n}\n#endif\n\n \nint\ninet_aton(cp, addr)\n\tregister const char *cp;\n\tstruct in_addr *addr;\n{\n\tregister u_bits32_t val;\n\tregister int base, n;\n\tregister unsigned char c;\n\tu_int parts[4];\n\tregister u_int *pp = parts;\n\n\tc = *cp;\n\tfor (;;) {\n\t\t \n#if 0\n\t\tif (!isdigit(c))\n#else\n\t\tif (c != '0' && c != '1' && c != '2' && c != '3' && c != '4' &&\n\t\t    c != '5' && c != '6' && c != '7' && c != '8' && c != '9')\n#endif\n\t\t\treturn (0);\n\t\tval = 0; base = 10;\n\t\tif (c == '0') {\n\t\t\tc = *++cp;\n\t\t\tif (c == 'x' || c == 'X')\n\t\t\t\tbase = 16, c = *++cp;\n\t\t\telse\n\t\t\t\tbase = 8;\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (isascii(c) && isdigit(c)) {\n\t\t\t\tval = (val * base) + (c - '0');\n\t\t\t\tc = *++cp;\n\t\t\t} else if (base == 16 && isascii(c) && isxdigit(c)) {\n\t\t\t\tval = (val << 4) |\n\t\t\t\t\t(c + 10 - (islower(c) ? 'a' : 'A'));\n\t\t\t\tc = *++cp;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (c == '.') {\n\t\t\t \n\t\t\tif (pp >= parts + 3)\n\t\t\t\treturn (0);\n\t\t\t*pp++ = val;\n\t\t\tc = *++cp;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t \n\tif (c != '\\0' && (!isascii(c) || !isspace(c)))\n\t\treturn (0);\n\t \n\tn = pp - parts + 1;\n\tswitch (n) {\n\n\tcase 0:\n\t\treturn (0);\t\t \n\n\tcase 1:\t\t\t\t \n\t\tbreak;\n\n\tcase 2:\t\t\t\t \n\t\tif (val > 0xffffff)\n\t\t\treturn (0);\n\t\tval |= parts[0] << 24;\n\t\tbreak;\n\n\tcase 3:\t\t\t\t \n\t\tif (val > 0xffff)\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16);\n\t\tbreak;\n\n\tcase 4:\t\t\t\t \n\t\tif (val > 0xff)\n\t\t\treturn (0);\n\t\tval |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n\t\tbreak;\n\t}\n\tif (addr)\n\t\taddr->s_addr = htonl(val);\n\treturn (1);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}