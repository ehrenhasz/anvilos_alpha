{
  "module_name": "shmatch.c",
  "hash_id": "a3fa8c32fd76b2ec9ffc351d231b4ec95668230ab402ee8f8e7adaba63d921d9",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/shmatch.c",
  "human_readable_source": " \n\n \n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n#if defined (HAVE_POSIX_REGEXP)\n\n#ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n\n#include <stdio.h>\n#include <regex.h>\n\n#include \"shell.h\"\n#include \"variables.h\"\n#include \"externs.h\"\n\nextern int glob_ignore_case, match_ignore_case;\n\n#if defined (ARRAY_VARS)\nextern SHELL_VAR *builtin_find_indexed_array (char *, int);\n#endif\n\nint\nsh_regmatch (string, pattern, flags)\n     const char *string;\n     const char *pattern;\n     int flags;\n{\n  regex_t regex = { 0 };\n  regmatch_t *matches;\n  int rflags;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *rematch;\n  ARRAY *amatch;\n  int subexp_ind;\n  char *subexp_str;\n  int subexp_len;\n#endif\n  int result;\n\n#if defined (ARRAY_VARS)\n  rematch = (SHELL_VAR *)NULL;\n#endif\n\n  rflags = REG_EXTENDED;\n  if (match_ignore_case)\n    rflags |= REG_ICASE;\n#if !defined (ARRAY_VARS)\n  rflags |= REG_NOSUB;\n#endif\n\n  if (regcomp (&regex, pattern, rflags))\n    return 2;\t\t \n\n#if defined (ARRAY_VARS)\n  matches = (regmatch_t *)malloc (sizeof (regmatch_t) * (regex.re_nsub + 1));\n#else\n  matches = NULL;\n#endif\n\n   \n  if (regexec (&regex, string, matches ? regex.re_nsub + 1 : 0, matches, 0))\n    result = EXECUTION_FAILURE;\n  else\n    result = EXECUTION_SUCCESS;\t\t \n\n#if defined (ARRAY_VARS)\n  subexp_len = strlen (string) + 10;\n  subexp_str = malloc (subexp_len + 1);\n\n   \n#if 1\n  unbind_global_variable_noref (\"BASH_REMATCH\");\n  rematch = make_new_array_variable (\"BASH_REMATCH\");\n#else\n   \n  rematch = builtin_find_indexed_array (\"BASH_REMATCH\", 1);\n#endif\n  amatch = rematch ? array_cell (rematch) : (ARRAY *)0;\n\n  if (matches && amatch && (flags & SHMAT_SUBEXP) && result == EXECUTION_SUCCESS && subexp_str)\n    {\n      for (subexp_ind = 0; subexp_ind <= regex.re_nsub; subexp_ind++)\n\t{\n\t  memset (subexp_str, 0, subexp_len);\n\t  strncpy (subexp_str, string + matches[subexp_ind].rm_so,\n\t\t     matches[subexp_ind].rm_eo - matches[subexp_ind].rm_so);\n\t  array_insert (amatch, subexp_ind, subexp_str);\n\t}\n    }\n\n#if 0\n  VSETATTR (rematch, att_readonly);\n#endif\n\n  free (subexp_str);\n  free (matches);\n#endif  \n\n  regfree (&regex);\n\n  return result;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}