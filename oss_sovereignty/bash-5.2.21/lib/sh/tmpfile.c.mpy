{
  "module_name": "tmpfile.c",
  "hash_id": "99823fef37479641ef506f62f88fa95c4d207b87e93f591e59222bb841f13d7b",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/tmpfile.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <bashtypes.h>\n#include <posixstat.h>\n#include <posixtime.h>\n#include <filecntl.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <bashansi.h>\n\n#include <stdio.h>\n#include <errno.h>\n\n#include <shell.h>\n\n#ifndef errno\nextern int errno;\n#endif\n\n#define BASEOPENFLAGS\t(O_CREAT | O_TRUNC | O_EXCL | O_BINARY)\n\n#define DEFAULT_TMPDIR\t\t\".\"\t \n#define DEFAULT_NAMEROOT\t\"shtmp\"\n\n \n#if !HAVE_RANDOM\n#define random() rand()\n#endif\n\nextern pid_t dollar_dollar_pid;\n\nstatic char *get_sys_tmpdir PARAMS((void));\nstatic char *get_tmpdir PARAMS((int));\n\nstatic char *sys_tmpdir = (char *)NULL;\nstatic int ntmpfiles;\nstatic int tmpnamelen = -1;\nstatic unsigned long filenum = 1L;\n\nstatic char *\nget_sys_tmpdir ()\n{\n  if (sys_tmpdir)\n    return sys_tmpdir;\n\n#ifdef P_tmpdir\n  sys_tmpdir = P_tmpdir;\n  if (file_iswdir (sys_tmpdir))\n    return sys_tmpdir;\n#endif\n\n  sys_tmpdir = \"/tmp\";\n  if (file_iswdir (sys_tmpdir))\n    return sys_tmpdir;\n\n  sys_tmpdir = \"/var/tmp\";\n  if (file_iswdir (sys_tmpdir))\n    return sys_tmpdir;\n\n  sys_tmpdir = \"/usr/tmp\";\n  if (file_iswdir (sys_tmpdir))\n    return sys_tmpdir;\n\n  sys_tmpdir = DEFAULT_TMPDIR;\n\n  return sys_tmpdir;\n}\n\nstatic char *\nget_tmpdir (flags)\n     int flags;\n{\n  char *tdir;\n\n  tdir = (flags & MT_USETMPDIR) ? get_string_value (\"TMPDIR\") : (char *)NULL;\n  if (tdir && (file_iswdir (tdir) == 0 || strlen (tdir) > PATH_MAX))\n    tdir = 0;\n\n  if (tdir == 0)\n    tdir = get_sys_tmpdir ();\n\n#if defined (HAVE_PATHCONF) && defined (_PC_NAME_MAX)\n  if (tmpnamelen == -1)\n    tmpnamelen = pathconf (tdir, _PC_NAME_MAX);\n#else\n  tmpnamelen = 0;\n#endif\n\n  return tdir;\n}\n\nstatic void\nsh_seedrand ()\n{\n#if HAVE_RANDOM\n  int d;\n  static int seeded = 0;\n  if (seeded == 0)\n    {\n      struct timeval tv;\n  \t      \n      gettimeofday (&tv, NULL);\n      srandom (tv.tv_sec ^ tv.tv_usec ^ (getpid () << 16) ^ (uintptr_t)&d);\n      seeded = 1;\n    }\n#endif\n}\n\nchar *\nsh_mktmpname (nameroot, flags)\n     char *nameroot;\n     int flags;\n{\n  char *filename, *tdir, *lroot;\n  struct stat sb;\n  int r, tdlen;\n  static int seeded = 0;\n\n  filename = (char *)xmalloc (PATH_MAX + 1);\n  tdir = get_tmpdir (flags);\n  tdlen = strlen (tdir);\n\n  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;\n  if (nameroot == 0)\n    flags &= ~MT_TEMPLATE;\n\n  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)\n    flags &= ~MT_TEMPLATE;\n\n#ifdef USE_MKTEMP\n  if (flags & MT_TEMPLATE)\n    strcpy (filename, nameroot);\n  else\n    sprintf (filename, \"%s/%s.XXXXXX\", tdir, lroot);\n  if (mktemp (filename) == 0)\n    {\n      free (filename);\n      filename = NULL;\n    }\n#else   \n  sh_seedrand ();\n  while (1)\n    {\n      filenum = (filenum << 1) ^\n\t\t(unsigned long) time ((time_t *)0) ^\n\t\t(unsigned long) dollar_dollar_pid ^\n\t\t(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);\n      sprintf (filename, \"%s/%s-%lu\", tdir, lroot, filenum);\n      if (tmpnamelen > 0 && tmpnamelen < 32)\n\tfilename[tdlen + 1 + tmpnamelen] = '\\0';\n#  ifdef HAVE_LSTAT\n      r = lstat (filename, &sb);\n#  else\n      r = stat (filename, &sb);\n#  endif\n      if (r < 0 && errno == ENOENT)\n\tbreak;\n    }\n#endif  \n\n  return filename;\n}\n\nint\nsh_mktmpfd (nameroot, flags, namep)\n     char *nameroot;\n     int flags;\n     char **namep;\n{\n  char *filename, *tdir, *lroot;\n  int fd, tdlen;\n  \n  filename = (char *)xmalloc (PATH_MAX + 1);\n  tdir = get_tmpdir (flags);\n  tdlen = strlen (tdir);\n\n  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;\n  if (nameroot == 0)\n    flags &= ~MT_TEMPLATE;\n\n  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)\n    flags &= ~MT_TEMPLATE;\n\n#ifdef USE_MKSTEMP\n  if (flags & MT_TEMPLATE)\n    strcpy (filename, nameroot);\n  else\n    sprintf (filename, \"%s/%s.XXXXXX\", tdir, lroot);\n  fd = mkstemp (filename);\n  if (fd < 0 || namep == 0)\n    {\n      free (filename);\n      filename = NULL;\n    }\n  if (namep)\n    *namep = filename;\n  return fd;\n#else  \n  sh_seedrand ();\n  do\n    {\n      filenum = (filenum << 1) ^\n\t\t(unsigned long) time ((time_t *)0) ^\n\t\t(unsigned long) dollar_dollar_pid ^\n\t\t(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);\n      sprintf (filename, \"%s/%s-%lu\", tdir, lroot, filenum);\n      if (tmpnamelen > 0 && tmpnamelen < 32)\n\tfilename[tdlen + 1 + tmpnamelen] = '\\0';\n      fd = open (filename, BASEOPENFLAGS | ((flags & MT_READWRITE) ? O_RDWR : O_WRONLY), 0600);\n    }\n  while (fd < 0 && errno == EEXIST);\n\n  if (namep)\n    *namep = filename;\n  else\n    free (filename);\n\n  return fd;\n#endif  \n}\n\nFILE *\nsh_mktmpfp (nameroot, flags, namep)\n     char *nameroot;\n     int flags;\n     char **namep;\n{\n  int fd;\n  FILE *fp;\n\n  fd = sh_mktmpfd (nameroot, flags, namep);\n  if (fd < 0)\n    return ((FILE *)NULL);\n  fp = fdopen (fd, (flags & MT_READWRITE) ? \"w+\" : \"w\");\n  if (fp == 0)\n    close (fd);\n  return fp;\n}\n\nchar *\nsh_mktmpdir (nameroot, flags)\n     char *nameroot;\n     int flags;\n{\n  char *filename, *tdir, *lroot, *dirname;\n  int fd, tdlen;\n  \n#ifdef USE_MKDTEMP\n  filename = (char *)xmalloc (PATH_MAX + 1);\n  tdir = get_tmpdir (flags);\n  tdlen = strlen (tdir);\n\n  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;\n  if (nameroot == 0)\n    flags &= ~MT_TEMPLATE;\n\n  if ((flags & MT_TEMPLATE) && strlen (nameroot) > PATH_MAX)\n    flags &= ~MT_TEMPLATE;\n\n  if (flags & MT_TEMPLATE)\n    strcpy (filename, nameroot);\n  else\n    sprintf (filename, \"%s/%s.XXXXXX\", tdir, lroot);\n  dirname = mkdtemp (filename);\n  if (dirname == 0)\n    {\n      free (filename);\n      filename = NULL;\n    }\n  return dirname;\n#else  \n  filename = (char *)NULL;\n  do\n    {\n      filename = sh_mktmpname (nameroot, flags);\n      fd = mkdir (filename, 0700);\n      if (fd == 0)\n\tbreak;\n      free (filename);\n      filename = (char *)NULL;\n    }\n  while (fd < 0 && errno == EEXIST);\n\n  return (filename);\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}