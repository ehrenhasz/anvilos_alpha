{
  "module_name": "shquote.c",
  "hash_id": "da4be4f51e63f795d6bc5c1fa5246ef8a7de1ae231847ec258253fe50710f29d",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/shquote.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <stdc.h>\n\n#include \"syntax.h\"\n#include <xmalloc.h>\n\n#include \"shmbchar.h\"\n#include \"shmbutil.h\"\n\nextern char *ansic_quote PARAMS((char *, int, int *));\nextern int ansic_shouldquote PARAMS((const char *));\n\n \nstatic const char bstab[256] =\n  {\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 1, 0, 0, 0, 0, 0,\t \n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    1, 1, 1, 0, 1, 0, 1, 1,\t \n    1, 1, 1, 0, 1, 0, 0, 0,\t \n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 1, 1, 0, 1, 1,\t \n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 1, 1, 1, 1, 0,\t \n\n    1, 0, 0, 0, 0, 0, 0, 0,\t \n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 1, 1, 1, 0, 0,\t \n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n  };\n\n \n \n \n \n \n\n \nchar *\nsh_single_quote (string)\n     const char *string;\n{\n  register int c;\n  char *result, *r;\n  const char *s;\n\n  result = (char *)xmalloc (3 + (4 * strlen (string)));\n  r = result;\n\n  if (string[0] == '\\'' && string[1] == 0)\n    {\n      *r++ = '\\\\';\n      *r++ = '\\'';\n      *r++ = 0;\n      return result;\n    }\n\n  *r++ = '\\'';\n\n  for (s = string; s && (c = *s); s++)\n    {\n      *r++ = c;\n\n      if (c == '\\'')\n\t{\n\t  *r++ = '\\\\';\t \n\t  *r++ = '\\'';\n\t  *r++ = '\\'';\t \n\t}\n    }\n\n  *r++ = '\\'';\n  *r = '\\0';\n\n  return (result);\n}\n\n \nchar *\nsh_double_quote (string)\n     const char *string;\n{\n  register unsigned char c;\n  int mb_cur_max;\n  char *result, *r;\n  size_t slen;\n  const char *s, *send;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n  mb_cur_max = MB_CUR_MAX;\n\n  result = (char *)xmalloc (3 + (2 * strlen (string)));\n  r = result;\n  *r++ = '\"';\n\n  for (s = string; s && (c = *s); s++)\n    {\n       \n      if ((sh_syntaxtab[c] & CBSDQUOTE) && c != '\\n')\n\t*r++ = '\\\\';\n\n#if defined (HANDLE_MULTIBYTE)\n      if ((locale_utf8locale && (c & 0x80)) ||\n\t  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))\n\t{\n\t  COPY_CHAR_P (r, s, send);\n\t  s--;\t\t \n\t  continue;\n\t}\n#endif\n\n       \n      *r++ = c;\n    }\n\n  *r++ = '\"';\n  *r = '\\0';\n\n  return (result);\n}\n\n \nchar *\nsh_mkdoublequoted (s, slen, flags)\n     const char *s;\n     int slen, flags;\n{\n  char *r, *ret;\n  const char *send;\n  int rlen, mb_cur_max;\n  DECLARE_MBSTATE;\n\n  send = s + slen;\n  mb_cur_max = flags ? MB_CUR_MAX : 1;\n  rlen = (flags == 0) ? slen + 3 : (2 * slen) + 1;\n  ret = r = (char *)xmalloc (rlen);\n\n  *r++ = '\"';\n  while (*s)\n    {\n      if (flags && *s == '\"')\n\t*r++ = '\\\\';\n\n#if defined (HANDLE_MULTIBYTE)\n      if  (flags && ((locale_utf8locale && (*s & 0x80)) ||\n\t\t     (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (*s) == 0)))\n\t{\n\t  COPY_CHAR_P (r, s, send);\n\t  continue;\n\t}\n#endif\n      *r++ = *s++;\n    }\n  *r++ = '\"';\n  *r = '\\0';\n\n  return ret;\n}\n\n \nchar *\nsh_un_double_quote (string)\n     char *string;\n{\n  register int c, pass_next;\n  char *result, *r, *s;\n\n  r = result = (char *)xmalloc (strlen (string) + 1);\n\n  for (pass_next = 0, s = string; s && (c = *s); s++)\n    {\n      if (pass_next)\n\t{\n\t  *r++ = c;\n\t  pass_next = 0;\n\t  continue;\n\t}\n      if (c == '\\\\' && (sh_syntaxtab[(unsigned char) s[1]] & CBSDQUOTE))\n\t{\n\t  pass_next = 1;\n\t  continue;\n\t}\n      *r++ = c;\n    }\n\n  *r = '\\0';\n  return result;\n}\n\n \n   \nchar *\nsh_backslash_quote (string, table, flags)\n     char *string;\n     char *table;\n     int flags;\n{\n  int c, mb_cur_max;\n  size_t slen;\n  char *result, *r, *s, *backslash_table, *send;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n  result = (char *)xmalloc (2 * slen + 1);\n\n  backslash_table = table ? table : (char *)bstab;\n  mb_cur_max = MB_CUR_MAX;\n\n  for (r = result, s = string; s && (c = *s); s++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n       \n      if (c >= 0 && c <= 127 && backslash_table[(unsigned char)c] == 1)\n\t{\n\t  *r++ = '\\\\';\n\t  *r++ = c;\n\t  continue;\n\t}\n      if ((locale_utf8locale && (c & 0x80)) ||\n\t  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))\n\t{\n\t  COPY_CHAR_P (r, s, send);\n\t  s--;\t\t \n\t  continue;\n\t}\n#endif\n      if (backslash_table[(unsigned char)c] == 1)\n\t*r++ = '\\\\';\n      else if (c == '#' && s == string)\t\t\t \n\t*r++ = '\\\\';\n      else if ((flags&1) && c == '~' && (s == string || s[-1] == ':' || s[-1] == '='))\n         \n\t*r++ = '\\\\';\n      else if ((flags&2) && shellblank((unsigned char)c))\n\t*r++ = '\\\\';\n      *r++ = c;\n    }\n\n  *r = '\\0';\n  return (result);\n}\n\n#if defined (PROMPT_STRING_DECODE) || defined (TRANSLATABLE_STRINGS)\n \nchar *\nsh_backslash_quote_for_double_quotes (string, flags)\n     char *string;\n     int flags;\n{\n  unsigned char c;\n  char *result, *r, *s, *send;\n  size_t slen;\n  int mb_cur_max;\n  DECLARE_MBSTATE;\n \n  slen = strlen (string);\n  send = string + slen;\n  mb_cur_max = MB_CUR_MAX;\n  result = (char *)xmalloc (2 * slen + 1);\n\n  for (r = result, s = string; s && (c = *s); s++)\n    {\n       \n      if ((sh_syntaxtab[c] & CBSDQUOTE) && c != '\\n')\n\t*r++ = '\\\\';\n       \n      else if (c == CTLESC || c == CTLNUL)\n\t*r++ = CTLESC;\t\t \n\n#if defined (HANDLE_MULTIBYTE)\n      if ((locale_utf8locale && (c & 0x80)) ||\n\t  (locale_utf8locale == 0 && mb_cur_max > 1 && is_basic (c) == 0))\n\t{\n\t  COPY_CHAR_P (r, s, send);\n\t  s--;\t\t \n\t  continue;\n\t}\n#endif\n\n      *r++ = c;\n    }\n\n  *r = '\\0';\n  return (result);\n}\n#endif  \n\nchar *\nsh_quote_reusable (s, flags)\n     char *s;\n     int flags;\n{\n  char *ret;\n\n  if (s == 0)\n    return s;\n  else if (*s == 0)\n    {\n      ret = (char *)xmalloc (3);\n      ret[0] = ret[1] = '\\'';\n      ret[2] = '\\0';\n    }\n  else if (ansic_shouldquote (s))\n    ret = ansic_quote (s, 0, (int *)0);\n  else if (flags)\n    ret = sh_backslash_quote (s, 0, 1);\n  else\n    ret = sh_single_quote (s);\n\n  return ret;\n}\n\nint\nsh_contains_shell_metas (string)\n     const char *string;\n{\n  const char *s;\n\n  for (s = string; s && *s; s++)\n    {\n      switch (*s)\n\t{\n\tcase ' ': case '\\t': case '\\n':\t\t \n\tcase '\\'': case '\"': case '\\\\':\t\t \n\tcase '|': case '&': case ';':\t\t \n\tcase '(': case ')': case '<': case '>':\n\tcase '!': case '{': case '}':\t\t \n\tcase '*': case '[': case '?': case ']':\t \n\tcase '^':\n\tcase '$': case '`':\t\t\t \n\t  return (1);\n\tcase '~':\t\t\t\t \n\t  if (s == string || s[-1] == '=' || s[-1] == ':')\n\t    return (1);\n\t  break;\n\tcase '#':\n\t  if (s == string)\t\t\t \n\t    return (1);\n\t   \n\tdefault:\n\t  break;\n\t}\n    }\n\n  return (0);\n}\n\nint\nsh_contains_quotes (string)\n     const char *string;\n{\n  const char *s;\n\n  for (s = string; s && *s; s++)\n    {\n      if (*s == '\\'' || *s == '\"' || *s == '\\\\')\n\treturn 1;\n    }\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}