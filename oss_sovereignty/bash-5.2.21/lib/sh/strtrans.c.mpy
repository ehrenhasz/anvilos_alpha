{
  "module_name": "strtrans.c",
  "hash_id": "a70048b1ba69a3aae66d16bb97f7b4755e211a56b14e6427c7a7c4ee412b88e0",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/strtrans.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <bashansi.h>\n#include <stdio.h>\n#include <chartypes.h>\n\n#include \"shell.h\"\n\n#include \"shmbchar.h\"\n#include \"shmbutil.h\"\n\n#ifdef ESC\n#undef ESC\n#endif\n#define ESC '\\033'\t \n\n \nchar *\nansicstr (string, len, flags, sawc, rlen)\n     char *string;\n     int len, flags, *sawc, *rlen;\n{\n  int c, temp;\n  char *ret, *r, *s;\n  unsigned long v;\n  size_t clen;\n  int b, mb_cur_max;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t wc;\n#endif\n\n  if (string == 0 || *string == '\\0')\n    return ((char *)NULL);\n\n  mb_cur_max = MB_CUR_MAX;\n#if defined (HANDLE_MULTIBYTE)\n  temp = 4*len + 4;\n  if (temp < 12)\n    temp = 12;\t\t\t\t \n  ret = (char *)xmalloc (temp);\n#else\n  ret = (char *)xmalloc (2*len + 1);\t \n#endif\n  for (r = ret, s = string; s && *s; )\n    {\n      c = *s++;\n      if (c != '\\\\' || *s == '\\0')\n\t{\n\t  clen = 1;\n#if defined (HANDLE_MULTIBYTE)\n\t  if ((locale_utf8locale && (c & 0x80)) ||\n\t      (locale_utf8locale == 0 && mb_cur_max > 0 && is_basic (c) == 0))\n\t    {\n\t      clen = mbrtowc (&wc, s - 1, mb_cur_max, 0);\n\t      if (MB_INVALIDCH (clen))\n\t\tclen = 1;\n\t    }\n#endif\n\t  *r++ = c;\n\t  for (--clen; clen > 0; clen--)\n\t    *r++ = *s++;\n\t}\n      else\n\t{\n\t  switch (c = *s++)\n\t    {\n#if defined (__STDC__)\n\t    case 'a': c = '\\a'; break;\n\t    case 'v': c = '\\v'; break;\n#else\n\t    case 'a': c = (int) 0x07; break;\n\t    case 'v': c = (int) 0x0B; break;\n#endif\n\t    case 'b': c = '\\b'; break;\n\t    case 'e': case 'E':\t\t \n\t      c = ESC; break;\n\t    case 'f': c = '\\f'; break;\n\t    case 'n': c = '\\n'; break;\n\t    case 'r': c = '\\r'; break;\n\t    case 't': c = '\\t'; break;\n\t    case '1': case '2': case '3':\n\t    case '4': case '5': case '6':\n\t    case '7':\n#if 1\n\t      if (flags & 1)\n\t\t{\n\t\t  *r++ = '\\\\';\n\t\t  break;\n\t\t}\n\t     \n#endif\n\t    case '0':\n\t       \n\t      temp = 2 + ((flags & 1) && (c == '0'));\n\t      for (c -= '0'; ISOCTAL (*s) && temp--; s++)\n\t\tc = (c * 8) + OCTVALUE (*s);\n\t      c &= 0xFF;\n\t      break;\n\t    case 'x':\t\t\t \n\t      if ((flags & 2) && *s == '{')\n\t\t{\n\t\t  flags |= 16;\t\t \n\t\t  s++;\n\t\t}\n\t       \n\t      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)\n\t\tc = (c * 16) + HEXVALUE (*s);\n\t       \n\t      if (flags & 16)\n\t\t{\n\t\t  for ( ; ISXDIGIT ((unsigned char)*s); s++)\n\t\t    c = (c * 16) + HEXVALUE (*s);\n\t\t  flags &= ~16;\n\t\t  if (*s == '}')\n\t\t    s++;\n\t        }\n\t       \n\t      else if (temp == 2)\n\t\t{\n\t\t  *r++ = '\\\\';\n\t\t  c = 'x';\n\t\t}\n\t      c &= 0xFF;\n\t      break;\n#if defined (HANDLE_MULTIBYTE)\n\t    case 'u':\n\t    case 'U':\n\t      temp = (c == 'u') ? 4 : 8;\t \n\t      for (v = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)\n\t\tv = (v * 16) + HEXVALUE (*s);\n\t      if (temp == ((c == 'u') ? 4 : 8))\n\t\t{\n\t\t  *r++ = '\\\\';\t \n\t\t  break;\n\t\t}\n\t      else if (v <= 0x7f)\t \n\t\t{\n\t\t  c = v;\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  temp = u32cconv (v, r);\n\t\t  r += temp;\n\t\t  continue;\n\t\t}\n#endif\n\t    case '\\\\':\n\t      break;\n\t    case '\\'': case '\"': case '?':\n\t      if (flags & 1)\n\t\t*r++ = '\\\\';\n\t      break;\n\t    case 'c':\n\t      if (sawc)\n\t\t{\n\t\t  *sawc = 1;\n\t\t  *r = '\\0';\n\t\t  if (rlen)\n\t\t    *rlen = r - ret;\n\t\t  return ret;\n\t\t}\n\t      else if ((flags & 1) == 0 && *s == 0)\n\t\t;\t\t \n\t      else if ((flags & 1) == 0 && (c = *s))\n\t\t{\n\t\t  s++;\n\t\t  if ((flags & 2) && c == '\\\\' && c == *s)\n\t\t    s++;\t \n\t\t  c = TOCTRL(c);\n\t\t  break;\n\t\t}\n\t\t \n\t    default:\n\t\tif ((flags & 4) == 0)\n\t\t  *r++ = '\\\\';\n\t\tbreak;\n\t    }\n\t  if ((flags & 2) && (c == CTLESC || c == CTLNUL))\n\t    *r++ = CTLESC;\n\t  *r++ = c;\n\t}\n    }\n  *r = '\\0';\n  if (rlen)\n    *rlen = r - ret;\n  return ret;\n}\n\n \nchar *\nansic_quote (str, flags, rlen)\n     char *str;\n     int flags, *rlen;\n{\n  char *r, *ret, *s;\n  int l, rsize;\n  unsigned char c;\n  size_t clen;\n  int b;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t wc;\n#endif\n\n  if (str == 0 || *str == 0)\n    return ((char *)0);\n\n  l = strlen (str);\n  rsize = 4 * l + 4;\n  r = ret = (char *)xmalloc (rsize);\n\n  *r++ = '$';\n  *r++ = '\\'';\n\n  for (s = str; c = *s; s++)\n    {\n      b = l = 1;\t\t \n      clen = 1;\n\n      switch (c)\n\t{\n\tcase ESC: c = 'E'; break;\n#ifdef __STDC__\n\tcase '\\a': c = 'a'; break;\n\tcase '\\v': c = 'v'; break;\n#else\n\tcase 0x07: c = 'a'; break;\n\tcase 0x0b: c = 'v'; break;\n#endif\n\n\tcase '\\b': c = 'b'; break;\n\tcase '\\f': c = 'f'; break;\n\tcase '\\n': c = 'n'; break;\n\tcase '\\r': c = 'r'; break;\n\tcase '\\t': c = 't'; break;\n\tcase '\\\\':\n\tcase '\\'':\n\t  break;\n\tdefault:\n#if defined (HANDLE_MULTIBYTE)\n\t  b = is_basic (c);\n\t   \n\t  if ((b == 0 && ((clen = mbrtowc (&wc, s, MB_CUR_MAX, 0)) < 0 || MB_INVALIDCH (clen) || iswprint (wc) == 0)) ||\n\t      (b == 1 && ISPRINT (c) == 0))\n#else\n\t  if (ISPRINT (c) == 0)\n#endif\n\t    {\n\t      *r++ = '\\\\';\n\t      *r++ = TOCHAR ((c >> 6) & 07);\n\t      *r++ = TOCHAR ((c >> 3) & 07);\n\t      *r++ = TOCHAR (c & 07);\n\t      continue;\n\t    }\n\t  l = 0;\n\t  break;\n\t}\n      if (b == 0 && clen == 0)\n\tbreak;\n\n      if (l)\n\t*r++ = '\\\\';\n\n      if (clen == 1)\n\t*r++ = c;\n      else\n\t{\n\t  for (b = 0; b < (int)clen; b++)\n\t    *r++ = (unsigned char)s[b];\n\t  s += clen - 1;\t \n\t}\n    }\n\n  *r++ = '\\'';\n  *r = '\\0';\n  if (rlen)\n    *rlen = r - ret;\n  return ret;\n}\n\n#if defined (HANDLE_MULTIBYTE)\nint\nansic_wshouldquote (string)\n     const char *string;\n{\n  const wchar_t *wcs;\n  wchar_t wcc;\n  wchar_t *wcstr = NULL;\n  size_t slen;\n\n  slen = mbstowcs (wcstr, string, 0);\n\n  if (slen == (size_t)-1)\n    return 1;\n\n  wcstr = (wchar_t *)xmalloc (sizeof (wchar_t) * (slen + 1));\n  mbstowcs (wcstr, string, slen + 1);\n\n  for (wcs = wcstr; wcc = *wcs; wcs++)\n    if (iswprint(wcc) == 0)\n      {\n\tfree (wcstr);\n\treturn 1;\n      }\n\n  free (wcstr);\n  return 0;\n}\n#endif\n\n \nint\nansic_shouldquote (string)\n     const char *string;\n{\n  const char *s;\n  unsigned char c;\n\n  if (string == 0)\n    return 0;\n\n  for (s = string; c = *s; s++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (is_basic (c) == 0)\n\treturn (ansic_wshouldquote (s));\n#endif\n      if (ISPRINT (c) == 0)\n\treturn 1;\n    }\n\n  return 0;\n}\n\n \nchar *\nansiexpand (string, start, end, lenp)\n     char *string;\n     int start, end, *lenp;\n{\n  char *temp, *t;\n  int len, tlen;\n\n  temp = (char *)xmalloc (end - start + 1);\n  for (tlen = 0, len = start; len < end; )\n    temp[tlen++] = string[len++];\n  temp[tlen] = '\\0';\n\n  if (*temp)\n    {\n      t = ansicstr (temp, tlen, 2, (int *)NULL, lenp);\n      free (temp);\n      return (t);\n    }\n  else\n    {\n      if (lenp)\n\t*lenp = 0;\n      return (temp);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}