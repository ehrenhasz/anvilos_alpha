{
  "module_name": "pathphys.c",
  "hash_id": "cceb226c448e8b2b03a8a0d3971bd0b8e3b9befc622c84c6d9f361ed9962be00",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/pathphys.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <bashtypes.h>\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n#include <posixstat.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <filecntl.h>\n#include <bashansi.h>\n#include <stdio.h>\n#include <chartypes.h>\n#include <errno.h>\n\n#include \"shell.h\"\n\n#if !defined (MAXSYMLINKS)\n#  define MAXSYMLINKS 32\n#endif\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\nextern char *get_working_directory PARAMS((char *));\n\nstatic int\n_path_readlink (path, buf, bufsiz)\n     char *path;\n     char *buf;\n     int bufsiz;\n{\n#ifdef HAVE_READLINK\n  return readlink (path, buf, bufsiz);\n#else\n  errno = EINVAL;\n  return -1;\n#endif\n}\n\n \n\n#define DOUBLE_SLASH(p)\t((p[0] == '/') && (p[1] == '/') && p[2] != '/')\n\n \n\nchar *\nsh_physpath (path, flags)\n     char *path;\n     int flags;\n{\n  char tbuf[PATH_MAX+1], linkbuf[PATH_MAX+1];\n  char *result, *p, *q, *qsave, *qbase, *workpath;\n  int double_slash_path, linklen, nlink;\n\n  linklen = strlen (path);\n\n#if 0\n   \n  if (linklen >= PATH_MAX)\n    return (savestring (path));\n#endif\n\n  nlink = 0;\n  q = result = (char *)xmalloc (PATH_MAX + 1);\n\n   \n  if (linklen >= PATH_MAX)\n    workpath = savestring (path);\n  else\n    {\n      workpath = (char *)xmalloc (PATH_MAX + 1);\n      strcpy (workpath, path);\n    }\n\n   \n\n   \n#if defined (__CYGWIN__)\n  qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;\n#else\n  qbase = workpath + 1;\n#endif\n  double_slash_path = DOUBLE_SLASH (workpath);\n  qbase += double_slash_path;\n\n  for (p = workpath; p < qbase; )\n    *q++ = *p++;\n  qbase = q;\n\n   \n\n  while (*p)\n    {\n      if (ISDIRSEP(p[0]))  \n\tp++;\n      else if(p[0] == '.' && PATHSEP(p[1]))\t \n\tp += 1; \t \n      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2]))  \n\t{\n\t  p += 2;  \n\t  if (q > qbase)\n\t    {\n\t      while (--q > qbase && ISDIRSEP(*q) == 0)\n\t\t;\n\t    }\n\t}\n      else\t \n\t{\n\t   \n\t  qsave = q;\n\t  if (q != qbase)\n\t    *q++ = DIRSEP;\n\t  while (*p && (ISDIRSEP(*p) == 0))\n\t    {\n\t      if (q - result >= PATH_MAX)\n\t\t{\n#ifdef ENAMETOOLONG\n\t\t  errno = ENAMETOOLONG;\n#else\n\t\t  errno = EINVAL;\n#endif\n\t\t  goto error;\n\t\t}\n\t\t\n\t      *q++ = *p++;\n\t    }\n\n\t  *q = '\\0';\n\n\t  linklen = _path_readlink (result, linkbuf, PATH_MAX);\n\t  if (linklen < 0)\t \n\t    {\n\t      if (errno != EINVAL)\n\t\tgoto error;\n\t      continue;\n\t    }\n\n\t   \n\t  nlink++;\n\t  if (nlink > MAXSYMLINKS)\n\t    {\n#ifdef ELOOP\n\t      errno = ELOOP;\n#else\n\t      errno = EINVAL;\n#endif\nerror:\n\t      free (result);\n\t      free (workpath);\n\t      return ((char *)NULL);\n\t    }\n\n\t  linkbuf[linklen] = '\\0';\n\n\t   \n\t  if ((strlen (p) + linklen + 2) >= PATH_MAX)\n\t    {\n#ifdef ENAMETOOLONG\n\t      errno = ENAMETOOLONG;\n#else\n\t      errno = EINVAL;\n#endif\n\t      goto error;\n\t    }\n\n\t   \n\t  strcpy (tbuf, linkbuf);\n\t  tbuf[linklen] = '/';\n\t  strcpy (tbuf + linklen, p);\n\t  strcpy (workpath, tbuf);\n\n\t  if (ABSPATH(linkbuf))\n\t    {\n\t      q = result;\n\t       \n#if defined (__CYGWIN__)\n\t      qbase = (ISALPHA((unsigned char)workpath[0]) && workpath[1] == ':') ? workpath + 3 : workpath + 1;\n#else\n\t      qbase = workpath + 1;\n#endif\n\t      double_slash_path = DOUBLE_SLASH (workpath);\n\t      qbase += double_slash_path;\n    \n\t      for (p = workpath; p < qbase; )\n\t\t*q++ = *p++;\n\t      qbase = q;\n\t    }\n\t  else\n\t    {\n\t      p = workpath;\n\t      q = qsave;\n\t    }\n\t}\n    }\n\n  *q = '\\0';\n  free (workpath);\n\n   \n  if (DOUBLE_SLASH(result) && double_slash_path == 0)\n    {\n      if (result[2] == '\\0')\t \n\tresult[1] = '\\0';\n      else\n\tmemmove (result, result + 1, strlen (result + 1) + 1);\n    }\n\n  return (result);\n}\n\nchar *\nsh_realpath (pathname, resolved)\n     const char *pathname;\n     char *resolved;\n{\n  char *tdir, *wd;\n\n  if (pathname == 0 || *pathname == '\\0')\n    {\n      errno = (pathname == 0) ? EINVAL : ENOENT;\n      return ((char *)NULL);\n    }\n\n  if (ABSPATH (pathname) == 0)\n    {\n      wd = get_working_directory (\"sh_realpath\");\n      if (wd == 0)\n\treturn ((char *)NULL);\n      tdir = sh_makepath (wd, (char *)pathname, 0);\n      free (wd);\n    }\n  else\n    tdir = savestring (pathname);\n\n  wd = sh_physpath (tdir, 0);\n  free (tdir);\n\n  if (resolved == 0)\n    return (wd);\n\n  if (wd)\n    {\n      strncpy (resolved, wd, PATH_MAX - 1);\n      resolved[PATH_MAX - 1] = '\\0';\n      free (wd);\n      return resolved;\n    }\n  else\n    {\n      resolved[0] = '\\0';\n      return wd;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}