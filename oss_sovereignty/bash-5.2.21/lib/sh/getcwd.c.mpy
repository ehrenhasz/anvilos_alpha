{
  "module_name": "getcwd.c",
  "hash_id": "fb5e5bf514e3873ab21e7870dce4e2aa1d81c0550ccd0f627b923727547b45c1",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/getcwd.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if !defined (HAVE_GETCWD)\n\n#if !defined (__GNUC__) && !defined (HAVE_ALLOCA_H) && defined (_AIX)\n  #pragma alloca\n#endif  \n\n#if defined (__QNX__)\n#  undef HAVE_LSTAT\n#endif\n\n#include <bashtypes.h>\n#include <errno.h>\n\n#if defined (HAVE_LIMITS_H)\n#  include <limits.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <posixdir.h>\n#include <posixstat.h>\n#include <maxpath.h>\n#include <memalloc.h>\n\n#include <bashansi.h>\n\n#if !defined (D_FILENO_AVAILABLE)\n#  include \"command.h\"\n#  include \"general.h\"\n#  include \"externs.h\"\n#endif\n\n#include <xmalloc.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#if !defined (HAVE_LSTAT)\n#  define lstat stat\n#endif\n\n#if !defined (NULL)\n#  define NULL 0\n#endif\n\n \n#if !defined (D_FILENO_AVAILABLE)\nstatic int\n_path_checkino (dotp, name, thisino)\n     char *dotp;\n     char *name;\n     ino_t thisino;\n{\n  char *fullpath;\n  int r, e;\n  struct stat st;\n\n  e = errno;\n  fullpath = sh_makepath (dotp, name, MP_RMDOT);\n  if (stat (fullpath, &st) < 0)\n    {\n      errno = e;\n      return 0;\n    }\n  free (fullpath);\n  errno = e;\n  return (st.st_ino == thisino);\n}\n#endif\n    \n \n#if defined (__STDC__)\nchar *\ngetcwd (char *buf, size_t size)\n#else  \nchar *\ngetcwd (buf, size)\n     char *buf;\n     size_t size;\n#endif  \n{\n  static const char dots[]\n    = \"../../../../../../../../../../../../../../../../../../../../../../../\\\n../../../../../../../../../../../../../../../../../../../../../../../../../../\\\n../../../../../../../../../../../../../../../../../../../../../../../../../..\";\n  const char *dotp, *dotlist;\n  size_t dotsize;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char path[PATH_MAX + 1];\n  register char *pathp;\n  char *pathbuf;\n  size_t pathsize;\n  struct stat st;\n  int saved_errno;\n\n  if (buf != NULL && size == 0)\n    {\n      errno = EINVAL;\n      return ((char *)NULL);\n    }\n\n  pathsize = sizeof (path);\n  pathp = &path[pathsize];\n  *--pathp = '\\0';\n  pathbuf = path;\n\n  if (stat (\".\", &st) < 0)\n    return ((char *)NULL);\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (stat (\"/\", &st) < 0)\n    return ((char *)NULL);\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  saved_errno = 0;\n\n  dotsize = sizeof (dots) - 1;\n  dotp = &dots[sizeof (dots)];\n  dotlist = dots;\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      register DIR *dirstream;\n      register struct dirent *d;\n      dev_t dotdev;\n      ino_t dotino;\n      char mount_point;\n      int namlen;\n\n      /* Look at the parent directory.  */\n      if (dotp == dotlist)\n\t{\n\t  /* My, what a deep directory tree you have, Grandma.  */\n\t  char *new;\n\t  if (dotlist == dots)\n\t    {\n\t      new = (char *)malloc (dotsize * 2 + 1);\n\t      if (new == NULL)\n\t\tgoto lose;\n\t      memcpy (new, dots, dotsize);\n\t    }\n\t  else\n\t    {\n\t      new = (char *)realloc ((PTR_T) dotlist, dotsize * 2 + 1);\n\t      if (new == NULL)\n\t\tgoto lose;\n\t    }\n\t  memcpy (&new[dotsize], new, dotsize);\n\t  dotp = &new[dotsize];\n\t  dotsize *= 2;\n\t  new[dotsize] = '\\0';\n\t  dotlist = new;\n\t}\n\n      dotp -= 3;\n\n      /* Figure out if this directory is a mount point.  */\n      if (stat (dotp, &st) < 0)\n\tgoto lose;\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n      dirstream = opendir (dotp);\n      if (dirstream == NULL)\n\tgoto lose;\n      while ((d = readdir (dirstream)) != NULL)\n\t{\n\t  if (d->d_name[0] == '.' &&\n\t      (d->d_name[1] == '\\0' ||\n\t\t(d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n\t    continue;\n#if defined (D_FILENO_AVAILABLE)\n\t  if (mount_point || d->d_fileno == thisino)\n#else\n\t  if (mount_point || _path_checkino (dotp, d->d_name, thisino))\n#endif\n\t    {\n\t      char *name;\n\n\t      namlen = D_NAMLEN(d);\n\t      name = (char *)\n\t\talloca (dotlist + dotsize - dotp + 1 + namlen + 1);\n\t      memcpy (name, dotp, dotlist + dotsize - dotp);\n\t      name[dotlist + dotsize - dotp] = '/';\n\t      memcpy (&name[dotlist + dotsize - dotp + 1],\n\t\t      d->d_name, namlen + 1);\n\t      if (lstat (name, &st) < 0)\n\t\t{\n#if 0\n\t\t  int save = errno;\n\t\t  (void) closedir (dirstream);\n\t\t  errno = save;\n\t\t  goto lose;\n#else\n\t\t  saved_errno = errno;\n#endif\n\t\t}\n\t      if (st.st_dev == thisdev && st.st_ino == thisino)\n\t\tbreak;\n\t    }\n\t}\n      if (d == NULL)\n\t{\n#if 0\n\t  int save = errno;\n#else\n\t  int save = errno ? errno : saved_errno;\n#endif\n\t  (void) closedir (dirstream);\n\t  errno = save;\n\t  goto lose;\n\t}\n      else\n\t{\n\t  size_t space;\n\n\t  while ((space = pathp - pathbuf) <= namlen)\n\t    {\n\t      char *new;\n\n\t      if (pathbuf == path)\n\t\t{\n\t\t  new = (char *)malloc (pathsize * 2);\n\t\t  if (!new)\n\t\t    goto lose;\n\t\t}\n\t      else\n\t\t{\n\t\t  new = (char *)realloc ((PTR_T) pathbuf, (pathsize * 2));\n\t\t  if (!new)\n\t\t    goto lose;\n\t\t  pathp = new + space;\n\t\t}\n\t      (void) memcpy (new + pathsize + space, pathp, pathsize - space);\n\t      pathp = new + pathsize + space;\n\t      pathbuf = new;\n\t      pathsize *= 2;\n\t    }\n\n\t  pathp -= namlen;\n\t  (void) memcpy (pathp, d->d_name, namlen);\n\t  *--pathp = '/';\n\t  (void) closedir (dirstream);\n\t}\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (pathp == &path[sizeof(path) - 1])\n    *--pathp = '/';\n\n  if (dotlist != dots)\n    free ((PTR_T) dotlist);\n\n  {\n    size_t len = pathbuf + pathsize - pathp;\n    if (buf == NULL && size <= 0)\n      size = len;\n\n    if ((size_t) size < len)\n      {\n\terrno = ERANGE;\n\tgoto lose2;\n      }\n    if (buf == NULL)\n      {\n\tbuf = (char *) malloc (size);\n\tif (buf == NULL)\n\t  goto lose2;\n      }\n\n    (void) memcpy((PTR_T) buf, (PTR_T) pathp, len);\n  }\n\n  if (pathbuf != path)\n    free (pathbuf);\n\n  return (buf);\n\n lose:\n  if ((dotlist != dots) && dotlist)\n    {\n      int e = errno;\n      free ((PTR_T) dotlist);\n      errno = e;\n    }\n\n lose2:\n  if ((pathbuf != path) && pathbuf)\n    {\n      int e = errno;\n      free ((PTR_T) pathbuf);\n      errno = e;\n    }\n  return ((char *)NULL);\n}\n\n#if defined (TEST)\n#  include <stdio.h>\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  char b[PATH_MAX];\n\n  if (getcwd(b, sizeof(b)))\n    {\n      printf (\"%s\\n\", b);\n      exit (0);\n    }\n  else\n    {\n      perror (\"cwd: getcwd\");\n      exit (1);\n    }\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}