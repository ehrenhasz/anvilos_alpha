{
  "module_name": "casemod.c",
  "hash_id": "b5ecd546ac0d7923bd4437abe29851e0d6f6d66356a61d9bcda3e14772fb1f76",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/casemod.c",
  "human_readable_source": " \n\n \n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#include <stdc.h>\n\n#include <bashansi.h>\n#include <bashintl.h>\n#include <bashtypes.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <xmalloc.h>\n\n#include <shmbchar.h>\n#include <shmbutil.h>\n#include <chartypes.h>\n#include <typemax.h>\n\n#include <glob/strmatch.h>\n\n#define _to_wupper(wc)\t(iswlower (wc) ? towupper (wc) : (wc))\n#define _to_wlower(wc)\t(iswupper (wc) ? towlower (wc) : (wc))\n\n#if !defined (HANDLE_MULTIBYTE)\n#  define cval(s, i, l)\t((s)[(i)])\n#  define iswalnum(c)\t(isalnum(c))\n#  define TOGGLE(x)\t(ISUPPER (x) ? tolower ((unsigned char)x) : (TOUPPER (x)))\n#else\n#  define TOGGLE(x)\t(iswupper (x) ? towlower (x) : (_to_wupper(x)))\n#endif\n\n \n#define CASE_NOOP\t0x0000\n#define CASE_LOWER\t0x0001\n#define CASE_UPPER\t0x0002\n#define CASE_CAPITALIZE\t0x0004\n#define CASE_UNCAP\t0x0008\n#define CASE_TOGGLE\t0x0010\n#define CASE_TOGGLEALL\t0x0020\n#define CASE_UPFIRST\t0x0040\n#define CASE_LOWFIRST\t0x0080\n\n#define CASE_USEWORDS\t0x1000\t\t \n\nextern char *substring PARAMS((char *, int, int));\n\n#ifndef UCHAR_MAX\n#  define UCHAR_MAX\tTYPE_MAXIMUM(unsigned char)\n#endif\n\n#if defined (HANDLE_MULTIBYTE)\nstatic wchar_t\ncval (s, i, l)\n     char *s;\n     int i, l;\n{\n  size_t tmp;\n  wchar_t wc;\n  mbstate_t mps;  \n\n  if (MB_CUR_MAX == 1 || is_basic (s[i]))\n    return ((wchar_t)s[i]);\n  if (i >= (l - 1))\n    return ((wchar_t)s[i]);\n  memset (&mps, 0, sizeof (mbstate_t));\n  tmp = mbrtowc (&wc, s + i, l - i, &mps);\n  if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))\n    return ((wchar_t)s[i]);\n  return wc;  \n}\n#endif\n\n \nchar *\nsh_modcase (string, pat, flags)\n     const char *string;\n     char *pat;\n     int flags;\n{\n  int start, next, end, retind;\n  int inword, c, nc, nop, match, usewords;\n  char *ret, *s;\n  wchar_t wc;\n  int mb_cur_max;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t nwc;\n  char mb[MB_LEN_MAX+1];\n  int mlen;\n  size_t m;\n  mbstate_t state;\n#endif\n\n  if (string == 0 || *string == 0)\n    {\n      ret = (char *)xmalloc (1);\n      ret[0] = '\\0';\n      return ret;\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (&state, 0, sizeof (mbstate_t));\n#endif\n\n  start = 0;\n  end = strlen (string);\n  mb_cur_max = MB_CUR_MAX;\n\n  ret = (char *)xmalloc (2*end + 1);\n  retind = 0;\n\n   \n  usewords = (flags & CASE_USEWORDS);\n  flags &= ~CASE_USEWORDS;\n\n  inword = 0;\n  while (start < end)\n    {\n      wc = cval ((char *)string, start, end);\n\n      if (iswalnum (wc) == 0)\n\tinword = 0;\n\n      if (pat)\n\t{\n\t  next = start;\n\t  ADVANCE_CHAR (string, end, next);\n\t  s = substring ((char *)string, start, next);\n\t  match = strmatch (pat, s, FNM_EXTMATCH) != FNM_NOMATCH;\n\t  free (s);\n\t  if (match == 0)\n            {\n               \n              memcpy (ret + retind, string + start, next - start);\n              retind += next - start;\n              start = next;\n              inword = 1;\n              continue;\n            }\n\t}\n\n       \n      if (flags == CASE_CAPITALIZE)\n\t{\n\t  if (usewords)\n\t    nop = inword ? CASE_LOWER : CASE_UPPER;\n\t  else\n\t    nop = (start > 0) ? CASE_LOWER : CASE_UPPER;\n\t  inword = 1;\n\t}\n      else if (flags == CASE_UNCAP)\n\t{\n\t  if (usewords)\n\t    nop = inword ? CASE_UPPER : CASE_LOWER;\n\t  else\n\t    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;\n\t  inword = 1;\n\t}\n      else if (flags == CASE_UPFIRST)\n \t{\n \t  if (usewords)\n\t    nop = inword ? CASE_NOOP : CASE_UPPER;\n\t  else\n\t    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;\n \t  inword = 1;\n \t}\n      else if (flags == CASE_LOWFIRST)\n \t{\n \t  if (usewords)\n\t    nop = inword ? CASE_NOOP : CASE_LOWER;\n\t  else\n\t    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;\n \t  inword = 1;\n \t}\n      else if (flags == CASE_TOGGLE)\n\t{\n\t  nop = inword ? CASE_NOOP : CASE_TOGGLE;\n\t  inword = 1;\n\t}\n      else\n\tnop = flags;\n\n       \n      if (mb_cur_max == 1)\n\t{\nsinglebyte:\n\t  switch (nop)\n\t    {\n\t    default:\n\t    case CASE_NOOP:  nc = wc; break;\n\t    case CASE_UPPER:  nc = TOUPPER (wc); break;\n\t    case CASE_LOWER:  nc = TOLOWER (wc); break;\n\t    case CASE_TOGGLEALL:\n\t    case CASE_TOGGLE: nc = TOGGLE (wc); break;\n\t    }\n\t  ret[retind++] = nc;\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      else\n\t{\n\t  m = mbrtowc (&wc, string + start, end - start, &state);\n\t   \n\t  if (MB_INVALIDCH (m))\n\t    {\n\t      wc = (unsigned char)string[start];\n\t      goto singlebyte;\n\t    }\n\t  else if (MB_NULLWCH (m))\n\t    wc = L'\\0';\n\t  switch (nop)\n\t    {\n\t    default:\n\t    case CASE_NOOP:  nwc = wc; break;\n\t    case CASE_UPPER:  nwc = _to_wupper (wc); break;\n\t    case CASE_LOWER:  nwc = _to_wlower (wc); break;\n\t    case CASE_TOGGLEALL:\n\t    case CASE_TOGGLE: nwc = TOGGLE (wc); break;\n\t    }\n\n\t   \n\t  if ((int)nwc <= UCHAR_MAX && is_basic ((int)nwc))\n\t    ret[retind++] = nwc;\n\t  else\n\t    {\n\t      mlen = wcrtomb (mb, nwc, &state);\n\t      if (mlen > 0)\n\t\tmb[mlen] = '\\0';\n\t       \n\t      strncpy (ret + retind, mb, mlen);\n\t      retind += mlen;\n\t    }\n\t}\n#endif\n\n      ADVANCE_CHAR (string, end, start);\n    }\n\n  ret[retind] = '\\0';\n  return ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}