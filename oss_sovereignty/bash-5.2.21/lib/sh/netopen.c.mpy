{
  "module_name": "netopen.c",
  "hash_id": "29ff44af1e24dc5bbc5227bd78d180b08eb30190fc88f15e3d45ab0c5462d25b",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/netopen.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_NETWORK)\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h> \n#include <sys/types.h>\n\n#if defined (HAVE_SYS_SOCKET_H)\n#  include <sys/socket.h>\n#endif\n\n#if defined (HAVE_NETINET_IN_H)\n#  include <netinet/in.h>\n#endif\n\n#if defined (HAVE_NETDB_H)\n#  include <netdb.h>\n#endif\n\n#if defined (HAVE_ARPA_INET_H)\n#  include <arpa/inet.h>\n#endif\n\n#include <bashansi.h>\n#include <bashintl.h>\n\n#include <errno.h>\n\n#include <shell.h>\n#include <xmalloc.h>\n\n#ifndef errno\nextern int errno;\n#endif\n\n#if !defined (HAVE_INET_ATON)\nextern int inet_aton PARAMS((const char *, struct in_addr *));\n#endif\n\n#ifndef HAVE_GETADDRINFO\nstatic int _getaddr PARAMS((char *, struct in_addr *));\nstatic int _getserv PARAMS((char *, int, unsigned short *));\nstatic int _netopen4 PARAMS((char *, char *, int));\n#else  \nstatic int _netopen6 PARAMS((char *, char *, int));\n#endif\n\nstatic int _netopen PARAMS((char *, char *, int));\n\n#ifndef HAVE_GETADDRINFO\n \n\nstatic int\n_getaddr (host, ap)\n     char *host;\n     struct in_addr *ap;\n{\n  struct hostent *h;\n  int r;\n\n  r = 0;\n  if (host[0] >= '0' && host[0] <= '9')\n    {\n       \n      r = inet_aton (host, ap);\n      if (r)\n\treturn r;\n    }\n#if !defined (HAVE_GETHOSTBYNAME)\n  return 0;\n#else\n  h = gethostbyname (host);\n  if (h && h->h_addr)\n    {\n      bcopy(h->h_addr, (char *)ap, h->h_length);\n      return 1;\n    }\n#endif\n  return 0;\n  \n}\n\n    \nstatic int\n_getserv (serv, proto, pp)\n     char *serv;\n     int proto;\n     unsigned short *pp;\n{\n  intmax_t l;\n  unsigned short s;\n\n  if (legal_number (serv, &l))\n    {\n      s = (unsigned short)(l & 0xFFFF);\n      if (s != l)\n\treturn (0);\n      s = htons (s);\n      if (pp)\n\t*pp = s;\n      return 1;\n    }\n  else\n#if defined (HAVE_GETSERVBYNAME)\n    {\n      struct servent *se;\n\n      se = getservbyname (serv, (proto == 't') ? \"tcp\" : \"udp\");\n      if (se == 0)\n\treturn 0;\n      if (pp)\n\t*pp = se->s_port;\t \n      return 1;\n    }\n#else  \n    return 0;\n#endif  \n}\n\n \nstatic int \n_netopen4(host, serv, typ)\n     char *host, *serv;\n     int typ;\n{\n  struct in_addr ina;\n  struct sockaddr_in sin;\n  unsigned short p;\n  int s, e;\n\n  if (_getaddr(host, &ina) == 0)\n    {\n      internal_error (_(\"%s: host unknown\"), host);\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (_getserv(serv, typ, &p) == 0)\n    {\n      internal_error(_(\"%s: invalid service\"), serv);\n      errno = EINVAL;\n      return -1;\n    }\n\t\n  memset ((char *)&sin, 0, sizeof(sin));\n  sin.sin_family = AF_INET;\n  sin.sin_port = p;\n  sin.sin_addr = ina;\n\n  s = socket(AF_INET, (typ == 't') ? SOCK_STREAM : SOCK_DGRAM, 0);\n  if (s < 0)\n    {\n      sys_error (\"socket\");\n      return (-1);\n    }\n\n  if (connect (s, (struct sockaddr *)&sin, sizeof (sin)) < 0)\n    {\n      e = errno;\n      sys_error(\"connect\");\n      close(s);\n      errno = e;\n      return (-1);\n    }\n\n  return(s);\n}\n#endif  \n\n#ifdef HAVE_GETADDRINFO\n \nstatic int\n_netopen6 (host, serv, typ)\n     char *host, *serv;\n     int typ;\n{\n  int s, e;\n  struct addrinfo hints, *res, *res0;\n  int gerr;\n\n  memset ((char *)&hints, 0, sizeof (hints));\n   \n#ifdef DEBUG\t \n  hints.ai_family = PF_INET;\n#else\n  hints.ai_family = PF_UNSPEC;\n#endif\n  hints.ai_socktype = (typ == 't') ? SOCK_STREAM : SOCK_DGRAM;\n\n  gerr = getaddrinfo (host, serv, &hints, &res0);\n  if (gerr)\n    {\n      if (gerr == EAI_SERVICE)\n\tinternal_error (\"%s: %s\", serv, gai_strerror (gerr));\n      else\n\tinternal_error (\"%s: %s\", host, gai_strerror (gerr));\n      errno = EINVAL;\n      return -1;\n    }\n\n  for (res = res0; res; res = res->ai_next)\n    {\n      if ((s = socket (res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)\n\t{\n\t  if (res->ai_next)\n\t    continue;\n\t  sys_error (\"socket\");\n\t  freeaddrinfo (res0);\n\t  return -1;\n\t}\n      if (connect (s, res->ai_addr, res->ai_addrlen) < 0)\n\t{\n\t  if (res->ai_next)\n\t    {\n\t      close (s);\n\t      continue;\n\t    }\n\t  e = errno;\n\t  sys_error (\"connect\");\n\t  close (s);\n\t  freeaddrinfo (res0);\n\t  errno = e;\n\t  return -1;\n\t}\n      freeaddrinfo (res0);\n      break;\n    }\n  return s;\n}\n#endif  \n\n \nstatic int \n_netopen(host, serv, typ)\n     char *host, *serv;\n     int typ;\n{\n#ifdef HAVE_GETADDRINFO\n  return (_netopen6 (host, serv, typ));\n#else\n  return (_netopen4 (host, serv, typ));\n#endif\n}\n\n \nint\nnetopen (path)\n     char *path;\n{\n  char *np, *s, *t;\n  int fd;\n\n  np = (char *)xmalloc (strlen (path) + 1);\n  strcpy (np, path);\n\n  s = np + 9;\n  t = strchr (s, '/');\n  if (t == 0)\n    {\n      internal_error (_(\"%s: bad network path specification\"), path);\n      free (np);\n      return -1;\n    }\n  *t++ = '\\0';\n  fd = _netopen (s, t, path[5]);\n  free (np);\n\n  return fd;\n}\n\n#if 0\n \nint\ntcpopen (host, serv)\n     char *host, *serv;\n{\n  return (_netopen (host, serv, 't'));\n}\n\n \nint\nudpopen (host, serv)\n     char *host, *serv;\n{\n  return _netopen (host, serv, 'u');\n}\n#endif\n\n#else  \n\nint\nnetopen (path)\n     char *path;\n{\n  internal_error (_(\"network operations not supported\"));\n  return -1;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}