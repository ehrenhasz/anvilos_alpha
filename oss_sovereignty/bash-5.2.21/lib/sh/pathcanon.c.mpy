{
  "module_name": "pathcanon.c",
  "hash_id": "e3a0612fdc5534917a7dd6b518b193dc7734248336e8eade8d71dd07845ac7f8",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/pathcanon.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <bashtypes.h>\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n#include <posixstat.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <filecntl.h>\n#include <bashansi.h>\n#include <stdio.h>\n#include <chartypes.h>\n#include <errno.h>\n\n#include \"shell.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#if defined (__CYGWIN__)\n#include <sys/cygwin.h>\n\nstatic int\n_is_cygdrive (path)\n     char *path;\n{\n  static char user[MAXPATHLEN];\n  static char system[MAXPATHLEN];\n  static int first_time = 1;\n\n   \n  if (path[0] == '/' && path[1] == '/' && !strchr (path + 2, '/'))\n    return 1; \n   \n  if (first_time)\n    {\n      char user_flags[MAXPATHLEN];\n      char system_flags[MAXPATHLEN];\n       \n      cygwin_internal (CW_GET_CYGDRIVE_INFO, user, system, user_flags, system_flags);\n      first_time = 0;\n    }\n  return !strcasecmp (path, user) || !strcasecmp (path, system);\n}\n#endif  \t\n\n \nstatic int\n_path_isdir (path)\n     char *path;\n{\n  int l;\n  struct stat sb;\n\n   \n  errno = 0;\n  l = stat (path, &sb) == 0 && S_ISDIR (sb.st_mode);\n#if defined (__CYGWIN__)\n  if (l == 0)\n    l = _is_cygdrive (path);\n#endif\n  return l;\n}\n\n \n\n \n\n#define DOUBLE_SLASH(p)\t((p[0] == '/') && (p[1] == '/') && p[2] != '/')\n\nchar *\nsh_canonpath (path, flags)\n     char *path;\n     int flags;\n{\n  char stub_char;\n  char *result, *p, *q, *base, *dotdot;\n  int rooted, double_slash_path;\n\n   \n  result = (flags & PATH_NOALLOC) ? path : savestring (path);\n\n   \n  if (rooted = ROOTEDPATH(path))\n    {\n      stub_char = DIRSEP;\n#if defined (__CYGWIN__)\n      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 3 : result + 1;\n#else\n      base = result + 1;\n#endif\n      double_slash_path = DOUBLE_SLASH (path);\n      base += double_slash_path;\n    }\n  else\n    {\n      stub_char = '.';\n#if defined (__CYGWIN__)\n      base = (ISALPHA((unsigned char)result[0]) && result[1] == ':') ? result + 2 : result;\n#else\n      base = result;\n#endif\n      double_slash_path = 0;\n    }\n\n   \n  p = q = dotdot = base;\n\n  while (*p)\n    {\n      if (ISDIRSEP(p[0]))  \n\tp++;\n      else if(p[0] == '.' && PATHSEP(p[1]))\t \n\tp += 1; \t \n      else if (p[0] == '.' && p[1] == '.' && PATHSEP(p[2]))  \n\t{\n\t  p += 2;  \n\t  if (q > dotdot)\t \n\t    {\n\t      if (flags & PATH_CHECKDOTDOT)\n\t\t{\n\t\t  char c;\n\n\t\t   \n\t\t  c = *q;\n\t\t  *q = '\\0';\n\t\t  if (_path_isdir (result) == 0)\n\t\t    {\n\t\t      if ((flags & PATH_NOALLOC) == 0)\n\t\t\tfree (result);\n\t\t      return ((char *)NULL);\n\t\t    }\n\t\t  *q = c;\n\t\t}\n\n\t      while (--q > dotdot && ISDIRSEP(*q) == 0)\n\t\t;\n\t    }\n\t  else if (rooted == 0)\n\t    {\n\t       \n\t      if (q != base)\n\t\t*q++ = DIRSEP;\n\t      *q++ = '.';\n\t      *q++ = '.';\n\t      dotdot = q;\n\t    }\n\t}\n      else\t \n\t{\n\t   \n\t  if (q != base)\n\t    *q++ = DIRSEP;\n\t  while (*p && (ISDIRSEP(*p) == 0))\n\t    *q++ = *p++;\n\t   \n\t  if (flags & PATH_CHECKEXISTS)\n\t    {\n\t      char c;\n\n\t       \n\t      c = *q;\n\t      *q = '\\0';\n\t      if (_path_isdir (result) == 0)\n\t\t{\n\t\t  if ((flags & PATH_NOALLOC) == 0)\n\t\t    free (result);\n\t\t  return ((char *)NULL);\n\t\t}\n\t      *q = c;\n\t    }\n\t}\n    }\n\n   \n  if (q == result)\n    *q++ = stub_char;\n  *q = '\\0';\n\n   \n  if (DOUBLE_SLASH(result) && double_slash_path == 0)\n    {\n      if (result[2] == '\\0')\t \n\tresult[1] = '\\0';\n      else\n\tmemmove (result, result + 1, strlen (result + 1) + 1);\n    }\n\n  return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}