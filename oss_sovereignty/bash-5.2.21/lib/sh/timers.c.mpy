{
  "module_name": "timers.c",
  "hash_id": "7246cc204835b931bba6fb54d50a2143442e75c72b62a1def17633d346a3c22a",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/timers.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include \"posixtime.h\"\n\n#if defined (HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n\n#if defined (HAVE_SELECT)\n#  include \"posixselect.h\"\n#  include \"stat-time.h\"\n#endif\n\n#include \"sig.h\"\n#include \"bashjmp.h\"\n#include \"xmalloc.h\"\n\n#include \"timer.h\"\n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#ifndef FREE\n#define FREE(s)  do { if (s) free (s); } while (0)\n#endif\n\nextern unsigned int falarm (unsigned int, unsigned int);\n\nstatic void shtimer_zero (sh_timer *);\n\nstatic void\nshtimer_zero (sh_timer *t)\n{\n  t->tmout.tv_sec = 0;\n  t->tmout.tv_usec = 0;\n\n  t->fd = -1;\n  t->flags = t->alrmflag = 0;\n\n  t->alrm_handler = t->old_handler = 0;\n\n  memset (t->jmpenv, '\\0', sizeof (t->jmpenv));\n\n  t->tm_handler = 0;\n  t->data = 0;\n}\n\nsh_timer *\nshtimer_alloc (void)\n{\n  sh_timer *t;\n\n  t = (sh_timer *)xmalloc (sizeof (sh_timer));\n  shtimer_zero (t);\n  return t;\n}\n\nvoid\nshtimer_flush (sh_timer *t)\n{\n   \n  FREE (t->data);\n  shtimer_zero (t);\n}\n\nvoid\nshtimer_dispose (sh_timer *t)\n{\n  free (t);\n}\n\n \nvoid\nshtimer_set (sh_timer *t, time_t sec, long usec)\n{\n  struct timeval now;\n\n  if (t->flags & SHTIMER_ALARM)\n    {\n      t->alrmflag = 0;\t\t \n      t->old_handler = set_signal_handler (SIGALRM, t->alrm_handler);\n      t->flags |= SHTIMER_SIGSET;\n      falarm (t->tmout.tv_sec = sec, t->tmout.tv_usec = usec);\n      t->flags |= SHTIMER_ALRMSET;\n      return;\n    }\n\n  if (gettimeofday (&now, 0) < 0)\n    timerclear (&now);\n\n  t->tmout.tv_sec = now.tv_sec + sec;\n  t->tmout.tv_usec = now.tv_usec + usec;\n  if (t->tmout.tv_usec > USEC_PER_SEC)\n    {\n      t->tmout.tv_sec++;\n      t->tmout.tv_usec -= USEC_PER_SEC;\n    }\n}\n\nvoid\nshtimer_unset (sh_timer *t)\n{\n  t->tmout.tv_sec = 0;\n  t->tmout.tv_usec = 0;\n\n  if (t->flags & SHTIMER_ALARM)\n    {\n      t->alrmflag = 0;\n      if (t->flags & SHTIMER_ALRMSET)\n\tfalarm (0, 0);\n      if (t->old_handler && (t->flags & SHTIMER_SIGSET))\n\t{\n\t  set_signal_handler (SIGALRM, t->old_handler);\n\t  t->flags &= ~SHTIMER_SIGSET;\n\t  t->old_handler = 0;\n\t}\n    }\n}\n\nvoid\nshtimer_cleanup (sh_timer *t)\n{\n  shtimer_unset (t);\n}\n\nvoid\nshtimer_clear (sh_timer *t)\n{\n  shtimer_unset (t);\n  shtimer_dispose (t);\n}\n\nint\nshtimer_chktimeout (sh_timer *t)\n{\n  struct timeval now;\n  int r;\n\n   \n  if (t->flags & SHTIMER_ALARM)\n    return t->alrmflag;\n\n   \n  if (t->tmout.tv_sec == 0 && t->tmout.tv_usec == 0)\n    return 0;\n\n  if (gettimeofday (&now, 0) < 0)\n    return 0;\n  r = ((now.tv_sec > t->tmout.tv_sec) ||\n\t(now.tv_sec == t->tmout.tv_sec && now.tv_usec >= t->tmout.tv_usec));\n\n  return r;\n}\n\n#if defined (HAVE_SELECT) || defined (HAVE_PSELECT)\nint\nshtimer_select (sh_timer *t)\n{\n  int r, nfd;\n  sigset_t blocked_sigs, prevmask;\n  struct timeval now, tv;\n  fd_set readfds;\n#if defined (HAVE_PSELECT)\n  struct timespec ts;\n#endif\n\n   \n  sigemptyset (&blocked_sigs);\n#  if defined (SIGCHLD)\n  sigaddset (&blocked_sigs, SIGCHLD);\n#  endif\n\n  if (gettimeofday (&now, 0) < 0)\n    {\n      if (t->flags & SHTIMER_LONGJMP)\n\tsh_longjmp (t->jmpenv, 1);\n      else\n\treturn -1;\n    }\n\n       \n  if ((now.tv_sec > t->tmout.tv_sec) ||\n\t(now.tv_sec == t->tmout.tv_sec && now.tv_usec >= t->tmout.tv_usec))\n    {\n      if (t->flags & SHTIMER_LONGJMP)\n\tsh_longjmp (t->jmpenv, 1);\n      else if (t->tm_handler)\n\treturn ((*t->tm_handler) (t));\n      else\n\treturn 0;\n    }\n\n   \n  tv.tv_sec = t->tmout.tv_sec - now.tv_sec;\n  tv.tv_usec = t->tmout.tv_usec - now.tv_usec;\n  if (tv.tv_usec < 0)\n    {\n      tv.tv_sec--;\n      tv.tv_usec += USEC_PER_SEC;\n    }\n\n#if defined (HAVE_PSELECT)\n  ts.tv_sec = tv.tv_sec;\n  ts.tv_nsec = tv.tv_usec * 1000;\n#else\n  sigemptyset (&prevmask);\n#endif  \n\n  nfd = (t->fd >= 0) ? t->fd + 1 : 0;\n  FD_ZERO (&readfds);\n  if (t->fd >= 0)\n    FD_SET (t->fd, &readfds);\n\n#if defined (HAVE_PSELECT)\n  r = pselect(nfd, &readfds, (fd_set *)0, (fd_set *)0, &ts, &blocked_sigs);\n#else\n  sigprocmask (SIG_SETMASK, &blocked_sigs, &prevmask);\n  r = select(nfd, &readfds, (fd_set *)0, (fd_set *)0, &tv);\n  sigprocmask (SIG_SETMASK, &prevmask, NULL);\n#endif\n\n  if (r < 0)\n    return r;\t\t \n  else if (r == 0 && (t->flags & SHTIMER_LONGJMP))\n    sh_longjmp (t->jmpenv, 1);\n  else if (r == 0 && t->tm_handler)\n    return ((*t->tm_handler) (t));\n  else\n    return r;\n}\n#endif  \n\nint\nshtimer_alrm (sh_timer *t)\n{\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}