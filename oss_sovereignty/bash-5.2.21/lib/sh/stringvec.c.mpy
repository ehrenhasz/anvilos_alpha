{
  "module_name": "stringvec.c",
  "hash_id": "ee766a1a4c85c1f30d587eb0dfbb870fbae6d3bacd1a5eedb50f26724ea07bac",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/stringvec.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <bashtypes.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <bashansi.h>\n#include <stdio.h>\n#include <chartypes.h>\n\n#include \"shell.h\"\n\n \nchar **\nstrvec_create (n)\n     int n;\n{\n  return ((char **)xmalloc ((n) * sizeof (char *)));\n}\n\n \nchar **\nstrvec_mcreate (n)\n     int n;\n{\n  return ((char **)malloc ((n) * sizeof (char *)));\n}\n\nchar **\nstrvec_resize (array, nsize)\n     char **array;\n     int nsize;\n{\n  return ((char **)xrealloc (array, nsize * sizeof (char *)));\n}\n\nchar **\nstrvec_mresize (array, nsize)\n     char **array;\n     int nsize;\n{\n  return ((char **)realloc (array, nsize * sizeof (char *)));\n}\n\n \nint\nstrvec_len (array)\n     char **array;\n{\n  register int i;\n\n  for (i = 0; array[i]; i++);\n  return (i);\n}\n\n \nvoid\nstrvec_flush (array)\n     char **array;\n{\n  register int i;\n\n  if (array == 0)\n    return;\n\n  for (i = 0; array[i]; i++)\n    free (array[i]);\n}\n\nvoid\nstrvec_dispose (array)\n     char **array;\n{\n  if (array == 0)\n    return;\n\n  strvec_flush (array);\n  free (array);\n}\n\nint\nstrvec_remove (array, name)\n     char **array, *name;\n{\n  register int i, j;\n  char *x;\n\n  if (array == 0)\n    return 0;\n\n  for (i = 0; array[i]; i++)\n    if (STREQ (name, array[i]))\n      {\n\tx = array[i];\n\tfor (j = i; array[j]; j++)\n\t  array[j] = array[j + 1];\n\tfree (x);\n\treturn 1;\n      }\n  return 0;\n}\n\n \nint\nstrvec_search (array, name)\n     char **array, *name;\n{\n  int i;\n\n  for (i = 0; array[i]; i++)\n    if (STREQ (name, array[i]))\n      return (i);\n\n  return (-1);\n}\n\n \nchar **\nstrvec_copy (array)\n     char **array;\n{\n  register int i;\n  int len;\n  char **ret;\n\n  len = strvec_len (array);\n\n  ret = (char **)xmalloc ((len + 1) * sizeof (char *));\n  for (i = 0; array[i]; i++)\n    ret[i] = savestring (array[i]);\n  ret[i] = (char *)NULL;\n\n  return (ret);\n}\n\n \nint\nstrvec_posixcmp (s1, s2)\n     register char **s1, **s2;\n{\n  int result;\n\n#if defined (HAVE_STRCOLL)\n   result = strcoll (*s1, *s2);\n   if (result != 0)\n     return result;\n#endif\n\n  if ((result = **s1 - **s2) == 0)\n    result = strcmp (*s1, *s2);\n\n  return (result);\n}\n\n \nint\nstrvec_strcmp (s1, s2)\n     register char **s1, **s2;\n{\n#if defined (HAVE_STRCOLL)\n   return (strcoll (*s1, *s2));\n#else  \n  int result;\n\n  if ((result = **s1 - **s2) == 0)\n    result = strcmp (*s1, *s2);\n\n  return (result);\n#endif  \n}\n\n \nvoid\nstrvec_sort (array, posix)\n     char **array;\n     int posix;\n{\n  if (posix)\n    qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_posixcmp);\n  else\n    qsort (array, strvec_len (array), sizeof (char *), (QSFUNC *)strvec_strcmp);\n}\n\n \n\nchar **\nstrvec_from_word_list (list, alloc, starting_index, ip)\n     WORD_LIST *list;\n     int alloc, starting_index, *ip;\n{\n  int count;\n  char **array;\n\n  count = list_length (list);\n  array = (char **)xmalloc ((1 + count + starting_index) * sizeof (char *));\n\n  for (count = 0; count < starting_index; count++)\n    array[count] = (char *)NULL;\n  for (count = starting_index; list; count++, list = list->next)\n    array[count] = alloc ? savestring (list->word->word) : list->word->word;\n  array[count] = (char *)NULL;\n\n  if (ip)\n    *ip = count;\n  return (array);\n}\n\n \n\nWORD_LIST *\nstrvec_to_word_list (array, alloc, starting_index)\n     char **array;\n     int alloc, starting_index;\n{\n  WORD_LIST *list;\n  WORD_DESC *w;\n  int i, count;\n\n  if (array == 0 || array[0] == 0)\n    return (WORD_LIST *)NULL;\n\n  for (count = 0; array[count]; count++)\n    ;\n\n  for (i = starting_index, list = (WORD_LIST *)NULL; i < count; i++)\n    {\n      w = make_bare_word (alloc ? array[i] : \"\");\n      if (alloc == 0)\n\t{\n\t  free (w->word);\n\t  w->word = array[i];\n\t}\n      list = make_word_list (w, list);\n    }\n  return (REVERSE_LIST (list, WORD_LIST *));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}