{
  "module_name": "strftime.c",
  "hash_id": "2e11991cf453d6f78e6706a168886eaa200fcba140f4efa778f4f7e5b47e2eda",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/strftime.c",
  "human_readable_source": " \n \n \n#include <config.h>\n\n#include <sys/types.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <posixtime.h>\n#include <errno.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n \n#define SUNOS_EXT\t1\t \n#define VMS_EXT\t\t1\t \n#define HPUX_EXT\t1\t \n#define POSIX_SEMANTICS\t1\t \n#define POSIX_2008\t1\t \n\n#undef strchr\t \n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#if defined (SHELL)\nextern char *get_string_value (const char *);\n#endif\n\nextern void tzset(void);\nstatic int weeknumber(const struct tm *timeptr, int firstweekday);\nstatic int iso8601wknum(const struct tm *timeptr);\n\n#ifndef inline\n#ifdef __GNUC__\n#define inline\t__inline__\n#else\n#define inline\t \n#endif\n#endif\n\n#define range(low, item, hi)\tmax(low, min(item, hi))\n\n \n#if !defined(OS2) && !defined(MSDOS) && !defined(__CYGWIN__) && defined(HAVE_TZNAME)\nextern char *tzname[2];\nextern int daylight;\n#if defined(SOLARIS) || defined(mips) || defined (M_UNIX)\nextern long int timezone, altzone;\n#else\n#  if defined (HPUX) || defined(__hpux)\nextern long int timezone;\n#  else\n#    if !defined(__CYGWIN__)\nextern int timezone, altzone;\n#    endif\n#  endif\n#endif\n#endif\n\n#undef min\t \n\n \n\nstatic inline int\nmin(int a, int b)\n{\n\treturn (a < b ? a : b);\n}\n\n#undef max\t \n\n \n\nstatic inline int\nmax(int a, int b)\n{\n\treturn (a > b ? a : b);\n}\n\n#ifdef POSIX_2008\n \n\nstatic void\niso_8601_2000_year(char *buf, int year, size_t fw)\n{\n\tint extra;\n\tchar sign = '\\0';\n\n\tif (year >= -9999 && year <= 9999) {\n\t\tsprintf(buf, \"%0*d\", (int) fw, year);\n\t\treturn;\n\t}\n\n\t \n\tif (year > 9999) {\n\t\tsign = '+';\n\t} else {\n\t\tsign = '-';\n\t\tyear = -year;\n\t}\n\n\textra = year / 10000;\n\tyear %= 10000;\n\tsprintf(buf, \"%c_%04d_%d\", sign, extra, year);\n}\n#endif  \n\n \n\nsize_t\nstrftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr)\n{\n\tchar *endp = s + maxsize;\n\tchar *start = s;\n\tauto char tbuf[100];\n\tlong off;\n\tint i, w, oerrno;\n\tlong y;\n\tstatic short first = 1;\n#ifdef POSIX_SEMANTICS\n\tstatic char *savetz = NULL;\n\tstatic int savetzlen = 0;\n\tchar *tz;\n#endif  \n#ifndef HAVE_TM_ZONE\n#ifndef HAVE_TM_NAME\n#ifndef HAVE_TZNAME\n#ifndef __CYGWIN__\n\textern char *timezone();\n\tstruct timeval tv;\n\tstruct timezone zone;\n#endif  \n#endif  \n#endif  \n#endif  \n#ifdef POSIX_2008\n\tint pad;\n\tsize_t fw;\n\tchar flag;\n#endif  \n\n\t \n\tstatic const char *days_a[] = {\n\t\t\"Sun\", \"Mon\", \"Tue\", \"Wed\",\n\t\t\"Thu\", \"Fri\", \"Sat\",\n\t};\n\tstatic const char *days_l[] = {\n\t\t\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\t\t\"Thursday\", \"Friday\", \"Saturday\",\n\t};\n\tstatic const char *months_a[] = {\n\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\t\t\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n\t};\n\tstatic const char *months_l[] = {\n\t\t\"January\", \"February\", \"March\", \"April\",\n\t\t\"May\", \"June\", \"July\", \"August\", \"September\",\n\t\t\"October\", \"November\", \"December\",\n\t};\n\tstatic const char *ampm[] = { \"AM\", \"PM\", };\n\n\toerrno = errno;\n\n\tif (s == NULL || format == NULL || timeptr == NULL || maxsize == 0)\n\t\treturn 0;\n\n\t \n\tif (strchr(format, '%') == NULL && strlen(format) + 1 >= maxsize)\n\t\treturn 0;\n\n#ifndef POSIX_SEMANTICS\n\tif (first) {\n\t\ttzset();\n\t\tfirst = 0;\n\t}\n#else\t \n#if defined (SHELL)\n\ttz = get_string_value (\"TZ\");\n#else\n\ttz = getenv(\"TZ\");\n#endif\n\tif (first) {\n\t\tif (tz != NULL) {\n\t\t\tint tzlen = strlen(tz);\n\n\t\t\tsavetz = (char *) malloc(tzlen + 1);\n\t\t\tif (savetz != NULL) {\n\t\t\t\tsavetzlen = tzlen + 1;\n\t\t\t\tstrcpy(savetz, tz);\n\t\t\t}\n\t\t}\n\t\ttzset();\n\t\tfirst = 0;\n\t}\n\t \n\tif (tz && savetz && (tz[0] != savetz[0] || strcmp(tz, savetz) != 0)) {\n\t\ti = strlen(tz) + 1;\n\t\tif (i > savetzlen) {\n\t\t\tsavetz = (char *) realloc(savetz, i);\n\t\t\tif (savetz) {\n\t\t\t\tsavetzlen = i;\n\t\t\t\tstrcpy(savetz, tz);\n\t\t\t}\n\t\t} else\n\t\t\tstrcpy(savetz, tz);\n\t\ttzset();\n\t}\n#endif\t \n\n\tfor (; *format && s < endp - 1; format++) {\n\t\ttbuf[0] = '\\0';\n\t\tif (*format != '%') {\n\t\t\t*s++ = *format;\n\t\t\tcontinue;\n\t\t}\n#ifdef POSIX_2008\n\t\tpad = '\\0';\n\t\tfw = 0;\n\t\tflag = '\\0';\n\t\tswitch (*++format) {\n\t\tcase '+':\n\t\t\tflag = '+';\n\t\t\t \n\t\tcase '0':\n\t\t\tpad = '0';\n\t\t\tformat++;\n\t\t\tbreak;\n\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tformat--;\n\t\t\tgoto again;\n\t\t}\n\t\tfor (; isdigit(*format); format++) {\n\t\t\tfw = fw * 10 + (*format - '0');\n\t\t}\n\t\tformat--;\n#endif  \n\n\tagain:\n\t\tswitch (*++format) {\n\t\tcase '\\0':\n\t\t\t*s++ = '%';\n\t\t\tgoto out;\n\n\t\tcase '%':\n\t\t\t*s++ = '%';\n\t\t\tcontinue;\n\n\t\tcase 'a':\t \n\t\t\tif (timeptr->tm_wday < 0 || timeptr->tm_wday > 6)\n\t\t\t\tstrcpy(tbuf, \"?\");\n\t\t\telse\n\t\t\t\tstrcpy(tbuf, days_a[timeptr->tm_wday]);\n\t\t\tbreak;\n\n\t\tcase 'A':\t \n\t\t\tif (timeptr->tm_wday < 0 || timeptr->tm_wday > 6)\n\t\t\t\tstrcpy(tbuf, \"?\");\n\t\t\telse\n\t\t\t\tstrcpy(tbuf, days_l[timeptr->tm_wday]);\n\t\t\tbreak;\n\n\t\tcase 'b':\t \n\t\tshort_month:\n\t\t\tif (timeptr->tm_mon < 0 || timeptr->tm_mon > 11)\n\t\t\t\tstrcpy(tbuf, \"?\");\n\t\t\telse\n\t\t\t\tstrcpy(tbuf, months_a[timeptr->tm_mon]);\n\t\t\tbreak;\n\n\t\tcase 'B':\t \n\t\t\tif (timeptr->tm_mon < 0 || timeptr->tm_mon > 11)\n\t\t\t\tstrcpy(tbuf, \"?\");\n\t\t\telse\n\t\t\t\tstrcpy(tbuf, months_l[timeptr->tm_mon]);\n\t\t\tbreak;\n\n\t\tcase 'c':\t \n\t\t\t \n\t\t\tstrftime(tbuf, sizeof tbuf, \"%A %B %d %T %Y\", timeptr);\n\t\t\tbreak;\n\n\t\tcase 'C':\n#ifdef POSIX_2008\n\t\t\tif (pad != '\\0' && fw > 0) {\n\t\t\t\tsize_t min_fw = (flag ? 3 : 2);\n\n\t\t\t\tfw = max(fw, min_fw);\n\t\t\t\tsprintf(tbuf, flag\n\t\t\t\t\t\t? \"%+0*ld\"\n\t\t\t\t\t\t: \"%0*ld\", (int) fw,\n\t\t\t\t\t\t(timeptr->tm_year + 1900L) / 100);\n\t\t\t} else\n#endif  \n\t\tcentury:\n\t\t\t\tsprintf(tbuf, \"%02ld\", (timeptr->tm_year + 1900L) / 100);\n\t\t\tbreak;\n\n\t\tcase 'd':\t \n\t\t\ti = range(1, timeptr->tm_mday, 31);\n\t\t\tsprintf(tbuf, \"%02d\", i);\n\t\t\tbreak;\n\n\t\tcase 'D':\t \n\t\t\tstrftime(tbuf, sizeof tbuf, \"%m/%d/%y\", timeptr);\n\t\t\tbreak;\n\n\t\tcase 'e':\t \n\t\t\tsprintf(tbuf, \"%2d\", range(1, timeptr->tm_mday, 31));\n\t\t\tbreak;\n\n\t\tcase 'E':\n\t\t\t \n\t\t\tgoto again;\n\n\t\tcase 'F':\t \n\t\t{\n#ifdef POSIX_2008\n\t\t\t \n\t\t\tchar m_d[10];\n\t\t\tstrftime(m_d, sizeof m_d, \"-%m-%d\", timeptr);\n\t\t\tsize_t min_fw = 10;\n\n\t\t\tif (pad != '\\0' && fw > 0) {\n\t\t\t\tfw = max(fw, min_fw);\n\t\t\t} else {\n\t\t\t\tfw = min_fw;\n\t\t\t}\n\n\t\t\tfw -= 6;\t \n\n\t\t\tiso_8601_2000_year(tbuf, timeptr->tm_year + 1900, fw);\n\t\t\tstrcat(tbuf, m_d);\n#else\n\t\t\tstrftime(tbuf, sizeof tbuf, \"%Y-%m-%d\", timeptr);\n#endif  \n\t\t}\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\tcase 'G':\n\t\t\t \n\t\t\tw = iso8601wknum(timeptr);\n\t\t\tif (timeptr->tm_mon == 11 && w == 1)\n\t\t\t\ty = 1900L + timeptr->tm_year + 1;\n\t\t\telse if (timeptr->tm_mon == 0 && w >= 52)\n\t\t\t\ty = 1900L + timeptr->tm_year - 1;\n\t\t\telse\n\t\t\t\ty = 1900L + timeptr->tm_year;\n\n\t\t\tif (*format == 'G') {\n#ifdef POSIX_2008\n\t\t\t\tif (pad != '\\0' && fw > 0) {\n\t\t\t\t\tsize_t min_fw = 4;\n\n\t\t\t\t\tfw = max(fw, min_fw);\n\t\t\t\t\tsprintf(tbuf, flag\n\t\t\t\t\t\t\t? \"%+0*ld\"\n\t\t\t\t\t\t\t: \"%0*ld\", (int) fw,\n\t\t\t\t\t\t\ty);\n\t\t\t\t} else\n#endif  \n\t\t\t\t\tsprintf(tbuf, \"%ld\", y);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsprintf(tbuf, \"%02ld\", y % 100);\n\t\t\tbreak;\n\n\t\tcase 'h':\t \n\t\t\tgoto short_month;\n\n\t\tcase 'H':\t \n\t\t\ti = range(0, timeptr->tm_hour, 23);\n\t\t\tsprintf(tbuf, \"%02d\", i);\n\t\t\tbreak;\n\n\t\tcase 'I':\t \n\t\t\ti = range(0, timeptr->tm_hour, 23);\n\t\t\tif (i == 0)\n\t\t\t\ti = 12;\n\t\t\telse if (i > 12)\n\t\t\t\ti -= 12;\n\t\t\tsprintf(tbuf, \"%02d\", i);\n\t\t\tbreak;\n\n\t\tcase 'j':\t \n\t\t\tsprintf(tbuf, \"%03d\", timeptr->tm_yday + 1);\n\t\t\tbreak;\n\n\t\tcase 'm':\t \n\t\t\ti = range(0, timeptr->tm_mon, 11);\n\t\t\tsprintf(tbuf, \"%02d\", i + 1);\n\t\t\tbreak;\n\n\t\tcase 'M':\t \n\t\t\ti = range(0, timeptr->tm_min, 59);\n\t\t\tsprintf(tbuf, \"%02d\", i);\n\t\t\tbreak;\n\n\t\tcase 'n':\t \n\t\t\ttbuf[0] = '\\n';\n\t\t\ttbuf[1] = '\\0';\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\t \n\t\t\tgoto again;\n\n\t\tcase 'p':\t \n\t\t\ti = range(0, timeptr->tm_hour, 23);\n\t\t\tif (i < 12)\n\t\t\t\tstrcpy(tbuf, ampm[0]);\n\t\t\telse\n\t\t\t\tstrcpy(tbuf, ampm[1]);\n\t\t\tbreak;\n\n\t\tcase 'r':\t \n\t\t\tstrftime(tbuf, sizeof tbuf, \"%I:%M:%S %p\", timeptr);\n\t\t\tbreak;\n\n\t\tcase 'R':\t \n\t\t\tstrftime(tbuf, sizeof tbuf, \"%H:%M\", timeptr);\n\t\t\tbreak;\n\n#if defined(HAVE_MKTIME)\n\t\tcase 's':\t \n\t\t{\n\t\t\tstruct tm non_const_timeptr;\n\n\t\t\tnon_const_timeptr = *timeptr;\n\t\t\tsprintf(tbuf, \"%ld\", mktime(& non_const_timeptr));\n\t\t\tbreak;\n\t\t}\n#endif  \n\n\t\tcase 'S':\t \n\t\t\ti = range(0, timeptr->tm_sec, 60);\n\t\t\tsprintf(tbuf, \"%02d\", i);\n\t\t\tbreak;\n\n\t\tcase 't':\t \n\t\t\ttbuf[0] = '\\t';\n\t\t\ttbuf[1] = '\\0';\n\t\t\tbreak;\n\n\t\tcase 'T':\t \n\t\tthe_time:\n\t\t\tstrftime(tbuf, sizeof tbuf, \"%H:%M:%S\", timeptr);\n\t\t\tbreak;\n\n\t\tcase 'u':\n\t\t \n\t\t\tsprintf(tbuf, \"%d\", timeptr->tm_wday == 0 ? 7 :\n\t\t\t\t\ttimeptr->tm_wday);\n\t\t\tbreak;\n\n\t\tcase 'U':\t \n\t\t\tsprintf(tbuf, \"%02d\", weeknumber(timeptr, 0));\n\t\t\tbreak;\n\n\t\tcase 'V':\t \n\t\t\tsprintf(tbuf, \"%02d\", iso8601wknum(timeptr));\n\t\t\tbreak;\n\n\t\tcase 'w':\t \n\t\t\ti = range(0, timeptr->tm_wday, 6);\n\t\t\tsprintf(tbuf, \"%d\", i);\n\t\t\tbreak;\n\n\t\tcase 'W':\t \n\t\t\tsprintf(tbuf, \"%02d\", weeknumber(timeptr, 1));\n\t\t\tbreak;\n\n\t\tcase 'x':\t \n\t\t\tstrftime(tbuf, sizeof tbuf, \"%A %B %d %Y\", timeptr);\n\t\t\tbreak;\n\n\t\tcase 'X':\t \n\t\t\tgoto the_time;\n\t\t\tbreak;\n\n\t\tcase 'y':\t \n\t\tyear:\n\t\t\ti = timeptr->tm_year % 100;\n\t\t\tsprintf(tbuf, \"%02d\", i);\n\t\t\tbreak;\n\n\t\tcase 'Y':\t \n#ifdef POSIX_2008\n\t\t\tif (pad != '\\0' && fw > 0) {\n\t\t\t\tsize_t min_fw = 4;\n\n\t\t\t\tfw = max(fw, min_fw);\n\t\t\t\tsprintf(tbuf, flag\n\t\t\t\t\t\t? \"%+0*ld\"\n\t\t\t\t\t\t: \"%0*ld\", (int) fw,\n\t\t\t\t\t\t1900L + timeptr->tm_year);\n\t\t\t} else\n#endif  \n\t\t\tsprintf(tbuf, \"%ld\", 1900L + timeptr->tm_year);\n\t\t\tbreak;\n\n\t\t \n \t\tcase 'z':\t \n \t\t\tif (timeptr->tm_isdst < 0)\n \t\t\t\tbreak;\n#ifdef HAVE_TM_NAME\n\t\t\t \n\t\t\toff = -timeptr->tm_tzadj / 60;\n#else  \n#ifdef HAVE_TM_ZONE\n\t\t\t \n\t\t\toff = timeptr->tm_gmtoff / 60;\n#else  \n#if HAVE_TZNAME\n\t\t\t \n#  if defined(__hpux) || defined (HPUX) || defined(__CYGWIN__)\n\t\t\toff = -timezone / 60;\n#  else\n\t\t\t \n\t\t\toff = -(daylight ? altzone : timezone) / 60;\n#  endif\n#else  \n\t\t\tgettimeofday(& tv, & zone);\n\t\t\toff = -zone.tz_minuteswest;\n#endif  \n#endif  \n#endif  \n\t\t\tif (off < 0) {\n\t\t\t\ttbuf[0] = '-';\n\t\t\t\toff = -off;\n\t\t\t} else {\n\t\t\t\ttbuf[0] = '+';\n\t\t\t}\n\t\t\tsprintf(tbuf+1, \"%02ld%02ld\", off/60, off%60);\n\t\t\tbreak;\n\n\t\tcase 'Z':\t \n#ifdef HAVE_TZNAME\n\t\t\ti = (daylight && timeptr->tm_isdst > 0);  \n\t\t\tstrcpy(tbuf, tzname[i]);\n#else\n#ifdef HAVE_TM_ZONE\n\t\t\tstrcpy(tbuf, timeptr->tm_zone);\n#else\n#ifdef HAVE_TM_NAME\n\t\t\tstrcpy(tbuf, timeptr->tm_name);\n#else\n\t\t\tgettimeofday(& tv, & zone);\n\t\t\tstrcpy(tbuf, timezone(zone.tz_minuteswest,\n\t\t\t\t\t\ttimeptr->tm_isdst > 0));\n#endif  \n#endif  \n#endif  \n\t\t\tbreak;\n\n#ifdef SUNOS_EXT\n\t\tcase 'k':\t \n\t\t\tsprintf(tbuf, \"%2d\", range(0, timeptr->tm_hour, 23));\n\t\t\tbreak;\n\n\t\tcase 'l':\t \n\t\t\ti = range(0, timeptr->tm_hour, 23);\n\t\t\tif (i == 0)\n\t\t\t\ti = 12;\n\t\t\telse if (i > 12)\n\t\t\t\ti -= 12;\n\t\t\tsprintf(tbuf, \"%2d\", i);\n\t\t\tbreak;\n#endif\n\n#ifdef HPUX_EXT\n\t\tcase 'N':\t \n\t\t\t \n\t\t\tgoto century;\t \n\n\t\tcase 'o':\t \n\t\t\tgoto year;\t \n#endif  \n\n\n#ifdef VMS_EXT\n\t\tcase 'v':\t \n\t\t\tsprintf(tbuf, \"%2d-%3.3s-%4ld\",\n\t\t\t\trange(1, timeptr->tm_mday, 31),\n\t\t\t\tmonths_a[range(0, timeptr->tm_mon, 11)],\n\t\t\t\ttimeptr->tm_year + 1900L);\n\t\t\tfor (i = 3; i < 6; i++)\n\t\t\t\tif (islower(tbuf[i]))\n\t\t\t\t\ttbuf[i] = toupper(tbuf[i]);\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\ttbuf[0] = '%';\n\t\t\ttbuf[1] = *format;\n\t\t\ttbuf[2] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\ti = strlen(tbuf);\n\t\tif (i) {\n\t\t\tif (s + i < endp - 1) {\n\t\t\t\tstrcpy(s, tbuf);\n\t\t\t\ts += i;\n\t\t\t} else\n\t\t\t\treturn 0;\n\t\t}\n\t}\nout:\n\tif (s < endp && *format == '\\0') {\n\t\t*s = '\\0';\n\t\tif (s == start)\n\t\t\terrno = oerrno;\n\t\treturn (s - start);\n\t} else\n\t\treturn 0;\n}\n\n \n\nstatic int\nisleap(long year)\n{\n\treturn ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);\n}\n\n\n \n\nstatic int\niso8601wknum(const struct tm *timeptr)\n{\n\t \n\n\tint weeknum, jan1day, diff;\n\n\t \n\tweeknum = weeknumber(timeptr, 1);\n\n\t \n\tjan1day = timeptr->tm_wday - (timeptr->tm_yday % 7);\n\tif (jan1day < 0)\n\t\tjan1day += 7;\n\n\t \n\tswitch (jan1day) {\n\tcase 1:\t\t \n\t\tbreak;\n\tcase 2:\t\t \n\tcase 3:\t\t \n\tcase 4:\t\t \n\t\tweeknum++;\n\t\tbreak;\n\tcase 5:\t\t \n\tcase 6:\t\t \n\tcase 0:\t\t \n\t\tif (weeknum == 0) {\n#ifdef USE_BROKEN_XPG4\n\t\t\t \n\t\t\tweeknum = 53;\n#else\n\t\t\t \n\t\t\tstruct tm dec31ly;\t \n\t\t\tdec31ly = *timeptr;\n\t\t\tdec31ly.tm_year--;\n\t\t\tdec31ly.tm_mon = 11;\n\t\t\tdec31ly.tm_mday = 31;\n\t\t\tdec31ly.tm_wday = (jan1day == 0) ? 6 : jan1day - 1;\n\t\t\tdec31ly.tm_yday = 364 + isleap(dec31ly.tm_year + 1900L);\n\t\t\tweeknum = iso8601wknum(& dec31ly);\n#endif\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (timeptr->tm_mon == 11) {\n\t\t \n\t\tint wday, mday;\n\n\t\twday = timeptr->tm_wday;\n\t\tmday = timeptr->tm_mday;\n\t\tif (   (wday == 1 && (mday >= 29 && mday <= 31))\n\t\t    || (wday == 2 && (mday == 30 || mday == 31))\n\t\t    || (wday == 3 &&  mday == 31))\n\t\t\tweeknum = 1;\n\t}\n\n\treturn weeknum;\n}\n\n \n\n \n\nstatic int\nweeknumber(const struct tm *timeptr, int firstweekday)\n{\n\tint wday = timeptr->tm_wday;\n\tint ret;\n\n\tif (firstweekday == 1) {\n\t\tif (wday == 0)\t \n\t\t\twday = 6;\n\t\telse\n\t\t\twday--;\n\t}\n\tret = ((timeptr->tm_yday + 7 - wday) / 7);\n\tif (ret < 0)\n\t\tret = 0;\n\treturn ret;\n}\n\n#if 0\n \n\nDate:         Wed, 24 Apr 91 20:54:08 MDT\nFrom: Michal Jaegermann <audfax!emory!vm.ucs.UAlberta.CA!NTOMCZAK>\nTo: arnold@audiofax.com\n\nHi Arnold,\nin a process of fixing of strftime() in libraries on Atari ST I grabbed\nsome pieces of code from your own strftime.  When doing that it came\nto mind that your weeknumber() function compiles a little bit nicer\nin the following form:\n \n{\n    return (timeptr->tm_yday - timeptr->tm_wday +\n\t    (firstweekday ? (timeptr->tm_wday ? 8 : 1) : 7)) / 7;\n}\nHow nicer it depends on a compiler, of course, but always a tiny bit.\n\n   Cheers,\n   Michal\n   ntomczak@vm.ucs.ualberta.ca\n#endif\n\n#ifdef\tTEST_STRFTIME\n\n \n\n \n\n#ifndef NULL\n#include\t<stdio.h>\n#endif\n#include\t<sys/time.h>\n#include\t<string.h>\n\n#define\t\tMAXTIME\t\t132\n\n \n\nstatic char *array[] =\n{\n\t\"(%%A)      full weekday name, var length (Sunday..Saturday)  %A\",\n\t\"(%%B)       full month name, var length (January..December)  %B\",\n\t\"(%%C)                                               Century  %C\",\n\t\"(%%D)                                       date (%%m/%%d/%%y)  %D\",\n\t\"(%%E)                           Locale extensions (ignored)  %E\",\n\t\"(%%F)       full month name, var length (January..December)  %F\",\n\t\"(%%H)                          hour (24-hour clock, 00..23)  %H\",\n\t\"(%%I)                          hour (12-hour clock, 01..12)  %I\",\n\t\"(%%M)                                       minute (00..59)  %M\",\n\t\"(%%N)                                      Emperor/Era Name  %N\",\n\t\"(%%O)                           Locale extensions (ignored)  %O\",\n\t\"(%%R)                                 time, 24-hour (%%H:%%M)  %R\",\n\t\"(%%S)                                       second (00..60)  %S\",\n\t\"(%%T)                              time, 24-hour (%%H:%%M:%%S)  %T\",\n\t\"(%%U)    week of year, Sunday as first day of week (00..53)  %U\",\n\t\"(%%V)                    week of year according to ISO 8601  %V\",\n\t\"(%%W)    week of year, Monday as first day of week (00..53)  %W\",\n\t\"(%%X)     appropriate locale time representation (%H:%M:%S)  %X\",\n\t\"(%%Y)                           year with century (1970...)  %Y\",\n\t\"(%%Z) timezone (EDT), or blank if timezone not determinable  %Z\",\n\t\"(%%a)          locale's abbreviated weekday name (Sun..Sat)  %a\",\n\t\"(%%b)            locale's abbreviated month name (Jan..Dec)  %b\",\n\t\"(%%c)           full date (Sat Nov  4 12:02:33 1989)%n%t%t%t  %c\",\n\t\"(%%d)                             day of the month (01..31)  %d\",\n\t\"(%%e)               day of the month, blank-padded ( 1..31)  %e\",\n\t\"(%%h)                                should be same as (%%b)  %h\",\n\t\"(%%j)                            day of the year (001..366)  %j\",\n\t\"(%%k)               hour, 24-hour clock, blank pad ( 0..23)  %k\",\n\t\"(%%l)               hour, 12-hour clock, blank pad ( 0..12)  %l\",\n\t\"(%%m)                                        month (01..12)  %m\",\n\t\"(%%o)                                      Emperor/Era Year  %o\",\n\t\"(%%p)              locale's AM or PM based on 12-hour clock  %p\",\n\t\"(%%r)                   time, 12-hour (same as %%I:%%M:%%S %%p)  %r\",\n\t\"(%%u) ISO 8601: Weekday as decimal number [1 (Monday) - 7]   %u\",\n\t\"(%%v)                                VMS date (dd-bbb-YYYY)  %v\",\n\t\"(%%w)                       day of week (0..6, Sunday == 0)  %w\",\n\t\"(%%x)                appropriate locale date representation  %x\",\n\t\"(%%y)                      last two digits of year (00..99)  %y\",\n\t\"(%%z)      timezone offset east of GMT as HHMM (e.g. -0500)  %z\",\n\t(char *) NULL\n};\n\n \n\nint\nmain(argc, argv)\nint argc;\nchar **argv;\n{\n\tlong time();\n\n\tchar *next;\n\tchar string[MAXTIME];\n\n\tint k;\n\tint length;\n\n\tstruct tm *tm;\n\n\tlong clock;\n\n\t \n\n\tclock = time((long *) 0);\n\ttm = localtime(&clock);\n\n\tfor (k = 0; next = array[k]; k++) {\n\t\tlength = strftime(string, MAXTIME, next, tm);\n\t\tprintf(\"%s\\n\", string);\n\t}\n\n\texit(0);\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}