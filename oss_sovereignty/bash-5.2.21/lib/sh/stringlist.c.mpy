{
  "module_name": "stringlist.c",
  "hash_id": "a6dc3cc8519a95eb0f999c8b18974f9be5524e5cce148a9b9e2a405624e9fc86",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/stringlist.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <bashansi.h>\n\n#include \"shell.h\"\n\n#ifdef STRDUP\n#  undef STRDUP\n#endif\n#define STRDUP(x)\t((x) ? savestring (x) : (char *)NULL)\n\n \n\nSTRINGLIST *\nstrlist_create (n)\n     int n;\n{\n  STRINGLIST *ret;\n  register int i;\n\n  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));\n  if (n)\n    {\n      ret->list = strvec_create (n+1);\n      ret->list_size = n;\n      for (i = 0; i < n; i++)\n\tret->list[i] = (char *)NULL;\n    }\n  else\n    {\n      ret->list = (char **)NULL;\n      ret->list_size = 0;\n    }\n  ret->list_len = 0;\n  return ret;\n}\n\nSTRINGLIST *\nstrlist_resize (sl, n)\n     STRINGLIST *sl;\n     int n;\n{\n  register int i;\n\n  if (sl == 0)\n    return (sl = strlist_create (n));\n\n  if (n > sl->list_size)\n    {\n      sl->list = strvec_resize (sl->list, n + 1);\n      for (i = sl->list_size; i <= n; i++)\n\tsl->list[i] = (char *)NULL;\n      sl->list_size = n;\n    }\n  return sl;\n}\n\nvoid\nstrlist_flush (sl)\n     STRINGLIST *sl;\n{\n  if (sl == 0 || sl->list == 0)\n    return;\n  strvec_flush (sl->list);\n  sl->list_len = 0;\n}\n  \nvoid\nstrlist_dispose (sl)\n     STRINGLIST *sl;\n{\n  if (sl == 0)\n    return;\n  if (sl->list)\n    strvec_dispose (sl->list);\n  free (sl);\n}\n\nint\nstrlist_remove (sl, s)\n     STRINGLIST *sl;\n     char *s;\n{\n  int r;\n\n  if (sl == 0 || sl->list == 0 || sl->list_len == 0)\n    return 0;\n\n  r = strvec_remove (sl->list, s);\n  if (r)\n    sl->list_len--;\n  return r;\n}\n\nSTRINGLIST *\nstrlist_copy (sl)\n     STRINGLIST *sl;\n{\n  STRINGLIST *new;\n  register int i;\n\n  if (sl == 0)\n    return ((STRINGLIST *)0);\n  new = strlist_create (sl->list_size);\n   \n  if (sl->list)\n    {\n      for (i = 0; i < sl->list_size; i++)\n\tnew->list[i] = STRDUP (sl->list[i]);\n    }\n  new->list_size = sl->list_size;\n  new->list_len = sl->list_len;\n   \n  if (new->list)\n    new->list[new->list_len] = (char *)NULL;\n  return new;\n}\n\n \n\nSTRINGLIST *\nstrlist_merge (m1, m2)\n     STRINGLIST *m1, *m2;\n{\n  STRINGLIST *sl;\n  int i, n, l1, l2;\n\n  l1 = m1 ? m1->list_len : 0;\n  l2 = m2 ? m2->list_len : 0;\n\n  sl = strlist_create (l1 + l2 + 1);\n  for (i = n = 0; i < l1; i++, n++)\n    sl->list[n] = STRDUP (m1->list[i]);\n  for (i = 0; i < l2; i++, n++)\n    sl->list[n] = STRDUP (m2->list[i]);\n  sl->list_len = n;\n  sl->list[n] = (char *)NULL;\n  return (sl);\n}\n\n \nSTRINGLIST *\nstrlist_append (m1, m2)\n     STRINGLIST *m1, *m2;\n{\n  register int i, n, len1, len2;\n\n  if (m1 == 0)\n    return (m2 ? strlist_copy (m2) : (STRINGLIST *)0);\n\n  len1 = m1->list_len;\n  len2 = m2 ? m2->list_len : 0;\n\n  if (len2)\n    {\n      m1 = strlist_resize (m1, len1 + len2 + 1);\n      for (i = 0, n = len1; i < len2; i++, n++)\n\tm1->list[n] = STRDUP (m2->list[i]);\n      m1->list[n] = (char *)NULL;\n      m1->list_len = n;\n    }\n\n  return m1;\n}\n\nSTRINGLIST *\nstrlist_prefix_suffix (sl, prefix, suffix)\n     STRINGLIST *sl;\n     char *prefix, *suffix;\n{\n  int plen, slen, tlen, llen, i;\n  char *t;\n\n  if (sl == 0 || sl->list == 0 || sl->list_len == 0)\n    return sl;\n\n  plen = STRLEN (prefix);\n  slen = STRLEN (suffix);\n\n  if (plen == 0 && slen == 0)\n    return (sl);\n\n  for (i = 0; i < sl->list_len; i++)\n    {\n      llen = STRLEN (sl->list[i]);\n      tlen = plen + llen + slen + 1;\n      t = (char *)xmalloc (tlen + 1);\n      if (plen)\n\tstrcpy (t, prefix);\n      strcpy (t + plen, sl->list[i]);\n      if (slen)\n\tstrcpy (t + plen + llen, suffix);\n      free (sl->list[i]);\n      sl->list[i] = t;\n    }\n\n  return (sl);\t \n}\n   \nvoid\nstrlist_print (sl, prefix)\n     STRINGLIST *sl;\n     char *prefix;\n{\n  register int i;\n\n  if (sl == 0)\n    return;\n  for (i = 0; i < sl->list_len; i++)\n    printf (\"%s%s\\n\", prefix ? prefix : \"\", sl->list[i]);\n}\n\nvoid\nstrlist_walk (sl, func)\n     STRINGLIST *sl;\n     sh_strlist_map_func_t *func;\n{\n  register int i;\n\n  if (sl == 0)\n    return;\n  for (i = 0; i < sl->list_len; i++)\n    if ((*func)(sl->list[i]) < 0)\n      break;\n} \n     \nvoid\nstrlist_sort (sl)\n     STRINGLIST *sl;\n{\n  if (sl == 0 || sl->list_len == 0 || sl->list == 0)\n    return;\n  strvec_sort (sl->list, 0);\n}\n\nSTRINGLIST *\nstrlist_from_word_list (list, alloc, starting_index, ip)\n     WORD_LIST *list;\n     int alloc, starting_index, *ip;\n{\n  STRINGLIST *ret;\n  int slen, len;\n\n  if (list == 0)\n    {\n      if (ip)\n        *ip = 0;\n      return ((STRINGLIST *)0);\n    }\n  slen = list_length (list);\n  ret = (STRINGLIST *)xmalloc (sizeof (STRINGLIST));\n  ret->list = strvec_from_word_list (list, alloc, starting_index, &len);\n  ret->list_size = slen + starting_index;\n  ret->list_len = len;\n  if (ip)\n    *ip = len;\n  return ret;\n}\n\nWORD_LIST *\nstrlist_to_word_list (sl, alloc, starting_index)\n     STRINGLIST *sl;\n     int alloc, starting_index;\n{\n  WORD_LIST *list;\n\n  if (sl == 0 || sl->list == 0)\n    return ((WORD_LIST *)NULL);\n\n  list = strvec_to_word_list (sl->list, alloc, starting_index);\n  return list;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}