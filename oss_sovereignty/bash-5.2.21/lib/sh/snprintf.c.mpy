{
  "module_name": "snprintf.c",
  "hash_id": "fc59d4dbeec84860614ab532660ba989b3550f093cb0f922067125c04d3d1786",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/snprintf.c",
  "human_readable_source": " \n\n \n \n \n\n \n\n#define FLOATING_POINT\n\n#ifdef HAVE_CONFIG_H\n#  include <config.h>\n#endif\n\n \n#if defined(DEBUG) && !defined (MACOSX)\n#  undef HAVE_SNPRINTF\n#  undef HAVE_ASPRINTF\n\n#  define HAVE_SNPRINTF 0\n#  define HAVE_ASPRINTF 0\n#endif\n\n#if defined(DRIVER) && !defined(HAVE_CONFIG_H)\n#define HAVE_LONG_LONG_INT\n#define HAVE_LONG_DOUBLE\n#ifdef __linux__\n#define HAVE_PRINTF_A_FORMAT\n#endif\n#define HAVE_ISINF_IN_LIBC\n#define HAVE_ISNAN_IN_LIBC\n#define PREFER_STDARG\n#define HAVE_STRINGIZE\n#define HAVE_LIMITS_H\n#define HAVE_STDDEF_H\n#define HAVE_LOCALE_H\n#define intmax_t long\n#endif\n\n#if !HAVE_SNPRINTF || !HAVE_ASPRINTF\n\n#include <bashtypes.h>\n\n#if defined(PREFER_STDARG)\n#  include <stdarg.h>\n#else\n#  include <varargs.h>\n#endif\n\n#ifdef HAVE_LIMITS_H\n#  include <limits.h>\n#endif\n#include <bashansi.h>\n#ifdef HAVE_STDDEF_H\n#  include <stddef.h>\n#endif\n#include <chartypes.h>\n\n#ifdef HAVE_STDINT_H\n#  include <stdint.h>\n#endif\n\n#ifdef FLOATING_POINT\n#  include <float.h>\t \n#  include <stdio.h>\t \n#endif\n\n#include <typemax.h>\n\n#ifdef HAVE_LOCALE_H\n#  include <locale.h>\n#endif\n\n#include \"stdc.h\"\n#include <shmbutil.h>\n\n#ifndef DRIVER\n#  include \"shell.h\"\n#else\n#  define FL_PREFIX     0x01     \n#  define FL_ADDBASE    0x02     \n#  define FL_HEXUPPER   0x04     \n#  define FL_UNSIGNED   0x08     \nextern char *fmtulong PARAMS((unsigned long int, int, char *, size_t, int));\nextern char *fmtullong PARAMS((unsigned long long int, int, char *, size_t, int));\n#endif\n\n#ifndef FREE\n#  define FREE(x)\tif (x) free (x)\n#endif\n\n \n#ifndef INT_STRLEN_BOUND\n#define INT_STRLEN_BOUND(t) \\\n  ((sizeof (t) * CHAR_BIT - TYPE_SIGNED (t)) * 302 / 1000 \\\n     + 1 + TYPE_SIGNED (t))\n#endif\n\n \n#define PF_ALTFORM\t0x00001\t\t \n#define PF_HEXPREFIX\t0x00002\t\t \n#define PF_LADJUST\t0x00004\t\t \n#define PF_ZEROPAD\t0x00008\t\t \n#define PF_PLUS\t\t0x00010\t\t \n#define PF_SPACE\t0x00020\t\t \n#define PF_THOUSANDS\t0x00040\t\t \n\n#define PF_DOT\t\t0x00080\t\t \n#define PF_STAR_P\t0x00100\t\t \n#define PF_STAR_W\t0x00200\t\t \n\n \n#define PF_SIGNEDCHAR\t0x00400\t\t \n#define PF_SHORTINT\t0x00800\t\t \n#define PF_LONGINT\t0x01000\t\t \n#define PF_LONGLONG\t0x02000\t\t \n#define PF_LONGDBL\t0x04000\t\t \n#define PF_INTMAX_T\t0x08000\t\t \n#define PF_SIZE_T\t0x10000\t\t \n#define PF_PTRDIFF_T\t0x20000\t\t \n\n#define PF_ALLOCBUF\t0x40000\t\t \n\n#define PFM_SN\t\t0x01\t\t \n#define PFM_AS\t\t0x02\t\t \n\n#define ASBUFSIZE\t128\n\n#define x_digs\t\"0123456789abcdef\"\n#define X_digs\t\"0123456789ABCDEF\"\n\nstatic char intbuf[INT_STRLEN_BOUND(unsigned long) + 1];\n\nstatic int decpoint;\nstatic int thoussep;\nstatic char *grouping;\n\n \n\n \n#define MAX_INT  99 + 1  \n#define MAX_FRACT 307 + 1\n\n \n#define itoa(n) fmtulong(n, 10, intbuf, sizeof(intbuf), 0);\n#define dtoa(n, p, f) numtoa(n, 10, p, f)\n\n#define SWAP_INT(a,b) {int t; t = (a); (a) = (b); (b) = t;}\n\n#define GETARG(type)\t(va_arg(args, type))\n\n \n#define GETSIGNED(p) \\\n  (((p)->flags & PF_LONGINT) \\\n\t? GETARG (long) \\\n  \t: (((p)->flags & PF_SHORTINT) ? (long)(short)GETARG (int) \\\n\t\t\t\t      : (long)GETARG (int)))\n\n#define GETUNSIGNED(p) \\\n  (((p)->flags & PF_LONGINT) \\\n\t? GETARG (unsigned long) \\\n\t: (((p)->flags & PF_SHORTINT) ? (unsigned long)(unsigned short)GETARG (int) \\\n\t\t\t\t      : (unsigned long)GETARG (unsigned int)))\n\n\n#ifdef HAVE_LONG_DOUBLE\n#define GETLDOUBLE(p) GETARG (long double)\n#endif\n#define GETDOUBLE(p) GETARG (double)\n\n#define SET_SIZE_FLAGS(p, type) \\\n  if (sizeof (type) > sizeof (int)) \\\n    (p)->flags |= PF_LONGINT; \\\n  if (sizeof (type) > sizeof (long)) \\\n    (p)->flags |= PF_LONGLONG;\n\n \nstruct DATA\n{\n  int length;\n  char *base;\t\t \n  char *holder;\n  int counter;\n  const char *pf;\n\n \n  int flags;\n  int justify;\n  int width, precision;\n  char pad;\n};\n\n \n#ifdef FLOATING_POINT\nstatic double pow_10 PARAMS((int));\nstatic int log_10 PARAMS((double));\nstatic double integral PARAMS((double, double *));\nstatic char *numtoa PARAMS((double, int, int, char **));\n#endif\n\nstatic void init_data PARAMS((struct DATA *, char *, size_t, const char *, int));\nstatic void init_conv_flag PARAMS((struct DATA *));\n\n \n#ifdef FLOATING_POINT\nstatic void floating PARAMS((struct DATA *, double));\nstatic void exponent PARAMS((struct DATA *, double));\n#endif\nstatic void number PARAMS((struct DATA *, unsigned long, int));\n#ifdef HAVE_LONG_LONG_INT\nstatic void lnumber PARAMS((struct DATA *, unsigned long long, int));\n#endif\nstatic void pointer PARAMS((struct DATA *, unsigned long));\nstatic void strings PARAMS((struct DATA *, char *));\n\n#ifdef FLOATING_POINT\n#  define FALLBACK_FMTSIZE\t32\n#  define FALLBACK_BASE\t\t4096\n#  define LFALLBACK_BASE\t5120\n#  ifdef HAVE_LONG_DOUBLE\nstatic void ldfallback PARAMS((struct DATA *, const char *, const char *, long double));\n#  endif\nstatic void dfallback PARAMS((struct DATA *, const char *, const char *, double));\n#endif\n\nstatic char *groupnum PARAMS((char *));\n\n#if defined (HAVE_LONG_DOUBLE)\n#  define LONGDOUBLE long double\n#else\n#  define LONGDOUBLE double\n#endif\n\n#ifndef isnan\n  static inline int isnan_f  (float       x) { return x != x; }\n  static inline int isnan_d  (double      x) { return x != x; }\n  static inline int isnan_ld (LONGDOUBLE  x) { return x != x; }\n  # define isnan(x) \\\n      (sizeof (x) == sizeof (LONGDOUBLE) ? isnan_ld (x) \\\n       : sizeof (x) == sizeof (double) ? isnan_d (x) \\\n       : isnan_f (x))\n#endif\n  \n#ifndef isinf\n  static inline int isinf_f  (float       x) { return !isnan (x) && isnan (x - x); }\n  static inline int isinf_d  (double      x) { return !isnan (x) && isnan (x - x); }\n  static inline int isinf_ld (LONGDOUBLE  x) { return !isnan (x) && isnan (x - x); }\n  # define isinf(x) \\\n      (sizeof (x) == sizeof (LONGDOUBLE) ? isinf_ld (x) \\\n       : sizeof (x) == sizeof (double) ? isinf_d (x) \\\n       : isinf_f (x))\n#endif\n\n#ifdef DRIVER\nstatic void memory_error_and_abort ();\nstatic void *xmalloc PARAMS((size_t));\nstatic void *xrealloc PARAMS((void *, size_t));\nstatic void xfree PARAMS((void *));\n#else\n#  include <xmalloc.h>\n#endif\n\n \n#define RIGHT 1\n#define LEFT  0\n#define NOT_FOUND -1\n#define FOUND 1\n#define MAX_FIELD 15\n\n \n#define ROUND(d, p) \\\n\t    (d < 0.) ? \\\n\t     d - pow_10(-(p)->precision) * 0.5 : \\\n\t     d + pow_10(-(p)->precision) * 0.5\n\n \n#define DEF_PREC(p) \\\n\t    if ((p)->precision == NOT_FOUND) \\\n\t      (p)->precision = 6\n\n \n#define PUT_CHAR(c, p) \\\n\tdo \\\n\t  { \\\n\t    if (((p)->flags & PF_ALLOCBUF) && ((p)->counter >= (p)->length - 1)) \\\n\t      { \\\n\t\t(p)->length += ASBUFSIZE; \\\n\t\t(p)->base = (char *)xrealloc((p)->base, (p)->length); \\\n\t\t(p)->holder = (p)->base + (p)->counter;   \\\n\t      } \\\n\t    if ((p)->counter < (p)->length) \\\n\t      *(p)->holder++ = (c); \\\n\t    (p)->counter++; \\\n\t  } \\\n\twhile (0)\n\n \n#define PUT_STRING(string, len, p) \\\n\tdo \\\n\t  { \\\n\t    PAD_RIGHT (p); \\\n\t    while ((len)-- > 0) \\\n\t      { \\\n\t\tPUT_CHAR (*(string), (p)); \\\n\t\t(string)++; \\\n\t      } \\\n\t    PAD_LEFT (p); \\\n\t  } \\\n\twhile (0)\n\n#define PUT_PLUS(d, p, zero) \\\n\t    if (((p)->flags & PF_PLUS) && (d) > zero) \\\n\t      PUT_CHAR('+', p)\n\n#define PUT_SPACE(d, p, zero) \\\n\t    if (((p)->flags & PF_SPACE) && (d) > zero) \\\n\t      PUT_CHAR(' ', p)\n\n  \n#define PAD_RIGHT(p) \\\n\t    if ((p)->width > 0 && (p)->justify != LEFT) \\\n\t      for (; (p)->width > 0; (p)->width--) \\\n\t\t PUT_CHAR((p)->pad, p)\n\n \n#define PAD_LEFT(p) \\\n\t    if ((p)->width > 0 && (p)->justify == LEFT) \\\n\t      for (; (p)->width > 0; (p)->width--) \\\n\t\t PUT_CHAR((p)->pad, p)\n\n \n#define PAD_ZERO(p) \\\n\tif ((p)->precision > 0) \\\n\t  for (; (p)->precision > 0; (p)->precision--) \\\n\t    PUT_CHAR('0', p)\n\n \n#define STAR_ARGS(p) \\\n\tdo { \\\n\t    if ((p)->flags & PF_STAR_W) \\\n\t      { \\\n\t\t(p)->width = GETARG (int); \\\n\t\tif ((p)->width < 0) \\\n\t\t  { \\\n\t\t    (p)->flags |= PF_LADJUST; \\\n\t\t    (p)->justify = LEFT; \\\n\t\t    (p)->width = -(p)->width; \\\n\t\t  } \\\n\t      } \\\n\t    if ((p)->flags & PF_STAR_P) \\\n\t      { \\\n\t\t(p)->precision = GETARG (int); \\\n\t\tif ((p)->precision < 0) \\\n\t\t  { \\\n\t\t    (p)->flags &= ~PF_STAR_P; \\\n\t\t    (p)->precision = NOT_FOUND; \\\n\t\t  } \\\n\t      } \\\n\t} while (0)\n\n#if defined (HAVE_LOCALE_H) && defined (HAVE_LOCALECONV)\n#  define GETLOCALEDATA(d, t, g) \\\n      do \\\n\t{ \\\n\t  struct lconv *lv; \\\n\t  if ((d) == 0) { \\\n\t  (d) = '.'; (t) = -1; (g) = 0;   \\\n\t  lv = localeconv(); \\\n\t  if (lv) \\\n\t    { \\\n\t      if (lv->decimal_point && lv->decimal_point[0]) \\\n\t\t(d) = lv->decimal_point[0]; \\\n\t      if (lv->thousands_sep && lv->thousands_sep[0]) \\\n\t\t(t) = lv->thousands_sep[0]; \\\n\t      (g) = lv->grouping ? lv->grouping : \"\"; \\\n\t      if (*(g) == '\\0' || *(g) == CHAR_MAX || (t) == -1) (g) = 0; \\\n\t    } \\\n\t  } \\\n\t} \\\n      while (0);\n#else\n#  define GETLOCALEDATA(d, t, g) \\\n      ( (d) = '.', (t) = ',', g = \"\\003\" )\n#endif\n\n#ifdef FLOATING_POINT\n \nstatic double\npow_10(n)\n     int n;\n{ \n  double P;\n\n   \n  switch (n)\n    {\n    case -3:\treturn .001;\n    case -2:\treturn .01;\n    case -1:\treturn .1;\n    case 0:\treturn 1.;\n    case 1:\treturn 10.;\n    case 2:\treturn 100.;\n    case 3:\treturn 1000.;\n    }\n\n  if (n < 0)\n    {\n      P = .0001;\n      for (n += 4; n < 0; n++)\n\tP /= 10.;\n    }\n  else\n    {\n      P = 10000.;\n      for (n -= 4; n > 0; n--)\n\tP *= 10.;\n    }\n\n  return P;\n}\n\n \nstatic int\nlog_10(r)\n     double r;\n{ \n  int i = 0;\n  double result = 1.;\n\n  if (r < 0.)\n    r = -r;\n\n  if (r < 1.)\n    {\n      while (result >= r)\n\t{\n\t  result /= 10.;\n\t  i++;\n\t}\n      return (-i);\n    }\n  else\n    {\n      while (result <= r)\n\t{\n\t  result *= 10.;\n\t  i++;\n\t}\n      return (i - 1);\n    }\n}\n\n \nstatic double\nintegral(real, ip)\n     double real;\n     double *ip;\n{ \n  int j;\n  double i, s, p;\n  double real_integral = 0.;\n\n   \n   \n  if (real == 0.)\n    {\n      *ip = 0.;\n      return (0.);\n    }\n\n   \n  if (real < 0.)\n    real = -real;\n\n   \n  if ( real < 1.)\n    {\n      *ip = 0.;\n      return real;\n    }\n\n   \n  for (j = log_10(real); j >= 0; j--)\n    {\n      p = pow_10(j);\n      s = (real - real_integral)/p;\n      i = 0.;\n      while (i + 1. <= s)\n\ti++;\n      real_integral += i*p;\n    }\n  *ip = real_integral;\n  return (real - real_integral);\n}\n\n#define PRECISION 1.e-6\n \nstatic char *\nnumtoa(number, base, precision, fract)\n     double number;\n     int base, precision;\n     char **fract;\n{\n  register int i, j;\n  double ip, fp;  \n  double fraction;\n  int digits, sign;\n  static char integral_part[MAX_INT];\n  static char fraction_part[MAX_FRACT];\n  int ch;\n\n   \n  if (number == 0.)\n    { \n      integral_part[0] = '0';\n      integral_part[1] = '\\0';\n       \n      for (ch = 0; ch < precision-1; ch++)\n \tfraction_part[ch] = '0';\n      fraction_part[ch] = '0';\n      fraction_part[ch+1] = '\\0';\n      if (fract)\n\t*fract = fraction_part;\n      return integral_part;\n    }\n\n   \n  sign = (number == -0.) ? '-' : ((number < 0.) ? '-' : '+');\n  digits = MAX_INT - 1;\n\n   \n  if (sign == '-')\n    {\n      number = -number;\n      digits--;  \n    }\n\n  fraction = integral(number, &ip);\n  number = ip;\n\n   \n  if (ip == 0.)\n    {\n      integral_part[0] = '0';\n      i = 1;\n    }\n  else\n    {\n      for ( i = 0; i < digits && number != 0.; ++i)\n\t{\n\t  number /= base;\n\t  fp = integral(number, &ip);\n\t  ch = (int)((fp + PRECISION)*base);  \n\t  integral_part[i] = (ch <= 9) ? ch + '0' : ch + 'a' - 10;\n\t  if (! ISXDIGIT((unsigned char)integral_part[i]))\n\t    break;\t \n\t  number = ip;\n\t }\n    }\n     \n   \n  if (number != 0.)\n    for (i = 0; i < digits; ++i)\n      integral_part[i] = '9';\n\n   \n  if (sign == '-')\n    integral_part[i++] = '-';\n\n  integral_part[i] = '\\0';\n\n   \n  for ( i--, j = 0; j < i; j++, i--)\n    SWAP_INT(integral_part[i], integral_part[j]);  \n\n   \n  for (i=0, fp=fraction; precision > 0 && i < MAX_FRACT ; i++, precision--)\n    {\n      fraction_part[i] = (int)((fp + PRECISION)*10. + '0');\n      if (! DIGIT(fraction_part[i]))  \n\tbreak;\n      fp = (fp*10.0) - (double)(long)((fp + PRECISION)*10.);\n    }\n  fraction_part[i] = '\\0';\n\n  if (fract != (char **)0)\n    *fract = fraction_part;\n\n  return integral_part;\n}\n#endif\n\n \nstatic void\nnumber(p, d, base)\n     struct DATA *p;\n     unsigned long d;\n     int base;\n{\n  char *tmp, *t;\n  long sd;\n  int flags;\n\n   \n  if ((p->flags & PF_ZEROPAD) && p->precision >= 0 && (p->flags & PF_DOT))\n    {\n      p->flags &= ~PF_ZEROPAD;\n      p->pad = ' ';\n    }\n\n  sd = d;\t \n  flags = 0;\n  flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;\n  if (*p->pf == 'X')\n    flags |= FL_HEXUPPER;\n\n  tmp = fmtulong (d, base, intbuf, sizeof(intbuf), flags);\n  t = 0;\n  if ((p->flags & PF_THOUSANDS))\n    {\n      GETLOCALEDATA(decpoint, thoussep, grouping);\n      if (grouping && (t = groupnum (tmp)))\n\ttmp = t;\n    }\n\n   \n  p->width -= strlen(tmp) + (base == 10 && d > 0 && (p->flags & PF_PLUS));\n  PAD_RIGHT(p);\n\n  if ((p->flags & PF_DOT) && p->precision > 0)\n    {\n      p->precision -= strlen(tmp);\n      PAD_ZERO(p);\n    }\n\n  switch (base)\n    {\n    case 10:\n      PUT_PLUS(sd, p, 0);\n      PUT_SPACE(sd, p, 0);\n      break;\n    case 8:\n      if (p->flags & PF_ALTFORM)\n\tPUT_CHAR('0', p);\n      break;\n    case 16:\n      if (p->flags & PF_ALTFORM)\n\t{\n\t  PUT_CHAR('0', p);\n\t  PUT_CHAR(*p->pf, p);\n\t}\n      break;\n    }\n\n  while (*tmp)\n    {\n      PUT_CHAR(*tmp, p);\n      tmp++;\n    }\n\n  PAD_LEFT(p);\n  FREE (t);\n}\n\n#ifdef HAVE_LONG_LONG_INT\n \nstatic void\nlnumber(p, d, base)\n     struct DATA *p;\n     unsigned long long d;\n     int base;\n{\n  char *tmp, *t;\n  long long sd;\n  int flags;\n\n   \n  if ((p->flags & PF_ZEROPAD) && p->precision >= 0 && (p->flags & PF_DOT))\n    {\n      p->flags &= ~PF_ZEROPAD;\n      p->pad = ' ';\n    }\n\n  sd = d;\t \n  flags = (*p->pf == 'x' || *p->pf == 'X' || *p->pf == 'o' || *p->pf == 'u' || *p->pf == 'U') ? FL_UNSIGNED : 0;\n  if (*p->pf == 'X')\n    flags |= FL_HEXUPPER;\n\n  tmp = fmtullong (d, base, intbuf, sizeof(intbuf), flags);\n  t = 0;\n  if ((p->flags & PF_THOUSANDS))\n    {\n      GETLOCALEDATA(decpoint, thoussep, grouping);\n      if (grouping && (t = groupnum (tmp)))\n\ttmp = t;\n    }\n\n   \n  p->width -= strlen(tmp) + (base == 10 && d > 0 && (p->flags & PF_PLUS));\n  PAD_RIGHT(p);\n\n  if ((p->flags & PF_DOT) && p->precision > 0)\n    {\n      p->precision -= strlen(tmp);\n      PAD_ZERO(p);\n    }\n\n  switch (base)\n    {\n    case 10:\n      PUT_PLUS(sd, p, 0);\n      PUT_SPACE(sd, p, 0);\n      break;\n    case 8:\n      if (p->flags & PF_ALTFORM)\n\tPUT_CHAR('0', p);\n      break;\n    case 16:\n      if (p->flags & PF_ALTFORM)\n\t{\n\t  PUT_CHAR('0', p);\n\t  PUT_CHAR(*p->pf, p);\n\t}\n      break;\n    }\n\n  while (*tmp)\n    {\n      PUT_CHAR(*tmp, p);\n      tmp++;\n    }\n\n  PAD_LEFT(p);\n  FREE (t);\n}\n#endif\n\nstatic void\npointer(p, d)\n     struct DATA *p;\n     unsigned long d;\n{\n  char *tmp;\n\n  tmp = fmtulong(d, 16, intbuf, sizeof(intbuf), 0);\n  p->width -= strlen(tmp);\n  PAD_RIGHT(p);\n\n   \n  PUT_CHAR('0', p);\n  PUT_CHAR('x', p);\n\n  while (*tmp)\n    {\n      PUT_CHAR(*tmp, p);\n      tmp++;\n    }\n\n  PAD_LEFT(p);\n}\n\n \nstatic void\nstrings(p, tmp)\n     struct DATA *p;\n     char *tmp;\n{\n  size_t len;\n\n  len = strlen(tmp);\n  if (p->precision != NOT_FOUND)  \n    len = (len < p->precision ? len : p->precision);\n  p->width -= len;\n\n  PUT_STRING (tmp, len, p);\n}\n\n#if HANDLE_MULTIBYTE\n \nstatic void\nwstrings(p, tmp)\n     struct DATA *p;\n     wchar_t *tmp;\n{\n  size_t len;\n  mbstate_t mbs;\n  char *os;\n  const wchar_t *ws;\n\n  memset (&mbs, '\\0', sizeof (mbstate_t));\n  ws = (const wchar_t *)tmp;\n\n  os = (char *)NULL;\n  if (p->precision != NOT_FOUND)\n    {\n      os = (char *)xmalloc (p->precision + 1);\n      len = wcsrtombs (os, &ws, p->precision, &mbs);\n    }\n  else\n    {\n      len = wcsrtombs (NULL, &ws, 0, &mbs);\n      if (len != (size_t)-1)\n\t{\n\t  memset (&mbs, '\\0', sizeof (mbstate_t));\n\t  os = (char *)xmalloc (len + 1);\n\t  (void)wcsrtombs (os, &ws, len + 1, &mbs);\n\t}\n    }\n  if (len == (size_t)-1)\n    {\n       \n      FREE (os);      \n      return;\n    }\n\n  p->width -= len;\n  PUT_STRING (os, len, p);\n  free (os);\n}\n\nstatic void\nwchars (p, wc)\n     struct DATA *p;\n     wint_t wc;\n{\n  char *lbuf, *l;\n  mbstate_t mbs;\n  size_t len;\n\n  lbuf = (char *)malloc (MB_CUR_MAX+1);\n  if (lbuf == 0)\n    return;\n  memset (&mbs, '\\0', sizeof (mbstate_t));\n  len = wcrtomb (lbuf, wc, &mbs);\n  if (len == (size_t)-1)\n     \n    return;\n  p->width -= len;\n  l = lbuf;\n  PUT_STRING (l, len, p);\n  free (lbuf);\n}\n#endif  \n\n#ifdef FLOATING_POINT\n\n \nstatic int\nchkinfnan(p, d, mode)\n     struct DATA *p;\n     double d;\n     int mode;\t\t \n{\n  int i;\n  char *tmp;\n  char *big, *small;\n\n  i = (mode == 1) ? isinf(d) : isnan(d);\n  if (i == 0)\n    return 0;\n  big = (mode == 1) ? \"INF\" : \"NAN\";\n  small = (mode == 1) ? \"inf\" : \"nan\";\n\n  tmp = (*p->pf == 'F' || *p->pf == 'G' || *p->pf == 'E') ? big : small;\n\n  if (i < 0)\n    PUT_CHAR('-', p);\n\n  while (*tmp)\n    {\n      PUT_CHAR (*tmp, p);\n      tmp++;\n    }\n\n  return 1;\n}\n\n \nstatic void\nfloating(p, d)\n     struct DATA *p;\n     double d;\n{\n  char *tmp, *tmp2, *t;\n  int i;\n\n  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))\n    return;\t \n\n  GETLOCALEDATA(decpoint, thoussep, grouping);\n  DEF_PREC(p);\n  d = ROUND(d, p);\n  tmp = dtoa(d, p->precision, &tmp2);\n  t = 0;\n  if ((p->flags & PF_THOUSANDS) && grouping && (t = groupnum (tmp)))\n    tmp = t;\n\n  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)\n    {\n       \n      for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)\n\ttmp2[i] = '\\0'; \n      if (tmp2[0] == '\\0')\n\tp->precision = 0;\n    }\n\n   \n  p->width = p->width -\n  \t     \n#if 0\n\t    ((d > 0. && p->justify == RIGHT) ? 1:0) -\n#else\n\t    ((d > 0. && (p->flags & PF_PLUS)) ? 1:0) -\n#endif\n\t    ((p->flags & PF_SPACE) ? 1:0) -\n\t    strlen(tmp) - p->precision -\n\t    ((p->precision != 0 || (p->flags & PF_ALTFORM)) ? 1 : 0);\t \n\n  if (p->pad == ' ')\n    {\n      PAD_RIGHT(p);\n      PUT_PLUS(d, p, 0.);\n    }\n  else\n    {\n      if (*tmp == '-')\n\tPUT_CHAR(*tmp++, p);\n      PUT_PLUS(d, p, 0.);\n      PAD_RIGHT(p);\n    }\n  PUT_SPACE(d, p, 0.);\n\n  while (*tmp)\n    {\n      PUT_CHAR(*tmp, p);\t \n      tmp++;\n    }\n  FREE (t);\n\n  if (p->precision != 0 || (p->flags & PF_ALTFORM))\n    PUT_CHAR(decpoint, p);   \n\n  for (; *tmp2; tmp2++)\n    PUT_CHAR(*tmp2, p);  \n  \n  PAD_LEFT(p);\n} \n\n \nstatic void\nexponent(p, d)\n     struct DATA *p;\n     double d;\n{\n  char *tmp, *tmp2;\n  int j, i;\n\n  if (d != 0 && (chkinfnan(p, d, 1) || chkinfnan(p, d, 2)))\n    return;\t \n\n  GETLOCALEDATA(decpoint, thoussep, grouping);\n  DEF_PREC(p);\n  if (d == 0.)\n    j = 0;\n  else\n    {\n      j = log_10(d);\n      d = d / pow_10(j);   \n      d = ROUND(d, p);\t\t  \n    }\n  tmp = dtoa(d, p->precision, &tmp2);\n\n   \n   \n  p->width = p->width - \n  \t     \n#if 0\n\t     ((d > 0. && p->justify == RIGHT) ? 1:0) -\n#else\n\t     ((d > 0. && (p->flags & PF_PLUS)) ? 1:0) -\n#endif\n\t     (p->precision != 0 || (p->flags & PF_ALTFORM)) -\n\t     ((p->flags & PF_SPACE) ? 1:0) - p->precision - 5;\n\n  if (p->pad == ' ')\n    {\n      PAD_RIGHT(p);\n      PUT_PLUS(d, p, 0.);\n    }\n  else\n    {\n      if (*tmp == '-')\n\tPUT_CHAR(*tmp++, p);\n      PUT_PLUS(d, p, 0.);\n      PAD_RIGHT(p);\n    }\n  PUT_SPACE(d, p, 0.);\n\n  while (*tmp)\n    {\n      PUT_CHAR(*tmp, p);\n      tmp++;\n    }\n\n  if (p->precision != 0 || (p->flags & PF_ALTFORM))\n      PUT_CHAR(decpoint, p);   \n\n  if ((*p->pf == 'g' || *p->pf == 'G') && (p->flags & PF_ALTFORM) == 0)\n     \n    for (i = strlen(tmp2) - 1; i >= 0 && tmp2[i] == '0'; i--)\n      tmp2[i] = '\\0'; \n\n  for (; *tmp2; tmp2++)\n    PUT_CHAR(*tmp2, p);  \n\n   \n  if (*p->pf == 'g' || *p->pf == 'e')\n    PUT_CHAR('e', p);\n  else\n    PUT_CHAR('E', p);\n\n   \n  if (j >= 0)\n    PUT_CHAR('+', p);\n  else\n    {\n      PUT_CHAR('-', p);\n      j = -j;\n    }\n\n   tmp = itoa(j);\n    \n   if (j <= 9)\n     PUT_CHAR('0', p);\n\n    \n   while (*tmp)\n     {\n       PUT_CHAR(*tmp, p);\n       tmp++;\n     }\n\n   PAD_LEFT(p);\n}\n#endif\n\n \nstatic char *\ngroupnum (s)\n     char *s;\n{\n  char *se, *ret, *re, *g;\n  int len, slen;\n\n  if (grouping == 0 || *grouping <= 0 || *grouping == CHAR_MAX)\n    return ((char *)NULL);\n\n   \n  for (len = *grouping, g = grouping; *g; g++)\n      if (*g > 0 && *g < len)\n\tlen = *g;\n\n  slen = strlen (s);\n  len = slen / len + 1;\n  ret = (char *)xmalloc (slen + len + 1);\n  re = ret + slen + len;\n  *re = '\\0';\n\n  g = grouping;\n  se = s + slen;\n  len = *g;\n\n  while (se > s)\n    {\n      *--re = *--se;\n\n       \n      if (se > s && se[-1] == '-')\n\tcontinue;\n\n       \n      if (--len == 0 && se > s)\n\t{\n\t  *--re = thoussep;\n\t  len = *++g;\t\t \n\t  if (*g == '\\0')\n\t    len = *--g;\t\t \n\t  else if (*g == CHAR_MAX)\n\t    {\n\t      do\n\t\t*--re = *--se;\n\t      while (se > s);\n\t      break;\n\t    }\n\t}\n    }\n\n  if (re > ret)\n#ifdef HAVE_MEMMOVE\n    memmove (ret, re, strlen (re) + 1);\n#else\n    strcpy (ret, re);\n#endif\n   \n  return ret;\n}\n\n \nstatic void\ninit_conv_flag (p)\n     struct DATA *p;\n{\n  p->flags &= PF_ALLOCBUF;\t\t \n  p->precision = p->width = NOT_FOUND;\n  p->justify = NOT_FOUND;\n  p->pad = ' ';\n}\n\nstatic void\ninit_data (p, string, length, format, mode)\n     struct DATA *p;\n     char *string;\n     size_t length;\n     const char *format;\n     int mode;\n{\n  p->length = length - 1;  \n  p->holder = p->base = string;\n  p->pf = format;\n  p->counter = 0;\n  p->flags = (mode == PFM_AS) ? PF_ALLOCBUF : 0;\n}\n\nstatic int\n#if defined (__STDC__)\nvsnprintf_internal(struct DATA *data, char *string, size_t length, const char *format, va_list args)\n#else\nvsnprintf_internal(data, string, length, format, args)\n     struct DATA *data;\n     char *string;\n     size_t length;\n     const char *format;\n     va_list args;\n#endif\n{\n  double d;  \n#ifdef HAVE_LONG_DOUBLE\n  long double ld;\t \n#endif\n  unsigned long ul;\n#ifdef HAVE_UNSIGNED_LONG_LONG_INT\n  unsigned long long ull;\n#endif\n  int state, i, c, n;\n  char *s;\n#if HANDLE_MULTIBYTE\n  wchar_t *ws;\n  wint_t wc;\n#endif\n  const char *convstart;\n  int negprec;\n\n   \n  if (length < 0)\n    return -1;\n\n  if (format == 0)\n    return 0;\n\n   \n  decpoint = thoussep = 0;\n  grouping = 0;\n\n  negprec = 0;\n  for (; c = *(data->pf); data->pf++)\n    {\n      if (c != '%')\n\t{\n\t  PUT_CHAR (c, data);\n\t  continue;\n\t}\n\n      convstart = data->pf;\n      init_conv_flag (data);  \n\n      state = 1;\n      for (state = 1; state && *data->pf; )\n\t{\n\t  c = *(++data->pf);\n\t       \n#if defined (FLOATING_POINT) && defined (HAVE_LONG_DOUBLE)\n\t  if (data->flags & PF_LONGDBL)\n\t    {\n\t      switch (c)\n\t\t{\n\t\tcase 'f': case 'F':\n\t\tcase 'e': case 'E':\n\t\tcase 'g': case 'G':\n#  ifdef HAVE_PRINTF_A_FORMAT\n\t\tcase 'a': case 'A':\n#  endif\n\t\t  STAR_ARGS (data);\n\t\t  ld = GETLDOUBLE (data);\n\t\t  ldfallback (data, convstart, data->pf, ld);\n\t\t  goto conv_break;\n\t\t}\n\t    }\n#endif  \n\n\t  switch (c)\n\t    {\n\t       \n\t      case '\\0':  \n\t\t*data->holder = '\\0';\n\t\treturn data->counter;\n\t\tbreak;\n\t      case '#':\n\t\tdata->flags |= PF_ALTFORM;\n\t\tcontinue;\n\t      case '*':\n\t\tif (data->flags & PF_DOT)\n\t\t  data->flags |= PF_STAR_P;\n\t\telse\n\t\t  data->flags |= PF_STAR_W;\n\t\tcontinue;\n\t      case '-':\n\t\tif ((data->flags & PF_DOT) == 0)\n\t\t  {\n\t\t    data->flags |= PF_LADJUST;\n\t\t    data->justify = LEFT;\n\t\t  }\n\t\telse\n\t\t  negprec = 1;\n\t\tcontinue;\n\t      case ' ':\n\t\tif ((data->flags & PF_PLUS) == 0)\n\t\t  data->flags |= PF_SPACE;\n\t\tcontinue;\n\t      case '+':\n\t\tif ((data->flags & PF_DOT) == 0)\n\t\t  {\n\t\t    data->flags |= PF_PLUS;\n\t\t    if ((data->flags & PF_LADJUST) == 0)\n\t\t      data->justify = RIGHT;\n\t\t  }\n\t\tcontinue;\n\t      case '\\'':\n\t\tdata->flags |= PF_THOUSANDS;\n\t\tcontinue;\n\n\t      case '0':\n\t\t \n\t        if ((data->flags & (PF_DOT|PF_LADJUST)) == 0)\n\t\t  {\n\t\t    data->flags |= PF_ZEROPAD;\n\t\t    data->pad = '0';\n\t\t    continue;\n\t\t  }\n\t      case '1': case '2': case '3':\n\t      case '4': case '5': case '6':\n\t      case '7': case '8': case '9':\n\t\tn = 0;\n\t\tdo\n\t\t  {\n\t\t    n = n * 10 + TODIGIT(c);\n\t\t    c = *(++data->pf);\n\t\t  }\n\t\twhile (DIGIT(c));\n\t\tdata->pf--;\t\t \n\t\tif (n < 0)\n\t\t  n = 0;\n\t\tif (data->flags & PF_DOT)\n\t\t  data->precision = negprec ? NOT_FOUND : n;\n\t\telse\n\t\t  data->width = n;\n\t\tcontinue;\n\n\t       \n\t      case '.':\n\t\tdata->flags |= PF_DOT;\n\t\tdata->precision = 0;\n\t\tcontinue;\n\n\t       \n\t      case 'h':\n\t\tdata->flags |= (data->flags & PF_SHORTINT) ? PF_SIGNEDCHAR : PF_SHORTINT;\n\t\tcontinue;\n\t      case 'l':\n\t\tdata->flags |= (data->flags & PF_LONGINT) ? PF_LONGLONG : PF_LONGINT;\n\t\tcontinue;\n\t      case 'L':\n\t\tdata->flags |= PF_LONGDBL;\n\t\tcontinue;\n\t      case 'q':\n\t\tdata->flags |= PF_LONGLONG;\n\t\tcontinue;\n\t      case 'j':\n\t\tdata->flags |= PF_INTMAX_T;\n\t\tSET_SIZE_FLAGS(data, intmax_t);\n\t\tcontinue;\n\t      case 'z':\n\t\tdata->flags |= PF_SIZE_T;\n\t\tSET_SIZE_FLAGS(data, size_t);\n\t\tcontinue;\n\t      case 't':\n\t\tdata->flags |= PF_PTRDIFF_T;\n\t\tSET_SIZE_FLAGS(data, ptrdiff_t);\n\t\tcontinue;\n\t\t\n\t       \n#ifdef FLOATING_POINT\n\t      case 'f':   \n\t      case 'F':\n\t\tSTAR_ARGS(data);\n\t\td = GETDOUBLE(data);\n\t\tfloating(data, d);\nconv_break:\t\t\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'g': \n\t      case 'G':\n\t\tSTAR_ARGS(data);\n\t\tDEF_PREC(data);\n\t\td = GETDOUBLE(data);\n\t\ti = (d != 0.) ? log_10(d) : -1;\n\t\t \n\t\tif (-4 < i && i < data->precision)\n\t\t  {\n\t\t     \n\t\t    data->precision -= i + 1;\n\t\t    floating(data, d);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t     \n\t\t    if (data->precision > 0)\n\t\t      data->precision--;\n\t\t    exponent(data, d);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'e':\n\t      case 'E':   \n\t\tSTAR_ARGS(data);\n\t\td = GETDOUBLE(data);\n\t\texponent(data, d);\n\t\tstate = 0;\n\t\tbreak;\n#  ifdef HAVE_PRINTF_A_FORMAT\n\t      case 'a':\n\t      case 'A':\n\t\tSTAR_ARGS(data);\n\t\td = GETDOUBLE(data);\n\t\tdfallback(data, convstart, data->pf, d);\n\t\tstate = 0;\n\t\tbreak;\n#  endif  \n#endif  \n\t      case 'U':\n\t\tdata->flags |= PF_LONGINT;\n\t\t \n\t      case 'u':\n\t\tSTAR_ARGS(data);\n#ifdef HAVE_LONG_LONG_INT\n\t\tif (data->flags & PF_LONGLONG)\n\t\t  {\n\t\t    ull = GETARG (unsigned long long);\n\t\t    lnumber(data, ull, 10);\n\t\t  }\n\t\telse\n#endif\n\t\t  {\n\t\t    ul = GETUNSIGNED(data);\n\t\t    number(data, ul, 10);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'D':\n\t\tdata->flags |= PF_LONGINT;\n\t\t \n\t      case 'd':   \n\t      case 'i':\n\t\tSTAR_ARGS(data);\n#ifdef HAVE_LONG_LONG_INT\n\t\tif (data->flags & PF_LONGLONG)\n\t\t  {\n\t\t    ull = GETARG (long long);\n\t\t    lnumber(data, ull, 10);\n\t\t  }\n\t\telse\n#endif\n\t\t  {\n\t\t    ul = GETSIGNED(data);\n\t\t    number(data, ul, 10);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'o':   \n\t\tSTAR_ARGS(data);\n#ifdef HAVE_LONG_LONG_INT\n\t\tif (data->flags & PF_LONGLONG)\n\t\t  {\n\t\t    ull = GETARG (unsigned long long);\n\t\t    lnumber(data, ull, 8);\n\t\t  }\n\t\telse\n#endif\n\t\t  {\n\t\t    ul = GETUNSIGNED(data);\n\t\t    number(data, ul, 8);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'x': \n\t      case 'X':   \n\t\tSTAR_ARGS(data);\n#ifdef HAVE_LONG_LONG_INT\n\t\tif (data->flags & PF_LONGLONG)\n\t\t  {\n\t\t    ull = GETARG (unsigned long long);\n\t\t    lnumber(data, ull, 16);\n\t\t  }\n\t\telse\n#endif\n\t\t  {\n\t\t    ul = GETUNSIGNED(data);\n\t\t    number(data, ul, 16);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'p':\n\t\tSTAR_ARGS(data);\n\t\tul = (unsigned long)GETARG (void *);\n\t\tpointer(data, ul);\n\t\tstate = 0;\n\t\tbreak;\n#if HANDLE_MULTIBYTE\n\t      case 'C':\n\t\tdata->flags |= PF_LONGINT;\n\t\t \n#endif\n\t      case 'c':  \n\t\tSTAR_ARGS(data);\n#if HANDLE_MULTIBYTE\n\t\tif (data->flags & PF_LONGINT)\n\t\t  {\n\t\t    wc = GETARG (wint_t);\n\t\t    wchars (data, wc);\n\t\t  }\n\t\telse\n#endif\n\t\t  {\t\t\n\t\t    ul = GETARG (int);\n\t\t    PUT_CHAR(ul, data);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n#if HANDLE_MULTIBYTE\n\t      case 'S':\n\t\tdata->flags |= PF_LONGINT;\n\t\t \n#endif\n\t      case 's':   \n\t\tSTAR_ARGS(data);\n#if HANDLE_MULTIBYTE\n\t\tif (data->flags & PF_LONGINT)\n\t\t  {\n\t\t    ws = GETARG (wchar_t *);\n\t\t    wstrings (data, ws);\n\t\t  }\n\t\telse\n#endif\n\t\t  {\n\t\t    s = GETARG (char *);\n\t\t    strings(data, s);\n\t\t  }\n\t\tstate = 0;\n\t\tbreak;\n\t      case 'n':\n#ifdef HAVE_LONG_LONG_INT\n\t\tif (data->flags & PF_LONGLONG)\n\t\t  *(GETARG (long long *)) = data->counter;\n\t\telse\n#endif\n\t\tif (data->flags & PF_LONGINT)\n\t\t  *(GETARG (long *)) = data->counter;\n\t\telse if (data->flags & PF_SHORTINT)\n\t\t  *(GETARG (short *)) = data->counter;\n\t\telse\n\t\t  *(GETARG (int *)) = data->counter;\n\t\tstate = 0;\n\t\tbreak;\n\t      case '%':   \n\t\tPUT_CHAR('%', data);\n\t\tstate = 0;\n\t\tbreak;\n  \t      default:\n\t\t \n\t\tstate = 0;\n\t\tbreak;\n\t}  \n      }  \n    }  \n\n  if (data->length >= 0)\n    *data->holder = '\\0';  \n\n  return data->counter;\n}\n\n#if defined (FLOATING_POINT) && defined (HAVE_LONG_DOUBLE)\n \nstatic void\nldfallback (data, fs, fe, ld)\n     struct DATA *data;\n     const char *fs, *fe;\n     long double ld;\n{\n  register char *x;\n  char fmtbuf[FALLBACK_FMTSIZE], *obuf;\n  int fl;\n\n  fl = LFALLBACK_BASE + (data->precision < 6 ? 6 : data->precision) + 2;\n  obuf = (char *)xmalloc (fl);\n  fl = fe - fs + 1;\n  strncpy (fmtbuf, fs, fl);\n  fmtbuf[fl] = '\\0';\n\n  if ((data->flags & PF_STAR_W) && (data->flags & PF_STAR_P))\n    sprintf (obuf, fmtbuf, data->width, data->precision, ld);\n  else if (data->flags & PF_STAR_W)\n    sprintf (obuf, fmtbuf, data->width, ld);\n  else if (data->flags & PF_STAR_P)\n    sprintf (obuf, fmtbuf, data->precision, ld);\n  else\n    sprintf (obuf, fmtbuf, ld);\n\n  for (x = obuf; *x; x++)\n    PUT_CHAR (*x, data);    \n  xfree (obuf);\n}\n#endif  \n\n#ifdef FLOATING_POINT\n \nstatic void\ndfallback (data, fs, fe, d)\n     struct DATA *data;\n     const char *fs, *fe;\n     double d;\n{\n  register char *x;\n  char fmtbuf[FALLBACK_FMTSIZE], obuf[FALLBACK_BASE];\n  int fl;\n\n  fl = fe - fs + 1;\n  strncpy (fmtbuf, fs, fl);\n  fmtbuf[fl] = '\\0';\n\n  if ((data->flags & PF_STAR_W) && (data->flags & PF_STAR_P))\n    sprintf (obuf, fmtbuf, data->width, data->precision, d);\n  else if (data->flags & PF_STAR_W)\n    sprintf (obuf, fmtbuf, data->width, d);\n  else if (data->flags & PF_STAR_P)\n    sprintf (obuf, fmtbuf, data->precision, d);\n  else\n    sprintf (obuf, fmtbuf, d);\n\n  for (x = obuf; *x; x++)\n    PUT_CHAR (*x, data);    \n}\n#endif  \n\n#if !HAVE_SNPRINTF\n\nint\n#if defined (__STDC__)\nvsnprintf(char *string, size_t length, const char *format, va_list args)\n#else\nvsnprintf(string, length, format, args)\n     char *string;\n     size_t length;\n     const char *format;\n     va_list args;\n#endif\n{\n  struct DATA data;\n\n  if (string == 0 && length != 0)\n    return 0;\n  init_data (&data, string, length, format, PFM_SN);\n  return (vsnprintf_internal(&data, string, length, format, args));\n}\n\nint\n#if defined(PREFER_STDARG)\nsnprintf(char *string, size_t length, const char * format, ...)\n#else\nsnprintf(string, length, format, va_alist)\n     char *string;\n     size_t length;\n     const char *format;\n     va_dcl\n#endif\n{\n  struct DATA data;\n  int rval;\n  va_list args;\n\n  SH_VA_START(args, format);\n\n  if (string == 0 && length != 0)\n    return 0;\n  init_data (&data, string, length, format, PFM_SN);\n  rval = vsnprintf_internal (&data, string, length, format, args);\n\n  va_end(args);\n\n  return rval;\n}\n\n#endif  \n\n#if !HAVE_ASPRINTF\n\nint\n#if defined (__STDC__)\nvasprintf(char **stringp, const char *format, va_list args)\n#else\nvasprintf(stringp, format, args)\n     char **stringp;\n     const char *format;\n     va_list args;\n#endif\n{\n  struct DATA data;\n  char *string;\n  int r;\n\n  string = (char *)xmalloc(ASBUFSIZE);\n  init_data (&data, string, ASBUFSIZE, format, PFM_AS);\n  r = vsnprintf_internal(&data, string, ASBUFSIZE, format, args);\n  *stringp = data.base;\t\t \n  return r;\n}\n\nint\n#if defined(PREFER_STDARG)\nasprintf(char **stringp, const char * format, ...)\n#else\nasprintf(stringp, format, va_alist)\n     char **stringp;\n     const char *format;\n     va_dcl\n#endif\n{\n  int rval;\n  va_list args;\n\n  SH_VA_START(args, format);\n\n  rval = vasprintf (stringp, format, args);\n\n  va_end(args);\n\n  return rval;\n}\n\n#endif  \n\n#endif  \n\n#ifdef DRIVER\n\nstatic void\nmemory_error_and_abort ()\n{\n  write (2, \"out of virtual memory\\n\", 22);\n  abort ();\n}\n\nstatic void *\nxmalloc(bytes)\n     size_t bytes;\n{\n  void *ret;\n\n  ret = malloc(bytes);\n  if (ret == 0)\n    memory_error_and_abort ();\n  return ret;\n}\n\nstatic void *\nxrealloc (pointer, bytes)\n     void *pointer;\n     size_t bytes;\n{\n  void *ret;\n\n  ret = pointer ? realloc(pointer, bytes) : malloc(bytes);\n  if (ret == 0)\n    memory_error_and_abort ();\n  return ret;\n}\n\nstatic void\nxfree(x)\n     void *x;\n{\n  if (x)\n    free (x);\n}\n\n \nmain()\n{\n  char holder[100];\n  char *h;\n  int i, si, ai;\n\n#ifdef HAVE_LOCALE_H\n  setlocale(LC_ALL, \"\");\n#endif\n\n#if 1\n  si = snprintf((char *)NULL, 0, \"abcde\\n\");\n  printf(\"snprintf returns %d with NULL first argument and size of 0\\n\", si);\n  si = snprintf(holder, 0, \"abcde\\n\");\n  printf(\"snprintf returns %d with non-NULL first argument and size of 0\\n\", si);\n  si = snprintf((char *)NULL, 16, \"abcde\\n\");\n  printf(\"snprintf returns %d with NULL first argument and non-zero size\\n\", si);\n  \n \n \n\n  printf(\"/%%ld %%ld/, 336, 336\\n\");\n  snprintf(holder, sizeof holder, \"/%ld %ld/\\n\", 336, 336);\n  asprintf(&h, \"/%ld %ld/\\n\", 336, 336);\n  printf(\"/%ld %ld/\\n\", 336, 336);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%d/, 336\\n\");\n  snprintf(holder, sizeof holder, \"/%d/\\n\", 336);\n  asprintf(&h, \"/%d/\\n\", 336);\n  printf(\"/%d/\\n\", 336);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%2d/, 336\\n\");\n  snprintf(holder, sizeof holder, \"/%2d/\\n\", 336);\n  asprintf(&h, \"/%2d/\\n\", 336);\n  printf(\"/%2d/\\n\", 336);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%10d/, 336\\n\");\n  snprintf(holder, sizeof holder, \"/%10d/\\n\", 336);\n  asprintf(&h, \"/%10d/\\n\", 336);\n  printf(\"/%10d/\\n\", 336);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%-10d/, 336\\n\");\n  snprintf(holder, sizeof holder, \"/%-10d/\\n\", 336);\n  asprintf(&h, \"/%-10d/\\n\", 336);\n  printf(\"/%-10d/\\n\", 336);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n\n \n\n  printf(\"/%%f/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%f/\\n\", 1234.56);\n  asprintf(&h, \"/%f/\\n\", 1234.56);\n  printf(\"/%f/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%e/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%e/\\n\", 1234.56);\n  asprintf(&h, \"/%e/\\n\", 1234.56);\n  printf(\"/%e/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%4.2f/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%4.2f/\\n\", 1234.56);\n  asprintf(&h, \"/%4.2f/\\n\", 1234.56);\n  printf(\"/%4.2f/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%3.1f/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%3.1f/\\n\", 1234.56);\n  asprintf(&h, \"/%3.1f/\\n\", 1234.56);\n  printf(\"/%3.1f/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%10.3f/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%10.3f/\\n\", 1234.56);\n  asprintf(&h, \"/%10.3f/\\n\", 1234.56);\n  printf(\"/%10.3f/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%10.3e/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%10.3e/\\n\", 1234.56);\n  asprintf(&h, \"/%10.3e/\\n\", 1234.56);\n  printf(\"/%10.3e/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%+4.2f/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%+4.2f/\\n\", 1234.56);\n  asprintf(&h, \"/%+4.2f/\\n\", 1234.56);\n  printf(\"/%+4.2f/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%010.2f/, 1234.56\\n\");\n  snprintf(holder, sizeof holder, \"/%010.2f/\\n\", 1234.56);\n  asprintf(&h, \"/%010.2f/\\n\", 1234.56);\n  printf(\"/%010.2f/\\n\", 1234.56);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n#define BLURB \"Outstanding acting !\"\n \n\n  printf(\"/%%2s/, \\\"%s\\\"\\n\", BLURB);\n  snprintf(holder, sizeof holder, \"/%2s/\\n\", BLURB);\n  asprintf(&h, \"/%2s/\\n\", BLURB);\n  printf(\"/%2s/\\n\", BLURB);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%22s/ %s\\n\", BLURB);\n  snprintf(holder, sizeof holder, \"/%22s/\\n\", BLURB);\n  asprintf(&h, \"/%22s/\\n\", BLURB);\n  printf(\"/%22s/\\n\", BLURB);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%22.5s/ %s\\n\", BLURB);\n  snprintf(holder, sizeof holder, \"/%22.5s/\\n\", BLURB);\n  asprintf(&h, \"/%22.5s/\\n\", BLURB);\n  printf(\"/%22.5s/\\n\", BLURB);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%-22.5s/ %s\\n\", BLURB);\n  snprintf(holder, sizeof holder, \"/%-22.5s/\\n\", BLURB);\n  asprintf(&h, \"/%-22.5s/\\n\", BLURB);\n  printf(\"/%-22.5s/\\n\", BLURB);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n \n\n  printf(\"%%x %%X %%#x, 31, 31, 31\\n\");\n  snprintf(holder, sizeof holder, \"%x %X %#x\\n\", 31, 31, 31);\n  asprintf(&h, \"%x %X %#x\\n\", 31, 31, 31);\n  printf(\"%x %X %#x\\n\", 31, 31, 31);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"**%%d**%% d**%% d**, 42, 42, -42\\n\");\n  snprintf(holder, sizeof holder, \"**%d**% d**% d**\\n\", 42, 42, -42);\n  asprintf(&h, \"**%d**% d**% d**\\n\", 42, 42, -42);\n  printf(\"**%d**% d**% d**\\n\", 42, 42, -42);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n \n\n  printf(\"/%%g/, 31.4\\n\");\n  snprintf(holder, sizeof holder, \"/%g/\\n\", 31.4);\n  asprintf(&h, \"/%g/\\n\", 31.4);\n  printf(\"/%g/\\n\", 31.4);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%.6g/, 31.4\\n\");\n  snprintf(holder, sizeof holder, \"/%.6g/\\n\", 31.4);\n  asprintf(&h, \"/%.6g/\\n\", 31.4);\n  printf(\"/%.6g/\\n\", 31.4);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%.1G/, 31.4\\n\");\n  snprintf(holder, sizeof holder, \"/%.1G/\\n\", 31.4);\n  asprintf(&h, \"/%.1G/\\n\", 31.4);\n  printf(\"/%.1G/\\n\", 31.4);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%.1G/, 3100000000.4\\n\");\n  snprintf(holder, sizeof holder, \"/%.1G/\\n\", 3100000000.4);  \n  asprintf(&h, \"/%.1G/\\n\", 3100000000.4);  \n  printf(\"/%.1G/\\n\", 3100000000.4); \n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"abc%%n\\n\");\n  printf(\"abc%n\", &i); printf(\"%d\\n\", i);\n  snprintf(holder, sizeof holder, \"abc%n\", &i);\n  printf(\"%s\", holder); printf(\"%d\\n\\n\", i);\n  asprintf(&h, \"abc%n\", &i);\n  printf(\"%s\", h); printf(\"%d\\n\\n\", i);\n  \n  printf(\"%%*.*s --> 10.10\\n\");\n  snprintf(holder, sizeof holder, \"%*.*s\\n\", 10, 10, BLURB);\n  asprintf(&h, \"%*.*s\\n\", 10, 10, BLURB);\n  printf(\"%*.*s\\n\", 10, 10, BLURB);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"%%%%%%%%\\n\");\n  snprintf(holder, sizeof holder, \"%%%%\\n\");\n  asprintf(&h, \"%%%%\\n\");\n  printf(\"%%%%\\n\");\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n#define BIG \"Hello this is a too big string for the buffer\"\n \n  printf(\"<%%>, %s\\n\", BIG); \n  i = snprintf(holder, 10, \"%s\\n\", BIG);\n  i = asprintf(&h, \"%s\", BIG);\n  printf(\"<%s>\\n\", BIG);\n  printf(\"<%s>\\n\", holder);\n  printf(\"<%s>\\n\\n\", h);\n\n  printf (\"<%%p> vsnprintf\\n\");\n  i = snprintf(holder, 100, \"%p\", vsnprintf);\n  i = asprintf(&h, \"%p\", vsnprintf);\n  printf(\"<%p>\\n\", vsnprintf);\n  printf(\"<%s>\\n\", holder);  \n  printf(\"<%s>\\n\\n\", h);\n\n  printf (\"<%%lu> LONG_MAX+1\\n\");\n  i = snprintf(holder, 100, \"%lu\", (unsigned long)(LONG_MAX)+1);\n  i = asprintf(&h, \"%lu\", (unsigned long)(LONG_MAX)+1);\n  printf(\"<%lu>\\n\", (unsigned long)(LONG_MAX)+1);\n  printf(\"<%s>\\n\", holder);\n  printf(\"<%s>\\n\\n\", h);\n\n#ifdef HAVE_LONG_LONG_INT\n  printf (\"<%%llu> LLONG_MAX+1\\n\");\n  i = snprintf(holder, 100, \"%llu\", (unsigned long long)(LLONG_MAX)+1);\n  i = asprintf(&h, \"%llu\", (unsigned long long)(LLONG_MAX)+1);\n  printf(\"<%llu>\\n\", (unsigned long long)(LLONG_MAX)+1);\n  printf(\"<%s>\\n\", holder);\n  printf(\"<%s>\\n\\n\", h);\n#endif\n\n#ifdef HAVE_LONG_DOUBLE\n  printf (\"<%%6.2LE> 42.42\\n\");\n  i = snprintf(holder, 100, \"%6.2LE\", (long double)42.42);\n  i = asprintf(&h, \"%6.2LE\", (long double)42.42);\n  printf (\"<%6.2LE>\\n\", (long double)42.42);\n  printf (\"<%s>\\n\", holder);\n  printf (\"<%s>\\n\\n\", h);\n#endif\n\n#ifdef HAVE_PRINTF_A_FORMAT\n  printf (\"<%%6.2A> 42.42\\n\");\n  i = snprintf(holder, 100, \"%6.2A\", 42.42);\n  i = asprintf(&h, \"%6.2A\", 42.42);\n  printf (\"<%6.2A>\\n\", 42.42);\n  printf (\"<%s>\\n\", holder);\n  printf (\"<%s>\\n\\n\", h);\n\n  printf (\"<%%6.2LA> 42.42\\n\");\n  i = snprintf(holder, 100, \"%6.2LA\", (long double)42.42);\n  i = asprintf(&h, \"%6.2LA\", (long double)42.42);\n  printf (\"<%6.2LA>\\n\", (long double)42.42);\n  printf (\"<%s>\\n\", holder);\n  printf (\"<%s>\\n\\n\", h);\n#endif\n\n  printf (\"<%%.10240f> DBL_MAX\\n\");\n  si = snprintf(holder, 100, \"%.10240f\", DBL_MAX);\n  ai = asprintf(&h, \"%.10240f\", DBL_MAX);\n  printf (\"<%.10240f>\\n\", DBL_MAX);\n  printf (\"<%d> <%s>\\n\", si, holder);\n  printf (\"<%d> <%s>\\n\\n\", ai, h);\n\n  printf (\"<%%.10240Lf> LDBL_MAX\\n\");\n  si = snprintf(holder, 100, \"%.10240Lf\", (long double)LDBL_MAX);\n  ai = asprintf(&h, \"%.10240Lf\", (long double)LDBL_MAX);\n  printf (\"<%.10240Lf>\\n\", (long double)LDBL_MAX);\n  printf (\"<%d> <%s>\\n\", si, holder);\n  printf (\"<%d> <%s>\\n\\n\", ai, h);\n\n   \n  printf(\"/%%g/, 421.2345\\n\");\n  snprintf(holder, sizeof holder, \"/%g/\\n\", 421.2345);\n  asprintf(&h, \"/%g/\\n\", 421.2345);\n  printf(\"/%g/\\n\", 421.2345);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%g/, 4214.2345\\n\");\n  snprintf(holder, sizeof holder, \"/%g/\\n\", 4214.2345);\n  asprintf(&h, \"/%g/\\n\", 4214.2345);\n  printf(\"/%g/\\n\", 4214.2345);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%.5g/, 4214.2345\\n\");\n  snprintf(holder, sizeof holder, \"/%.5g/\\n\", 4214.2345);\n  asprintf(&h, \"/%.5g/\\n\", 4214.2345);\n  printf(\"/%.5g/\\n\", 4214.2345);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%.4g/, 4214.2345\\n\");\n  snprintf(holder, sizeof holder, \"/%.4g/\\n\", 4214.2345);\n  asprintf(&h, \"/%.4g/\\n\", 4214.2345);\n  printf(\"/%.4g/\\n\", 4214.2345);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'ld %%'ld/, 12345, 1234567\\n\");\n  snprintf(holder, sizeof holder, \"/%'ld %'ld/\\n\", 12345, 1234567);\n  asprintf(&h, \"/%'ld %'ld/\\n\", 12345, 1234567);\n  printf(\"/%'ld %'ld/\\n\", 12345, 1234567);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'ld %%'ld/, 336, 3336\\n\");\n  snprintf(holder, sizeof holder, \"/%'ld %'ld/\\n\", 336, 3336);\n  asprintf(&h, \"/%'ld %'ld/\\n\", 336, 3336);\n  printf(\"/%'ld %'ld/\\n\", 336, 3336);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'ld %%'ld/, -42786, -142786\\n\");\n  snprintf(holder, sizeof holder, \"/%'ld %'ld/\\n\", -42786, -142786);\n  asprintf(&h, \"/%'ld %'ld/\\n\", -42786, -142786);\n  printf(\"/%'ld %'ld/\\n\", -42786, -142786);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'f %%'f/, 421.2345, 421234.56789\\n\");\n  snprintf(holder, sizeof holder, \"/%'f %'f/\\n\", 421.2345, 421234.56789);\n  asprintf(&h, \"/%'f %'f/\\n\", 421.2345, 421234.56789);\n  printf(\"/%'f %'f/\\n\", 421.2345, 421234.56789);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'f %%'f/, -421.2345, -421234.56789\\n\");\n  snprintf(holder, sizeof holder, \"/%'f %'f/\\n\", -421.2345, -421234.56789);\n  asprintf(&h, \"/%'f %'f/\\n\", -421.2345, -421234.56789);\n  printf(\"/%'f %'f/\\n\", -421.2345, -421234.56789);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'g %%'g/, 421.2345, 421234.56789\\n\");\n  snprintf(holder, sizeof holder, \"/%'g %'g/\\n\", 421.2345, 421234.56789);\n  asprintf(&h, \"/%'g %'g/\\n\", 421.2345, 421234.56789);\n  printf(\"/%'g %'g/\\n\", 421.2345, 421234.56789);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  printf(\"/%%'g %%'g/, -421.2345, -421234.56789\\n\");\n  snprintf(holder, sizeof holder, \"/%'g %'g/\\n\", -421.2345, -421234.56789);\n  asprintf(&h, \"/%'g %'g/\\n\", -421.2345, -421234.56789);\n  printf(\"/%'g %'g/\\n\", -421.2345, -421234.56789);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n#endif\n\n  printf(\"/%%'g/, 4213455.8392\\n\");\n  snprintf(holder, sizeof holder, \"/%'g/\\n\", 4213455.8392);\n  asprintf(&h, \"/%'g/\\n\", 4213455.8392);\n  printf(\"/%'g/\\n\", 4213455.8392);\n  printf(\"%s\", holder);\n  printf(\"%s\\n\", h);\n\n  exit (0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}