{
  "module_name": "unicode.c",
  "hash_id": "626d2cb4b9d84c0ca59fb712e106b79fdc462cb459dc20ee9f919fca7ca586ea",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/unicode.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HANDLE_MULTIBYTE)\n\n#include <stdc.h>\n#include <wchar.h>\n#include <bashansi.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <stdio.h>\n#include <limits.h>\n\n#if HAVE_ICONV\n#  include <iconv.h>\n#endif\n\n#include <xmalloc.h>\n\n#ifndef USHORT_MAX\n#  ifdef USHRT_MAX\n#    define USHORT_MAX USHRT_MAX\n#  else\n#    define USHORT_MAX ((unsigned short) ~(unsigned short)0)\n#  endif\n#endif\n\n#if !defined (STREQ)\n#  define STREQ(a, b) ((a)[0] == (b)[0] && strcmp ((a), (b)) == 0)\n#endif  \n\n#if defined (HAVE_LOCALE_CHARSET)\nextern const char *locale_charset PARAMS((void));\n#else\nextern char *get_locale_var PARAMS((char *));\n#endif\n\nextern int locale_utf8locale;\n\nstatic int u32init = 0;\nstatic int utf8locale = 0;\n#if defined (HAVE_ICONV)\nstatic iconv_t localconv;\n#endif\n\n#ifndef HAVE_LOCALE_CHARSET\nstatic char charsetbuf[40];\n\nstatic char *\nstub_charset ()\n{\n  char *locale, *s, *t;\n\n  locale = get_locale_var (\"LC_CTYPE\");\n  if (locale == 0 || *locale == 0)\n    {\n      strcpy (charsetbuf, \"ASCII\");\n      return charsetbuf;\n    }\n  s = strrchr (locale, '.');\n  if (s)\n    {\n      strncpy (charsetbuf, s+1, sizeof (charsetbuf) - 1);\n      charsetbuf[sizeof (charsetbuf) - 1] = '\\0';\n      t = strchr (charsetbuf, '@');\n      if (t)\n\t*t = 0;\n      return charsetbuf;\n    }\n  strncpy (charsetbuf, locale, sizeof (charsetbuf) - 1);\n  charsetbuf[sizeof (charsetbuf) - 1] = '\\0';\n  return charsetbuf;\n}\n#endif\n\nvoid\nu32reset ()\n{\n#if defined (HAVE_ICONV)\n  if (u32init && localconv != (iconv_t)-1)\n    {\n      iconv_close (localconv);\n      localconv = (iconv_t)-1;\n    }\n#endif\n  u32init = 0;\n  utf8locale = 0;\n}\n\n \nint\nu32tochar (x, s)\n     unsigned long x;\n     char *s;\n{\n  int l;\n\n  l = (x <= UCHAR_MAX) ? 1 : ((x <= USHORT_MAX) ? 2 : 4);\n\n  if (x <= UCHAR_MAX)\n    s[0] = x & 0xFF;\n  else if (x <= USHORT_MAX)\t \n    {\n      s[0] = (x >> 8) & 0xFF;\n      s[1] = x & 0xFF;\n    }\n  else\n    {\n      s[0] = (x >> 24) & 0xFF;\n      s[1] = (x >> 16) & 0xFF;\n      s[2] = (x >> 8) & 0xFF;\n      s[3] = x & 0xFF;\n    }\n  s[l] = '\\0';\n  return l;  \n}\n\nint\nu32tocesc (wc, s)\n     u_bits32_t wc;\n     char *s;\n{\n  int l;\n\n  if (wc < 0x10000)\n    l = sprintf (s, \"\\\\u%04X\", wc);\n  else\n    l = sprintf (s, \"\\\\U%08X\", wc);\n  return l;\n}\n\n \nint\nu32toutf8 (wc, s)\n     u_bits32_t wc;\n     char *s;\n{\n  int l;\n\n  if (wc < 0x0080)\n    {\n      s[0] = (char)wc;\n      l = 1;\n    }\n  else if (wc < 0x0800)\n    {\n      s[0] = (wc >> 6) | 0xc0;\n      s[1] = (wc & 0x3f) | 0x80;\n      l = 2;\n    }\n  else if (wc < 0x10000)\n    {\n       \n      s[0] = (wc >> 12) | 0xe0;\n      s[1] = ((wc >> 6) & 0x3f) | 0x80;\n      s[2] = (wc & 0x3f) | 0x80;\n      l = 3;\n    }\n  else if (wc < 0x200000)\n    {\n      s[0] = (wc >> 18) | 0xf0;\n      s[1] = ((wc >> 12) & 0x3f) | 0x80;\n      s[2] = ((wc >>  6) & 0x3f) | 0x80;\n      s[3] = (wc & 0x3f) | 0x80;\n      l = 4;\n    }\n   \n  else if (wc < 0x04000000)\n    {\n      s[0] = (wc >> 24) | 0xf8;\n      s[1] = ((wc >> 18) & 0x3f) | 0x80;\n      s[2] = ((wc >> 12) & 0x3f) | 0x80;\n      s[3] = ((wc >>  6) & 0x3f) | 0x80;\n      s[4] = (wc & 0x3f) | 0x80;\n      l = 5;\n    }\n  else if (wc < 0x080000000)\n    {\n      s[0] = (wc >> 30) | 0xfc;\n      s[1] = ((wc >> 24) & 0x3f) | 0x80;\n      s[2] = ((wc >> 18) & 0x3f) | 0x80;\n      s[3] = ((wc >> 12) & 0x3f) | 0x80;\n      s[4] = ((wc >>  6) & 0x3f) | 0x80;\n      s[5] = (wc & 0x3f) | 0x80;\n      l = 6;\n    }\n  else\n    l = 0;\n\n  s[l] = '\\0';\n  return l;\n}\n\n \nint\nu32toutf16 (c, s)\n     u_bits32_t c;\n     wchar_t *s;\n{\n  int l;\n\n  l = 0;\n  if (c < 0x0d800 || (c >= 0x0e000 && c <= 0x0ffff))\n    {\n      s[0] = (wchar_t) (c & 0xFFFF);\n      l = 1;\n    }\n  else if (c >= 0x10000 && c <= 0x010ffff)\n    {\n      c -= 0x010000;\n      s[0] = (wchar_t)((c >> 10) + 0xd800);\n      s[1] = (wchar_t)((c & 0x3ff) + 0xdc00);\n      l = 2;\n    }\n  s[l] = 0;\n  return l;\n}\n\n \nint\nu32cconv (c, s)\n     unsigned long c;\n     char *s;\n{\n  wchar_t wc;\n  wchar_t ws[3];\n  int n;\n#if HAVE_ICONV\n  const char *charset;\n  char obuf[25], *optr;\n  size_t obytesleft;\n  const char *iptr;\n  size_t sn;\n#endif\n\n#if __STDC_ISO_10646__\n  wc = c;\n  if (sizeof (wchar_t) == 4 && c <= 0x7fffffff)\n    n = wctomb (s, wc);\n  else if (sizeof (wchar_t) == 2 && c <= 0x10ffff && u32toutf16 (c, ws))\n    n = wcstombs (s, ws, MB_LEN_MAX);\n  else\n    n = -1;\n  if (n != -1)\n    return n;\n#endif\n\n#if HAVE_ICONV\n   \n  if (u32init == 0)\n    {\n      utf8locale = locale_utf8locale;\n      localconv = (iconv_t)-1;\n      if (utf8locale == 0)\n\t{\n#if HAVE_LOCALE_CHARSET\n\t  charset = locale_charset ();\n#elif HAVE_NL_LANGINFO\n\t  charset = nl_langinfo (CODESET);\n#else\n\t  charset = stub_charset ();\n#endif\n\t  localconv = iconv_open (charset, \"UTF-8\");\n\t  if (localconv == (iconv_t)-1)\n\t     \n\t    localconv = iconv_open (\"ASCII\", \"UTF-8\");\n\t}\n      u32init = 1;\n    }\n\n   \n  \n   \n  n = u32toutf8 (c, s);\n  if (utf8locale)\n    return n;\n\n   \n  if (localconv == (iconv_t)-1)\n    return n;\n    \n  optr = obuf;\n  obytesleft = sizeof (obuf);\n  iptr = s;\n  sn = n;\n\n  iconv (localconv, NULL, NULL, NULL, NULL);\n\n  if (iconv (localconv, (ICONV_CONST char **)&iptr, &sn, &optr, &obytesleft) == (size_t)-1)\n    {\n             \n      n = u32tocesc (c, s);\n      return n;\n    }\n\n  *optr = '\\0';\n\n   \n  strcpy (s, obuf);\n  return (optr - obuf);\n#endif\t \n\n  if (locale_utf8locale)\n    n = u32toutf8 (c, s);\n  else\n    n = u32tocesc (c, s);\t \n  return n;\n}\n#else\nvoid\nu32reset ()\n{\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}