{
  "module_name": "oslib.c",
  "hash_id": "58e1d7811a4f1580361f23972a1da872f51157d01f92081ed42c112c59f675ed",
  "original_prompt": "Ingested from bash-5.2.21/lib/sh/oslib.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <bashtypes.h>\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_LIMITS_H)\n#  include <limits.h>\n#endif\n\n#include <posixstat.h>\n#include <filecntl.h>\n#include <bashansi.h>\n\n#if !defined (HAVE_KILLPG)\n#  include <signal.h>\n#endif\n\n#include <stdio.h>\n#include <errno.h>\n#include <chartypes.h>\n\n#include <shell.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n \n#if !defined (HAVE_STRCHR)\nchar *\nstrchr (string, c)\n     char *string;\n     int c;\n{\n  register char *s;\n\n  for (s = string; s && *s; s++)\n    if (*s == c)\n      return (s);\n\n  return ((char *) NULL);\n}\n\nchar *\nstrrchr (string, c)\n     char *string;\n     int c;\n{\n  register char *s, *t;\n\n  for (s = string, t = (char *)NULL; s && *s; s++)\n    if (*s == c)\n      t = s;\n  return (t);\n}\n#endif  \n\n#if !defined (HAVE_DUP2) || defined (DUP2_BROKEN)\n \nint\ndup2 (fd1, fd2)\n     int fd1, fd2;\n{\n  int saved_errno, r;\n\n   \n  if (fcntl (fd1, F_GETFL, 0) == -1)\n    return (-1);\n\n  if (fd2 < 0 || fd2 >= getdtablesize ())\n    {\n      errno = EBADF;\n      return (-1);\n    }\n\n  if (fd1 == fd2)\n    return (0);\n\n  saved_errno = errno;\n\n  (void) close (fd2);\n  r = fcntl (fd1, F_DUPFD, fd2);\n\n  if (r >= 0)\n    errno = saved_errno;\n  else\n    if (errno == EINVAL)\n      errno = EBADF;\n\n   \n  SET_OPEN_ON_EXEC (fd2);\n  return (r);\n}\n#endif  \n\n \n\n#if !defined (HAVE_GETDTABLESIZE)\nint\ngetdtablesize ()\n{\n#  if defined (_POSIX_VERSION) && defined (HAVE_SYSCONF) && defined (_SC_OPEN_MAX)\n  return (sysconf(_SC_OPEN_MAX));\t \n#  else  \n#    if defined (ULIMIT_MAXFDS)\n  return (ulimit (4, 0L));\t \n#    else  \n#      if defined (NOFILE)\t \n  return (NOFILE);\n#      else  \n  return (20);\t\t\t \n#      endif  \n#    endif  \n#  endif  \n}\n#endif  \n\n#if !defined (HAVE_BCOPY)\n#  if defined (bcopy)\n#    undef bcopy\n#  endif\nvoid\nbcopy (s,d,n)\n     void *d, *s;\n     size_t n;\n{\n  FASTCOPY (s, d, n);\n}\n#endif  \n\n#if !defined (HAVE_BZERO)\n#  if defined (bzero)\n#    undef bzero\n#  endif\nvoid\nbzero (s, n)\n     void *s; \n     size_t n;\n{\n  register int i;\n  register char *r;\n\n  for (i = 0, r = s; i < n; i++)\n    *r++ = '\\0';\n}\n#endif\n\n#if !defined (HAVE_GETHOSTNAME)\n#  if defined (HAVE_UNAME)\n#    include <sys/utsname.h>\nint\ngethostname (name, namelen)\n     char *name;\n     size_t namelen;\n{\n  int i;\n  struct utsname ut;\n\n  --namelen;\n\n  uname (&ut);\n  i = strlen (ut.nodename) + 1;\n  strncpy (name, ut.nodename, i < namelen ? i : namelen);\n  name[namelen] = '\\0';\n  return (0);\n}\n#  else  \nint\ngethostname (name, namelen)\n     char *name;\n     size_t namelen;\n{\n  strncpy (name, \"unknown\", namelen);\n  name[namelen] = '\\0';\n  return 0;\n}\n#  endif  \n#endif  \n\n#if !defined (HAVE_KILLPG)\nint\nkillpg (pgrp, sig)\n     pid_t pgrp;\n     int sig;\n{\n  return (kill (-pgrp, sig));\n}\n#endif  \n\n#if !defined (HAVE_MKFIFO) && defined (PROCESS_SUBSTITUTION)\nint\nmkfifo (path, mode)\n     char *path;\n     mode_t mode;\n{\n#if defined (S_IFIFO)\n  return (mknod (path, (mode | S_IFIFO), 0));\n#else  \n  return (-1);\n#endif  \n}\n#endif  \n\n#define DEFAULT_MAXGROUPS 64\n\nint\ngetmaxgroups ()\n{\n  static int maxgroups = -1;\n\n  if (maxgroups > 0)\n    return maxgroups;\n\n#if defined (HAVE_SYSCONF) && defined (_SC_NGROUPS_MAX)\n  maxgroups = sysconf (_SC_NGROUPS_MAX);\n#else\n#  if defined (NGROUPS_MAX)\n  maxgroups = NGROUPS_MAX;\n#  else  \n#    if defined (NGROUPS)\n  maxgroups = NGROUPS;\n#    else  \n  maxgroups = DEFAULT_MAXGROUPS;\n#    endif  \n#  endif    \n#endif  \n\n  if (maxgroups <= 0)\n    maxgroups = DEFAULT_MAXGROUPS;\n\n  return maxgroups;\n}\n\nlong\ngetmaxchild ()\n{\n  static long maxchild = -1L;\n\n  if (maxchild > 0)\n    return maxchild;\n\n#if defined (HAVE_SYSCONF) && defined (_SC_CHILD_MAX)\n  maxchild = sysconf (_SC_CHILD_MAX);\n#else\n#  if defined (CHILD_MAX)\n  maxchild = CHILD_MAX;\n#  else\n#    if defined (MAXUPRC)\n  maxchild = MAXUPRC;\n#    endif  \n#  endif  \n#endif  \n\n  return (maxchild);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}