{
  "module_name": "readline.c",
  "hash_id": "1ab342224f2404e0112d86fb6d5c537cfd2b4329795b3c41cb34642a4138455d",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/readline.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include \"posixstat.h\"\n#include <fcntl.h>\n#if defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_LOCALE_H)\n#  include <locale.h>\n#endif\n\n#include <stdio.h>\n#include \"posixjmp.h\"\n#include <errno.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#if defined (__EMX__)\n#  define INCL_DOSPROCESS\n#  include <os2.h>\n#endif  \n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n#if defined (COLOR_SUPPORT)\n#  include \"parse-colors.h\"\n#endif\n\n#ifndef RL_LIBRARY_VERSION\n#  define RL_LIBRARY_VERSION \"8.1\"\n#endif\n\n#ifndef RL_READLINE_VERSION\n#  define RL_READLINE_VERSION\t0x0801\n#endif\n\n \nstatic char *readline_internal (void);\nstatic void readline_initialize_everything (void);\n\nstatic void run_startup_hooks (void);\n\nstatic void bind_arrow_keys_internal (Keymap);\nstatic void bind_arrow_keys (void);\n\nstatic void bind_bracketed_paste_prefix (void);\n\nstatic void readline_default_bindings (void);\nstatic void reset_default_bindings (void);\n\nstatic int _rl_subseq_result (int, Keymap, int, int);\nstatic int _rl_subseq_getchar (int);\n\n \n \n \n \n \n\nconst char *rl_library_version = RL_LIBRARY_VERSION;\n\nint rl_readline_version = RL_READLINE_VERSION;\n\n \nint rl_gnu_readline_p = 1;\n\n \nKeymap _rl_keymap = emacs_standard_keymap;\n\n \nint rl_editing_mode = emacs_mode;\n\n \nint rl_insert_mode = RL_IM_DEFAULT;\n\n \nint rl_dispatching;\n\n \nint _rl_last_command_was_kill = 0;\n\n \nint rl_numeric_arg = 1;\n\n \nint rl_explicit_arg = 0;\n\n \nint rl_arg_sign = 1;\n\n \nstatic int rl_initialized;\n\n#if 0\n \nstatic int running_in_emacs;\n#endif\n\n \nunsigned long rl_readline_state = RL_STATE_NONE;\n\n \nint rl_point;\n\n \nint rl_mark;\n\n \nint rl_end;\n\n \nint rl_done;\n\n \nint rl_eof_found = 0;\n\n \nrl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;\n\n \nprocenv_t _rl_top_level;\n\n \nFILE *_rl_in_stream, *_rl_out_stream;\n\n \nFILE *rl_instream = (FILE *)NULL;\nFILE *rl_outstream = (FILE *)NULL;\n\n \nint _rl_echoing_p = 0;\n\n \nchar *rl_prompt = (char *)NULL;\nint rl_visible_prompt_length = 0;\n\n \nint rl_already_prompted = 0;\n\n \nint rl_key_sequence_length = 0;\n\n \nrl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;\n\n \nrl_hook_func_t *_rl_internal_startup_hook = (rl_hook_func_t *)NULL;\n\n \nrl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;\n\n \nstatic char *the_line;\n\n \nint _rl_eof_char = CTRL ('D');\n\n \nint rl_pending_input = 0;\n\n \nconst char *rl_terminal_name = (const char *)NULL;\n\n \nint _rl_horizontal_scroll_mode = 0;\n\n \nint _rl_mark_modified_lines = 0;\n\n \nint _rl_bell_preference = AUDIBLE_BELL;\n     \n \nchar *_rl_comment_begin;\n\n \nKeymap rl_executing_keymap;\n\n \nrl_command_func_t *_rl_executing_func;\n\n \nKeymap _rl_dispatching_keymap;\n\n \nint rl_erase_empty_line = 0;\n\n \nint rl_num_chars_to_read = 0;\n\n \nchar *rl_line_buffer = (char *)NULL;\nint rl_line_buffer_len = 0;\n\n \n_rl_keyseq_cxt *_rl_kscxt = 0;\n\nint rl_executing_key;\nchar *rl_executing_keyseq = 0;\nint _rl_executing_keyseq_size = 0;\n\nstruct _rl_cmd _rl_pending_command;\nstruct _rl_cmd *_rl_command_to_execute = (struct _rl_cmd *)NULL;\n\n \nint _rl_keyseq_timeout = 500;\n\n#define RESIZE_KEYSEQ_BUFFER() \\\n  do \\\n    { \\\n      if (rl_key_sequence_length + 2 >= _rl_executing_keyseq_size) \\\n\t{ \\\n\t  _rl_executing_keyseq_size += 16; \\\n\t  rl_executing_keyseq = xrealloc (rl_executing_keyseq, _rl_executing_keyseq_size); \\\n\t} \\\n    } \\\n  while (0);\n        \n \n\n \n \n \n \n \n\n \nunsigned char _rl_parsing_conditionalized_out = 0;\n\n \nint _rl_convert_meta_chars_to_ascii = 1;\n\n \nint _rl_output_meta_chars = 0;\n\n \nint _rl_bind_stty_chars = 1;\n\n \nint _rl_revert_all_at_newline = 0;\n\n \nint _rl_echo_control_chars = 1;\n\n \nint _rl_show_mode_in_prompt = 0;\n\n \nint _rl_enable_bracketed_paste = BRACKETED_PASTE_DEFAULT;\nint _rl_enable_active_region = BRACKETED_PASTE_DEFAULT;\n\n \n \n \n \n \n\n \nint _rl_meta_flag = 0;\t \n\n \nint\nrl_set_prompt (const char *prompt)\n{\n  FREE (rl_prompt);\n  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;\n  rl_display_prompt = rl_prompt ? rl_prompt : \"\";\n\n  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);\n  return 0;\n}\n  \n \nchar *\nreadline (const char *prompt)\n{\n  char *value;\n#if 0\n  int in_callback;\n#endif\n\n   \n  if (rl_pending_input == EOF)\n    {\n      rl_clear_pending_input ();\n      return ((char *)NULL);\n    }\n\n#if 0\n   \n  if (in_callback = RL_ISSTATE (RL_STATE_CALLBACK))\n    RL_UNSETSTATE (RL_STATE_CALLBACK);\n#endif\n\n  rl_set_prompt (prompt);\n\n  rl_initialize ();\n  if (rl_prep_term_function)\n    (*rl_prep_term_function) (_rl_meta_flag);\n\n#if defined (HANDLE_SIGNALS)\n  rl_set_signals ();\n#endif\n\n  value = readline_internal ();\n  if (rl_deprep_term_function)\n    (*rl_deprep_term_function) ();\n\n#if defined (HANDLE_SIGNALS)\n  rl_clear_signals ();\n#endif\n\n#if 0\n  if (in_callback)\n    RL_SETSTATE (RL_STATE_CALLBACK);\n#endif\n\n#if HAVE_DECL_AUDIT_USER_TTY && defined (HAVE_LIBAUDIT_H) && defined (ENABLE_TTY_AUDIT_SUPPORT)\n  if (value)\n    _rl_audit_tty (value);\n#endif\n\n  return (value);\n}\n\nstatic void\nrun_startup_hooks (void)\n{\n  if (rl_startup_hook)\n    (*rl_startup_hook) ();\n\n  if (_rl_internal_startup_hook)\n    (*_rl_internal_startup_hook) ();\n}\n\n#if defined (READLINE_CALLBACKS)\n#  define STATIC_CALLBACK\n#else\n#  define STATIC_CALLBACK static\n#endif\n\nSTATIC_CALLBACK void\nreadline_internal_setup (void)\n{\n  char *nprompt;\n\n  _rl_in_stream = rl_instream;\n  _rl_out_stream = rl_outstream;\n\n   \n  if (_rl_enable_meta & RL_ISSTATE (RL_STATE_TERMPREPPED))\n    _rl_enable_meta_key ();\n\n  run_startup_hooks ();\n\n  rl_deactivate_mark ();\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    rl_vi_insertion_mode (1, 'i');\t \n  else\n#endif  \n    if (_rl_show_mode_in_prompt)\n      _rl_reset_prompt ();\n\n   \n  if (_rl_echoing_p == 0 && rl_redisplay_function == rl_redisplay)\n    {\n      if (rl_prompt && rl_already_prompted == 0)\n\t{\n\t  nprompt = _rl_strip_prompt (rl_prompt);\n\t  fprintf (_rl_out_stream, \"%s\", nprompt);\n\t  fflush (_rl_out_stream);\n\t  xfree (nprompt);\n\t}\n    }\n  else\n    {\n      if (rl_prompt && rl_already_prompted)\n\trl_on_new_line_with_prompt ();\n      else\n\trl_on_new_line ();\n      (*rl_redisplay_function) ();\n    }\n\n  if (rl_pre_input_hook)\n    (*rl_pre_input_hook) ();\n\n  RL_CHECK_SIGNALS ();\n}\n\nSTATIC_CALLBACK char *\nreadline_internal_teardown (int eof)\n{\n  char *temp;\n  HIST_ENTRY *entry;\n\n  RL_CHECK_SIGNALS ();\n\n  if (eof)\n    RL_SETSTATE (RL_STATE_EOF);\t\t \n\n   \n  entry = current_history ();\n\n   \n  if (entry && rl_undo_list)\n   {\n      temp = savestring (the_line);\n      rl_revert_line (1, 0);\n      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);\n      _rl_free_history_entry (entry);\n\n      strcpy (the_line, temp);\n      xfree (temp);\n    }\n\n  if (_rl_revert_all_at_newline)\n    _rl_revert_all_lines ();\n\n   \n  if (rl_undo_list)\n    rl_free_undo_list ();\n\n   \n  _rl_disable_meta_key ();\n\n   \n  _rl_set_insert_mode (RL_IM_INSERT, 0);\n\n  return (eof ? (char *)NULL : savestring (the_line));\n}\n\nvoid\n_rl_internal_char_cleanup (void)\n{\n  if (_rl_keep_mark_active)\n    _rl_keep_mark_active = 0;\n  else if (rl_mark_active_p ())\n    rl_deactivate_mark ();\n\n#if defined (VI_MODE)\n   \n  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)\n    rl_vi_check ();\n#endif  \n\n  if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)\n    {\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n      rl_newline (1, '\\n');\n    }\n\n  if (rl_done == 0)\n    {\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n    }\n\n   \n  if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&\n      rl_point == 0 && rl_end == 0)\n    _rl_erase_entire_line ();\n}\n\nSTATIC_CALLBACK int\n#if defined (READLINE_CALLBACKS)\nreadline_internal_char (void)\n#else\nreadline_internal_charloop (void)\n#endif\n{\n  static int lastc, eof_found;\n  int c, code, lk, r;\n\n  lastc = EOF;\n\n#if !defined (READLINE_CALLBACKS)\n  eof_found = 0;\n  while (rl_done == 0)\n    {\n#endif\n      lk = _rl_last_command_was_kill;\n\n#if defined (HAVE_POSIX_SIGSETJMP)\n      code = sigsetjmp (_rl_top_level, 0);\n#else\n      code = setjmp (_rl_top_level);\n#endif\n\n      if (code)\n\t{\n\t  (*rl_redisplay_function) ();\n\t  _rl_want_redisplay = 0;\n\n\t   \n\t  if (RL_ISSTATE (RL_STATE_TIMEOUT))\n\t    {\n\t      RL_SETSTATE (RL_STATE_DONE);\n\t      rl_done = 1;\n\t      return 1;\n\t    }\n\n\t   \n\t  if (RL_ISSTATE (RL_STATE_CALLBACK))\n\t    return (0);\n\t}\n\n      if (rl_pending_input == 0)\n\t{\n\t   \n\t  _rl_reset_argument ();\n\t  rl_executing_keyseq[rl_key_sequence_length = 0] = '\\0';\n\t}\n\n      RL_SETSTATE(RL_STATE_READCMD);\n      c = rl_read_key ();\n      RL_UNSETSTATE(RL_STATE_READCMD);\n\n       \n      if (c == READERR)\n\t{\n#if defined (READLINE_CALLBACKS)\n\t  RL_SETSTATE(RL_STATE_DONE);\n\t  return (rl_done = 1);\n#else\n\t  RL_SETSTATE(RL_STATE_EOF);\n\t  eof_found = 1;\n\t  break;\n#endif\n\t}\n\n       \n      if (c == EOF && rl_end)\n\t{\n\t  if (RL_SIG_RECEIVED ())\n\t    {\n\t      RL_CHECK_SIGNALS ();\n\t      if (rl_signal_event_hook)\n\t\t(*rl_signal_event_hook) ();\t\t \n\t    }\n\n\t   \n\t  if (RL_ISSTATE (RL_STATE_TERMPREPPED))\n\t    {\n\t      if (lastc == _rl_eof_char || lastc == EOF)\n\t\trl_end = 0;\n\t      else\n\t        c = _rl_eof_char;\n\t    }\n\t  else\n\t    c = NEWLINE;\n\t}\n\n       \n      if (((c == _rl_eof_char && lastc != c) || c == EOF) && rl_end == 0)\n\t{\n#if defined (READLINE_CALLBACKS)\n\t  RL_SETSTATE(RL_STATE_DONE);\n\t  return (rl_done = 1);\n#else\n\t  RL_SETSTATE(RL_STATE_EOF);\n\t  eof_found = 1;\n\t  break;\n#endif\n\t}\n\n      lastc = c;\n      r = _rl_dispatch ((unsigned char)c, _rl_keymap);\n      RL_CHECK_SIGNALS ();\n\n      if (_rl_command_to_execute)\n\t{\n\t  (*rl_redisplay_function) ();\n\n\t  rl_executing_keymap = _rl_command_to_execute->map;\n\t  rl_executing_key = _rl_command_to_execute->key;\n\n\t  _rl_executing_func = _rl_command_to_execute->func;\n\n\t  rl_dispatching = 1;\n\t  RL_SETSTATE(RL_STATE_DISPATCHING);\n\t  r = (*(_rl_command_to_execute->func)) (_rl_command_to_execute->count, _rl_command_to_execute->key);\n\t  _rl_command_to_execute = 0;\n\t  RL_UNSETSTATE(RL_STATE_DISPATCHING);\n\t  rl_dispatching = 0;\n\n\t  RL_CHECK_SIGNALS ();\n\t}\n\n       \n      if (rl_pending_input == 0 && lk == _rl_last_command_was_kill)\n\t_rl_last_command_was_kill = 0;\n\n      _rl_internal_char_cleanup ();\n\n#if defined (READLINE_CALLBACKS)\n      return 0;\n#else\n    }\n\n  return (eof_found);\n#endif\n}\n\n#if defined (READLINE_CALLBACKS)\nstatic int\nreadline_internal_charloop (void)\n{\n  int eof = 1;\n\n  while (rl_done == 0)\n    eof = readline_internal_char ();\n  return (eof);\n}\n#endif  \n\n \nstatic char *\nreadline_internal (void)\n{\n  readline_internal_setup ();\n  rl_eof_found = readline_internal_charloop ();\n  return (readline_internal_teardown (rl_eof_found));\n}\n\nvoid\n_rl_init_line_state (void)\n{\n  rl_point = rl_end = rl_mark = 0;\n  the_line = rl_line_buffer;\n  the_line[0] = 0;\n}\n\nvoid\n_rl_set_the_line (void)\n{\n  the_line = rl_line_buffer;\n}\n\n#if defined (READLINE_CALLBACKS)\n_rl_keyseq_cxt *\n_rl_keyseq_cxt_alloc (void)\n{\n  _rl_keyseq_cxt *cxt;\n\n  cxt = (_rl_keyseq_cxt *)xmalloc (sizeof (_rl_keyseq_cxt));\n\n  cxt->flags = cxt->subseq_arg = cxt->subseq_retval = 0;\n\n  cxt->okey = 0;\n  cxt->ocxt = _rl_kscxt;\n  cxt->childval = 42;\t\t \n\n  return cxt;\n}\n\nvoid\n_rl_keyseq_cxt_dispose (_rl_keyseq_cxt *cxt)\n{\n  xfree (cxt);\n}\n\nvoid\n_rl_keyseq_chain_dispose (void)\n{\n  _rl_keyseq_cxt *cxt;\n\n  while (_rl_kscxt)\n    {\n      cxt = _rl_kscxt;\n      _rl_kscxt = _rl_kscxt->ocxt;\n      _rl_keyseq_cxt_dispose (cxt);\n    }\n}\n#endif\n\nstatic int\n_rl_subseq_getchar (int key)\n{\n  int k;\n\n  if (key == ESC)\n    RL_SETSTATE(RL_STATE_METANEXT);\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  k = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n  if (key == ESC)\n    RL_UNSETSTATE(RL_STATE_METANEXT);\n\n  return k;\n}\n\n#if defined (READLINE_CALLBACKS)\nint\n_rl_dispatch_callback (_rl_keyseq_cxt *cxt)\n{\n  int nkey, r;\n\n   \n   \n  if ((cxt->flags & KSEQ_DISPATCHED) == 0)\n    {\n      nkey = _rl_subseq_getchar (cxt->okey);\n      if (nkey < 0)\n\t{\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n      r = _rl_dispatch_subseq (nkey, cxt->dmap, cxt->subseq_arg);\n      cxt->flags |= KSEQ_DISPATCHED;\n    }\n  else\n    r = cxt->childval;\n\n   \n  if (r != -3)\t \n    r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));\n\n  RL_CHECK_SIGNALS ();\n   \n  if (r >= 0 || (r == -1 && (cxt->flags & KSEQ_SUBSEQ) == 0))\t \n    {\n      _rl_keyseq_chain_dispose ();\n      RL_UNSETSTATE (RL_STATE_MULTIKEY);\n      return r;\n    }\n\n  if (r != -3)\t\t\t \n    _rl_kscxt = cxt->ocxt;\n  if (_rl_kscxt)\n    _rl_kscxt->childval = r;\n  if (r != -3)\n    _rl_keyseq_cxt_dispose (cxt);\n\n  return r;\n}\n#endif  \n  \n \nint\n_rl_dispatch (register int key, Keymap map)\n{\n  _rl_dispatching_keymap = map;\n  return _rl_dispatch_subseq (key, map, 0);\n}\n\nint\n_rl_dispatch_subseq (register int key, Keymap map, int got_subseq)\n{\n  int r, newkey;\n  char *macro;\n  rl_command_func_t *func;\n#if defined (READLINE_CALLBACKS)\n  _rl_keyseq_cxt *cxt;\n#endif\n\n  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)\n    {\n      if (map[ESC].type == ISKMAP)\n\t{\n\t  if (RL_ISSTATE (RL_STATE_MACRODEF))\n\t    _rl_add_macro_char (ESC);\n\t  RESIZE_KEYSEQ_BUFFER ();\n\t  rl_executing_keyseq[rl_key_sequence_length++] = ESC;\n\t  map = FUNCTION_TO_KEYMAP (map, ESC);\n\t  key = UNMETA (key);\n\t  return (_rl_dispatch (key, map));\n\t}\n      else\n\trl_ding ();\n      return 0;\n    }\n\n  if (RL_ISSTATE (RL_STATE_MACRODEF))\n    _rl_add_macro_char (key);\n\n  r = 0;\n  switch (map[key].type)\n    {\n    case ISFUNC:\n      func = map[key].function;\n      if (func)\n\t{\n\t   \n\t  if (func == rl_do_lowercase_version)\n\t     \n\t    return (_rl_dispatch (_rl_to_lower ((unsigned char)key), map));\n\n\t  rl_executing_keymap = map;\n\t  rl_executing_key = key;\n\n\t  _rl_executing_func = func;\n\n\t  RESIZE_KEYSEQ_BUFFER();\n\t  rl_executing_keyseq[rl_key_sequence_length++] = key;\n\t  rl_executing_keyseq[rl_key_sequence_length] = '\\0';\n\n\t  rl_dispatching = 1;\n\t  RL_SETSTATE(RL_STATE_DISPATCHING);\n\t  r = (*func) (rl_numeric_arg * rl_arg_sign, key);\n\t  RL_UNSETSTATE(RL_STATE_DISPATCHING);\n\t  rl_dispatching = 0;\n\n\t   \n#if defined (VI_MODE)\n\t  if (rl_pending_input == 0 && map[key].function != rl_digit_argument && map[key].function != rl_vi_arg_digit)\n#else\n\t  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)\n#endif\n\t    rl_last_func = map[key].function;\n\n\t  RL_CHECK_SIGNALS ();\n\t}\n      else if (map[ANYOTHERKEY].function)\n\t{\n\t   \n\t  if (RL_ISSTATE (RL_STATE_MACROINPUT))\n\t    _rl_prev_macro_key ();\n\t  else\n\t    _rl_unget_char  (key);\n\t  if (rl_key_sequence_length > 0)\n\t    rl_executing_keyseq[--rl_key_sequence_length] = '\\0';\n\t  return -2;\n\t}\n      else if (got_subseq)\n\t{\n\t   \n\t  if (RL_ISSTATE (RL_STATE_MACROINPUT))\n\t    _rl_prev_macro_key ();\n\t  else\n\t    _rl_unget_char (key);\n\t  if (rl_key_sequence_length > 0)\n\t    rl_executing_keyseq[--rl_key_sequence_length] = '\\0';\n\t  return -1;\n\t}\n      else\n\t{\n#if defined (READLINE_CALLBACKS)\n\t  RL_UNSETSTATE (RL_STATE_MULTIKEY);\n\t  _rl_keyseq_chain_dispose ();\n#endif\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n      break;\n\n    case ISKMAP:\n      if (map[key].function != 0)\n\t{\n#if defined (VI_MODE)\n\t   \n\t   \n\t  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap &&\n\t      (RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n              _rl_pushed_input_available () == 0 &&\n\t      _rl_input_queued ((_rl_keyseq_timeout > 0) ? _rl_keyseq_timeout*1000 : 0) == 0)\n\t    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));\n\t   \n\t  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap &&\n\t      (RL_ISSTATE (RL_STATE_INPUTPENDING) == 0) &&\n\t      (RL_ISSTATE (RL_STATE_MACROINPUT) && _rl_peek_macro_key () == 0) &&\n\t      _rl_pushed_input_available () == 0 &&\n\t      _rl_input_queued ((_rl_keyseq_timeout > 0) ? _rl_keyseq_timeout*1000 : 0) == 0)\n\t    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));\t      \n#endif\n\n\t  RESIZE_KEYSEQ_BUFFER ();\n\t  rl_executing_keyseq[rl_key_sequence_length++] = key;\n\t  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);\n\n\t   \n#if defined (READLINE_CALLBACKS)\n#  if defined (VI_MODE)\n\t   \n\t  if (_rl_vi_redoing && RL_ISSTATE (RL_STATE_CALLBACK) &&\n\t      map[ANYOTHERKEY].function != 0)\n\t    return (_rl_subseq_result (-2, map, key, got_subseq));\n#  endif\n\t  if (RL_ISSTATE (RL_STATE_CALLBACK))\n\t    {\n\t       \n\t      r = RL_ISSTATE (RL_STATE_MULTIKEY) ? -3 : 0;\n\t      cxt = _rl_keyseq_cxt_alloc ();\n\n\t      if (got_subseq)\n\t\tcxt->flags |= KSEQ_SUBSEQ;\n\t      cxt->okey = key;\n\t      cxt->oldmap = map;\n\t      cxt->dmap = _rl_dispatching_keymap;\n\t      cxt->subseq_arg = got_subseq || cxt->dmap[ANYOTHERKEY].function;\n\n\t      RL_SETSTATE (RL_STATE_MULTIKEY);\n\t      _rl_kscxt = cxt;\n\n\t      return r;\t\t \n\t    }\n#endif\n\n\t   \n\t   \n\t  if (_rl_keyseq_timeout > 0 &&\n\t  \t(RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n\t  \t_rl_pushed_input_available () == 0 &&\n\t\t_rl_dispatching_keymap[ANYOTHERKEY].function &&\n\t\t_rl_input_queued (_rl_keyseq_timeout*1000) == 0)\n\t    {\n\t      if (rl_key_sequence_length > 0)\n\t\trl_executing_keyseq[--rl_key_sequence_length] = '\\0';\n\t      return (_rl_subseq_result (-2, map, key, got_subseq));\n\t    }\n\n\t  newkey = _rl_subseq_getchar (key);\n\t  if (newkey < 0)\n\t    {\n\t      _rl_abort_internal ();\n\t      return -1;\n\t    }\n\n\t  r = _rl_dispatch_subseq (newkey, _rl_dispatching_keymap, got_subseq || map[ANYOTHERKEY].function);\n\t  return _rl_subseq_result (r, map, key, got_subseq);\n\t}\n      else\n\t{\n\t  _rl_abort_internal ();\t \n\t  return -1;\n\t}\n      break;\n\n    case ISMACR:\n      if (map[key].function != 0)\n\t{\n\t  rl_executing_keyseq[rl_key_sequence_length] = '\\0';\n\t  macro = savestring ((char *)map[key].function);\n\t  _rl_with_macro_input (macro);\n\t  return 0;\n\t}\n      break;\n    }\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&\n      key != ANYOTHERKEY &&\n      _rl_dispatching_keymap == vi_movement_keymap &&\n      _rl_vi_textmod_command (key))\n    _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);\n#endif\n\n  return (r);\n}\n\nstatic int\n_rl_subseq_result (int r, Keymap map, int key, int got_subseq)\n{\n  Keymap m;\n  int type, nt;\n  rl_command_func_t *func, *nf;\n\n  if (r == -2)\n     \n    {\n      m = _rl_dispatching_keymap;\n      type = m[ANYOTHERKEY].type;\n      func = m[ANYOTHERKEY].function;\n      if (type == ISFUNC && func == rl_do_lowercase_version)\n\tr = _rl_dispatch (_rl_to_lower ((unsigned char)key), map);\n      else if (type == ISFUNC)\n\t{\n\t   \n\t  nt = m[key].type;\n\t  nf = m[key].function;\n\n\t  m[key].type = type;\n\t  m[key].function = func;\n\t   \n\t  _rl_dispatching_keymap = map;\t\t \n\t  r = _rl_dispatch_subseq (key, m, 0);\n\t  m[key].type = nt;\n\t  m[key].function = nf;\n\t}\n      else\n\t \n\tr = _rl_dispatch (ANYOTHERKEY, m);\n    }\n  else if (r < 0 && map[ANYOTHERKEY].function)\n    {\n       \n      if (RL_ISSTATE (RL_STATE_MACROINPUT))\n\t_rl_prev_macro_key ();\n      else\n\t_rl_unget_char (key);\n      if (rl_key_sequence_length > 0)\n\trl_executing_keyseq[--rl_key_sequence_length] = '\\0';\n      _rl_dispatching_keymap = map;\n      return -2;\n    }\n  else if (r < 0 && got_subseq)\t\t \n    {\n       \n      if (RL_ISSTATE (RL_STATE_MACROINPUT))\n\t_rl_prev_macro_key ();\n      else\n\t_rl_unget_char (key);\n      if (rl_key_sequence_length > 0)\n\trl_executing_keyseq[--rl_key_sequence_length] = '\\0';\n      _rl_dispatching_keymap = map;\n      return -1;\n    }\n\n  return r;\n}\n\n \n \n \n \n \n\n \nint\nrl_initialize (void)\n{\n   \n  _rl_timeout_init ();\n\n   \n  if (rl_initialized == 0)\n    {\n      RL_SETSTATE(RL_STATE_INITIALIZING);\n      readline_initialize_everything ();\n      RL_UNSETSTATE(RL_STATE_INITIALIZING);\n      rl_initialized++;\n      RL_SETSTATE(RL_STATE_INITIALIZED);\n    }\n  else\n    _rl_reset_locale ();\t \n\n   \n  _rl_init_line_state ();\n\n   \n  rl_done = 0;\n  RL_UNSETSTATE(RL_STATE_DONE|RL_STATE_TIMEOUT|RL_STATE_EOF);\n\n   \n  _rl_start_using_history ();\n\n   \n  rl_reset_line_state ();\n\n   \n  rl_last_func = (rl_command_func_t *)NULL;\n\n   \n  _rl_parsing_conditionalized_out = 0;\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    _rl_vi_initialize_line ();\n#endif\n\n   \n  _rl_set_insert_mode (RL_IM_DEFAULT, 1);\n\n  return 0;\n}\n\n#if 0\n#if defined (__EMX__)\nstatic void\n_emx_build_environ (void)\n{\n  TIB *tibp;\n  PIB *pibp;\n  char *t, **tp;\n  int c;\n\n  DosGetInfoBlocks (&tibp, &pibp);\n  t = pibp->pib_pchenv;\n  for (c = 1; *t; c++)\n    t += strlen (t) + 1;\n  tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));\n  t = pibp->pib_pchenv;\n  while (*t)\n    {\n      *tp++ = t;\n      t += strlen (t) + 1;\n    }\n  *tp = 0;\n}\n#endif  \n#endif\n\n \nstatic void\nreadline_initialize_everything (void)\n{\n#if 0\n#if defined (__EMX__)\n  if (environ == 0)\n    _emx_build_environ ();\n#endif\n#endif\n\n#if 0\n   \n  running_in_emacs = sh_get_env_value (\"EMACS\") != (char *)0;\n#endif\n\n   \n  if (!rl_instream)\n    rl_instream = stdin;\n\n  if (!rl_outstream)\n    rl_outstream = stdout;\n\n   \n  _rl_in_stream = rl_instream;\n  _rl_out_stream = rl_outstream;\n\n   \n  if (rl_line_buffer == 0)\n    rl_line_buffer = (char *)xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);\n\n   \n  if (rl_terminal_name == 0)\n    rl_terminal_name = sh_get_env_value (\"TERM\");\n  _rl_init_terminal_io (rl_terminal_name);\n\n   \n  readline_default_bindings ();\n\n   \n  rl_initialize_funmap ();\n\n   \n  _rl_init_eightbit ();\n      \n   \n  rl_read_init_file ((char *)NULL);\n\n   \n  if (_rl_horizontal_scroll_mode && _rl_term_autowrap)\n    {\n      _rl_screenwidth--;\n      _rl_screenchars -= _rl_screenheight;\n    }\n\n   \n  rl_set_keymap_from_edit_mode ();\n\n   \n  bind_arrow_keys ();\n\n   \n  bind_bracketed_paste_prefix ();\n\n   \n  if (rl_completer_word_break_characters == 0)\n    rl_completer_word_break_characters = rl_basic_word_break_characters;\n\n#if defined (COLOR_SUPPORT)\n  if (_rl_colored_stats || _rl_colored_completion_prefix)\n    _rl_parse_colors ();\n#endif\n\n  rl_executing_keyseq = malloc (_rl_executing_keyseq_size = 16);\n  if (rl_executing_keyseq)\n    rl_executing_keyseq[rl_key_sequence_length = 0] = '\\0';\n}\n\n \nstatic void\nreadline_default_bindings (void)\n{\n  if (_rl_bind_stty_chars)\n    rl_tty_set_default_bindings (_rl_keymap);\n}\n\n \nstatic void\nreset_default_bindings (void)\n{\n  if (_rl_bind_stty_chars)\n    {\n      rl_tty_unset_default_bindings (_rl_keymap);\n      rl_tty_set_default_bindings (_rl_keymap);\n    }\n}\n\n \nstatic void\nbind_arrow_keys_internal (Keymap map)\n{\n  Keymap xkeymap;\n\n  xkeymap = _rl_keymap;\n  _rl_keymap = map;\n\n#if defined (__MSDOS__)\n  rl_bind_keyseq_if_unbound (\"\\033[0A\", rl_get_previous_history);\n  rl_bind_keyseq_if_unbound (\"\\033[0B\", rl_backward_char);\n  rl_bind_keyseq_if_unbound (\"\\033[0C\", rl_forward_char);\n  rl_bind_keyseq_if_unbound (\"\\033[0D\", rl_get_next_history);\n#endif\n\n  rl_bind_keyseq_if_unbound (\"\\033[A\", rl_get_previous_history);\n  rl_bind_keyseq_if_unbound (\"\\033[B\", rl_get_next_history);\n  rl_bind_keyseq_if_unbound (\"\\033[C\", rl_forward_char);\n  rl_bind_keyseq_if_unbound (\"\\033[D\", rl_backward_char);\n  rl_bind_keyseq_if_unbound (\"\\033[H\", rl_beg_of_line);\n  rl_bind_keyseq_if_unbound (\"\\033[F\", rl_end_of_line);\n\n  rl_bind_keyseq_if_unbound (\"\\033OA\", rl_get_previous_history);\n  rl_bind_keyseq_if_unbound (\"\\033OB\", rl_get_next_history);\n  rl_bind_keyseq_if_unbound (\"\\033OC\", rl_forward_char);\n  rl_bind_keyseq_if_unbound (\"\\033OD\", rl_backward_char);\n  rl_bind_keyseq_if_unbound (\"\\033OH\", rl_beg_of_line);\n  rl_bind_keyseq_if_unbound (\"\\033OF\", rl_end_of_line);\n\n   \n  rl_bind_keyseq_if_unbound (\"\\033[1;5C\", rl_forward_word);\n  rl_bind_keyseq_if_unbound (\"\\033[1;5D\", rl_backward_word);\n  rl_bind_keyseq_if_unbound (\"\\033[3;5~\", rl_kill_word);\n\n   \n  rl_bind_keyseq_if_unbound (\"\\033[1;3C\", rl_forward_word);\n  rl_bind_keyseq_if_unbound (\"\\033[1;3D\", rl_backward_word);\n\n#if defined (__MINGW32__)\n  rl_bind_keyseq_if_unbound (\"\\340H\", rl_get_previous_history);\n  rl_bind_keyseq_if_unbound (\"\\340P\", rl_get_next_history);\n  rl_bind_keyseq_if_unbound (\"\\340M\", rl_forward_char);\n  rl_bind_keyseq_if_unbound (\"\\340K\", rl_backward_char);\n  rl_bind_keyseq_if_unbound (\"\\340G\", rl_beg_of_line);\n  rl_bind_keyseq_if_unbound (\"\\340O\", rl_end_of_line);\n  rl_bind_keyseq_if_unbound (\"\\340S\", rl_delete);\n  rl_bind_keyseq_if_unbound (\"\\340R\", rl_overwrite_mode);\n\n   \n  rl_bind_keyseq_if_unbound (\"\\\\000H\", rl_get_previous_history);\n  rl_bind_keyseq_if_unbound (\"\\\\000P\", rl_get_next_history);\n  rl_bind_keyseq_if_unbound (\"\\\\000M\", rl_forward_char);\n  rl_bind_keyseq_if_unbound (\"\\\\000K\", rl_backward_char);\n  rl_bind_keyseq_if_unbound (\"\\\\000G\", rl_beg_of_line);\n  rl_bind_keyseq_if_unbound (\"\\\\000O\", rl_end_of_line);\n  rl_bind_keyseq_if_unbound (\"\\\\000S\", rl_delete);\n  rl_bind_keyseq_if_unbound (\"\\\\000R\", rl_overwrite_mode);\n#endif\n\n  _rl_keymap = xkeymap;\n}\n\n \nstatic void\nbind_arrow_keys (void)\n{\n  bind_arrow_keys_internal (emacs_standard_keymap);\n\n#if defined (VI_MODE)\n  bind_arrow_keys_internal (vi_movement_keymap);\n   \n  if (vi_movement_keymap[ESC].type == ISKMAP)\n    rl_bind_keyseq_in_map (\"\\033\", (rl_command_func_t *)NULL, vi_movement_keymap);\n  bind_arrow_keys_internal (vi_insertion_keymap);\n#endif\n}\n\nstatic void\nbind_bracketed_paste_prefix (void)\n{\n  Keymap xkeymap;\n\n  xkeymap = _rl_keymap;\n\n  _rl_keymap = emacs_standard_keymap;\n  rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_bracketed_paste_begin);\n\n#if defined (VI_MODE)\n  _rl_keymap = vi_insertion_keymap;\n  rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_bracketed_paste_begin);\n   \n#endif\n\n  _rl_keymap = xkeymap;\n}\n  \n \n \n \n \n \n\nint\nrl_save_state (struct readline_state *sp)\n{\n  if (sp == 0)\n    return -1;\n\n  sp->point = rl_point;\n  sp->end = rl_end;\n  sp->mark = rl_mark;\n  sp->buffer = rl_line_buffer;\n  sp->buflen = rl_line_buffer_len;\n  sp->ul = rl_undo_list;\n  sp->prompt = rl_prompt;\n\n  sp->rlstate = rl_readline_state;\n  sp->done = rl_done;\n  sp->kmap = _rl_keymap;\n\n  sp->lastfunc = rl_last_func;\n  sp->insmode = rl_insert_mode;\n  sp->edmode = rl_editing_mode;\n  sp->kseq = rl_executing_keyseq;\n  sp->kseqlen = rl_key_sequence_length;\n  sp->inf = rl_instream;\n  sp->outf = rl_outstream;\n  sp->pendingin = rl_pending_input;\n  sp->macro = rl_executing_macro;\n\n  sp->catchsigs = rl_catch_signals;\n  sp->catchsigwinch = rl_catch_sigwinch;\n\n  sp->entryfunc = rl_completion_entry_function;\n  sp->menuentryfunc = rl_menu_completion_entry_function;\n  sp->ignorefunc = rl_ignore_some_completions_function;\n  sp->attemptfunc = rl_attempted_completion_function;\n  sp->wordbreakchars = rl_completer_word_break_characters;\n\n  return (0);\n}\n\nint\nrl_restore_state (struct readline_state *sp)\n{\n  if (sp == 0)\n    return -1;\n\n  rl_point = sp->point;\n  rl_end = sp->end;\n  rl_mark = sp->mark;\n  the_line = rl_line_buffer = sp->buffer;\n  rl_line_buffer_len = sp->buflen;\n  rl_undo_list = sp->ul;\n  rl_prompt = sp->prompt;\n\n  rl_readline_state = sp->rlstate;\n  rl_done = sp->done;\n  _rl_keymap = sp->kmap;\n\n  rl_last_func = sp->lastfunc;\n  rl_insert_mode = sp->insmode;\n  rl_editing_mode = sp->edmode;\n  rl_executing_keyseq = sp->kseq;\n  rl_key_sequence_length = sp->kseqlen;\n  rl_instream = sp->inf;\n  rl_outstream = sp->outf;\n  rl_pending_input = sp->pendingin;\n  rl_executing_macro = sp->macro;\n\n  rl_catch_signals = sp->catchsigs;\n  rl_catch_sigwinch = sp->catchsigwinch;\n\n  rl_completion_entry_function = sp->entryfunc;\n  rl_menu_completion_entry_function = sp->menuentryfunc;\n  rl_ignore_some_completions_function = sp->ignorefunc;\n  rl_attempted_completion_function = sp->attemptfunc;\n  rl_completer_word_break_characters = sp->wordbreakchars;\n\n  rl_deactivate_mark ();\n\n  return (0);\n}\n\n \n\nvoid\n_rl_init_executing_keyseq (void)\n{\n  rl_executing_keyseq[rl_key_sequence_length = 0] = '\\0';\n}\n\nvoid\n_rl_term_executing_keyseq (void)\n{\n  rl_executing_keyseq[rl_key_sequence_length] = '\\0';\n}\n\nvoid\n_rl_end_executing_keyseq (void)\n{\n  if (rl_key_sequence_length > 0)\n    rl_executing_keyseq[--rl_key_sequence_length] = '\\0';\n}\n\nvoid\n_rl_add_executing_keyseq (int key)\n{\n  RESIZE_KEYSEQ_BUFFER ();\n rl_executing_keyseq[rl_key_sequence_length++] = key;\n}\n\n \nvoid\n_rl_del_executing_keyseq (void)\n{\n  if (rl_key_sequence_length > 0)\n    rl_key_sequence_length--;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}