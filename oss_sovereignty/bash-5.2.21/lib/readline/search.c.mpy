{
  "module_name": "search.c",
  "hash_id": "35b81f397de3467eeb35a1df2a7a504df7ac847a40642ea2b06680280b0a55db",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/search.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif\n\n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#include \"readline.h\"\n#include \"history.h\"\n#include \"histlib.h\"\n\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n#ifdef abs\n#  undef abs\n#endif\n#define abs(x)\t\t(((x) >= 0) ? (x) : -(x))\n\n_rl_search_cxt *_rl_nscxt = 0;\n\nstatic char *noninc_search_string = (char *) NULL;\nstatic int noninc_history_pos;\n\nstatic char *prev_line_found = (char *) NULL;\n\nstatic int _rl_history_search_len;\n  int _rl_history_search_pos;\nstatic int _rl_history_search_flags;\n\nstatic char *history_search_string;\nstatic int history_string_size;\n\nstatic void make_history_line_current (HIST_ENTRY *);\nstatic int noninc_search_from_pos (char *, int, int, int, int *);\nstatic int noninc_dosearch (char *, int, int);\nstatic int noninc_search (int, int);\nstatic int rl_history_search_internal (int, int);\nstatic void rl_history_search_reinit (int);\n\nstatic _rl_search_cxt *_rl_nsearch_init (int, int);\nstatic void _rl_nsearch_abort (_rl_search_cxt *);\nstatic int _rl_nsearch_dispatch (_rl_search_cxt *, int);\n\n \nstatic void\nmake_history_line_current (HIST_ENTRY *entry)\n{\n  UNDO_LIST *xlist;\n\n  xlist = _rl_saved_line_for_history ? (UNDO_LIST *)_rl_saved_line_for_history->data : 0;\n   \n  if (rl_undo_list && rl_undo_list != (UNDO_LIST *)entry->data && rl_undo_list != xlist)\n    rl_free_undo_list ();\n\n   \n  _rl_replace_text (entry->line, 0, rl_end);\n  _rl_fix_point (1);\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n     \n    rl_free_undo_list ();\n#endif\n\n   \n  if (_rl_saved_line_for_history)\n    _rl_free_history_entry (_rl_saved_line_for_history);\n  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n}\n\n \nstatic int\nnoninc_search_from_pos (char *string, int pos, int dir, int flags, int *ncp)\n{\n  int ret, old, sflags;\n  char *s;\n\n  if (pos < 0)\n    return -1;\n\n  old = where_history ();\n  if (history_set_pos (pos) == 0)\n    return -1;\n\n  RL_SETSTATE(RL_STATE_SEARCH);\n   \n  if (flags & SF_PATTERN)\n    {\n      s = string;\n      sflags = 0;\t\t \n      if (*s == '^')\n\t{\n\t  sflags |= ANCHORED_SEARCH;\n\t  s++;\n\t}\n      ret = _hs_history_patsearch (s, dir, sflags);\n    }\n  else if (*string == '^')\n    ret = history_search_prefix (string + 1, dir);\n  else\n    ret = history_search (string, dir);\n  RL_UNSETSTATE(RL_STATE_SEARCH);\n\n  if (ncp)\n    *ncp = ret;\t\t \n\n  if (ret != -1)\n    ret = where_history ();\n\n  history_set_pos (old);\n  return (ret);\n}\n\n \nstatic int\nnoninc_dosearch (char *string, int dir, int flags)\n{\n  int oldpos, pos, ind;\n  HIST_ENTRY *entry;\n\n  if (string == 0 || *string == '\\0' || noninc_history_pos < 0)\n    {\n      rl_ding ();\n      return 0;\n    }\n\n  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir, flags, &ind);\n  if (pos == -1)\n    {\n       \n      rl_maybe_unsave_line ();\n      rl_clear_message ();\n      rl_point = 0;\n      rl_ding ();\n      return 0;\n    }\n\n  noninc_history_pos = pos;\n\n  oldpos = where_history ();\n  history_set_pos (noninc_history_pos);\n  entry = current_history ();\t\t \n  \n#if defined (VI_MODE)\n  if (rl_editing_mode != vi_mode)\n#endif\n    history_set_pos (oldpos);\n\n  make_history_line_current (entry);\n\n  if (_rl_enable_active_region && ((flags & SF_PATTERN) == 0) && ind > 0 && ind < rl_end)\n    {\n      rl_point = ind;\n      rl_mark = ind + strlen (string);\n      if (rl_mark > rl_end)\n\trl_mark = rl_end;\t \n      rl_activate_mark ();\n    }\n  else\n    {  \n      rl_point = 0;\n      rl_mark = rl_end;\n    }\n\n  rl_clear_message ();\n  return 1;\n}\n\nstatic _rl_search_cxt *\n_rl_nsearch_init (int dir, int pchar)\n{\n  _rl_search_cxt *cxt;\n  char *p;\n\n  cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);\n  if (dir < 0)\n    cxt->sflags |= SF_REVERSE;\t\t \n#if defined (VI_MODE)\n  if (VI_COMMAND_MODE() && (pchar == '?' || pchar == '/'))\n    cxt->sflags |= SF_PATTERN;\n#endif\n\n  cxt->direction = dir;\n  cxt->history_pos = cxt->save_line;\n\n  rl_maybe_save_line ();\n\n   \n  rl_undo_list = 0;\n\n   \n  rl_line_buffer[0] = 0;\n  rl_end = rl_point = 0;\n\n  p = _rl_make_prompt_for_search (pchar ? pchar : ':');\n  rl_message (\"%s\", p);\n  xfree (p);\n\n  RL_SETSTATE(RL_STATE_NSEARCH);\n\n  _rl_nscxt = cxt;\n\n  return cxt;\n}\n\nint\n_rl_nsearch_cleanup (_rl_search_cxt *cxt, int r)\n{\n  _rl_scxt_dispose (cxt, 0);\n  _rl_nscxt = 0;\n\n  RL_UNSETSTATE(RL_STATE_NSEARCH);\n\n  return (r != 1);\n}\n\nstatic void\n_rl_nsearch_abort (_rl_search_cxt *cxt)\n{\n  rl_maybe_unsave_line ();\n  rl_point = cxt->save_point;\n  rl_mark = cxt->save_mark;\n  rl_restore_prompt ();\n  rl_clear_message ();\n  _rl_fix_point (1);\n\n  RL_UNSETSTATE (RL_STATE_NSEARCH);\n}\n\n \nstatic int\n_rl_nsearch_dispatch (_rl_search_cxt *cxt, int c)\n{\n  int n;\n\n  if (c < 0)\n    c = CTRL ('C');  \n\n  switch (c)\n    {\n    case CTRL('W'):\n      rl_unix_word_rubout (1, c);\n      break;\n\n    case CTRL('U'):\n      rl_unix_line_discard (1, c);\n      break;\n\n    case RETURN:\n    case NEWLINE:\n      return 0;\n\n    case CTRL('H'):\n    case RUBOUT:\n      if (rl_point == 0)\n\t{\n\t  _rl_nsearch_abort (cxt);\n\t  return -1;\n\t}\n      _rl_rubout_char (1, c);\n      break;\n\n    case CTRL('C'):\n    case CTRL('G'):\n      rl_ding ();\n      _rl_nsearch_abort (cxt);\n      return -1;\n\n    case ESC:\n       \n      if (_rl_enable_bracketed_paste && ((n = _rl_nchars_available ()) >= (BRACK_PASTE_SLEN-1)))\n\t{\n\t  if (_rl_read_bracketed_paste_prefix (c) == 1)\n\t    rl_bracketed_paste_begin (1, c);\n\t  else\n\t    {\n\t      c = rl_read_key ();\t \n\t      _rl_insert_char (1, c);\n\t    }\n        }\n      else\n        _rl_insert_char (1, c);\n      break;\n\n    default:\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_insert_text (cxt->mb);\n      else\n#endif\n\t_rl_insert_char (1, c);\n      break;\n    }\n\n  (*rl_redisplay_function) ();\n  rl_deactivate_mark ();\n  return 1;\n}\n\n \nstatic int\n_rl_nsearch_dosearch (_rl_search_cxt *cxt)\n{\n  rl_mark = cxt->save_mark;\n\n   \n  if (rl_point == 0)\n    {\n      if (noninc_search_string == 0)\n\t{\n\t  rl_ding ();\n\t  rl_restore_prompt ();\n\t  RL_UNSETSTATE (RL_STATE_NSEARCH);\n\t  return -1;\n\t}\n    }\n  else\n    {\n       \n      noninc_history_pos = cxt->save_line;\n      FREE (noninc_search_string);\n      noninc_search_string = savestring (rl_line_buffer);\n\n       \n      rl_free_undo_list ();\n    }\n\n  rl_restore_prompt ();\n  return (noninc_dosearch (noninc_search_string, cxt->direction, cxt->sflags&SF_PATTERN));\n}\n\n \nstatic int\nnoninc_search (int dir, int pchar)\n{\n  _rl_search_cxt *cxt;\n  int c, r;\n\n  cxt = _rl_nsearch_init (dir, pchar);\n\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    return (0);\n\n   \n  r = 0;\n  while (1)\n    {\n      c = _rl_search_getchar (cxt);\n\n      if (c < 0)\n\t{\n\t  _rl_nsearch_abort (cxt);\n\t  return 1;\n\t}\n\t  \n      if (c == 0)\n\tbreak;\n\n      r = _rl_nsearch_dispatch (cxt, c);\n      if (r < 0)\n        return 1;\n      else if (r == 0)\n\tbreak;        \n    }\n\n  r = _rl_nsearch_dosearch (cxt);\n  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));\n}\n\n \nint\nrl_noninc_forward_search (int count, int key)\n{\n  return noninc_search (1, (key == '?') ? '?' : 0);\n}\n\n \nint\nrl_noninc_reverse_search (int count, int key)\n{\n  return noninc_search (-1, (key == '/') ? '/' : 0);\n}\n\n \nint\nrl_noninc_forward_search_again (int count, int key)\n{\n  int r;\n\n  if (!noninc_search_string)\n    {\n      rl_ding ();\n      return (1);\n    }\n#if defined (VI_MODE)\n  if (VI_COMMAND_MODE() && key == 'N')\n    r = noninc_dosearch (noninc_search_string, 1, SF_PATTERN);\n  else\n#endif\n    r = noninc_dosearch (noninc_search_string, 1, 0);\n  return (r != 1);\n}\n\n \nint\nrl_noninc_reverse_search_again (int count, int key)\n{\n  int r;\n\n  if (!noninc_search_string)\n    {\n      rl_ding ();\n      return (1);\n    }\n#if defined (VI_MODE)\n  if (VI_COMMAND_MODE() && key == 'n')\n    r = noninc_dosearch (noninc_search_string, -1, SF_PATTERN);\n  else\n#endif\n    r = noninc_dosearch (noninc_search_string, -1, 0);\n  return (r != 1);\n}\n\n#if defined (READLINE_CALLBACKS)\nint\n_rl_nsearch_callback (_rl_search_cxt *cxt)\n{\n  int c, r;\n\n  c = _rl_search_getchar (cxt);\n  if (c <= 0)\n    {\n      if (c < 0)\n        _rl_nsearch_abort (cxt);\n      return 1;\n    }\n  r = _rl_nsearch_dispatch (cxt, c);\n  if (r != 0)\n    return 1;\n\n  r = _rl_nsearch_dosearch (cxt);\n  return ((r >= 0) ? _rl_nsearch_cleanup (cxt, r) : (r != 1));\n}\n#endif\n  \nstatic int\nrl_history_search_internal (int count, int dir)\n{\n  HIST_ENTRY *temp;\n  int ret, oldpos, newcol;\n  int had_saved_line;\n  char *t;\n\n  had_saved_line = _rl_saved_line_for_history != 0;\n  rl_maybe_save_line ();\n  temp = (HIST_ENTRY *)NULL;\n\n   \n  while (count)\n    {\n      RL_CHECK_SIGNALS ();\n      ret = noninc_search_from_pos (history_search_string, _rl_history_search_pos + dir, dir, 0, &newcol);\n      if (ret == -1)\n\tbreak;\n\n       \n      _rl_history_search_pos = ret;\n      oldpos = where_history ();\n      history_set_pos (_rl_history_search_pos);\n      temp = current_history ();\t \n      history_set_pos (oldpos);\n\n       \n      if (prev_line_found && STREQ (prev_line_found, temp->line))\n        continue;\n      prev_line_found = temp->line;\n      count--;\n    }\n\n   \n  if (temp == 0)\n    {\n       \n      rl_maybe_unsave_line ();\n      rl_ding ();\n       \n#if 0\n      if (rl_point > _rl_history_search_len)\n        {\n          rl_point = rl_end = _rl_history_search_len;\n          rl_line_buffer[rl_end] = '\\0';\n          rl_mark = 0;\n        }\n#else\n      rl_point = _rl_history_search_len;\t \n      rl_mark = rl_end;\n#endif\n      return 1;\n    }\n\n   \n  make_history_line_current (temp);\n\n   \n  if (_rl_history_search_flags & ANCHORED_SEARCH)\n    rl_point = _rl_history_search_len;\t \n  else\n    {\n#if 0\n      t = strstr (rl_line_buffer, history_search_string);\t \n      rl_point = t ? (int)(t - rl_line_buffer) + _rl_history_search_len : rl_end;\n#else\n      rl_point = (newcol >= 0) ? newcol : rl_end;\n#endif\n    }\n  rl_mark = rl_end;\n\n  return 0;\n}\n\nstatic void\nrl_history_search_reinit (int flags)\n{\n  int sind;\n\n  _rl_history_search_pos = where_history ();\n  _rl_history_search_len = rl_point;\n  _rl_history_search_flags = flags;\n\n  prev_line_found = (char *)NULL;\n  if (rl_point)\n    {\n       \n      if (_rl_history_search_len >= history_string_size - 2)\n\t{\n\t  history_string_size = _rl_history_search_len + 2;\n\t  history_search_string = (char *)xrealloc (history_search_string, history_string_size);\n\t}\n      sind = 0;\n      if (flags & ANCHORED_SEARCH)\n\thistory_search_string[sind++] = '^';\n      strncpy (history_search_string + sind, rl_line_buffer, rl_point);\n      history_search_string[rl_point + sind] = '\\0';\n    }\n  _rl_free_saved_history_line ();\t \n}\n\n \nint\nrl_history_search_forward (int count, int ignore)\n{\n  if (count == 0)\n    return (0);\n\n  if (rl_last_func != rl_history_search_forward &&\n      rl_last_func != rl_history_search_backward)\n    rl_history_search_reinit (ANCHORED_SEARCH);\n\n  if (_rl_history_search_len == 0)\n    return (rl_get_next_history (count, ignore));\n  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));\n}\n\n \nint\nrl_history_search_backward (int count, int ignore)\n{\n  if (count == 0)\n    return (0);\n\n  if (rl_last_func != rl_history_search_forward &&\n      rl_last_func != rl_history_search_backward)\n    rl_history_search_reinit (ANCHORED_SEARCH);\n\n  if (_rl_history_search_len == 0)\n    return (rl_get_previous_history (count, ignore));\n  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));\n}\n\n \nint\nrl_history_substr_search_forward (int count, int ignore)\n{\n  if (count == 0)\n    return (0);\n\n  if (rl_last_func != rl_history_substr_search_forward &&\n      rl_last_func != rl_history_substr_search_backward)\n    rl_history_search_reinit (NON_ANCHORED_SEARCH);\n\n  if (_rl_history_search_len == 0)\n    return (rl_get_next_history (count, ignore));\n  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));\n}\n\n \nint\nrl_history_substr_search_backward (int count, int ignore)\n{\n  if (count == 0)\n    return (0);\n\n  if (rl_last_func != rl_history_substr_search_forward &&\n      rl_last_func != rl_history_substr_search_backward)\n    rl_history_search_reinit (NON_ANCHORED_SEARCH);\n\n  if (_rl_history_search_len == 0)\n    return (rl_get_previous_history (count, ignore));\n  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}