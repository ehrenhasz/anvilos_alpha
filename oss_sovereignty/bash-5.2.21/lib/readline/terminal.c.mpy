{
  "module_name": "terminal.c",
  "hash_id": "1a31f7593d91fceade41b8d36ee31ae698f1f323595c7c852301eb238fc309a5",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/terminal.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <sys/types.h>\n#include \"posixstat.h\"\n#include <fcntl.h>\n#if defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_LOCALE_H)\n#  include <locale.h>\n#endif\n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n\n#ifdef __MSDOS__\n#  include <pc.h>\n#endif\n\n#include \"rltty.h\"\n#if defined (HAVE_SYS_IOCTL_H)\n#  include <sys/ioctl.h>\t\t \n#endif\n#include \"tcap.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n#if defined (__MINGW32__)\n#  include <windows.h>\n#  include <wincon.h>\n\nstatic void _win_get_screensize (int *, int *);\n#endif\n\n#if defined (__EMX__)\nstatic void _emx_get_screensize (int *, int *);\n#endif\n\n \nint rl_prefer_env_winsize = 0;\n\n \nint rl_change_environment = 1;\n\n \n \n \n \n \n\n#ifndef __MSDOS__\nstatic char *term_buffer = (char *)NULL;\nstatic char *term_string_buffer = (char *)NULL;\n#endif\n\nstatic int tcap_initialized;\n\n#if !defined (__linux__) && !defined (NCURSES_VERSION)\n#  if defined (__EMX__) || defined (NEED_EXTERN_PC)\nextern \n#  endif  \nchar PC, *BC, *UP;\n#endif  \n\n \nchar *_rl_term_clreol;\nchar *_rl_term_clrpag;\nchar *_rl_term_clrscroll;\nchar *_rl_term_cr;\nchar *_rl_term_backspace;\nchar *_rl_term_goto;\nchar *_rl_term_pc;\n\n \nint _rl_terminal_can_insert = 0;\n\n \nchar *_rl_term_im;\nchar *_rl_term_ei;\nchar *_rl_term_ic;\nchar *_rl_term_ip;\nchar *_rl_term_IC;\n\n \nchar *_rl_term_dc;\nchar *_rl_term_DC;\n\n \nchar *_rl_term_forward_char;\n\n \nchar *_rl_term_up;\n\n \nstatic char *_rl_visible_bell;\n\n \nint _rl_term_autowrap = -1;\n\n \nstatic int term_has_meta;\n\n \nstatic char *_rl_term_mm;\nstatic char *_rl_term_mo;\n\n \nstatic char *_rl_term_so;\nstatic char *_rl_term_se;\n\n \nstatic char *_rl_term_ku;\nstatic char *_rl_term_kd;\nstatic char *_rl_term_kr;\nstatic char *_rl_term_kl;\n\n \nstatic char *_rl_term_ks;\nstatic char *_rl_term_ke;\n\n \nstatic char *_rl_term_kh;\nstatic char *_rl_term_kH;\nstatic char *_rl_term_at7;\t \n\n \nstatic char *_rl_term_kD;\n\n \nstatic char *_rl_term_kI;\n\n \nstatic char *_rl_term_kP;\nstatic char *_rl_term_kN;\n\n \nstatic char *_rl_term_vs;\t \nstatic char *_rl_term_ve;\t \n\n \nchar *_rl_active_region_start_color = NULL;\nchar *_rl_active_region_end_color = NULL;\n\n \n#ifdef TGETENT_BROKEN\n#  define TGETENT_SUCCESS 0\n#else\n#  define TGETENT_SUCCESS 1\n#endif\n#ifdef TGETFLAG_BROKEN\n#  define TGETFLAG_SUCCESS 0\n#else\n#  define TGETFLAG_SUCCESS 1\n#endif\n#define TGETFLAG(cap)\t(tgetflag (cap) == TGETFLAG_SUCCESS)\n\nstatic void bind_termcap_arrow_keys (Keymap);\n\n \nint _rl_screenwidth, _rl_screenheight, _rl_screenchars;\n\n \nint _rl_enable_keypad;\n\n \nint _rl_enable_meta = 1;\n\n#if defined (__EMX__)\nstatic void\n_emx_get_screensize (int *swp, int *shp)\n{\n  int sz[2];\n\n  _scrsize (sz);\n\n  if (swp)\n    *swp = sz[0];\n  if (shp)\n    *shp = sz[1];\n}\n#endif\n\n#if defined (__MINGW32__)\nstatic void\n_win_get_screensize (int *swp, int *shp)\n{\n  HANDLE hConOut;\n  CONSOLE_SCREEN_BUFFER_INFO scr;\n\n  hConOut = GetStdHandle (STD_OUTPUT_HANDLE);\n  if (hConOut != INVALID_HANDLE_VALUE)\n    {\n      if (GetConsoleScreenBufferInfo (hConOut, &scr))\n\t{\n\t  *swp = scr.dwSize.X;\n\t  *shp = scr.srWindow.Bottom - scr.srWindow.Top + 1;\n\t}\n    }\n}\n#endif\n\n \nvoid\n_rl_get_screen_size (int tty, int ignore_env)\n{\n  char *ss;\n#if defined (TIOCGWINSZ)\n  struct winsize window_size;\n#endif  \n  int wr, wc;\n\n  wr = wc = -1;\n#if defined (TIOCGWINSZ)\n  if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)\n    {\n      wc = (int) window_size.ws_col;\n      wr = (int) window_size.ws_row;\n    }\n#endif  \n\n#if defined (__EMX__)\n  _emx_get_screensize (&wc, &wr);\n#elif defined (__MINGW32__)\n  _win_get_screensize (&wc, &wr);\n#endif\n\n  if (ignore_env || rl_prefer_env_winsize == 0)\n    {\n      _rl_screenwidth = wc;\n      _rl_screenheight = wr;\n    }\n  else\n    _rl_screenwidth = _rl_screenheight = -1;\n\n   \n  if (_rl_screenwidth <= 0)\n    {\n      if (ignore_env == 0 && (ss = sh_get_env_value (\"COLUMNS\")))\n\t_rl_screenwidth = atoi (ss);\n\n      if (_rl_screenwidth <= 0)\n        _rl_screenwidth = wc;\n\n#if defined (__DJGPP__)\n      if (_rl_screenwidth <= 0)\n\t_rl_screenwidth = ScreenCols ();\n#else\n      if (_rl_screenwidth <= 0 && term_string_buffer)\n\t_rl_screenwidth = tgetnum (\"co\");\n#endif\n    }\n\n   \n  if (_rl_screenheight <= 0)\n    {\n      if (ignore_env == 0 && (ss = sh_get_env_value (\"LINES\")))\n\t_rl_screenheight = atoi (ss);\n\n      if (_rl_screenheight <= 0)\n        _rl_screenheight = wr;\n\n#if defined (__DJGPP__)\n      if (_rl_screenheight <= 0)\n\t_rl_screenheight = ScreenRows ();\n#else\n      if (_rl_screenheight <= 0 && term_string_buffer)\n\t_rl_screenheight = tgetnum (\"li\");\n#endif\n    }\n\n   \n  if (_rl_screenwidth <= 1)\n    _rl_screenwidth = 80;\n\n  if (_rl_screenheight <= 0)\n    _rl_screenheight = 24;\n\n   \n  if (rl_change_environment)\n    sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);\n\n  if (_rl_term_autowrap == 0)\n    _rl_screenwidth--;\n\n  _rl_screenchars = _rl_screenwidth * _rl_screenheight;\n}\n\nvoid\n_rl_set_screen_size (int rows, int cols)\n{\n  if (_rl_term_autowrap == -1)\n    _rl_init_terminal_io (rl_terminal_name);\n\n  if (rows > 0)\n    _rl_screenheight = rows;\n  if (cols > 0)\n    {\n      _rl_screenwidth = cols;\n      if (_rl_term_autowrap == 0)\n\t_rl_screenwidth--;\n    }\n\n  if (rows > 0 || cols > 0)\n    _rl_screenchars = _rl_screenwidth * _rl_screenheight;\n}\n\nvoid\nrl_set_screen_size (int rows, int cols)\n{\n  _rl_set_screen_size (rows, cols);\n}\n\nvoid\nrl_get_screen_size (int *rows, int *cols)\n{\n  if (rows)\n    *rows = _rl_screenheight;\n  if (cols)\n    *cols = _rl_screenwidth;\n}\n\nvoid\nrl_reset_screen_size (void)\n{\n  _rl_get_screen_size (fileno (rl_instream), 0);\n}\n\nvoid\n_rl_sigwinch_resize_terminal (void)\n{\n  _rl_get_screen_size (fileno (rl_instream), 1);\n}\n\t\nvoid\nrl_resize_terminal (void)\n{\n  int width, height;\n\n  width = _rl_screenwidth;\n  height = _rl_screenheight;\n  _rl_get_screen_size (fileno (rl_instream), 1);\n  if (_rl_echoing_p && (width != _rl_screenwidth || height != _rl_screenheight))\n    {\n      if (CUSTOM_REDISPLAY_FUNC ())\n\trl_forced_update_display ();\n      else if (RL_ISSTATE(RL_STATE_REDISPLAYING) == 0)\n\t_rl_redisplay_after_sigwinch ();\n    }\n}\n\nstruct _tc_string {\n     const char * const tc_var;\n     char **tc_value;\n};\n\n \nstatic const struct _tc_string tc_strings[] =\n{\n  { \"@7\", &_rl_term_at7 },\n  { \"DC\", &_rl_term_DC },\n  { \"E3\", &_rl_term_clrscroll },\n  { \"IC\", &_rl_term_IC },\n  { \"ce\", &_rl_term_clreol },\n  { \"cl\", &_rl_term_clrpag },\n  { \"cr\", &_rl_term_cr },\n  { \"dc\", &_rl_term_dc },\n  { \"ei\", &_rl_term_ei },\n  { \"ic\", &_rl_term_ic },\n  { \"im\", &_rl_term_im },\n  { \"kD\", &_rl_term_kD },\t \n  { \"kH\", &_rl_term_kH },\t \n  { \"kI\", &_rl_term_kI },\t \n  { \"kN\", &_rl_term_kN },\t \n  { \"kP\", &_rl_term_kP },\t \n  { \"kd\", &_rl_term_kd },\n  { \"ke\", &_rl_term_ke },\t \n  { \"kh\", &_rl_term_kh },\t \n  { \"kl\", &_rl_term_kl },\n  { \"kr\", &_rl_term_kr },\n  { \"ks\", &_rl_term_ks },\t \n  { \"ku\", &_rl_term_ku },\n  { \"le\", &_rl_term_backspace },\n  { \"mm\", &_rl_term_mm },\n  { \"mo\", &_rl_term_mo },\n  { \"nd\", &_rl_term_forward_char },\n  { \"pc\", &_rl_term_pc },\n  { \"se\", &_rl_term_se },\n  { \"so\", &_rl_term_so },\n  { \"up\", &_rl_term_up },\n  { \"vb\", &_rl_visible_bell },\n  { \"vs\", &_rl_term_vs },\n  { \"ve\", &_rl_term_ve },\n};\n\n#define NUM_TC_STRINGS (sizeof (tc_strings) / sizeof (struct _tc_string))\n\n \nstatic void\nget_term_capabilities (char **bp)\n{\n#if !defined (__DJGPP__)\t \n  register int i;\n\n  for (i = 0; i < NUM_TC_STRINGS; i++)\n    *(tc_strings[i].tc_value) = tgetstr ((char *)tc_strings[i].tc_var, bp);\n#endif\n  tcap_initialized = 1;\n}\n\nint\n_rl_init_terminal_io (const char *terminal_name)\n{\n  const char *term;\n  char *buffer;\n  int tty, tgetent_ret, dumbterm, reset_region_colors;\n\n  term = terminal_name ? terminal_name : sh_get_env_value (\"TERM\");\n  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = _rl_term_clrscroll = (char *)NULL;\n  tty = rl_instream ? fileno (rl_instream) : 0;\n\n  if (term == 0)\n    term = \"dumb\";\n\n  dumbterm = STREQ (term, \"dumb\");\n\n  reset_region_colors = 1;\n\n#ifdef __MSDOS__\n  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;\n  _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;\n  _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;\n  _rl_term_mm = _rl_term_mo = (char *)NULL;\n  _rl_terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;\n  _rl_term_cr = \"\\r\";\n  _rl_term_backspace = (char *)NULL;\n  _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;\n  _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;\n  _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;\n  _rl_term_kN = _rl_term_kP = (char *)NULL;\n  _rl_term_so = _rl_term_se = (char *)NULL;\n#if defined(HACK_TERMCAP_MOTION)\n  _rl_term_forward_char = (char *)NULL;\n#endif\n\n  _rl_get_screen_size (tty, 0);\n#else   \n   \n  if (CUSTOM_REDISPLAY_FUNC())\n    {\n      tgetent_ret = -1;\n    }\n  else\n    {\n      if (term_string_buffer == 0)\n\tterm_string_buffer = (char *)xmalloc(2032);\n\n      if (term_buffer == 0)\n\tterm_buffer = (char *)xmalloc(4080);\n\n      buffer = term_string_buffer;\n\n      tgetent_ret = tgetent (term_buffer, term);\n    }\n\n  if (tgetent_ret != TGETENT_SUCCESS)\n    {\n      FREE (term_string_buffer);\n      FREE (term_buffer);\n      buffer = term_buffer = term_string_buffer = (char *)NULL;\n\n      _rl_term_autowrap = 0;\t \n\n       \n      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)\n\t{\n#if defined (__EMX__)\n\t  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);\n\t  _rl_screenwidth--;\n#else  \n\t  _rl_get_screen_size (tty, 0);\n#endif  \n\t}\n\n       \n      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)\n        {\n\t  _rl_screenwidth = 79;\n\t  _rl_screenheight = 24;\n        }\n\n       \n      _rl_screenchars = _rl_screenwidth * _rl_screenheight;\n      _rl_term_cr = \"\\r\";\n      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;\n      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;\n      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;\n      _rl_term_kh = _rl_term_kH = _rl_term_kI = _rl_term_kD = (char *)NULL;\n      _rl_term_ks = _rl_term_ke = _rl_term_at7 = (char *)NULL;\n      _rl_term_kN = _rl_term_kP = (char *)NULL;\n      _rl_term_mm = _rl_term_mo = (char *)NULL;\n      _rl_term_ve = _rl_term_vs = (char *)NULL;\n      _rl_term_forward_char = (char *)NULL;\n      _rl_term_so = _rl_term_se = (char *)NULL;\n      _rl_terminal_can_insert = term_has_meta = 0;\n\n       \n      _rl_enable_bracketed_paste = 0;\n\n       \n      _rl_enable_active_region = 0;\n      _rl_reset_region_color (0, NULL);\n      _rl_reset_region_color (1, NULL);\n    \n       \n      PC = '\\0';\n      BC = _rl_term_backspace = \"\\b\";\n      UP = _rl_term_up;\n\n      return 0;\n    }\n\n  get_term_capabilities (&buffer);\n\n   \n  PC = _rl_term_pc ? *_rl_term_pc : 0;\n  BC = _rl_term_backspace;\n  UP = _rl_term_up;\n\n  if (_rl_term_cr == 0)\n    _rl_term_cr = \"\\r\";\n\n  _rl_term_autowrap = TGETFLAG (\"am\") && TGETFLAG (\"xn\");\n\n   \n  if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)\n    _rl_get_screen_size (tty, 0);\n\n   \n  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);\n\n   \n  term_has_meta = TGETFLAG (\"km\");\n  if (term_has_meta == 0)\n    _rl_term_mm = _rl_term_mo = (char *)NULL;\n#endif  \n\n   \n\n  bind_termcap_arrow_keys (emacs_standard_keymap);\n\n#if defined (VI_MODE)\n  bind_termcap_arrow_keys (vi_movement_keymap);\n  bind_termcap_arrow_keys (vi_insertion_keymap);\n#endif  \n\n   \n  if (dumbterm)\n    _rl_enable_bracketed_paste = _rl_enable_active_region = 0;\n\n  if (reset_region_colors)\n    {\n      _rl_reset_region_color (0, _rl_term_so);\n      _rl_reset_region_color (1, _rl_term_se);\n    }\n\n  return 0;\n}\n\n \nstatic void\nbind_termcap_arrow_keys (Keymap map)\n{\n  Keymap xkeymap;\n\n  xkeymap = _rl_keymap;\n  _rl_keymap = map;\n\n  rl_bind_keyseq_if_unbound (_rl_term_ku, rl_get_previous_history);\n  rl_bind_keyseq_if_unbound (_rl_term_kd, rl_get_next_history);\n  rl_bind_keyseq_if_unbound (_rl_term_kr, rl_forward_char);\n  rl_bind_keyseq_if_unbound (_rl_term_kl, rl_backward_char);\n\n  rl_bind_keyseq_if_unbound (_rl_term_kh, rl_beg_of_line);\t \n  rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);\t \n\n  rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);\n  rl_bind_keyseq_if_unbound (_rl_term_kI, rl_overwrite_mode);\t \n\n  rl_bind_keyseq_if_unbound (_rl_term_kN, rl_history_search_forward);\t \n  rl_bind_keyseq_if_unbound (_rl_term_kP, rl_history_search_backward);\t \n\n  _rl_keymap = xkeymap;\n}\n\nchar *\nrl_get_termcap (const char *cap)\n{\n  register int i;\n\n  if (tcap_initialized == 0)\n    return ((char *)NULL);\n  for (i = 0; i < NUM_TC_STRINGS; i++)\n    {\n      if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)\n        return *(tc_strings[i].tc_value);\n    }\n  return ((char *)NULL);\n}\n\n \nint\nrl_reset_terminal (const char *terminal_name)\n{\n  _rl_screenwidth = _rl_screenheight = 0;\n  _rl_init_terminal_io (terminal_name);\n  return 0;\n}\n\n \n#ifdef _MINIX\nvoid\n_rl_output_character_function (int c)\n{\n  putc (c, _rl_out_stream);\n}\n#else  \nint\n_rl_output_character_function (int c)\n{\n  return putc (c, _rl_out_stream);\n}\n#endif  \n\n \nvoid\n_rl_output_some_chars (const char *string, int count)\n{\n  fwrite (string, 1, count, _rl_out_stream);\n}\n\n \nint\n_rl_backspace (int count)\n{\n  register int i;\n\n#ifndef __MSDOS__\n  if (_rl_term_backspace)\n    for (i = 0; i < count; i++)\n      tputs (_rl_term_backspace, 1, _rl_output_character_function);\n  else\n#endif\n    for (i = 0; i < count; i++)\n      putc ('\\b', _rl_out_stream);\n  return 0;\n}\n\n \nint\nrl_crlf (void)\n{\n#if defined (NEW_TTY_DRIVER) || defined (__MINT__)\n  if (_rl_term_cr)\n    tputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif  \n  putc ('\\n', _rl_out_stream);\n  return 0;\n}\n\nvoid\n_rl_cr (void)\n{\n#if defined (__MSDOS__)\n  putc ('\\r', rl_outstream);\n#else\n  tputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif\n}\n\n \nint\nrl_ding (void)\n{\n  if (_rl_echoing_p)\n    {\n      switch (_rl_bell_preference)\n        {\n\tcase NO_BELL:\n\tdefault:\n\t  break;\n\tcase VISIBLE_BELL:\n\t  if (_rl_visible_bell)\n\t    {\n#ifdef __DJGPP__\n\t      ScreenVisualBell ();\n#else\n\t      tputs (_rl_visible_bell, 1, _rl_output_character_function);\n#endif\n\t      break;\n\t    }\n\t   \n\tcase AUDIBLE_BELL:\n\t  fprintf (stderr, \"\\007\");\n\t  fflush (stderr);\n\t  break;\n        }\n      return (0);\n    }\n  return (-1);\n}\n\n \n \n \n \n \n\nvoid\n_rl_standout_on (void)\n{\n#ifndef __MSDOS__\n  if (_rl_term_so && _rl_term_se)\n    tputs (_rl_term_so, 1, _rl_output_character_function);\n#endif\n}\n\nvoid\n_rl_standout_off (void)\n{\n#ifndef __MSDOS__\n  if (_rl_term_so && _rl_term_se)\n    tputs (_rl_term_se, 1, _rl_output_character_function);\n#endif\n}\n\n \n \n \n \n \n\n \nint\n_rl_reset_region_color (int which, const char *value)\n{\n  int len;\n\n  if (which == 0)\n    {\n      xfree (_rl_active_region_start_color);\n      if (value && *value)\n\t{\n\t  _rl_active_region_start_color = (char *)xmalloc (2 * strlen (value) + 1);\n\t  rl_translate_keyseq (value, _rl_active_region_start_color, &len);\n\t  _rl_active_region_start_color[len] = '\\0';\n\t}\n      else\n\t_rl_active_region_start_color = NULL;\n    }\n  else\n    {\n      xfree (_rl_active_region_end_color);\n      if (value && *value)\n\t{\n\t  _rl_active_region_end_color = (char *)xmalloc (2 * strlen (value) + 1);\n\t  rl_translate_keyseq (value, _rl_active_region_end_color, &len);\n\t  _rl_active_region_end_color[len] = '\\0';\n\t}\n      else\n\t_rl_active_region_end_color = NULL;\n    }\n\n  return 0;\n}\n\nvoid\n_rl_region_color_on (void)\n{\n#ifndef __MSDOS__\n  if (_rl_active_region_start_color && _rl_active_region_end_color)\n    tputs (_rl_active_region_start_color, 1, _rl_output_character_function);\n#endif\n}\n\nvoid\n_rl_region_color_off (void)\n{\n#ifndef __MSDOS__\n  if (_rl_active_region_start_color && _rl_active_region_end_color)\n    tputs (_rl_active_region_end_color, 1, _rl_output_character_function);\n#endif\n}\n\n \n \n \n \n \n\nstatic int enabled_meta = 0;\t \n\nvoid\n_rl_enable_meta_key (void)\n{\n#if !defined (__DJGPP__)\n  if (term_has_meta && _rl_term_mm)\n    {\n      tputs (_rl_term_mm, 1, _rl_output_character_function);\n      enabled_meta = 1;\n    }\n#endif\n}\n\nvoid\n_rl_disable_meta_key (void)\n{\n#if !defined (__DJGPP__)\n  if (term_has_meta && _rl_term_mo && enabled_meta)\n    {\n      tputs (_rl_term_mo, 1, _rl_output_character_function);\n      enabled_meta = 0;\n    }\n#endif\n}\n\nvoid\n_rl_control_keypad (int on)\n{\n#if !defined (__DJGPP__)\n  if (on && _rl_term_ks)\n    tputs (_rl_term_ks, 1, _rl_output_character_function);\n  else if (!on && _rl_term_ke)\n    tputs (_rl_term_ke, 1, _rl_output_character_function);\n#endif\n}\n\n \n \n \n \n \n\n \nvoid\n_rl_set_cursor (int im, int force)\n{\n#ifndef __MSDOS__\n  if (_rl_term_ve && _rl_term_vs)\n    {\n      if (force || im != rl_insert_mode)\n\t{\n\t  if (im == RL_IM_OVERWRITE)\n\t    tputs (_rl_term_vs, 1, _rl_output_character_function);\n\t  else\n\t    tputs (_rl_term_ve, 1, _rl_output_character_function);\n\t}\n    }\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}