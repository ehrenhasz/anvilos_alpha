{
  "module_name": "colors.c",
  "hash_id": "82f21f22fd311a94f90789fc945d7d9de95975ee8e44a4889b9159f9ed781707",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/colors.c",
  "human_readable_source": " \n\n \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include \"rlconf.h\"\n\n#if defined __TANDEM\n#  define _XOPEN_SOURCE_EXTENDED 1\n#  define _TANDEM_SOURCE 1\n#  include <sys/types.h>\n#  include <sys/stat.h>\n#endif\n\n#include <stdio.h>\n\n#include \"posixstat.h\"  \n#include <fcntl.h>  \n\n#ifndef S_ISDIR\n#  define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n#endif\n\n \n#if defined (HAVE_STRING_H)\n#  include <string.h>\n#else  \n#  include <strings.h>\n#endif  \n\n \n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include \"readline.h\"\n#include \"rldefs.h\"\n\n#ifdef COLOR_SUPPORT\n\n#include \"xmalloc.h\"\n#include \"colors.h\"\n\nstatic bool is_colored (enum indicator_no type);\nstatic void restore_default_color (void);\n\n#define RL_COLOR_PREFIX_EXTENSION\t\"readline-colored-completion-prefix\"\n\nCOLOR_EXT_TYPE *_rl_color_ext_list = 0;\n\n \nvoid\n_rl_put_indicator (const struct bin_str *ind)\n{\n  fwrite (ind->string, ind->len, 1, rl_outstream);\n}\n\nstatic bool\nis_colored (enum indicator_no colored_filetype)\n{\n  size_t len = _rl_color_indicator[colored_filetype].len;\n  char const *s = _rl_color_indicator[colored_filetype].string;\n  return ! (len == 0\n            || (len == 1 && strncmp (s, \"0\", 1) == 0)\n            || (len == 2 && strncmp (s, \"00\", 2) == 0));\n}\n\nstatic void\nrestore_default_color (void)\n{\n  _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n  _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n}\n\nvoid\n_rl_set_normal_color (void)\n{\n  if (is_colored (C_NORM))\n    {\n      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n      _rl_put_indicator (&_rl_color_indicator[C_NORM]);\n      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n    }\n}\n\nstatic struct bin_str *\n_rl_custom_readline_prefix (void)\n{\n  size_t len;\n  COLOR_EXT_TYPE *ext;\n\n  len = strlen (RL_COLOR_PREFIX_EXTENSION);\n  for (ext = _rl_color_ext_list; ext; ext = ext->next)\n    if (ext->ext.len == len && STREQN (ext->ext.string, RL_COLOR_PREFIX_EXTENSION, len))\n      return (&ext->seq);\n  return (NULL);\n}\n\nbool\n_rl_print_prefix_color (void)\n{\n  struct bin_str *s;\n\n   \n  s = _rl_custom_readline_prefix ();\n  if (s == 0)\n    s = &_rl_color_indicator[C_PREFIX];\n  if (s->string != NULL)\n    {\n      if (is_colored (C_NORM))\n\trestore_default_color ();\n      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n      _rl_put_indicator (s);\n      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n      return 0;\n    }\n  else\n    return 1;\n}\n  \n \nbool\n_rl_print_color_indicator (const char *f)\n{\n  enum indicator_no colored_filetype;\n  COLOR_EXT_TYPE *ext;\t \n  size_t len;\t\t \n\n  const char* name;\n  char *filename;\n  struct stat astat, linkstat;\n  mode_t mode;\n  int linkok;\t \n  int stat_ok;\n\n  name = f;\n\n   \n  filename = 0;\n  if (rl_filename_stat_hook)\n    {\n      filename = savestring (f);\n      (*rl_filename_stat_hook) (&filename);\n      name = filename;\n    }\n\n#if defined (HAVE_LSTAT)\n  stat_ok = lstat(name, &astat);\n#else\n  stat_ok = stat(name, &astat);\n#endif\n  if (stat_ok == 0)\n    {\n      mode = astat.st_mode;\n#if defined (HAVE_LSTAT)\n      if (S_ISLNK (mode))\n\t{\n\t  linkok = stat (name, &linkstat) == 0;\n\t  if (linkok && strncmp (_rl_color_indicator[C_LINK].string, \"target\", 6) == 0)\n\t    mode = linkstat.st_mode;\n\t}\n      else\n#endif\n\tlinkok = 1;\n    }\n  else\n    linkok = -1;\n\n   \n\n  if (linkok == -1 && _rl_color_indicator[C_MISSING].string != NULL)\n    colored_filetype = C_MISSING;\n  else if (linkok == 0 && _rl_color_indicator[C_ORPHAN].string != NULL)\n    colored_filetype = C_ORPHAN;\t \n  else if(stat_ok != 0)\n    {\n      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n      colored_filetype = filetype_indicator[normal]; \n    }\n  else\n    {\n      if (S_ISREG (mode))\n        {\n          colored_filetype = C_FILE;\n\n#if defined (S_ISUID)\n          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n            colored_filetype = C_SETUID;\n          else\n#endif\n#if defined (S_ISGID)\n          if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n            colored_filetype = C_SETGID;\n          else\n#endif\n          if (is_colored (C_CAP) && 0) \n            colored_filetype = C_CAP;\n          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n            colored_filetype = C_EXEC;\n          else if ((1 < astat.st_nlink) && is_colored (C_MULTIHARDLINK))\n            colored_filetype = C_MULTIHARDLINK;\n        }\n      else if (S_ISDIR (mode))\n        {\n          colored_filetype = C_DIR;\n\n#if defined (S_ISVTX)\n          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n              && is_colored (C_STICKY_OTHER_WRITABLE))\n            colored_filetype = C_STICKY_OTHER_WRITABLE;\n          else\n#endif\n          if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n            colored_filetype = C_OTHER_WRITABLE;\n#if defined (S_ISVTX)\n          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n            colored_filetype = C_STICKY;\n#endif\n        }\n#if defined (S_ISLNK)\n      else if (S_ISLNK (mode))\n        colored_filetype = C_LINK;\n#endif\n      else if (S_ISFIFO (mode))\n        colored_filetype = C_FIFO;\n#if defined (S_ISSOCK)\n      else if (S_ISSOCK (mode))\n        colored_filetype = C_SOCK;\n#endif\n#if defined (S_ISBLK)\n      else if (S_ISBLK (mode))\n        colored_filetype = C_BLK;\n#endif\n      else if (S_ISCHR (mode))\n        colored_filetype = C_CHR;\n      else\n        {\n           \n          colored_filetype = C_ORPHAN;\n        }\n    }\n\n   \n  ext = NULL;\n  if (colored_filetype == C_FILE)\n    {\n       \n      len = strlen (name);\n      name += len;\t\t \n      for (ext = _rl_color_ext_list; ext != NULL; ext = ext->next)\n        {\n          if (ext->ext.len <= len\n              && strncmp (name - ext->ext.len, ext->ext.string,\n                          ext->ext.len) == 0)\n            break;\n        }\n    }\n\n  free (filename);\t \n\n  {\n    const struct bin_str *const s\n      = ext ? &(ext->seq) : &_rl_color_indicator[colored_filetype];\n    if (s->string != NULL)\n      {\n         \n        if (is_colored (C_NORM))\n\t  restore_default_color ();\n        _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n        _rl_put_indicator (s);\n        _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n        return 0;\n      }\n    else\n      return 1;\n  }\n}\n\nvoid\n_rl_prep_non_filename_text (void)\n{\n  if (_rl_color_indicator[C_END].string != NULL)\n    _rl_put_indicator (&_rl_color_indicator[C_END]);\n  else\n    {\n      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n      _rl_put_indicator (&_rl_color_indicator[C_RESET]);\n      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n    }\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}