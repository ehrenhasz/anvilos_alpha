{
  "module_name": "histfile.c",
  "hash_id": "0a764c149e70736ca10946702efdc909811863df39aa65d094e78bd6228fb892",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/histfile.c",
  "human_readable_source": " \n\n \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (__TANDEM)\n#  define _XOPEN_SOURCE_EXTENDED 1\n#  include <unistd.h>\n#  include <floss.h>\n#endif\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n#if defined (HAVE_LIMITS_H)\n#  include <limits.h>\n#endif\n\n#include <sys/types.h>\n#if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"posixstat.h\"\n#include <fcntl.h>\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <ctype.h>\n\n#if defined (__EMX__)\n#  undef HAVE_MMAP\n#endif\n\n#ifdef HISTORY_USE_MMAP\n#  include <sys/mman.h>\n\n#  ifdef MAP_FILE\n#    define MAP_RFLAGS\t(MAP_FILE|MAP_PRIVATE)\n#    define MAP_WFLAGS\t(MAP_FILE|MAP_SHARED)\n#  else\n#    define MAP_RFLAGS\tMAP_PRIVATE\n#    define MAP_WFLAGS\tMAP_SHARED\n#  endif\n\n#  ifndef MAP_FAILED\n#    define MAP_FAILED\t((void *)-1)\n#  endif\n\n#endif  \n\n#if defined(_WIN32)\n#  define WIN32_LEAN_AND_MEAN\n#  include <windows.h>\n#endif\n\n \n#if defined (__EMX__) || defined (__CYGWIN__)\n#  ifndef O_BINARY\n#    define O_BINARY 0\n#  endif\n#else  \n#  undef O_BINARY\n#  define O_BINARY 0\n#endif  \n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#include \"history.h\"\n#include \"histlib.h\"\n\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n#if !defined (PATH_MAX)\n#  define PATH_MAX\t1024\t \n#endif\n\n \nint history_file_version = 1;\n\n \nint history_write_timestamps = 0;\n\n \nint history_multiline_entries = 0;\n\n \nint history_lines_read_from_file = 0;\n\n \nint history_lines_written_to_file = 0;\n\n \n#define HIST_TIMESTAMP_START(s)\t\t(*(s) == history_comment_char && isdigit ((unsigned char)(s)[1]) )\n\nstatic char *history_backupfile (const char *);\nstatic char *history_tempfile (const char *);\nstatic int histfile_backup (const char *, const char *);\nstatic int histfile_restore (const char *, const char *);\nstatic int history_rename (const char *, const char *);\n\n \nstatic char *\nhistory_filename (const char *filename)\n{\n  char *return_val;\n  const char *home;\n  int home_len;\n\n  return_val = filename ? savestring (filename) : (char *)NULL;\n\n  if (return_val)\n    return (return_val);\n  \n  home = sh_get_env_value (\"HOME\");\n#if defined (_WIN32)\n  if (home == 0)\n    home = sh_get_env_value (\"APPDATA\");\n#endif\n\n  if (home == 0)\n    return (NULL);\n  else\n    home_len = strlen (home);\n\n  return_val = (char *)xmalloc (2 + home_len + 8);  \n  strcpy (return_val, home);\n  return_val[home_len] = '/';\n#if defined (__MSDOS__)\n  strcpy (return_val + home_len + 1, \"_history\");\n#else\n  strcpy (return_val + home_len + 1, \".history\");\n#endif\n\n  return (return_val);\n}\n\nstatic char *\nhistory_backupfile (const char *filename)\n{\n  const char *fn;\n  char *ret, linkbuf[PATH_MAX+1];\n  size_t len;\n  ssize_t n;\n  struct stat fs;\n\n  fn = filename;  \n#if defined (HAVE_READLINK)\n   \n  if ((n = readlink (filename, linkbuf, sizeof (linkbuf) - 1)) > 0)\n    {\n      linkbuf[n] = '\\0';\n      fn = linkbuf;\n    }\n#endif\n      \n  len = strlen (fn);\n  ret = xmalloc (len + 2);\n  strcpy (ret, fn);\n  ret[len] = '-';\n  ret[len+1] = '\\0';\n  return ret;\n}\n  \nstatic char *\nhistory_tempfile (const char *filename)\n{\n  const char *fn;\n  char *ret, linkbuf[PATH_MAX+1];\n  size_t len;\n  ssize_t n;\n  struct stat fs;\n  int pid;\n\n  fn = filename;  \n#if defined (HAVE_READLINK)\n   \n  if ((n = readlink (filename, linkbuf, sizeof (linkbuf) - 1)) > 0)\n    {\n      linkbuf[n] = '\\0';\n      fn = linkbuf;\n    }\n#endif\n      \n  len = strlen (fn);\n  ret = xmalloc (len + 11);\n  strcpy (ret, fn);\n\n  pid = (int)getpid ();\n\n   \n  ret[len] = '-';\n  ret[len+1] = (pid / 10000 % 10) + '0';\n  ret[len+2] = (pid / 1000 % 10) + '0';\n  ret[len+3] = (pid / 100 % 10) + '0';\n  ret[len+4] = (pid / 10 % 10) + '0';\n  ret[len+5] = (pid % 10) + '0';\n  strcpy (ret + len + 6, \".tmp\");\n\n  return ret;\n}\n  \n \nint\nread_history (const char *filename)\n{\n  return (read_history_range (filename, 0, -1));\n}\n\n \nint\nread_history_range (const char *filename, int from, int to)\n{\n  register char *line_start, *line_end, *p;\n  char *input, *buffer, *bufend, *last_ts;\n  int file, current_line, chars_read, has_timestamps, reset_comment_char;\n  struct stat finfo;\n  size_t file_size;\n#if defined (EFBIG)\n  int overflow_errno = EFBIG;\n#elif defined (EOVERFLOW)\n  int overflow_errno = EOVERFLOW;\n#else\n  int overflow_errno = EIO;\n#endif\n\n  history_lines_read_from_file = 0;\n\n  buffer = last_ts = (char *)NULL;\n  input = history_filename (filename);\n  file = input ? open (input, O_RDONLY|O_BINARY, 0666) : -1;\n\n  if ((file < 0) || (fstat (file, &finfo) == -1))\n    goto error_and_exit;\n\n  if (S_ISREG (finfo.st_mode) == 0)\n    {\n#ifdef EFTYPE\n      errno = EFTYPE;\n#else\n      errno = EINVAL;\n#endif\n      goto error_and_exit;\n    }\n\n  file_size = (size_t)finfo.st_size;\n\n   \n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      errno = overflow_errno;\n      goto error_and_exit;\n    }\n\n  if (file_size == 0)\n    {\n      xfree (input);\n      close (file);\n      return 0;\t \n    }\n\n#ifdef HISTORY_USE_MMAP\n   \n  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);\n  if ((void *)buffer == MAP_FAILED)\n    {\n      errno = overflow_errno;\n      goto error_and_exit;\n    }\n  chars_read = file_size;\n#else\n  buffer = (char *)malloc (file_size + 1);\n  if (buffer == 0)\n    {\n      errno = overflow_errno;\n      goto error_and_exit;\n    }\n\n  chars_read = read (file, buffer, file_size);\n#endif\n  if (chars_read < 0)\n    {\n  error_and_exit:\n      if (errno != 0)\n\tchars_read = errno;\n      else\n\tchars_read = EIO;\n      if (file >= 0)\n\tclose (file);\n\n      FREE (input);\n#ifndef HISTORY_USE_MMAP\n      FREE (buffer);\n#endif\n\n      return (chars_read);\n    }\n\n  close (file);\n\n   \n  if (to < 0)\n    to = chars_read;\n\n   \n  bufend = buffer + chars_read;\n  *bufend = '\\0';\t\t \n  current_line = 0;\n\n   \n  reset_comment_char = 0;\n  if (history_comment_char == '\\0' && buffer[0] == '#' && isdigit ((unsigned char)buffer[1]))\n    {\n      history_comment_char = '#';\n      reset_comment_char = 1;\n    }\n\n  has_timestamps = HIST_TIMESTAMP_START (buffer);\n  history_multiline_entries += has_timestamps && history_write_timestamps;\n\n   \n  if (has_timestamps)\n    last_ts = buffer;\n  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)\n    if (*line_end == '\\n')\n      {\n      \tp = line_end + 1;\n      \t \n\tif (HIST_TIMESTAMP_START(p) == 0)\n\t  current_line++;\n\telse\n\t  last_ts = p;\n\tline_start = p;\n\t \n\tif (current_line >= from && has_timestamps)\n\t  {\n\t    for (line_end = p; line_end < bufend && *line_end != '\\n'; line_end++)\n\t      ;\n\t    line_start = (*line_end == '\\n') ? line_end + 1 : line_end;\n\t  }\n      }\n\n   \n  for (line_end = line_start; line_end < bufend; line_end++)\n    if (*line_end == '\\n')\n      {\n\t \n\tif (line_end > line_start && line_end[-1] == '\\r')\n\t  line_end[-1] = '\\0';\n\telse\n\t  *line_end = '\\0';\n\n\tif (*line_start)\n\t  {\n\t    if (HIST_TIMESTAMP_START(line_start) == 0)\n\t      {\n\t      \tif (last_ts == NULL && history_length > 0 && history_multiline_entries)\n\t\t  _hs_append_history_line (history_length - 1, line_start);\n\t\telse\n\t\t  add_history (line_start);\n\t\tif (last_ts)\n\t\t  {\n\t\t    add_history_time (last_ts);\n\t\t    last_ts = NULL;\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\tlast_ts = line_start;\n\t\tcurrent_line--;\n\t      }\n\t  }\n\n\tcurrent_line++;\n\n\tif (current_line >= to)\n\t  break;\n\n\tline_start = line_end + 1;\n      }\n\n  history_lines_read_from_file = current_line;\n  if (reset_comment_char)\n    history_comment_char = '\\0';\n\n  FREE (input);\n#ifndef HISTORY_USE_MMAP\n  FREE (buffer);\n#else\n  munmap (buffer, file_size);\n#endif\n\n  return (0);\n}\n\n \nstatic int\nhistory_rename (const char *old, const char *new)\n{\n#if defined (_WIN32)\n  return (MoveFileEx (old, new, MOVEFILE_REPLACE_EXISTING) == 0 ? -1 : 0);\n#else\n  return (rename (old, new));\n#endif\n}\n\n \nstatic int\nhistfile_backup (const char *filename, const char *back)\n{\n#if defined (HAVE_READLINK)\n  char linkbuf[PATH_MAX+1];\n  ssize_t n;\n\n   \n  if ((n = readlink (filename, linkbuf, sizeof (linkbuf) - 1)) > 0)\n    {\n      linkbuf[n] = '\\0';\n      return (history_rename (linkbuf, back));\n    }\n#endif\n  return (history_rename (filename, back));\n}\n\n \nstatic int\nhistfile_restore (const char *backup, const char *orig)\n{\n#if defined (HAVE_READLINK)\n  char linkbuf[PATH_MAX+1];\n  ssize_t n;\n\n   \n  if ((n = readlink (orig, linkbuf, sizeof (linkbuf) - 1)) > 0)\n    {\n      linkbuf[n] = '\\0';\n      return (history_rename (backup, linkbuf));\n    }\n#endif\n  return (history_rename (backup, orig));\n}\n\n \n\n#define SHOULD_CHOWN(finfo, nfinfo) \\\n  (finfo.st_uid != nfinfo.st_uid || finfo.st_gid != nfinfo.st_gid)\n  \n \nint\nhistory_truncate_file (const char *fname, int lines)\n{\n  char *buffer, *filename, *tempname, *bp, *bp1;\t\t \n  int file, chars_read, rv, orig_lines, exists, r;\n  struct stat finfo, nfinfo;\n  size_t file_size;\n\n  history_lines_written_to_file = 0;\n\n  buffer = (char *)NULL;\n  filename = history_filename (fname);\n  tempname = 0;\n  file = filename ? open (filename, O_RDONLY|O_BINARY, 0666) : -1;\n  rv = exists = 0;\n\n   \n  if (file == -1 || fstat (file, &finfo) == -1)\n    {\n      rv = errno;\n      if (file != -1)\n\tclose (file);\n      goto truncate_exit;\n    }\n  exists = 1;\n\n  nfinfo.st_uid = finfo.st_uid;\n  nfinfo.st_gid = finfo.st_gid;\n\n  if (S_ISREG (finfo.st_mode) == 0)\n    {\n      close (file);\n#ifdef EFTYPE\n      rv = EFTYPE;\n#else\n      rv = EINVAL;\n#endif\n      goto truncate_exit;\n    }\n\n  file_size = (size_t)finfo.st_size;\n\n   \n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      close (file);\n#if defined (EFBIG)\n      rv = errno = EFBIG;\n#elif defined (EOVERFLOW)\n      rv = errno = EOVERFLOW;\n#else\n      rv = errno = EINVAL;\n#endif\n      goto truncate_exit;\n    }\n\n  buffer = (char *)malloc (file_size + 1);\n  if (buffer == 0)\n    {\n      rv = errno;\n      close (file);\n      goto truncate_exit;\n    }\n\n  chars_read = read (file, buffer, file_size);\n  close (file);\n\n  if (chars_read <= 0)\n    {\n      rv = (chars_read < 0) ? errno : 0;\n      goto truncate_exit;\n    }\n\n  orig_lines = lines;\n   \n  for (bp1 = bp = buffer + chars_read - 1; lines && bp > buffer; bp--)\n    {\n      if (*bp == '\\n' && HIST_TIMESTAMP_START(bp1) == 0)\n\tlines--;\n      bp1 = bp;\n    }\n\n   \n  for ( ; bp > buffer; bp--)\n    {\n      if (*bp == '\\n' && HIST_TIMESTAMP_START(bp1) == 0)\n        {\n\t  bp++;\n\t  break;\n        }\n      bp1 = bp;\n    }\n\n   \n  if (bp <= buffer)\n    {\n      rv = 0;\n       \n      history_lines_written_to_file = orig_lines - lines;\n      goto truncate_exit;\n    }\n\n  tempname = history_tempfile (filename);\n\n  if ((file = open (tempname, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0600)) != -1)\n    {\n      if (write (file, bp, chars_read - (bp - buffer)) < 0)\n\trv = errno;\n\n      if (fstat (file, &nfinfo) < 0 && rv == 0)\n\trv = errno;\n\n      if (close (file) < 0 && rv == 0)\n\trv = errno;\n    }\n  else\n    rv = errno;\n\n truncate_exit:\n  FREE (buffer);\n\n  history_lines_written_to_file = orig_lines - lines;\n\n  if (rv == 0 && filename && tempname)\n    rv = histfile_restore (tempname, filename);\n\n  if (rv != 0)\n    {\n      rv = errno;\n      if (tempname)\n\tunlink (tempname);\n      history_lines_written_to_file = 0;\n    }\n\n#if defined (HAVE_CHOWN)\n   \n  if (rv == 0 && exists && SHOULD_CHOWN (finfo, nfinfo))\n    r = chown (filename, finfo.st_uid, finfo.st_gid);\n#endif\n\n  xfree (filename);\n  FREE (tempname);\n\n  return rv;\n}\n\n \nstatic int\nhistory_do_write (const char *filename, int nelements, int overwrite)\n{\n  register int i;\n  char *output, *tempname, *histname;\n  int file, mode, rv, exists;\n  struct stat finfo, nfinfo;\n#ifdef HISTORY_USE_MMAP\n  size_t cursize;\n\n  history_lines_written_to_file = 0;\n\n  mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;\n#else\n  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;\n#endif\n  histname = history_filename (filename);\n  exists = histname ? (stat (histname, &finfo) == 0) : 0;\n\n  tempname = (overwrite && exists && S_ISREG (finfo.st_mode)) ? history_tempfile (histname) : 0;\n  output = tempname ? tempname : histname;\n\n  file = output ? open (output, mode, 0600) : -1;\n  rv = 0;\n\n  if (file == -1)\n    {\n      rv = errno;\n      FREE (histname);\n      FREE (tempname);\n      return (rv);\n    }\n\n#ifdef HISTORY_USE_MMAP\n  cursize = overwrite ? 0 : lseek (file, 0, SEEK_END);\n#endif\n\n  if (nelements > history_length)\n    nelements = history_length;\n\n   \n  {\n    HIST_ENTRY **the_history;\t \n    register int j;\n    int buffer_size;\n    char *buffer;\n\n    the_history = history_list ();\n     \n    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)\n      {\n\tif (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])\n\t  buffer_size += strlen (the_history[i]->timestamp) + 1;\n\tbuffer_size += strlen (the_history[i]->line) + 1;\n      }\n\n     \n#ifdef HISTORY_USE_MMAP\n    if (ftruncate (file, buffer_size+cursize) == -1)\n      goto mmap_error;\n    buffer = (char *)mmap (0, buffer_size, PROT_READ|PROT_WRITE, MAP_WFLAGS, file, cursize);\n    if ((void *)buffer == MAP_FAILED)\n      {\nmmap_error:\n\trv = errno;\n\tclose (file);\n\tif (tempname)\n\t  unlink (tempname);\n\tFREE (histname);\n\tFREE (tempname);\n\treturn rv;\n      }\n#else    \n    buffer = (char *)malloc (buffer_size);\n    if (buffer == 0)\n      {\n      \trv = errno;\n\tclose (file);\n\tif (tempname)\n\t  unlink (tempname);\n\tFREE (histname);\n\tFREE (tempname);\n\treturn rv;\n      }\n#endif\n\n    for (j = 0, i = history_length - nelements; i < history_length; i++)\n      {\n\tif (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])\n\t  {\n\t    strcpy (buffer + j, the_history[i]->timestamp);\n\t    j += strlen (the_history[i]->timestamp);\n\t    buffer[j++] = '\\n';\n\t  }\n\tstrcpy (buffer + j, the_history[i]->line);\n\tj += strlen (the_history[i]->line);\n\tbuffer[j++] = '\\n';\n      }\n\n#ifdef HISTORY_USE_MMAP\n    if (msync (buffer, buffer_size, MS_ASYNC) != 0 || munmap (buffer, buffer_size) != 0)\n      rv = errno;\n#else\n    if (write (file, buffer, buffer_size) < 0)\n      rv = errno;\n    xfree (buffer);\n#endif\n  }\n\n  history_lines_written_to_file = nelements;\n\n  if (close (file) < 0 && rv == 0)\n    rv = errno;\n\n  if (rv == 0 && histname && tempname)\n    rv = histfile_restore (tempname, histname);\n\n  if (rv != 0)\n    {\n      rv = errno;\n      if (tempname)\n\tunlink (tempname);\n      history_lines_written_to_file = 0;\n    }\n\n#if defined (HAVE_CHOWN)\n   \n  if (rv == 0 && exists)\n    mode = chown (histname, finfo.st_uid, finfo.st_gid);\n#endif\n\n  FREE (histname);\n  FREE (tempname);\n\n  return (rv);\n}\n\n \nint\nappend_history (int nelements, const char *filename)\n{\n  return (history_do_write (filename, nelements, HISTORY_APPEND));\n}\n\n \nint\nwrite_history (const char *filename)\n{\n  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}