{
  "module_name": "callback.c",
  "hash_id": "29dfafa0c4ec608e4ddefd2d19d6fa082644224364e9ce5b242ac0754b6dd90a",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/callback.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include \"rlconf.h\"\n\n#if defined (READLINE_CALLBACKS)\n\n#include <sys/types.h>\n\n#ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif\n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n#include \"readline.h\"\n#include \"rlprivate.h\"\n#include \"xmalloc.h\"\n\n \n_rl_callback_func_t *_rl_callback_func = 0;\n_rl_callback_generic_arg *_rl_callback_data = 0;\n\n    \nint rl_persistent_signal_handlers = 0;\n\n \n \n \n \n \n\n \n\nrl_vcpfunc_t *rl_linefunc;\t\t \nstatic int in_handler;\t\t \n\n \nstatic void\n_rl_callback_newline (void)\n{\n  rl_initialize ();\n\n  if (in_handler == 0)\n    {\n      in_handler = 1;\n\n      if (rl_prep_term_function)\n\t(*rl_prep_term_function) (_rl_meta_flag);\n\n#if defined (HANDLE_SIGNALS)\n      if (rl_persistent_signal_handlers)\n\trl_set_signals ();\n#endif\n    }\n\n  readline_internal_setup ();\n  RL_CHECK_SIGNALS ();\n}\n\n \nvoid\nrl_callback_handler_install (const char *prompt, rl_vcpfunc_t *linefunc)\n{\n  rl_set_prompt (prompt);\n  RL_SETSTATE (RL_STATE_CALLBACK);\n  rl_linefunc = linefunc;\n  _rl_callback_newline ();\n}\n\n#if defined (HANDLE_SIGNALS)\n#define CALLBACK_READ_RETURN() \\\n  do { \\\n    if (rl_persistent_signal_handlers == 0) \\\n      rl_clear_signals (); \\\n    return; \\\n  } while (0)\n#else\n#define CALLBACK_READ_RETURN() return\n#endif\n\n \nvoid\nrl_callback_read_char (void)\n{\n  char *line;\n  int eof, jcode;\n  static procenv_t olevel;\n\n  if (rl_linefunc == NULL)\n    {\n      _rl_errmsg (\"readline_callback_read_char() called with no handler!\");\n      abort ();\n    }\n\n  eof = 0;\n\n  memcpy ((void *)olevel, (void *)_rl_top_level, sizeof (procenv_t));\n#if defined (HAVE_POSIX_SIGSETJMP)\n  jcode = sigsetjmp (_rl_top_level, 0);\n#else\n  jcode = setjmp (_rl_top_level);\n#endif\n  if (jcode)\n    {\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n      memcpy ((void *)_rl_top_level, (void *)olevel, sizeof (procenv_t));\n\n       \n      if (RL_ISSTATE (RL_STATE_TIMEOUT))\n\t{\n\t  RL_SETSTATE (RL_STATE_DONE);\n\t  rl_done = 1;\n\t}\n\n      CALLBACK_READ_RETURN ();\n    }\n\n#if defined (HANDLE_SIGNALS)\n   \n  if (rl_persistent_signal_handlers == 0)\n    rl_set_signals ();\n#endif\n\n  do\n    {\n      RL_CHECK_SIGNALS ();\n      if  (RL_ISSTATE (RL_STATE_ISEARCH))\n\t{\n\t  eof = _rl_isearch_callback (_rl_iscxt);\n\t  if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))\n\t    rl_callback_read_char ();\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n      else if  (RL_ISSTATE (RL_STATE_NSEARCH))\n\t{\n\t  eof = _rl_nsearch_callback (_rl_nscxt);\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n#if defined (VI_MODE)\n       \n      else if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n\t{\n\t  int k;\n\n\t  k = _rl_callback_data->i2;\n\n\t  eof = (*_rl_callback_func) (_rl_callback_data);\n\t   \n\t  if (_rl_callback_func == 0)\t \n\t    {\n\t      if (_rl_callback_data)\n\t\t{\n\t\t  _rl_callback_data_dispose (_rl_callback_data);\n\t\t  _rl_callback_data = 0;\n\t\t}\n\t    }\n\n\t   \n\t  if (RL_ISSTATE (RL_STATE_VIMOTION))\n\t    {\n\t      _rl_vi_domove_motion_cleanup (k, _rl_vimvcxt);\n\t      _rl_internal_char_cleanup ();\n\t      CALLBACK_READ_RETURN ();\t      \n\t    }\n\n\t  _rl_internal_char_cleanup ();\n\t}\n      else if (RL_ISSTATE (RL_STATE_VIMOTION))\n\t{\n\t  eof = _rl_vi_domove_callback (_rl_vimvcxt);\n\t   \n\t  if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)\n\t    _rl_internal_char_cleanup ();\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n#endif\n      else if (RL_ISSTATE (RL_STATE_NUMERICARG))\n\t{\n\t  eof = _rl_arg_callback (_rl_argcxt);\n\t  if (eof == 0 && (RL_ISSTATE (RL_STATE_NUMERICARG) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))\n\t    rl_callback_read_char ();\n\t   \n\t  else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)\n\t    _rl_internal_char_cleanup ();\n\n\t  CALLBACK_READ_RETURN ();\n\t}\n      else if (RL_ISSTATE (RL_STATE_MULTIKEY))\n\t{\n\t  eof = _rl_dispatch_callback (_rl_kscxt);\t \n\t  while ((eof == -1 || eof == -2) && RL_ISSTATE (RL_STATE_MULTIKEY) && _rl_kscxt && (_rl_kscxt->flags & KSEQ_DISPATCHED))\n\t    eof = _rl_dispatch_callback (_rl_kscxt);\n\t  if (RL_ISSTATE (RL_STATE_MULTIKEY) == 0)\n\t    {\n\t      _rl_internal_char_cleanup ();\n\t      _rl_want_redisplay = 1;\n\t    }\n\t}\n      else if (_rl_callback_func)\n\t{\n\t   \n\t  eof = (*_rl_callback_func) (_rl_callback_data);\n\t   \n\t  if (_rl_callback_func == 0)\n\t    {\n\t      if (_rl_callback_data) \t\n\t\t{\n\t\t  _rl_callback_data_dispose (_rl_callback_data);\n\t\t  _rl_callback_data = 0;\n\t\t}\n\t      _rl_internal_char_cleanup ();\n\t    }\n\t}\n      else\n\teof = readline_internal_char ();\n\n      RL_CHECK_SIGNALS ();\n      if (rl_done == 0 && _rl_want_redisplay)\n\t{\n\t  (*rl_redisplay_function) ();\n\t  _rl_want_redisplay = 0;\n\t}\n\n       \n      if (eof > 0)\n\t{\n\t  rl_eof_found = eof;\n\t  RL_SETSTATE(RL_STATE_EOF);\n\t}\n\n      if (rl_done)\n\t{\n\t  line = readline_internal_teardown (eof);\n\n\t  if (rl_deprep_term_function)\n\t    (*rl_deprep_term_function) ();\n#if defined (HANDLE_SIGNALS)\n\t  rl_clear_signals ();\n#endif\n\t  in_handler = 0;\n\t  if (rl_linefunc)\t\t\t \n\t    (*rl_linefunc) (line);\n\n\t   \n\t  if (rl_line_buffer[0])\n\t    _rl_init_line_state ();\n\n\t   \n\t  if (in_handler == 0 && rl_linefunc)\n\t    _rl_callback_newline ();\n\t}\n    }\n  while (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT));\n\n  CALLBACK_READ_RETURN ();\n}\n\n \nvoid\nrl_callback_handler_remove (void)\n{\n  rl_linefunc = NULL;\n  RL_UNSETSTATE (RL_STATE_CALLBACK);\n  RL_CHECK_SIGNALS ();\n  if (in_handler)\n    {\n      in_handler = 0;\n      if (rl_deprep_term_function)\n\t(*rl_deprep_term_function) ();\n#if defined (HANDLE_SIGNALS)\n      rl_clear_signals ();\n#endif\n    }\n}\n\n_rl_callback_generic_arg *\n_rl_callback_data_alloc (int count)\n{\n  _rl_callback_generic_arg *arg;\n\n  arg = (_rl_callback_generic_arg *)xmalloc (sizeof (_rl_callback_generic_arg));\n  arg->count = count;\n\n  arg->i1 = arg->i2 = 0;\n\n  return arg;\n}\n\nvoid\n_rl_callback_data_dispose (_rl_callback_generic_arg *arg)\n{\n  xfree (arg);\n}\n\n \nvoid\nrl_callback_sigcleanup (void)\n{\n  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n    return;\n\n  if (RL_ISSTATE (RL_STATE_ISEARCH))\n    _rl_isearch_cleanup (_rl_iscxt, 0);\n  else if (RL_ISSTATE (RL_STATE_NSEARCH))\n    _rl_nsearch_cleanup (_rl_nscxt, 0);\n  else if (RL_ISSTATE (RL_STATE_VIMOTION))\n    RL_UNSETSTATE (RL_STATE_VIMOTION);\n  else if (RL_ISSTATE (RL_STATE_NUMERICARG))\n    {\n      _rl_argcxt = 0;\n      RL_UNSETSTATE (RL_STATE_NUMERICARG);\n    }\n  else if (RL_ISSTATE (RL_STATE_MULTIKEY))\n    RL_UNSETSTATE (RL_STATE_MULTIKEY);\n  if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n    RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n\n  _rl_callback_func = 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}