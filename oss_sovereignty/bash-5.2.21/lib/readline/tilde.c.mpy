{
  "module_name": "tilde.c",
  "hash_id": "9cdfb35881b67ad38c60dc0bb56e344fb613b3224548538dbdb7a7fbf359b160",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/tilde.c",
  "human_readable_source": " \n\n \n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_STRING_H)\n#  include <string.h>\n#else  \n#  include <strings.h>\n#endif    \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include <sys/types.h>\n#if defined (HAVE_PWD_H)\n#include <pwd.h>\n#endif\n\n#include \"tilde.h\"\n\n#if defined (TEST) || defined (STATIC_MALLOC)\nstatic void *xmalloc (), *xrealloc ();\n#else\n#  include \"xmalloc.h\"\n#endif  \n\n#if !defined (HAVE_GETPW_DECLS)\n#  if defined (HAVE_GETPWUID)\nextern struct passwd *getpwuid (uid_t);\n#  endif\n#  if defined (HAVE_GETPWNAM)\nextern struct passwd *getpwnam (const char *);\n#  endif\n#endif  \n\n#if !defined (savestring)\n#define savestring(x) strcpy ((char *)xmalloc (1 + strlen (x)), (x))\n#endif  \n\n#if !defined (NULL)\n#  if defined (__STDC__)\n#    define NULL ((void *) 0)\n#  else\n#    define NULL 0x0\n#  endif  \n#endif  \n\n \nextern char *sh_get_home_dir (void);\nextern char *sh_get_env_value (const char *);\n\n \nstatic const char *default_prefixes[] =\n  { \" ~\", \"\\t~\", (const char *)NULL };\n\n \nstatic const char *default_suffixes[] =\n  { \" \", \"\\n\", (const char *)NULL };\n\n \ntilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;\n\n \ntilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;\n\n \nchar **tilde_additional_prefixes = (char **)default_prefixes;\n\n \nchar **tilde_additional_suffixes = (char **)default_suffixes;\n\nstatic int tilde_find_prefix (const char *, int *);\nstatic int tilde_find_suffix (const char *);\nstatic char *isolate_tilde_prefix (const char *, int *);\nstatic char *glue_prefix_and_suffix (char *, const char *, int);\n\n \nstatic int\ntilde_find_prefix (const char *string, int *len)\n{\n  register int i, j, string_len;\n  register char **prefixes;\n\n  prefixes = tilde_additional_prefixes;\n\n  string_len = strlen (string);\n  *len = 0;\n\n  if (*string == '\\0' || *string == '~')\n    return (0);\n\n  if (prefixes)\n    {\n      for (i = 0; i < string_len; i++)\n\t{\n\t  for (j = 0; prefixes[j]; j++)\n\t    {\n\t      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)\n\t\t{\n\t\t  *len = strlen (prefixes[j]) - 1;\n\t\t  return (i + *len);\n\t\t}\n\t    }\n\t}\n    }\n  return (string_len);\n}\n\n \nstatic int\ntilde_find_suffix (const char *string)\n{\n  register int i, j, string_len;\n  register char **suffixes;\n\n  suffixes = tilde_additional_suffixes;\n  string_len = strlen (string);\n\n  for (i = 0; i < string_len; i++)\n    {\n#if defined (__MSDOS__)\n      if (string[i] == '/' || string[i] == '\\\\'  )\n#else\n      if (string[i] == '/'  )\n#endif\n\tbreak;\n\n      for (j = 0; suffixes && suffixes[j]; j++)\n\t{\n\t  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)\n\t    return (i);\n\t}\n    }\n  return (i);\n}\n\n \nchar *\ntilde_expand (const char *string)\n{\n  char *result;\n  int result_size, result_index;\n\n  result_index = result_size = 0;\n  if (result = strchr (string, '~'))\n    result = (char *)xmalloc (result_size = (strlen (string) + 16));\n  else\n    result = (char *)xmalloc (result_size = (strlen (string) + 1));\n\n   \n  while (1)\n    {\n      register int start, end;\n      char *tilde_word, *expansion;\n      int len;\n\n       \n      start = tilde_find_prefix (string, &len);\n\n       \n      if ((result_index + start + 1) > result_size)\n\tresult = (char *)xrealloc (result, 1 + (result_size += (start + 20)));\n\n      strncpy (result + result_index, string, start);\n      result_index += start;\n\n       \n      string += start;\n\n       \n      end = tilde_find_suffix (string);\n\n       \n      if (!start && !end)\n\tbreak;\n\n       \n      tilde_word = (char *)xmalloc (1 + end);\n      strncpy (tilde_word, string, end);\n      tilde_word[end] = '\\0';\n      string += end;\n\n      expansion = tilde_expand_word (tilde_word);\n\n      if (expansion == 0)\n\texpansion = tilde_word;\n      else\n\txfree (tilde_word);\t\n\n      len = strlen (expansion);\n#ifdef __CYGWIN__\n       \n      if (len > 1 || *expansion != '/' || *string != '/')\n#endif\n\t{\n\t  if ((result_index + len + 1) > result_size)\n\t    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));\n\n\t  strcpy (result + result_index, expansion);\n\t  result_index += len;\n\t}\n      xfree (expansion);\n    }\n\n  result[result_index] = '\\0';\n\n  return (result);\n}\n\n \nstatic char *\nisolate_tilde_prefix (const char *fname, int *lenp)\n{\n  char *ret;\n  int i;\n\n  ret = (char *)xmalloc (strlen (fname));\n#if defined (__MSDOS__)\n  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\\\'; i++)\n#else\n  for (i = 1; fname[i] && fname[i] != '/'; i++)\n#endif\n    ret[i - 1] = fname[i];\n  ret[i - 1] = '\\0';\n  if (lenp)\n    *lenp = i;\n  return ret;\n}\n\n#if 0\n \nchar *\ntilde_find_word (const char *fname, int flags, int *lenp)\n{\n  int x;\n  char *r;\n\n  x = tilde_find_suffix (fname);\n  if (x == 0)\n    {\n      r = savestring (fname);\n      if (lenp)\n\t*lenp = 0;\n    }\n  else\n    {\n      r = (char *)xmalloc (1 + x);\n      strncpy (r, fname, x);\n      r[x] = '\\0';\n      if (lenp)\n\t*lenp = x;\n    }\n\n  return r;\n}\n#endif\n\n \nstatic char *\nglue_prefix_and_suffix (char *prefix, const char *suffix, int suffind)\n{\n  char *ret;\n  int plen, slen;\n\n  plen = (prefix && *prefix) ? strlen (prefix) : 0;\n  slen = strlen (suffix + suffind);\n  ret = (char *)xmalloc (plen + slen + 1);\n  if (plen)\n    strcpy (ret, prefix);\n  strcpy (ret + plen, suffix + suffind);\n  return ret;\n}\n\n \nchar *\ntilde_expand_word (const char *filename)\n{\n  char *dirname, *expansion, *username;\n  int user_len;\n  struct passwd *user_entry;\n\n  if (filename == 0)\n    return ((char *)NULL);\n\n  if (*filename != '~')\n    return (savestring (filename));\n\n   \n  if (filename[1] == '\\0' || filename[1] == '/')\n    {\n       \n      expansion = sh_get_env_value (\"HOME\");\n#if defined (_WIN32)\n      if (expansion == 0)\n\texpansion = sh_get_env_value (\"APPDATA\");\n#endif\n\n       \n      if (expansion == 0)\n\texpansion = sh_get_home_dir ();\n\n      return (glue_prefix_and_suffix (expansion, filename, 1));\n    }\n\n  username = isolate_tilde_prefix (filename, &user_len);\n\n  if (tilde_expansion_preexpansion_hook)\n    {\n      expansion = (*tilde_expansion_preexpansion_hook) (username);\n      if (expansion)\n\t{\n\t  dirname = glue_prefix_and_suffix (expansion, filename, user_len);\n\t  xfree (username);\n\t  xfree (expansion);\n\t  return (dirname);\n\t}\n    }\n\n   \n  dirname = (char *)NULL;\n#if defined (HAVE_GETPWNAM)\n  user_entry = getpwnam (username);\n#else\n  user_entry = 0;\n#endif\n  if (user_entry == 0)\n    {\n       \n      if (tilde_expansion_failure_hook)\n\t{\n\t  expansion = (*tilde_expansion_failure_hook) (username);\n\t  if (expansion)\n\t    {\n\t      dirname = glue_prefix_and_suffix (expansion, filename, user_len);\n\t      xfree (expansion);\n\t    }\n\t}\n       \n      if (dirname == 0)\n\tdirname = savestring (filename);\n    }\n#if defined (HAVE_GETPWENT)\n  else\n    dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);\n#endif\n\n  xfree (username);\n#if defined (HAVE_GETPWENT)\n  endpwent ();\n#endif\n  return (dirname);\n}\n\n\f\n#if defined (TEST)\n#undef NULL\n#include <stdio.h>\n\nmain (int argc, char **argv)\n{\n  char *result, line[512];\n  int done = 0;\n\n  while (!done)\n    {\n      printf (\"~expand: \");\n      fflush (stdout);\n\n      if (!gets (line))\n\tstrcpy (line, \"done\");\n\n      if ((strcmp (line, \"done\") == 0) ||\n\t  (strcmp (line, \"quit\") == 0) ||\n\t  (strcmp (line, \"exit\") == 0))\n\t{\n\t  done = 1;\n\t  break;\n\t}\n\n      result = tilde_expand (line);\n      printf (\"  --> %s\\n\", result);\n      free (result);\n    }\n  exit (0);\n}\n\nstatic void memory_error_and_abort (void);\n\nstatic void *\nxmalloc (size_t bytes)\n{\n  void *temp = (char *)malloc (bytes);\n\n  if (!temp)\n    memory_error_and_abort ();\n  return (temp);\n}\n\nstatic void *\nxrealloc (void *pointer, int bytes)\n{\n  void *temp;\n\n  if (!pointer)\n    temp = malloc (bytes);\n  else\n    temp = realloc (pointer, bytes);\n\n  if (!temp)\n    memory_error_and_abort ();\n\n  return (temp);\n}\n\nstatic void\nmemory_error_and_abort (void)\n{\n  fprintf (stderr, \"readline: out of virtual memory\\n\");\n  abort ();\n}\n\n \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}