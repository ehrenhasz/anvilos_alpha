{
  "module_name": "histsearch.c",
  "hash_id": "5fb65c9a6c8fc9b5ac0579d135eacb8f2e2a258c018fc761f68ba98f29f47d22",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/histsearch.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_FNMATCH)\n#  include <fnmatch.h>\n#endif\n\n#include \"history.h\"\n#include \"histlib.h\"\n#include \"xmalloc.h\"\n\n \nchar *history_search_delimiter_chars = (char *)NULL;\n\nstatic int history_search_internal (const char *, int, int);\n\n \n\nstatic int\nhistory_search_internal (const char *string, int direction, int flags)\n{\n  register int i, reverse;\n  register char *line;\n  register int line_index;\n  int string_len, anchored, patsearch;\n  HIST_ENTRY **the_history; \t \n\n  i = history_offset;\n  reverse = (direction < 0);\n  anchored = (flags & ANCHORED_SEARCH);\n#if defined (HAVE_FNMATCH)\n  patsearch = (flags & PATTERN_SEARCH);\n#else\n  patsearch = 0;\n#endif\n\n   \n  if (string == 0 || *string == '\\0')\n    return (-1);\n\n  if (!history_length || ((i >= history_length) && !reverse))\n    return (-1);\n\n  if (reverse && (i >= history_length))\n    i = history_length - 1;\n\n#define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)\n\n  the_history = history_list ();\n  string_len = strlen (string);\n  while (1)\n    {\n       \n\n       \n      if ((reverse && i < 0) || (!reverse && i == history_length))\n\treturn (-1);\n\n      line = the_history[i]->line;\n      line_index = strlen (line);\n\n       \n      if (patsearch == 0 && (string_len > line_index))\n\t{\n\t  NEXT_LINE ();\n\t  continue;\n\t}\n\n       \n      if (anchored == ANCHORED_SEARCH)\n\t{\n#if defined (HAVE_FNMATCH)\n\t  if (patsearch)\n\t    {\n\t      if (fnmatch (string, line, 0) == 0)\n\t\t{\n\t\t  history_offset = i;\n\t\t  return (0);\n\t\t}\n\t    }\n\t  else\n#endif\n\t  if (STREQN (string, line, string_len))\n\t    {\n\t      history_offset = i;\n\t      return (0);\n\t    }\n\n\t  NEXT_LINE ();\n\t  continue;\n\t}\n\n       \n      if (reverse)\n\t{\n\t  line_index -= (patsearch == 0) ? string_len : 1;\n\n\t  while (line_index >= 0)\n\t    {\n#if defined (HAVE_FNMATCH)\n\t      if (patsearch)\n\t\t{\n\t\t  if (fnmatch (string, line + line_index, 0) == 0)\n\t\t    {\n\t\t      history_offset = i;\n\t\t      return (line_index);\n\t\t    }\n\t\t}\n\t      else\n#endif\n\t      if (STREQN (string, line + line_index, string_len))\n\t\t{\n\t\t  history_offset = i;\n\t\t  return (line_index);\n\t\t}\n\t      line_index--;\n\t    }\n\t}\n      else\n\t{\n\t  register int limit;\n\n\t  limit = line_index - string_len + 1;\n\t  line_index = 0;\n\n\t  while (line_index < limit)\n\t    {\n#if defined (HAVE_FNMATCH)\n\t      if (patsearch)\n\t\t{\n\t\t  if (fnmatch (string, line + line_index, 0) == 0)\n\t\t    {\n\t\t      history_offset = i;\n\t\t      return (line_index);\n\t\t    }\n\t\t}\n\t      else\n#endif\n\t      if (STREQN (string, line + line_index, string_len))\n\t\t{\n\t\t  history_offset = i;\n\t\t  return (line_index);\n\t\t}\n\t      line_index++;\n\t    }\n\t}\n      NEXT_LINE ();\n    }\n}\n\nint\n_hs_history_patsearch (const char *string, int direction, int flags)\n{\n  char *pat;\n  size_t len, start;\n  int ret, unescaped_backslash;\n\n#if defined (HAVE_FNMATCH)\n   \n  len = strlen (string);\n  ret = len - 1;\n   \n  if (unescaped_backslash = (string[ret] == '\\\\'))\n    {\n      while (ret > 0 && string[--ret] == '\\\\')\n\tunescaped_backslash = 1 - unescaped_backslash;\n    }\n  if (unescaped_backslash)\n    return -1;\n  pat = (char *)xmalloc (len + 3);\n   \n  if ((flags & ANCHORED_SEARCH) == 0 && string[0] != '*')\n    {\n      pat[0] = '*';\n      start = 1;\n      len++;\n    }\n  else\n    {\n      start = 0;\n    }\n\n   \n  strcpy (pat + start, string);\n  if (pat[len - 1] != '*')\n    {\n      pat[len] = '*';\t\t \n      pat[len+1] = '\\0';\n    }\n#else\n  pat = string;\n#endif\n\n  ret = history_search_internal (pat, direction, flags|PATTERN_SEARCH);\n\n  if (pat != string)\n    xfree (pat);\n  return ret;\n}\n\t\n \nint\nhistory_search (const char *string, int direction)\n{\n  return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));\n}\n\n \nint\nhistory_search_prefix (const char *string, int direction)\n{\n  return (history_search_internal (string, direction, ANCHORED_SEARCH));\n}\n\n \nint\nhistory_search_pos (const char *string, int dir, int pos)\n{\n  int ret, old;\n\n  old = where_history ();\n  history_set_pos (pos);\n  if (history_search (string, dir) == -1)\n    {\n      history_set_pos (old);\n      return (-1);\n    }\n  ret = where_history ();\n  history_set_pos (old);\n  return ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}