{
  "module_name": "parens.c",
  "hash_id": "fbea42868e5e0535581874b0694d0beb66acdc6d6c2f20f2699fa5a0d0d043d6",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/parens.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (__TANDEM)\n#  include <floss.h>\n#endif\n\n#include \"rlconf.h\"\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n#include <sys/types.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"posixselect.h\"\n\n#if defined (HAVE_STRING_H)\n#  include <string.h>\n#else  \n#  include <strings.h>\n#endif  \n\n#if !defined (strchr) && !defined (__STDC__)\nextern char *strchr (), *strrchr ();\n#endif  \n\n#include \"readline.h\"\n#include \"rlprivate.h\"\n\nstatic int find_matching_open (char *, int, int);\n\n \nint rl_blink_matching_paren = 0;\n\nstatic int _paren_blink_usec = 500000;\n\n \nvoid\n_rl_enable_paren_matching (int on_or_off)\n{\n  if (on_or_off)\n    {\n       \n      rl_bind_key_in_map (')', rl_insert_close, emacs_standard_keymap);\n      rl_bind_key_in_map (']', rl_insert_close, emacs_standard_keymap);\n      rl_bind_key_in_map ('}', rl_insert_close, emacs_standard_keymap);\n\n#if defined (VI_MODE)\n       \n      rl_bind_key_in_map (')', rl_insert_close, vi_insertion_keymap);\n      rl_bind_key_in_map (']', rl_insert_close, vi_insertion_keymap);\n      rl_bind_key_in_map ('}', rl_insert_close, vi_insertion_keymap);\n#endif\n    }\n  else\n    {\n       \n      rl_bind_key_in_map (')', rl_insert, emacs_standard_keymap);\n      rl_bind_key_in_map (']', rl_insert, emacs_standard_keymap);\n      rl_bind_key_in_map ('}', rl_insert, emacs_standard_keymap);\n\n#if defined (VI_MODE)\n       \n      rl_bind_key_in_map (')', rl_insert, vi_insertion_keymap);\n      rl_bind_key_in_map (']', rl_insert, vi_insertion_keymap);\n      rl_bind_key_in_map ('}', rl_insert, vi_insertion_keymap);\n#endif\n    }\n}\n\nint\nrl_set_paren_blink_timeout (int u)\n{\n  int o;\n\n  o = _paren_blink_usec;\n  if (u > 0)\n    _paren_blink_usec = u;\n  return (o);\n}\n\nint\nrl_insert_close (int count, int invoking_key)\n{\n  if (rl_explicit_arg || !rl_blink_matching_paren)\n    _rl_insert_char (count, invoking_key);\n  else\n    {\n#if defined (HAVE_SELECT)\n      int orig_point, match_point, ready;\n      struct timeval timer;\n      fd_set readfds;\n\n      _rl_insert_char (1, invoking_key);\n      (*rl_redisplay_function) ();\n      match_point =\n\tfind_matching_open (rl_line_buffer, rl_point - 2, invoking_key);\n\n       \n      if (match_point < 0)\n\treturn 1;\n\n      FD_ZERO (&readfds);\n      FD_SET (fileno (rl_instream), &readfds);\n      USEC_TO_TIMEVAL (_paren_blink_usec, timer);\n\n      orig_point = rl_point;\n      rl_point = match_point;\n      (*rl_redisplay_function) ();\n#  if defined (RL_TIMEOUT_USE_SELECT)\n      ready = _rl_timeout_select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer, NULL);\n#  else\n      ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);\n#  endif\n      rl_point = orig_point;\n#else  \n      _rl_insert_char (count, invoking_key);\n#endif  \n    }\n  return 0;\n}\n\nstatic int\nfind_matching_open (char *string, int from, int closer)\n{\n  register int i;\n  int opener, level, delimiter;\n\n  switch (closer)\n    {\n    case ']': opener = '['; break;\n    case '}': opener = '{'; break;\n    case ')': opener = '('; break;\n    default:\n      return (-1);\n    }\n\n  level = 1;\t\t\t \n  delimiter = 0;\t\t \n\n  for (i = from; i > -1; i--)\n    {\n      if (delimiter && (string[i] == delimiter))\n\tdelimiter = 0;\n      else if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, string[i]))\n\tdelimiter = string[i];\n      else if (!delimiter && (string[i] == closer))\n\tlevel++;\n      else if (!delimiter && (string[i] == opener))\n\tlevel--;\n\n      if (!level)\n\tbreak;\n    }\n  return (i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}