{
  "module_name": "signals.c",
  "hash_id": "495da04a29bb5c7df6cd57ac511615c5bfa68af25a7b4a0dd1c8d04e9d78b844",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/signals.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\t\t \n#include <sys/types.h>\n#include <signal.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n \n#include \"rldefs.h\"\n\n#if defined (GWINSZ_IN_SYS_IOCTL)\n#  include <sys/ioctl.h>\n#endif  \n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n\n#if defined (HANDLE_SIGNALS)\n\n#define SIGHANDLER_RETURN return\n\n \ntypedef void SigHandler (int);\n\n#if defined (HAVE_POSIX_SIGNALS)\ntypedef struct sigaction sighandler_cxt;\n#  define rl_sigaction(s, nh, oh)\tsigaction(s, nh, oh)\n#else\ntypedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;\n#  define sigemptyset(m)\n#endif  \n\n#ifndef SA_RESTART\n#  define SA_RESTART 0\n#endif\n\nstatic SigHandler *rl_set_sighandler (int, SigHandler *, sighandler_cxt *);\nstatic void rl_maybe_set_sighandler (int, SigHandler *, sighandler_cxt *);\nstatic void rl_maybe_restore_sighandler (int, sighandler_cxt *);\n\nstatic void rl_signal_handler (int);\nstatic void _rl_handle_signal (int);\n     \n \n\n \nint rl_catch_signals = 1;\n\n \n#ifdef SIGWINCH\nint rl_catch_sigwinch = 1;\n#else\nint rl_catch_sigwinch = 0;\t \n#endif\n\n \nint volatile _rl_caught_signal = 0;\t \n\n \nint _rl_echoctl = 0;\n\nint _rl_intr_char = 0;\nint _rl_quit_char = 0;\nint _rl_susp_char = 0;\n\nstatic int signals_set_flag;\nstatic int sigwinch_set_flag;\n\n#if defined (HAVE_POSIX_SIGNALS)\nsigset_t _rl_orig_sigset;\n#endif  \n\n \n \n \n \n \n\nstatic sighandler_cxt old_int, old_term, old_hup, old_alrm, old_quit;\n#if defined (SIGTSTP)\nstatic sighandler_cxt old_tstp, old_ttou, old_ttin;\n#endif\n#if defined (SIGWINCH)\nstatic sighandler_cxt old_winch;\n#endif\n\n_rl_sigcleanup_func_t *_rl_sigcleanup;\nvoid *_rl_sigcleanarg;\n\n \n\n \nvoid\n_rl_signal_handler (int sig)\n{\n  _rl_caught_signal = 0;\t \n\n#if defined (SIGWINCH)\n  if (sig == SIGWINCH)\n    {\n      RL_SETSTATE(RL_STATE_SIGHANDLER);\n\n      rl_resize_terminal ();\n       \n       \n      if (rl_signal_event_hook)\n\t(*rl_signal_event_hook) ();\n\n      RL_UNSETSTATE(RL_STATE_SIGHANDLER);\n    }\n  else\n#endif\n    _rl_handle_signal (sig);\n\n  SIGHANDLER_RETURN;\n}\n\nstatic void\nrl_signal_handler (int sig)\n{\n  _rl_caught_signal = sig;\n  SIGHANDLER_RETURN;\n}\n\n \nstatic void\n_rl_handle_signal (int sig)\n{\n  int block_sig;\n\n#if defined (HAVE_POSIX_SIGNALS)\n  sigset_t set, oset;\n#else  \n#  if defined (HAVE_BSD_SIGNALS)\n  long omask;\n#  else  \n  sighandler_cxt dummy_cxt;\t \n#  endif  \n#endif  \n\n  RL_SETSTATE(RL_STATE_SIGHANDLER);\n\n#if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)\n   \n#  if defined (SIGALRM)\n  if (sig == SIGINT || sig == SIGALRM)\n#  else\n  if (sig == SIGINT)\n#  endif\n    rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);\n#endif  \n\n   \n  if (_rl_sigcleanup)\n    {\n      (*_rl_sigcleanup) (sig, _rl_sigcleanarg);\n      _rl_sigcleanup = 0;\n      _rl_sigcleanarg = 0;\n    }\n\n#if defined (HAVE_POSIX_SIGNALS)\n   \n  block_sig = 0;\t \n  sigemptyset (&set);\n  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);\n#endif\n\n  switch (sig)\n    {\n    case SIGINT:\n       \n      _rl_reset_completion_state ();\n      rl_free_line_state ();\n#if defined (READLINE_CALLBACKS)\n      rl_callback_sigcleanup ();\n#endif\n\n       \n\n#if defined (SIGTSTP)\n    case SIGTSTP:\n    case SIGTTIN:\n    case SIGTTOU:\n#  if defined (HAVE_POSIX_SIGNALS)\n       \n      if (block_sig == 0)\n\t{\n\t  sigaddset (&set, SIGTTOU);\n\t  block_sig = 1;\n\t}\n#  endif\n#endif  \n    \n#if defined (SIGHUP)\n    case SIGHUP:\n#  if defined (_AIX)\n      if (block_sig == 0)\n\t{\n\t  sigaddset (&set, sig);\n\t  block_sig = 1;\n\t}\n#  endif \n#endif\n     \n    case SIGTERM:\n#if defined (SIGALRM)\n    case SIGALRM:\n      if (sig == SIGALRM)\n\t_rl_timeout_handle_sigalrm ();\n#endif\n#if defined (SIGQUIT)\n    case SIGQUIT:\n#endif\n\n#if defined (HAVE_POSIX_SIGNALS)\n      if (block_sig)\n\tsigprocmask (SIG_BLOCK, &set, &oset);\n#endif\n\n      rl_echo_signal_char (sig);\n      rl_cleanup_after_signal ();\n\n       \n\n#if defined (HAVE_POSIX_SIGNALS)\n       \n      if (block_sig)\n\tsigprocmask (SIG_UNBLOCK, &oset, (sigset_t *)NULL);\n#endif\n\n       \n\n#if defined (__EMX__)\n      signal (sig, SIG_ACK);\n#endif\n\n#if defined (HAVE_KILL)\n      kill (getpid (), sig);\n#else\n      raise (sig);\t\t \n#endif\n\n       \n\n      rl_reset_after_signal ();      \n    }\n\n  RL_UNSETSTATE(RL_STATE_SIGHANDLER);\n  SIGHANDLER_RETURN;\n}\n\n#if defined (SIGWINCH)\nstatic void\nrl_sigwinch_handler (int sig)\n{\n  SigHandler *oh;\n\n#if defined (MUST_REINSTALL_SIGHANDLERS)\n  sighandler_cxt dummy_winch;\n\n   \n  rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);\n#endif\n\n  RL_SETSTATE(RL_STATE_SIGHANDLER);\n  _rl_caught_signal = sig;\n\n   \n  oh = (SigHandler *)old_winch.sa_handler;\n  if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)\n    (*oh) (sig);\n\n  RL_UNSETSTATE(RL_STATE_SIGHANDLER);\n  SIGHANDLER_RETURN;\n}\n#endif   \n\n \n\n#if !defined (HAVE_POSIX_SIGNALS)\nstatic int\nrl_sigaction (int sig, sighandler_cxt *nh, sighandler_cxt *oh)\n{\n  oh->sa_handler = signal (sig, nh->sa_handler);\n  return 0;\n}\n#endif  \n\n \nstatic SigHandler *\nrl_set_sighandler (int sig, SigHandler *handler, sighandler_cxt *ohandler)\n{\n  sighandler_cxt old_handler;\n#if defined (HAVE_POSIX_SIGNALS)\n  struct sigaction act;\n\n  act.sa_handler = handler;\n#  if defined (SIGWINCH)\n  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;\n#  else\n  act.sa_flags = 0;\n#  endif  \n  sigemptyset (&act.sa_mask);\n  sigemptyset (&ohandler->sa_mask);\n  sigaction (sig, &act, &old_handler);\n#else\n  old_handler.sa_handler = (SigHandler *)signal (sig, handler);\n#endif  \n\n   \n   \n  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)\n    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));\n\n  return (ohandler->sa_handler);\n}\n\n \nstatic void\nrl_maybe_set_sighandler (int sig, SigHandler *handler, sighandler_cxt *ohandler)\n{\n  sighandler_cxt dummy;\n  SigHandler *oh;\n\n  sigemptyset (&dummy.sa_mask);\n  dummy.sa_flags = 0;\n  oh = rl_set_sighandler (sig, handler, ohandler);\n  if (oh == (SigHandler *)SIG_IGN)\n    rl_sigaction (sig, ohandler, &dummy);\n}\n\n \nstatic void\nrl_maybe_restore_sighandler (int sig, sighandler_cxt *handler)\n{\n  sighandler_cxt dummy;\n\n  sigemptyset (&dummy.sa_mask);\n  dummy.sa_flags = 0;\n  if (handler->sa_handler != SIG_IGN)\n    rl_sigaction (sig, handler, &dummy);\n}\n\nint\nrl_set_signals (void)\n{\n  sighandler_cxt dummy;\n  SigHandler *oh;\n#if defined (HAVE_POSIX_SIGNALS)\n  static int sigmask_set = 0;\n  static sigset_t bset, oset;\n#endif\n\n#if defined (HAVE_POSIX_SIGNALS)\n  if (rl_catch_signals && sigmask_set == 0)\n    {\n      sigemptyset (&bset);\n\n      sigaddset (&bset, SIGINT);\n      sigaddset (&bset, SIGTERM);\n#if defined (SIGHUP)\n      sigaddset (&bset, SIGHUP);\n#endif\n#if defined (SIGQUIT)\n      sigaddset (&bset, SIGQUIT);\n#endif\n#if defined (SIGALRM)\n      sigaddset (&bset, SIGALRM);\n#endif\n#if defined (SIGTSTP)\n      sigaddset (&bset, SIGTSTP);\n#endif\n#if defined (SIGTTIN)\n      sigaddset (&bset, SIGTTIN);\n#endif\n#if defined (SIGTTOU)\n      sigaddset (&bset, SIGTTOU);\n#endif\n      sigmask_set = 1;\n    }      \n#endif  \n\n  if (rl_catch_signals && signals_set_flag == 0)\n    {\n#if defined (HAVE_POSIX_SIGNALS)\n      sigemptyset (&_rl_orig_sigset);\n      sigprocmask (SIG_BLOCK, &bset, &_rl_orig_sigset);\n#endif\n\n      rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);\n      rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);\n#if defined (SIGHUP)\n      rl_maybe_set_sighandler (SIGHUP, rl_signal_handler, &old_hup);\n#endif\n#if defined (SIGQUIT)\n      rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);\n#endif\n\n#if defined (SIGALRM)\n      oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);\n      if (oh == (SigHandler *)SIG_IGN)\n\trl_sigaction (SIGALRM, &old_alrm, &dummy);\n#if defined (HAVE_POSIX_SIGNALS) && defined (SA_RESTART)\n       \n      if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))\n\trl_sigaction (SIGALRM, &old_alrm, &dummy);\n#endif  \n#endif  \n\n#if defined (SIGTSTP)\n      rl_maybe_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);\n#endif  \n\n#if defined (SIGTTOU)\n      rl_maybe_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);\n#endif  \n\n#if defined (SIGTTIN)\n      rl_maybe_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);\n#endif  \n\n      signals_set_flag = 1;\n\n#if defined (HAVE_POSIX_SIGNALS)\n      sigprocmask (SIG_SETMASK, &_rl_orig_sigset, (sigset_t *)NULL);\n#endif\n    }\n  else if (rl_catch_signals == 0)\n    {\n#if defined (HAVE_POSIX_SIGNALS)\n      sigemptyset (&_rl_orig_sigset);\n      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &_rl_orig_sigset);\n#endif\n    }\n\n#if defined (SIGWINCH)\n  if (rl_catch_sigwinch && sigwinch_set_flag == 0)\n    {\n      rl_maybe_set_sighandler (SIGWINCH, rl_sigwinch_handler, &old_winch);\n      sigwinch_set_flag = 1;\n    }\n#endif  \n\n  return 0;\n}\n\nint\nrl_clear_signals (void)\n{\n  sighandler_cxt dummy;\n\n  if (rl_catch_signals && signals_set_flag == 1)\n    {\n       \n      rl_maybe_restore_sighandler (SIGINT, &old_int);\n      rl_maybe_restore_sighandler (SIGTERM, &old_term);\n#if defined (SIGHUP)\n      rl_maybe_restore_sighandler (SIGHUP, &old_hup);\n#endif\n#if defined (SIGQUIT)\n      rl_maybe_restore_sighandler (SIGQUIT, &old_quit);\n#endif\n#if defined (SIGALRM)\n      rl_maybe_restore_sighandler (SIGALRM, &old_alrm);\n#endif\n\n#if defined (SIGTSTP)\n      rl_maybe_restore_sighandler (SIGTSTP, &old_tstp);\n#endif  \n\n#if defined (SIGTTOU)\n      rl_maybe_restore_sighandler (SIGTTOU, &old_ttou);\n#endif  \n\n#if defined (SIGTTIN)\n      rl_maybe_restore_sighandler (SIGTTIN, &old_ttin);\n#endif  \n\n      signals_set_flag = 0;\n    }\n\n#if defined (SIGWINCH)\n  if (rl_catch_sigwinch && sigwinch_set_flag == 1)\n    {\n      sigemptyset (&dummy.sa_mask);\n      rl_sigaction (SIGWINCH, &old_winch, &dummy);\n      sigwinch_set_flag = 0;\n    }\n#endif\n\n  return 0;\n}\n\n \nvoid\nrl_cleanup_after_signal (void)\n{\n  _rl_clean_up_for_exit ();\n  if (rl_deprep_term_function)\n    (*rl_deprep_term_function) ();\n  rl_clear_pending_input ();\n  rl_clear_signals ();\n}\n\n \nvoid\nrl_reset_after_signal (void)\n{\n  if (rl_prep_term_function)\n    (*rl_prep_term_function) (_rl_meta_flag);\n  rl_set_signals ();\n}\n\n  \nvoid\nrl_free_line_state (void)\n{\n  register HIST_ENTRY *entry;\n\n  rl_free_undo_list ();\n\n  entry = current_history ();\n  if (entry)\n    entry->data = (char *)NULL;\n\n  _rl_kill_kbd_macro ();\n  rl_clear_message ();\n  _rl_reset_argument ();\n}\n\nint\nrl_pending_signal (void)\n{\n  return (_rl_caught_signal);\n}\n\nvoid\nrl_check_signals (void)\n{\n  RL_CHECK_SIGNALS ();\n}\n#endif   \n\n \n \n \n \n \n\n#if defined (HAVE_POSIX_SIGNALS)\nstatic sigset_t sigint_set, sigint_oset;\nstatic sigset_t sigwinch_set, sigwinch_oset;\n#else  \n#  if defined (HAVE_BSD_SIGNALS)\nstatic int sigint_oldmask;\nstatic int sigwinch_oldmask;\n#  endif  \n#endif  \n\nstatic int sigint_blocked;\nstatic int sigwinch_blocked;\n\n \nvoid\n_rl_block_sigint (void)\n{\n  if (sigint_blocked)\n    return;\n\n  sigint_blocked = 1;\n}\n\n \nvoid\n_rl_release_sigint (void)\n{\n  if (sigint_blocked == 0)\n    return;\n\n  sigint_blocked = 0;\n  RL_CHECK_SIGNALS ();\n}\n\n \nvoid\n_rl_block_sigwinch (void)\n{\n  if (sigwinch_blocked)\n    return;\n\n#if defined (SIGWINCH)\n\n#if defined (HAVE_POSIX_SIGNALS)\n  sigemptyset (&sigwinch_set);\n  sigemptyset (&sigwinch_oset);\n  sigaddset (&sigwinch_set, SIGWINCH);\n  sigprocmask (SIG_BLOCK, &sigwinch_set, &sigwinch_oset);\n#else  \n#  if defined (HAVE_BSD_SIGNALS)\n  sigwinch_oldmask = sigblock (sigmask (SIGWINCH));\n#  else  \n#    if defined (HAVE_USG_SIGHOLD)\n  sighold (SIGWINCH);\n#    endif  \n#  endif  \n#endif  \n\n#endif  \n\n  sigwinch_blocked = 1;\n}\n\n \nvoid\n_rl_release_sigwinch (void)\n{\n  if (sigwinch_blocked == 0)\n    return;\n\n#if defined (SIGWINCH)\n\n#if defined (HAVE_POSIX_SIGNALS)\n  sigprocmask (SIG_SETMASK, &sigwinch_oset, (sigset_t *)NULL);\n#else\n#  if defined (HAVE_BSD_SIGNALS)\n  sigsetmask (sigwinch_oldmask);\n#  else  \n#    if defined (HAVE_USG_SIGHOLD)\n  sigrelse (SIGWINCH);\n#    endif  \n#  endif  \n#endif  \n\n#endif  \n\n  sigwinch_blocked = 0;\n}\n\n \n \n \n \n \nvoid\nrl_echo_signal_char (int sig)\n{\n  char cstr[3];\n  int cslen, c;\n\n  if (_rl_echoctl == 0 || _rl_echo_control_chars == 0)\n    return;\n\n  switch (sig)\n    {\n    case SIGINT:  c = _rl_intr_char; break;\n#if defined (SIGQUIT)\n    case SIGQUIT: c = _rl_quit_char; break;\n#endif\n#if defined (SIGTSTP)\n    case SIGTSTP: c = _rl_susp_char; break;\n#endif\n    default: return;\n    }\n\n  if (CTRL_CHAR (c) || c == RUBOUT)\n    {\n      cstr[0] = '^';\n      cstr[1] = CTRL_CHAR (c) ? UNCTRL (c) : '?';\n      cstr[cslen = 2] = '\\0';\n    }\n  else\n    {\n      cstr[0] = c;\n      cstr[cslen = 1] = '\\0';\n    }\n\n  _rl_output_some_chars (cstr, cslen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}