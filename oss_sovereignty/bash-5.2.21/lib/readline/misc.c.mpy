{
  "module_name": "misc.c",
  "hash_id": "e9bcc3ae8318c2dfe7c0017cafd0e95238d315fa3ae9ca66e5dfe4655b460f1f",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/misc.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_LOCALE_H)\n#  include <locale.h>\n#endif\n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"histlib.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\nstatic int rl_digit_loop (void);\nstatic void _rl_history_set_point (void);\n\n \nint _rl_history_preserve_point = 0;\n\n_rl_arg_cxt _rl_argcxt;\n\n \nint _rl_history_saved_point = -1;\n\n \n \n \n \n \n\nint\n_rl_arg_overflow (void)\n{\n  if (rl_numeric_arg > 1000000)\n    {\n      _rl_argcxt = 0;\n      rl_explicit_arg = rl_numeric_arg = 0;\n      rl_ding ();\n      rl_restore_prompt ();\n      rl_clear_message ();\n      RL_UNSETSTATE(RL_STATE_NUMERICARG);\n      return 1;\n    }\n  return 0;\n}\n\nvoid\n_rl_arg_init (void)\n{\n  rl_save_prompt ();\n  _rl_argcxt = 0;\n  RL_SETSTATE(RL_STATE_NUMERICARG);\n}\n\nint\n_rl_arg_getchar (void)\n{\n  int c;\n\n  rl_message (\"(arg: %d) \", rl_arg_sign * rl_numeric_arg);\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  c = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  return c;\n}\n\n \nint\n_rl_arg_dispatch (_rl_arg_cxt cxt, int c)\n{\n  int key, r;\n\n  key = c;\n\n   \n  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)\n    {\n      if ((cxt & NUM_SAWDIGITS) == 0)\n\t{\n\t  rl_numeric_arg *= 4;\n\t  return 1;\n\t}\n      else if (RL_ISSTATE (RL_STATE_CALLBACK))\n        {\n          _rl_argcxt |= NUM_READONE;\n          return 0;\t \n        }\n      else\n\t{\n\t  key = _rl_bracketed_read_key ();\n\t  rl_restore_prompt ();\n\t  rl_clear_message ();\n\t  RL_UNSETSTATE(RL_STATE_NUMERICARG);\n\t  if (key < 0)\n\t    return -1;\n\t  return (_rl_dispatch (key, _rl_keymap));\n\t}\n    }\n\n  c = UNMETA (c);\n\n  if (_rl_digit_p (c))\n    {\n      r = _rl_digit_value (c);    \t\n      rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) +  r : r;\n      rl_explicit_arg = 1;\n      _rl_argcxt |= NUM_SAWDIGITS;\n    }\n  else if (c == '-' && rl_explicit_arg == 0)\n    {\n      rl_numeric_arg = 1;\n      _rl_argcxt |= NUM_SAWMINUS;\n      rl_arg_sign = -1;\n    }\n  else\n    {\n       \n      if ((_rl_argcxt & NUM_SAWMINUS) && rl_numeric_arg == 1 && rl_explicit_arg == 0)\n\trl_explicit_arg = 1;\n      rl_restore_prompt ();\n      rl_clear_message ();\n      RL_UNSETSTATE(RL_STATE_NUMERICARG);\n\n      r = _rl_dispatch (key, _rl_keymap);\n      if (RL_ISSTATE (RL_STATE_CALLBACK))\n\t{\n\t   \n\t  if (rl_done == 0)\n\t    (*rl_redisplay_function) ();\n\t  r = 0;\n\t}\n      return r;\n    }\n\n  return 1;\n}\n\n \nstatic int\nrl_digit_loop (void)\n{\n  int c, r;\n\n  while (1)\n    {\n      if (_rl_arg_overflow ())\n\treturn 1;\n\n      c = _rl_arg_getchar ();\n\n      if (c < 0)\n\t{\n\t  _rl_abort_internal ();\n\t  return -1;\n\t}\n\n      r = _rl_arg_dispatch (_rl_argcxt, c);\n      if (r <= 0 || (RL_ISSTATE (RL_STATE_NUMERICARG) == 0))\n        break;\n    }\n\n  return r;\n}\n\n \nvoid\n_rl_reset_argument (void)\n{\n  rl_numeric_arg = rl_arg_sign = 1;\n  rl_explicit_arg = 0;\n  _rl_argcxt = 0;\n}\n\n \nint\nrl_digit_argument (int ignore, int key)\n{\n  _rl_arg_init ();\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_arg_dispatch (_rl_argcxt, key);\n      rl_message (\"(arg: %d) \", rl_arg_sign * rl_numeric_arg);\n      return 0;\n    }\n  else\n    {\n      rl_execute_next (key);\n      return (rl_digit_loop ());\n    }\n}\n\n \nint\nrl_universal_argument (int count, int key)\n{\n  _rl_arg_init ();\n  rl_numeric_arg *= 4;\n\n  return (RL_ISSTATE (RL_STATE_CALLBACK) ? 0 : rl_digit_loop ());\n}\n\nint\n_rl_arg_callback (_rl_arg_cxt cxt)\n{\n  int c, r;\n\n  c = _rl_arg_getchar ();\n  if (c < 0)\n    return (1);\t\t \n\n  if (_rl_argcxt & NUM_READONE)\n    {\n      _rl_argcxt &= ~NUM_READONE;\n      rl_restore_prompt ();\n      rl_clear_message ();\n      RL_UNSETSTATE(RL_STATE_NUMERICARG);\n      rl_execute_next (c);\n      return 0;\n    }\n\n  r = _rl_arg_dispatch (cxt, c);\n  if (r > 0)\n    rl_message (\"(arg: %d) \", rl_arg_sign * rl_numeric_arg);\n  return (r != 1);\n}\n\n \nint\nrl_discard_argument (void)\n{\n  rl_ding ();\n  rl_clear_message ();\n  _rl_reset_argument ();\n\n  return 0;\n}\n\n \n \n \n \n \n\n \n\n \nHIST_ENTRY *_rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n\n \nvoid\n_rl_start_using_history (void)\n{\n  using_history ();\n  if (_rl_saved_line_for_history)\n    _rl_free_saved_history_line ();\n  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n  _rl_history_search_pos = -99;\t\t \n}\n\n \nvoid\n_rl_free_history_entry (HIST_ENTRY *entry)\n{\n  if (entry == 0)\n    return;\n\n  FREE (entry->line);\n  FREE (entry->timestamp);\n\n  xfree (entry);\n}\n\n \nint\nrl_maybe_replace_line (void)\n{\n  HIST_ENTRY *temp;\n\n  temp = current_history ();\n   \n  if (temp && ((UNDO_LIST *)(temp->data) != rl_undo_list))\n    {\n      temp = replace_history_entry (where_history (), rl_line_buffer, (histdata_t)rl_undo_list);\n      xfree (temp->line);\n      FREE (temp->timestamp);\n      xfree (temp);\n    }\n  return 0;\n}\n\n \nint\nrl_maybe_unsave_line (void)\n{\n  if (_rl_saved_line_for_history)\n    {\n       \n      rl_replace_line (_rl_saved_line_for_history->line, 0);\n      rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;\n\n       \n      _rl_free_history_entry (_rl_saved_line_for_history);\n      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n      rl_point = rl_end;\t \n    }\n  else\n    rl_ding ();\n  return 0;\n}\n\n \nint\nrl_maybe_save_line (void)\n{\n  if (_rl_saved_line_for_history == 0)\n    {\n      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));\n      _rl_saved_line_for_history->line = savestring (rl_line_buffer);\n      _rl_saved_line_for_history->timestamp = (char *)NULL;\n      _rl_saved_line_for_history->data = (char *)rl_undo_list;\n    }\n\n  return 0;\n}\n\nint\n_rl_free_saved_history_line (void)\n{\n  UNDO_LIST *orig;\n\n  if (_rl_saved_line_for_history)\n    {\n      if (rl_undo_list && rl_undo_list == (UNDO_LIST *)_rl_saved_line_for_history->data)\n\trl_undo_list = 0;\n       \n      if (_rl_saved_line_for_history->data)\n\t_rl_free_undo_list ((UNDO_LIST *)_rl_saved_line_for_history->data);\n      _rl_free_history_entry (_rl_saved_line_for_history);\n      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n    }\n  return 0;\n}\n\nstatic void\n_rl_history_set_point (void)\n{\n  rl_point = (_rl_history_preserve_point && _rl_history_saved_point != -1)\n\t\t? _rl_history_saved_point\n\t\t: rl_end;\n  if (rl_point > rl_end)\n    rl_point = rl_end;\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode && _rl_keymap != vi_insertion_keymap)\n    rl_point = 0;\n#endif  \n\n  if (rl_editing_mode == emacs_mode)\n    rl_mark = (rl_point == rl_end ? 0 : rl_end);\n}\n\nvoid\nrl_replace_from_history (HIST_ENTRY *entry, int flags)\n{\n   \n  rl_replace_line (entry->line, 0);\n  rl_undo_list = (UNDO_LIST *)entry->data;\n  rl_point = rl_end;\n  rl_mark = 0;\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    {\n      rl_point = 0;\n      rl_mark = rl_end;\n    }\n#endif\n}\n\n \nvoid\n_rl_revert_previous_lines (void)\n{\n  int hpos;\n  HIST_ENTRY *entry;\n  UNDO_LIST *ul, *saved_undo_list;\n  char *lbuf;\n\n  lbuf = savestring (rl_line_buffer);\n  saved_undo_list = rl_undo_list;\n  hpos = where_history ();\n\n  entry = (hpos == history_length) ? previous_history () : current_history ();\n  while (entry)\n    {\n      if (ul = (UNDO_LIST *)entry->data)\n\t{\n\t  if (ul == saved_undo_list)\n\t    saved_undo_list = 0;\n\t   \n\t  rl_replace_from_history (entry, 0);\t \n\t  entry->data = 0;\t\t\t \n\t   \n\t  while (rl_undo_list)\n\t    rl_do_undo ();\n\t   \n\t  FREE (entry->line);\n\t  entry->line = savestring (rl_line_buffer);\n\t}\n      entry = previous_history ();\n    }\n\n   \n  rl_undo_list = saved_undo_list;\t \n  history_set_pos (hpos);\n  \n   \n  rl_replace_line (lbuf, 0);\n  _rl_set_the_line ();\n\n   \n  xfree (lbuf);\n}  \n\n \nvoid\n_rl_revert_all_lines (void)\n{\n  int pos;\n\n  pos = where_history ();\n  using_history ();\n  _rl_revert_previous_lines ();\n  history_set_pos (pos);\n}\n\n \nvoid\nrl_clear_history (void)\n{\n  HIST_ENTRY **hlist, *hent;\n  register int i;\n  UNDO_LIST *ul, *saved_undo_list;\n\n  saved_undo_list = rl_undo_list;\n  hlist = history_list ();\t\t \n\n  for (i = 0; i < history_length; i++)\n    {\n      hent = hlist[i];\n      if (ul = (UNDO_LIST *)hent->data)\n\t{\n\t  if (ul == saved_undo_list)\n\t    saved_undo_list = 0;\n\t  _rl_free_undo_list (ul);\n\t  hent->data = 0;\n\t}\n      _rl_free_history_entry (hent);\n    }\n\n  history_offset = history_length = 0;\n  rl_undo_list = saved_undo_list;\t \n}\n\n \n \n \n \n \n\n \nint\nrl_beginning_of_history (int count, int key)\n{\n  return (rl_get_previous_history (1 + where_history (), key));\n}\n\n \nint\nrl_end_of_history (int count, int key)\n{\n  rl_maybe_replace_line ();\n  using_history ();\n  rl_maybe_unsave_line ();\n  return 0;\n}\n\n \nint\nrl_get_next_history (int count, int key)\n{\n  HIST_ENTRY *temp;\n\n  if (count < 0)\n    return (rl_get_previous_history (-count, key));\n\n  if (count == 0)\n    return 0;\n\n  rl_maybe_replace_line ();\n\n   \n  if (_rl_history_saved_point == -1 && (rl_point || rl_end))\n    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;\n\n  temp = (HIST_ENTRY *)NULL;\n  while (count)\n    {\n      temp = next_history ();\n      if (!temp)\n\tbreak;\n      --count;\n    }\n\n  if (temp == 0)\n    rl_maybe_unsave_line ();\n  else\n    {\n      rl_replace_from_history (temp, 0);\n      _rl_history_set_point ();\n    }\n  return 0;\n}\n\n \nint\nrl_get_previous_history (int count, int key)\n{\n  HIST_ENTRY *old_temp, *temp;\n  int had_saved_line;\n\n  if (count < 0)\n    return (rl_get_next_history (-count, key));\n\n  if (count == 0 || history_list () == 0)\n    return 0;\n\n   \n  if (_rl_history_saved_point == -1 && (rl_point || rl_end))\n    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;\n\n   \n  had_saved_line = _rl_saved_line_for_history != 0;\n  rl_maybe_save_line ();\n\n   \n  rl_maybe_replace_line ();\n\n  temp = old_temp = (HIST_ENTRY *)NULL;\n  while (count)\n    {\n      temp = previous_history ();\n      if (temp == 0)\n\tbreak;\n\n      old_temp = temp;\n      --count;\n    }\n\n   \n  if (!temp && old_temp)\n    temp = old_temp;\n\n  if (temp == 0)\n    {\n      if (had_saved_line == 0)\n\t_rl_free_saved_history_line ();\n      rl_ding ();\n    }\n  else\n    {\n      rl_replace_from_history (temp, 0);\n      _rl_history_set_point ();\n    }\n\n  return 0;\n}\n\n \nint\nrl_fetch_history (int count, int c)\n{\n  int wanted, nhist;\n\n   \n  if (rl_explicit_arg)\n    {\n      nhist = history_base + where_history ();\n       \n      wanted = (count >= 0) ? nhist - count : -count;\n\n      if (wanted <= 0 || wanted >= nhist)\n\t{\n\t   \n\t  if (rl_editing_mode == vi_mode)\n\t    rl_ding ();\n\t  else\n\t    rl_beginning_of_history (0, 0);\n\t}\n      else\n        rl_get_previous_history (wanted, c);\n    }\n  else\n    rl_beginning_of_history (count, 0);\n\n  return (0);\n}\n\n \n\n \nstatic rl_hook_func_t *_rl_saved_internal_startup_hook = 0;\nstatic int saved_history_logical_offset = -1;\n\n#define HISTORY_FULL() (history_is_stifled () && history_length >= history_max_entries)\n\nstatic int\nset_saved_history ()\n{\n  int absolute_offset, count;\n\n  if (saved_history_logical_offset >= 0)\n    {\n      absolute_offset = saved_history_logical_offset - history_base;\n      count = where_history () - absolute_offset;\n      rl_get_previous_history (count, 0);\n    }\n  saved_history_logical_offset = -1;\n  _rl_internal_startup_hook = _rl_saved_internal_startup_hook;\n\n  return (0);\n}\n\nint\nrl_operate_and_get_next (int count, int c)\n{\n   \n  rl_newline (1, c);\n\n  saved_history_logical_offset = rl_explicit_arg ? count : where_history () + history_base + 1;\n\n  _rl_saved_internal_startup_hook = _rl_internal_startup_hook;\n  _rl_internal_startup_hook = set_saved_history;\n\n  return 0;\n}\n\n \n \n \n \n \n \nint\nrl_vi_editing_mode (int count, int key)\n{\n#if defined (VI_MODE)\n  _rl_set_insert_mode (RL_IM_INSERT, 1);\t \n  rl_editing_mode = vi_mode;\n  rl_vi_insert_mode (1, key);\n#endif  \n\n  return 0;\n}\n\nint\nrl_emacs_editing_mode (int count, int key)\n{\n  rl_editing_mode = emacs_mode;\n  _rl_set_insert_mode (RL_IM_INSERT, 1);  \n  _rl_keymap = emacs_standard_keymap;\n\n  if (_rl_show_mode_in_prompt)\n    _rl_reset_prompt ();\n\n  return 0;\n}\n\n \nvoid\n_rl_set_insert_mode (int im, int force)\n{\n#ifdef CURSOR_MODE\n  _rl_set_cursor (im, force);\n#endif\n\n  rl_insert_mode = im;\n}\n\n \nint\nrl_overwrite_mode (int count, int key)\n{\n  if (rl_explicit_arg == 0)\n    _rl_set_insert_mode (rl_insert_mode ^ 1, 0);\n  else if (count > 0)\n    _rl_set_insert_mode (RL_IM_OVERWRITE, 0);\n  else\n    _rl_set_insert_mode (RL_IM_INSERT, 0);\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}