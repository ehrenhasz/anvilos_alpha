{
  "module_name": "text.c",
  "hash_id": "313f207afe11eea1d5e4d7c7b4f686f7a4b13e22882b6490d9ea1df23d8d29bf",
  "original_prompt": "Ingested from bash-5.2.21/lib/readline/text.c",
  "human_readable_source": " \n\n \n\n#define READLINE_LIBRARY\n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif  \n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#if defined (HAVE_LOCALE_H)\n#  include <locale.h>\n#endif\n\n#include <stdio.h>\n\n \n#include \"rldefs.h\"\n#include \"rlmbutil.h\"\n\n#if defined (__EMX__)\n#  define INCL_DOSPROCESS\n#  include <os2.h>\n#endif  \n\n \n#include \"readline.h\"\n#include \"history.h\"\n\n#include \"rlprivate.h\"\n#include \"rlshell.h\"\n#include \"xmalloc.h\"\n\n \nstatic int rl_change_case (int, int);\nstatic int _rl_char_search (int, int, int);\n\n#if defined (READLINE_CALLBACKS)\nstatic int _rl_insert_next_callback (_rl_callback_generic_arg *);\nstatic int _rl_char_search_callback (_rl_callback_generic_arg *);\n#endif\n\n \n#define TEXT_COUNT_MAX\t1024\n\nint _rl_optimize_typeahead = 1;\t \n\n \n \n \n \n \n\n \nint\nrl_insert_text (const char *string)\n{\n  register int i, l;\n\n  l = (string && *string) ? strlen (string) : 0;\n  if (l == 0)\n    return 0;\n\n  if (rl_end + l >= rl_line_buffer_len)\n    rl_extend_line_buffer (rl_end + l);\n\n  for (i = rl_end; i >= rl_point; i--)\n    rl_line_buffer[i + l] = rl_line_buffer[i];\n\n  strncpy (rl_line_buffer + rl_point, string, l);\n\n   \n  if (_rl_doing_an_undo == 0)\n    {\n       \n      if ((l == 1) &&\n\t  rl_undo_list &&\n\t  (rl_undo_list->what == UNDO_INSERT) &&\n\t  (rl_undo_list->end == rl_point) &&\n\t  (rl_undo_list->end - rl_undo_list->start < 20))\n\trl_undo_list->end++;\n      else\n\trl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);\n    }\n  rl_point += l;\n  rl_end += l;\n  rl_line_buffer[rl_end] = '\\0';\n  return l;\n}\n\n \nint\nrl_delete_text (int from, int to)\n{\n  register char *text;\n  register int diff, i;\n\n   \n  if (from > to)\n    SWAP (from, to);\n\n   \n  if (to > rl_end)\n    {\n      to = rl_end;\n      if (from > to)\n\tfrom = to;\n    }\n  if (from < 0)\n    from = 0;\n\n  text = rl_copy_text (from, to);\n\n   \n  diff = to - from;\n  for (i = from; i < rl_end - diff; i++)\n    rl_line_buffer[i] = rl_line_buffer[i + diff];\n\n   \n  if (_rl_doing_an_undo == 0)\n    rl_add_undo (UNDO_DELETE, from, to, text);\n  else\n    xfree (text);\n\n  rl_end -= diff;\n  rl_line_buffer[rl_end] = '\\0';\n  _rl_fix_mark ();\n  return (diff);\n}\n\n \n\n#define _RL_FIX_POINT(x) \\\n\tdo { \\\n\tif (x > rl_end) \\\n\t  x = rl_end; \\\n\telse if (x < 0) \\\n\t  x = 0; \\\n\t} while (0)\n\nvoid\n_rl_fix_point (int fix_mark_too)\n{\n  _RL_FIX_POINT (rl_point);\n  if (fix_mark_too)\n    _RL_FIX_POINT (rl_mark);\n}\n\nvoid\n_rl_fix_mark (void)\n{\n  _RL_FIX_POINT (rl_mark);\n}\n#undef _RL_FIX_POINT\n\n \nint\n_rl_replace_text (const char *text, int start, int end)\n{\n  int n;\n\n  n = 0;\n  rl_begin_undo_group ();\n  if (start <= end)\n    rl_delete_text (start, end + 1);\n  rl_point = start;\n  if (*text)\n    n = rl_insert_text (text);\n  rl_end_undo_group ();\n\n  return n;\n}\n\n \nvoid\nrl_replace_line (const char *text, int clear_undo)\n{\n  int len;\n\n  len = strlen (text);\n  if (len >= rl_line_buffer_len)\n    rl_extend_line_buffer (len);\n  strcpy (rl_line_buffer, text);\n  rl_end = len;\n\n  if (clear_undo)\n    rl_free_undo_list ();\n\n  _rl_fix_point (1);\n}\n\n \n \n \n \n \n\n \n\n \n\n \n \n \n \n \n\n \n\n \nint\nrl_forward_byte (int count, int key)\n{\n  if (count < 0)\n    return (rl_backward_byte (-count, key));\n\n  if (count > 0)\n    {\n      int end, lend;\n\n      end = rl_point + count;\n#if defined (VI_MODE)\n      lend = rl_end > 0 ? rl_end - (VI_COMMAND_MODE()) : rl_end;\n#else\n      lend = rl_end;\n#endif\n\n      if (end > lend)\n\t{\n\t  rl_point = lend;\n\t  rl_ding ();\n\t}\n      else\n\trl_point = end;\n    }\n\n  if (rl_end < 0)\n    rl_end = 0;\n\n  return 0;\n}\n\nint\n_rl_forward_char_internal (int count)\n{\n  int point;\n\n#if defined (HANDLE_MULTIBYTE)\n  point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);\n\n#if defined (VI_MODE)\n  if (point >= rl_end && VI_COMMAND_MODE())\n    point = _rl_find_prev_mbchar (rl_line_buffer, rl_end, MB_FIND_NONZERO);\n#endif\n\n    if (rl_end < 0)\n      rl_end = 0;\n#else\n  point = rl_point + count;\n#endif\n\n  if (point > rl_end)\n    point = rl_end;\n  return (point);\n}\n\nint\n_rl_backward_char_internal (int count)\n{\n  int point;\n\n  point = rl_point;\n#if defined (HANDLE_MULTIBYTE)\n  if (count > 0)\n    {\n      while (count > 0 && point > 0)\n\t{\n\t  point = _rl_find_prev_mbchar (rl_line_buffer, point, MB_FIND_NONZERO);\n\t  count--;\n\t}\n      if (count > 0)\n        return 0;\t \n    }\n#else\n  if (count > 0)\n    point -= count;\n#endif\n\n  if (point < 0)\n    point = 0;\n  return (point);\n}\n\n#if defined (HANDLE_MULTIBYTE)\n \nint\nrl_forward_char (int count, int key)\n{\n  int point;\n\n  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n    return (rl_forward_byte (count, key));\n\n  if (count < 0)\n    return (rl_backward_char (-count, key));\n\n  if (count > 0)\n    {\n      if (rl_point == rl_end && EMACS_MODE())\n\t{\n\t  rl_ding ();\n\t  return 0;\n\t}\n\n      point = _rl_forward_char_internal (count);\n\n      if (rl_point == point)\n\trl_ding ();\n\n      rl_point = point;\n    }\n\n  return 0;\n}\n#else  \nint\nrl_forward_char (int count, int key)\n{\n  return (rl_forward_byte (count, key));\n}\n#endif  \n  \n \nint\nrl_forward (int count, int key)\n{\n  return (rl_forward_char (count, key));\n}\n\n \nint\nrl_backward_byte (int count, int key)\n{\n  if (count < 0)\n    return (rl_forward_byte (-count, key));\n\n  if (count > 0)\n    {\n      if (rl_point < count)\n\t{\n\t  rl_point = 0;\n\t  rl_ding ();\n\t}\n      else\n\trl_point -= count;\n    }\n\n  if (rl_point < 0)\n    rl_point = 0;\n\n  return 0;\n}\n\n#if defined (HANDLE_MULTIBYTE)\n \nint\nrl_backward_char (int count, int key)\n{\n  int point;\n\n  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n    return (rl_backward_byte (count, key));\n\n  if (count < 0)\n    return (rl_forward_char (-count, key));\n\n  if (count > 0)\n    {\n      point = rl_point;\n\n      while (count > 0 && point > 0)\n\t{\n\t  point = _rl_find_prev_mbchar (rl_line_buffer, point, MB_FIND_NONZERO);\n\t  count--;\n\t}\n      if (count > 0)\n\t{\n\t  rl_point = 0;\n\t  rl_ding ();\n\t}\n      else\n        rl_point = point;\n    }\n\n  return 0;\n}\n#else\nint\nrl_backward_char (int count, int key)\n{\n  return (rl_backward_byte (count, key));\n}\n#endif\n\n \nint\nrl_backward (int count, int key)\n{\n  return (rl_backward_char (count, key));\n}\n\n \nint\nrl_beg_of_line (int count, int key)\n{\n  rl_point = 0;\n  return 0;\n}\n\n \nint\nrl_end_of_line (int count, int key)\n{\n  rl_point = rl_end;\n  return 0;\n}\n\n \nint\nrl_forward_word (int count, int key)\n{\n  int c;\n\n  if (count < 0)\n    return (rl_backward_word (-count, key));\n\n  while (count)\n    {\n      if (rl_point > rl_end)\n\trl_point = rl_end;\n      if (rl_point == rl_end)\n\treturn 0;\n\n       \n      c = _rl_char_value (rl_line_buffer, rl_point);\n\n      if (_rl_walphabetic (c) == 0)\n\t{\n\t  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n\t  while (rl_point < rl_end)\n\t    {\n\t      c = _rl_char_value (rl_line_buffer, rl_point);\n\t      if (_rl_walphabetic (c))\n\t\tbreak;\n\t      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n\t    }\n\t}\n\n      if (rl_point > rl_end)\n\trl_point = rl_end;\n      if (rl_point == rl_end)\n\treturn 0;\n\n      rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n      while (rl_point < rl_end)\n\t{\n\t  c = _rl_char_value (rl_line_buffer, rl_point);\n\t  if (_rl_walphabetic (c) == 0)\n\t    break;\n\t  rl_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n\t}\n\n      --count;\n    }\n\n  return 0;\n}\n\n \nint\nrl_backward_word (int count, int key)\n{\n  int c, p;\n\n  if (count < 0)\n    return (rl_forward_word (-count, key));\n\n  while (count)\n    {\n      if (rl_point == 0)\n\treturn 0;\n\n       \n\n      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n      c = _rl_char_value (rl_line_buffer, p);\n\n      if (_rl_walphabetic (c) == 0)\n\t{\n\t  rl_point = p;\n\t  while (rl_point > 0)\n\t    {\n\t      p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n\t      c = _rl_char_value (rl_line_buffer, p);\n\t      if (_rl_walphabetic (c))\n\t\tbreak;\n\t      rl_point = p;\n\t    }\n\t}\n\n      while (rl_point)\n\t{\n\t  p = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n\t  c = _rl_char_value (rl_line_buffer, p);\t  \n\t  if (_rl_walphabetic (c) == 0)\n\t    break;\n\t  else\n\t    rl_point = p;\n\t}\n\n      --count;\n    }\n\n  return 0;\n}\n\n \nint\nrl_refresh_line (int ignore1, int ignore2)\n{\n  _rl_refresh_line ();\n  rl_display_fixed = 1;\n  return 0;\n}\n\n \nint\nrl_clear_screen (int count, int key)\n{\n  if (rl_explicit_arg)\n    {\n      rl_refresh_line (count, key);\n      return 0;\n    }\n\n  _rl_clear_screen (0);\t\t \n  rl_keep_mark_active ();\n  rl_forced_update_display ();\n  rl_display_fixed = 1;\n\n  return 0;\n}\n\nint\nrl_clear_display (int count, int key)\n{\n  _rl_clear_screen (1);\t\t \n  rl_forced_update_display ();\n  rl_display_fixed = 1;\n\n  return 0;\n}\n\nint\nrl_previous_screen_line (int count, int key)\n{\n  int c;\n\n  c = _rl_term_autowrap ? _rl_screenwidth : (_rl_screenwidth + 1);\n  return (rl_backward_char (c, key));\n}\n\nint\nrl_next_screen_line (int count, int key)\n{\n  int c;\n\n  c = _rl_term_autowrap ? _rl_screenwidth : (_rl_screenwidth + 1);\n  return (rl_forward_char (c, key));\n}\n\nint\nrl_skip_csi_sequence (int count, int key)\n{\n  int ch;\n\n  RL_SETSTATE (RL_STATE_MOREINPUT);\n  do\n    ch = rl_read_key ();\n  while (ch >= 0x20 && ch < 0x40);\n  RL_UNSETSTATE (RL_STATE_MOREINPUT);\n\n  return (ch < 0);\n}\n\nint\nrl_arrow_keys (int count, int key)\n{\n  int ch;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  ch = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n  if (ch < 0)\n    return (1);\n\n  switch (_rl_to_upper (ch))\n    {\n    case 'A':\n      rl_get_previous_history (count, ch);\n      break;\n\n    case 'B':\n      rl_get_next_history (count, ch);\n      break;\n\n    case 'C':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_forward_char (count, ch);\n      else\n\trl_forward_byte (count, ch);\n      break;\n\n    case 'D':\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_backward_char (count, ch);\n      else\n\trl_backward_byte (count, ch);\n      break;\n\n    default:\n      rl_ding ();\n    }\n\n  return 0;\n}\n\n \n \n \n \n \n\n#ifdef HANDLE_MULTIBYTE\nstatic char pending_bytes[MB_LEN_MAX];\nstatic int pending_bytes_length = 0;\nstatic mbstate_t ps = {0};\n#endif\n\n \nint\n_rl_insert_char (int count, int c)\n{\n  register int i;\n  char *string;\n#ifdef HANDLE_MULTIBYTE\n  int string_size;\n  char incoming[MB_LEN_MAX + 1];\n  int incoming_length = 0;\n  mbstate_t ps_back;\n  static int stored_count = 0;\n#endif\n\n  if (count <= 0)\n    return 0;\n\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n    {\n      incoming[0] = c;\n      incoming[1] = '\\0';\n      incoming_length = 1;\n    }\n  else if (_rl_utf8locale && (c & 0x80) == 0)\n    {\n      incoming[0] = c;\n      incoming[1] = '\\0';\n      incoming_length = 1;\n    }\n  else\n    {\n      WCHAR_T wc;\n      size_t ret;\n\n      if (stored_count <= 0)\n\tstored_count = count;\n      else\n\tcount = stored_count;\n\n      ps_back = ps;\n      pending_bytes[pending_bytes_length++] = c;\n      ret = MBRTOWC (&wc, pending_bytes, pending_bytes_length, &ps);\n\n      if (ret == (size_t)-2)\n\t{\n\t   \n\t  ps = ps_back;\n\t  return 1;\n\t}\n      else if (ret == (size_t)-1)\n\t{\n\t   \n\t  incoming[0] = pending_bytes[0];\n\t  incoming[1] = '\\0';\n\t  incoming_length = 1;\n\t  pending_bytes_length--;\n\t  memmove (pending_bytes, pending_bytes + 1, pending_bytes_length);\n\t   \n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t}\n      else if (ret == (size_t)0)\n\t{\n\t  incoming[0] = '\\0';\n\t  incoming_length = 0;\n\t  pending_bytes_length--;\n\t   \n\t  memset (&ps, 0, sizeof (mbstate_t));\n\t}\n      else if (ret == 1)\n\t{\n\t  incoming[0] = pending_bytes[0];\n\t  incoming[incoming_length = 1] = '\\0';\n\t  pending_bytes_length = 0;\n\t}\n      else\n\t{\n\t   \n\t  memcpy (incoming, pending_bytes, pending_bytes_length);\n\t  incoming[pending_bytes_length] = '\\0';\n\t  incoming_length = pending_bytes_length;\n\t  pending_bytes_length = 0;\n\t}\n    }\n#endif  \n\t  \n   \n  if (count > 1 && count <= TEXT_COUNT_MAX)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      string_size = count * incoming_length;\n      string = (char *)xmalloc (1 + string_size);\n\n      i = 0;\n      while (i < string_size)\n\t{\n\t  if (incoming_length == 1)\n\t    string[i++] = *incoming;\n\t  else\n\t    {\n\t      strncpy (string + i, incoming, incoming_length);\n\t      i += incoming_length;\n\t    }\n\t}\n      incoming_length = 0;\n      stored_count = 0;\n#else  \n      string = (char *)xmalloc (1 + count);\n\n      for (i = 0; i < count; i++)\n\tstring[i] = c;\n#endif  \n\n      string[i] = '\\0';\n      rl_insert_text (string);\n      xfree (string);\n\n      return 0;\n    }\n\n  if (count > TEXT_COUNT_MAX)\n    {\n      int decreaser;\n#if defined (HANDLE_MULTIBYTE)\n      string_size = incoming_length * TEXT_COUNT_MAX;\n      string = (char *)xmalloc (1 + string_size);\n\n      i = 0;\n      while (i < string_size)\n\t{\n\t  if (incoming_length == 1)\n\t    string[i++] = *incoming;\n\t  else\n\t    {\n\t      strncpy (string + i, incoming, incoming_length);\n\t      i += incoming_length;\n\t    }\n\t}\n\n      while (count)\n\t{\n\t  decreaser = (count > TEXT_COUNT_MAX) ? TEXT_COUNT_MAX : count;\n\t  string[decreaser*incoming_length] = '\\0';\n\t  rl_insert_text (string);\n\t  count -= decreaser;\n\t}\n\n      xfree (string);\n      incoming_length = 0;\n      stored_count = 0;\n#else  \n      char str[TEXT_COUNT_MAX+1];\n\n      for (i = 0; i < TEXT_COUNT_MAX; i++)\n\tstr[i] = c;\n\n      while (count)\n\t{\n\t  decreaser = (count > TEXT_COUNT_MAX ? TEXT_COUNT_MAX : count);\n\t  str[decreaser] = '\\0';\n\t  rl_insert_text (str);\n\t  count -= decreaser;\n\t}\n#endif  \n\n      return 0;\n    }\n\n  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n    {\n       \n      if ((RL_ISSTATE (RL_STATE_MACROINPUT) == 0) && _rl_pushed_input_available ())\n\t_rl_insert_typein (c);\n      else\n\t{\n\t   \n\t  char str[2];\n\n\t  str[1] = '\\0';\n\t  str[0] = c;\n\t  rl_insert_text (str);\n\t}\n    }\n#if defined (HANDLE_MULTIBYTE)\n  else\n    {\n      rl_insert_text (incoming);\n      stored_count = 0;\n    }\n#endif\n\n  return 0;\n}\n\n \nint\n_rl_overwrite_char (int count, int c)\n{\n  int i;\n#if defined (HANDLE_MULTIBYTE)\n  char mbkey[MB_LEN_MAX];\n  int k;\n\n   \n  k = 1;\n  if (count > 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    k = _rl_read_mbstring (c, mbkey, MB_LEN_MAX);\n  if (k < 0)\n    return 1;\n#endif\n\n  rl_begin_undo_group ();\n\n  for (i = 0; i < count; i++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_insert_text (mbkey);\n      else\n#endif\n\t_rl_insert_char (1, c);\n\n      if (rl_point < rl_end)\n\trl_delete (1, c);\n    }\n\n  rl_end_undo_group ();\n\n  return 0;\n}\n\nint\nrl_insert (int count, int c)\n{\n  int r, n, x;\n\n  r = (rl_insert_mode == RL_IM_INSERT) ? _rl_insert_char (count, c) : _rl_overwrite_char (count, c);\n\n   \n  x = 0;\n  n = (unsigned short)-2;\n  while (_rl_optimize_typeahead &&\n\t rl_num_chars_to_read == 0 &&\n\t (RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n\t _rl_pushed_input_available () == 0 &&\n\t _rl_input_queued (0) &&\n\t (n = rl_read_key ()) > 0 &&\n\t _rl_keymap[(unsigned char)n].type == ISFUNC &&\n\t _rl_keymap[(unsigned char)n].function == rl_insert)\n    {\n      r = (rl_insert_mode == RL_IM_INSERT) ? _rl_insert_char (1, n) : _rl_overwrite_char (1, n);\n       \n      n = (unsigned short)-2;\n      x++;\t\t \n      if (r == 1)\t \n\tcontinue;\n      if (rl_done || r != 0)\n\tbreak;\n    }\n\n  if (n != (unsigned short)-2)\t\t \n    {\n       \n      rl_last_func = rl_insert; \n      _rl_reset_argument ();\n      rl_executing_keyseq[rl_key_sequence_length = 0] = '\\0';\n      r = rl_execute_next (n);\n    }\n\n  return r;\n}\n\n \nstatic int\n_rl_insert_next (int count)\n{\n  int c;\n\n  RL_SETSTATE(RL_STATE_MOREINPUT);\n  c = rl_read_key ();\n  RL_UNSETSTATE(RL_STATE_MOREINPUT);\n\n  if (c < 0)\n    return 1;\n\n  if (RL_ISSTATE (RL_STATE_MACRODEF))\n    _rl_add_macro_char (c);\n\n#if defined (HANDLE_SIGNALS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n    _rl_restore_tty_signals ();\n#endif\n\n  return (_rl_insert_char (count, c));  \n}\n\n#if defined (READLINE_CALLBACKS)\nstatic int\n_rl_insert_next_callback (_rl_callback_generic_arg *data)\n{\n  int count, r;\n\n  count = data->count;\n  r = 0;\n\n  if (count < 0)\n    {\n      data->count++;\n      r = _rl_insert_next (1);\n      _rl_want_redisplay = 1;\n       \n      if (data->count < 0 && r == 0)\n\treturn r;\n      count = 0;\t \n    }\n\n   \n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n\n  if (count == 0)\n    return r;\n\n  return _rl_insert_next (count);\n}\n#endif\n  \nint\nrl_quoted_insert (int count, int key)\n{\n   \n#if defined (HANDLE_SIGNALS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n    _rl_disable_tty_signals ();\n#endif\n\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_callback_data = _rl_callback_data_alloc (count);\n      _rl_callback_func = _rl_insert_next_callback;\n      return (0);\n    }\n#endif\n\n   \n  if (count < 0)\n    {\n      int r;\n\n      do\n\tr = _rl_insert_next (1);\n      while (r == 0 && ++count < 0);\n      return r;\n    }\n\n  return _rl_insert_next (count);\n}\n\n \nint\nrl_tab_insert (int count, int key)\n{\n  return (_rl_insert_char (count, '\\t'));\n}\n\n \nint\nrl_newline (int count, int key)\n{\n  if (rl_mark_active_p ())\n    {\n      rl_deactivate_mark ();\n      (*rl_redisplay_function) ();\n      _rl_want_redisplay = 0;\n    }\n\n  rl_done = 1;\n\n  if (_rl_history_preserve_point)\n    _rl_history_saved_point = (rl_point == rl_end) ? -1 : rl_point;\n\n  RL_SETSTATE(RL_STATE_DONE);\n\n#if defined (VI_MODE)\n  if (rl_editing_mode == vi_mode)\n    {\n      _rl_vi_done_inserting ();\n      if (_rl_vi_textmod_command (_rl_vi_last_command) == 0)\t \n\t_rl_vi_reset_last ();\n    }\n#endif  \n\n   \n  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)\n    return 0;\n\n  if (_rl_echoing_p)\n    _rl_update_final ();\n  return 0;\n}\n\n \nint\nrl_do_lowercase_version (int ignore1, int ignore2)\n{\n  return 99999;\t\t \n}\n\n \nint\n_rl_overwrite_rubout (int count, int key)\n{\n  int opoint;\n  int i, l;\n\n  if (rl_point == 0)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  opoint = rl_point;\n\n   \n  for (i = l = 0; i < count; i++)\n    {\n      rl_backward_char (1, key);\n      l += rl_character_len (rl_line_buffer[rl_point], rl_point);\t \n    }\n\n  rl_begin_undo_group ();\n\n  if (count > 1 || rl_explicit_arg)\n    rl_kill_text (opoint, rl_point);\n  else\n    rl_delete_text (opoint, rl_point);\n\n   \n  if (rl_point < rl_end)\n    {\n      opoint = rl_point;\n      _rl_insert_char (l, ' ');\n      rl_point = opoint;\n    }\n\n  rl_end_undo_group ();\n\n  return 0;\n}\n  \n \nint\nrl_rubout (int count, int key)\n{\n  if (count < 0)\n    return (rl_delete (-count, key));\n\n  if (!rl_point)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  if (rl_insert_mode == RL_IM_OVERWRITE)\n    return (_rl_overwrite_rubout (count, key));\n\n  return (_rl_rubout_char (count, key));\n}\n\nint\n_rl_rubout_char (int count, int key)\n{\n  int orig_point;\n  unsigned char c;\n\n   \n  if (count < 0)\n    return (rl_delete (-count, key));\n\n  if (rl_point == 0)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  orig_point = rl_point;\n  if (count > 1 || rl_explicit_arg)\n    {\n      rl_backward_char (count, key);\n      rl_kill_text (orig_point, rl_point);\n    }\n  else if (MB_CUR_MAX == 1 || rl_byte_oriented)\n    {\n      c = rl_line_buffer[--rl_point];\n      rl_delete_text (rl_point, orig_point);\n       \n      if (rl_point == rl_end && ISPRINT ((unsigned char)c) && _rl_last_c_pos)\n\t{\n\t  int l;\n\t  l = rl_character_len (c, rl_point);\n\t  _rl_erase_at_end_of_line (l);\n\t}\n    }\n  else\n    {\n      rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n      rl_delete_text (rl_point, orig_point);\n    }\n\n  return 0;\n}\n\n \nint\nrl_delete (int count, int key)\n{\n  int xpoint;\n\n  if (count < 0)\n    return (_rl_rubout_char (-count, key));\n\n  if (rl_point == rl_end)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  if (count > 1 || rl_explicit_arg)\n    {\n      xpoint = rl_point;\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\trl_forward_char (count, key);\n      else\n\trl_forward_byte (count, key);\n\n      rl_kill_text (xpoint, rl_point);\n      rl_point = xpoint;\n    }\n  else\n    {\n      xpoint = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n      rl_delete_text (rl_point, xpoint);\n    }\n  return 0;\n}\n\n       \nint\nrl_rubout_or_delete (int count, int key)\n{\n  if (rl_end != 0 && rl_point == rl_end)\n    return (_rl_rubout_char (count, key));\n  else\n    return (rl_delete (count, key));\n}  \n\n \nint\nrl_delete_horizontal_space (int count, int ignore)\n{\n  int start;\n\n  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))\n    rl_point--;\n\n  start = rl_point;\n\n  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n    rl_point++;\n\n  if (start != rl_point)\n    {\n      rl_delete_text (start, rl_point);\n      rl_point = start;\n    }\n\n  if (rl_point < 0)\n    rl_point = 0;\n\n  return 0;\n}\n\n \nint\nrl_delete_or_show_completions (int count, int key)\n{\n  if (rl_end != 0 && rl_point == rl_end)\n    return (rl_possible_completions (count, key));\n  else\n    return (rl_delete (count, key));\n}\n\n#ifndef RL_COMMENT_BEGIN_DEFAULT\n#define RL_COMMENT_BEGIN_DEFAULT \"#\"\n#endif\n\n \nint\nrl_insert_comment (int count, int key)\n{\n  char *rl_comment_text;\n  int rl_comment_len;\n\n  rl_beg_of_line (1, key);\n  rl_comment_text = _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT;\n\n  if (rl_explicit_arg == 0)\n    rl_insert_text (rl_comment_text);\n  else\n    {\n      rl_comment_len = strlen (rl_comment_text);\n      if (STREQN (rl_comment_text, rl_line_buffer, rl_comment_len))\n\trl_delete_text (rl_point, rl_point + rl_comment_len);\n      else\n\trl_insert_text (rl_comment_text);\n    }\n\n  (*rl_redisplay_function) ();\n  rl_newline (1, '\\n');\n\n  return (0);\n}\n\n \n \n \n \n \n\n \n#define UpCase 1\n#define DownCase 2\n#define CapCase 3\n\n \nint\nrl_upcase_word (int count, int key)\n{\n  return (rl_change_case (count, UpCase));\n}\n\n \nint\nrl_downcase_word (int count, int key)\n{\n  return (rl_change_case (count, DownCase));\n}\n\n \nint\nrl_capitalize_word (int count, int key)\n{\n return (rl_change_case (count, CapCase));\n}\n\n \nstatic int\nrl_change_case (int count, int op)\n{\n  int start, next, end;\n  int inword, nc, nop;\n  WCHAR_T c;\n#if defined (HANDLE_MULTIBYTE)\n  WCHAR_T wc, nwc;\n  char mb[MB_LEN_MAX+1];\n  int mlen;\n  size_t m;\n  mbstate_t mps;\n#endif\n\n  start = rl_point;\n  rl_forward_word (count, 0);\n  end = rl_point;\n\n  if (op != UpCase && op != DownCase && op != CapCase)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  if (count < 0)\n    SWAP (start, end);\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (&mps, 0, sizeof (mbstate_t));\n#endif\n\n   \n  rl_modifying (start, end);\n\n  inword = 0;\n  while (start < end)\n    {\n      c = _rl_char_value (rl_line_buffer, start);\n       \n      next = MB_NEXTCHAR (rl_line_buffer, start, 1, MB_FIND_NONZERO);\n\n      if (_rl_walphabetic (c) == 0)\n\t{\n\t  inword = 0;\n\t  start = next;\n\t  continue;\n\t}\n\n      if (op == CapCase)\n\t{\n\t  nop = inword ? DownCase : UpCase;\n\t  inword = 1;\n\t}\n      else\n\tnop = op;\n       \n      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n\t{\n\t  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);\n\t  rl_line_buffer[start] = nc;\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      else\n\t{\n\t  m = MBRTOWC (&wc, rl_line_buffer + start, end - start, &mps);\n\t  if (MB_INVALIDCH (m))\n\t    wc = (WCHAR_T)rl_line_buffer[start];\n\t  else if (MB_NULLWCH (m))\n\t    wc = L'\\0';\n\t  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);\n\t  if  (nwc != wc)\t \n\t    {\n\t      char *s, *e;\n\t      mbstate_t ts;\n\n\t      memset (&ts, 0, sizeof (mbstate_t));\n\t      mlen = WCRTOMB (mb, nwc, &ts);\n\t      if (mlen < 0)\n\t\t{\n\t\t  nwc = wc;\n\t\t  memset (&ts, 0, sizeof (mbstate_t));\n\t\t  mlen = WCRTOMB (mb, nwc, &ts);\n\t\t  if (mlen < 0)\t\t \n\t\t    strncpy (mb, rl_line_buffer + start, mlen = m);\n\t\t}\n\t      if (mlen > 0)\n\t\tmb[mlen] = '\\0';\n\t       \n\t       \n\t      s = rl_line_buffer + start;\n\t      e = rl_line_buffer + rl_end;\n\t      if (m == mlen)\n\t\tmemcpy (s, mb, mlen);\n\t      else if (m > mlen)\n\t\t{\n\t\t  memcpy (s, mb, mlen);\n\t\t  memmove (s + mlen, s + m, (e - s) - m);\n\t\t  next -= m - mlen;\t \n\t\t  end -= m - mlen;\t \n\t\t  rl_end -= m - mlen;\t \n\t\t  rl_line_buffer[rl_end] = 0;\n\t\t}\n\t      else if (m < mlen)\n\t\t{\n\t\t  rl_extend_line_buffer (rl_end + mlen + (e - s) - m + 2);\n\t\t  s = rl_line_buffer + start;\t \n\t\t  e = rl_line_buffer + rl_end;\n\t\t  memmove (s + mlen, s + m, (e - s) - m);\n\t\t  memcpy (s, mb, mlen);\n\t\t  next += mlen - m;\t \n\t\t  end += mlen - m;\t \n\t\t  rl_end += mlen - m;\t \n\t\t  rl_line_buffer[rl_end] = 0;\n\t\t}\n\t    }\n\t}\n#endif\n\n      start = next;\n    }\n\n  rl_point = end;\n  return 0;\n}\n\n \n \n \n \n \n\n \nint\nrl_transpose_words (int count, int key)\n{\n  char *word1, *word2;\n  int w1_beg, w1_end, w2_beg, w2_end;\n  int orig_point, orig_end;\n\n  orig_point = rl_point;\n  orig_end = rl_end;\n\n  if (!count)\n    return 0;\n\n   \n  rl_forward_word (count, key);\n  w2_end = rl_point;\n  rl_backward_word (1, key);\n  w2_beg = rl_point;\n  rl_backward_word (count, key);\n  w1_beg = rl_point;\n  rl_forward_word (1, key);\n  w1_end = rl_point;\n\n   \n  if ((w1_beg == w2_beg) || (w2_beg < w1_end))\n    {\n      rl_ding ();\n      rl_point = orig_point;\n      return 1;\n    }\n\n   \n  word1 = rl_copy_text (w1_beg, w1_end);\n  word2 = rl_copy_text (w2_beg, w2_end);\n\n   \n  rl_begin_undo_group ();\n\n   \n  rl_point = w2_beg;\n  rl_delete_text (w2_beg, w2_end);\n  rl_insert_text (word1);\n\n  rl_point = w1_beg;\n  rl_delete_text (w1_beg, w1_end);\n  rl_insert_text (word2);\n\n   \n  rl_point = w2_end;\n  rl_end = orig_end;\t\t \n\n   \n  rl_end_undo_group ();\n  xfree (word1);\n  xfree (word2);\n\n  return 0;\n}\n\n \nint\nrl_transpose_chars (int count, int key)\n{\n#if defined (HANDLE_MULTIBYTE)\n  char *dummy;\n  int i;\n#else\n  char dummy[2];\n#endif\n  int char_length, prev_point;\n\n  if (count == 0)\n    return 0;\n\n  if (!rl_point || rl_end < 2)\n    {\n      rl_ding ();\n      return 1;\n    }\n\n  rl_begin_undo_group ();\n\n  if (rl_point == rl_end)\n    {\n      rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n      count = 1;\n    }\n\n  prev_point = rl_point;\n  rl_point = MB_PREVCHAR (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n\n#if defined (HANDLE_MULTIBYTE)\n  char_length = prev_point - rl_point;\n  dummy = (char *)xmalloc (char_length + 1);\n  for (i = 0; i < char_length; i++)\n    dummy[i] = rl_line_buffer[rl_point + i];\n  dummy[i] = '\\0';\n#else\n  dummy[0] = rl_line_buffer[rl_point];\n  dummy[char_length = 1] = '\\0';\n#endif\n\n  rl_delete_text (rl_point, rl_point + char_length);\n\n  rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, count, MB_FIND_NONZERO);\n\n  _rl_fix_point (0);\n  rl_insert_text (dummy);\n  rl_end_undo_group ();\n\n#if defined (HANDLE_MULTIBYTE)\n  xfree (dummy);\n#endif\n\n  return 0;\n}\n\n \n \n \n \n \n\nint\n#if defined (HANDLE_MULTIBYTE)\n_rl_char_search_internal (int count, int dir, char *smbchar, int len)\n#else\n_rl_char_search_internal (int count, int dir, int schar)\n#endif\n{\n  int pos, inc;\n#if defined (HANDLE_MULTIBYTE)\n  int prepos;\n#endif\n\n  if (dir == 0)\n    return 1;\n\n  pos = rl_point;\n  inc = (dir < 0) ? -1 : 1;\n  while (count)\n    {\n      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))\n\t{\n\t  rl_ding ();\n\t  return 1;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      pos = (inc > 0) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)\n\t\t      : _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY);\n#else\n      pos += inc;\n#endif\n      do\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (_rl_is_mbchar_matched (rl_line_buffer, pos, rl_end, smbchar, len))\n#else\n\t  if (rl_line_buffer[pos] == schar)\n#endif\n\t    {\n\t      count--;\n\t      if (dir < 0)\n\t        rl_point = (dir == BTO) ? _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)\n\t\t\t\t\t: pos;\n\t      else\n\t\trl_point = (dir == FTO) ? _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)\n\t\t\t\t\t: pos;\n\t      break;\n\t    }\n#if defined (HANDLE_MULTIBYTE)\n\t  prepos = pos;\n#endif\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      while ((dir < 0) ? (pos = _rl_find_prev_mbchar (rl_line_buffer, pos, MB_FIND_ANY)) != prepos\n\t\t       : (pos = _rl_find_next_mbchar (rl_line_buffer, pos, 1, MB_FIND_ANY)) != prepos);\n#else\n      while ((dir < 0) ? pos-- : ++pos < rl_end);\n#endif\n    }\n  return (0);\n}\n\n \n#if defined (HANDLE_MULTIBYTE)\nstatic int\n_rl_char_search (int count, int fdir, int bdir)\n{\n  char mbchar[MB_LEN_MAX];\n  int mb_len;\n\n  mb_len = _rl_read_mbchar (mbchar, MB_LEN_MAX);\n\n  if (mb_len <= 0)\n    return 1;\n\n  if (count < 0)\n    return (_rl_char_search_internal (-count, bdir, mbchar, mb_len));\n  else\n    return (_rl_char_search_internal (count, fdir, mbchar, mb_len));\n}\n#else  \nstatic int\n_rl_char_search (int count, int fdir, int bdir)\n{\n  int c;\n\n  c = _rl_bracketed_read_key ();\n  if (c < 0)\n    return 1;\n\n  if (count < 0)\n    return (_rl_char_search_internal (-count, bdir, c));\n  else\n    return (_rl_char_search_internal (count, fdir, c));\n}\n#endif  \n\n#if defined (READLINE_CALLBACKS)\nstatic int\n_rl_char_search_callback (data)\n     _rl_callback_generic_arg *data;\n{\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n\n  return (_rl_char_search (data->count, data->i1, data->i2));\n}\n#endif\n\nint\nrl_char_search (int count, int key)\n{\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_callback_data = _rl_callback_data_alloc (count);\n      _rl_callback_data->i1 = FFIND;\n      _rl_callback_data->i2 = BFIND;\n      _rl_callback_func = _rl_char_search_callback;\n      return (0);\n    }\n#endif\n  \n  return (_rl_char_search (count, FFIND, BFIND));\n}\n\nint\nrl_backward_char_search (int count, int key)\n{\n#if defined (READLINE_CALLBACKS)\n  if (RL_ISSTATE (RL_STATE_CALLBACK))\n    {\n      _rl_callback_data = _rl_callback_data_alloc (count);\n      _rl_callback_data->i1 = BFIND;\n      _rl_callback_data->i2 = FFIND;\n      _rl_callback_func = _rl_char_search_callback;\n      return (0);\n    }\n#endif\n\n  return (_rl_char_search (count, BFIND, FFIND));\n}\n\n \n \n \n \n \n\n \nint\n_rl_set_mark_at_pos (int position)\n{\n  if (position < 0 || position > rl_end)\n    return 1;\n\n  rl_mark = position;\n  return 0;\n}\n\n \nint\nrl_set_mark (int count, int key)\n{\n  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));\n}\n\n \nint\nrl_exchange_point_and_mark (int count, int key)\n{\n  if (rl_mark > rl_end)\n    rl_mark = -1;\n\n  if (rl_mark < 0)\n    {\n      rl_ding ();\n      rl_mark = 0;\t\t \n      return 1;\n    }\n  else\n    {\n      SWAP (rl_point, rl_mark);\n      rl_activate_mark ();\n    }\n\n  return 0;\n}\n\n \n\n \nstatic int mark_active = 0;\n\n \nint _rl_keep_mark_active;\n\nvoid\nrl_keep_mark_active (void)\n{\n  _rl_keep_mark_active++;\n}\n\nvoid\nrl_activate_mark (void)\n{\n  mark_active = 1;\n  rl_keep_mark_active ();\n}\n\nvoid\nrl_deactivate_mark (void)\n{\n  mark_active = 0;\n}\n\nint\nrl_mark_active_p (void)\n{\n  return (mark_active);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}