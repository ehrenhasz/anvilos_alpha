{
  "module_name": "tparam.c",
  "hash_id": "dea0ade11e66ffbba01f37b931e5f525b103a95aaf01dbc03a9fb66f336c41b3",
  "original_prompt": "Ingested from bash-5.2.21/lib/termcap/tparam.c",
  "human_readable_source": " \n\n \n\n \n#ifdef HAVE_CONFIG_H\n#include <config.h>\n\n#ifdef HAVE_STDLIB_H \n#  include <stdlib.h>\n#else\nextern char *getenv ();\nextern char *malloc ();\nextern char *realloc ();\n#endif\n\n#if defined (HAVE_STRING_H)\n#include <string.h>\n#endif\n\n#if !defined (HAVE_BCOPY) && (defined (HAVE_STRING_H) || defined (STDC_HEADERS))\n#  define bcopy(s, d, n)\tmemcpy ((d), (s), (n))\n#endif\n\n#else  \n\n#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)\n#define bcopy(s, d, n) memcpy ((d), (s), (n))\n#endif\n\n#ifdef STDC_HEADERS\n#include <stdlib.h>\n#include <string.h>\n#else\nchar *malloc ();\nchar *realloc ();\n#endif\n\n#endif  \n\n#include \"ltcap.h\"\n\n#ifndef NULL\n#define NULL (char *) 0\n#endif\n\f\n#ifndef emacs\nstatic void\nmemory_out ()\n{\n  write (2, \"virtual memory exhausted\\n\", 25);\n  exit (1);\n}\n\nstatic char *\nxmalloc (size)\n     unsigned size;\n{\n  register char *tem = malloc (size);\n\n  if (!tem)\n    memory_out ();\n  return tem;\n}\n\nstatic char *\nxrealloc (ptr, size)\n     char *ptr;\n     unsigned size;\n{\n  register char *tem = realloc (ptr, size);\n\n  if (!tem)\n    memory_out ();\n  return tem;\n}\n#endif  \n\f\n \n\nstatic char *tparam1 ();\n\n \nchar *\ntparam (string, outstring, len, arg0, arg1, arg2, arg3)\n     char *string;\n     char *outstring;\n     int len;\n     int arg0, arg1, arg2, arg3;\n{\n  int arg[4];\n\n  arg[0] = arg0;\n  arg[1] = arg1;\n  arg[2] = arg2;\n  arg[3] = arg3;\n  return tparam1 (string, outstring, len, NULL, NULL, arg);\n}\n\n__private_extern__ char *BC;\n__private_extern__ char *UP;\n\nstatic char tgoto_buf[50];\n\n__private_extern__\nchar *\ntgoto (cm, hpos, vpos)\n     char *cm;\n     int hpos, vpos;\n{\n  int args[2];\n  if (!cm)\n    return NULL;\n  args[0] = vpos;\n  args[1] = hpos;\n  return tparam1 (cm, tgoto_buf, 50, UP, BC, args);\n}\n\nstatic char *\ntparam1 (string, outstring, len, up, left, argp)\n     char *string;\n     char *outstring;\n     int len;\n     char *up, *left;\n     register int *argp;\n{\n  register int c;\n  register char *p = string;\n  register char *op = outstring;\n  char *outend;\n  int outlen = 0;\n\n  register int tem;\n  int *old_argp = argp;\n  int doleft = 0;\n  int doup = 0;\n\n  outend = outstring + len;\n\n  while (1)\n    {\n       \n      if (op + 5 >= outend)\n\t{\n\t  register char *new;\n\t  if (outlen == 0)\n\t    {\n\t      outlen = len + 40;\n\t      new = (char *) xmalloc (outlen);\n\t      outend += 40;\n\t      bcopy (outstring, new, op - outstring);\n\t    }\n\t  else\n\t    {\n\t      outend += outlen;\n\t      outlen *= 2;\n\t      new = (char *) xrealloc (outstring, outlen);\n\t    }\n\t  op += new - outstring;\n\t  outend += new - outstring;\n\t  outstring = new;\n\t}\n      c = *p++;\n      if (!c)\n\tbreak;\n      if (c == '%')\n\t{\n\t  c = *p++;\n\t  tem = *argp;\n\t  switch (c)\n\t    {\n\t    case 'd':\t\t \n\t      if (tem < 10)\n\t\tgoto onedigit;\n\t      if (tem < 100)\n\t\tgoto twodigit;\n\t    case '3':\t\t \n\t      if (tem > 999)\n\t\t{\n\t\t  *op++ = tem / 1000 + '0';\n\t\t  tem %= 1000;\n\t\t}\n\t      *op++ = tem / 100 + '0';\n\t    case '2':\t\t \n\t    twodigit:\n\t      tem %= 100;\n\t      *op++ = tem / 10 + '0';\n\t    onedigit:\n\t      *op++ = tem % 10 + '0';\n\t      argp++;\n\t      break;\n\n\t    case 'C':\n\t       \n\t      if (tem >= 96)\n\t\t{\n\t\t  *op++ = tem / 96;\n\t\t  tem %= 96;\n\t\t}\n\t    case '+':\t\t \n\t      tem += *p++;\n\t    case '.':\t\t \n\t      if (left)\n\t\t{\n\t\t   \n\t\t  while (tem == 0 || tem == '\\n' || tem == '\\t')\n\t\t    {\n\t\t      tem++;\n\t\t      if (argp == old_argp)\n\t\t\tdoup++, outend -= strlen (up);\n\t\t      else\n\t\t\tdoleft++, outend -= strlen (left);\n\t\t    }\n\t\t}\n\t      *op++ = tem ? tem : 0200;\n\t    case 'f':\t\t \n\t      argp++;\n\t      break;\n\n\t    case 'b':\t\t \n\t      argp--;\n\t      break;\n\n\t    case 'r':\t\t \n\t      argp[0] = argp[1];\n\t      argp[1] = tem;\n\t      old_argp++;\n\t      break;\n\n\t    case '>':\t\t \n\t      if (argp[0] > *p++)  \n\t\targp[0] += *p;\t \n\t      p++;\t\t \n\t      break;\n\n\t    case 'a':\t\t \n\t       \n\t       \n\t       \n\t      tem = p[2] & 0177;\n\t      if (p[1] == 'p')\n\t\ttem = argp[tem - 0100];\n\t      if (p[0] == '-')\n\t\targp[0] -= tem;\n\t      else if (p[0] == '+')\n\t\targp[0] += tem;\n\t      else if (p[0] == '*')\n\t\targp[0] *= tem;\n\t      else if (p[0] == '/')\n\t\targp[0] /= tem;\n\t      else\n\t\targp[0] = tem;\n\n\t      p += 3;\n\t      break;\n\n\t    case 'i':\t\t \n\t      argp[0] ++;\t \n\t      argp[1] ++;\t \n\t      break;\n\n\t    case '%':\t\t \n\t      goto ordinary;\n\n\t    case 'n':\t\t \n\t      argp[0] ^= 0140;\n\t      argp[1] ^= 0140;\n\t      break;\n\n\t    case 'm':\t\t \n\t      argp[0] ^= 0177;\n\t      argp[1] ^= 0177;\n\t      break;\n\n\t    case 'B':\t\t \n\t      argp[0] += 6 * (tem / 10);\n\t      break;\n\n\t    case 'D':\t\t \n\t      argp[0] -= 2 * (tem % 16);\n\t      break;\n\t    }\n\t}\n      else\n\t \n      ordinary:\n\t*op++ = c;\n    }\n  *op = 0;\n  while (doup-- > 0)\n    strcat (op, up);\n  while (doleft-- > 0)\n    strcat (op, left);\n  return outstring;\n}\n\f\n#ifdef DEBUG\n\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  char buf[50];\n  int args[3];\n  args[0] = atoi (argv[2]);\n  args[1] = atoi (argv[3]);\n  args[2] = atoi (argv[4]);\n  tparam1 (argv[1], buf, \"LEFT\", \"UP\", args);\n  printf (\"%s\\n\", buf);\n  return 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}