{
  "module_name": "termcap.c",
  "hash_id": "2d6c7a7db172e5d3cc7b554a2ae9be819ed147137c5e51a3ec3d379806ada604",
  "original_prompt": "Ingested from bash-5.2.21/lib/termcap/termcap.c",
  "human_readable_source": " \n\n \n\n \n#ifdef HAVE_CONFIG_H\n\n#include <config.h>\n\n \n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n\n#include <fcntl.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n#else\nextern char *getenv ();\nextern char *malloc ();\nextern char *realloc ();\n#endif\n\n#if defined (HAVE_STRING_H)\n#include <string.h>\n#endif\n\n#if !defined (HAVE_BCOPY) && (defined (HAVE_STRING_H) || defined (STDC_HEADERS))\n#  define bcopy(s, d, n)\tmemcpy ((d), (s), (n))\n#endif\n\n#else  \n\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#else\nchar *getenv ();\nchar *malloc ();\nchar *realloc ();\n#endif\n\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n \n#if (defined(HAVE_STRING_H) || defined(STDC_HEADERS)) && !defined(bcopy)\n#define bcopy(s, d, n) memcpy ((d), (s), (n))\n#endif\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef _POSIX_VERSION\n#include <fcntl.h>\n#endif\n\n#endif  \n\n#ifndef NULL\n#define NULL (char *) 0\n#endif\n\n#ifndef O_RDONLY\n#define O_RDONLY 0\n#endif\n\n \n\n#ifndef BUFSIZE\n#ifdef DEBUG\n#define BUFSIZE bufsize\n\nint bufsize = 128;\n#else\n#define BUFSIZE 2048\n#endif\n#endif\n\n#include \"ltcap.h\"\n\n#ifndef TERMCAP_FILE\n#define TERMCAP_FILE \"/etc/termcap\"\n#endif\n\n#ifndef emacs\nstatic void\nmemory_out ()\n{\n  write (2, \"virtual memory exhausted\\n\", 25);\n  exit (1);\n}\n\nstatic char *\nxmalloc (size)\n     unsigned size;\n{\n  register char *tem = malloc (size);\n\n  if (!tem)\n    memory_out ();\n  return tem;\n}\n\nstatic char *\nxrealloc (ptr, size)\n     char *ptr;\n     unsigned size;\n{\n  register char *tem = realloc (ptr, size);\n\n  if (!tem)\n    memory_out ();\n  return tem;\n}\n#endif  \n\f\n \n\n \nstatic char *term_entry;\n\nstatic char *tgetst1 ();\n\n \n\nstatic char *\nfind_capability (bp, cap)\n     register char *bp, *cap;\n{\n  for (; *bp; bp++)\n    if (bp[0] == ':'\n\t&& bp[1] == cap[0]\n\t&& bp[2] == cap[1])\n      return &bp[4];\n  return NULL;\n}\n\n__private_extern__\nint\ntgetnum (cap)\n     char *cap;\n{\n  register char *ptr = find_capability (term_entry, cap);\n  if (!ptr || ptr[-1] != '#')\n    return -1;\n  return atoi (ptr);\n}\n\n__private_extern__\nint\ntgetflag (cap)\n     char *cap;\n{\n  register char *ptr = find_capability (term_entry, cap);\n  return ptr && ptr[-1] == ':';\n}\n\n \n\n__private_extern__\nchar *\ntgetstr (cap, area)\n     char *cap;\n     char **area;\n{\n  register char *ptr = find_capability (term_entry, cap);\n  if (!ptr || (ptr[-1] != '=' && ptr[-1] != '~'))\n    return NULL;\n  return tgetst1 (ptr, area);\n}\n\n \n\nstatic char esctab[]\n  = \" \\007\\010  \\033\\014 \\\n      \\012 \\\n  \\015 \\011 \\013 \\\n        \";\n\n/* PTR points to a string value inside a termcap entry.\n   Copy that value, processing \\ and ^ abbreviations,\n   into the block that *AREA points to,\n   or to newly allocated storage if AREA is NULL.\n   Return the address to which we copied the value,\n   or NULL if PTR is NULL.  */\n\nstatic char *\ntgetst1 (ptr, area)\n     char *ptr;\n     char **area;\n{\n  register char *p, *r;\n  register int c;\n  register int size;\n  char *ret;\n  register int c1;\n\n  if (!ptr)\n    return NULL;\n\n  /* `ret' gets address of where to store the string.  */\n  if (!area)\n    {\n      /* Compute size of block needed (may overestimate).  */\n      p = ptr;\n      while ((c = *p++) && c != ':' && c != '\\n')\n\t;\n      ret = (char *) xmalloc (p - ptr + 1);\n    }\n  else\n    ret = *area;\n\n  /* Copy the string value, stopping at null or colon.\n     Also process ^ and \\ abbreviations.  */\n  p = ptr;\n  r = ret;\n  while ((c = *p++) && c != ':' && c != '\\n')\n    {\n      if (c == '^')\n\t{\n\t  c = *p++;\n\t  if (c == '?')\n\t    c = 0177;\n\t  else\n\t    c &= 037;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  c = *p++;\n\t  if (c >= '0' && c <= '7')\n\t    {\n\t      c -= '0';\n\t      size = 0;\n\n\t      while (++size < 3 && (c1 = *p) >= '0' && c1 <= '7')\n\t\t{\n\t\t  c *= 8;\n\t\t  c += c1 - '0';\n\t\t  p++;\n\t\t}\n\t    }\n\t  else if (c >= 0100 && c < 0200)\n\t    {\n\t      c1 = esctab[(c & ~040) - 0100];\n\t      if (c1 != ' ')\n\t\tc = c1;\n\t    }\n\t}\n      *r++ = c;\n    }\n  *r = '\\0';\n  /* Update *AREA.  */\n  if (area)\n    *area = r + 1;\n  return ret;\n}\n\f\n/* Outputting a string with padding.  */\n\nshort ospeed;\n/* If OSPEED is 0, we use this as the actual baud rate.  */\nint tputs_baud_rate;\n__private_extern__ char PC = '\\0';\n\n/* Actual baud rate if positive;\n   - baud rate / 100 if negative.  */\n\nstatic int speeds[] =\n  {\n#ifdef VMS\n    0, 50, 75, 110, 134, 150, -3, -6, -12, -18,\n    -20, -24, -36, -48, -72, -96, -192\n#else /* not VMS */\n    0, 50, 75, 110, 135, 150, -2, -3, -6, -12,\n    -18, -24, -48, -96, -192, -288, -384, -576, -1152\n#endif /* not VMS */\n  };\n\n__private_extern__\nint\ntputs (str, nlines, outfun)\n     register char *str;\n     int nlines;\n     register int (*outfun) ();\n{\n  register int padcount = 0;\n  register int speed;\n\n#ifdef emacs\n  extern baud_rate;\n  speed = baud_rate;\n  /* For quite high speeds, convert to the smaller\n     units to avoid overflow.  */\n  if (speed > 10000)\n    speed = - speed / 100;\n#else\n  if (ospeed == 0)\n    speed = tputs_baud_rate;\n  else if (ospeed > 0 && ospeed < (sizeof speeds / sizeof speeds[0]))\n    speed = speeds[ospeed];\n  else\n    speed = 0;\n#endif\n\n  if (!str)\n    return -1;\n\n  while (*str >= '0' && *str <= '9')\n    {\n      padcount += *str++ - '0';\n      padcount *= 10;\n    }\n  if (*str == '.')\n    {\n      str++;\n      padcount += *str++ - '0';\n    }\n  if (*str == '*')\n    {\n      str++;\n      padcount *= nlines;\n    }\n  while (*str)\n    (*outfun) (*str++);\n\n  /* PADCOUNT is now in units of tenths of msec.\n     SPEED is measured in characters per 10 seconds\n     or in characters per .1 seconds (if negative).\n     We use the smaller units for larger speeds to avoid overflow.  */\n  padcount *= speed;\n  padcount += 500;\n  padcount /= 1000;\n  if (speed < 0)\n    padcount = -padcount;\n  else\n    {\n      padcount += 50;\n      padcount /= 100;\n    }\n\n  while (padcount-- > 0)\n    (*outfun) (PC);\n\n  return 0;\n}\n\f\n/* Finding the termcap entry in the termcap data base.  */\n\nstruct buffer\n  {\n    char *beg;\n    int size;\n    char *ptr;\n    int ateof;\n    int full;\n  };\n\n/* Forward declarations of static functions.  */\n\nstatic int scan_file ();\nstatic char *gobble_line ();\nstatic int compare_contin ();\nstatic int name_match ();\n\n#ifdef VMS\n\n#include <rmsdef.h>\n#include <fab.h>\n#include <nam.h>\n\nstatic int\nvalid_filename_p (fn)\n     char *fn;\n{\n  struct FAB fab = cc$rms_fab;\n  struct NAM nam = cc$rms_nam;\n  char esa[NAM$C_MAXRSS];\n\n  fab.fab$l_fna = fn;\n  fab.fab$b_fns = strlen(fn);\n  fab.fab$l_nam = &nam;\n  fab.fab$l_fop = FAB$M_NAM;\n\n  nam.nam$l_esa = esa;\n  nam.nam$b_ess = sizeof esa;\n\n  return SYS$PARSE(&fab, 0, 0) == RMS$_NORMAL;\n}\n\n#else /* !VMS */\n\n#ifdef MSDOS /* MW, May 1993 */\nstatic int\nvalid_filename_p (fn)\n     char *fn;\n{\n  return *fn == '\\\\' || *fn == '/' ||\n    (*fn >= 'A' && *fn <= 'z' && fn[1] == ':');\n}\n#else\n#define valid_filename_p(fn) (*(fn) == '/')\n#endif\n\n#endif /* !VMS */\n\n/* Find the termcap entry data for terminal type NAME\n   and store it in the block that BP points to.\n   Record its address for future use.\n\n   If BP is null, space is dynamically allocated.\n\n   Return -1 if there is some difficulty accessing the data base\n   of terminal types,\n   0 if the data base is accessible but the type NAME is not defined\n   in it, and some other value otherwise.  */\n\n__private_extern__\nint\ntgetent (bp, name)\n     char *bp, *name;\n{\n  register char *termcap_name;\n  register int fd;\n  struct buffer buf;\n  register char *bp1;\n  char *bp2;\n  char *term;\n  int malloc_size = 0;\n  register int c;\n  char *tcenv;\t\t\t/* TERMCAP value, if it contains :tc=.  */\n  char *indirect = NULL;\t/* Terminal type in :tc= in TERMCAP value.  */\n  int filep;\n\n#ifdef INTERNAL_TERMINAL\n  /* For the internal terminal we don't want to read any termcap file,\n     so fake it.  */\n  if (!strcmp (name, \"internal\"))\n    {\n      term = INTERNAL_TERMINAL;\n      if (!bp)\n\t{\n\t  malloc_size = 1 + strlen (term);\n\t  bp = (char *) xmalloc (malloc_size);\n\t}\n      strcpy (bp, term);\n      goto ret;\n    }\n#endif /* INTERNAL_TERMINAL */\n\n  /* For compatibility with programs like `less' that want to\n     put data in the termcap buffer themselves as a fallback.  */\n  if (bp)\n    term_entry = bp;\n\n  termcap_name = getenv (\"TERMCAP\");\n  if (termcap_name && *termcap_name == '\\0')\n    termcap_name = NULL;\n#if 0\n#if defined (MSDOS) && !defined (TEST)\n  if (termcap_name && (*termcap_name == '\\\\'\n\t\t       || *termcap_name == '/'\n\t\t       || termcap_name[1] == ':'))\n    dostounix_filename(termcap_name);\n#endif\n#endif\n\n  filep = termcap_name && valid_filename_p (termcap_name);\n\n  /* If termcap_name is non-null and starts with / (in the un*x case, that is),\n     it is a file name to use instead of /etc/termcap.\n     If it is non-null and does not start with /,\n     it is the entry itself, but only if\n     the name the caller requested matches the TERM variable.  */\n\n  if (termcap_name && !filep && !strcmp (name, getenv (\"TERM\")))\n    {\n      indirect = tgetst1 (find_capability (termcap_name, \"tc\"), (char **) 0);\n      if (!indirect)\n\t{\n\t  if (!bp)\n\t    bp = termcap_name;\n\t  else\n\t    strcpy (bp, termcap_name);\n\t  goto ret;\n\t}\n      else\n\t{\t\t\t/* It has tc=.  Need to read /etc/termcap.  */\n\t  tcenv = termcap_name;\n \t  termcap_name = NULL;\n\t}\n    }\n\n  if (!termcap_name || !filep)\n    termcap_name = TERMCAP_FILE;\n\n  /* Here we know we must search a file and termcap_name has its name.  */\n\n#ifdef MSDOS\n  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);\n#else\n  fd = open (termcap_name, O_RDONLY, 0);\n#endif\n  if (fd < 0)\n    return -1;\n\n  buf.size = BUFSIZE;\n  /* Add 1 to size to ensure room for terminating null.  */\n  buf.beg = (char *) xmalloc (buf.size + 1);\n  term = indirect ? indirect : name;\n\n  if (!bp)\n    {\n      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;\n      bp = (char *) xmalloc (malloc_size);\n    }\n  bp1 = bp;\n\n  if (indirect)\n    /* Copy the data from the environment variable.  */\n    {\n      strcpy (bp, tcenv);\n      bp1 += strlen (tcenv);\n    }\n\n  while (term)\n    {\n      /* Scan the file, reading it via buf, till find start of main entry.  */\n      if (scan_file (term, fd, &buf) == 0)\n\t{\n\t  close (fd);\n\t  free (buf.beg);\n\t  if (malloc_size)\n\t    free (bp);\n\t  return 0;\n\t}\n\n      /* Free old `term' if appropriate.  */\n      if (term != name)\n\tfree (term);\n\n      /* If BP is malloc'd by us, make sure it is big enough.  */\n      if (malloc_size)\n\t{\n\t  malloc_size = bp1 - bp + buf.size;\n\t  termcap_name = (char *) xrealloc (bp, malloc_size);\n\t  bp1 += termcap_name - bp;\n\t  bp = termcap_name;\n\t}\n\n      bp2 = bp1;\n\n      /* Copy the line of the entry from buf into bp.  */\n      termcap_name = buf.ptr;\n      while ((*bp1++ = c = *termcap_name++) && c != '\\n')\n\t/* Drop out any \\ newline sequence.  */\n\tif (c == '\\\\' && *termcap_name == '\\n')\n\t  {\n\t    bp1--;\n\t    termcap_name++;\n\t  }\n      *bp1 = '\\0';\n\n      /* Does this entry refer to another terminal type's entry?\n\t If something is found, copy it into heap and null-terminate it.  */\n      term = tgetst1 (find_capability (bp2, \"tc\"), (char **) 0);\n    }\n\n  close (fd);\n  free (buf.beg);\n\n  if (malloc_size)\n    bp = (char *) xrealloc (bp, bp1 - bp + 1);\n\n ret:\n  term_entry = bp;\n  return 1;\n}\n\n/* Given file open on FD and buffer BUFP,\n   scan the file from the beginning until a line is found\n   that starts the entry for terminal type STR.\n   Return 1 if successful, with that line in BUFP,\n   or 0 if no entry is found in the file.  */\n\nstatic int\nscan_file (str, fd, bufp)\n     char *str;\n     int fd;\n     register struct buffer *bufp;\n{\n  register char *end;\n\n  bufp->ptr = bufp->beg;\n  bufp->full = 0;\n  bufp->ateof = 0;\n  *bufp->ptr = '\\0';\n\n  lseek (fd, 0L, 0);\n\n  while (!bufp->ateof)\n    {\n      /* Read a line into the buffer.  */\n      end = NULL;\n      do\n\t{\n\t  /* if it is continued, append another line to it,\n\t     until a non-continued line ends.  */\n\t  end = gobble_line (fd, bufp, end);\n\t}\n      while (!bufp->ateof && end[-2] == '\\\\');\n\n      if (*bufp->ptr != '#'\n\t  && name_match (bufp->ptr, str))\n\treturn 1;\n\n      /* Discard the line just processed.  */\n      bufp->ptr = end;\n    }\n  return 0;\n}\n\n/* Return nonzero if NAME is one of the names specified\n   by termcap entry LINE.  */\n\nstatic int\nname_match (line, name)\n     char *line, *name;\n{\n  register char *tem;\n\n  if (!compare_contin (line, name))\n    return 1;\n  /* This line starts an entry.  Is it the right one?  */\n  for (tem = line; *tem && *tem != '\\n' && *tem != ':'; tem++)\n    if (*tem == '|' && !compare_contin (tem + 1, name))\n      return 1;\n\n  return 0;\n}\n\nstatic int\ncompare_contin (str1, str2)\n     register char *str1, *str2;\n{\n  register int c1, c2;\n  while (1)\n    {\n      c1 = *str1++;\n      c2 = *str2++;\n      while (c1 == '\\\\' && *str1 == '\\n')\n\t{\n\t  str1++;\n\t  while ((c1 = *str1++) == ' ' || c1 == '\\t');\n\t}\n      if (c2 == '\\0')\n\t{\n\t  /* End of type being looked up.  */\n\t  if (c1 == '|' || c1 == ':')\n\t    /* If end of name in data base, we win.  */\n\t    return 0;\n\t  else\n\t    return 1;\n        }\n      else if (c1 != c2)\n\treturn 1;\n    }\n}\n\n/* Make sure that the buffer <- BUFP contains a full line\n   of the file open on FD, starting at the place BUFP->ptr\n   points to.  Can read more of the file, discard stuff before\n   BUFP->ptr, or make the buffer bigger.\n\n   Return the pointer to after the newline ending the line,\n   or to the end of the file, if there is no newline to end it.\n\n   Can also merge on continuation lines.  If APPEND_END is\n   non-null, it points past the newline of a line that is\n   continued; we add another line onto it and regard the whole\n   thing as one line.  The caller decides when a line is continued.  */\n\nstatic char *\ngobble_line (fd, bufp, append_end)\n     int fd;\n     register struct buffer *bufp;\n     char *append_end;\n{\n  register char *end;\n  register int nread;\n  register char *buf = bufp->beg;\n  register char *tem;\n\n  if (!append_end)\n    append_end = bufp->ptr;\n\n  while (1)\n    {\n      end = append_end;\n      while (*end && *end != '\\n') end++;\n      if (*end)\n        break;\n      if (bufp->ateof)\n\treturn buf + bufp->full;\n      if (bufp->ptr == buf)\n\t{\n\t  if (bufp->full == bufp->size)\n\t    {\n\t      bufp->size *= 2;\n\t      /* Add 1 to size to ensure room for terminating null.  */\n\t      tem = (char *) xrealloc (buf, bufp->size + 1);\n\t      bufp->ptr = (bufp->ptr - buf) + tem;\n\t      append_end = (append_end - buf) + tem;\n\t      bufp->beg = buf = tem;\n\t    }\n\t}\n      else\n\t{\n\t  append_end -= bufp->ptr - buf;\n\t  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);\n\t  bufp->ptr = buf;\n\t}\n      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))\n\tbufp->ateof = 1;\n      bufp->full += nread;\n      buf[bufp->full] = '\\0';\n    }\n  return end + 1;\n}\n\f\n#ifdef TEST\n\n#ifdef NULL\n#undef NULL\n#endif\n\n#include <stdio.h>\n\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  char *term;\n  char *buf;\n\n  term = argv[1];\n  printf (\"TERM: %s\\n\", term);\n\n  buf = (char *) tgetent (0, term);\n  if ((int) buf <= 0)\n    {\n      printf (\"No entry.\\n\");\n      return 0;\n    }\n\n  printf (\"Entry: %s\\n\", buf);\n\n  tprint (\"cm\");\n  tprint (\"AL\");\n\n  printf (\"co: %d\\n\", tgetnum (\"co\"));\n  printf (\"am: %d\\n\", tgetflag (\"am\"));\n}\n\ntprint (cap)\n     char *cap;\n{\n  char *x = tgetstr (cap, 0);\n  register char *y;\n\n  printf (\"%s: \", cap);\n  if (x)\n    {\n      for (y = x; *y; y++)\n\tif (*y <= ' ' || *y == 0177)\n\t  printf (\"\\\\%0o\", *y);\n\telse\n\t  putchar (*y);\n      free (x);\n    }\n  else\n    printf (\"none\");\n  putchar ('\\n');\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}