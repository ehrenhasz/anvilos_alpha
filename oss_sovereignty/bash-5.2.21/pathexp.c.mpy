{
  "module_name": "pathexp.c",
  "hash_id": "3ec786b54ce86f9ce140b4f53012ea726e658784d72df6cfbc73233668589475",
  "original_prompt": "Ingested from bash-5.2.21/pathexp.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n\n#include \"shell.h\"\n#include \"pathexp.h\"\n#include \"flags.h\"\n\n#include \"shmbutil.h\"\n#include \"bashintl.h\"\n\n#include <glob/strmatch.h>\n\nstatic int glob_name_is_acceptable PARAMS((const char *));\nstatic void ignore_globbed_names PARAMS((char **, sh_ignore_func_t *));\nstatic char *split_ignorespec PARAMS((char *, int *));\n\t       \n#include <glob/glob.h>\n\n \nint glob_dot_filenames;\n\n \nint extended_glob = EXTGLOB_DEFAULT;\n\n \nint glob_star = 0;\n\n \nint\nunquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n\n  DECLARE_MBSTATE;\n\n  open = bsquote = 0;\n  send = string + strlen (string);\n\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\n\tcase '[':\n\t  open++;\n\t  continue;\n\n\tcase ']':\n\t  if (open)\t\t \n\t    return (1);\n\t  continue;\n\n\tcase '/':\n\t  if (open)\n\t    open = 0;\n\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t \n\t    return (1);\n\t  continue;\n\n\t \n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (open && *string == '/')\n\t    {\n\t      string++;\t\t \n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\t \t  \n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n\n       \n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n\n#if 0\n  return (bsquote ? 2 : 0);\n#else\n  return (0);\n#endif\n}\n\n \nstatic inline int\nere_char (c)\n     int c;\n{\n  switch (c)\n    {\n    case '.':\n    case '[':\n    case '\\\\':\n    case '(':\n    case ')':\n    case '*':\n    case '+':\n    case '?':\n    case '{':\n    case '|':\n    case '^':\n    case '$':\n      return 1;\n    default: \n      return 0;\n    }\n  return (0);\n}\n\n \nint\nglob_char_p (s)\n     const char *s;\n{\n  switch (*s)\n    {\n    case '*':\n    case '[':\n    case ']':\n    case '?':\n    case '\\\\':\n      return 1;\n    case '+':\n    case '@':\n    case '!':\n      if (s[1] == '(')\t \n\treturn 1;\n      break;\n    }\n  return 0;\n}\n\n \nchar *\nquote_string_for_globbing (pathname, qflags)\n     const char *pathname;\n     int qflags;\n{\n  char *temp;\n  register int i, j;\n  int cclass, collsym, equiv, c, last_was_backslash;\n  int savei, savej;\n\n  temp = (char *)xmalloc (2 * strlen (pathname) + 1);\n\n  if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))\n    {\n      temp[0] = '\\0';\n      return temp;\n    }\n\n  cclass = collsym = equiv = last_was_backslash = 0;\n  for (i = j = 0; pathname[i]; i++)\n    {\n       \n      if (pathname[i] == CTLESC && pathname[i+1] == '\\0')\n\t{\n\t  temp[j++] = pathname[i++];\n\t  break;\n\t}\n       \n      else if ((qflags & (QGLOB_REGEXP|QGLOB_CTLESC)) && pathname[i] == CTLESC && (pathname[i+1] == CTLESC || pathname[i+1] == CTLNUL))\n\t{\n\t  i++;\n\t  temp[j++] = pathname[i];\n\t  continue;\n\t}\n      else if (pathname[i] == CTLESC)\n\t{\nconvert_to_backslash:\n\t  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')\n\t    continue;\n\t   \n\t  if (pathname[i+1] != CTLESC && (qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)\n\t    continue;\n\t  temp[j++] = '\\\\';\n\t  i++;\n\t  if (pathname[i] == '\\0')\n\t    break;\n\t}\n      else if ((qflags & QGLOB_REGEXP) && (i == 0 || pathname[i-1] != CTLESC) && pathname[i] == '[')\t \n\t{\n\t  temp[j++] = pathname[i++];\t \n\t  savej = j;\n\t  savei = i;\n\t  c = pathname[i++];\t \n\t  if (c == '^')\t\t \n\t    {\n\t      temp[j++] = c;\n\t      c = pathname[i++];\n\t    }\n\t  if (c == ']')\t\t \n\t    {\n\t      temp[j++] = c;\n\t      c = pathname[i++];\n\t    }\n\t  do\n\t    {\n\t      if (c == 0)\n\t\tgoto endpat;\n\t      else if (c == CTLESC)\n\t\t{\n\t\t   \n\t\t   \n\t\t  if (pathname[i] == 0)\n\t\t    goto endpat;\n\t\t  temp[j++] = pathname[i++];\n\t\t}\n\t      else if (c == '[' && pathname[i] == ':')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  cclass = 1;\n\t\t}\n\t      else if (cclass && c == ':' && pathname[i] == ']')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  cclass = 0;\n\t\t}\n\t      else if (c == '[' && pathname[i] == '=')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  if (pathname[i] == ']')\n\t\t    temp[j++] = pathname[i++];\t\t \n\t\t  equiv = 1;\n\t\t}\n\t      else if (equiv && c == '=' && pathname[i] == ']')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  equiv = 0;\n\t\t}\n\t      else if (c == '[' && pathname[i] == '.')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  if (pathname[i] == ']')\n\t\t    temp[j++] = pathname[i++];\t\t \n\t\t  collsym = 1;\n\t\t}\n\t      else if (collsym && c == '.' && pathname[i] == ']')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  collsym = 0;\n\t\t}\n\t      else\n\t\ttemp[j++] = c;\n\t    }\n\t  while (((c = pathname[i++]) != ']') && c != 0);\n\n\t   \n\t  if (c == 0)\n\t    {\n\t      i = savei - 1;\t \n\t      j = savej;\n\t      continue;\n\t    }\n\n\t  temp[j++] = c;\t \n\t  i--;\t\t\t \n\t  continue;\t\t \n\t}\n      else if (pathname[i] == '\\\\' && (qflags & QGLOB_REGEXP) == 0)\n\t{\n\t   \n\n\t   \n\t  temp[j++] = '\\\\';\n\n\t  i++;\n\t  if (pathname[i] == '\\0')\n\t    break;\n\t   \n\t  if ((qflags & QGLOB_CTLESC) && pathname[i] == CTLESC && (pathname[i+1] == CTLESC || pathname[i+1] == CTLNUL))\n\t    i++;\t \n\t  else if ((qflags & QGLOB_CTLESC) && pathname[i] == CTLESC)\n\t     \n\t    goto convert_to_backslash;\n\t}\n      else if (pathname[i] == '\\\\' && (qflags & QGLOB_REGEXP))\n        last_was_backslash = 1;\n      temp[j++] = pathname[i];\n    }\nendpat:\n  temp[j] = '\\0';\n\n  return (temp);\n}\n\nchar *\nquote_globbing_chars (string)\n     const char *string;\n{\n  size_t slen;\n  char *temp, *t;\n  const char *s, *send;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n\n  temp = (char *)xmalloc (slen * 2 + 1);\n  for (t = temp, s = string; *s; )\n    {\n      if (glob_char_p (s))\n\t*t++ = '\\\\';\n\n       \n      COPY_CHAR_P (t, s, send);\n    }\n  *t = '\\0';\n  return temp;\n}\n\n \nchar **\nshell_glob_filename (pathname, qflags)\n     const char *pathname;\n     int qflags;\n{\n  char *temp, **results;\n  int gflags, quoted_pattern;\n\n  noglob_dot_filenames = glob_dot_filenames == 0;\n\n  temp = quote_string_for_globbing (pathname, QGLOB_FILENAME|qflags);\n  gflags = glob_star ? GX_GLOBSTAR : 0;\n  results = glob_filename (temp, gflags);\n  free (temp);\n\n  if (results && ((GLOB_FAILED (results)) == 0))\n    {\n      if (should_ignore_glob_matches ())\n\tignore_glob_matches (results);\n      if (results && results[0])\n\tstrvec_sort (results, 1);\t\t \n      else\n\t{\n\t  FREE (results);\n\t  results = (char **)&glob_error_return;\n\t}\n    }\n\n  return (results);\n}\n\n \n\nstatic struct ignorevar globignore =\n{\n  \"GLOBIGNORE\",\n  (struct ign *)0,\n  0,\n  (char *)0,\n  (sh_iv_item_func_t *)0,\n};\n\n \nvoid\nsetup_glob_ignore (name)\n     char *name;\n{\n  char *v;\n\n  v = get_string_value (name);\n  setup_ignore_patterns (&globignore);\n\n  if (globignore.num_ignores)\n    glob_dot_filenames = 1;\n  else if (v == 0)\n    glob_dot_filenames = 0;\n}\n\nint\nshould_ignore_glob_matches ()\n{\n  return globignore.num_ignores;\n}\n\n \nstatic int\nglob_name_is_acceptable (name)\n     const char *name;\n{\n  struct ign *p;\n  char *n;\n  int flags;\n\n   \n  n = strrchr (name, '/');\n  if (n == 0 || n[1] == 0)\n    n = (char *)name;\n  else\n    n++;\n\n  if (n[0] == '.' && (n[1] == '\\0' || (n[1] == '.' && n[2] == '\\0')))\n    return (0);\n\n  flags = FNM_PATHNAME | FNMATCH_EXTFLAG | FNMATCH_NOCASEGLOB;\n  for (p = globignore.ignores; p->val; p++)\n    {\n      if (strmatch (p->val, (char *)name, flags) != FNM_NOMATCH)\n\treturn (0);\n    }\n  return (1);\n}\n\n \n\nstatic void\nignore_globbed_names (names, name_func)\n     char **names;\n     sh_ignore_func_t *name_func;\n{\n  char **newnames;\n  int n, i;\n\n  for (i = 0; names[i]; i++)\n    ;\n  newnames = strvec_create (i + 1);\n\n  for (n = i = 0; names[i]; i++)\n    {\n      if ((*name_func) (names[i]))\n\tnewnames[n++] = names[i];\n      else\n\tfree (names[i]);\n    }\n\n  newnames[n] = (char *)NULL;\n\n  if (n == 0)\n    {\n      names[0] = (char *)NULL;\n      free (newnames);\n      return;\n    }\n\n   \n  for (n = 0; newnames[n]; n++)\n    names[n] = newnames[n];\n  names[n] = (char *)NULL;\n  free (newnames);\n}\n\nvoid\nignore_glob_matches (names)\n     char **names;\n{\n  if (globignore.num_ignores == 0)\n    return;\n\n  ignore_globbed_names (names, glob_name_is_acceptable);\n}\n\nstatic char *\nsplit_ignorespec (s, ip)\n     char *s;\n     int *ip;\n{\n  char *t;\n  int n, i;\n\n  if (s == 0)\n    return 0;\n\n  i = *ip;\n  if (s[i] == 0)\n    return 0;\n\n  n = skip_to_delim (s, i, \":\", SD_NOJMP|SD_EXTGLOB|SD_GLOB);\n  t = substring (s, i, n);\n\n  if (s[n] == ':')\n    n++;  \n  *ip = n;  \n  return t;\n}\n  \nvoid\nsetup_ignore_patterns (ivp)\n     struct ignorevar *ivp;\n{\n  int numitems, maxitems, ptr;\n  char *colon_bit, *this_ignoreval;\n  struct ign *p;\n\n  this_ignoreval = get_string_value (ivp->varname);\n\n   \n  if ((this_ignoreval && ivp->last_ignoreval && STREQ (this_ignoreval, ivp->last_ignoreval)) ||\n      (!this_ignoreval && !ivp->last_ignoreval))\n    return;\n\n   \n  ivp->num_ignores = 0;\n\n  if (ivp->ignores)\n    {\n      for (p = ivp->ignores; p->val; p++)\n\tfree(p->val);\n      free (ivp->ignores);\n      ivp->ignores = (struct ign *)NULL;\n    }\n\n  if (ivp->last_ignoreval)\n    {\n      free (ivp->last_ignoreval);\n      ivp->last_ignoreval = (char *)NULL;\n    }\n\n  if (this_ignoreval == 0 || *this_ignoreval == '\\0')\n    return;\n\n  ivp->last_ignoreval = savestring (this_ignoreval);\n\n  numitems = maxitems = ptr = 0;\n\n#if 0\n  while (colon_bit = extract_colon_unit (this_ignoreval, &ptr))\n#else\n  while (colon_bit = split_ignorespec (this_ignoreval, &ptr))\n#endif\n    {\n      if (numitems + 1 >= maxitems)\n\t{\n\t  maxitems += 10;\n\t  ivp->ignores = (struct ign *)xrealloc (ivp->ignores, maxitems * sizeof (struct ign));\n\t}\n      ivp->ignores[numitems].val = colon_bit;\n      ivp->ignores[numitems].len = strlen (colon_bit);\n      ivp->ignores[numitems].flags = 0;\n      if (ivp->item_func)\n\t(*ivp->item_func) (&ivp->ignores[numitems]);\n      numitems++;\n    }\n  ivp->ignores[numitems].val = (char *)NULL;\n  ivp->num_ignores = numitems;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}