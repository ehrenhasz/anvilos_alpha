{
  "module_name": "locale.c",
  "hash_id": "8770b01d9637e8d6959741bfec0c82d1e02a87d00e5fda8cd5bce4c8f54249b1",
  "original_prompt": "Ingested from bash-5.2.21/locale.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if HAVE_LANGINFO_CODESET\n#  include <langinfo.h>\n#endif\n\n#include \"bashintl.h\"\n#include \"bashansi.h\"\n#include <stdio.h>\n#include \"chartypes.h\"\n#include <errno.h>\n\n#include \"shell.h\"\n#include \"input.h\"\t \n\n#ifndef errno\nextern int errno;\n#endif\n\nint locale_utf8locale;\nint locale_mb_cur_max;\t \nint locale_shiftstates = 0;\n\nint singlequote_translations = 0;\t \n\nextern int dump_translatable_strings, dump_po_strings;\n\n \nstatic char *default_locale;\n\n \nstatic char *default_domain;\nstatic char *default_dir;\n\n \nstatic char *lc_all;\n\n \nstatic char *lang;\n\n \nstatic int reset_locale_vars PARAMS((void));\n\nstatic void locale_setblanks PARAMS((void));\nstatic int locale_isutf8 PARAMS((char *));\n\n \nvoid\nset_default_locale ()\n{\n#if defined (HAVE_SETLOCALE)\n  default_locale = setlocale (LC_ALL, \"\");\n  if (default_locale)\n    default_locale = savestring (default_locale);\n#else\n  default_locale = savestring (\"C\");\n#endif  \n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  locale_mb_cur_max = MB_CUR_MAX;\n  locale_utf8locale = locale_isutf8 (default_locale);\n#if defined (HANDLE_MULTIBYTE)\n  locale_shiftstates = mblen ((char *)NULL, 0);\n#else\n  locale_shiftstates = 0;\n#endif\n}\n\n \nvoid\nset_default_locale_vars ()\n{\n  char *val;\n\n#if defined (HAVE_SETLOCALE)\n\n#  if defined (LC_CTYPE)\n  val = get_string_value (\"LC_CTYPE\");\n  if (val == 0 && lc_all && *lc_all)\n    {\n      setlocale (LC_CTYPE, lc_all);\n      locale_setblanks ();\n      locale_mb_cur_max = MB_CUR_MAX;\n      locale_utf8locale = locale_isutf8 (lc_all);\n\n#    if defined (HANDLE_MULTIBYTE)\n      locale_shiftstates = mblen ((char *)NULL, 0);\n#    else\n      locale_shiftstates = 0;\n#    endif\n\n      u32reset ();\n    }\n#  endif\n\n#  if defined (LC_COLLATE)\n  val = get_string_value (\"LC_COLLATE\");\n  if (val == 0 && lc_all && *lc_all)\n    setlocale (LC_COLLATE, lc_all);\n#  endif  \n\n#  if defined (LC_MESSAGES)\n  val = get_string_value (\"LC_MESSAGES\");\n  if (val == 0 && lc_all && *lc_all)\n    setlocale (LC_MESSAGES, lc_all);\n#  endif  \n\n#  if defined (LC_NUMERIC)\n  val = get_string_value (\"LC_NUMERIC\");\n  if (val == 0 && lc_all && *lc_all)\n    setlocale (LC_NUMERIC, lc_all);\n#  endif  \n\n#  if defined (LC_TIME)\n  val = get_string_value (\"LC_TIME\");\n  if (val == 0 && lc_all && *lc_all)\n    setlocale (LC_TIME, lc_all);\n#  endif  \n\n#endif  \n\n  val = get_string_value (\"TEXTDOMAIN\");\n  if (val && *val)\n    {\n      FREE (default_domain);\n      default_domain = savestring (val);\n      if (default_dir && *default_dir)\n\tbindtextdomain (default_domain, default_dir);\n    }\n\n  val = get_string_value (\"TEXTDOMAINDIR\");\n  if (val && *val)\n    {\n      FREE (default_dir);\n      default_dir = savestring (val);\n      if (default_domain && *default_domain)\n\tbindtextdomain (default_domain, default_dir);\n    }\n}\n\n \nint\nset_locale_var (var, value)\n     char *var, *value;\n{\n  int r;\n  char *x;\n\n  x = \"\";\n  errno = 0;\n  if (var[0] == 'T' && var[10] == 0)\t\t \n    {\n      FREE (default_domain);\n      default_domain = value ? savestring (value) : (char *)NULL;\n      if (default_dir && *default_dir)\n\tbindtextdomain (default_domain, default_dir);\n      return (1);\n    }\n  else if (var[0] == 'T')\t\t\t \n    {\n      FREE (default_dir);\n      default_dir = value ? savestring (value) : (char *)NULL;\n      if (default_domain && *default_domain)\n\tbindtextdomain (default_domain, default_dir);\n      return (1);\n    }\n\n   \n\n  else if (var[3] == 'A')\t\t\t \n    {\n      FREE (lc_all);\n      if (value)\n\tlc_all = savestring (value);\n      else\n\t{\n\t  lc_all = (char *)xmalloc (1);\n\t  lc_all[0] = '\\0';\n\t}\n#if defined (HAVE_SETLOCALE)\n      r = *lc_all ? ((x = setlocale (LC_ALL, lc_all)) != 0) : reset_locale_vars ();\n      if (x == 0)\n\t{\n\t  if (errno == 0)\n\t    internal_warning(_(\"setlocale: LC_ALL: cannot change locale (%s)\"), lc_all);\n\t  else\n\t    internal_warning(_(\"setlocale: LC_ALL: cannot change locale (%s): %s\"), lc_all, strerror (errno));\n\t}\n      locale_setblanks ();\n      locale_mb_cur_max = MB_CUR_MAX;\n       \n      if (*lc_all && x)\n\tlocale_utf8locale = locale_isutf8 (lc_all);\n#  if defined (HANDLE_MULTIBYTE)\n      locale_shiftstates = mblen ((char *)NULL, 0);\n#  else\n      locale_shiftstates = 0;\n#  endif\n      u32reset ();\n      return r;\n#else\n      return (1);\n#endif\n    }\n\n#if defined (HAVE_SETLOCALE)\n  else if (var[3] == 'C' && var[4] == 'T')\t \n    {\n#  if defined (LC_CTYPE)\n      if (lc_all == 0 || *lc_all == '\\0')\n\t{\n\t  x = setlocale (LC_CTYPE, get_locale_var (\"LC_CTYPE\"));\n\t  locale_setblanks ();\n\t  locale_mb_cur_max = MB_CUR_MAX;\n\t   \n\t  if (x)\n\t    locale_utf8locale = locale_isutf8 (x);\n#if defined (HANDLE_MULTIBYTE)\n\t  locale_shiftstates = mblen ((char *)NULL, 0);\n#else\n\t  locale_shiftstates = 0;\n#endif\n\t  u32reset ();\n\t}\n#  endif\n    }\n  else if (var[3] == 'C' && var[4] == 'O')\t \n    {\n#  if defined (LC_COLLATE)\n      if (lc_all == 0 || *lc_all == '\\0')\n\tx = setlocale (LC_COLLATE, get_locale_var (\"LC_COLLATE\"));\n#  endif  \n    }\n  else if (var[3] == 'M' && var[4] == 'E')\t \n    {\n#  if defined (LC_MESSAGES)\n      if (lc_all == 0 || *lc_all == '\\0')\n\tx = setlocale (LC_MESSAGES, get_locale_var (\"LC_MESSAGES\"));\n#  endif  \n    }\n  else if (var[3] == 'N' && var[4] == 'U')\t \n    {\n#  if defined (LC_NUMERIC)\n      if (lc_all == 0 || *lc_all == '\\0')\n\tx = setlocale (LC_NUMERIC, get_locale_var (\"LC_NUMERIC\"));\n#  endif  \n    }\n  else if (var[3] == 'T' && var[4] == 'I')\t \n    {\n#  if defined (LC_TIME)\n      if (lc_all == 0 || *lc_all == '\\0')\n\tx = setlocale (LC_TIME, get_locale_var (\"LC_TIME\"));\n#  endif  \n    }\n#endif  \n  \n  if (x == 0)\n    {\n      if (errno == 0)\n\tinternal_warning(_(\"setlocale: %s: cannot change locale (%s)\"), var, get_locale_var (var));\n      else\n\tinternal_warning(_(\"setlocale: %s: cannot change locale (%s): %s\"), var, get_locale_var (var), strerror (errno));\n    }\n\n  return (x != 0);\n}\n\n \nint\nset_lang (var, value)\n     char *var, *value;\n{\n  FREE (lang);\n  if (value)\n    lang = savestring (value);\n  else\n    {\n      lang = (char *)xmalloc (1);\n      lang[0] = '\\0';\n    }\n\n  return ((lc_all == 0 || *lc_all == 0) ? reset_locale_vars () : 0);\n}\n\n \nvoid\nset_default_lang ()\n{\n  char *v;\n\n  v = get_string_value (\"LC_ALL\");\n  set_locale_var (\"LC_ALL\", v);\n\n  v = get_string_value (\"LANG\");\n  set_lang (\"LANG\", v);\n}\n\n \nchar *\nget_locale_var (var)\n     char *var;\n{\n  char *locale;\n\n  locale = lc_all;\n\n  if (locale == 0 || *locale == 0)\n    locale = get_string_value (var);\t \n  if (locale == 0 || *locale == 0)\n    locale = lang;\n  if (locale == 0 || *locale == 0)\n#if 0\n    locale = default_locale;\t \n#else\n    locale = \"\";\n#endif\n  return (locale);\n}\n\n \nstatic int\nreset_locale_vars ()\n{\n  char *t, *x;\n#if defined (HAVE_SETLOCALE)\n  if (lang == 0 || *lang == '\\0')\n    maybe_make_export_env ();\t\t \n  if (setlocale (LC_ALL, lang ? lang : \"\") == 0)\n    return 0;\n\n  x = 0;\n#  if defined (LC_CTYPE)\n  x = setlocale (LC_CTYPE, get_locale_var (\"LC_CTYPE\"));\n#  endif\n#  if defined (LC_COLLATE)\n  t = setlocale (LC_COLLATE, get_locale_var (\"LC_COLLATE\"));\n#  endif\n#  if defined (LC_MESSAGES)\n  t = setlocale (LC_MESSAGES, get_locale_var (\"LC_MESSAGES\"));\n#  endif\n#  if defined (LC_NUMERIC)\n  t = setlocale (LC_NUMERIC, get_locale_var (\"LC_NUMERIC\"));\n#  endif\n#  if defined (LC_TIME)\n  t = setlocale (LC_TIME, get_locale_var (\"LC_TIME\"));\n#  endif\n\n  locale_setblanks ();  \n  locale_mb_cur_max = MB_CUR_MAX;\n  if (x)\n    locale_utf8locale = locale_isutf8 (x);\n#  if defined (HANDLE_MULTIBYTE)\n  locale_shiftstates = mblen ((char *)NULL, 0);\n#  else\n  locale_shiftstates = 0;\n#  endif\n  u32reset ();\n#endif\n  return 1;\n}\n\n#if defined (TRANSLATABLE_STRINGS)\n \nchar *\nlocaletrans (string, len, lenp)\n     char *string;\n     int len, *lenp;\n{\n  char *locale, *t;\n  char *translated;\n  int tlen;\n\n   \n  if (string == 0 || *string == 0)\n    {\n      if (lenp)\n\t*lenp = 0;\n      return ((char *)NULL);\n    }\n\n  locale = get_locale_var (\"LC_MESSAGES\");\n\n   \n  if (locale == 0 || locale[0] == '\\0' ||\n      (locale[0] == 'C' && locale[1] == '\\0') || STREQ (locale, \"POSIX\"))\n    {\n      t = (char *)xmalloc (len + 1);\n      strcpy (t, string);\n      if (lenp)\n\t*lenp = len;\n      return (t);\n    }\n\n   \n  if (default_domain && *default_domain)\n    translated = dgettext (default_domain, string);\n  else\n    translated = string;\n\n  if (translated == string)\t \n    {\n      t = (char *)xmalloc (len + 1);\n      strcpy (t, string);\n      if (lenp)\n\t*lenp = len;\n    }\n  else\n    {\n      tlen = strlen (translated);\n      t = (char *)xmalloc (tlen + 1);\n      strcpy (t, translated);\n      if (lenp)\n\t*lenp = tlen;\n    }\n  return (t);\n}\n\n \nchar *\nmk_msgstr (string, foundnlp)\n     char *string;\n     int *foundnlp;\n{\n  register int c, len;\n  char *result, *r, *s;\n\n  for (len = 0, s = string; s && *s; s++)\n    {\n      len++;\n      if (*s == '\"' || *s == '\\\\')\n\tlen++;\n      else if (*s == '\\n')\n\tlen += 5;\n    }\n  \n  r = result = (char *)xmalloc (len + 3);\n  *r++ = '\"';\n\n  for (s = string; s && (c = *s); s++)\n    {\n      if (c == '\\n')\t \n\t{\n\t  *r++ = '\\\\';\n\t  *r++ = 'n';\n\t  *r++ = '\"';\n\t  *r++ = '\\n';\n\t  *r++ = '\"';\n\t  if (foundnlp)\n\t    *foundnlp = 1;\n\t  continue;\n\t}\n      if (c == '\"' || c == '\\\\')\n\t*r++ = '\\\\';\n      *r++ = c;\n    }\n\n  *r++ = '\"';\n  *r++ = '\\0';\n\n  return result;\n}\n\n \nchar *\nlocale_expand (string, start, end, lineno, lenp)\n     char *string;\n     int start, end, lineno, *lenp;\n{\n  int len, tlen, foundnl;\n  char *temp, *t, *t2;\n\n  temp = (char *)xmalloc (end - start + 1);\n  for (tlen = 0, len = start; len < end; )\n    temp[tlen++] = string[len++];\n  temp[tlen] = '\\0';\n\n   \n  if (dump_translatable_strings)\n    {\n      if (dump_po_strings)\n\t{\n\t  foundnl = 0;\n\t  t = mk_msgstr (temp, &foundnl);\n\t  t2 = foundnl ? \"\\\"\\\"\\n\" : \"\";\n\n\t  printf (\"#: %s:%d\\nmsgid %s%s\\nmsgstr \\\"\\\"\\n\",\n\t\t\tyy_input_name (), lineno, t2, t);\n\t  free (t);\n\t}\n      else\n\tprintf (\"\\\"%s\\\"\\n\", temp);\n\n      if (lenp)\n\t*lenp = tlen;\n      return (temp);\n    }\n  else if (*temp)\n    {\n      t = localetrans (temp, tlen, &len);\n      free (temp);\n      if (lenp)\n\t*lenp = len;\n      return (t);\n    }\n  else\n    {\n      if (lenp)\n\t*lenp = 0;\n      return (temp);\n    }\n}\n#endif\n\n \nstatic void\nlocale_setblanks ()\n{\n  int x;\n\n  for (x = 0; x < sh_syntabsiz; x++)\n    {\n      if (isblank ((unsigned char)x))\n\tsh_syntaxtab[x] |= CSHBRK|CBLANK;\n      else if (member (x, shell_break_chars))\n\t{\n\t  sh_syntaxtab[x] |= CSHBRK;\n\t  sh_syntaxtab[x] &= ~CBLANK;\n\t}\n      else\n\tsh_syntaxtab[x] &= ~(CSHBRK|CBLANK);\n    }\n}\n\n \nstatic int\nlocale_isutf8 (lspec)\n     char *lspec;\n{\n  char *cp, *encoding;\n\n#if HAVE_LANGINFO_CODESET\n  cp = nl_langinfo (CODESET);\n  return (STREQ (cp, \"UTF-8\") || STREQ (cp, \"utf8\"));\n#elif HAVE_LOCALE_CHARSET\n  cp = locale_charset ();\n  return (STREQ (cp, \"UTF-8\") || STREQ (cp, \"utf8\"));\n#else\n   \n  for (cp = lspec; *cp && *cp != '@' && *cp != '+' && *cp != ','; cp++)\n    {\n      if (*cp == '.')\n\t{\n\t  for (encoding = ++cp; *cp && *cp != '@' && *cp != '+' && *cp != ','; cp++)\n\t    ;\n\t   \n\t  if ((cp - encoding == 5 && STREQN (encoding, \"UTF-8\", 5)) ||\n\t      (cp - encoding == 4 && STREQN (encoding, \"utf8\", 4)))\n\t    return 1;\n\t  else\n\t    return 0;\n\t}\n    }\n  return 0;\n#endif\n}\n\n#if defined (HAVE_LOCALECONV)\nint\nlocale_decpoint ()\n{\n  struct lconv *lv;\n\n  lv = localeconv ();\n  return (lv && lv->decimal_point && lv->decimal_point[0]) ? lv->decimal_point[0] : '.';\n}\n#else\n#  undef locale_decpoint\nint\nlocale_decpoint ()\n{\n  return '.';\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}