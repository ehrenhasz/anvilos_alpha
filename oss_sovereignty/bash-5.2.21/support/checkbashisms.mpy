{
  "module_name": "checkbashisms",
  "hash_id": "629a6d706a5a3e86acb55bf10de71225c0ffe99a3afdf7e332f7ddddc0bc5d8d",
  "original_prompt": "Ingested from bash-5.2.21/support/checkbashisms",
  "human_readable_source": "#! /usr/bin/perl -w\n\n# This script is essentially copied from /usr/share/lintian/checks/scripts,\n# which is:\n#   Copyright (C) 1998 Richard Braakman\n#   Copyright (C) 2002 Josip Rodin\n# This version is\n#   Copyright (C) 2003 Julian Gilbey\n# \n#   This program is free software: you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation, either version 3 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nuse strict;\n\n(my $progname = $0) =~ s|.*/||;\n\nmy $usage = <<\"EOF\";\nUsage: $progname [-n] script ...\n   or: $progname --help\n   or: $progname --version\nThis script performs basic checks for the presence of bashisms\nin /bin/sh scripts.\nEOF\n\nmy $version = <<\"EOF\";\nThis is $progname, from the Debian devscripts package, version 2.10.7ubuntu5\nThis code is copyright 2003 by Julian Gilbey <jdg\\@debian.org>,\nbased on original code which is copyright 1998 by Richard Braakman\nand copyright 2002 by Josip Rodin.\nThis program comes with ABSOLUTELY NO WARRANTY.\nYou are free to redistribute this code under the terms of the\nGNU General Public License, version 3, or (at your option) any later version.\nEOF\n\nmy $opt_echo = 0;\n\n##\n## handle command-line options\n##\nif (int(@ARGV) == 0 or $ARGV[0] =~ /^(--help|-h)$/) { print $usage; exit 0; }\nif (@ARGV and $ARGV[0] =~ /^(--version|-v)$/) { print $version; exit 0; }\nif (@ARGV and $ARGV[0] =~ /^(--newline|-n)$/) { $opt_echo = 1; }\n\n\nmy $status = 0;\n\nforeach my $filename (@ARGV) {\n    if ($filename eq '-n' or $filename eq '--newline') {\n\tnext;\n    }\n    unless (open C, \"$filename\") {\n\twarn \"cannot open script $filename for reading: $!\\n\";\n\t$status |= 2;\n\tnext;\n    }\n\n    my $cat_string = \"\";\n\n    while (<C>) {\n\tif ($. == 1) { # This should be an interpreter line\n\t    if (m,^\\#!\\s*(\\S+),) {\n\t\tmy $interpreter = $1;\n\t\tif ($interpreter =~ m,/bash$,) {\n\t\t    warn \"script $filename is already a bash script; skipping\\n\";\n\t\t    $status |= 2;\n\t\t    last;  # end this file\n\t\t}\n\t\telsif ($interpreter !~ m,/(sh|ash|dash)$,) {\n\t\t    warn \"script $filename does not appear to be a /bin/sh script; skipping\\n\";\n\t\t    $status |= 2;\n\t\t    last;\n\t\t}\n\t    } else {\n\t\twarn \"script $filename does not appear to have a \\#! interpreter line;\\nyou may get strange results\\n\";\n\t    }\n\t}\n\n\tnext if m,^\\s*\\#,;  # skip comment lines\n\tchomp;\n\tmy $orig_line = $_;\n\n\ts/(?<!\\\\)\\#.*$//;   # eat comments\n\n\tif (m/(?:^|\\s+)cat\\s*\\<\\<\\s*(\\w+)/) {\n\t    $cat_string = $1;\n\t}\n\telsif ($cat_string ne \"\" and m/^$cat_string/) {\n\t    $cat_string = \"\";\n\t}\n\tmy $within_another_shell = 0;\n\tif (m,(^|\\s+)((/usr)?/bin/)?((b|d)?a|k|z|t?c)sh\\s+-c\\s*.+,) {\n\t    $within_another_shell = 1;\n\t}\n\t# if cat_string is set, we are in a HERE document and need not\n\t# check for things\n\tif ($cat_string eq \"\" and !$within_another_shell) {\n\t    my $found = 0;\n\t    my $match = '';\n\t    my $explanation = '';\n\t    my %bashisms = (\n\t\t'(?:^|\\s+)function\\s+\\w+' =>   q<'function' is useless>,\n\t\t'(?:^|\\s+)select\\s+\\w+' =>     q<'select' is not POSIX>,\n\t\t'(?:^|\\s+)source\\s+(?:\\.\\/|\\/|\\$)[^\\s]+' =>\n\t\t                               q<should be '.', not 'source'>,\n\t\t'(\\[|test|-o|-a)\\s*[^\\s]+\\s+==\\s' =>\n\t\t                               q<should be 'b = a'>,\n\t\t'\\s\\|\\&' =>                    q<pipelining is not POSIX>,\n\t\t'\\$\\[\\w+\\]' =>                 q<arithmetic not allowed>,\n\t\t'\\$\\{\\w+\\:\\d+(?::\\d+)?\\}' =>   q<${foo:3[:1]}>,\n\t\t'\\$\\{!\\w+[@*]\\}' =>            q<${!prefix[*|@]>,\n\t\t'\\$\\{!\\w+\\}' =>                q<${!name}>,\n\t\t'\\$\\{\\w+(/.+?){1,2}\\}' =>      q<${parm/?/pat[/str]}>,\n\t\t'[^\\\\\\]\\{([^\\s]+?,)+[^\\\\\\}\\s]+\\}' =>\n\t\t                               q<brace expansion>,\n\t\t'(?:^|\\s+)\\w+\\[\\d+\\]=' =>      q<bash arrays, H[0]>,\n\t\t'\\$\\{\\#?\\w+\\[[0-9\\*\\@]+\\]\\}' => q<bash arrays, ${name[0|*|@]}>,\n\t\t'(?:^|\\s+)(read\\s*(?:;|$))' => q<read without variable>,\n\t\t'\\$\\(\\([A-Za-z]' => q<cnt=$((cnt + 1)) does not work in dash>,\n\t\t'echo\\s+-[e]' =>               q<echo -e>,\n\t\t'exec\\s+-[acl]' =>             q<exec -c/-l/-a name>,\n\t\t'\\blet\\s' =>                   q<let ...>,\n\t\t'\\$RANDOM\\b' =>                q<$RANDOM>,\n\t\t'(?<!\\$)\\(\\(' =>               q<'((' should be '$(('>,\n\t    );\n\n\t    if ($opt_echo) {\n\t\t$bashisms{'echo\\s+-[n]'} = 'q<echo -n>';\n\t    }\n\n\t    while (my ($re,$expl) = each %bashisms) {\n\t\tif (m/($re)/) {\n\t\t    $found = 1;\n\t\t    $match = $1;\n\t\t    $explanation = $expl;\n\t\t    last;\n\t\t}\n\t    }\n\t    # since this test is ugly, I have to do it by itself\n\t    # detect source (.) trying to pass args to the command it runs\n\t    if (not $found and m/^\\s*(\\.\\s+[^\\s]+\\s+([^\\s]+))/) {\n\t\tif ($2 eq '&&' || $2 eq '||') {\n\t\t    # everything is ok\n\t\t    ;\n\t\t} else {\n\t\t    $found = 1;\n\t\t    $match = $1;\n\t\t}\n\t    }\n\t    unless ($found == 0) {\n\t\twarn \"possible bashism in $filename line $. ($explanation):\\n$orig_line\\n\";\n\t\t$status |= 1;\n\t    }\n\t}\n    }\n\n    close C;\n}\n\nexit $status;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}