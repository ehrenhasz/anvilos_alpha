{
  "module_name": "texi2html",
  "hash_id": "6bf8bd72814b6fe851d3e8d17a4658f2137e2ae78b829cf3e82c231dd2eea237",
  "original_prompt": "Ingested from bash-5.2.21/support/texi2html",
  "human_readable_source": "#! /usr/bin/perl\n'di ';\n'ig 00 ';\n#+##############################################################################\n#\n# texi2html: Program to transform Texinfo documents to HTML\n#\n#    Copyright (C) 1999, 2000  Free Software Foundation, Inc.\n#\n#   This program is free software: you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation, either version 3 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n#-##############################################################################\n\n# This requires perl version 5 or higher\nrequire 5.0;\n\n#++##############################################################################\n#\n# NOTE FOR DEBUGGING THIS SCRIPT:\n# You can run 'perl texi2html.pl' directly, provided you have\n# the environment variable T2H_HOME set to the directory containing\n# the texi2html.init file\n#\n#--##############################################################################\n\n# CVS version:\n# $Id: texi2html.pl,v 1.55 2000/07/27 14:39:41 obachman Exp $\n\n# Homepage:\n$T2H_HOMEPAGE = <<EOT;\nhttp://www.mathematik.uni-kl.de/~obachman/Texi2html\nEOT\n\n# Authors:  \n$T2H_AUTHORS = <<EOT;\nWritten by: Lionel Cons <Lionel.Cons\\@cern.ch> (original author)\n            Karl Berry  <karl\\@freefriends.org>\n            Olaf Bachmann <obachman\\@mathematik.uni-kl.de>\n            and many others.\nMaintained by: Olaf Bachmann <obachman\\@mathematik.uni-kl.de>\nSend bugs and suggestions to <texi2html\\@mathematik.uni-kl.de>\nEOT\n\n# Version: set in configure.in\n$THISVERSION = '1.64';\n$THISPROG = \"texi2html $THISVERSION\";\t# program name and version\n  \n# The man page for this program is included at the end of this file and can be\n# viewed using the command 'nroff -man texi2html'.\n\n# Identity:\n\n$T2H_TODAY = &pretty_date;\t\t# like \"20 September 1993\"\n# the eval prevents this from breaking on system which do not have\n# a proper getpwuid implemented\neval { ($T2H_USER = (getpwuid ($<))[6]) =~ s/,.*//;}; # Who am i\n\n#+++############################################################################\n#                                                                              #\n# Initialization                                                               #\n# Pasted content of File $(srcdir)/texi2html.init: Default initializations     # \n#                                                                              #\n#---############################################################################\n\n# leave this within comments, and keep the require statement\n# This way, you can directly run texi2html.pl, if $ENV{T2H_HOME}/texi2html.init\n# exists.\n\n# \n# -*-perl-*-\n######################################################################\n# File: texi2html.init\n#\n# Sets default values for command-line arguments and for various customizable\n# procedures\n#\n# A copy of this file is pasted into the beginning of texi2html by\n# 'make texi2html'\n#\n# Copy this file and make changes to it, if you like.\n# Afterwards, either, load it with command-line option -init_file <your_init_file>\n#\n# $Id: texi2html.init,v 1.34 2000/07/27 14:09:02 obachman Exp $\n\n######################################################################\n# stuff which can also be set by command-line options\n#\n#\n# Note: values set here, overwrite values set by the command-line\n# options before -init_file and might still be overwritten by\n# command-line arguments following the -init_file option\n#\n\n# T2H_OPTIONS is a hash whose keys are the (long) names of valid\n# command-line options and whose values are a hash with the following keys:\n# type    ==> one of !|=i|:i|=s|:s (see GetOpt::Long for more info)\n# linkage ==> ref to scalar, array, or subroutine (see GetOpt::Long for more info)\n# verbose ==> short description of option (displayed by -h)\n# noHelp  ==> if 1 -> for \"not so important options\": only print description on -h 1\n#                2 -> for obsolete options: only print description on -h 2\n\n$T2H_DEBUG = 0;\n$T2H_OPTIONS -> {debug} =\n{\n type => '=i',\n linkage => \\$main::T2H_DEBUG,\n verbose => 'output HTML with debuging information',\n};\n\n$T2H_DOCTYPE = '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">'; \n$T2H_OPTIONS -> {doctype} = \n{\n type => '=s',\n linkage => \\$main::T2H_DOCTYPE,\n verbose => 'document type which is output in header of HTML files',\n noHelp => 1\n};\n\n$T2H_CHECK = 0;\n$T2H_OPTIONS -> {check} =\n{\n type => '!',\n linkage => \\$main::T2H_CHECK,\n verbose => 'if set, only check files and output all things that may be Texinfo commands',\n noHelp => 1\n};\n\n# -expand\n# if set to \"tex\" (or, \"info\") expand @iftex and @tex (or, @ifinfo) sections\n# else, neither expand @iftex, @tex, nor @ifinfo sections\n$T2H_EXPAND = \"info\";\n$T2H_OPTIONS -> {expand} = \n{\n type => '=s',\n linkage => \\$T2H_EXPAND,\n verbose => 'Expand info|tex|none section of texinfo source',\n};\n\n# - glossary\n#if set, uses section named `Footnotes' for glossary\n$T2H_USE_GLOSSARY = 0;\nT2H_OPTIONS -> {glossary} =\n{\n type => '!',\n linkage => \\$T2H_USE_GLOSSARY,\n verbose => \"if set, uses section named `Footnotes' for glossary\",\n noHelp  => 1,\n};\n\n\n# -invisible\n# $T2H_INVISIBLE_MARK is the text used to create invisible destination\n# anchors for index links (you can for instance use the invisible.xbm\n# file shipped with this program). This is a workaround for a known\n# bug of many WWW browsers, including netscape.\n# For me, it works fine without it -- on the contrary: if there, it\n# inserts space between headers and start of text (obachman 3/99)\n$T2H_INVISIBLE_MARK = '';\n# $T2H_INVISIBLE_MARK = '&#160;';\n$T2H_OPTIONS -> {invisible} =\n{\n type => '=s',\n linkage => \\$T2H_INVISIBLE_MARK,\n verbose => 'use text in invisble anchot',\n noHelp  => 1,\n};\n\n# -iso\n# if set, ISO8879 characters are used for special symbols (like copyright, etc)\n$T2H_USE_ISO = 0;\n$T2H_OPTIONS -> {iso} =\n{\n type => 'iso',\n linkage => \\$T2H_USE_ISO,\n verbose => 'if set, ISO8879 characters are used for special symbols (like copyright, etc)',\n noHelp => 1,\n};\n\n# -I\n# list directories where @include files are searched for (besides the\n# directory of the doc file) additional '-I' args add to this list\n@T2H_INCLUDE_DIRS = (\".\");\n$T2H_OPTIONS -> {I} =\n{\n type => '=s',\n linkage => \\@T2H_INCLUDE_DIRS,\n verbose => 'append $s to the @include search path',\n};\n\n# -top_file\n# uses file of this name for top-level file\n# extension is manipulated appropriately, if necessary.\n# If empty, <basename of document>.html is used\n# Typically, you would set this to \"index.html\".\n$T2H_TOP_FILE = '';\n$T2H_OPTIONS -> {top_file} =\n{\n type => '=s',\n linkage => \\$T2H_TOP_FILE,\n verbose => 'use $s as top file, instead of <docname>.html',\n};\n\n\n# -toc_file\n# uses file of this name for table of contents file\n# extension is manipulated appropriately, if necessary.\n# If empty, <basename of document>_toc.html is used\n$T2H_TOC_FILE = '';\n$T2H_OPTIONS -> {toc_file} =\n{\n type => '=s',\n linkage => \\$T2H_TOC_FILE,\n verbose => 'use $s as ToC file, instead of <docname>_toc.html',\n};\n\n# -frames\n# if set, output two additional files which use HTML 4.0 \"frames\".\n$T2H_FRAMES = 0;\n$T2H_OPTIONS -> {frames} =\n{\n type => '!',\n linkage => \\$T2H_FRAMES,\n verbose => 'output files which use HTML 4.0 frames (experimental)',\n noHelp => 1,\n};\n\n\n# -menu | -nomenu\n# if set, show the Texinfo menus\n$T2H_SHOW_MENU = 1;\n$T2H_OPTIONS -> {menu} =\n{\n type => '!',\n linkage => \\$T2H_SHOW_MENU,\n verbose => 'ouput Texinfo menus',\n};\n\n# -number | -nonumber\n# if set, number sections and show section names and numbers in references \n# and menus\n$T2H_NUMBER_SECTIONS = 1;\n$T2H_OPTIONS -> {number} =\n{\n type => '!',\n linkage => \\$T2H_NUMBER_SECTIONS,\n verbose => 'use numbered sections'\n};\n\n# if set, and T2H_NUMBER_SECTIONS is set, then use node names in menu\n# entries, instead of section names\n$T2H_NODE_NAME_IN_MENU = 0;\n\n# if set and menu entry equals menu descr, then do not print menu descr.\n# Likewise, if node name equals entry name, do not print entry name.\n$T2H_AVOID_MENU_REDUNDANCY = 1;\n\n# -split section|chapter|none \n# if set to 'section' (resp. 'chapter') create one html file per (sub)section\n# (resp. chapter) and separate pages for Top, ToC, Overview, Index,\n# Glossary, About.\n# otherwise, create monolithic html file which contains whole document\n#$T2H_SPLIT = 'section';\n$T2H_SPLIT = '';\n$T2H_OPTIONS -> {split} =\n{\n type => '=s',\n linkage => \\$T2H_SPLIT,\n verbose => 'split document on section|chapter else no splitting',\n};\n\n# -section_navigation|-no-section_navigation\n# if set, then navigation panels are printed at the beginning of each section\n# and, possibly at the end (depending on whether or not there were more than \n# $T2H_WORDS_IN_PAGE  words on page\n# This is most useful if you do not want to have section navigation \n# on -split chapter\n$T2H_SECTION_NAVIGATION = 1;\n$T2H_OPTIONS -> {sec_nav} =\n{\n type => '!',\n linkage => \\$T2H_SECTION_NAVIGATION,\n verbose => 'output navigation panels for each section',\n};\n\n# -subdir\n# if set put result files in this directory\n# if not set result files are put into current directory\n#$T2H_SUBDIR = 'html';\n$T2H_SUBDIR = '';\n$T2H_OPTIONS -> {subdir} =\n{\n type => '=s',\n linkage => \\$T2H_SUBDIR,\n verbose => 'put HTML files in directory $s, instead of $cwd',\n};\n\n# -short_extn\n# If this is set all HTML file will have extension \".htm\" instead of\n# \".html\". This is helpful when shipping the document to PC systems.\n$T2H_SHORTEXTN = 0;\n$T2H_OPTIONS -> {short_ext} =\n{\n type => '!',\n linkage => \\$T2H_SHORTEXTN,\n verbose => 'use \"htm\" extension for output HTML files',\n};\n\n\n# -prefix\n# Set the output file prefix, prepended to all .html, .gif and .pl files.\n# By default, this is the basename of the document\n$T2H_PREFIX = '';\n$T2H_OPTIONS -> {prefix} =\n{\n type => '=s',\n linkage => \\$T2H_PREFIX,\n verbose => 'use as prefix for output files, instead of <docname>',\n};\n\n# -o filename\n# If set, generate monolithic document output html into $filename\n$T2H_OUT = '';\n$T2H_OPTIONS -> {out_file} =\n{\n type => '=s',\n linkage => sub {$main::T2H_OUT = @_[1]; $T2H_SPLIT = '';},\n verbose => 'if set, all HTML output goes into file $s',\n};\n\n# -short_ref\n#if set cross-references are given without section numbers\n$T2H_SHORT_REF = '';\n$T2H_OPTIONS -> {short_ref} =\n{\n type => '!',\n linkage => \\$T2H_SHORT_REF,\n verbose => 'if set, references are without section numbers',\n};\n\n# -idx_sum\n# if value is set, then for each @prinindex $what\n# $docu_name_$what.idx is created which contains lines of the form\n# $key\\t$ref sorted alphabetically (case matters)\n$T2H_IDX_SUMMARY = 0;\n$T2H_OPTIONS -> {idx_sum} =\n{\n type => '!',\n linkage => \\$T2H_IDX_SUMMARY,\n verbose => 'if set, also output index summary',\n noHelp  => 1,\n};\n\n# -verbose\n# if set, chatter about what we are doing\n$T2H_VERBOSE = '';\n$T2H_OPTIONS -> {Verbose} =\n{\n type => '!',\n linkage => \\$T2H_VERBOSE,\n verbose => 'print progress info to stdout',\n};\n\n# -lang\n# For page titles use $T2H_WORDS->{$T2H_LANG}->{...} as title.\n# To add a new language, supply list of titles (see $T2H_WORDS below).\n# and use ISO 639 language codes (see e.g. perl module Locale-Codes-1.02 \n# for  definitions)\n# Default's to 'en' if not set or no @documentlanguage is specified\n$T2H_LANG = '';\n$T2H_OPTIONS -> {lang} =\n{\n type => '=s',\n linkage => sub {SetDocumentLanguage($_[1])},\n verbose => 'use $s as document language (ISO 639 encoding)',\n};\n\n# -l2h\n# if set, uses latex2html for generation of math content \n$T2H_L2H = '';\n$T2H_OPTIONS -> {l2h} =\n{\n type => '!',\n linkage => \\$T2H_L2H,\n verbose => 'if set, uses latex2html for @math and @tex',\n};\n\n######################\n# The following options are only relevant if $T2H_L2H is set\n#\n# -l2h_l2h\n# name/location of latex2html progam\n$T2H_L2H_L2H = \"latex2html\";\n$T2H_OPTIONS -> {l2h_l2h} =\n{\n type => '=s',\n linkage => \\$T2H_L2H_L2H,\n verbose => 'program to use for latex2html translation',\n noHelp => 1,\n};\n\n# -l2h_skip\n# if set, skips actual call to latex2html tries to reuse previously generated \n# content, instead\n$T2H_L2H_SKIP = '';\n$T2H_OPTIONS -> {l2h_skip} =\n{\n type => '!',\n linkage => \\$T2H_L2H_SKIP,\n verbose => 'if set, tries to reuse previously latex2html output',\n noHelp => 1,\n};\n\n# -l2h_tmp\n# if set, l2h uses this directory for temporarary files. The path\n# leading to this directory may not contain a dot (i.e., a \".\"),\n# otherwise, l2h will fail\n$T2H_L2H_TMP = '';\n$T2H_OPTIONS -> {l2h_tmp} =\n{\n type => '=s',\n linkage => \\$T2H_L2H_TMP,\n verbose => 'if set, uses $s as temporary latex2html directory',\n noHelp => 1,\n};\n\n# if set, cleans intermediate files (they all have the prefix $doc_l2h_) \n# of l2h \n$T2H_L2H_CLEAN = 1;\n$T2H_OPTIONS -> {l2h_clean} =\n{\n type => '!',\n linkage => \\$T2H_L2H_CLEAN,\n verbose => 'if set, do not keep intermediate latex2html files for later reuse',\n noHelp => 1,\n};\n\n$T2H_OPTIONS -> {D} =\n{\n type => '=s',\n linkage => sub {$main::value{@_[1]} = 1;},\n verbose => 'equivalent to Texinfo \"@set $s 1\"',\n noHelp => 1,\n};\n\n$T2H_OPTIONS -> {init_file} =\n{\n type => '=s',\n linkage => \\&LoadInitFile,\n verbose => 'load init file $s'\n};\n\n\n##############################################################################\n#\n# The following can only be set in the init file\n#\n##############################################################################\n\n# if set, center @image by default\n# otherwise, do not center by default\n$T2H_CENTER_IMAGE = 1;\n\n# used as identation for block enclosing command @example, etc\n# If not empty, must be enclosed in <td></td>\n$T2H_EXAMPLE_INDENT_CELL = '<td>&nbsp;</td>';\n# same as above, only for @small\n$T2H_SMALL_EXAMPLE_INDENT_CELL = '<td>&nbsp;</td>';\n# font size for @small\n$T2H_SMALL_FONT_SIZE = '-1';\n\n# if non-empty, and no @..heading appeared in Top node, then\n# use this as header for top node/section, otherwise use value of \n# @settitle or @shorttitle (in that order)\n$T2H_TOP_HEADING = '';\n\n# if set, use this chapter for 'Index' button, else\n# use first chapter whose name matches 'index' (case insensitive)\n$T2H_INDEX_CHAPTER = '';\n\n# if set and $T2H_SPLIT is set, then split index pages at the next letter\n# after they have more than that many entries\n$T2H_SPLIT_INDEX = 100;\n\n# if set (e.g., to index.html) replace hrefs to this file \n# (i.e., to index.html) by ./\n$T2H_HREF_DIR_INSTEAD_FILE = '';\n\n########################################################################\n# Language dependencies: \n# To add a new language extend T2H_WORDS hash and create $T2H_<...>_WORDS hash\n# To redefine one word, simply do:\n# $T2H_WORDS->{<language>}->{<word>} = 'whatever' in your personal init file.\n#\n$T2H_WORDS_EN =\n{\n # titles  of pages\n 'ToC_Title' => 'Table of Contents',\n 'Overview_Title' => 'Short Table of Contents',\n 'Index_Title' => 'Index',\n 'About_Title' => 'About this document',\n 'Footnotes_Title' => 'Footnotes',\n 'See' => 'See',\n 'see' => 'see',\n 'section' => 'section',\n# If necessary, we could extend this as follows: \n#  # text for buttons\n#  'Top_Button' => 'Top',\n#  'ToC_Button' => 'Contents',\n#  'Overview_Button' => 'Overview',\n#  'Index_button' => 'Index',\n#  'Back_Button' => 'Back',\n#  'FastBack_Button' => 'FastBack',\n#  'Prev_Button' => 'Prev',\n#  'Up_Button' => 'Up',\n#  'Next_Button' => 'Next',\n#  'Forward_Button' =>'Forward',\n#  'FastWorward_Button' => 'FastForward',\n#  'First_Button' => 'First',\n#  'Last_Button' => 'Last',\n#  'About_Button' => 'About'\n};\n\n$T2H_WORD_DE =\n{\n 'ToC_Title' => 'Inhaltsverzeichniss',\n 'Overview_Title' => 'Kurzes Inhaltsverzeichniss',\n 'Index_Title' => 'Index',\n 'About_Title' => '&Uuml;ber dieses Dokument',\n 'Footnotes_Title' => 'Fu&szlig;noten',\n 'See' => 'Siehe',\n 'see' => 'siehe',\n 'section' => 'Abschnitt',\n};\n\n$T2H_WORD_NL =\n{\n 'ToC_Title' => 'Inhoudsopgave',\n 'Overview_Title' => 'Korte inhoudsopgave',\n 'Index_Title' => 'Index', #Not sure ;-)\n 'About_Title' => 'No translation available!', #No translation available!\n 'Footnotes_Title' => 'No translation available!', #No translation available!\n 'See' => 'Zie',\n 'see' => 'zie',\n 'section' => 'sectie',\n};\n\n$T2H_WORD_ES =\n{\n 'ToC_Title' => '&iacute;ndice General',\n 'Overview_Title' => 'Resumen del Contenido',\n 'Index_Title' => 'Index', #Not sure ;-)\n 'About_Title' => 'No translation available!', #No translation available!\n 'Footnotes_Title' => 'Fu&szlig;noten',\n 'See' => 'V&eacute;ase',\n 'see' => 'v&eacute;ase',\n 'section' => 'secci&oacute;n',\n};\n\n$T2H_WORD_NO =\n{\n 'ToC_Title' => 'Innholdsfortegnelse',\n 'Overview_Title' => 'Kort innholdsfortegnelse',\n 'Index_Title' => 'Indeks', #Not sure ;-)\n 'About_Title' => 'No translation available!', #No translation available!\n 'Footnotes_Title' => 'No translation available!',\n 'See' => 'Se',\n 'see' => 'se',\n 'section' => 'avsnitt',\n};\n\n$T2H_WORD_PT =\n{\n 'ToC_Title' => 'Sum&aacute;rio',\n 'Overview_Title' => 'Breve Sum&aacute;rio',\n 'Index_Title' => '&Iacute;ndice', #Not sure ;-)\n 'About_Title' => 'No translation available!', #No translation available!\n 'Footnotes_Title' => 'No translation available!',\n 'See' => 'Veja',\n 'see' => 'veja',\n 'section' => 'Se&ccedil;&atilde;o',\n};\n\n$T2H_WORDS =\n{\n 'en' => $T2H_WORDS_EN,\n 'de' => $T2H_WORDS_DE,\n 'nl' => $T2H_WORDS_NL,\n 'es' => $T2H_WORDS_ES,\n 'no' => $T2H_WORDS_NO,\n 'pt' => $T2H_WORDS_PT\n};\n\n@MONTH_NAMES_EN =\n(\n 'January', 'February', 'March', 'April', 'May',\n 'June', 'July', 'August', 'September', 'October',\n 'November', 'December'\n);\n\n@MONTH_NAMES_DE =\n(\n 'Januar', 'Februar', 'M&auml;rz', 'April', 'Mai',\n 'Juni', 'Juli', 'August', 'September', 'Oktober',\n 'November', 'Dezember'\n);\n\n@MONTH_NAMES_NL =\n(\n 'Januari', 'Februari', 'Maart', 'April', 'Mei',\n 'Juni', 'Juli', 'Augustus', 'September', 'Oktober',\n 'November', 'December'\n);\n\n@MONTH_NAMES_ES =\n(\n 'enero', 'febrero', 'marzo', 'abril', 'mayo',\n 'junio', 'julio', 'agosto', 'septiembre', 'octubre',\n 'noviembre', 'diciembre'\n);\n\n@MONTH_NAMES_NO =\n(\n\n 'januar', 'februar', 'mars', 'april', 'mai',\n 'juni', 'juli', 'august', 'september', 'oktober',\n 'november', 'desember'\n);\n\n@MONTH_NAMES_PT =\n(\n 'Janeiro', 'Fevereiro', 'Mar&ccedil;o', 'Abril', 'Maio',\n 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro',\n 'Novembro', 'Dezembro'\n);\n\n\n$MONTH_NAMES =\n{\n    'en' => \\@MONTH_NAMES_EN,\n    'de' => \\@MONTH_NAMES_DE,\n    'es' => \\@MONTH_NAMES_ES,\n    'nl' => \\@MONTH_NAMES_NL,\n    'no' => \\@MONTH_NAMES_NO,\n    'pt' => \\@MONTH_NAMES_PT\n};\n########################################################################\n# Control of Page layout:\n# You can make changes of the Page layout at two levels:\n# 1.) For small changes, it is often enough to change the value of\n#     some global string/hash/array variables\n# 2.) For larger changes, reimplement one of the T2H_DEFAULT_<fnc>* routines,\n#     give them another name, and assign them to the respective\n#     $T2H_<fnc> variable.\n\n# As a general interface, the hashes T2H_HREF, T2H_NAME, T2H_NODE hold \n# href, html-name, node-name of\n# This     -- current section (resp. html page)\n# Top      -- top page ($T2H_TOP_FILE)\n# Contents -- Table of contents\n# Overview -- Short table of contents\n# Index    -- Index page\n# About    -- page which explain \"navigation buttons\"\n# First    -- first node \n# Last     -- last node\n#\n# Whether or not the following hash values are set, depends on the context \n# (all values are w.r.t. 'This' section)\n# Next        -- next node of texinfo\n# Prev        -- previous node of texinfo\n# Up          -- up node of texinfo\n# Forward     -- next node in reading order\n# Back        -- previous node in reading order\n# FastForward -- if leave node, up and next, else next node\n# FastBackward-- if leave node, up and prev, else prev node\n#\n# Furthermore, the following global variabels are set:\n# $T2H_THISDOC{title}     -- title as set by @setttile\n# $T2H_THISDOC{fulltitle} -- full title as set by @title...\n# $T2H_THISDOC{subtitle}  -- subtitle as set by @subtitle\n# $T2H_THISDOC{author}    -- author as set by @author\n# \n# and pointer to arrays of lines which need to be printed by t2h_print_lines \n# $T2H_OVERVIEW      -- lines of short table of contents\n# $T2H_TOC           -- lines of table of contents\n# $T2H_TOP           -- lines of Top texinfo node \n# $T2H_THIS_SECTION  -- lines of 'This' section\n\n#\n# There are the following subs which control the layout:\n#\n$T2H_print_section            = \\&T2H_DEFAULT_print_section;\n$T2H_print_Top_header         = \\&T2H_DEFAULT_print_Top_header;       \n$T2H_print_Top_footer\t      = \\&T2H_DEFAULT_print_Top_footer;       \n$T2H_print_Top\t\t      = \\&T2H_DEFAULT_print_Top;              \n$T2H_print_Toc\t\t      = \\&T2H_DEFAULT_print_Toc;              \n$T2H_print_Overview\t      = \\&T2H_DEFAULT_print_Overview;         \n$T2H_print_Footnotes\t      = \\&T2H_DEFAULT_print_Footnotes;        \n$T2H_print_About\t      = \\&T2H_DEFAULT_print_About;            \n$T2H_print_misc_header\t      = \\&T2H_DEFAULT_print_misc_header;      \n$T2H_print_misc_footer\t      = \\&T2H_DEFAULT_print_misc_footer;      \n$T2H_print_misc\t\t      = \\&T2H_DEFAULT_print_misc;\n$T2H_print_chapter_header     = \\&T2H_DEFAULT_print_chapter_header;      \n$T2H_print_chapter_footer     = \\&T2H_DEFAULT_print_chapter_footer;      \n$T2H_print_page_head\t      = \\&T2H_DEFAULT_print_page_head;        \n$T2H_print_page_foot\t      = \\&T2H_DEFAULT_print_page_foot;        \n$T2H_print_head_navigation    = \\&T2H_DEFAULT_print_head_navigation;  \n$T2H_print_foot_navigation    = \\&T2H_DEFAULT_print_foot_navigation;  \n$T2H_button_icon_img\t      = \\&T2H_DEFAULT_button_icon_img;        \n$T2H_print_navigation\t      = \\&T2H_DEFAULT_print_navigation;       \n$T2H_about_body\t\t      = \\&T2H_DEFAULT_about_body;            \n$T2H_print_frame              = \\&T2H_DEFAULT_print_frame;\n$T2H_print_toc_frame          = \\&T2H_DEFAULT_print_toc_frame;\n\n########################################################################\n# Layout for html for every sections\n#\nsub T2H_DEFAULT_print_section\n{\n  my $fh = shift;\n  local $T2H_BUTTONS = \\@T2H_SECTION_BUTTONS;\n  &$T2H_print_head_navigation($fh) if $T2H_SECTION_NAVIGATION;\n  my $nw = t2h_print_lines($fh);\n  if ($T2H_SPLIT eq 'section' && $T2H_SECTION_NAVIGATION)\n  {\n    &$T2H_print_foot_navigation($fh, $nw);\n  }\n  else\n  {\n    print $fh '<HR SIZE=\"6\">' . \"\\n\";\n  }\n}\n\n###################################################################\n# Layout of top-page I recommend that you use @ifnothtml, @ifhtml,\n# @html within the Top texinfo node to specify content of top-level\n# page. \n#\n# If you enclose everything in @ifnothtml, then title, subtitle,\n# author and overview is printed\n# T2H_HREF of Next, Prev, Up, Forward, Back are not defined\n# if $T2H_SPLIT then Top page is in its own html file\nsub T2H_DEFAULT_print_Top_header\n{\n  &$T2H_print_page_head(@_) if $T2H_SPLIT;\n  t2h_print_label(@_); # this needs to be called, otherwise no label set\n  &$T2H_print_head_navigation(@_);\n}\nsub T2H_DEFAULT_print_Top_footer\n{\n  &$T2H_print_foot_navigation(@_);\n  &$T2H_print_page_foot(@_) if $T2H_SPLIT; \n}\nsub T2H_DEFAULT_print_Top\n{\n  my $fh = shift;\n\n  # for redefining navigation buttons use:\n  # local $T2H_BUTTONS = [...];\n  # as it is, 'Top', 'Contents', 'Index', 'About' are printed\n  local $T2H_BUTTONS = \\@T2H_MISC_BUTTONS;\n  &$T2H_print_Top_header($fh);\n  if ($T2H_THIS_SECTION)\n  {\n    # if top-level node has content, then print it with extra header\n    print $fh \"<H1>$T2H_NAME{Top}</H1>\"\n      unless ($T2H_HAS_TOP_HEADING);\n    t2h_print_lines($fh, $T2H_THIS_SECTION)\n  }\n  else\n  {\n    # top-level node is fully enclosed in @ifnothtml\n    # print fulltitle, subtitle, author, Overview\n    print $fh \n      \"<CENTER>\\n<H1>\" .\n      join(\"</H1>\\n<H1>\", split(/\\n/,  $T2H_THISDOC{fulltitle})) .\n      \"</H1>\\n\";\n    print $fh \"<H2>$T2H_THISDOC{subtitle}</H2>\\n\" if $T2H_THISDOC{subtitle};\n    print $fh \"$T2H_THISDOC{author}\\n\" if $T2H_THISDOC{author};\n    print $fh <<EOT;\n</CENTER>\n<HR>\n<P></P>  \n<H2> Overview: </H2>\n<BLOCKQUOTE>  \nEOT\n    t2h_print_lines($fh, $T2H_OVERVIEW);\n    print $fh \"</BLOCKQUOTE>\\n\";\n  }\n  &$T2H_print_Top_footer($fh);\n}\n\n###################################################################\n# Layout of Toc, Overview, and Footnotes pages\n# By default, we use \"normal\" layout \n# T2H_HREF of Next, Prev, Up, Forward, Back, etc are not defined\n# use: local $T2H_BUTTONS = [...] to redefine navigation buttons\nsub T2H_DEFAULT_print_Toc\n{\n  return &$T2H_print_misc(@_);\n}\nsub T2H_DEFAULT_print_Overview\n{\n  return &$T2H_print_misc(@_);\n}\nsub T2H_DEFAULT_print_Footnotes\n{\n  return &$T2H_print_misc(@_);\n}\nsub T2H_DEFAULT_print_About\n{\n  return &$T2H_print_misc(@_);\n}\n\nsub T2H_DEFAULT_print_misc_header\n{\n  &$T2H_print_page_head(@_) if $T2H_SPLIT;\n  # this needs to be called, otherwise, no labels are set\n  t2h_print_label(@_); \n  &$T2H_print_head_navigation(@_);\n}\nsub T2H_DEFAULT_print_misc_footer\n{\n  &$T2H_print_foot_navigation(@_);\n  &$T2H_print_page_foot(@_) if $T2H_SPLIT; \n}\nsub T2H_DEFAULT_print_misc\n{\n  my $fh = shift;\n  local $T2H_BUTTONS = \\@T2H_MISC_BUTTONS;\n  &$T2H_print_misc_header($fh);\n  print $fh \"<H1>$T2H_NAME{This}</H1>\\n\";\n  t2h_print_lines($fh);\n  &$T2H_print_misc_footer($fh);\n}\n\n###################################################################\n# chapter_header and chapter_footer are only called if\n# T2H_SPLIT eq 'chapter'\n# chapter_header: after print_page_header, before print_section\n# chapter_footer: after print_section of last section, before print_page_footer\n# \n# If you want to get rid of navigation stuff after each section,\n# redefine print_section such that it does not call print_navigation,\n# and put print_navigation into print_chapter_header\n@T2H_CHAPTER_BUTTONS =\n  (\n   'FastBack', 'FastForward', ' ', \n   ' ', ' ', ' ', ' ',\n   'Top', 'Contents', 'Index', 'About', \n  );\n\nsub T2H_DEFAULT_print_chapter_header\n{\n  # nothing to do there, by default\n  if (! $T2H_SECTION_NAVIGATION)\n  {\n    my $fh = shift;\n    local $T2H_BUTTONS = \\@T2H_CHAPTER_BUTTONS;\n    &$T2H_print_navigation($fh);\n    print $fh \"\\n<HR SIZE=2>\\n\";\n  }\n}\n\nsub T2H_DEFAULT_print_chapter_footer\n{\n  local $T2H_BUTTONS = \\@T2H_CHAPTER_BUTTONS;\n  &$T2H_print_navigation(@_);\n}\n###################################################################\n$T2H_TODAY = &pretty_date;\t\t# like \"20 September 1993\"\n\nsub pretty_date {\n    local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);\n\n    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);\n    $year += ($year < 70) ? 2000 : 1900;\n    # obachman: Let's do it as the Americans do\n    return($MONTH_NAMES->{$T2H_LANG}[$mon] . \", \" . $mday . \" \" . $year);\n}\n\n\n###################################################################\n# Layout of standard header and footer\n#\n\n# Set the default body text, inserted between <BODY ... > \n###$T2H_BODYTEXT = 'LANG=\"EN\" BGCOLOR=\"#FFFFFF\" TEXT=\"#000000\" LINK=\"#0000FF\" VLINK=\"#800080\" ALINK=\"#FF0000\"';\n$T2H_BODYTEXT = 'LANG=\"' . $T2H_LANG . '\" BGCOLOR=\"#FFFFFF\" TEXT=\"#000000\" LINK=\"#0000FF\" VLINK=\"#800080\" ALINK=\"#FF0000\"';\n# text inserted after <BODY ...>\n$T2H_AFTER_BODY_OPEN = '';\n#text inserted before </BODY>\n$T2H_PRE_BODY_CLOSE = '';\n# this is used in footer\n$T2H_ADDRESS = \"by <I>$T2H_USER</I> \" if $T2H_USER;\n$T2H_ADDRESS .= \"on <I>$T2H_TODAY</I>\";\n# this is added inside <HEAD></HEAD> after <TITLE> and some META NAME stuff\n# can be used for <style> <script>, <meta> tags\n$T2H_EXTRA_HEAD = '';\n\nsub T2H_DEFAULT_print_page_head\n{\n  my $fh = shift; \n  my $longtitle = \"$T2H_THISDOC{title}: $T2H_NAME{This}\";\n  print $fh <<EOT;\n<HTML>\n$T2H_DOCTYPE\n<!-- Created on $T2H_TODAY by $THISPROG -->\n<!-- \n$T2H_AUTHORS \n-->\n<HEAD>\n<TITLE>$longtitle</TITLE>\n\n<META NAME=\"description\" CONTENT=\"$longtitle\">\n<META NAME=\"keywords\" CONTENT=\"$longtitle\">\n<META NAME=\"resource-type\" CONTENT=\"document\">\n<META NAME=\"distribution\" CONTENT=\"global\">\n<META NAME=\"Generator\" CONTENT=\"$THISPROG\">\n$T2H_EXTRA_HEAD\n</HEAD>\n\n<BODY $T2H_BODYTEXT>\n$T2H_AFTER_BODY_OPEN\nEOT\n}\n\nsub T2H_DEFAULT_print_page_foot\n{\n  my $fh = shift;\n  print $fh <<EOT;\n<BR>  \n<FONT SIZE=\"-1\">\nThis document was generated\n$T2H_ADDRESS\nusing <A HREF=\"$T2H_HOMEPAGE\"><I>texi2html</I></A>\n$T2H_PRE_BODY_CLOSE\n</BODY>\n</HTML>\nEOT\n}\n\n###################################################################\n# Layout of navigation panel\n\n# if this is set, then a vertical navigation panel is used\n$T2H_VERTICAL_HEAD_NAVIGATION = 0;\nsub T2H_DEFAULT_print_head_navigation\n{\n  my $fh = shift;\n  if ($T2H_VERTICAL_HEAD_NAVIGATION)\n  {\n    print $fh <<EOT;\n<TABLE BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n<TR VALIGN=\"TOP\">\n<TD ALIGN=\"LEFT\">\nEOT\n  }\n  &$T2H_print_navigation($fh, $T2H_VERTICAL_HEAD_NAVIGATION);\n  if ($T2H_VERTICAL_HEAD_NAVIGATION)\n  {\n    print $fh <<EOT;\n</TD>\n<TD ALIGN=\"LEFT\">\nEOT\n  }\n  elsif ($T2H_SPLIT eq 'section')\n  {\n    print $fh \"<HR SIZE=1>\\n\";\n  }\n}\n\n# Specifies the minimum page length required before a navigation panel\n# is placed at the bottom of a page (the default is that of latex2html)\n# T2H_THIS_WORDS_IN_PAGE holds number of words of current page\n$T2H_WORDS_IN_PAGE = 300;\nsub T2H_DEFAULT_print_foot_navigation\n{\n  my $fh = shift;\n  my $nwords = shift;\n  if ($T2H_VERTICAL_HEAD_NAVIGATION)\n  {\n    print $fh <<EOT;\n</TD>\n</TR>\n</TABLE>\nEOT\n  }\n  print $fh \"<HR SIZE=1>\\n\";\n  &$T2H_print_navigation($fh) if ($nwords >= $T2H_WORDS_IN_PAGE)\n}\n\n######################################################################\n# navigation panel\n#\n# specify in this array which \"buttons\" should appear in which order\n# in the navigation panel for sections; use ' ' for empty buttons (space)\n@T2H_SECTION_BUTTONS =\n  (\n   'Back', 'Forward', ' ', 'FastBack', 'Up', 'FastForward',  \n   ' ', ' ', ' ', ' ',\n   'Top', 'Contents', 'Index', 'About', \n  );\n\n# buttons for misc stuff\n@T2H_MISC_BUTTONS = ('Top', 'Contents', 'Index', 'About');\n\n# insert here name of icon images for buttons \n# Icons are used, if $T2H_ICONS and resp. value are set\n%T2H_ACTIVE_ICONS =\n  (\n   'Top',      '',\n   'Contents', '',\n   'Overview', '',\n   'Index',    '',\n   'Back',     '',\n   'FastBack', '',\n   'Prev',     '',\n   'Up',       '',\n   'Next',     '',\n   'Forward',  '',\n   'FastForward', '',\n   'About' ,    '',\n   'First',    '',\n   'Last',     '',\n   ' ',        ''\n  );\n\n# insert here name of icon images for these, if button is inactive\n%T2H_PASSIVE_ICONS =\n  (\n   'Top',      '',\n   'Contents', '',\n   'Overview', '',\n   'Index',    '',\n   'Back',     '',\n   'FastBack', '',\n   'Prev',     '',\n   'Up',       '',\n   'Next',     '',\n   'Forward',  '',\n   'FastForward', '',\n   'About',     '',\n   'First',    '',\n   'Last',     '',\n  );\n\n# how to create IMG tag\nsub T2H_DEFAULT_button_icon_img\n{\n  my $button = shift;\n  my $icon = shift;\n  my $name = shift;\n  return qq{<IMG SRC=\"$icon\" BORDER=\"0\" ALT=\"$button: $name\" ALIGN=\"MIDDLE\">};\n}\n\n# Names of text as alternative for icons\n%T2H_NAVIGATION_TEXT =\n  (\n   'Top',      'Top',\n   'Contents', 'Contents',\n   'Overview', 'Overview',\n   'Index',    'Index',\n   ' ',        ' &nbsp; ',\n   'Back',     ' &lt; ',\n   'FastBack', ' &lt;&lt; ',\n   'Prev',     'Prev',\n   'Up',       ' Up ',\n   'Next',     'Next',\n   'Forward',  ' &gt; ',\n   'FastForward',  ' &gt;&gt; ',\n   'About',     ' ? ',\n   'First',    ' |&lt; ',\n   'Last',     ' &gt;| '\n  );\n\nsub T2H_DEFAULT_print_navigation\n{\n  my $fh = shift;\n  my $vertical = shift;\n  my $spacing = 1;\n  print $fh \"<TABLE CELLPADDING=$spacing CELLSPACING=$spacing BORDER=0>\\n\";\n\n  print $fh \"<TR>\" unless $vertical;\n  for $button (@$T2H_BUTTONS)\n  {\n    print $fh qq{<TR VALIGN=\"TOP\" ALIGN=\"LEFT\">\\n} if $vertical;\n    print $fh qq{<TD VALIGN=\"MIDDLE\" ALIGN=\"LEFT\">};\n\n    if (ref($button) eq 'CODE')\n    {\n      &$button($fh, $vertical);\n    }\n    elsif ($button eq ' ')\n    { # handle space button\n      print $fh \n\t$T2H_ICONS && $T2H_ACTIVE_ICONS{' '} ? \n\t &$T2H_button_icon_img($button, $T2H_ACTIVE_ICONS{' '}) :\n\t $T2H_NAVIGATION_TEXT{' '};\n      next;\n    }\n    elsif ($T2H_HREF{$button})\n    { # button is active\n      print $fh   \n\t $T2H_ICONS && $T2H_ACTIVE_ICONS{$button} ? # use icon ? \n\t   t2h_anchor('', $T2H_HREF{$button},  # yes\n\t\t    &$T2H_button_icon_img($button,\n\t\t\t\t\t$T2H_ACTIVE_ICONS{$button},\n\t\t\t\t\t$T2H_NAME{$button})) \n\t : # use text\n\t \"[\" . \n\t t2h_anchor('', $T2H_HREF{$button}, $T2H_NAVIGATION_TEXT{$button}) .\n\t \"]\";  \n    }\n    else\n    { # button is passive \n      print $fh \n\t$T2H_ICONS && $T2H_PASSIVE_ICONS{$button} ?\n\t &$T2H_button_icon_img($button,\n\t\t\t       $T2H_PASSIVE_ICONS{$button},\n\t\t\t       $T2H_NAME{$button}) :\n\t \n\t \"[\" . $T2H_NAVIGATION_TEXT{$button} . \"]\";\n    }\n    print $fh \"</TD>\\n\";\n    print $fh \"</TR>\\n\" if $vertical;\n  }\n  print $fh \"</TR>\" unless $vertical;\n  print $fh \"</TABLE>\\n\";\n}\n\n######################################################################\n# Frames: this is from \"Richard Y. Kim\" <ryk@coho.net>\n# Should be improved to be more conforming to other _print* functions\n\nsub T2H_DEFAULT_print_frame\n{\n  my $fh = shift;\n  print $fh <<EOT;\n<HTML>\n<HEAD><TITLE>$T2H_THISDOC{title}</TITLE></HEAD>\n<FRAMESET cols=\"140,*\"> \n  <FRAME name=toc  src=\"$docu_toc_frame_file\">\n  <FRAME name=main src=\"$docu_doc\">\n</FRAMESET> \n</HTML>\nEOT\n}\n\nsub T2H_DEFAULT_print_toc_frame\n{\n  my $fh = shift;\n  &$T2H_print_page_head($fh);\n  print $fh <<EOT;\n<H2>Content</H2>\nEOT\n  print $fh map {s/HREF=/target=\\\"main\\\" HREF=/; $_;} @stoc_lines;\n  print $fh \"</BODY></HTML>\\n\";\n}\n\n######################################################################\n# About page\n#\n\n# T2H_PRE_ABOUT might be a function\n$T2H_PRE_ABOUT = <<EOT;\nThis document was generated $T2H_ADDRESS\nusing <A HREF=\"$T2H_HOMEPAGE\"><I>texi2html</I></A>\n<P></P>  \nEOT\n$T2H_AFTER_ABOUT = '';\n\nsub T2H_DEFAULT_about_body\n{\n  my $about;\n  if (ref($T2H_PRE_ABOUT) eq 'CODE')\n  {\n    $about = &$T2H_PRE_ABOUT();\n  }\n  else\n  {\n    $about = $T2H_PRE_ABOUT;\n  }\n  $about .= <<EOT;\nThe buttons in the navigation panels have the following meaning:\n<P></P>\n<table border = \"1\">\n<TR>\n<TH> Button </TH>\n<TH> Name </TH>\n<TH> Go to </TH>\n<TH> From 1.2.3 go to</TH>\n</TR>\nEOT\n  \n  for $button (@T2H_SECTION_BUTTONS)\n  {\n    next if $button eq ' ' || ref($button) eq 'CODE';\n    $about .= <<EOT;\n<TR>\n<TD ALIGN=\"CENTER\">\nEOT\n    $about .= \t\n      ($T2H_ICONS && $T2H_ACTIVE_ICONS{$button} ?\n       &$T2H_button_icon_img($button, $T2H_ACTIVE_ICONS{$button}) :\n       \" [\" . $T2H_NAVIGATION_TEXT{$button} . \"] \");\n    $about .= <<EOT;\n</TD>\n<TD ALIGN=\"CENTER\">\n$button\n</TD>\n<TD>\n$T2H_BUTTONS_GOTO{$button}\n</TD>\n<TD>\n$T2H_BUTTONS_EXAMPLE{$button}\n</TD>\n</TR>\nEOT\n  }\n\n  $about .= <<EOT;\n</TABLE>\n<P></P>\nwhere the <STRONG> Example </STRONG> assumes that the current position \nis at <STRONG> Subsubsection One-Two-Three </STRONG> of a document of \nthe following structure:\n<UL>\n<LI> 1. Section One  </LI>\n<UL>\n<LI>1.1 Subsection One-One</LI>\n<UL>\n<LI> ... </LI>\n</UL>\n<LI>1.2 Subsection One-Two</LI>\n<UL>\n<LI>1.2.1 Subsubsection One-Two-One\n</LI><LI>1.2.2 Subsubsection One-Two-Two\n</LI><LI>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp; <STRONG>\n&lt;== Current Position </STRONG>\n</LI><LI>1.2.4 Subsubsection One-Two-Four\n</LI></UL>\n<LI>1.3 Subsection One-Three</LI>\n<UL>\n<LI> ... </LI>\n</UL>\n<LI>1.4 Subsection One-Four</LI>\n</UL>\n</UL>\n$T2H_AFTER_ABOUT\nEOT\n  return $about;  \n}\n\n  \n%T2H_BUTTONS_GOTO =\n  (\n   'Top',      'cover (top) of document',\n   'Contents', 'table of contents',\n   'Overview', 'short table of contents',\n   'Index',    'concept index',\n   'Back',     'previous section in reading order',\n   'FastBack', 'previous or up-and-previous section ',\n   'Prev',     'previous section same level',\n   'Up',       'up section',\n   'Next',     'next section same level',\n   'Forward',  'next section in reading order',\n   'FastForward', 'next or up-and-next section',\n   'About' ,    'this page',\n   'First',    'first section in reading order',\n   'Last',     'last section in reading order',\n  );\n\n%T2H_BUTTONS_EXAMPLE = \n(\n   'Top',      ' &nbsp; ',\n   'Contents', ' &nbsp; ',\n   'Overview', ' &nbsp; ',\n   'Index',    ' &nbsp; ',\n   'Back',     '1.2.2',\n   'FastBack', '1.1',\n   'Prev',     '1.2.2',\n   'Up',       '1.2',\n   'Next',     '1.2.4',\n   'Forward',  '1.2.4',\n   'FastForward', '1.3',\n   'About',     ' &nbsp; ',\n   'First',    '1.',\n   'Last',     '1.2.4',\n);\n\n\n######################################################################\n# from here on, its l2h init stuff \n#\n\n## initialization for latex2html as for Singular manual generation\n## obachman 3/99\n\n#\n# Options controlling Titles, File-Names, Tracing and Sectioning\n#\n$TITLE = '';\n\n$SHORTEXTN = 0;\n\n$LONG_TITLES = 0;\n\n$DESTDIR = ''; # should be overwritten by cmd-line argument\n\n$NO_SUBDIR = 0;# should be overwritten by cmd-line argument\n\n$PREFIX = '';  # should be overwritten by cmd-line argument\n\n$AUTO_PREFIX = 0; # this is needed, so that prefix settings are used\n\n$AUTO_LINK = 0; \n\n$SPLIT = 0;\n\n$MAX_LINK_DEPTH = 0;\n\n$TMP = ''; # should be overwritten by cmd-line argument\n\n$DEBUG = 0;\n\n$VERBOSE = 1;\n\n#\n# Options controlling Extensions and Special Features \n#\n$HTML_VERSION = \"3.2\";\n\n$TEXDEFS = 1; # we absolutely need that\n\n$EXTERNAL_FILE = '';\n\n$SCALABLE_FONTS = 1;\n\n$NO_SIMPLE_MATH = 1;\n\n$LOCAL_ICONS = 1;\n\n$SHORT_INDEX = 0;\n\n$NO_FOOTNODE = 1;\n\n$ADDRESS = '';\n\n$INFO = '';\n\n#\n# Switches controlling Image Generation \n#\n$ASCII_MODE = 0;\n\n$NOLATEX = 0;\n\n$EXTERNAL_IMAGES = 0;\n\n$PS_IMAGES = 0;\n\n$NO_IMAGES = 0;\n\n$IMAGES_ONLY = 0;\n\n$REUSE = 2;\n\n$ANTI_ALIAS = 1;\n\n$ANTI_ALIAS_TEXT = 1;\n\n#\n#Switches controlling Navigation Panels\n#\n$NO_NAVIGATION = 1;\n$ADDRESS = '';\n$INFO = 0;              # 0 = do not make a \"About this document...\" section \n\n#\n#Switches for Linking to other documents \n#\n# actuall -- we don't care\n\n$MAX_SPLIT_DEPTH = 0;\t# Stop making separate files at this depth\n\n$MAX_LINK_DEPTH = 0;    # Stop showing child nodes at this depth   \n\n$NOLATEX = 0;           # 1 = do not pass unknown environments to Latex\n\n$EXTERNAL_IMAGES = 0;   # 1 = leave the images outside the document \n\n$ASCII_MODE = 0;        # 1 = do not use any icons or internal images\n\n# 1 =  use links to external postscript images rather than inlined bitmap\n# images.\n$PS_IMAGES = 0;\n$SHOW_SECTION_NUMBERS = 0;\n\n### Other global variables ###############################################\n$CHILDLINE = \"\";\n\n# This is the line width measured in pixels and it is used to right justify\n# equations and equation arrays; \n$LINE_WIDTH = 500;\t\t\n\n# Used in conjunction with AUTO_NAVIGATION\n$WORDS_IN_PAGE = 300;\t\n\n# Affects ONLY the way accents are processed \n$default_language = 'english';\t\n\n# The value of this variable determines how many words to use in each \n# title that is added to the navigation panel (see below)\n# \n$WORDS_IN_NAVIGATION_PANEL_TITLES = 0;\n\n# This number will determine the size of the equations, special characters,\n# and anything which will be converted into an inlined image\n# *except* \"image generating environments\" such as \"figure\", \"table\" \n# or \"minipage\".\n# Effective values are those greater than 0.\n# Sensible values are between 0.1 - 4.\n$MATH_SCALE_FACTOR = 1.5;\n\n# This number will determine the size of \n# image generating environments such as \"figure\", \"table\" or \"minipage\".\n# Effective values are those greater than 0.\n# Sensible values are between 0.1 - 4.\n$FIGURE_SCALE_FACTOR = 1.6;\n\n\n#  If both of the following two variables are set then the \"Up\" button\n#  of the navigation panel in the first node/page of a converted document\n#  will point to $EXTERNAL_UP_LINK. $EXTERNAL_UP_TITLE should be set\n#  to some text which describes this external link.\n$EXTERNAL_UP_LINK = \"\";\n$EXTERNAL_UP_TITLE = \"\";\n\n# If this is set then the resulting HTML will look marginally better if viewed \n# with Netscape.\n$NETSCAPE_HTML = 1;\n\n# Valid paper sizes are \"letter\", \"legal\", \"a4\",\"a3\",\"a2\" and \"a0\"\n# Paper sizes has no effect other than in the time it takes to create inlined\n# images and in whether large images can be created at all ie\n#  - larger paper sizes *MAY* help with large image problems \n#  - smaller paper sizes are quicker to handle\n$PAPERSIZE = \"a4\";\n\n# Replace \"english\" with another language in order to tell LaTeX2HTML that you \n# want some generated section titles (eg \"Table of Contents\" or \"References\")\n# to appear in a different language. Currently only \"english\" and \"french\"\n# is supported but it is very easy to add your own. See the example in the\n# file \"latex2html.config\" \n$TITLES_LANGUAGE = \"english\";\n\n1;\t# This must be the last non-comment line\n\n# End File texi2html.init\n######################################################################\n\n\nrequire \"$ENV{T2H_HOME}/texi2html.init\" \n  if ($0 =~ /\\.pl$/ &&\n      -e \"$ENV{T2H_HOME}/texi2html.init\" && -r \"$ENV{T2H_HOME}/texi2html.init\");\n\n#+++############################################################################\n#                                                                              #\n# Initialization                                                               #\n# Pasted content of File $(srcdir)/MySimple.pm: Command-line processing        #\n#                                                                              #\n#---############################################################################\n\n# leave this within comments, and keep the require statement\n# This way, you can directly run texi2html.pl, if $ENV{T2H_HOME}/texi2html.init\n# exists.\n\n# \npackage Getopt::MySimple;\n\n# Name:\n#\tGetopt::MySimple.\n#\n# Documentation:\n#\tPOD-style (incomplete) documentation is in file MySimple.pod\n#\n# Tabs:\n#\t4 spaces || die.\n#\n# Author:\n#\tRon Savage\trpsavage@ozemail.com.au.\n#\t1.00\t19-Aug-97\tInitial version.\n#\t1.10\t13-Oct-97\tAdd arrays of switches (eg '=s@').\n#\t1.20\t 3-Dec-97\tAdd 'Help' on a per-switch basis.\n#\t1.30\t11-Dec-97\tChange 'Help' to 'verbose'. Make all hash keys lowercase.\n#\t1.40\t10-Nov-98\tChange width of help report. Restructure tests.\n#               1-Jul-00        Modifications for Texi2html\n\n# --------------------------------------------------------------------------\n# Locally modified by obachman (Display type instead of env, order by cmp)\n# $Id: MySimple.pm,v 1.1 2000/07/03 08:44:13 obachman Exp $\n\n# use strict;\n# no strict 'refs';\n\nuse vars qw(@EXPORT @EXPORT_OK @ISA);\nuse vars qw($fieldWidth $opt $VERSION);\n\nuse Exporter();\nuse Getopt::Long;\n\n@ISA\t\t= qw(Exporter);\n@EXPORT\t\t= qw();\n@EXPORT_OK\t= qw($opt);\t# An alias for $self -> {'opt'}.\n\n# --------------------------------------------------------------------------\n\n$fieldWidth\t= 20;\n$VERSION\t= '1.41';\n\n# --------------------------------------------------------------------------\n\nsub byOrder\n{\n\tmy($self) = @_;\n\t\n\treturn uc($a) cmp (uc($b));\n}\n\n# --------------------------------------------------------------------------\n\nsub dumpOptions\n{\n\tmy($self) = @_;\n\n\tprint 'Option', ' ' x ($fieldWidth - length('Option') ), \"Value\\n\";\n\n\tfor (sort byOrder keys(%{$self -> {'opt'} }) )\n\t{\n\t  print \"-$_\", ' ' x ($fieldWidth - (1 + length) ), \"${$self->{'opt'} }{$_}\\n\";\n\t}\n\n\tprint \"\\n\";\n\n}\t# End of dumpOptions.\n\n# --------------------------------------------------------------------------\n# Return:\n#\t0 -> Error.\n#\t1 -> Ok.\n\nsub getOptions\n{\n\tpush(@_, 0) if ($#_ == 2);\t# Default for $ignoreCase is 0.\n\tpush(@_, 1) if ($#_ == 3);\t# Default for $helpThenExit is 1.\n\n\tmy($self, $default, $helpText, $versionText, \n\t   $helpThenExit, $versionThenExit, $ignoreCase) = @_;\n\t\n\t$helpThenExit = 1 unless (defined($helpThenExit));\n\t$versionThenExit = 1 unless (defined($versionThenExit));\n\t$ignoreCase = 0 unless (defined($ignoreCase));\n\n\t$self -> {'default'}\t\t= $default;\n\t$self -> {'helpText'}\t\t= $helpText;\n\t$self -> {'versionText'}        = $versionText;\n\t$Getopt::Long::ignorecase\t= $ignoreCase;\n\n\tunless (defined($self -> {'default'}{'help'}))\n\t{\n\t  $self -> {'default'}{'help'} = \n\t  { \n\t   type => ':i', \n\t   default => '',\n\t   linkage => sub {$self->helpOptions($_[1]); exit (0) if $helpThenExit;},\n\t   verbose => \"print help and exit\"\n\t  };\n\t}\n\n\tunless (defined($self -> {'default'}{'version'}))\n\t{\n\t  $self -> {'default'}{'version'} = \n\t  { \n\t   type => '', \n\t   default => '',\n\t   linkage => sub {print $self->{'versionText'};  exit (0) if versionTheExit;},\n\t   verbose => \"print version and exit\"\n\t  };\n\t}\n\n\tfor (keys(%{$self -> {'default'} }) )\n\t{\n\t  my $type = ${$self -> {'default'} }{$_}{'type'};\n\t  push(@{$self -> {'type'} }, \"$_$type\");\n\t  $self->{'opt'}->{$_} =  ${$self -> {'default'} }{$_}{'linkage'}\n            if ${$self -> {'default'} }{$_}{'linkage'};\n\t}\n\n\tmy($result) = &GetOptions($self -> {'opt'}, @{$self -> {'type'} });\n\n        return $result unless $result;\n\n\tfor (keys(%{$self -> {'default'} }) )\n\t{\n \t   if (! defined(${$self -> {'opt'} }{$_})) #{\n            {\n \t     ${$self -> {'opt'} }{$_} = ${$self -> {'default'} }{$_}{'default'};\n            }\n\t}\n\n\t$result;\n}\t# End of getOptions.\n\n# --------------------------------------------------------------------------\n\nsub helpOptions\n{\n\tmy($self) = shift;\n\tmy($noHelp) = shift;\n\t$noHelp = 0 unless $noHelp;\n\tmy($optwidth, $typewidth, $defaultwidth, $maxlinewidth, $valind, $valwidth) \n\t  = (10, 5, 9, 78, 4, 11);\n\n\tprint \"$self->{'helpText'}\" if ($self -> {'helpText'});\n\n\tprint ' Option', ' ' x ($optwidth - length('Option') -1 ),\n\t\t'Type', ' ' x ($typewidth - length('Type') + 1),\n\t\t'Default', ' ' x ($defaultwidth - length('Default') ),\n\t        \"Description\\n\";\n\n\tfor (sort byOrder keys(%{$self -> {'default'} }) )\n\t{\n\t  my($line, $help, $option, $val);\n\t  $option = $_;\n\t  next if ${$self->{'default'} }{$_}{'noHelp'} && ${$self->{'default'} }{$_}{'noHelp'} > $noHelp;\n\t\t$line = \" -$_ \" . ' ' x ($optwidth - (2 + length) ) .\n\t\t\t\"${$self->{'default'} }{$_}{'type'} \".\n\t\t\t' ' x ($typewidth - (1+length(${$self -> {'default'} }{$_}{'type'}) ));\n\n                 $val = ${$self->{'default'} }{$_}{'linkage'};\n                if ($val)\n                {\n                  if (ref($val) eq 'SCALAR')\n\t\t  {\n\t\t    $val = $$val; \n\t\t  }\n\t\t  else\n\t\t  {\n\t\t    $val = '';\n\t\t  }\n                }\n\t\telse\n\t\t{\n\t\t  $val = ${$self->{'default'} }{$_}{'default'};\n\t\t}\n\t        $line .= \"$val  \";\n\t\t$line .= ' ' x ($optwidth + $typewidth + $defaultwidth + 1 - length($line));\n\t\t\n\t\tif (defined(${$self -> {'default'} }{$_}{'verbose'}) &&\n\t\t  ${$self -> {'default'} }{$_}{'verbose'} ne '')\n\t      {\n\t\t$help = \"${$self->{'default'} }{$_}{'verbose'}\";\n\t      }\n\t      else\n\t      {\n\t\t$help = ' ';\n\t      }\n\t      if ((length(\"$line\") + length($help)) < $maxlinewidth)\n\t      {\n\t\tprint $line , $help, \"\\n\";\n\t      }\n\t      else\n\t      {\n\t\tprint $line, \"\\n\", ' ' x $valind, $help, \"\\n\";\n\t      }\n\t      for $val (sort byOrder keys(%{${$self->{'default'}}{$option}{'values'}}))\n\t      {\n\t        print ' ' x ($valind + 2);\n\t        print $val, '  ', ' ' x ($valwidth - length($val) - 2);\n\t        print ${$self->{'default'}}{$option}{'values'}{$val}, \"\\n\";\n\t      }\n\t}\n\n\tprint <<EOT;\nNote: 'Options' may be abbreviated. 'Type' specifications mean:\n <none>| !    no argument: variable is set to 1 on -foo (or, to 0 on -nofoo)\n    =s | :s   mandatory (or, optional)  string argument\n    =i | :i   mandatory (or, optional)  integer argument\nEOT\n}\t# End of helpOptions.\n\n#-------------------------------------------------------------------\n\nsub new\n{\n\tmy($class)\t\t\t\t= @_;\n\tmy($self)\t\t\t\t= {};\n\t$self -> {'default'}\t= {};\n\t$self -> {'helpText'}\t= '';\n\t$self -> {'opt'}\t\t= {};\n\t$opt\t\t\t\t\t= $self -> {'opt'};\t # An alias for $self -> {'opt'}.\n\t$self -> {'type'}\t\t= ();\n\n\treturn bless $self, $class;\n\n}\t# End of new.\n\n# --------------------------------------------------------------------------\n\n1;\n\n# End MySimple.pm\n\nrequire \"$ENV{T2H_HOME}/MySimple.pm\" \n  if ($0 =~ /\\.pl$/ &&\n      -e \"$ENV{T2H_HOME}/texi2html.init\" && -r \"$ENV{T2H_HOME}/texi2html.init\");\n\npackage main;\n\n#+++############################################################################\n#                                                                              #\n# Constants                                                                    #\n#                                                                              #\n#---############################################################################\n\n$DEBUG_TOC   =  1;\n$DEBUG_INDEX =  2;\n$DEBUG_BIB   =  4;\n$DEBUG_GLOSS =  8;\n$DEBUG_DEF   = 16;\n$DEBUG_HTML  = 32;\n$DEBUG_USER  = 64;\n$DEBUG_L2H   = 128;\n\n\n$BIBRE = '\\[[\\w\\/-]+\\]';\t\t# RE for a bibliography reference\n$FILERE = '[\\/\\w.+-]+';\t\t\t# RE for a file name\n$VARRE = '[^\\s\\{\\}]+';\t\t\t# RE for a variable name\n$NODERE = '[^,:]+';\t\t        # RE for a node name\n$NODESRE = '[^:]+';\t\t        # RE for a list of node names\n\n$ERROR = \"***\";\t\t\t        # prefix for errors \n$WARN  = \"**\";                          # prefix for warnings\n  \n                                        # program home page\n$PROTECTTAG = \"_ThisIsProtected_\";\t# tag to recognize protected sections\n\n$CHAPTEREND = \"<!-- End chapter -->\\n\"; # to know where a chpater ends\n$SECTIONEND = \"<!-- End section -->\\n\"; # to know where section ends\n$TOPEND     = \"<!-- End top     -->\\n\"; # to know where top ends\n\n  \n\n#\n# pre-defined indices\n#\n$index_properties =\n{\n 'c' => { name => 'cp'},\n 'f' => { name => 'fn', code => 1},\n 'v' => { name => 'vr', code => 1},\n 'k' => { name => 'ky', code => 1},\n 'p' => { name => 'pg', code => 1},\n 't' => { name => 'tp', code => 1}\n};\n\n\n%predefined_index = (\n\t\t    'cp', 'c',\n\t\t    'fn', 'f',\n\t\t    'vr', 'v',\n\t\t    'ky', 'k',\n\t\t    'pg', 'p',\n\t\t    'tp', 't',\n\t            );\n\n#\n# valid indices\n#\n%valid_index = (\n\t\t    'c', 1,\n\t\t    'f', 1,\n\t\t    'v', 1,\n\t\t    'k', 1,\n\t\t    'p', 1,\n\t\t    't', 1,\n\t\t);\n\n#\n# texinfo section names to level\n#\n%sec2level = (\n\t      'top', 0,\n\t      'chapter', 1,\n\t      'unnumbered', 1,\n\t      'majorheading', 1,\n\t      'chapheading', 1,\n\t      'appendix', 1,\n\t      'section', 2,\n\t      'unnumberedsec', 2,\n\t      'heading', 2,\n\t      'appendixsec', 2,\n\t      'appendixsection', 2,\n\t      'subsection', 3,\n\t      'unnumberedsubsec', 3,\n\t      'subheading', 3,\n\t      'appendixsubsec', 3,\n\t      'subsubsection', 4,\n\t      'unnumberedsubsubsec', 4,\n\t      'subsubheading', 4,\n\t      'appendixsubsubsec', 4,\n\t      );\n\n#\n# accent map, TeX command to ISO name\n#\n%accent_map = (\n\t       '\"',  'uml',\n\t       '~',  'tilde',\n\t       '^',  'circ',\n\t       '`',  'grave',\n\t       '\\'', 'acute',\n\t       );\n\n#\n# texinfo \"simple things\" (@foo) to HTML ones\n#\n%simple_map = (\n\t       # cf. makeinfo.c\n\t       \"*\", \"<BR>\",\t\t# HTML+\n\t       \" \", \" \",\n\t       \"\\t\", \" \",\n  \t       \"-\", \"&#173;\",\t# soft hyphen\n\t       \"\\n\", \"\\n\",\n\t       \"|\", \"\",\n\t       'tab', '<\\/TD><TD>',\n\t       # spacing commands\n\t       \":\", \"\",\n\t       \"!\", \"!\",\n\t       \"?\", \"?\",\n\t       \".\", \".\",\n\t       \"-\", \"\",\n\t       );\n\n#\n# texinfo \"things\" (@foo{}) to HTML ones\n#\n%things_map = (\n\t       'TeX', 'TeX',\n\t       'br', '<P>',\t\t# paragraph break\n\t       'bullet', '*',\n\t       'copyright', '(C)',\n\t       'dots', '<small>...<\\/small>',\n\t       'enddots', '<small>....<\\/small>',\n\t       'equiv', '==',\n\t       'error', 'error-->',\n\t       'expansion', '==>',\n\t       'minus', '-',\n\t       'point', '-!-',\n\t       'print', '-|',\n\t       'result', '=>',\n\t       'today', $T2H_TODAY,\n\t       'aa', '&aring;',\n\t       'AA', '&Aring;',\n\t       'ae', '&aelig;',\n\t       'oe', '&#156;',\n\t       'AE', '&AElig;',\n\t       'OE', '&#140;',\n\t       'o',  '&oslash;',\n\t       'O',  '&Oslash;',\n\t       'ss', '&szlig;',\n\t       'l', '\\/l',\n\t       'L', '\\/L',\n\t       'exclamdown', '&iexcl;',\n\t       'questiondown', '&iquest;',\n\t       'pounds', '&pound;'\n\t       );\n\n#\n# texinfo styles (@foo{bar}) to HTML ones\n#\n%style_map = (\n\t      'acronym', '&do_acronym',\n\t      'asis', '',\n\t      'b', 'B',\n\t      'cite', 'CITE',\n\t      'code', 'CODE',\n\t      'command', 'CODE',\n\t      'ctrl', '&do_ctrl',\t# special case\n\t      'dfn', 'EM',\t\t# DFN tag is illegal in the standard\n\t      'dmn', '',\t\t# useless\n\t      'email', '&do_email',     # insert a clickable email address\n\t      'emph', 'EM',\n\t      'env', 'CODE',\n\t      'file', '\"TT',\t\t# will put quotes, cf. &apply_style\n\t      'i', 'I',\n\t      'kbd', 'KBD',\n\t      'key', 'KBD',\n\t      'math', '&do_math',\n\t      'option', '\"SAMP',        # will put quotes, cf. &apply_style\n\t      'r', '',\t\t\t# unsupported\n\t      'samp', '\"SAMP',\t\t# will put quotes, cf. &apply_style\n\t      'sc', '&do_sc',\t\t# special case\n\t      'strong', 'STRONG',\n\t      't', 'TT',\n\t      'titlefont', '',\t\t# useless\n\t      'uref', '&do_uref',       # insert a clickable URL\n\t      'url', '&do_url',         # insert a clickable URL\n\t      'var', 'VAR',\n\t      'w', '',\t\t\t# unsupported\n\t      'H', '&do_accent',\n\t      'dotaccent', '&do_accent',\n\t      'ringaccent','&do_accent',\n\t      'tieaccent', '&do_accent',\n\t      'u','&do_accent',\n\t      'ubaraccent','&do_accent',\n\t      'udotaccent','&do_accent',\n\t      'v', '&do_accent',\n\t      ',', '&do_accent',\n\t      'dotless', '&do_accent'\n\t      );\n\n#\n# texinfo format (@foo/@end foo) to HTML ones\n#\n%format_map = (\n\t       'quotation', 'BLOCKQUOTE',\n\t       # lists\n\t       'itemize', 'UL',\n\t       'enumerate', 'OL',\n\t       # poorly supported\n\t       'flushleft', 'PRE',\n\t       'flushright', 'PRE',\n\t       );\n\n#\n# an eval of these $complex_format_map->{what}->[0] yields beginning\n# an eval of these $complex_format_map->{what}->[1] yieleds end\n$complex_format_map =\n{\n example => \n [\n  q{\"<TABLE><tr>$T2H_EXAMPLE_INDENT_CELL<td class=example><pre>\"},\n  q{'</pre></td></tr></table>'}\n ],\n smallexample => \n [\n  q{\"<TABLE><tr>$T2H_SMALL_EXAMPLE_INDENT_CELL<td class=smallexample><FONT SIZE=$T2H_SMALL_FONT_SIZE><pre>\"},\n  q{'</FONT></pre></td></tr></table>'}\n ],\n display =>\n [\n  q{\"<TABLE><tr>$T2H_EXAMPLE_INDENT_CELL<td class=display><pre \" . 'style=\"font-family: serif\">'},\n  q{'</pre></td></tr></table>'}\n ],\n smalldisplay =>\n [\n  q{\"<TABLE><tr>$T2H_SMALL_EXAMPLE_INDENT_CELL<td class=smalldisplay><FONT SIZE=$T2H_SMALL_FONT_SIZE><pre \" . 'style=\"font-family: serif\">'},\n  q{'</pre></FONT></td></tr></table>'}\n ]\n};\n\n$complex_format_map->{lisp} = $complex_format_map->{example};\n$complex_format_map->{smalllisp} = $complex_format_map->{smallexample};\n$complex_format_map->{format} = $complex_format_map->{display};\n$complex_format_map->{smallformat} = $complex_format_map->{smalldisplay};\n\n#\n# texinfo definition shortcuts to real ones\n#\n%def_map = (\n\t    # basic commands\n\t    'deffn', 0,\n\t    'defvr', 0,\n\t    'deftypefn', 0,\n\t    'deftypevr', 0,\n\t    'defcv', 0,\n\t    'defop', 0,\n\t    'deftp', 0,\n\t    # basic x commands\n\t    'deffnx', 0,\n\t    'defvrx', 0,\n\t    'deftypefnx', 0,\n\t    'deftypevrx', 0,\n\t    'defcvx', 0,\n\t    'defopx', 0,\n\t    'deftpx', 0,\n\t    # shortcuts\n\t    'defun', 'deffn Function',\n\t    'defmac', 'deffn Macro',\n\t    'defspec', 'deffn {Special Form}',\n\t    'defvar', 'defvr Variable',\n\t    'defopt', 'defvr {User Option}',\n\t    'deftypefun', 'deftypefn Function',\n\t    'deftypevar', 'deftypevr Variable',\n\t    'defivar', 'defcv {Instance Variable}',\n\t    'deftypeivar', 'defcv {Instance Variable}', # NEW: FIXME\n\t    'defmethod', 'defop Method',\n\t    'deftypemethod', 'defop Method', # NEW:FIXME\n\t    # x shortcuts\n\t    'defunx', 'deffnx Function',\n\t    'defmacx', 'deffnx Macro',\n\t    'defspecx', 'deffnx {Special Form}',\n\t    'defvarx', 'defvrx Variable',\n\t    'defoptx', 'defvrx {User Option}',\n\t    'deftypefunx', 'deftypefnx Function',\n\t    'deftypevarx', 'deftypevrx Variable',\n\t    'defivarx', 'defcvx {Instance Variable}',\n\t    'defmethodx', 'defopx Method',\n\t    );\n\n#\n# things to skip\n#\n%to_skip = (\n\t    # comments\n\t    'c', 1,\n\t    'comment', 1,\n            'ifnotinfo', 1,\n            'ifnottex', 1,\n\t    'ifhtml', 1,\n\t    'end ifhtml', 1,\n            'end ifnotinfo', 1,\n            'end ifnottex', 1,\n\t    # useless\n\t    'detailmenu', 1,\n            'direntry', 1,\n\t    'contents', 1,\n\t    'shortcontents', 1,\n\t    'summarycontents', 1,\n\t    'footnotestyle', 1,\n\t    'end ifclear', 1,\n\t    'end ifset', 1,\n\t    'titlepage', 1,\n\t    'end titlepage', 1,\n\t    # unsupported commands (formatting)\n\t    'afourpaper', 1,\n\t    'cropmarks', 1,\n\t    'finalout', 1,\n\t    'headings', 1,\n            'sp', 1,\n\t    'need', 1,\n\t    'page', 1,\n\t    'setchapternewpage', 1,\n\t    'everyheading', 1,\n\t    'everyfooting', 1,\n\t    'evenheading', 1,\n\t    'evenfooting', 1,\n\t    'oddheading', 1,\n\t    'oddfooting', 1,\n\t    'smallbook', 1,\n\t    'vskip', 1,\n\t    'filbreak', 1,\n\t    'paragraphindent', 1,\n\t    # unsupported formats\n\t    'cartouche', 1,\n\t    'end cartouche', 1,\n\t    'group', 1,\n\t    'end group', 1,\n\t    );\n\n#+++############################################################################\n#                                                                              #\n# Argument parsing, initialisation                                             #\n#                                                                              #\n#---############################################################################\n\n#\n# flush stdout and stderr after every write\n#\nselect(STDERR);\n$| = 1;\nselect(STDOUT);\n$| = 1;\n\n\n%value = ();\t\t\t\t# hold texinfo variables, see also -D\n$use_bibliography = 1;\n$use_acc = 1;\n\n#\n# called on -init-file\nsub LoadInitFile\n{\n  my $init_file = shift;\n  # second argument is value of options\n  $init_file = shift;\n  if (-f $init_file)\n  {\n    print \"# reading initialization file from $init_file\\n\" \n      if ($T2H_VERBOSE);\n    require($init_file);\n  }\n  else\n  {\n    print \"$ERROR Error: can't read init file $int_file\\n\";\n    $init_file = '';\n  }\n}\n\n#\n# called on -lang\nsub SetDocumentLanguage\n{\n  my $lang = shift;\n  if (! exists($T2H_WORDS->{$lang}))\n  {\n    warn \"$ERROR: Language specs for '$lang' do not exists. Reverting to '\" . \n      ($T2H_LANG ? T2H_LANG : \"en\") . \"'\\n\";\n  }\n  else\n  {\n    print \"# using '$lang' as document language\\n\" if ($T2H_VERBOSE);\n    $T2H_LANG = $lang;\n  }\n}\n\n##\n## obsolete cmd line options\n##\n$T2H_OBSOLETE_OPTIONS -> {'no-section_navigation'} =\n{\n type => '!',\n linkage => sub {$main::T2H_SECTION_NAVIGATION = 0;},\n verbose => 'obsolete, use -nosec_nav',\n noHelp => 2,\n};\n$T2H_OBSOLETE_OPTIONS -> {use_acc} =\n{\n type => '!',\n linkage => \\$use_acc,\n verbose => 'obsolete',\n noHelp => 2\n};\n$T2H_OBSOLETE_OPTIONS -> {expandinfo} =\n{\n type => '!',\n linkage => sub {$main::T2H_EXPAND = 'info';},\n verbose => 'obsolete, use \"-expand info\" instead',\n noHelp => 2,\n};\n$T2H_OBSOLETE_OPTIONS -> {expandtex} =\n{\n type => '!',\n linkage => sub {$main::T2H_EXPAND = 'tex';},\n verbose => 'obsolete, use \"-expand tex\" instead',\n noHelp => 2,\n};\n$T2H_OBSOLETE_OPTIONS -> {monolithic} =\n{\n type => '!',\n linkage => sub {$main::T2H_SPLIT = '';},\n verbose => 'obsolete, use \"-split no\" instead',\n noHelp => 2\n};\n$T2H_OBSOLETE_OPTIONS -> {split_node} =\n{\n type => '!',\n linkage => sub{$main::T2H_SPLIT = 'section';},\n verbose => 'obsolete, use \"-split section\" instead',\n noHelp => 2,\n};\n$T2H_OBSOLETE_OPTIONS -> {split_chapter} =\n{\n type => '!',\n linkage => sub{$main::T2H_SPLIT = 'chapter';},\n verbose => 'obsolete, use \"-split chapter\" instead',\n noHelp => 2,\n};\n$T2H_OBSOLETE_OPTIONS -> {no_verbose} =\n{\n type => '!',\n linkage => sub {$main::T2H_VERBOSE = 0;},\n verbose => 'obsolete, use -noverbose instead',\n noHelp => 2,\n};\n$T2H_OBSOLETE_OPTIONS -> {output_file} =\n{\n type => '=s',\n linkage => sub {$main::T2H_OUT = @_[1]; $T2H_SPLIT = '';},\n verbose => 'obsolete, use -out_file instead',\n noHelp => 2\n};\n\n$T2H_OBSOLETE_OPTIONS -> {section_navigation} =\n{\n type => '!',\n linkage => \\$T2H_SECTION_NAVIGATION,\n verbose => 'obsolete, use -sec_nav instead',\n noHelp => 2,\n};\n\n$T2H_OBSOLETE_OPTIONS -> {verbose} =\n{\n type => '!',\n linkage => \\$T2H_VERBOSE,\n verbose => 'obsolete, use -Verbose instead',\n noHelp => 2\n};\n\n# read initialzation from $sysconfdir/texi2htmlrc or $HOME/.texi2htmlrc\nmy $home = $ENV{HOME};\ndefined($home) or $home = '';\nforeach $i ('/usr/local/etc/texi2htmlrc', \"$home/.texi2htmlrc\") {\n    if (-f $i) {\n\tprint \"# reading initialization file from $i\\n\" \n\t    if ($T2H_VERBOSE);\n\trequire($i);\n    }\n}\n\n\n#+++############################################################################\n#                                                                              #\n# parse command-line options\n#                                                                              #\n#---############################################################################\n$T2H_USAGE_TEXT = <<EOT;\nUsage: texi2html  [OPTIONS] TEXINFO-FILE\nTranslates Texinfo source documentation to HTML.\nEOT\n$T2H_FAILURE_TEXT = <<EOT;\nTry 'texi2html -help' for usage instructions.\nEOT\n$options = new Getopt::MySimple;\n\n# some older version of GetOpt::Long don't have \n# Getopt::Long::Configure(\"pass_through\")\neval {Getopt::Long::Configure(\"pass_through\");};\n$Configure_failed = $@ && <<EOT;\n**WARNING: Parsing of obsolete command-line options could have failed. \n           Consider to use only documented command-line options (run\n           'texi2html -help 2' for a complete list) or upgrade to perl \n           version 5.005 or higher.\nEOT\n\nif (! $options->getOptions($T2H_OPTIONS, $T2H_USAGE_TEXT, \"$THISVERSION\\n\"))\n{\n  print $Configure_failed if $Configure_failed;\n  die $T2H_FAILURE_TEXT;\n}\n\nif (@ARGV > 1)\n{\n  eval {Getopt::Long::Configure(\"no_pass_through\");};\n  if (! $options->getOptions($T2H_OBSOLETE_OPTIONS, $T2H_USAGE_TEXT, \"$THISVERSION\\n\"))\n  {\n    print $Configure_failed if $Configure_failed;\n    die $T2H_FAILURE_TEXT;\n  }\n}\n\nif ($T2H_CHECK) {\n    die \"Need file to check\\n$T2H_FAILURE_TEXT\" unless @ARGV > 0;\n    &check;\n    exit;\n}\n\n#+++############################################################################\n#                                                                              #\n# evaluation of cmd line options\n#                                                                              #\n#---############################################################################\n\nif ($T2H_EXPAND eq 'info') \n{\n  $to_skip{'ifinfo'} = 1;\n  $to_skip{'end ifinfo'} = 1;\n} \nelsif ($T2H_EXPAND eq 'tex')\n{\n  $to_skip{'iftex'} = 1;\n  $to_skip{'end iftex'} = 1;\n  \n}\n\n$T2H_INVISIBLE_MARK = '<IMG SRC=\"invisible.xbm\">' if $T2H_INVISIBLE_MARK eq 'xbm';\n\n#\n# file name buisness\n#\ndie \"Need exactly one file to translate\\n$T2H_FAILURE_TEXT\" unless @ARGV == 1;\n$docu = shift(@ARGV);\nif ($docu =~ /.*\\//) {\n    chop($docu_dir = $&);\n    $docu_name = $';\n} else {\n    $docu_dir = '.';\n    $docu_name = $docu;\n}\nunshift(@T2H_INCLUDE_DIRS, $docu_dir);\n$docu_name =~ s/\\.te?x(i|info)?$//;\t# basename of the document\n$docu_name = $T2H_PREFIX if ($T2H_PREFIX);\n\n# subdir\nif ($T2H_SUBDIR && ! $T2H_OUT)\n{\n  $T2H_SUBDIR =~ s|/*$||;\n  unless (-d \"$T2H_SUBDIR\" && -w \"$T2H_SUBDIR\")\n  {\n    if ( mkdir($T2H_SUBDIR, oct(755)))\n    {\n      print \"# created directory $T2H_SUBDIR\\n\" if ($T2H_VERBOSE);\n    }\n    else\n    {\n      warn \"$ERROR can't create directory $T2H_SUBDIR. Put results into current directory\\n\";\n      $T2H_SUBDIR = '';\n    }\n  }\n}\n\nif ($T2H_SUBDIR && ! $T2H_OUT)\n{\n  $docu_rdir = \"$T2H_SUBDIR/\";\n  print \"# putting result files into directory $docu_rdir\\n\" if ($T2H_VERBOSE);\n}\nelse\n{\n  if ($T2H_OUT && $T2H_OUT =~ m|(.*)/|)\n  {\n    $docu_rdir = \"$1/\";\n    print \"# putting result files into directory $docu_rdir\\n\" if ($T2H_VERBOSE);\n  }\n  else\n  {\n    print \"# putting result files into current directory \\n\" if ($T2H_VERBOSE);\n    $docu_rdir = '';\n  }\n}\n\n# extension\nif ($T2H_SHORTEXTN)\n{\n  $docu_ext = \"htm\";\n}\nelse\n{\n  $docu_ext = \"html\";\n}\nif ($T2H_TOP_FILE =~ /\\..*$/)\n{\n  $T2H_TOP_FILE = $`.\".$docu_ext\";\n}\n\n# result files\nif (! $T2H_OUT && ($T2H_SPLIT =~ /section/i || $T2H_SPLIT =~ /node/i))\n{\n  $T2H_SPLIT = 'section';\n}\nelsif (! $T2H_OUT && $T2H_SPLIT =~ /chapter/i)\n{\n  $T2H_SPLIT = 'chapter'\n}\nelse\n{\n  undef $T2H_SPLIT;\n}\n\n$docu_doc = \"$docu_name.$docu_ext\";\t\t# document's contents\n$docu_doc_file = \"$docu_rdir$docu_doc\";\nif ($T2H_SPLIT) \n{\n  $docu_toc  = $T2H_TOC_FILE || \"${docu_name}_toc.$docu_ext\"; # document's table of contents\n  $docu_stoc = \"${docu_name}_ovr.$docu_ext\"; # document's short toc\n  $docu_foot = \"${docu_name}_fot.$docu_ext\"; # document's footnotes\n  $docu_about = \"${docu_name}_abt.$docu_ext\"; # about this document\n  $docu_top  = $T2H_TOP_FILE || $docu_doc;\n}\nelse\n{\n  if ($T2H_OUT)\n  {\n    $docu_doc = $T2H_OUT;\n    $docu_doc =~ s|.*/||;\n  }\n  $docu_toc = $docu_foot = $docu_stoc = $docu_about = $docu_top = $docu_doc;\n}\n\n$docu_toc_file  = \"$docu_rdir$docu_toc\";\n$docu_stoc_file = \"$docu_rdir$docu_stoc\";\n$docu_foot_file = \"$docu_rdir$docu_foot\";\n$docu_about_file = \"$docu_rdir$docu_about\";\n$docu_top_file  = \"$docu_rdir$docu_top\";\n\n$docu_frame_file =     \"$docu_rdir${docu_name}_frame.$docu_ext\";\n$docu_toc_frame_file = \"$docu_rdir${docu_name}_toc_frame.$docu_ext\";\n\n#\n# variables\n#\n$value{'html'} = 1;\t\t\t# predefine html (the output format)\n$value{'texi2html'} = $THISVERSION;\t# predefine texi2html (the translator)\n# _foo: internal to track @foo\nforeach ('_author', '_title', '_subtitle',\n\t '_settitle', '_setfilename', '_shorttitle') {\n    $value{$_} = '';\t\t        # prevent -w warnings\n}\n%node2sec = ();\t\t\t\t# node to section name\n%sec2node = ();\t\t\t\t# section to node name\n%sec2number = ();                       # section to number\n%number2sec = ();                       # number to section \n%idx2node = ();                         # index keys to node\n%node2href = ();\t\t\t# node to HREF\n%node2next = ();\t\t\t# node to next\n%node2prev = ();\t\t\t# node to prev\n%node2up   = ();\t\t\t# node to up\n%bib2href = ();\t\t\t\t# bibliography reference to HREF\n%gloss2href = ();\t\t\t# glossary term to HREF\n@sections = ();\t\t\t\t# list of sections\n%tag2pro = ();\t\t\t\t# protected sections\n\n#\n# initial indexes\n#\n$bib_num = 0;\n$foot_num = 0;\n$gloss_num = 0;\n$idx_num = 0;\n$sec_num = 0;\n$doc_num = 0;\n$html_num = 0;\n\n#\n# can I use ISO8879 characters? (HTML+)\n#\nif ($T2H_USE_ISO) {\n    $things_map{'bullet'} = \"&bull;\";\n    $things_map{'copyright'} = \"&copy;\";\n    $things_map{'dots'} = \"&hellip;\";\n    $things_map{'equiv'} = \"&equiv;\";\n    $things_map{'expansion'} = \"&rarr;\";\n    $things_map{'point'} = \"&lowast;\";\n    $things_map{'result'} = \"&rArr;\";\n}\n\n#\n# read texi2html extensions (if any)\n#\n$extensions = 'texi2html.ext'; # extensions in working directory\nif (-f $extensions) {\n    print \"# reading extensions from $extensions\\n\" if $T2H_VERBOSE;\n    require($extensions);\n}\n($progdir = $0) =~ s/[^\\/]+$//;\nif ($progdir && ($progdir ne './')) {\n    $extensions = \"${progdir}texi2html.ext\"; # extensions in texi2html directory\n    if (-f $extensions) {\n\tprint \"# reading extensions from $extensions\\n\" if $T2H_VERBOSE;\n\trequire($extensions);\n    }\n}\n\n\nprint \"# reading from $docu\\n\" if $T2H_VERBOSE;\n\n#########################################################################\n#\n# latex2html stuff\n# \n# latex2html conversions consist of three stages:\n# 1) ToLatex: Put \"latex\" code into a latex file\n# 2) ToHtml: Use latex2html to generate corresponding html code and images\n# 3) FromHtml: Extract generated code and images from latex2html run\n#\n\n##########################\n# default settings\n#\n\n# defaults for files and names\n\nsub l2h_Init \n{\n  local($root) = @_;\n  \n  return 0 unless ($root);\n  \n  $l2h_name =  \"${root}_l2h\";\n  \n  $l2h_latex_file = \"$docu_rdir${l2h_name}.tex\";\n  $l2h_cache_file = \"${docu_rdir}l2h_cache.pm\";\n  $T2H_L2H_L2H = \"latex2html\" unless ($T2H_L2H_L2H);\n  \n  # destination dir -- generated images are put there, should be the same\n  # as dir of enclosing html document -- \n  $l2h_html_file = \"$docu_rdir${l2h_name}.html\";\n  $l2h_prefix = \"${l2h_name}_\";\n  return 1;\n}\n\n\n##########################\n# \n# First stage: Generation of Latex file\n# Initialize with: l2h_InitToLatex\n# Add content with: l2h_ToLatex($text) --> HTML placeholder comment\n# Finish with: l2h_FinishToLatex\n# \n\n$l2h_latex_preample = <<EOT;\n% This document was automatically generated by the l2h extenstion of texi2html\n% DO NOT EDIT !!!\n\\\\documentclass{article}\n\\\\usepackage{html}\n\\\\begin{document}\nEOT\n\n$l2h_latex_closing = <<EOT;\n\\\\end{document}\nEOT\n\n# return used latex 1, if l2h could be initalized properly, 0 otherwise\nsub l2h_InitToLatex\n{\n  %l2h_to_latex = ();\n  unless ($T2H_L2H_SKIP)\n  {\n    unless (open(L2H_LATEX, \">$l2h_latex_file\"))\n    {\n      warn \"$ERROR Error l2h: Can't open latex file '$latex_file' for writing\\n\";\n      return 0;\n    }  \n    print \"# l2h: use ${l2h_latex_file} as latex file\\n\" if ($T2H_VERBOSE);\n    print L2H_LATEX $l2h_latex_preample;\n  }\n  # open database for caching\n  l2h_InitCache();\n  $l2h_latex_count = 0;\n  $l2h_to_latex_count = 0;\n  $l2h_cached_count = 0;\n  return  1;\n}\n\n# print text (1st arg) into latex file (if not already there), return\n# HTML commentary which can be later on replaced by the latex2html\n# generated text\nsub l2h_ToLatex\n{\n  my($text) = @_;\n  my($count);\n  \n  $l2h_to_latex_count++;\n  $text =~ s/(\\s*)$//;\n  \n  # try whether we can cache it\n  my $cached_text = l2h_FromCache($text);\n  if ($cached_text)\n  {\n    $l2h_cached_count++;\n    return $cached_text;\n  }\n  \n  # try whether we have text already on things to do\n  unless ($count = $l2h_to_latex{$text})\n  {\n    $count = $l2h_latex_count;\n    $l2h_latex_count++;\n    $l2h_to_latex{$text} = $count;\n    $l2h_to_latex[$count] = $text;\n    unless ($T2H_L2H_SKIP)\n    {\n      print L2H_LATEX \"\\\\begin{rawhtml}\\n\";\n      print L2H_LATEX \"<!-- l2h_begin ${l2h_name} ${count} -->\\n\";\n      print L2H_LATEX \"\\\\end{rawhtml}\\n\";\n      \n      print L2H_LATEX \"$text\\n\";\n      \n      print L2H_LATEX \"\\\\begin{rawhtml}\\n\";\n      print L2H_LATEX \"<!-- l2h_end ${l2h_name} ${count} -->\\n\";\n      print L2H_LATEX \"\\\\end{rawhtml}\\n\";\n    }\n  }\n  return \"<!-- l2h_replace ${l2h_name} ${count} -->\"; \n}\n\n# print closing into latex file and close it\nsub l2h_FinishToLatex\n{\n  local ($reused);\n  \n  $reused = $l2h_to_latex_count - $l2h_latex_count - $l2h_cached_count;\n  unless ($T2H_L2H_SKIP)\n  {\n    print L2H_LATEX $l2h_latex_closing;\n    close(L2H_LATEX);\n  }\n  print \"# l2h: finished to latex ($l2h_cached_count cached, $reused reused, $l2h_latex_count contents)\\n\" if ($T2H_VERBOSE);\n  unless ($l2h_latex_count)\n  {\n    l2h_Finish();\n    return 0;\n  }\n  return 1;\n}\n\n###################################\n# Second stage: Use latex2html to generate corresponding html code and images\n#\n# l2h_ToHtml([$l2h_latex_file, [$l2h_html_dir]]):\n#   Call latex2html on $l2h_latex_file\n#   Put images (prefixed with $l2h_name.\"_\") and html file(s) in $l2h_html_dir\n#   Return 1, on success\n#          0, otherwise\n#\nsub l2h_ToHtml\n{\n  local($call, $ext, $root, $dotbug);\n  \n  if ($T2H_L2H_SKIP)\n  {\n    print \"# l2h: skipping latex2html run\\n\" if ($T2H_VERBOSE);\n    return 1;\n  }\n  \n  # Check for dot in directory where dvips will work\n  if ($T2H_L2H_TMP)\n  {\n    if ($T2H_L2H_TMP =~ /\\./)\n    {\n      warn \"$ERROR Warning l2h: l2h_tmp dir contains a dot. Use /tmp, instead\\n\";\n      $dotbug = 1;\n    }\n  }\n  else\n  {\n    if (&getcwd =~ /\\./)\n    {\n     warn \"$ERROR Warning l2h: current dir contains a dot. Use /tmp as l2h_tmp dir \\n\";\n     $dotbug = 1;\n   }\n  }\n  # fix it, if necessary and hope that it works \n  $T2H_L2H_TMP = \"/tmp\" if ($dotbug);\n    \n  $call = $T2H_L2H_L2H;\n  # use init file, if specified\n  $call = $call . \" -init_file \" . $init_file if ($init_file && -f $init_file);\n  # set output dir\n  $call .=  ($docu_rdir ? \" -dir $docu_rdir\" : \" -no_subdir\");\n  # use l2h_tmp, if specified\n  $call = $call . \" -tmp $T2H_L2H_TMP\" if ($T2H_L2H_TMP);\n  # options we want to be sure of\n  $call = $call .\" -address 0 -info 0 -split 0 -no_navigation -no_auto_link\";\n  $call = $call .\" -prefix ${l2h_prefix} $l2h_latex_file\"; \n\n  print \"# l2h: executing '$call'\\n\" if ($T2H_VERBOSE);\n  if (system($call))\n  {\n    warn \"l2h ***Error: '${call}' did not succeed\\n\";\n    return 0;\n  }\n  else\n  {\n    print \"# l2h: latex2html finished successfully\\n\" if ($T2H_VERBOSE);\n    return 1;\n  }\n}\n\n# this is directly pasted over from latex2html\nsub getcwd {\n    local($_) = `pwd`;\n\n    die \"'pwd' failed (out of memory?)\\n\"\n\tunless length;\n    chop;\n    $_;\n}\n\n\n##########################\n# Third stage: Extract generated contents from latex2html run\n# Initialize with: l2h_InitFromHtml\n#   open $l2h_html_file for reading\n#   reads in contents into array indexed by numbers\n#   return 1,  on success -- 0, otherwise\n# Extract Html code with: l2h_FromHtml($text)\n#   replaces in $text all previosuly inserted comments by generated html code\n#   returns (possibly changed) $text\n# Finish with: l2h_FinishFromHtml\n#   closes $l2h_html_dir/$l2h_name.\".$docu_ext\" \n\nsub l2h_InitFromHtml\n{\n  local($h_line, $h_content, $count, %l2h_img);\n\n  if (! open(L2H_HTML, \"<${l2h_html_file}\"))\n  {\n    print \"$ERROR Error l2h: Can't open ${l2h_html_file} for reading\\n\";\n    return 0;\n  }\n  print \"# l2h: use ${l2h_html_file} as html file\\n\" if ($T2H_VERBOSE);\n\n  $l2h_html_count = 0;\n  \n  while ($h_line = <L2H_HTML>)\n  {\n    if ($h_line =~ /^<!-- l2h_begin $l2h_name ([0-9]+) -->/)\n    {\n      $count = $1;\n      $h_content = \"\";\n      while ($h_line = <L2H_HTML>)\n      {\n\tif ($h_line =~ /^<!-- l2h_end $l2h_name $count -->/)\n\t{\n\t  chomp $h_content;\n\t  chomp $h_content;\n\t  $l2h_html_count++;\n\t  $h_content = l2h_ToCache($count, $h_content);\n\t  $l2h_from_html[$count] = $h_content;\n\t  $h_content = '';\n\t  last;\n\t}\n\t$h_content = $h_content.$h_line;\n      }\n      if ($hcontent)\n      {\n\tprint \"$ERROR Warning l2h: l2h_end $l2h_name $count not found\\n\" \n\t  if ($T2H_VERBOSE);\n\tclose(L2H_HTML);\n\treturn 0;\n      }\n    }\n  }\n  print \"# l2h: Got $l2h_html_count of $l2h_latex_count html contents\\n\"\n    if ($T2H_VERBOSE);\n\n  close(L2H_HTML);\n  return 1;\n}\n\nsub l2h_FromHtml\n{\n  local($text) = @_;\n  local($done, $to_do, $count);\n  \n  $to_do = $text;\n  \n  while ($to_do =~ /([^\\000]*)<!-- l2h_replace $l2h_name ([0-9]+) -->([^\\000]*)/)\n  {\n    $to_do = $1;\n    $count = $2;\n    $done = $3.$done;\n    \n    $done = \"<!-- l2h_end $l2h_name $count -->\".$done\n      if ($T2H_DEBUG & $DEBUG_L2H);\n\n    $done = &l2h_ExtractFromHtml($count) . $done;\n\n    $done = \"<!-- l2h_begin $l2h_name $count -->\".$done\n      if ($T2H_DEBUG & $DEBUG_L2H);\n  }\n  return $to_do.$done;\n}\n\n\nsub l2h_ExtractFromHtml\n{\n  local($count) = @_;\n  \n  return $l2h_from_html[$count] if ($l2h_from_html[$count]);\n  \n  if ($count >= 0 && $count < $l2h_latex_count)\n  {\n    # now we are in trouble\n    local($l_l2h, $_);\n\n    $l2h_extract_error++;\n    print \"$ERROR l2h: can't extract content $count from html\\n\" \n      if ($T2H_VERBOSE);\n    # try simple (ordinary) substition (without l2h)\n    $l_l2h = $T2H_L2H;\n    $T2H_L2H = 0;\n    $_ = $l2h_to_latex{$count};\n    $_ = &substitute_style($_); \n    &unprotect_texi;\n    $_ = \"<!-- l2h: \". __LINE__ . \" use texi2html -->\" . $_\n      if ($T2H_DEBUG & $DEBUG_L2H);\n    $T2H_L2H = $l_l2h;\n    return $_;\n  }\n  else\n  {\n    # now we have been incorrectly called\n    $l2h_range_error++;\n    print \"$ERROR l2h: Request of $count content which is out of valide range [0,$l2h_latex_count)\\n\";\n    return \"<!-- l2h: \". __LINE__ . \" out of range count $count -->\"\n      if ($T2H_DEBUG & $DEBUG_L2H);\n    return \"<!-- l2h: out of range count $count -->\";\n  }\n}\n    \nsub l2h_FinishFromHtml\n{\n  if ($T2H_VERBOSE)\n  {\n    if ($l2h_extract_error + $l2h_range_error)\n    {\n      print \"# l2h: finished from html ($l2h_extract_error extract and $l2h_range_error errors)\\n\";\n    }\n    else\n    {\n      print \"# l2h: finished from html (no errors)\\n\";\n    }\n  }\n}\n\nsub l2h_Finish\n{\n  l2h_StoreCache();\n  if ($T2H_L2H_CLEAN)\n  {\n    print \"# l2h: removing temporary files generated by l2h extension\\n\"\n      if $T2H_VERBOSE;\n    while (<\"$docu_rdir$l2h_name\"*>)\n    {\n      unlink $_;\n    }\n  }\n  print \"# l2h: Finished\\n\" if $T2H_VERBOSE;\n  return 1;\n}\n\n##############################\n# stuff for l2h caching\n#\n\n# I tried doing this with a dbm data base, but it did not store all\n# keys/values. Hence, I did as latex2html does it\nsub l2h_InitCache\n{\n  if (-r \"$l2h_cache_file\")\n  {\n    my $rdo = do \"$l2h_cache_file\";\n    warn(\"$ERROR l2h Error: could not load $docu_rdir$l2h_cache_file: $@\\n\")\n      unless ($rdo);\n  }\n}\n\nsub l2h_StoreCache\n{\n  return unless $l2h_latex_count;\n  \n  my ($key, $value);\n  open(FH, \">$l2h_cache_file\") || return warn\"$ERROR l2h Error: could not open $docu_rdir$l2h_cache_file for writing: $!\\n\";\n\n  \n  while (($key, $value) = each %l2h_cache)\n  {\n    # escape stuff\n    $key =~ s|/|\\\\/|g;\n    $key =~ s|\\\\\\\\/|\\\\/|g;\n    # weird, a \\ at the end of the key results in an error\n    # maybe this also broke the dbm database stuff\n    $key =~ s|\\\\$|\\\\\\\\|;\n    $value =~ s/\\|/\\\\\\|/g; \n    $value =~ s/\\\\\\\\\\|/\\\\\\|/g; \n    $value =~ s|\\\\\\\\|\\\\\\\\\\\\\\\\|g;\n    print FH \"\\n\\$l2h_cache_key = q/$key/;\\n\";\n    print FH \"\\$l2h_cache{\\$l2h_cache_key} = q|$value|;\\n\";\n  }\n  print FH \"1;\";\n  close(FH);\n}\n\n# return cached html, if it exists for text, and if all pictures\n# are there, as well\nsub l2h_FromCache\n{\n  my $text = shift;\n  my $cached = $l2h_cache{$text};\n  if ($cached)\n  {\n    while ($cached =~ m/SRC=\"(.*?)\"/g)\n    {\n      unless (-e \"$docu_rdir$1\")\n      {\n\treturn undef;\n      }\n    }\n    return $cached;\n  }\n  return undef;\n}\n\n# insert generated html into cache, move away images, \n# return transformed html\n$maximage = 1;\nsub l2h_ToCache\n{\n  my $count = shift;\n  my $content = shift;\n  my @images = ($content =~ /SRC=\"(.*?)\"/g);\n  my ($src, $dest);\n\n  for $src (@images)\n  {\n    $dest = $l2h_img{$src};\n    unless ($dest)\n    {\n      my $ext;\n      if ($src =~ /.*\\.(.*)$/ && $1 ne $docu_ext)\n      {\n\t$ext = $1;\n      }\n      else\n      {\n\twarn \"$ERROR: L2h image $src has invalid extension\\n\";\n\tnext;\n      }\n      while (-e \"$docu_rdir${docu_name}_$maximage.$ext\") { $maximage++;}\n      $dest = \"${docu_name}_$maximage.$ext\";\n      system(\"cp -f $docu_rdir$src $docu_rdir$dest\");\n      $l2h_img{$src} = $dest;\n      unlink \"$docu_rdir$src\" unless ($DEBUG & DEBUG_L2H);\n    }\n    $content =~ s/$src/$dest/g;\n  }\n  $l2h_cache{$l2h_to_latex[$count]} = $content;\n  return $content;\n}\n\n\n#+++############################################################################\n#                                                                              #\n# Pass 1: read source, handle command, variable, simple substitution           #\n#                                                                              #\n#---############################################################################\n\n@lines = ();\t\t\t\t# whole document\n@toc_lines = ();\t\t\t# table of contents\n@stoc_lines = ();\t\t\t# table of contents\n$curlevel = 0;\t\t\t\t# current level in TOC\n$node = '';\t\t\t\t# current node name\n$node_next = '';                        # current node next name               \n$node_prev = '';                        # current node prev name\n$node_up = '';                          # current node up name\n$in_table = 0;\t\t\t\t# am I inside a table\n$table_type = '';\t\t\t# type of table ('', 'f', 'v', 'multi')\n@tables = ();\t\t\t        # nested table support\n$in_bibliography = 0;\t\t\t# am I inside a bibliography\n$in_glossary = 0;\t\t\t# am I inside a glossary\n$in_top = 0;\t\t\t\t# am I inside the top node\n$has_top = 0;\t\t\t\t# did I see a top node?\n$has_top_command = 0;\t\t\t# did I see @top for automatic pointers?\n$in_pre = 0;\t\t\t\t# am I inside a preformatted section\n$in_list = 0;\t\t\t\t# am I inside a list\n$in_html = 0;\t\t\t\t# am I inside an HTML section\n$first_line = 1;\t\t        # is it the first line\n$dont_html = 0;\t\t\t\t# don't protect HTML on this line\n$deferred_ref = '';\t\t\t# deferred reference for indexes\n@html_stack = ();\t\t\t# HTML elements stack\n$html_element = '';\t\t\t# current HTML element\n&html_reset;\n%macros = ();                           # macros\n\n# init l2h\n$T2H_L2H = &l2h_Init($docu_name) if ($T2H_L2H);\n$T2H_L2H = &l2h_InitToLatex      if ($T2H_L2H);    \n\n# build code for simple substitutions\n# the maps used (%simple_map and %things_map) MUST be aware of this\n# watch out for regexps, / and escaped characters!\n$subst_code = '';\nforeach (keys(%simple_map)) {\n    ($re = $_) =~ s/(\\W)/\\\\$1/g; # protect regexp chars\n    $subst_code .= \"s/\\\\\\@$re/$simple_map{$_}/g;\\n\";\n}\nforeach (keys(%things_map)) {\n    $subst_code .= \"s/\\\\\\@$_\\\\{\\\\}/$things_map{$_}/g;\\n\";\n}\nif ($use_acc) {\n    # accentuated characters\n    foreach (keys(%accent_map)) {\n\tif ($_ eq \"`\") {\n\t    $subst_code .= \"s/$;3\";\n\t} elsif ($_ eq \"'\") {\n\t    $subst_code .= \"s/$;4\";\n\t} else {\n\t    $subst_code .= \"s/\\\\\\@\\\\$_\";\n\t}\n\t$subst_code .= \"([a-z])/&\\${1}$accent_map{$_};/gi;\\n\";\n    }\n}\neval(\"sub simple_substitutions { $subst_code }\");\n\n&init_input;\nINPUT_LINE: while ($_ = &next_line) {\n    #\n    # remove \\input on the first lines only\n    #\n    if ($first_line) {\n\tnext if /^\\\\input/;\n\t$first_line = 0;\n    }\n    # non-@ substitutions cf. texinfmt.el\n    #\n    # parse texinfo tags\n    #\n    $tag = '';\n    $end_tag = '';\n    if (/^\\s*\\@end\\s+(\\w+)\\b/) {\n\t$end_tag = $1;\n    } elsif (/^\\s*\\@(\\w+)\\b/) {\n\t$tag = $1;\n    }\n    #\n    # handle @html / @end html\n    #\n    if ($in_html) {\n\tif ($end_tag eq 'html') {\n\t    $in_html = 0;\n\t} else {\n\t    $tag2pro{$in_html} .= $_;\n\t}\n\tnext;\n    } elsif ($tag eq 'html') {\n\t$in_html = $PROTECTTAG . ++$html_num;\n\tpush(@lines, $in_html);\n\tnext;\n    }\n\n    #\n    # try to remove inlined comments\n    # syntax from tex-mode.el comment-start-skip\n    #\n    s/((^|[^\\@])(\\@\\@)*)\\@c(omment | |\\{|$).*/$1/;\n\n# Sometimes I use @c right at the end of  a line ( to suppress the line feed )\n#    s/((^|[^\\@])(\\@\\@)*)\\@c(omment)?$/$1/;\n#     s/((^|[^\\@])(\\@\\@)*)\\@c(omment)? .*/$1/;\n#     s/(.*)\\@c{.*?}(.*)/$1$2/;\n#     s/(.*)\\@comment{.*?}(.*)/$1$2/;\n#     s/^(.*)\\@c /$1/;\n#     s/^(.*)\\@comment /$1/;\n\n    #############################################################\n    # value substitution before macro expansion, so that\n    # it works in macro arguments\t\t\t    \n    s/\\@value{($VARRE)}/$value{$1}/eg;\n\t\t\t    \n    #############################################################\n    # macro substitution\n    while (/\\@(\\w+)/g)\n    {\n      if (exists($macros->{$1}))    \n      {\n\tmy $before = $`;\n\tmy $name = $1;\n\tmy $after = $';\n\tmy @args;\n\tmy $args;\n\tif ($after =~ /^\\s*{(.*?[^\\\\])}(.*)/)  \n\t{\n\t  $args = $1;\n\t  $after = $2;\n\t}\n\telsif (@{$macros->{$name}->{Args}} == 1)\n\t{\n\t  $args = $after;\n\t  $args =~ s/^\\s*//;\n\t  $args =~ s/\\s*$//;\n\t  $after = '';\n\t}\n\t$args =~ s|\\\\\\\\|\\\\|g;\n\t$args =~ s|\\\\{|{|g;\n        $args =~ s|\\\\}|}|g;\n\tif (@{$macros->{$name}->{Args}} > 1)\n\t{\n\t  $args =~ s/(^|[^\\\\]),/$1$;/g ;\n\t  $args =~ s|\\\\,|,|g;\n\t  @args = split(/$;\\s*/, $args) if (@{$macros->{$name}->{Args}} > 1);\n\t}\n\telse\n\t{\n\t  $args =~ s|\\\\,|,|g;\n\t  @args = ($args);\n\t}\n\tmy $macrobody = $macros->{$name}->{Body};\n\tfor ($i=0; $i<=$#args; $i++)\n\t{\n\t  $macrobody =~ s|\\\\$macros->{$name}->{Args}->[$i]\\\\|$args[$i]|g;\n\t}\n\t$macrobody =~ s|\\\\\\\\|\\\\|g;\n\t$_ = $before . $macrobody . $after;\n\tunshift @input_spool, map {$_ = $_.\"\\n\"} split(/\\n/, $_);\n\tnext INPUT_LINE;\n      }\n    }\t\t\t\t#\n\t\t\t    \n    \n    #\n    # try to skip the line\n    #\n    if ($end_tag) {\n        $in_titlepage = 0 if $end_tag eq 'titlepage';\n\tnext if $to_skip{\"end $end_tag\"};\n    } elsif ($tag) {\n      $in_titlepage = 1 if $tag eq 'titlepage';\n      next if $to_skip{$tag};\n      last if $tag eq 'bye';\n    }\n    if ($in_top) {\n\t# parsing the top node\n\tif ($tag eq 'node' || \n\t    ($sec2level{$tag} && $tag !~ /unnumbered/ && $tag !~ /heading/))\n\t{\n\t    # no more in top\n\t    $in_top = 0;\n\t    push(@lines, $TOPEND);\n\t}\n    }\n    unless ($in_pre) {\n\ts/``/\\\"/g;\n\ts/''/\\\"/g;\n\ts/([\\w ])---([\\w ])/$1--$2/g;\n    }\n    #\n    # analyze the tag\n    #\n    if ($tag) {\n\t# skip lines\n\t&skip_until($tag), next if $tag eq 'ignore';\n\t&skip_until($tag), next if $tag eq 'ifnothtml';\n\tif ($tag eq 'ifinfo')\n\t{\n\t  &skip_until($tag), next unless $T2H_EXPAND eq 'info';\n\t}\n\tif ($tag eq 'iftex')\n\t{\n\t  &skip_until($tag), next unless $T2H_EXPAND eq 'tex';\n\t} \n\tif ($tag eq 'tex')\n\t{\n\t  # add to latex2html file\n\t  if ($T2H_EXPAND eq 'tex' && $T2H_L2H && ! $in_pre)\n\t  {\n\t    # add space to the end -- tex(i2dvi) does this, as well \n\t    push(@lines, &l2h_ToLatex(&string_until($tag) . \" \"));\n\t  }\n\t  else\n\t  {\n\t    &skip_until($tag);\n\t  }\n\t  next;\n\t}\n\tif ($tag eq 'titlepage')\n\t{\n\t  next;\n\t}\n\t# handle special tables\n\tif ($tag =~ /^(|f|v|multi)table$/) {\n\t    $table_type = $1;\n\t    $tag = 'table';\n\t}\n\t# special cases\n\tif ($tag eq 'top' || ($tag eq 'node' && /^\\@node\\s+top\\s*,/i)) {\n\t    $in_top = 1;\n\t    $has_top = 1;\n\t    $has_top_command = 1 if $tag eq 'top';\n\t    @lines = (); # ignore all lines before top (title page garbage)\n\t    next;\n\t} elsif ($tag eq 'node') {\n\t  if ($in_top)\n\t  {\n\t    $in_top = 0;\n\t    push(@lines, $TOPEND);\n\t  }\n\t  warn \"$ERROR Bad node line: $_\" unless $_ =~ /^\\@node\\s$NODESRE$/o;\n\t  # request of \"Richard Y. Kim\" <ryk@ap.com>\n\t  s/^\\@node\\s+//;\n\t  $_ = &protect_html($_); # if node contains '&' for instance\n\t  ($node, $node_next, $node_prev, $node_up) = split(/,/);\n\t  &normalise_node($node);\n\t  &normalise_node($node_next);\n\t  &normalise_node($node_prev);\n\t  &normalise_node($node_up);\n\t  $node =~ /\\\"/ ?\n\t    push @lines, &html_debug(\"<A NAME='$node'></A>\\n\", __LINE__) :\n\t    push @lines, &html_debug(\"<A NAME=\\\"$node\\\"></A>\\n\", __LINE__);\n\t  next;\n\t} elsif ($tag eq 'include') {\n\t    if (/^\\@include\\s+($FILERE)\\s*$/o) {\n\t\t$file = LocateIncludeFile($1);\n\t\tif ($file && -e $file) {\n\t\t    &open($file);\n\t\t    print \"# including $file\\n\" if $T2H_VERBOSE;\n\t\t} else {\n\t\t    warn \"$ERROR Can't find $1, skipping\";\n\t\t}\n\t    } else {\n\t\twarn \"$ERROR Bad include line: $_\";\n\t    }\n\t    next;\n\t} elsif ($tag eq 'ifclear') {\n\t    if (/^\\@ifclear\\s+($VARRE)\\s*$/o) {\n\t\tnext unless defined($value{$1});\n\t\t&skip_until($tag);\n\t    } else {\n\t\twarn \"$ERROR Bad ifclear line: $_\";\n\t    }\n\t    next;\n\t} elsif ($tag eq 'ifset') {\n\t    if (/^\\@ifset\\s+($VARRE)\\s*$/o) {\n\t\tnext if defined($value{$1});\n\t\t&skip_until($tag);\n\t    } else {\n\t\twarn \"$ERROR Bad ifset line: $_\";\n\t    }\n\t    next;\n\t} elsif ($tag eq 'menu') {\n\t    unless ($T2H_SHOW_MENU) {\n\t\t&skip_until($tag);\n\t\tnext;\n\t    }\n\t    &html_push_if($tag);\n\t    push(@lines, &html_debug('', __LINE__));\n\t} elsif ($format_map{$tag}) {\n\t    $in_pre = 1 if $format_map{$tag} eq 'PRE';\n\t    &html_push_if($format_map{$tag});\n\t    push(@lines, &html_debug('', __LINE__));\n\t    $in_list++ if $format_map{$tag} eq 'UL' || $format_map{$tag} eq 'OL' ;\n#\t    push(@lines, &debug(\"<BLOCKQUOTE>\\n\", __LINE__))\n#\t      if $tag =~ /example/i;\n\t    # sunshine@sunshineco.com: <PRE>bla</PRE> looks better than\n\t    # <PRE>\\nbla</PRE> (at least on NeXTstep browser\n\t    push(@lines, &debug(\"<$format_map{$tag}>\" . \n\t\t\t\t($in_pre ? '' : \"\\n\"), __LINE__));\n\t    next;\n\t}\n\telsif (exists $complex_format_map->{$tag})\n\t{\n\t  my $start = eval $complex_format_map->{$tag}->[0];\n\t  if ($@)\n\t  {\n\t    print \"$ERROR: eval of complex_format_map->{$tag}->[0] $complex_format_map->{$tag}->[0]: $@\";\n\t    $start = '<pre>'\n\t  }\n\t  $in_pre = 1 if $start =~ /<pre/;\n\t  push(@lines, html_debug($start. ($in_pre ? '' : \"\\n\"), __LINE__));\n\t  next;\n\t} elsif ($tag eq 'table') {\n\t  # anorland@hem2.passagen.se\n\t  # if (/^\\s*\\@(|f|v|multi)table\\s+\\@(\\w+)/) {\n\t     if (/^\\s*\\@(|f|v|multi)table\\s+\\@(\\w+)|(\\{[^\\}]*\\})/) {\n\t\t$in_table = $2;\n\t\tunshift(@tables, join($;, $table_type, $in_table));\n\t\tif ($table_type eq \"multi\") {\n\t\t    # don't use borders -- gets confused by empty cells\n\t\t    push(@lines, &debug(\"<TABLE>\\n\", __LINE__));\n\t\t    &html_push_if('TABLE');\n\t\t} else {\n\t\t    push(@lines, &debug(\"<DL COMPACT>\\n\", __LINE__));\n\t\t    &html_push_if('DL');\n\t\t}\n\t\tpush(@lines, &html_debug('', __LINE__));\n\t    } else {\n\t\twarn \"$ERROR Bad table line: $_\";\n\t    }\n\t    next;\n\t} \n\telsif ($tag eq 'synindex' || $tag eq 'syncodeindex') \n\t{\n\t  if (/^\\@$tag\\s+(\\w+)\\s+(\\w+)\\s*$/) \n\t  {\n\t    my $from = $1;\n\t    my $to = $2;\n\t    my $prefix_from = IndexName2Prefix($from);\n\t    my $prefix_to = IndexName2Prefix($to);\n\n\t    warn(\"$ERROR unknown from index name $from ind syn*index line: $_\"), next\n\t      unless $prefix_from;\n\t    warn(\"$ERROR unknown to index name $to ind syn*index line: $_\"), next\n\t      unless $prefix_to;\n\n\t    if ($tag eq 'syncodeindex')\n\t    {\n\t      $index_properties->{$prefix_to}->{'from_code'}->{$prefix_from} = 1;\n\t    }\n\t    else\n\t    {\n\t       $index_properties->{$prefix_to}->{'from'}->{$prefix_from} = 1;\n\t    }\n\t  } \n\t  else \n\t  {\n\t    warn \"$ERROR Bad syn*index line: $_\";\n\t  }\n\t  next;\n\t} \n\telsif ($tag eq 'defindex' || $tag eq 'defcodeindex') \n\t{\n\t  if (/^\\@$tag\\s+(\\w+)\\s*$/) \n\t  {\n\t    my $name = $1;\n\t    $index_properties->{$name}->{name} = $name;\n\t    $index_properties->{$name}->{code} = 1 if $tag eq 'defcodeindex';\n\t  } \n\t  else \n\t  {\n\t    warn \"$ERROR Bad defindex line: $_\";\n\t  }\n\t  next;\n\t}\n\telsif (/^\\@printindex/)\n\t{\n\t  push (@lines, \"<!--::${section}::-->$_\");\n\t  next;\n\t}\n\telsif ($tag eq 'sp') {\n\t    push(@lines, &debug(\"<P>\\n\", __LINE__));\n\t    next;\n\t} elsif ($tag eq 'center') {\n\t    push(@lines, &debug(\"<center>\\n\", __LINE__));\n\t    s/\\@center//;\n\t} elsif ($tag eq 'setref') {\n\t    &protect_html; # if setref contains '&' for instance\n\t    if (/^\\@$tag\\s*{($NODERE)}\\s*$/) {\n\t\t$setref = $1;\n\t\t$setref =~ s/\\s+/ /g; # normalize\n\t\t$setref =~ s/ $//;\n\t\t$node2sec{$setref} = $name;\n\t\t$sec2node{$name} = $setref;\n\t\t$node2href{$setref} = \"$docu_doc#$docid\";\n\t    } else {\n\t\twarn \"$ERROR Bad setref line: $_\";\n\t    }\n\t    next;\n\t} elsif ($tag eq 'lowersections') {\n\t    local ($sec, $level);\n\t    while (($sec, $level) = each %sec2level) {\n\t\t$sec2level{$sec} = $level + 1;\n\t    }\n\t    next;\n\t} elsif ($tag eq 'raisesections') {\n\t    local ($sec, $level);\n\t    while (($sec, $level) = each %sec2level) {\n\t\t$sec2level{$sec} = $level - 1;\n\t    }\n\t    next;\n\t}\n\telsif ($tag eq 'macro' || $tag eq 'rmacro')\n\t{\n\t  if (/^\\@$tag\\s*(\\w+)\\s*(.*)/)\n\t  {\n\t    my $name = $1;\n\t    my @args;\n\t    @args = split(/\\s*,\\s*/ , $1)\n\t      if ($2 =~ /^\\s*{(.*)}\\s*/);\n\t    \n\t    $macros->{$name}->{Args} = \\@args;\n\t    $macros->{$name}->{Body} = '';\n\t    while (($_ = &next_line) && $_ !~ /\\@end $tag/)\n\t    {\n\t      $macros->{$name}->{Body} .= $_;\n\t    }\n\t    die \"ERROR: No closing '\\@end $tag' found for macro definition of '$name'\\n\"\n\t      unless (/\\@end $tag/);\n\t    chomp $macros->{$name}->{Body};\n\t  }\n\t  else\n\t  {\n\t    warn \"$ERROR: Bad macro defintion $_\"\n\t  }\n\t  next;\n\t}\n\telsif ($tag eq 'unmacro')\n\t{\n\t  delete $macros->{$1} if (/^\\@unmacro\\s*(\\w+)/);\n\t  next;\n\t}\n\telsif ($tag eq 'documentlanguage')\n\t{\n\t  SetDocumentLanguage($1) if (!$T2H_LANG && /documentlanguage\\s*(\\w+)/);\n\t}\n\telsif (defined($def_map{$tag})) {\n\t    if ($def_map{$tag}) {\n\t\ts/^\\@$tag\\s+//;\n\t\t$tag = $def_map{$tag};\n\t\t$_ = \"\\@$tag $_\";\n\t\t$tag =~ s/\\s.*//;\n\t    }\n\t} elsif (defined($user_sub{$tag})) {\n\t    s/^\\@$tag\\s+//;\n\t    $sub = $user_sub{$tag};\n\t    print \"# user $tag = $sub, arg: $_\" if $T2H_DEBUG & $DEBUG_USER;\n\t    if (defined(&$sub)) {\n\t\tchop($_);\n\t\t&$sub($_);\n\t    } else {\n\t\twarn \"$ERROR Bad user sub for $tag: $sub\\n\";\n\t    }\n\t    next;\n\t  } \n\tif (defined($def_map{$tag})) {\n\t    s/^\\@$tag\\s+//;\n\t    if ($tag =~ /x$/) {\n\t\t# extra definition line\n\t\t$tag = $`;\n\t\t$is_extra = 1;\n\t    } else {\n\t\t$is_extra = 0;\n\t    }\n\t    while (/\\{([^\\{\\}]*)\\}/) {\n\t\t# this is a {} construct\n\t\t($before, $contents, $after) = ($`, $1, $');\n\t\t# protect spaces\n\t\t$contents =~ s/\\s+/$;9/g;\n\t\t# restore $_ protecting {}\n\t\t$_ = \"$before$;7$contents$;8$after\";\n\t    }\n\t    @args = split(/\\s+/, &protect_html($_));\n\t    foreach (@args) {\n\t\ts/$;9/ /g;\t# unprotect spaces\n\t\ts/$;7/\\{/g;\t# ... {\n\t\ts/$;8/\\}/g;\t# ... }\n\t    }\n\t    $type = shift(@args);\n\t    $type =~ s/^\\{(.*)\\}$/$1/;\n\t    print \"# def ($tag): {$type} \", join(', ', @args), \"\\n\"\n\t\tif $T2H_DEBUG & $DEBUG_DEF;\n\t    $type .= ':'; # it's nicer like this\n\t    my $name = shift(@args);\n\t    $name =~ s/^\\{(.*)\\}$/$1/;\n\t    if ($is_extra) {\n\t\t$_ = &debug(\"<DT>\", __LINE__);\n\t    } else {\n\t\t$_ = &debug(\"<DL>\\n<DT>\", __LINE__);\n\t    }\n\t    if ($tag eq 'deffn' || $tag eq 'defvr' || $tag eq 'deftp') {\n\t\t$_ .= \"<U>$type</U> <B>$name</B>\";\n\t\t$_ .= \" <I>@args</I>\" if @args;\n\t    } elsif ($tag eq 'deftypefn' || $tag eq 'deftypevr'\n\t\t     || $tag eq 'defcv' || $tag eq 'defop') {\n\t\t$ftype = $name;\n\t\t$name = shift(@args);\n\t\t$name =~ s/^\\{(.*)\\}$/$1/;\n\t\t$_ .= \"<U>$type</U> $ftype <B>$name</B>\";\n\t\t$_ .= \" <I>@args</I>\" if @args;\n\t    } else {\n\t\twarn \"$ERROR Unknown definition type: $tag\\n\";\n\t\t$_ .= \"<U>$type</U> <B>$name</B>\";\n\t\t$_ .= \" <I>@args</I>\" if @args;\n\t    }\n \t    $_ .= &debug(\"\\n<DD>\", __LINE__);\n\t    $name = &unprotect_html($name);\n\t    if ($tag eq 'deffn' || $tag eq 'deftypefn') {\n\t      EnterIndexEntry('f', $name, $docu_doc, $section, \\@lines);\n#\t\tunshift(@input_spool, \"\\@findex $name\\n\");\n\t    } elsif ($tag eq 'defop') {\n\t      EnterIndexEntry('f', \"$name on $ftype\", $docu_doc, $section, \\@lines);\n#\t\tunshift(@input_spool, \"\\@findex $name on $ftype\\n\");\n\t    } elsif ($tag eq 'defvr' || $tag eq 'deftypevr' || $tag eq 'defcv') {\n\t      EnterIndexEntry('v', $name, $docu_doc, $section, \\@lines);\n#\t\tunshift(@input_spool, \"\\@vindex $name\\n\");\n\t    } else {\n\t      EnterIndexEntry('t', $name, $docu_doc, $section, \\@lines);\n#\t\tunshift(@input_spool, \"\\@tindex $name\\n\");\n\t    }\n\t    $dont_html = 1;\n\t}\n    } elsif ($end_tag) {\n\tif ($format_map{$end_tag}) {\n\t    $in_pre = 0 if $format_map{$end_tag} eq 'PRE';\n\t    $in_list-- if $format_map{$end_tag} eq 'UL' || $format_map{$end_tag} eq 'OL' ;\n\t    &html_pop_if('P');\n\t    &html_pop_if('LI');\n\t    &html_pop_if();\n\t    push(@lines, &debug(\"</$format_map{$end_tag}>\\n\", __LINE__));\n\t    push(@lines, &html_debug('', __LINE__));\n\t}\n\telsif (exists $complex_format_map->{$end_tag})\n\t{\n\t  my $end = eval $complex_format_map->{$end_tag}->[1];\n\t  if ($@)\n\t  {\n\t    print \"$ERROR: eval of complex_format_map->{$end_tag}->[1] $complex_format_map->{$end_tag}->[0]: $@\";\n\t    $end = '</pre>'\n\t  }\n\t  $in_pre = 0 if $end =~ m|</pre>|;\n\t  push(@lines, html_debug($end, __LINE__));\n\t} elsif ($end_tag =~ /^(|f|v|multi)table$/) {\n\t    unless (@tables) {\n\t\twarn \"$ERROR \\@end $end_tag without \\@*table\\n\";\n\t\tnext;\n\t    }\n\t    &html_pop_if('P');\n\t    ($table_type, $in_table) = split($;, shift(@tables));\n\t    unless ($1 eq $table_type) {\n\t\twarn \"$ERROR \\@end $end_tag without matching \\@$end_tag\\n\";\n\t\tnext;\n\t    }\n\t    if ($table_type eq \"multi\") {\n\t\tpush(@lines, \"</TR></TABLE>\\n\");\n\t\t&html_pop_if('TR');\n\t    } else {\n\t\tpush(@lines, \"</DL>\\n\");\n\t\t&html_pop_if('DD');\n\t    }\n\t    &html_pop_if();\n\t    if (@tables) {\n\t\t($table_type, $in_table) = split($;, $tables[0]);\n\t    } else {\n\t\t$in_table = 0;\n\t    }\n\t} elsif (defined($def_map{$end_tag})) {\n \t    push(@lines, &debug(\"</DL>\\n\", __LINE__));\n\t} elsif ($end_tag eq 'menu') {\n\t    &html_pop_if();\n\t    push(@lines, $_); # must keep it for pass 2\n\t} \n\tnext;\n    }\n    #############################################################\n    # anchor insertion\n    while (/\\@anchor\\s*\\{(.*?)\\}/)\n    {\n      $_ = $`.$';\n      my $anchor = $1;\n      $anchor = &normalise_node($anchor);\n      push @lines, &html_debug(\"<A NAME=\\\"$anchor\\\"></A>\\n\");\n      $node2href{$anchor} = \"$docu_doc#$anchor\";\n      next INPUT_LINE if $_ =~ /^\\s*$/;\n    }\n\n    #############################################################\n    # index entry generation, after value substitutions\n    if (/^\\@(\\w+?)index\\s+/)\n    {\n      EnterIndexEntry($1, $', $docu_doc, $section, \\@lines);\n      next;\n    }\n    #\n    # protect texi and HTML things\n    &protect_texi;\n    $_ = &protect_html($_) unless $dont_html;\n    $dont_html = 0;\n    # substitution (unsupported things)\n    s/^\\@exdent\\s+//g;\n    s/\\@noindent\\s+//g;\n    s/\\@refill\\s+//g;\n    # other substitutions\n    &simple_substitutions;\n    s/\\@footnote\\{/\\@footnote$docu_doc\\{/g; # mark footnotes, cf. pass 4\n    #\n    # analyze the tag again\n    #\n    if ($tag) {\n      if (defined($sec2level{$tag}) && $sec2level{$tag} > 0) {\n\t    if (/^\\@$tag\\s+(.+)$/) {\n\t\t$name = $1;\n\t\t$name = &normalise_node($name);\n\t\t$level = $sec2level{$tag};\n\t\t# check for index\n\t\t$first_index_chapter = $node\n\t\t  if ($level == 1 && !$first_index_chapter && \n\t\t      $name =~ /index/i);\n\t\tif ($in_top && /heading/){\n\t\t    $T2H_HAS_TOP_HEADING = 1;\n                    $_ = &debug(\"<H$level>$name</H$level>\\n\", __LINE__);\n\t\t    &html_push_if('body');\n\t\t    print \"# top heading, section $name, level $level\\n\"\n\t\t\tif $T2H_DEBUG & $DEBUG_TOC;\n\t\t}\n\t\telse\n\t\t{\n\t\t  unless (/^\\@\\w*heading/)\n\t\t  {\n\t\t    unless (/^\\@unnumbered/)\n\t\t    {\n\t\t      my $number = &update_sec_num($tag, $level);\n\t\t      $name = $number. ' ' . $name if $T2H_NUMBER_SECTIONS;\n\t\t      $sec2number{$name} = $number;\n\t\t      $number2sec{$number} = $name;\n\t\t    }\n\t\t    if (defined($toplevel))\n\t\t    {\n\t\t      push @lines, ($level==$toplevel ? $CHAPTEREND : $SECTIONEND);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t      # first time we see a \"section\"\n\t\t      unless ($level == 1) \n\t\t      {\n\t\t\twarn \"$WARN The first section found is not of level 1: $_\";\n\t\t      }\n\t\t      $toplevel = $level;\n\t\t    }\n\t\t    push(@sections, $name);\n\t\t    next_doc() if ($T2H_SPLIT eq 'section' ||\n\t\t\t\t   $T2H_SPLIT && $level == $toplevel);\n\t\t  }\n\t\t  $sec_num++;\n\t\t  $docid = \"SEC$sec_num\";\n\t\t  $tocid = (/^\\@\\w*heading/ ? undef : \"TOC$sec_num\");\n\t\t  # check biblio and glossary\n\t\t  $in_bibliography = ($name =~ /^([A-Z]|\\d+)?(\\.\\d+)*\\s*bibliography$/i);\n\t\t  $in_glossary = ($name =~ /^([A-Z]|\\d+)?(\\.\\d+)*\\s*glossary$/i);\n\t\t  # check node\n\t\t  if ($node)\n\t\t  {\n\t\t    warn \"$ERROR Duplicate node found: $node\\n\"\n\t\t      if ($node2sec{$node});\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t    $name .= ' ' while ($node2sec{$name});\n\t\t    $node = $name;\n\t\t  }\n\t\t  $name .= ' ' while ($sec2node{$name});\n\t\t  $section = $name; \n\t\t  $node2sec{$node} = $name;\n\t\t  $sec2node{$name} = $node;\n\t\t  $node2href{$node} = \"$docu_doc#$docid\";\n\t\t  $node2next{$node} = $node_next;\n\t\t  $node2prev{$node} = $node_prev;\n\t\t  $node2up{$node} = $node_up;\n\t\t  print \"# node $node, section $name, level $level\\n\"\n\t\t    if $T2H_DEBUG & $DEBUG_TOC;\n\n\t\t  $node = '';\n\t\t  $node_next = '';\n\t\t  $node_prev = '';\n\t\t  $node_next = '';\n\t\t  if ($tocid)\n\t\t  {\n\t\t    # update TOC\n\t\t    while ($level > $curlevel) {\n\t\t      $curlevel++;\n\t\t      push(@toc_lines, \"<UL>\\n\");\n\t\t    }\n\t\t    while ($level < $curlevel) {\n\t\t      $curlevel--;\n\t\t      push(@toc_lines, \"</UL>\\n\");\n\t\t    }\n\t\t    $_ = &t2h_anchor($tocid, \"$docu_doc#$docid\", $name, 1);\n\t\t    $_ = &substitute_style($_);\n\t\t    push(@stoc_lines, \"$_<BR>\\n\") if ($level == 1);\n\t\t    if ($T2H_NUMBER_SECTIONS)\n\t\t    {\n\t\t      push(@toc_lines, $_ . \"<BR>\\n\")\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t      push(@toc_lines, \"<LI>\" . $_ .\"</LI>\");\n\t\t    }\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t    push(@lines, &html_debug(\"<A NAME=\\\"$docid\\\"></A>\\n\", \n\t\t\t\t\t   __LINE__));\n\t\t  }\n\t\t  # update DOC\n\t\t  push(@lines, &html_debug('', __LINE__));\n\t\t  &html_reset;\n\t\t  $_ =  \"<H$level> $name </H$level>\\n<!--docid::${docid}::-->\\n\";\n\t\t  $_ = &debug($_, __LINE__);\n\t\t  push(@lines, &html_debug('', __LINE__));\n\t\t}\n\t\t# update DOC\n\t\tforeach $line (split(/\\n+/, $_)) {\n\t\t    push(@lines, \"$line\\n\");\n\t\t}\n\t\tnext;\n\t    } else {\n\t\twarn \"$ERROR Bad section line: $_\";\n\t    }\n\t} else {\n\t    # track variables\n\t    $value{$1} = Unprotect_texi($2), next if /^\\@set\\s+($VARRE)\\s+(.*)$/o;\n\t    delete $value{$1}, next if /^\\@clear\\s+($VARRE)\\s*$/o;\n\t    # store things\n\t    $value{'_shorttitle'} = Unprotect_texi($1), next if /^\\@shorttitle\\s+(.*)$/;\n\t    $value{'_setfilename'}   = Unprotect_texi($1), next if /^\\@setfilename\\s+(.*)$/;\n\t    $value{'_settitle'}      = Unprotect_texi($1), next if /^\\@settitle\\s+(.*)$/;\n\t    $value{'_author'}   .= Unprotect_texi($1).\"\\n\", next if /^\\@author\\s+(.*)$/;\n\t    $value{'_subtitle'} .= Unprotect_texi($1).\"\\n\", next if /^\\@subtitle\\s+(.*)$/;\n\t    $value{'_title'}    .= Unprotect_texi($1).\"\\n\", next if /^\\@title\\s+(.*)$/;\n\n\t    # list item\n\t    if (/^\\s*\\@itemx?\\s+/) {\n\t\t$what = $';\n\t\t$what =~ s/\\s+$//;\n\t\tif ($in_bibliography && $use_bibliography) {\n\t\t    if ($what =~ /^$BIBRE$/o) {\n\t\t\t$id = 'BIB' . ++$bib_num;\n\t\t\t$bib2href{$what} = \"$docu_doc#$id\";\n\t\t\tprint \"# found bibliography for '$what' id $id\\n\"\n\t\t\t    if $T2H_DEBUG & $DEBUG_BIB;\n\t\t\t$what = &t2h_anchor($id, '', $what);\n\t\t    }\n\t\t} elsif ($in_glossary && $T2H_USE_GLOSSARY) {\n\t\t    $id = 'GLOSS' . ++$gloss_num;\n\t\t    $entry = $what;\n\t\t    $entry =~ tr/A-Z/a-z/ unless $entry =~ /^[A-Z\\s]+$/;\n\t\t    $gloss2href{$entry} = \"$docu_doc#$id\";\n\t\t    print \"# found glossary for '$entry' id $id\\n\"\n\t\t\tif $T2H_DEBUG & $DEBUG_GLOSS;\n\t\t    $what = &t2h_anchor($id, '', $what);\n\t\t}\n\t\telsif ($in_table && ($table_type eq 'f' || $table_type eq 'v'))\n\t\t{\n\t\t  EnterIndexEntry($table_type, $what, $docu_doc, $section, \\@lines);\n\t\t}\n\t\t&html_pop_if('P');\n\t\tif ($html_element eq 'DL' || $html_element eq 'DD') {\n\t\t    if ($things_map{$in_table} && !$what) {\n\t\t\t# special case to allow @table @bullet for instance\n\t\t\tpush(@lines, &debug(\"<DT>$things_map{$in_table}\\n\", __LINE__));\n\t\t    } else {\n\t\t\tpush(@lines, &debug(\"<DT>\\@$in_table\\{$what\\}\\n\", __LINE__));\n\t\t    }\n\t\t    push(@lines, \"<DD>\");\n\t\t    &html_push('DD') unless $html_element eq 'DD';\n\t\t    if ($table_type) { # add also an index\n\t\t\tunshift(@input_spool, \"\\@${table_type}index $what\\n\");\n\t\t    }\n\t\t} elsif ($html_element eq 'TABLE') {\n\t\t    push(@lines, &debug(\"<TR><TD>$what</TD>\\n\", __LINE__));\n\t\t    &html_push('TR');\n\t\t} elsif ($html_element eq 'TR') {\n\t\t    push(@lines, &debug(\"</TR>\\n\", __LINE__));\n\t\t    push(@lines, &debug(\"<TR><TD>$what</TD>\\n\", __LINE__));\n\t\t} else {\n\t\t    push(@lines, &debug(\"<LI>$what\\n\", __LINE__));\n\t\t    &html_push('LI') unless $html_element eq 'LI';\n\t\t}\n\t\tpush(@lines, &html_debug('', __LINE__));\n\t\tif ($deferred_ref) {\n\t\t    push(@lines, &debug(\"$deferred_ref\\n\", __LINE__));\n\t\t    $deferred_ref = '';\n\t\t}\n\t\tnext;\n\t    } elsif (/^\\@tab\\s+(.*)$/) {\n\t\tpush(@lines, \"<TD>$1</TD>\\n\");\n\t\tnext;\n\t    }\n\t}\n    }\n    # paragraph separator\n    if ($_ eq \"\\n\" && ! $in_pre) {\n\tnext if $#lines >= 0 && $lines[$#lines] eq \"\\n\";\n\tif ($html_element eq 'P') {\n\t    push (@lines, &debug(\"</P><P>\\n\", __LINE__));\n\t}\n# \telse\n# \t{\n# \t  push(@lines, \"<P></P>\\n\");\n# \t  $_ = &debug(\"<P></P>\\n\", __LINE__);\n# \t}\n        elsif ($html_element eq 'body' || $html_element eq 'BLOCKQUOTE' || $html_element eq 'DD' || $html_element eq 'LI') \n\t{\n\t  &html_push('P');\n\t  push(@lines, &debug(\"<P>\\n\", __LINE__));\n\t}\n      }\n    # otherwise\n    push(@lines, $_) unless $in_titlepage;\n    push(@lines, &debug(\"</center>\\n\", __LINE__))  if ($tag eq 'center');\n}\n\n# finish TOC\n$level = 0;\nwhile ($level < $curlevel) {\n    $curlevel--;\n    push(@toc_lines, \"</UL>\\n\");\n}\n\nprint \"# end of pass 1\\n\" if $T2H_VERBOSE;\n\nSetDocumentLanguage('en') unless ($T2H_LANG);\n#+++############################################################################\n#                                                                              #\n# Stuff related to Index generation                                            #\n#                                                                              #\n#---############################################################################\n\nsub EnterIndexEntry\n{\n  my $prefix = shift;\n  my $key = shift;\n  my $docu_doc = shift;\n  my $section = shift;\n  my $lines = shift;\n  local $_;\n\n  warn \"$ERROR Undefined index command: $_\", next\n    unless (exists ($index_properties->{$prefix}));\n  $key =~ s/\\s+$//;\n  $_ = $key;\n  &protect_texi;\n  $key = $_;\n  $_ = &protect_html($_);\n  my $html_key = substitute_style($_);\n  my $id;\n  $key = remove_style($key);\n  $key = remove_things($key);\n  $_ = $key;\n  &unprotect_texi;\n  $key = $_;\n  while (exists $index->{$prefix}->{$key}) {$key .= ' '};\n  if ($lines->[$#lines] =~ /^<!--docid::(.+)::-->$/)\n  {\n    $id = $1;\n  }\n  else\n  {\n    $id = 'IDX' . ++$idx_num;\n    push(@$lines, &t2h_anchor($id, '', $T2H_INVISIBLE_MARK, !$in_pre));\n  }\n  $index->{$prefix}->{$key}->{html_key} = $html_key;\n  $index->{$prefix}->{$key}->{section} = $section;\n  $index->{$prefix}->{$key}->{href} = \"$docu_doc#$id\";\n  print \"# found ${prefix}index  for '$key' with id $id\\n\"\n    if $T2H_DEBUG & $DEBUG_INDEX;\n}\n\nsub IndexName2Prefix\n{\n  my $name = shift;\n  my $prefix;\n\n  for $prefix (keys %$index_properties)\n  {\n    return $prefix if ($index_properties->{$prefix}->{name} eq $name);\n  }\n  return undef;\n}\n\nsub GetIndexEntries\n{\n  my $normal = shift;\n  my $code = shift;\n  my ($entries, $prefix, $key) = ({});\n  \n  for $prefix (keys %$normal)\n  {\n    for $key (keys %{$index->{$prefix}})\n    {\n      $entries->{$key} = {%{$index->{$prefix}->{$key}}};\n    }\n  }\n\n  if (defined($code))\n  {\n    for $prefix (keys %$code)\n    {\n      unless (exists $normal->{$keys})\n      {\n\tfor $key (keys %{$index->{$prefix}})\n\t{\n\t  $entries->{$key} = {%{$index->{$prefix}->{$key}}};\n\t  $entries->{$key}->{html_key} = \"<CODE>$entries->{$key}->{html_key}</CODE>\";\n\t}\n      }\n    }\n  }\n  return $entries;\n}\n\nsub byAlpha\n{\n  if ($a =~ /^[A-Za-z]/)\n  {\n    if ($b =~ /^[A-Za-z]/)\n    {\n      return lc($a) cmp lc($b);\n    }\n    else\n    {\n      return 1;\n    }\n  }\n  elsif ($b =~ /^[A-Za-z]/)\n  {\n    return -1;\n  }\n  else\n  {\n    return lc($a) cmp lc($b);\n  } \n}\n\nsub GetIndexPages\n{\n  my $entries = shift;\n  my (@Letters, $key);\n  my ($EntriesByLetter, $Pages, $page) = ({}, [], {});\n  my @keys = sort byAlpha keys %$entries;\n\n  for $key (@keys)\n  {\n    push @{$EntriesByLetter->{uc(substr($key,0, 1))}} , $entries->{$key};\n  }\n  @Letters = sort byAlpha keys %$EntriesByLetter;\n  \n  $T2H_SPLIT_INDEX = 0 unless ($T2H_SPLIT);\n\n  unless ($T2H_SPLIT_INDEX)\n  {\n    $page->{First} = $Letters[0];\n    $page->{Last} = $Letters[$#Letters];\n    $page->{Letters} = \\@Letters;\n    $page->{EntriesByLetter} = $EntriesByLetter;\n    push @$Pages, $page;\n    return $Pages;\n  }\n\n  if ($T2H_SPLIT_INDEX =~ /^\\d+$/)\n  {\n    my $i = 0;\n    my ($prev_letter, $letter);\n    $page->{First} = $Letters[0];\n    for $letter (@Letters)\n    {\n      if ($i > $T2H_SPLIT_INDEX)\n      {\n\t$page->{Last} = $prev_letter;\n\tpush @$Pages, {%$page};\n\t$page->{Letters} = [];\n\t$page->{EntriesByLetter} = {};\n\t$page->{First} = $letter;\n\t$i=0;\n      }\n      push @{$page->{Letters}}, $letter;\n      $page->{EntriesByLetter}->{$letter} = [@{$EntriesByLetter->{$letter}}];\n      $i += scalar(@{$EntriesByLetter->{$letter}});\n      $prev_letter = $letter;\n    }\n    $page->{Last} = $Letters[$#Letters];\n    push @$Pages, {%$page};\n  }\n  return $Pages;\n}\n\nsub GetIndexSummary\n{\n  my $first_page = shift;\n  my $Pages = shift;\n  my $name = shift;\n  my ($page, $letter, $summary, $i, $l1, $l2, $l);\n\n  $i = 0;\n  $summary = '<table><tr><th valign=top>Jump to: &nbsp; </th><td>';\n  \n  for $page ($first_page, @$Pages)\n  {\n    for $letter (@{$page->{Letters}})\n    {\n      $l = t2h_anchor('', \"$page->{href}#${name}_$letter\", \"<b>$letter</b>\", \n\t\t      0, 'style=\"text-decoration:none\"') . \"\\n &nbsp; \\n\";\n      \n      if ($letter =~ /^[A-Za-z]/)\n      {\n\t$l2 .= $l;\n      }\n      else\n      {\n\t$l1 .= $l;\n      }\n    }\n  }\n  $summary .= $l1 . \"<BR>\\n\" if ($l1);\n  $summary .= $l2 . '</td></tr></table><br>';\n  return $summary;\n}\n\nsub PrintIndexPage\n{\n  my $lines = shift;\n  my $summary = shift;\n  my $page = shift;\n  my $name = shift;\n\n  push @$lines, $summary;\n\n  push @$lines , <<EOT;\n<P></P>\n<TABLE border=0>\n<TR><TD></TD><TH ALIGN=LEFT>Index Entry</TH><TH ALIGN=LEFT> Section</TH></TR>\n<TR><TD COLSPAN=3> <HR></TD></TR>\nEOT\n\n  for $letter (@{$page->{Letters}})\n  {\n    push @$lines, \"<TR><TH><A NAME=\\\"${name}_$letter\\\"></A>$letter</TH><TD></TD><TD></TD></TR>\\n\";\n    for $entry (@{$page->{EntriesByLetter}->{$letter}})\n    {\n      push @$lines, \n      \"<TR><TD></TD><TD valign=top>\" . \n\tt2h_anchor('', $entry->{href}, $entry->{html_key}) .\n\t  \"</TD><TD valign=top>\" . \n\t    t2h_anchor('', sec_href($entry->{section}), clean_name($entry->{section})) .\n\t      \"</TD></TR>\\n\";\n    }\n    push @$lines, \"<TR><TD COLSPAN=3> <HR></TD></TR>\\n\";\n  }\n  push @$lines, \"</TABLE><P></P>\";\n  push @$lines, $summary;\n}\n\nsub PrintIndex\n{\n  my $lines = shift;\n  my $name = shift;\n  my $section = shift;\n  $section = 'Top' unless $section;\n  my $prefix = IndexName2Prefix($name);\n\n  warn (\"$ERROR printindex: bad index name: $name\"), return \n    unless $prefix;\n\n  if ($index_properties->{$prefix}->{code})\n  {\n    $index_properties->{$prefix}->{from_code}->{$prefix} = 1;\n  }\n  else\n  {\n    $index_properties->{$prefix}->{from}->{$prefix}= 1;\n  }\n\n  my $Entries = GetIndexEntries($index_properties->{$prefix}->{from}, \n\t\t\t\t$index_properties->{$prefix}->{from_code});\n  return unless %$Entries;\n\n  if ($T2H_IDX_SUMMARY)\n  {\n    my $key;\n    open(FHIDX, \">$docu_rdir$docu_name\" . \"_$name.idx\")\n      || die \"Can't open > $docu_rdir$docu_name\" . \"_$name.idx for writing: $!\\n\";\n    print \"# writing $name index summary in $docu_rdir$docu_name\" . \"_$name.idx...\\n\" if $T2H_VERBOSE;\n\n    for $key (sort keys %$Entries)\n    {\n      print FHIDX \"$key\\t$Entries->{$key}->{href}\\n\";\n    }\n  }\n\n  my $Pages = GetIndexPages($Entries);\n  my $page;\n  my $first_page = shift @$Pages;\n  my $sec_name = $section;\n  # remove section number\n  $sec_name =~ s/.*? // if $sec_name =~ /^([A-Z]|\\d+)\\./;\n\n  ($first_page->{href} = sec_href($section)) =~ s/\\#.*$//;\n  # Update tree structure of document\n  if (@$Pages)\n  {\n    my $sec;\n    my @after;\n\n    while (@sections && $sections[$#sections] ne $section)\n    {\n      unshift @after, pop @sections;\n    }\n\n    for $page (@$Pages)\n    {\n      my $node = ($page->{First} ne $page->{Last} ? \n\t\t  \"$sec_name: $page->{First} -- $page->{Last}\" :\n\t\t  \"$sec_name: $page->{First}\");\n      push @sections, $node;\n      $node2sec{$node} = $node;\n      $sec2node{$node} = $node;\n      $node2up{$node} = $section;\n      $page->{href} = next_doc();\n      $page->{name} = $node;\n      $node2href{$node} = $page->{href};\n      if ($prev_node)\n      {\n\t$node2next{$prev_node} = $node;\n\t$node2prev{$node} = $prev_node;\n      }\n      $prev_node = $node;\n    }\n    push @sections, @after;\n  }\n\n  my $summary = GetIndexSummary($first_page, $Pages, $name);\n  PrintIndexPage($lines, $summary, $first_page, $name);\n  for $page (@$Pages)\n  {\n    push @$lines, ($T2H_SPLIT eq 'chapter' ? $CHAPTEREND : $SECTIONEND);\n    push @$lines, \"<H2 ALIGN=\\\"Left\\\">$page->{name}</H2>\\n\";\n    PrintIndexPage($lines, $summary, $page, $name);\n  }\n}\n\n\n#+++############################################################################\n#                                                                              #\n# Pass 2/3: handle style, menu, index, cross-reference                         #\n#                                                                              #\n#---############################################################################\n\n@lines2 = ();\t\t\t\t# whole document (2nd pass)\n@lines3 = ();\t\t\t\t# whole document (3rd pass)\n$in_menu = 0;\t\t\t\t# am I inside a menu\n\nwhile (@lines) {\n    $_ = shift(@lines);\n    #\n    # special case (protected sections)\n    #\n    if (/^$PROTECTTAG/o) {\n\tpush(@lines2, $_);\n\tnext;\n    }\n    #\n    # menu\n    #\n    if (/^\\@menu\\b/)\n    {\n      $in_menu = 1;\n      $in_menu_listing = 1;\n      push(@lines2, &debug(\"<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> \\n\", __LINE__));\n      next;\n    }\n    if (/^\\@end\\s+menu\\b/)\n    {\n      if ($in_menu_listing)\n      {\n\tpush(@lines2, &debug(\"</TABLE></BLOCKQUOTE>\\n\", __LINE__));\n      }\n      else\n      {\n\tpush(@lines2, &debug(\"</BLOCKQUOTE>\\n\", __LINE__));\n      }\n      $in_menu = 0;\n      $in_menu_listing = 0;\n      next;\n    }\n    if ($in_menu) \n    {\n      my ($node, $name, $descr);\n      if (/^\\*\\s+($NODERE)::/o)\n      {\n\t$node = $1;\n\t$descr = $';\n      }\n      elsif (/^\\*\\s+(.+):\\s+([^\\t,\\.\\n]+)[\\t,\\.\\n]/)\n      {\n\t$name = $1;\n\t$node = $2;\n\t$descr = $';\n      }\n      elsif (/^\\*/) \n      {\n\twarn \"$ERROR Bad menu line: $_\";\n      }\n      else\n      {\n\tif ($in_menu_listing)\n\t{\n\t  $in_menu_listing = 0;\n\t  push(@lines2, &debug(\"</TABLE>\\n\", __LINE__));\n\t}\n\t# should be like verbatim -- preseve spaces, etc\n\ts/ /\\&nbsp;/g;\n\t$_ .= \"<br>\\n\";\n\tpush(@lines2, $_);\n      }\n      if ($node)\n      {\n\tif (! $in_menu_listing)\n\t{\n\t  $in_menu_listing = 1;\n\t  push(@lines2, &debug(\"<TABLE BORDER=0 CELLSPACING=0>\\n\", __LINE__));\n\t}\n\t# look for continuation\n\twhile ($lines[0] =~ /^\\s+\\w+/)\n\t{\n\t  $descr .= shift(@lines);\n\t}\n\t&menu_entry($node, $name, $descr);\n      } \n      next;\n    }\n    #\n    # printindex\n    #\n    PrintIndex(\\@lines2, $2, $1), next\n      if (/^<!--::(.*)::-->\\@printindex\\s+(\\w+)/);\n    #\n    # simple style substitutions\n    #\n    $_ = &substitute_style($_);\n    #\n    # xref\n    #\n    while (/\\@(x|px|info|)ref{([^{}]+)(}?)/) {\n\t# note: Texinfo may accept other characters\n\t($type, $nodes, $full) = ($1, $2, $3);\n\t($before, $after) = ($`, $');\n\tif (! $full && $after) {\n\t    warn \"$ERROR Bad xref (no ending } on line): $_\";\n\t    $_ = \"$before$;0${type}ref\\{$nodes$after\";\n\t    next; # while xref\n\t}\n\tif ($type eq 'x') {\n\t    $type = \"$T2H_WORDS->{$T2H_LANG}->{'See'} \";\n\t} elsif ($type eq 'px') {\n\t    $type = \"$T2H_WORDS->{$T2H_LANG}->{'see'} \";\n\t} elsif ($type eq 'info') {\n\t    $type = \"$T2H_WORDS->{$T2H_LANG}->{'See'} Info\";\n\t} else {\n\t    $type = '';\n\t}\n\tunless ($full) {\n\t    $next = shift(@lines);\n\t    $next = &substitute_style($next);\n\t    chop($nodes); # remove final newline\n\t    if ($next =~ /\\}/) { # split on 2 lines\n\t\t$nodes .= \" $`\";\n\t\t$after = $';\n\t    } else {\n\t\t$nodes .= \" $next\";\n\t\t$next = shift(@lines);\n\t\t$next = &substitute_style($next);\n\t\tchop($nodes);\n\t\tif ($next =~ /\\}/) { # split on 3 lines\n\t\t    $nodes .= \" $`\";\n\t\t    $after = $';\n\t\t} else {\n\t\t    warn \"$ERROR Bad xref (no ending }): $_\";\n\t\t    $_ = \"$before$;0xref\\{$nodes$after\";\n\t\t    unshift(@lines, $next);\n\t\t    next; # while xref\n\t\t}\n\t    }\n\t}\n\t$nodes =~ s/\\s+/ /g; # remove useless spaces\n\t@args = split(/\\s*,\\s*/, $nodes);\n\t$node = $args[0]; # the node is always the first arg\n\t$node = &normalise_node($node);\n\t$sec = $args[2] || $args[1] || $node2sec{$node};\n\t$href = $node2href{$node};\n\tif (@args == 5) { # reference to another manual\n\t    $sec = $args[2] || $node;\n\t    $man = $args[4] || $args[3];\n\t    $_ = \"${before}${type}$T2H_WORDS->{$T2H_LANG}->{'section'} `$sec' in \\@cite{$man}$after\";\n\t} elsif ($type =~ /Info/) { # inforef\n\t    warn \"$ERROR Wrong number of arguments: $_\" unless @args == 3;\n\t    ($nn, $_, $in) = @args;\n\t    $_ = \"${before}${type} file `$in', node `$nn'$after\";\n\t} elsif ($sec && $href && ! $T2H_SHORT_REF) {\n\t    $_  = \"${before}${type}\";\n\t    $_ .= \"$T2H_WORDS->{$T2H_LANG}->{'section'} \" if ${type};\n\t    $_ .= &t2h_anchor('', $href, $sec) . $after;\n\t} \n\telsif ($href)\n\t{\n\t  $_ = \"${before}${type} \" . \n\t    &t2h_anchor('', $href, $args[2] || $args[1] || $node) . \n\t      $after;\n\t}\n\telse {\n\t    warn \"$ERROR Undefined node ($node): $_\";\n\t    $_ = \"$before$;0xref{$nodes}$after\";\n\t}\n    }\n\n    # replace images\n    s[\\@image\\s*{(.+?)}]\n    {\n     my @args = split (/\\s*,\\s*/, $1);\n     my $base = $args[0];\n     my $image = \n       LocateIncludeFile(\"$base.png\") || \n       LocateIncludeFile(\"$base.jpg\") ||\n       LocateIncludeFile(\"$base.gif\");\n     warn \"$ERROR no image file for $base: $_\" unless ($image && -e $image);\n     \"<IMG SRC=\\\"$image\\\" ALT=\\\"$base\\\">\";\n     ($T2H_CENTER_IMAGE ?\n      \"<CENTER><IMG SRC=\\\"$image\\\" ALT=\\\"$base\\\"></CENTER>\" :\n      \"<IMG SRC=\\\"$image\\\" ALT=\\\"$base\\\">\");\n    }eg;\n\n    #\n    # try to guess bibliography references or glossary terms\n    #\n    unless (/^<H\\d><A NAME=\\\"SEC\\d/) {\n\tif ($use_bibliography) {\n\t    $done = '';\n\t    while (/$BIBRE/o) {\n\t\t($pre, $what, $post) = ($`, $&, $');\n\t\t$href = $bib2href{$what};\n\t\tif (defined($href) && $post !~ /^[^<]*<\\/A>/) {\n\t\t    $done .= $pre . &t2h_anchor('', $href, $what);\n\t\t} else {\n\t\t    $done .= \"$pre$what\";\n\t\t}\n\t\t$_ = $post;\n\t    }\n\t    $_ = $done . $_;\n\t}\n\tif ($T2H_USE_GLOSSARY) {\n\t    $done = '';\n\t    while (/\\b\\w+\\b/) {\n\t\t($pre, $what, $post) = ($`, $&, $');\n\t\t$entry = $what;\n\t\t$entry =~ tr/A-Z/a-z/ unless $entry =~ /^[A-Z\\s]+$/;\n\t\t$href = $gloss2href{$entry};\n\t\tif (defined($href) && $post !~ /^[^<]*<\\/A>/) {\n\t\t    $done .= $pre . &t2h_anchor('', $href, $what);\n\t\t} else {\n\t\t    $done .= \"$pre$what\";\n\t\t}\n\t\t$_ = $post;\n\t    }\n\t    $_ = $done . $_;\n\t}\n    }\n    # otherwise\n    push(@lines2, $_);\n}\nprint \"# end of pass 2\\n\" if $T2H_VERBOSE;\n\n#\n# split style substitutions\n#\nwhile (@lines2) {\n    $_ = shift(@lines2);\n    #\n    # special case (protected sections)\n    #\n    if (/^$PROTECTTAG/o) {\n\tpush(@lines3, $_);\n\tnext;\n    }\n    #\n    # split style substitutions\n    #\n    $old = '';\n    while ($old ne $_) {\n        $old = $_;\n\tif (/\\@(\\w+)\\{/) {\n\t    ($before, $style, $after) = ($`, $1, $');\n\t    if (defined($style_map{$style})) {\n\t\t$_ = $after;\n\t\t$text = '';\n\t\t$after = '';\n\t\t$failed = 1;\n\t\twhile (@lines2) {\n\t\t    if (/\\}/) {\n\t\t\t$text .= $`;\n\t\t\t$after = $';\n\t\t\t$failed = 0;\n\t\t\tlast;\n\t\t    } else {\n\t\t\t$text .= $_;\n\t\t\t$_ = shift(@lines2);\n\t\t    }\n\t\t}\n\t\tif ($failed) {\n\t\t    die \"* Bad syntax (\\@$style) after: $before\\n\";\n\t\t} else {\n\t\t    $text = &apply_style($style, $text);\n\t\t    $_ = \"$before$text$after\";\n\t\t}\n\t    }\n\t}\n    }\n    # otherwise\n    push(@lines3, $_);\n}\nprint \"# end of pass 3\\n\" if $T2H_VERBOSE;\n\t\n#+++############################################################################\n#                                                                              #\n# Pass 4: foot notes, final cleanup                                            #\n#                                                                              #\n#---############################################################################\n\n@foot_lines = ();\t\t\t# footnotes\n@doc_lines = ();\t\t\t# final document\n$end_of_para = 0;\t\t\t# true if last line is <P>\n\t\nwhile (@lines3) {\n    $_ = shift(@lines3);\n    #\n    # special case (protected sections)\n    #\n    if (/^$PROTECTTAG/o) {\n\tpush(@doc_lines, $_);\n\t$end_of_para = 0;\n\tnext;\n    }\n    #\n    # footnotes\n    #\n    while (/\\@footnote([^\\{\\s]+)\\{/) {\n\t($before, $d, $after) = ($`, $1, $');\n\t$_ = $after;\n\t$text = '';\n\t$after = '';\n\t$failed = 1;\n\twhile (@lines3) {\n\t    if (/\\}/) {\n\t\t$text .= $`;\n\t\t$after = $';\n\t\t$failed = 0;\n\t\tlast;\n\t    } else {\n\t\t$text .= $_;\n\t\t$_ = shift(@lines3);\n\t    }\n\t}\n\tif ($failed) {\n\t    die \"* Bad syntax (\\@footnote) after: $before\\n\";\n\t} else {\n\t    $foot_num++;\n\t    $docid  = \"DOCF$foot_num\";\n\t    $footid = \"FOOT$foot_num\";\n\t    $foot = \"($foot_num)\";\n\t    push(@foot_lines, \"<H3>\" . &t2h_anchor($footid, \"$d#$docid\", $foot) . \"</H3>\\n\");\n\t    $text = \"<P>$text\" unless $text =~ /^\\s*<P>/;\n\t    push(@foot_lines, \"$text\\n\");\n\t    $_ = $before . &t2h_anchor($docid, \"$docu_foot#$footid\", $foot) . $after;\n\t}\n    }\n    #\n    # remove unnecessary <P>\n    #\n    if (/^\\s*<P>\\s*$/) {\n\tnext if $end_of_para++;\n    } else {\n\t$end_of_para = 0;\n    }\n    # otherwise\n    push(@doc_lines, $_);\n}\n\t\nprint \"# end of pass 4\\n\" if $T2H_VERBOSE;\n\n#+++############################################################################\n#                                                                              #\n# Pass 5: print things                                                         #\n#                                                                              #\n#---############################################################################\n\n$T2H_L2H = &l2h_FinishToLatex if ($T2H_L2H);\n$T2H_L2H = &l2h_ToHtml        if ($T2H_L2H);\n$T2H_L2H = &l2h_InitFromHtml  if ($T2H_L2H);\n\n# fix node2up, node2prev, node2next, if desired\nif ($has_top_command)\n{\n  for $section (keys %sec2number)\n  {\n    $node = $sec2node{$section};\n    $node2up{$node} = Sec2UpNode($section) unless $node2up{$node};\n    $node2prev{$node} = Sec2PrevNode($section) unless $node2prev{$node};\n    $node2next{$node} = Sec2NextNode($section) unless $node2next{$node};\n  }\n}\n\n# prepare %T2H_THISDOC\n$T2H_THISDOC{fulltitle} = $value{'_title'} || $value{'_settitle'} || \"Untitled Document\";\n$T2H_THISDOC{title} = $value{'_settitle'} || $T2H_THISDOC{fulltitle};\n$T2H_THISDOC{author} = $value{'_author'};\n$T2H_THISDOC{subtitle} = $value{'_subtitle'};\n$T2H_THISDOC{shorttitle} = $value{'_shorttitle'};\nfor $key (keys %T2H_THISDOC)\n{\n  $_ = &substitute_style($T2H_THISDOC{$key});\n  &unprotect_texi;\n  s/\\s*$//;\n  $T2H_THISDOC{$key} = $_;\n}\n\n# if no sections, then simply print document as is\nunless (@sections)\n{\n  print \"# Writing content into $docu_top_file \\n\" if $T2H_VERBOSE;\n  open(FILE, \"> $docu_top_file\") \n    || die \"$ERROR: Can't open $docu_top_file for writing: $!\\n\";\n\n  &$T2H_print_page_head(\\*FILE);\n  $T2H_THIS_SECTION = \\@doc_lines;\n  t2h_print_lines(\\*FILE);\n  &$T2H_print_foot_navigation(\\*FILE);\n  &$T2H_print_page_foot(\\*FILE);\n  close(FILE);\n  goto Finish;\n}\n\n# initialize $T2H_HREF, $T2H_NAME\n%T2H_HREF = \n  (\n   'First' ,   sec_href($sections[0]),\n   'Last',     sec_href($sections[$#sections]),\n   'About',     $docu_about. '#SEC_About',\n  );\n\n# prepare TOC, OVERVIEW, TOP\n$T2H_TOC = \\@toc_lines;\n$T2H_OVERVIEW = \\@stoc_lines;\nif ($has_top)\n{\n  while (1)\n  {\n    $_ = shift @doc_lines;\n    last if /$TOPEND/;\n    push @$T2H_TOP, $_;\n  }\n  $T2H_HREF{'Top'} = $docu_top . '#SEC_Top';\n}\nelse\n{\n  $T2H_HREF{'Top'} = $T2H_HREF{First};\n}\n\n$node2href{Top} = $T2H_HREF{Top};\n$T2H_HREF{Contents} = $docu_toc.'#SEC_Contents' if @toc_lines;\n$T2H_HREF{Overview} = $docu_stoc.'#SEC_OVERVIEW' if @stoc_lines;\n\n# settle on index\nif ($T2H_INDEX_CHAPTER)\n{\n  $T2H_HREF{Index} = $node2href{normalise_node($T2H_INDEX_CHAPTER)};\n  warn \"$ERROR T2H_INDEX_CHAPTER '$T2H_INDEX_CHAPTER' not found\\n\"\n    unless $T2H_HREF{Index};\n}\nif (! $T2H_HREF{Index} && $first_index_chapter)\n{\n  $T2H_INDEX_CHAPTER = $first_index_chapter;\n  $T2H_HREF{Index} = $node2href{$T2H_INDEX_CHAPTER};\n}\n\nprint \"# Using '\" . clean_name($T2H_INDEX_CHAPTER) . \"' as index page\\n\"\n  if ($T2H_VERBOSE && $T2H_HREF{Index});\n\n%T2H_NAME =\n  (\n   'First',   clean_name($sec2node{$sections[0]}),\n   'Last',    clean_name($sec2node{$sections[$#sections]}),\n   'About',    $T2H_WORDS->{$T2H_LANG}->{'About_Title'},\n   'Contents', $T2H_WORDS->{$T2H_LANG}->{'ToC_Title'},\n   'Overview', $T2H_WORDS->{$T2H_LANG}->{'Overview_Title'},\n   'Index' ,   clean_name($T2H_INDEX_CHAPTER),\n   'Top',      clean_name($T2H_TOP_HEADING || $T2H_THISDOC{'title'} || $T2H_THISDOC{'shorttitle'}),\n  );\n\n#############################################################################\n# print frame and frame toc file\n#\nif ( $T2H_FRAMES )\n{\n  open(FILE, \"> $docu_frame_file\") \n    || die \"$ERROR: Can't open $docu_frame_file for writing: $!\\n\";\n  print \"# Creating frame in $docu_frame_file ...\\n\" if $T2H_VERBOSE;\n  &$T2H_print_frame(\\*FILE);\n  close(FILE);\n\n  open(FILE, \"> $docu_toc_frame_file\") \n    || die \"$ERROR: Can't open $docu_toc_frame_file for writing: $!\\n\";\n  print \"# Creating toc frame in $docu_frame_file ...\\n\" if $T2H_VERBOSE;\n   &$T2H_print_toc_frame(\\*FILE);\n  close(FILE);\n}\n\n\n#############################################################################\n# print Top\n#\nopen(FILE, \"> $docu_top_file\") \n  || die \"$ERROR: Can't open $docu_top_file for writing: $!\\n\";\n&$T2H_print_page_head(\\*FILE) unless ($T2H_SPLIT);\n\nif ($has_top)\n{\n  print \"# Creating Top in $docu_top_file ...\\n\" if $T2H_VERBOSE;\n  $T2H_THIS_SECTION = $T2H_TOP;\n  $T2H_HREF{This} = $T2H_HREF{Top};\n  $T2H_NAME{This} = $T2H_NAME{Top};\n  &$T2H_print_Top(\\*FILE);\n}\n  \nclose(FILE) if $T2H_SPLIT;\n\n#############################################################################\n# Print sections\n#\n$T2H_NODE{Forward} = $sec2node{$sections[0]};\n$T2H_NAME{Forward} = &clean_name($sec2node{$sections[0]});\n$T2H_HREF{Forward} = sec_href($sections[0]);\n$T2H_NODE{This} = 'Top';\n$T2H_NAME{This} = $T2H_NAME{Top};\n$T2H_HREF{This} = $T2H_HREF{Top};\nif ($T2H_SPLIT)\n{\n  print \"# writing \" . scalar(@sections) . \n    \" sections in $docu_rdir$docu_name\".\"_[1..$doc_num]\"\n\t  if $T2H_VERBOSE;\n  $previous = ($T2H_SPLIT eq 'chapter' ? $CHAPTEREND : $SECTIONEND);\n  undef $FH;\n  $doc_num = 0;\n}\nelse\n{\n  print \"# writing \" . scalar(@sections) . \" sections in $docu_top_file ...\" \n    if $T2H_VERBOSE;\n  $FH = \\*FILE;\n  $previous = '';\n}\n\n$counter = 0;\n# loop through sections\nwhile ($section = shift(@sections)) \n{\n  if ($T2H_SPLIT && ($T2H_SPLIT eq 'section' || $previous eq $CHAPTEREND))\n  { \n    if ($FH)\n    {\n      #close previous page\n      &$T2H_print_chapter_footer($FH) if $T2H_SPLIT eq 'chapter';\n      &$T2H_print_page_foot($FH);\n      close($FH);\n      undef $FH;\n    }\n  }\n  $T2H_NAME{Back} = $T2H_NAME{This};\n  $T2H_HREF{Back} = $T2H_HREF{This};\n  $T2H_NODE{Back} = $T2H_NODE{This};\n  $T2H_NAME{This} = $T2H_NAME{Forward};\n  $T2H_HREF{This} = $T2H_HREF{Forward};\n  $T2H_NODE{This} = $T2H_NODE{Forward};\n  if ($sections[0])\n  {\n    $T2H_NODE{Forward} = $sec2node{$sections[0]};\n    $T2H_NAME{Forward} = &clean_name($T2H_NODE{Forward});\n    $T2H_HREF{Forward} = sec_href($sections[0]);\n  }\n  else\n  {\n    undef $T2H_HREF{Forward}, $T2H_NODE{Forward}, $T2H_NAME{Forward};\n  }\n\n  $node = $node2up{$T2H_NODE{This}};\n  $T2H_HREF{Up} = $node2href{$node};\n  if ($T2H_HREF{Up} eq $T2H_HREF{This} || ! $T2H_HREF{Up})\n  {\n    $T2H_NAME{Up} = $T2H_NAME{Top};\n    $T2H_HREF{Up} = $T2H_HREF{Top};\n    $T2H_NODE{Up} = 'Up';\n  }\n  else\n  {\n    $T2H_NAME{Up} = &clean_name($node);\n    $T2H_NODE{Up} = $node;\n  }\n\n  $node = $T2H_NODE{This};\n  $node = $node2prev{$node};\n  $T2H_NAME{Prev} = &clean_name($node);\n  $T2H_HREF{Prev} = $node2href{$node};\n  $T2H_NODE{Prev} = $node;\n\n  $node = $T2H_NODE{This};\n  if ($node2up{$node} && $node2up{$node} ne 'Top'&&\n      ($node2prev{$node} eq $T2H_NODE{Back} || ! $node2prev{$node}))\n  {\n    $node = $node2up{$node};\n    while ($node && $node ne $node2up{$node} && ! $node2prev{$node})\n    {\n      $node = $node2up{$node};\n    }\n    $node = $node2prev{$node} \n      unless $node2up{$node} eq 'Top' || ! $node2up{$node};\n  }\n  else\n  {\n    $node = $node2prev{$node};\n  }\n  $T2H_NAME{FastBack} = &clean_name($node);\n  $T2H_HREF{FastBack} = $node2href{$node};\n  $T2H_NODE{FastBack} = $node;\n  \n  $node = $T2H_NODE{This};\n  $node = $node2next{$node};\n  $T2H_NAME{Next} = &clean_name($node);\n  $T2H_HREF{Next} = $node2href{$node};\n  $T2H_NODE{Next} = $node;\n\n  $node = $T2H_NODE{This};\n  if ($node2up{$node} && $node2up{$node} ne 'Top'&& \n      ($node2next{$node} eq $T2H_NODE{Forward} || ! $node2next{$node}))\n  {\n    $node = $node2up{$node};\n    while ($node && $node ne $node2up{$node} && ! $node2next{$node})\n    {\n      $node = $node2up{$node};\n    }\n  }\n  $node = $node2next{$node};\n  $T2H_NAME{FastForward} = &clean_name($node);\n  $T2H_HREF{FastForward} = $node2href{$node};\n  $T2H_NODE{FastForward} = $node;\n\n  if (! defined($FH))\n  {\n    my $file = $T2H_HREF{This};\n    $file =~ s/\\#.*$//;\n    open(FILE, \"> $docu_rdir$file\") || \n      die \"$ERROR: Can't open $docu_rdir$file for writing: $!\\n\";\n    $FH = \\*FILE;\n    &$T2H_print_page_head($FH);\n    t2h_print_label($FH);\n    &$T2H_print_chapter_header($FH) if $T2H_SPLIT eq 'chapter';\n  }\n  else\n  {\n    t2h_print_label($FH);\n  }\n\n  $T2H_THIS_SECTION = [];\n  while (@doc_lines) {\n    $_ = shift(@doc_lines);\n    last if ($_ eq $SECTIONEND || $_ eq $CHAPTEREND);\n    push(@$T2H_THIS_SECTION, $_);\n  }\n  $previous = $_;\n  &$T2H_print_section($FH);\n\n  if ($T2H_VERBOSE)\n  {\n    $counter++;\n    print \".\" if $counter =~ /00$/;\n  }\n}\nif ($T2H_SPLIT)\n{\n  &$T2H_print_chapter_footer($FH) if $T2H_SPLIT eq 'chapter';\n  &$T2H_print_page_foot($FH);\n  close($FH);\n}\nprint \"\\n\" if $T2H_VERBOSE;\n\n#############################################################################\n# Print ToC, Overview, Footnotes\n#\nundef $T2H_HREF{Prev};\nundef $T2H_HREF{Next};\nundef $T2H_HREF{Back};\nundef $T2H_HREF{Forward};\nundef $T2H_HREF{Up};\n\nif (@foot_lines)\n{\n  print \"# writing Footnotes in $docu_foot_file...\\n\" if $T2H_VERBOSE;\n  open (FILE, \"> $docu_foot_file\") || die \"$ERROR: Can't open $docu_foot_file for writing: $!\\n\"\n      if $T2H_SPLIT;\n  $T2H_HREF{This} = $docu_foot;\n  $T2H_NAME{This} = $T2H_WORDS->{$T2H_LANG}->{'Footnotes_Title'};\n  $T2H_THIS_SECTION = \\@foot_lines;\n  &$T2H_print_Footnotes(\\*FILE);\n  close(FILE) if $T2H_SPLIT;\n}\n\nif (@toc_lines)\n{\n  print \"# writing Toc in $docu_toc_file...\\n\" if $T2H_VERBOSE;\n  open (FILE, \"> $docu_toc_file\") || die \"$ERROR: Can't open $docu_toc_file for writing: $!\\n\"\n      if $T2H_SPLIT;\n  $T2H_HREF{This} = $T2H_HREF{Contents};\n  $T2H_NAME{This} = $T2H_NAME{Contents};\n  $T2H_THIS_SECTION = \\@toc_lines;\n  &$T2H_print_Toc(\\*FILE);\n  close(FILE) if $T2H_SPLIT;\n}\n\nif (@stoc_lines)\n{\n  print \"# writing Overview in $docu_stoc_file...\\n\" if $T2H_VERBOSE;\n  open (FILE, \"> $docu_stoc_file\") || die \"$ERROR: Can't open $docu_stoc_file for writing: $!\\n\"\n      if $T2H_SPLIT;\n  \n  $T2H_HREF{This} = $T2H_HREF{Overview};\n  $T2H_NAME{This} = $T2H_NAME{Overview};\n  $T2H_THIS_SECTION = \\@stoc_lines;\n  unshift @$T2H_THIS_SECTION, \"<BLOCKQUOTE>\\n\";\n  push @$T2H_THIS_SECTION, \"\\n</BLOCKQUOTE>\\n\";\n  &$T2H_print_Overview(\\*FILE);\n  close(FILE) if $T2H_SPLIT;\n}\n\nif ($about_body = &$T2H_about_body())\n{\n  print \"# writing About in $docu_about_file...\\n\" if $T2H_VERBOSE;\n  open (FILE, \"> $docu_about_file\") || die \"$ERROR: Can't open $docu_about_file for writing: $!\\n\"\n      if $T2H_SPLIT;\n  \n  $T2H_HREF{This} = $T2H_HREF{About};\n  $T2H_NAME{This} = $T2H_NAME{About};\n  $T2H_THIS_SECTION = [$about_body];\n  &$T2H_print_About(\\*FILE);\n  close(FILE) if $T2H_SPLIT;\n}\n\nunless ($T2H_SPLIT)\n{\n  &$T2H_print_page_foot(\\*FILE);\n  close (FILE);\n}\n  \nFinish:\n&l2h_FinishFromHtml if ($T2H_L2H);\n&l2h_Finish if($T2H_L2H);\nprint \"# that's all folks\\n\" if $T2H_VERBOSE;\n\nexit(0);\n\n#+++############################################################################\n#                                                                              #\n# Low level functions                                                          #\n#                                                                              #\n#---############################################################################\n\nsub LocateIncludeFile\n{\n  my $file = shift;\n  my $dir;\n\n  return $file if (-e $file && -r $file);\n  foreach $dir (@T2H_INCLUDE_DIRS)\n  {\n    return \"$dir/$file\" if (-e \"$dir/$file\" && -r \"$dir/$file\");\n  }\n  return undef;\n}\n\nsub clean_name \n{\n  local ($_);\n  $_ = &remove_style($_[0]);\n  &unprotect_texi;\n  return $_;\n}\n\nsub update_sec_num {\n    local($name, $level) = @_;\n    my $ret;\n\n    $level--; # here we start at 0\n    if ($name =~ /^appendix/ || defined(@appendix_sec_num)) {\n\t# appendix style\n\tif (defined(@appendix_sec_num)) {\n\t    &incr_sec_num($level, @appendix_sec_num);\n\t} else {\n\t    @appendix_sec_num = ('A', 0, 0, 0);\n\t}\n\t$ret = join('.', @appendix_sec_num[0..$level]);\n    } else {\n\t# normal style\n\tif (defined(@normal_sec_num)) \n\t{\n\t  &incr_sec_num($level, @normal_sec_num);\n\t} \n\telse \n\t{\n\t  @normal_sec_num = (1, 0, 0, 0);\n\t}\n\t$ret = join('.', @normal_sec_num[0..$level]);\n    }\n    \n    $ret .= \".\" if $level == 0;\n    return $ret;\n}\n\nsub incr_sec_num {\n    local($level, $l);\n    $level = shift(@_);\n    $_[$level]++;\n    foreach $l ($level+1 .. 3) {\n\t$_[$l] = 0;\n    }\n}\n\nsub Sec2UpNode\n{\n  my $sec = shift;\n  my $num = $sec2number{$sec};\n\n  return '' unless $num;\n  return 'Top' unless $num =~ /\\.\\d+/;\n  $num =~ s/\\.[^\\.]*$//;\n  $num = $num . '.' unless $num =~ /\\./;\n  return $sec2node{$number2sec{$num}};\n}\n\nsub Sec2PrevNode\n{\n  my $sec = shift;\n  my $num = $sec2number{$sec};\n  my ($i, $post);\n  \n  if ($num =~ /(\\w+)(\\.$|$)/)\n  {\n    $num = $`;\n    $i = $1;\n    $post = $2;\n    if ($i eq 'A')\n    {\n      $i = $normal_sec_num[0];\n    }\n    elsif ($i ne '1')\n    {\n      # unfortunately, -- operator is not magical\n      $i = chr(ord($i) + 1);\n    }\n    else\n    {\n      return '';\n    }\n    return $sec2node{$number2sec{$num . $i . $post}}\n  }\n  return '';\n}\n\nsub Sec2NextNode\n{\n  my $sec = shift;\n  my $num = $sec2number{$sec};\n  my $i;\n\n  if ($num =~ /(\\w+)(\\.$|$)/)\n  {\n    $num = $`;\n    $i = $1;\n    $post = $2;\n    if ($post eq '.' && $i eq $normal_sec_num[0])\n    {\n      $i = 'A';\n    }\n    else\n    {\n      $i++;\n    }\n    return $sec2node{$number2sec{$num . $i . $post}}\n  }\n  return '';\n}\n\nsub check {\n    local($_, %seen, %context, $before, $match, $after);\n\n    while (<>) {\n\tif (/\\@(\\*|\\.|\\:|\\@|\\{|\\})/) {\n\t    $seen{$&}++;\n\t    $context{$&} .= \"> $_\" if $T2H_VERBOSE;\n\t    $_ = \"$`XX$'\";\n\t    redo;\n\t}\n\tif (/\\@(\\w+)/) {\n\t    ($before, $match, $after) = ($`, $&, $');\n\t    if ($before =~ /\\b[\\w-]+$/ && $after =~ /^[\\w-.]*\\b/) { # e-mail address\n\t\t$seen{'e-mail address'}++;\n\t\t$context{'e-mail address'} .= \"> $_\" if $T2H_VERBOSE;\n\t    } else {\n\t\t$seen{$match}++;\n\t\t$context{$match} .= \"> $_\" if $T2H_VERBOSE;\n\t    }\n\t    $match =~ s/^\\@/X/;\n\t    $_ = \"$before$match$after\";\n\t    redo;\n\t}\n    }\n    \n    foreach (sort(keys(%seen))) {\n\tif ($T2H_VERBOSE) {\n\t    print \"$_\\n\";\n\t    print $context{$_};\n\t} else {\n\t    print \"$_ ($seen{$_})\\n\";\n\t}\n    }\n}\n\nsub open {\n    local($name) = @_;\n\n    ++$fh_name;\n    if (open($fh_name, $name)) {\n\tunshift(@fhs, $fh_name);\n    } else {\n\twarn \"$ERROR Can't read file $name: $!\\n\";\n    }\n}\n\nsub init_input {\n    @fhs = ();\t\t\t# hold the file handles to read\n    @input_spool = ();\t\t# spooled lines to read\n    $fh_name = 'FH000';\n    &open($docu);\n}\n\nsub next_line {\n    local($fh, $line);\n\n    if (@input_spool) {\n\t$line = shift(@input_spool);\n\treturn($line);\n    }\n    while (@fhs) {\n\t$fh = $fhs[0];\n\t$line = <$fh>;\n\treturn($line) if $line;\n\tclose($fh);\n\tshift(@fhs);\n    }\n    return(undef);\n}\n\n# used in pass 1, use &next_line\nsub skip_until {\n    local($tag) = @_;\n    local($_);\n\n    while ($_ = &next_line) {\n\treturn if /^\\@end\\s+$tag\\s*$/;\n    }\n    die \"* Failed to find '$tag' after: \" . $lines[$#lines];\n}\n\n# used in pass 1 for l2h use &next_line\nsub string_until {\n    local($tag) = @_;\n    local($_, $string);\n\n    while ($_ = &next_line) {\n\treturn $string if /^\\@end\\s+$tag\\s*$/;\n#\t$_ =~ s/hbox/mbox/g;\n\t$string = $string.$_;\n    }\n    die \"* Failed to find '$tag' after: \" . $lines[$#lines];\n}\n\n#\n# HTML stacking to have a better HTML output\n#\n\nsub html_reset {\n    @html_stack = ('html');\n    $html_element = 'body';\n}\n\nsub html_push {\n    local($what) = @_;\n    push(@html_stack, $html_element);\n    $html_element = $what;\n}\n\nsub html_push_if {\n    local($what) = @_;\n    push(@html_stack, $html_element)\n\tif ($html_element && $html_element ne 'P');\n    $html_element = $what;\n}\n\nsub html_pop {\n    $html_element = pop(@html_stack);\n}\n\nsub html_pop_if {\n    local($elt);\n\n    if (@_) {\n\tforeach $elt (@_) {\n\t    if ($elt eq $html_element) {\n\t\t$html_element = pop(@html_stack) if @html_stack;\n\t\tlast;\n\t    }\n\t}\n    } else {\n\t$html_element = pop(@html_stack) if @html_stack;\n    }\n}\n\nsub html_debug {\n    local($what, $line) = @_;\n    if ($T2H_DEBUG & $DEBUG_HTML)\n    {\n     $what = \"\\n\" unless $what;\n     return(\"<!-- $line @html_stack, $html_element -->$what\")\n    }\t\n    return($what);\n}\n\n# to debug the output...\nsub debug {\n    local($what, $line) = @_;\n    return(\"<!-- $line -->$what\")\n\tif $T2H_DEBUG & $DEBUG_HTML;\n    return($what);\n}\n\nsub SimpleTexi2Html\n{\n  local $_ = $_[0];\n  &protect_texi;\n  &protect_html;\n  $_ = substitute_style($_);\n  $_[0]  = $_;\n}\n\nsub normalise_node {\n  local $_ = $_[0];\n  s/\\s+/ /g;\n  s/ $//;\n  s/^ //;\n  &protect_texi;\n  &protect_html;\n  $_ = substitute_style($_);\n  $_[0]  = $_;\n}\n\nsub menu_entry \n{\n  my ($node, $name, $descr) = @_;\n  my ($href, $entry);\n  \n  &normalise_node($node);\n  $href = $node2href{$node};\n  if ($href) \n  {\n    $descr =~ s/^\\s+//;\n    $descr =~ s/\\s*$//;\n    $descr = SimpleTexi2Html($descr);\n    if ($T2H_NUMBER_SECTIONS && !$T2H_NODE_NAME_IN_MENU && $node2sec{$node})\n    {\n      $entry = $node2sec{$node};\n      $name = '';\n    }\n    else\n    {\n      &normalise_node($name);\n      $entry = ($name && ($name ne $node || ! $T2H_AVOID_MENU_REDUNDANCY) \n\t\t? \"$name : $node\" : $node);\n    }\n\n    if ($T2H_AVOID_MENU_REDUNDANCY && $descr)\n    {\n      my $clean_entry = $entry;\n      $clean_entry =~ s/^.*? // if ($clean_entry =~ /^([A-Z]|\\d+)\\.[\\d\\.]* /);\n      $clean_entry =~ s/[^\\w]//g;\n      my $clean_descr = $descr;\n      $clean_descr =~ s/[^\\w]//g;\n      $descr = '' if ($clean_entry eq $clean_descr)\n    }\n    push(@lines2,&debug('<TR><TD ALIGN=\"left\" VALIGN=\"TOP\">' . \n\t\t\t&t2h_anchor('', $href, $entry) . \n\t\t\t'</TD><TD>&nbsp;&nbsp;</TD><TD ALIGN=\"left\" VALIGN=\"TOP\">' . \n\t\t\t$descr . \n\t\t\t\"</TD></TR>\\n\", __LINE__));\n  }\n  elsif ($node =~ /^\\(.*\\)\\w+/)\n  {\n    push(@lines2,&debug('<TR><TD ALIGN=\"left\" VALIGN=\"TOP\">' . \n\t\t\t$entry . \n\t\t\t'</TD><TD ALIGN=\"left\" VALIGN=\"TOP\">' . $descr . \n\t\t\t\"</TD></TR>\\n\", __LINE__))\n  }\n  else\n  {\n    warn \"$ERROR Undefined node of menu_entry ($node): $_\";\n  }\n}\n\nsub do_ctrl { \"^$_[0]\" }\n\nsub do_email {\n    local($addr, $text) = split(/,\\s*/, $_[0]);\n\n    $text = $addr unless $text;\n    &t2h_anchor('', \"mailto:$addr\", $text);\n}\n\nsub do_sc \n{ \n  # l2h does this much better\n  return &l2h_ToLatex(\"{\\\\sc \".&unprotect_html($_[0]).\"}\") if ($T2H_L2H);\n  return \"\\U$_[0]\\E\";\n}\n\nsub do_math\n{\n  return &l2h_ToLatex(\"\\$\".&unprotect_html($_[0]).\"\\$\") if ($T2H_L2H);\n  return \"<EM>\".$text.\"</EM>\";\n}\n\nsub do_uref {\n    local($url, $text, $only_text) = split(/,\\s*/, $_[0]);\n\n    $text = $only_text if $only_text;\n    $text = $url unless $text;\n    &t2h_anchor('', $url, $text);\n}\n\nsub do_url { &t2h_anchor('', $_[0], $_[0]) }\n\nsub do_acronym\n{\n  return '<FONT SIZE=\"-1\">' . $_[0] . '</FONT>';\n}\n\nsub do_accent\n{\n  return \"&$_[0]acute;\" if $_[1] eq 'H';\n  return \"$_[0].\" if $_[1] eq 'dotaccent';\n  return \"$_[0]*\" if $_[1] eq 'ringaccent';\n  return \"$_[0]\".'[' if $_[1] eq 'tieaccent';\n  return \"$_[0]\".'(' if $_[1] eq 'u';\n  return \"$_[0]_\" if $_[1] eq 'ubaraccent';\n  return \".$_[0]\" if $_[1] eq 'udotaccent';\n  return \"$_[0]&lt;\" if $_[1] eq 'v';\n  return \"&$_[0]cedil;\" if $_[1] eq ',';\n  return \"$_[0]\" if $_[1] eq 'dotless';\n  return undef;\n}\n\nsub apply_style {\n    local($texi_style, $text) = @_;\n    local($style);\n\n    $style = $style_map{$texi_style};\n    if (defined($style)) { # known style\n\tif ($style =~ /^\\\"/) { # add quotes\n\t    $style = $';\n\t    $text = \"\\`$text\\'\";\n\t}\n\tif ($style =~ /^\\&/) { # custom\n\t    $style = $';\n\t    $text = &$style($text, $texi_style);\n\t} elsif ($style) { # good style\n\t    $text = \"<$style>$text</$style>\";\n\t} else { # no style\n\t}\n    } else { # unknown style\n\t$text = undef;\n    }\n    return($text);\n}\n\n# remove Texinfo styles\nsub remove_style {\n    local($_) = @_;\n    1 while(s/\\@\\w+{([^\\{\\}]+)}/$1/g);\n    return($_);\n}\n\nsub remove_things\n{\n  local ($_) = @_;\n  s|\\@(\\w+)\\{\\}|$1|g;\n  return $_;\n}\n\nsub substitute_style {\n    local($_) = @_;\n    local($changed, $done, $style, $text);\n\n    &simple_substitutions;\n    $changed = 1;\n    while ($changed) {\n\t$changed = 0;\n\t$done = '';\n\twhile (/\\@(\\w+){([^\\{\\}]+)}/ || /\\@(,){([^\\{\\}]+)}/) {\n\t    $text = &apply_style($1, $2);\n\t    if ($text) {\n\t\t$_ = \"$`$text$'\";\n\t\t$changed = 1;\n\t    } else {\n\t\t$done .= \"$`\\@$1\";\n\t\t$_ = \"{$2}$'\";\n\t    }\n\t}\n        $_ = $done . $_;\n    }\n    return($_);\n}\n\nsub t2h_anchor {\n    local($name, $href, $text, $newline, $extra_attribs) = @_;\n    local($result);\n\n    $result = \"<A\";\n    $result .= \" NAME=\\\"$name\\\"\" if $name;\n    if ($href)\n    {\n      $href =~ s|^$T2H_HREF_DIR_INSTEAD_FILE|./| \n\tif ($T2H_HREF_DIR_INSTEAD_FILE);\n      $result .= ($href =~ /\\\"/ ? \" HREF='$href'\"  : \" HREF=\\\"$href\\\"\");\n    }\n    $result .= \" $extra_attribs\" if $extra_attribs;\n    $result .= \">$text</A>\";\n    $result .= \"\\n\" if $newline;\n    return($result);\n}\n\nsub pretty_date {\n    local(@MoY, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);\n\n    @MoY = ('January', 'February', 'March', 'April', 'May', 'June',\n\t    'July', 'August', 'September', 'October', 'November', 'December');\n    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);\n    $year += ($year < 70) ? 2000 : 1900;\n    # obachman: Let's do it as the Americans do\n    return(\"$MoY[$mon], $mday  $year\");\n}\n\nsub doc_href {\n    local($num) = @_;\n\n    return(\"${docu_name}_$num.$docu_ext\");\n}\n\nsub sec_href\n{\n  return $node2href{$sec2node{$_[0]}};\n}\n\nsub next_doc {\n    $docu_doc = &doc_href(++$doc_num);\n}\n\nsub t2h_print_lines {\n    my ($fh, $lines) = @_;\n    local($_);\n    $lines = $T2H_THIS_SECTION unless $lines;\n    my $cnt = 0;\n    for (@$lines) \n    {\n\t$_ = l2h_FromHtml($_) if ($T2H_L2H);\n\tif (/^$PROTECTTAG/o) {\n\t    $_ = $tag2pro{$_};\n\t} else {\n\t    &unprotect_texi;\n\t}\n\tprint $fh $_;\n\t$cnt += split(/\\W*\\s+\\W*/);\n    }\n    return $cnt;\n}\n\nsub protect_texi {\n    # protect @ { } ` '\n    s/\\@\\@/$;0/go;\n    s/\\@\\{/$;1/go;\n    s/\\@\\}/$;2/go;\n    s/\\@\\`/$;3/go;\n    s/\\@\\'/$;4/go;\n}\n\nsub protect_html {\n    local($what) = @_;\n    # protect & < >\n    $what =~ s/\\&/\\&\\#38;/g;\n    $what =~ s/\\</\\&\\#60;/g;\n    $what =~ s/\\>/\\&\\#62;/g;\n    # restore anything in quotes\n    # this fixes my problem where I had:\n    # < IMG SRC=\"leftarrow.gif\" ALT=\"<--\" >  but what if I wanted &#60; in my ALT text ??\n    # maybe byte stuffing or some other technique should be used.\n    $what =~ s/\\\"([^\\&]+)\\&\\#60;(.*)\\\"/\"$1<$2\"/g;\n    $what =~ s/\\\"([^\\&]+)\\&\\#62;(.*)\\\"/\"$1>$2\"/g;\n    $what =~ s/\\\"([^\\&]+)\\&\\#38;(.*)\\\"/\"$1&$2\"/g;\n    # but recognize some HTML things\n    $what =~ s/\\&\\#60;\\/A\\&\\#62;/<\\/A>/g;\t      # </A>\n    $what =~ s/\\&\\#60;A ([^\\&]+)\\&\\#62;/<A $1>/g;     # <A [^&]+>\n    $what =~ s/\\&\\#60;IMG ([^\\&]+)\\&\\#62;/<IMG $1>/g; # <IMG [^&]+>\n    return($what);\n}\n\nsub unprotect_texi {\n    s/$;0/\\@/go;\n    s/$;1/\\{/go;\n    s/$;2/\\}/go;\n    s/$;3/\\`/go;\n    s/$;4/\\'/go;\n}\n\nsub Unprotect_texi \n{\n  local $_ = shift;\n  &unprotect_texi;\n  return($_);\n}\n\nsub unprotect_html {\n    local($what) = @_;\n    $what =~ s/\\&\\#38;/\\&/g;\n    $what =~ s/\\&\\#60;/\\</g;\n    $what =~ s/\\&\\#62;/\\>/g;\n    return($what);\n}\n\nsub t2h_print_label\n{\n    my $fh = shift;\n    my $href = shift || $T2H_HREF{This};\n    $href =~ s/.*#(.*)$/$1/;\n    print $fh qq{<A NAME=\"$href\"></A>\\n};\n}\n\n##############################################################################\n\n\t# These next few lines are legal in both Perl and nroff.\n\n.00 ;\t\t\t# finish .ig\n \n'di\t\t\t\\\" finish diversion--previous line must be blank\n.nr nl 0-1\t\t\\\" fake up transition to first page again\n.nr % 0\t\t\t\\\" start at page 1\n'; __END__ ############# From here on it's a standard manual page ############\n.so /usr/local/man/man1/texi2html.1\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}