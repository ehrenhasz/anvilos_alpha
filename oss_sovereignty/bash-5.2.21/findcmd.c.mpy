{
  "module_name": "findcmd.c",
  "hash_id": "60e6fd60e3416de6cc8240e78a810e2ccc18b1e74b2f42533740ea6d96f86936",
  "original_prompt": "Ingested from bash-5.2.21/findcmd.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include <stdio.h>\n#include \"chartypes.h\"\n#include \"bashtypes.h\"\n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"filecntl.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n#include <errno.h>\n\n#include \"bashansi.h\"\n\n#include \"memalloc.h\"\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"flags.h\"\n#include \"hashlib.h\"\n#include \"pathexp.h\"\n#include \"hashcmd.h\"\n#include \"findcmd.h\"\t \n\n#include <glob/strmatch.h>\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n \nstatic char *_find_user_command_internal PARAMS((const char *, int));\nstatic char *find_user_command_internal PARAMS((const char *, int));\nstatic char *find_user_command_in_path PARAMS((const char *, char *, int, int *));\nstatic char *find_in_path_element PARAMS((const char *, char *, int, int, struct stat *, int *));\nstatic char *find_absolute_program PARAMS((const char *, int));\n\nstatic char *get_next_path_element PARAMS((char *, int *));\n\n \nstatic char *file_to_lose_on;\n\n \nint check_hashed_filenames = CHECKHASH_DEFAULT;\n\n \nint dot_found_in_search = 0;\n\n \nstatic struct ignorevar execignore =\n{\n  \"EXECIGNORE\",\n  NULL,\n  0,\n  NULL,\n  NULL\n};\n\nvoid\nsetup_exec_ignore (varname)\n     char *varname;\n{\n  setup_ignore_patterns (&execignore);\n}\n\nstatic int\nexec_name_should_ignore (name)\n     const char *name;\n{\n  struct ign *p;\n\n  for (p = execignore.ignores; p && p->val; p++)\n    if (strmatch (p->val, (char *)name, FNMATCH_EXTFLAG|FNM_CASEFOLD) != FNM_NOMATCH)\n      return 1;\n  return 0;\n}\n\n \nint\nfile_status (name)\n     const char *name;\n{\n  struct stat finfo;\n  int r;\n\n   \n  if (stat (name, &finfo) < 0)\n    return (0);\n\n   \n  if (S_ISDIR (finfo.st_mode))\n    return (FS_EXISTS|FS_DIRECTORY);\n\n  r = FS_EXISTS;\n\n#if defined (HAVE_EACCESS)\n   \n  if (exec_name_should_ignore (name) == 0 && eaccess (name, X_OK) == 0)\n    r |= FS_EXECABLE;\n  if (eaccess (name, R_OK) == 0)\n    r |= FS_READABLE;\n\n  return r;\n#elif defined (AFS)\n   \n  if (exec_name_should_ignore (name) == 0 && access (name, X_OK) == 0)\n    r |= FS_EXECABLE;\n  if (access (name, R_OK) == 0)\n    r |= FS_READABLE;\n\n  return r;\n#else  \n\n   \n\n   \n  if (current_user.euid == (uid_t)0)\n    {\n      r |= FS_READABLE;\n      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXUGO))\n\tr |= FS_EXECABLE;\n      return r;\n    }\n\n   \n  if (current_user.euid == finfo.st_uid)\n    {\n      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXUSR))\n\tr |= FS_EXECABLE;\n      if (finfo.st_mode & S_IRUSR)\n\tr |= FS_READABLE;\n    }\n\n   \n  else if (group_member (finfo.st_gid))\n    {\n      if (exec_name_should_ignore (name) == 0 && (finfo.st_mode & S_IXGRP))\n\tr |= FS_EXECABLE;\n      if (finfo.st_mode & S_IRGRP)\n\tr |= FS_READABLE;\n    }\n\n   \n  else\n    {\n      if (exec_name_should_ignore (name) == 0 && finfo.st_mode & S_IXOTH)\n\tr |= FS_EXECABLE;\n      if (finfo.st_mode & S_IROTH)\n\tr |= FS_READABLE;\n    }\n\n  return r;\n#endif  \n}\n\n \nint\nexecutable_file (file)\n     const char *file;\n{\n  int s;\n\n  s = file_status (file);\n#if defined (EISDIR)\n  if (s & FS_DIRECTORY)\n    errno = EISDIR;\t \n#endif\n  return ((s & FS_EXECABLE) && ((s & FS_DIRECTORY) == 0));\n}\n\nint\nis_directory (file)\n     const char *file;\n{\n  return (file_status (file) & FS_DIRECTORY);\n}\n\nint\nexecutable_or_directory (file)\n     const char *file;\n{\n  int s;\n\n  s = file_status (file);\n  return ((s & FS_EXECABLE) || (s & FS_DIRECTORY));\n}\n\n \nchar *\nfind_user_command (name)\n     const char *name;\n{\n  return (find_user_command_internal (name, FS_EXEC_PREFERRED|FS_NODIRS));\n}\n\n \nchar *\nfind_path_file (name)\n     const char *name;\n{\n  return (find_user_command_internal (name, FS_READABLE));\n}\n\nstatic char *\n_find_user_command_internal (name, flags)\n     const char *name;\n     int flags;\n{\n  char *path_list, *cmd;\n  SHELL_VAR *var;\n\n   \n  if (var = find_variable_tempenv (\"PATH\"))\t \n    path_list = value_cell (var);\n  else\n    path_list = (char *)NULL;\n\n  if (path_list == 0 || *path_list == '\\0')\n    return (savestring (name));\n\n  cmd = find_user_command_in_path (name, path_list, flags, (int *)0);\n\n  return (cmd);\n}\n\nstatic char *\nfind_user_command_internal (name, flags)\n     const char *name;\n     int flags;\n{\n#ifdef __WIN32__\n  char *res, *dotexe;\n\n  dotexe = (char *)xmalloc (strlen (name) + 5);\n  strcpy (dotexe, name);\n  strcat (dotexe, \".exe\");\n  res = _find_user_command_internal (dotexe, flags);\n  free (dotexe);\n  if (res == 0)\n    res = _find_user_command_internal (name, flags);\n  return res;\n#else\n  return (_find_user_command_internal (name, flags));\n#endif\n}\n\n \nstatic char *\nget_next_path_element (path_list, path_index_pointer)\n     char *path_list;\n     int *path_index_pointer;\n{\n  char *path;\n\n  path = extract_colon_unit (path_list, path_index_pointer);\n\n  if (path == 0)\n    return (path);\n\n  if (*path == '\\0')\n    {\n      free (path);\n      path = savestring (\".\");\n    }\n\n  return (path);\n}\n\n \nchar *\nsearch_for_command (pathname, flags)\n     const char *pathname;\n     int flags;\n{\n  char *hashed_file, *command, *path_list;\n  int temp_path, st;\n  SHELL_VAR *path;\n\n  hashed_file = command = (char *)NULL;\n\n   \n  path = find_variable_tempenv (\"PATH\");\n  temp_path = path && tempvar_p (path);\n\n   \n  if (temp_path == 0 && (flags & CMDSRCH_STDPATH) == 0 && absolute_program (pathname) == 0)\n    hashed_file = phash_search (pathname);\n\n   \n\n  if (hashed_file && (posixly_correct || check_hashed_filenames))\n    {\n      st = file_status (hashed_file);\n      if ((st & (FS_EXISTS|FS_EXECABLE)) != (FS_EXISTS|FS_EXECABLE))\n\t{\n\t  phash_remove (pathname);\n\t  free (hashed_file);\n\t  hashed_file = (char *)NULL;\n\t}\n    }\n\n  if (hashed_file)\n    command = hashed_file;\n  else if (absolute_program (pathname))\n     \n    command = savestring (pathname);\n  else\n    {\n      if (flags & CMDSRCH_STDPATH)\n\tpath_list = conf_standard_path ();\n      else if (temp_path || path)\n\tpath_list = value_cell (path);\n      else\n\tpath_list = 0;\n\n      command = find_user_command_in_path (pathname, path_list, FS_EXEC_PREFERRED|FS_NODIRS, &st);\n\n      if (command && hashing_enabled && temp_path == 0 && (flags & CMDSRCH_HASH))\n\t{\n\t   \n\t  if (STREQ (command, pathname))\n\t    {\n\t      if (st & FS_EXECABLE)\n\t        phash_insert ((char *)pathname, command, dot_found_in_search, 1);\n\t    }\n\t   \n\t  else if (posixly_correct || check_hashed_filenames)\n\t    {\n\t      if (st & FS_EXECABLE)\n\t        phash_insert ((char *)pathname, command, dot_found_in_search, 1);\n\t    }\n\t  else\n\t    phash_insert ((char *)pathname, command, dot_found_in_search, 1);\n\t}\n\n      if (flags & CMDSRCH_STDPATH)\n\tfree (path_list);\n    }\n\n  return (command);\n}\n\nchar *\nuser_command_matches (name, flags, state)\n     const char *name;\n     int flags, state;\n{\n  register int i;\n  int  path_index, name_len;\n  char *path_list, *path_element, *match;\n  struct stat dotinfo;\n  static char **match_list = NULL;\n  static int match_list_size = 0;\n  static int match_index = 0;\n\n  if (state == 0)\n    {\n       \n      if (match_list == 0)\n\t{\n\t  match_list_size = 5;\n\t  match_list = strvec_create (match_list_size);\n\t}\n\n       \n      for (i = 0; i < match_list_size; i++)\n\tmatch_list[i] = 0;\n\n       \n      match_index = 0;\n\n      if (absolute_program (name))\n\t{\n\t  match_list[0] = find_absolute_program (name, flags);\n\t  match_list[1] = (char *)NULL;\n\t  path_list = (char *)NULL;\n\t}\n      else\n\t{\n\t  name_len = strlen (name);\n\t  file_to_lose_on = (char *)NULL;\n\t  dot_found_in_search = 0;\n\t  if (stat (\".\", &dotinfo) < 0)\n\t    dotinfo.st_dev = dotinfo.st_ino = 0;\t \n\t  path_list = get_string_value (\"PATH\");\n      \t  path_index = 0;\n\t}\n\n      while (path_list && path_list[path_index])\n\t{\n\t  path_element = get_next_path_element (path_list, &path_index);\n\n\t  if (path_element == 0)\n\t    break;\n\n\t  match = find_in_path_element (name, path_element, flags, name_len, &dotinfo, (int *)0);\n\t  free (path_element);\n\n\t  if (match == 0)\n\t    continue;\n\n\t  if (match_index + 1 == match_list_size)\n\t    {\n\t      match_list_size += 10;\n\t      match_list = strvec_resize (match_list, (match_list_size + 1));\n\t    }\n\n\t  match_list[match_index++] = match;\n\t  match_list[match_index] = (char *)NULL;\n\t  FREE (file_to_lose_on);\n\t  file_to_lose_on = (char *)NULL;\n\t}\n\n       \n      match_index = 0;\n    }\n\n  match = match_list[match_index];\n\n  if (match)\n    match_index++;\n\n  return (match);\n}\n\nstatic char *\nfind_absolute_program (name, flags)\n     const char *name;\n     int flags;\n{\n  int st;\n\n  st = file_status (name);\n\n   \n  if ((st & FS_EXISTS) == 0)\n    return ((char *)NULL);\n\n   \n  if ((flags & FS_EXISTS) || ((flags & FS_EXEC_ONLY) && (st & FS_EXECABLE)))\n    return (savestring (name));\n\n  return (NULL);\n}\n\nstatic char *\nfind_in_path_element (name, path, flags, name_len, dotinfop, rflagsp)\n     const char *name;\n     char *path;\n     int flags, name_len;\n     struct stat *dotinfop;\n     int *rflagsp;\n{\n  int status;\n  char *full_path, *xpath;\n\n  xpath = (posixly_correct == 0 && *path == '~') ? bash_tilde_expand (path, 0) : path;\n\n   \n   \n  if (dot_found_in_search == 0 && *xpath == '.')\n    dot_found_in_search = same_file (\".\", xpath, dotinfop, (struct stat *)NULL);\n\n  full_path = sh_makepath (xpath, name, 0);\n\n  status = file_status (full_path);\n\n  if (xpath != path)\n    free (xpath);\n\n  if (rflagsp)\n    *rflagsp = status;\n\n  if ((status & FS_EXISTS) == 0)\n    {\n      free (full_path);\n      return ((char *)NULL);\n    }\n\n   \n  if (flags & FS_EXISTS)\n    return (full_path);\n\n   \n  if ((flags & FS_READABLE) && (status & FS_READABLE))\n    return (full_path);\n\n   \n  if ((status & FS_EXECABLE) && (flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) &&\n      (((flags & FS_NODIRS) == 0) || ((status & FS_DIRECTORY) == 0)))\n    {\n      FREE (file_to_lose_on);\n      file_to_lose_on = (char *)NULL;\n      return (full_path);\n    }\n\n   \n  if ((flags & FS_EXEC_PREFERRED) && file_to_lose_on == 0 && exec_name_should_ignore (full_path) == 0)\n    file_to_lose_on = savestring (full_path);\n\n   \n  if ((flags & (FS_EXEC_ONLY|FS_EXEC_PREFERRED)) ||\n      ((flags & FS_NODIRS) && (status & FS_DIRECTORY)) ||\n      ((flags & FS_READABLE) && (status & FS_READABLE) == 0))\n    {\n      free (full_path);\n      return ((char *)NULL);\n    }\n  else\n    return (full_path);\n}\n\n \nstatic char *\nfind_user_command_in_path (name, path_list, flags, rflagsp)\n     const char *name;\n     char *path_list;\n     int flags, *rflagsp;\n{\n  char *full_path, *path;\n  int path_index, name_len, rflags;\n  struct stat dotinfo;\n\n   \n  dot_found_in_search = 0;\n\n  if (rflagsp)\n    *rflagsp = 0;\n\n  if (absolute_program (name))\n    {\n      full_path = find_absolute_program (name, flags);\n      return (full_path);\n    }\n\n  if (path_list == 0 || *path_list == '\\0')\n    return (savestring (name));\t\t \n\n  file_to_lose_on = (char *)NULL;\n  name_len = strlen (name);\n  if (stat (\".\", &dotinfo) < 0)\n    dotinfo.st_dev = dotinfo.st_ino = 0;\n  path_index = 0;\n\n  while (path_list[path_index])\n    {\n       \n      QUIT;\n\n      path = get_next_path_element (path_list, &path_index);\n      if (path == 0)\n\tbreak;\n\n       \n      full_path = find_in_path_element (name, path, flags, name_len, &dotinfo, &rflags);\n      free (path);\n\n       \n      if (full_path && (rflags & FS_DIRECTORY))\n\t{\n\t  free (full_path);\n\t  continue;\n\t}\n\n      if (full_path)\n\t{\n\t  if (rflagsp)\n\t    *rflagsp = rflags;\n\t  FREE (file_to_lose_on);\n\t  return (full_path);\n\t}\n    }\n\n   \n  if (file_to_lose_on && (flags & FS_NODIRS) && file_isdir (file_to_lose_on))\n    {\n      free (file_to_lose_on);\n      file_to_lose_on = (char *)NULL;\n    }\n\n  return (file_to_lose_on);\n}\n\n \nchar *\nfind_in_path (name, path_list, flags)\n     const char *name;\n     char *path_list;\n     int flags;\n{\n  return (find_user_command_in_path (name, path_list, flags, (int *)0));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}