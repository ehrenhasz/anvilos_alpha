{
  "module_name": "print_cmd.c",
  "hash_id": "a7b3285aea0d9aca632a334898045054e9839bae3d1547da31d9600d31895145",
  "original_prompt": "Ingested from bash-5.2.21/print_cmd.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#if defined (PREFER_STDARG)\n#  include <stdarg.h>\n#else\n#  include <varargs.h>\n#endif\n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#define NEED_XTRACE_SET_DECL\n\n#include \"shell.h\"\n#include \"flags.h\"\n#include <y.tab.h>\t \n#include \"input.h\"\n\n#include \"shmbutil.h\"\n\n#include \"builtins/common.h\"\n\n#if !HAVE_DECL_PRINTF\nextern int printf PARAMS((const char *, ...));\t \n#endif\n\nstatic int indentation;\nstatic int indentation_amount = 4;\n\n#if defined (PREFER_STDARG)\ntypedef void PFUNC PARAMS((const char *, ...));\n\nstatic void cprintf PARAMS((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));\nstatic void xprintf PARAMS((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));\n#else\n#define PFUNC VFunction\nstatic void cprintf ();\nstatic void xprintf ();\n#endif\n\nstatic void reset_locals PARAMS((void));\nstatic void newline PARAMS((char *));\nstatic void indent PARAMS((int));\nstatic void semicolon PARAMS((void));\nstatic void the_printed_command_resize PARAMS((int));\n\nstatic void make_command_string_internal PARAMS((COMMAND *));\nstatic void _print_word_list PARAMS((WORD_LIST *, char *, PFUNC *));\nstatic void command_print_word_list PARAMS((WORD_LIST *, char *));\nstatic void print_case_clauses PARAMS((PATTERN_LIST *));\nstatic void print_redirection_list PARAMS((REDIRECT *));\nstatic void print_redirection PARAMS((REDIRECT *));\nstatic void print_heredoc_header PARAMS((REDIRECT *));\nstatic void print_heredoc_body PARAMS((REDIRECT *));\nstatic void print_heredocs PARAMS((REDIRECT *));\nstatic void print_heredoc_bodies PARAMS((REDIRECT *));\nstatic void print_deferred_heredocs PARAMS((const char *));\n\nstatic void print_for_command PARAMS((FOR_COM *));\n#if defined (ARITH_FOR_COMMAND)\nstatic void print_arith_for_command PARAMS((ARITH_FOR_COM *));\n#endif\n#if defined (SELECT_COMMAND)\nstatic void print_select_command PARAMS((SELECT_COM *));\n#endif\nstatic void print_group_command PARAMS((GROUP_COM *));\nstatic void print_case_command PARAMS((CASE_COM *));\nstatic void print_while_command PARAMS((WHILE_COM *));\nstatic void print_until_command PARAMS((WHILE_COM *));\nstatic void print_until_or_while PARAMS((WHILE_COM *, char *));\nstatic void print_if_command PARAMS((IF_COM *));\n#if defined (COND_COMMAND)\nstatic void print_cond_node PARAMS((COND_COM *));\n#endif\nstatic void print_function_def PARAMS((FUNCTION_DEF *));\n\n#define PRINTED_COMMAND_INITIAL_SIZE 64\n#define PRINTED_COMMAND_GROW_SIZE 128\n\nchar *the_printed_command = (char *)NULL;\nint the_printed_command_size = 0;\nint command_string_index = 0;\n\nint xtrace_fd = -1;\nFILE *xtrace_fp = 0;\n\n#define CHECK_XTRACE_FP\txtrace_fp = (xtrace_fp ? xtrace_fp : stderr)\n\n \n#define EXPCHAR(c) ((c) == '{' || (c) == '~' || (c) == '$' || (c) == '`')\n\n#define PRINT_DEFERRED_HEREDOCS(x) \\\n  do { \\\n    if (deferred_heredocs) \\\n      print_deferred_heredocs (x); \\\n  } while (0)\n\n \nstatic int inside_function_def;\nstatic int skip_this_indent;\nstatic int was_heredoc;\nstatic int printing_connection;\nstatic int printing_comsub;\nstatic REDIRECT *deferred_heredocs;\n\n \nstatic int group_command_nesting;\n\n \nstatic char *indirection_string = 0;\nstatic int indirection_stringsiz = 0;\n\n \nvoid\nprint_command (command)\n     COMMAND *command;\n{\n  command_string_index = 0;\n  printf (\"%s\", make_command_string (command));\n}\n\n \nchar *\nmake_command_string (command)\n     COMMAND *command;\n{\n  command_string_index = was_heredoc = 0;\n  deferred_heredocs = 0;\n  make_command_string_internal (command);\n  return (the_printed_command);\n}\n\n \nchar *\nprint_comsub (command)\n     COMMAND *command;\n{\n  char *ret;\n\n  printing_comsub++;\n  ret = make_command_string (command);\n  printing_comsub--;\n  return ret;\n}\n\n \nstatic void\nmake_command_string_internal (command)\n     COMMAND *command;\n{\n  char s[3];\n\n  if (command == 0)\n    cprintf (\"\");\n  else\n    {\n      if (skip_this_indent)\n\tskip_this_indent--;\n      else\n\tindent (indentation);\n\n      if (command->flags & CMD_TIME_PIPELINE)\n\t{\n\t  cprintf (\"time \");\n\t  if (command->flags & CMD_TIME_POSIX)\n\t    cprintf (\"-p \");\n\t}\n\n      if (command->flags & CMD_INVERT_RETURN)\n\tcprintf (\"! \");\n\n      switch (command->type)\n\t{\n\tcase cm_for:\n\t  print_for_command (command->value.For);\n\t  break;\n\n#if defined (ARITH_FOR_COMMAND)\n\tcase cm_arith_for:\n\t  print_arith_for_command (command->value.ArithFor);\n\t  break;\n#endif\n\n#if defined (SELECT_COMMAND)\n\tcase cm_select:\n\t  print_select_command (command->value.Select);\n\t  break;\n#endif\n\n\tcase cm_case:\n\t  print_case_command (command->value.Case);\n\t  break;\n\n\tcase cm_while:\n\t  print_while_command (command->value.While);\n\t  break;\n\n\tcase cm_until:\n\t  print_until_command (command->value.While);\n\t  break;\n\n\tcase cm_if:\n\t  print_if_command (command->value.If);\n\t  break;\n\n#if defined (DPAREN_ARITHMETIC)\n\tcase cm_arith:\n\t  print_arith_command (command->value.Arith->exp);\n\t  break;\n#endif\n\n#if defined (COND_COMMAND)\n\tcase cm_cond:\n\t  print_cond_command (command->value.Cond);\n\t  break;\n#endif\n\n\tcase cm_simple:\n\t  print_simple_command (command->value.Simple);\n\t  break;\n\n\tcase cm_connection:\n\n\t  skip_this_indent++;\n\t  printing_connection++;\n\t  make_command_string_internal (command->value.Connection->first);\n\n\t  switch (command->value.Connection->connector)\n\t    {\n\t    case '&':\n\t    case '|':\n\t      {\n\t\tchar c = command->value.Connection->connector;\n\n\t\ts[0] = ' ';\n\t\ts[1] = c;\n\t\ts[2] = '\\0';\n\t\t\n\t\tprint_deferred_heredocs (s);\n\n\t\tif (c != '&' || command->value.Connection->second)\n\t\t  {\n\t\t    cprintf (\" \");\n\t\t    skip_this_indent++;\n\t\t  }\n\t      }\n\t      break;\n\n\t    case AND_AND:\n\t      print_deferred_heredocs (\" && \");\n\t      if (command->value.Connection->second)\n\t\tskip_this_indent++;\n\t      break;\n\n\t    case OR_OR:\n\t      print_deferred_heredocs (\" || \");\n\t      if (command->value.Connection->second)\n\t\tskip_this_indent++;\n\t      break;\n\n\t    case ';':\n\t    case '\\n':\t\t\t\t \n\t      {\n\t\tchar c = command->value.Connection->connector;\n\t\tint was_newline;\n\n\t\ts[0] = printing_comsub ? c : ';';\n\t\ts[1] = '\\0';\n\n\t\twas_newline = deferred_heredocs == 0 && was_heredoc == 0 && c == '\\n';\n\t\tif (deferred_heredocs == 0)\n\t\t  {\n\t\t    if (was_heredoc == 0)\n\t\t      cprintf (\"%s\", s);\t \n\t\t    else\n\t\t      was_heredoc = 0;\n\t\t  }\n\t\telse\n\t\t   \n\t\t  print_deferred_heredocs (inside_function_def ? \"\" : \";\");\n\n\t\tif (inside_function_def)\n\t\t  cprintf (\"\\n\");\n\t\telse if (printing_comsub && c == '\\n' && was_newline == 0)\n\t\t  cprintf (\"\\n\");\t \n\t\telse\n\t\t  {\n\t\t    if (c == ';')\n\t\t      cprintf (\" \");\n\t\t    if (command->value.Connection->second)\n\t\t      skip_this_indent++;\n\t\t  }\n\t\tbreak;\n\t      }\n\n\t    default:\n\t      cprintf (_(\"print_command: bad connector `%d'\"),\n\t\t       command->value.Connection->connector);\n\t      break;\n\t    }\n\n\t  make_command_string_internal (command->value.Connection->second);\n\t  PRINT_DEFERRED_HEREDOCS (\"\");\n\t  printing_connection--;\t  \t  \n\t  break;\n\n\tcase cm_function_def:\n\t  print_function_def (command->value.Function_def);\n\t  break;\n\n\tcase cm_group:\n\t  print_group_command (command->value.Group);\n\t  break;\n\n\tcase cm_subshell:\n\t  cprintf (\"( \");\n\t  skip_this_indent++;\n\t  make_command_string_internal (command->value.Subshell->command);\n\t  PRINT_DEFERRED_HEREDOCS (\"\");\n\t  cprintf (\" )\");\n\t  break;\n\n\tcase cm_coproc:\n\t  cprintf (\"coproc %s \", command->value.Coproc->name);\n\t  skip_this_indent++;\n\t  make_command_string_internal (command->value.Coproc->command);\n\t  break;\n\n\tdefault:\n\t  command_error (\"print_command\", CMDERR_BADTYPE, command->type, 0);\n\t  break;\n\t}\n\n\n      if (command->redirects)\n\t{\n\t  cprintf (\" \");\n\t  print_redirection_list (command->redirects);\n\t}\n    }\n}\n\nstatic void\n_print_word_list (list, separator, pfunc)\n     WORD_LIST *list;\n     char *separator;\n     PFUNC *pfunc;\n{\n  WORD_LIST *w;\n\n  for (w = list; w; w = w->next)\n    (*pfunc) (\"%s%s\", w->word->word, w->next ? separator : \"\");\n}\n\nvoid\nprint_word_list (list, separator)\n     WORD_LIST *list;\n     char *separator;\n{\n  _print_word_list (list, separator, xprintf);\n}\n\nvoid\nxtrace_set (fd, fp)\n     int fd;\n     FILE *fp;\n{\n  if (fd >= 0 && sh_validfd (fd) == 0)\n    {\n      internal_error (_(\"xtrace_set: %d: invalid file descriptor\"), fd);\n      return;\n    }\n  if (fp == 0)\n    {\n      internal_error (_(\"xtrace_set: NULL file pointer\"));\n      return;\n    }\n  if (fd >= 0 && fileno (fp) != fd)\n    internal_warning (_(\"xtrace fd (%d) != fileno xtrace fp (%d)\"), fd, fileno (fp));\n  \n  xtrace_fd = fd;\n  xtrace_fp = fp;\n}\n\nvoid\nxtrace_init ()\n{\n  xtrace_set (-1, stderr);\n}\n\nvoid\nxtrace_reset ()\n{\n  if (xtrace_fd >= 0 && xtrace_fp)\n    {\n      fflush (xtrace_fp);\n      fclose (xtrace_fp);\n    }\n  else if (xtrace_fd >= 0)\n    close (xtrace_fd);\n\n  xtrace_fd = -1;\n  xtrace_fp = stderr;\n}\n\nvoid\nxtrace_fdchk (fd)\n     int fd;\n{\n  if (fd == xtrace_fd)\n    xtrace_reset ();\n}\n\n \n\nchar *\nindirection_level_string ()\n{\n  register int i, j;\n  char *ps4;\n  char ps4_firstc[MB_LEN_MAX+1];\n  int ps4_firstc_len, ps4_len, ineed, old;\n\n  ps4 = get_string_value (\"PS4\");\n  if (indirection_string == 0)\n    indirection_string = xmalloc (indirection_stringsiz = 100);\n  indirection_string[0] = '\\0';\n\n  if (ps4 == 0 || *ps4 == '\\0')\n    return (indirection_string);\n\n  old = change_flag ('x', FLAG_OFF);\n  ps4 = decode_prompt_string (ps4);\n  if (old)\n    change_flag ('x', FLAG_ON);\n\n  if (ps4 == 0 || *ps4 == '\\0')\n    {\n      FREE (ps4);\n      return (indirection_string);\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  ps4_len = strnlen (ps4, MB_CUR_MAX);\n  ps4_firstc_len = MBLEN (ps4, ps4_len);\n  if (ps4_firstc_len == 1 || ps4_firstc_len == 0 || ps4_firstc_len < 0)\n    {\n      ps4_firstc[0] = ps4[0];\n      ps4_firstc[ps4_firstc_len = 1] = '\\0';\n    }\n  else\n    memcpy (ps4_firstc, ps4, ps4_firstc_len);\n#else\n  ps4_firstc[0] = ps4[0];\n  ps4_firstc[ps4_firstc_len = 1] = '\\0';\n#endif\n\n   \n  ineed = (ps4_firstc_len * indirection_level) + strlen (ps4);\n  if (ineed > indirection_stringsiz - 1)\n    {\n      indirection_stringsiz = ineed + 1;\n      indirection_string = xrealloc (indirection_string, indirection_stringsiz);\n    }\n\n  for (i = j = 0; ps4_firstc[0] && j < indirection_level && i < indirection_stringsiz - 1; i += ps4_firstc_len, j++)\n    {\n      if (ps4_firstc_len == 1)\n\tindirection_string[i] = ps4_firstc[0];\n      else\n\tmemcpy (indirection_string+i, ps4_firstc, ps4_firstc_len);\n    }      \n\n  for (j = ps4_firstc_len; *ps4 && ps4[j] && i < indirection_stringsiz - 1; i++, j++)\n    indirection_string[i] = ps4[j];\n\n  indirection_string[i] = '\\0';\n  free (ps4);\n  return (indirection_string);\n}\n\nvoid\nxtrace_print_assignment (name, value, assign_list, xflags)\n     char *name, *value;\n     int assign_list, xflags;\n{\n  char *nval;\n\n  CHECK_XTRACE_FP;\n\n  if (xflags)\n    fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n\n   \n  if (*value == '\\0' || assign_list)\n    nval = value;\n  else if (sh_contains_shell_metas (value))\n    nval = sh_single_quote (value);\n  else if (ansic_shouldquote (value))\n    nval = ansic_quote (value, 0, (int *)0);\n  else\n    nval = value;\n\n  if (assign_list)\n    fprintf (xtrace_fp, \"%s=(%s)\\n\", name, nval);\n  else\n    fprintf (xtrace_fp, \"%s=%s\\n\", name, nval);\n\n  if (nval != value)\n    FREE (nval);\n\n  fflush (xtrace_fp);\n}\n\n \nvoid\nxtrace_print_word_list (list, xtflags)\n     WORD_LIST *list;\n     int xtflags;\n{\n  WORD_LIST *w;\n  char *t, *x;\n\n  CHECK_XTRACE_FP;\n\n  if (xtflags&1)\n    fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n\n  for (w = list; w; w = w->next)\n    {\n      t = w->word->word;\n      if (t == 0 || *t == '\\0')\n\tfprintf (xtrace_fp, \"''%s\", w->next ? \" \" : \"\");\n      else if (xtflags & 2)\n\tfprintf (xtrace_fp, \"%s%s\", t, w->next ? \" \" : \"\");\n      else if (sh_contains_shell_metas (t))\n\t{\n\t  x = sh_single_quote (t);\n\t  fprintf (xtrace_fp, \"%s%s\", x, w->next ? \" \" : \"\");\n\t  free (x);\n\t}\n      else if (ansic_shouldquote (t))\n\t{\n\t  x = ansic_quote (t, 0, (int *)0);\n\t  fprintf (xtrace_fp, \"%s%s\", x, w->next ? \" \" : \"\");\n\t  free (x);\n\t}\n      else\n\tfprintf (xtrace_fp, \"%s%s\", t, w->next ? \" \" : \"\");\n    }\n  fprintf (xtrace_fp, \"\\n\");\n  fflush (xtrace_fp);\n}\n\nstatic void\ncommand_print_word_list (list, separator)\n     WORD_LIST *list;\n     char *separator;\n{\n  _print_word_list (list, separator, cprintf);\n}\n\nvoid\nprint_for_command_head (for_command)\n     FOR_COM *for_command;\n{\n  cprintf (\"for %s in \", for_command->name->word);\n  command_print_word_list (for_command->map_list, \" \");\n}\n\nvoid\nxtrace_print_for_command_head (for_command)\n     FOR_COM *for_command;\n{\n  CHECK_XTRACE_FP;\n  fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n  fprintf (xtrace_fp, \"for %s in \", for_command->name->word);\n  xtrace_print_word_list (for_command->map_list, 2);\n}\n\nstatic void\nprint_for_command (for_command)\n     FOR_COM *for_command;\n{\n  print_for_command_head (for_command);\n  cprintf (\";\");\n  newline (\"do\\n\");\n\n  indentation += indentation_amount;\n  make_command_string_internal (for_command->action);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n  semicolon ();\n  indentation -= indentation_amount;\n\n  newline (\"done\");\n}\n\n#if defined (ARITH_FOR_COMMAND)\nstatic void\nprint_arith_for_command (arith_for_command)\n     ARITH_FOR_COM *arith_for_command;\n{\n  cprintf (\"for ((\");\n  command_print_word_list (arith_for_command->init, \" \");\n  cprintf (\"; \");\n  command_print_word_list (arith_for_command->test, \" \");\n  cprintf (\"; \");\n  command_print_word_list (arith_for_command->step, \" \");\n  cprintf (\"))\");\n  newline (\"do\\n\");\n  indentation += indentation_amount;\n  make_command_string_internal (arith_for_command->action);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n  semicolon ();\n  indentation -= indentation_amount;\n  newline (\"done\");\n}\n#endif  \n\n#if defined (SELECT_COMMAND)\nvoid\nprint_select_command_head (select_command)\n     SELECT_COM *select_command;\n{\n  cprintf (\"select %s in \", select_command->name->word);\n  command_print_word_list (select_command->map_list, \" \");\n}\n\nvoid\nxtrace_print_select_command_head (select_command)\n     SELECT_COM *select_command;\n{\n  CHECK_XTRACE_FP;\n  fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n  fprintf (xtrace_fp, \"select %s in \", select_command->name->word);\n  xtrace_print_word_list (select_command->map_list, 2);\n}\n\nstatic void\nprint_select_command (select_command)\n     SELECT_COM *select_command;\n{\n  print_select_command_head (select_command);\n\n  cprintf (\";\");\n  newline (\"do\\n\");\n  indentation += indentation_amount;\n  make_command_string_internal (select_command->action);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n  semicolon ();\n  indentation -= indentation_amount;\n  newline (\"done\");\n}\n#endif  \n\nstatic void\nprint_group_command (group_command)\n     GROUP_COM *group_command;\n{\n  group_command_nesting++;\n  cprintf (\"{ \");\n\n  if (inside_function_def == 0)\n    skip_this_indent++;\n  else\n    {\n       \n      cprintf (\"\\n\");\n      indentation += indentation_amount;\n    }\n\n  make_command_string_internal (group_command->command);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n\n  if (inside_function_def)\n    {\n      cprintf (\"\\n\");\n      indentation -= indentation_amount;\n      indent (indentation);\n    }\n  else\n    {\n      semicolon ();\n      cprintf (\" \");\n    }\n\n  cprintf (\"}\");\n\n  group_command_nesting--;\n}\n\nvoid\nprint_case_command_head (case_command)\n     CASE_COM *case_command;\n{\n  cprintf (\"case %s in \", case_command->word->word);\n}\n\nvoid\nxtrace_print_case_command_head (case_command)\n     CASE_COM *case_command;\n{\n  CHECK_XTRACE_FP;\n  fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n  fprintf (xtrace_fp, \"case %s in\\n\", case_command->word->word);\n}\n\nstatic void\nprint_case_command (case_command)\n     CASE_COM *case_command;\n{\n  print_case_command_head (case_command);\n\n  if (case_command->clauses)\n    print_case_clauses (case_command->clauses);\n  newline (\"esac\");\n}\n\nstatic void\nprint_case_clauses (clauses)\n     PATTERN_LIST *clauses;\n{\n  indentation += indentation_amount;\n  while (clauses)\n    {\n      newline (\"\");\n      command_print_word_list (clauses->patterns, \" | \");\n      cprintf (\")\\n\");\n      indentation += indentation_amount;\n      make_command_string_internal (clauses->action);\n      indentation -= indentation_amount;\n      PRINT_DEFERRED_HEREDOCS (\"\");\n      if (clauses->flags & CASEPAT_FALLTHROUGH)\n\tnewline (\";&\");\n      else if (clauses->flags & CASEPAT_TESTNEXT)\n\tnewline (\";;&\");\n      else\n\tnewline (\";;\");\n      clauses = clauses->next;\n    }\n  indentation -= indentation_amount;\n}\n\nstatic void\nprint_while_command (while_command)\n     WHILE_COM *while_command;\n{\n  print_until_or_while (while_command, \"while\");\n}\n\nstatic void\nprint_until_command (while_command)\n     WHILE_COM *while_command;\n{\n  print_until_or_while (while_command, \"until\");\n}\n\nstatic void\nprint_until_or_while (while_command, which)\n     WHILE_COM *while_command;\n     char *which;\n{\n  cprintf (\"%s \", which);\n  skip_this_indent++;\n  make_command_string_internal (while_command->test);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n  semicolon ();\n  cprintf (\" do\\n\");\t \n  indentation += indentation_amount;\n  make_command_string_internal (while_command->action);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n  indentation -= indentation_amount;\n  semicolon ();\n  newline (\"done\");\n}\n\nstatic void\nprint_if_command (if_command)\n     IF_COM *if_command;\n{\n  cprintf (\"if \");\n  skip_this_indent++;\n  make_command_string_internal (if_command->test);\n  semicolon ();\n  cprintf (\" then\\n\");\n  indentation += indentation_amount;\n  make_command_string_internal (if_command->true_case);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n  indentation -= indentation_amount;\n\n  if (if_command->false_case)\n    {\n      semicolon ();\n      newline (\"else\\n\");\n      indentation += indentation_amount;\n      make_command_string_internal (if_command->false_case);\n      PRINT_DEFERRED_HEREDOCS (\"\");\n      indentation -= indentation_amount;\n    }\n  semicolon ();\n  newline (\"fi\");\n}\n\n#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)\nvoid\nprint_arith_command (arith_cmd_list)\n     WORD_LIST *arith_cmd_list;\n{\n  cprintf (\"((\");\n  command_print_word_list (arith_cmd_list, \" \");\n  cprintf (\"))\");\n}\n#endif\n\n#if defined (COND_COMMAND)\nstatic void\nprint_cond_node (cond)\n     COND_COM *cond;\n{\n  if (cond->flags & CMD_INVERT_RETURN)\n    cprintf (\"! \");\n\n  if (cond->type == COND_EXPR)\n    {\n      cprintf (\"( \");\n      print_cond_node (cond->left);\n      cprintf (\" )\");\n    }\n  else if (cond->type == COND_AND)\n    {\n      print_cond_node (cond->left);\n      cprintf (\" && \");\n      print_cond_node (cond->right);\n    }\n  else if (cond->type == COND_OR)\n    {\n      print_cond_node (cond->left);\n      cprintf (\" || \");\n      print_cond_node (cond->right);\n    }\n  else if (cond->type == COND_UNARY)\n    {\n      cprintf (\"%s\", cond->op->word);\n      cprintf (\" \");\n      print_cond_node (cond->left);\n    }\n  else if (cond->type == COND_BINARY)\n    {\n      print_cond_node (cond->left);\n      cprintf (\" \");\n      cprintf (\"%s\", cond->op->word);\n      cprintf (\" \");\n      print_cond_node (cond->right);\n    }\n  else if (cond->type == COND_TERM)\n    {\n      cprintf (\"%s\", cond->op->word);\t\t \n    }\n}\n\nvoid\nprint_cond_command (cond)\n     COND_COM *cond;\n{\n  cprintf (\"[[ \");\n  print_cond_node (cond);\n  cprintf (\" ]]\");\n}\n\n#ifdef DEBUG\nvoid\ndebug_print_word_list (s, list, sep)\n     char *s;\n     WORD_LIST *list;\n     char *sep;\n{\n  WORD_LIST *w;\n\n  if (s)\n    fprintf (stderr, \"%s: \", s);\n  for (w = list; w; w = w->next)\n    fprintf (stderr, \"%s%s\", w->word->word, w->next ? sep : \"\");\n  fprintf (stderr, \"\\n\");\n}\n\nvoid\ndebug_print_cond_command (cond)\n     COND_COM *cond;\n{\n  fprintf (stderr, \"DEBUG: \");\n  command_string_index = 0;\n  print_cond_command (cond);\n  fprintf (stderr, \"%s\\n\", the_printed_command);\n}\n#endif\n\nvoid\nxtrace_print_cond_term (type, invert, op, arg1, arg2)\n     int type, invert;\n     WORD_DESC *op;\n     char *arg1, *arg2;\n{\n  CHECK_XTRACE_FP;\n  command_string_index = 0;\n  fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n  fprintf (xtrace_fp, \"[[ \");\n  if (invert)\n    fprintf (xtrace_fp, \"! \");\n\n  if (type == COND_UNARY)\n    {\n      fprintf (xtrace_fp, \"%s \", op->word);\n      fprintf (xtrace_fp, \"%s\", (arg1 && *arg1) ? arg1 : \"''\");\n    }\n  else if (type == COND_BINARY)\n    {\n      fprintf (xtrace_fp, \"%s\", (arg1 && *arg1) ? arg1 : \"''\");\n      fprintf (xtrace_fp, \" %s \", op->word);\n      fprintf (xtrace_fp, \"%s\", (arg2 && *arg2) ? arg2 : \"''\");\n    }\n\n  fprintf (xtrace_fp, \" ]]\\n\");\n\n  fflush (xtrace_fp);\n}\t  \n#endif  \n\n#if defined (DPAREN_ARITHMETIC) || defined (ARITH_FOR_COMMAND)\n \nvoid\nxtrace_print_arith_cmd (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *w;\n\n  CHECK_XTRACE_FP;\n  fprintf (xtrace_fp, \"%s\", indirection_level_string ());\n  fprintf (xtrace_fp, \"(( \");\n  for (w = list; w; w = w->next)\n    fprintf (xtrace_fp, \"%s%s\", w->word->word, w->next ? \" \" : \"\");\n  fprintf (xtrace_fp, \" ))\\n\");\n\n  fflush (xtrace_fp);\n}\n#endif\n\nvoid\nprint_simple_command (simple_command)\n     SIMPLE_COM *simple_command;\n{\n  if (simple_command->words)\n    command_print_word_list (simple_command->words, \" \");\n\n  if (simple_command->redirects)\n    {\n      if (simple_command->words)\n\tcprintf (\" \");\n      print_redirection_list (simple_command->redirects);\n    }\n}\n\nstatic void\nprint_heredocs (heredocs)\n     REDIRECT *heredocs;\n{\n  REDIRECT *hdtail;\n\n  cprintf (\" \"); \n  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)\n    {\n      print_redirection (hdtail);\n      cprintf (\"\\n\");\n    }\n  was_heredoc = 1;\n}\n\nstatic void\nprint_heredoc_bodies (heredocs)\n     REDIRECT *heredocs;\n{\n  REDIRECT *hdtail;\n\n  cprintf (\"\\n\"); \n  for (hdtail = heredocs; hdtail; hdtail = hdtail->next)\n    {\n      print_heredoc_body (hdtail);\n      cprintf (\"\\n\");\n    }\n  was_heredoc = 1;\n}\n\n \nstatic void\nprint_deferred_heredocs (cstring)\n     const char *cstring;\n{\n   \n  if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))\n    cprintf (\"%s\", cstring); \n  if (deferred_heredocs)\n    {\n      print_heredoc_bodies (deferred_heredocs);\n      if (cstring && cstring[0] && (cstring[0] != ';' || cstring[1]))\n\tcprintf (\" \");\t \n      dispose_redirects (deferred_heredocs);\n      was_heredoc = 1;\n    }\n  deferred_heredocs = (REDIRECT *)NULL;\n}\n      \nstatic void\nprint_redirection_list (redirects)\n     REDIRECT *redirects;\n{\n  REDIRECT *heredocs, *hdtail, *newredir;\n  char *rw;\n\n  heredocs = (REDIRECT *)NULL;\n  hdtail = heredocs;\n\n  was_heredoc = 0;\n  while (redirects)\n    {\n       \n      if (redirects->instruction == r_reading_until || redirects->instruction == r_deblank_reading_until)\n\t{\n\t  newredir = copy_redirect (redirects);\n\t  newredir->next = (REDIRECT *)NULL;\n\n\t  print_heredoc_header (newredir);\n\n\t  if (heredocs)\n\t    {\n\t      hdtail->next = newredir;\n\t      hdtail = newredir;\n\t    }\n\t  else\n\t    hdtail = heredocs = newredir;\n\t}\n#if 0\n       \n      else if (redirects->instruction == r_duplicating_output_word && (redirects->flags & REDIR_VARASSIGN) == 0 && redirects->redirector.dest == 1)\n\t{\n\t   \n\t  rw = redirects->redirectee.filename->word;\n\t  if (rw && *rw != '-' && DIGIT (*rw) == 0 && EXPCHAR (*rw) == 0)\n\t    redirects->instruction = r_err_and_out;\n\t  print_redirection (redirects);\n\t  redirects->instruction = r_duplicating_output_word;\n\t}\n#endif\n      else\n\tprint_redirection (redirects);\n\n      redirects = redirects->next;\n      if (redirects)\n\tcprintf (\" \");\n    }\n\n   \n  if (heredocs && printing_connection)\n    deferred_heredocs = heredocs;\n  else if (heredocs)\n    {\n      print_heredoc_bodies (heredocs);\n      dispose_redirects (heredocs);\n    }\n}\n\nstatic void\nprint_heredoc_header (redirect)\n     REDIRECT *redirect;\n{\n  int kill_leading;\n  char *x;\n\n  kill_leading = redirect->instruction == r_deblank_reading_until;\n\n   \n  if (redirect->rflags & REDIR_VARASSIGN)\n    cprintf (\"{%s}\", redirect->redirector.filename->word);\n  else if (redirect->redirector.dest != 0)\n    cprintf (\"%d\", redirect->redirector.dest);\n\n   \n  if (redirect->redirectee.filename->flags & W_QUOTED)\n    {\n      x = sh_single_quote (redirect->here_doc_eof);\n      cprintf (\"<<%s%s\", kill_leading ? \"-\" : \"\", x);\n      free (x);\n    }\n  else\n    cprintf (\"<<%s%s\", kill_leading ? \"-\" : \"\", redirect->here_doc_eof);\n}\n\nstatic void\nprint_heredoc_body (redirect)\n     REDIRECT *redirect;\n{\n   \n  cprintf (\"%s%s\", redirect->redirectee.filename->word, redirect->here_doc_eof);\n}\n\nstatic void\nprint_redirection (redirect)\n     REDIRECT *redirect;\n{\n  int redirector, redir_fd;\n  WORD_DESC *redirectee, *redir_word;\n\n  redirectee = redirect->redirectee.filename;\n  redir_fd = redirect->redirectee.dest;\n\n  redir_word = redirect->redirector.filename;\n  redirector = redirect->redirector.dest;\n\n  switch (redirect->instruction)\n    {\n    case r_input_direction:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}\", redir_word->word);\n      else if (redirector != 0)\n\tcprintf (\"%d\", redirector);\n      cprintf (\"< %s\", redirectee->word);\n      break;\n\n    case r_output_direction:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}\", redir_word->word);\n      else if (redirector != 1)\n\tcprintf (\"%d\", redirector);\n      cprintf (\"> %s\", redirectee->word);\n      break;\n\n    case r_inputa_direction:\t \n      cprintf (\"&\");\n      break;\n\n    case r_output_force:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}\", redir_word->word);\n      else if (redirector != 1)\n\tcprintf (\"%d\", redirector);\n      cprintf (\">| %s\", redirectee->word);\n      break;\n\n    case r_appending_to:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}\", redir_word->word);\n      else if (redirector != 1)\n\tcprintf (\"%d\", redirector);\n      cprintf (\">> %s\", redirectee->word);\n      break;\n\n    case r_input_output:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}\", redir_word->word);\n      else if (redirector != 1)\n\tcprintf (\"%d\", redirector);\n      cprintf (\"<> %s\", redirectee->word);\n      break;\n\n    case r_deblank_reading_until:\n    case r_reading_until:\n      print_heredoc_header (redirect);\n      cprintf (\"\\n\");\n      print_heredoc_body (redirect);\n      break;\n\n    case r_reading_string:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}\", redir_word->word);\n      else if (redirector != 0)\n\tcprintf (\"%d\", redirector);\n#if 0\n       \n      if (ansic_shouldquote (redirect->redirectee.filename->word))\n\t{\n\t  char *x;\n\t  x = ansic_quote (redirect->redirectee.filename->word, 0, (int *)0);\n\t  cprintf (\"<<< %s\", x);\n\t  free (x);\n\t}\n      else\n#endif\n\tcprintf (\"<<< %s\", redirect->redirectee.filename->word);\n      break;\n\n    case r_duplicating_input:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}<&%d\", redir_word->word, redir_fd);\n      else\n\tcprintf (\"%d<&%d\", redirector, redir_fd);\n      break;\n\n    case r_duplicating_output:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}>&%d\", redir_word->word, redir_fd);\n      else\n\tcprintf (\"%d>&%d\", redirector, redir_fd);\n      break;\n\n    case r_duplicating_input_word:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}<&%s\", redir_word->word, redirectee->word);\n      else if (redirector == 0)\n\tcprintf (\"<&%s\", redirectee->word);\n      else\n\tcprintf (\"%d<&%s\", redirector, redirectee->word);\n      break;\n\n    case r_duplicating_output_word:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}>&%s\", redir_word->word, redirectee->word);\n      else if (redirector == 1)\n\tcprintf (\">&%s\", redirectee->word);\n      else\n\tcprintf (\"%d>&%s\", redirector, redirectee->word);\n      break;\n\n    case r_move_input:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}<&%d-\", redir_word->word, redir_fd);\n      else\n\tcprintf (\"%d<&%d-\", redirector, redir_fd);\n      break;\n\n    case r_move_output:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}>&%d-\", redir_word->word, redir_fd);\n      else\n\tcprintf (\"%d>&%d-\", redirector, redir_fd);\n      break;\n\n    case r_move_input_word:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}<&%s-\", redir_word->word, redirectee->word);\n      else\n\tcprintf (\"%d<&%s-\", redirector, redirectee->word);\n      break;\n\n    case r_move_output_word:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}>&%s-\", redir_word->word, redirectee->word);\n      else\n\tcprintf (\"%d>&%s-\", redirector, redirectee->word);\n      break;\n\n    case r_close_this:\n      if (redirect->rflags & REDIR_VARASSIGN)\n\tcprintf (\"{%s}>&-\", redir_word->word);\n      else\n\tcprintf (\"%d>&-\", redirector);\n      break;\n\n    case r_err_and_out:\n      cprintf (\"&> %s\", redirectee->word);\n      break;\n\n    case r_append_err_and_out:\n      cprintf (\"&>> %s\", redirectee->word);\n      break;\n    }\n}\n\nstatic void\nreset_locals ()\n{\n  inside_function_def = 0;\n  indentation = 0;\n  printing_connection = 0;\n  deferred_heredocs = 0;\n  printing_comsub = 0;\n}\n\nstatic void\nprint_function_def (func)\n     FUNCTION_DEF *func;\n{\n  COMMAND *cmdcopy;\n  REDIRECT *func_redirects;\n\n  func_redirects = NULL;\n   \n  if (posixly_correct == 0)\n    cprintf (\"function %s () \\n\", func->name->word);\n  else\n    cprintf (\"%s () \\n\", func->name->word);\n  add_unwind_protect (reset_locals, 0);\n\n  indent (indentation);\n  cprintf (\"{ \\n\");\n\n  inside_function_def++;\n  indentation += indentation_amount;\n\n  cmdcopy = copy_command (func->command);\n  if (cmdcopy->type == cm_group)\n    {\n      func_redirects = cmdcopy->redirects;\n      cmdcopy->redirects = (REDIRECT *)NULL;\n    }\n  make_command_string_internal (cmdcopy->type == cm_group\n\t\t\t\t\t? cmdcopy->value.Group->command\n\t\t\t\t\t: cmdcopy);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n\n  remove_unwind_protect ();\n  indentation -= indentation_amount;\n  inside_function_def--;\n\n  if (func_redirects)\n    {  \n      newline (\"} \");\n      print_redirection_list (func_redirects);\n      cmdcopy->redirects = func_redirects;\n    }\n  else\n    {\n       \n      newline (\"}\");\n      was_heredoc = 0;\t\t \n    }\n\n  dispose_command (cmdcopy);\n}\n\n \nchar *\nnamed_function_string (name, command, flags)\n     char *name;\n     COMMAND *command;\n     int flags;\n{\n  char *result;\n  int old_indent, old_amount;\n  COMMAND *cmdcopy;\n  REDIRECT *func_redirects;\n\n  old_indent = indentation;\n  old_amount = indentation_amount;\n  command_string_index = was_heredoc = 0;\n  deferred_heredocs = 0;\n  printing_comsub = 0;\n\n  if (name && *name)\n    {\n      if (find_reserved_word (name) >= 0)\n\tcprintf (\"function \");\n      cprintf (\"%s \", name);\n    }\n\n  cprintf (\"() \");\n\n  if ((flags & FUNC_MULTILINE) == 0)\n    {\n      indentation = 1;\n      indentation_amount = 0;\n    }\n  else\n    {\n      cprintf (\"\\n\");\n      indentation += indentation_amount;\n    }\n\n  inside_function_def++;\n\n  cprintf ((flags & FUNC_MULTILINE) ? \"{ \\n\" : \"{ \");\n\n  cmdcopy = copy_command (command);\n   \n  func_redirects = (REDIRECT *)NULL;\n  if (cmdcopy->type == cm_group)\n    {\n      func_redirects = cmdcopy->redirects;\n      cmdcopy->redirects = (REDIRECT *)NULL;\n    }\n  make_command_string_internal (cmdcopy->type == cm_group\n\t\t\t\t\t? cmdcopy->value.Group->command\n\t\t\t\t\t: cmdcopy);\n  PRINT_DEFERRED_HEREDOCS (\"\");\n\n  indentation = old_indent;\n  indentation_amount = old_amount;\n  inside_function_def--;\n\n  if (func_redirects)\n    {  \n      newline (\"} \");\n      print_redirection_list (func_redirects);\n      cmdcopy->redirects = func_redirects;\n    }\n  else\n    {\t \n      newline (\"}\");\n      was_heredoc = 0;\n    }\n\n  result = the_printed_command;\n\n  if ((flags & FUNC_MULTILINE) == 0)\n    {\n#if 0\n      register int i;\n      for (i = 0; result[i]; i++)\n\tif (result[i] == '\\n')\n\t  {\n\t    strcpy (result + i, result + i + 1);\n\t    --i;\n\t  }\n#else\n      if (result[2] == '\\n')\t \n\tmemmove (result + 2, result + 3, strlen (result) - 2);\t\n#endif\n    }\n\n  dispose_command (cmdcopy);\n\n  if (flags & FUNC_EXTERNAL)\n    result = remove_quoted_escapes (result);\n\n  return (result);\n}\n\nstatic void\nnewline (string)\n     char *string;\n{\n  cprintf (\"\\n\");\n  indent (indentation);\n  if (string && *string)\n    cprintf (\"%s\", string);\n}\n\nstatic char *indentation_string;\nstatic int indentation_size;\n\nstatic void\nindent (amount)\n     int amount;\n{\n  register int i;\n\n  RESIZE_MALLOCED_BUFFER (indentation_string, 0, amount, indentation_size, 16);\n\n  for (i = 0; amount > 0; amount--)\n    indentation_string[i++] = ' ';\n  indentation_string[i] = '\\0';\n  cprintf (\"%s\", indentation_string);\n}\n\nstatic void\nsemicolon ()\n{\n  if (command_string_index > 0 &&\n       (the_printed_command[command_string_index - 1] == '&' ||\n\tthe_printed_command[command_string_index - 1] == '\\n'))\n    return;\n  cprintf (\";\");\n}\n\n \nstatic void\n#if defined (PREFER_STDARG)\ncprintf (const char *control, ...)\n#else\ncprintf (control, va_alist)\n     const char *control;\n     va_dcl\n#endif\n{\n  register const char *s;\n  char char_arg[2], *argp, intbuf[INT_STRLEN_BOUND (unsigned int) + 1];\n  int digit_arg, arg_len, c;\n  va_list args;\n\n  SH_VA_START (args, control);\n\n  arg_len = strlen (control);\n  the_printed_command_resize (arg_len + 1);\n\n  char_arg[1] = '\\0';\n  s = control;\n  while (s && *s)\n    {\n      c = *s++;\n      argp = (char *)NULL;\n      if (c != '%' || !*s)\n\t{\n\t  char_arg[0] = c;\n\t  argp = char_arg;\n\t  arg_len = 1;\n\t}\n      else\n\t{\n\t  c = *s++;\n\t  switch (c)\n\t    {\n\t    case '%':\n\t      char_arg[0] = c;\n\t      argp = char_arg;\n\t      arg_len = 1;\n\t      break;\n\n\t    case 's':\n\t      argp = va_arg (args, char *);\n\t      arg_len = strlen (argp);\n\t      break;\n\n\t    case 'd':\n\t       \n\t      digit_arg = va_arg (args, int);\n\t      if (digit_arg < 0)\n\t\t{\n\t\t  sprintf (intbuf, \"%u\", (unsigned int)-1);\n\t\t  argp = intbuf;\n\t\t}\n\t      else\n\t\targp = inttostr (digit_arg, intbuf, sizeof (intbuf));\n\t      arg_len = strlen (argp);\n\t      break;\n\n\t    case 'c':\n\t      char_arg[0] = va_arg (args, int);\n\t      argp = char_arg;\n\t      arg_len = 1;\n\t      break;\n\n\t    default:\n\t      programming_error (_(\"cprintf: `%c': invalid format character\"), c);\n\t       \n\t    }\n\t}\n\n      if (argp && arg_len)\n\t{\n\t  the_printed_command_resize (arg_len + 1);\n\t  FASTCOPY (argp, the_printed_command + command_string_index, arg_len);\n\t  command_string_index += arg_len;\n\t}\n    }\n\n  va_end (args);\n\n  the_printed_command[command_string_index] = '\\0';\n}\n\n \nstatic void\nthe_printed_command_resize (length)\n     int length;\n{\n  if (the_printed_command == 0)\n    {\n      the_printed_command_size = (length + PRINTED_COMMAND_INITIAL_SIZE - 1) & ~(PRINTED_COMMAND_INITIAL_SIZE - 1);\n      the_printed_command = (char *)xmalloc (the_printed_command_size);\n      command_string_index = 0;\n    }\n  else if ((command_string_index + length) >= the_printed_command_size)\n    {\n      int new;\n      new = command_string_index + length + 1;\n\n       \n      new = (new + PRINTED_COMMAND_GROW_SIZE - 1) & ~(PRINTED_COMMAND_GROW_SIZE - 1);\n      the_printed_command_size = new;\n\n      the_printed_command = (char *)xrealloc (the_printed_command, the_printed_command_size);\n    }\n}\n\n#if defined (HAVE_VPRINTF)\n \n\nstatic void\n#if defined (PREFER_STDARG)\nxprintf (const char *format, ...)\n#else\nxprintf (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  SH_VA_START (args, format);\n\n  vfprintf (stdout, format, args);\n  va_end (args);\n}\n\n#else\n\nstatic void\nxprintf (format, arg1, arg2, arg3, arg4, arg5)\n     const char *format;\n{\n  printf (format, arg1, arg2, arg3, arg4, arg5);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}