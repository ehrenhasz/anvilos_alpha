{
  "module_name": "test.c",
  "hash_id": "33130d8f069f028e7e9ddb2f1a27091c110b07e9234140fd2943d27414393448",
  "original_prompt": "Ingested from bash-5.2.21/test.c",
  "human_readable_source": " \n\n \n\n \n\n \n \n\n#if defined (HAVE_CONFIG_H)\n#  include <config.h>\n#endif\n\n#include <stdio.h>\n\n#include \"bashtypes.h\"\n\n#if !defined (HAVE_LIMITS_H) && defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#if !defined (_POSIX_VERSION) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif  \n#include \"posixstat.h\"\n#include \"filecntl.h\"\n#include \"stat-time.h\"\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"pathexp.h\"\n#include \"test.h\"\n#include \"builtins/common.h\"\n\n#include <glob/strmatch.h>\n\n#if !defined (STRLEN)\n#  define STRLEN(s) ((s)[0] ? ((s)[1] ? ((s)[2] ? strlen(s) : 2) : 1) : 0)\n#endif\n\n#if !defined (STREQ)\n#  define STREQ(a, b) ((a)[0] == (b)[0] && strcmp ((a), (b)) == 0)\n#endif  \n#define STRCOLLEQ(a, b) ((a)[0] == (b)[0] && strcoll ((a), (b)) == 0)\n\n#if !defined (R_OK)\n#define R_OK 4\n#define W_OK 2\n#define X_OK 1\n#define F_OK 0\n#endif  \n\n#define EQ\t0\n#define NE\t1\n#define LT\t2\n#define GT\t3\n#define LE\t4\n#define GE\t5\n\n#define NT\t0\n#define OT\t1\n#define EF\t2\n\n \n#define TRUE 1\n#define FALSE 0\n#define SHELL_BOOLEAN(value) (!(value))\n\n#define TEST_ERREXIT_STATUS\t2\n\nstatic procenv_t test_exit_buf;\nstatic int test_error_return;\n#define test_exit(val) \\\n\tdo { test_error_return = val; sh_longjmp (test_exit_buf, 1); } while (0)\n\nextern int sh_stat PARAMS((const char *, struct stat *));\n\nstatic int pos;\t\t \nstatic int argc;\t \nstatic char **argv;\t \nstatic int noeval;\n\nstatic void test_syntax_error PARAMS((char *, char *)) __attribute__((__noreturn__));\nstatic void beyond PARAMS((void)) __attribute__((__noreturn__));\nstatic void integer_expected_error PARAMS((char *)) __attribute__((__noreturn__));\n\nstatic int unary_operator PARAMS((void));\nstatic int binary_operator PARAMS((void));\nstatic int two_arguments PARAMS((void));\nstatic int three_arguments PARAMS((void));\nstatic int posixtest PARAMS((void));\n\nstatic int expr PARAMS((void));\nstatic int term PARAMS((void));\nstatic int and PARAMS((void));\nstatic int or PARAMS((void));\n\nstatic int filecomp PARAMS((char *, char *, int));\nstatic int arithcomp PARAMS((char *, char *, int, int));\nstatic int patcomp PARAMS((char *, char *, int));\n\nstatic void\ntest_syntax_error (format, arg)\n     char *format, *arg;\n{\n  builtin_error (format, arg);\n  test_exit (TEST_ERREXIT_STATUS);\n}\n\n \nstatic void\nbeyond ()\n{\n  test_syntax_error (_(\"argument expected\"), (char *)NULL);\n}\n\n \nstatic void\ninteger_expected_error (pch)\n     char *pch;\n{\n  test_syntax_error (_(\"%s: integer expression expected\"), pch);\n}\n\n \n#define advance(f) do { ++pos; if (f && pos >= argc) beyond (); } while (0)\n#define unary_advance() do { advance (1); ++pos; } while (0)\n\n \nstatic int\nexpr ()\n{\n  if (pos >= argc)\n    beyond ();\n\n  return (FALSE ^ or ());\t\t \n}\n\n \nstatic int\nor ()\n{\n  int value, v2;\n\n  value = and ();\n  if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'o' && !argv[pos][2])\n    {\n      advance (0);\n      v2 = or ();\n      return (value || v2);\n    }\n\n  return (value);\n}\n\n \nstatic int\nand ()\n{\n  int value, v2;\n\n  value = term ();\n  if (pos < argc && argv[pos][0] == '-' && argv[pos][1] == 'a' && !argv[pos][2])\n    {\n      advance (0);\n      v2 = and ();\n      return (value && v2);\n    }\n  return (value);\n}\n\n \nstatic int\nterm ()\n{\n  int value;\n\n  if (pos >= argc)\n    beyond ();\n\n   \n  if (argv[pos][0] == '!' && argv[pos][1] == '\\0')\n    {\n      value = 0;\n      while (pos < argc && argv[pos][0] == '!' && argv[pos][1] == '\\0')\n\t{\n\t  advance (1);\n\t  value = 1 - value;\n\t}\n\n      return (value ? !term() : term());\n    }\n\n   \n  if (argv[pos][0] == '(' && argv[pos][1] == '\\0')  \n    {\n      advance (1);\n      value = expr ();\n      if (argv[pos] == 0)  \n\ttest_syntax_error (_(\"`)' expected\"), (char *)NULL);\n      else if (argv[pos][0] != ')' || argv[pos][1])  \n\ttest_syntax_error (_(\"`)' expected, found %s\"), argv[pos]);\n      advance (0);\n      return (value);\n    }\n\n   \n  if ((pos + 3 <= argc) && test_binop (argv[pos + 1]))\n    value = binary_operator ();\n\n   \n  else if ((pos + 2) <= argc && test_unop (argv[pos]))\n    value = unary_operator ();\n\n  else\n    {\n      value = argv[pos][0] != '\\0';\n      advance (0);\n    }\n\n  return (value);\n}\n\nstatic int\nstat_mtime (fn, st, ts)\n     char *fn;\n     struct stat *st;\n     struct timespec *ts;\n{\n  int r;\n\n  r = sh_stat (fn, st);\n  if (r < 0)\n    return r;\n  *ts = get_stat_mtime (st);\n  return 0;\n}\n\nstatic int\nfilecomp (s, t, op)\n     char *s, *t;\n     int op;\n{\n  struct stat st1, st2;\n  struct timespec ts1, ts2;\n  int r1, r2;\n\n  if ((r1 = stat_mtime (s, &st1, &ts1)) < 0)\n    {\n      if (op == EF)\n\treturn (FALSE);\n    }\n  if ((r2 = stat_mtime (t, &st2, &ts2)) < 0)\n    {\n      if (op == EF)\n\treturn (FALSE);\n    }\n  \n  switch (op)\n    {\n    case OT: return (r1 < r2 || (r2 == 0 && timespec_cmp (ts1, ts2) < 0));\n    case NT: return (r1 > r2 || (r1 == 0 && timespec_cmp (ts1, ts2) > 0));\n    case EF: return (same_file (s, t, &st1, &st2));\n    }\n  return (FALSE);\n}\n\nstatic int\narithcomp (s, t, op, flags)\n     char *s, *t;\n     int op, flags;\n{\n  intmax_t l, r;\n  int expok;\n\n  if (flags & TEST_ARITHEXP)\t\t \n    {\n      int eflag;\n\n      eflag = (shell_compatibility_level > 51) ? 0 : EXP_EXPANDED;\n      l = evalexp (s, eflag, &expok);\n      if (expok == 0)\n\treturn (FALSE);\t\t \n      r = evalexp (t, eflag, &expok);\n      if (expok == 0)\n\treturn (FALSE);\t\t \n    }\n  else\n    {\n      if (legal_number (s, &l) == 0)\n\tinteger_expected_error (s);\n      if (legal_number (t, &r) == 0)\n\tinteger_expected_error (t);\n    }\n\n  switch (op)\n    {\n    case EQ: return (l == r);\n    case NE: return (l != r);\n    case LT: return (l < r);\n    case GT: return (l > r);\n    case LE: return (l <= r);\n    case GE: return (l >= r);\n    }\n\n  return (FALSE);\n}\n\nstatic int\npatcomp (string, pat, op)\n     char *string, *pat;\n     int op;\n{\n  int m;\n\n  m = strmatch (pat, string, FNMATCH_EXTFLAG|FNMATCH_IGNCASE);\n  return ((op == EQ) ? (m == 0) : (m != 0));\n}\n\nint\nbinary_test (op, arg1, arg2, flags)\n     char *op, *arg1, *arg2;\n     int flags;\n{\n  int patmatch;\n\n  patmatch = (flags & TEST_PATMATCH);\n\n  if (op[0] == '=' && (op[1] == '\\0' || (op[1] == '=' && op[2] == '\\0')))\n    return (patmatch ? patcomp (arg1, arg2, EQ) : STREQ (arg1, arg2));\n  else if ((op[0] == '>' || op[0] == '<') && op[1] == '\\0')\n    {\n#if defined (HAVE_STRCOLL)\n      if (shell_compatibility_level > 40 && flags & TEST_LOCALE)\n\treturn ((op[0] == '>') ? (strcoll (arg1, arg2) > 0) : (strcoll (arg1, arg2) < 0));\n      else\n#endif\n\treturn ((op[0] == '>') ? (strcmp (arg1, arg2) > 0) : (strcmp (arg1, arg2) < 0));\n    }\n  else if (op[0] == '!' && op[1] == '=' && op[2] == '\\0')\n    return (patmatch ? patcomp (arg1, arg2, NE) : (STREQ (arg1, arg2) == 0));\n    \n\n  else if (op[2] == 't')\n    {\n      switch (op[1])\n\t{\n\tcase 'n': return (filecomp (arg1, arg2, NT));\t\t \n\tcase 'o': return (filecomp (arg1, arg2, OT));\t\t \n\tcase 'l': return (arithcomp (arg1, arg2, LT, flags));\t \n\tcase 'g': return (arithcomp (arg1, arg2, GT, flags));\t \n\t}\n    }\n  else if (op[1] == 'e')\n    {\n      switch (op[2])\n\t{\n\tcase 'f': return (filecomp (arg1, arg2, EF));\t\t \n\tcase 'q': return (arithcomp (arg1, arg2, EQ, flags));\t \n\t}\n    }\n  else if (op[2] == 'e')\n    {\n      switch (op[1])\n\t{\n\tcase 'n': return (arithcomp (arg1, arg2, NE, flags));\t \n\tcase 'g': return (arithcomp (arg1, arg2, GE, flags));\t \n\tcase 'l': return (arithcomp (arg1, arg2, LE, flags));\t \n\t}\n    }\n\n  return (FALSE);\t \n}\n\n\nstatic int\nbinary_operator ()\n{\n  int value;\n  char *w;\n\n  w = argv[pos + 1];\n  if ((w[0] == '=' && (w[1] == '\\0' || (w[1] == '=' && w[2] == '\\0'))) ||  \n      ((w[0] == '>' || w[0] == '<') && w[1] == '\\0') ||\t\t \n      (w[0] == '!' && w[1] == '=' && w[2] == '\\0'))\t\t \n    {\n      value = binary_test (w, argv[pos], argv[pos + 2], 0);\n      pos += 3;\n      return (value);\n    }\n\n#if defined (PATTERN_MATCHING)\n  if ((w[0] == '=' || w[0] == '!') && w[1] == '~' && w[2] == '\\0')\n    {\n      value = patcomp (argv[pos], argv[pos + 2], w[0] == '=' ? EQ : NE);\n      pos += 3;\n      return (value);\n    }\n#endif\n\n  if ((w[0] != '-' || w[3] != '\\0') || test_binop (w) == 0)\n    {\n      test_syntax_error (_(\"%s: binary operator expected\"), w);\n       \n      return (FALSE);\n    }\n\n  value = binary_test (w, argv[pos], argv[pos + 2], 0);\n  pos += 3;\n  return value;\n}\n\nstatic int\nunary_operator ()\n{\n  char *op;\n  intmax_t r;\n\n  op = argv[pos];\n  if (test_unop (op) == 0)\n    return (FALSE);\n\n   \n  if (op[1] == 't')\n    {\n      advance (0);\n      if (pos < argc)\n\t{\n\t  if (legal_number (argv[pos], &r))\n\t    {\n\t      advance (0);\n\t      return (unary_test (op, argv[pos - 1], 0));\n\t    }\n\t  else\n\t    return (FALSE);\n\t}\n      else\n\treturn (unary_test (op, \"1\", 0));\n    }\n\n   \n  unary_advance ();\n  return (unary_test (op, argv[pos - 1], 0));\n}\n\nint\nunary_test (op, arg, flags)\n     char *op, *arg;\n     int flags;\n{\n  intmax_t r;\n  struct stat stat_buf;\n  struct timespec mtime, atime;\n  SHELL_VAR *v;\n  int aflags;\n     \n  switch (op[1])\n    {\n    case 'a':\t\t\t \n    case 'e':\n      return (sh_stat (arg, &stat_buf) == 0);\n\n    case 'r':\t\t\t \n      return (sh_eaccess (arg, R_OK) == 0);\n\n    case 'w':\t\t\t \n      return (sh_eaccess (arg, W_OK) == 0);\n\n    case 'x':\t\t\t \n      return (sh_eaccess (arg, X_OK) == 0);\n\n    case 'O':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 &&\n\t      (uid_t) current_user.euid == (uid_t) stat_buf.st_uid);\n\n    case 'G':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 &&\n\t      (gid_t) current_user.egid == (gid_t) stat_buf.st_gid);\n\n    case 'N':\n      if (sh_stat (arg, &stat_buf) < 0)\n\treturn (FALSE);\n      atime = get_stat_atime (&stat_buf);\n      mtime = get_stat_mtime (&stat_buf);\n      return (timespec_cmp (mtime, atime) > 0);\n\n    case 'f':\t\t\t \n      if (sh_stat (arg, &stat_buf) < 0)\n\treturn (FALSE);\n\n       \n#if defined (S_IFMT)\n      return (S_ISREG (stat_buf.st_mode) || (stat_buf.st_mode & S_IFMT) == 0);\n#else\n      return (S_ISREG (stat_buf.st_mode));\n#endif  \n\n    case 'd':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 && (S_ISDIR (stat_buf.st_mode)));\n\n    case 's':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 && stat_buf.st_size > (off_t) 0);\n\n    case 'S':\t\t\t \n#if !defined (S_ISSOCK)\n      return (FALSE);\n#else\n      return (sh_stat (arg, &stat_buf) == 0 && S_ISSOCK (stat_buf.st_mode));\n#endif  \n\n    case 'c':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 && S_ISCHR (stat_buf.st_mode));\n\n    case 'b':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 && S_ISBLK (stat_buf.st_mode));\n\n    case 'p':\t\t\t \n#ifndef S_ISFIFO\n      return (FALSE);\n#else\n      return (sh_stat (arg, &stat_buf) == 0 && S_ISFIFO (stat_buf.st_mode));\n#endif  \n\n    case 'L':\t\t\t \n    case 'h':\t\t\t \n#if !defined (S_ISLNK) || !defined (HAVE_LSTAT)\n      return (FALSE);\n#else\n      return ((arg[0] != '\\0') &&\n\t      (lstat (arg, &stat_buf) == 0) && S_ISLNK (stat_buf.st_mode));\n#endif  \n\n    case 'u':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISUID) != 0);\n\n    case 'g':\t\t\t \n      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISGID) != 0);\n\n    case 'k':\t\t\t \n#if !defined (S_ISVTX)\n       \n      return (FALSE);\n#else\n      return (sh_stat (arg, &stat_buf) == 0 && (stat_buf.st_mode & S_ISVTX) != 0);\n#endif\n\n    case 't':\t \n      if (legal_number (arg, &r) == 0)\n\treturn (FALSE);\n      return ((r == (int)r) && isatty ((int)r));\n\n    case 'n':\t\t\t \n      return (arg[0] != '\\0');\n\n    case 'z':\t\t\t \n      return (arg[0] == '\\0');\n\n    case 'o':\t\t\t \n      return (minus_o_option_value (arg) == 1);\n\n    case 'v':\n#if defined (ARRAY_VARS)\n      aflags = assoc_expand_once ? AV_NOEXPAND : 0;\n      if (valid_array_reference (arg, aflags))\n\t{\n\t  char *t;\n\t  int ret;\n\t  array_eltstate_t es;\n\n\t   \n\t   \n\n\t  if (shell_compatibility_level > 51)\n\t     \n\t    aflags |= AV_ATSTARKEYS;\t \n\t  init_eltstate (&es);\n\t  t = get_array_value (arg, aflags|AV_ALLOWALL, &es);\n\t  ret = t ? TRUE : FALSE;\n\t  if (es.subtype > 0)\t \n\t    free (t);\n\t  flush_eltstate (&es);\n\t  return ret;\n\t}\n      else if (legal_number (arg, &r))\t\t \n\treturn ((r >= 0 && r <= number_of_args()) ? TRUE : FALSE);\n      v = find_variable (arg);\n      if (v && invisible_p (v) == 0 && array_p (v))\n\t{\n\t  char *t;\n\t   \n\t  t = array_reference (array_cell (v), 0);\n\t  return (t ? TRUE : FALSE);\n\t}\n      else if (v && invisible_p (v) == 0 && assoc_p (v))\n\t{\n\t  char *t;\n\t  t = assoc_reference (assoc_cell (v), \"0\");\n\t  return (t ? TRUE : FALSE);\n\t}\n#else\n      v = find_variable (arg);\n#endif\n      return (v && invisible_p (v) == 0 && var_isset (v) ? TRUE : FALSE);\n\n    case 'R':\n      v = find_variable_noref (arg);\n      return ((v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v)) ? TRUE : FALSE);\n    }\n\n   \n  return (FALSE);\n}\n\n \nint\ntest_binop (op)\n     char *op;\n{\n  if (op[0] == '=' && op[1] == '\\0')\n    return (1);\t\t \n  else if ((op[0] == '<' || op[0] == '>') && op[1] == '\\0')   \n    return (1);\n  else if ((op[0] == '=' || op[0] == '!') && op[1] == '=' && op[2] == '\\0')\n    return (1);\t\t \n#if defined (PATTERN_MATCHING)\n  else if (op[2] == '\\0' && op[1] == '~' && (op[0] == '=' || op[0] == '!'))\n    return (1);\n#endif\n  else if (op[0] != '-' || op[1] == '\\0' || op[2] == '\\0' || op[3] != '\\0')\n    return (0);\n  else\n    {\n      if (op[2] == 't')\n\tswitch (op[1])\n\t  {\n\t  case 'n':\t\t \n\t  case 'o':\t\t \n\t  case 'l':\t\t \n\t  case 'g':\t\t \n\t    return (1);\n\t  default:\n\t    return (0);\n\t  }\n      else if (op[1] == 'e')\n\tswitch (op[2])\n\t  {\n\t  case 'q':\t\t \n\t  case 'f':\t\t \n\t    return (1);\n\t  default:\n\t    return (0);\n\t  }\n      else if (op[2] == 'e')\n\tswitch (op[1])\n\t  {\n\t  case 'n':\t\t \n\t  case 'g':\t\t \n\t  case 'l':\t\t \n\t    return (1);\n\t  default:\n\t    return (0);\n\t  }\n      else\n\treturn (0);\n    }\n}\n\n \nint\ntest_unop (op)\n     char *op;\n{\n  if (op[0] != '-' || (op[1] && op[2] != 0))\n    return (0);\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n    case 'R':\n      return (1);\n    }\n\n  return (0);\n}\n\nstatic int\ntwo_arguments ()\n{\n  if (argv[pos][0] == '!' && argv[pos][1] == '\\0')\n    return (argv[pos + 1][0] == '\\0');\n  else if (argv[pos][0] == '-' && argv[pos][1] && argv[pos][2] == '\\0')\n    {\n      if (test_unop (argv[pos]))\n\treturn (unary_operator ());\n      else\n\ttest_syntax_error (_(\"%s: unary operator expected\"), argv[pos]);\n    }\n  else\n    test_syntax_error (_(\"%s: unary operator expected\"), argv[pos]);\n\n  return (0);\n}\n\n#define ANDOR(s)  (s[0] == '-' && (s[1] == 'a' || s[1] == 'o') && s[2] == 0)\n\n \n#define ONE_ARG_TEST(s)\t\t((s)[0] != '\\0')\n\nstatic int\nthree_arguments ()\n{\n  int value;\n\n  if (test_binop (argv[pos+1]))\n    {\n      value = binary_operator ();\n      pos = argc;\n    }\n  else if (ANDOR (argv[pos+1]))\n    {\n      if (argv[pos+1][1] == 'a')\n\tvalue = ONE_ARG_TEST(argv[pos]) && ONE_ARG_TEST(argv[pos+2]);\n      else\n\tvalue = ONE_ARG_TEST(argv[pos]) || ONE_ARG_TEST(argv[pos+2]);\n      pos = argc;\n    }\n  else if (argv[pos][0] == '!' && argv[pos][1] == '\\0')\n    {\n      advance (1);\n      value = !two_arguments ();\n      pos = argc;\n    }\n  else if (argv[pos][0] == '(' && argv[pos+2][0] == ')')\n    {\n      value = ONE_ARG_TEST(argv[pos+1]);\n      pos = argc;\n    }\n  else\n    test_syntax_error (_(\"%s: binary operator expected\"), argv[pos+1]);\n\n  return (value);\n}\n\n \nstatic int\nposixtest ()\n{\n  int value;\n\n  switch (argc - 1)\t \n    {\n      case 0:\n\tvalue = FALSE;\n\tpos = argc;\n\tbreak;\n\n      case 1:\n\tvalue = ONE_ARG_TEST(argv[1]);\n\tpos = argc;\n\tbreak;\n\n      case 2:\n\tvalue = two_arguments ();\n\tpos = argc;\n\tbreak;\n\n      case 3:\n\tvalue = three_arguments ();\n\tbreak;\n\n      case 4:\n\tif (argv[pos][0] == '!' && argv[pos][1] == '\\0')\n\t  {\n\t    advance (1);\n\t    value = !three_arguments ();\n\t    break;\n\t  }\n\telse if (argv[pos][0] == '(' && argv[pos][1] == '\\0' && argv[argc-1][0] == ')' && argv[argc-1][1] == '\\0')\n\t  {\n\t    advance (1);\n\t    value = two_arguments ();\n\t    pos = argc;\n\t    break;\n\t  }\n\t \n      default:\n\tvalue = expr ();\n    }\n\n  return (value);\n}\n\n \nint\ntest_command (margc, margv)\n     int margc;\n     char **margv;\n{\n  int value;\n  int code;\n\n  USE_VAR(margc);\n\n  code = setjmp_nosigs (test_exit_buf);\n\n  if (code)\n    return (test_error_return);\n\n  argv = margv;\n\n  if (margv[0] && margv[0][0] == '[' && margv[0][1] == '\\0')\n    {\n      --margc;\n\n      if (margv[margc] && (margv[margc][0] != ']' || margv[margc][1]))\n\ttest_syntax_error (_(\"missing `]'\"), (char *)NULL);\n\n      if (margc < 2)\n\ttest_exit (SHELL_BOOLEAN (FALSE));\n    }\n\n  argc = margc;\n  pos = 1;\n\n  if (pos >= argc)\n    test_exit (SHELL_BOOLEAN (FALSE));\n\n  noeval = 0;\n  value = posixtest ();\n\n  if (pos != argc)\n    {\n      if (pos < argc && argv[pos][0] == '-')\n\ttest_syntax_error (_(\"syntax error: `%s' unexpected\"), argv[pos]);\n      else\n\ttest_syntax_error (_(\"too many arguments\"), (char *)NULL);\n    }\n\n  test_exit (SHELL_BOOLEAN (value));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}