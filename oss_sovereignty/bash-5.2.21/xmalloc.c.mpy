{
  "module_name": "xmalloc.c",
  "hash_id": "98a1255adb3b0eae8ead047258add73b933a35c302f5a029ca70711d14da3883",
  "original_prompt": "Ingested from bash-5.2.21/xmalloc.c",
  "human_readable_source": " \n\n \n\n#if defined (HAVE_CONFIG_H)\n#include <config.h>\n#endif\n\n#include \"bashtypes.h\"\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_STDLIB_H)\n#  include <stdlib.h>\n#else\n#  include \"ansi_stdlib.h\"\n#endif  \n\n#include \"error.h\"\n\n#include \"bashintl.h\"\n\n#if !defined (PTR_T)\n#  if defined (__STDC__)\n#    define PTR_T void *\n#  else\n#    define PTR_T char *\n#  endif  \n#endif  \n\n#if HAVE_SBRK && !HAVE_DECL_SBRK\nextern char *sbrk();\n#endif\n\n#if HAVE_SBRK && defined (USING_BASH_MALLOC)\nstatic PTR_T lbreak;\nstatic int brkfound;\nstatic size_t allocated;\n#endif\n\n \n \n \n \n \n\n#if HAVE_SBRK && defined (USING_BASH_MALLOC)\n#define FINDBRK() \\\ndo { \\\n  if (brkfound == 0) \\\n    { \\\n      lbreak = (PTR_T)sbrk (0); \\\n      brkfound++; \\\n    } \\\n} while (0)\n\nstatic size_t\nfindbrk ()\n{\n  FINDBRK();\n  return (char *)sbrk (0) - (char *)lbreak;\n}\n#else\n#define FINDBRK()\n#endif\n\nstatic void\nallocerr (func, bytes)\n     const char *func;\n     size_t bytes;\n{\n#if HAVE_SBRK && defined (USING_BASH_MALLOC)\n      allocated = findbrk ();\n      fatal_error (_(\"%s: cannot allocate %lu bytes (%lu bytes allocated)\"), func, (unsigned long)bytes, (unsigned long)allocated);\n#else\n      fatal_error (_(\"%s: cannot allocate %lu bytes\"), func, (unsigned long)bytes);\n#endif  \n}\n\n \nPTR_T\nxmalloc (bytes)\n     size_t bytes;\n{\n  PTR_T temp;\n\n#if defined (DEBUG)\n  if (bytes == 0)\n    internal_warning(\"xmalloc: size argument is 0\");\n#endif\n\n  FINDBRK();\n  temp = malloc (bytes);\n\n  if (temp == 0)\n    allocerr (\"xmalloc\", bytes);\n\n  return (temp);\n}\n\nPTR_T\nxrealloc (pointer, bytes)\n     PTR_T pointer;\n     size_t bytes;\n{\n  PTR_T temp;\n\n#if defined (DEBUG)\n  if (bytes == 0)\n    internal_warning(\"xrealloc: size argument is 0\");\n#endif\n\n  FINDBRK();\n  temp = pointer ? realloc (pointer, bytes) : malloc (bytes);\n\n  if (temp == 0)\n    allocerr (\"xrealloc\", bytes);\n\n  return (temp);\n}\n\n \nvoid\nxfree (string)\n     PTR_T string;\n{\n  if (string)\n    free (string);\n}\n\n#ifdef USING_BASH_MALLOC\n#include <malloc/shmalloc.h>\n\nstatic void\nsh_allocerr (func, bytes, file, line)\n     const char *func;\n     size_t bytes;\n     char *file;\n     int line;\n{\n#if HAVE_SBRK\n      allocated = findbrk ();\n      fatal_error (_(\"%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)\"), func, file, line, (unsigned long)bytes, (unsigned long)allocated);\n#else\n      fatal_error (_(\"%s: %s:%d: cannot allocate %lu bytes\"), func, file, line, (unsigned long)bytes);\n#endif  \n}\n\nPTR_T\nsh_xmalloc (bytes, file, line)\n     size_t bytes;\n     char *file;\n     int line;\n{\n  PTR_T temp;\n\n#if defined (DEBUG)\n  if (bytes == 0)\n    internal_warning(\"xmalloc: %s:%d: size argument is 0\", file, line);\n#endif\n\n  FINDBRK();\n  temp = sh_malloc (bytes, file, line);\n\n  if (temp == 0)\n    sh_allocerr (\"xmalloc\", bytes, file, line);\n\n  return (temp);\n}\n\nPTR_T\nsh_xrealloc (pointer, bytes, file, line)\n     PTR_T pointer;\n     size_t bytes;\n     char *file;\n     int line;\n{\n  PTR_T temp;\n\n#if defined (DEBUG)\n  if (bytes == 0)\n    internal_warning(\"xrealloc: %s:%d: size argument is 0\", file, line);\n#endif\n\n  FINDBRK();\n  temp = pointer ? sh_realloc (pointer, bytes, file, line) : sh_malloc (bytes, file, line);\n\n  if (temp == 0)\n    sh_allocerr (\"xrealloc\", bytes, file, line);\n\n  return (temp);\n}\n\nvoid\nsh_xfree (string, file, line)\n     PTR_T string;\n     char *file;\n     int line;\n{\n  if (string)\n    sh_free (string, file, line);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}