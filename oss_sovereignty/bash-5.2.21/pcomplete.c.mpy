{
  "module_name": "pcomplete.c",
  "hash_id": "9c3e009f9c46f32152c172f72227681e1d64d872edb7e3118e7758da56262cc9",
  "original_prompt": "Ingested from bash-5.2.21/pcomplete.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (PROGRAMMABLE_COMPLETION)\n\n#include \"bashtypes.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <signal.h>\n\n#if defined (PREFER_STDARG)\n#  include <stdarg.h>\n#else\n#  include <varargs.h>\n#endif\n\n#include \"posixtime.h\"\n\n#include <stdio.h>\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"pcomplete.h\"\n#include \"alias.h\"\n#include \"bashline.h\"\n#include \"execute_cmd.h\"\n#include \"pathexp.h\"\n\n#if defined (JOB_CONTROL)\n#  include \"jobs.h\"\n#endif\n\n#if !defined (NSIG)\n#  include \"trap.h\"\n#endif\n\n#include \"shmbutil.h\"\n\n#include \"builtins.h\"\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\n\n#include <glob/glob.h>\n#include <glob/strmatch.h>\n\n#include <readline/rlconf.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n\n#ifdef STRDUP\n#  undef STRDUP\n#endif\n#define STRDUP(x)\t((x) ? savestring (x) : (char *)NULL)\n\ntypedef SHELL_VAR **SVFUNC ();\n\n#ifndef HAVE_STRPBRK\nextern char *strpbrk PARAMS((char *, char *));\n#endif\n\nextern STRING_INT_ALIST word_token_alist[];\nextern char *signal_names[];\n\n#if defined (DEBUG)\n#if defined (PREFER_STDARG)\nstatic void debug_printf (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));\n#endif\n#endif  \n\nstatic int it_init_joblist PARAMS((ITEMLIST *, int));\n\nstatic int it_init_aliases PARAMS((ITEMLIST *));\nstatic int it_init_arrayvars PARAMS((ITEMLIST *));\nstatic int it_init_bindings PARAMS((ITEMLIST *));\nstatic int it_init_builtins PARAMS((ITEMLIST *));\nstatic int it_init_disabled PARAMS((ITEMLIST *));\nstatic int it_init_enabled PARAMS((ITEMLIST *));\nstatic int it_init_exported PARAMS((ITEMLIST *));\nstatic int it_init_functions PARAMS((ITEMLIST *));\nstatic int it_init_helptopics PARAMS((ITEMLIST *));\nstatic int it_init_hostnames PARAMS((ITEMLIST *));\nstatic int it_init_jobs PARAMS((ITEMLIST *));\nstatic int it_init_running PARAMS((ITEMLIST *));\nstatic int it_init_stopped PARAMS((ITEMLIST *));\nstatic int it_init_keywords PARAMS((ITEMLIST *));\nstatic int it_init_signals PARAMS((ITEMLIST *));\nstatic int it_init_variables PARAMS((ITEMLIST *));\nstatic int it_init_setopts PARAMS((ITEMLIST *));\nstatic int it_init_shopts PARAMS((ITEMLIST *));\n\nstatic int shouldexp_filterpat PARAMS((char *));\nstatic char *preproc_filterpat PARAMS((char *, const char *));\n\nstatic void init_itemlist_from_varlist PARAMS((ITEMLIST *, SVFUNC *));\n\nstatic STRINGLIST *gen_matches_from_itemlist PARAMS((ITEMLIST *, const char *));\nstatic STRINGLIST *gen_action_completions PARAMS((COMPSPEC *, const char *));\nstatic STRINGLIST *gen_globpat_matches PARAMS((COMPSPEC *, const char *));\nstatic STRINGLIST *gen_wordlist_matches PARAMS((COMPSPEC *, const char *));\nstatic STRINGLIST *gen_shell_function_matches PARAMS((COMPSPEC *, const char *,\n\t\t\t\t\t\t   const char *,\n\t\t\t\t\t\t   char *, int, WORD_LIST *,\n\t\t\t\t\t\t   int, int, int *));\nstatic STRINGLIST *gen_command_matches PARAMS((COMPSPEC *, const char *,\n\t\t\t\t\t    const char *,\n\t\t\t\t\t    char *, int, WORD_LIST *,\n\t\t\t\t\t    int, int));\n\nstatic STRINGLIST *gen_progcomp_completions PARAMS((const char *, const char *,\n\t\t\t\t\t\t const char *,\n\t\t\t\t\t\t int, int, int *, int *,\n\t\t\t\t\t\t COMPSPEC **));\n\nstatic char *pcomp_filename_completion_function PARAMS((const char *, int));\n\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *bind_comp_words PARAMS((WORD_LIST *));\n#endif\nstatic void bind_compfunc_variables PARAMS((char *, int, WORD_LIST *, int, int));\nstatic void unbind_compfunc_variables PARAMS((int));\nstatic WORD_LIST *build_arg_list PARAMS((char *, const char *, const char *, WORD_LIST *, int));\nstatic WORD_LIST *command_line_to_word_list PARAMS((char *, int, int, int *, int *));\n\n#ifdef DEBUG\nstatic int progcomp_debug = 0;\n#endif\n\nint prog_completion_enabled = 1;\n\n#ifdef ALIAS\nint progcomp_alias = 0;\t \n#endif\n\n \nITEMLIST it_aliases = { 0, it_init_aliases, (STRINGLIST *)0 };\nITEMLIST it_arrayvars  = { LIST_DYNAMIC, it_init_arrayvars, (STRINGLIST *)0 };\nITEMLIST it_bindings  = { 0, it_init_bindings, (STRINGLIST *)0 };\nITEMLIST it_builtins  = { 0, it_init_builtins, (STRINGLIST *)0 };\nITEMLIST it_commands = { LIST_DYNAMIC };\t \nITEMLIST it_directories = { LIST_DYNAMIC };\t \nITEMLIST it_disabled = { 0, it_init_disabled, (STRINGLIST *)0 };\nITEMLIST it_enabled = { 0, it_init_enabled, (STRINGLIST *)0 };\nITEMLIST it_exports  = { LIST_DYNAMIC, it_init_exported, (STRINGLIST *)0 };\nITEMLIST it_files = { LIST_DYNAMIC };\t\t \nITEMLIST it_functions  = { 0, it_init_functions, (STRINGLIST *)0 };\nITEMLIST it_helptopics  = { 0, it_init_helptopics, (STRINGLIST *)0 };\nITEMLIST it_hostnames  = { LIST_DYNAMIC, it_init_hostnames, (STRINGLIST *)0 };\nITEMLIST it_groups = { LIST_DYNAMIC };\t\t \nITEMLIST it_jobs = { LIST_DYNAMIC, it_init_jobs, (STRINGLIST *)0 };\nITEMLIST it_keywords = { 0, it_init_keywords, (STRINGLIST *)0 };\nITEMLIST it_running = { LIST_DYNAMIC, it_init_running, (STRINGLIST *)0 };\nITEMLIST it_services = { LIST_DYNAMIC };\t \nITEMLIST it_setopts = { 0, it_init_setopts, (STRINGLIST *)0 };\nITEMLIST it_shopts = { 0, it_init_shopts, (STRINGLIST *)0 };\nITEMLIST it_signals = { 0, it_init_signals, (STRINGLIST *)0 };\nITEMLIST it_stopped = { LIST_DYNAMIC, it_init_stopped, (STRINGLIST *)0 };\nITEMLIST it_users = { LIST_DYNAMIC };\t\t \nITEMLIST it_variables = { LIST_DYNAMIC, it_init_variables, (STRINGLIST *)0 };\n\nCOMPSPEC *pcomp_curcs;\nconst char *pcomp_curcmd;\nconst char *pcomp_curtxt;\n\nchar *pcomp_line;\nint pcomp_ind;\n\n#ifdef DEBUG\n \nstatic void\n#if defined (PREFER_STDARG)\ndebug_printf (const char *format, ...)\n#else\ndebug_printf (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  if (progcomp_debug == 0)\n    return;\n\n  SH_VA_START (args, format);\n\n  fprintf (stdout, \"DEBUG: \");\n  vfprintf (stdout, format, args);\n  fprintf (stdout, \"\\n\");\n\n  rl_on_new_line ();\n\n  va_end (args);\n}\n#endif\n\n \n\nvoid\nset_itemlist_dirty (it)\n     ITEMLIST *it;\n{\n  it->flags |= LIST_DIRTY;\n}\n\nvoid\ninitialize_itemlist (itp)\n     ITEMLIST *itp;\n{\n  (*itp->list_getter) (itp);\n  itp->flags |= LIST_INITIALIZED;\n  itp->flags &= ~LIST_DIRTY;\n}\n\nvoid\nclean_itemlist (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n\n  sl = itp->slist;\n  if (sl)\n    {\n      if ((itp->flags & (LIST_DONTFREEMEMBERS|LIST_DONTFREE)) == 0)\n\tstrvec_flush (sl->list);\n      if ((itp->flags & LIST_DONTFREE) == 0)\n\tfree (sl->list);\n      free (sl);\n    }\n  itp->slist = (STRINGLIST *)NULL;\n  itp->flags &= ~(LIST_DONTFREE|LIST_DONTFREEMEMBERS|LIST_INITIALIZED|LIST_DIRTY);\n}\n\n\nstatic int\nshouldexp_filterpat (s)\n     char *s;\n{\n  register char *p;\n\n  for (p = s; p && *p; p++)\n    {\n      if (*p == '\\\\')\n\tp++;\n      else if (*p == '&')\n\treturn 1;\n    }\n  return 0;\n}\n\n \nstatic char *\npreproc_filterpat (pat, text)\n     char *pat;\n     const char *text;\n{\n  char *ret;\n\n  ret = strcreplace (pat, '&', text, 1);\n  return ret;\n}\n\t\n    \nSTRINGLIST *\nfilter_stringlist (sl, filterpat, text)\n     STRINGLIST *sl;\n     char *filterpat;\n     const char *text;\n{\n  int i, m, not;\n  STRINGLIST *ret;\n  char *npat, *t;\n\n  if (sl == 0 || sl->list == 0 || sl->list_len == 0)\n    return sl;\n\n  npat = shouldexp_filterpat (filterpat) ? preproc_filterpat (filterpat, text) : filterpat;\n\n#if defined (EXTENDED_GLOB)\n  not = (npat[0] == '!' && (extended_glob == 0 || npat[1] != '('));\t \n#else\n  not = (npat[0] == '!');\n#endif\n  t = not ? npat + 1 : npat;\n\n  ret = strlist_create (sl->list_size);\n  for (i = 0; i < sl->list_len; i++)\n    {\n      m = strmatch (t, sl->list[i], FNMATCH_EXTFLAG | FNMATCH_IGNCASE);\n      if ((not && m == FNM_NOMATCH) || (not == 0 && m != FNM_NOMATCH))\n\tfree (sl->list[i]);\n      else\n\tret->list[ret->list_len++] = sl->list[i];\n    }\n\n  ret->list[ret->list_len] = (char *)NULL;\n  if (npat != filterpat)\n    free (npat);\n\n  return ret;\n}\n\n \nSTRINGLIST *\ncompletions_to_stringlist (matches)\n     char **matches;\n{\n  STRINGLIST *sl;\n  int mlen, i, n;\n\n  mlen = (matches == 0) ? 0 : strvec_len (matches);\n  sl = strlist_create (mlen + 1);\n\n  if (matches == 0 || matches[0] == 0)\n    return sl;\n\n  if (matches[1] == 0)\n    {\n      sl->list[0] = STRDUP (matches[0]);\n      sl->list[sl->list_len = 1] = (char *)NULL;\n      return sl;\n    }\n\n  for (i = 1, n = 0; i < mlen; i++, n++)\n    sl->list[n] = STRDUP (matches[i]);\n  sl->list_len = n;\n  sl->list[n] = (char *)NULL;\n\n  return sl;\n}\n\n \n\nstatic int\nit_init_aliases (itp)\n     ITEMLIST *itp;\n{\n#ifdef ALIAS\n  alias_t **alias_list;\n  register int i, n;\n  STRINGLIST *sl;\n\n  alias_list = all_aliases ();\n  if (alias_list == 0)\n    {\n      itp->slist = (STRINGLIST *)NULL;\n      return 0;\n    }\n  for (n = 0; alias_list[n]; n++)\n    ;\n  sl = strlist_create (n+1);\n  for (i = 0; i < n; i++)\n    sl->list[i] = STRDUP (alias_list[i]->name);\n  sl->list[n] = (char *)NULL;\n  sl->list_size = sl->list_len = n;\n  itp->slist = sl;\n#else\n  itp->slist = (STRINGLIST *)NULL;\n#endif\n  free (alias_list);\n  return 1;\n}\n\nstatic void\ninit_itemlist_from_varlist (itp, svfunc)\n     ITEMLIST *itp;\n     SVFUNC *svfunc;\n{\n  SHELL_VAR **vlist;\n  STRINGLIST *sl;\n  register int i, n;\n\n  vlist = (*svfunc) ();\n  if (vlist == 0)\n    {\n      itp->slist = (STRINGLIST *)NULL;\n      return;\n    }    \n  for (n = 0; vlist[n]; n++)\n    ;\n  sl = strlist_create (n+1);\n  for (i = 0; i < n; i++)\n    sl->list[i] = savestring (vlist[i]->name);\n  sl->list[sl->list_len = n] = (char *)NULL;\n  itp->slist = sl;\n  free (vlist);\n}\n\nstatic int\nit_init_arrayvars (itp)\n     ITEMLIST *itp;\n{\n#if defined (ARRAY_VARS)\n  init_itemlist_from_varlist (itp, all_array_variables);\n  return 1;\n#else\n  return 0;\n#endif\n}\n\nstatic int\nit_init_bindings (itp)\n     ITEMLIST *itp;\n{\n  char **blist;\n  STRINGLIST *sl;\n\n   \n  blist = (char **)rl_funmap_names ();\t \n  sl = strlist_create (0);\n  sl->list = blist;\n  sl->list_size = 0;\n  sl->list_len = strvec_len (sl->list);\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  itp->slist = sl;\n\n  return 0;\n}\n\nstatic int\nit_init_builtins (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n  register int i, n;\n\n  sl = strlist_create (num_shell_builtins);\n  for (i = n = 0; i < num_shell_builtins; i++)\n    if (shell_builtins[i].function)\n      sl->list[n++] = shell_builtins[i].name;\n  sl->list[sl->list_len = n] = (char *)NULL;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  itp->slist = sl;\n  return 0;\n}\n\nstatic int\nit_init_enabled (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n  register int i, n;\n\n  sl = strlist_create (num_shell_builtins);\n  for (i = n = 0; i < num_shell_builtins; i++)\n    {\n      if (shell_builtins[i].function && (shell_builtins[i].flags & BUILTIN_ENABLED))\n\tsl->list[n++] = shell_builtins[i].name;\n    }\n  sl->list[sl->list_len = n] = (char *)NULL;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  itp->slist = sl;\n  return 0;\n}\n\nstatic int\nit_init_disabled (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n  register int i, n;\n\n  sl = strlist_create (num_shell_builtins);\n  for (i = n = 0; i < num_shell_builtins; i++)\n    {\n      if (shell_builtins[i].function && ((shell_builtins[i].flags & BUILTIN_ENABLED) == 0))\n\tsl->list[n++] = shell_builtins[i].name;\n    }\n  sl->list[sl->list_len = n] = (char *)NULL;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  itp->slist = sl;\n  return 0;\n}\n\nstatic int\nit_init_exported (itp)\n     ITEMLIST *itp;\n{\n  init_itemlist_from_varlist (itp, all_exported_variables);\n  return 0;\n}\n\nstatic int\nit_init_functions (itp)\n     ITEMLIST *itp;\n{\n  init_itemlist_from_varlist (itp, all_visible_functions);\n  return 0;\n}\n\n \nstatic int\nit_init_helptopics (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n  register int i, n;\n\n  sl = strlist_create (num_shell_builtins);\n  for (i = n = 0; i < num_shell_builtins; i++)\n    sl->list[n++] = shell_builtins[i].name;\n  sl->list[sl->list_len = n] = (char *)NULL;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  itp->slist = sl;\n  return 0;\n}\n\nstatic int\nit_init_hostnames (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n\n  sl = strlist_create (0);\n  sl->list = get_hostname_list ();\n  sl->list_len = sl->list ? strvec_len (sl->list) : 0;\n  sl->list_size = sl->list_len;\n  itp->slist = sl;\n  itp->flags |= LIST_DONTFREEMEMBERS|LIST_DONTFREE;\n  return 0;\n}\n\nstatic int\nit_init_joblist (itp, jstate)\n     ITEMLIST *itp;\n     int jstate;\n{\n#if defined (JOB_CONTROL)\n  STRINGLIST *sl;\n  register int i;\n  register PROCESS *p;\n  char *s, *t;\n  JOB *j;\n  JOB_STATE ws;\t\t \n\n  ws = JNONE;\n  if (jstate == 0)\n    ws = JRUNNING;\n  else if (jstate == 1)\n    ws = JSTOPPED;\n\n  sl = strlist_create (js.j_jobslots);\n  for (i = js.j_jobslots - 1; i >= 0; i--)\n    {\n      j = get_job_by_jid (i);\n      if (j == 0)\n\tcontinue;\n      p = j->pipe;\n      if (jstate == -1 || JOBSTATE(i) == ws)\n\t{\n\t  s = savestring (p->command);\n\t  t = strpbrk (s, \" \\t\\n\");\n\t  if (t)\n\t    *t = '\\0';\n\t  sl->list[sl->list_len++] = s;\n\t}\n    }\n  itp->slist = sl;\n#else\n  itp->slist = (STRINGLIST *)NULL;\n#endif\n  return 0;\n}\n\nstatic int\nit_init_jobs (itp)\n     ITEMLIST *itp;\n{\n  return (it_init_joblist (itp, -1));\n}\n\nstatic int\nit_init_running (itp)\n     ITEMLIST *itp;\n{\n  return (it_init_joblist (itp, 0));\n}\n\nstatic int\nit_init_stopped (itp)\n     ITEMLIST *itp;\n{\n  return (it_init_joblist (itp, 1));\n}\n\nstatic int\nit_init_keywords (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n  register int i, n;\n\n  for (n = 0; word_token_alist[n].word; n++)\n    ;\n  sl = strlist_create (n);\n  for (i = 0; i < n; i++)\n    sl->list[i] = word_token_alist[i].word;\n  sl->list[sl->list_len = i] = (char *)NULL;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  itp->slist = sl;\n  return 0;\n}\n\nstatic int\nit_init_signals (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n\n  sl = strlist_create (0);\n  sl->list = signal_names;\n  sl->list_len = strvec_len (sl->list);\n  itp->flags |= LIST_DONTFREE;\n  itp->slist = sl;\n  return 0;\n}\n\nstatic int\nit_init_variables (itp)\n     ITEMLIST *itp;\n{\n  init_itemlist_from_varlist (itp, all_visible_variables);\n  return 0;\n}\n\nstatic int\nit_init_setopts (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n\n  sl = strlist_create (0);\n  sl->list = get_minus_o_opts ();\n  sl->list_len = strvec_len (sl->list);\n  itp->slist = sl;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  return 0;\n}\n\nstatic int\nit_init_shopts (itp)\n     ITEMLIST *itp;\n{\n  STRINGLIST *sl;\n\n  sl = strlist_create (0);\n  sl->list = get_shopt_options ();\n  sl->list_len = strvec_len (sl->list);\n  itp->slist = sl;\n  itp->flags |= LIST_DONTFREEMEMBERS;\n  return 0;\n}\n\n \nstatic STRINGLIST *\ngen_matches_from_itemlist (itp, text)\n     ITEMLIST *itp;\n     const char *text;\n{\n  STRINGLIST *ret, *sl;\n  int tlen, i, n;\n  char *ntxt;\n\n  if ((itp->flags & (LIST_DIRTY|LIST_DYNAMIC)) ||\n      (itp->flags & LIST_INITIALIZED) == 0)\n    {\n      if (itp->flags & (LIST_DIRTY|LIST_DYNAMIC))\n\tclean_itemlist (itp);\n      if ((itp->flags & LIST_INITIALIZED) == 0)\n\tinitialize_itemlist (itp);\n    }\n  if (itp->slist == 0)\n    return ((STRINGLIST *)NULL);\n  ret = strlist_create (itp->slist->list_len+1);\n  sl = itp->slist;\n\n  ntxt = bash_dequote_text (text);\n  tlen = STRLEN (ntxt);\n\n  for (i = n = 0; i < sl->list_len; i++)\n    {\n      if (tlen == 0 || STREQN (sl->list[i], ntxt, tlen))\n\tret->list[n++] = STRDUP (sl->list[i]);\n    }\n  ret->list[ret->list_len = n] = (char *)NULL;\n\n  FREE (ntxt);\n  return ret;\n}\n\n \nstatic char *\npcomp_filename_completion_function (text, state)\n     const char *text;\n     int state;\n{\n  static char *dfn;\t \n  int iscompgen, iscompleting;\n\n  if (state == 0)\n    {\n      FREE (dfn);\n       \n       \n      iscompgen = this_shell_builtin == compgen_builtin;\n      iscompleting = RL_ISSTATE (RL_STATE_COMPLETING);\n      if (iscompgen && iscompleting == 0 && rl_completion_found_quote == 0\n\t  && rl_filename_dequoting_function)\n\t{\n\t   \n\t  dfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);\n\t}\n       \n      else if (iscompgen && iscompleting &&\n\t       pcomp_curtxt && *pcomp_curtxt == 0 &&\n\t       text && (*text == '\\'' || *text == '\"') && text[1] == text[0] && text[2] == 0 && \n\t       rl_filename_dequoting_function)\n\tdfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);\n       \n       \n      else if (iscompgen && iscompleting && rl_filename_dequoting_function &&\n\t       pcomp_curtxt && text &&\n\t       STREQ (pcomp_curtxt, text) == 0 &&\n\t       variable_context &&\n\t       sh_contains_quotes (text))\t \n\tdfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);\n      else\n\tdfn = savestring (text);\n    }\n\n  return (rl_filename_completion_function (dfn, state));\n}\n\n#define GEN_COMPS(bmap, flag, it, text, glist, tlist) \\\n  do { \\\n    if (bmap & flag) \\\n      { \\\n\ttlist = gen_matches_from_itemlist (it, text); \\\n\tif (tlist) \\\n\t  { \\\n\t    glist = strlist_append (glist, tlist); \\\n\t    strlist_dispose (tlist); \\\n\t  } \\\n      } \\\n  } while (0)\n\n#define GEN_XCOMPS(bmap, flag, text, func, cmatches, glist, tlist) \\\n  do { \\\n    if (bmap & flag) \\\n      { \\\n\tcmatches = rl_completion_matches (text, func); \\\n\ttlist = completions_to_stringlist (cmatches); \\\n\tglist = strlist_append (glist, tlist); \\\n\tstrvec_dispose (cmatches); \\\n\tstrlist_dispose (tlist); \\\n      } \\\n  } while (0)\n\n \n\nstatic STRINGLIST *\ngen_action_completions (cs, text)\n     COMPSPEC *cs;\n     const char *text;\n{\n  STRINGLIST *ret, *tmatches;\n  char **cmatches;\t \n  unsigned long flags;\n  int t;\n\n  ret = tmatches = (STRINGLIST *)NULL;\n  flags = cs->actions;\n\n  GEN_COMPS (flags, CA_ALIAS, &it_aliases, text, ret, tmatches);\n  GEN_COMPS (flags, CA_ARRAYVAR, &it_arrayvars, text, ret, tmatches);\n  GEN_COMPS (flags, CA_BINDING, &it_bindings, text, ret, tmatches);\n  GEN_COMPS (flags, CA_BUILTIN, &it_builtins, text, ret, tmatches);\n  GEN_COMPS (flags, CA_DISABLED, &it_disabled, text, ret, tmatches);\n  GEN_COMPS (flags, CA_ENABLED, &it_enabled, text, ret, tmatches);\n  GEN_COMPS (flags, CA_EXPORT, &it_exports, text, ret, tmatches);\n  GEN_COMPS (flags, CA_FUNCTION, &it_functions, text, ret, tmatches);\n  GEN_COMPS (flags, CA_HELPTOPIC, &it_helptopics, text, ret, tmatches);\n  GEN_COMPS (flags, CA_HOSTNAME, &it_hostnames, text, ret, tmatches);\n  GEN_COMPS (flags, CA_JOB, &it_jobs, text, ret, tmatches);\n  GEN_COMPS (flags, CA_KEYWORD, &it_keywords, text, ret, tmatches);\n  GEN_COMPS (flags, CA_RUNNING, &it_running, text, ret, tmatches);\n  GEN_COMPS (flags, CA_SETOPT, &it_setopts, text, ret, tmatches);\n  GEN_COMPS (flags, CA_SHOPT, &it_shopts, text, ret, tmatches);\n  GEN_COMPS (flags, CA_SIGNAL, &it_signals, text, ret, tmatches);\n  GEN_COMPS (flags, CA_STOPPED, &it_stopped, text, ret, tmatches);\n  GEN_COMPS (flags, CA_VARIABLE, &it_variables, text, ret, tmatches);\n\n  GEN_XCOMPS(flags, CA_COMMAND, text, command_word_completion_function, cmatches, ret, tmatches);\n  GEN_XCOMPS(flags, CA_FILE, text, pcomp_filename_completion_function, cmatches, ret, tmatches);\n  GEN_XCOMPS(flags, CA_USER, text, rl_username_completion_function, cmatches, ret, tmatches);\n  GEN_XCOMPS(flags, CA_GROUP, text, bash_groupname_completion_function, cmatches, ret, tmatches);\n  GEN_XCOMPS(flags, CA_SERVICE, text, bash_servicename_completion_function, cmatches, ret, tmatches);\n\n   \n  if (flags & CA_DIRECTORY)\n    {\n      t = rl_filename_completion_desired;\n      rl_completion_mark_symlink_dirs = 1;\t \n      cmatches = bash_directory_completion_matches (text);\n       \n      if (t == 0 && cmatches == 0 && rl_filename_completion_desired == 1)\n        rl_filename_completion_desired = 0;\n      tmatches = completions_to_stringlist (cmatches);\n      ret = strlist_append (ret, tmatches);\n      strvec_dispose (cmatches);\n      strlist_dispose (tmatches);\n    }\n\n  return ret;\n}\n\n \nstatic STRINGLIST *\ngen_globpat_matches (cs, text)\n      COMPSPEC *cs;\n      const char *text;\n{\n  STRINGLIST *sl;\n  int gflags;\n\n  sl = strlist_create (0);\n  gflags = glob_star ? GX_GLOBSTAR : 0;\n  sl->list = glob_filename (cs->globpat, gflags);\n  if (GLOB_FAILED (sl->list))\n    sl->list = (char **)NULL;\n  if (sl->list)\n    sl->list_len = sl->list_size = strvec_len (sl->list);\n  return sl;\n}\n\n \nstatic STRINGLIST *\ngen_wordlist_matches (cs, text)\n     COMPSPEC *cs;\n     const char *text;\n{\n  WORD_LIST *l, *l2;\n  STRINGLIST *sl;\n  int nw, tlen;\n  char *ntxt;\t\t \n\n  if (cs->words == 0 || cs->words[0] == '\\0')\n    return ((STRINGLIST *)NULL);\n\n   \n   \n  l = split_at_delims (cs->words, strlen (cs->words), (char *)NULL, -1, 0, (int *)NULL, (int *)NULL);\n  if (l == 0)\n    return ((STRINGLIST *)NULL);\n   \n  l2 = expand_words_shellexp (l);\n  dispose_words (l);\n\n  nw = list_length (l2);\n  sl = strlist_create (nw + 1);\n\n  ntxt = bash_dequote_text (text);\n  tlen = STRLEN (ntxt);\n\n  for (nw = 0, l = l2; l; l = l->next)\n    {\n      if (tlen == 0 || STREQN (l->word->word, ntxt, tlen))\n\tsl->list[nw++] = STRDUP (l->word->word);\n    }\n  sl->list[sl->list_len = nw] = (char *)NULL;\n\n  dispose_words (l2);\n  FREE (ntxt);\n  return sl;\n}\n\n#ifdef ARRAY_VARS\n\nstatic SHELL_VAR *\nbind_comp_words (lwords)\n     WORD_LIST *lwords;\n{\n  SHELL_VAR *v;\n\n  v = find_variable_noref (\"COMP_WORDS\");\n  if (v == 0)\n    v = make_new_array_variable (\"COMP_WORDS\");\n  if (nameref_p (v))\n    VUNSETATTR (v, att_nameref);\n#if 0\n  if (readonly_p (v))\n    VUNSETATTR (v, att_readonly);\n#endif\n  if (array_p (v) == 0)\n    v = convert_var_to_array (v);\n  v = assign_array_var_from_word_list (v, lwords, 0);\n\n  VUNSETATTR (v, att_invisible);\n  return v;\n}\n#endif  \n\nstatic void\nbind_compfunc_variables (line, ind, lwords, cw, exported)\n     char *line;\n     int ind;\n     WORD_LIST *lwords;\n     int cw, exported;\n{\n  char ibuf[INT_STRLEN_BOUND(int) + 1];\n  char *value;\n  SHELL_VAR *v;\n  size_t llen;\n  int c;\n\n   \n  v = bind_variable (\"COMP_LINE\", line, 0);\n  if (v && exported)\n    VSETATTR(v, att_exported);\n\n   \n  c = line[ind];\n  line[ind] = '\\0';\n  llen = MB_STRLEN (line);\n  line[ind] = c;\n  value = inttostr (llen, ibuf, sizeof(ibuf));\n  v = bind_int_variable (\"COMP_POINT\", value, 0);\n  if (v && exported)\n    VSETATTR(v, att_exported);\n\n  value = inttostr (rl_completion_type, ibuf, sizeof (ibuf));\n  v = bind_int_variable (\"COMP_TYPE\", value, 0);\n  if (v && exported)\n    VSETATTR(v, att_exported);\n\n  value = inttostr (rl_completion_invoking_key, ibuf, sizeof (ibuf));\n  v = bind_int_variable (\"COMP_KEY\", value, 0);\n  if (v && exported)\n    VSETATTR(v, att_exported);\n\n   \n  if (exported == 0)\n    {\n#ifdef ARRAY_VARS\n      v = bind_comp_words (lwords);\n      value = inttostr (cw, ibuf, sizeof(ibuf));\n      bind_int_variable (\"COMP_CWORD\", value, 0);\n#endif\n    }\n  else\n    array_needs_making = 1;\n}\n\nstatic void\nunbind_compfunc_variables (exported)\n     int exported;\n{\n  unbind_variable_noref (\"COMP_LINE\");\n  unbind_variable_noref (\"COMP_POINT\");\n  unbind_variable_noref (\"COMP_TYPE\");\n  unbind_variable_noref (\"COMP_KEY\");\n#ifdef ARRAY_VARS\n  unbind_variable_noref (\"COMP_WORDS\");\n  unbind_variable_noref (\"COMP_CWORD\");\n#endif\n  if (exported)\n    array_needs_making = 1;\n}\n\n \n\nstatic WORD_LIST *\nbuild_arg_list (cmd, cname, text, lwords, ind)\n     char *cmd;\n     const char *cname;\n     const char *text;\n     WORD_LIST *lwords;\n     int ind;\n{\n  WORD_LIST *ret, *cl, *l;\n  WORD_DESC *w;\n  int i;\n\n  ret = (WORD_LIST *)NULL;\n  w = make_word (cmd);\n  ret = make_word_list (w, (WORD_LIST *)NULL);\t \n\n  w = make_word (cname);\t\t\t \n  cl = ret->next = make_word_list (w, (WORD_LIST *)NULL);\n\n  w = make_word (text);\n  cl->next = make_word_list (w, (WORD_LIST *)NULL);\t \n  cl = cl->next;\n\n   \n  for (l = lwords, i = 1; l && i < ind-1; l = l->next, i++)\n    ;\n  w = (l && l->word) ? copy_word (l->word) : make_word (\"\");\n  cl->next = make_word_list (w, (WORD_LIST *)NULL);\n\n  return ret;\n}\n\n \n\nstatic STRINGLIST *\ngen_shell_function_matches (cs, cmd, text, line, ind, lwords, nw, cw, foundp)\n     COMPSPEC *cs;\n     const char *cmd;\n     const char *text;\n     char *line;\n     int ind;\n     WORD_LIST *lwords;\n     int nw, cw;\n     int *foundp;\n{\n  char *funcname;\n  STRINGLIST *sl;\n  SHELL_VAR *f, *v;\n  WORD_LIST *cmdlist;\n  int fval, found;\n  sh_parser_state_t ps;\n  sh_parser_state_t * restrict pps;\n#if defined (ARRAY_VARS)\n  ARRAY *a;\n#endif\n\n  found = 0;\n  if (foundp)\n    *foundp = found;\n\n  funcname = cs->funcname;\n  f = find_function (funcname);\n  if (f == 0)\n    {\n      internal_error (_(\"completion: function `%s' not found\"), funcname);\n      rl_ding ();\n      rl_on_new_line ();\n      return ((STRINGLIST *)NULL);\n    }\n\n#if !defined (ARRAY_VARS)\n  return ((STRINGLIST *)NULL);\n#else\n\n   \n  bind_compfunc_variables (line, ind, lwords, cw - 1, 0);\n\n  cmdlist = build_arg_list (funcname, cmd, text, lwords, cw);\n\n  pps = &ps;\n  save_parser_state (pps);\n  begin_unwind_frame (\"gen-shell-function-matches\");\n  add_unwind_protect (restore_parser_state, (char *)pps);\n  add_unwind_protect (dispose_words, (char *)cmdlist);\n  add_unwind_protect (unbind_compfunc_variables, (char *)0);\n\n  fval = execute_shell_function (f, cmdlist);  \n\n  discard_unwind_frame (\"gen-shell-function-matches\");\n  restore_parser_state (pps);\n\n  found = fval != EX_NOTFOUND;\n  if (fval == EX_RETRYFAIL)\n    found |= PCOMP_RETRYFAIL;\n  if (foundp)\n    *foundp = found;\n\n   \n  dispose_words (cmdlist);\n  unbind_compfunc_variables (0);\n\n   \n  v = find_variable (\"COMPREPLY\");\n  if (v == 0)\n    return ((STRINGLIST *)NULL);\n  if (array_p (v) == 0 && assoc_p (v) == 0)\n    v = convert_var_to_array (v);\n\n  VUNSETATTR (v, att_invisible);\n\n  a = array_cell (v);\n  if (found == 0 || (found & PCOMP_RETRYFAIL) || a == 0 || array_p (v) == 0 || array_empty (a))\n    sl = (STRINGLIST *)NULL;\n  else\n    {\n       \n      sl = strlist_create (0);\n      sl->list = array_to_argv (a, 0);\n      sl->list_len = sl->list_size = array_num_elements (a);\n    }\n\n   \n  unbind_variable_noref (\"COMPREPLY\");\n\n  return (sl);\n#endif\n}\n\n \n\nstatic STRINGLIST *\ngen_command_matches (cs, cmd, text, line, ind, lwords, nw, cw)\n     COMPSPEC *cs;\n     const char *cmd;\n     const char *text;\n     char *line;\n     int ind;\n     WORD_LIST *lwords;\n     int nw, cw;\n{\n  char *csbuf, *cscmd, *t;\n  int cmdlen, cmdsize, n, ws, we;\n  WORD_LIST *cmdlist, *cl;\n  WORD_DESC *tw;\n  STRINGLIST *sl;\n\n  bind_compfunc_variables (line, ind, lwords, cw, 1);\n  cmdlist = build_arg_list (cs->command, cmd, text, lwords, cw);\n\n   \n  n = strlen (cs->command);\n  cmdsize = n + 1;\n  for (cl = cmdlist->next; cl; cl = cl->next)\n    cmdsize += STRLEN (cl->word->word) + 3;\n  cmdsize += 2;\n\n   \n  cscmd = (char *)xmalloc (cmdsize + 1);\n\n  strcpy (cscmd, cs->command);\t\t\t \n  cmdlen = n;\n  cscmd[cmdlen++] = ' ';\n  for (cl = cmdlist->next; cl; cl = cl->next)    \n    {\n      t = sh_single_quote (cl->word->word ? cl->word->word : \"\");\n      n = strlen (t);\n      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);\n      strcpy (cscmd + cmdlen, t);\n      cmdlen += n;\n      if (cl->next)\n\tcscmd[cmdlen++] = ' ';\n      free (t);\n    }\n  cscmd[cmdlen] = '\\0';\n\n  tw = command_substitute (cscmd, 0, 0);\n  csbuf = tw ? tw->word : (char *)NULL;\n  if (tw)\n    dispose_word_desc (tw);\n\n   \n  dispose_words (cmdlist);\n  free (cscmd);\n  unbind_compfunc_variables (1);\n\n  if (csbuf == 0 || *csbuf == '\\0')\n    {\n      FREE (csbuf);\n      return ((STRINGLIST *)NULL);\n    }\n\n   \n  sl = strlist_create (16);\n  for (ws = 0; csbuf[ws]; )\n    {\n      we = ws;\n      while (csbuf[we] && csbuf[we] != '\\n')\n\t{\n\t  if (csbuf[we] == '\\\\' && csbuf[we+1] == '\\n')\n\t    we++;\n\t  we++;\n\t}\n      t = substring (csbuf, ws, we);\n      if (sl->list_len >= sl->list_size - 1)\n\tstrlist_resize (sl, sl->list_size + 16);\n      sl->list[sl->list_len++] = t;\n      while (csbuf[we] == '\\n') we++;\n      ws = we;\n    }\n  sl->list[sl->list_len] = (char *)NULL;\n\n  free (csbuf);\n  return (sl);\n}\n\nstatic WORD_LIST *\ncommand_line_to_word_list (line, llen, sentinel, nwp, cwp)\n     char *line;\n     int llen, sentinel, *nwp, *cwp;\n{\n  WORD_LIST *ret;\n  const char *delims;\n\n#if 0\n  delims = \"()<>;&| \\t\\n\";\t \n#else\n  delims = rl_completer_word_break_characters;\n#endif\n  ret = split_at_delims (line, llen, delims, sentinel, SD_NOQUOTEDELIM|SD_COMPLETE, nwp, cwp);\n  return (ret);\n}\n\n \n\nSTRINGLIST *\ngen_compspec_completions (cs, cmd, word, start, end, foundp)\n     COMPSPEC *cs;\n     const char *cmd;\n     const char *word;\n     int start, end;\n     int *foundp;\n{\n  STRINGLIST *ret, *tmatches;\n  char *line;\n  int llen, nw, cw, found, foundf;\n  WORD_LIST *lwords;\n  WORD_DESC *lw;\n  COMPSPEC *tcs;\n\n  found = 1;\n\n#ifdef DEBUG\n  debug_printf (\"gen_compspec_completions (%s, %s, %d, %d)\", cmd, word, start, end);\n  debug_printf (\"gen_compspec_completions: %s -> %p\", cmd, cs);\n#endif\n  ret = gen_action_completions (cs, word);\n#ifdef DEBUG\n  if (ret && progcomp_debug)\n    {\n      debug_printf (\"gen_action_completions (%p, %s) -->\", cs, word);\n      strlist_print (ret, \"\\t\");\n      rl_on_new_line ();\n    }\n#endif\n\n   \n  if (cs->globpat)\n    {\n      tmatches = gen_globpat_matches (cs, word);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_globpat_matches (%p, %s) -->\", cs, word);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t  rl_filename_completion_desired = 1;\n\t}\n    }\n\n  if (cs->words)\n    {\n      tmatches = gen_wordlist_matches (cs, word);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_wordlist_matches (%p, %s) -->\", cs, word);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  lwords = (WORD_LIST *)NULL;\n  line = (char *)NULL;\n  if (cs->command || cs->funcname)\n    {\n       \n      line = substring (pcomp_line, start, end);\n      llen = end - start;\n\n#ifdef DEBUG\n      debug_printf (\"command_line_to_word_list (%s, %d, %d, %p, %p)\",\n\t\tline, llen, pcomp_ind - start, &nw, &cw);\n#endif\n      lwords = command_line_to_word_list (line, llen, pcomp_ind - start, &nw, &cw);\n       \n      if (lwords && lwords->word && cmd[0] == 0 && lwords->word->word[0] != 0)\n\t{\n\t  lw = make_bare_word (cmd);\n\t  lwords = make_word_list (lw, lwords);\n\t  nw++;\n\t  cw++;\n\t}\n#ifdef DEBUG\n      if (lwords == 0 && llen > 0)\n\tdebug_printf (\"ERROR: command_line_to_word_list returns NULL\");\n      else if (progcomp_debug)\n\t{\n\t  debug_printf (\"command_line_to_word_list -->\");\n\t  printf (\"\\t\");\n\t  print_word_list (lwords, \"!\");\n\t  printf (\"\\n\");\n\t  fflush(stdout);\n\t  rl_on_new_line ();\n\t}\n#endif\n    }\n\n  if (cs->funcname)\n    {\n      foundf = 0;\n      tmatches = gen_shell_function_matches (cs, cmd, word, line, pcomp_ind - start, lwords, nw, cw, &foundf);\n      if (foundf != 0)\n\tfound = foundf;\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_shell_function_matches (%p, %s, %s, %p, %d, %d) -->\", cs, cmd, word, lwords, nw, cw);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  if (cs->command)\n    {\n      tmatches = gen_command_matches (cs, cmd, word, line, pcomp_ind - start, lwords, nw, cw);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_command_matches (%p, %s, %s, %p, %d, %d) -->\", cs, cmd, word, lwords, nw, cw);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  if (cs->command || cs->funcname)\n    {\n      if (lwords)\n\tdispose_words (lwords);\n      FREE (line);\n    }\n\n  if (foundp)\n    *foundp = found;\n\n  if (found == 0 || (found & PCOMP_RETRYFAIL))\n    {\n      strlist_dispose (ret);\n      return NULL;\n    }\n\n  if (cs->filterpat)\n    {\n      tmatches = filter_stringlist (ret, cs->filterpat, word);\n#ifdef DEBUG\n      if (progcomp_debug)\n\t{\n\t  debug_printf (\"filter_stringlist (%p, %s, %s) -->\", ret, cs->filterpat, word);\n\t  strlist_print (tmatches, \"\\t\");\n\t  rl_on_new_line ();\n\t}\n#endif\n      if (ret && ret != tmatches)\n\t{\n\t  FREE (ret->list);\n\t  free (ret);\n\t}\n      ret = tmatches;\n    }\n\n  if (cs->prefix || cs->suffix)\n    ret = strlist_prefix_suffix (ret, cs->prefix, cs->suffix);\n\n   \n  if ((ret == 0 || ret->list_len == 0) && (cs->options & COPT_DIRNAMES))\n    {\n      tcs = compspec_create ();\n      tcs->actions = CA_DIRECTORY;\n      FREE (ret);\n      ret = gen_action_completions (tcs, word);\n      compspec_dispose (tcs);\n    }\n  else if (cs->options & COPT_PLUSDIRS)\n    {\n      tcs = compspec_create ();\n      tcs->actions = CA_DIRECTORY;\n      tmatches = gen_action_completions (tcs, word);\n      ret = strlist_append (ret, tmatches);\n      strlist_dispose (tmatches);\n      compspec_dispose (tcs);\n    }\n\n  return (ret);\n}\n\nvoid\npcomp_set_readline_variables (flags, nval)\n     int flags, nval;\n{\n   \n  if (flags & COPT_FILENAMES)\n    rl_filename_completion_desired = nval;\n   \n  if (flags & COPT_NOSPACE)\n    rl_completion_suppress_append = nval;\n   \n  if (flags & COPT_NOQUOTE)\n    rl_filename_quoting_desired = 1 - nval;\n  if (flags & COPT_NOSORT)\n    rl_sort_completion_matches = 1 - nval;\n}\n\n \nvoid\npcomp_set_compspec_options (cs, flags, set_or_unset)\n     COMPSPEC *cs;\n     int flags, set_or_unset;\n{\n  if (cs == 0 && ((cs = pcomp_curcs) == 0))\n    return;\n  if (set_or_unset)\n    cs->options |= flags;\n  else\n    cs->options &= ~flags;\n}\n\nstatic STRINGLIST *\ngen_progcomp_completions (ocmd, cmd, word, start, end, foundp, retryp, lastcs)\n     const char *ocmd;\n     const char *cmd;\n     const char *word;\n     int start, end;\n     int *foundp, *retryp;\n     COMPSPEC **lastcs;\n{\n  COMPSPEC *cs, *oldcs;\n  const char *oldcmd, *oldtxt;\n  STRINGLIST *ret;\n\n  cs = progcomp_search (ocmd);\n\n  if (cs == 0 || cs == *lastcs)\n    {\n#if 0\n      if (foundp)\n\t*foundp = 0;\n#endif\n      return (NULL);\n    }\n\n  if (*lastcs)\n    compspec_dispose (*lastcs);\n  cs->refcount++;\t \n  *lastcs = cs;\n\n  cs = compspec_copy (cs);\n\n  oldcs = pcomp_curcs;\n  oldcmd = pcomp_curcmd;\n  oldtxt = pcomp_curtxt;\n\n  pcomp_curcs = cs;\n  pcomp_curcmd = cmd;\n  pcomp_curtxt = word;\n\n  ret = gen_compspec_completions (cs, cmd, word, start, end, foundp);\n\n  pcomp_curcs = oldcs;\n  pcomp_curcmd = oldcmd;\n  pcomp_curtxt = oldtxt;\n\n   \n  if (retryp)\n    *retryp = foundp && (*foundp & PCOMP_RETRYFAIL);    \t\n\n  if (foundp)\n    {\n      *foundp &= ~PCOMP_RETRYFAIL;\n      *foundp |= cs->options;\n    }\n\n  compspec_dispose (cs);\n  return ret;  \n}\n\n \nchar **\nprogrammable_completions (cmd, word, start, end, foundp)\n     const char *cmd;\n     const char *word;\n     int start, end, *foundp;\n{\n  COMPSPEC *lastcs;\n  STRINGLIST *ret;\n  char **rmatches, *t;\n  int found, retry, count;\n  char *ocmd;\n  int oend;\n#if defined (ALIAS)\n  alias_t *al;\n#endif\n\n  lastcs = 0;\n  found = count = 0;\n\n  pcomp_line = rl_line_buffer;\n  pcomp_ind = rl_point;\n\n  ocmd = (char *)cmd;\n  oend = end;\n\n  do\n    {\n      retry = 0;\n\n       \n      ret = gen_progcomp_completions (ocmd, ocmd, word, start, oend, &found, &retry, &lastcs);\n      if (found == 0)\n\t{\n\t  t = strrchr (ocmd, '/');\n\t  if (t && *(++t))\n\t    ret = gen_progcomp_completions (t, ocmd, word, start, oend, &found, &retry, &lastcs);\n\t}\n\n      if (found == 0)\n\tret = gen_progcomp_completions (DEFAULTCMD, ocmd, word, start, oend, &found, &retry, &lastcs);\n\n#if defined (ALIAS)\n       \n       \n      if (found == 0 && retry == 0 && progcomp_alias && (al = find_alias (ocmd)))\n\t{\n\t  char *ncmd, *nline, *ntxt;\n\t  int ind, lendiff;\n\t  size_t nlen, olen, llen;\n\n\t   \n\t  ntxt = al->value;\n\t  nlen = strlen (ntxt);\n\t  if (nlen == 0)\n\t    break;\n\t  olen = strlen (ocmd);\n\t  lendiff = nlen - olen;\t \n\t  llen = strlen (pcomp_line);\n\n\t  nline = (char *)xmalloc (llen + lendiff + 1);\n\t  if (start > 0)\n\t    strncpy (nline, pcomp_line, start);\n\t  strncpy (nline + start, ntxt, nlen);\n\t  strcpy (nline + start + nlen, pcomp_line + start + olen);\n\n\t   \n\t  ind = skip_to_delim (ntxt, 0, \"()<>;&| \\t\\n\", SD_NOJMP|SD_COMPLETE);\n\t  if (ind > 0)\n\t    ncmd = substring (ntxt, 0, ind);\n\t  else\n\t    {\n\t      free (nline);\n\t      break;\t\t \n\t    }\n\n\t   \n\t  pcomp_ind += lendiff;\n\t  oend += lendiff;\n\n\t   \n\t  if (ocmd != cmd)\n\t    free (ocmd);\n\t  if (pcomp_line != rl_line_buffer)\n\t    free (pcomp_line);\n\n\t  ocmd = ncmd;\n\t  pcomp_line = nline;\n\n\t   \n\t  retry = 1;\n\t}\n#endif  \n\n      count++;\n\n      if (count > 32)\n\t{\n\t  internal_warning (_(\"programmable_completion: %s: possible retry loop\"), cmd);\n\t  break;\n\t}\n    }\n  while (retry);\n\n  if (pcomp_line != rl_line_buffer)\n    free (pcomp_line);\n  if (ocmd != cmd)\n    free (ocmd);\n\n  if (ret)\n    {\n      rmatches = ret->list;\n      free (ret);\n    }\n  else\n    rmatches = (char **)NULL;\n\n  if (foundp)\n    *foundp = found;\n\n  if (lastcs)\t \n    compspec_dispose (lastcs);\n\n   \n  pcomp_line = rl_line_buffer;\n  pcomp_ind = rl_point;\n\n  return (rmatches);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}