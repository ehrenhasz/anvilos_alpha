{
  "module_name": "ulimit.def",
  "hash_id": "ab91878bb862fbd314b478926e326f59315084b2beff1d841b9b6eed3f9f085e",
  "original_prompt": "Ingested from bash-5.2.21/builtins/ulimit.def",
  "human_readable_source": "This file is ulimit.def, from which is created ulimit.c.\nIt implements the builtin \"ulimit\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES ulimit.c\n\n$BUILTIN ulimit\n$FUNCTION ulimit_builtin\n$DEPENDS_ON !_MINIX\n$SHORT_DOC ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]\nModify shell resource limits.\n\nProvides control over the resources available to the shell and processes\nit creates, on systems that allow such control.\n\nOptions:\n  -S\tuse the `soft' resource limit\n  -H\tuse the `hard' resource limit\n  -a\tall current limits are reported\n  -b\tthe socket buffer size\n  -c\tthe maximum size of core files created\n  -d\tthe maximum size of a process's data segment\n  -e\tthe maximum scheduling priority (`nice')\n  -f\tthe maximum size of files written by the shell and its children\n  -i\tthe maximum number of pending signals\n  -k\tthe maximum number of kqueues allocated for this process\n  -l\tthe maximum size a process may lock into memory\n  -m\tthe maximum resident set size\n  -n\tthe maximum number of open file descriptors\n  -p\tthe pipe buffer size\n  -q\tthe maximum number of bytes in POSIX message queues\n  -r\tthe maximum real-time scheduling priority\n  -s\tthe maximum stack size\n  -t\tthe maximum amount of cpu time in seconds\n  -u\tthe maximum number of user processes\n  -v\tthe size of virtual memory\n  -x\tthe maximum number of file locks\n  -P\tthe maximum number of pseudoterminals\n  -R\tthe maximum time a real-time process can run before blocking\n  -T\tthe maximum number of threads\n\nNot all options are available on all platforms.\n\nIf LIMIT is given, it is the new value of the specified resource; the\nspecial LIMIT values `soft', `hard', and `unlimited' stand for the\ncurrent soft limit, the current hard limit, and no limit, respectively.\nOtherwise, the current value of the specified resource is printed.  If\nno option is given, then -f is assumed.\n\nValues are in 1024-byte increments, except for -t, which is in seconds,\n-p, which is in increments of 512 bytes, and -u, which is an unscaled\nnumber of processes.\n\nExit Status:\nReturns success unless an invalid option is supplied or an error occurs.\n$END\n\n#if !defined (_MINIX)\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <errno.h>\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n#include \"pipesize.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n/* For some reason, HPUX chose to make these definitions visible only if\n   _KERNEL is defined, so we define _KERNEL before including <sys/resource.h>\n   and #undef it afterward. */\n#if defined (HAVE_RESOURCE)\n#  include <sys/time.h>\n#  if defined (HPUX) && defined (RLIMIT_NEEDS_KERNEL)\n#    define _KERNEL\n#  endif\n#  include <sys/resource.h>\n#  if defined (HPUX) && defined (RLIMIT_NEEDS_KERNEL)\n#    undef _KERNEL\n#  endif\n#elif defined (HAVE_SYS_TIMES_H)\n#  include <sys/times.h>\n#endif\n\n#if defined (HAVE_LIMITS_H)\n#  include <limits.h>\n#endif\n\n/* Check for the most basic symbols.  If they aren't present, this\n   system's <sys/resource.h> isn't very useful to us. */\n#if !defined (RLIMIT_FSIZE) || !defined (HAVE_GETRLIMIT)\n#  undef HAVE_RESOURCE\n#endif\n\n#if !defined (HAVE_RESOURCE) && defined (HAVE_ULIMIT_H)\n#  include <ulimit.h>\n#endif\n\n#if !defined (RLIMTYPE)\n#  define RLIMTYPE long\n#  define string_to_rlimtype(s) strtol(s, (char **)NULL, 10)\n#  define print_rlimtype(num, nl) printf (\"%ld%s\", num, nl ? \"\\n\" : \"\")\n#endif\n\n/* Alternate names */\n\n/* Some systems use RLIMIT_NOFILE, others use RLIMIT_OFILE */\n#if defined (HAVE_RESOURCE) && defined (RLIMIT_OFILE) && !defined (RLIMIT_NOFILE)\n#  define RLIMIT_NOFILE RLIMIT_OFILE\n#endif /* HAVE_RESOURCE && RLIMIT_OFILE && !RLIMIT_NOFILE */\n\n#if defined (HAVE_RESOURCE) && defined (RLIMIT_POSIXLOCKS) && !defined (RLIMIT_LOCKS)\n#  define RLIMIT_LOCKS RLIMIT_POSIXLOCKS\n#endif /* HAVE_RESOURCE && RLIMIT_POSIXLOCKS && !RLIMIT_LOCKS */\n\n/* Some systems have these, some do not. */\n#ifdef RLIMIT_FSIZE\n#  define RLIMIT_FILESIZE\tRLIMIT_FSIZE\n#else\n#  define RLIMIT_FILESIZE\t256\n#endif\n\n#define RLIMIT_PIPESIZE\t257\n\n#ifdef RLIMIT_NOFILE\n#  define RLIMIT_OPENFILES\tRLIMIT_NOFILE\n#else\n#  define RLIMIT_OPENFILES\t258\n#endif\n\n#ifdef RLIMIT_VMEM\n#  define RLIMIT_VIRTMEM\tRLIMIT_VMEM\n#  define RLIMIT_VMBLKSZ\t1024\n#else\n#  ifdef RLIMIT_AS\n#    define RLIMIT_VIRTMEM\tRLIMIT_AS\n#    define RLIMIT_VMBLKSZ\t1024\n#  else\n#    define RLIMIT_VIRTMEM\t259\n#    define RLIMIT_VMBLKSZ\t1\n#  endif\n#endif\n\n#ifdef RLIMIT_NPROC\n#  define RLIMIT_MAXUPROC\tRLIMIT_NPROC\n#else\n#  define RLIMIT_MAXUPROC\t260\n#endif\n\n#if !defined (RLIMIT_PTHREAD) && defined (RLIMIT_NTHR)\n#  define RLIMIT_PTHREAD RLIMIT_NTHR\n#endif\n\n#if !defined (RLIM_INFINITY)\n#  define RLIM_INFINITY 0x7fffffff\n#endif\n\n#if !defined (RLIM_SAVED_CUR)\n#  define RLIM_SAVED_CUR RLIM_INFINITY\n#endif\n\n#if !defined (RLIM_SAVED_MAX)\n#  define RLIM_SAVED_MAX RLIM_INFINITY\n#endif\n\n#define LIMIT_HARD 0x01\n#define LIMIT_SOFT 0x02\n\n/* \"Blocks\" are defined as 512 bytes when in Posix mode and 1024 bytes\n   otherwise. */\n#define POSIXBLK\t-2\n\n#define BLOCKSIZE(x)\t(((x) == POSIXBLK) ? (posixly_correct ? 512 : 1024) : (x))\n\nstatic int _findlim PARAMS((int));\n\nstatic int ulimit_internal PARAMS((int, char *, int, int));\n\nstatic int get_limit PARAMS((int, RLIMTYPE *, RLIMTYPE *));\nstatic int set_limit PARAMS((int, RLIMTYPE, int));\n\nstatic void printone PARAMS((int, RLIMTYPE, int));\nstatic void print_all_limits PARAMS((int));\n\nstatic int set_all_limits PARAMS((int, RLIMTYPE));\n\nstatic int filesize PARAMS((RLIMTYPE *));\nstatic int pipesize PARAMS((RLIMTYPE *));\nstatic int getmaxuprc PARAMS((RLIMTYPE *));\nstatic int getmaxvm PARAMS((RLIMTYPE *, RLIMTYPE *));\n\ntypedef struct {\n  int  option;\t\t\t/* The ulimit option for this limit. */\n  int  parameter;\t\t/* Parameter to pass to get_limit (). */\n  int  block_factor;\t\t/* Blocking factor for specific limit. */\n  const char * const description;\t/* Descriptive string to output. */\n  const char * const units;\t/* scale */\n} RESOURCE_LIMITS;\n\nstatic RESOURCE_LIMITS limits[] = {\n#ifdef RLIMIT_NPTS\n  { 'P',\tRLIMIT_NPTS,  1,\t\"number of pseudoterminals\",\t(char *)NULL },\n#endif\n#ifdef RLIMIT_RTTIME\n  { 'R',\tRLIMIT_RTTIME,  1,\t\"real-time non-blocking time\",\t\"microseconds\" },\n#endif\n#ifdef RLIMIT_PTHREAD\n  { 'T',\tRLIMIT_PTHREAD, 1,\t\"number of threads\",\t(char *)NULL },\n#endif\n#ifdef RLIMIT_SBSIZE\n  { 'b',\tRLIMIT_SBSIZE,  1,\t\"socket buffer size\",\t\"bytes\" },\n#endif\n#ifdef RLIMIT_CORE\n  { 'c',\tRLIMIT_CORE,  POSIXBLK,\t\"core file size\",\t\"blocks\" },\n#endif\n#ifdef RLIMIT_DATA\n  { 'd',\tRLIMIT_DATA,  1024,\t\"data seg size\",\t\"kbytes\" },\n#endif\n#ifdef RLIMIT_NICE\n  { 'e',\tRLIMIT_NICE,  1,\t\"scheduling priority\",\t(char *)NULL },\n#endif\n  { 'f',\tRLIMIT_FILESIZE, POSIXBLK,\t\"file size\",\t\t\"blocks\" },\n#ifdef RLIMIT_SIGPENDING\n  { 'i',\tRLIMIT_SIGPENDING, 1,\t\"pending signals\",\t(char *)NULL },\n#endif\n#ifdef RLIMIT_KQUEUES\n  { 'k',\tRLIMIT_KQUEUES, 1,\t\"max kqueues\",\t\t(char *)NULL },\n#endif\n#ifdef RLIMIT_MEMLOCK\n  { 'l',\tRLIMIT_MEMLOCK, 1024,\t\"max locked memory\",\t\"kbytes\" },\n#endif\n#ifdef RLIMIT_RSS\n  { 'm',\tRLIMIT_RSS,   1024,\t\"max memory size\",\t\"kbytes\" },\n#endif /* RLIMIT_RSS */\n  { 'n',\tRLIMIT_OPENFILES, 1,\t\"open files\",\t\t(char *)NULL},\n  { 'p',\tRLIMIT_PIPESIZE, 512,\t\"pipe size\", \t\t\"512 bytes\" },\n#ifdef RLIMIT_MSGQUEUE\n  { 'q',\tRLIMIT_MSGQUEUE, 1,\t\"POSIX message queues\",\t\"bytes\" },\n#endif\n#ifdef RLIMIT_RTPRIO\n  { 'r',\tRLIMIT_RTPRIO,  1,\t\"real-time priority\",\t(char *)NULL },\n#endif\n#ifdef RLIMIT_STACK\n  { 's',\tRLIMIT_STACK, 1024,\t\"stack size\",\t\t\"kbytes\" },\n#endif\n#ifdef RLIMIT_CPU\n  { 't',\tRLIMIT_CPU,      1,\t\"cpu time\",\t\t\"seconds\" },\n#endif /* RLIMIT_CPU */\n  { 'u',\tRLIMIT_MAXUPROC, 1,\t\"max user processes\",\t(char *)NULL },\n#if defined (HAVE_RESOURCE)\n  { 'v',\tRLIMIT_VIRTMEM, RLIMIT_VMBLKSZ, \"virtual memory\", \"kbytes\" },\n#endif\n#ifdef RLIMIT_SWAP\n  { 'w',\tRLIMIT_SWAP,\t1024,\t\"swap size\",\t\t\"kbytes\" },\n#endif\n#ifdef RLIMIT_LOCKS\n  { 'x',\tRLIMIT_LOCKS,\t1,\t\"file locks\",\t\t(char *)NULL },\n#endif\n  { -1, -1, -1, (char *)NULL, (char *)NULL }\n};\n#define NCMDS\t(sizeof(limits) / sizeof(limits[0]))\n\ntypedef struct _cmd {\n  int cmd;\n  char *arg;\n} ULCMD;\n\nstatic ULCMD *cmdlist;\nstatic int ncmd;\nstatic int cmdlistsz;\n\n#if !defined (HAVE_RESOURCE) && !defined (HAVE_ULIMIT)\nlong\nulimit (cmd, newlim)\n     int cmd;\n     long newlim;\n{\n  errno = EINVAL;\n  return -1;\n}\n#endif /* !HAVE_RESOURCE && !HAVE_ULIMIT */\n\nstatic int\n_findlim (opt)\n     int opt;\n{\n  register int i;\n\n  for (i = 0; limits[i].option > 0; i++)\n    if (limits[i].option == opt)\n      return i;\n  return -1;\n}\n\nstatic char optstring[4 + 2 * NCMDS];\n\n/* Report or set limits associated with certain per-process resources.\n   See the help documentation in builtins.c for a full description. */\nint\nulimit_builtin (list)\n     register WORD_LIST *list;\n{\n  register char *s;\n  int c, limind, mode, opt, all_limits;\n\n  mode = 0;\n\n  all_limits = 0;\n\n  /* Idea stolen from pdksh -- build option string the first time called. */\n  if (optstring[0] == 0)\n    {\n      s = optstring;\n      *s++ = 'a'; *s++ = 'S'; *s++ = 'H';\n      for (c = 0; limits[c].option > 0; c++)\n\t{\n\t  *s++ = limits[c].option;\n\t  *s++ = ';';\n\t}\n      *s = '\\0';\n    }\n\n  /* Initialize the command list. */\n  if (cmdlistsz == 0)\n    cmdlist = (ULCMD *)xmalloc ((cmdlistsz = 16) * sizeof (ULCMD));\n  ncmd = 0;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, optstring)) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'a':\n\t  all_limits++;\n\t  break;\n\n\t/* -S and -H are modifiers, not real options.  */\n\tcase 'S':\n\t  mode |= LIMIT_SOFT;\n\t  break;\n\n\tcase 'H':\n\t  mode |= LIMIT_HARD;\n\t  break;\n\n\tCASE_HELPOPT;\n\tcase '?':\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\n\tdefault:\n\t  if (ncmd >= cmdlistsz)\n\t    cmdlist = (ULCMD *)xrealloc (cmdlist, (cmdlistsz *= 2) * sizeof (ULCMD));\n\t  cmdlist[ncmd].cmd = opt;\n\t  cmdlist[ncmd++].arg = list_optarg;\n\t  break;\n\t}\n    }\n  list = loptend;\n\n  if (all_limits)\n    {\n#ifdef NOTYET\n      if (list)\t\t/* setting */\n        {\n          if (STREQ (list->word->word, \"unlimited\") == 0)\n            {\n              builtin_error (_(\"%s: invalid limit argument\"), list->word->word);\n              return (EXECUTION_FAILURE);\n            }\n          return (set_all_limits (mode == 0 ? LIMIT_SOFT|LIMIT_HARD : mode, RLIM_INFINITY));\n        }\n#endif\n      print_all_limits (mode == 0 ? LIMIT_SOFT : mode);\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  /* default is `ulimit -f' */\n  if (ncmd == 0)\n    {\n      cmdlist[ncmd].cmd = 'f';\n      /* `ulimit something' is same as `ulimit -f something' */\n      cmdlist[ncmd++].arg = list ? list->word->word : (char *)NULL;\n      if (list)\n\tlist = list->next;\n    }\n\n  /* verify each command in the list. */\n  for (c = 0; c < ncmd; c++)\n    {\n      limind = _findlim (cmdlist[c].cmd);\n      if (limind == -1)\n\t{\n\t  builtin_error (_(\"`%c': bad command\"), cmdlist[c].cmd);\n\t  return (EX_USAGE);\n\t}\n    }\n\n  /* POSIX compatibility. If the last item in cmdlist does not have an option\n     argument, but there is an operand (list != 0), treat the operand as if\n     it were an option argument for that last command. */\n  if (list && list->word && cmdlist[ncmd - 1].arg == 0)\n    {\n      cmdlist[ncmd - 1].arg = list->word->word;\n      list = list->next;\n    }\n\n  for (c = 0; c < ncmd; c++)\n    if (ulimit_internal (cmdlist[c].cmd, cmdlist[c].arg, mode, ncmd > 1) == EXECUTION_FAILURE)\n      return (EXECUTION_FAILURE);\n\n  return (EXECUTION_SUCCESS);\n}\n\nstatic int\nulimit_internal (cmd, cmdarg, mode, multiple)\n     int cmd;\n     char *cmdarg;\n     int mode, multiple;\n{\n  int opt, limind, setting;\n  int block_factor;\n  RLIMTYPE soft_limit, hard_limit, real_limit, limit;\n\n  setting = cmdarg != 0;\n  limind = _findlim (cmd);\n  if (mode == 0)\n    mode = setting ? (LIMIT_HARD|LIMIT_SOFT) : LIMIT_SOFT;\n  opt = get_limit (limind, &soft_limit, &hard_limit);\n  if (opt < 0)\n    {\n      builtin_error (_(\"%s: cannot get limit: %s\"), limits[limind].description,\n\t\t\t\t\t\t strerror (errno));\n      return (EXECUTION_FAILURE);\n    }\n\n  if (setting == 0)\t/* print the value of the specified limit */\n    {\n      printone (limind, (mode & LIMIT_SOFT) ? soft_limit : hard_limit, multiple);\n      return (EXECUTION_SUCCESS);\n    }\n \n  /* Setting the limit. */\n  if (STREQ (cmdarg, \"hard\"))\n    real_limit = hard_limit;\n  else if (STREQ (cmdarg, \"soft\"))\n    real_limit = soft_limit;\n  else if (STREQ (cmdarg, \"unlimited\"))\n    real_limit = RLIM_INFINITY;\n  else if (all_digits (cmdarg))\n    {\n      limit = string_to_rlimtype (cmdarg);\n      block_factor = BLOCKSIZE(limits[limind].block_factor);\n      real_limit = limit * block_factor;\n\n      if ((real_limit / block_factor) != limit)\n\t{\n\t  sh_erange (cmdarg, _(\"limit\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n    }\n  else\n    {\n      sh_invalidnum (cmdarg);\n      return (EXECUTION_FAILURE);\n    }\n\n  if (set_limit (limind, real_limit, mode) < 0)\n    {\n      builtin_error (_(\"%s: cannot modify limit: %s\"), limits[limind].description,\n\t\t\t\t\t\t    strerror (errno));\n      return (EXECUTION_FAILURE);\n    }\n\n  return (EXECUTION_SUCCESS);\n}\n\nstatic int\nget_limit (ind, softlim, hardlim)\n     int ind;\n     RLIMTYPE *softlim, *hardlim;\n{\n  RLIMTYPE value;\n#if defined (HAVE_RESOURCE)\n  struct rlimit limit;\n#endif\n\n  if (limits[ind].parameter >= 256)\n    {\n      switch (limits[ind].parameter)\n\t{\n\tcase RLIMIT_FILESIZE:\n\t  if (filesize (&value) < 0)\n\t    return -1;\n\t  break;\n\tcase RLIMIT_PIPESIZE:\n\t  if (pipesize (&value) < 0)\n\t    return -1;\n\t  break;\n\tcase RLIMIT_OPENFILES:\n\t  value = (RLIMTYPE)getdtablesize ();\n\t  break;\n\tcase RLIMIT_VIRTMEM:\n\t  return (getmaxvm (softlim, hardlim));\n\tcase RLIMIT_MAXUPROC:\n\t  if (getmaxuprc (&value) < 0)\n\t    return -1;\n\t  break;\n\tdefault:\n\t  errno = EINVAL;\n\t  return -1;\n\t}\n      *softlim = *hardlim = value;\n      return (0);\n    }\n  else\n    {\n#if defined (HAVE_RESOURCE)\n      if (getrlimit (limits[ind].parameter, &limit) < 0)\n\treturn -1;\n      *softlim = limit.rlim_cur;\n      *hardlim = limit.rlim_max;\n#  if defined (HPUX9)\n      if (limits[ind].parameter == RLIMIT_FILESIZE)\n\t{\n\t  *softlim *= 512;\n\t  *hardlim *= 512;\t\t\t/* Ugh. */\n\t}\n      else\n#  endif /* HPUX9 */\n      return 0;\n#else\n      errno = EINVAL;\n      return -1;\n#endif\n    }\n}\n\nstatic int\nset_limit (ind, newlim, mode)\n     int ind;\n     RLIMTYPE newlim;\n     int mode;\n{\n#if defined (HAVE_RESOURCE)\n   struct rlimit limit;\n   RLIMTYPE val;\n#endif\n\n  if (limits[ind].parameter >= 256)\n    switch (limits[ind].parameter)\n      {\n      case RLIMIT_FILESIZE:\n#if !defined (HAVE_RESOURCE)\n\treturn (ulimit (2, newlim / 512L));\n#else\n\terrno = EINVAL;\n\treturn -1;\n#endif\n\n      case RLIMIT_OPENFILES:\n#if defined (HAVE_SETDTABLESIZE)\n#  if defined (__CYGWIN__)\n\t/* Grrr... Cygwin declares setdtablesize as void. */\n\tsetdtablesize (newlim);\n\treturn 0;\n#  else\n\treturn (setdtablesize (newlim));\n#  endif\n#endif\n      case RLIMIT_PIPESIZE:\n      case RLIMIT_VIRTMEM:\n      case RLIMIT_MAXUPROC:\n      default:\n\terrno = EINVAL;\n\treturn -1;\n      }\n  else\n    {\n#if defined (HAVE_RESOURCE)\n      if (getrlimit (limits[ind].parameter, &limit) < 0)\n\treturn -1;\n#  if defined (HPUX9)\n      if (limits[ind].parameter == RLIMIT_FILESIZE)\n\tnewlim /= 512;\t\t\t\t/* Ugh. */\n#  endif /* HPUX9 */\n      val = (current_user.euid != 0 && newlim == RLIM_INFINITY &&\n\t       (mode & LIMIT_HARD) == 0 &&\t\t/* XXX -- test */\n\t       (limit.rlim_cur <= limit.rlim_max))\n\t\t ? limit.rlim_max : newlim;\n      if (mode & LIMIT_SOFT)\n\tlimit.rlim_cur = val;\n      if (mode & LIMIT_HARD)\n\tlimit.rlim_max = val;\n\t  \n      return (setrlimit (limits[ind].parameter, &limit));\n#else\n      errno = EINVAL;\n      return -1;\n#endif\n    }\n}\n\nstatic int\ngetmaxvm (softlim, hardlim)\n     RLIMTYPE *softlim, *hardlim;\n{\n#if defined (HAVE_RESOURCE)\n  struct rlimit datalim, stacklim;\n\n  if (getrlimit (RLIMIT_DATA, &datalim) < 0)\n    return -1;\n\n  if (getrlimit (RLIMIT_STACK, &stacklim) < 0)\n    return -1;\n\n  /* Protect against overflow. */\n  *softlim = (datalim.rlim_cur / 1024L) + (stacklim.rlim_cur / 1024L);\n  *hardlim = (datalim.rlim_max / 1024L) + (stacklim.rlim_max / 1024L);\n  return 0;\n#else\n  errno = EINVAL;\n  return -1;\n#endif /* HAVE_RESOURCE */\n}\n\nstatic int\nfilesize(valuep)\n     RLIMTYPE *valuep;\n{\n#if !defined (HAVE_RESOURCE)\n  long result;\n  if ((result = ulimit (1, 0L)) < 0)\n    return -1;\n  else\n    *valuep = (RLIMTYPE) result * 512;\n  return 0;\n#else\n  errno = EINVAL;\n  return -1;\n#endif\n}\n\nstatic int\npipesize (valuep)\n     RLIMTYPE *valuep;\n{\n#if defined (PIPE_BUF)\n  /* This is defined on Posix systems. */\n  *valuep = (RLIMTYPE) PIPE_BUF;\n  return 0;\n#else\n#  if defined (_POSIX_PIPE_BUF)\n  *valuep = (RLIMTYPE) _POSIX_PIPE_BUF;\n  return 0;\n#  else\n#    if defined (PIPESIZE)\n  /* This is defined by running a program from the Makefile. */\n  *valuep = (RLIMTYPE) PIPESIZE;\n  return 0;\n#    else\n  errno = EINVAL;\n  return -1;  \n#    endif /* PIPESIZE */\n#  endif /* _POSIX_PIPE_BUF */\n#endif /* PIPE_BUF */\n}\n\nstatic int\ngetmaxuprc (valuep)\n     RLIMTYPE *valuep;\n{\n  long maxchild;\n\n  maxchild = getmaxchild ();\n  if (maxchild < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  else\n    {\n      *valuep = (RLIMTYPE) maxchild;\n      return 0;\n    }\n}\n\nstatic void\nprint_all_limits (mode)\n     int mode;\n{\n  register int i;\n  RLIMTYPE softlim, hardlim;\n\n  if (mode == 0)\n    mode |= LIMIT_SOFT;\n\n  for (i = 0; limits[i].option > 0; i++)\n    {\n      if (get_limit (i, &softlim, &hardlim) == 0)\n\tprintone (i, (mode & LIMIT_SOFT) ? softlim : hardlim, 1);\n      else if (errno != EINVAL)\n\tbuiltin_error (\"%s: cannot get limit: %s\", limits[i].description,\n\t\t\t\t\t\t   strerror (errno));\n    }\n}\n\nstatic void\nprintone (limind, curlim, pdesc)\n     int limind;\n     RLIMTYPE curlim;\n     int pdesc;\n{\n  char unitstr[64];\n  int factor;\n\n  factor = BLOCKSIZE(limits[limind].block_factor);\n  if (pdesc)\n    {\n      if (limits[limind].units)\n\tsprintf (unitstr, \"(%s, -%c) \", limits[limind].units, limits[limind].option);\n      else\n        sprintf (unitstr, \"(-%c) \", limits[limind].option);\n\n      printf (\"%-20s %20s\", limits[limind].description, unitstr);\n    }\n  if (curlim == RLIM_INFINITY)\n    puts (\"unlimited\");\n  else if (curlim == RLIM_SAVED_MAX)\n    puts (\"hard\");\n  else if (curlim == RLIM_SAVED_CUR)\n    puts (\"soft\");\n  else\n    print_rlimtype ((curlim / factor), 1);\n}\n\n/* Set all limits to NEWLIM.  NEWLIM currently must be RLIM_INFINITY, which\n   causes all limits to be set as high as possible depending on mode (like\n   csh `unlimit').  Returns -1 if NEWLIM is invalid, 0 if all limits\n   were set successfully, and 1 if at least one limit could not be set.\n\n   To raise all soft limits to their corresponding hard limits, use\n\tulimit -S -a unlimited\n   To attempt to raise all hard limits to infinity (superuser-only), use\n\tulimit -H -a unlimited\n   To attempt to raise all soft and hard limits to infinity, use\n\tulimit -a unlimited\n*/\n\nstatic int\nset_all_limits (mode, newlim)\n     int mode;\n     RLIMTYPE newlim;\n{\n  register int i;\n  int retval = 0;\n\n  if (newlim != RLIM_INFINITY)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  \n  if (mode == 0)\n    mode = LIMIT_SOFT|LIMIT_HARD;\n\n  for (retval = i = 0; limits[i].option > 0; i++)\n    if (set_limit (i, newlim, mode) < 0)\n      {\n\tbuiltin_error (_(\"%s: cannot modify limit: %s\"), limits[i].description,\n\t\t\t\t\t\t      strerror (errno));\n\tretval = 1;\n      }\n  return retval;\n}\n\n#endif /* !_MINIX */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}