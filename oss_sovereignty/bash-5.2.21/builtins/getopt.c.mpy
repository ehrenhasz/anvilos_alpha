{
  "module_name": "getopt.c",
  "hash_id": "9247c2607e02f7c16310687b744b1a140126bf57e2e29a9ee5de723e3e0c8bd9",
  "original_prompt": "Ingested from bash-5.2.21/builtins/getopt.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"memalloc.h\"\n#include \"../bashintl.h\"\n#include \"../shell.h\"\n#include \"getopt.h\"\n\n \nchar *sh_optarg = 0;\n\n \n\n \nint sh_optind = 0;\n\n \nstatic int sh_curopt;\n\n \n\nstatic char *nextchar;\nstatic int sh_charindex;\n\n \n\nint sh_opterr = 1;\n\n \n\nint sh_optopt = '?';\n\n \nint sh_badopt = 0;\n\n \n\n \n#define BADOPT(x)  fprintf (stderr, _(\"%s: illegal option -- %c\\n\"), argv[0], x)\n#define NEEDARG(x) fprintf (stderr, _(\"%s: option requires an argument -- %c\\n\"), argv[0], x)\n\nint\nsh_getopt (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  char c, *temp;\n\n  sh_optarg = 0;\n\n  if (sh_optind >= argc || sh_optind < 0)\t \n    {\n      sh_optind = argc;\n      return (EOF);\n    }\n\n   \n\n  if (sh_optind == 0)\n    {\n      sh_optind = 1;\n      nextchar = (char *)NULL;\n    }\n\n  if (nextchar == 0 || *nextchar == '\\0')\n    {\n       \n      if (sh_optind >= argc)\n\treturn EOF;\n\n      temp = argv[sh_optind];\n\n       \n      if (temp[0] == '-' && temp[1] == '-' && temp[2] == '\\0')\n\t{\n\t  sh_optind++;\n\t  return EOF;\n\t}\n\n       \n      if (temp[0] != '-' || temp[1] == '\\0')\n\treturn EOF;\n\n       \n      nextchar = argv[sh_curopt = sh_optind] + 1;\n      sh_charindex = 1;\n    }\n\n   \n\n  c = *nextchar++; sh_charindex++;\n  temp = strchr (optstring, c);\n\n  sh_optopt = c;\n\n   \n  if (nextchar == 0 || *nextchar == '\\0')\n    {\n      sh_optind++;\n      nextchar = (char *)NULL;\n    }\n\n  if (sh_badopt = (temp == NULL || c == ':'))\n    {\n      if (sh_opterr)\n\tBADOPT (c);\n\n      return '?';\n    }\n\n  if (temp[1] == ':')\n    {\n      if (nextchar && *nextchar)\n\t{\n\t   \n\t  sh_optarg = nextchar;\n\t   \n\t  sh_optind++;\n\t}\n      else if (sh_optind == argc)\n\t{\n\t  if (sh_opterr)\n\t    NEEDARG (c);\n\n\t  sh_optopt = c;\n\t  sh_optarg = \"\";\t \n\t  c = (optstring[0] == ':') ? ':' : '?';\n\t}\n      else\n\t \n\tsh_optarg = argv[sh_optind++];\n      nextchar = (char *)NULL;\n    }\n  return c;\n}\n\nvoid\nsh_getopt_restore_state (argv)\n     char **argv;\n{\n  if (nextchar)\n    nextchar = argv[sh_curopt] + sh_charindex;\n}\n\nsh_getopt_state_t *\nsh_getopt_alloc_istate ()\n{\n  sh_getopt_state_t *ret;\n\n  ret = (sh_getopt_state_t *)xmalloc (sizeof (sh_getopt_state_t));\n  return ret;\n}\n\nvoid\nsh_getopt_dispose_istate (gs)\n     sh_getopt_state_t *gs;\n{\n  free (gs);\n}\n\nsh_getopt_state_t *\nsh_getopt_save_istate ()\n{\n  sh_getopt_state_t *ret;\n\n  ret = sh_getopt_alloc_istate ();\n\n  ret->gs_optarg = sh_optarg;\n  ret->gs_optind = sh_optind;\n  ret->gs_curopt = sh_curopt;\n  ret->gs_nextchar = nextchar;\t\t \n  ret->gs_charindex = sh_charindex;\n  ret->gs_flags = 0;\t\t\t \n\n  return ret;\n}\n\nvoid\nsh_getopt_restore_istate (state)\n     sh_getopt_state_t *state;\n{\n  sh_optarg = state->gs_optarg;\n  sh_optind = state->gs_optind;\n  sh_curopt = state->gs_curopt;\n  nextchar = state->gs_nextchar;\t \n  sh_charindex = state->gs_charindex;\n\n  sh_getopt_dispose_istate (state);\n}\n\n#if 0\nvoid\nsh_getopt_debug_restore_state (argv)\n     char **argv;\n{\n  if (nextchar && nextchar != argv[sh_curopt] + sh_charindex)\n    {\n      itrace(\"sh_getopt_debug_restore_state: resetting nextchar\");\n      nextchar = argv[sh_curopt] + sh_charindex;\n    }\n}\n#endif\n \n#ifdef TEST\n\n \n\nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int c;\n  int digit_sh_optind = 0;\n\n  while (1)\n    {\n      int this_option_sh_optind = sh_optind ? sh_optind : 1;\n\n      c = sh_getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == EOF)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_sh_optind != 0 && digit_sh_optind != this_option_sh_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_sh_optind = this_option_sh_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value `%s'\\n\", sh_optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? sh_getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (sh_optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (sh_optind < argc)\n\tprintf (\"%s \", argv[sh_optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}