{
  "module_name": "hash.def",
  "hash_id": "d48c807398a8ff8789e4bfdaf5131ed834f1759fe8edab4a56ad11baa6f46f8d",
  "original_prompt": "Ingested from bash-5.2.21/builtins/hash.def",
  "human_readable_source": "This file is hash.def, from which is created hash.c.\nIt implements the builtin \"hash\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES hash.c\n\n$BUILTIN hash\n$FUNCTION hash_builtin\n$SHORT_DOC hash [-lr] [-p pathname] [-dt] [name ...]\nRemember or display program locations.\n\nDetermine and remember the full pathname of each command NAME.  If\nno arguments are given, information about remembered commands is displayed.\n\nOptions:\n  -d\tforget the remembered location of each NAME\n  -l\tdisplay in a format that may be reused as input\n  -p pathname\tuse PATHNAME as the full pathname of NAME\n  -r\tforget all remembered locations\n  -t\tprint the remembered location of each NAME, preceding\n\t\teach location with the corresponding NAME if multiple\n\t\tNAMEs are given\nArguments:\n  NAME\tEach NAME is searched for in $PATH and added to the list\n\t\tof remembered commands.\n\nExit Status:\nReturns success unless NAME is not found or an invalid option is given.\n$END\n\n#include <config.h>\n\n#include <stdio.h>\n\n#include \"../bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <errno.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../builtins.h\"\n#include \"../execute_cmd.h\"\n#include \"../flags.h\"\n#include \"../findcmd.h\"\n#include \"../hashcmd.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\nextern int dot_found_in_search;\n\nstatic int add_hashed_command PARAMS((char *, int));\nstatic int print_hash_info PARAMS((BUCKET_CONTENTS *));\nstatic int print_portable_hash_info PARAMS((BUCKET_CONTENTS *));\nstatic int print_hashed_commands PARAMS((int));\nstatic int list_hashed_filename_targets PARAMS((WORD_LIST *, int));\n\n/* Print statistics on the current state of hashed commands.  If LIST is\n   not empty, then rehash (or hash in the first place) the specified\n   commands. */\nint\nhash_builtin (list)\n     WORD_LIST *list;\n{\n  int expunge_hash_table, list_targets, list_portably, delete, opt;\n  char *w, *pathname;\n\n  if (hashing_enabled == 0)\n    {\n      builtin_error (_(\"hashing disabled\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  expunge_hash_table = list_targets = list_portably = delete = 0;\n  pathname = (char *)NULL;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"dlp:rt\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'd':\n\t  delete = 1;\n\t  break;\n\tcase 'l':\n\t  list_portably = 1;\n\t  break;\n\tcase 'p':\n\t  pathname = list_optarg;\n\t  break;\n\tcase 'r':\n\t  expunge_hash_table = 1;\n\t  break;\n\tcase 't':\n\t  list_targets = 1;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  /* hash -t requires at least one argument. */\n  if (list == 0 && (delete || list_targets))\n    {\n      sh_needarg (delete ? \"-d\" : \"-t\");\n      return (EXECUTION_FAILURE);\n    }\n\n  /* We want hash -r to be silent, but hash -- to print hashing info, so\n     we test expunge_hash_table. */\n  if (list == 0 && expunge_hash_table == 0)\n    {\n      opt = print_hashed_commands (list_portably);\n      if (opt == 0 && posixly_correct == 0 &&\n\t    (list_portably == 0 || shell_compatibility_level <= 50))\n\tprintf (_(\"%s: hash table empty\\n\"), this_command_name);\n\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  if (expunge_hash_table)\n    phash_flush ();\n\n  /* If someone runs `hash -r -t xyz' he will be disappointed. */\n  if (list_targets)\n    return (list_hashed_filename_targets (list, list_portably));\n      \n#if defined (RESTRICTED_SHELL)\n  if (restricted && pathname)\n    {\n      if (strchr (pathname, '/'))\n\t{\n          sh_restricted (pathname);\n          return (EXECUTION_FAILURE);\n\t}\n      /* If we are changing the hash table in a restricted shell, make sure the\n\t target pathname can be found using a $PATH search. */\n      w = find_user_command (pathname);\n      if (w == 0 || *w == 0 || executable_file (w) == 0)\n\t{\n\t  sh_notfound (pathname);\n\t  free (w);\n\t  return (EXECUTION_FAILURE);\n\t}\n      free (w);\n    }\n#endif\n\n  for (opt = EXECUTION_SUCCESS; list; list = list->next)\n    {\n      /* Add, remove or rehash the specified commands. */\n      w = list->word->word;\n      if (absolute_program (w))\n\tcontinue;\n      else if (pathname)\n\t{\n\t  if (file_isdir (pathname))\n\t    {\n#ifdef EISDIR\n\t      builtin_error (\"%s: %s\", pathname, strerror (EISDIR));\n#else\n\t      builtin_error (_(\"%s: is a directory\"), pathname);\n#endif\n\t      opt = EXECUTION_FAILURE;\n\t    }\n\t  else\n\t    phash_insert (w, pathname, 0, 0);\n\t}\n      else if (delete)\n\t{\n\t  if (phash_remove (w))\n\t    {\n\t      sh_notfound (w);\n\t      opt = EXECUTION_FAILURE;\n\t    }\n\t}\n      else if (add_hashed_command (w, 0))\n\topt = EXECUTION_FAILURE;\n    }\n\n  fflush (stdout);\n  return (opt);\n}\n\nstatic int\nadd_hashed_command (w, quiet)\n     char *w;\n     int quiet;\n{\n  int rv;\n  char *full_path;\n\n  rv = 0;\n  if (find_function (w) == 0 && find_shell_builtin (w) == 0)\n    {\n      phash_remove (w);\n      full_path = find_user_command (w);\n      if (full_path && executable_file (full_path))\n\tphash_insert (w, full_path, dot_found_in_search, 0);\n      else\n\t{\n\t  if (quiet == 0)\n\t    sh_notfound (w);\n\t  rv++;\n\t}\n      FREE (full_path);\n    }\n  return (rv);\n}\n\n/* Print information about current hashed info. */\nstatic int\nprint_hash_info (item)\n     BUCKET_CONTENTS *item;\n{\n  printf (\"%4d\\t%s\\n\", item->times_found, pathdata(item)->path);\n  return 0;\n}\n\nstatic int\nprint_portable_hash_info (item)\n     BUCKET_CONTENTS *item;\n{\n  char *fp, *fn;\n\n  fp = printable_filename (pathdata(item)->path, 1);\n  fn = printable_filename (item->key, 1);\n  printf (\"builtin hash -p %s %s\\n\", fp, fn);\n  if (fp != pathdata(item)->path)\n    free (fp);\n  if (fn != item->key)\n    free (fn);\n  return 0;\n}\n\nstatic int\nprint_hashed_commands (fmt)\n     int fmt;\n{\n  if (hashed_filenames == 0 || HASH_ENTRIES (hashed_filenames) == 0)\n    return (0);\n\n  if (fmt == 0)\n    printf (_(\"hits\\tcommand\\n\"));\n  hash_walk (hashed_filenames, fmt ? print_portable_hash_info : print_hash_info);\n  return (1);\n}\n\nstatic int\nlist_hashed_filename_targets (list, fmt)\n     WORD_LIST *list;\n     int fmt;\n{\n  int all_found, multiple;\n  char *target;\n  WORD_LIST *l;\n\n  all_found = 1;\n  multiple = list->next != 0;\n\n  for (l = list; l; l = l->next)\n    {\n      target = phash_search (l->word->word);\n      if (target == 0)\n\t{\n\t  all_found = 0;\n\t  sh_notfound (l->word->word);\n\t  continue;\n\t}\n      if (fmt)\n\tprintf (\"builtin hash -p %s %s\\n\", target, l->word->word);\n      else\n\t{\n\t  if (multiple)\n\t    printf (\"%s\\t\", l->word->word);\n\t  printf (\"%s\\n\", target);\n\t}\n      free (target);\n    }\n\n  return (all_found ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}