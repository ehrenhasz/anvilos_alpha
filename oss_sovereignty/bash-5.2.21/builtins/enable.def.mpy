{
  "module_name": "enable.def",
  "hash_id": "90abc3b810e18762eab04659df19277be474495cd66cb02f6bdae0781c6fe7c3",
  "original_prompt": "Ingested from bash-5.2.21/builtins/enable.def",
  "human_readable_source": "This file is enable.def, from which is created enable.c.\nIt implements the builtin \"enable\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc. \n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES enable.c\n\n$BUILTIN enable\n$FUNCTION enable_builtin\n$SHORT_DOC enable [-a] [-dnps] [-f filename] [name ...]\nEnable and disable shell builtins.\n\nEnables and disables builtin shell commands.  Disabling allows you to\nexecute a disk command which has the same name as a shell builtin\nwithout using a full pathname.\n\nOptions:\n  -a\tprint a list of builtins showing whether or not each is enabled\n  -n\tdisable each NAME or display a list of disabled builtins\n  -p\tprint the list of builtins in a reusable format\n  -s\tprint only the names of Posix `special' builtins\n\nOptions controlling dynamic loading:\n  -f\tLoad builtin NAME from shared object FILENAME\n  -d\tRemove a builtin loaded with -f\n\nWithout options, each NAME is enabled.\n\nTo use the `test' found in $PATH instead of the shell builtin\nversion, type `enable -n test'.\n\nExit Status:\nReturns success unless NAME is not a shell builtin or an error occurs.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../builtins.h\"\n#include \"../flags.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n#include \"findcmd.h\"\n\n#if defined (PROGRAMMABLE_COMPLETION)\n#  include \"../pcomplete.h\"\n#endif\n\n#define ENABLED  1\n#define DISABLED 2\n#define SPECIAL  4\n#define SILENT\t 8\t/* affects dyn_load_builtin behavior */\n\n#define AFLAG\t0x01\n#define DFLAG\t0x02\n#define FFLAG\t0x04\n#define NFLAG\t0x08\n#define PFLAG\t0x10\n#define SFLAG\t0x20\n\n#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)\nstatic int dyn_load_builtin PARAMS((WORD_LIST *, int, char *));\n#endif\n\n#if defined (HAVE_DLCLOSE)\nstatic int dyn_unload_builtin PARAMS((char *));\nstatic void delete_builtin PARAMS((struct builtin *));\nstatic int local_dlclose PARAMS((void *));\n#endif\n\n#define STRUCT_SUFFIX\t\"_struct\"\n/* for now */\n#define LOAD_SUFFIX\t\"_builtin_load\"\n#define UNLOAD_SUFFIX\t\"_builtin_unload\"\n\nstatic void list_some_builtins PARAMS((int));\nstatic int enable_shell_command PARAMS((char *, int));\n\n/* Enable/disable shell commands present in LIST.  If list is not specified,\n   then print out a list of shell commands showing which are enabled and\n   which are disabled. */\nint\nenable_builtin (list)\n     WORD_LIST *list;\n{\n  int result, flags;\n  int opt, filter;\n  WORD_LIST *next;\n#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)\n  char *filename;\n#endif\n\n  result = EXECUTION_SUCCESS;\n  flags = 0;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"adnpsf:\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'a':\n\t  flags |= AFLAG;\n\t  break;\n\tcase 'n':\n\t  flags |= NFLAG;\n\t  break;\n\tcase 'p':\n\t  flags |= PFLAG;\n\t  break;\n\tcase 's':\n\t  flags |= SFLAG;\n\t  break;\n\tcase 'f':\n#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)\n\t  flags |= FFLAG;\n\t  filename = list_optarg;\n\t  break;\n#else\n\t  builtin_error (_(\"dynamic loading not available\"));\n\t  return (EX_USAGE);\n#endif\n#if defined (HAVE_DLCLOSE)\n\tcase 'd':\n\t  flags |= DFLAG;\n\t  break;\n#else\n\t  builtin_error (_(\"dynamic loading not available\"));\n\t  return (EX_USAGE);\n#endif /* HAVE_DLCLOSE */\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n#if defined (RESTRICTED_SHELL)\n  /* Restricted shells cannot load new builtins. */\n  if (restricted && (flags & (FFLAG|DFLAG)))\n    {\n      sh_restricted ((char *)NULL);\n      return (EXECUTION_FAILURE);\n    }\n#endif\n\n  if (list == 0 || (flags & PFLAG))\n    {\n      filter = (flags & AFLAG) ? (ENABLED | DISABLED)\n\t\t\t       : (flags & NFLAG) ? DISABLED : ENABLED;\n\n      if (flags & SFLAG)\n\tfilter |= SPECIAL;\n\n      list_some_builtins (filter);\n      result = sh_chkwrite (EXECUTION_SUCCESS);\n    }\n#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)\n  else if (flags & FFLAG)\n    {\n      filter = (flags & NFLAG) ? DISABLED : ENABLED;\n      if (flags & SFLAG)\n\tfilter |= SPECIAL;\n\n      result = dyn_load_builtin (list, filter, filename);\n      if (result != EXECUTION_SUCCESS)\n\tresult = EXECUTION_FAILURE;\t/* normalize return value */\n#if defined (PROGRAMMABLE_COMPLETION)\n      set_itemlist_dirty (&it_builtins);\n#endif\n    }\n#endif\n#if defined (HAVE_DLCLOSE)\n  else if (flags & DFLAG)\n    {\n      while (list)\n\t{\n\t  opt = dyn_unload_builtin (list->word->word);\n\t  if (opt == EXECUTION_FAILURE)\n\t    result = EXECUTION_FAILURE;\n\t  list = list->next;\n\t}\n#if defined (PROGRAMMABLE_COMPLETION)\n      set_itemlist_dirty (&it_builtins);\n#endif\n    }\n#endif\n  else\n    {\n      while (list)\n\t{\n\t  opt = enable_shell_command (list->word->word, flags & NFLAG);\n\t  next = list->next;\n\n#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)\n\t  /* If we try to enable a non-existent builtin, and we have dynamic\n\t     loading, try the equivalent of `enable -f name name'. */\n\t  if (opt == EX_NOTFOUND)\n\t    {\n\t      int dflags, r;\n\t      \n\t      dflags = ENABLED|SILENT|((flags & SFLAG) ? SPECIAL : 0);\n\n\t      list->next = 0;\n\t      r = dyn_load_builtin (list, dflags, list->word->word);\n\t      list->next = next;\n\t      if (r == EXECUTION_SUCCESS)\n\t\topt = r;\n#if defined (PROGRAMMABLE_COMPLETION)\n\t      set_itemlist_dirty (&it_builtins);\n#endif\n\t    }\n#endif\n\n\t  if (opt == EX_NOTFOUND)\n\t    {\n\t      sh_notbuiltin (list->word->word);\n\t      result = EXECUTION_FAILURE;\n\t    }\n\t  else if (opt != EXECUTION_SUCCESS)\n\t    result = EXECUTION_FAILURE;\n\n\t  list = next;\n\t}\n    }\n  return (result);\n}\n\n/* List some builtins.\n   FILTER is a mask with two slots: ENABLED and DISABLED. */\nstatic void\nlist_some_builtins (filter)\n     int filter;\n{\n  register int i;\n\n  for (i = 0; i < num_shell_builtins; i++)\n    {\n      if (shell_builtins[i].function == 0 || (shell_builtins[i].flags & BUILTIN_DELETED))\n\tcontinue;\n\n      if ((filter & SPECIAL) &&\n\t  (shell_builtins[i].flags & SPECIAL_BUILTIN) == 0)\n\tcontinue;\n\n      if ((filter & ENABLED) && (shell_builtins[i].flags & BUILTIN_ENABLED))\n\tprintf (\"enable %s\\n\", shell_builtins[i].name);\n      else if ((filter & DISABLED) &&\n\t       ((shell_builtins[i].flags & BUILTIN_ENABLED) == 0))\n\tprintf (\"enable -n %s\\n\", shell_builtins[i].name);\n    }\n}\n\n/* Enable the shell command NAME.  If DISABLE_P is non-zero, then\n   disable NAME instead. */\nstatic int\nenable_shell_command (name, disable_p)\n     char *name;\n     int disable_p;\n{\n  struct builtin *b;\n\n  b = builtin_address_internal (name, 1);\n  if (b == 0)\n    return (EX_NOTFOUND);\n\n  if (disable_p)\n    b->flags &= ~BUILTIN_ENABLED;\n#if defined (RESTRICTED_SHELL)\n  else if (restricted && ((b->flags & BUILTIN_ENABLED) == 0))\n    {\n      sh_restricted ((char *)NULL);\n      return (EXECUTION_FAILURE);\n    }\n#endif\n  else\n    b->flags |= BUILTIN_ENABLED;\n\n#if defined (PROGRAMMABLE_COMPLETION)\n  set_itemlist_dirty (&it_enabled);\n  set_itemlist_dirty (&it_disabled);\n#endif\n\n  return (EXECUTION_SUCCESS);\n}\n\n#if defined (HAVE_DLOPEN) && defined (HAVE_DLSYM)\n\n#if defined (HAVE_DLFCN_H)\n#  include <dlfcn.h>\n#endif\n\nstatic int\ndyn_load_builtin (list, flags, filename)\n     WORD_LIST *list;\n     int flags;\n     char *filename;\n{\n  WORD_LIST *l;\n  void *handle;\n  \n  int total, size, new, replaced, r;\n  char *struct_name, *name, *funcname;\n  sh_load_func_t *loadfunc;\n  struct builtin **new_builtins, *b, *new_shell_builtins, *old_builtin;\n  char *loadables_path, *load_path;\n\n  if (list == 0)\n    return (EXECUTION_FAILURE);\n\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n\n  handle = 0;\n  if (absolute_program (filename) == 0)\n    {\n      loadables_path = get_string_value (\"BASH_LOADABLES_PATH\");\n      if (loadables_path)\n\t{\n\t  load_path = find_in_path (filename, loadables_path, FS_NODIRS|FS_EXEC_PREFERRED);\n\t  if (load_path)\n\t    {\n#if defined (_AIX)\n\t      handle = dlopen (load_path, RTLD_NOW|RTLD_GLOBAL);\n#else\n\t      handle = dlopen (load_path, RTLD_LAZY);\n#endif /* !_AIX */\n\t      free (load_path);\n\t    }\n\t}\n    }\n\n  /* Fall back to current directory for now */\n  if (handle == 0)\n#if defined (_AIX)\n    handle = dlopen (filename, RTLD_NOW|RTLD_GLOBAL);\n#else\n    handle = dlopen (filename, RTLD_LAZY);\n#endif /* !_AIX */\n\n  if (handle == 0)\n    {\n      /* If we've been told to be quiet, don't complain about not finding the\n\t specified shared object. */\n      if ((flags & SILENT) == 0)\n\t{\n\t  name = printable_filename (filename, 0);\n\t  builtin_error (_(\"cannot open shared object %s: %s\"), name, dlerror ());\n\t  if (name != filename)\n\t    free (name);\n\t}\n      return (EX_NOTFOUND);\n    }\n\n  for (new = 0, l = list; l; l = l->next, new++)\n    ;\n  new_builtins = (struct builtin **)xmalloc (new * sizeof (struct builtin *));\n\n  /* For each new builtin in the shared object, find it and its describing\n     structure.  If this is overwriting an existing builtin, do so, otherwise\n     save the loaded struct for creating the new list of builtins. */\n  for (replaced = new = 0; list; list = list->next)\n    {\n      name = list->word->word;\n\n      size = strlen (name);\n      struct_name = (char *)xmalloc (size + 8);\n      strcpy (struct_name, name);\n      strcpy (struct_name + size, STRUCT_SUFFIX);\n\n      old_builtin = builtin_address_internal (name, 1);\n\n      b = (struct builtin *)dlsym (handle, struct_name);\n      if (b == 0)\n\t{\n\t  name = printable_filename (filename, 0);\n\t  builtin_error (_(\"cannot find %s in shared object %s: %s\"),\n\t\t\t    struct_name, name, dlerror ());\n\t  if (name != filename)\n\t    free (name);\n\t  free (struct_name);\n\t  continue;\n\t}\n\n      funcname = xrealloc (struct_name, size + sizeof (LOAD_SUFFIX) + 1);\n      strcpy (funcname, name);\n      strcpy (funcname + size, LOAD_SUFFIX);\n\n      loadfunc = (sh_load_func_t *)dlsym (handle, funcname);\n      if (loadfunc)\n\t{\n\t  /* Add warning if running an init function more than once */\n\t  if (old_builtin && (old_builtin->flags & STATIC_BUILTIN) == 0)\n\t    builtin_warning (_(\"%s: dynamic builtin already loaded\"), name);\n\t  r = (*loadfunc) (name);\n\t  if (r == 0)\n\t    {\n\t      builtin_error (_(\"load function for %s returns failure (%d): not loaded\"), name, r);\n\t      free (funcname);\n\t      continue;\n\t    }\n\t}\n      free (funcname);\n\n      b->flags &= ~STATIC_BUILTIN;\n      if (flags & SPECIAL)\n\tb->flags |= SPECIAL_BUILTIN;\n      b->handle = handle;\n\n      if (old_builtin)\n\t{\n\t  replaced++;\n\t  FASTCOPY ((char *)b, (char *)old_builtin, sizeof (struct builtin));\n\t}\n      else\n\t  new_builtins[new++] = b;\n    }\n\n  if (replaced == 0 && new == 0)\n    {\n      free (new_builtins);\n      dlclose (handle);\n      return (EXECUTION_FAILURE);\n    }\n\n  if (new)\n    {\n      total = num_shell_builtins + new;\n      size = (total + 1) * sizeof (struct builtin);\n\n      new_shell_builtins = (struct builtin *)xmalloc (size);\n      FASTCOPY ((char *)shell_builtins, (char *)new_shell_builtins,\n\t\tnum_shell_builtins * sizeof (struct builtin));\n      for (replaced = 0; replaced < new; replaced++)\n\tFASTCOPY ((char *)new_builtins[replaced],\n\t\t  (char *)&new_shell_builtins[num_shell_builtins + replaced],\n\t\t  sizeof (struct builtin));\n\n      new_shell_builtins[total].name = (char *)0;\n      new_shell_builtins[total].function = (sh_builtin_func_t *)0;\n      new_shell_builtins[total].flags = 0;\n\n      if (shell_builtins != static_shell_builtins)\n\tfree (shell_builtins);\n\n      shell_builtins = new_shell_builtins;\n      num_shell_builtins = total;\n      initialize_shell_builtins ();\n    }\n\n  free (new_builtins);\n  return (EXECUTION_SUCCESS);\n}\n#endif\n\n#if defined (HAVE_DLCLOSE)\nstatic void\ndelete_builtin (b)\n     struct builtin *b;\n{\n  int ind, size;\n  struct builtin *new_shell_builtins;\n\n  /* XXX - funky pointer arithmetic - XXX */\n#ifdef __STDC__\n  ind = b - shell_builtins;\n#else\n  ind = ((int)b - (int)shell_builtins) / sizeof (struct builtin);\n#endif\n  size = num_shell_builtins * sizeof (struct builtin);\n  new_shell_builtins = (struct builtin *)xmalloc (size);\n\n  /* Copy shell_builtins[0]...shell_builtins[ind - 1] to new_shell_builtins */\n  if (ind)\n    FASTCOPY ((char *)shell_builtins, (char *)new_shell_builtins,\n\t      ind * sizeof (struct builtin));\n  /* Copy shell_builtins[ind+1]...shell_builtins[num_shell_builtins to\n     new_shell_builtins, starting at ind. */\n  FASTCOPY ((char *)(&shell_builtins[ind+1]),\n  \t    (char *)(&new_shell_builtins[ind]),\n  \t    (num_shell_builtins - ind) * sizeof (struct builtin));\n\n  if (shell_builtins != static_shell_builtins)\n    free (shell_builtins);\n\n  /* The result is still sorted. */\n  num_shell_builtins--;\n  shell_builtins = new_shell_builtins;\n}\n\n/* Tenon's MachTen has a dlclose that doesn't return a value, so we\n   finesse it with a local wrapper. */\nstatic int\nlocal_dlclose (handle)\n     void *handle;\n{\n#if !defined (__MACHTEN__)\n  return (dlclose (handle));\n#else /* __MACHTEN__ */\n  dlclose (handle);\n  return ((dlerror () != NULL) ? -1 : 0);    \n#endif /* __MACHTEN__ */\n}\n\nstatic int\ndyn_unload_builtin (name)\n     char *name;\n{\n  struct builtin *b;\n  void *handle;\n  char *funcname;\n  sh_unload_func_t *unloadfunc;\n  int ref, i, size;\n\n  b = builtin_address_internal (name, 1);\n  if (b == 0)\n    {\n      sh_notbuiltin (name);\n      return (EXECUTION_FAILURE);\n    }\n  if (b->flags & STATIC_BUILTIN)\n    {\n      builtin_error (_(\"%s: not dynamically loaded\"), name);\n      return (EXECUTION_FAILURE);\n    }\n\n  handle = (void *)b->handle;\n  for (ref = i = 0; i < num_shell_builtins; i++)\n    {\n      if (shell_builtins[i].handle == b->handle)\n\tref++;\n    }\n\n  /* Call any unload function */\n  size = strlen (name);\n  funcname = xmalloc (size + sizeof (UNLOAD_SUFFIX) + 1);\n  strcpy (funcname, name);\n  strcpy (funcname + size, UNLOAD_SUFFIX);\n\n  unloadfunc = (sh_unload_func_t *)dlsym (handle, funcname);\n  if (unloadfunc)\n    (*unloadfunc) (name);\t/* void function */\n  free (funcname);\n\n  /* Don't remove the shared object unless the reference count of builtins\n     using it drops to zero. */\n  if (ref == 1 && local_dlclose (handle) != 0)\n    {\n      builtin_error (_(\"%s: cannot delete: %s\"), name, dlerror ());\n      return (EXECUTION_FAILURE);\n    }\n\n  /* Now remove this entry from the builtin table and reinitialize. */\n  delete_builtin (b);\n\n  return (EXECUTION_SUCCESS);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}