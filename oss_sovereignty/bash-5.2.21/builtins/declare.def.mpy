{
  "module_name": "declare.def",
  "hash_id": "9570a3a415721df7421664e759c697483d6035090e99006649cfc5306f5067cd",
  "original_prompt": "Ingested from bash-5.2.21/builtins/declare.def",
  "human_readable_source": "This file is declare.def, from which is created declare.c.\nIt implements the builtins \"declare\" and \"local\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES declare.c\n\n$BUILTIN declare\n$FUNCTION declare_builtin\n$SHORT_DOC declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] [name ...]\nSet variable values and attributes.\n\nDeclare variables and give them attributes.  If no NAMEs are given,\ndisplay the attributes and values of all variables.\n\nOptions:\n  -f\trestrict action or display to function names and definitions\n  -F\trestrict display to function names only (plus line number and\n\t\tsource file when debugging)\n  -g\tcreate global variables when used in a shell function; otherwise\n\t\tignored\n  -I\tif creating a local variable, inherit the attributes and value\n\t\tof a variable with the same name at a previous scope\n  -p\tdisplay the attributes and value of each NAME\n\nOptions which set attributes:\n  -a\tto make NAMEs indexed arrays (if supported)\n  -A\tto make NAMEs associative arrays (if supported)\n  -i\tto make NAMEs have the `integer' attribute\n  -l\tto convert the value of each NAME to lower case on assignment\n  -n\tmake NAME a reference to the variable named by its value\n  -r\tto make NAMEs readonly\n  -t\tto make NAMEs have the `trace' attribute\n  -u\tto convert the value of each NAME to upper case on assignment\n  -x\tto make NAMEs export\n\nUsing `+' instead of `-' turns off the given attribute.\n\nVariables with the integer attribute have arithmetic evaluation (see\nthe `let' command) performed when the variable is assigned a value.\n\nWhen used in a function, `declare' makes NAMEs local, as with the `local'\ncommand.  The `-g' option suppresses this behavior.\n\nExit Status:\nReturns success unless an invalid option is supplied or a variable\nassignment error occurs.\n$END\n\n$BUILTIN typeset\n$FUNCTION declare_builtin\n$SHORT_DOC typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] [name ...]\nSet variable values and attributes.\n\nA synonym for `declare'.  See `help declare'.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../flags.h\"\n#include \"common.h\"\n#include \"builtext.h\"\n#include \"bashgetopt.h\"\n\nstatic SHELL_VAR *declare_find_variable PARAMS((const char *, int, int));\nstatic char *declare_build_newname PARAMS((char *, char *, int, char *, int));\nstatic char *declare_transform_name PARAMS((char *, int, int));\n\nstatic int declare_internal PARAMS((register WORD_LIST *, int));\n\n/* Declare or change variable attributes. */\nint\ndeclare_builtin (list)\n     register WORD_LIST *list;\n{\n  return (declare_internal (list, 0));\n}\n\n$BUILTIN local\n$FUNCTION local_builtin\n$SHORT_DOC local [option] name[=value] ...\nDefine local variables.\n\nCreate a local variable called NAME, and give it VALUE.  OPTION can\nbe any option accepted by `declare'.\n\nLocal variables can only be used within a function; they are visible\nonly to the function where they are defined and its children.\n\nExit Status:\nReturns success unless an invalid option is supplied, a variable\nassignment error occurs, or the shell is not executing a function.\n$END\nint\nlocal_builtin (list)\n     register WORD_LIST *list;\n{\n  /* Catch a straight `local --help' before checking function context */\n  if (list && list->word && STREQ (list->word->word, \"--help\"))\n    {\n      builtin_help ();\n      return (EX_USAGE);\n    }\n    \n  if (variable_context)\n    return (declare_internal (list, 1));\n  else\n    {\n      builtin_error (_(\"can only be used in a function\"));\n      return (EXECUTION_FAILURE);\n    }\n}\n\n#if defined (ARRAY_VARS)\n#  define DECLARE_OPTS\t\"+acfgilnprtuxAFGI\"\n#else\n#  define DECLARE_OPTS\t\"+cfgilnprtuxFGI\"\n#endif\n\nstatic SHELL_VAR *\ndeclare_find_variable (name, mkglobal, chklocal)\n     const char *name;\n     int mkglobal, chklocal;\n{\n  SHELL_VAR *var;\n\n  if (mkglobal == 0)\n    return (find_variable (name));\n  else if (chklocal)\n    {\n      var = find_variable (name);\n      if (var && local_p (var) && var->context == variable_context)\n\treturn var;\n      return (find_global_variable (name));\n    }\n  else\n    return (find_global_variable (name));\n}\n\n/* Build a new string\n\tNAME[SUBSCRIPT][[+]=VALUE]\n   from expanding a nameref into NAME */\nstatic char *\ndeclare_build_newname (name, subscript_start, offset, value, aflags)\n     char *name, *subscript_start;\n     int offset;\n     char *value;\n     int aflags;\n{\n  size_t namelen, savelen;\n  char *ret;\n\n  savelen = namelen = strlen (name);\n  if (subscript_start)\n    {\n      *subscript_start = '[';\t\t/* ] */\n      namelen += strlen (subscript_start);\n    }\n  ret = xmalloc (namelen + 2 + strlen (value) + 1);\n  strcpy (ret, name);\n  if (subscript_start)\n    strcpy (ret + savelen, subscript_start);\n  if (offset)\n    {\n      if (aflags & ASS_APPEND)\n\tret[namelen++] = '+';\n      ret[namelen++] = '=';\n      if (value && *value)\n\tstrcpy (ret + namelen, value);\n      else\n\tret[namelen] = '\\0';\n    }\n\n  return (ret);\n}\n\nstatic char *\ndeclare_transform_name (name, flags_on, flags_off)\n     char *name;\n     int flags_on, flags_off;\n{\n  SHELL_VAR *var, *v;\n  char *newname;\n  \n  var = find_variable (name);\n  if (var == 0)\n    newname = nameref_transform_name (name, ASS_MKLOCAL);\n  else if ((flags_on & att_nameref) == 0 && (flags_off & att_nameref) == 0)\n    {\n      /* Ok, we're following namerefs here, so let's make sure that if\n\t we followed one, it was at the same context (see below for\n\t more details). */\n      v = find_variable_last_nameref (name, 1);\n      newname = (v && v->context != variable_context) ? name : name_cell (var);\n    }\n  else\n    newname = name;\t/* dealing with nameref attribute */\n\n  return (newname);\n}\n\n/* The workhorse function. */\nstatic int\ndeclare_internal (list, local_var)\n     register WORD_LIST *list;\n     int local_var;\n{\n  int flags_on, flags_off, *flags;\n  int any_failed, assign_error, pflag, nodefs, opt, onref, offref;\n  int mkglobal, chklocal, inherit_flag;\n  char *t, *subscript_start;\n  SHELL_VAR *var, *refvar, *v;\n  FUNCTION_DEF *shell_fn;\n\n  flags_on = flags_off = any_failed = assign_error = pflag = nodefs = 0;\n  mkglobal = chklocal = inherit_flag = 0;\n  refvar = (SHELL_VAR *)NULL;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, DECLARE_OPTS)) != -1)\n    {\n      flags = list_opttype == '+' ? &flags_off : &flags_on;\n\n      /* If you add options here, see whether or not they need to be added to\n\t the loop in subst.c:shell_expand_word_list() */\n      switch (opt)\n\t{\n\tcase 'a':\n#if defined (ARRAY_VARS)\n\t  *flags |= att_array;\n\t  break;\n#else\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n#endif\n\tcase 'A':\n#if defined (ARRAY_VARS)\n\t  *flags |= att_assoc;\n\t  break;\n#else\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n#endif\n\tcase 'p':\n\t  pflag++;\n\t  break;\n\tcase 'F':\n\t  nodefs++;\n\t  *flags |= att_function;\n\t  break;\n\tcase 'f':\n\t  *flags |= att_function;\n\t  break;\n\tcase 'G':\n\t  if (flags == &flags_on)\n\t    chklocal = 1;\n\t  /*FALLTHROUGH*/\n\tcase 'g':\n\t  if (flags == &flags_on)\n\t    mkglobal = 1;\n\t  break;\n\tcase 'i':\n\t  *flags |= att_integer;\n\t  break;\n\tcase 'n':\n\t  *flags |= att_nameref;\n\t  break;\n\tcase 'r':\n\t  *flags |= att_readonly;\n\t  break;\n\tcase 't':\n\t  *flags |= att_trace;\n\t  break;\n\tcase 'x':\n\t  *flags |= att_exported;\n\t  array_needs_making = 1;\n\t  break;\n#if defined (CASEMOD_ATTRS)\n#  if defined (CASEMOD_CAPCASE)\n\t case 'c':\n\t  *flags |= att_capcase;\n\t  if (flags == &flags_on)\n\t    flags_off |= att_uppercase|att_lowercase;\n\t  break;\n#  endif\n\tcase 'l':\n\t  *flags |= att_lowercase;\n\t  if (flags == &flags_on)\n\t    flags_off |= att_capcase|att_uppercase;\n\t  break;\n\tcase 'u':\n\t  *flags |= att_uppercase;\n\t  if (flags == &flags_on)\n\t    flags_off |= att_capcase|att_lowercase;\n\t  break;\n#endif /* CASEMOD_ATTRS */\n\tcase 'I':\n\t  inherit_flag = MKLOC_INHERIT;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  /* If there are no more arguments left, then we just want to show\n     some variables. */\n  if (list == 0)\t/* declare -[aAfFilnrtux] */\n    {\n      /* Show local variables defined at this context level if this is\n\t the `local' builtin. */\n      if (local_var)\n\tshow_local_var_attributes (0, nodefs);\t/* XXX - fix up args later */\n      else if (pflag && (flags_on == 0 || flags_on == att_function))\n\tshow_all_var_attributes (flags_on == 0, nodefs);\n      else if (flags_on == 0)\n\treturn (set_builtin ((WORD_LIST *)NULL));\n      else\n\tset_or_show_attributes ((WORD_LIST *)NULL, flags_on, nodefs);\n\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  if (pflag)\t/* declare -p [-aAfFilnrtux] [name ...] */\n    {\n      for (any_failed = 0; list; list = list->next)\n\t{\n\t  if (flags_on & att_function)\n\t    pflag = show_func_attributes (list->word->word, nodefs);\n\t  else if (local_var)\n\t    pflag = show_localname_attributes (list->word->word, nodefs);\n\t  else\n\t    pflag = show_name_attributes (list->word->word, nodefs);\n\t  if (pflag)\n\t    {\n\t      sh_notfound (list->word->word);\n\t      any_failed++;\n\t    }\n\t}\n      return (sh_chkwrite (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS));\n    }\n\n  /* Some option combinations that don't make any sense */\n  if ((flags_on & att_function) && (flags_on & (att_array|att_assoc|att_integer|att_nameref)))\n    {\n      char *optchar;\n\n      if (flags_on & att_nameref)\n\toptchar = \"-n\";\n      else if (flags_on & att_integer)\n\toptchar = \"-i\";\n      else if (flags_on & att_assoc)\n\toptchar = \"-A\";\n      else if (flags_on & att_array)\n\toptchar = \"-a\";\n\n      sh_invalidopt (optchar);\t\n      return (EXECUTION_FAILURE);\n    }\n\n#define NEXT_VARIABLE() free (name); list = list->next; continue\n\n  /* There are arguments left, so we are making variables. */\n  while (list)\t\t/* declare [-aAfFilnrtux] name[=value] [name[=value] ...] */\n    {\n      char *value, *name, *newname;\n      int offset, aflags, wflags, created_var;\n      int assoc_noexpand;\n#if defined (ARRAY_VARS)\n      int making_array_special, compound_array_assign, simple_array_assign;\n      int var_exists, array_exists, creating_array, array_subscript_assignment;\n#endif\n\n      name = savestring (list->word->word);\n      wflags = list->word->flags;\n#if defined (ARRAY_VARS)\n      assoc_noexpand = assoc_expand_once && (wflags & W_ASSIGNMENT);\n#else\n      assoc_noexpand = 0;\n#endif\n      /* XXX - we allow unbalanced brackets if assoc_noexpand is set, we count\n\t brackets and make sure they match if assoc_noexpand is not set. So we\n\t need to make sure we're checking assoc_noexpand and expand_once_flag\n\t for backwards compatibility. We also use assoc_noexpand below when\n\t we call assign_array_element, so we need to make sure they're\n\t consistent in how they count brackets. */\n      offset = assignment (name, assoc_noexpand ? 2 : 0);\n      aflags = 0;\n      created_var = 0;\n\n      if (local_var && variable_context && STREQ (name, \"-\"))\n\t{\n\t  var = make_local_variable (\"-\", 0);\n\t  FREE (value_cell (var));\t\t/* just in case */\n\t  value = get_current_options ();\n\t  var_setvalue (var, value);\n\t  VSETATTR (var, att_invisible);\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* If we are declaring a function, then complain about it in some way.\n\t We don't let people make functions by saying `typeset -f foo=bar'. */\n\n      /* Can't define functions using assignment statements */\n      if (offset && (flags_on & att_function))\t/* declare -f [-rix] foo=bar */\n\t{\n\t  builtin_error (_(\"cannot use `-f' to make functions\"));\n\t  free (name);\n\t  return (EXECUTION_FAILURE);\n\t}\n\n      /* There should be a way, however, to let people look at a particular\n\t function definition by saying `typeset -f foo'.  This is the only\n\t place in this builtin where we deal with functions. */\n\n      if (flags_on & att_function)\n\t{\n\t  /* Should we restrict this when the shell is in posix mode even if\n\t     the function was created before the shell entered posix mode?\n\t     Previous versions of the shell enforced the restriction. */\n\t  if (posixly_correct && legal_identifier (name) == 0)\n\t    {\n\t      sh_invalidid (name);\n\t      assign_error++;\n\t      NEXT_VARIABLE ();\n\t    }\n\n\t  var = find_function (name);\n\n\t  if (var)\n\t    {\n\t      if (readonly_p (var) && (flags_off & att_readonly))\n\t\t{\n\t\t  builtin_error (_(\"%s: readonly function\"), name);\n\t\t  any_failed++;\n\t\t  NEXT_VARIABLE ();\n\t\t}\n\t      /* declare -[Ff] name [name...] */\n\t      if (flags_on == att_function && flags_off == 0)\n\t\t{\n#if defined (DEBUGGER)\n\t\t  if (nodefs && debugging_mode)\n\t\t    {\n\t\t      shell_fn = find_function_def (name_cell (var));\n\t\t      if (shell_fn)\n\t\t\tprintf (\"%s %d %s\\n\", name_cell (var), shell_fn->line, shell_fn->source_file);\n\t\t      else\n\t\t\tprintf (\"%s\\n\", name_cell (var));\n\t\t    }\n\t\t  else\n#endif /* DEBUGGER */\n\t\t    {\t\n\t\t      t = nodefs ? name_cell (var) : named_function_string (name, function_cell (var), FUNC_MULTILINE|FUNC_EXTERNAL);\n\t\t      printf (\"%s\\n\", t);\n\t\t      any_failed = sh_chkwrite (any_failed);\n\t\t    }\n\t\t}\n\t      else\t\t/* declare -[fF] -[rx] name [name...] */\n\t\t{\n\t\t  VSETATTR (var, flags_on);\n\t\t  flags_off &= ~att_function;\t/* makes no sense */\n\t\t  VUNSETATTR (var, flags_off);\n\t\t}\n\t    }\n\t  else\n\t    any_failed++;\n\n\t  NEXT_VARIABLE ();\n\t}\n\n      if (offset)\t/* declare [-aAfFirx] name=value */\n\t{\n\t  name[offset] = '\\0';\n\t  value = name + offset + 1;\n\t  if (name[offset - 1] == '+')\n\t    {\n\t      aflags |= ASS_APPEND;\n\t      name[offset - 1] = '\\0';\n\t    }\n\t}\n      else\n\tvalue = \"\";\n\n      /* Do some lexical error checking on the LHS and RHS of the assignment\n\t that is specific to nameref variables. */\n      if (flags_on & att_nameref)\n\t{\n#if defined (ARRAY_VARS)\n\t  if (valid_array_reference (name, 0))\n\t    {\n\t      builtin_error (_(\"%s: reference variable cannot be an array\"), name);\n\t      any_failed++;\n\t      NEXT_VARIABLE ();\n\t    }\n\t  else\n#endif\n\t  /* disallow self references at global scope, warn at function scope */\n\t  if (check_selfref (name, value, 0))\n\t    {\n\t      if (variable_context == 0)\n\t\t{\n\t\t  builtin_error (_(\"%s: nameref variable self references not allowed\"), name);\n\t\t  assign_error++;\t/* XXX any_failed++ instead? */\n\t\t  NEXT_VARIABLE ();\n\t\t}\n\t      else\n\t\tbuiltin_warning (_(\"%s: circular name reference\"), name);\n\t    }\n\t  if (value && *value && (aflags & ASS_APPEND) == 0 && valid_nameref_value (value, 1) == 0)\n\t    {\n\t      builtin_error (_(\"`%s': invalid variable name for name reference\"), value);\n\t      assign_error++;\n\t      NEXT_VARIABLE ();\n\t    }\n\t}\n\nrestart_new_var_name:\n\n      /* The rest of the loop body deals with declare -[aAlinrtux] name [name...]\n\t where each NAME can be an assignment statement. */\n\n      subscript_start = (char *)NULL;\t/* used below */\n#if defined (ARRAY_VARS)\n      /* Determine whether we are creating or assigning an array variable */\n      var_exists = array_exists = creating_array = 0;\n      compound_array_assign = simple_array_assign = 0;\n      array_subscript_assignment = 0;\n      if (t = strchr (name, '['))\t/* ] */\n\t{\n\t  /* If offset != 0 we have already validated any array reference\n\t     because assignment() calls skipsubscript() */\n\t  if (offset == 0 && valid_array_reference (name, 0) == 0)\n\t    {\n\t      sh_invalidid (name);\n\t      assign_error++;\n\t      NEXT_VARIABLE ();\n\t    }\n\t  subscript_start = t;\n\t  *t = '\\0';\n\t  making_array_special = 1;\t/* XXX - should this check offset? */\n\t  array_subscript_assignment = offset != 0;\n\t}\n      else\n\tmaking_array_special = 0;\n#endif\n\n      /* Ensure the argument is a valid, well-formed shell identifier. */\n      if (legal_identifier (name) == 0)\n\t{\n\t  sh_invalidid (name);\n\t  assign_error++;\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* If VARIABLE_CONTEXT has a non-zero value, then we are executing\n\t inside of a function.  This means we should make local variables,\n\t not global ones. */\n\n      /* XXX - this has consequences when we're making a local copy of a\n\t       variable that was in the temporary environment.  Watch out\n\t       for this. */\n      refvar = (SHELL_VAR *)NULL;\n      if (variable_context && mkglobal == 0)\n\t{\n\t  /* We don't check newname for validity here. We should not have an\n\t     invalid name assigned as the value of a nameref, but this could\n\t     cause problems. */\n\t  newname = declare_transform_name (name, flags_on, flags_off);\n\n#if defined (ARRAY_VARS)\n\t  /* Pass 1 as second argument to make_local_{assoc,array}_variable\n\t     return an existing {array,assoc} variable to be flagged as an\n\t     error below. */\n\t  if (flags_on & att_assoc)\n\t    var = make_local_assoc_variable (newname, MKLOC_ARRAYOK|inherit_flag);\n\t  else if ((flags_on & att_array) || making_array_special)\n\t    var = make_local_array_variable (newname, MKLOC_ASSOCOK|inherit_flag);\n\t  else\n#endif\n\t  if (offset == 0 && (flags_on & att_nameref))\n\t    {\n\t      /* First look for refvar at current scope */\n\t      refvar = find_variable_last_nameref (name, 1);\n\t      /* VARIABLE_CONTEXT != 0, so we are attempting to create or modify\n\t\t the attributes for a local variable at the same scope.  If we've\n\t\t used a reference from a previous context to resolve VAR, we\n\t\t want to throw REFVAR and VAR away and create a new local var. */\n\t      if (refvar && refvar->context != variable_context)\n\t\t{\n\t\t  refvar = 0;\n\t\t  var = make_local_variable (name, inherit_flag);\n\t\t}\n\t      else if (refvar && refvar->context == variable_context)\n\t\tvar = refvar;\n\t      /* Maybe we just want to create a new local variable */\n\t      else if ((var = find_variable (name)) == 0 || var->context != variable_context)\n\t\tvar = make_local_variable (name, inherit_flag);\n\t      /* otherwise we have a var at the right context */\n\t    }\n\t  else\n\t    /* XXX - check name for validity here with valid_nameref_value? */\n\t    var = make_local_variable ((flags_on & att_nameref) ? name : newname, inherit_flag);\t/* sets att_invisible for new vars */\n\n\t  if (var == 0)\n\t    {\n\t      any_failed++;\n\t      NEXT_VARIABLE ();\n\t    }\n\t  if (var && nameref_p (var) && readonly_p (var) && nameref_cell (var) && (flags_off & att_nameref))\n\t    {\n\t      sh_readonly (name);\n\t      any_failed++;\n\t      NEXT_VARIABLE ();\n\t    }\n\t}\n      else\n\tvar = (SHELL_VAR *)NULL;\n\n      /* VAR is non-null if we just created or fetched a local variable. */\n\n      /* Here's what ksh93 seems to do as of the 2012 version: if we are\n\t using declare -n to modify the value of an existing nameref\n\t variable, don't follow the nameref chain at all and just search\n\t for a nameref at the current context.  If we have a nameref,\n\t modify its value (changing which variable it references). */\n      if (var == 0 && (flags_on & att_nameref))\n\t{\n\t  /* See if we are trying to modify an existing nameref variable,\n\t     but don't follow the nameref chain. */\n\t  var = mkglobal ? find_global_variable_noref (name) : find_variable_noref (name);\n\t  if (var && nameref_p (var) == 0)\n\t    var = 0;\n\t}\n\n      /* However, if we're turning off the nameref attribute on an existing\n\t nameref variable, we first follow the nameref chain to the end,\n\t modify the value of the variable this nameref variable references\n\t if there is an assignment statement argument,\n\t *CHANGING ITS VALUE AS A SIDE EFFECT*, then turn off the nameref\n\t flag *LEAVING THE NAMEREF VARIABLE'S VALUE UNCHANGED* */\n      else if (var == 0 && (flags_off & att_nameref))\n\t{\n\t  /* See if we are trying to modify an existing nameref variable */\n\t     refvar = mkglobal ? find_global_variable_last_nameref (name, 0) : find_variable_last_nameref (name, 0);\n\t  if (refvar && nameref_p (refvar) == 0)\n\t    refvar = 0;\n\t  /* If the nameref is readonly but doesn't have a value, ksh93\n\t     allows the nameref attribute to be removed.  If it's readonly\n\t     and has a value, even if the value doesn't reference an\n\t     existing variable, we disallow the modification */\n\t  if (refvar && nameref_cell (refvar) && readonly_p (refvar))\n\t    {\n\t      sh_readonly (name);\n\t      any_failed++;\n\t      NEXT_VARIABLE ();\n\t    }\n\n\t  /* If all we're doing is turning off the nameref attribute, don't\n\t     bother with VAR at all, whether it exists or not. Just turn it\n\t     off and go on. */\n\t  if (refvar && flags_on == 0 && offset == 0 && flags_off == att_nameref)\n\t    {\n\t      VUNSETATTR (refvar, att_nameref);\n\t      NEXT_VARIABLE ();\n\t    }\n\n\t  if (refvar)\n\t    var = declare_find_variable (nameref_cell (refvar), mkglobal, 0);\n\t}\n#if defined (ARRAY_VARS)\n      /* If we have an array assignment to a nameref, remove the nameref\n\t attribute and go on.  This handles\n\t declare -n xref[=value]; declare [-a] xref[1]=one */\n      else if (var == 0 && offset && array_subscript_assignment)\n\t{\n\t  var = mkglobal ? find_global_variable_noref (name) : find_variable_noref (name);\n\t  if (var && nameref_p (var))\n\t    {\n\t      internal_warning (_(\"%s: removing nameref attribute\"), name);\n\t      FREE (value_cell (var));\t\t/* XXX - bash-4.3 compat */\n\t      var_setvalue (var, (char *)NULL);\n\t      VUNSETATTR (var, att_nameref);\n\t    }\n\t}\n#endif\n\n      /* See if we are trying to set flags or value (or create) for an\n\t existing nameref that points to a non-existent variable: e.g.,\n\t\tdeclare -n foo=bar\n\t\tunset foo\t# unsets bar\n\t\tdeclare -i foo\n\t\tfoo=4+4\n\t\tdeclare -p foo\n      */\n      if (var == 0 && (mkglobal || flags_on || flags_off || offset))\n\t{\n\t  refvar = mkglobal ? find_global_variable_last_nameref (name, 0) : find_variable_last_nameref (name, 0);\n\t  if (refvar && nameref_p (refvar) == 0)\n\t    refvar = 0;\n\t  if (refvar)\n\t    var = declare_find_variable (nameref_cell (refvar), mkglobal, 0);\n\t  if (refvar && var == 0)\n\t    {\n\t      /* I'm not sure subscript_start is ever non-null here. In any\n\t\t event, build a new name from the nameref value, including any\n\t\t subscript, and add the [[+]=value] if offset != 0 */\n\t      newname = declare_build_newname (nameref_cell (refvar), subscript_start, offset, value, aflags);\n\t      free (name);\n\t      name = newname;\n\n\t      if (offset)\n\t\t{\n\t\t  offset = assignment (name, 0);\n\t\t  /* If offset was valid previously, but substituting the\n\t\t     the nameref value results in an invalid assignment,\n\t\t     throw an invalid identifier error */\n\t\t  if (offset == 0)\n\t\t    {\n\t\t      sh_invalidid (name);\n\t\t      assign_error++;\n\t\t      NEXT_VARIABLE ();\n\t\t    }\n\t\t  name[(aflags & ASS_APPEND) ? offset - 1 : offset] = '\\0';\n\t\t  value = name + offset + 1;\n\t\t}\n\n\t      /* OK, let's turn off the nameref attribute.\n\t\t Now everything else applies to VAR. */\n\t      if (flags_off & att_nameref)\n\t\tVUNSETATTR (refvar, att_nameref);\n\n\t      goto restart_new_var_name;\n\t      /* NOTREACHED */\n\t    }\n\t}\n      if (var == 0)\n\tvar = declare_find_variable (name, mkglobal, chklocal);\n\n      /* At this point, VAR is the variable we are dealing with; REFVAR is the\n\t nameref variable we dereferenced to get VAR, if any. */\n#if defined (ARRAY_VARS)\n      var_exists = var != 0;\n      array_exists = var && (array_p (var) || assoc_p (var));\n      creating_array = flags_on & (att_array|att_assoc);\n#endif\n\n      /* Make a new variable if we need to. */\n      if (var == 0)\n\t{\n#if defined (ARRAY_VARS)\n\t  if (flags_on & att_assoc)\n\t    var = make_new_assoc_variable (name);\n\t  else if ((flags_on & att_array) || making_array_special)\n\t    var = make_new_array_variable (name);\n\t  else\n#endif\n\t    var = mkglobal ? bind_global_variable (name, (char *)NULL, ASS_FORCE) : bind_variable (name, (char *)NULL, ASS_FORCE);\n\n\t  if (var == 0)\n\t    {\n\t      /* Has to appear in brackets */\n\t      NEXT_VARIABLE ();\n\t    }\n\t  if (offset == 0)\n\t    VSETATTR (var, att_invisible);\n\t  created_var = 1;\n\t}\n\n      /* Nameref variable error checking. */\n\n      /* Can't take an existing array variable and make it a nameref */\n      else if ((array_p (var) || assoc_p (var)) && (flags_on & att_nameref))\n\t{\n\t  builtin_error (_(\"%s: reference variable cannot be an array\"), name);\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n      /* Can't have an invalid identifier as nameref value */\n      else if (nameref_p (var) && (flags_on & att_nameref) == 0 && (flags_off & att_nameref) == 0 && offset && valid_nameref_value (value, 1) == 0)\n\t{\n\t  builtin_error (_(\"`%s': invalid variable name for name reference\"), value);\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n      /* Can't make an existing variable a nameref if its current value is not\n\t a valid identifier. Check of offset is to allow an assignment to a\n\t nameref var as part of the declare word to override existing value. */\n      else if ((flags_on & att_nameref) && nameref_p (var) == 0 && var_isset (var) && offset == 0 && valid_nameref_value (value_cell (var), 0) == 0)\n\t{\n\t  builtin_error (_(\"`%s': invalid variable name for name reference\"), value_cell (var));\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n      /* Can't make an existing readonly variable a nameref. */\n      else if ((flags_on & att_nameref) && readonly_p (var))\n\t{\n\t  sh_readonly (name);\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* Readonly variable error checking. */\n\n      /* Cannot use declare +r to turn off readonly attribute. */ \n      if (readonly_p (var) && (flags_off & att_readonly))\n\t{\n\t  sh_readonly (name_cell (var));\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n      /* Cannot use declare to assign value to readonly or noassign variable. */\n      else if ((readonly_p (var) || noassign_p (var)) && offset)\n\t{\n\t  if (readonly_p (var))\n\t    sh_readonly (name);\n\t  assign_error++;\n\t  NEXT_VARIABLE ();\n\t}\n\n#if defined (ARRAY_VARS)\n      /* Array variable error checking. */\n\n      /* Cannot use declare +a name or declare +A name to remove an array variable. */\n      if (((flags_off & att_array) && array_p (var)) || ((flags_off & att_assoc) && assoc_p (var)))\n\t{\n\t  builtin_error (_(\"%s: cannot destroy array variables in this way\"), name);\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n      else if ((flags_on & att_array) && assoc_p (var))\n\t{\n\t  builtin_error (_(\"%s: cannot convert associative to indexed array\"), name);\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n      else if ((flags_on & att_assoc) && array_p (var))\n\t{\n\t  builtin_error (_(\"%s: cannot convert indexed to associative array\"), name);\n\t  any_failed++;\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* make declare A[2]=foo as similar to A[2]=foo as possible if A is\n\t already an array or assoc variable. */\n      if (array_subscript_assignment && array_exists && creating_array == 0)\n\tsimple_array_assign = 1;\n      else if ((making_array_special || creating_array || array_exists) && offset)\n\t{\n\t  int vlen;\n\t  vlen = STRLEN (value);\n/*itrace(\"declare_builtin: name = %s value = %s flags = %d\", name, value, wflags);*/\n\n\t  if (shell_compatibility_level > 43 && (wflags & W_COMPASSIGN) == 0 &&\n\t\tvalue[0] == '(' && value[vlen-1] == ')')\n\t    {\n\t      /* I don't believe this warning is printed any more.\n\t\t We use creating_array to allow things like\n\t\t     declare -a foo$bar='(abc)'\n\t\t to work as they have in the past. */\n\t      if (array_exists == 0 && creating_array == 0)\n\t\tinternal_warning (_(\"%s: quoted compound array assignment deprecated\"), list->word->word);\n\t      compound_array_assign = array_exists || creating_array;\n\t      simple_array_assign = making_array_special;\n\t    }\n\t  else if (value[0] == '(' && value[vlen-1] == ')' && (shell_compatibility_level < 44 || (wflags & W_COMPASSIGN)))\n\t    compound_array_assign = 1;\n\t  else\n\t    simple_array_assign = 1;\n\t}\n\n      /* declare -A name[[n]] makes name an associative array variable. */\n      if (flags_on & att_assoc)\n\t{\n\t  if (assoc_p (var) == 0)\n\t    var = convert_var_to_assoc (var);\n\t}\n      /* declare -a name[[n]] or declare name[n] makes NAME an indexed\n\t array variable. */\n      else if ((making_array_special || (flags_on & att_array)) && array_p (var) == 0 && assoc_p (var) == 0)\n\tvar = convert_var_to_array (var);\n#endif /* ARRAY_VARS */\n\n      /* ksh93 compat: turning on nameref attribute turns off -ilu */\n      if (flags_on & att_nameref)\n\tVUNSETATTR (var, att_integer|att_uppercase|att_lowercase|att_capcase);\n\n      /* XXX - we note that we are turning on nameref attribute and defer\n\t setting it until the assignment has been made so we don't do an\n\t inadvertent nameref lookup.  Might have to do the same thing for\n\t flags_off&att_nameref. */\n      /* XXX - ksh93 makes it an error to set a readonly nameref variable\n\t using a single typeset command. */\n      onref = (flags_on & att_nameref);\n      flags_on &= ~att_nameref;\n#if defined (ARRAY_VARS)\n      /* I don't believe this condition ever tests true, but array variables\n\t may not be namerefs */\n      if (array_p (var) || assoc_p (var) || compound_array_assign || simple_array_assign)\n\tonref = 0;\n#endif\n\n      /* ksh93 seems to do this */\n      offref = (flags_off & att_nameref);\n      flags_off &= ~att_nameref;\n\n      VSETATTR (var, flags_on);\n      VUNSETATTR (var, flags_off);\n\n#if defined (ARRAY_VARS)\n      if (offset && compound_array_assign)\n\tassign_array_var_from_string (var, value, aflags|ASS_FORCE);\n      else if (simple_array_assign && subscript_start)\n\t{\n\t  int local_aflags;\n\n\t  /* declare [-aA] name[N]=value */\n\t  *subscript_start = '[';\t/* ] */\n\t  /* XXX - problem here with appending */\n\t  local_aflags = aflags&ASS_APPEND;\n\t  local_aflags |= assoc_noexpand ? ASS_NOEXPAND : 0;\n\t  local_aflags |= ASS_ALLOWALLSUB;\t\t/* allow declare a[@]=at */\n\t  var = assign_array_element (name, value, local_aflags, (array_eltstate_t *)0);\t/* XXX - not aflags */\n\t  *subscript_start = '\\0';\n\t  if (var == 0)\t/* some kind of assignment error */\n\t    {\n\t      assign_error++;\n\t      flags_on |= onref;\n\t      flags_off |= offref;\n\t      NEXT_VARIABLE ();\n\t    }\n\t}\n      else if (simple_array_assign)\n\t{\n\t  /* let bind_{array,assoc}_variable take care of this. */\n\t  if (assoc_p (var))\n\t    bind_assoc_variable (var, name, savestring (\"0\"), value, aflags|ASS_FORCE);\n\t  else\n\t    bind_array_variable (name, 0, value, aflags|ASS_FORCE);\n\t}\n      else\n#endif\n      /* XXX - no ASS_FORCE here */\n      /* bind_variable_value duplicates the essential internals of bind_variable() */\n      if (offset)\n\t{\n\t  if (onref || nameref_p (var))\n\t    aflags |= ASS_NAMEREF;\n\t  v = bind_variable_value (var, value, aflags);\n\t  if (v == 0 && (onref || nameref_p (var)))\n\t    {\n\t      if (valid_nameref_value (value, 1) == 0)\n\t\tsh_invalidid (value);\n\t      assign_error++;\n\t      /* XXX - unset this variable? or leave it as normal var? */\n\t      if (created_var)\n\t\tdelete_var (name_cell (var), mkglobal ? global_variables : shell_variables);\n\t      flags_on |= onref;\t\t/* undo change from above */\n\t      flags_off |= offref;\n\t      NEXT_VARIABLE ();\n\t    }\n\t}\n\n      /* If we found this variable in the temporary environment, as with\n\t `var=value declare -x var', make sure it is treated identically\n\t to `var=value export var'.  Do the same for `declare -r' and\n\t `readonly'.  Preserve the attributes, except for att_tempvar. */\n      /* XXX -- should this create a variable in the global scope, or\n\t modify the local variable flags?  ksh93 has it modify the\n\t global scope.\n\t Need to handle case like in set_var_attribute where a temporary\n\t variable is in the same table as the function local vars. */\n      if ((flags_on & (att_exported|att_readonly)) && tempvar_p (var))\n\t{\n\t  SHELL_VAR *tv;\n\t  char *tvalue;\n\n\t  tv = find_tempenv_variable (name_cell (var));\n\t  if (tv)\n\t    {\n\t      tvalue = var_isset (var) ? savestring (value_cell (var)) : savestring (\"\");\n\t      tv = bind_variable (name_cell (var), tvalue, 0);\n\t      if (tv)\n\t\t{\n\t\t  tv->attributes |= var->attributes & ~att_tempvar;\n\t\t  if (tv->context > 0)\n\t\t    VSETATTR (tv, att_propagate);\n\t\t}\n\t      free (tvalue);\n\t    }\n\t  VSETATTR (var, att_propagate);\n\t}\n\n      /* Turn on nameref attribute we deferred above. */\n      VSETATTR (var, onref);\n      flags_on |= onref;\n      VUNSETATTR (var, offref);\n      flags_off |= offref;\n\n      /* Yuck.  ksh93 compatibility.  XXX - need to investigate more but\n\t definitely happens when turning off nameref attribute on nameref\n\t (see comments above).  Under no circumstances allow this to turn\n\t off readonly attribute on readonly nameref variable. */\n      if (refvar)\n\t{\n\t  if (flags_off & att_readonly)\n\t    flags_off &= ~att_readonly;\n \t  VUNSETATTR (refvar, flags_off);\n\t}\n\n      stupidly_hack_special_variables (name);\n\n      NEXT_VARIABLE ();\n    }\n\n  return (assign_error ? EX_BADASSIGN\n\t\t       : ((any_failed == 0) ? EXECUTION_SUCCESS\n  \t\t\t\t\t    : EXECUTION_FAILURE));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}