{
  "module_name": "reserved.def",
  "hash_id": "a96cc2445f493b8a29823603504211360f98f84e1b0875bd47cb90e655fdb7ae",
  "original_prompt": "Ingested from bash-5.2.21/builtins/reserved.def",
  "human_readable_source": "This file is reserved.def, in which the shell reserved words are defined.\nIt has no direct C file production, but defines builtins for the Bash\nbuiltin help command.\n\nCopyright (C) 1987-2019 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$BUILTIN for\n$SHORT_DOC for NAME [in WORDS ... ] ; do COMMANDS; done\nExecute commands for each member in a list.\n\nThe `for' loop executes a sequence of commands for each member in a\nlist of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\nassumed.  For each element in WORDS, NAME is set to that element, and\nthe COMMANDS are executed.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN for ((\n$DOCNAME arith_for\n$SHORT_DOC for (( exp1; exp2; exp3 )); do COMMANDS; done\nArithmetic for loop.\n\nEquivalent to\n\t(( EXP1 ))\n\twhile (( EXP2 )); do\n\t\tCOMMANDS\n\t\t(( EXP3 ))\n\tdone\nEXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\nomitted, it behaves as if it evaluates to 1.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN select\n$SHORT_DOC select NAME [in WORDS ... ;] do COMMANDS; done\nSelect words from a list and execute commands.\n\nThe WORDS are expanded, generating a list of words.  The\nset of expanded words is printed on the standard error, each\npreceded by a number.  If `in WORDS' is not present, `in \"$@\"'\nis assumed.  The PS3 prompt is then displayed and a line read\nfrom the standard input.  If the line consists of the number\ncorresponding to one of the displayed words, then NAME is set\nto that word.  If the line is empty, WORDS and the prompt are\nredisplayed.  If EOF is read, the command completes.  Any other\nvalue read causes NAME to be set to null.  The line read is saved\nin the variable REPLY.  COMMANDS are executed after each selection\nuntil a break command is executed.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN time\n$SHORT_DOC time [-p] pipeline\nReport time consumed by pipeline's execution.\n\nExecute PIPELINE and print a summary of the real time, user CPU time,\nand system CPU time spent executing PIPELINE when it terminates.\n\nOptions:\n  -p\tprint the timing summary in the portable Posix format\n\nThe value of the TIMEFORMAT variable is used as the output format.\n\nExit Status:\nThe return status is the return status of PIPELINE.\n$END\n\n$BUILTIN case\n$SHORT_DOC case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac\nExecute commands based on pattern matching.\n\nSelectively execute COMMANDS based upon WORD matching PATTERN.  The\n`|' is used to separate multiple patterns.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN if\n$SHORT_DOC if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi\nExecute commands based on conditional.\n\nThe `if COMMANDS' list is executed.  If its exit status is zero, then the\n`then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\nexecuted in turn, and if its exit status is zero, the corresponding\n`then COMMANDS' list is executed and the if command completes.  Otherwise,\nthe `else COMMANDS' list is executed, if present.  The exit status of the\nentire construct is the exit status of the last command executed, or zero\nif no condition tested true.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN while\n$SHORT_DOC while COMMANDS; do COMMANDS-2; done\nExecute commands as long as a test succeeds.\n\nExpand and execute COMMANDS-2 as long as the final command in COMMANDS has\nan exit status of zero.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN until\n$SHORT_DOC until COMMANDS; do COMMANDS-2; done\nExecute commands as long as a test does not succeed.\n\nExpand and execute COMMANDS-2 as long as the final command in COMMANDS has\nan exit status which is not zero.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN coproc\n$SHORT_DOC coproc [NAME] command [redirections]\nCreate a coprocess named NAME.\n\nExecute COMMAND asynchronously, with the standard output and standard\ninput of the command connected via a pipe to file descriptors assigned\nto indices 0 and 1 of an array variable NAME in the executing shell.\nThe default NAME is \"COPROC\".\n\nExit Status:\nThe coproc command returns an exit status of 0.\n$END\n\n$BUILTIN function\n$SHORT_DOC function name { COMMANDS ; } or name () { COMMANDS ; }\nDefine shell function.\n\nCreate a shell function named NAME.  When invoked as a simple command,\nNAME runs COMMANDs in the calling shell's context.  When NAME is invoked,\nthe arguments are passed to the function as $1...$n, and the function's\nname is in $FUNCNAME.\n\nExit Status:\nReturns success unless NAME is readonly.\n$END\n\n$BUILTIN { ... }\n$DOCNAME grouping_braces\n$SHORT_DOC { COMMANDS ; }\nGroup commands as a unit.\n\nRun a set of commands in a group.  This is one way to redirect an\nentire set of commands.\n\nExit Status:\nReturns the status of the last command executed.\n$END\n\n$BUILTIN %\n$DOCNAME fg_percent\n$SHORT_DOC job_spec [&]\nResume job in foreground.\n\nEquivalent to the JOB_SPEC argument to the `fg' command.  Resume a\nstopped or background job.  JOB_SPEC can specify either a job name\nor a job number.  Following JOB_SPEC with a `&' places the job in\nthe background, as if the job specification had been supplied as an\nargument to `bg'.\n\nExit Status:\nReturns the status of the resumed job.\n$END\n\n$BUILTIN (( ... ))\n$DOCNAME arith\n$SHORT_DOC (( expression ))\nEvaluate arithmetic expression.\n\nThe EXPRESSION is evaluated according to the rules for arithmetic\nevaluation.  Equivalent to `let \"EXPRESSION\"'.\n\nExit Status:\nReturns 1 if EXPRESSION evaluates to 0; returns 0 otherwise.\n$END\n\n$BUILTIN [[ ... ]]\n$DOCNAME conditional\n$SHORT_DOC [[ expression ]]\nExecute conditional command.\n\nReturns a status of 0 or 1 depending on the evaluation of the conditional\nexpression EXPRESSION.  Expressions are composed of the same primaries used\nby the `test' builtin, and may be combined using the following operators:\n\n  ( EXPRESSION )\tReturns the value of EXPRESSION\n  ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n  EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n  EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n\nWhen the `==' and `!=' operators are used, the string to the right of\nthe operator is used as a pattern and pattern matching is performed.\nWhen the `=~' operator is used, the string to the right of the operator\nis matched as a regular expression.\n\nThe && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\ndetermine the expression's value.\n\nExit Status:\n0 or 1 depending on value of EXPRESSION.\n$END\n\n$BUILTIN variables\n$DOCNAME variable_help\n$SHORT_DOC variables - Names and meanings of some shell variables\nCommon shell variable names and usage.\n\nBASH_VERSION\tVersion information for this Bash.\nCDPATH\tA colon-separated list of directories to search\n\t\tfor directories given as arguments to `cd'.\nGLOBIGNORE\tA colon-separated list of patterns describing filenames to\n\t\tbe ignored by pathname expansion.\n#if defined (HISTORY)\nHISTFILE\tThe name of the file where your command history is stored.\nHISTFILESIZE\tThe maximum number of lines this file can contain.\nHISTSIZE\tThe maximum number of history lines that a running\n\t\tshell can access.\n#endif /* HISTORY */\nHOME\tThe complete pathname to your login directory.\nHOSTNAME\tThe name of the current host.\nHOSTTYPE\tThe type of CPU this version of Bash is running under.\nIGNOREEOF\tControls the action of the shell on receipt of an EOF\n\t\tcharacter as the sole input.  If set, then the value\n\t\tof it is the number of EOF characters that can be seen\n\t\tin a row on an empty line before the shell will exit\n\t\t(default 10).  When unset, EOF signifies the end of input.\nMACHTYPE\tA string describing the current system Bash is running on.\nMAILCHECK\tHow often, in seconds, Bash checks for new mail.\nMAILPATH\tA colon-separated list of filenames which Bash checks\n\t\tfor new mail.\nOSTYPE\tThe version of Unix this version of Bash is running on.\nPATH\tA colon-separated list of directories to search when\n\t\tlooking for commands.\nPROMPT_COMMAND\tA command to be executed before the printing of each\n\t\tprimary prompt.\nPS1\t\tThe primary prompt string.\nPS2\t\tThe secondary prompt string.\nPWD\t\tThe full pathname of the current directory.\nSHELLOPTS\tA colon-separated list of enabled shell options.\nTERM\tThe name of the current terminal type.\nTIMEFORMAT\tThe output format for timing statistics displayed by the\n\t\t`time' reserved word.\nauto_resume\tNon-null means a command word appearing on a line by\n\t\titself is first looked for in the list of currently\n\t\tstopped jobs.  If found there, that job is foregrounded.\n\t\tA value of `exact' means that the command word must\n\t\texactly match a command in the list of stopped jobs.  A\n\t\tvalue of `substring' means that the command word must\n\t\tmatch a substring of the job.  Any other value means that\n\t\tthe command must be a prefix of a stopped job.\n#if defined (HISTORY)\n#  if defined (BANG_HISTORY)\nhistchars\tCharacters controlling history expansion and quick\n\t\tsubstitution.  The first character is the history\n\t\tsubstitution character, usually `!'.  The second is\n\t\tthe `quick substitution' character, usually `^'.  The\n\t\tthird is the `history comment' character, usually `#'.\n#  endif /* BANG_HISTORY */\nHISTIGNORE\tA colon-separated list of patterns used to decide which\n\t\tcommands should be saved on the history list.\n#endif /* HISTORY */\n$END\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}