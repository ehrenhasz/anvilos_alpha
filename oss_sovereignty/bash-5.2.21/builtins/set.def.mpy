{
  "module_name": "set.def",
  "hash_id": "60cc498e28d4e9edd49a1415f1b5f92cfd326c6cb0d17d0d0827757f23580793",
  "original_prompt": "Ingested from bash-5.2.21/builtins/set.def",
  "human_readable_source": "This file is set.def, from which is created set.c.\nIt implements the \"set\" and \"unset\" builtins in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES set.c\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../parser.h\"\n#include \"../flags.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#if defined (READLINE)\n#  include \"../input.h\"\n#  include \"../bashline.h\"\n#  include <readline/readline.h>\n#endif\n\n#if defined (HISTORY)\n#  include \"../bashhist.h\"\n#endif\n\n$BUILTIN set\n$FUNCTION set_builtin\n$SHORT_DOC set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]\nSet or unset values of shell options and positional parameters.\n\nChange the value of shell attributes and positional parameters, or\ndisplay the names and values of shell variables.\n\nOptions:\n  -a  Mark variables which are modified or created for export.\n  -b  Notify of job termination immediately.\n  -e  Exit immediately if a command exits with a non-zero status.\n  -f  Disable file name generation (globbing).\n  -h  Remember the location of commands as they are looked up.\n  -k  All assignment arguments are placed in the environment for a\n      command, not just those that precede the command name.\n  -m  Job control is enabled.\n  -n  Read commands but do not execute them.\n  -o option-name\n      Set the variable corresponding to option-name:\n          allexport    same as -a\n          braceexpand  same as -B\n#if defined (READLINE)\n          emacs        use an emacs-style line editing interface\n#endif /* READLINE */\n          errexit      same as -e\n          errtrace     same as -E\n          functrace    same as -T\n          hashall      same as -h\n#if defined (BANG_HISTORY)\n          histexpand   same as -H\n#endif /* BANG_HISTORY */\n#if defined (HISTORY)\n          history      enable command history\n#endif\n          ignoreeof    the shell will not exit upon reading EOF\n          interactive-comments\n                       allow comments to appear in interactive commands\n          keyword      same as -k\n#if defined (JOB_CONTROL)\n          monitor      same as -m\n#endif\n          noclobber    same as -C\n          noexec       same as -n\n          noglob       same as -f\n          nolog        currently accepted but ignored\n#if defined (JOB_CONTROL)\n          notify       same as -b\n#endif\n          nounset      same as -u\n          onecmd       same as -t\n          physical     same as -P\n          pipefail     the return value of a pipeline is the status of\n                       the last command to exit with a non-zero status,\n                       or zero if no command exited with a non-zero status\n          posix        change the behavior of bash where the default\n                       operation differs from the Posix standard to\n                       match the standard\n          privileged   same as -p\n          verbose      same as -v\n#if defined (READLINE)\n          vi           use a vi-style line editing interface\n#endif /* READLINE */\n          xtrace       same as -x\n  -p  Turned on whenever the real and effective user ids do not match.\n      Disables processing of the $ENV file and importing of shell\n      functions.  Turning this option off causes the effective uid and\n      gid to be set to the real uid and gid.\n  -t  Exit after reading and executing one command.\n  -u  Treat unset variables as an error when substituting.\n  -v  Print shell input lines as they are read.\n  -x  Print commands and their arguments as they are executed.\n#if defined (BRACE_EXPANSION)\n  -B  the shell will perform brace expansion\n#endif /* BRACE_EXPANSION */\n  -C  If set, disallow existing regular files to be overwritten\n      by redirection of output.\n  -E  If set, the ERR trap is inherited by shell functions.\n#if defined (BANG_HISTORY)\n  -H  Enable ! style history substitution.  This flag is on\n      by default when the shell is interactive.\n#endif /* BANG_HISTORY */\n  -P  If set, do not resolve symbolic links when executing commands\n      such as cd which change the current directory.\n  -T  If set, the DEBUG and RETURN traps are inherited by shell functions.\n  --  Assign any remaining arguments to the positional parameters.\n      If there are no remaining arguments, the positional parameters\n      are unset.\n  -   Assign any remaining arguments to the positional parameters.\n      The -x and -v options are turned off.\n\nUsing + rather than - causes these flags to be turned off.  The\nflags can also be used upon invocation of the shell.  The current\nset of flags may be found in $-.  The remaining n ARGs are positional\nparameters and are assigned, in order, to $1, $2, .. $n.  If no\nARGs are given, all shell variables are printed.\n\nExit Status:\nReturns success unless an invalid option is given.\n$END\n\ntypedef int setopt_set_func_t PARAMS((int, char *));\ntypedef int setopt_get_func_t PARAMS((char *));\n\nstatic int find_minus_o_option PARAMS((char *));\n\nstatic void print_minus_o_option PARAMS((char *, int, int));\nstatic void print_all_shell_variables PARAMS((void));\n\nstatic int set_ignoreeof PARAMS((int, char *));\nstatic int set_posix_mode PARAMS((int, char *));\n\n#if defined (READLINE)\nstatic int set_edit_mode PARAMS((int, char *));\nstatic int get_edit_mode PARAMS((char *));\n#endif\n\n#if defined (HISTORY)\nstatic int bash_set_history PARAMS((int, char *));\n#endif\n\nstatic const char * const on = \"on\";\nstatic const char * const off = \"off\";\n\nstatic int previous_option_value;\n\n/* A struct used to match long options for set -o to the corresponding\n   option letter or internal variable.  The functions can be called to\n   dynamically generate values.  If you add a new variable name here\n   that doesn't have a corresponding single-character option letter, make\n   sure to set the value appropriately in reset_shell_options. */\nconst struct {\n  char *name;\n  int letter;\n  int *variable;\n  setopt_set_func_t *set_func;\n  setopt_get_func_t *get_func;\n} o_options[] = {\n  { \"allexport\",  'a', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },\n#if defined (BRACE_EXPANSION)\n  { \"braceexpand\",'B', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#endif\n#if defined (READLINE)\n  { \"emacs\",     '\\0', (int *)NULL, set_edit_mode, get_edit_mode },\n#endif\n  { \"errexit\",\t  'e', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"errtrace\",\t  'E', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"functrace\",  'T', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"hashall\",    'h', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#if defined (BANG_HISTORY)\n  { \"histexpand\", 'H', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#endif /* BANG_HISTORY */\n#if defined (HISTORY)\n  { \"history\",   '\\0', &enable_history_list, bash_set_history, (setopt_get_func_t *)NULL },\n#endif\n  { \"ignoreeof\", '\\0', &ignoreeof, set_ignoreeof, (setopt_get_func_t *)NULL },\n  { \"interactive-comments\", '\\0', &interactive_comments, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },\n  { \"keyword\",    'k', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#if defined (JOB_CONTROL)\n  { \"monitor\",\t  'm', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#endif\n  { \"noclobber\",  'C', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"noexec\",\t  'n', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"noglob\",\t  'f', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#if defined (HISTORY)\n  { \"nolog\",     '\\0', &dont_save_function_defs, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },\n#endif\n#if defined (JOB_CONTROL)\n  { \"notify\",\t  'b', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#endif /* JOB_CONTROL */\n  { \"nounset\",\t  'u', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"onecmd\",\t  't', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },\n  { \"physical\",   'P', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"pipefail\",  '\\0', &pipefail_opt, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"posix\",     '\\0', &posixly_correct, set_posix_mode, (setopt_get_func_t *)NULL },\n  { \"privileged\", 'p', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  { \"verbose\",\t  'v', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n#if defined (READLINE)\n  { \"vi\",        '\\0', (int *)NULL, set_edit_mode, get_edit_mode },\n#endif\n  { \"xtrace\",\t  'x', (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL  },\n  {(char *)NULL, 0 , (int *)NULL, (setopt_set_func_t *)NULL, (setopt_get_func_t *)NULL },\n};\n\n#define N_O_OPTIONS\t(sizeof (o_options) / sizeof (o_options[0]))\n\n#define GET_BINARY_O_OPTION_VALUE(i, name) \\\n  ((o_options[i].get_func) ? (*o_options[i].get_func) (name) \\\n\t\t\t   : (*o_options[i].variable))\n\n#define SET_BINARY_O_OPTION_VALUE(i, onoff, name) \\\n  ((o_options[i].set_func) ? (*o_options[i].set_func) (onoff, name) \\\n\t\t\t   : (*o_options[i].variable = (onoff == FLAG_ON)))\n\nstatic int\nfind_minus_o_option (name)\n     char *name;\n{\n  register int i;\n\n  for (i = 0; o_options[i].name; i++)\n    if (STREQ (name, o_options[i].name))\n      return i;\n  return -1;\n}\n\nint\nminus_o_option_value (name)\n     char *name;\n{\n  register int\ti;\n  int *on_or_off;\n\n  i = find_minus_o_option (name);\n  if (i < 0)\n    return (-1);\n\n  if (o_options[i].letter)\n    {\n      on_or_off = find_flag (o_options[i].letter);\n      return ((on_or_off == FLAG_UNKNOWN) ? -1 : *on_or_off);\n    }\n  else\n    return (GET_BINARY_O_OPTION_VALUE (i, name));\n}\n\n#define MINUS_O_FORMAT \"%-15s\\t%s\\n\"\n\nstatic void\nprint_minus_o_option (name, value, pflag)\n     char *name;\n     int value, pflag;\n{\n  if (pflag == 0)\n    printf (MINUS_O_FORMAT, name, value ? on : off);\n  else\n    printf (\"set %co %s\\n\", value ? '-' : '+', name);\n}\n\nvoid\nlist_minus_o_opts (mode, reusable)\n     int mode, reusable;\n{\n  register int\ti;\n  int *on_or_off, value;\n\n  for (i = 0; o_options[i].name; i++)\n    {\n      if (o_options[i].letter)\n\t{\n\t  value = 0;\n\t  on_or_off = find_flag (o_options[i].letter);\n\t  if (on_or_off == FLAG_UNKNOWN)\n\t    on_or_off = &value;\n\t  if (mode == -1 || mode == *on_or_off)\n\t    print_minus_o_option (o_options[i].name, *on_or_off, reusable);\n\t}\n      else\n\t{\n\t  value = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);\n\t  if (mode == -1 || mode == value)\n\t    print_minus_o_option (o_options[i].name, value, reusable);\n\t}\n    }\n}\n\nchar **\nget_minus_o_opts ()\n{\n  char **ret;\n  int i;\n\n  ret = strvec_create (N_O_OPTIONS + 1);\n  for (i = 0; o_options[i].name; i++)\n    ret[i] = o_options[i].name;\n  ret[i] = (char *)NULL;\n  return ret;\n}\n\nchar *\nget_current_options ()\n{\n  char *temp;\n  int i, posixopts;\n\n  posixopts = num_posix_options ();\t/* shopts modified by posix mode */\n  /* Make the buffer big enough to hold the set -o options and the shopt\n     options modified by posix mode. */\n  temp = (char *)xmalloc (1 + N_O_OPTIONS + posixopts);\n  for (i = 0; o_options[i].name; i++)\n    {\n      if (o_options[i].letter)\n\ttemp[i] = *(find_flag (o_options[i].letter));\n      else\n\ttemp[i] = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);\n    }\n\n  /* Add the shell options that are modified by posix mode to the end of the\n     bitmap. They will be handled in set_current_options() */\n  get_posix_options (temp+i);\n  temp[i+posixopts] = '\\0';\n  return (temp);\n}\n\nvoid\nset_current_options (bitmap)\n     const char *bitmap;\n{\n  int i, v, cv, *on_or_off;\n\n  if (bitmap == 0)\n    return;\n\n  for (i = 0; o_options[i].name; i++)\n    {\n      v = bitmap[i] ? FLAG_ON : FLAG_OFF;\n      if (o_options[i].letter)\n\t{\n\t  /* We should not get FLAG_UNKNOWN here */\n\t  on_or_off = find_flag (o_options[i].letter);\n\t  cv = *on_or_off ? FLAG_ON : FLAG_OFF;\n\t  if (v != cv)\n\t    change_flag (o_options[i].letter, v);\n\t}\n      else\n\t{\n\t  cv = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);\n\t  cv = cv ? FLAG_ON : FLAG_OFF;\n\t  if (v != cv)\n\t    SET_BINARY_O_OPTION_VALUE (i, v, o_options[i].name);\n\t}\n    }\n\n  /* Now reset the variables changed by posix mode */\n  set_posix_options (bitmap+i);\n}\n\nstatic int\nset_ignoreeof (on_or_off, option_name)\n     int on_or_off;\n     char *option_name;\n{\n  ignoreeof = on_or_off == FLAG_ON;\n  unbind_variable_noref (\"ignoreeof\");\n  if (ignoreeof)\n    bind_variable (\"IGNOREEOF\", \"10\", 0); \n  else\n    unbind_variable_noref (\"IGNOREEOF\");\n  sv_ignoreeof (\"IGNOREEOF\");\n  return 0;\n}\n\nstatic int\nset_posix_mode (on_or_off, option_name)\n     int on_or_off;\n     char *option_name;\n{\n  /* short-circuit on no-op */\n  if ((on_or_off == FLAG_ON && posixly_correct) ||\n      (on_or_off == FLAG_OFF && posixly_correct == 0))\n    return 0;\n\n  posixly_correct = on_or_off == FLAG_ON;\n  if (posixly_correct == 0)\n    unbind_variable_noref (\"POSIXLY_CORRECT\");\n  else\n    bind_variable (\"POSIXLY_CORRECT\", \"y\", 0);\n  sv_strict_posix (\"POSIXLY_CORRECT\");\n  return (0);\n}\n\n#if defined (READLINE)\n/* Magic.  This code `knows' how readline handles rl_editing_mode. */\nstatic int\nset_edit_mode (on_or_off, option_name)\n     int on_or_off;\n     char *option_name;\n{\n  int isemacs;\n\n  if (on_or_off == FLAG_ON)\n    {\n      rl_variable_bind (\"editing-mode\", option_name);\n\n      if (interactive)\n\twith_input_from_stdin ();\n      no_line_editing = 0;\n    }\n  else\n    {\n      isemacs = rl_editing_mode == 1;\n      if ((isemacs && *option_name == 'e') || (!isemacs && *option_name == 'v'))\n\t{\n\t  if (interactive)\n\t    with_input_from_stream (stdin, \"stdin\");\n\t  no_line_editing = 1;\n\t}\n    }\n  return 1-no_line_editing;\n}\n\nstatic int\nget_edit_mode (name)\n     char *name;\n{\n  return (*name == 'e' ? no_line_editing == 0 && rl_editing_mode == 1\n\t\t       : no_line_editing == 0 && rl_editing_mode == 0);\n}\n#endif /* READLINE */\n\n#if defined (HISTORY)\nstatic int\nbash_set_history (on_or_off, option_name)\n     int on_or_off;\n     char *option_name;\n{\n  if (on_or_off == FLAG_ON)\n    {\n      enable_history_list = 1;\n      bash_history_enable ();\n      if (history_lines_this_session == 0)\n\tload_history ();\n    }\n  else\n    {\n      enable_history_list = 0;\n      bash_history_disable ();\n    }\n  return (1 - enable_history_list);\n}\n#endif\n\nint\nset_minus_o_option (on_or_off, option_name)\n     int on_or_off;\n     char *option_name;\n{\n  register int i;\n\n  i = find_minus_o_option (option_name);\n  if (i < 0)\n    {\n      sh_invalidoptname (option_name);\n      return (EX_USAGE);\n    }\n\n  if (o_options[i].letter == 0)\n    {\n      previous_option_value = GET_BINARY_O_OPTION_VALUE (i, o_options[i].name);\n      SET_BINARY_O_OPTION_VALUE (i, on_or_off, option_name);\n      return (EXECUTION_SUCCESS);\n    }\n  else\n    {\n      if ((previous_option_value = change_flag (o_options[i].letter, on_or_off)) == FLAG_ERROR)\n\t{\n\t  sh_invalidoptname (option_name);\n\t  return (EXECUTION_FAILURE);\n\t}\n      else\n\treturn (EXECUTION_SUCCESS);\n    }\n}\n\nstatic void\nprint_all_shell_variables ()\n{\n  SHELL_VAR **vars;\n\n  vars = all_shell_variables ();\n  if (vars)\n    {\n      print_var_list (vars);\n      free (vars);\n    }\n\n  /* POSIX.2 does not allow function names and definitions to be output when\n     `set' is invoked without options (PASC Interp #202). */\n  if (posixly_correct == 0)\n    {\n      vars = all_shell_functions ();\n      if (vars)\n\t{\n\t  print_func_list (vars);\n\t  free (vars);\n\t}\n    }\n}\n\nvoid\nset_shellopts ()\n{\n  char *value;\n  char tflag[N_O_OPTIONS];\n  int vsize, i, vptr, *ip, exported;\n  SHELL_VAR *v;\n\n  for (vsize = i = 0; o_options[i].name; i++)\n    {\n      tflag[i] = 0;\n      if (o_options[i].letter)\n\t{\n\t  ip = find_flag (o_options[i].letter);\n\t  if (ip && *ip)\n\t    {\n\t      vsize += strlen (o_options[i].name) + 1;\n\t      tflag[i] = 1;\n\t    }\n\t}\n      else if (GET_BINARY_O_OPTION_VALUE (i, o_options[i].name))\n\t{\n\t  vsize += strlen (o_options[i].name) + 1;\n\t  tflag[i] = 1;\n\t}\n    }\n\n  value = (char *)xmalloc (vsize + 1);\n\n  for (i = vptr = 0; o_options[i].name; i++)\n    {\n      if (tflag[i])\n\t{\n\t  strcpy (value + vptr, o_options[i].name);\n\t  vptr += strlen (o_options[i].name);\n\t  value[vptr++] = ':';\n\t}\n    }\n\n  if (vptr)\n    vptr--;\t\t\t/* cut off trailing colon */\n  value[vptr] = '\\0';\n\n  v = find_variable (\"SHELLOPTS\");\n\n  /* Turn off the read-only attribute so we can bind the new value, and\n     note whether or not the variable was exported. */\n  if (v)\n    {\n      VUNSETATTR (v, att_readonly);\n      exported = exported_p (v);\n    }\n  else\n    exported = 0;\n\n  v = bind_variable (\"SHELLOPTS\", value, 0);\n\n  /* Turn the read-only attribute back on, and turn off the export attribute\n     if it was set implicitly by mark_modified_vars and SHELLOPTS was not\n     exported before we bound the new value. */\n  VSETATTR (v, att_readonly);\n  if (mark_modified_vars && exported == 0 && exported_p (v))\n    VUNSETATTR (v, att_exported);\n\n  free (value);\n}\n\nvoid\nparse_shellopts (value)\n     char *value;\n{\n  char *vname;\n  int vptr;\n\n  vptr = 0;\n  while (vname = extract_colon_unit (value, &vptr))\n    {\n      set_minus_o_option (FLAG_ON, vname);\n      free (vname);\n    }\n}\n\nvoid\ninitialize_shell_options (no_shellopts)\n     int no_shellopts;\n{\n  char *temp;\n  SHELL_VAR *var;\n\n  if (no_shellopts == 0)\n    {\n      var = find_variable (\"SHELLOPTS\");\n      /* set up any shell options we may have inherited. */\n      if (var && imported_p (var))\n\t{\n\t  temp = (array_p (var) || assoc_p (var)) ? (char *)NULL : savestring (value_cell (var));\n\t  if (temp)\n\t    {\n\t      parse_shellopts (temp);\n\t      free (temp);\n\t    }\n\t}\n    }\n\n  /* Set up the $SHELLOPTS variable. */\n  set_shellopts ();\n}\n\n/* Reset the values of the -o options that are not also shell flags.  This is\n   called from execute_cmd.c:initialize_subshell() when setting up a subshell\n   to run an executable shell script without a leading `#!'. */\nvoid\nreset_shell_options ()\n{\n  pipefail_opt = 0;\n  ignoreeof = 0;\n\n#if defined (STRICT_POSIX)\n  posixly_correct = 1;\n#else\n  posixly_correct = 0;\n#endif\n#if defined (HISTORY)\n  dont_save_function_defs = 0;\n  remember_on_history = enable_history_list = 1;\t/* XXX */\n#endif\n}\n\n/* Set some flags from the word values in the input list.  If LIST is empty,\n   then print out the values of the variables instead.  If LIST contains\n   non-flags, then set $1 - $9 to the successive words of LIST. */\nint\nset_builtin (list)\n     WORD_LIST *list;\n{\n  int on_or_off, flag_name, force_assignment, opts_changed, rv, r;\n  register char *arg;\n  char s[3];\n\n  if (list == 0)\n    {\n      print_all_shell_variables ();\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  /* Check validity of flag arguments. */\n  rv = EXECUTION_SUCCESS;\n  reset_internal_getopt ();\n  while ((flag_name = internal_getopt (list, optflags)) != -1)\n    {\n      switch (flag_name)\n\t{\n\t  case 'i':\t/* don't allow set -i */\n\t    s[0] = list_opttype;\n\t    s[1] = 'i';\n\t    s[2] = '\\0';\n\t    sh_invalidopt (s);\n\t    builtin_usage ();\n\t    return (EX_USAGE);\n\t  CASE_HELPOPT;\n\t  case '?':\n\t    builtin_usage ();\n\t    return (list_optopt == '?' ? EXECUTION_SUCCESS : EX_USAGE);\n\t  default:\n\t    break;\n\t}\n    }\n    \n  /* Do the set command.  While the list consists of words starting with\n     '-' or '+' treat them as flags, otherwise, start assigning them to\n     $1 ... $n. */\n  for (force_assignment = opts_changed = 0; list; )\n    {\n      arg = list->word->word;\n\n      /* If the argument is `--' or `-' then signal the end of the list\n\t and remember the remaining arguments. */\n      if (arg[0] == '-' && (!arg[1] || (arg[1] == '-' && !arg[2])))\n\t{\n\t  list = list->next;\n\n\t  /* `set --' unsets the positional parameters. */\n\t  if (arg[1] == '-')\n\t    force_assignment = 1;\n\n\t  /* Until told differently, the old shell behaviour of\n\t     `set - [arg ...]' being equivalent to `set +xv [arg ...]'\n\t     stands.  Posix.2 says the behaviour is marked as obsolescent. */\n\t  else\n\t    {\n\t      change_flag ('x', '+');\n\t      change_flag ('v', '+');\n\t      opts_changed = 1;\n\t    }\n\n\t  break;\n\t}\n\n      if ((on_or_off = *arg) && (on_or_off == '-' || on_or_off == '+'))\n\t{\n\t  while (flag_name = *++arg)\n\t    {\n\t      if (flag_name == '?')\n\t\t{\n\t\t  builtin_usage ();\n\t\t  return (EXECUTION_SUCCESS);\n\t\t}\n\t      else if (flag_name == 'o') /* -+o option-name */\n\t\t{\n\t\t  char *option_name;\n\t\t  WORD_LIST *opt;\n\n\t\t  opt = list->next;\n\n\t\t  if (opt == 0)\n\t\t    {\n\t\t      list_minus_o_opts (-1, (on_or_off == '+'));\n\t\t      rv = sh_chkwrite (rv);\n\t\t      continue;\n\t\t    }\n\n\t\t  option_name = opt->word->word;\n\n\t\t  if (option_name == 0 || *option_name == '\\0' ||\n\t\t      *option_name == '-' || *option_name == '+')\n\t\t    {\n\t\t      list_minus_o_opts (-1, (on_or_off == '+'));\n\t\t      continue;\n\t\t    }\n\t\t  list = list->next; /* Skip over option name. */\n\n\t\t  opts_changed = 1;\n\t\t  if ((r = set_minus_o_option (on_or_off, option_name)) != EXECUTION_SUCCESS)\n\t\t    {\n\t\t      set_shellopts ();\n\t\t      return (r);\n\t\t    }\n\t\t}\n\t      else if (change_flag (flag_name, on_or_off) == FLAG_ERROR)\n\t\t{\n\t\t  s[0] = on_or_off;\n\t\t  s[1] = flag_name;\n\t\t  s[2] = '\\0';\n\t\t  sh_invalidopt (s);\n\t\t  builtin_usage ();\n\t\t  set_shellopts ();\n\t\t  return (EXECUTION_FAILURE);\n\t\t}\n\t      opts_changed = 1;\n\t    }\n\t}\n      else\n\t{\n\t  break;\n\t}\n      list = list->next;\n    }\n\n  /* Assigning $1 ... $n */\n  if (list || force_assignment)\n    remember_args (list, 1);\n  /* Set up new value of $SHELLOPTS */\n  if (opts_changed)\n    set_shellopts ();\n  return (rv);\n}\n\n$BUILTIN unset\n$FUNCTION unset_builtin\n$SHORT_DOC unset [-f] [-v] [-n] [name ...]\nUnset values and attributes of shell variables and functions.\n\nFor each NAME, remove the corresponding variable or function.\n\nOptions:\n  -f\ttreat each NAME as a shell function\n  -v\ttreat each NAME as a shell variable\n  -n\ttreat each NAME as a name reference and unset the variable itself\n\t\trather than the variable it references\n\nWithout options, unset first tries to unset a variable, and if that fails,\ntries to unset a function.\n\nSome variables cannot be unset; also see `readonly'.\n\nExit Status:\nReturns success unless an invalid option is given or a NAME is read-only.\n$END\n\n#define NEXT_VARIABLE()\tany_failed++; list = list->next; continue;\n\nint\nunset_builtin (list)\n  WORD_LIST *list;\n{\n  int unset_function, unset_variable, unset_array, opt, nameref, any_failed;\n  int global_unset_func, global_unset_var, vflags, base_vflags, valid_id;\n  char *name, *tname;\n\n  unset_function = unset_variable = unset_array = nameref = any_failed = 0;\n  global_unset_func = global_unset_var = 0;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"fnv\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'f':\n\t  global_unset_func = 1;\n\t  break;\n\tcase 'v':\n\t  global_unset_var = 1;\n\t  break;\n\tcase 'n':\n\t  nameref = 1;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  if (global_unset_func && global_unset_var)\n    {\n      builtin_error (_(\"cannot simultaneously unset a function and a variable\"));\n      return (EXECUTION_FAILURE);\n    }\n  else if (unset_function && nameref)\n    nameref = 0;\n\n#if defined (ARRAY_VARS)\n  base_vflags = assoc_expand_once ? VA_NOEXPAND : 0;\n#endif\n\n  while (list)\n    {\n      SHELL_VAR *var;\n      int tem;\n#if defined (ARRAY_VARS)\n      char *t;\n#endif\n\n      name = list->word->word;\n\n      unset_function = global_unset_func;\n      unset_variable = global_unset_var;\n\n#if defined (ARRAY_VARS)\n      vflags = builtin_arrayref_flags (list->word, base_vflags);\n#endif\n\n#if defined (ARRAY_VARS)\n      unset_array = 0;\n      /* XXX valid array reference second arg was 0 */\n      if (!unset_function && nameref == 0 && tokenize_array_reference (name, vflags, &t))\n\tunset_array = 1;\n#endif\n      /* Get error checking out of the way first.  The low-level functions\n\t just perform the unset, relying on the caller to verify. */\n      valid_id = legal_identifier (name);\n\n      /* Whether or not we are in posix mode, if neither -f nor -v appears,\n\t skip over trying to unset variables with invalid names and just\n\t treat them as potential shell function names. */\n      if (global_unset_func == 0 && global_unset_var == 0 && valid_id == 0)\n\t{\n\t  unset_variable = unset_array = 0;\n\t  unset_function = 1;\n\t}\n\n      /* Bash allows functions with names which are not valid identifiers\n\t to be created when not in posix mode, so check only when in posix\n\t mode when unsetting a function. */\n      if (unset_function == 0 && valid_id == 0)\n\t{\n\t  sh_invalidid (name);\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* Search for functions here if -f supplied or if NAME cannot be a\n\t variable name. */\n      var = unset_function ? find_function (name)\n\t\t\t   : (nameref ? find_variable_last_nameref (name, 0) : find_variable (name));\n\n      /* Some variables (but not functions yet) cannot be unset, period. */\n      if (var && unset_function == 0 && non_unsettable_p (var))\n\t{\n\t  builtin_error (_(\"%s: cannot unset\"), name);\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* if we have a nameref we want to use it */\n      if (var && unset_function == 0 && nameref == 0 && STREQ (name, name_cell(var)) == 0)\n\tname = name_cell (var);\n\n      /* Posix.2 says try variables first, then functions.  If we would\n\t find a function after unsuccessfully searching for a variable,\n\t note that we're acting on a function now as if -f were\n\t supplied.  The readonly check below takes care of it. */\n      if (var == 0 && nameref == 0 &&  unset_variable == 0 && unset_function == 0)\n\t{\n\t  if (var = find_function (name))\n\t    unset_function = 1;\n\t}\n\n      /* Posix.2 says that unsetting readonly variables is an error. */\n      if (var && readonly_p (var))\n\t{\n\t  builtin_error (_(\"%s: cannot unset: readonly %s\"),\n\t\t\t var->name, unset_function ? \"function\" : \"variable\");\n\t  NEXT_VARIABLE ();\n\t}\n\n      /* Unless the -f option is supplied, the name refers to a variable. */\n#if defined (ARRAY_VARS)\n      if (var && unset_array)\n\t{\n\t  if (shell_compatibility_level <= 51)\n\t    vflags |= VA_ALLOWALL;\n\n\t  /* Let unbind_array_element decide what to do with non-array vars */\n\t  tem = unbind_array_element (var, t, vflags);\t/* XXX new third arg */\n\t  if (tem == -2 && array_p (var) == 0 && assoc_p (var) == 0)\n\t    {\n\t      builtin_error (_(\"%s: not an array variable\"), var->name);\n\t      NEXT_VARIABLE ();\n\t    }\n\t  else if (tem < 0)\n\t    any_failed++;\n\t}\n      else\n#endif /* ARRAY_VARS */\n      /* If we're trying to unset a nameref variable whose value isn't a set\n\t variable, make sure we still try to unset the nameref's value */\n      if (var == 0 && nameref == 0 && unset_function == 0)\n\t{\n\t  var = find_variable_last_nameref (name, 0);\n\t  if (var && nameref_p (var))\n\t    {\n#if defined (ARRAY_VARS)\n\t      if (valid_array_reference (nameref_cell (var), 0))\n\t\t{\n\t\t  int len;\n\n\t\t  tname = savestring (nameref_cell (var));\n\t\t  if (var = array_variable_part (tname, 0, &t, &len))\n\t\t    {\n\t\t      /* change to what unbind_array_element now expects */\n\t\t      if (t[len - 1] == ']')\n\t\t\tt[len - 1] = 0;\n\t\t      tem = unbind_array_element (var, t, vflags);\t/* XXX new third arg */\n\t\t    }\n\t\t  free (tname);\n\t\t}\n\t      else\n#endif\n\t\ttem = unbind_variable (nameref_cell (var));\n\t    }\n\t  else\n\t    tem = unbind_variable (name);\n\t}\n      else\n\ttem = unset_function ? unbind_func (name) : (nameref ? unbind_nameref (name) : unbind_variable (name));\n\n      /* This is what Posix.2 says:  ``If neither -f nor -v\n\t is specified, the name refers to a variable; if a variable by\n\t that name does not exist, a function by that name, if any,\n\t shall be unset.'' */\n      if (tem == -1 && nameref == 0 && unset_function == 0 && unset_variable == 0)\n\ttem = unbind_func (name);\n\n      name = list->word->word;\t\t/* reset above for namerefs */\n\n      /* SUSv3, POSIX.1-2001 say:  ``Unsetting a variable or function that\n\t was not previously set shall not be considered an error.'' */\n\n      if (unset_function == 0)\n\tstupidly_hack_special_variables (name);\n\n      list = list->next;\n    }\n\n  return (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}