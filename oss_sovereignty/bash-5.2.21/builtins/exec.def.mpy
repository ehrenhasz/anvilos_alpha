{
  "module_name": "exec.def",
  "hash_id": "037917f6205f8792c51d69ba78a85927d079c89f319f7cd12276fa42254845e9",
  "original_prompt": "Ingested from bash-5.2.21/builtins/exec.def",
  "human_readable_source": "This file is exec.def, from which is created exec.c.\nIt implements the builtin \"exec\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES exec.c\n\n$BUILTIN exec\n$FUNCTION exec_builtin\n$SHORT_DOC exec [-cl] [-a name] [command [argument ...]] [redirection ...]\nReplace the shell with the given command.\n\nExecute COMMAND, replacing this shell with the specified program.\nARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,\nany redirections take effect in the current shell.\n\nOptions:\n  -a name\tpass NAME as the zeroth argument to COMMAND\n  -c\texecute COMMAND with an empty environment\n  -l\tplace a dash in the zeroth argument to COMMAND\n\nIf the command cannot be executed, a non-interactive shell exits, unless\nthe shell option `execfail' is set.\n\nExit Status:\nReturns success unless COMMAND is not found or a redirection error occurs.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n#include <signal.h>\n#include <errno.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../findcmd.h\"\n#if defined (JOB_CONTROL)\n#  include \"../jobs.h\"\n#endif\n#include \"../flags.h\"\n#include \"../trap.h\"\n#if defined (HISTORY)\n#  include \"../bashhist.h\"\n#endif\n#include \"common.h\"\n#include \"bashgetopt.h\"\n#include \"input.h\"\n\n/* Not all systems declare ERRNO in errno.h... and some systems #define it! */\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\nextern REDIRECT *redirection_undo_list;\nextern char *exec_argv0;\n\nint no_exit_on_failed_exec;\n\n/* If the user wants this to look like a login shell, then\n   prepend a `-' onto NAME and return the new name. */\nstatic char *\nmkdashname (name)\n     char *name;\n{\n  char *ret;\n\n  ret = (char *)xmalloc (2 + strlen (name));\n  ret[0] = '-';\n  strcpy (ret + 1, name);\n  return ret;\n}\n\nint\nexec_builtin (list)\n     WORD_LIST *list;\n{\n  int exit_value = EXECUTION_FAILURE;\n  int cleanenv, login, opt, orig_job_control;\n  char *argv0, *command, **args, **env, *newname, *com2;\n\n  cleanenv = login = orig_job_control = 0;\n  exec_argv0 = argv0 = (char *)NULL;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"cla:\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'c':\n\t  cleanenv = 1;\n\t  break;\n\tcase 'l':\n\t  login = 1;\n\t  break;\n\tcase 'a':\n\t  argv0 = list_optarg;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  /* First, let the redirections remain. */\n  dispose_redirects (redirection_undo_list);\n  redirection_undo_list = (REDIRECT *)NULL;\n\n  if (list == 0)\n    return (EXECUTION_SUCCESS);\n\n#if defined (RESTRICTED_SHELL)\n  if (restricted)\n    {\n      sh_restricted ((char *)NULL);\n      return (EXECUTION_FAILURE);\n    }\n#endif /* RESTRICTED_SHELL */\n\n  args = strvec_from_word_list (list, 1, 0, (int *)NULL);\n  env = (char **)0;\n\n  /* A command with a slash anywhere in its name is not looked up in $PATH. */\n  command = absolute_program (args[0]) ? args[0] : search_for_command (args[0], 1);\n\n  if (command == 0)\n    {\n      if (file_isdir (args[0]))\n\t{\n#if defined (EISDIR)\n\t  builtin_error (_(\"%s: cannot execute: %s\"), args[0], strerror (EISDIR));\n#else\n\t  builtin_error (_(\"%s: cannot execute: %s\"), args[0], strerror (errno));\n#endif\n\t  exit_value = EX_NOEXEC;\n\t}\n      else\n\t{\n\t  sh_notfound (args[0]);\n\t  exit_value = EX_NOTFOUND;\t/* As per Posix.2, 3.14.6 */\n\t}\n      goto failed_exec;\n    }\n\n  com2 = full_pathname (command);\n  if (com2)\n    {\n      if (command != args[0])\n\tfree (command);\n      command = com2;\n    }\n\n  if (argv0)\n    {\n      free (args[0]);\n      args[0] = login ? mkdashname (argv0) : savestring (argv0);\n      exec_argv0 = savestring (args[0]);\n    }\n  else if (login)\n    {\n      newname = mkdashname (args[0]);\n      free (args[0]);\n      args[0] = newname;\n    }\n\n  /* Decrement SHLVL by 1 so a new shell started here has the same value,\n     preserving the appearance.  After we do that, we need to change the\n     exported environment to include the new value.  If we've already forked\n     and are in a subshell, we don't want to decrement the shell level,\n     since we are `increasing' the level */\n\n  if (cleanenv == 0 && (subshell_environment & SUBSHELL_PAREN) == 0)\n    adjust_shell_level (-1);\n\n  if (cleanenv)\n    {\n      env = strvec_create (1);\n      env[0] = (char *)0;\n    }\n  else\n    {\t\n      maybe_make_export_env ();\n      env = export_env;\n    }\n\n#if defined (HISTORY)\n  if (interactive_shell && subshell_environment == 0)\n    maybe_save_shell_history ();\n#endif /* HISTORY */\n\n  reset_signal_handlers ();\t\t/* leave trap strings in place */\n\n#if defined (JOB_CONTROL)\n  orig_job_control = job_control;\t/* XXX - was also interactive_shell */\n  if (subshell_environment == 0)\n    end_job_control ();\n  if (interactive || job_control)\n    default_tty_job_signals ();\t\t/* undo initialize_job_signals */\n#endif /* JOB_CONTROL */\n\n#if defined (BUFFERED_INPUT)\n  if (default_buffered_input >= 0)\n    sync_buffered_stream (default_buffered_input);\n#endif\n\n  exit_value = shell_execve (command, args, env);\n\n  /* We have to set this to NULL because shell_execve has called realloc()\n     to stuff more items at the front of the array, which may have caused\n     the memory to be freed by realloc().  We don't want to free it twice. */\n  args = (char **)NULL;\n  if (cleanenv == 0)\n    adjust_shell_level (1);\n\n  if (exit_value == EX_NOTFOUND)\t/* no duplicate error message */\n    goto failed_exec;\n  else if (executable_file (command) == 0)\n    {\n      builtin_error (_(\"%s: cannot execute: %s\"), command, strerror (errno));\n      exit_value = EX_NOEXEC;\t/* As per Posix.2, 3.14.6 */\n    }\n  else\n    file_error (command);\n\nfailed_exec:\n  FREE (command);\n\n  if (subshell_environment || (interactive == 0 && no_exit_on_failed_exec == 0))\n    exit_shell (last_command_exit_value = exit_value);\n\n  if (args)\n    strvec_dispose (args);\n\n  if (env && env != export_env)\n    strvec_dispose (env);\n\n  /* If we're not exiting after the exec fails, we restore the shell signal\n     handlers and then modify the signal dispositions based on the trap strings\n     before the failed exec. */\n  initialize_signals (1);\n  restore_traps ();\n\n#if defined (JOB_CONTROL)\n  if (orig_job_control)\n    restart_job_control ();\n#endif /* JOB_CONTROL */\n\n  return (exit_value);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}