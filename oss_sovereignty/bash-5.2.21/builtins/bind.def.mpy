{
  "module_name": "bind.def",
  "hash_id": "4c9fd0e1c1f7f3660b0be44cd83485aa8da8c7ff4bb369fd456d80b9baf5175f",
  "original_prompt": "Ingested from bash-5.2.21/builtins/bind.def",
  "human_readable_source": "This file is bind.def, from which is created bind.c.\nIt implements the builtin \"bind\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES bind.c\n\n#include <config.h>\n\n$BUILTIN bind\n$DEPENDS_ON READLINE\n$FUNCTION bind_builtin\n$SHORT_DOC bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-command]\nSet Readline key bindings and variables.\n\nBind a key sequence to a Readline function or a macro, or set a\nReadline variable.  The non-option argument syntax is equivalent to\nthat found in ~/.inputrc, but must be passed as a single argument:\ne.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n\nOptions:\n  -m  keymap         Use KEYMAP as the keymap for the duration of this\n                     command.  Acceptable keymap names are emacs,\n                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n                     vi-command, and vi-insert.\n  -l                 List names of functions.\n  -P                 List function names and bindings.\n  -p                 List functions and bindings in a form that can be\n                     reused as input.\n  -S                 List key sequences that invoke macros and their values\n  -s                 List key sequences that invoke macros and their values\n                     in a form that can be reused as input.\n  -V                 List variable names and values\n  -v                 List variable names and values in a form that can\n                     be reused as input.\n  -q  function-name  Query about which keys invoke the named function.\n  -u  function-name  Unbind all keys which are bound to the named function.\n  -r  keyseq         Remove the binding for KEYSEQ.\n  -f  filename       Read key bindings from FILENAME.\n  -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n\t\t\t\tKEYSEQ is entered.\n  -X                 List key sequences bound with -x and associated commands\n                     in a form that can be reused as input.\n\nExit Status:\nbind returns 0 unless an unrecognized option is given or an error occurs.\n$END\n\n#if defined (READLINE)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <errno.h>\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\n#include <readline/readline.h>\n#include <readline/history.h>\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../bashline.h\"\n#include \"bashgetopt.h\"\n#include \"common.h\"\n\nstatic int query_bindings PARAMS((char *));\nstatic int unbind_command PARAMS((char *));\nstatic int unbind_keyseq PARAMS((char *));\n\n#define BIND_RETURN(x)  do { return_code = x; goto bind_exit; } while (0)\n\n#define LFLAG\t0x0001\n#define PFLAG\t0x0002\n#define FFLAG\t0x0004\n#define VFLAG\t0x0008\n#define QFLAG\t0x0010\n#define MFLAG\t0x0020\n#define RFLAG\t0x0040\n#define PPFLAG\t0x0080\n#define VVFLAG\t0x0100\n#define SFLAG   0x0200\n#define SSFLAG  0x0400\n#define UFLAG\t0x0800\n#define XFLAG\t0x1000\n#define XXFLAG\t0x2000\n\nint\nbind_builtin (list)\n     WORD_LIST *list;\n{\n  int return_code;\n  Keymap kmap, saved_keymap;\n  int flags, opt;\n  char *initfile, *map_name, *fun_name, *unbind_name, *remove_seq, *cmd_seq, *t;\n\n  if (no_line_editing)\n    {\n#if 0\n      builtin_error (_(\"line editing not enabled\"));\n      return (EXECUTION_FAILURE);\n#else\n      builtin_warning (_(\"line editing not enabled\"));\n#endif\n    }\n\n  kmap = saved_keymap = (Keymap) NULL;\n  flags = 0;\n  initfile = map_name = fun_name = unbind_name = remove_seq = cmd_seq = (char *)NULL;\n  return_code = EXECUTION_SUCCESS;\n\n  if (bash_readline_initialized == 0)\n    initialize_readline ();\n\n  begin_unwind_frame (\"bind_builtin\");\n  unwind_protect_var (rl_outstream);\n\n  rl_outstream = stdout;\n\n  reset_internal_getopt ();  \n  while ((opt = internal_getopt (list, \"lvpVPsSXf:q:u:m:r:x:\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'l':\n\t  flags |= LFLAG;\n\t  break;\n\tcase 'v':\n\t  flags |= VFLAG;\n\t  break;\n\tcase 'p':\n\t  flags |= PFLAG;\n\t  break;\n\tcase 'f':\n\t  flags |= FFLAG;\n\t  initfile = list_optarg;\n\t  break;\n\tcase 'm':\n\t  flags |= MFLAG;\n\t  map_name = list_optarg;\n\t  break;\n\tcase 'q':\n\t  flags |= QFLAG;\n\t  fun_name = list_optarg;\n\t  break;\n\tcase 'u':\n\t  flags |= UFLAG;\n\t  unbind_name = list_optarg;\n\t  break;\n\tcase 'r':\n\t  flags |= RFLAG;\n\t  remove_seq = list_optarg;\n\t  break;\n\tcase 'V':\n\t  flags |= VVFLAG;\n\t  break;\n\tcase 'P':\n\t  flags |= PPFLAG;\n\t  break;\n\tcase 's':\n\t  flags |= SFLAG;\n\t  break;\n\tcase 'S':\n\t  flags |= SSFLAG;\n\t  break;\n\tcase 'x':\n\t  flags |= XFLAG;\n\t  cmd_seq = list_optarg;\n\t  break;\n\tcase 'X':\n\t  flags |= XXFLAG;\n\t  break;\n\tcase GETOPT_HELP:\n\tdefault:\n\t  builtin_usage ();\n\t  BIND_RETURN (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  /* First, see if we need to install a special keymap for this\n     command.  Then start on the arguments. */\n\n  if ((flags & MFLAG) && map_name)\n    {\n      kmap = rl_get_keymap_by_name (map_name);\n      if (kmap == 0)\n\t{\n\t  builtin_error (_(\"`%s': invalid keymap name\"), map_name);\n\t  BIND_RETURN (EXECUTION_FAILURE);\n\t}\n    }\n\n  if (kmap)\n    {\n      saved_keymap = rl_get_keymap ();\n      rl_set_keymap (kmap);\n    }\n\n  /* XXX - we need to add exclusive use tests here.  It doesn't make sense\n     to use some of these options together. */\n  /* Now hack the option arguments */\n  if (flags & LFLAG)\n    rl_list_funmap_names ();\n\n  if (flags & PFLAG)\n    rl_function_dumper (1);\n\n  if (flags & PPFLAG)\n    rl_function_dumper (0);\n\n  if (flags & SFLAG)\n    rl_macro_dumper (1);\n\n  if (flags & SSFLAG)\n    rl_macro_dumper (0);\n\n  if (flags & VFLAG)\n    rl_variable_dumper (1);\n\n  if (flags & VVFLAG)\n    rl_variable_dumper (0);\n\n  if ((flags & FFLAG) && initfile)\n    {\n      if (rl_read_init_file (initfile) != 0)\n\t{\n\t  t = printable_filename (initfile, 0);\n\t  builtin_error (_(\"%s: cannot read: %s\"), t, strerror (errno));\n\t  if (t != initfile)\n\t    free (t);\n\t  BIND_RETURN (EXECUTION_FAILURE);\n\t}\n    }\n\n  if ((flags & QFLAG) && fun_name)\n    return_code = query_bindings (fun_name);\n\n  if ((flags & UFLAG) && unbind_name)\n    return_code = unbind_command (unbind_name);\n\n  if ((flags & RFLAG) && remove_seq)\n    {\n      opt = unbind_keyseq (remove_seq);\n      BIND_RETURN (opt);\n    }\n\n  if (flags & XFLAG)\n    return_code = bind_keyseq_to_unix_command (cmd_seq);\n\n  if (flags & XXFLAG)\n    return_code = print_unix_command_map ();\n\n  /* Process the rest of the arguments as binding specifications. */\n  while (list)\n    {\n      int olen, nlen, d, i;\n      char **obindings, **nbindings;\n\n      obindings = rl_invoking_keyseqs (bash_execute_unix_command);\n      olen = obindings ? strvec_len (obindings) : 0;\n\n      rl_parse_and_bind (list->word->word);\n\n      nbindings = rl_invoking_keyseqs (bash_execute_unix_command);\n      nlen = nbindings ? strvec_len (nbindings) : 0;\n\n      if (nlen < olen)\t/* fewer bind -x bindings */\n\tfor (d = olen - nlen, i = 0; i < olen && d > 0; i++)\n\t  if (nlen == 0 || strvec_search (nbindings, obindings[i]) < 0)\n\t    {\n\t      unbind_unix_command (obindings[i]);\n\t      d--;\n\t    }\n\n      strvec_dispose (obindings);\n      strvec_dispose (nbindings);\n\n      list = list->next;\n    }\n\n bind_exit:\n  if (saved_keymap)\n    rl_set_keymap (saved_keymap);\n\n  run_unwind_frame (\"bind_builtin\");\n\n  if (return_code < 0)\n    return_code = EXECUTION_FAILURE;\n\n  return (sh_chkwrite (return_code));\n}\n\nstatic int\nquery_bindings (name)\n     char *name;\n{\n  rl_command_func_t *function;\n  char **keyseqs;\n  int j;\n\n  function = rl_named_function (name);\n  if (function == 0)\n    {\n      builtin_error (_(\"`%s': unknown function name\"), name);\n      return EXECUTION_FAILURE;\n    }\n\n  keyseqs = rl_invoking_keyseqs (function);\n\n  if (!keyseqs)\n    {\n      printf (_(\"%s is not bound to any keys.\\n\"), name);\n      return EXECUTION_FAILURE;\n    }\n\n  printf (_(\"%s can be invoked via \"), name);\n  for (j = 0; j < 5 && keyseqs[j]; j++)\n    printf (\"\\\"%s\\\"%s\", keyseqs[j], keyseqs[j + 1] ? \", \" : \".\\n\");\n  if (keyseqs[j])\n    printf (\"...\\n\");\n  strvec_dispose (keyseqs);\n  return EXECUTION_SUCCESS;\n}\n\nstatic int\nunbind_command (name)\n     char *name;\n{\n  rl_command_func_t *function;\n\n  function = rl_named_function (name);\n  if (function == 0)\n    {\n      builtin_error (_(\"`%s': unknown function name\"), name);\n      return EXECUTION_FAILURE;\n    }\n\n  rl_unbind_function_in_map (function, rl_get_keymap ());\n  return EXECUTION_SUCCESS;\n}\n\nstatic int\nunbind_keyseq (seq)\n     char *seq;\n{\n  char *kseq;\n  int kslen, type;\n  rl_command_func_t *f;\n\n  kseq = (char *)xmalloc ((2 * strlen (seq)) + 1);\n  if (rl_translate_keyseq (seq, kseq, &kslen))\n    {\n      free (kseq);\n      builtin_error (_(\"`%s': cannot unbind\"), seq);\n      return EXECUTION_FAILURE;\n    }\n  if ((f = rl_function_of_keyseq_len (kseq, kslen, (Keymap)0, &type)) == 0)\n    {\n      free (kseq);\n      return (EXECUTION_SUCCESS);\n    }\n  if (type == ISKMAP)\n    f = ((Keymap) f)[ANYOTHERKEY].function;\n\n  /* I wish this didn't have to translate the key sequence again, but readline\n     doesn't have a binding function that takes a translated key sequence as\n     an argument. */\n  if (rl_bind_keyseq (seq, (rl_command_func_t *)NULL) != 0)\n    {\n      free (kseq);\n      builtin_error (_(\"`%s': cannot unbind\"), seq);\n      return (EXECUTION_FAILURE);\n    }\n\n  if (f == bash_execute_unix_command)\n    unbind_unix_command (seq);\n\n  free (kseq);\n  return (EXECUTION_SUCCESS);\n}\n#endif /* READLINE */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}