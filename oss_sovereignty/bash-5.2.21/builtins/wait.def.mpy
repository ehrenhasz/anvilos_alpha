{
  "module_name": "wait.def",
  "hash_id": "0c310ebc604773c0a21a0fa4795c985f78a53aa3b00fe06883dceb9b86d45fd1",
  "original_prompt": "Ingested from bash-5.2.21/builtins/wait.def",
  "human_readable_source": "'This file is wait.def, from which is created wait.c.\nIt implements the builtin \"wait\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$BUILTIN wait\n$FUNCTION wait_builtin\n$DEPENDS_ON JOB_CONTROL\n$PRODUCES wait.c\n$SHORT_DOC wait [-fn] [-p var] [id ...]\nWait for job completion and return exit status.\n\nWaits for each process identified by an ID, which may be a process ID or a\njob specification, and reports its termination status.  If ID is not\ngiven, waits for all currently active child processes, and the return\nstatus is zero.  If ID is a job specification, waits for all processes\nin that job's pipeline.\n\nIf the -n option is supplied, waits for a single job from the list of IDs,\nor, if no IDs are supplied, for the next job to complete and returns its\nexit status.\n\nIf the -p option is supplied, the process or job identifier of the job\nfor which the exit status is returned is assigned to the variable VAR\nnamed by the option argument. The variable will be unset initially, before\nany assignment. This is useful only when the -n option is supplied.\n\nIf the -f option is supplied, and job control is enabled, waits for the\nspecified ID to terminate, instead of waiting for it to change status.\n\nExit Status:\nReturns the status of the last ID; fails if ID is invalid or an invalid\noption is given, or if -n is supplied and the shell has no unwaited-for\nchildren.\n$END\n\n$BUILTIN wait\n$FUNCTION wait_builtin\n$DEPENDS_ON !JOB_CONTROL\n$SHORT_DOC wait [pid ...]\nWait for process completion and return exit status.\n\nWaits for each process specified by a PID and reports its termination status.\nIf PID is not given, waits for all currently active child processes,\nand the return status is zero.  PID must be a process ID.\n\nExit Status:\nReturns the status of the last PID; fails if PID is invalid or an invalid\noption is given.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include <signal.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <chartypes.h>\n\n#include \"../bashansi.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../jobs.h\"\n#include \"../trap.h\"\n#include \"../sig.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\nextern int wait_signal_received;\n\nprocenv_t wait_intr_buf;\nint wait_intr_flag;\n\nstatic int set_waitlist PARAMS((WORD_LIST *));\nstatic void unset_waitlist PARAMS((void));\n\n/* Wait for the pid in LIST to stop or die.  If no arguments are given, then\n   wait for all of the active background processes of the shell and return\n   0.  If a list of pids or job specs are given, return the exit status of\n   the last one waited for. */\n\n#define WAIT_RETURN(s) \\\n  do \\\n    { \\\n      wait_signal_received = 0; \\\n      wait_intr_flag = 0; \\\n      return (s);\\\n    } \\\n  while (0)\n\nint\nwait_builtin (list)\n     WORD_LIST *list;\n{\n  int status, code, opt, nflag, vflags, bindflags;\n  volatile int wflags;\n  char *vname;\n  SHELL_VAR *pidvar;\n  struct procstat pstat;\n\n  USE_VAR(list);\n\n  nflag = wflags = vflags = 0;\n  vname = NULL;\n  pidvar = (SHELL_VAR *)NULL;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"fnp:\")) != -1)\n    {\n      switch (opt)\n\t{\n#if defined (JOB_CONTROL)\n\tcase 'n':\n\t  nflag = 1;\n\t  break;\n\tcase 'f':\n\t  wflags |= JWAIT_FORCE;\n\t  break;\n\tcase 'p':\n\t  vname = list_optarg;\n\t  vflags = list_optflags;\t  \n\t  break;\t\n#endif\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  /* Sanity-check variable name if -p supplied. */\n  if (vname)\n    {\n#if defined (ARRAY_VARS)\n      int arrayflags;\n\n      SET_VFLAGS (vflags, arrayflags, bindflags);\n      if (legal_identifier (vname) == 0 && valid_array_reference (vname, arrayflags) == 0)\n#else\n      bindflags = 0;\n      if (legal_identifier (vname) == 0)\n#endif\n\t{\n\t  sh_invalidid (vname);\n\t  WAIT_RETURN (EXECUTION_FAILURE);\n\t}\n      if (builtin_unbind_variable (vname) == -2)\n\tWAIT_RETURN (EXECUTION_FAILURE);\n    }\n\n  /* POSIX.2 says:  When the shell is waiting (by means of the wait utility)\n     for asynchronous commands to complete, the reception of a signal for\n     which a trap has been set shall cause the wait utility to return\n     immediately with an exit status greater than 128, after which the trap\n     associated with the signal shall be taken.\n\n     We handle SIGINT here; it's the only one that needs to be treated\n     specially (I think), since it's handled specially in {no,}jobs.c. */\n  wait_intr_flag = 1;\n  code = setjmp_sigs (wait_intr_buf);\n\n  if (code)\n    {\n      last_command_exit_signal = wait_signal_received;\n      status = 128 + wait_signal_received;\n      wait_sigint_cleanup ();\n#if defined (JOB_CONTROL)\n      if (wflags & JWAIT_WAITING)\n\tunset_waitlist ();\n#endif\n      WAIT_RETURN (status);\n    }\n\n  opt = first_pending_trap ();\n#if defined (SIGCHLD)\n  /* We special case SIGCHLD when not in posix mode because we don't break\n     out of the wait even when the signal is trapped; we run the trap after\n     the wait completes. See how it's handled in jobs.c:waitchld(). */\n  if (opt == SIGCHLD && posixly_correct == 0)\n    opt = next_pending_trap (opt+1);\n#endif\n  if (opt != -1)\n    {\n      last_command_exit_signal = wait_signal_received = opt;\n      status = opt + 128;\n      WAIT_RETURN (status);\n    }\n\n  /* We support jobs or pids.\n     wait <pid-or-job> [pid-or-job ...] */\n\n#if defined (JOB_CONTROL)\n  if (nflag)\n    {\n      if (list)\n\t{\n\t  opt = set_waitlist (list);\n\t  if (opt == 0)\n\t    WAIT_RETURN (127);\n\t  wflags |= JWAIT_WAITING;\n\t}\n\n      status = wait_for_any_job (wflags, &pstat);\n      if (vname && status >= 0)\n\tbuiltin_bind_var_to_int (vname, pstat.pid, bindflags);\n\n      if (status < 0)\n\tstatus = 127;\n      if (list)\n\tunset_waitlist ();\n      WAIT_RETURN (status);\n    }\n#endif\n      \n  /* But wait without any arguments means to wait for all of the shell's\n     currently active background processes. */\n  if (list == 0)\n    {\n      opt = wait_for_background_pids (&pstat);\n#if 0\n      /* Compatibility with NetBSD sh: don't set VNAME since it doesn't\n\t correspond to the return status. */\n      if (vname && opt)\n\tbuiltin_bind_var_to_int (vname, pstat.pid, bindflags);\n#endif\n      WAIT_RETURN (EXECUTION_SUCCESS);\n    }\n\n  status = EXECUTION_SUCCESS;\n  while (list)\n    {\n      pid_t pid;\n      char *w;\n      intmax_t pid_value;\n\n      w = list->word->word;\n      if (DIGIT (*w))\n\t{\n\t  if (legal_number (w, &pid_value) && pid_value == (pid_t)pid_value)\n\t    {\n\t      pid = (pid_t)pid_value;\n\t      status = wait_for_single_pid (pid, wflags|JWAIT_PERROR);\n\t      /* status > 256 means pid error */\n\t      pstat.pid = (status > 256) ? NO_PID : pid;\n\t      pstat.status = (status > 256) ? 127 : status;\n\t      if (status > 256)\n\t\tstatus = 127;\n\t    }\n\t  else\n\t    {\n\t      sh_badpid (w);\n\t      pstat.pid = NO_PID;\n\t      pstat.status = 127;\n\t      WAIT_RETURN (EXECUTION_FAILURE);\n\t    }\n\t}\n#if defined (JOB_CONTROL)\n      else if (*w && *w == '%')\n\t/* Must be a job spec.  Check it out. */\n\t{\n\t  int job;\n\t  sigset_t set, oset;\n\n\t  BLOCK_CHILD (set, oset);\n\t  job = get_job_spec (list);\n\n\t  if (INVALID_JOB (job))\n\t    {\n\t      if (job != DUP_JOB)\n\t\tsh_badjob (list->word->word);\n\t      UNBLOCK_CHILD (oset);\n\t      status = 127;\t/* As per Posix.2, section 4.70.2 */\n\t      pstat.pid = NO_PID;\n\t      pstat.status = status;\n\t      list = list->next;\n\t      continue;\n\t    }\n\n\t  /* Job spec used.  Wait for the last pid in the pipeline. */\n\t  UNBLOCK_CHILD (oset);\n\t  status = wait_for_job (job, wflags, &pstat);\n\t}\n#endif /* JOB_CONTROL */\n      else\n\t{\n\t  sh_badpid (w);\n\t  pstat.pid = NO_PID;\n\t  pstat.status = 127;\n\t  status = EXECUTION_FAILURE;\n\t}\n\n      /* Don't waste time with a longjmp. */\n      if (wait_signal_received)\n\t{\n\t  last_command_exit_signal = wait_signal_received;\n\t  status = 128 + wait_signal_received;\n\t  wait_sigint_cleanup ();\n\t  WAIT_RETURN (status);\n\t}\n\n      list = list->next;\n    }\n\n  if (vname && pstat.pid != NO_PID)\n    builtin_bind_var_to_int (vname, pstat.pid, bindflags);\n\n  WAIT_RETURN (status);\n}\n\n#if defined (JOB_CONTROL)\n/* Take each valid pid or jobspec in LIST and mark the corresponding job as\n   J_WAITING, so wait -n knows which jobs to wait for. Return the number of\n   jobs we found. */\nstatic int\nset_waitlist (list)\n     WORD_LIST *list;\n{\n  sigset_t set, oset;\n  int job, r, njob;\n  intmax_t pid;\n  WORD_LIST *l;\n\n  BLOCK_CHILD (set, oset);\n  njob = 0;\n  for (l = list; l; l = l->next)\n    {\n      job = NO_JOB;\n      job = (l && legal_number (l->word->word, &pid) && pid == (pid_t) pid)\n\t\t? get_job_by_pid ((pid_t) pid, 0, 0)\n\t\t: get_job_spec (l);\n      if (job == NO_JOB || jobs == 0 || INVALID_JOB (job))\n\t{\n\t  sh_badjob (l->word->word);\n\t  continue;\n\t}\n      /* We don't check yet to see if one of the desired jobs has already\n\t terminated, but we could. We wait until wait_for_any_job(). This\n\t has the advantage of validating all the arguments. */\n      if ((jobs[job]->flags & J_WAITING) == 0)\n\t{\n\t  njob++;\n\t  jobs[job]->flags |= J_WAITING;\n\t}\n    }\n  UNBLOCK_CHILD (oset);\n  return (njob);\n}\n\n/* Clean up after a call to wait -n jobs */\nstatic void\nunset_waitlist ()\n{\n  int i;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  for (i = 0; i < js.j_jobslots; i++)\n    if (jobs[i] && (jobs[i]->flags & J_WAITING))\n      jobs[i]->flags &= ~J_WAITING;\n  UNBLOCK_CHILD (oset);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}