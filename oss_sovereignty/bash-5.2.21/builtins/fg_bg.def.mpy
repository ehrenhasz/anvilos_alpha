{
  "module_name": "fg_bg.def",
  "hash_id": "32153aecbfda2ba5c754ad6f24bea05b32659cd3258c5dfc2bc472403c402a30",
  "original_prompt": "Ingested from bash-5.2.21/builtins/fg_bg.def",
  "human_readable_source": "This file is fg_bg.def, from which is created fg_bg.c.\nIt implements the builtins \"bg\" and \"fg\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES fg_bg.c\n\n$BUILTIN fg\n$FUNCTION fg_builtin\n$DEPENDS_ON JOB_CONTROL\n$SHORT_DOC fg [job_spec]\nMove job to the foreground.\n\nPlace the job identified by JOB_SPEC in the foreground, making it the\ncurrent job.  If JOB_SPEC is not present, the shell's notion of the\ncurrent job is used.\n\nExit Status:\nStatus of command placed in foreground, or failure if an error occurs.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include <signal.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../jobs.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#if defined (JOB_CONTROL)\nstatic int fg_bg PARAMS((WORD_LIST *, int));\n\n/* How to bring a job into the foreground. */\nint\nfg_builtin (list)\n     WORD_LIST *list;\n{\n  int fg_bit;\n  register WORD_LIST *t;\n\n  CHECK_HELPOPT (list);\n\n  if (job_control == 0)\n    {\n      sh_nojobs ((char *)NULL);\n      return (EXECUTION_FAILURE);\n    }\n\n  if (no_options (list))\n    return (EX_USAGE);\n  list = loptend;\n\n  /* If the last arg on the line is '&', then start this job in the\n     background.  Else, fg the job. */\n  for (t = list; t && t->next; t = t->next)\n    ;\n  fg_bit = (t && t->word->word[0] == '&' && t->word->word[1] == '\\0') == 0;\n\n  return (fg_bg (list, fg_bit));\n}\n#endif /* JOB_CONTROL */\n\n$BUILTIN bg\n$FUNCTION bg_builtin\n$DEPENDS_ON JOB_CONTROL\n$SHORT_DOC bg [job_spec ...]\nMove jobs to the background.\n\nPlace the jobs identified by each JOB_SPEC in the background, as if they\nhad been started with `&'.  If JOB_SPEC is not present, the shell's notion\nof the current job is used.\n\nExit Status:\nReturns success unless job control is not enabled or an error occurs.\n$END\n\n#if defined (JOB_CONTROL)\n/* How to put a job into the background. */\nint\nbg_builtin (list)\n     WORD_LIST *list;\n{\n  int r;\n\n  CHECK_HELPOPT (list);\n\n  if (job_control == 0)\n    {\n      sh_nojobs ((char *)NULL);\n      return (EXECUTION_FAILURE);\n    }\n\n  if (no_options (list))\n    return (EX_USAGE);\n  list = loptend;\n\n  /* This relies on the fact that fg_bg() takes a WORD_LIST *, but only acts\n     on the first member (if any) of that list. */\n  r = EXECUTION_SUCCESS;\n  do\n    {\n      if (fg_bg (list, 0) == EXECUTION_FAILURE)\n\tr = EXECUTION_FAILURE;\n      if (list)\n\tlist = list->next;\n    }\n  while (list);\n\n  return r;\n}\n\n/* How to put a job into the foreground/background. */\nstatic int\nfg_bg (list, foreground)\n     WORD_LIST *list;\n     int foreground;\n{\n  sigset_t set, oset;\n  int job, status, old_async_pid;\n  JOB *j;\n\n  BLOCK_CHILD (set, oset);\n  job = get_job_spec (list);\n\n  if (INVALID_JOB (job))\n    {\n      if (job != DUP_JOB)\n\tsh_badjob (list ? list->word->word : _(\"current\"));\n\n      goto failure;\n    }\n\n  j = get_job_by_jid (job);\n  /* Or if j->pgrp == shell_pgrp. */\n  if (IS_JOBCONTROL (job) == 0)\n    {\n      builtin_error (_(\"job %d started without job control\"), job + 1);\n      goto failure;\n    }\n\n  if (foreground == 0)\n    {\n      old_async_pid = last_asynchronous_pid;\n      last_asynchronous_pid = j->pgrp;\t/* As per Posix.2 5.4.2 */\n    }\n\n  status = start_job (job, foreground);\n\n  if (status >= 0)\n    {\n    /* win: */\n      UNBLOCK_CHILD (oset);\n      return (foreground ? status : EXECUTION_SUCCESS);\n    }\n  else\n    {\n      if (foreground == 0)\n\tlast_asynchronous_pid = old_async_pid;\n\n    failure:\n      UNBLOCK_CHILD (oset);\n      return (EXECUTION_FAILURE);\n    }\n}\n#endif /* JOB_CONTROL */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}