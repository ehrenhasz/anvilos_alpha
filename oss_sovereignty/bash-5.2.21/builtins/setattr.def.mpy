{
  "module_name": "setattr.def",
  "hash_id": "3b62c1810dce0b7dea5550ed9cb3a5aef3362678ac762b3a787c58d1a247bba0",
  "original_prompt": "Ingested from bash-5.2.21/builtins/setattr.def",
  "human_readable_source": "This file is setattr.def, from which is created setattr.c.\nIt implements the builtins \"export\" and \"readonly\", in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES setattr.c\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../flags.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\nextern sh_builtin_func_t *this_shell_builtin;\n\n#ifdef ARRAY_VARS\nextern int declare_builtin PARAMS((WORD_LIST *));\n#endif\n\n#define READONLY_OR_EXPORT \\\n  (this_shell_builtin == readonly_builtin || this_shell_builtin == export_builtin)\n\n$BUILTIN export\n$FUNCTION export_builtin\n$SHORT_DOC export [-fn] [name[=value] ...] or export -p\nSet export attribute for shell variables.\n\nMarks each NAME for automatic export to the environment of subsequently\nexecuted commands.  If VALUE is supplied, assign VALUE before exporting.\n\nOptions:\n  -f\trefer to shell functions\n  -n\tremove the export property from each NAME\n  -p\tdisplay a list of all exported variables and functions\n\nAn argument of `--' disables further option processing.\n\nExit Status:\nReturns success unless an invalid option is given or NAME is invalid.\n$END\n\n/* For each variable name in LIST, make that variable appear in the\n   environment passed to simple commands.  If there is no LIST, then\n   print all such variables.  An argument of `-n' says to remove the\n   exported attribute from variables named in LIST.  An argument of\n  -f indicates that the names present in LIST refer to functions. */\nint\nexport_builtin (list)\n     register WORD_LIST *list;\n{\n  return (set_or_show_attributes (list, att_exported, 0));\n}\n\n$BUILTIN readonly\n$FUNCTION readonly_builtin\n$SHORT_DOC readonly [-aAf] [name[=value] ...] or readonly -p\nMark shell variables as unchangeable.\n\nMark each NAME as read-only; the values of these NAMEs may not be\nchanged by subsequent assignment.  If VALUE is supplied, assign VALUE\nbefore marking as read-only.\n\nOptions:\n  -a\trefer to indexed array variables\n  -A\trefer to associative array variables\n  -f\trefer to shell functions\n  -p\tdisplay a list of all readonly variables or functions,\n\t\tdepending on whether or not the -f option is given\n\nAn argument of `--' disables further option processing.\n\nExit Status:\nReturns success unless an invalid option is given or NAME is invalid.\n$END\n\n/* For each variable name in LIST, make that variable readonly.  Given an\n   empty LIST, print out all existing readonly variables. */\nint\nreadonly_builtin (list)\n     register WORD_LIST *list;\n{\n  return (set_or_show_attributes (list, att_readonly, 0));\n}\n\n#if defined (ARRAY_VARS)\n#  define ATTROPTS\t\"aAfnp\"\n#else\n#  define ATTROPTS\t\"fnp\"\n#endif\n\n/* For each variable name in LIST, make that variable have the specified\n   ATTRIBUTE.  An arg of `-n' says to remove the attribute from the the\n   remaining names in LIST (doesn't work for readonly). */\nint\nset_or_show_attributes (list, attribute, nodefs)\n     register WORD_LIST *list;\n     int attribute, nodefs;\n{\n  register SHELL_VAR *var;\n  int assign, undo, any_failed, assign_error, opt;\n  int functions_only, arrays_only, assoc_only;\n  int aflags;\n  char *name;\n#if defined (ARRAY_VARS)\n  WORD_LIST *nlist, *tlist;\n  WORD_DESC *w;\n  char optw[8];\n  int opti;\n#endif\n\n  functions_only = arrays_only = assoc_only = 0;\n  undo = any_failed = assign_error = 0;\n  /* Read arguments from the front of the list. */\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, ATTROPTS)) != -1)\n    {\n      switch (opt)\n\t{\n\t  case 'n':\n\t    undo = 1;\n\t    break;\n\t  case 'f':\n\t    functions_only = 1;\n\t    break;\n#if defined (ARRAY_VARS)\n\t  case 'a':\n\t    arrays_only = 1;\n\t    break;\n\t  case 'A':\n\t    assoc_only = 1;\n\t    break;\n#endif\n\t  case 'p':\n\t    break;\n\t  CASE_HELPOPT;\n\t  default:\n\t    builtin_usage ();\n\t    return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  if (list)\n    {\n      if (attribute & att_exported)\n\tarray_needs_making = 1;\n\n      /* Cannot undo readonly status, silently disallowed. */\n      if (undo && (attribute & att_readonly))\n\tattribute &= ~att_readonly;\n\n      while (list)\n\t{\n\t  name = list->word->word;\n\n\t  if (functions_only)\t\t/* xxx -f name */\n\t    {\n\t      var = find_function (name);\n\t      if (var == 0)\n\t\t{\n\t\t  builtin_error (_(\"%s: not a function\"), name);\n\t\t  any_failed++;\n\t\t}\n\t      else if ((attribute & att_exported) && undo == 0 && exportable_function_name (name) == 0)\n\t\t{\n\t\t  builtin_error (_(\"%s: cannot export\"), name);\n\t\t  any_failed++;\n\t\t}\n\t      else\n\t\tSETVARATTR (var, attribute, undo);\n\n\t      list = list->next;\n\t      continue;\n\t    }\n\n\t  /* xxx [-np] name[=value] */\n\t  assign = assignment (name, 0);\n\n\t  aflags = 0;\n\t  if (assign)\n\t    {\n\t      name[assign] = '\\0';\n\t      if (name[assign - 1] == '+')\n\t\t{\n\t\t  aflags |= ASS_APPEND;\n\t\t  name[assign - 1] = '\\0';\n\t\t}\n\t    }\n\n\t  if (legal_identifier (name) == 0)\n\t    {\n\t      sh_invalidid (name);\n\t      if (assign)\n\t\tassign_error++;\n\t      else\n\t\tany_failed++;\n\t      list = list->next;\n\t      continue;\n\t    }\n\n\t  if (assign)\t/* xxx [-np] name=value */\n\t    {\n\t      name[assign] = '=';\n\t      if (aflags & ASS_APPEND)\n\t\tname[assign - 1] = '+';\n#if defined (ARRAY_VARS)\n\t      /* Let's try something here.  Turn readonly -a xxx=yyy into\n\t\t declare -ra xxx=yyy and see what that gets us. */\n\t      if (arrays_only || assoc_only)\n\t\t{\n\t\t  tlist = list->next;\n\t\t  list->next = (WORD_LIST *)NULL;\n\t\t  /* Add -g to avoid readonly/export creating local variables:\n\t\t     only local/declare/typeset create local variables */\n\t\t  opti = 0;\n\t\t  optw[opti++] = '-';\n\t\t  optw[opti++] = 'g';\n\t\t  if (attribute & att_readonly)\n\t\t    optw[opti++] = 'r';\n\t\t  if (attribute & att_exported)\n\t\t    optw[opti++] = 'x';\n\t\t  if (arrays_only)\n\t\t    optw[opti++] = 'a';\n\t\t  else\n\t\t    optw[opti++] = 'A';\n\t\t  optw[opti] = '\\0';\n\n\t\t  w = make_word (optw);\n\t\t  nlist = make_word_list (w, list);\n\n\t\t  opt = declare_builtin (nlist);\n\t\t  if (opt != EXECUTION_SUCCESS)\n\t\t    assign_error++;\n\t\t  list->next = tlist;\n\t\t  dispose_word (w);\n\t\t  free (nlist);\n\t\t}\n\t      else\n#endif\n\t      /* This word has already been expanded once with command\n\t\t and parameter expansion.  Call do_assignment_no_expand (),\n\t\t which does not do command or parameter substitution.  If\n\t\t the assignment is not performed correctly, flag an error. */\n\t      if (do_assignment_no_expand (name) == 0)\n\t\tassign_error++;\n\t      name[assign] = '\\0';\n\t      if (aflags & ASS_APPEND)\n\t\tname[assign - 1] = '\\0';\n\t    }\n\n\t  set_var_attribute (name, attribute, undo);\n\t  if (assign)\t\t/* restore word */\n\t    {\n\t      name[assign] = '=';\n\t      if (aflags & ASS_APPEND)\n\t\tname[assign-1] = '+';\n\t    }\n\t  list = list->next;\n\t}\n    }\n  else\n    {\n      SHELL_VAR **variable_list;\n      register int i;\n\n      if ((attribute & att_function) || functions_only)\n\t{\n\t  variable_list = all_shell_functions ();\n\t  if (attribute != att_function)\n\t    attribute &= ~att_function;\t/* so declare -xf works, for example */\n\t}\n      else\n\tvariable_list = all_shell_variables ();\n\n#if defined (ARRAY_VARS)\n      if (attribute & att_array)\n\t{\n\t  arrays_only++;\n\t  if (attribute != att_array)\n\t    attribute &= ~att_array;\n\t}\n      else if (attribute & att_assoc)\n\t{\n\t  assoc_only++;\n\t  if (attribute != att_assoc)\n\t    attribute &= ~att_assoc;\n\t}\n#endif\n\n      if (variable_list)\n\t{\n\t  for (i = 0; var = variable_list[i]; i++)\n\t    {\n#if defined (ARRAY_VARS)\n\t      if (arrays_only && array_p (var) == 0)\n\t\tcontinue;\n\t      else if (assoc_only && assoc_p (var) == 0)\n\t\tcontinue;\n#endif\n\n\t      /* If we imported a variable that's not a valid identifier, don't\n\t\t show it in any lists. */\n\t      if ((var->attributes & (att_invisible|att_imported)) == (att_invisible|att_imported))\n\t\tcontinue;\n\n\t      if ((var->attributes & attribute))\n\t\t{\n\t\t  show_var_attributes (var, READONLY_OR_EXPORT, nodefs);\n\t\t  if (any_failed = sh_chkwrite (any_failed))\n\t\t    break;\n\t\t}\n\t    }\n\t  free (variable_list);\n\t}\n    }\n\n  return (assign_error ? EX_BADASSIGN\n\t\t       : ((any_failed == 0) ? EXECUTION_SUCCESS\n  \t\t\t\t\t    : EXECUTION_FAILURE));\n}\n\n/* Show all variable variables (v == 1) or functions (v == 0) with\n   attributes. */\nint\nshow_all_var_attributes (v, nodefs)\n     int v, nodefs;\n{\n  SHELL_VAR **variable_list, *var;\n  int any_failed;\n  register int i;\n\n  variable_list = v ? all_shell_variables () : all_shell_functions ();\n  if (variable_list == 0)  \n    return (EXECUTION_SUCCESS);\n\n  for (i = any_failed = 0; var = variable_list[i]; i++)\n    {\n      /* There is no equivalent `declare -'. */\n      if (variable_context && var->context == variable_context && STREQ (var->name, \"-\"))\n\tprintf (\"local -\\n\");\n      else  \n\tshow_var_attributes (var, READONLY_OR_EXPORT, nodefs);\n      if (any_failed = sh_chkwrite (any_failed))\n        break;\n    }\n  free (variable_list);\n  return (any_failed == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n}\n\n/* Show all local variable variables with their attributes. This shows unset\n   local variables (all_local_variables called with 0 argument). */\nint\nshow_local_var_attributes (v, nodefs)\n     int v, nodefs;\n{\n  SHELL_VAR **variable_list, *var;\n  int any_failed;\n  register int i;\n\n  variable_list = all_local_variables (0);\n  if (variable_list == 0)  \n    return (EXECUTION_SUCCESS);\n\n  for (i = any_failed = 0; var = variable_list[i]; i++)\n    {\n      /* There is no equivalent `declare -'. */\n      if (STREQ (var->name, \"-\"))\n\tprintf (\"local -\\n\");\n      else  \n\tshow_var_attributes (var, READONLY_OR_EXPORT, nodefs);\n      if (any_failed = sh_chkwrite (any_failed))\n        break;\n    }\n  free (variable_list);\n  return (any_failed == 0 ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n}\n\nint\nvar_attribute_string (var, pattr, flags)\n     SHELL_VAR *var;\n     int pattr;\n     char *flags;\t/* filled in with attributes */\n{\n  int i;\n\n  i = 0;\n\n  /* pattr == 0 means we are called from `declare'. */\n  if (pattr == 0 || posixly_correct == 0)\n    {\n#if defined (ARRAY_VARS)\n      if (array_p (var))\n\tflags[i++] = 'a';\n\n      if (assoc_p (var))\n\tflags[i++] = 'A';\n#endif\n\n      if (function_p (var))\n\tflags[i++] = 'f';\n\n      if (integer_p (var))\n\tflags[i++] = 'i';\n\n      if (nameref_p (var))\n\tflags[i++] = 'n';\n\n      if (readonly_p (var))\n\tflags[i++] = 'r';\n\n      if (trace_p (var))\n\tflags[i++] = 't';\n\n      if (exported_p (var))\n\tflags[i++] = 'x';\n\n      if (capcase_p (var))\n\tflags[i++] = 'c';\n\n      if (lowercase_p (var))\n\tflags[i++] = 'l';\n\n      if (uppercase_p (var))\n\tflags[i++] = 'u';\n    }\n  else\n    {\n#if defined (ARRAY_VARS)\n      if (array_p (var))\n\tflags[i++] = 'a';\n\n      if (assoc_p (var))\n\tflags[i++] = 'A';\n#endif\n\n      if (function_p (var))\n\tflags[i++] = 'f';\n    }\n\n  flags[i] = '\\0';\n  return i;\n}\n\n/* Show the attributes for shell variable VAR.  If NODEFS is non-zero,\n   don't show function definitions along with the name.  If PATTR is\n   non-zero, it indicates we're being called from `export' or `readonly'.\n   In POSIX mode, this prints the name of the calling builtin (`export'\n   or `readonly') instead of `declare', and doesn't print function defs\n   when called by `export' or `readonly'. */\nint\nshow_var_attributes (var, pattr, nodefs)\n     SHELL_VAR *var;\n     int pattr, nodefs;\n{\n  char flags[MAX_ATTRIBUTES], *x;\n  int i;\n\n  i = var_attribute_string (var, pattr, flags);\n\n  /* If we're printing functions with definitions, print the function def\n     first, then the attributes, instead of printing output that can't be\n     reused as input to recreate the current state. */\n  if (function_p (var) && nodefs == 0 && (pattr == 0 || posixly_correct == 0))\n    {\n      printf (\"%s\\n\", named_function_string (var->name, function_cell (var), FUNC_MULTILINE|FUNC_EXTERNAL));\n      nodefs++;\n      if (pattr == 0 && i == 1 && flags[0] == 'f')\n\treturn 0;\t\t/* don't print `declare -f name' */\n    }\n\n  if (pattr == 0 || posixly_correct == 0)\n    printf (\"declare -%s \", i ? flags : \"-\");\n  else if (i)\n    printf (\"%s -%s \", this_command_name, flags);\n  else\n    printf (\"%s \", this_command_name);\n\n#if defined (ARRAY_VARS)\n  if (invisible_p (var) && (array_p (var) || assoc_p (var)))\n    printf (\"%s\\n\", var->name);\n  else if (array_p (var))\n    print_array_assignment (var, 0);\n  else if (assoc_p (var))\n    print_assoc_assignment (var, 0);\n  else\n#endif\n  /* force `readonly' and `export' to not print out function definitions\n     when in POSIX mode. */\n  if (nodefs || (function_p (var) && pattr != 0 && posixly_correct))\n    printf (\"%s\\n\", var->name);\n  else if (function_p (var))\n    printf (\"%s\\n\", named_function_string (var->name, function_cell (var), FUNC_MULTILINE|FUNC_EXTERNAL));\n  else if (invisible_p (var) || var_isset (var) == 0)\n    printf (\"%s\\n\", var->name);\n  else\n    {\n      if (ansic_shouldquote (value_cell (var)))\n\tx = ansic_quote (value_cell (var), 0, (int *)0);\n      else\n\tx = sh_double_quote (value_cell (var));\n      printf (\"%s=%s\\n\", var->name, x);\n      free (x);\n    }\n  return (0);\n}\n\nint\nshow_name_attributes (name, nodefs)\n     char *name;\n     int nodefs;\n{\n  SHELL_VAR *var;\n\n  var = find_variable_noref (name);\n\n  if (var)\t/* show every variable with attributes, even unset ones */\n    {\n      show_var_attributes (var, READONLY_OR_EXPORT, nodefs);\n      return (0);\n    }\n  else\n    return (1);\n}\n\nint\nshow_localname_attributes (name, nodefs)\n     char *name;\n     int nodefs;\n{\n  SHELL_VAR *var;\n\n  var = find_variable_noref (name);\n\n  if (var && local_p (var) && var->context == variable_context)\t/* show every variable with attributes, even unset ones */\n    {\n      show_var_attributes (var, READONLY_OR_EXPORT, nodefs);\n      return (0);\n    }\n  else\n    return (1);\n}\n\nint\nshow_func_attributes (name, nodefs)\n     char *name;\n     int nodefs;\n{\n  SHELL_VAR *var;\n\n  var = find_function (name);\n\n  if (var)\n    {\n      show_var_attributes (var, READONLY_OR_EXPORT, nodefs);\n      return (0);\n    }\n  else\n    return (1);\n}\n\nvoid\nset_var_attribute (name, attribute, undo)\n     char *name;\n     int attribute, undo;\n{\n  SHELL_VAR *var, *tv, *v, *refvar;\n  char *tvalue;\n\n  if (undo)\n    var = find_variable (name);\n  else\n    {\n      tv = find_tempenv_variable (name);\n      /* XXX -- need to handle case where tv is a temp variable in a\n\t function-scope context, since function_env has been merged into\n\t the local variables table. */\n      if (tv && tempvar_p (tv))\n\t{\n\t  tvalue = var_isset (tv) ? savestring (value_cell (tv)) : savestring (\"\");\n\n\t  var = bind_variable (tv->name, tvalue, 0);\n\t  if (var == 0)\n\t    {\n\t      free (tvalue);\n\t      return;\t\t/* XXX - no error message here */\n\t    }\n\t  var->attributes |= tv->attributes & ~att_tempvar;\n\t  /* This avoids an error message when propagating a read-only var\n\t     later on. */\n\t  if (posixly_correct || shell_compatibility_level <= 44)\n\t    {\n\t      if (var->context == 0 && (attribute & att_readonly))\n\t\t{\n\t\t  /* Don't bother to set the `propagate to the global variables\n\t\t     table' flag if we've just bound the variable in that\n\t\t     table */\n\t\t  v = find_global_variable (tv->name);\n\t\t  if (v != var)\n\t\t    VSETATTR (tv, att_propagate);\n\t\t}\n\t      else\n\t\tVSETATTR (tv, att_propagate);\n\t      if (var->context != 0)\n\t\tVSETATTR (var, att_propagate);\n\t    }\n\n\t  SETVARATTR (tv, attribute, undo);\t/* XXX */\n\n\t  stupidly_hack_special_variables (tv->name);\n\n\t  free (tvalue);\n\t}\n      else\n\t{\n\t  var = find_variable_notempenv (name);\n\t  if (var == 0)\n\t    {\n\t      /* We might have a nameref pointing to something that we can't\n\t\t resolve to a shell variable.  If we do, skip it.  We do a little\n\t\t checking just so we can print an error message. */\n\t      refvar = find_variable_nameref_for_create (name, 0);\n\t      if (refvar == INVALID_NAMEREF_VALUE)\n\t\treturn;\n\t      /* Otherwise we probably have a nameref pointing to a variable\n\t\t that hasn't been created yet. bind_variable will take care\n\t\t of that. */\n\t    }\n\t  if (var == 0)\n\t    {\n\t      var = bind_variable (name, (char *)NULL, 0);\n\t      if (var)\n\t\tVSETATTR (var, att_invisible);\n\t    }\n\t  else if (var->context != 0)\n\t    VSETATTR (var, att_propagate);\n\t}\n    }\n\n  if (var)\n    SETVARATTR (var, attribute, undo);\n\n  if (var && (exported_p (var) || (attribute & att_exported)))\n    array_needs_making++;\t/* XXX */\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}