{
  "module_name": "help.def",
  "hash_id": "5b4aebad052c2be1ca49b741ca284524a4eb08fcd9eb97d0a493a1991c3bf8a1",
  "original_prompt": "Ingested from bash-5.2.21/builtins/help.def",
  "human_readable_source": "This file is help.def, from which is created help.c.\nIt implements the builtin \"help\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES help.c\n\n$BUILTIN help\n$FUNCTION help_builtin\n$DEPENDS_ON HELP_BUILTIN\n$SHORT_DOC help [-dms] [pattern ...]\nDisplay information about builtin commands.\n\nDisplays brief summaries of builtin commands.  If PATTERN is\nspecified, gives detailed help on all commands matching PATTERN,\notherwise the list of help topics is printed.\n\nOptions:\n  -d\toutput short description for each topic\n  -m\tdisplay usage in pseudo-manpage format\n  -s\toutput only a short usage synopsis for each topic matching\n\t\tPATTERN\n\nArguments:\n  PATTERN\tPattern specifying a help topic\n\nExit Status:\nReturns success unless PATTERN is not found or an invalid option is given.\n$END\n\n#include <config.h>\n\n#if defined (HELP_BUILTIN)\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <errno.h>\n\n#include <filecntl.h>\n#include <stddef.h>\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../builtins.h\"\n#include \"../execute_cmd.h\"\n#include \"../pathexp.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#include <glob/strmatch.h>\n#include <glob/glob.h>\n\n#ifndef errno\nextern int errno;\n#endif\n\nextern const char * const bash_copyright;\nextern const char * const bash_license;\n\nstatic void show_builtin_command_help PARAMS((void));\nstatic int open_helpfile PARAMS((char *));\nstatic void show_desc PARAMS((char *, int));\nstatic void show_manpage PARAMS((char *, int));\nstatic void show_longdoc PARAMS((int));\n\n/* Print out a list of the known functions in the shell, and what they do.\n   If LIST is supplied, print out the list which matches for each pattern\n   specified. */\nint\nhelp_builtin (list)\n     WORD_LIST *list;\n{\n  register int i;\n  char *pattern, *name;\n  int plen, match_found, sflag, dflag, mflag, m, pass, this_found;\n\n  dflag = sflag = mflag = 0;\n  reset_internal_getopt ();\n  while ((i = internal_getopt (list, \"dms\")) != -1)\n    {\n      switch (i)\n\t{\n\tcase 'd':\n\t  dflag = 1;\n\t  break;\n\tcase 'm':\n\t  mflag = 1;\n\t  break;\n\tcase 's':\n\t  sflag = 1;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  if (list == 0)\n    {\n      show_shell_version (0);\n      show_builtin_command_help ();\n      return (EXECUTION_SUCCESS);\n    }\n\n  /* We should consider making `help bash' do something. */\n\n  if (glob_pattern_p (list->word->word) == 1)\n    {\n      printf (\"%s\", ngettext (\"Shell commands matching keyword `\", \"Shell commands matching keywords `\", (list->next ? 2 : 1)));\n      print_word_list (list, \", \");\n      printf (\"%s\", _(\"'\\n\\n\"));\n    }\n\n  for (match_found = 0, pattern = \"\"; list; list = list->next)\n    {\n      pattern = list->word->word;\n      plen = strlen (pattern);\n\n      for (pass = 1, this_found = 0; pass < 3; pass++)\n\t{\n\t  for (i = 0; name = shell_builtins[i].name; i++)\n\t    {\n\t      QUIT;\n\n\t      /* First pass: look for exact string or pattern matches.\n\t\t Second pass: look for prefix matches like bash-4.2 */\n\t      if (pass == 1)\n\t        m = (strcmp (pattern, name) == 0) ||\n\t\t    (strmatch (pattern, name, FNMATCH_EXTFLAG) != FNM_NOMATCH);\n\t      else\n\t\tm = strncmp (pattern, name, plen) == 0;\n\n\t      if (m)\n\t        {\n\t          this_found = 1;\n\t          match_found++;\n\t          if (dflag)\n\t\t    {\n\t\t      show_desc (name, i);\n\t\t      continue;\n\t\t    }\n\t          else if (mflag)\n\t\t    {\n\t\t      show_manpage (name, i);\n\t\t      continue;\n\t\t    }\n\n\t          printf (\"%s: %s\\n\", name, _(shell_builtins[i].short_doc));\n\n\t          if (sflag == 0)\n\t\t    show_longdoc (i);\n\t        }\n\t    }\n\t  if (pass == 1 && this_found == 1)\n\t    break;\n\t}\n    }\n\n  if (match_found == 0)\n    {\n      builtin_error (_(\"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'.\"), pattern, pattern, pattern);\n      return (EXECUTION_FAILURE);\n    }\n\n  return (sh_chkwrite (EXECUTION_SUCCESS));\n}\n\nvoid\nbuiltin_help ()\n{\n  int ind;\n  ptrdiff_t d;\n\n  current_builtin = builtin_address_internal (this_command_name, 0);\n  if (current_builtin == 0)\n    return;\n\n  d = current_builtin - shell_builtins;\n\n#if defined (__STDC__)\n  ind = (int)d;\n#else\n  ind = (int)d / sizeof (struct builtin);\n#endif\n\n  printf (\"%s: %s\\n\", this_command_name, _(shell_builtins[ind].short_doc));\n  show_longdoc (ind);  \n}\n\nstatic int\nopen_helpfile (name)\n     char *name;\n{\n  int fd;\n\n  fd = open (name, O_RDONLY);\n  if (fd == -1)\n    {\n      builtin_error (_(\"%s: cannot open: %s\"), name, strerror (errno));\n      return -1;\n    }\n  return fd;\n}\n\n/* By convention, enforced by mkbuiltins.c, if separate help files are being\n   used, the long_doc array contains one string -- the full pathname of the\n   help file for this builtin.  */\nstatic void\nshow_longdoc (i)\n     int i;\n{\n  register int j;\n  char * const *doc;\n  int fd;\n\n  doc = shell_builtins[i].long_doc;\n\n  if (doc && doc[0] && *doc[0] == '/' && doc[1] == (char *)NULL)\n    {\n      fd = open_helpfile (doc[0]);\n      if (fd < 0)\n\treturn;\n      zcatfd (fd, 1, doc[0]);\n      close (fd);\n    }\n  else if (doc)\n    for (j = 0; doc[j]; j++)\n      printf (\"%*s%s\\n\", BASE_INDENT, \" \", _(doc[j]));\n}\n\nstatic void\nshow_desc (name, i)\n     char *name;\n     int i;\n{\n  register int j, r;\n  char **doc, *line;\n  int fd, usefile;\n\n  doc = (char **)shell_builtins[i].long_doc;\n\n  usefile = (doc && doc[0] && *doc[0] == '/' && doc[1] == (char *)NULL);\n  if (usefile)\n    {\n      fd = open_helpfile (doc[0]);\n      if (fd < 0)\n\treturn;\n      r = zmapfd (fd, &line, doc[0]);\n      close (fd);\n      /* XXX - handle errors if zmapfd returns < 0 */\n    }\n  else\n    line = doc ? doc[0] : (char *)NULL;\n\n  printf (\"%s - \", name);\n  for (j = 0; line && line[j]; j++)\n    {\n      putchar (line[j]);\n      if (line[j] == '\\n')\n\tbreak;\n    }\n  \n  fflush (stdout);\n\n  if (usefile)\n    free (line);\n}\n\n/* Print builtin help in pseudo-manpage format. */\nstatic void\nshow_manpage (name, i)\n     char *name;\n     int i;\n{\n  register int j;\n  char **doc, *line;\n  int fd, usefile;\n\n  doc = (char **)shell_builtins[i].long_doc;\n\n  usefile = (doc && doc[0] && *doc[0] == '/' && doc[1] == (char *)NULL);\n  if (usefile)\n    {\n      fd = open_helpfile (doc[0]);\n      if (fd < 0)\n\treturn;\n      zmapfd (fd, &line, doc[0]);\n      close (fd);\n    }\n  else\n    line = doc ? _(doc[0]) : (char *)NULL;\n\n  /* NAME */\n  printf (\"NAME\\n\");\n  printf (\"%*s%s - \", BASE_INDENT, \" \", name);\n  for (j = 0; line && line[j]; j++)\n    {\n      putchar (line[j]);\n      if (line[j] == '\\n')\n\tbreak;\n    }\n  printf (\"\\n\");\n\n  /* SYNOPSIS */\n  printf (\"SYNOPSIS\\n\");\n  printf (\"%*s%s\\n\\n\", BASE_INDENT, \" \", _(shell_builtins[i].short_doc));\n\n  /* DESCRIPTION */\n  printf (\"DESCRIPTION\\n\");\n  if (usefile == 0)\n    {\n      for (j = 0; doc[j]; j++)\n        printf (\"%*s%s\\n\", BASE_INDENT, \" \", _(doc[j]));\n    }\n  else\n    {\n      for (j = 0; line && line[j]; j++)\n\t{\n\t  putchar (line[j]);\n\t  if (line[j] == '\\n')\n\t    printf (\"%*s\", BASE_INDENT, \" \");\n\t}\n    }\n  putchar ('\\n');\n\n  /* SEE ALSO */\n  printf (\"SEE ALSO\\n\");\n  printf (\"%*sbash(1)\\n\\n\", BASE_INDENT, \" \");\n\n  /* IMPLEMENTATION */\n  printf (\"IMPLEMENTATION\\n\");\n  printf (\"%*s\", BASE_INDENT, \" \");\n  show_shell_version (0);\n  printf (\"%*s\", BASE_INDENT, \" \");\n  printf (\"%s\\n\", _(bash_copyright));\n  printf (\"%*s\", BASE_INDENT, \" \");\n  printf (\"%s\\n\", _(bash_license));\n\n  fflush (stdout);\n  if (usefile)\n    free (line);\n}\n\nstatic void\ndispcolumn (i, buf, bufsize, width, height)\n     int i;\n     char *buf;\n     size_t bufsize;\n     int width, height;\n{\n  int j;\n  int dispcols;\n  char *helpdoc;\n\n  /* first column */\n  helpdoc = _(shell_builtins[i].short_doc);\n\n  buf[0] = (shell_builtins[i].flags & BUILTIN_ENABLED) ? ' ' : '*';\n  strncpy (buf + 1, helpdoc, width - 2);\n  buf[width - 2] = '>';\t\t/* indicate truncation */\n  buf[width - 1] = '\\0';\n  printf (\"%s\", buf);\n  if (((i << 1) >= num_shell_builtins) || (i+height >= num_shell_builtins))\n    {\n      printf (\"\\n\");\n      return;\n    }\n\n  dispcols = strlen (buf);\n  /* two spaces */\n  for (j = dispcols; j < width; j++)\n    putc (' ', stdout);\n\n  /* second column */\n  helpdoc = _(shell_builtins[i+height].short_doc);\n\n  buf[0] = (shell_builtins[i+height].flags & BUILTIN_ENABLED) ? ' ' : '*';\n  strncpy (buf + 1, helpdoc, width - 3);\n  buf[width - 3] = '>';\t\t/* indicate truncation */\n  buf[width - 2] = '\\0';\n\n  printf (\"%s\\n\", buf);\n}\n\n#if defined (HANDLE_MULTIBYTE)\nstatic void\nwdispcolumn (i, buf, bufsize, width, height)\n     int i;\n     char *buf;\n     size_t bufsize;\n     int width, height;\n{\n  int j;\n  int dispcols, dispchars;\n  char *helpdoc;\n  wchar_t *wcstr;\n  size_t slen, n;\n\n  /* first column */\n  helpdoc = _(shell_builtins[i].short_doc);\n\n  wcstr = 0;\n  slen = mbstowcs ((wchar_t *)0, helpdoc, 0);\n  if (slen == -1)\n    {\n      dispcolumn (i, buf, bufsize, width, height);\n      return;\n    }\n\n  /* No bigger than the passed max width */\n  if (slen >= width)\n    slen = width - 2;\n  wcstr = (wchar_t *)xmalloc (sizeof (wchar_t) * (width + 2));\n  n = mbstowcs (wcstr+1, helpdoc, slen + 1);\n  wcstr[n+1] = L'\\0';\n\n  /* Turn tabs and newlines into spaces for column display, since wcwidth\n     returns -1 for them */\n  for (j = 1; j < n; j++)\n    if (wcstr[j] == L'\\n' || wcstr[j] == L'\\t')\n      wcstr[j] = L' ';\n\n  /* dispchars == number of characters that will be displayed */\n  dispchars = wcsnwidth (wcstr+1, slen, width - 2);\n  /* dispcols == number of columns required to display DISPCHARS */\n  dispcols = wcswidth (wcstr+1, dispchars) + 1;\t/* +1 for ' ' or '*' */\n\n  wcstr[0] = (shell_builtins[i].flags & BUILTIN_ENABLED) ? L' ' : L'*';\n\n  if (dispcols >= width-2)\n    {\n      wcstr[dispchars] = L'>';\t\t/* indicate truncation */\n      wcstr[dispchars+1] = L'\\0';\n    }\n\n  printf (\"%ls\", wcstr);\n  if (((i << 1) >= num_shell_builtins) || (i+height >= num_shell_builtins))\n    {\n      printf (\"\\n\");\n      free (wcstr);\n      return;\n    }\n\n  /* at least one space */\n  for (j = dispcols; j < width; j++)\n    putc (' ', stdout);\n\n  /* second column */\n  helpdoc = _(shell_builtins[i+height].short_doc);\n  slen = mbstowcs ((wchar_t *)0, helpdoc, 0);\n  if (slen == -1)\n    {\n      /* for now */\n      printf (\"%c%s\\n\", (shell_builtins[i+height].flags & BUILTIN_ENABLED) ? ' ' : '*', helpdoc);\n      free (wcstr);\n      return;\n    }\n\n  /* Reuse wcstr since it is already width wide chars long */\n  if (slen >= width)\n    slen = width - 2;\n  n = mbstowcs (wcstr+1, helpdoc, slen + 1);\n  wcstr[n+1] = L'\\0';\t\t/* make sure null-terminated */\n\n  /* Turn tabs and newlines into spaces for column display */\n  for (j = 1; j < n; j++)\n    if (wcstr[j] == L'\\n' || wcstr[j] == L'\\t')\n      wcstr[j] = L' ';\n\n  /* dispchars == number of characters that will be displayed */\n  dispchars = wcsnwidth (wcstr+1, slen, width - 2);\n  dispcols = wcswidth (wcstr+1, dispchars) + 1;\t/* +1 for ' ' or '*' */\n  \n  wcstr[0] = (shell_builtins[i+height].flags & BUILTIN_ENABLED) ? L' ' : L'*';\n\n  /* The dispchars-1 is there for terminals that behave strangely when you\n     have \\n in the nth column for terminal width n; this is what bash-4.3\n     did. */\n  if (dispcols >= width - 2)\n    {\n      wcstr[dispchars-1] = L'>';\t\t/* indicate truncation */\n      wcstr[dispchars] = L'\\0';\n    }\n\n  printf (\"%ls\\n\", wcstr);\n\n  free (wcstr);\n}\n#endif /* HANDLE_MULTIBYTE */\n\nstatic void\nshow_builtin_command_help ()\n{\n  int i, j;\n  int height, width;\n  char *t, blurb[128];\n\n  printf (\n_(\"These shell commands are defined internally.  Type `help' to see this list.\\n\\\nType `help name' to find out more about the function `name'.\\n\\\nUse `info bash' to find out more about the shell in general.\\n\\\nUse `man -k' or `info' to find out more about commands not in this list.\\n\\\n\\n\\\nA star (*) next to a name means that the command is disabled.\\n\\\n\\n\"));\n\n  width = default_columns ();\n\n  width /= 2;\n  if (width > sizeof (blurb))\n    width = sizeof (blurb);\n  if (width <= 3)\n    width = 40;\n  height = (num_shell_builtins + 1) / 2;\t/* number of rows */\n\n  for (i = 0; i < height; i++)\n    {\n      QUIT;\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1)\n\twdispcolumn (i, blurb, sizeof (blurb), width, height);\n      else\n#endif\n\tdispcolumn (i, blurb, sizeof (blurb), width, height);\n    }\n}\n#endif /* HELP_BUILTIN */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}