{
  "module_name": "shopt.def",
  "hash_id": "c1bb281be9ac815fce0ab20022689d8ca8702e63c0de2cae94ebc9b4e812d91d",
  "original_prompt": "Ingested from bash-5.2.21/builtins/shopt.def",
  "human_readable_source": "This file is shopt.def, from which is created shopt.c.\nIt implements the Bash `shopt' builtin.\n\nCopyright (C) 1994-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES shopt.c\n\n$BUILTIN shopt\n$FUNCTION shopt_builtin\n$SHORT_DOC shopt [-pqsu] [-o] [optname ...]\nSet and unset shell options.\n\nChange the setting of each shell option OPTNAME.  Without any option\narguments, list each supplied OPTNAME, or all shell options if no\nOPTNAMEs are given, with an indication of whether or not each is set.\n\nOptions:\n  -o\trestrict OPTNAMEs to those defined for use with `set -o'\n  -p\tprint each shell option with an indication of its status\n  -q\tsuppress output\n  -s\tenable (set) each OPTNAME\n  -u\tdisable (unset) each OPTNAME\n\nExit Status:\nReturns success if OPTNAME is enabled; fails if an invalid option is\ngiven or OPTNAME is disabled.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"version.h\"\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../flags.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#if defined (READLINE)\n#  include \"../bashline.h\"\n#endif\n\n#if defined (HISTORY)\n#  include \"../bashhist.h\"\n#endif\n\n#define UNSETOPT\t0\n#define SETOPT\t\t1\n\n#define OPTFMT\t\t\"%-15s\\t%s\\n\"\n\nextern int allow_null_glob_expansion, fail_glob_expansion, glob_dot_filenames;\nextern int cdable_vars, mail_warning, source_uses_path;\nextern int no_exit_on_failed_exec, print_shift_error;\nextern int check_hashed_filenames, promptvars;\nextern int cdspelling, expand_aliases;\nextern int extended_quote;\nextern int check_window_size;\nextern int glob_ignore_case, match_ignore_case;\nextern int hup_on_exit;\nextern int xpg_echo;\nextern int gnu_error_format;\nextern int check_jobs_at_exit;\nextern int autocd;\nextern int glob_star;\nextern int glob_asciirange;\nextern int glob_always_skip_dot_and_dotdot;\nextern int lastpipe_opt;\nextern int inherit_errexit;\nextern int localvar_inherit;\nextern int localvar_unset;\nextern int varassign_redir_autoclose;\nextern int singlequote_translations;\nextern int patsub_replacement;\n\n#if defined (EXTENDED_GLOB)\nextern int extended_glob;\n#endif\n\n#if defined (READLINE)\nextern int hist_verify, history_reediting, perform_hostname_completion;\nextern int no_empty_command_completion;\nextern int force_fignore;\nextern int dircomplete_spelling, dircomplete_expand;\nextern int complete_fullquote;\n\nextern int enable_hostname_completion PARAMS((int));\n#endif\n\n#if defined (PROGRAMMABLE_COMPLETION)\nextern int prog_completion_enabled;\nextern int progcomp_alias;\n#endif\n\n#if defined (DEBUGGER)\nextern int debugging_mode;\n#endif\n\n#if defined (ARRAY_VARS)\nextern int assoc_expand_once;\nextern int array_expand_once;\nint expand_once_flag;\n#endif\n\n#if defined (SYSLOG_HISTORY)\nextern int syslog_history;\n#endif\n\nstatic void shopt_error PARAMS((char *));\n\nstatic int set_shellopts_after_change PARAMS((char *, int));\nstatic int set_compatibility_level PARAMS((char *, int));\n\n#if defined (RESTRICTED_SHELL)\nstatic int set_restricted_shell PARAMS((char *, int));\n#endif\n\n#if defined (READLINE)\nstatic int shopt_enable_hostname_completion PARAMS((char *, int));\nstatic int shopt_set_complete_direxpand PARAMS((char *, int));\n#endif\n\n#if defined (ARRAY_VARS)\nstatic int set_assoc_expand PARAMS((char *, int));\n#endif\n\n#if defined (EXTENDED_GLOB)\nint extglob_flag = EXTGLOB_DEFAULT;\nstatic int shopt_set_extglob PARAMS((char *, int));\n#endif\n\nint expaliases_flag = 0;\nstatic int shopt_set_expaliases PARAMS((char *, int));\n\nstatic int shopt_set_debug_mode PARAMS((char *, int));\n\nstatic int shopt_login_shell;\nstatic int shopt_compat31;\nstatic int shopt_compat32;\nstatic int shopt_compat40;\nstatic int shopt_compat41;\nstatic int shopt_compat42;\nstatic int shopt_compat43;\nstatic int shopt_compat44;\n\ntypedef int shopt_set_func_t PARAMS((char *, int));\n\n/* If you add a new variable name here, make sure to set the default value\n   appropriately in reset_shopt_options. */\n\nstatic struct {\n  char *name;\n  int  *value;\n  shopt_set_func_t *set_func;\n} shopt_vars[] = {\n  { \"autocd\", &autocd, (shopt_set_func_t *)NULL },\n#if defined (ARRAY_VARS)\n  { \"assoc_expand_once\", &expand_once_flag, set_assoc_expand },\n#endif\n  { \"cdable_vars\", &cdable_vars, (shopt_set_func_t *)NULL },\n  { \"cdspell\", &cdspelling, (shopt_set_func_t *)NULL },\n  { \"checkhash\", &check_hashed_filenames, (shopt_set_func_t *)NULL },\n#if defined (JOB_CONTROL)\n  { \"checkjobs\", &check_jobs_at_exit, (shopt_set_func_t *)NULL },\n#endif\n  { \"checkwinsize\", &check_window_size, (shopt_set_func_t *)NULL },\n#if defined (HISTORY)\n  { \"cmdhist\", &command_oriented_history, (shopt_set_func_t *)NULL },\n#endif\n  { \"compat31\", &shopt_compat31, set_compatibility_level },\n  { \"compat32\", &shopt_compat32, set_compatibility_level },\n  { \"compat40\", &shopt_compat40, set_compatibility_level },\n  { \"compat41\", &shopt_compat41, set_compatibility_level },\n  { \"compat42\", &shopt_compat42, set_compatibility_level },\n  { \"compat43\", &shopt_compat43, set_compatibility_level },\n  { \"compat44\", &shopt_compat44, set_compatibility_level },\n#if defined (READLINE)\n  { \"complete_fullquote\", &complete_fullquote, (shopt_set_func_t *)NULL},\n  { \"direxpand\", &dircomplete_expand, shopt_set_complete_direxpand },\n  { \"dirspell\", &dircomplete_spelling, (shopt_set_func_t *)NULL },\n#endif\n  { \"dotglob\", &glob_dot_filenames, (shopt_set_func_t *)NULL },\n  { \"execfail\", &no_exit_on_failed_exec, (shopt_set_func_t *)NULL },\n  { \"expand_aliases\", &expaliases_flag, shopt_set_expaliases },\n#if defined (DEBUGGER)\n  { \"extdebug\", &debugging_mode, shopt_set_debug_mode },\n#endif\n#if defined (EXTENDED_GLOB)\n  { \"extglob\", &extglob_flag, shopt_set_extglob },\n#endif\n  { \"extquote\", &extended_quote, (shopt_set_func_t *)NULL },\n  { \"failglob\", &fail_glob_expansion, (shopt_set_func_t *)NULL },\n#if defined (READLINE)\n  { \"force_fignore\", &force_fignore, (shopt_set_func_t *)NULL },\n#endif\n  { \"globasciiranges\", &glob_asciirange, (shopt_set_func_t *)NULL },\n  { \"globskipdots\", &glob_always_skip_dot_and_dotdot, (shopt_set_func_t *)NULL },\n  { \"globstar\", &glob_star, (shopt_set_func_t *)NULL },\n  { \"gnu_errfmt\", &gnu_error_format, (shopt_set_func_t *)NULL },\n#if defined (HISTORY)\n  { \"histappend\", &force_append_history, (shopt_set_func_t *)NULL },\n#endif\n#if defined (READLINE)\n  { \"histreedit\", &history_reediting, (shopt_set_func_t *)NULL },\n  { \"histverify\", &hist_verify, (shopt_set_func_t *)NULL },\n  { \"hostcomplete\", &perform_hostname_completion, shopt_enable_hostname_completion },\n#endif\n  { \"huponexit\", &hup_on_exit, (shopt_set_func_t *)NULL },\n  { \"inherit_errexit\", &inherit_errexit, (shopt_set_func_t *)NULL },\n  { \"interactive_comments\", &interactive_comments, set_shellopts_after_change },\n  { \"lastpipe\", &lastpipe_opt, (shopt_set_func_t *)NULL },\n#if defined (HISTORY)\n  { \"lithist\", &literal_history, (shopt_set_func_t *)NULL },\n#endif\n  { \"localvar_inherit\", &localvar_inherit, (shopt_set_func_t *)NULL },\n  { \"localvar_unset\", &localvar_unset, (shopt_set_func_t *)NULL },\n  { \"login_shell\", &shopt_login_shell, set_login_shell },\n  { \"mailwarn\", &mail_warning, (shopt_set_func_t *)NULL },\n#if defined (READLINE)\n  { \"no_empty_cmd_completion\", &no_empty_command_completion, (shopt_set_func_t *)NULL },\n#endif\n  { \"nocaseglob\", &glob_ignore_case, (shopt_set_func_t *)NULL },\n  { \"nocasematch\", &match_ignore_case, (shopt_set_func_t *)NULL },\n  { \"noexpand_translation\", &singlequote_translations, (shopt_set_func_t *)NULL },\n  { \"nullglob\",\t&allow_null_glob_expansion, (shopt_set_func_t *)NULL },\n  { \"patsub_replacement\", &patsub_replacement, (shopt_set_func_t *)NULL },\n#if defined (PROGRAMMABLE_COMPLETION)\n  { \"progcomp\", &prog_completion_enabled, (shopt_set_func_t *)NULL },\n#  if defined (ALIAS)\n  { \"progcomp_alias\", &progcomp_alias, (shopt_set_func_t *)NULL },\n#  endif\n#endif\n  { \"promptvars\", &promptvars, (shopt_set_func_t *)NULL },\n#if defined (RESTRICTED_SHELL)\n  { \"restricted_shell\", &restricted_shell, set_restricted_shell },\n#endif\n  { \"shift_verbose\", &print_shift_error, (shopt_set_func_t *)NULL },\n  { \"sourcepath\", &source_uses_path, (shopt_set_func_t *)NULL },\n#if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)\n  { \"syslog_history\", &syslog_history, (shopt_set_func_t *)NULL },\n#endif\n  { \"varredir_close\", &varassign_redir_autoclose, (shopt_set_func_t *)NULL },\n  { \"xpg_echo\", &xpg_echo, (shopt_set_func_t *)NULL },\n  { (char *)0, (int *)0, (shopt_set_func_t *)NULL }\n};\n\n#define N_SHOPT_OPTIONS\t\t(sizeof (shopt_vars) / sizeof (shopt_vars[0]))\n\n#define GET_SHOPT_OPTION_VALUE(i)\t(*shopt_vars[i].value)\n\nstatic const char * const on = \"on\";\nstatic const char * const off = \"off\";\n\nstatic int find_shopt PARAMS((char *));\nstatic int toggle_shopts PARAMS((int, WORD_LIST *, int));\nstatic void print_shopt PARAMS((char *, int, int));\nstatic int list_shopts PARAMS((WORD_LIST *, int));\nstatic int list_some_shopts PARAMS((int, int));\nstatic int list_shopt_o_options PARAMS((WORD_LIST *, int));\nstatic int list_some_o_options PARAMS((int, int));\nstatic int set_shopt_o_options PARAMS((int, WORD_LIST *, int));\n\n#define SFLAG\t0x01\n#define UFLAG\t0x02\n#define QFLAG\t0x04\n#define OFLAG\t0x08\n#define PFLAG\t0x10\n\nint\nshopt_builtin (list)\n     WORD_LIST *list;\n{\n  int opt, flags, rval;\n\n  flags = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"psuoq\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 's':\n\t  flags |= SFLAG;\n\t  break;\n\tcase 'u':\n\t  flags |= UFLAG;\n\t  break;\n\tcase 'q':\n\t  flags |= QFLAG;\n\t  break;\n\tcase 'o':\n\t  flags |= OFLAG;\n\t  break;\n\tcase 'p':\n\t  flags |= PFLAG;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  if ((flags & (SFLAG|UFLAG)) == (SFLAG|UFLAG))\n    {\n      builtin_error (_(\"cannot set and unset shell options simultaneously\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  rval = EXECUTION_SUCCESS;\n  if ((flags & OFLAG) && ((flags & (SFLAG|UFLAG)) == 0))\t/* shopt -o */\n    rval = list_shopt_o_options (list, flags);\n  else if (list && (flags & OFLAG))\t\t/* shopt -so args */\n    rval = set_shopt_o_options ((flags & SFLAG) ? FLAG_ON : FLAG_OFF, list, flags & QFLAG);\n  else if (flags & OFLAG)\t/* shopt -so */\n    rval = list_some_o_options ((flags & SFLAG) ? 1 : 0, flags);\n  else if (list && (flags & (SFLAG|UFLAG)))\t/* shopt -su args */\n    rval = toggle_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, list, flags & QFLAG);\n  else if ((flags & (SFLAG|UFLAG)) == 0)\t/* shopt [args] */\n    rval = list_shopts (list, flags);\n  else\t\t\t\t\t\t/* shopt -su */\n    rval = list_some_shopts ((flags & SFLAG) ? SETOPT : UNSETOPT, flags);\n  return (rval);\n}\n\n/* Reset the options managed by `shopt' to the values they would have at\n   shell startup.  Variables from shopt_vars. */\nvoid\nreset_shopt_options ()\n{\n  autocd = cdable_vars = cdspelling = 0;\n  check_hashed_filenames = CHECKHASH_DEFAULT;\n  check_window_size = CHECKWINSIZE_DEFAULT;\n  allow_null_glob_expansion = glob_dot_filenames = 0;\n  no_exit_on_failed_exec = 0;\n  expand_aliases = expaliases_flag = 0;\n  extended_quote = 1;\n  fail_glob_expansion = 0;\n  glob_asciirange = GLOBASCII_DEFAULT;\n  glob_star = 0;\n  gnu_error_format = 0;\n  hup_on_exit = 0;\n  inherit_errexit = 0;\n  interactive_comments = 1;\n  lastpipe_opt = 0;\n  localvar_inherit = localvar_unset = 0;\n  mail_warning = 0;\n  glob_ignore_case = match_ignore_case = 0;\n  print_shift_error = 0;\n  source_uses_path = promptvars = 1;\n  varassign_redir_autoclose = 0;\n  singlequote_translations = 0;\n  patsub_replacement = 1;\n\n#if defined (JOB_CONTROL)\n  check_jobs_at_exit = 0;\n#endif\n\n#if defined (EXTENDED_GLOB)\n  extended_glob = extglob_flag = EXTGLOB_DEFAULT;\n#endif\n\n#if defined (ARRAY_VARS)\n  expand_once_flag = assoc_expand_once = 0;\n#endif\n\n#if defined (HISTORY)\n  literal_history = 0;\n  force_append_history = 0;\n  command_oriented_history = 1;\n#endif\n\n#if defined (SYSLOG_HISTORY)\n#  if defined (SYSLOG_SHOPT)\n  syslog_history = SYSLOG_SHOPT;\n#  else\n  syslog_history = 1;\n#  endif /* SYSLOG_SHOPT */\n#endif\n\n#if defined (READLINE)\n  complete_fullquote = 1;\n  force_fignore = 1;\n  hist_verify = history_reediting = 0;\n  perform_hostname_completion = 1;\n#  if DIRCOMPLETE_EXPAND_DEFAULT\n  dircomplete_expand = 1;\n#  else\n  dircomplete_expand = 0;\n#endif\n  dircomplete_spelling = 0;\n  no_empty_command_completion = 0;\n#endif\n\n#if defined (PROGRAMMABLE_COMPLETION)\n  prog_completion_enabled = 1;\n#  if defined (ALIAS)\n  progcomp_alias = 0;\n#  endif\n#endif\n\n#if defined (DEFAULT_ECHO_TO_XPG) || defined (STRICT_POSIX)\n  xpg_echo = 1;\n#else\n  xpg_echo = 0;\n#endif /* DEFAULT_ECHO_TO_XPG */\n\n  shopt_login_shell = login_shell;\n}\n\nstatic int\nfind_shopt (name)\n     char *name;\n{\n  int i;\n\n  for (i = 0; shopt_vars[i].name; i++)\n    if (STREQ (name, shopt_vars[i].name))\n      return i;\n  return -1;\n}\n\nstatic void\nshopt_error (s)\n     char *s;\n{\n  builtin_error (_(\"%s: invalid shell option name\"), s);\n}\n\nstatic int\ntoggle_shopts (mode, list, quiet)\n     int mode;\n     WORD_LIST *list;\n     int quiet;\n{\n  WORD_LIST *l;\n  int ind, rval;\n  SHELL_VAR *v;\n\n  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)\n    {\n      ind = find_shopt (l->word->word);\n      if (ind < 0)\n\t{\n\t  shopt_error (l->word->word);\n\t  rval = EXECUTION_FAILURE;\n\t}\n      else\n\t{\n\t  *shopt_vars[ind].value = mode;\t/* 1 for set, 0 for unset */\n\t  if (shopt_vars[ind].set_func)\n\t    (*shopt_vars[ind].set_func) (shopt_vars[ind].name, mode);\n\t}\n    }\n\n  /* Don't set $BASHOPTS here if it hasn't already been initialized */\n  if (v = find_variable (\"BASHOPTS\"))\n    set_bashopts ();\n  return (rval);\n}\n\nstatic void\nprint_shopt (name, val, flags)\n     char *name;\n     int val, flags;\n{\n  if (flags & PFLAG)\n    printf (\"shopt %s %s\\n\", val ? \"-s\" : \"-u\", name);\n  else\n    printf (OPTFMT, name, val ? on : off);\n}\n\n/* List the values of all or any of the `shopt' options.  Returns 0 if\n   all were listed or all variables queried were on; 1 otherwise. */\nstatic int\nlist_shopts (list, flags)\n     WORD_LIST *list;\n     int flags;\n{\n  WORD_LIST *l;\n  int i, val, rval;\n\n  if (list == 0)\n    {\n      for (i = 0; shopt_vars[i].name; i++)\n\t{\n\t  val = *shopt_vars[i].value;\n\t  if ((flags & QFLAG) == 0)\n\t    print_shopt (shopt_vars[i].name, val, flags);\n\t}\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)\n    {\n      i = find_shopt (l->word->word);\n      if (i < 0)\n\t{\n\t  shopt_error (l->word->word);\n\t  rval = EXECUTION_FAILURE;\n\t  continue;\n\t}\n      val = *shopt_vars[i].value;\n      if (val == 0)\n\trval = EXECUTION_FAILURE;\n      if ((flags & QFLAG) == 0)\n\tprint_shopt (l->word->word, val, flags);\n    }\n\n  return (sh_chkwrite (rval));\n}\n\nstatic int\nlist_some_shopts (mode, flags)\n     int mode, flags;\n{\n  int val, i;\n\n  for (i = 0; shopt_vars[i].name; i++)\n    {\n      val = *shopt_vars[i].value;\n      if (((flags & QFLAG) == 0) && mode == val)\n\tprint_shopt (shopt_vars[i].name, val, flags);\n    }\n  return (sh_chkwrite (EXECUTION_SUCCESS));\n}\n\nstatic int\nlist_shopt_o_options (list, flags)\n     WORD_LIST *list;\n     int flags;\n{\n  WORD_LIST *l;\n  int val, rval;\n\n  if (list == 0)\n    {\n      if ((flags & QFLAG) == 0)\n\tlist_minus_o_opts (-1, (flags & PFLAG));\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)\n    {\n      val = minus_o_option_value (l->word->word);\n      if (val == -1)\n\t{\n\t  sh_invalidoptname (l->word->word);\n\t  rval = EXECUTION_FAILURE;\n\t  continue;\n\t}\n      if (val == 0)\n\trval = EXECUTION_FAILURE;\n      if ((flags & QFLAG) == 0)\n\t{\n\t  if (flags & PFLAG)\n\t    printf (\"set %co %s\\n\", val ? '-' : '+', l->word->word);\n\t  else\n\t    printf (OPTFMT, l->word->word, val ? on : off);\n\t}\n    }\n  return (sh_chkwrite (rval));\n}\n\nstatic int\nlist_some_o_options (mode, flags)\n     int mode, flags;\n{\n  if ((flags & QFLAG) == 0)\n    list_minus_o_opts (mode, (flags & PFLAG));\n  return (sh_chkwrite (EXECUTION_SUCCESS));\n}\n\nstatic int\nset_shopt_o_options (mode, list, quiet)\n     int mode;\n     WORD_LIST *list;\n     int quiet;\n{\n  WORD_LIST *l;\n  int rval;\n\n  for (l = list, rval = EXECUTION_SUCCESS; l; l = l->next)\n    {\n      if (set_minus_o_option (mode, l->word->word) == EXECUTION_FAILURE)\n\trval = EXECUTION_FAILURE;\n    }\n  set_shellopts ();\n  return rval;\n}\n\n/* If we set or unset interactive_comments with shopt, make sure the\n   change is reflected in $SHELLOPTS. */\nstatic int\nset_shellopts_after_change (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  set_shellopts ();\n  return (0);\n}\n\nstatic int\nshopt_set_debug_mode (option_name, mode)\n     char *option_name;\n     int mode;\n{\n#if defined (DEBUGGER)\n  error_trace_mode = function_trace_mode = debugging_mode;\n  set_shellopts ();\n  if (debugging_mode)\n    init_bash_argv ();\n#endif\n  return (0);\n}\n\nstatic int\nshopt_set_expaliases (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  expand_aliases = expaliases_flag;\n  return 0;\n}\n\n#if defined (EXTENDED_GLOB)\nstatic int\nshopt_set_extglob (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  extended_glob = extglob_flag;\n  return 0;\n}\n#endif\n\n#if defined (READLINE)\nstatic int\nshopt_enable_hostname_completion (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  return (enable_hostname_completion (mode));\n}\n#endif\n\nstatic int\nset_compatibility_level (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  int ind, oldval;\n  char *rhs;\n\n  /* If we're unsetting one of the compatibility options, make sure the\n     current value is in the range of the compatNN space. */\n  if (mode == 0)\n    oldval = shell_compatibility_level;\n\n  /* If we're setting something, redo some of the work we did above in\n     toggle_shopt().  Unset everything and reset the appropriate option\n     based on OPTION_NAME. */\n  if (mode)\n    {\n      shopt_compat31 = shopt_compat32 = 0;\n      shopt_compat40 = shopt_compat41 = shopt_compat42 = shopt_compat43 = 0;\n      shopt_compat44 = 0;\n      ind = find_shopt (option_name);\n      *shopt_vars[ind].value = mode;\n    }\n\n  /* Then set shell_compatibility_level based on what remains */\n  if (shopt_compat31)\n    shell_compatibility_level = 31;\n  else if (shopt_compat32)\n    shell_compatibility_level = 32;\n  else if (shopt_compat40)\n    shell_compatibility_level = 40;\n  else if (shopt_compat41)\n    shell_compatibility_level = 41;\n  else if (shopt_compat42)\n    shell_compatibility_level = 42;\n  else if (shopt_compat43)\n    shell_compatibility_level = 43;\n  else if (shopt_compat44)\n    shell_compatibility_level = 44;\n  else if (oldval > 44 && shell_compatibility_level < DEFAULT_COMPAT_LEVEL)\n    ;\n  else\n    shell_compatibility_level = DEFAULT_COMPAT_LEVEL;\n\n  /* Make sure the current compatibility level is reflected in BASH_COMPAT */\n  rhs = itos (shell_compatibility_level);\n  bind_variable (\"BASH_COMPAT\", rhs, 0);\n  free (rhs);\n\n  return 0;\n}\n\n/* Set and unset the various compatibility options from the value of\n   shell_compatibility_level; used by sv_shcompat */\nvoid\nset_compatibility_opts ()\n{\n  shopt_compat31 = shopt_compat32 = 0;\n  shopt_compat40 = shopt_compat41 = shopt_compat42 = shopt_compat43 = 0;\n  shopt_compat44 = 0;\n  switch (shell_compatibility_level)\n    {\n      case DEFAULT_COMPAT_LEVEL:\n      case 51:\t\t\t/* completeness */\n      case 50:\n\tbreak;\n      case 44:\n\tshopt_compat44 = 1; break;\n      case 43:\n\tshopt_compat43 = 1; break;\n      case 42:\n\tshopt_compat42 = 1; break;\n      case 41:\n\tshopt_compat41 = 1; break;\n      case 40:\n\tshopt_compat40 = 1; break;\n      case 32:\n\tshopt_compat32 = 1; break;\n      case 31:\n\tshopt_compat31 = 1; break;\n    }\n}\n\n#if defined (READLINE)\nstatic int\nshopt_set_complete_direxpand (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  set_directory_hook ();\n  return 0;\n}\n#endif\n\n#if defined (RESTRICTED_SHELL)\n/* Don't allow the value of restricted_shell to be modified. */\n\nstatic int\nset_restricted_shell (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  static int save_restricted = -1;\n\n  if (save_restricted == -1)\n    save_restricted = shell_is_restricted (shell_name);\n\n  restricted_shell = save_restricted;\n  return (0);\n}\n#endif /* RESTRICTED_SHELL */\n\n/* Not static so shell.c can call it to initialize shopt_login_shell */\nint\nset_login_shell (option_name, mode)\n     char *option_name;\n     int mode;\n{\n  shopt_login_shell = login_shell != 0;\n  return (0);\n}\n\nchar **\nget_shopt_options ()\n{\n  char **ret;\n  int n, i;\n\n  n = sizeof (shopt_vars) / sizeof (shopt_vars[0]);\n  ret = strvec_create (n + 1);\n  for (i = 0; shopt_vars[i].name; i++)\n    ret[i] = savestring (shopt_vars[i].name);\n  ret[i] = (char *)NULL;\n  return ret;\n}\n\n/*\n * External interface for other parts of the shell.  NAME is a string option;\n * MODE is 0 if we want to unset an option; 1 if we want to set an option.\n * REUSABLE is 1 if we want to print output in a form that may be reused.\n */\nint\nshopt_setopt (name, mode)\n     char *name;\n     int mode;\n{\n  WORD_LIST *wl;\n  int r;\n\n  wl = add_string_to_list (name, (WORD_LIST *)NULL);\n  r = toggle_shopts (mode, wl, 0);\n  dispose_words (wl);\n  return r;\n}\n\nint\nshopt_listopt (name, reusable)\n     char *name;\n     int reusable;\n{\n  int i;\n\n  if (name == 0)\n    return (list_shopts ((WORD_LIST *)NULL, reusable ? PFLAG : 0));\n\n  i = find_shopt (name);\n  if (i < 0)\n    {\n      shopt_error (name);\n      return (EXECUTION_FAILURE);\n    }\n\n  print_shopt (name, *shopt_vars[i].value, reusable ? PFLAG : 0);\n  return (sh_chkwrite (EXECUTION_SUCCESS));\n}\n\nvoid\nset_bashopts ()\n{\n  char *value;\n  char tflag[N_SHOPT_OPTIONS];\n  int vsize, i, vptr, *ip, exported;\n  SHELL_VAR *v;\n\n  for (vsize = i = 0; shopt_vars[i].name; i++)\n    {\n      tflag[i] = 0;\n      if (GET_SHOPT_OPTION_VALUE (i))\n\t{\n\t  vsize += strlen (shopt_vars[i].name) + 1;\n\t  tflag[i] = 1;\n\t}\n    }\n\n  value = (char *)xmalloc (vsize + 1);\n\n  for (i = vptr = 0; shopt_vars[i].name; i++)\n    {\n      if (tflag[i])\n\t{\n\t  strcpy (value + vptr, shopt_vars[i].name);\n\t  vptr += strlen (shopt_vars[i].name);\n\t  value[vptr++] = ':';\n\t}\n    }\n\n  if (vptr)\n    vptr--;\t\t\t/* cut off trailing colon */\n  value[vptr] = '\\0';\n\n  v = find_variable (\"BASHOPTS\");\n\n  /* Turn off the read-only attribute so we can bind the new value, and\n     note whether or not the variable was exported. */\n  if (v)\n    {\n      VUNSETATTR (v, att_readonly);\n      exported = exported_p (v);\n    }\n  else\n    exported = 0;\n\n  v = bind_variable (\"BASHOPTS\", value, 0);\n\n  /* Turn the read-only attribute back on, and turn off the export attribute\n     if it was set implicitly by mark_modified_vars and SHELLOPTS was not\n     exported before we bound the new value. */\n  VSETATTR (v, att_readonly);\n  if (mark_modified_vars && exported == 0 && exported_p (v))\n    VUNSETATTR (v, att_exported);\n\n  free (value);\n}\n\nvoid\nparse_bashopts (value)\n     char *value;\n{\n  char *vname;\n  int vptr, ind;\n\n  vptr = 0;\n  while (vname = extract_colon_unit (value, &vptr))\n    {\n      ind = find_shopt (vname);\n      if (ind >= 0)\n\t{\n          *shopt_vars[ind].value = 1;\n\t  if (shopt_vars[ind].set_func)\n\t    (*shopt_vars[ind].set_func) (shopt_vars[ind].name, 1);\n\t}\n      free (vname);\n    }\n}\n\nvoid\ninitialize_bashopts (no_bashopts)\n     int no_bashopts;\n{\n  char *temp;\n  SHELL_VAR *var;\n\n  if (no_bashopts == 0)\n    {\n      var = find_variable (\"BASHOPTS\");\n      /* set up any shell options we may have inherited. */\n      if (var && imported_p (var))\n\t{\n\t  temp = (array_p (var) || assoc_p (var)) ? (char *)NULL : savestring (value_cell (var));\n\t  if (temp)\n\t    {\n\t      parse_bashopts (temp);\n\t      free (temp);\n\t    }\n\t}\n    }\n\n  /* Set up the $BASHOPTS variable. */\n  set_bashopts ();\n}\n\n#if defined (ARRAY_VARS)\nstatic int\nset_assoc_expand (option_name, mode)\n     char *option_name;\n     int mode;\n{\n#if 0 /* leave this disabled */\n  if (shell_compatibility_level <= 51)\n#endif\n    assoc_expand_once = expand_once_flag;\n  return 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}