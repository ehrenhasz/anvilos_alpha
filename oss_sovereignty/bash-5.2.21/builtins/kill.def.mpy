{
  "module_name": "kill.def",
  "hash_id": "619e4c2f42ff40e9cedf504205c8ec054ba52dc255d941bac5595bb639a56fe7",
  "original_prompt": "Ingested from bash-5.2.21/builtins/kill.def",
  "human_readable_source": "This file is kill.def, from which is created kill.c.\nIt implements the builtin \"kill\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES kill.c\n\n$BUILTIN kill\n$FUNCTION kill_builtin\n$SHORT_DOC kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]\nSend a signal to a job.\n\nSend the processes identified by PID or JOBSPEC the signal named by\nSIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\nSIGTERM is assumed.\n\nOptions:\n  -s sig\tSIG is a signal name\n  -n sig\tSIG is a signal number\n  -l\tlist the signal names; if arguments follow `-l' they are\n\t\tassumed to be signal numbers for which names should be listed\n  -L\tsynonym for -l\n\nKill is a shell builtin for two reasons: it allows job IDs to be used\ninstead of process IDs, and allows processes to be killed if the limit\non processes that you can create is reached.\n\nExit Status:\nReturns success unless an invalid option is given or an error occurs.\n$END\n\n#include <config.h>\n\n#include <stdio.h>\n#include <errno.h>\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include <signal.h>\n\n#include \"../shell.h\"\n#include \"../trap.h\"\n#include \"../jobs.h\"\n#include \"common.h\"\n\n/* Not all systems declare ERRNO in errno.h... and some systems #define it! */\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\nstatic void kill_error PARAMS((pid_t, int));\n\n#if !defined (CONTINUE_AFTER_KILL_ERROR)\n#  define CONTINUE_OR_FAIL return (EXECUTION_FAILURE)\n#else\n#  define CONTINUE_OR_FAIL goto continue_killing\n#endif /* CONTINUE_AFTER_KILL_ERROR */\n\n/* Here is the kill builtin.  We only have it so that people can type\n   kill -KILL %1?  No, if you fill up the process table this way you\n   can still kill some. */\nint\nkill_builtin (list)\n     WORD_LIST *list;\n{\n  int sig, any_succeeded, listing, saw_signal, dflags;\n  char *sigspec, *word;\n  pid_t pid;\n  intmax_t pid_value;\n\n  if (list == 0)\n    {\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n  CHECK_HELPOPT (list);\n\n  any_succeeded = listing = saw_signal = 0;\n  sig = SIGTERM;\n  sigspec = \"TERM\";\n\n  dflags = DSIG_NOCASE | ((posixly_correct == 0) ? DSIG_SIGPREFIX : 0);\n  /* Process options. */\n  while (list)\n    {\n      word = list->word->word;\n\n      if (ISOPTION (word, 'l') || ISOPTION (word, 'L'))\n\t{\n\t  listing++;\n\t  list = list->next;\n\t}\n      else if (ISOPTION (word, 's') || ISOPTION (word, 'n'))\n\t{\n\t  list = list->next;\n\t  if (list)\n\t    {\n\t      sigspec = list->word->word;\nuse_sigspec:\n\t      if (sigspec[0] == '0' && sigspec[1] == '\\0')\n\t\tsig = 0;\n\t      else\n\t\tsig = decode_signal (sigspec, dflags);\n\t      list = list->next;\n\t      saw_signal++;\n\t    }\n\t  else\n\t    {\n\t      sh_needarg (word);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t}\n      else if (word[0] == '-' && word[1] == 's' && ISALPHA (word[2]))\n\t{\n\t  sigspec = word + 2;\n\t  goto use_sigspec;\n\t}\n      else if (word[0] == '-' && word[1] == 'n' && ISDIGIT (word[2]))\n\t{\n\t  sigspec = word + 2;\n\t  goto use_sigspec;\n\t}\n      else if (ISOPTION (word, '-'))\n\t{\n\t  list = list->next;\n\t  break;\n\t}\n      else if (ISOPTION (word, '?'))\n\t{\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n      /* If this is a signal specification then process it.  We only process\n\t the first one seen; other arguments may signify process groups (e.g,\n\t -num == process group num). */\n      else if (*word == '-' && saw_signal == 0)\n\t{\n\t  sigspec = word + 1;\n\t  sig = decode_signal (sigspec, dflags);\n\t  saw_signal++;\n\t  list = list->next;\n\t}\n      else\n\tbreak;\n    }\n\n  if (listing)\n    return (display_signal_list (list, 0));\n\n  /* OK, we are killing processes. */\n  if (sig == NO_SIG)\n    {\n      sh_invalidsig (sigspec);\n      return (EXECUTION_FAILURE);\n    }\n\n  if (list == 0)\n    {\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n\n  while (list)\n    {\n      word = list->word->word;\n\n      if (*word == '-')\n\tword++;\n\n      /* Use the entire argument in case of minus sign presence. */\n      if (*word && legal_number (list->word->word, &pid_value) && (pid_value == (pid_t)pid_value))\n\t{\n\t  pid = (pid_t) pid_value;\n\n\t  if (kill_pid (pid, sig, pid < -1) < 0)\n\t    {\n\t      if (errno == EINVAL)\n\t\tsh_invalidsig (sigspec);\n\t      else\n\t\tkill_error (pid, errno);\n\t      CONTINUE_OR_FAIL;\n\t    }\n\t  else\n\t    any_succeeded++;\n\t}\n#if defined (JOB_CONTROL)\n      else if (*list->word->word && *list->word->word != '%')\n\t{\n\t  builtin_error (_(\"%s: arguments must be process or job IDs\"), list->word->word);\n\t  CONTINUE_OR_FAIL;\n\t}\n      else if (*word)\n\t/* Posix.2 says you can kill without job control active (4.32.4) */\n\t{\t\t\t/* Must be a job spec.  Check it out. */\n\t  int job;\n\t  sigset_t set, oset;\n\t  JOB *j;\n\n\t  BLOCK_CHILD (set, oset);\n\t  job = get_job_spec (list);\n\n\t  if (INVALID_JOB (job))\n\t    {\n\t      if (job != DUP_JOB)\n\t\tsh_badjob (list->word->word);\n\t      UNBLOCK_CHILD (oset);\n\t      CONTINUE_OR_FAIL;\n\t    }\n\n\t  j = get_job_by_jid (job);\n\t  /* Job spec used.  Kill the process group. If the job was started\n\t     without job control, then its pgrp == shell_pgrp, so we have\n\t     to be careful.  We take the pid of the first job in the pipeline\n\t     in that case. */\n\t  pid = IS_JOBCONTROL (job) ? j->pgrp : j->pipe->pid;\n\n\t  UNBLOCK_CHILD (oset);\n\n\t  if (kill_pid (pid, sig, 1) < 0)\n\t    {\n\t      if (errno == EINVAL)\n\t\tsh_invalidsig (sigspec);\n\t      else\n\t\tkill_error (pid, errno);\n\t      CONTINUE_OR_FAIL;\n\t    }\n\t  else\n\t    any_succeeded++;\n\t}\n#endif /* !JOB_CONTROL */\n      else\n\t{\n\t  sh_badpid (list->word->word);\n\t  CONTINUE_OR_FAIL;\n\t}\n    continue_killing:\n      list = list->next;\n    }\n\n  return (any_succeeded ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n}\n\nstatic void\nkill_error (pid, e)\n     pid_t pid;\n     int e;\n{\n  char *x;\n\n  x = strerror (e);\n  if (x == 0)\n    x = _(\"Unknown error\");\n  builtin_error (\"(%ld) - %s\", (long)pid, x);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}