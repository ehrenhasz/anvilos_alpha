{
  "module_name": "jobs.def",
  "hash_id": "6e4b98d15b4e6398c035e16f4ff06c9a124404dcfa3c29087c6e1338ca47adff",
  "original_prompt": "Ingested from bash-5.2.21/builtins/jobs.def",
  "human_readable_source": "This file is jobs.def, from which is created jobs.c.\nIt implements the builtins \"jobs\" and \"disown\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES jobs.c\n\n$BUILTIN jobs\n$FUNCTION jobs_builtin\n$DEPENDS_ON JOB_CONTROL\n$SHORT_DOC jobs [-lnprs] [jobspec ...] or jobs -x command [args]\nDisplay status of jobs.\n\nLists the active jobs.  JOBSPEC restricts output to that job.\nWithout options, the status of all active jobs is displayed.\n\nOptions:\n  -l\tlists process IDs in addition to the normal information\n  -n\tlists only processes that have changed status since the last\n\t\tnotification\n  -p\tlists process IDs only\n  -r\trestrict output to running jobs\n  -s\trestrict output to stopped jobs\n\nIf -x is supplied, COMMAND is run after all job specifications that\nappear in ARGS have been replaced with the process ID of that job's\nprocess group leader.\n\nExit Status:\nReturns success unless an invalid option is given or an error occurs.\nIf -x is used, returns the exit status of COMMAND.\n$END\n\n#include <config.h>\n\n#if defined (JOB_CONTROL)\n#include \"../bashtypes.h\"\n#include <signal.h>\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../jobs.h\"\n#include \"../execute_cmd.h\"\n#include \"bashgetopt.h\"\n#include \"common.h\"\n\n#define JSTATE_ANY\t0x0\n#define JSTATE_RUNNING\t0x1\n#define JSTATE_STOPPED\t0x2\n\nstatic int execute_list_with_replacements PARAMS((WORD_LIST *));\n\n/* The `jobs' command.  Prints outs a list of active jobs.  If the\n   argument `-l' is given, then the process id's are printed also.\n   If the argument `-p' is given, print the process group leader's\n   pid only.  If `-n' is given, only processes that have changed\n   status since the last notification are printed.  If -x is given,\n   replace all job specs with the pid of the appropriate process\n   group leader and execute the command.  The -r and -s options mean\n   to print info about running and stopped jobs only, respectively. */\nint\njobs_builtin (list)\n     WORD_LIST *list;\n{\n  int form, execute, state, opt, any_failed, job;\n  sigset_t set, oset;\n\n  execute = any_failed = 0;\n  form = JLIST_STANDARD;\n  state = JSTATE_ANY;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"lpnxrs\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'l':\n\t  form = JLIST_LONG;\n\t  break;\n\tcase 'p':\n\t  form = JLIST_PID_ONLY;\n\t  break;\n\tcase 'n':\n\t  form = JLIST_CHANGED_ONLY;\n\t  break;\n\tcase 'x':\n\t  if (form != JLIST_STANDARD)\n\t    {\n\t      builtin_error (_(\"no other options allowed with `-x'\"));\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  execute++;\n\t  break;\n\tcase 'r':\n\t  state = JSTATE_RUNNING;\n\t  break;\n\tcase 's':\n\t  state = JSTATE_STOPPED;\n\t  break;\n\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  if (execute)\n    return (execute_list_with_replacements (list));\n\n  if (!list)\n    {\n      switch (state)\n\t{\n\tcase JSTATE_ANY:\n\t  list_all_jobs (form);\n\t  break;\n\tcase JSTATE_RUNNING:\n\t  list_running_jobs (form);\n\t  break;\n\tcase JSTATE_STOPPED:\n\t  list_stopped_jobs (form);\n\t  break;\n\t}\n      return (EXECUTION_SUCCESS);\n    }\n\n  while (list)\n    {\n      BLOCK_CHILD (set, oset);\n      job = get_job_spec (list);\n\n      if ((job == NO_JOB) || jobs == 0 || get_job_by_jid (job) == 0)\n\t{\n\t  sh_badjob (list->word->word);\n\t  any_failed++;\n\t}\n      else if (job != DUP_JOB)\n\tlist_one_job ((JOB *)NULL, form, 0, job);\n\n      UNBLOCK_CHILD (oset);\n      list = list->next;\n    }\n  return (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n\nstatic int\nexecute_list_with_replacements (list)\n     WORD_LIST *list;\n{\n  register WORD_LIST *l;\n  int job, result;\n  COMMAND *command;\n  JOB *j;\n\n  /* First do the replacement of job specifications with pids. */\n  for (l = list; l; l = l->next)\n    {\n      if (l->word->word[0] == '%')\t/* we have a winner */\n\t{\n\t  job = get_job_spec (l);\n\n\t  /* A bad job spec is not really a job spec! Pass it through. */\n\t  if (INVALID_JOB (job))\n\t    continue;\n\n\t  j = get_job_by_jid (job);\n\t  free (l->word->word);\n\t  l->word->word = itos (j->pgrp);\n\t}\n    }\n\n  /* Next make a new simple command and execute it. */\n  begin_unwind_frame (\"jobs_builtin\");\n\n  command = make_bare_simple_command ();\n  command->value.Simple->words = copy_word_list (list);\n  command->value.Simple->redirects = (REDIRECT *)NULL;\n  command->flags |= CMD_INHIBIT_EXPANSION;\n  command->value.Simple->flags |= CMD_INHIBIT_EXPANSION;\n\n  add_unwind_protect (dispose_command, command);\n  result = execute_command (command);\n  dispose_command (command);\n\n  discard_unwind_frame (\"jobs_builtin\");\n  return (result);\n}\n#endif /* JOB_CONTROL */\n\n$BUILTIN disown\n$FUNCTION disown_builtin\n$DEPENDS_ON JOB_CONTROL\n$SHORT_DOC disown [-h] [-ar] [jobspec ... | pid ...]\nRemove jobs from current shell.\n\nRemoves each JOBSPEC argument from the table of active jobs.  Without\nany JOBSPECs, the shell uses its notion of the current job.\n\nOptions:\n  -a\tremove all jobs if JOBSPEC is not supplied\n  -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n\t\tshell receives a SIGHUP\n  -r\tremove only running jobs\n\nExit Status:\nReturns success unless an invalid option or JOBSPEC is given.\n$END\n\n#if defined (JOB_CONTROL)\nint\ndisown_builtin (list)\n     WORD_LIST *list;\n{\n  int opt, job, retval, nohup_only, running_jobs, all_jobs;\n  sigset_t set, oset;\n  intmax_t pid_value;\n\n  nohup_only = running_jobs = all_jobs = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"ahr\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'a':\n\t  all_jobs = 1;\n\t  break;\n\tcase 'h':\n\t  nohup_only = 1;\n\t  break;\n\tcase 'r':\n\t  running_jobs = 1;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n  retval = EXECUTION_SUCCESS;\n\n  /* `disown -a' or `disown -r' */\n  if (list == 0 && (all_jobs || running_jobs))\n    {\n      if (nohup_only)\n\tnohup_all_jobs (running_jobs);\n      else\n\tdelete_all_jobs (running_jobs);\n      return (EXECUTION_SUCCESS);\n    }\n\n  do\n    {\n      BLOCK_CHILD (set, oset);\n      job = (list && legal_number (list->word->word, &pid_value) && pid_value == (pid_t) pid_value)\n\t\t? get_job_by_pid ((pid_t) pid_value, 0, 0)\n\t\t: get_job_spec (list);\n\n      if (job == NO_JOB || jobs == 0 || INVALID_JOB (job))\n\t{\n\t  sh_badjob (list ? list->word->word : _(\"current\"));\n\t  retval = EXECUTION_FAILURE;\n\t}\n      else if (nohup_only)\n\tnohup_job (job);\n      else\n\tdelete_job (job, 1);\n      UNBLOCK_CHILD (oset);\n\n      if (list)\n\tlist = list->next;\n    }\n  while (list);\n\n  return (retval);\n}\n#endif /* JOB_CONTROL */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}