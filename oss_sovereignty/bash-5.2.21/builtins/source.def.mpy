{
  "module_name": "source.def",
  "hash_id": "c82205c3fe42ba6f751c780fb8a10d84b91ae81e58aa4a64dfa23429b1d87734",
  "original_prompt": "Ingested from bash-5.2.21/builtins/source.def",
  "human_readable_source": "This file is source.def, from which is created source.c.\nIt implements the builtins \".\" and  \"source\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES source.c\n\n$BUILTIN source\n$FUNCTION source_builtin\n$SHORT_DOC source filename [arguments]\nExecute commands from a file in the current shell.\n\nRead and execute commands from FILENAME in the current shell.  The\nentries in $PATH are used to find the directory containing FILENAME.\nIf any ARGUMENTS are supplied, they become the positional parameters\nwhen FILENAME is executed.\n\nExit Status:\nReturns the status of the last command executed in FILENAME; fails if\nFILENAME cannot be read.\n$END\n\n$BUILTIN .\n$DOCNAME dot\n$FUNCTION source_builtin\n$SHORT_DOC . filename [arguments]\nExecute commands from a file in the current shell.\n\nRead and execute commands from FILENAME in the current shell.  The\nentries in $PATH are used to find the directory containing FILENAME.\nIf any ARGUMENTS are supplied, they become the positional parameters\nwhen FILENAME is executed.\n\nExit Status:\nReturns the status of the last command executed in FILENAME; fails if\nFILENAME cannot be read.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n#include \"filecntl.h\"\n#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include <errno.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../flags.h\"\n#include \"../findcmd.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n#include \"../trap.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\nstatic void maybe_pop_dollar_vars PARAMS((void));\n\n/* If non-zero, `.' uses $PATH to look up the script to be sourced. */\nint source_uses_path = 1;\n\n/* If non-zero, `.' looks in the current directory if the filename argument\n   is not found in the $PATH. */\nint source_searches_cwd = 1;\n\n/* If this . script is supplied arguments, we save the dollar vars and\n   replace them with the script arguments for the duration of the script's\n   execution.  If the script does not change the dollar vars, we restore\n   what we saved.  If the dollar vars are changed in the script, and we are\n   not executing a shell function, we leave the new values alone and free\n   the saved values. */\nstatic void\nmaybe_pop_dollar_vars ()\n{\n  if (variable_context == 0 && (dollar_vars_changed () & ARGS_SETBLTIN))\n    dispose_saved_dollar_vars ();\n  else\n    pop_dollar_vars ();\n  if (debugging_mode)\n    pop_args ();\t/* restore BASH_ARGC and BASH_ARGV */\n  set_dollar_vars_unchanged ();\n  invalidate_cached_quoted_dollar_at ();\t/* just invalidate to be safe */\n}\n\n/* Read and execute commands from the file passed as argument.  Guess what.\n   This cannot be done in a subshell, since things like variable assignments\n   take place in there.  So, I open the file, place it into a large string,\n   close the file, and then execute the string. */\nint\nsource_builtin (list)\n     WORD_LIST *list;\n{\n  int result;\n  char *filename, *debug_trap, *x;\n\n  if (no_options (list))\n    return (EX_USAGE);\n  list = loptend;\n\n  if (list == 0)\n    {\n      builtin_error (_(\"filename argument required\"));\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n\n#if defined (RESTRICTED_SHELL)\n  if (restricted && strchr (list->word->word, '/'))\n    {\n      sh_restricted (list->word->word);\n      return (EXECUTION_FAILURE);\n    }\n#endif\n\n  filename = (char *)NULL;\n  /* XXX -- should this be absolute_pathname? */\n  if (posixly_correct && strchr (list->word->word, '/'))\n    filename = savestring (list->word->word);\n  else if (absolute_pathname (list->word->word))\n    filename = savestring (list->word->word);\n  else if (source_uses_path)\n    filename = find_path_file (list->word->word);\n  if (filename == 0)\n    {\n      if (source_searches_cwd == 0)\n\t{\n\t  x = printable_filename (list->word->word, 0);\n\t  builtin_error (_(\"%s: file not found\"), x);\n\t  if (x != list->word->word)\n\t    free (x);\n\t  if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      jump_to_top_level (EXITPROG);\n\t    }\n\t  return (EXECUTION_FAILURE);\n\t}\n      else\n\tfilename = savestring (list->word->word);\n    }\n\n  begin_unwind_frame (\"source\");\n  add_unwind_protect (xfree, filename);\n\n  if (list->next)\n    {\n      push_dollar_vars ();\n      add_unwind_protect ((Function *)maybe_pop_dollar_vars, (char *)NULL);\n      if (debugging_mode || shell_compatibility_level <= 44)\n\tinit_bash_argv ();\t/* Initialize BASH_ARGV and BASH_ARGC */\n      remember_args (list->next, 1);\n      if (debugging_mode)\n\tpush_args (list->next);\t/* Update BASH_ARGV and BASH_ARGC */\n    }\n  set_dollar_vars_unchanged ();\n\n  /* Don't inherit the DEBUG trap unless function_trace_mode (overloaded)\n     is set.  XXX - should sourced files inherit the RETURN trap?  Functions\n     don't. */\n  debug_trap = TRAP_STRING (DEBUG_TRAP);\n  if (debug_trap && function_trace_mode == 0)\n    {\n      debug_trap = savestring (debug_trap);\n      add_unwind_protect (xfree, debug_trap);\n      add_unwind_protect (maybe_set_debug_trap, debug_trap);\n      restore_default_signal (DEBUG_TRAP);\n    }\n\n  result = source_file (filename, (list && list->next));\n\n  run_unwind_frame (\"source\");\n\n  return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}