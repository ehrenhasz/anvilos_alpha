{
  "module_name": "common.c",
  "hash_id": "9764fcb41d2830f5d4f82e92cb50a1ab2d0a773ed1eeea0ff2bf220ca3de549e",
  "original_prompt": "Ingested from bash-5.2.21/builtins/common.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <chartypes.h>\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n#include <signal.h>\n\n#include <errno.h>\n\n#if defined (PREFER_STDARG)\n#  include <stdarg.h>\n#else\n#  include <varargs.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#define NEED_FPURGE_DECL\n\n#include \"../shell.h\"\n#include \"maxpath.h\"\n#include \"../flags.h\"\n#include \"../parser.h\"\n#include \"../jobs.h\"\n#include \"../builtins.h\"\n#include \"../input.h\"\n#include \"../execute_cmd.h\"\n#include \"../trap.h\"\n#include \"bashgetopt.h\"\n#include \"common.h\"\n#include \"builtext.h\"\n#include <tilde/tilde.h>\n\n#if defined (HISTORY)\n#  include \"../bashhist.h\"\n#endif\n\n#if !defined (errno)\nextern int errno;   \n#endif  \n\nextern const char * const bash_getcwd_errstr;\n\n \nsh_builtin_func_t *last_shell_builtin = (sh_builtin_func_t *)NULL;\nsh_builtin_func_t *this_shell_builtin = (sh_builtin_func_t *)NULL;\n\n \n \n \n \n \n\n \n\nstatic void\nbuiltin_error_prolog ()\n{\n  char *name;\n\n  name = get_name_for_error ();\n  fprintf (stderr, \"%s: \", name);\n\n  if (interactive_shell == 0)\n    fprintf (stderr, _(\"line %d: \"), executing_line_number ());\n\n  if (this_command_name && *this_command_name)\n    fprintf (stderr, \"%s: \", this_command_name);\n}\n\nvoid\n#if defined (PREFER_STDARG)\nbuiltin_error (const char *format, ...)\n#else\nbuiltin_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  builtin_error_prolog ();\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  va_end (args);\n  fprintf (stderr, \"\\n\");\n}\n\nvoid\n#if defined (PREFER_STDARG)\nbuiltin_warning (const char *format, ...)\n#else\nbuiltin_warning (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  builtin_error_prolog ();\n  fprintf (stderr, _(\"warning: \"));\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  va_end (args);\n  fprintf (stderr, \"\\n\");\n}\n\n \nvoid\nbuiltin_usage ()\n{\n  if (this_command_name && *this_command_name)\n    fprintf (stderr, _(\"%s: usage: \"), this_command_name);\n  fprintf (stderr, \"%s\\n\", _(current_builtin->short_doc));\n  fflush (stderr);\n}\n\n \nvoid\nno_args (list)\n     WORD_LIST *list;\n{\n  if (list)\n    {\n      builtin_error (_(\"too many arguments\"));\n      top_level_cleanup ();\n      jump_to_top_level (DISCARD);\n    }\n}\n\n \nint\nno_options (list)\n     WORD_LIST *list;\n{\n  int opt;\n\n  reset_internal_getopt ();\n  if ((opt = internal_getopt (list, \"\")) != -1)\n    {\n      if (opt == GETOPT_HELP)\n\t{\n\t  builtin_help ();\n\t  return (2);\n\t}\n      builtin_usage ();\n      return (1);\n    }\n  return (0);\n}\n\nvoid\nsh_needarg (s)\n     char *s;\n{\n  builtin_error (_(\"%s: option requires an argument\"), s);\n}\n\nvoid\nsh_neednumarg (s)\n     char *s;\n{\n  builtin_error (_(\"%s: numeric argument required\"), s);\n}\n\nvoid\nsh_notfound (s)\n     char *s;\n{\n  builtin_error (_(\"%s: not found\"), s);\n}\n\n \nvoid\nsh_invalidopt (s)\n     char *s;\n{\n  builtin_error (_(\"%s: invalid option\"), s);\n}\n\nvoid\nsh_invalidoptname (s)\n     char *s;\n{\n  builtin_error (_(\"%s: invalid option name\"), s);\n}\n\nvoid\nsh_invalidid (s)\n     char *s;\n{\n  builtin_error (_(\"`%s': not a valid identifier\"), s);\n}\n\nvoid\nsh_invalidnum (s)\n     char *s;\n{\n  char *msg;\n\n  if (*s == '0' && isdigit ((unsigned char)s[1]))\n    msg = _(\"invalid octal number\");\n  else if (*s == '0' && s[1] == 'x')\n    msg = _(\"invalid hex number\");\n  else\n    msg = _(\"invalid number\");\n  builtin_error (\"%s: %s\", s, msg);\n}\n\nvoid\nsh_invalidsig (s)\n     char *s;\n{\n  builtin_error (_(\"%s: invalid signal specification\"), s);\n}\n\nvoid\nsh_badpid (s)\n     char *s;\n{\n  builtin_error (_(\"`%s': not a pid or valid job spec\"), s);\n}\n\nvoid\nsh_readonly (s)\n     const char *s;\n{\n  builtin_error (_(\"%s: readonly variable\"), s);\n}\n\nvoid\nsh_noassign (s)\n     const char *s;\n{\n  internal_error (_(\"%s: cannot assign\"), s);\t \n}\n\nvoid\nsh_erange (s, desc)\n     char *s, *desc;\n{\n  if (s)\n    builtin_error (_(\"%s: %s out of range\"), s, desc ? desc : _(\"argument\"));\n  else\n    builtin_error (_(\"%s out of range\"), desc ? desc : _(\"argument\"));\n}\n\n#if defined (JOB_CONTROL)\nvoid\nsh_badjob (s)\n     char *s;\n{\n  builtin_error (_(\"%s: no such job\"), s);\n}\n\nvoid\nsh_nojobs (s)\n     char *s;\n{\n  if (s)\n    builtin_error (_(\"%s: no job control\"), s);\n  else\n    builtin_error (_(\"no job control\"));\n}\n#endif\n\n#if defined (RESTRICTED_SHELL)\nvoid\nsh_restricted (s)\n     char *s;\n{\n  if (s)\n    builtin_error (_(\"%s: restricted\"), s);\n  else\n    builtin_error (_(\"restricted\"));\n}\n#endif\n\nvoid\nsh_notbuiltin (s)\n     char *s;\n{\n  builtin_error (_(\"%s: not a shell builtin\"), s);\n}\n\nvoid\nsh_wrerror ()\n{\n#if defined (DONT_REPORT_BROKEN_PIPE_WRITE_ERRORS) && defined (EPIPE)\n  if (errno != EPIPE)\n#endif  \n  builtin_error (_(\"write error: %s\"), strerror (errno));\n}\n\nvoid\nsh_ttyerror (set)\n     int set;\n{\n  if (set)\n    builtin_error (_(\"error setting terminal attributes: %s\"), strerror (errno));\n  else\n    builtin_error (_(\"error getting terminal attributes: %s\"), strerror (errno));\n}\n\nint\nsh_chkwrite (s)\n     int s;\n{\n  QUIT;\n  fflush (stdout);\n  QUIT;\n  if (ferror (stdout))\n    {\n      sh_wrerror ();\n      fpurge (stdout);\n      clearerr (stdout);\n      return (EXECUTION_FAILURE);\n    }\n  return (s);\n}\n\n \n \n \n \n \n\n \nchar **\nmake_builtin_argv (list, ip)\n     WORD_LIST *list;\n     int *ip;\n{\n  char **argv;\n\n  argv = strvec_from_word_list (list, 0, 1, ip);\n  argv[0] = this_command_name;\n  return argv;\n}\n\n \nvoid\nremember_args (list, destructive)\n     WORD_LIST *list;\n     int destructive;\n{\n  register int i;\n\n  posparam_count = 0;\n\n  for (i = 1; i < 10; i++)\n    {\n      if ((destructive || list) && dollar_vars[i])\n\t{\n\t  free (dollar_vars[i]);\n\t  dollar_vars[i] = (char *)NULL;\n\t}\n\n      if (list)\n\t{\n\t  dollar_vars[posparam_count = i] = savestring (list->word->word);\n\t  list = list->next;\n\t}\n    }\n\n   \n  if (destructive || list)\n    {\n      dispose_words (rest_of_args);\n      rest_of_args = copy_word_list (list);\n      posparam_count += list_length (list);\n    }\n\n  if (destructive)\n    set_dollar_vars_changed ();\n\n  invalidate_cached_quoted_dollar_at ();\n}\n\nvoid\nshift_args (times)\n     int times;\n{\n  WORD_LIST *temp;\n  int count;\n\n  if (times <= 0)\t\t \n    return;\n\n  while (times-- > 0)\n    {\n      if (dollar_vars[1])\n\tfree (dollar_vars[1]);\n\n      for (count = 1; count < 9; count++)\n\tdollar_vars[count] = dollar_vars[count + 1];\n\n      if (rest_of_args)\n\t{\n\t  temp = rest_of_args;\n\t  dollar_vars[9] = savestring (temp->word->word);\n\t  rest_of_args = rest_of_args->next;\n\t  temp->next = (WORD_LIST *)NULL;\n\t  dispose_words (temp);\n\t}\n      else\n\tdollar_vars[9] = (char *)NULL;\n\n      posparam_count--;\n    }\n}\n\nint\nnumber_of_args ()\n{\n#if 0\n  register WORD_LIST *list;\n  int n;\n\n  for (n = 0; n < 9 && dollar_vars[n+1]; n++)\n    ;\n  for (list = rest_of_args; list; list = list->next)\n    n++;\n\nif (n != posparam_count)\n  itrace(\"number_of_args: n (%d) != posparam_count (%d)\", n, posparam_count);\n#else\n  return posparam_count;\n#endif\n}\n\nstatic int changed_dollar_vars;\n\n \nint\ndollar_vars_changed ()\n{\n  return (changed_dollar_vars);\n}\n\nvoid\nset_dollar_vars_unchanged ()\n{\n  changed_dollar_vars = 0;\n}\n\nvoid\nset_dollar_vars_changed ()\n{\n  if (variable_context)\n    changed_dollar_vars |= ARGS_FUNC;\n  else if (this_shell_builtin == set_builtin)\n    changed_dollar_vars |= ARGS_SETBLTIN;\n  else\n    changed_dollar_vars |= ARGS_INVOC;\n}\n\n \n \n \n \n \n\n \nint\nget_numeric_arg (list, fatal, count)\n     WORD_LIST *list;\n     int fatal;\n     intmax_t *count;\n{\n  char *arg;\n\n  if (count)\n    *count = 1;\n\n  if (list && list->word && ISOPTION (list->word->word, '-'))\n    list = list->next;\n\n  if (list)\n    {\n      arg = list->word->word;\n      if (arg == 0 || (legal_number (arg, count) == 0))\n\t{\n\t  sh_neednumarg (list->word->word ? list->word->word : \"`'\");\n\t  if (fatal == 0)\n\t    return 0;\n\t  else if (fatal == 1)\t\t \n\t    throw_to_top_level ();\n\t  else\t\t\t\t \n\t    {\n\t      top_level_cleanup ();\n\t      jump_to_top_level (DISCARD);\n\t    }\n\t}\n      no_args (list->next);\n    }\n\n  return (1);\n}\n\n \nint\nget_exitstat (list)\n     WORD_LIST *list;\n{\n  int status;\n  intmax_t sval;\n  char *arg;\n\n  if (list && list->word && ISOPTION (list->word->word, '-'))\n    list = list->next;\n\n  if (list == 0)\n    {\n       \n      if (this_shell_builtin == return_builtin && running_trap > 0 && running_trap != DEBUG_TRAP+1)\n\treturn (trap_saved_exit_value);\n      return (last_command_exit_value);\n    }\n\n  arg = list->word->word;\n  if (arg == 0 || legal_number (arg, &sval) == 0)\n    {\n      sh_neednumarg (list->word->word ? list->word->word : \"`'\");\n      return EX_BADUSAGE;\n    }\n  no_args (list->next);\n\n  status = sval & 255;\n  return status;\n}\n\n \nint\nread_octal (string)\n     char *string;\n{\n  int result, digits;\n\n  result = digits = 0;\n  while (*string && ISOCTAL (*string))\n    {\n      digits++;\n      result = (result * 8) + (*string++ - '0');\n      if (result > 07777)\n\treturn -1;\n    }\n\n  if (digits == 0 || *string)\n    result = -1;\n\n  return (result);\n}\n\n \n \n \n \n \n\n \nchar *the_current_working_directory = (char *)NULL;\n\nchar *\nget_working_directory (for_whom)\n     char *for_whom;\n{\n  if (no_symbolic_links)\n    {\n      FREE (the_current_working_directory);\n      the_current_working_directory = (char *)NULL;\n    }\n\n  if (the_current_working_directory == 0)\n    {\n#if defined (GETCWD_BROKEN)\n      the_current_working_directory = getcwd (0, PATH_MAX);\n#else\n      the_current_working_directory = getcwd (0, 0);\n#endif\n      if (the_current_working_directory == 0)\n\t{\n\t  fprintf (stderr, _(\"%s: error retrieving current directory: %s: %s\\n\"),\n\t\t   (for_whom && *for_whom) ? for_whom : get_name_for_error (),\n\t\t   _(bash_getcwd_errstr), strerror (errno));\n\t  return (char *)NULL;\n\t}\n    }\n\n  return (savestring (the_current_working_directory));\n}\n\n \nvoid\nset_working_directory (name)\n     char *name;\n{\n  FREE (the_current_working_directory);\n  the_current_working_directory = savestring (name);\n}\n\n \n \n \n \n \n\n#if defined (JOB_CONTROL)\nint\nget_job_by_name (name, flags)\n     const char *name;\n     int flags;\n{\n  register int i, wl, cl, match, job;\n  register PROCESS *p;\n  register JOB *j;\n\n  job = NO_JOB;\n  wl = strlen (name);\n  for (i = js.j_jobslots - 1; i >= 0; i--)\n    {\n      j = get_job_by_jid (i);\n      if (j == 0 || ((flags & JM_STOPPED) && J_JOBSTATE(j) != JSTOPPED))\n        continue;\n\n      p = j->pipe;\n      do\n        {\n\t  if (flags & JM_EXACT)\n\t    {\n\t      cl = strlen (p->command);\n\t      match = STREQN (p->command, name, cl);\n\t    }\n\t  else if (flags & JM_SUBSTRING)\n\t    match = strcasestr (p->command, name) != (char *)0;\n\t  else\n\t    match = STREQN (p->command, name, wl);\n\n\t  if (match == 0)\n\t    {\n\t      p = p->next;\n\t      continue;\n\t    }\n\t  else if (flags & JM_FIRSTMATCH)\n\t    return i;\t\t \n\t  else if (job != NO_JOB)\n\t    {\n\t      if (this_shell_builtin)\n\t        builtin_error (_(\"%s: ambiguous job spec\"), name);\n\t      else\n\t        internal_error (_(\"%s: ambiguous job spec\"), name);\n\t      return (DUP_JOB);\n\t    }\n\t  else\n\t    job = i;\n        }\n      while (p != j->pipe);\n    }\n\n  return (job);\n}\n\n \nint\nget_job_spec (list)\n     WORD_LIST *list;\n{\n  register char *word;\n  int job, jflags;\n\n  if (list == 0)\n    return (js.j_current);\n\n  word = list->word->word;\n\n  if (*word == '\\0')\n    return (NO_JOB);\n\n  if (*word == '%')\n    word++;\n\n  if (DIGIT (*word) && all_digits (word))\n    {\n      job = atoi (word);\n      return ((job < 0 || job > js.j_jobslots) ? NO_JOB : job - 1);\n    }\n\n  jflags = 0;\n  switch (*word)\n    {\n    case 0:\n    case '%':\n    case '+':\n      return (js.j_current);\n\n    case '-':\n      return (js.j_previous);\n\n    case '?':\t\t\t \n      jflags |= JM_SUBSTRING;\n      word++;\n       \n\n    default:\n      return get_job_by_name (word, jflags);\n    }\n}\n#endif  \n\n \nint\ndisplay_signal_list (list, forcecols)\n     WORD_LIST *list;\n     int forcecols;\n{\n  register int i, column;\n  char *name;\n  int result, signum, dflags;\n  intmax_t lsignum;\n\n  result = EXECUTION_SUCCESS;\n  if (!list)\n    {\n      for (i = 1, column = 0; i < NSIG; i++)\n\t{\n\t  name = signal_name (i);\n\t  if (STREQN (name, \"SIGJUNK\", 7) || STREQN (name, \"Unknown\", 7))\n\t    continue;\n\n\t  if (posixly_correct && !forcecols)\n\t    {\n\t       \n\t      if (STREQN (name, \"SIG\", 3))\n\t\tname += 3;\n\t      printf (\"%s%s\", name, (i == NSIG - 1) ? \"\" : \" \");\n\t    }\n\t  else\n\t    {\n\t      printf (\"%2d) %s\", i, name);\n\n\t      if (++column < 5)\n\t\tprintf (\"\\t\");\n\t      else\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  column = 0;\n\t\t}\n\t    }\n\t}\n\n      if ((posixly_correct && !forcecols) || column != 0)\n\tprintf (\"\\n\");\n      return result;\n    }\n\n   \n  while (list)\n    {\n      if (legal_number (list->word->word, &lsignum))\n\t{\n\t   \n\t  if (lsignum > 128)\n\t    lsignum -= 128;\n\t  if (lsignum < 0 || lsignum >= NSIG)\n\t    {\n\t      sh_invalidsig (list->word->word);\n\t      result = EXECUTION_FAILURE;\n\t      list = list->next;\n\t      continue;\n\t    }\n\n\t  signum = lsignum;\n\t  name = signal_name (signum);\n\t  if (STREQN (name, \"SIGJUNK\", 7) || STREQN (name, \"Unknown\", 7))\n\t    {\n\t      list = list->next;\n\t      continue;\n\t    }\n\t   \n\t  printf (\"%s\\n\", (this_shell_builtin == kill_builtin && signum > 0) ? name + 3 : name);\n\t}\n      else\n\t{\n\t  dflags = DSIG_NOCASE;\n\t  if (posixly_correct == 0 || this_shell_builtin != kill_builtin)\n\t    dflags |= DSIG_SIGPREFIX;\n\t  signum = decode_signal (list->word->word, dflags);\n\t  if (signum == NO_SIG)\n\t    {\n\t      sh_invalidsig (list->word->word);\n\t      result = EXECUTION_FAILURE;\n\t      list = list->next;\n\t      continue;\n\t    }\n\t  printf (\"%d\\n\", signum);\n\t}\n      list = list->next;\n    }\n  return (result);\n}\n\n \n \n \n \n \n\n \nstruct builtin *\nbuiltin_address_internal (name, disabled_okay)\n     char *name;\n     int disabled_okay;\n{\n  int hi, lo, mid, j;\n\n  hi = num_shell_builtins - 1;\n  lo = 0;\n\n  while (lo <= hi)\n    {\n      mid = (lo + hi) / 2;\n\n      j = shell_builtins[mid].name[0] - name[0];\n\n      if (j == 0)\n\tj = strcmp (shell_builtins[mid].name, name);\n\n      if (j == 0)\n\t{\n\t   \n\t  if (shell_builtins[mid].function &&\n\t      ((shell_builtins[mid].flags & BUILTIN_DELETED) == 0) &&\n\t      ((shell_builtins[mid].flags & BUILTIN_ENABLED) || disabled_okay))\n\t    return (&shell_builtins[mid]);\n\t  else\n\t    return ((struct builtin *)NULL);\n\t}\n      if (j > 0)\n\thi = mid - 1;\n      else\n\tlo = mid + 1;\n    }\n  return ((struct builtin *)NULL);\n}\n\n \nsh_builtin_func_t *\nfind_shell_builtin (name)\n     char *name;\n{\n  current_builtin = builtin_address_internal (name, 0);\n  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);\n}\n\n \nsh_builtin_func_t *\nbuiltin_address (name)\n     char *name;\n{\n  current_builtin = builtin_address_internal (name, 1);\n  return (current_builtin ? current_builtin->function : (sh_builtin_func_t *)NULL);\n}\n\n \nsh_builtin_func_t *\nfind_special_builtin (name)\n     char *name;\n{\n  current_builtin = builtin_address_internal (name, 0);\n  return ((current_builtin && (current_builtin->flags & SPECIAL_BUILTIN)) ?\n  \t\t\tcurrent_builtin->function :\n  \t\t\t(sh_builtin_func_t *)NULL);\n}\n\nstatic int\nshell_builtin_compare (sbp1, sbp2)\n     struct builtin *sbp1, *sbp2;\n{\n  int result;\n\n  if ((result = sbp1->name[0] - sbp2->name[0]) == 0)\n    result = strcmp (sbp1->name, sbp2->name);\n\n  return (result);\n}\n\n \nvoid\ninitialize_shell_builtins ()\n{\n  qsort (shell_builtins, num_shell_builtins, sizeof (struct builtin),\n    (QSFUNC *)shell_builtin_compare);\n}\n\n#if !defined (HELP_BUILTIN)\nvoid\nbuiltin_help ()\n{\n  printf (\"%s: %s\\n\", this_command_name, _(\"help not available in this version\"));\n}\n#endif\n\n \n \n \n \n \n\n \nSHELL_VAR *\nbuiltin_bind_variable (name, value, flags)\n     char *name;\n     char *value;\n     int flags;\n{\n  SHELL_VAR *v;\n  int vflags, bindflags;\n\n#if defined (ARRAY_VARS)\n   \n  vflags = assoc_expand_once ? (VA_NOEXPAND|VA_ONEWORD) : 0;\n  bindflags = flags | (assoc_expand_once ? ASS_NOEXPAND : 0) | ASS_ALLOWALLSUB;\n  if (flags & ASS_NOEXPAND)\n    vflags |= VA_NOEXPAND;\n  if (flags & ASS_ONEWORD)\n    vflags |= VA_ONEWORD;\n\n  if (valid_array_reference (name, vflags) == 0)\n    v = bind_variable (name, value, flags);\n  else\n    v = assign_array_element (name, value, bindflags, (array_eltstate_t *)0);\n#else  \n  v = bind_variable (name, value, flags);\n#endif  \n\n  if (v && readonly_p (v) == 0 && noassign_p (v) == 0)\n    VUNSETATTR (v, att_invisible);\n\n  return v;\n}\n\nSHELL_VAR *\nbuiltin_bind_var_to_int (name, val, flags)\n     char *name;\n     intmax_t val;\n     int flags;\n{\n  SHELL_VAR *v;\n\n  v = bind_var_to_int (name, val, flags|ASS_ALLOWALLSUB);\n  return v;\n}\n\n#if defined (ARRAY_VARS)\nSHELL_VAR *\nbuiltin_find_indexed_array (array_name, flags)\n     char *array_name;\n     int flags;\n{\n  SHELL_VAR *entry;\n\n  if ((flags & 2) && legal_identifier (array_name) == 0)\n    {\n      sh_invalidid (array_name);\n      return (SHELL_VAR *)NULL;\n    }\n\n  entry = find_or_make_array_variable (array_name, 1);\n   \n  if (entry == 0)\n    return entry;\n  else if (array_p (entry) == 0)\n    {\n      builtin_error (_(\"%s: not an indexed array\"), array_name);\n      return (SHELL_VAR *)NULL;\n    }\n  else if (invisible_p (entry))\n    VUNSETATTR (entry, att_invisible);\t \n\n  if (flags & 1)\n    array_flush (array_cell (entry));\n\n  return entry;\n}\n#endif  \t\n\n \nint\nbuiltin_unbind_variable (vname)\n     const char *vname;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (vname);\n  if (v && readonly_p (v))\n    {\n      builtin_error (_(\"%s: cannot unset: readonly %s\"), vname, \"variable\");\n      return -2;\n    }\n  else if (v && non_unsettable_p (v))\n    {\n      builtin_error (_(\"%s: cannot unset\"), vname);\n      return -2;\n    }\n  return (unbind_variable (vname));\n}\n\nint\nbuiltin_arrayref_flags (w, baseflags)\n     WORD_DESC *w;\n     int baseflags;\n{\n  char *t;\n  int vflags;\n\n  vflags = baseflags;\n\n   \n  if (w->flags & W_ARRAYREF)\n    vflags |= VA_ONEWORD|VA_NOEXPAND;\n\n#  if 0\n   \n  if (assoc_expand_once && (t =  strchr (w->word, '[')) && t[strlen(t) - 1] == ']')\n    vflags |= VA_ONEWORD|VA_NOEXPAND;\n#  endif\n\n  return vflags;\n}\n\n \n \n \n \n \n\n#if defined (ARRAY_VARS)\nint\nset_expand_once (nval, uwp)\n     int nval, uwp;\n{\n  int oa;\n\n  oa = assoc_expand_once;\n  if (shell_compatibility_level > 51)\t \n    {\n      if (uwp)\n\tunwind_protect_int (assoc_expand_once);\n      assoc_expand_once = nval;\n    }\n  return oa;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}