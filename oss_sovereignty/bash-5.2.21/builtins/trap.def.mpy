{
  "module_name": "trap.def",
  "hash_id": "22f1bb7989082744577c82027dc24871e75ff66f003316c49ddfb139f8bd5b3e",
  "original_prompt": "Ingested from bash-5.2.21/builtins/trap.def",
  "human_readable_source": "This file is trap.def, from which is created trap.c.\nIt implements the builtin \"trap\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES trap.c\n\n$BUILTIN trap\n$FUNCTION trap_builtin\n$SHORT_DOC trap [-lp] [[arg] signal_spec ...]\nTrap signals and other events.\n\nDefines and activates handlers to be run when the shell receives signals\nor other conditions.\n\nARG is a command to be read and executed when the shell receives the\nsignal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\nis supplied) or `-', each specified signal is reset to its original\nvalue.  If ARG is the null string each SIGNAL_SPEC is ignored by the\nshell and by the commands it invokes.\n\nIf a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  If\na SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.  If\na SIGNAL_SPEC is RETURN, ARG is executed each time a shell function or a\nscript run by the . or source builtins finishes executing.  A SIGNAL_SPEC\nof ERR means to execute ARG each time a command's failure would cause the\nshell to exit when the -e option is enabled.\n\nIf no arguments are supplied, trap prints the list of commands associated\nwith each signal.\n\nOptions:\n  -l\tprint a list of signal names and their corresponding numbers\n  -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n\nEach SIGNAL_SPEC is either a signal name in <signal.h> or a signal number.\nSignal names are case insensitive and the SIG prefix is optional.  A\nsignal may be sent to the shell with \"kill -signal $$\".\n\nExit Status:\nReturns success unless a SIGSPEC is invalid or an invalid option is given.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashtypes.h\"\n#include <signal.h>\n#include <stdio.h>\n#include \"../bashansi.h\"\n\n#include \"../shell.h\"\n#include \"../trap.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\nstatic void showtrap PARAMS((int, int));\nstatic int display_traps PARAMS((WORD_LIST *, int));\n\n/* The trap command:\n\n   trap <arg> <signal ...>\n   trap <signal ...>\n   trap -l\n   trap -p [sigspec ...]\n   trap [--]\n\n   Set things up so that ARG is executed when SIGNAL(s) N is received.\n   If ARG is the empty string, then ignore the SIGNAL(s).  If there is\n   no ARG, then set the trap for SIGNAL(s) to its original value.  Just\n   plain \"trap\" means to print out the list of commands associated with\n   each signal number.  Single arg of \"-l\" means list the signal names. */\n\n/* Possible operations to perform on the list of signals.*/\n#define SET 0\t\t\t/* Set this signal to first_arg. */\n#define REVERT 1\t\t/* Revert to this signals original value. */\n#define IGNORE 2\t\t/* Ignore this signal. */\n\nint\ntrap_builtin (list)\n     WORD_LIST *list;\n{\n  int list_signal_names, display, result, opt;\n\n  list_signal_names = display = 0;\n  result = EXECUTION_SUCCESS;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"lp\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'l':\n\t  list_signal_names++;\n\t  break;\n\tcase 'p':\n\t  display++;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  opt = DSIG_NOCASE|DSIG_SIGPREFIX;\t/* flags for decode_signal */\n\n  if (list_signal_names)\n    return (sh_chkwrite (display_signal_list ((WORD_LIST *)NULL, 1)));\n  else if (display || list == 0)\n    {\n      initialize_terminating_signals ();\n      get_all_original_signals ();\n      return (sh_chkwrite (display_traps (list, display && posixly_correct)));\n    }\n  else\n    {\n      char *first_arg;\n      int operation, sig, first_signal;\n\n      operation = SET;\n      first_arg = list->word->word;\n      first_signal = first_arg && *first_arg && all_digits (first_arg) && signal_object_p (first_arg, opt);\n\n      /* Backwards compatibility.  XXX - question about whether or not we\n\t should throw an error if an all-digit argument doesn't correspond\n\t to a valid signal number (e.g., if it's `50' on a system with only\n\t 32 signals).  */\n      if (first_signal)\n\toperation = REVERT;\n      /* When in posix mode, the historical behavior of looking for a\n\t missing first argument is disabled.  To revert to the original\n\t signal handling disposition, use `-' as the first argument. */\n      else if (posixly_correct == 0 && first_arg && *first_arg &&\n\t\t(*first_arg != '-' || first_arg[1]) &&\n\t\tsignal_object_p (first_arg, opt) && list->next == 0)\n\toperation = REVERT;\n      else\n\t{\n\t  list = list->next;\n\t  if (list == 0)\n\t    {\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\t  else if (*first_arg == '\\0')\n\t    operation = IGNORE;\n\t  else if (first_arg[0] == '-' && !first_arg[1])\n\t    operation = REVERT;\n\t}\n\n      /* If we're in a command substitution, we haven't freed the trap strings\n\t (though we reset the signal handlers).  If we're setting a trap to\n\t handle a signal here, free the rest of the trap strings since they\n\t don't apply any more. */\n      if (subshell_environment & SUBSHELL_RESETTRAP)\n\t{\n\t  free_trap_strings ();\n\t  subshell_environment &= ~SUBSHELL_RESETTRAP;\n\t}\n\n      while (list)\n\t{\n\t  sig = decode_signal (list->word->word, opt);\n\n\t  if (sig == NO_SIG)\n\t    {\n\t      sh_invalidsig (list->word->word);\n\t      result = EXECUTION_FAILURE;\n\t    }\n\t  else\n\t    {\n\t      switch (operation)\n\t\t{\n\t\t  case SET:\n\t\t    set_signal (sig, first_arg);\n\t\t    break;\n\n\t\t  case REVERT:\n\t\t    restore_default_signal (sig);\n\n\t\t    /* Signals that the shell treats specially need special\n\t\t       handling. */\n\t\t    switch (sig)\n\t\t      {\n\t\t      case SIGINT:\n\t\t\t/* XXX - should we do this if original disposition\n\t\t\t   was SIG_IGN? */\n\t\t\tif (interactive)\n\t\t\t  set_signal_handler (SIGINT, sigint_sighandler);\n\t\t\t/* special cases for interactive == 0 */\n\t\t\telse if (interactive_shell && (sourcelevel||running_trap||parse_and_execute_level))\n\t\t\t  set_signal_handler (SIGINT, sigint_sighandler);\n\t\t\telse\n\t\t\t  set_signal_handler (SIGINT, termsig_sighandler);\n\t\t\tbreak;\n\n\t\t      case SIGQUIT:\n\t\t\t/* Always ignore SIGQUIT. */\n\t\t\tset_signal_handler (SIGQUIT, SIG_IGN);\n\t\t\tbreak;\n\t\t      case SIGTERM:\n#if defined (JOB_CONTROL)\n\t\t      case SIGTTIN:\n\t\t      case SIGTTOU:\n\t\t      case SIGTSTP:\n#endif /* JOB_CONTROL */\n\t\t\tif (interactive)\n\t\t\t  set_signal_handler (sig, SIG_IGN);\n\t\t\tbreak;\n\t\t      }\n\t\t    break;\n\n\t\t  case IGNORE:\n\t\t    ignore_signal (sig);\n\t\t    break;\n\t\t}\n\t    }\n\t  list = list->next;\n\t}\n    }\n\n  return (result);\n}\n\nstatic void\nshowtrap (i, show_default)\n     int i, show_default;\n{\n  char *t, *p, *sn;\n  int free_t;\n\n  free_t = 1;\n  p = trap_list[i];\n  if (p == (char *)DEFAULT_SIG && signal_is_hard_ignored (i) == 0)\n    {\n      if (show_default)\n\tt = \"-\";\n      else\n\treturn;\n      free_t = 0;\n    }\n  else if (signal_is_hard_ignored (i))\n    t = (char *)NULL;\n  else\n    t = (p == (char *)IGNORE_SIG) ? (char *)NULL : sh_single_quote (p);\n\n  sn = signal_name (i);\n  /* Make sure that signals whose names are unknown (for whatever reason)\n     are printed as signal numbers. */\n  if (STREQN (sn, \"SIGJUNK\", 7) || STREQN (sn, \"unknown\", 7))\n    printf (\"trap -- %s %d\\n\", t ? t : \"''\", i);\n  else if (posixly_correct)\n    {\n      if (STREQN (sn, \"SIG\", 3))\n\tprintf (\"trap -- %s %s\\n\", t ? t : \"''\", sn+3);\n      else\n\tprintf (\"trap -- %s %s\\n\", t ? t : \"''\", sn);\n    }\n  else\n    printf (\"trap -- %s %s\\n\", t ? t : \"''\", sn);\n\n  if (free_t)\n    FREE (t);\n}\n\nstatic int\ndisplay_traps (list, show_all)\n     WORD_LIST *list;\n     int show_all;\n{\n  int result, i;\n\n  if (list == 0)\n    {\n      for (i = 0; i < BASH_NSIG; i++)\n\tshowtrap (i, show_all);\n      return (EXECUTION_SUCCESS);\n    }\n\n  for (result = EXECUTION_SUCCESS; list; list = list->next)\n    {\n      i = decode_signal (list->word->word, DSIG_NOCASE|DSIG_SIGPREFIX);\n      if (i == NO_SIG)\n\t{\n\t  sh_invalidsig (list->word->word);\n\t  result = EXECUTION_FAILURE;\n\t}\n      else\n\tshowtrap (i, show_all);\n    }\n\n  return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}