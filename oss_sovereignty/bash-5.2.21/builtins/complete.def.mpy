{
  "module_name": "complete.def",
  "hash_id": "19e54e2031382fad4dae20af4c7a4ea9e1149acb1842ceadfa44e524934ac283",
  "original_prompt": "Ingested from bash-5.2.21/builtins/complete.def",
  "human_readable_source": "This file is complete.def, from which is created complete.c.\nIt implements the builtins \"complete\", \"compgen\", and \"compopt\" in Bash.\n\nCopyright (C) 1999-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES complete.c\n\n$BUILTIN complete\n$DEPENDS_ON PROGRAMMABLE_COMPLETION\n$FUNCTION complete_builtin\n$SHORT_DOC complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]\nSpecify how arguments are to be completed by Readline.\n\nFor each NAME, specify how arguments are to be completed.  If no options\nare supplied, existing completion specifications are printed in a way that\nallows them to be reused as input.\n\nOptions:\n  -p\tprint existing completion specifications in a reusable format\n  -r\tremove a completion specification for each NAME, or, if no\n\t\tNAMEs are supplied, all completion specifications\n  -D\tapply the completions and actions as the default for commands\n\t\twithout any specific completion defined\n  -E\tapply the completions and actions to \"empty\" commands --\n\t\tcompletion attempted on a blank line\n  -I\tapply the completions and actions to the initial (usually the\n\t\tcommand) word\n\nWhen completion is attempted, the actions are applied in the order the\nuppercase-letter options are listed above. If multiple options are supplied,\nthe -D option takes precedence over -E, and both take precedence over -I.\n\nExit Status:\nReturns success unless an invalid option is supplied or an error occurs.\n$END\n\n#include <config.h>\n\n#include <stdio.h>\n\n#include \"../bashtypes.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../builtins.h\"\n#include \"../pcomplete.h\"\n#include \"../bashline.h\"\n\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#include <readline/readline.h>\n\n#define STRDUP(x)       ((x) ? savestring (x) : (char *)NULL)\n\n/* Structure containing all the non-action (binary) options; filled in by\n   build_actions(). */\nstruct _optflags {\n  int pflag;\n  int rflag;\n  int Dflag;\n  int Eflag;\n  int Iflag;\n};\n\nstatic int find_compact PARAMS((char *));\nstatic int find_compopt PARAMS((char *));\n\nstatic int build_actions PARAMS((WORD_LIST *, struct _optflags *, unsigned long *, unsigned long *));\n\nstatic int remove_cmd_completions PARAMS((WORD_LIST *));\n\nstatic int print_one_completion PARAMS((char *, COMPSPEC *));\nstatic int print_compitem PARAMS((BUCKET_CONTENTS *));\nstatic void print_compopts PARAMS((const char *, COMPSPEC *, int));\nstatic void print_all_completions PARAMS((void));\nstatic int print_cmd_completions PARAMS((WORD_LIST *));\n\nstatic void print_compoptions PARAMS((unsigned long, int));\nstatic void print_compactions PARAMS((unsigned long));\nstatic void print_arg PARAMS((const char *, const char *, int));\nstatic void print_cmd_name PARAMS((const char *));\n\nstatic char *Garg, *Warg, *Parg, *Sarg, *Xarg, *Farg, *Carg;\n\nstatic const struct _compacts {\n  const char * const actname;\n  unsigned long actflag;\n  int actopt;\n} compacts[] = {\n  { \"alias\",     CA_ALIAS,     'a' },\n  { \"arrayvar\",  CA_ARRAYVAR,   0 },\n  { \"binding\",   CA_BINDING,    0 },\n  { \"builtin\",   CA_BUILTIN,   'b' },\n  { \"command\",   CA_COMMAND,   'c' },\n  { \"directory\", CA_DIRECTORY, 'd' },\n  { \"disabled\",  CA_DISABLED,   0 },\n  { \"enabled\",   CA_ENABLED,    0 },\n  { \"export\",    CA_EXPORT,    'e' },\n  { \"file\",      CA_FILE,      'f' },\n  { \"function\",  CA_FUNCTION,   0 },\n  { \"helptopic\", CA_HELPTOPIC,  0 },\n  { \"hostname\",  CA_HOSTNAME,   0 },\n  { \"group\",     CA_GROUP,     'g' },\n  { \"job\",       CA_JOB,       'j' },\n  { \"keyword\",   CA_KEYWORD,   'k' },\n  { \"running\",   CA_RUNNING,    0 },\n  { \"service\",   CA_SERVICE,   's' },\n  { \"setopt\",    CA_SETOPT,     0 },\n  { \"shopt\",     CA_SHOPT,      0 },\n  { \"signal\",    CA_SIGNAL,     0 },\n  { \"stopped\",   CA_STOPPED,    0 },\n  { \"user\",      CA_USER,      'u' },\n  { \"variable\",  CA_VARIABLE,  'v' },\n  { (char *)NULL, 0, 0 },\n};\n\n/* This should be a STRING_INT_ALIST */\nstatic const struct _compopt {\n  const char * const optname;\n  unsigned long optflag;\n} compopts[] = {\n  { \"bashdefault\", COPT_BASHDEFAULT },\n  { \"default\",\tCOPT_DEFAULT },\n  { \"dirnames\", COPT_DIRNAMES },\n  { \"filenames\",COPT_FILENAMES},\n  { \"noquote\", COPT_NOQUOTE },\n  { \"nosort\", COPT_NOSORT },\n  { \"nospace\",\tCOPT_NOSPACE },\n  { \"plusdirs\", COPT_PLUSDIRS },\n  { (char *)NULL, 0 },\n};\n\nstatic int\nfind_compact (name)\n     char *name;\n{\n  register int i;\n\n  for (i = 0; compacts[i].actname; i++)\n    if (STREQ (name, compacts[i].actname))\n      return i;\n  return -1;\n}\n\nstatic int\nfind_compopt (name)\n     char *name;\n{\n  register int i;\n\n  for (i = 0; compopts[i].optname; i++)\n    if (STREQ (name, compopts[i].optname))\n      return i;\n  return -1;\n}\n\n/* Build the actions and compspec options from the options specified in LIST.\n   ACTP is a pointer to an unsigned long in which to place the bitmap of\n   actions.  OPTP is a pointer to an unsigned long in which to place the\n   bitmap of compspec options (arguments to `-o').  PP, if non-null, gets 1\n   if -p is supplied; RP, if non-null, gets 1 if -r is supplied.\n   If either is null, the corresponding option generates an error.\n   This also sets variables corresponding to options that take arguments as\n   a side effect; the caller should ensure that those variables are set to\n   NULL before calling build_actions.  Return value:\n   \tEX_USAGE = bad option\n   \tEXECUTION_SUCCESS = some options supplied\n   \tEXECUTION_FAILURE = no options supplied\n*/\n\nstatic int\nbuild_actions (list, flagp, actp, optp)\n     WORD_LIST *list;\n     struct _optflags *flagp;\n     unsigned long *actp, *optp;\n{\n  int opt, ind, opt_given;\n  unsigned long acts, copts;\n  WORD_DESC w;\n\n  acts = copts = (unsigned long)0L;\n  opt_given = 0;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"abcdefgjko:prsuvA:G:W:P:S:X:F:C:DEI\")) != -1)\n    {\n      opt_given = 1;\n      switch (opt)\n\t{\n\tcase 'r':\n\t  if (flagp)\n\t    {\n\t      flagp->rflag = 1;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      sh_invalidopt (\"-r\");\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\n\tcase 'p':\n\t  if (flagp)\n\t    {\n\t      flagp->pflag = 1;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      sh_invalidopt (\"-p\");\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\n\tcase 'a':\n\t  acts |= CA_ALIAS;\n\t  break;\n\tcase 'b':\n\t  acts |= CA_BUILTIN;\n\t  break;\n\tcase 'c':\n\t  acts |= CA_COMMAND;\n\t  break;\n\tcase 'd':\n\t  acts |= CA_DIRECTORY;\n\t  break;\n\tcase 'e':\n\t  acts |= CA_EXPORT;\n\t  break;\n\tcase 'f':\n\t  acts |= CA_FILE;\n\t  break;\n\tcase 'g':\n\t  acts |= CA_GROUP;\n\t  break;\n\tcase 'j':\n\t  acts |= CA_JOB;\n\t  break;\n\tcase 'k':\n\t  acts |= CA_KEYWORD;\n\t  break;\n\tcase 's':\n\t  acts |= CA_SERVICE;\n\t  break;\n\tcase 'u':\n\t  acts |= CA_USER;\n\t  break;\n\tcase 'v':\n\t  acts |= CA_VARIABLE;\n\t  break;\n\tcase 'o':\n\t  ind = find_compopt (list_optarg);\n\t  if (ind < 0)\n\t    {\n\t      sh_invalidoptname (list_optarg);\n\t      return (EX_USAGE);\n\t    }\n\t  copts |= compopts[ind].optflag;\n\t  break;\n\tcase 'A':\n\t  ind = find_compact (list_optarg);\n\t  if (ind < 0)\n\t    {\n\t      builtin_error (_(\"%s: invalid action name\"), list_optarg);\n\t      return (EX_USAGE);\n\t    }\n\t  acts |= compacts[ind].actflag;\n\t  break;\n\tcase 'C':\n\t  Carg = list_optarg;\n\t  break;\n\tcase 'D':\n\t  if (flagp)\n\t    {\n\t      flagp->Dflag = 1;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      sh_invalidopt (\"-D\");\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\tcase 'E':\n\t  if (flagp)\n\t    {\n\t      flagp->Eflag = 1;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      sh_invalidopt (\"-E\");\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\tcase 'I':\n\t  if (flagp)\n\t    {\n\t      flagp->Iflag = 1;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      sh_invalidopt (\"-I\");\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\tcase 'F':\n\t  w.word = Farg = list_optarg;\n\t  w.flags = 0;\n\t  if (check_identifier (&w, posixly_correct) == 0 || strpbrk (Farg, shell_break_chars) != 0)\n\t    {\n\t      sh_invalidid (Farg);\n\t      return (EX_USAGE);\n\t    }\n\t  break;\n\tcase 'G':\n\t  Garg = list_optarg;\n\t  break;\n\tcase 'P':\n\t  Parg = list_optarg;\n\t  break;\n\tcase 'S':\n\t  Sarg = list_optarg;\n\t  break;\n\tcase 'W':\n\t  Warg = list_optarg;\n\t  break;\n\tcase 'X':\n\t  Xarg = list_optarg;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  *actp = acts;\n  *optp = copts;\n\n  return (opt_given ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n}\n\n/* Add, remove, and display completion specifiers. */\nint\ncomplete_builtin (list)\n     WORD_LIST *list;\n{\n  int opt_given, rval;\n  unsigned long acts, copts;\n  COMPSPEC *cs;\n  struct _optflags oflags;\n  WORD_LIST *l, *wl;\n\n  if (list == 0)\n    {\n      print_all_completions ();\n      return (EXECUTION_SUCCESS);\n    }\n\n  opt_given = oflags.pflag = oflags.rflag = 0;\n  oflags.Dflag = oflags.Eflag = oflags.Iflag = 0;\n\n  acts = copts = (unsigned long)0L;\n  Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;\n  cs = (COMPSPEC *)NULL;\n\n  /* Build the actions from the arguments.  Also sets the [A-Z]arg variables\n     as a side effect if they are supplied as options. */\n  rval = build_actions (list, &oflags, &acts, &copts);\n  if (rval == EX_USAGE)\n    return (rval);\n  opt_given = rval != EXECUTION_FAILURE;\n\n  list = loptend;\n\n  if (oflags.Dflag)\n    wl = make_word_list (make_bare_word (DEFAULTCMD), (WORD_LIST *)NULL);\n  else if (oflags.Eflag)\n    wl = make_word_list (make_bare_word (EMPTYCMD), (WORD_LIST *)NULL);\n  else if (oflags.Iflag)\n    wl = make_word_list (make_bare_word (INITIALWORD), (WORD_LIST *)NULL);\n  else\n    wl = (WORD_LIST *)NULL;\n\n  /* -p overrides everything else */\n  if (oflags.pflag || (list == 0 && opt_given == 0))\n    {\n      if (wl)\n\t{\n\t  rval = print_cmd_completions (wl);\n\t  dispose_words (wl);\n\t  return rval;\n\t}\n      else if (list == 0)\n\t{\n\t  print_all_completions ();\n\t  return (EXECUTION_SUCCESS);\n\t}\n      return (print_cmd_completions (list));\n    }\n\n  /* next, -r overrides everything else. */\n  if (oflags.rflag)\n    {\n      if (wl)\n\t{\n\t  rval = remove_cmd_completions (wl);\n\t  dispose_words (wl);\n\t  return rval;\n\t}\n      else if (list == 0)\n\t{\n\t  progcomp_flush ();\n\t  return (EXECUTION_SUCCESS);\n\t}\n      return (remove_cmd_completions (list));\n    }\n\n  if (wl == 0 && list == 0 && opt_given)\n    {\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n\n  /* If we get here, we need to build a compspec and add it for each\n     remaining argument. */\n  cs = compspec_create ();\n  cs->actions = acts;\n  cs->options = copts;\n\n  cs->globpat = STRDUP (Garg);\n  cs->words = STRDUP (Warg);\n  cs->prefix = STRDUP (Parg);\n  cs->suffix = STRDUP (Sarg);\n  cs->funcname = STRDUP (Farg);\n  cs->command = STRDUP (Carg);\n  cs->filterpat = STRDUP (Xarg);\n\n  for (rval = EXECUTION_SUCCESS, l = wl ? wl : list ; l; l = l->next)\n    {\n      /* Add CS as the compspec for the specified commands. */\n      if (progcomp_insert (l->word->word, cs) == 0)\n\trval = EXECUTION_FAILURE;\n    }\n\n  dispose_words (wl);\n  return (rval);\n}\n\nstatic int\nremove_cmd_completions (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *l;\n  int ret;\n\n  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)\n    {\n      if (progcomp_remove (l->word->word) == 0)\n\t{\n\t  builtin_error (_(\"%s: no completion specification\"), l->word->word);\n\t  ret = EXECUTION_FAILURE;\n\t}\n    }\n  return ret;\n}\n\nstatic void\nprint_compoptions (copts, full)\n     unsigned long copts;\n     int full;\n{\n  const struct _compopt *co;\n\n  for (co = compopts; co->optname; co++)\n    if (copts & co->optflag)\n      printf (\"-o %s \", co->optname);\n    else if (full)\n      printf (\"+o %s \", co->optname);\n}\n\nstatic void\nprint_compactions (acts)\n     unsigned long acts;\n{\n  const struct _compacts *ca;\n\n  /* simple flags first */\n  for (ca = compacts; ca->actname; ca++)\n    if (ca->actopt && (acts & ca->actflag))\n      printf (\"-%c \", ca->actopt);\n\n  /* then the rest of the actions */\n  for (ca = compacts; ca->actname; ca++)\n    if (ca->actopt == 0 && (acts & ca->actflag))\n      printf (\"-A %s \", ca->actname);\n}\n\nstatic void\nprint_arg (arg, flag, quote)\n     const char *arg, *flag;\n     int quote;\n{\n  char *x;\n\n  if (arg)\n    {\n      x = quote ? sh_single_quote (arg) : (char *)arg;\n      printf (\"%s %s \", flag, x);\n      if (x != arg)\n\tfree (x);\n    }\n}\n\nstatic void\nprint_cmd_name (cmd)\n     const char *cmd;\n{\n  char *x;\n\n  if (STREQ (cmd, DEFAULTCMD))\n    printf (\"-D\");\n  else if (STREQ (cmd, EMPTYCMD))\n    printf (\"-E\");\n  else if (STREQ (cmd, INITIALWORD))\n    printf (\"-I\");\n  else if (*cmd == 0)\t\t/* XXX - can this happen? */\n    printf (\"''\");\n  else if (sh_contains_shell_metas (cmd))\n    {\n      x = sh_single_quote (cmd);\n      printf (\"%s\", x);\n      free (x);\n    }\n  else\n    printf (\"%s\", cmd);\n}\n\nstatic int\nprint_one_completion (cmd, cs)\n     char *cmd;\n     COMPSPEC *cs;\n{\n  printf (\"complete \");\n\n  print_compoptions (cs->options, 0);\n  print_compactions (cs->actions);\n\n  /* now the rest of the arguments */\n\n  /* arguments that require quoting */\n  print_arg (cs->globpat, \"-G\", 1);\n  print_arg (cs->words, \"-W\", 1);\n  print_arg (cs->prefix, \"-P\", 1);\n  print_arg (cs->suffix, \"-S\", 1);\n  print_arg (cs->filterpat, \"-X\", 1);\n\n  print_arg (cs->command, \"-C\", 1);\n\n  /* simple arguments that don't require quoting */\n  print_arg (cs->funcname, \"-F\", sh_contains_shell_metas (cs->funcname) != 0);\n\n  print_cmd_name (cmd);\n  printf (\"\\n\");\n\n  return (0);\n}\n\nstatic void\nprint_compopts (cmd, cs, full)\n     const char *cmd;\n     COMPSPEC *cs;\n     int full;\n{\n  printf (\"compopt \");\n\n  print_compoptions (cs->options, full);\n  print_cmd_name (cmd);\n\n  printf (\"\\n\");\n}\n\nstatic int\nprint_compitem (item)\n     BUCKET_CONTENTS *item;\n{\n  COMPSPEC *cs;\n  char *cmd;\n\n  cmd = item->key;\n  cs = (COMPSPEC *)item->data;\n\n  return (print_one_completion (cmd, cs));\n}\n\nstatic void\nprint_all_completions ()\n{\n  progcomp_walk (print_compitem);\n}\n\nstatic int\nprint_cmd_completions (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *l;\n  COMPSPEC *cs;\n  int ret;\n\n  for (ret = EXECUTION_SUCCESS, l = list; l; l = l->next)\n    {\n      cs = progcomp_search (l->word->word);\n      if (cs)\n\tprint_one_completion (l->word->word, cs);\n      else\n\t{\n\t  builtin_error (_(\"%s: no completion specification\"), l->word->word);\n\t  ret = EXECUTION_FAILURE;\n\t}\n    }\n\n  return (sh_chkwrite (ret));\n}\n\n$BUILTIN compgen\n$DEPENDS_ON PROGRAMMABLE_COMPLETION\n$FUNCTION compgen_builtin\n$SHORT_DOC compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]\nDisplay possible completions depending on the options.\n\nIntended to be used from within a shell function generating possible\ncompletions.  If the optional WORD argument is supplied, matches against\nWORD are generated.\n\nExit Status:\nReturns success unless an invalid option is supplied or an error occurs.\n$END\n\nint\ncompgen_builtin (list)\n     WORD_LIST *list;\n{\n  int rval;\n  unsigned long acts, copts;\n  COMPSPEC *cs;\n  STRINGLIST *sl;\n  char *word, **matches;\n  char *old_line;\n  int old_ind;\n\n  if (list == 0)\n    return (EXECUTION_SUCCESS);\n\n  acts = copts = (unsigned long)0L;\n  Garg = Warg = Parg = Sarg = Xarg = Farg = Carg = (char *)NULL;\n  cs = (COMPSPEC *)NULL;\n\n  /* Build the actions from the arguments.  Also sets the [A-Z]arg variables\n     as a side effect if they are supplied as options. */\n  rval = build_actions (list, (struct _optflags *)NULL, &acts, &copts);\n  if (rval == EX_USAGE)\n    return (rval);\n  if (rval == EXECUTION_FAILURE)\n    return (EXECUTION_SUCCESS);\n\n  list = loptend;\n\n  word = (list && list->word) ? list->word->word : \"\";\n\n  if (Farg)\n    builtin_error (_(\"warning: -F option may not work as you expect\"));\n  if (Carg)\n    builtin_error (_(\"warning: -C option may not work as you expect\"));\n\n  /* If we get here, we need to build a compspec and evaluate it. */\n  cs = compspec_create ();\n  cs->actions = acts;\n  cs->options = copts;\n  cs->refcount = 1;\n\n  cs->globpat = STRDUP (Garg);\n  cs->words = STRDUP (Warg);\n  cs->prefix = STRDUP (Parg);\n  cs->suffix = STRDUP (Sarg);\n  cs->funcname = STRDUP (Farg);\n  cs->command = STRDUP (Carg);\n  cs->filterpat = STRDUP (Xarg);\n\n  rval = EXECUTION_FAILURE;\n\n  /* probably don't have to save these, just being safe */\n  old_line = pcomp_line;\n  old_ind = pcomp_ind;\n  pcomp_line = (char *)NULL;\n  pcomp_ind = 0;\n  sl = gen_compspec_completions (cs, \"compgen\", word, 0, 0, 0);\n  pcomp_line = old_line;\n  pcomp_ind = old_ind;\n\n  /* If the compspec wants the bash default completions, temporarily\n     turn off programmable completion and call the bash completion code. */\n  if ((sl == 0 || sl->list_len == 0) && (copts & COPT_BASHDEFAULT))\n    {\n      matches = bash_default_completion (word, 0, 0, 0, 0);\n      sl = completions_to_stringlist (matches);\n      strvec_dispose (matches);\n    }\n\n  /* This isn't perfect, but it's the best we can do, given what readline\n     exports from its set of completion utility functions. */\n  if ((sl == 0 || sl->list_len == 0) && (copts & COPT_DEFAULT))\n    {\n      matches = rl_completion_matches (word, rl_filename_completion_function);\n      strlist_dispose (sl);\n      sl = completions_to_stringlist (matches);\n      strvec_dispose (matches);\n    }\n\n  if (sl)\n    {\n      if (sl->list && sl->list_len)\n\t{\n\t  rval = EXECUTION_SUCCESS;\n\t  strlist_print (sl, (char *)NULL);\n\t}\n      strlist_dispose (sl);\n    }\n\n  compspec_dispose (cs);\n  return (rval);\n}\n\n$BUILTIN compopt\n$DEPENDS_ON PROGRAMMABLE_COMPLETION\n$FUNCTION compopt_builtin\n$SHORT_DOC compopt [-o|+o option] [-DEI] [name ...]\nModify or display completion options.\n\nModify the completion options for each NAME, or, if no NAMEs are supplied,\nthe completion currently being executed.  If no OPTIONs are given, print\nthe completion options for each NAME or the current completion specification.\n\nOptions:\n\t-o option\tSet completion option OPTION for each NAME\n\t-D\t\tChange options for the \"default\" command completion\n\t-E\t\tChange options for the \"empty\" command completion\n\t-I\t\tChange options for completion on the initial word\n\nUsing `+o' instead of `-o' turns off the specified option.\n\nArguments:\n\nEach NAME refers to a command for which a completion specification must\nhave previously been defined using the `complete' builtin.  If no NAMEs\nare supplied, compopt must be called by a function currently generating\ncompletions, and the options for that currently-executing completion\ngenerator are modified.\n\nExit Status:\nReturns success unless an invalid option is supplied or NAME does not\nhave a completion specification defined.\n$END\n\nint\ncompopt_builtin (list)\n     WORD_LIST *list;\n{\n  int opts_on, opts_off, *opts, opt, oind, ret, Dflag, Eflag, Iflag;\n  WORD_LIST *l, *wl;\n  COMPSPEC *cs;\n\n  opts_on = opts_off = Eflag = Dflag = Iflag = 0;\n  ret = EXECUTION_SUCCESS;\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"+o:DEI\")) != -1)\n    {\n      opts = (list_opttype == '-') ? &opts_on : &opts_off;\n\n      switch (opt)\n\t{\n\tcase 'o':\n\t  oind = find_compopt (list_optarg);\n\t  if (oind < 0)\n\t    {\n\t      sh_invalidoptname (list_optarg);\n\t      return (EX_USAGE);\n\t    }\n\t  *opts |= compopts[oind].optflag;\n\t  break;\n\tcase 'D':\n\t  Dflag = 1;\n\t  break;\n\tcase 'E':\n\t  Eflag = 1;\n\t  break;\n\tcase 'I':\n\t  Iflag = 1;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  if (Dflag)\n    wl = make_word_list (make_bare_word (DEFAULTCMD), (WORD_LIST *)NULL);\n  else if (Eflag)\n    wl = make_word_list (make_bare_word (EMPTYCMD), (WORD_LIST *)NULL);\n  else if (Iflag)\n    wl = make_word_list (make_bare_word (INITIALWORD), (WORD_LIST *)NULL);\n  else\n    wl = (WORD_LIST *)NULL;\n\n  if (list == 0 && wl == 0)\n    {\n      if (RL_ISSTATE (RL_STATE_COMPLETING) == 0 || pcomp_curcs == 0)\n\t{\n\t  builtin_error (_(\"not currently executing completion function\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n      cs = pcomp_curcs;\n\n      if (opts_on == 0 && opts_off == 0)\n\t{\n\t  print_compopts (pcomp_curcmd, cs, 1);\n          return (sh_chkwrite (ret));\n\t}\n\n      /* Set the compspec options */\n      pcomp_set_compspec_options (cs, opts_on, 1);\n      pcomp_set_compspec_options (cs, opts_off, 0);\n\n      /* And change the readline variables the options control */\n      pcomp_set_readline_variables (opts_on, 1);\n      pcomp_set_readline_variables (opts_off, 0);\n\n      return (ret);\n    }\n\n  for (l = wl ? wl : list; l; l = l->next)\n    {\n      cs = progcomp_search (l->word->word);\n      if (cs == 0)\n\t{\n\t  builtin_error (_(\"%s: no completion specification\"), l->word->word);\n\t  ret = EXECUTION_FAILURE;\n\t  continue;\n\t}\n      if (opts_on == 0 && opts_off == 0)\n\t{\n\t  print_compopts (l->word->word, cs, 1);\n\t  continue;\t\t\t/* XXX -- fill in later */\n\t}\n\n      /* Set the compspec options */\n      pcomp_set_compspec_options (cs, opts_on, 1);\n      pcomp_set_compspec_options (cs, opts_off, 0);\n    }\n\n  if (wl)\n    dispose_words (wl);\n\n  return (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}