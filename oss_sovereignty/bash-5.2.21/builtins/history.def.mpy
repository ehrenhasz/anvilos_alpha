{
  "module_name": "history.def",
  "hash_id": "32e0cec254227bf20f0c2b0bd2a4edb4d6a507262487d650eb944fa8e8b1bd26",
  "original_prompt": "Ingested from bash-5.2.21/builtins/history.def",
  "human_readable_source": "This file is history.def, from which is created history.c.\nIt implements the builtin \"history\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES history.c\n\n$BUILTIN history\n$FUNCTION history_builtin\n$DEPENDS_ON HISTORY\n$SHORT_DOC history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]\nDisplay or manipulate the history list.\n\nDisplay the history list with line numbers, prefixing each modified\nentry with a `*'.  An argument of N lists only the last N entries.\n\nOptions:\n  -c\tclear the history list by deleting all of the entries\n  -d offset\tdelete the history entry at position OFFSET. Negative\n\t\toffsets count back from the end of the history list\n\n  -a\tappend history lines from this session to the history file\n  -n\tread all history lines not already read from the history file\n\t\tand append them to the history list\n  -r\tread the history file and append the contents to the history\n\t\tlist\n  -w\twrite the current history to the history file\n\n  -p\tperform history expansion on each ARG and display the result\n\t\twithout storing it in the history list\n  -s\tappend the ARGs to the history list as a single entry\n\nIf FILENAME is given, it is used as the history file.  Otherwise,\nif HISTFILE has a value, that is used, else ~/.bash_history.\n\nIf the HISTTIMEFORMAT variable is set and not null, its value is used\nas a format string for strftime(3) to print the time stamp associated\nwith each displayed history entry.  No time stamps are printed otherwise.\n\nExit Status:\nReturns success unless an invalid option is given or an error occurs.\n$END\n\n#include <config.h>\n\n#if defined (HISTORY)\n#include \"../bashtypes.h\"\n#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"posixstat.h\"\n#include \"filecntl.h\"\n#include <errno.h>\n#include <stdio.h>\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../flags.h\"\n#include \"../parser.h\"\n#include \"../bashhist.h\"\n#include <readline/history.h>\n#include \"bashgetopt.h\"\n#include \"common.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\nstatic char *histtime PARAMS((HIST_ENTRY *, const char *));\nstatic int display_history PARAMS((WORD_LIST *));\nstatic void push_history PARAMS((WORD_LIST *));\nstatic int expand_and_print_history PARAMS((WORD_LIST *));\n\n#define AFLAG\t0x01\n#define RFLAG\t0x02\n#define WFLAG\t0x04\n#define NFLAG\t0x08\n#define SFLAG\t0x10\n#define PFLAG\t0x20\n#define CFLAG\t0x40\n#define DFLAG\t0x80\n\n#ifndef TIMELEN_MAX\n#  define TIMELEN_MAX 128\n#endif\n\nint\nhistory_builtin (list)\n     WORD_LIST *list;\n{\n  int flags, opt, result, old_history_lines, obase, ind;\n  char *filename, *delete_arg, *range;\n  intmax_t delete_offset;\n\n  flags = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"acd:npsrw\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'a':\n\t  flags |= AFLAG;\n\t  break;\n\tcase 'c':\n\t  flags |= CFLAG;\n\t  break;\n\tcase 'n':\n\t  flags |= NFLAG;\n\t  break;\n\tcase 'r':\n\t  flags |= RFLAG;\n\t  break;\n\tcase 'w':\n\t  flags |= WFLAG;\n\t  break;\n\tcase 's':\n\t  flags |= SFLAG;\n\t  break;\n\tcase 'd':\n\t  flags |= DFLAG;\n\t  delete_arg = list_optarg;\n\t  break;\n\tcase 'p':\n#if defined (BANG_HISTORY)\n\t  flags |= PFLAG;\n#endif\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  opt = flags & (AFLAG|RFLAG|WFLAG|NFLAG);\n  if (opt && opt != AFLAG && opt != RFLAG && opt != WFLAG && opt != NFLAG)\n    {\n      builtin_error (_(\"cannot use more than one of -anrw\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  /* clear the history, but allow other arguments to add to it again. */\n  if (flags & CFLAG)\n    {\n      bash_clear_history ();\n      if (list == 0)\n\treturn (EXECUTION_SUCCESS);\n    }\n\n  if (flags & SFLAG)\n    {\n      if (list)\n\tpush_history (list);\n      return (EXECUTION_SUCCESS);\n    }\n#if defined (BANG_HISTORY)\n  else if (flags & PFLAG)\n    {\n      if (list)\n\treturn (expand_and_print_history (list));\n      return (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n#endif\n  else if ((flags & DFLAG) && (range = strchr ((delete_arg[0] == '-') ? delete_arg + 1 : delete_arg, '-')))\n    {\n      intmax_t delete_start, delete_end;\n      *range++ = '\\0';\n      if (legal_number (delete_arg, &delete_start) == 0 || legal_number (range, &delete_end) == 0)\n\t{\n\t  range[-1] = '-';\n\t  sh_erange (delete_arg, _(\"history position\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n      if (delete_arg[0] == '-' && delete_start < 0)\n\t/* the_history[history_length] == 0x0, so this is correct */\n        delete_start += history_length;\n      /* numbers as displayed by display_history are offset by history_base */\n      else if (delete_start > 0)\n\tdelete_start -= history_base;\n\n      if (delete_start < 0 || delete_start >= history_length)\n\t{\n\t  sh_erange (delete_arg, _(\"history position\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n\n      if (range[0] == '-' && delete_end < 0)\n        delete_end += history_length;\n      else if (delete_end > 0)\n\tdelete_end -= history_base;\n\n      if (delete_end < 0 || delete_end >= history_length)\n\t{\n\t  sh_erange (range, _(\"history position\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n      /* XXX - print error if end < start? */\n      result = bash_delete_history_range (delete_start, delete_end);\n      if (where_history () > history_length)\n\thistory_set_pos (history_length);\n      return (result ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n    }\n  else if (flags & DFLAG)\n    {\n      if (legal_number (delete_arg, &delete_offset) == 0)\n\t{\n\t  sh_erange (delete_arg, _(\"history position\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n      /* check for negative offsets, count back from end of list */\n      if (delete_arg[0] == '-' && delete_offset < 0)\n\t{\n\t  /* since the_history[history_length] == 0x0, this calculation means\n\t     that history -d -1 will delete the last history entry, which at\n\t     this point is the history -d -1 we just added. */\n\t  ind = history_length + delete_offset;\n\t  if (ind < 0)\t\t/* offset by history_base below */\n\t    {\n\t      sh_erange (delete_arg, _(\"history position\"));\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  opt = ind + history_base;\t/* compensate for opt - history_base below */\n\t}\n      else if ((delete_offset < history_base) || (delete_offset >= (history_base + history_length)))\n\t{\n\t  sh_erange (delete_arg, _(\"history position\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n      else\n\topt = delete_offset;\n\n      /* Positive arguments from numbers as displayed by display_history need\n\t to be offset by history_base */\n      result = bash_delete_histent (opt - history_base);\n      /* Since remove_history changes history_length, this can happen if\n\t we delete the last history entry. */\n      if (where_history () > history_length)\n\thistory_set_pos (history_length);\n      return (result ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n    }\n  else if ((flags & (AFLAG|RFLAG|NFLAG|WFLAG|CFLAG)) == 0)\n    {\n      result = display_history (list);\n      return (sh_chkwrite (result));\n    }\n\n  filename = list ? list->word->word : get_string_value (\"HISTFILE\");\n  result = EXECUTION_SUCCESS;\n\n#if defined (RESTRICTED_SHELL)\n  if (restricted && strchr (filename, '/'))\n    {\n      sh_restricted (filename);\n      return (EXECUTION_FAILURE);\n    }\n#endif\n\n  if (flags & AFLAG)\t\t/* Append session's history to file. */\n    result = maybe_append_history (filename);\n  else if (flags & WFLAG)\t/* Write entire history. */\n    result = write_history (filename);\n  else if (flags & RFLAG)\t/* Read entire file. */\n    {\n      result = read_history (filename);\n      history_lines_in_file = history_lines_read_from_file;\n      /* history_lines_in_file = where_history () + history_base - 1; */\n    }\n  else if (flags & NFLAG)\t/* Read `new' history from file. */\n    {\n      /* Read all of the lines in the file that we haven't already read. */\n      old_history_lines = history_lines_in_file;\n      obase = history_base;\n\n      using_history ();\n      result = read_history_range (filename, history_lines_in_file, -1);\n      using_history ();\n\n      history_lines_in_file = history_lines_read_from_file;\n      /* history_lines_in_file = where_history () + history_base - 1; */\n\n      /* If we're rewriting the history file at shell exit rather than just\n\t appending the lines from this session to it, the question is whether\n\t we reset history_lines_this_session to 0, losing any history entries\n\t we had before we read the new entries from the history file, or\n\t whether we count the new entries we just read from the file as\n\t history lines added during this session.\n\t Right now, we do the latter.  This will cause these history entries\n\t to be written to the history file along with any intermediate entries\n\t we add when we do a `history -a', but the alternative is losing\n\t them altogether. */\n      if (force_append_history == 0)\n\thistory_lines_this_session += history_lines_in_file - old_history_lines +\n\t\t\t\t    history_base - obase;\n    }\n\n  return (result ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n\n/* Accessors for HIST_ENTRY lists that are called HLIST. */\n#define histline(i) (hlist[(i)]->line)\n#define histdata(i) (hlist[(i)]->data)\n\nstatic char *\nhisttime (hlist, histtimefmt)\n     HIST_ENTRY *hlist;\n     const char *histtimefmt;\n{\n  static char timestr[TIMELEN_MAX];\n  time_t t;\n  struct tm *tm;\n\n  t = history_get_time (hlist);\n  tm = t ? localtime (&t) : 0;\n  if (t && tm)\n    strftime (timestr, sizeof (timestr), histtimefmt, tm);\n  else if (hlist->timestamp && hlist->timestamp[0])\n    snprintf (timestr, sizeof (timestr), _(\"%s: invalid timestamp\"),\n\t(hlist->timestamp[0] == '#') ? hlist->timestamp + 1: hlist->timestamp);\n  else\n    strcpy (timestr, \"??\");\n  return timestr;\n}\n\nstatic int\ndisplay_history (list)\n     WORD_LIST *list;\n{\n  register int i;\n  intmax_t limit;\n  HIST_ENTRY **hlist;\n  char *histtimefmt, *timestr;\n\n  if (list)\n    {\n      if (get_numeric_arg (list, 0, &limit) == 0)\n\treturn (EXECUTION_FAILURE);\n\n      if (limit < 0)\n\tlimit = -limit;\n    }\n  else\n    limit = -1;\n\n  hlist = history_list ();\n\n  if (hlist)\n    {\n      for (i = 0;  hlist[i]; i++)\n\t;\n\n      if (0 <= limit && limit < i)\n\ti -= limit;\n      else\n\ti = 0;\n\n      histtimefmt = get_string_value (\"HISTTIMEFORMAT\");\n\n      while (hlist[i])\n\t{\n\t  QUIT;\n\n\t  timestr = (histtimefmt && *histtimefmt) ? histtime (hlist[i], histtimefmt) : (char *)NULL;\n\t  printf (\"%5d%c %s%s\\n\", i + history_base,\n\t\t  histdata(i) ? '*' : ' ',\n\t\t  ((timestr && *timestr) ? timestr : \"\"),\n\t\t  histline(i));\n\t  i++;\n\t}\n    }\n\n  return (EXECUTION_SUCCESS);\n}\n\n/* Remove the last entry in the history list and add each argument in\n   LIST to the history. */\nstatic void\npush_history (list)\n     WORD_LIST *list;\n{\n  char *s;\n\n  /* Delete the last history entry if it was a single entry added to the\n     history list (generally the `history -s' itself), or if `history -s'\n     is being used in a compound command and the compound command was\n     added to the history as a single element (command-oriented history).\n     If you don't want history -s to remove the compound command from the\n     history, change #if 0 to #if 1 below. */\n#if 0\n  if (remember_on_history && hist_last_line_pushed == 0 &&\n\thist_last_line_added && bash_delete_last_history () == 0)\n#else\n  if (remember_on_history && hist_last_line_pushed == 0 &&\n\t(hist_last_line_added ||\n\t  (current_command_line_count > 0 && current_command_first_line_saved && command_oriented_history))\n      && bash_delete_last_history () == 0)\n#endif\n      return;\n\n  s = string_list (list);\n  /* Call check_add_history with FORCE set to 1 to skip the check against\n     current_command_line_count.  If history -s is used in a compound\n     command, the above code will delete the compound command's history\n     entry and this call will add the line to the history as a separate\n     entry.  Without FORCE=1, if current_command_line_count were > 1, the\n     line would be appended to the entry before the just-deleted entry. */\n  check_add_history (s, 1);\t/* obeys HISTCONTROL, HISTIGNORE */\n\n  hist_last_line_pushed = 1;\t/* XXX */\n  free (s);\n}\n\n#if defined (BANG_HISTORY)\nstatic int\nexpand_and_print_history (list)\n     WORD_LIST *list;\n{\n  char *s;\n  int r, result;\n\n  if (hist_last_line_pushed == 0 && hist_last_line_added && bash_delete_last_history () == 0)\n    return EXECUTION_FAILURE;\n  result = EXECUTION_SUCCESS;\n  while (list)\n    {\n      r = history_expand (list->word->word, &s);\n      if (r < 0)\n\t{\n\t  builtin_error (_(\"%s: history expansion failed\"), list->word->word);\n\t  result = EXECUTION_FAILURE;\n\t}\n      else\n\t{\n\t  fputs (s, stdout);\n\t  putchar ('\\n');\n\t}\n      FREE (s);\n      list = list->next;\n    }\n  fflush (stdout);\n  return result;\n}\n#endif /* BANG_HISTORY */\n#endif /* HISTORY */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}