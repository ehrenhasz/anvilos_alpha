{
  "module_name": "mapfile.def",
  "hash_id": "241e40476a49bc354847cd3581d3ee3c541a3e442bace5d7f4984f761ff43500",
  "original_prompt": "Ingested from bash-5.2.21/builtins/mapfile.def",
  "human_readable_source": "This file is mapfile.def, from which is created mapfile.c.\nIt implements the builtin \"mapfile\" in Bash.\n\nCopyright (C) 2005-2006 Rocky Bernstein for Free Software Foundation, Inc.\nCopyright (C) 2008-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES mapfile.c\n\n$BUILTIN mapfile\n$FUNCTION mapfile_builtin\n$SHORT_DOC mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]\nRead lines from the standard input into an indexed array variable.\n\nRead lines from the standard input into the indexed array variable ARRAY, or\nfrom file descriptor FD if the -u option is supplied.  The variable MAPFILE\nis the default ARRAY.\n\nOptions:\n  -d delim\tUse DELIM to terminate lines, instead of newline\n  -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are copied\n  -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default index is 0\n  -s count\tDiscard the first COUNT lines read\n  -t\tRemove a trailing DELIM from each line read (default newline)\n  -u fd\tRead lines from file descriptor FD instead of the standard input\n  -C callback\tEvaluate CALLBACK each time QUANTUM lines are read\n  -c quantum\tSpecify the number of lines read between each call to\n\t\t\tCALLBACK\n\nArguments:\n  ARRAY\tArray variable name to use for file data\n\nIf -C is supplied without -c, the default quantum is 5000.  When\nCALLBACK is evaluated, it is supplied the index of the next array\nelement to be assigned and the line to be assigned to that element\nas additional arguments.\n\nIf not supplied with an explicit origin, mapfile will clear ARRAY before\nassigning to it.\n\nExit Status:\nReturns success unless an invalid option is given or ARRAY is readonly or\nnot an indexed array.\n$END\n\n$BUILTIN readarray\n$FUNCTION mapfile_builtin\n$SHORT_DOC readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]\nRead lines from a file into an array variable.\n\nA synonym for `mapfile'.\n$END\n\n#include <config.h>\n\n#include \"builtins.h\"\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include <stdio.h>\n#include <errno.h>\n\n#include \"../bashintl.h\"\n#include \"../shell.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#if defined (ARRAY_VARS)\n\nstatic int run_callback PARAMS((const char *, unsigned int, const char *));\n\n#define DEFAULT_ARRAY_NAME\t\"MAPFILE\"\n#define DEFAULT_VARIABLE_NAME\t\"MAPLINE\"\t/* not used right now */\n\n/* The value specifying how frequently `mapfile'  calls the callback. */\n#define DEFAULT_QUANTUM 5000\n\n/* Values for FLAGS */\n#define MAPF_CLEARARRAY\t0x01\n#define MAPF_CHOP\t0x02\n\nstatic int delim;\n\nstatic int\nrun_callback (callback, curindex, curline)\n     const char *callback;\n     unsigned int curindex;\n     const char *curline;\n{\n  unsigned int execlen;\n  char  *execstr, *qline;\n  int flags;\n\n  qline = sh_single_quote (curline);\n  execlen = strlen (callback) + strlen (qline) + 10;\n  /* 1 for each space between %s and %d,\n     another 1 for the last nul char for C string. */\n  execlen += 3;\n  execstr = xmalloc (execlen);\n\n  flags = SEVAL_NOHIST;\n#if 0\n  if (interactive)\n    flags |= SEVAL_INTERACT;\n#endif\n  snprintf (execstr, execlen, \"%s %d %s\", callback, curindex, qline);\n  free (qline);\n  return evalstring (execstr, NULL, flags);\n}\n\nstatic void\ndo_chop(line, delim)\n     char *line;\n     unsigned char delim;\n{\n  int length;\n\n  length = strlen (line);\n  if (length && (unsigned char)line[length-1] == delim) \n    line[length-1] = '\\0';\n}\n\nstatic int\nmapfile (fd, line_count_goal, origin, nskip, callback_quantum, callback, array_name, delim, flags)\n     int fd;\n     long line_count_goal, origin, nskip, callback_quantum;\n     char *callback, *array_name;\n     int delim;\n     int flags;\n{\n  char *line;\n  size_t line_length;\n  unsigned int array_index, line_count;\n  SHELL_VAR *entry;\n  struct stat sb;\n  int unbuffered_read;\n  \n  line = NULL;\n  line_length = 0;\n  unbuffered_read = 0;\n\n  /* The following check should be done before reading any lines.  Doing it\n     here allows us to call bind_array_element instead of bind_array_variable\n     and skip the variable lookup on every call. */\n  entry = builtin_find_indexed_array (array_name, flags & MAPF_CLEARARRAY);\n  if (entry == 0)\n    return EXECUTION_FAILURE;\n\n#ifndef __CYGWIN__\n  /* If the delimiter is a newline, turn on unbuffered reads for pipes\n     (terminals are ok). If the delimiter is not a newline, unbuffered reads\n     for every file descriptor that's not a regular file. */\n  if (delim == '\\n')\n    unbuffered_read = (lseek (fd, 0L, SEEK_CUR) < 0) && (errno == ESPIPE);\n  else\n    unbuffered_read = (fstat (fd, &sb) != 0) || (S_ISREG (sb.st_mode) == 0);\n#else\n  unbuffered_read = 1;\n#endif\n\n  zreset ();\n\n  /* Skip any lines at beginning of file? */\n  for (line_count = 0; line_count < nskip; line_count++)\n    if (zgetline (fd, &line, &line_length, delim, unbuffered_read) < 0)\n      break;\n\n  line = 0;\n  line_length = 0;    \n\n  /* Reset the buffer for bash own stream */\n  for (array_index = origin, line_count = 1; \n \tzgetline (fd, &line, &line_length, delim, unbuffered_read) != -1;\n\tarray_index++) \n    {\n      /* Remove trailing newlines? */\n      if (flags & MAPF_CHOP)\n\tdo_chop (line, delim);\n\t  \n      /* Has a callback been registered and if so is it time to call it? */\n      if (callback && line_count && (line_count % callback_quantum) == 0) \n\t{\n\t  /* Reset the buffer for bash own stream. */\n\t  if (unbuffered_read == 0)\n\t    zsyncfd (fd);\n\n\t  run_callback (callback, array_index, line);\n\t}\n\n      /* XXX - bad things can happen if the callback modifies ENTRY, e.g.,\n\t unsetting it or changing it to a non-indexed-array type. */\n      bind_array_element (entry, array_index, line, 0);\n\n      /* Have we exceeded # of lines to store? */\n      line_count++;\n      if (line_count_goal != 0 && line_count > line_count_goal) \n\tbreak;\n    }\n\n  free (line);\n\n  if (unbuffered_read == 0)\n    zsyncfd (fd);\n\n  return EXECUTION_SUCCESS;\n}\n\nint\nmapfile_builtin (list)\n     WORD_LIST *list;\n{\n  int opt, code, fd, flags;\n  intmax_t intval;\n  long lines, origin, nskip, callback_quantum;\n  char *array_name, *callback;\n\n  fd = 0;\n  lines = origin = nskip = 0;\n  flags = MAPF_CLEARARRAY;\n  callback_quantum = DEFAULT_QUANTUM;\n  callback = 0;\n  delim = '\\n';\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"d:u:n:O:tC:c:s:\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'd':\n\t  delim = *list_optarg;\n\t  break;\n\tcase 'u':\n\t  code = legal_number (list_optarg, &intval);\n\t  if (code == 0 || intval < 0 || intval != (int)intval)\n\t    {\n\t      builtin_error (_(\"%s: invalid file descriptor specification\"), list_optarg);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  else\n\t    fd = intval;\n\n\t  if (sh_validfd (fd) == 0)\n\t    {\n\t      builtin_error (_(\"%d: invalid file descriptor: %s\"), fd, strerror (errno));\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  break;\t  \n\n\tcase 'n':\n\t  code = legal_number (list_optarg, &intval);\n\t  if (code == 0 || intval < 0 || intval != (unsigned)intval)\n\t    {\n\t      builtin_error (_(\"%s: invalid line count\"), list_optarg);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  else\n\t    lines = intval;\n\t  break;\n\n\tcase 'O':\n\t  code = legal_number (list_optarg, &intval);\n\t  if (code == 0 || intval < 0 || intval != (unsigned)intval)\n\t    {\n\t      builtin_error (_(\"%s: invalid array origin\"), list_optarg);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  else\n\t    origin = intval;\n\t  flags &= ~MAPF_CLEARARRAY;\n\t  break;\n\tcase 't':\n\t  flags |= MAPF_CHOP;\n\t  break;\n\tcase 'C':\n\t  callback = list_optarg;\n\t  break;\n\tcase 'c':\n\t  code = legal_number (list_optarg, &intval);\n\t  if (code == 0 || intval <= 0 || intval != (unsigned)intval)\n\t    {\n\t      builtin_error (_(\"%s: invalid callback quantum\"), list_optarg);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  else\n\t    callback_quantum = intval;\n\t  break;\n\tcase 's':\n\t  code = legal_number (list_optarg, &intval);\n\t  if (code == 0 || intval < 0 || intval != (unsigned)intval)\n\t    {\n\t      builtin_error (_(\"%s: invalid line count\"), list_optarg);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  else\n\t    nskip = intval;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  if (list == 0) \n    array_name = DEFAULT_ARRAY_NAME;\n  else if (list->word == 0 || list->word->word == 0)\n    {\n      builtin_error (\"internal error: getting variable name\");\n      return (EXECUTION_FAILURE);\n    }\n  else if (list->word->word[0] == '\\0')\n    {\n      builtin_error (_(\"empty array variable name\"));\n      return (EX_USAGE);\n    } \n  else\n    array_name = list->word->word;\n  \n  if (legal_identifier (array_name) == 0)\n    {\n      sh_invalidid (array_name);\n      return (EXECUTION_FAILURE);\n    }\n\n  return mapfile (fd, lines, origin, nskip, callback_quantum, callback, array_name, delim, flags);\n}\n\n#else\n\nint\nmapfile_builtin (list)\n     WORD_LIST *list;\n{\n  builtin_error (_(\"array variable support required\"));\n  return (EXECUTION_FAILURE);\n}\n\n#endif  /* ARRAY_VARS */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}