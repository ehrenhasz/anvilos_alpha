{
  "module_name": "pushd.def",
  "hash_id": "08d0d2c041a2aa8e2e5b1944e6375cb03e1d199b75fccd120f0c571ccf212d67",
  "original_prompt": "Ingested from bash-5.2.21/builtins/pushd.def",
  "human_readable_source": "This file is pushd.def, from which is created pushd.c.  It implements the\nbuiltins \"pushd\", \"popd\", and \"dirs\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES pushd.c\n\n$BUILTIN pushd\n$FUNCTION pushd_builtin\n$DEPENDS_ON PUSHD_AND_POPD\n$SHORT_DOC pushd [-n] [+N | -N | dir]\nAdd directories to stack.\n\nAdds a directory to the top of the directory stack, or rotates\nthe stack, making the new top of the stack the current working\ndirectory.  With no arguments, exchanges the top two directories.\n\nOptions:\n  -n\tSuppresses the normal change of directory when adding\n\t\tdirectories to the stack, so only the stack is manipulated.\n\nArguments:\n  +N\tRotates the stack so that the Nth directory (counting\n\t\tfrom the left of the list shown by `dirs', starting with\n\t\tzero) is at the top.\n\n  -N\tRotates the stack so that the Nth directory (counting\n\t\tfrom the right of the list shown by `dirs', starting with\n\t\tzero) is at the top.\n\n  dir\tAdds DIR to the directory stack at the top, making it the\n\t\tnew current working directory.\n\nThe `dirs' builtin displays the directory stack.\n\nExit Status:\nReturns success unless an invalid argument is supplied or the directory\nchange fails.\n$END\n\n$BUILTIN popd\n$FUNCTION popd_builtin\n$DEPENDS_ON PUSHD_AND_POPD\n$SHORT_DOC popd [-n] [+N | -N]\nRemove directories from stack.\n\nRemoves entries from the directory stack.  With no arguments, removes\nthe top directory from the stack, and changes to the new top directory.\n\nOptions:\n  -n\tSuppresses the normal change of directory when removing\n\t\tdirectories from the stack, so only the stack is manipulated.\n\nArguments:\n  +N\tRemoves the Nth entry counting from the left of the list\n\t\tshown by `dirs', starting with zero.  For example: `popd +0'\n\t\tremoves the first directory, `popd +1' the second.\n\n  -N\tRemoves the Nth entry counting from the right of the list\n\t\tshown by `dirs', starting with zero.  For example: `popd -0'\n\t\tremoves the last directory, `popd -1' the next to last.\n\nThe `dirs' builtin displays the directory stack.\n\nExit Status:\nReturns success unless an invalid argument is supplied or the directory\nchange fails.\n$END\n\n$BUILTIN dirs\n$FUNCTION dirs_builtin\n$DEPENDS_ON PUSHD_AND_POPD\n$SHORT_DOC dirs [-clpv] [+N] [-N]\nDisplay directory stack.\n\nDisplay the list of currently remembered directories.  Directories\nfind their way onto the list with the `pushd' command; you can get\nback up through the list with the `popd' command.\n\nOptions:\n  -c\tclear the directory stack by deleting all of the elements\n  -l\tdo not print tilde-prefixed versions of directories relative\n\t\tto your home directory\n  -p\tprint the directory stack with one entry per line\n  -v\tprint the directory stack with one entry per line prefixed\n\t\twith its position in the stack\n\nArguments:\n  +N\tDisplays the Nth entry counting from the left of the list\n\t\tshown by dirs when invoked without options, starting with\n\t\tzero.\n\n  -N\tDisplays the Nth entry counting from the right of the list\n\t\tshown by dirs when invoked without options, starting with\n\t\tzero.\n\nExit Status:\nReturns success unless an invalid option is supplied or an error occurs.\n$END\n\n#include <config.h>\n\n#if defined (PUSHD_AND_POPD)\n#include <stdio.h>\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include <errno.h>\n\n#include <tilde/tilde.h>\n\n#include \"../shell.h\"\n#include \"maxpath.h\"\n#include \"common.h\"\n#include \"builtext.h\"\n\n#ifdef LOADABLE_BUILTIN\n#  include \"builtins.h\"\n#endif\n\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\n/* The list of remembered directories. */\nstatic char **pushd_directory_list = (char **)NULL;\n\n/* Number of existing slots in this list. */\nstatic int directory_list_size;\n\n/* Offset to the end of the list. */\nstatic int directory_list_offset;\n\nstatic void pushd_error PARAMS((int, char *));\nstatic void clear_directory_stack PARAMS((void));\nstatic int cd_to_string PARAMS((char *));\nstatic int change_to_temp PARAMS((char *));\nstatic void add_dirstack_element PARAMS((char *));\nstatic int get_dirstack_index PARAMS((intmax_t, int, int *));\n\n#define NOCD\t\t0x01\n#define ROTATE\t\t0x02\n#define LONGFORM\t0x04\n#define CLEARSTAK\t0x08\n\nint\npushd_builtin (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *orig_list;\n  char *temp, *current_directory, *top;\n  int j, flags, skipopt;\n  intmax_t num;\n  char direction;\n\n  orig_list = list;\n\n  CHECK_HELPOPT (list);\n  if (list && list->word && ISOPTION (list->word->word, '-'))\n    {\n      list = list->next;\n      skipopt = 1;\n    }\n  else\n    skipopt = 0;\n\n  /* If there is no argument list then switch current and\n     top of list. */\n  if (list == 0)\n    {\n      if (directory_list_offset == 0)\n\t{\n\t  builtin_error (_(\"no other directory\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n\n      current_directory = get_working_directory (\"pushd\");\n      if (current_directory == 0)\n\treturn (EXECUTION_FAILURE);\n\n      j = directory_list_offset - 1;\n      temp = pushd_directory_list[j];\n      pushd_directory_list[j] = current_directory;\n      j = change_to_temp (temp);\n      free (temp);\n      return j;\n    }\n\n  for (flags = 0; skipopt == 0 && list; list = list->next)\n    {\n      if (ISOPTION (list->word->word, 'n'))\n\t{\n\t  flags |= NOCD;\n\t}\n      else if (ISOPTION (list->word->word, '-'))\n\t{\n\t  list = list->next;\n\t  break;\n\t}\n      else if (list->word->word[0] == '-' && list->word->word[1] == '\\0')\n\t/* Let `pushd -' work like it used to. */\n\tbreak;\n      else if (((direction = list->word->word[0]) == '+') || direction == '-')\n\t{\n\t  if (legal_number (list->word->word + 1, &num) == 0)\n\t    {\n\t      sh_invalidnum (list->word->word);\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\n\t  if (direction == '-')\n\t    num = directory_list_offset - num;\n\n\t  if (num > directory_list_offset || num < 0)\n\t    {\n\t      pushd_error (directory_list_offset, list->word->word);\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t  flags |= ROTATE;\n\t}\n      else if (*list->word->word == '-')\n\t{\n\t  sh_invalidopt (list->word->word);\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n      else\n\tbreak;\n    }\n\n  if (flags & ROTATE)\n    {\n      /* Rotate the stack num times.  Remember, the current\n\t directory acts like it is part of the stack. */\n      temp = get_working_directory (\"pushd\");\n\n      if (num == 0)\n\t{\n\t  j = ((flags & NOCD) == 0) ? change_to_temp (temp) : EXECUTION_SUCCESS;\n\t  free (temp);\n\t  return j;\n\t}\n\n      do\n\t{\n\t  top = pushd_directory_list[directory_list_offset - 1];\n\n\t  for (j = directory_list_offset - 2; j > -1; j--)\n\t    pushd_directory_list[j + 1] = pushd_directory_list[j];\n\n\t  pushd_directory_list[j + 1] = temp;\n\n\t  temp = top;\n\t  num--;\n\t}\n      while (num);\n\n      j = ((flags & NOCD) == 0) ? change_to_temp (temp) : EXECUTION_SUCCESS;\n      free (temp);\n      return j;\n    }\n\n  if (list == 0)\n    return (EXECUTION_SUCCESS);\n\n  /* Change to the directory in list->word->word.  Save the current\n     directory on the top of the stack. */\n  current_directory = get_working_directory (\"pushd\");\n  if (current_directory == 0)\n    return (EXECUTION_FAILURE);\n\n  j = ((flags & NOCD) == 0) ? cd_builtin (skipopt ? orig_list : list) : EXECUTION_SUCCESS;\n  if (j == EXECUTION_SUCCESS)\n    {\n      add_dirstack_element ((flags & NOCD) ? savestring (list->word->word) : current_directory);\n      dirs_builtin ((WORD_LIST *)NULL);\n      if (flags & NOCD)\n\tfree (current_directory);\n      return (EXECUTION_SUCCESS);\n    }\n  else\n    {\n      free (current_directory);\n      return (EXECUTION_FAILURE);\n    }\n}\n\n/* Pop the directory stack, and then change to the new top of the stack.\n   If LIST is non-null it should consist of a word +N or -N, which says\n   what element to delete from the stack.  The default is the top one. */\nint\npopd_builtin (list)\n     WORD_LIST *list;\n{\n  register int i;\n  intmax_t which;\n  int flags;\n  char direction;\n  char *which_word;\n\n  CHECK_HELPOPT (list);\n\n  which_word = (char *)NULL;\n  for (flags = 0, which = 0, direction = '+'; list; list = list->next)\n    {\n      if (ISOPTION (list->word->word, 'n'))\n\t{\n\t  flags |= NOCD;\n\t}\n      else if (ISOPTION (list->word->word, '-'))\n\t{\n\t  list = list->next;\n\t  break;\n\t}\n      else if (((direction = list->word->word[0]) == '+') || direction == '-')\n\t{\n\t  if (legal_number (list->word->word + 1, &which) == 0)\n\t    {\n\t      sh_invalidnum (list->word->word);\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\t  which_word = list->word->word;\n\t}\n      else if (*list->word->word == '-')\n\t{\n\t  sh_invalidopt (list->word->word);\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n      else if (*list->word->word)\n\t{\n\t  builtin_error (_(\"%s: invalid argument\"), list->word->word);\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n      else\n\tbreak;\n    }\n\n  if (which > directory_list_offset || (which < -directory_list_offset) || (directory_list_offset == 0 && which == 0))\n    {\n      pushd_error (directory_list_offset, which_word ? which_word : \"\");\n      return (EXECUTION_FAILURE);\n    }\n\n  /* Handle case of no specification, or top of stack specification. */\n  if ((direction == '+' && which == 0) ||\n      (direction == '-' && which == directory_list_offset))\n    {\n      i = ((flags & NOCD) == 0) ? cd_to_string (pushd_directory_list[directory_list_offset - 1])\n      \t\t\t\t: EXECUTION_SUCCESS;\n      if (i != EXECUTION_SUCCESS)\n\treturn (i);\n      free (pushd_directory_list[--directory_list_offset]);\n    }\n  else\n    {\n      /* Since an offset other than the top directory was specified,\n\t remove that directory from the list and shift the remainder\n\t of the list into place. */\n      i = (direction == '+') ? directory_list_offset - which : which;\n      if (i < 0 || i > directory_list_offset)\n\t{\n\t  pushd_error (directory_list_offset, which_word ? which_word : \"\");\n\t  return (EXECUTION_FAILURE);\n\t}\n      free (pushd_directory_list[i]);\n      directory_list_offset--;\n\n      /* Shift the remainder of the list into place. */\n      for (; i < directory_list_offset; i++)\n\tpushd_directory_list[i] = pushd_directory_list[i + 1];\n    }\n\n  dirs_builtin ((WORD_LIST *)NULL);\n  return (EXECUTION_SUCCESS);\n}\n\n/* Print the current list of directories on the directory stack. */\nint\ndirs_builtin (list)\n     WORD_LIST *list;\n{\n  int flags, desired_index, index_flag, vflag;\n  intmax_t i;\n  char *temp, *w;\n\n  CHECK_HELPOPT (list);\n  for (flags = vflag = index_flag = 0, desired_index = -1, w = \"\"; list; list = list->next)\n    {\n      if (ISOPTION (list->word->word, 'l'))\n\t{\n\t  flags |= LONGFORM;\n\t}\n      else if (ISOPTION (list->word->word, 'c'))\n\t{\n\t  flags |= CLEARSTAK;\n\t}\n      else if (ISOPTION (list->word->word, 'v'))\n\t{\n\t  vflag |= 2;\n\t}\n      else if (ISOPTION (list->word->word, 'p'))\n\t{\n\t  vflag |= 1;\n\t}\n      else if (ISOPTION (list->word->word, '-'))\n\t{\n\t  list = list->next;\n\t  break;\n\t}\n      else if (*list->word->word == '+' || *list->word->word == '-')\n\t{\n\t  int sign;\n\t  if (legal_number (w = list->word->word + 1, &i) == 0)\n\t    {\n\t      sh_invalidnum (list->word->word);\n\t      builtin_usage ();\n\t      return (EX_USAGE);\n\t    }\n\t  sign = (*list->word->word == '+') ? 1 : -1;\n\t  desired_index = get_dirstack_index (i, sign, &index_flag);\n\t}\n      else\n\t{\n\t  sh_invalidopt (list->word->word);\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  if (flags & CLEARSTAK)\n    {\n      clear_directory_stack ();\n      return (EXECUTION_SUCCESS);\n    }\n\n  if (index_flag && (desired_index < 0 || desired_index > directory_list_offset))\n    {\n      pushd_error (directory_list_offset, w);\n      return (EXECUTION_FAILURE);\n    }\n\n#define DIRSTACK_FORMAT(temp) \\\n  (flags & LONGFORM) ? temp : polite_directory_format (temp)\n\n  /* The first directory printed is always the current working directory. */\n  if (index_flag == 0 || (index_flag == 1 && desired_index == 0))\n    {\n      temp = get_working_directory (\"dirs\");\n      if (temp == 0)\n\ttemp = savestring (_(\"<no current directory>\"));\n      if (vflag & 2)\n\tprintf (\"%2d  %s\", 0, DIRSTACK_FORMAT (temp));\n      else\n\tprintf (\"%s\", DIRSTACK_FORMAT (temp));\n      free (temp);\n      if (index_flag)\n\t{\n\t  putchar ('\\n');\n\t  return (sh_chkwrite (EXECUTION_SUCCESS));\n\t}\n    }\n\n#define DIRSTACK_ENTRY(i) \\\n  (flags & LONGFORM) ? pushd_directory_list[i] \\\n\t\t     : polite_directory_format (pushd_directory_list[i])\n\n  /* Now print the requested directory stack entries. */\n  if (index_flag)\n    {\n      if (vflag & 2)\n\tprintf (\"%2d  %s\", directory_list_offset - desired_index,\n\t\t\t   DIRSTACK_ENTRY (desired_index));\n      else\n\tprintf (\"%s\", DIRSTACK_ENTRY (desired_index));\n    }\n  else\n    for (i = directory_list_offset - 1; i >= 0; i--)\n      if (vflag >= 2)\n\tprintf (\"\\n%2d  %s\", directory_list_offset - (int)i, DIRSTACK_ENTRY (i));\n      else\n\tprintf (\"%s%s\", (vflag & 1) ? \"\\n\" : \" \", DIRSTACK_ENTRY (i));\n\n  putchar ('\\n');\n\n  return (sh_chkwrite (EXECUTION_SUCCESS));\n}\n\nstatic void\npushd_error (offset, arg)\n     int offset;\n     char *arg;\n{\n  if (offset == 0)\n    builtin_error (_(\"directory stack empty\"));\n  else\n    sh_erange (arg, _(\"directory stack index\"));\n}\n\nstatic void\nclear_directory_stack ()\n{\n  register int i;\n\n  for (i = 0; i < directory_list_offset; i++)\n    free (pushd_directory_list[i]);\n  directory_list_offset = 0;\n}\n\n/* Switch to the directory in NAME.  This uses the cd_builtin to do the work,\n   so if the result is EXECUTION_FAILURE then an error message has already\n   been printed. */\nstatic int\ncd_to_string (name)\n     char *name;\n{\n  WORD_LIST *tlist;\n  WORD_LIST *dir;\n  int result;\n\n  dir = make_word_list (make_word (name), NULL);\n  tlist = make_word_list (make_word (\"--\"), dir);\n  result = cd_builtin (tlist);\n  dispose_words (tlist);\n  return (result);\n}\n\nstatic int\nchange_to_temp (temp)\n     char *temp;\n{\n  int tt;\n\n  tt = temp ? cd_to_string (temp) : EXECUTION_FAILURE;\n\n  if (tt == EXECUTION_SUCCESS)\n    dirs_builtin ((WORD_LIST *)NULL);\n\n  return (tt);\n}\n\nstatic void\nadd_dirstack_element (dir)\n     char *dir;\n{\n  if (directory_list_offset == directory_list_size)\n    pushd_directory_list = strvec_resize (pushd_directory_list, directory_list_size += 10);\n  pushd_directory_list[directory_list_offset++] = dir;\n}\n\nstatic int\nget_dirstack_index (ind, sign, indexp)\n     intmax_t ind;\n     int sign, *indexp;\n{\n  if (indexp)\n    *indexp = sign > 0 ? 1 : 2;\n\n  /* dirs +0 prints the current working directory. */\n  /* dirs -0 prints last element in directory stack */\n  if (ind == 0 && sign > 0)\n    return 0;\n  else if (ind == directory_list_offset)\n    {\n      if (indexp)\n\t*indexp = sign > 0 ? 2 : 1;\n      return 0;\n    }\n  else if (ind >= 0 && ind <= directory_list_offset)\n    return (sign > 0 ? directory_list_offset - ind : ind);\n  else\n    return -1;\n}\n\n/* Used by the tilde expansion code. */\nchar *\nget_dirstack_from_string (string)\n     char *string;\n{\n  int ind, sign, index_flag;\n  intmax_t i;\n\n  sign = 1;\n  if (*string == '-' || *string == '+')\n    {\n      sign = (*string == '-') ? -1 : 1;\n      string++;\n    }\n  if (legal_number (string, &i) == 0)\n    return ((char *)NULL);\n\n  index_flag = 0;\n  ind = get_dirstack_index (i, sign, &index_flag);\n  if (index_flag && (ind < 0 || ind > directory_list_offset))\n    return ((char *)NULL);\n  if (index_flag == 0 || (index_flag == 1 && ind == 0))\n    return (get_string_value (\"PWD\"));\n  else\n    return (pushd_directory_list[ind]);\n}\n\n#ifdef INCLUDE_UNUSED\nchar *\nget_dirstack_element (ind, sign)\n     intmax_t ind;\n     int sign;\n{\n  int i;\n\n  i = get_dirstack_index (ind, sign, (int *)NULL);\n  return (i < 0 || i > directory_list_offset) ? (char *)NULL\n\t\t\t\t\t      : pushd_directory_list[i];\n}\n#endif\n\nvoid\nset_dirstack_element (ind, sign, value)\n     intmax_t ind;\n     int  sign;\n     char *value;\n{\n  int i;\n\n  i = get_dirstack_index (ind, sign, (int *)NULL);\n  if (ind == 0 || i < 0 || i > directory_list_offset)\n    return;\n  free (pushd_directory_list[i]);\n  pushd_directory_list[i] = savestring (value);\n}\n\nWORD_LIST *\nget_directory_stack (flags)\n     int flags;\n{\n  register int i;\n  WORD_LIST *ret;\n  char *d, *t;\n\n  for (ret = (WORD_LIST *)NULL, i = 0; i < directory_list_offset; i++)\n    {\n      d = (flags&1) ? polite_directory_format (pushd_directory_list[i])\n\t\t    : pushd_directory_list[i];\n      ret = make_word_list (make_word (d), ret);\n    }\n  /* Now the current directory. */\n  d = get_working_directory (\"dirstack\");\n  i = 0;\t/* sentinel to decide whether or not to free d */\n  if (d == 0)\n    d = \".\";\n  else\n    {\n      t = (flags&1) ? polite_directory_format (d) : d;\n      /* polite_directory_format sometimes returns its argument unchanged.\n\t If it does not, we can free d right away.  If it does, we need to\n\t mark d to be deleted later. */\n      if (t != d)\n\t{\n\t  free (d);\n\t  d = t;\n\t}\n      else /* t == d, so d is what we want */\n\ti = 1;\n    }\n  ret = make_word_list (make_word (d), ret);\n  if (i)\n    free (d);\n  return ret;\t/* was (REVERSE_LIST (ret, (WORD_LIST *)); */\n}\n\n#ifdef LOADABLE_BUILTIN\nchar * const dirs_doc[] = {\nN_(\"Display the list of currently remembered directories.  Directories\\n\\\n    find their way onto the list with the `pushd' command; you can get\\n\\\n    back up through the list with the `popd' command.\\n\\\n    \\n\\\n    Options:\\n\\\n      -c\tclear the directory stack by deleting all of the elements\\n\\\n      -l\tdo not print tilde-prefixed versions of directories relative\\n\\\n    \tto your home directory\\n\\\n      -p\tprint the directory stack with one entry per line\\n\\\n      -v\tprint the directory stack with one entry per line prefixed\\n\\\n    \twith its position in the stack\\n\\\n    \\n\\\n    Arguments:\\n\\\n      +N\tDisplays the Nth entry counting from the left of the list shown by\\n\\\n    \tdirs when invoked without options, starting with zero.\\n\\\n    \\n\\\n      -N\tDisplays the Nth entry counting from the right of the list shown by\\n\\\n\tdirs when invoked without options, starting with zero.\"),\n  (char *)NULL\n};\n\nchar * const pushd_doc[] = {\nN_(\"Adds a directory to the top of the directory stack, or rotates\\n\\\n    the stack, making the new top of the stack the current working\\n\\\n    directory.  With no arguments, exchanges the top two directories.\\n\\\n    \\n\\\n    Options:\\n\\\n      -n\tSuppresses the normal change of directory when adding\\n\\\n    \tdirectories to the stack, so only the stack is manipulated.\\n\\\n    \\n\\\n    Arguments:\\n\\\n      +N\tRotates the stack so that the Nth directory (counting\\n\\\n    \tfrom the left of the list shown by `dirs', starting with\\n\\\n    \tzero) is at the top.\\n\\\n    \\n\\\n      -N\tRotates the stack so that the Nth directory (counting\\n\\\n    \tfrom the right of the list shown by `dirs', starting with\\n\\\n    \tzero) is at the top.\\n\\\n    \\n\\\n      dir\tAdds DIR to the directory stack at the top, making it the\\n\\\n    \tnew current working directory.\\n\\\n    \\n\\\n    The `dirs' builtin displays the directory stack.\"),\n  (char *)NULL\n};\n\nchar * const popd_doc[] = {\nN_(\"Removes entries from the directory stack.  With no arguments, removes\\n\\\n    the top directory from the stack, and changes to the new top directory.\\n\\\n    \\n\\\n    Options:\\n\\\n      -n\tSuppresses the normal change of directory when removing\\n\\\n    \tdirectories from the stack, so only the stack is manipulated.\\n\\\n    \\n\\\n    Arguments:\\n\\\n      +N\tRemoves the Nth entry counting from the left of the list\\n\\\n    \tshown by `dirs', starting with zero.  For example: `popd +0'\\n\\\n    \tremoves the first directory, `popd +1' the second.\\n\\\n    \\n\\\n      -N\tRemoves the Nth entry counting from the right of the list\\n\\\n    \tshown by `dirs', starting with zero.  For example: `popd -0'\\n\\\n    \tremoves the last directory, `popd -1' the next to last.\\n\\\n    \\n\\\n    The `dirs' builtin displays the directory stack.\"),\n  (char *)NULL\n};\n\nstruct builtin pushd_struct = {\n\t\"pushd\",\n\tpushd_builtin,\n\tBUILTIN_ENABLED,\n\tpushd_doc,\n\t\"pushd [+N | -N] [-n] [dir]\",\n\t0\n};\n\nstruct builtin popd_struct = {\n\t\"popd\",\n\tpopd_builtin,\n\tBUILTIN_ENABLED,\n\tpopd_doc,\n\t\"popd [+N | -N] [-n]\",\n\t0\n};\n\nstruct builtin dirs_struct = {\n\t\"dirs\",\n\tdirs_builtin,\n\tBUILTIN_ENABLED,\n\tdirs_doc,\n\t\"dirs [-clpv] [+N] [-N]\",\n\t0\n};\n#endif /* LOADABLE_BUILTIN */\n\n#endif /* PUSHD_AND_POPD */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}