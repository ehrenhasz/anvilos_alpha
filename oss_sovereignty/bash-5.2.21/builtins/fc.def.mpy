{
  "module_name": "fc.def",
  "hash_id": "8ec701d50247bbc7d4c2d75f519582a9c4534947da51b7b5b9cd9a31c94334b0",
  "original_prompt": "Ingested from bash-5.2.21/builtins/fc.def",
  "human_readable_source": "This file is fc.def, from which is created fc.c.\nIt implements the builtin \"fc\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES fc.c\n\n$BUILTIN fc\n$FUNCTION fc_builtin\n$DEPENDS_ON HISTORY\n$SHORT_DOC fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]\nDisplay or execute commands from the history list.\n\nfc is used to list or edit and re-execute commands from the history list.\nFIRST and LAST can be numbers specifying the range, or FIRST can be a\nstring, which means the most recent command beginning with that\nstring.\n\nOptions:\n  -e ENAME\tselect which editor to use.  Default is FCEDIT, then EDITOR,\n\t\tthen vi\n  -l \tlist lines instead of editing\n  -n\tomit line numbers when listing\n  -r\treverse the order of the lines (newest listed first)\n\nWith the `fc -s [pat=rep ...] [command]' format, COMMAND is\nre-executed after the substitution OLD=NEW is performed.\n\nA useful alias to use with this is r='fc -s', so that typing `r cc'\nruns the last command beginning with `cc' and typing `r' re-executes\nthe last command.\n\nExit Status:\nReturns success or status of executed command; non-zero if an error occurs.\n$END\n\n#include <config.h>\n\n#if defined (HISTORY)\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <chartypes.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n#include <errno.h>\n\n#include \"../shell.h\"\n#include \"../builtins.h\"\n#include \"../flags.h\"\n#include \"../parser.h\"\n#include \"../bashhist.h\"\n#include \"maxpath.h\"\n#include <readline/history.h>\n#include \"bashgetopt.h\"\n#include \"common.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\n#define HIST_INVALID INT_MIN\n#define HIST_ERANGE  INT_MIN+1\n#define HIST_NOTFOUND INT_MIN+2\n\n/* Values for the flags argument to fc_gethnum */\n#define HN_LISTING\t0x01\n#define HN_FIRST\t0x02\n\nextern int unlink PARAMS((const char *));\n\nextern FILE *sh_mktmpfp PARAMS((char *, int, char **));\n\nextern int suppress_debug_trap_verbose;\n\n/* **************************************************************** */\n/*\t\t\t\t\t\t\t\t    */\n/*\tThe K*rn shell style fc command (Fix Command)\t\t    */\n/*\t\t\t\t\t\t\t\t    */\n/* **************************************************************** */\n\n/* fc builtin command (fix command) for Bash for those who\n   like K*rn-style history better than csh-style.\n\n     fc [-e ename] [-nlr] [first] [last]\n\n   FIRST and LAST can be numbers specifying the range, or FIRST can be\n   a string, which means the most recent command beginning with that\n   string.\n\n   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,\n      then the editor which corresponds to the current readline editing\n      mode, then vi.\n\n   -l means list lines instead of editing.\n   -n means no line numbers listed.\n   -r means reverse the order of the lines (making it newest listed first).\n\n     fc -e - [pat=rep ...] [command]\n     fc -s [pat=rep ...] [command]\n\n   Equivalent to !command:sg/pat/rep execpt there can be multiple PAT=REP's.\n*/\n\n/* Data structure describing a list of global replacements to perform. */\ntypedef struct repl {\n  struct repl *next;\n  char *pat;\n  char *rep;\n} REPL;\n\n/* Accessors for HIST_ENTRY lists that are called HLIST. */\n#define histline(i) (hlist[(i)]->line)\n#define histdata(i) (hlist[(i)]->data)\n\n#define FREE_RLIST() \\\n\tdo { \\\n\t\tfor (rl = rlist; rl; ) { \\\n\t\t\tREPL *r;\t\\\n\t\t\tr = rl->next; \\\n\t\t\tif (rl->pat) \\\n\t\t\t\tfree (rl->pat); \\\n\t\t\tif (rl->rep) \\\n\t\t\t\tfree (rl->rep); \\\n\t\t\tfree (rl); \\\n\t\t\trl = r; \\\n\t\t} \\\n\t} while (0)\n\nstatic char *fc_dosubs PARAMS((char *, REPL *));\nstatic char *fc_gethist PARAMS((char *, HIST_ENTRY **, int));\nstatic int fc_gethnum PARAMS((char *, HIST_ENTRY **, int));\nstatic int fc_number PARAMS((WORD_LIST *));\nstatic void fc_replhist PARAMS((char *));\n#ifdef INCLUDE_UNUSED\nstatic char *fc_readline PARAMS((FILE *));\nstatic void fc_addhist PARAMS((char *));\n#endif\n\nstatic void\nset_verbose_flag ()\n{\n  echo_input_at_read = verbose_flag;\n}\n\n/* String to execute on a file that we want to edit. */\n#define FC_EDIT_COMMAND \"${FCEDIT:-${EDITOR:-vi}}\"\n#if defined (STRICT_POSIX)\n#  define POSIX_FC_EDIT_COMMAND \"${FCEDIT:-ed}\"\n#else\n#  define POSIX_FC_EDIT_COMMAND \"${FCEDIT:-${EDITOR:-ed}}\"\n#endif\n\nint\nfc_builtin (list)\n     WORD_LIST *list;\n{\n  register int i;\n  register char *sep;\n  int numbering, reverse, listing, execute;\n  int histbeg, histend, last_hist, retval, opt, rh, real_last;\n  FILE *stream;\n  REPL *rlist, *rl;\n  char *ename, *command, *newcom, *fcedit;\n  HIST_ENTRY **hlist;\n  char *fn;\n\n  numbering = 1;\n  reverse = listing = execute = 0;\n  ename = (char *)NULL;\n\n  /* Parse out the options and set which of the two forms we're in. */\n  reset_internal_getopt ();\n  lcurrent = list;\t\t/* XXX */\n  while (fc_number (loptend = lcurrent) == 0 &&\n\t (opt = internal_getopt (list, \":e:lnrs\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'n':\n\t  numbering = 0;\n\t  break;\n\n\tcase 'l':\n\t  listing = HN_LISTING;\t\t/* for fc_gethnum */\n\t  break;\n\n\tcase 'r':\n\t  reverse = 1;\n\t  break;\n\n\tcase 's':\n\t  execute = 1;\n\t  break;\n\n\tcase 'e':\n\t  ename = list_optarg;\n\t  break;\n\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  if (ename && (*ename == '-') && (ename[1] == '\\0'))\n    execute = 1;\n\n  /* The \"execute\" form of the command (re-run, with possible string\n     substitutions). */\n  if (execute)\n    {\n      rlist = (REPL *)NULL;\n      while (list && ((sep = (char *)strchr (list->word->word, '=')) != NULL))\n\t{\n\t  *sep++ = '\\0';\n\t  rl = (REPL *)xmalloc (sizeof (REPL));\n\t  rl->next = (REPL *)NULL;\n\t  rl->pat = savestring (list->word->word);\n\t  rl->rep = savestring (sep);\n\n\t  if (rlist == NULL)\n\t    rlist = rl;\n\t  else\n\t    {\n\t      rl->next = rlist;\n\t      rlist = rl;\n\t    }\n\t  list = list->next;\n\t}\n\n      /* If we have a list of substitutions to do, then reverse it\n\t to get the replacements in the proper order. */\n\n      rlist = REVERSE_LIST (rlist, REPL *);\n\n      hlist = history_list ();\n\n      /* If we still have something in list, it is a command spec.\n\t Otherwise, we use the most recent command in time. */\n      command = fc_gethist (list ? list->word->word : (char *)NULL, hlist, 0);\n\n      if (command == NULL)\n\t{\n\t  builtin_error (_(\"no command found\"));\n\t  if (rlist)\n\t    FREE_RLIST ();\n\n\t  return (EXECUTION_FAILURE);\n\t}\n\n      if (rlist)\n\t{\n\t  newcom = fc_dosubs (command, rlist);\n\t  free (command);\n\t  FREE_RLIST ();\n\t  command = newcom;\n\t}\n\n      fprintf (stderr, \"%s\\n\", command);\n      fc_replhist (command);\t/* replace `fc -s' with command */\n      /* Posix says that the re-executed commands should be entered into the\n\t history. */\n      return (parse_and_execute (command, \"fc\", SEVAL_NOHIST));\n    }\n\n  /* This is the second form of the command (the list-or-edit-and-rerun\n     form). */\n  hlist = history_list ();\n  if (hlist == 0)\n    return (EXECUTION_SUCCESS);\n  for (i = 0; hlist[i]; i++);\n\n  /* With the Bash implementation of history, the current command line\n     (\"fc blah...\" and so on) is already part of the history list by\n     the time we get to this point.  This just skips over that command\n     and makes the last command that this deals with be the last command\n     the user entered before the fc.  We need to check whether the\n     line was actually added (HISTIGNORE may have caused it to not be),\n     so we check hist_last_line_added. */\n\n  /* Even though command substitution through parse_and_execute turns off\n     remember_on_history, command substitution in a shell when set -o history\n     has been enabled (interactive or not) should use it in the last_hist\n     calculation as if it were on. */\n  rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);\n  last_hist = i - rh - hist_last_line_added;\n\n  /* Make sure that real_last is calculated the same way here and in\n     fc_gethnum.  The return value from fc_gethnum is treated specially if\n     it is == real_last and we are listing commands. */\n  real_last = i;\n  /* back up from the end to the last non-null history entry */\n  while (hlist[real_last] == 0 && real_last > 0)\n    real_last--;\n\n  /* XXX */\n  if (i == last_hist && hlist[last_hist] == 0)\n    while (last_hist >= 0 && hlist[last_hist] == 0)\n      last_hist--;\n  if (last_hist < 0)\n    last_hist = 0;\t\t/* per POSIX */\n\n  if (list)\n    {\n      histbeg = fc_gethnum (list->word->word, hlist, listing|HN_FIRST);\n      list = list->next;\n\n      if (list)\n\thistend = fc_gethnum (list->word->word, hlist, listing);\n      else if (histbeg == real_last)\n\thistend = listing ? real_last : histbeg;\n      else\n\thistend = listing ? last_hist : histbeg;\n    }\n  else\n    {\n      /* The default for listing is the last 16 history items. */\n      if (listing)\n\t{\n\t  histend = last_hist;\n\t  histbeg = histend - 16 + 1;\t/* +1 because loop below uses >= */\n\t  if (histbeg < 0)\n\t    histbeg = 0;\n\t}\n      else\n\t/* For editing, it is the last history command. */\n\thistbeg = histend = last_hist;\n    }\n\n  if (histbeg == HIST_INVALID || histend == HIST_INVALID)\n    {\n      sh_erange ((char *)NULL, _(\"history specification\")); \n      return (EXECUTION_FAILURE);\n    }\n  else if (histbeg == HIST_ERANGE || histend == HIST_ERANGE)\n    {\n      sh_erange ((char *)NULL, _(\"history specification\"));\n      return (EXECUTION_FAILURE);\n    }\n  else if (histbeg == HIST_NOTFOUND || histend == HIST_NOTFOUND)\n    {\n      builtin_error (_(\"no command found\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  /* We don't throw an error for line specifications out of range, per POSIX */\n  if (histbeg < 0)\n    histbeg = 0;\n  if (histend < 0)\n    histend = 0;\n\n  /* \"When not listing, the fc command that caused the editing shall not be\n     entered into the history list.\" */\n  if (listing == 0 && hist_last_line_added)\n    {\n      bash_delete_last_history ();\n      /* If we're editing a single command -- the last command in the\n\t history -- and we just removed the dummy command added by\n\t edit_and_execute_command (), we need to check whether or not we\n\t just removed the last command in the history and need to back\n\t the pointer up.  remember_on_history is off because we're running\n\t in parse_and_execute(). */\n      if (histbeg == histend && histend == last_hist && hlist[last_hist] == 0)\n\tlast_hist = histbeg = --histend;\n\n      if (hlist[last_hist] == 0)\n\tlast_hist--;\n      if (histend >= last_hist)\n\thistend = last_hist;\n      else if (histbeg >= last_hist)\n\thistbeg = last_hist;\n    }\n\n  if (histbeg == HIST_INVALID || histend == HIST_INVALID)\n    {\n      sh_erange ((char *)NULL, _(\"history specification\")); \n      return (EXECUTION_FAILURE);\n    }\n  else if (histbeg == HIST_ERANGE || histend == HIST_ERANGE)\n    {\n      sh_erange ((char *)NULL, _(\"history specification\"));\n      return (EXECUTION_FAILURE);\n    }\n  else if (histbeg == HIST_NOTFOUND || histend == HIST_NOTFOUND)\n    {\n      builtin_error (_(\"no command found\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  /* We don't throw an error for line specifications out of range, per POSIX */\n  if (histbeg < 0)\n    histbeg = 0;\n  if (histend < 0)\n    histend = 0;\n\n  if (histend < histbeg)\n    {\n      i = histend;\n      histend = histbeg;\n      histbeg = i;\n\n      reverse = 1;\n    }\n\n  if (listing)\n    stream = stdout;\n  else\n    {\n      numbering = 0;\n      stream = sh_mktmpfp (\"bash-fc\", MT_USERANDOM|MT_USETMPDIR, &fn);\n      if (stream == 0)\n\t{\n\t  builtin_error (_(\"%s: cannot open temp file: %s\"), fn ? fn : \"\", strerror (errno));\n\t  FREE (fn);\n\t  return (EXECUTION_FAILURE);\n\t}\n    }\n\n  for (i = reverse ? histend : histbeg; reverse ? i >= histbeg : i <= histend; reverse ? i-- : i++)\n    {\n      QUIT;\n      if (hlist[i] == 0)\n\tcontinue;\n      if (numbering)\n\tfprintf (stream, \"%d\", i + history_base);\n      if (listing)\n\t{\n\t  if (posixly_correct)\n\t    fputs (\"\\t\", stream);\n\t  else\n\t    fprintf (stream, \"\\t%c\", histdata (i) ? '*' : ' ');\n\t}\n      if (histline (i))\n\tfprintf (stream, \"%s\\n\", histline (i));\n    }\n\n  if (listing)\n    return (sh_chkwrite (EXECUTION_SUCCESS));\n\n  fflush (stream);\n  if (ferror (stream))\n    {\n      sh_wrerror ();\n      fclose (stream);\n      FREE (fn);\n      return (EXECUTION_FAILURE);\n    }\n  fclose (stream);\n\n  /* Now edit the file of commands. */\n  if (ename)\n    {\n      command = (char *)xmalloc (strlen (ename) + strlen (fn) + 2);\n      sprintf (command, \"%s %s\", ename, fn);\n    }\n  else\n    {\n      fcedit = posixly_correct ? POSIX_FC_EDIT_COMMAND : FC_EDIT_COMMAND;\n      command = (char *)xmalloc (3 + strlen (fcedit) + strlen (fn));\n      sprintf (command, \"%s %s\", fcedit, fn);\n    }\n  retval = parse_and_execute (command, \"fc\", SEVAL_NOHIST);\n  if (retval != EXECUTION_SUCCESS)\n    {\n      unlink (fn);\n      free (fn);\n      return (EXECUTION_FAILURE);\n    }\n\n#if defined (READLINE)\n  /* If we're executing as part of a dispatched readline command like\n     {emacs,vi}_edit_and_execute_command, the readline state will indicate it.\n     We could remove the partial command from the history, but ksh93 doesn't\n     so we stay compatible. */\n#endif\n\n  /* Make sure parse_and_execute doesn't turn this off, even though a\n     call to parse_and_execute farther up the function call stack (e.g.,\n     if this is called by vi_edit_and_execute_command) may have already\n     called bash_history_disable. */\n  remember_on_history = 1;\n\n  /* Turn on the `v' flag while fc_execute_file runs so the commands\n     will be echoed as they are read by the parser. */\n  begin_unwind_frame (\"fc builtin\");\n  add_unwind_protect (xfree, fn);\n  add_unwind_protect (unlink, fn);\n  add_unwind_protect (set_verbose_flag, (char *)NULL);\n  unwind_protect_int (suppress_debug_trap_verbose);\n  echo_input_at_read = 1;\n  suppress_debug_trap_verbose = 1;\n\n  retval = fc_execute_file (fn);\n  run_unwind_frame (\"fc builtin\");\n\n  return (retval);\n}\n\n/* Return 1 if LIST->word->word is a legal number for fc's use. */\nstatic int\nfc_number (list)\n     WORD_LIST *list;\n{\n  char *s;\n\n  if (list == 0)\n    return 0;\n  s = list->word->word;\n  if (*s == '-')\n    s++;\n  return (legal_number (s, (intmax_t *)NULL));\n}\n\n/* Return an absolute index into HLIST which corresponds to COMMAND.  If\n   COMMAND is a number, then it was specified in relative terms.  If it\n   is a string, then it is the start of a command line present in HLIST.\n   MODE includes HN_LISTING if we are listing commands, and does not if we\n   are executing them. If MODE includes HN_FIRST we are looking for the\n   first history number specification. */\nstatic int\nfc_gethnum (command, hlist, mode)\n     char *command;\n     HIST_ENTRY **hlist;\n     int mode;\n{\n  int sign, n, clen, rh;\n  register int i, j, last_hist, real_last, listing;\n  register char *s;\n\n  listing = mode & HN_LISTING;\n  sign = 1;\n  /* Count history elements. */\n  for (i = 0; hlist[i]; i++);\n\n  /* With the Bash implementation of history, the current command line\n     (\"fc blah...\" and so on) is already part of the history list by\n     the time we get to this point.  This just skips over that command\n     and makes the last command that this deals with be the last command\n     the user entered before the fc.  We need to check whether the\n     line was actually added (HISTIGNORE may have caused it to not be),\n     so we check hist_last_line_added.  This needs to agree with the\n     calculation of last_hist in fc_builtin above. */\n  /* Even though command substitution through parse_and_execute turns off\n     remember_on_history, command substitution in a shell when set -o history\n     has been enabled (interactive or not) should use it in the last_hist\n     calculation as if it were on. */\n  rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);\n  last_hist = i - rh - hist_last_line_added;\n\n  if (i == last_hist && hlist[last_hist] == 0)\n    while (last_hist >= 0 && hlist[last_hist] == 0)\n      last_hist--;\n  if (last_hist < 0)\n    return (-1);\n\n  real_last = i;\n  i = last_hist;\n\n  /* No specification defaults to most recent command. */\n  if (command == NULL)\n    return (i);\n\n  /* back up from the end to the last non-null history entry */\n  while (hlist[real_last] == 0 && real_last > 0)\n    real_last--;\n\n  /* Otherwise, there is a specification.  It can be a number relative to\n     the current position, or an absolute history number. */\n  s = command;\n\n  /* Handle possible leading minus sign. */\n  if (s && (*s == '-'))\n    {\n      sign = -1;\n      s++;\n    }\n\n  if (s && DIGIT(*s))\n    {\n      n = atoi (s);\n      n *= sign;\n\n      /* We want to return something that is an offset to HISTORY_BASE. */\n\n      /* If the value is negative or zero, then it is an offset from\n\t the current history item. */\n      /* We don't use HN_FIRST here, so we don't return different values\n\t depending on whether we're looking for the first or last in a\n\t pair of range arguments, but nobody else does, either. */\n      if (n < 0)\n\t{\n\t  n += i + 1;\n\t  return (n < 0 ? 0 : n);\n\t}\n      else if (n == 0)\n\treturn ((sign == -1) ? (listing ? real_last : HIST_INVALID) : i);\n      else\n\t{\n\t  /* If we're out of range (greater than I (last history entry) or\n\t     less than HISTORY_BASE, we want to return different values\n\t     based on whether or not we are looking for the first or last\n\t     value in a desired range of history entries. */\n\t  n -= history_base;\n\t  if (n < 0)\n\t    return (mode & HN_FIRST ? 0 : i);\n\t  else if (n >= i)\n\t    return (mode & HN_FIRST ? 0 : i);\n\t  else\n\t    return n;\n\t}\n    }\n\n  clen = strlen (command);\n  for (j = i; j >= 0; j--)\n    {\n      if (STREQN (command, histline (j), clen))\n\treturn (j);\n    }\n  return (HIST_NOTFOUND);\n}\n\n/* Locate the most recent history line which begins with\n   COMMAND in HLIST, and return a malloc()'ed copy of it.\n   MODE is 1 if we are listing commands, 0 if we are executing them. */\nstatic char *\nfc_gethist (command, hlist, mode)\n     char *command;\n     HIST_ENTRY **hlist;\n     int mode;\n{\n  int i;\n\n  if (hlist == 0)\n    return ((char *)NULL);\n\n  i = fc_gethnum (command, hlist, mode);\n\n  if (i >= 0)\n    return (savestring (histline (i)));\n  else\n    return ((char *)NULL);\n}\n\n#ifdef INCLUDE_UNUSED\n/* Read the edited history lines from STREAM and return them\n   one at a time.  This can read unlimited length lines.  The\n   caller should free the storage. */\nstatic char *\nfc_readline (stream)\n     FILE *stream;\n{\n  register int c;\n  int line_len = 0, lindex = 0;\n  char *line = (char *)NULL;\n\n  while ((c = getc (stream)) != EOF)\n    {\n      if ((lindex + 2) >= line_len)\n\tline = (char *)xrealloc (line, (line_len += 128));\n\n      if (c == '\\n')\n\t{\n\t  line[lindex++] = '\\n';\n\t  line[lindex++] = '\\0';\n\t  return (line);\n\t}\n      else\n\tline[lindex++] = c;\n    }\n\n  if (!lindex)\n    {\n      if (line)\n\tfree (line);\n\n      return ((char *)NULL);\n    }\n\n  if (lindex + 2 >= line_len)\n    line = (char *)xrealloc (line, lindex + 3);\n\n  line[lindex++] = '\\n';\t    /* Finish with newline if none in file */\n  line[lindex++] = '\\0';\n  return (line);\n}\n#endif\n\n/* Perform the SUBS on COMMAND.\n   SUBS is a list of substitutions, and COMMAND is a simple string.\n   Return a pointer to a malloc'ed string which contains the substituted\n   command. */\nstatic char *\nfc_dosubs (command, subs)\n     char *command;\n     REPL *subs;\n{\n  register char *new, *t;\n  register REPL *r;\n\n  for (new = savestring (command), r = subs; r; r = r->next)\n    {\n      t = strsub (new, r->pat, r->rep, 1);\n      free (new);\n      new = t;\n    }\n  return (new);\n}\n\n/* Use `command' to replace the last entry in the history list, which,\n   by this time, is `fc blah...'.  The intent is that the new command\n   become the history entry, and that `fc' should never appear in the\n   history list.  This way you can do `r' to your heart's content. */\nstatic void\nfc_replhist (command)\n     char *command;\n{\n  int n;\n\n  if (command == 0 || *command == '\\0')\n    return;\n\n  n = strlen (command);\n  if (command[n - 1] == '\\n')\n    command[n - 1] = '\\0';\n\n  if (command && *command)\n    {\n      bash_delete_last_history ();\n      maybe_add_history (command);\t/* Obeys HISTCONTROL setting. */\n    }\n}\n\n#ifdef INCLUDE_UNUSED\n/* Add LINE to the history, after removing a single trailing newline. */\nstatic void\nfc_addhist (line)\n     char *line;\n{\n  register int n;\n\n  if (line == 0 || *line == 0)\n    return;\n\n  n = strlen (line);\n\n  if (line[n - 1] == '\\n')\n    line[n - 1] = '\\0';\n\n  if (line && *line)\n    maybe_add_history (line);\t\t/* Obeys HISTCONTROL setting. */\n}\n#endif\n\n#endif /* HISTORY */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}