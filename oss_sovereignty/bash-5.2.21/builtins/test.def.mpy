{
  "module_name": "test.def",
  "hash_id": "e0fdf68b5ee67f7a5a85c717b8e0b716fed61101a7ca8241df9d38f92fdcffe4",
  "original_prompt": "Ingested from bash-5.2.21/builtins/test.def",
  "human_readable_source": "This file is test.def, from which is created test.c.\nIt implements the builtin \"test\" in Bash.\n\nCopyright (C) 1987-2015 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES test.c\n\n$BUILTIN test\n$FUNCTION test_builtin\n$SHORT_DOC test [expr]\nEvaluate conditional expression.\n\nExits with a status of 0 (true) or 1 (false) depending on\nthe evaluation of EXPR.  Expressions may be unary or binary.  Unary\nexpressions are often used to examine the status of a file.  There\nare string operators and numeric comparison operators as well.\n\nThe behavior of test depends on the number of arguments.  Read the\nbash manual page for the complete specification.\n\nFile operators:\n\n  -a FILE        True if file exists.\n  -b FILE        True if file is block special.\n  -c FILE        True if file is character special.\n  -d FILE        True if file is a directory.\n  -e FILE        True if file exists.\n  -f FILE        True if file exists and is a regular file.\n  -g FILE        True if file is set-group-id.\n  -h FILE        True if file is a symbolic link.\n  -L FILE        True if file is a symbolic link.\n  -k FILE        True if file has its `sticky' bit set.\n  -p FILE        True if file is a named pipe.\n  -r FILE        True if file is readable by you.\n  -s FILE        True if file exists and is not empty.\n  -S FILE        True if file is a socket.\n  -t FD          True if FD is opened on a terminal.\n  -u FILE        True if the file is set-user-id.\n  -w FILE        True if the file is writable by you.\n  -x FILE        True if the file is executable by you.\n  -O FILE        True if the file is effectively owned by you.\n  -G FILE        True if the file is effectively owned by your group.\n  -N FILE        True if the file has been modified since it was last read.\n\n  FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n                   modification date).\n\n  FILE1 -ot FILE2  True if file1 is older than file2.\n\n  FILE1 -ef FILE2  True if file1 is a hard link to file2.\n\nString operators:\n\n  -z STRING      True if string is empty.\n\n  -n STRING\n     STRING      True if string is not empty.\n\n  STRING1 = STRING2\n                 True if the strings are equal.\n  STRING1 != STRING2\n                 True if the strings are not equal.\n  STRING1 < STRING2\n                 True if STRING1 sorts before STRING2 lexicographically.\n  STRING1 > STRING2\n                 True if STRING1 sorts after STRING2 lexicographically.\n\nOther operators:\n\n  -o OPTION      True if the shell option OPTION is enabled.\n  -v VAR         True if the shell variable VAR is set.\n  -R VAR         True if the shell variable VAR is set and is a name\n                 reference.\n  ! EXPR         True if expr is false.\n  EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n  EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n\n  arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n                 -lt, -le, -gt, or -ge.\n\nArithmetic binary operators return true if ARG1 is equal, not-equal,\nless-than, less-than-or-equal, greater-than, or greater-than-or-equal\nthan ARG2.\n\nExit Status:\nReturns success if EXPR evaluates to true; fails if EXPR evaluates to\nfalse or an invalid argument is given.\n$END\n\n$BUILTIN [\n$DOCNAME test_bracket\n$FUNCTION test_builtin\n$SHORT_DOC [ arg... ]\nEvaluate conditional expression.\n\nThis is a synonym for the \"test\" builtin, but the last argument must\nbe a literal `]', to match the opening `['.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../test.h\"\n#include \"common.h\"\n\n/* TEST/[ builtin. */\nint\ntest_builtin (list)\n     WORD_LIST *list;\n{\n  char **argv;\n  int argc, result;\n\n  /* We let Matthew Bradburn and Kevin Braunsdorf's code do the\n     actual test command.  So turn the list of args into an array\n     of strings, since that is what their code wants. */\n  if (list == 0)\n    {\n      if (this_command_name[0] == '[' && !this_command_name[1])\n\t{\n\t  builtin_error (_(\"missing `]'\"));\n\t  return (EX_BADUSAGE);\n\t}\n\n      return (EXECUTION_FAILURE);\n    }\n\n  argv = make_builtin_argv  (list, &argc);\n  result = test_command (argc, argv);\n  free ((char *)argv);\n\n  return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}