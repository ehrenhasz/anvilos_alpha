{
  "module_name": "type.def",
  "hash_id": "298f8eb17b5b7dbcb2147a27f9f75255a430fd97970f7b85b0cb184b23aacc07",
  "original_prompt": "Ingested from bash-5.2.21/builtins/type.def",
  "human_readable_source": "This file is type.def, from which is created type.c.\nIt implements the builtin \"type\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES type.c\n\n$BUILTIN type\n$FUNCTION type_builtin\n$SHORT_DOC type [-afptP] name [name ...]\nDisplay information about command type.\n\nFor each NAME, indicate how it would be interpreted if used as a\ncommand name.\n\nOptions:\n  -a\tdisplay all locations containing an executable named NAME;\n\t\tincludes aliases, builtins, and functions, if and only if\n\t\tthe `-p' option is not also used\n  -f\tsuppress shell function lookup\n  -P\tforce a PATH search for each NAME, even if it is an alias,\n\t\tbuiltin, or function, and returns the name of the disk file\n\t\tthat would be executed\n  -p\treturns either the name of the disk file that would be executed,\n\t\tor nothing if `type -t NAME' would not return `file'\n  -t\toutput a single word which is one of `alias', `keyword',\n\t\t`function', `builtin', `file' or `', if NAME is an alias,\n\t\tshell reserved word, shell function, shell builtin, disk file,\n\t\tor not found, respectively\n\nArguments:\n  NAME\tCommand name to be interpreted.\n\nExit Status:\nReturns success if all of the NAMEs are found; fails if any are not found.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../parser.h\"\n#include \"../execute_cmd.h\"\n#include \"../findcmd.h\"\n#include \"../hashcmd.h\"\n\n#if defined (ALIAS)\n#include \"../alias.h\"\n#endif /* ALIAS */\n\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\nextern int find_reserved_word PARAMS((char *));\n\n/* For each word in LIST, find out what the shell is going to do with\n   it as a simple command. i.e., which file would this shell use to\n   execve, or if it is a builtin command, or an alias.  Possible flag\n   arguments:\n\t-t\t\tReturns the \"type\" of the object, one of\n\t\t\t`alias', `keyword', `function', `builtin',\n\t\t\tor `file'.\n\n\t-p\t\tReturns the pathname of the file if -type is\n\t\t\ta file.\n\n\t-a\t\tReturns all occurrences of words, whether they\n\t\t\tbe a filename in the path, alias, function,\n\t\t\tor builtin.\n\n\t-f\t\tSuppress shell function lookup, like `command'.\n\n\t-P\t\tForce a path search even in the presence of other\n\t\t\tdefinitions.\n\n   Order of evaluation:\n\talias\n\tkeyword\n\tfunction\n\tbuiltin\n\tfile\n */\n\nint\ntype_builtin (list)\n     WORD_LIST *list;\n{\n  int dflags, any_failed, opt;\n  WORD_LIST *this;\n\n  if (list == 0)\n    return (EXECUTION_SUCCESS);\n\n  dflags = CDESC_SHORTDESC;\t/* default */\n  any_failed = 0;\n\n  /* Handle the obsolescent `-type', `-path', and `-all' by prescanning\n     the arguments and converting those options to the form that\n     internal_getopt recognizes. Converts `--type', `--path', and `--all'\n     also. THIS SHOULD REALLY GO AWAY. */\n  for (this = list; this && this->word->word[0] == '-'; this = this->next)\n    {\n      char *flag = &(this->word->word[1]);\n\n      if (STREQ (flag, \"type\") || STREQ (flag, \"-type\"))\n\t{\n\t  this->word->word[1] = 't';\n\t  this->word->word[2] = '\\0';\n\t}\n      else if (STREQ (flag, \"path\") || STREQ (flag, \"-path\"))\n\t{\n\t  this->word->word[1] = 'p';\n\t  this->word->word[2] = '\\0';\n\t}\n      else if (STREQ (flag, \"all\") || STREQ (flag, \"-all\"))\n\t{\n\t  this->word->word[1] = 'a';\n\t  this->word->word[2] = '\\0';\n\t}\n    }\n\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"afptP\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'a':\n\t  dflags |= CDESC_ALL;\n\t  break;\n\tcase 'f':\n\t  dflags |= CDESC_NOFUNCS;\n\t  break;\n\tcase 'p':\n\t  dflags |= CDESC_PATH_ONLY;\n\t  dflags &= ~(CDESC_TYPE|CDESC_SHORTDESC);\n\t  break;\n\tcase 't':\n\t  dflags |= CDESC_TYPE;\n\t  dflags &= ~(CDESC_PATH_ONLY|CDESC_SHORTDESC);\n\t  break;\n\tcase 'P':\t/* shorthand for type -ap */\n\t  dflags |= (CDESC_PATH_ONLY|CDESC_FORCE_PATH);\n\t  dflags &= ~(CDESC_TYPE|CDESC_SHORTDESC);\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  while (list)\n    {\n      int found;\n\n      found = describe_command (list->word->word, dflags);\n\n      if (!found && (dflags & (CDESC_PATH_ONLY|CDESC_TYPE)) == 0)\n\tsh_notfound (list->word->word);\n\n      any_failed += found == 0;\n      list = list->next;\n    }\n\n  opt = (any_failed == 0) ? EXECUTION_SUCCESS : EXECUTION_FAILURE;\n  return (sh_chkwrite (opt));\n}\n\n/*\n * Describe COMMAND as required by the type and command builtins.\n *\n * Behavior is controlled by DFLAGS.  Flag values are\n *\tCDESC_ALL\tprint all descriptions of a command\n *\tCDESC_SHORTDESC\tprint the description for type and command -V\n *\tCDESC_REUSABLE\tprint in a format that may be reused as input\n *\tCDESC_TYPE\tprint the type for type -t\n *\tCDESC_PATH_ONLY\tprint the path for type -p\n *\tCDESC_FORCE_PATH\tforce a path search for type -P\n *\tCDESC_NOFUNCS\tskip function lookup for type -f\n *\tCDESC_ABSPATH\tconvert to absolute path, no ./ prefix\n *\tCDESC_STDPATH\tcommand -p standard path list\n *\n * CDESC_ALL says whether or not to look for all occurrences of COMMAND, or\n * return after finding it once.\n */\nint\ndescribe_command (command, dflags)\n     char *command;\n     int dflags;\n{\n  int found, i, found_file, f, all;\n  char *full_path, *x, *pathlist;\n  SHELL_VAR *func;\n#if defined (ALIAS)\n  alias_t *alias;\n#endif\n\n  all = (dflags & CDESC_ALL) != 0;\n  found = found_file = 0;\n  full_path = (char *)NULL;\n\n#if defined (ALIAS)\n  /* Command is an alias? */\n  if (((dflags & CDESC_FORCE_PATH) == 0) && expand_aliases && (alias = find_alias (command)))\n    {\n      if (dflags & CDESC_TYPE)\n\tputs (\"alias\");\n      else if (dflags & CDESC_SHORTDESC)\n\tprintf (_(\"%s is aliased to `%s'\\n\"), command, alias->value);\n      else if (dflags & CDESC_REUSABLE)\n\t{\n\t  x = sh_single_quote (alias->value);\n\t  printf (\"alias %s=%s\\n\", command, x);\n\t  free (x);\n\t}\n\n      found = 1;\n\n      if (all == 0)\n\treturn (1);\n    }\n#endif /* ALIAS */\n\n  /* Command is a shell reserved word? */\n  if (((dflags & CDESC_FORCE_PATH) == 0) && (i = find_reserved_word (command)) >= 0)\n    {\n      if (dflags & CDESC_TYPE)\n\tputs (\"keyword\");\n      else if (dflags & CDESC_SHORTDESC)\n\tprintf (_(\"%s is a shell keyword\\n\"), command);\n      else if (dflags & CDESC_REUSABLE)\n\tprintf (\"%s\\n\", command);\n\n      found = 1;\n\n      if (all == 0)\n\treturn (1);\n    }\n\n  /* Command is a function? */\n  if (((dflags & (CDESC_FORCE_PATH|CDESC_NOFUNCS)) == 0) && (func = find_function (command)))\n    {\n      if (dflags & CDESC_TYPE)\n\tputs (\"function\");\n      else if (dflags & CDESC_SHORTDESC)\n\t{\n\t  char *result;\n\n\t  printf (_(\"%s is a function\\n\"), command);\n\n\t  /* We're blowing away THE_PRINTED_COMMAND here... */\n\n\t  result = named_function_string (command, function_cell (func), FUNC_MULTILINE|FUNC_EXTERNAL);\n\t  printf (\"%s\\n\", result);\n\t}\n      else if (dflags & CDESC_REUSABLE)\n\tprintf (\"%s\\n\", command);\n\n      found = 1;\n\n      if (all == 0)\n\treturn (1);\n    }\n\n  /* Command is a builtin? */\n  if (((dflags & CDESC_FORCE_PATH) == 0) && find_shell_builtin (command))\n    {\n      if (dflags & CDESC_TYPE)\n\tputs (\"builtin\");\n      else if (dflags & CDESC_SHORTDESC)\n\t{\n\t  if (posixly_correct && find_special_builtin (command) != 0)\n\t    printf (_(\"%s is a special shell builtin\\n\"), command);\n\t  else\n\t    printf (_(\"%s is a shell builtin\\n\"), command);\n\t}\n      else if (dflags & CDESC_REUSABLE)\n\tprintf (\"%s\\n\", command);\n\n      found = 1;\n\n      if (all == 0)\n\treturn (1);\n    }\n\n  /* Command is a disk file? */\n  /* If the command name given is already an absolute command, just\n     check to see if it is executable. */\n  if (absolute_program (command))\n    {\n      f = file_status (command);\n      if (f & FS_EXECABLE)\n\t{\n\t  if (dflags & CDESC_TYPE)\n\t    puts (\"file\");\n\t  else if (dflags & CDESC_SHORTDESC)\n\t    printf (_(\"%s is %s\\n\"), command, command);\n\t  else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY))\n\t    printf (\"%s\\n\", command);\n\n\t  /* There's no use looking in the hash table or in $PATH,\n\t     because they're not consulted when an absolute program\n\t     name is supplied. */\n\t  return (1);\n\t}\n    }\n\n  /* If the user isn't doing \"-a\", then we might care about\n     whether the file is present in our hash table. */\n  if (all == 0 || (dflags & CDESC_FORCE_PATH))\n    {\n      if (full_path = phash_search (command))\n\t{\n\t  if (dflags & CDESC_TYPE)\n\t    puts (\"file\");\n\t  else if (dflags & CDESC_SHORTDESC)\n\t    printf (_(\"%s is hashed (%s)\\n\"), command, full_path);\n\t  else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY))\n\t    printf (\"%s\\n\", full_path);\n\n\t  free (full_path);\n\t  return (1);\n\t}\n    }\n\n  /* Now search through $PATH. */\n  while (1)\n    {\n      if (dflags & CDESC_STDPATH)\t/* command -p, all cannot be non-zero */\n\t{\n\t  pathlist = conf_standard_path ();\n\t  full_path = find_in_path (command, pathlist, FS_EXEC_PREFERRED|FS_NODIRS);\n\t  free (pathlist);\n\t  /* Will only go through this once, since all == 0 if STDPATH set */\n\t}\n      else if (all == 0)\n\tfull_path = find_user_command (command);\n      else\n\tfull_path = user_command_matches (command, FS_EXEC_ONLY, found_file);\t/* XXX - should that be FS_EXEC_PREFERRED? */\n\n      if (full_path == 0)\n\tbreak;\n\n      /* If we found the command as itself by looking through $PATH, it\n\t probably doesn't exist.  Check whether or not the command is an\n\t executable file.  If it's not, don't report a match.  This is\n\t the default posix mode behavior */\n      if (STREQ (full_path, command) || posixly_correct)\n\t{\n\t  f = file_status (full_path);\n\t  if ((f & FS_EXECABLE) == 0)\n\t    {\n\t      free (full_path);\n\t      full_path = (char *)NULL;\n\t      if (all == 0)\n\t\tbreak;\n\t    }\n\t  else if (ABSPATH (full_path))\n\t    ;\t/* placeholder; don't need to do anything yet */\n\t  else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY|CDESC_SHORTDESC))\n\t    {\n\t      f = MP_DOCWD | ((dflags & CDESC_ABSPATH) ? MP_RMDOT : 0);\n\t      x = sh_makepath ((char *)NULL, full_path, f);\n\t      free (full_path);\n\t      full_path = x;\n\t    }\n\t}\n      /* If we require a full path and don't have one, make one */\n      else if ((dflags & CDESC_ABSPATH) && ABSPATH (full_path) == 0)\n\t{\n\t  x = sh_makepath ((char *)NULL, full_path, MP_DOCWD|MP_RMDOT);\n\t  free (full_path);\n\t  full_path = x;\n\t}\n\n      found_file++;\n      found = 1;\n\n      if (dflags & CDESC_TYPE)\n\tputs (\"file\");\n      else if (dflags & CDESC_SHORTDESC)\n\tprintf (_(\"%s is %s\\n\"), command, full_path);\n      else if (dflags & (CDESC_REUSABLE|CDESC_PATH_ONLY))\n\tprintf (\"%s\\n\", full_path);\n\n      free (full_path);\n      full_path = (char *)NULL;\n\n      if (all == 0)\n\tbreak;\n    }\n\n  return (found);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}