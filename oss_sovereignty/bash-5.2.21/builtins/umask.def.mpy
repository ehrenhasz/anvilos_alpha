{
  "module_name": "umask.def",
  "hash_id": "c52d295390a5ba574014169370062ef04084577ea6875bf8f4b4adefe3617bbb",
  "original_prompt": "Ingested from bash-5.2.21/builtins/umask.def",
  "human_readable_source": "This file is umask.def, from which is created umask.c.\nIt implements the builtin \"umask\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES umask.c\n\n$BUILTIN umask\n$FUNCTION umask_builtin\n$SHORT_DOC umask [-p] [-S] [mode]\nDisplay or set file mode mask.\n\nSets the user file-creation mask to MODE.  If MODE is omitted, prints\nthe current value of the mask.\n\nIf MODE begins with a digit, it is interpreted as an octal number;\notherwise it is a symbolic mode string like that accepted by chmod(1).\n\nOptions:\n  -p\tif MODE is omitted, output in a form that may be reused as input\n  -S\tmakes the output symbolic; otherwise an octal number is output\n\nExit Status:\nReturns success unless MODE is invalid or an invalid option is given.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include \"filecntl.h\"\n#if ! defined(_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n\n#if defined (HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <chartypes.h>\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"posixstat.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n/* **************************************************************** */\n/*                                                                  */\n/*                     UMASK Builtin and Helpers                    */\n/*                                                                  */\n/* **************************************************************** */\n\nstatic void print_symbolic_umask PARAMS((mode_t));\nstatic int symbolic_umask PARAMS((WORD_LIST *));\n\n/* Set or display the mask used by the system when creating files.  Flag\n   of -S means display the umask in a symbolic mode. */\nint\numask_builtin (list)\n     WORD_LIST *list;\n{\n  int print_symbolically, opt, umask_value, pflag;\n  mode_t umask_arg;\n\n  print_symbolically = pflag = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"Sp\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'S':\n\t  print_symbolically++;\n\t  break;\n\tcase 'p':\n\t  pflag++;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  if (list)\n    {\n      if (DIGIT (*list->word->word))\n\t{\n\t  umask_value = read_octal (list->word->word);\n\n\t  /* Note that other shells just let you set the umask to zero\n\t     by specifying a number out of range.  This is a problem\n\t     with those shells.  We don't change the umask if the input\n\t     is lousy. */\n\t  if (umask_value == -1)\n\t    {\n\t      sh_erange (list->word->word, _(\"octal number\"));\n\t      return (EXECUTION_FAILURE);\n\t    }\n\t}\n      else\n\t{\n\t  umask_value = symbolic_umask (list);\n\t  if (umask_value == -1)\n\t    return (EXECUTION_FAILURE);\n\t}\n      umask_arg = (mode_t)umask_value;\n      umask (umask_arg);\n      if (print_symbolically)\n\tprint_symbolic_umask (umask_arg);\n    }\n  else\t\t\t\t/* Display the UMASK for this user. */\n    {\n      umask_arg = umask (022);\n      umask (umask_arg);\n\n      if (pflag)\n\tprintf (\"umask%s \", (print_symbolically ? \" -S\" : \"\"));\n      if (print_symbolically)\n\tprint_symbolic_umask (umask_arg);\n      else\n\tprintf (\"%04lo\\n\", (unsigned long)umask_arg);\n    }\n\n  return (sh_chkwrite (EXECUTION_SUCCESS));\n}\n\n/* Print the umask in a symbolic form.  In the output, a letter is\n   printed if the corresponding bit is clear in the umask. */\nstatic void\n#if defined (__STDC__)\nprint_symbolic_umask (mode_t um)\n#else\nprint_symbolic_umask (um)\n     mode_t um;\n#endif\n{\n  char ubits[4], gbits[4], obits[4];\t\t/* u=rwx,g=rwx,o=rwx */\n  int i;\n\n  i = 0;\n  if ((um & S_IRUSR) == 0)\n    ubits[i++] = 'r';\n  if ((um & S_IWUSR) == 0)\n    ubits[i++] = 'w';\n  if ((um & S_IXUSR) == 0)\n    ubits[i++] = 'x';\n  ubits[i] = '\\0';\n\n  i = 0;\n  if ((um & S_IRGRP) == 0)\n    gbits[i++] = 'r';\n  if ((um & S_IWGRP) == 0)\n    gbits[i++] = 'w';\n  if ((um & S_IXGRP) == 0)\n    gbits[i++] = 'x';\n  gbits[i] = '\\0';\n\n  i = 0;\n  if ((um & S_IROTH) == 0)\n    obits[i++] = 'r';\n  if ((um & S_IWOTH) == 0)\n    obits[i++] = 'w';\n  if ((um & S_IXOTH) == 0)\n    obits[i++] = 'x';\n  obits[i] = '\\0';\n\n  printf (\"u=%s,g=%s,o=%s\\n\", ubits, gbits, obits);\n}\n\nint\nparse_symbolic_mode (mode, initial_bits)\n     char *mode;\n     int initial_bits;\n{\n  int who, op, perm, bits, c;\n  char *s;\n\n  for (s = mode, bits = initial_bits;;)\n    {\n      who = op = perm = 0;\n\n      /* Parse the `who' portion of the symbolic mode clause. */\n      while (member (*s, \"agou\"))\n\t{\n\t  switch (c = *s++)\n\t    {\n\t    case 'u':\n\t      who |= S_IRWXU;\n\t      continue;\n\t    case 'g':\n\t      who |= S_IRWXG;\n\t      continue;\n\t    case 'o':\n\t      who |= S_IRWXO;\n\t      continue;\n\t    case 'a':\n\t      who |= S_IRWXU | S_IRWXG | S_IRWXO;\n\t      continue;\n\t    default:\n\t      break;\n\t    }\n\t}\n\n      /* The operation is now sitting in *s. */\n      op = *s++;\n      switch (op)\n\t{\n\tcase '+':\n\tcase '-':\n\tcase '=':\n\t  break;\n\tdefault:\n\t  builtin_error (_(\"`%c': invalid symbolic mode operator\"), op);\n\t  return (-1);\n\t}\n\n      /* Parse out the `perm' section of the symbolic mode clause. */\n      while (member (*s, \"rwx\"))\n\t{\n\t  c = *s++;\n\n\t  switch (c)\n\t    {\n\t    case 'r':\n\t      perm |= S_IRUGO;\n\t      break;\n\t    case 'w':\n\t      perm |= S_IWUGO;\n\t      break;\n\t    case 'x':\n\t      perm |= S_IXUGO;\n\t      break;\n\t    }\n\t}\n\n      /* Now perform the operation or return an error for a\n\t bad permission string. */\n      if (!*s || *s == ',')\n\t{\n\t  if (who)\n\t    perm &= who;\n\n\t  switch (op)\n\t    {\n\t    case '+':\n\t      bits |= perm;\n\t      break;\n\t    case '-':\n\t      bits &= ~perm;\n\t      break;\n\t    case '=':\n\t      if (who == 0)\n\t\twho = S_IRWXU | S_IRWXG | S_IRWXO;\n\t      bits &= ~who;\n\t      bits |= perm;\n\t      break;\n\n\t    /* No other values are possible. */\n\t    }\n\n\t  if (*s == '\\0')\n\t    break;\n\t  else\n\t    s++;\t/* skip past ',' */\n\t}\n      else\n\t{\n\t  builtin_error (_(\"`%c': invalid symbolic mode character\"), *s);\n\t  return (-1);\n\t}\n    }\n\n  return (bits);\n}\n\n/* Set the umask from a symbolic mode string similar to that accepted\n   by chmod.  If the -S argument is given, then print the umask in a\n   symbolic form. */\nstatic int\nsymbolic_umask (list)\n     WORD_LIST *list;\n{\n  int um, bits;\n\n  /* Get the initial umask.  Don't change it yet. */\n  um = umask (022);\n  umask (um);\n\n  /* All work is done with the complement of the umask -- it's\n     more intuitive and easier to deal with.  It is complemented\n     again before being returned. */\n  bits = parse_symbolic_mode (list->word->word, ~um & 0777);\n  if (bits == -1)\n    return (-1);\n\n  um = ~bits & 0777;\n  return (um);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}