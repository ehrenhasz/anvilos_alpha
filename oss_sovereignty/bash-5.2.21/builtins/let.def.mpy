{
  "module_name": "let.def",
  "hash_id": "541378a95dcc8247cc6b52ad08b76f68f28620f36de2a25c4c34c8fb550b81af",
  "original_prompt": "Ingested from bash-5.2.21/builtins/let.def",
  "human_readable_source": "This file is let.def, from which is created let.c.\nIt implements the builtin \"let\" in Bash.\n\nCopyright (C) 1987-2009 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$BUILTIN let\n$FUNCTION let_builtin\n$PRODUCES let.c\n$SHORT_DOC let arg [arg ...]\nEvaluate arithmetic expressions.\n\nEvaluate each ARG as an arithmetic expression.  Evaluation is done in\nfixed-width integers with no check for overflow, though division by 0\nis trapped and flagged as an error.  The following list of operators is\ngrouped into levels of equal-precedence operators.  The levels are listed\nin order of decreasing precedence.\n\n\tid++, id--\tvariable post-increment, post-decrement\n\t++id, --id\tvariable pre-increment, pre-decrement\n\t-, +\t\tunary minus, plus\n\t!, ~\t\tlogical and bitwise negation\n\t**\t\texponentiation\n\t*, /, %\t\tmultiplication, division, remainder\n\t+, -\t\taddition, subtraction\n\t<<, >>\t\tleft and right bitwise shifts\n\t<=, >=, <, >\tcomparison\n\t==, !=\t\tequality, inequality\n\t&\t\tbitwise AND\n\t^\t\tbitwise XOR\n\t|\t\tbitwise OR\n\t&&\t\tlogical AND\n\t||\t\tlogical OR\n\texpr ? expr : expr\n\t\t\tconditional operator\n\t=, *=, /=, %=,\n\t+=, -=, <<=, >>=,\n\t&=, ^=, |=\tassignment\n\nShell variables are allowed as operands.  The name of the variable\nis replaced by its value (coerced to a fixed-width integer) within\nan expression.  The variable need not have its integer attribute\nturned on to be used in an expression.\n\nOperators are evaluated in order of precedence.  Sub-expressions in\nparentheses are evaluated first and may override the precedence\nrules above.\n\nExit Status:\nIf the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"common.h\"\n\n/* Arithmetic LET function. */\nint\nlet_builtin (list)\n     WORD_LIST *list;\n{\n  intmax_t ret;\n  int expok;\n\n  CHECK_HELPOPT (list);\n\n  /* Skip over leading `--' argument. */\n  if (list && list->word && ISOPTION (list->word->word, '-'))\n    list = list->next;\n\n  if (list == 0)\n    {\n      builtin_error (_(\"expression expected\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  for (; list; list = list->next)\n    {\n      ret = evalexp (list->word->word, EXP_EXPANDED, &expok);\n      if (expok == 0)\n\treturn (EXECUTION_FAILURE);\n    }\n\n  return ((ret == 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n\n#ifdef INCLUDE_UNUSED\nint\nexp_builtin (list)\n     WORD_LIST *list;\n{\n  char *exp;\n  intmax_t ret;\n  int expok;\n\n  if (list == 0)\n    {\n      builtin_error (_(\"expression expected\"));\n      return (EXECUTION_FAILURE);\n    }\n\n  exp = string_list (list);\n  ret = evalexp (exp, EXP_EXPANDED, &expok);\n  (void)free (exp);\n  return (((ret == 0) || (expok == 0)) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}