{
  "module_name": "printf.def",
  "hash_id": "c6fe3ed8d1b30abdbe3d736f250565688af0c089b5c61c25a47c39b079cc6fd6",
  "original_prompt": "Ingested from bash-5.2.21/builtins/printf.def",
  "human_readable_source": "This file is printf.def, from which is created printf.c.\nIt implements the builtin \"printf\" in Bash.\n\nCopyright (C) 1997-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES printf.c\n\n$BUILTIN printf\n$FUNCTION printf_builtin\n$SHORT_DOC printf [-v var] format [arguments]\nFormats and prints ARGUMENTS under control of the FORMAT.\n\nOptions:\n  -v var\tassign the output to shell variable VAR rather than\n\t\tdisplay it on the standard output\n\nFORMAT is a character string which contains three types of objects: plain\ncharacters, which are simply copied to standard output; character escape\nsequences, which are converted and copied to the standard output; and\nformat specifications, each of which causes printing of the next successive\nargument.\n\nIn addition to the standard format specifications described in printf(1),\nprintf interprets:\n\n  %b\texpand backslash escape sequences in the corresponding argument\n  %q\tquote the argument in a way that can be reused as shell input\n  %Q\tlike %q, but apply any precision to the unquoted argument before\n\t\tquoting\n  %(fmt)T\toutput the date-time string resulting from using FMT as a format\n\t        string for strftime(3)\n\nThe format is re-used as necessary to consume all of the arguments.  If\nthere are fewer arguments than the format requires,  extra format\nspecifications behave as if a zero value or null string, as appropriate,\nhad been supplied.\n\nExit Status:\nReturns success unless an invalid option is given or a write or assignment\nerror occurs.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n\n#include <errno.h>\n#if defined (HAVE_LIMITS_H)\n#  include <limits.h>\n#else\n   /* Assume 32-bit ints. */\n#  define INT_MAX\t\t2147483647\n#  define INT_MIN\t\t(-2147483647-1)\n#endif\n\n#if defined (PREFER_STDARG)\n#  include <stdarg.h>\n#else\n#  include <varargs.h>\n#endif\n\n#include <stdio.h>\n#include <chartypes.h>\n\n#ifdef HAVE_INTTYPES_H\n#  include <inttypes.h>\n#endif\n\n#include \"posixtime.h\"\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#define NEED_STRFTIME_DECL\n\n#include \"../shell.h\"\n#include \"shmbutil.h\"\n#include \"stdc.h\"\n#include \"bashgetopt.h\"\n#include \"common.h\"\n\n#if defined (PRI_MACROS_BROKEN)\n#  undef PRIdMAX\n#endif\n\n#if !defined (PRIdMAX)\n#  if HAVE_LONG_LONG\n#    define PRIdMAX\t\"lld\"\n#  else\n#    define PRIdMAX\t\"ld\"\n#  endif\n#endif\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#define PC(c) \\\n  do { \\\n    char b[2]; \\\n    tw++; \\\n    b[0] = c; b[1] = '\\0'; \\\n    if (vflag) \\\n      vbadd (b, 1); \\\n    else \\\n      putchar (c); \\\n    QUIT; \\\n  } while (0)\n\n#define PF(f, func) \\\n  do { \\\n    int nw; \\\n    clearerr (stdout); \\\n    if (have_fieldwidth && have_precision) \\\n      nw = vflag ? vbprintf (f, fieldwidth, precision, func) : printf (f, fieldwidth, precision, func); \\\n    else if (have_fieldwidth) \\\n      nw = vflag ? vbprintf (f, fieldwidth, func) : printf (f, fieldwidth, func); \\\n    else if (have_precision) \\\n      nw = vflag ? vbprintf (f, precision, func) : printf (f, precision, func); \\\n    else \\\n      nw = vflag ? vbprintf (f, func) : printf (f, func); \\\n    tw += nw; \\\n    QUIT; \\\n    if (ferror (stdout)) \\\n      { \\\n\tsh_wrerror (); \\\n\tclearerr (stdout); \\\n\treturn (EXECUTION_FAILURE); \\\n      } \\\n  } while (0)\n\n/* We free the buffer used by mklong() if it's `too big'. */\n#define PRETURN(value) \\\n  do \\\n    { \\\n      QUIT; \\\n      if (vflag) \\\n\t{ \\\n\t  SHELL_VAR *v; \\\n\t  v = builtin_bind_variable  (vname, vbuf, bindflags); \\\n\t  stupidly_hack_special_variables (vname); \\\n\t  if (v == 0 || readonly_p (v) || noassign_p (v)) \\\n\t    return (EXECUTION_FAILURE); \\\n\t} \\\n      if (conv_bufsize > 4096 ) \\\n\t{ \\\n\t  free (conv_buf); \\\n\t  conv_bufsize = 0; \\\n\t  conv_buf = 0; \\\n\t} \\\n      if (vbsize > 4096) \\\n\t{ \\\n\t  free (vbuf); \\\n\t  vbsize = 0; \\\n\t  vbuf = 0; \\\n\t} \\\n      else if (vbuf) \\\n\tvbuf[0] = 0; \\\n      if (ferror (stdout) == 0) \\\n\tfflush (stdout); \\\n      QUIT; \\\n      if (ferror (stdout)) \\\n\t{ \\\n\t  sh_wrerror (); \\\n\t  clearerr (stdout); \\\n\t  return (EXECUTION_FAILURE); \\\n\t} \\\n      return (value); \\\n    } \\\n  while (0)\n\n#define SKIP1 \"#'-+ 0\"\n#define LENMODS \"hjlLtz\"\n\n#ifndef TIMELEN_MAX\n#  define TIMELEN_MAX 128\n#endif\n\nextern time_t shell_start_time;\n\n#if !HAVE_ASPRINTF\nextern int asprintf PARAMS((char **, const char *, ...)) __attribute__((__format__ (printf, 2, 3)));\n#endif\n\n#if !HAVE_VSNPRINTF\nextern int vsnprintf PARAMS((char *, size_t, const char *, va_list)) __attribute__((__format__ (printf, 3, 0)));\n#endif\n\nstatic void printf_erange PARAMS((char *));\nstatic int printstr PARAMS((char *, char *, int, int, int));\nstatic int tescape PARAMS((char *, char *, int *, int *));\nstatic char *bexpand PARAMS((char *, int, int *, int *));\nstatic char *vbadd PARAMS((char *, int));\nstatic int vbprintf PARAMS((const char *, ...)) __attribute__((__format__ (printf, 1, 2)));\nstatic char *mklong PARAMS((char *, char *, size_t));\nstatic int getchr PARAMS((void));\nstatic char *getstr PARAMS((void));\nstatic int  getint PARAMS((void));\nstatic intmax_t getintmax PARAMS((void));\nstatic uintmax_t getuintmax PARAMS((void));\n\n#if defined (HAVE_LONG_DOUBLE) && HAVE_DECL_STRTOLD && !defined(STRTOLD_BROKEN)\ntypedef long double floatmax_t;\n#  define USE_LONG_DOUBLE 1\n#  define FLOATMAX_CONV\t\"L\"\n#  define strtofltmax\tstrtold\n#else\ntypedef double floatmax_t;\n#  define USE_LONG_DOUBLE 0\n#  define FLOATMAX_CONV\t\"\"\n#  define strtofltmax\tstrtod\n#endif\nstatic double getdouble PARAMS((void));\nstatic floatmax_t getfloatmax PARAMS((void));\n\nstatic intmax_t asciicode PARAMS((void));\n\nstatic WORD_LIST *garglist, *orig_arglist;\nstatic int retval;\nstatic int conversion_error;\n\n/* printf -v var support */\nstatic int vflag = 0;\nstatic int bindflags = 0;\nstatic char *vbuf, *vname;\nstatic size_t vbsize;\nstatic int vblen;\n\nstatic intmax_t tw;\n\nstatic char *conv_buf;\nstatic size_t conv_bufsize;\n\nint\nprintf_builtin (list)\n     WORD_LIST *list;\n{\n  int ch, fieldwidth, precision;\n  int have_fieldwidth, have_precision, use_Lmod, altform;\n  char convch, thisch, nextch, *format, *modstart, *precstart, *fmt, *start;\n#if defined (HANDLE_MULTIBYTE)\n  char mbch[25];\t\t/* 25 > MB_LEN_MAX, plus can handle 4-byte UTF-8 and large Unicode characters*/\n  int mbind, mblen;\n#endif\n#if defined (ARRAY_VARS)\n  int arrayflags;\n#endif\n\n  conversion_error = 0;\n  vflag = 0;\n\n  reset_internal_getopt ();\n  while ((ch = internal_getopt (list, \"v:\")) != -1)\n    {\n      switch (ch)\n\t{\n\tcase 'v':\n\t  vname = list_optarg;\n\t  bindflags = 0;\n#if defined (ARRAY_VARS)\n\t  SET_VFLAGS (list_optflags, arrayflags, bindflags);\n\t  retval = legal_identifier (vname) || valid_array_reference (vname, arrayflags);\n#else\n\t  retval = legal_identifier (vname);\n#endif\n\t  if (retval)\n\t    {\n\t      vflag = 1;\n\t      if (vbsize == 0)\n\t\tvbuf = xmalloc (vbsize = 16);\n\t      vblen = 0;\n\t      if (vbuf)\n\t\tvbuf[0] = 0;\n\t    }\n\t  else\n\t    {\n\t      sh_invalidid (vname);\n\t      return (EX_USAGE);\n\t    }\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\t/* skip over possible `--' */\n\n  if (list == 0)\n    {\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n\n  /* Allow printf -v var \"\" to act like var=\"\" */\n  if (vflag && list->word->word && list->word->word[0] == '\\0')\n    {\n      SHELL_VAR *v;\n      v = builtin_bind_variable (vname, \"\", 0);\n      stupidly_hack_special_variables (vname);\n      return ((v == 0 || readonly_p (v) || noassign_p (v)) ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n    }\n\n  if (list->word->word == 0 || list->word->word[0] == '\\0')\n    return (EXECUTION_SUCCESS);\n\n  format = list->word->word;\n  tw = 0;\n  retval = EXECUTION_SUCCESS;\n\n  garglist = orig_arglist = list->next;\n\n  /* If the format string is empty after preprocessing, return immediately. */\n  if (format == 0 || *format == 0)\n    return (EXECUTION_SUCCESS);\n\n  /* Basic algorithm is to scan the format string for conversion\n     specifications -- once one is found, find out if the field\n     width or precision is a '*'; if it is, gather up value.  Note,\n     format strings are reused as necessary to use up the provided\n     arguments, arguments of zero/null string are provided to use\n     up the format string. */\n  do\n    {\n      tw = 0;\n      /* find next format specification */\n      for (fmt = format; *fmt; fmt++)\n\t{\n\t  precision = fieldwidth = 0;\n\t  have_fieldwidth = have_precision = altform = 0;\n\t  precstart = 0;\n\n\t  if (*fmt == '\\\\')\n\t    {\n\t      fmt++;\n\t      /* A NULL third argument to tescape means to bypass the\n\t\t special processing for arguments to %b. */\n#if defined (HANDLE_MULTIBYTE)\n\t      /* Accommodate possible use of \\u or \\U, which can result in\n\t\t multibyte characters */\n\t      memset (mbch, '\\0', sizeof (mbch));\n\t      fmt += tescape (fmt, mbch, &mblen, (int *)NULL);\n\t      for (mbind = 0; mbind < mblen; mbind++)\n\t        PC (mbch[mbind]);\n#else\n\t      fmt += tescape (fmt, &nextch, (int *)NULL, (int *)NULL);\n\t      PC (nextch);\n#endif\n\t      fmt--;\t/* for loop will increment it for us again */\n\t      continue;\n\t    }\n\n\t  if (*fmt != '%')\n\t    {\n\t      PC (*fmt);\n\t      continue;\n\t    }\n\n\t  /* ASSERT(*fmt == '%') */\n\t  start = fmt++;\n\n\t  if (*fmt == '%')\t\t/* %% prints a % */\n\t    {\n\t      PC ('%');\n\t      continue;\n\t    }\n\n\t  /* Found format specification, skip to field width. We check for\n\t     alternate form for possible later use. */\n\t  for (; *fmt && strchr(SKIP1, *fmt); ++fmt)\n\t    if (*fmt == '#')\n\t      altform++;\n\n\t  /* Skip optional field width. */\n\t  if (*fmt == '*')\n\t    {\n\t      fmt++;\n\t      have_fieldwidth = 1;\n\t      fieldwidth = getint ();\n\t    }\n\t  else\n\t    while (DIGIT (*fmt))\n\t      fmt++;\n\n\t  /* Skip optional '.' and precision */\n\t  if (*fmt == '.')\n\t    {\n\t      ++fmt;\n\t      if (*fmt == '*')\n\t\t{\n\t\t  fmt++;\n\t\t  have_precision = 1;\n\t\t  precision = getint ();\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Negative precisions are allowed but treated as if the\n\t\t     precision were missing; I would like to allow a leading\n\t\t     `+' in the precision number as an extension, but lots\n\t\t     of asprintf/fprintf implementations get this wrong. */\n#if 0\n\t\t  if (*fmt == '-' || *fmt == '+')\n#else\n\t\t  if (*fmt == '-')\n#endif\n\t\t    fmt++;\n\t\t  if (DIGIT (*fmt))\n\t\t    precstart = fmt;\n\t\t  while (DIGIT (*fmt))\n\t\t    fmt++;\n\t\t}\n\t    }\n\n\t  /* skip possible format modifiers */\n\t  modstart = fmt;\n\t  use_Lmod = 0;\n\t  while (*fmt && strchr (LENMODS, *fmt))\n\t    {\n\t      use_Lmod |= USE_LONG_DOUBLE && *fmt == 'L';\n\t      fmt++;\n\t    }\n\t    \n\t  if (*fmt == 0)\n\t    {\n\t      builtin_error (_(\"`%s': missing format character\"), start);\n\t      PRETURN (EXECUTION_FAILURE);\n\t    }\n\n\t  convch = *fmt;\n\t  thisch = modstart[0];\n\t  nextch = modstart[1];\n\t  modstart[0] = convch;\n\t  modstart[1] = '\\0';\n\n\t  QUIT;\n\t  switch(convch)\n\t    {\n\t    case 'c':\n\t      {\n\t\tchar p;\n\n\t\tp = getchr ();\n\t\tPF(start, p);\n\t\tbreak;\n\t      }\n\n\t    case 's':\n\t      {\n\t\tchar *p;\n\n\t\tp = getstr ();\n\t\tPF(start, p);\n\t\tbreak;\n\t      }\n\n\t    case '(':\n\t      {\n\t\tchar *timefmt, timebuf[TIMELEN_MAX], *t;\n\t\tint n;\n\t\tintmax_t arg;\n\t\ttime_t secs;\n\t\tstruct tm *tm;\n\n\t\tmodstart[1] = nextch;\t/* restore char after left paren */\n\t\ttimefmt = xmalloc (strlen (fmt) + 3);\n\t\tfmt++;\t/* skip over left paren */\n\t\tfor (t = timefmt, n = 1; *fmt; )\n\t\t  {\n\t\t    if (*fmt == '(')\n\t\t      n++;\n\t\t    else if (*fmt == ')')\n\t\t      n--;\n\t\t    if (n == 0)\n\t\t      break;\n\t\t    *t++ = *fmt++;\n\t\t  }\n\t\t*t = '\\0';\n\t\tif (*++fmt != 'T')\n\t\t  {\n\t\t    builtin_warning (_(\"`%c': invalid time format specification\"), *fmt);\n\t\t    fmt = start;\n\t\t    free (timefmt);\n\t\t    PC (*fmt);\n\t\t    continue;\n\t\t  }\n\t\tif (timefmt[0] == '\\0')\n\t\t  {\n\t\t    timefmt[0] = '%';\n\t\t    timefmt[1] = 'X';\t/* locale-specific current time - should we use `+'? */\n\t\t    timefmt[2] = '\\0';\n\t\t  }\n\t\t/* argument is seconds since the epoch with special -1 and -2 */\n\t\t/* default argument is equivalent to -1; special case */\n\t\targ = garglist ? getintmax () : -1;\n\t\tif (arg == -1)\n\t\t  secs = NOW;\t\t/* roughly date +%s */\n\t\telse if (arg == -2)\n\t\t  secs = shell_start_time;\t/* roughly $SECONDS */\n\t\telse\n\t\t  secs = arg;\n#if defined (HAVE_TZSET)\n\t\tsv_tz (\"TZ\");\t\t/* XXX -- just make sure */\n#endif\n\t\ttm = localtime (&secs);\n\t\tif (tm == 0)\n\t\t  {\n\t\t    secs = 0;\n\t\t    tm = localtime (&secs);\n\t\t  }\n\t\tn = tm ? strftime (timebuf, sizeof (timebuf), timefmt, tm) : 0;\n\t\tfree (timefmt);\n\t\tif (n == 0)\n\t\t  timebuf[0] = '\\0';\n\t\telse\n\t\t  timebuf[sizeof(timebuf) - 1] = '\\0';\n\t\t/* convert to %s format that preserves fieldwidth and precision */\n\t\tmodstart[0] = 's';\n\t\tmodstart[1] = '\\0';\n\t\tn = printstr (start, timebuf, strlen (timebuf), fieldwidth, precision);\t/* XXX - %s for now */\n\t\tif (n < 0)\n\t\t  {\n\t\t    if (ferror (stdout) == 0)\n\t\t      {\n\t\t\tsh_wrerror ();\n\t\t\tclearerr (stdout);\n\t\t      }\n\t\t    PRETURN (EXECUTION_FAILURE);\n\t\t  }\n\t\tbreak;\n\t      }\n\n\t    case 'n':\n\t      {\n\t\tchar *var;\n\n\t\tvar = getstr ();\n\t\tif (var && *var)\n\t\t  {\n\t\t    if (legal_identifier (var))\n\t\t      bind_var_to_int (var, tw, 0);\n\t\t    else\n\t\t      {\n\t\t\tsh_invalidid (var);\n\t\t\tPRETURN (EXECUTION_FAILURE);\n\t\t      }\n\t\t  }\n\t\tbreak;\n\t      }\n\n\t    case 'b':\t\t/* expand escapes in argument */\n\t      {\n\t\tchar *p, *xp;\n\t\tint rlen, r;\n\n\t\tp = getstr ();\n\t\tch = rlen = r = 0;\n\t\txp = bexpand (p, strlen (p), &ch, &rlen);\n\n\t\tif (xp)\n\t\t  {\n\t\t    /* Have to use printstr because of possible NUL bytes\n\t\t       in XP -- printf does not handle that well. */\n\t\t    r = printstr (start, xp, rlen, fieldwidth, precision);\n\t\t    if (r < 0)\n\t\t      {\n\t\t\tif (ferror (stdout) == 0)\n\t\t\t  {\n\t\t            sh_wrerror ();\n\t\t\t    clearerr (stdout);\n\t\t\t  }\n\t\t        retval = EXECUTION_FAILURE;\n\t\t      }\n\t\t    free (xp);\n\t\t  }\n\n\t\tif (ch || r < 0)\n\t\t  PRETURN (retval);\n\t\tbreak;\n\t      }\n\n\t    case 'q':\t\t/* print with shell quoting */\n\t    case 'Q':\n\t      {\n\t\tchar *p, *xp;\n\t\tint r, mpr;\n\t\tsize_t slen;\n\n\t\tr = 0;\n\t\tp = getstr ();\n\t\t/* Decode precision and apply it to the unquoted string. */\n\t\tif (convch == 'Q' && precstart)\n\t\t  {\n\t\t    mpr = *precstart++ - '0';\n\t\t    while (DIGIT (*precstart))\n\t\t      mpr = (mpr * 10) + (*precstart++ - '0');\n\t\t    /* Error if precision > INT_MAX here? */\n\t\t    precision = (mpr < 0 || mpr > INT_MAX) ? INT_MAX : mpr;\n\t\t    slen = strlen (p);\n\t\t    /* printf precision works in bytes. */\n\t\t    if (precision < slen)\n\t\t      p[precision] = '\\0';\n\t\t  }\n\t\tif (p && *p == 0)\t/* XXX - getstr never returns null */\n\t\t  xp = savestring (\"''\");\n\t\telse if (ansic_shouldquote (p))\n\t\t  xp = ansic_quote (p, 0, (int *)0);\n\t\telse\n\t\t  xp = sh_backslash_quote (p, 0, 3);\n\t\tif (xp)\n\t\t  {\n\t\t    if (convch == 'Q')\n\t\t      {\n\t\t\tslen = strlen (xp);\n\t\t\tif (slen > precision)\n\t\t\t  precision = slen;\n\t\t      }\t\t    \n\t\t    /* Use printstr to get fieldwidth and precision right. */\n\t\t    r = printstr (start, xp, strlen (xp), fieldwidth, precision);\n\t\t    if (r < 0)\n\t\t      {\n\t\t\tsh_wrerror ();\n\t\t\tclearerr (stdout);\n\t\t      }\n\t\t    free (xp);\n\t\t  }\n\n\t\tif (r < 0)\n\t\t  PRETURN (EXECUTION_FAILURE);\n\t\tbreak;\n\t      }\n\n\t    case 'd':\n\t    case 'i':\n\t      {\n\t\tchar *f;\n\t\tlong p;\n\t\tintmax_t pp;\n\n\t\tp = pp = getintmax ();\n\t\tif (p != pp)\n\t\t  {\n\t\t    f = mklong (start, PRIdMAX, sizeof (PRIdMAX) - 2);\n\t\t    PF (f, pp);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    /* Optimize the common case where the integer fits\n\t\t       in \"long\".  This also works around some long\n\t\t       long and/or intmax_t library bugs in the common\n\t\t       case, e.g. glibc 2.2 x86.  */\n\t\t    f = mklong (start, \"l\", 1);\n\t\t    PF (f, p);\n\t\t  }\n\t\tbreak;\n\t      }\n\n\t    case 'o':\n\t    case 'u':\n\t    case 'x':\n\t    case 'X':\n\t      {\n\t\tchar *f;\n\t\tunsigned long p;\n\t\tuintmax_t pp;\n\n\t\tp = pp = getuintmax ();\n\t\tif (p != pp)\n\t\t  {\n\t\t    f = mklong (start, PRIdMAX, sizeof (PRIdMAX) - 2);\n\t\t    PF (f, pp);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    f = mklong (start, \"l\", 1);\n\t\t    PF (f, p);\n\t\t  }\n\t\tbreak;\n\t      }\n\n\t    case 'e':\n\t    case 'E':\n\t    case 'f':\n\t    case 'F':\n\t    case 'g':\n\t    case 'G':\n#if defined (HAVE_PRINTF_A_FORMAT)\n\t    case 'a':\n\t    case 'A':\n#endif\n\t      {\n\t\tchar *f;\n\n\t      \tif (use_Lmod || posixly_correct == 0)\n\t\t  {\n\t\t    floatmax_t p;\n\n\t\t    p = getfloatmax ();\n\t\t    f = mklong (start, \"L\", 1);\n\t\t    PF (f, p);\n\t\t  }\n\t\telse\t\t/* posixly_correct */\n\t\t  {\n\t\t    double p;\n\n\t\t    p = getdouble ();\n\t\t    f = mklong (start, \"\", 0);\n\t\t    PF (f, p);\n\t\t  }\n\n\t\tbreak;\n\t      }\n\n\t    /* We don't output unrecognized format characters; we print an\n\t       error message and return a failure exit status. */\n\t    default:\n\t      builtin_error (_(\"`%c': invalid format character\"), convch);\n\t      PRETURN (EXECUTION_FAILURE);\n\t    }\n\n\t  modstart[0] = thisch;\n\t  modstart[1] = nextch;\n\t}\n\n      if (ferror (stdout))\n\t{\n\t  /* PRETURN will print error message. */\n\t  PRETURN (EXECUTION_FAILURE);\n\t}\n    }\n  while (garglist && garglist != list->next);\n\n  if (conversion_error)\n    retval = EXECUTION_FAILURE;\n\n  PRETURN (retval);\n}\n\nstatic void\nprintf_erange (s)\n     char *s;\n{\n  builtin_error (_(\"warning: %s: %s\"), s, strerror(ERANGE));\n}\n\n/* We duplicate a lot of what printf(3) does here. */\nstatic int\nprintstr (fmt, string, len, fieldwidth, precision)\n     char *fmt;\t\t\t/* format */\n     char *string;\t\t/* expanded string argument */\n     int len;\t\t\t/* length of expanded string */\n     int fieldwidth;\t\t/* argument for width of `*' */\n     int precision;\t\t/* argument for precision of `*' */\n{\n#if 0\n  char *s;\n#endif\n  int padlen, nc, ljust, i;\n  int fw, pr;\t\t\t/* fieldwidth and precision */\n  intmax_t mfw, mpr;\n\n  if (string == 0)\n    string = \"\";\n\n#if 0\n  s = fmt;\n#endif\n  if (*fmt == '%')\n    fmt++;\n\n  ljust = fw = 0;\n  pr = -1;\n  mfw = 0;\n  mpr = -1;\n\n  /* skip flags */\n  while (strchr (SKIP1, *fmt))\n    {\n      if (*fmt == '-')\n\tljust = 1;\n      fmt++;\n    }\n\n  /* get fieldwidth, if present.  rely on caller to clamp fieldwidth at INT_MAX */\n  if (*fmt == '*')\n    {\n      fmt++;\n      fw = fieldwidth;\n      if (fw < 0)\n\t{\n\t  fw = -fw;\n\t  ljust = 1;\n\t}\n    }\n  else if (DIGIT (*fmt))\n    {\n      mfw = *fmt++ - '0';\n      while (DIGIT (*fmt))\n\tmfw = (mfw * 10) + (*fmt++ - '0');\n      /* Error if fieldwidth > INT_MAX here? */\n      fw = (mfw < 0 || mfw > INT_MAX) ? INT_MAX : mfw;\n    }\n\n  /* get precision, if present. doesn't handle negative precisions */\n  if (*fmt == '.')\n    {\n      fmt++;\n      if (*fmt == '*')\n\t{\n\t  fmt++;\n\t  pr = precision;\n\t}\n      else if (DIGIT (*fmt))\n\t{\n\t  mpr = *fmt++ - '0';\n\t  while (DIGIT (*fmt))\n\t    mpr = (mpr * 10) + (*fmt++ - '0');\n\t  /* Error if precision > INT_MAX here? */\n\t  pr = (mpr < 0 || mpr > INT_MAX) ? INT_MAX : mpr;\n\t  if (pr < precision && precision < INT_MAX)\n\t    pr = precision;\t\t/* XXX */\n\t}\n      else\n\tpr = 0;\t\t/* \"a null digit string is treated as zero\" */\n    }\n\n#if 0\n  /* If we remove this, get rid of `s'. */\n  if (*fmt != 'b' && *fmt != 'q')\n    {\n      internal_error (_(\"format parsing problem: %s\"), s);\n      fw = pr = 0;\n    }\n#endif\n\n  /* chars from string to print */\n  nc = (pr >= 0 && pr <= len) ? pr : len;\n\n  padlen = fw - nc;\n  if (padlen < 0)\n    padlen = 0;\n  if (ljust)\n    padlen = -padlen;\n\n  /* leading pad characters */\n  for (; padlen > 0; padlen--)\n    PC (' ');\n\n  /* output NC characters from STRING */\n  for (i = 0; i < nc; i++)\n    PC (string[i]);\n\n  /* output any necessary trailing padding */\n  for (; padlen < 0; padlen++)\n    PC (' ');\n\n  return (ferror (stdout) ? -1 : 0);\n}\n  \n/* Convert STRING by expanding the escape sequences specified by the\n   POSIX standard for printf's `%b' format string.  If SAWC is non-null,\n   perform the processing appropriate for %b arguments.  In particular,\n   recognize `\\c' and use that as a string terminator.  If we see \\c, set\n   *SAWC to 1 before returning.  LEN is the length of STRING. */\n\n/* Translate a single backslash-escape sequence starting at ESTART (the\n   character after the backslash) and return the number of characters\n   consumed by the sequence.  CP is the place to return the translated\n   value.  *SAWC is set to 1 if the escape sequence was \\c, since that means\n   to short-circuit the rest of the processing.  If SAWC is null, we don't\n   do the \\c short-circuiting, and \\c is treated as an unrecognized escape\n   sequence; we also bypass the other processing specific to %b arguments.  */\nstatic int\ntescape (estart, cp, lenp, sawc)\n     char *estart;\n     char *cp;\n     int *lenp, *sawc;\n{\n  register char *p;\n  int temp, c, evalue;\n  unsigned long uvalue;\n\n  p = estart;\n  if (lenp)\n    *lenp = 1;\n\n  switch (c = *p++)\n    {\n#if defined (__STDC__)\n      case 'a': *cp = '\\a'; break;\n#else\n      case 'a': *cp = '\\007'; break;\n#endif\n\n      case 'b': *cp = '\\b'; break;\n\n      case 'e':\n      case 'E': *cp = '\\033'; break;\t/* ESC -- non-ANSI */\n\n      case 'f': *cp = '\\f'; break;\n\n      case 'n': *cp = '\\n'; break;\n\n      case 'r': *cp = '\\r'; break;\n\n      case 't': *cp = '\\t'; break;\n\n      case 'v': *cp = '\\v'; break;\n\n      /* The octal escape sequences are `\\0' followed by up to three octal\n\t digits (if SAWC), or `\\' followed by up to three octal digits (if\n\t !SAWC).  As an extension, we allow the latter form even if SAWC. */\n      case '0': case '1': case '2': case '3':\n      case '4': case '5': case '6': case '7':\n\tevalue = OCTVALUE (c);\n\tfor (temp = 2 + (!evalue && !!sawc); ISOCTAL (*p) && temp--; p++)\n\t  evalue = (evalue * 8) + OCTVALUE (*p);\n\t*cp = evalue & 0xFF;\n\tbreak;\n\n      /* And, as another extension, we allow \\xNN, where each N is a\n\t hex digit. */\n      case 'x':\n\tfor (temp = 2, evalue = 0; ISXDIGIT ((unsigned char)*p) && temp--; p++)\n\t  evalue = (evalue * 16) + HEXVALUE (*p);\n\tif (p == estart + 1)\n\t  {\n\t    builtin_error (_(\"missing hex digit for \\\\x\"));\n\t    *cp = '\\\\';\n\t    return 0;\n\t  }\n\t*cp = evalue & 0xFF;\n\tbreak;\n\n#if defined (HANDLE_MULTIBYTE)\n      case 'u':\n      case 'U':\n\ttemp = (c == 'u') ? 4 : 8;\t/* \\uNNNN \\UNNNNNNNN */\n\tfor (uvalue = 0; ISXDIGIT ((unsigned char)*p) && temp--; p++)\n\t  uvalue = (uvalue * 16) + HEXVALUE (*p);\n\tif (p == estart + 1)\n\t  {\n\t    builtin_error (_(\"missing unicode digit for \\\\%c\"), c);\n\t    *cp = '\\\\';\n\t    return 0;\n\t  }\n\tif (uvalue <= 0x7f)\t\t/* <= 0x7f translates directly */\n\t  *cp = uvalue;\n\telse\n\t  {\n\t    temp = u32cconv (uvalue, cp);\n\t    cp[temp] = '\\0';\n\t    if (lenp)\n\t      *lenp = temp;\n\t  }\n\tbreak;\n#endif\n\t\n      case '\\\\':\t/* \\\\ -> \\ */\n\t*cp = c;\n\tbreak;\n\n      /* SAWC == 0 means that \\', \\\", and \\? are recognized as escape\n\t sequences, though the only processing performed is backslash\n\t removal. */\n      case '\\'': case '\"': case '?':\n\tif (!sawc)\n\t  *cp = c;\n\telse\n\t  {\n\t    *cp = '\\\\';\n\t    return 0;\n\t  }\n\tbreak;\n\n      case 'c':\n\tif (sawc)\n\t  {\n\t    *sawc = 1;\n\t    break;\n\t  }\n      /* other backslash escapes are passed through unaltered */\n      default:\n\t*cp = '\\\\';\n\treturn 0;\n      }\n  return (p - estart);\n}\n\nstatic char *\nbexpand (string, len, sawc, lenp)\n     char *string;\n     int len, *sawc, *lenp;\n{\n  int temp;\n  char *ret, *r, *s, c;\n#if defined (HANDLE_MULTIBYTE)\n  char mbch[25];\n  int mbind, mblen;\n#endif\n\n  if (string == 0 || len == 0)\n    {\n      if (sawc)\n\t*sawc = 0;\n      if (lenp)\n\t*lenp = 0;\n      ret = (char *)xmalloc (1);\n      ret[0] = '\\0';\n      return (ret);\n    }\n\n  ret = (char *)xmalloc (len + 1);\n  for (r = ret, s = string; s && *s; )\n    {\n      c = *s++;\n      if (c != '\\\\' || *s == '\\0')\n\t{\n\t  *r++ = c;\n\t  continue;\n\t}\n      temp = 0;\n#if defined (HANDLE_MULTIBYTE)\n      memset (mbch, '\\0', sizeof (mbch));\n      s += tescape (s, mbch, &mblen, &temp);\n#else\n      s += tescape (s, &c, (int *)NULL, &temp);\n#endif\n      if (temp)\n\t{\n\t  if (sawc)\n\t    *sawc = 1;\n\t  break;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      for (mbind = 0; mbind < mblen; mbind++)\n\t*r++ = mbch[mbind];\n#else\n      *r++ = c;\n#endif      \n    }\n\n  *r = '\\0';\n  if (lenp)\n    *lenp = r - ret;\n  return ret;\n}\n\nstatic char *\nvbadd (buf, blen)\n     char *buf;\n     int blen;\n{\n  size_t nlen;\n\n  nlen = vblen + blen + 1;\n  if (nlen >= vbsize)\n    {\n      vbsize = ((nlen + 63) >> 6) << 6;\n      vbuf = (char *)xrealloc (vbuf, vbsize);\n    }\n\n  if (blen == 1)\n    vbuf[vblen++] = buf[0];\n  else if (blen > 1)\n    {\n      FASTCOPY (buf, vbuf  + vblen, blen);\n      vblen += blen;\n    }\n  vbuf[vblen] = '\\0';\n\n#ifdef DEBUG\n  if  (strlen (vbuf) != vblen)\n    internal_error  (\"printf:vbadd: vblen (%d) != strlen (vbuf) (%d)\", vblen, (int)strlen (vbuf));\n#endif\n\n  return vbuf;\n}\n\nstatic int\n#if defined (PREFER_STDARG)\nvbprintf (const char *format, ...)\n#else\nvbprintf (format, va_alist)\n  const char *format;\n  va_dcl\n#endif\n{\n  va_list args;\n  size_t nlen;\n  int blen;\n\n  SH_VA_START (args, format);\n  blen = vsnprintf (vbuf + vblen, vbsize - vblen, format, args);\n  va_end (args);\n\n  nlen = vblen + blen + 1;\n  if (nlen >= vbsize)\n    {\n      vbsize = ((nlen + 63) >> 6) << 6;\n      vbuf = (char *)xrealloc (vbuf, vbsize);\n      SH_VA_START (args, format);\n      blen = vsnprintf (vbuf + vblen, vbsize - vblen, format, args);\n      va_end (args);\n    }\n\n  vblen += blen;\n  vbuf[vblen] = '\\0';\n\n#ifdef DEBUG\n  if  (strlen (vbuf) != vblen)\n    internal_error  (\"printf:vbprintf: vblen (%d) != strlen (vbuf) (%d)\", vblen, (int)strlen (vbuf));\n#endif\n  \n  return (blen);\n}\n\nstatic char *\nmklong (str, modifiers, mlen)\n     char *str;\n     char *modifiers;\n     size_t mlen;\n{\n  size_t len, slen;\n\n  slen = strlen (str);\n  len = slen + mlen + 1;\n\n  if (len > conv_bufsize)\n    {\n      conv_bufsize = (((len + 1023) >> 10) << 10);\n      conv_buf = (char *)xrealloc (conv_buf, conv_bufsize);\n    }\n\n  FASTCOPY (str, conv_buf, slen - 1);\n  FASTCOPY (modifiers, conv_buf + slen - 1, mlen);\n\n  conv_buf[len - 2] = str[slen - 1];\n  conv_buf[len - 1] = '\\0';\n  return (conv_buf);\n}\n\nstatic int\ngetchr ()\n{\n  int ret;\n\n  if (garglist == 0)\n    return ('\\0');\n\n  ret = (int)garglist->word->word[0];\n  garglist = garglist->next;\n  return ret;\n}\n\nstatic char *\ngetstr ()\n{\n  char *ret;\n\n  if (garglist == 0)\n    return (\"\");\n\n  ret = garglist->word->word;\n  garglist = garglist->next;\n  return ret;\n}\n\nstatic int\ngetint ()\n{\n  intmax_t ret;\n\n  ret = getintmax ();\n\n  if (garglist == 0)\n    return ret;\n\n  if (ret > INT_MAX)\n    {\n      printf_erange (garglist->word->word);\n      ret = INT_MAX;\n    }\n  else if (ret < INT_MIN)\n    {\n      printf_erange (garglist->word->word);\n      ret = INT_MIN;\n    }\n\n  return ((int)ret);\n}\n\nstatic intmax_t\ngetintmax ()\n{\n  intmax_t ret;\n  char *ep;\n\n  if (garglist == 0)\n    return (0);\n\n  if (garglist->word->word[0] == '\\'' || garglist->word->word[0] == '\"')\n    return asciicode ();\n\n  errno = 0;\n  ret = strtoimax (garglist->word->word, &ep, 0);\n\n  if (*ep)\n    {\n      sh_invalidnum (garglist->word->word);\n      /* POSIX.2 says ``...a diagnostic message shall be written to standard\n\t error, and the utility shall not exit with a zero exit status, but\n\t shall continue processing any remaining operands and shall write the\n         value accumulated at the time the error was detected to standard\n\t output.''  Yecch. */\n#if 0\n      ret = 0;\t\t/* return partially-converted value from strtoimax */\n#endif\n      conversion_error = 1;\n    }\n  else if (errno == ERANGE)\n    printf_erange (garglist->word->word);\n\n  garglist = garglist->next;\n  return (ret);\n}\n\nstatic uintmax_t\ngetuintmax ()\n{\n  uintmax_t ret;\n  char *ep;\n\n  if (garglist == 0)\n    return (0);\n\n  if (garglist->word->word[0] == '\\'' || garglist->word->word[0] == '\"')\n    return asciicode ();\n\n  errno = 0;\n  ret = strtoumax (garglist->word->word, &ep, 0);\n  \n  if (*ep)\n    {\n      sh_invalidnum (garglist->word->word);\n#if 0\n      /* Same POSIX.2 conversion error requirements as getintmax(). */\n      ret = 0;\n#endif\n      conversion_error = 1;\n    }\n  else if (errno == ERANGE)\n    printf_erange (garglist->word->word);\n\n  garglist = garglist->next;\n  return (ret);\n}\n\nstatic double\ngetdouble ()\n{\n  double ret;\n  char *ep;\n\n  if (garglist == 0)\n    return (0);\n\n  if (garglist->word->word[0] == '\\'' || garglist->word->word[0] == '\"')\n    return asciicode ();\n\n  errno = 0;\n  ret = strtod (garglist->word->word, &ep);\n\n  if (*ep)\n    {\n      sh_invalidnum (garglist->word->word);\n      conversion_error = 1;\n    }\n  else if (errno == ERANGE)\n    printf_erange (garglist->word->word);\n\n  garglist = garglist->next;\n  return (ret);\n}\n\nstatic floatmax_t\ngetfloatmax ()\n{\n  floatmax_t ret;\n  char *ep;\n\n  if (garglist == 0)\n    return (0);\n\n  if (garglist->word->word[0] == '\\'' || garglist->word->word[0] == '\"')\n    return asciicode ();\n\n  errno = 0;\n  ret = strtofltmax (garglist->word->word, &ep);\n\n  if (*ep)\n    {\n      sh_invalidnum (garglist->word->word);\n#if 0\n      /* Same thing about POSIX.2 conversion error requirements. */\n      ret = 0;\n#endif\n      conversion_error = 1;\n    }\n  else if (errno == ERANGE)\n    printf_erange (garglist->word->word);\n\n  garglist = garglist->next;\n  return (ret);\n}\n\n/* NO check is needed for garglist here. */\nstatic intmax_t\nasciicode ()\n{\n  register intmax_t ch;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t wc;\n  size_t slen;\n  int mblength;\n#endif\n  DECLARE_MBSTATE;\n\n#if defined (HANDLE_MULTIBYTE)\n  slen = strlen (garglist->word->word+1);\n  wc = 0;\n  mblength = mbtowc (&wc, garglist->word->word+1, slen);\n  if (mblength > 0)\n    ch = wc;\t\t/* XXX */\n  else\n#endif\n    ch = (unsigned char)garglist->word->word[1];\n\n  garglist = garglist->next;\n  return (ch);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}