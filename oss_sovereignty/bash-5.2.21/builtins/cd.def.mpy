{
  "module_name": "cd.def",
  "hash_id": "99400079cd8dc8cc0359fdfd0f25aab49edf4380682549ceda5f74d851eeb238",
  "original_prompt": "Ingested from bash-5.2.21/builtins/cd.def",
  "human_readable_source": "This file is cd.def, from which is created cd.c.  It implements the\nbuiltins \"cd\" and \"pwd\" in Bash.\n\nCopyright (C) 1987-2022 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES cd.c\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashtypes.h\"\n#include \"posixdir.h\"\n#include \"posixstat.h\"\n#if defined (HAVE_SYS_PARAM_H)\n#include <sys/param.h>\n#endif\n#include <fcntl.h>\n\n#include <stdio.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include <errno.h>\n#include <tilde/tilde.h>\n\n#include \"../shell.h\"\n#include \"../flags.h\"\n#include \"maxpath.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif /* !errno */\n\nextern const char * const bash_getcwd_errstr;\n\nstatic int bindpwd PARAMS((int));\nstatic int setpwd PARAMS((char *));\nstatic char *resetpwd PARAMS((char *));\nstatic int change_to_directory PARAMS((char *, int, int));\n\nstatic int cdxattr PARAMS((char *, char **));\nstatic void resetxattr PARAMS((void));\n\n/* Change this to 1 to get cd spelling correction by default. */\nint cdspelling = 0;\n\nint cdable_vars;\n\nstatic int eflag;\t/* file scope so bindpwd() can see it */\nstatic int xattrflag;\t/* O_XATTR support for openat */\nstatic int xattrfd = -1;\n\n$BUILTIN cd\n$FUNCTION cd_builtin\n$SHORT_DOC cd [-L|[-P [-e]] [-@]] [dir]\nChange the shell working directory.\n\nChange the current directory to DIR.  The default DIR is the value of the\nHOME shell variable. If DIR is \"-\", it is converted to $OLDPWD.\n\nThe variable CDPATH defines the search path for the directory containing\nDIR.  Alternative directory names in CDPATH are separated by a colon (:).\nA null directory name is the same as the current directory.  If DIR begins\nwith a slash (/), then CDPATH is not used.\n\nIf the directory is not found, and the shell option `cdable_vars' is set,\nthe word is assumed to be  a variable name.  If that variable has a value,\nits value is used for DIR.\n\nOptions:\n  -L\tforce symbolic links to be followed: resolve symbolic\n\t\tlinks in DIR after processing instances of `..'\n  -P\tuse the physical directory structure without following\n\t\tsymbolic links: resolve symbolic links in DIR before\n\t\tprocessing instances of `..'\n  -e\tif the -P option is supplied, and the current working\n\t\tdirectory cannot be determined successfully, exit with\n\t\ta non-zero status\n#if defined (O_XATTR)\n  -@\ton systems that support it, present a file with extended\n\t\tattributes as a directory containing the file attributes\n#endif\n\nThe default is to follow symbolic links, as if `-L' were specified.\n`..' is processed by removing the immediately previous pathname component\nback to a slash or the beginning of DIR.\n\nExit Status:\nReturns 0 if the directory is changed, and if $PWD is set successfully when\n-P is used; non-zero otherwise.\n$END\n\n/* Just set $PWD, don't change OLDPWD.  Used by `pwd -P' in posix mode. */\nstatic int\nsetpwd (dirname)\n     char *dirname;\n{\n  int old_anm;\n  SHELL_VAR *tvar;\n\n  old_anm = array_needs_making;\n  tvar = bind_variable (\"PWD\", dirname ? dirname : \"\", 0);\n  if (tvar && readonly_p (tvar))\n    return EXECUTION_FAILURE;\n  if (tvar && old_anm == 0 && array_needs_making && exported_p (tvar))\n    {\n      update_export_env_inplace (\"PWD=\", 4, dirname ? dirname : \"\");\n      array_needs_making = 0;\n    }\n  return EXECUTION_SUCCESS;\n}\n\nstatic int\nbindpwd (no_symlinks)\n     int no_symlinks;\n{\n  char *dirname, *pwdvar;\n  int old_anm, r, canon_failed;\n  SHELL_VAR *tvar;\n\n  r = sh_chkwrite (EXECUTION_SUCCESS);\n\n#define tcwd the_current_working_directory\n  dirname = tcwd ? (no_symlinks ? sh_physpath (tcwd, 0) : tcwd)\n  \t\t : get_working_directory (\"cd\");\n#undef tcwd\n\n  /* If canonicalization fails, reset dirname to the_current_working_directory */\n  canon_failed = 0;\n  if (dirname == 0)\n    {\n      canon_failed = 1;\n      dirname = the_current_working_directory;\n    }\n\n  old_anm = array_needs_making;\n  pwdvar = get_string_value (\"PWD\");\n\n  tvar = bind_variable (\"OLDPWD\", pwdvar, 0);\n  if (tvar && readonly_p (tvar))\n    r = EXECUTION_FAILURE;\n\n  if (old_anm == 0 && array_needs_making && exported_p (tvar))\n    {\n      update_export_env_inplace (\"OLDPWD=\", 7, pwdvar);\n      array_needs_making = 0;\n    }\n\n  if (setpwd (dirname) == EXECUTION_FAILURE)\n    r = EXECUTION_FAILURE;\n  if (canon_failed && eflag)\n    r = EXECUTION_FAILURE;\n\n  if (dirname && dirname != the_current_working_directory)\n    free (dirname);\n\n  return (r);\n}\n\n/* Call get_working_directory to reset the value of\n   the_current_working_directory () */\nstatic char *\nresetpwd (caller)\n     char *caller;\n{\n  char *tdir;\n      \n  FREE (the_current_working_directory);\n  the_current_working_directory = (char *)NULL;\n  tdir = get_working_directory (caller);\n  return (tdir);\n}\n\nstatic int\ncdxattr (dir, ndirp)\n     char *dir;\t\t/* don't assume we can always free DIR */\n     char **ndirp;\t/* return new constructed directory name */\n{\n#if defined (O_XATTR)\n  int apfd, fd, r, e;\n  char buf[11+40+40];\t/* construct new `fake' path for pwd */\n\n  apfd = openat (AT_FDCWD, dir, O_RDONLY|O_NONBLOCK);\n  if (apfd < 0)\n    return -1;\n  fd = openat (apfd, \".\", O_XATTR);\n  e = errno;\n  close (apfd);\t\t/* ignore close error for now */\n  errno = e;\n  if (fd < 0)\n    return -1;\n  r = fchdir (fd);\t/* assume fchdir exists everywhere with O_XATTR */\n  if (r < 0)\n    {\n      close (fd);\n      return -1;\n    }\n  /* NFSv4 and ZFS extended attribute directories do not have names which are\n     visible in the standard Unix directory tree structure.  To ensure we have\n     a valid name for $PWD, we synthesize one under /proc, but to keep that\n     path valid, we need to keep the file descriptor open as long as we are in\n     this directory.  This imposes a certain structure on /proc. */\n  if (ndirp)\n    {\n      sprintf (buf, \"/proc/%d/fd/%d\", getpid(), fd);\n      *ndirp = savestring (buf);\n    }\n\n  if (xattrfd >= 0)\n    close (xattrfd);\n  xattrfd = fd;  \n\n  return r;\n#else\n  return -1;\n#endif\n}\n\n/* Clean up the O_XATTR baggage.  Currently only closes xattrfd */\nstatic void\nresetxattr ()\n{\n#if defined (O_XATTR)\n  if (xattrfd >= 0)\n    {\n      close (xattrfd);\n      xattrfd = -1;\n    }\n#else\n  xattrfd = -1;\t\t/* not strictly necessary */\n#endif\n}\n\n#define LCD_DOVARS\t0x001\n#define LCD_DOSPELL\t0x002\n#define LCD_PRINTPATH\t0x004\n#define LCD_FREEDIRNAME\t0x008\n\n/* This builtin is ultimately the way that all user-visible commands should\n   change the current working directory.  It is called by cd_to_string (),\n   so the programming interface is simple, and it handles errors and\n   restrictions properly. */\nint\ncd_builtin (list)\n     WORD_LIST *list;\n{\n  char *dirname, *cdpath, *path, *temp;\n  int path_index, no_symlinks, opt, lflag, e;\n\n#if defined (RESTRICTED_SHELL)\n  if (restricted)\n    {\n      sh_restricted ((char *)NULL);\n      return (EXECUTION_FAILURE);\n    }\n#endif /* RESTRICTED_SHELL */\n\n  eflag = 0;\n  no_symlinks = no_symbolic_links;\n  xattrflag = 0;\n  reset_internal_getopt ();\n#if defined (O_XATTR)\n  while ((opt = internal_getopt (list, \"eLP@\")) != -1)\n#else\n  while ((opt = internal_getopt (list, \"eLP\")) != -1)\n#endif\n    {\n      switch (opt)\n\t{\n\tcase 'P':\n\t  no_symlinks = 1;\n\t  break;\n\tcase 'L':\n\t  no_symlinks = 0;\n\t  break;\n\tcase 'e':\n\t  eflag = 1;\n\t  break;\n#if defined (O_XATTR)\n\tcase '@':\n\t  xattrflag = 1;\n\t  break;\n#endif\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  lflag = (cdable_vars ? LCD_DOVARS : 0) |\n\t  ((interactive && cdspelling) ? LCD_DOSPELL : 0);\n  if (eflag && no_symlinks == 0)\n    eflag = 0;\n\n  if (list == 0)\n    {\n      /* `cd' without arguments is equivalent to `cd $HOME' */\n      dirname = get_string_value (\"HOME\");\n\n      if (dirname == 0)\n\t{\n\t  builtin_error (_(\"HOME not set\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n      lflag = 0;\n    }\n#if defined (CD_COMPLAINS)\n  else if (list->next)\n    {\n      builtin_error (_(\"too many arguments\"));\n      return (EXECUTION_FAILURE);\n    }\n#endif\n#if 0\n  else if (list->word->word[0] == '\\0')\n    {\n      builtin_error (_(\"null directory\"));\n      return (EXECUTION_FAILURE);\n    }\n#endif\n  else if (list->word->word[0] == '-' && list->word->word[1] == '\\0')\n    {\n      /* This is `cd -', equivalent to `cd $OLDPWD' */\n      dirname = get_string_value (\"OLDPWD\");\n\n      if (dirname == 0)\n\t{\n\t  builtin_error (_(\"OLDPWD not set\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n#if 0\n      lflag = interactive ? LCD_PRINTPATH : 0;\n#else\n      lflag = LCD_PRINTPATH;\t\t/* According to SUSv3 */\n#endif\n    }\n  else if (absolute_pathname (list->word->word))\n    dirname = list->word->word;\n  else if (privileged_mode == 0 && (cdpath = get_string_value (\"CDPATH\")))\n    {\n      dirname = list->word->word;\n\n      /* Find directory in $CDPATH. */\n      path_index = 0;\n      while (path = extract_colon_unit (cdpath, &path_index))\n\t{\n\t  /* OPT is 1 if the path element is non-empty */\n\t  opt = path[0] != '\\0';\n\t  temp = sh_makepath (path, dirname, MP_DOTILDE);\n\t  free (path);\n\n\t  if (change_to_directory (temp, no_symlinks, xattrflag))\n\t    {\n\t      /* POSIX.2 says that if a nonempty directory from CDPATH\n\t\t is used to find the directory to change to, the new\n\t\t directory name is echoed to stdout, whether or not\n\t\t the shell is interactive. */\n\t      if (opt && (path = no_symlinks ? temp : the_current_working_directory))\n\t\tprintf (\"%s\\n\", path);\n\n\t      free (temp);\n#if 0\n\t      /* Posix.2 says that after using CDPATH, the resultant\n\t\t value of $PWD will not contain `.' or `..'. */\n\t      return (bindpwd (posixly_correct || no_symlinks));\n#else\n\t      return (bindpwd (no_symlinks));\n#endif\n\t    }\n\t  else\n\t    free (temp);\n\t}\n\n#if 0\n      /* changed for bash-4.2 Posix cd description steps 5-6 */\n      /* POSIX.2 says that if `.' does not appear in $CDPATH, we don't\n\t try the current directory, so we just punt now with an error\n\t message if POSIXLY_CORRECT is non-zero.  The check for cdpath[0]\n\t is so we don't mistakenly treat a CDPATH value of \"\" as not\n\t specifying the current directory. */\n      if (posixly_correct && cdpath[0])\n\t{\n\t  builtin_error (\"%s: %s\", dirname, strerror (ENOENT));\n\t  return (EXECUTION_FAILURE);\n\t}\n#endif\n    }\n  else\n    dirname = list->word->word;\n\n  /* When we get here, DIRNAME is the directory to change to.  If we\n     chdir successfully, just return. */\n  if (change_to_directory (dirname, no_symlinks, xattrflag))\n    {\n      if (lflag & LCD_PRINTPATH)\n\tprintf (\"%s\\n\", dirname);\n      return (bindpwd (no_symlinks));\n    }\n\n  /* If the user requests it, then perhaps this is the name of\n     a shell variable, whose value contains the directory to\n     change to. */\n  if (lflag & LCD_DOVARS)\n    {\n      temp = get_string_value (dirname);\n      if (temp && change_to_directory (temp, no_symlinks, xattrflag))\n\t{\n\t  printf (\"%s\\n\", temp);\n\t  return (bindpwd (no_symlinks));\n\t}\n    }\n\n  /* If the user requests it, try to find a directory name similar in\n     spelling to the one requested, in case the user made a simple\n     typo.  This is similar to the UNIX 8th and 9th Edition shells. */\n  if (lflag & LCD_DOSPELL)\n    {\n      temp = dirspell (dirname);\n      if (temp && change_to_directory (temp, no_symlinks, xattrflag))\n\t{\n\t  printf (\"%s\\n\", temp);\n\t  free (temp);\n\t  return (bindpwd (no_symlinks));\n\t}\n      else\n\tFREE (temp);\n    }\n\n  e = errno;\n  temp = printable_filename (dirname, 0);\n  builtin_error (\"%s: %s\", temp, strerror (e));\n  if (temp != dirname)\n    free (temp);\n  return (EXECUTION_FAILURE);\n}\n\n$BUILTIN pwd\n$FUNCTION pwd_builtin\n$SHORT_DOC pwd [-LP]\nPrint the name of the current working directory.\n\nOptions:\n  -L\tprint the value of $PWD if it names the current working\n\t\tdirectory\n  -P\tprint the physical directory, without any symbolic links\n\nBy default, `pwd' behaves as if `-L' were specified.\n\nExit Status:\nReturns 0 unless an invalid option is given or the current directory\ncannot be read.\n$END\n\n/* Non-zero means that pwd always prints the physical directory, without\n   symbolic links. */\nstatic int verbatim_pwd;\n\n/* Print the name of the current working directory. */\nint\npwd_builtin (list)\n     WORD_LIST *list;\n{\n  char *directory;\n  int opt, pflag;\n\n  verbatim_pwd = no_symbolic_links;\n  pflag = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"LP\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'P':\n\t  verbatim_pwd = pflag = 1;\n\t  break;\n\tcase 'L':\n\t  verbatim_pwd = 0;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n#define tcwd the_current_working_directory\n\n  directory = tcwd ? (verbatim_pwd ? sh_physpath (tcwd, 0) : tcwd)\n\t\t   : get_working_directory (\"pwd\");\n\n  /* Try again using getcwd() if canonicalization fails (for instance, if\n     the file system has changed state underneath bash). */\n  if ((tcwd && directory == 0) ||\n      (posixly_correct && same_file (\".\", tcwd, (struct stat *)0, (struct stat *)0) == 0))\n    {\n      if (directory && directory != tcwd)\n        free (directory);\n      directory = resetpwd (\"pwd\");\n    }\n\n#undef tcwd\n\n  if (directory)\n    {\n      opt = EXECUTION_SUCCESS;\n      printf (\"%s\\n\", directory);\n      /* This is dumb but posix-mandated. */\n      if (posixly_correct && pflag)\n\topt = setpwd (directory);\n      if (directory != the_current_working_directory)\n\tfree (directory);\n      return (sh_chkwrite (opt));\n    }\n  else\n    return (EXECUTION_FAILURE);\n}\n\n/* Do the work of changing to the directory NEWDIR.  Handle symbolic\n   link following, etc.  This function *must* return with\n   the_current_working_directory either set to NULL (in which case\n   getcwd() will eventually be called), or set to a string corresponding\n   to the working directory.  Return 1 on success, 0 on failure. */\n\nstatic int\nchange_to_directory (newdir, nolinks, xattr)\n     char *newdir;\n     int nolinks, xattr;\n{\n  char *t, *tdir, *ndir;\n  int err, canon_failed, r, ndlen;\n\n  tdir = (char *)NULL;\n\n  if (the_current_working_directory == 0)\n    {\n      t = get_working_directory (\"chdir\");\n      FREE (t);\n    }\n\n  t = make_absolute (newdir, the_current_working_directory);\n\n  /* TDIR is either the canonicalized absolute pathname of NEWDIR\n     (nolinks == 0) or the absolute physical pathname of NEWDIR\n     (nolinks != 0). */\n  tdir = nolinks ? sh_physpath (t, 0)\n\t\t : sh_canonpath (t, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\n  ndlen = strlen (newdir);\n\n  /* Use the canonicalized version of NEWDIR, or, if canonicalization\n     failed, use the non-canonical form. */\n  canon_failed = 0;\n  if (tdir && *tdir)\n    free (t);\n  else\n    {\n      FREE (tdir);\n      tdir = t;\n      canon_failed = 1;\n    }\n\n  /* In POSIX mode, if we're resolving symlinks logically and sh_canonpath\n     returns NULL (because it checks the path, it will return NULL if the\n     resolved path doesn't exist), fail immediately. */\n#if defined (ENAMETOOLONG)\n  if (posixly_correct && nolinks == 0 && canon_failed && (errno != ENAMETOOLONG || ndlen > PATH_MAX))\n#else\n  if (posixly_correct && nolinks == 0 && canon_failed && ndlen > PATH_MAX)\n#endif\n    {\n#if defined ENAMETOOLONG\n      if (errno != ENOENT && errno != ENAMETOOLONG)\n#else\n      if (errno != ENOENT)\n#endif\n\terrno = ENOTDIR;\n      free (tdir);\n      return (0);\n    }\n\n#if defined (O_XATTR)\n  if (xattrflag)\n    {\n      r = cdxattr (nolinks ? newdir : tdir, &ndir);\n      if (r >= 0)\n\t{\n\t  canon_failed = 0;\n\t  free (tdir);\n\t  tdir = ndir;\n\t}\n      else\n\t{\n\t  err = errno;\n\t  free (tdir);\n\t  errno = err;\n\t  return (0);\t\t/* no xattr */\n\t}\n    }\n  else\n#endif\n    {\n      r = chdir (nolinks ? newdir : tdir);\n      if (r >= 0)\n\tresetxattr ();\n    }\n\n  /* If the chdir succeeds, update the_current_working_directory. */\n  if (r == 0)\n    {\n      /* If canonicalization failed, but the chdir succeeded, reset the\n\t shell's idea of the_current_working_directory. */\n      if (canon_failed)\n\t{\n\t  t = resetpwd (\"cd\");\n\t  if (t == 0)\n\t    set_working_directory (tdir);\n\t  else\n\t    free (t);\n\t}\n      else\n\tset_working_directory (tdir);\n\n      free (tdir);\n      return (1);\n    }\n\n  /* We failed to change to the appropriate directory name.  If we tried\n     what the user passed (nolinks != 0), punt now. */\n  if (nolinks)\n    {\n      free (tdir);\n      return (0);\n    }\n\n  err = errno;\n\n  /* We're not in physical mode (nolinks == 0), but we failed to change to\n     the canonicalized directory name (TDIR).  Try what the user passed\n     verbatim. If we succeed, reinitialize the_current_working_directory.\n     POSIX requires that we just fail here, so we do in posix mode. */\n  if (posixly_correct == 0 && chdir (newdir) == 0)\n    {\n      t = resetpwd (\"cd\");\n      if (t == 0)\n\tset_working_directory (tdir);\n      else\n\tfree (t);\n\n      r = 1;\n    }\n  else\n    {\n      errno = err;\n      r = 0;\n    }\n\n  free (tdir);\n  return r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}