{
  "module_name": "exit.def",
  "hash_id": "1e36d61612e576aa3954e94214b735f1fa15a58813a99e6cc380a60108640130",
  "original_prompt": "Ingested from bash-5.2.21/builtins/exit.def",
  "human_readable_source": "This file is exit.def, from which is created exit.c.\nIt implements the builtins \"exit\", and \"logout\" in Bash.\n\nCopyright (C) 1987-2021 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES exit.c\n\n$BUILTIN exit\n$FUNCTION exit_builtin\n$SHORT_DOC exit [n]\nExit the shell.\n\nExits the shell with a status of N.  If N is omitted, the exit status\nis that of the last command executed.\n$END\n\n#include <config.h>\n\n#include \"../bashtypes.h\"\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../jobs.h\"\n#include \"../trap.h\"\n\n#include \"common.h\"\n#include \"builtext.h\"\t/* for jobs_builtin */\n\nextern int check_jobs_at_exit;\n\nstatic int exit_or_logout PARAMS((WORD_LIST *));\nstatic int sourced_logout;\n\nint\nexit_builtin (list)\n     WORD_LIST *list;\n{\n  CHECK_HELPOPT (list);\n\n  if (interactive)\n    {\n      fprintf (stderr, login_shell ? _(\"logout\\n\") : \"exit\\n\");\n      fflush (stderr);\n    }\n\n  return (exit_or_logout (list));\n}\n\n$BUILTIN logout\n$FUNCTION logout_builtin\n$SHORT_DOC logout [n]\nExit a login shell.\n\nExits a login shell with exit status N.  Returns an error if not executed\nin a login shell.\n$END\n\n/* How to logout. */\nint\nlogout_builtin (list)\n     WORD_LIST *list;\n{\n  CHECK_HELPOPT (list);\n\n  if (login_shell == 0 /* && interactive */)\n    {\n      builtin_error (_(\"not login shell: use `exit'\"));\n      return (EXECUTION_FAILURE);\n    }\n  else\n    return (exit_or_logout (list));\n}\n\nstatic int\nexit_or_logout (list)\n     WORD_LIST *list;\n{\n  int exit_value;\n\n#if defined (JOB_CONTROL)\n  int exit_immediate_okay, stopmsg;\n\n  exit_immediate_okay = (interactive  == 0 ||\n\t\t\t last_shell_builtin == exit_builtin ||\n\t\t\t last_shell_builtin == logout_builtin ||\n\t\t\t last_shell_builtin == jobs_builtin);\n\n  /* Check for stopped jobs if the user wants to. */\n  if (exit_immediate_okay == 0)\n    {\n      register int i;\n      for (i = stopmsg = 0; i < js.j_jobslots; i++)\n\tif (jobs[i] && STOPPED (i))\n\t  stopmsg = JSTOPPED;\n\telse if (check_jobs_at_exit && stopmsg == 0 && jobs[i] && RUNNING (i))\n\t  stopmsg = JRUNNING;\n\n      if (stopmsg == JSTOPPED)\n\tfprintf (stderr, _(\"There are stopped jobs.\\n\"));\n      else if (stopmsg == JRUNNING)\n\tfprintf (stderr, _(\"There are running jobs.\\n\"));\n\n      if (stopmsg && check_jobs_at_exit)\n        list_all_jobs (JLIST_STANDARD);\n\n      if (stopmsg)\n\t{\n\t  /* This is NOT superfluous because EOF can get here without\n\t     going through the command parser.  Set both last and this\n\t     so that either `exit', `logout', or ^D will work to exit\n\t     immediately if nothing intervenes. */\n\t  this_shell_builtin = last_shell_builtin = exit_builtin;\n\t  return (EXECUTION_FAILURE);\n\t}\n    }\n#endif /* JOB_CONTROL */\n\n  /* Get return value if present.  This means that you can type\n     `logout 5' to a shell, and it returns 5. */\n\n  /* If we're running the exit trap (running_trap == 1, since running_trap\n     gets set to SIG+1), and we don't have a argument given to `exit'\n     (list == 0), use the exit status we saved before running the trap\n     commands (trap_saved_exit_value). */\n  exit_value = (running_trap == 1 && list == 0) ? trap_saved_exit_value : get_exitstat (list);\n\n  bash_logout ();\n\n  last_command_exit_value = exit_value;\n\n  /* Exit the program. */\n  jump_to_top_level (EXITBLTIN);\n  /*NOTREACHED*/\n}\n\nvoid\nbash_logout ()\n{\n  /* Run our `~/.bash_logout' file if it exists, and this is a login shell. */\n  if (login_shell && sourced_logout++ == 0 && subshell_environment == 0)\n    {\n      maybe_execute_file (\"~/.bash_logout\", 1);\n#ifdef SYS_BASH_LOGOUT\n      maybe_execute_file (SYS_BASH_LOGOUT, 1);\n#endif\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}