{
  "module_name": "command.def",
  "hash_id": "296d9efe9dc39e84833291e6c61909ffc19c5bafb45023bf6bc487bf03713d1c",
  "original_prompt": "Ingested from bash-5.2.21/builtins/command.def",
  "human_readable_source": "This file is command.def, from which is created command.c.\nIt implements the builtin \"command\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES command.c\n\n$BUILTIN command\n$FUNCTION command_builtin\n$SHORT_DOC command [-pVv] command [arg ...]\nExecute a simple command or display information about commands.\n\nRuns COMMAND with ARGS suppressing  shell function lookup, or display\ninformation about the specified COMMANDs.  Can be used to invoke commands\non disk when a function with the same name exists.\n\nOptions:\n  -p    use a default value for PATH that is guaranteed to find all of\n        the standard utilities\n  -v    print a description of COMMAND similar to the `type' builtin\n  -V    print a more verbose description of each COMMAND\n\nExit Status:\nReturns exit status of COMMAND, or failure if COMMAND is not found.\n$END\n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"../flags.h\"\n#include \"bashgetopt.h\"\n#include \"common.h\"\n\n#if defined (_CS_PATH) && defined (HAVE_CONFSTR) && !HAVE_DECL_CONFSTR\nextern size_t confstr PARAMS((int, char *, size_t));\n#endif\n\n/* Run the commands mentioned in LIST without paying attention to shell\n   functions. */\nint\ncommand_builtin (list)\n     WORD_LIST *list;\n{\n  int result, verbose, use_standard_path, opt;\n  COMMAND *command;\n\n  verbose = use_standard_path = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"pvV\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'p':\n\t  use_standard_path = CDESC_STDPATH;\n\t  break;\n\tcase 'V':\n\t  verbose = CDESC_SHORTDESC|CDESC_ABSPATH;\t/* look in common.h for constants */\n\t  break;\n\tcase 'v':\n\t  verbose = CDESC_REUSABLE;\t/* ditto */\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n  list = loptend;\n\n  if (list == 0)\n    return (EXECUTION_SUCCESS);\n\n#if defined (RESTRICTED_SHELL)\n  if (use_standard_path && restricted)\n    {\n      sh_restricted (\"-p\");\n      return (EXECUTION_FAILURE);\n    }\n#endif\n\n  if (verbose)\n    {\n      int found, any_found;\n\n      for (any_found = 0; list; list = list->next)\n\t{\n\t  found = describe_command (list->word->word, verbose|use_standard_path);\n\n\t  if (found == 0 && verbose != CDESC_REUSABLE)\n\t    sh_notfound (list->word->word);\n\n\t  any_found += found;\n\t}\n\n      return (any_found ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n    }\n\n  begin_unwind_frame (\"command_builtin\");\n\n#define COMMAND_BUILTIN_FLAGS (CMD_NO_FUNCTIONS | CMD_INHIBIT_EXPANSION | CMD_COMMAND_BUILTIN | (use_standard_path ? CMD_STDPATH : 0))\n\n  INTERNAL_DEBUG ((\"command_builtin: running execute_command for `%s'\", list->word->word));\n\n  /* We don't want this to be reparsed (consider command echo 'foo &'), so\n     just make a simple_command structure and call execute_command with it. */\n  command = make_bare_simple_command ();\n  command->value.Simple->words = (WORD_LIST *)copy_word_list (list);\n  command->value.Simple->redirects = (REDIRECT *)NULL;\n  command->flags |= COMMAND_BUILTIN_FLAGS;\n  command->value.Simple->flags |= COMMAND_BUILTIN_FLAGS;\n\n  add_unwind_protect ((char *)dispose_command, command);\n  result = execute_command (command);\n\n  run_unwind_frame (\"command_builtin\");\n\n  return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}