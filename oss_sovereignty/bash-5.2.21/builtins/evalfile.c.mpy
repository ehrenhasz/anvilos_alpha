{
  "module_name": "evalfile.c",
  "hash_id": "614da0aef54c264eacb090d05252f9a1f9fbd2f732d466795c0d8fa8fcd467aa",
  "original_prompt": "Ingested from bash-5.2.21/builtins/evalfile.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"../bashtypes.h\"\n#include \"posixstat.h\"\n#include \"filecntl.h\"\n\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../parser.h\"\n#include \"../jobs.h\"\n#include \"../builtins.h\"\n#include \"../flags.h\"\n#include \"../input.h\"\n#include \"../execute_cmd.h\"\n#include \"../trap.h\"\n\n#include <y.tab.h>\n\n#if defined (HISTORY)\n#  include \"../bashhist.h\"\n#endif\n\n#include <typemax.h>\n\n#include \"common.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n \n#define FEVAL_ENOENTOK\t\t0x001\n#define FEVAL_BUILTIN\t\t0x002\n#define FEVAL_UNWINDPROT\t0x004\n#define FEVAL_NONINT\t\t0x008\n#define FEVAL_LONGJMP\t\t0x010\n#define FEVAL_HISTORY\t\t0x020\n#define FEVAL_CHECKBINARY\t0x040\n#define FEVAL_REGFILE\t\t0x080\n#define FEVAL_NOPUSHARGS\t0x100\n\n \nint sourcelevel = 0;\n\nstatic int\n_evalfile (filename, flags)\n     const char *filename;\n     int flags;\n{\n  volatile int old_interactive;\n  procenv_t old_return_catch;\n  int return_val, fd, result, pflags, i, nnull;\n  ssize_t nr;\t\t\t \n  char *string;\n  struct stat finfo;\n  size_t file_size;\n  sh_vmsg_func_t *errfunc;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *funcname_v, *bash_source_v, *bash_lineno_v;\n  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;\n  struct func_array_state *fa;\n#  if defined (DEBUGGER)\n  SHELL_VAR *bash_argv_v, *bash_argc_v;\n  ARRAY *bash_argv_a, *bash_argc_a;\n#  endif\n  char *t, tt[2];\n#endif\n\n  USE_VAR(pflags);\n\n#if defined (ARRAY_VARS)\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", funcname_v, funcname_a);\n  GET_ARRAY_FROM_VAR (\"BASH_SOURCE\", bash_source_v, bash_source_a);\n  GET_ARRAY_FROM_VAR (\"BASH_LINENO\", bash_lineno_v, bash_lineno_a);\n#  if defined (DEBUGGER)\n  GET_ARRAY_FROM_VAR (\"BASH_ARGV\", bash_argv_v, bash_argv_a);\n  GET_ARRAY_FROM_VAR (\"BASH_ARGC\", bash_argc_v, bash_argc_a);\n#  endif\n#endif\n\n  fd = open (filename, O_RDONLY);\n\n  if (fd < 0 || (fstat (fd, &finfo) == -1))\n    {\n      i = errno;\n      if (fd >= 0)\n\tclose (fd);\n      errno = i;\n\nfile_error_and_exit:\n      if (((flags & FEVAL_ENOENTOK) == 0) || errno != ENOENT)\n\tfile_error (filename);\n\n      if (flags & FEVAL_LONGJMP)\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  jump_to_top_level (EXITPROG);\n\t}\n\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE\n      \t\t\t\t      : ((errno == ENOENT && (flags & FEVAL_ENOENTOK) != 0) ? 0 : -1));\n    }\n\n  errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);\n\n  if (S_ISDIR (finfo.st_mode))\n    {\n      (*errfunc) (_(\"%s: is a directory\"), filename);\n      close (fd);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);\n    }\n  else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)\n    {\n      (*errfunc) (_(\"%s: not a regular file\"), filename);\n      close (fd);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);\n    }\n\n  file_size = (size_t)finfo.st_size;\n   \n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      (*errfunc) (_(\"%s: file is too large\"), filename);\n      close (fd);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);\n    }      \n\n  if (S_ISREG (finfo.st_mode) && file_size <= SSIZE_MAX)\n    {\n      string = (char *)xmalloc (1 + file_size);\n      nr = read (fd, string, file_size);\n      if (nr >= 0)\n\tstring[nr] = '\\0';\n    }\n  else\n    nr = zmapfd (fd, &string, 0);\n\n  return_val = errno;\n  close (fd);\n  errno = return_val;\n\n  if (nr < 0)\t\t \n    {\n      free (string);\n      goto file_error_and_exit;\n    }\n\n  if (nr == 0)\n    {\n      free (string);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_SUCCESS : 1);\n    }\n      \n  if ((flags & FEVAL_CHECKBINARY) && \n      check_binary_file (string, (nr > 80) ? 80 : nr))\n    {\n      free (string);\n      (*errfunc) (_(\"%s: cannot execute binary file\"), filename);\n      return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);\n    }\n\n  i = strlen (string);\n  if (i < nr)\n    {\n      for (nnull = i = 0; i < nr; i++)\n\tif (string[i] == '\\0')\n          {\n\t    memmove (string+i, string+i+1, nr - i);\n\t    nr--;\n\t     \n\t    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)\n\t      {\n\t\tfree (string);\n\t\t(*errfunc) (_(\"%s: cannot execute binary file\"), filename);\n\t\treturn ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);\n\t      }\n          }\n    }\n\n  if (flags & FEVAL_UNWINDPROT)\n    {\n      begin_unwind_frame (\"_evalfile\");\n\n      unwind_protect_int (return_catch_flag);\n      unwind_protect_jmp_buf (return_catch);\n      if (flags & FEVAL_NONINT)\n\tunwind_protect_int (interactive);\n      unwind_protect_int (sourcelevel);\n    }\n  else\n    {\n      COPY_PROCENV (return_catch, old_return_catch);\n      if (flags & FEVAL_NONINT)\n\told_interactive = interactive;\n    }\n\n  if (flags & FEVAL_NONINT)\n    interactive = 0;\n\n  return_catch_flag++;\n  sourcelevel++;\n\n#if defined (ARRAY_VARS)\n  array_push (bash_source_a, (char *)filename);\n  t = itos (executing_line_number ());\n  array_push (bash_lineno_a, t);\n  free (t);\n  array_push (funcname_a, \"source\");\t \n\n  fa = (struct func_array_state *)xmalloc (sizeof (struct func_array_state));\n  fa->source_a = bash_source_a;\n  fa->source_v = bash_source_v;\n  fa->lineno_a = bash_lineno_a;\n  fa->lineno_v = bash_lineno_v;\n  fa->funcname_a = funcname_a;\n  fa->funcname_v = funcname_v;\n  if (flags & FEVAL_UNWINDPROT)\n    add_unwind_protect (restore_funcarray_state, fa);\n\n#  if defined (DEBUGGER)\n   \n  if ((flags & FEVAL_NOPUSHARGS) == 0)\n    {\n      if (shell_compatibility_level <= 44)\n\tinit_bash_argv ();\n      array_push (bash_argv_a, (char *)filename);\t \n      tt[0] = '1'; tt[1] = '\\0';\n      array_push (bash_argc_a, tt);\n      if (flags & FEVAL_UNWINDPROT)\n\tadd_unwind_protect (pop_args, 0);\n    }\n#  endif\n#endif\n\n   \n  pflags = SEVAL_RESETLINE|SEVAL_NOOPTIMIZE;\n  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;\n\n  if (flags & FEVAL_BUILTIN)\n    result = EXECUTION_SUCCESS;\n\n  return_val = setjmp_nosigs (return_catch);\n\n   \n  if (return_val)\n    {\n      parse_and_execute_cleanup (-1);\n      result = return_catch_value;\n    }\n  else\n    result = parse_and_execute (string, filename, pflags);\n\n  if (flags & FEVAL_UNWINDPROT)\n    run_unwind_frame (\"_evalfile\");\n  else\n    {\n      if (flags & FEVAL_NONINT)\n\tinteractive = old_interactive;\n#if defined (ARRAY_VARS)\n      restore_funcarray_state (fa);\n#  if defined (DEBUGGER)\n      if ((flags & FEVAL_NOPUSHARGS) == 0)\n\t{\n\t   \n\t  array_pop (bash_argc_a);\n\t  array_pop (bash_argv_a);\n\t}\n#  endif\n#endif\n      return_catch_flag--;\n      sourcelevel--;\n      COPY_PROCENV (old_return_catch, return_catch);\n    }\n\n   \n  if (current_token == yacc_EOF)\n    push_token ('\\n');\t\t \n\n  return ((flags & FEVAL_BUILTIN) ? result : 1);\n}\n\nint\nmaybe_execute_file (fname, force_noninteractive)\n     const char *fname;\n     int force_noninteractive;\n{\n  char *filename;\n  int result, flags;\n\n  filename = bash_tilde_expand (fname, 0);\n  flags = FEVAL_ENOENTOK;\n  if (force_noninteractive)\n    flags |= FEVAL_NONINT;\n  result = _evalfile (filename, flags);\n  free (filename);\n  return result;\n}\n\nint\nforce_execute_file (fname, force_noninteractive)\n     const char *fname;\n     int force_noninteractive;\n{\n  char *filename;\n  int result, flags;\n\n  filename = bash_tilde_expand (fname, 0);\n  flags = 0;\n  if (force_noninteractive)\n    flags |= FEVAL_NONINT;\n  result = _evalfile (filename, flags);\n  free (filename);\n  return result;\n}\n\n#if defined (HISTORY)\nint\nfc_execute_file (filename)\n     const char *filename;\n{\n  int flags;\n\n   \n  flags = FEVAL_ENOENTOK|FEVAL_HISTORY|FEVAL_REGFILE|FEVAL_BUILTIN;\n  return (_evalfile (filename, flags));\n}\n#endif  \n\nint\nsource_file (filename, sflags)\n     const char *filename;\n     int sflags;\n{\n  int flags, rval;\n\n  flags = FEVAL_BUILTIN|FEVAL_UNWINDPROT|FEVAL_NONINT;\n  if (sflags)\n    flags |= FEVAL_NOPUSHARGS;\n   \n  if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)\n    flags |= FEVAL_LONGJMP;\n  rval = _evalfile (filename, flags);\n\n  run_return_trap ();\n  return rval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}