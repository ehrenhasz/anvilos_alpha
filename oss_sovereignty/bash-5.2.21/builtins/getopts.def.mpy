{
  "module_name": "getopts.def",
  "hash_id": "ec25212f63f3e7b4aaa84f5e7cb7283102e166c0f5638aad8d697fbd976dc8a8",
  "original_prompt": "Ingested from bash-5.2.21/builtins/getopts.def",
  "human_readable_source": "This file is getopts.def, from which is created getopts.c.\nIt implements the builtin \"getopts\" in Bash.\n\nCopyright (C) 1987-2019 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES getopts.c\n\n$BUILTIN getopts\n$FUNCTION getopts_builtin\n$SHORT_DOC getopts optstring name [arg ...]\nParse option arguments.\n\nGetopts is used by shell procedures to parse positional parameters\nas options.\n\nOPTSTRING contains the option letters to be recognized; if a letter\nis followed by a colon, the option is expected to have an argument,\nwhich should be separated from it by white space.\n\nEach time it is invoked, getopts will place the next option in the\nshell variable $name, initializing name if it does not exist, and\nthe index of the next argument to be processed into the shell\nvariable OPTIND.  OPTIND is initialized to 1 each time the shell or\na shell script is invoked.  When an option requires an argument,\ngetopts places that argument into the shell variable OPTARG.\n\ngetopts reports errors in one of two ways.  If the first character\nof OPTSTRING is a colon, getopts uses silent error reporting.  In\nthis mode, no error messages are printed.  If an invalid option is\nseen, getopts places the option character found into OPTARG.  If a\nrequired argument is not found, getopts places a ':' into NAME and\nsets OPTARG to the option character found.  If getopts is not in\nsilent mode, and an invalid option is seen, getopts places '?' into\nNAME and unsets OPTARG.  If a required argument is not found, a '?'\nis placed in NAME, OPTARG is unset, and a diagnostic message is\nprinted.\n\nIf the shell variable OPTERR has the value 0, getopts disables the\nprinting of error messages, even if the first character of\nOPTSTRING is not a colon.  OPTERR has the value 1 by default.\n\nGetopts normally parses the positional parameters, but if arguments\nare supplied as ARG values, they are parsed instead.\n\nExit Status:\nReturns success if an option is found; fails if the end of options is\nencountered or an error occurs.\n$END\n\n#include <config.h>\n\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashansi.h\"\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n#include \"getopt.h\"\n\n#define G_EOF\t\t-1\n#define G_INVALID_OPT\t-2\n#define G_ARG_MISSING\t-3\n\nstatic int getopts_unbind_variable PARAMS((char *));\nstatic int getopts_bind_variable PARAMS((char *, char *));\nstatic int dogetopts PARAMS((int, char **));\n\n/* getopts_reset is magic code for when OPTIND is reset.  N is the\n   value that has just been assigned to OPTIND. */\nvoid\ngetopts_reset (newind)\n     int newind;\n{\n  sh_optind = newind;\n  sh_badopt = 0;\n}\n\nstatic int\ngetopts_unbind_variable (name)\n     char *name;\n{\n#if 0\n  return (unbind_variable (name));\n#else\n  return (unbind_variable_noref (name));\n#endif\n}\n\nstatic int\ngetopts_bind_variable (name, value)\n     char *name, *value;\n{\n  SHELL_VAR *v;\n\n  if (legal_identifier (name))\n    {\n      v = bind_variable (name, value, 0);\n      if (v && (readonly_p (v) || noassign_p (v)))\n\treturn (EX_MISCERROR);\n      return (v ? EXECUTION_SUCCESS : EXECUTION_FAILURE);\n    }\n  else\n    {\n      sh_invalidid (name);\n      return (EXECUTION_FAILURE);\n    }\n}\n\n/* Error handling is now performed as specified by Posix.2, draft 11\n   (identical to that of ksh-88).  The special handling is enabled if\n   the first character of the option string is a colon; this handling\n   disables diagnostic messages concerning missing option arguments\n   and invalid option characters.  The handling is as follows.\n\n   INVALID OPTIONS:\n        name -> \"?\"\n        if (special_error) then\n                OPTARG = option character found\n                no error output\n        else\n                OPTARG unset\n                diagnostic message\n        fi\n \n  MISSING OPTION ARGUMENT;\n        if (special_error) then\n                name -> \":\"\n                OPTARG = option character found\n        else\n                name -> \"?\"\n                OPTARG unset\n                diagnostic message\n        fi\n */\n\nstatic int\ndogetopts (argc, argv)\n     int argc;\n     char **argv;\n{\n  int ret, special_error, old_opterr, i, n;\n  char strval[2], numval[16];\n  char *optstr;\t\t\t/* list of options */\n  char *name;\t\t\t/* variable to get flag val */\n  char *t;\n\n  if (argc < 3)\n    {\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n\n  /* argv[0] is \"getopts\". */\n\n  optstr = argv[1];\n  name = argv[2];\n  argc -= 2;\n  argv += 2;\n\n  special_error = optstr[0] == ':';\n\n  if (special_error)\n    {\n      old_opterr = sh_opterr;\n      optstr++;\n      sh_opterr = 0;\t\t/* suppress diagnostic messages */\n    }\n\n  if (argc > 1)\n    {\n      sh_getopt_restore_state (argv);\n      t = argv[0];\n      argv[0] = dollar_vars[0];\n      ret = sh_getopt (argc, argv, optstr);\n      argv[0] = t;\n    }\n  else if (rest_of_args == (WORD_LIST *)NULL)\n    {\n      for (i = 0; i < 10 && dollar_vars[i]; i++)\n\t;\n\n      sh_getopt_restore_state (dollar_vars);\n      ret = sh_getopt (i, dollar_vars, optstr);\n    }\n  else\n    {\n      register WORD_LIST *words;\n      char **v;\n\n      i = number_of_args () + 1;\t/* +1 for $0 */\n      v = strvec_create (i + 1);\n      for (i = 0; i < 10 && dollar_vars[i]; i++)\n\tv[i] = dollar_vars[i];\n      for (words = rest_of_args; words; words = words->next, i++)\n\tv[i] = words->word->word;\n      v[i] = (char *)NULL;\n      sh_getopt_restore_state (v);\n      ret = sh_getopt (i, v, optstr);\n      free (v);\n    }\n\n  if (special_error)\n    sh_opterr = old_opterr;\n\n  /* Set the OPTIND variable in any case, to handle \"--\" skipping.  It's\n     highly unlikely that 14 digits will be too few. */\n  if (sh_optind < 10)\n    {\n      numval[14] = sh_optind + '0';\n      numval[15] = '\\0';\n      i = 14;\n    }\n  else\n    {\n      numval[i = 15] = '\\0';\n      n = sh_optind;\n      do\n\t{\n\t  numval[--i] = (n % 10) + '0';\n\t}\n      while (n /= 10);\n    }\n  bind_variable (\"OPTIND\", numval + i, 0);\n\n  /* If an error occurred, decide which one it is and set the return\n     code appropriately.  In all cases, the option character in error\n     is in OPTOPT.  If an invalid option was encountered, OPTARG is\n     NULL.  If a required option argument was missing, OPTARG points\n     to a NULL string (that is, sh_optarg[0] == 0). */\n  if (ret == '?')\n    {\n      if (sh_optarg == NULL)\n\tret = G_INVALID_OPT;\n      else if (sh_optarg[0] == '\\0')\n\tret = G_ARG_MISSING;\n    }\n\t    \n  if (ret == G_EOF)\n    {\n      getopts_unbind_variable (\"OPTARG\");\n      getopts_bind_variable (name, \"?\");\n      return (EXECUTION_FAILURE);\n    }\n\n  if (ret == G_INVALID_OPT)\n    {\n      /* Invalid option encountered. */\n      ret = getopts_bind_variable (name, \"?\");\n\n      if (special_error)\n\t{\n\t  strval[0] = (char)sh_optopt;\n\t  strval[1] = '\\0';\n\t  bind_variable (\"OPTARG\", strval, 0);\n\t}\n      else\n\tgetopts_unbind_variable (\"OPTARG\");\n\n      return (ret);\n    }\n\n  if (ret == G_ARG_MISSING)\n    {\n      /* Required argument missing. */\n      if (special_error)\n\t{\n\t  ret = getopts_bind_variable (name, \":\");\n\n\t  strval[0] = (char)sh_optopt;\n\t  strval[1] = '\\0';\n\t  bind_variable (\"OPTARG\", strval, 0);\n\t}\n      else\n\t{\n\t  ret = getopts_bind_variable (name, \"?\");\n\t  getopts_unbind_variable (\"OPTARG\");\n\t}\n      return (ret);\n    }\t\t\t\n\n  bind_variable (\"OPTARG\", sh_optarg, 0);\n\n  strval[0] = (char) ret;\n  strval[1] = '\\0';\n  return (getopts_bind_variable (name, strval));\n}\n\n/* The getopts builtin.  Build an argv, and call dogetopts with it. */\nint\ngetopts_builtin (list)\n     WORD_LIST *list;\n{\n  char **av;\n  int ac, ret;\n\n  if (list == 0)\n    {\n      builtin_usage ();\n      return EX_USAGE;\n    }\n\n  reset_internal_getopt ();\n  if ((ret = internal_getopt (list, \"\")) != -1)\n    {\n      if (ret == GETOPT_HELP)\n\tbuiltin_help ();\n      else\n\tbuiltin_usage ();\n      return (EX_USAGE);\n    }\n  list = loptend;\n\n  av = make_builtin_argv (list, &ac);\n  ret = dogetopts (ac, av);\n  free ((char *)av);\n\n  return (ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}