{
  "module_name": "alias.def",
  "hash_id": "b45ae7c8b22228142aefb0c5f4f048deade6b876ba5eb73befedacb3202b7962",
  "original_prompt": "Ingested from bash-5.2.21/builtins/alias.def",
  "human_readable_source": "This file is alias.def, from which is created alias.c\nIt implements the builtins \"alias\" and \"unalias\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$BUILTIN alias\n$FUNCTION alias_builtin\n$DEPENDS_ON ALIAS\n$PRODUCES alias.c\n$SHORT_DOC alias [-p] [name[=value] ... ]\nDefine or display aliases.\n\nWithout arguments, `alias' prints the list of aliases in the reusable\nform `alias NAME=VALUE' on standard output.\n\nOtherwise, an alias is defined for each NAME whose VALUE is given.\nA trailing space in VALUE causes the next word to be checked for\nalias substitution when the alias is expanded.\n\nOptions:\n  -p\tprint all defined aliases in a reusable format\n\nExit Status:\nalias returns true unless a NAME is supplied for which no alias has been\ndefined.\n$END\n\n#include <config.h>\n\n#if defined (ALIAS)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#  include \"../bashansi.h\"\n#  include \"../bashintl.h\"\n\n#  include <stdio.h>\n#  include \"../shell.h\"\n#  include \"../alias.h\"\n#  include \"common.h\"\n#  include \"bashgetopt.h\"\n\n/* Flags for print_alias */\n#define AL_REUSABLE\t0x01\n\nstatic void print_alias PARAMS((alias_t *, int));\n\n/* Hack the alias command in a Korn shell way. */\nint\nalias_builtin (list)\n     WORD_LIST *list;\n{\n  int any_failed, offset, pflag, dflags;\n  alias_t **alias_list, *t;\n  char *name, *value;\n\n  dflags = posixly_correct ? 0 : AL_REUSABLE;\n  pflag = 0;\n  reset_internal_getopt ();\n  while ((offset = internal_getopt (list, \"p\")) != -1)\n    {\n      switch (offset)\n\t{\n\tcase 'p':\n\t  pflag = 1;\n\t  dflags |= AL_REUSABLE;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  if (list == 0 || pflag)\n    {\n      if (aliases == 0)\n\treturn (EXECUTION_SUCCESS);\n\n      alias_list = all_aliases ();\n\n      if (alias_list == 0)\n\treturn (EXECUTION_SUCCESS);\n\n      for (offset = 0; alias_list[offset]; offset++)\n\tprint_alias (alias_list[offset], dflags);\n\n      free (alias_list);\t/* XXX - Do not free the strings. */\n\n      if (list == 0)\n\treturn (sh_chkwrite (EXECUTION_SUCCESS));\n    }\n\n  any_failed = 0;\n  while (list)\n    {\n      name = list->word->word;\n\n      for (offset = 0; name[offset] && name[offset] != '='; offset++)\n\t;\n\n      if (offset && name[offset] == '=')\n\t{\n\t  name[offset] = '\\0';\n\t  value = name + offset + 1;\n\n\t  if (legal_alias_name (name, 0) == 0)\n\t    {\n\t      builtin_error (_(\"`%s': invalid alias name\"), name);\n\t      any_failed++;\n\t    }\n\t  else\n\t    add_alias (name, value);\n\t}\n      else\n\t{\n\t  t = find_alias (name);\n\t  if (t)\n\t    print_alias (t, dflags);\n\t  else\n\t    {\n\t      sh_notfound (name);\n\t      any_failed++;\n\t    }\n\t}\n      list = list->next;\n    }\n\n  return (any_failed ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n#endif /* ALIAS */\n\n$BUILTIN unalias\n$FUNCTION unalias_builtin\n$DEPENDS_ON ALIAS\n$SHORT_DOC unalias [-a] name [name ...]\nRemove each NAME from the list of defined aliases.\n\nOptions:\n  -a\tremove all alias definitions\n\nReturn success unless a NAME is not an existing alias.\n$END\n\n#if defined (ALIAS)\n/* Remove aliases named in LIST from the aliases database. */\nint\nunalias_builtin (list)\n     register WORD_LIST *list;\n{\n  register alias_t *alias;\n  int opt, aflag;\n\n  aflag = 0;\n  reset_internal_getopt ();\n  while ((opt = internal_getopt (list, \"a\")) != -1)\n    {\n      switch (opt)\n\t{\n\tcase 'a':\n\t  aflag = 1;\n\t  break;\n\tCASE_HELPOPT;\n\tdefault:\n\t  builtin_usage ();\n\t  return (EX_USAGE);\n\t}\n    }\n\n  list = loptend;\n\n  if (aflag)\n    {\n      delete_all_aliases ();\n      return (EXECUTION_SUCCESS);\n    }\n\n  if (list == 0)\n    {\n      builtin_usage ();\n      return (EX_USAGE);\n    }\n\n  aflag = 0;\n  while (list)\n    {\n      alias = find_alias (list->word->word);\n\n      if (alias)\n\tremove_alias (alias->name);\n      else\n\t{\n\t  sh_notfound (list->word->word);\n\t  aflag++;\n\t}\n\n      list = list->next;\n    }\n\n  return (aflag ? EXECUTION_FAILURE : EXECUTION_SUCCESS);\n}\n\n/* Output ALIAS in such a way as to allow it to be read back in. */\nstatic void\nprint_alias (alias, flags)\n     alias_t *alias;\n     int flags;\n{\n  char *value;\n\n  value = sh_single_quote (alias->value);\n  if (flags & AL_REUSABLE)\n    printf (\"alias %s\", (alias->name && alias->name[0] == '-') ? \"-- \" : \"\");\n  printf (\"%s=%s\\n\", alias->name, value);\n  free (value);\n\n  fflush (stdout);\n}\n#endif /* ALIAS */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}