{
  "module_name": "suspend.def",
  "hash_id": "dfb8f8da440a0863ebe2bb98e665406a98a7cb5524c4d16c5ec3b31d91a525e0",
  "original_prompt": "Ingested from bash-5.2.21/builtins/suspend.def",
  "human_readable_source": "This file is suspend.def, from which is created suspend.c.\nIt implements the builtin \"suspend\" in Bash.\n\nCopyright (C) 1987-2022 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES suspend.c\n\n$BUILTIN suspend\n$DEPENDS_ON JOB_CONTROL\n$FUNCTION suspend_builtin\n$SHORT_DOC suspend [-f]\nSuspend shell execution.\n\nSuspend the execution of this shell until it receives a SIGCONT signal.\nUnless forced, login shells and shells without job control cannot be\nsuspended.\n\nOptions:\n  -f\tforce the suspend, even if the shell is a login shell or job\n\t\tcontrol is not enabled.\n\nExit Status:\nReturns success unless job control is not enabled or an error occurs.\n$END\n\n#include <config.h>\n\n#if defined (JOB_CONTROL)\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashtypes.h\"\n#include <signal.h>\n#include \"../bashintl.h\"\n#include \"../shell.h\"\n#include \"../jobs.h\"\n#include \"common.h\"\n#include \"bashgetopt.h\"\n\nstatic sighandler suspend_continue PARAMS((int));\n\nstatic SigHandler *old_cont;\n#if 0\nstatic SigHandler *old_stop;\n#endif\n\n/* Continue handler. */\nstatic sighandler\nsuspend_continue (sig)\n     int sig;\n{\n  set_signal_handler (SIGCONT, old_cont);\n#if 0\n  set_signal_handler (SIGSTOP, old_stop);\n#endif\n  SIGRETURN (0);\n}\n\n/* Suspending the shell.  If -f is the arg, then do the suspend\n   no matter what.  Otherwise, complain if a login shell. */\nint\nsuspend_builtin (list)\n     WORD_LIST *list;\n{\n  int opt, force;\n\n  reset_internal_getopt ();\n  force = 0;\n  while ((opt = internal_getopt (list, \"f\")) != -1)\n    switch (opt)\n      {\n      case 'f':\n\tforce++;\n\tbreak;\n      CASE_HELPOPT;\n      default:\n\tbuiltin_usage ();\n\treturn (EX_USAGE);\n      }\n      \n  list = loptend;\n  no_args (list);\n\n  if (force == 0)  \n    {\n      if (job_control == 0)\n\t{\n\t  sh_nojobs (_(\"cannot suspend\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n\n      if (login_shell)\n\t{\n\t  builtin_error (_(\"cannot suspend a login shell\"));\n\t  return (EXECUTION_FAILURE);\n\t}\n    }\n\n  /* XXX - should we put ourselves back into the original pgrp now?  If so,\n     call end_job_control() here and do the right thing in suspend_continue\n     (that is, call restart_job_control()). */\n  old_cont = (SigHandler *)set_signal_handler (SIGCONT, suspend_continue);\n#if 0\n  old_stop = (SigHandler *)set_signal_handler (SIGSTOP, SIG_DFL);\n#endif\n  killpg (shell_pgrp, SIGSTOP);\n  return (EXECUTION_SUCCESS);\n}\n\n#endif /* JOB_CONTROL */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}