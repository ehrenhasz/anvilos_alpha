{
  "module_name": "evalstring.c",
  "hash_id": "b26b8127c471a96bbf43b38a11ef835a9debfe901577c647643cb158d6c17016",
  "original_prompt": "Ingested from bash-5.2.21/builtins/evalstring.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <signal.h>\n\n#include <errno.h>\n\n#include \"filecntl.h\"\n#include \"../bashansi.h\"\n\n#include \"../shell.h\"\n#include \"../jobs.h\"\n#include \"../builtins.h\"\n#include \"../flags.h\"\n#include \"../parser.h\"\n#include \"../input.h\"\n#include \"../execute_cmd.h\"\n#include \"../redir.h\"\n#include \"../trap.h\"\n#include \"../bashintl.h\"\n\n#include <y.tab.h>\n\n#if defined (HISTORY)\n#  include \"../bashhist.h\"\n#endif\n\n#include \"common.h\"\n#include \"builtext.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif\n\n#define IS_BUILTIN(s)\t(builtin_address_internal(s, 0) != (struct builtin *)NULL)\n\nint parse_and_execute_level = 0;\n\nstatic int cat_file PARAMS((REDIRECT *));\n\n#define PE_TAG \"parse_and_execute top\"\n#define PS_TAG \"parse_string top\"\n\n#if defined (HISTORY)\nstatic void\nset_history_remembering ()\n{\n  remember_on_history = enable_history_list;\n}\n#endif\n\nstatic void\nrestore_lastcom (x)\n     char *x;\n{\n  FREE (the_printed_command_except_trap);\n  the_printed_command_except_trap = x;\n}\n\nint\nshould_optimize_fork (command, subshell)\n     COMMAND *command;\n     int subshell;\n{\n  return (running_trap == 0 &&\n      command->type == cm_simple &&\n      signal_is_trapped (EXIT_TRAP) == 0 &&\n      signal_is_trapped (ERROR_TRAP) == 0 &&\n      any_signals_trapped () < 0 &&\n      (subshell || (command->redirects == 0 && command->value.Simple->redirects == 0)) &&\n      ((command->flags & CMD_TIME_PIPELINE) == 0) &&\n      ((command->flags & CMD_INVERT_RETURN) == 0));\n}\n\n \nint\nshould_suppress_fork (command)\n     COMMAND *command;\n{\n  int subshell;\n\n  subshell = subshell_environment & SUBSHELL_PROCSUB;\t \n  return (startup_state == 2 && parse_and_execute_level == 1 &&\n\t  *bash_input.location.string == '\\0' &&\n\t  parser_expanding_alias () == 0 &&\n\t  should_optimize_fork (command, subshell));\n}\n\nint\ncan_optimize_connection (command)\n     COMMAND *command;\n{\n  return (*bash_input.location.string == '\\0' &&\n\t  parser_expanding_alias () == 0 &&\n\t  (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&\n\t  command->value.Connection->second->type == cm_simple);\n}\n\nvoid\noptimize_connection_fork (command)\n     COMMAND *command;\n{\n  if (command->type == cm_connection &&\n      (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&\n      (command->value.Connection->second->flags & CMD_TRY_OPTIMIZING) &&\n      (should_suppress_fork (command->value.Connection->second) ||\n      ((subshell_environment & SUBSHELL_PAREN) && should_optimize_fork (command->value.Connection->second, 0))))\n    {\n      command->value.Connection->second->flags |= CMD_NO_FORK;\n      command->value.Connection->second->value.Simple->flags |= CMD_NO_FORK;\n    }\n}\n\nvoid\noptimize_subshell_command (command)\n     COMMAND *command;\n{\n  if (should_optimize_fork (command, 0))\n    {\n      command->flags |= CMD_NO_FORK;\n      command->value.Simple->flags |= CMD_NO_FORK;\n    }\n  else if (command->type == cm_connection &&\n\t   (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&\n\t   command->value.Connection->second->type == cm_simple &&\n\t   parser_expanding_alias () == 0)\n    {\t   \n      command->value.Connection->second->flags |= CMD_TRY_OPTIMIZING;\n      command->value.Connection->second->value.Simple->flags |= CMD_TRY_OPTIMIZING;\n    }\n}\n\nvoid\noptimize_shell_function (command)\n     COMMAND *command;\n{\n  COMMAND *fc;\n\n  fc = (command->type == cm_group) ? command->value.Group->command : command;\n\n  if (fc->type == cm_simple && should_suppress_fork (fc))\n    {\n      fc->flags |= CMD_NO_FORK;\n      fc->value.Simple->flags |= CMD_NO_FORK;\n    }\n  else if (fc->type == cm_connection && can_optimize_connection (fc) && should_suppress_fork (fc->value.Connection->second))\n    {\n      fc->value.Connection->second->flags |= CMD_NO_FORK;\n      fc->value.Connection->second->value.Simple->flags |= CMD_NO_FORK;\n    }  \n}\n\nint\ncan_optimize_cat_file (command)\n     COMMAND *command;\n{\n  return (command->type == cm_simple && !command->redirects &&\n\t    (command->flags & CMD_TIME_PIPELINE) == 0 &&\n\t    command->value.Simple->words == 0 &&\n\t    command->value.Simple->redirects &&\n\t    command->value.Simple->redirects->next == 0 &&\n\t    command->value.Simple->redirects->instruction == r_input_direction &&\n\t    command->value.Simple->redirects->redirector.dest == 0);\n}\n\n \nvoid\nparse_and_execute_cleanup (old_running_trap)\n     int old_running_trap;\n{\n  if (running_trap > 0)\n    {\n       \n      if (running_trap != old_running_trap)\n\trun_trap_cleanup (running_trap - 1);\n      unfreeze_jobs_list ();\n    }\n\n  if (have_unwind_protects ())\n     run_unwind_frame (PE_TAG);\n  else\n    parse_and_execute_level = 0;\t\t\t \n}\n\nstatic void\nparse_prologue (string, flags, tag)\n     char *string;\n     int flags;\n     char *tag;\n{\n  char *orig_string, *lastcom;\n  int x;\n\n  orig_string = string;\n   \n  begin_unwind_frame (tag);\n  unwind_protect_int (parse_and_execute_level);\n  unwind_protect_jmp_buf (top_level);\n  unwind_protect_int (indirection_level);\n  unwind_protect_int (line_number);\n  unwind_protect_int (line_number_for_err_trap);\n  unwind_protect_int (loop_level);\n  unwind_protect_int (executing_list);\n  unwind_protect_int (comsub_ignore_return);\n  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))\n    unwind_protect_int (interactive);\n\n#if defined (HISTORY)\n  if (parse_and_execute_level == 0)\n    add_unwind_protect (set_history_remembering, (char *)NULL);\n  else\n    unwind_protect_int (remember_on_history);\t \n#  if defined (BANG_HISTORY)\n  unwind_protect_int (history_expansion_inhibited);\n#  endif  \n#endif  \n\n  if (interactive_shell)\n    {\n      x = get_current_prompt_level ();\n      add_unwind_protect (set_current_prompt_level, x);\n    }\n\n  if (the_printed_command_except_trap)\n    {\n      lastcom = savestring (the_printed_command_except_trap);\n      add_unwind_protect (restore_lastcom, lastcom);\n    }\n\n  add_unwind_protect (pop_stream, (char *)NULL);\n  if (parser_expanding_alias ())\n    add_unwind_protect (parser_restore_alias, (char *)NULL);\n\n  if (orig_string && ((flags & SEVAL_NOFREE) == 0))\n    add_unwind_protect (xfree, orig_string);\n  end_unwind_frame ();\n\n  if (flags & (SEVAL_NONINT|SEVAL_INTERACT))\n    interactive = (flags & SEVAL_NONINT) ? 0 : 1;\n\n#if defined (HISTORY)\n  if (flags & SEVAL_NOHIST)\n    bash_history_disable ();\n#  if defined (BANG_HISTORY)\n  if (flags & SEVAL_NOHISTEXP)\n    history_expansion_inhibited = 1;\n#  endif  \n#endif  \n}\n\n \n\nint\nparse_and_execute (string, from_file, flags)\n     char *string;\n     const char *from_file;\n     int flags;\n{\n  int code, lreset;\n  volatile int should_jump_to_top_level, last_result;\n  COMMAND *volatile command;\n  volatile sigset_t pe_sigmask;\n\n  parse_prologue (string, flags, PE_TAG);\n\n  parse_and_execute_level++;\n\n  lreset = flags & SEVAL_RESETLINE;\n\n#if defined (HAVE_POSIX_SIGNALS)\n   \n  sigemptyset ((sigset_t *)&pe_sigmask);\n  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, (sigset_t *)&pe_sigmask);\n#endif\n\n   \n  push_stream (lreset);\n  if (parser_expanding_alias ())\n     \n    parser_save_alias ();\n  \n  if (lreset == 0)\n    line_number--;\n    \n  indirection_level++;\n\n  code = should_jump_to_top_level = 0;\n  last_result = EXECUTION_SUCCESS;\n\n   \n  if (current_token == yacc_EOF)\n    current_token = '\\n';\t\t \n\n  with_input_from_string (string, from_file);\n  clear_shell_input_line ();\n  while (*(bash_input.location.string) || parser_expanding_alias ())\n    {\n      command = (COMMAND *)NULL;\n\n      if (interrupt_state)\n\t{\n\t  last_result = EXECUTION_FAILURE;\n\t  break;\n\t}\n\n       \n      code = setjmp_nosigs (top_level);\n\n      if (code)\n\t{\n\t  should_jump_to_top_level = 0;\n\t  switch (code)\n\t    {\n\t    case ERREXIT:\n\t       \n\t      if (exit_immediately_on_error && variable_context)\n\t        {\n\t          discard_unwind_frame (\"pe_dispose\");\n\t          reset_local_contexts ();  \n\t        }\n\t      should_jump_to_top_level = 1;\n\t      goto out;\n\t    case FORCE_EOF:\t      \n\t    case EXITPROG:\n\t      if (command)\n\t\trun_unwind_frame (\"pe_dispose\");\n\t       \n\t      should_jump_to_top_level = 1;\n\t      goto out;\n\n\t    case EXITBLTIN:\n\t      if (command)\n\t\t{\n\t\t  if (variable_context && signal_is_trapped (0))\n\t\t    {\n\t\t       \n\t\t      dispose_command (command);\n\t\t      discard_unwind_frame (\"pe_dispose\");\n\t\t    }\n\t\t  else\n\t\t    run_unwind_frame (\"pe_dispose\");\n\t\t}\n\t      should_jump_to_top_level = 1;\n\t      goto out;\n\n\t    case DISCARD:\n\t      if (command)\n\t\trun_unwind_frame (\"pe_dispose\");\n\t      last_result = last_command_exit_value = EXECUTION_FAILURE;  \n\t      set_pipestatus_from_exit (last_command_exit_value);\n\t      if (subshell_environment)\n\t\t{\n\t\t  should_jump_to_top_level = 1;\n\t\t  goto out;\n\t\t}\n\t      else\n\t\t{\n#if 0\n\t\t  dispose_command (command);\t \n#endif\n#if defined (HAVE_POSIX_SIGNALS)\n\t\t  sigprocmask (SIG_SETMASK, (sigset_t *)&pe_sigmask, (sigset_t *)NULL);\n#endif\n\t\t  continue;\n\t\t}\n\n\t    default:\n\t      command_error (\"parse_and_execute\", CMDERR_BADJUMP, code, 0);\n\t      break;\n\t    }\n\t}\n\n      if (parse_command () == 0)\n\t{\n\t  int local_expalias, local_alflag;\n\n\t  if ((flags & SEVAL_PARSEONLY) || (interactive_shell == 0 && read_but_dont_execute))\n\t    {\n\t      last_result = EXECUTION_SUCCESS;\n\t      dispose_command (global_command);\n\t      global_command = (COMMAND *)NULL;\n\t    }\n\t  else if (command = global_command)\n\t    {\n\t      struct fd_bitmap *bitmap;\n\n\t      if (flags & SEVAL_FUNCDEF)\n\t\t{\n\t\t  char *x;\n\n\t\t   \n\t\t  if (command->type != cm_function_def ||\n\t\t      ((x = parser_remaining_input ()) && *x) ||\n\t\t      (STREQ (from_file, command->value.Function_def->name->word) == 0))\n\t\t    {\n\t\t      internal_warning (_(\"%s: ignoring function definition attempt\"), from_file);\n\t\t      should_jump_to_top_level = 0;\n\t\t      last_result = last_command_exit_value = EX_BADUSAGE;\n\t\t      set_pipestatus_from_exit (last_command_exit_value);\n\t\t      reset_parser ();\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);\n\t      begin_unwind_frame (\"pe_dispose\");\n\t      add_unwind_protect (dispose_fd_bitmap, bitmap);\n\t      add_unwind_protect (dispose_command, command);\t \n\n\t      global_command = (COMMAND *)NULL;\n\n\t      if ((subshell_environment & SUBSHELL_COMSUB) && comsub_ignore_return)\n\t\tcommand->flags |= CMD_IGNORE_RETURN;\n\n#if defined (ONESHOT)\n\t       \n\t      if (should_suppress_fork (command))\n\t\t{\n\t\t  command->flags |= CMD_NO_FORK;\n\t\t  command->value.Simple->flags |= CMD_NO_FORK;\n\t\t}\n\n\t       \n\t      else if (command->type == cm_connection &&\n\t\t       (flags & SEVAL_NOOPTIMIZE) == 0 &&\n\t\t       can_optimize_connection (command))\n\t\t{\n\t\t  command->value.Connection->second->flags |= CMD_TRY_OPTIMIZING;\n\t\t  command->value.Connection->second->value.Simple->flags |= CMD_TRY_OPTIMIZING;\n\t\t}\n#endif  \n\n\t       \n\t      local_expalias = expand_aliases;\n\t      local_alflag = expaliases_flag;\n\t      if (subshell_environment & SUBSHELL_COMSUB)\n\t\texpand_aliases = expaliases_flag;\n\n\t       \n\t      if (startup_state == 2 &&\n\t\t  (subshell_environment & SUBSHELL_COMSUB) &&\n\t\t  *bash_input.location.string == '\\0' &&\n\t\t  can_optimize_cat_file (command))\n\t\t{\n\t\t  int r;\n\t\t  r = cat_file (command->value.Simple->redirects);\n\t\t  last_result = (r < 0) ? EXECUTION_FAILURE : EXECUTION_SUCCESS;\n\t\t}\n\t      else\n\t\tlast_result = execute_command_internal\n\t\t\t\t(command, 0, NO_PIPE, NO_PIPE, bitmap);\n\t      dispose_command (command);\n\t      dispose_fd_bitmap (bitmap);\n\t      discard_unwind_frame (\"pe_dispose\");\n\n\t       \n\t      if ((subshell_environment & SUBSHELL_COMSUB) && local_alflag == expaliases_flag)\n\t\texpand_aliases = local_expalias;\n\n\t      if (flags & SEVAL_ONECMD)\n\t\t{\n\t\t  reset_parser ();\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  last_result = EX_BADUSAGE;\t \n\n\t  if (interactive_shell == 0 && this_shell_builtin &&\n\t      (this_shell_builtin == source_builtin || this_shell_builtin == eval_builtin) &&\n\t      last_command_exit_value == EX_BADSYNTAX && posixly_correct && executing_command_builtin == 0)\n\t    {\n\t      should_jump_to_top_level = 1;\n\t      code = ERREXIT;\n\t      last_command_exit_value = EX_BADUSAGE;\n\t    }\n\n\t   \n\t  break;\n\t}\n    }\n\n out:\n\n  run_unwind_frame (PE_TAG);\n\n  if (interrupt_state && parse_and_execute_level == 0)\n    {\n       \n      interactive = interactive_shell;\n      throw_to_top_level ();\n    }\n\n  CHECK_TERMSIG;\n\n  if (should_jump_to_top_level)\n    jump_to_top_level (code);\n\n  return (last_result);\n}\n\n \nint\nparse_string (string, from_file, flags, cmdp, endp)\n     char *string;\n     const char *from_file;\n     int flags;\n     COMMAND **cmdp;\n     char **endp;\n{\n  int code, nc;\n  volatile int should_jump_to_top_level;\n  COMMAND *volatile command, *oglobal;\n  char *ostring;\n  volatile sigset_t ps_sigmask;\n\n  parse_prologue (string, flags, PS_TAG);\n\n#if defined (HAVE_POSIX_SIGNALS)\n   \n  sigemptyset ((sigset_t *)&ps_sigmask);\n  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, (sigset_t *)&ps_sigmask);\n#endif\n\n   \n  push_stream (0);\n  if (parser_expanding_alias ())\n     \n    parser_save_alias ();\n\n  code = should_jump_to_top_level = 0;\n  oglobal = global_command;\n\n  with_input_from_string (string, from_file);\n  ostring = bash_input.location.string;\n  while (*(bash_input.location.string))\t\t \n    {\n      command = (COMMAND *)NULL;\n\n#if 0\n      if (interrupt_state)\n\tbreak;\n#endif\n\n       \n      code = setjmp_nosigs (top_level);\n\n      if (code)\n\t{\n\t  INTERNAL_DEBUG((\"parse_string: longjmp executed: code = %d\", code));\n\n\t  should_jump_to_top_level = 0;\n\t  switch (code)\n\t    {\n\t    case FORCE_EOF:\n\t    case ERREXIT:\n\t    case EXITPROG:\n\t    case EXITBLTIN:\n\t    case DISCARD:\t\t \n\t      if (command)\n\t\tdispose_command (command);\n\t       \n\t      should_jump_to_top_level = 1;\n\t      goto out;\n\n\t    default:\n#if defined (HAVE_POSIX_SIGNALS)\n\t      sigprocmask (SIG_SETMASK, (sigset_t *)&ps_sigmask, (sigset_t *)NULL);\n#endif\n\t      command_error (\"parse_string\", CMDERR_BADJUMP, code, 0);\n\t      break;\n\t    }\n\t}\n\t  \n      if (parse_command () == 0)\n\t{\n\t  if (cmdp)\n\t    *cmdp = global_command;\n\t  else\n\t    dispose_command (global_command);\n\t  global_command = (COMMAND *)NULL;\n\t}\n      else\n\t{\n\t  if ((flags & SEVAL_NOLONGJMP) == 0)\n\t    {\n\t      should_jump_to_top_level = 1;\n\t      code = DISCARD;\n\t    }\n\t  else\n\t    reset_parser ();\t \n\t  break;\n\t}\n\n      if (current_token == yacc_EOF || current_token == shell_eof_token)\n\t{\n\t  if (current_token == shell_eof_token)\n\t    rewind_input_string ();\n\t  break;\n\t}\n    }\n\nout:\n\n  global_command = oglobal;\n  nc = bash_input.location.string - ostring;\n  if (endp)\n    *endp = bash_input.location.string;\n\n  run_unwind_frame (PS_TAG);\n\n   \n  if (should_jump_to_top_level)\n    {\n      if (parse_and_execute_level == 0)\n\ttop_level_cleanup ();\n      if (code == DISCARD)\n\treturn -DISCARD;\n      jump_to_top_level (code);\n    }\n\n  return (nc);\n}\n\nint\nopen_redir_file (r, fnp)\n     REDIRECT *r;\n     char **fnp;\n{\n  char *fn;\n  int fd, rval;\n\n  if (r->instruction != r_input_direction)\n    return -1;\n\n   \n  if (posixly_correct && !interactive_shell)\n    disallow_filename_globbing++;\n  fn = redirection_expand (r->redirectee.filename);\n  if (posixly_correct && !interactive_shell)\n    disallow_filename_globbing--;\n\n  if (fn == 0)\n    {\n      redirection_error (r, AMBIGUOUS_REDIRECT, fn);\n      return -1;\n    }\n\n  fd = open(fn, O_RDONLY);\n  if (fd < 0)\n    {\n      file_error (fn);\n      free (fn);\n      if (fnp)\n\t*fnp = 0;\n      return -1;\n    }\n\n  if (fnp)\n    *fnp = fn;\n  return fd;\n}\n\n \nstatic int\ncat_file (r)\n     REDIRECT *r;\n{\n  char *fn;\n  int fd, rval;\n\n  fd = open_redir_file (r, &fn);\n  if (fd < 0)\n    return -1;\n\n  rval = zcatfd (fd, 1, fn);\n\n  free (fn);\n  close (fd);\n\n  return (rval);\n}\n\nint\nevalstring (string, from_file, flags)\n     char *string;\n     const char *from_file;\n     int flags;\n{\n  volatile int r, rflag, rcatch;\n  volatile int was_trap;\n\n   \n  was_trap = running_trap;\n\n  rcatch = 0;\n  rflag = return_catch_flag;\n   \n  if (rflag)\n    {\n      begin_unwind_frame (\"evalstring\");\n\n      unwind_protect_int (return_catch_flag);\n      unwind_protect_jmp_buf (return_catch);\n\n      return_catch_flag++;\t \n      rcatch = setjmp_nosigs (return_catch);\n    }\n\n  if (rcatch)\n    {\n       \n      parse_and_execute_cleanup (was_trap);\n      r = return_catch_value;\n    }\n  else\n     \n    r = parse_and_execute (string, from_file, flags);\n\n  if (rflag)\n    {\n      run_unwind_frame (\"evalstring\");\n      if (rcatch && return_catch_flag)\n\t{\n\t  return_catch_value = r;\n\t  sh_longjmp (return_catch, 1);\n\t}\n    }\n    \n  return (r);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}