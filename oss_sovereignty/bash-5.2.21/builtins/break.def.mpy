{
  "module_name": "break.def",
  "hash_id": "4077768535be5cff07e749ebaba92913813c13be4dfbd65c7ff2baaba81d2a28",
  "original_prompt": "Ingested from bash-5.2.21/builtins/break.def",
  "human_readable_source": "This file is break.def, from which is created break.c.\nIt implements the builtins \"break\" and \"continue\" in Bash.\n\nCopyright (C) 1987-2020 Free Software Foundation, Inc.\n\nThis file is part of GNU Bash, the Bourne Again SHell.\n\nBash is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nBash is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Bash.  If not, see <http://www.gnu.org/licenses/>.\n\n$PRODUCES break.c\n\n$BUILTIN break\n$FUNCTION break_builtin\n$SHORT_DOC break [n]\nExit for, while, or until loops.\n\nExit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\nloops.\n\nExit Status:\nThe exit status is 0 unless N is not greater than or equal to 1.\n$END\n#include <config.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"../bashintl.h\"\n\n#include \"../shell.h\"\n#include \"../execute_cmd.h\"\n#include \"common.h\"\n\nstatic int check_loop_level PARAMS((void));\n\n/* The depth of while's and until's. */\nint loop_level = 0;\n\n/* Non-zero when a \"break\" instruction is encountered. */\nint breaking = 0;\n\n/* Non-zero when we have encountered a continue instruction. */\nint continuing = 0;\n\n/* Set up to break x levels, where x defaults to 1, but can be specified\n   as the first argument. */\nint\nbreak_builtin (list)\n     WORD_LIST *list;\n{\n  intmax_t newbreak;\n\n  CHECK_HELPOPT (list);\n\n  if (check_loop_level () == 0)\n    return (EXECUTION_SUCCESS);\n\n  (void)get_numeric_arg (list, 1, &newbreak);\n\n  if (newbreak <= 0)\n    {\n      sh_erange (list->word->word, _(\"loop count\"));\n      breaking = loop_level;\n      return (EXECUTION_FAILURE);\n    }\n\n  if (newbreak > loop_level)\n    newbreak = loop_level;\n\n  breaking = newbreak;\n\n  return (EXECUTION_SUCCESS);\n}\n\n$BUILTIN continue\n$FUNCTION continue_builtin\n$SHORT_DOC continue [n]\nResume for, while, or until loops.\n\nResumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\nIf N is specified, resumes the Nth enclosing loop.\n\nExit Status:\nThe exit status is 0 unless N is not greater than or equal to 1.\n$END\n\n/* Set up to continue x levels, where x defaults to 1, but can be specified\n   as the first argument. */\nint\ncontinue_builtin (list)\n     WORD_LIST *list;\n{\n  intmax_t newcont;\n\n  CHECK_HELPOPT (list);\n\n  if (check_loop_level () == 0)\n    return (EXECUTION_SUCCESS);\n\n  (void)get_numeric_arg (list, 1, &newcont);\n\n  if (newcont <= 0)\n    {\n      sh_erange (list->word->word, _(\"loop count\"));\n      breaking = loop_level;\n      return (EXECUTION_FAILURE);\n    }\n\n  if (newcont > loop_level)\n    newcont = loop_level;\n\n  continuing = newcont;\n\n  return (EXECUTION_SUCCESS);\n}\n\n/* Return non-zero if a break or continue command would be okay.\n   Print an error message if break or continue is meaningless here. */\nstatic int\ncheck_loop_level ()\n{\n#if defined (BREAK_COMPLAINS)\n  if (loop_level == 0 && posixly_correct == 0)\n    builtin_error (_(\"only meaningful in a `for', `while', or `until' loop\"));\n#endif /* BREAK_COMPLAINS */\n\n  return (loop_level);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}