{
  "module_name": "mkbuiltins.c",
  "hash_id": "169370ece8fba9b31dee071a732a385b68fb66c24744d93cadc80a728f63d41a",
  "original_prompt": "Ingested from bash-5.2.21/builtins/mkbuiltins.c",
  "human_readable_source": " \n\n \n\n#if !defined (CROSS_COMPILING) \n#  include <config.h>\n#else\t \n \n#  define HAVE_UNISTD_H\n#  define HAVE_STRING_H\n#  define HAVE_STDLIB_H\n\n#  define HAVE_RENAME\n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#ifndef _MINIX\n#  include \"../bashtypes.h\"\n#  if defined (HAVE_SYS_FILE_H)\n#    include <sys/file.h>\n#  endif\n#endif\n\n#include \"posixstat.h\"\n#include \"filecntl.h\"\n\n#include \"../bashansi.h\"\n#include <stdio.h>\n#include <errno.h>\n\n#include \"stdc.h\"\n\n#define DOCFILE \"builtins.texi\"\n\n#ifndef errno\nextern int errno;\n#endif\n\nstatic char *xmalloc (), *xrealloc ();\n\n#if !defined (__STDC__) && !defined (strcpy)\nextern char *strcpy ();\n#endif  \n\n#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))\n#define whitespace(c) (((c) == ' ') || ((c) == '\\t'))\n\n \n#define BUILTIN_FLAG_SPECIAL\t0x01\n#define BUILTIN_FLAG_ASSIGNMENT 0x02\n#define BUILTIN_FLAG_LOCALVAR\t0x04\n#define BUILTIN_FLAG_POSIX_BUILTIN\t0x08\n#define BUILTIN_FLAG_ARRAYREF_ARG\t0x10\n\n#define BASE_INDENT\t4\n\n \nFILE *documentation_file = (FILE *)NULL;\n\n \nint only_documentation = 0;\n\n \nint inhibit_production = 0;\n\n \nint inhibit_functions = 0;\n\n \nint separate_helpfiles = 0;\n\n \nint single_longdoc_strings = 1;\n\n \nchar *helpfile_directory;\n\n \nchar *error_directory = (char *)NULL;\n\n \nchar *struct_filename = (char *)NULL;\n\n \nchar *extern_filename = (char *)NULL;\n\n \nchar *include_filename = (char *)NULL;\n\n \n\n \ntypedef struct {\n  int size;\t\t \n  int sindex;\t\t \n  int width;\t\t \n  int growth_rate;\t \n  char **array;\t\t \n} ARRAY;\n\n \ntypedef struct {\n  char *name;\t\t \n  char *function;\t \n  char *shortdoc;\t \n  char *docname;\t \n  ARRAY *longdoc;\t \n  ARRAY *dependencies;\t \n  int flags;\t\t \n} BUILTIN_DESC;\n\n \ntypedef struct {\n  char *filename;\t \n  ARRAY *lines;\t\t \n  int line_number;\t \n  char *production;\t \n  FILE *output;\t\t \n  ARRAY *builtins;\t \n} DEF_FILE;\n\n \nARRAY *saved_builtins = (ARRAY *)NULL;\n\n \nchar *special_builtins[] =\n{\n  \":\", \".\", \"source\", \"break\", \"continue\", \"eval\", \"exec\", \"exit\",\n  \"export\", \"readonly\", \"return\", \"set\", \"shift\", \"times\", \"trap\", \"unset\",\n  (char *)NULL\n};\n\n \nchar *assignment_builtins[] =\n{\n  \"alias\", \"declare\", \"export\", \"local\", \"readonly\", \"typeset\",\n  (char *)NULL\n};\n\nchar *localvar_builtins[] =\n{\n  \"declare\", \"local\", \"typeset\", (char *)NULL\n};\n\n \nchar *posix_builtins[] =\n{\n  \"alias\", \"bg\", \"cd\", \"command\", \"false\", \"fc\", \"fg\", \"getopts\", \"jobs\",\n  \"kill\", \"newgrp\", \"pwd\", \"read\", \"true\", \"umask\", \"unalias\", \"wait\",\n  (char *)NULL\n};\n\n \nchar *arrayvar_builtins[] =\n{\n  \"declare\", \"let\", \"local\", \"printf\", \"read\", \"test\", \"[\",\n  \"typeset\", \"unset\", \"wait\",\t\t \n  (char *)NULL\n};\n\t\n \nstatic int is_special_builtin ();\nstatic int is_assignment_builtin ();\nstatic int is_localvar_builtin ();\nstatic int is_posix_builtin ();\nstatic int is_arrayvar_builtin ();\n\n#if !defined (HAVE_RENAME)\nstatic int rename ();\n#endif\n\nvoid extract_info ();\n\nvoid file_error ();\nvoid line_error ();\n\nvoid write_file_headers ();\nvoid write_file_footers ();\nvoid write_ifdefs ();\nvoid write_endifs ();\nvoid write_documentation ();\nvoid write_longdocs ();\nvoid write_builtins ();\n\nint write_helpfiles ();\n\nvoid free_defs ();\nvoid add_documentation ();\n\nvoid must_be_building ();\nvoid remove_trailing_whitespace ();\n\n#define document_name(b)\t((b)->docname ? (b)->docname : (b)->name)\n\n\f\n \nint\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  int arg_index = 1;\n  FILE *structfile, *externfile;\n  char *documentation_filename, *temp_struct_filename;\n\n  structfile = externfile = (FILE *)NULL;\n  documentation_filename = DOCFILE;\n  temp_struct_filename = (char *)NULL;\n\n  while (arg_index < argc && argv[arg_index][0] == '-')\n    {\n      char *arg = argv[arg_index++];\n\n      if (strcmp (arg, \"-externfile\") == 0)\n\textern_filename = argv[arg_index++];\n      else if (strcmp (arg, \"-includefile\") == 0)\n\tinclude_filename = argv[arg_index++];\n      else if (strcmp (arg, \"-structfile\") == 0)\n\tstruct_filename = argv[arg_index++];\n      else if (strcmp (arg, \"-noproduction\") == 0)\n\tinhibit_production = 1;\n      else if (strcmp (arg, \"-nofunctions\") == 0)\n\tinhibit_functions = 1;\n      else if (strcmp (arg, \"-document\") == 0)\n\tdocumentation_file = fopen (documentation_filename, \"w\");\n      else if (strcmp (arg, \"-D\") == 0)\n\t{\n\t  int len;\n\n\t  if (error_directory)\n\t    free (error_directory);\n\n\t  error_directory = xmalloc (2 + strlen (argv[arg_index]));\n\t  strcpy (error_directory, argv[arg_index]);\n\t  len = strlen (error_directory);\n\n\t  if (len && error_directory[len - 1] != '/')\n\t    strcat (error_directory, \"/\");\n\n\t  arg_index++;\n\t}\n      else if (strcmp (arg, \"-documentonly\") == 0)\n\t{\n\t  only_documentation = 1;\n\t  documentation_file = fopen (documentation_filename, \"w\");\n\t}\n      else if (strcmp (arg, \"-H\") == 0)\n        {\n\t  separate_helpfiles = 1;\n\t  helpfile_directory = argv[arg_index++];\n        }\n      else if (strcmp (arg, \"-S\") == 0)\n\tsingle_longdoc_strings = 0;\n      else\n\t{\n\t  fprintf (stderr, \"%s: Unknown flag %s.\\n\", argv[0], arg);\n\t  exit (2);\n\t}\n    }\n\n  if (include_filename == 0)\n    include_filename = extern_filename;\n\n   \n  if (arg_index == argc)\n    exit (0);\n\n  if (!only_documentation)\n    {\n       \n      if (struct_filename)\n\t{\n\t  temp_struct_filename = xmalloc (15);\n\t  sprintf (temp_struct_filename, \"mk-%ld\", (long) getpid ());\n\t  structfile = fopen (temp_struct_filename, \"w\");\n\n\t  if (!structfile)\n\t    file_error (temp_struct_filename);\n\t}\n\n      if (extern_filename)\n\t{\n\t  externfile = fopen (extern_filename, \"w\");\n\n\t  if (!externfile)\n\t    file_error (extern_filename);\n\t}\n\n       \n      write_file_headers (structfile, externfile);\n    }\n\n  if (documentation_file)\n    {\n      fprintf (documentation_file, \"@c Table of builtins created with %s.\\n\",\n\t       argv[0]);\n      fprintf (documentation_file, \"@ftable @asis\\n\");\n    }\n\n   \n  while (arg_index < argc)\n    {\n      register char *arg;\n\n      arg = argv[arg_index++];\n\n      extract_info (arg, structfile, externfile);\n    }\n\n   \n  if (!only_documentation)\n    {\n       \n      write_file_footers (structfile, externfile);\n\n      if (structfile)\n\t{\n\t  write_longdocs (structfile, saved_builtins);\n\t  fclose (structfile);\n\t  rename (temp_struct_filename, struct_filename);\n\t}\n\n      if (externfile)\n\tfclose (externfile);\n    }\n\n#if 0\n   \n  if (separate_helpfiles)\n    {\n      write_helpfiles (saved_builtins);\n    }\n#endif\n\n  if (documentation_file)\n    {\n      fprintf (documentation_file, \"@end ftable\\n\");\n      fclose (documentation_file);\n    }\n\n  exit (0);\n}\n\n \n \n \n \n \n\n \nARRAY *\narray_create (width)\n     int width;\n{\n  ARRAY *array;\n\n  array = (ARRAY *)xmalloc (sizeof (ARRAY));\n  array->size = 0;\n  array->sindex = 0;\n  array->width = width;\n\n   \n  array->growth_rate = 20;\n\n  array->array = (char **)NULL;\n\n  return (array);\n}\n\n \nARRAY *\ncopy_string_array (array)\n     ARRAY *array;\n{\n  register int i;\n  ARRAY *copy;\n\n  if (!array)\n    return (ARRAY *)NULL;\n\n  copy = array_create (sizeof (char *));\n\n  copy->size = array->size;\n  copy->sindex = array->sindex;\n  copy->width = array->width;\n\n  copy->array = (char **)xmalloc ((1 + array->sindex) * sizeof (char *));\n  \n  for (i = 0; i < array->sindex; i++)\n    copy->array[i] = savestring (array->array[i]);\n\n  copy->array[i] = (char *)NULL;\n\n  return (copy);\n}\n\n \nvoid\narray_add (element, array)\n     char *element;\n     ARRAY *array;\n{\n  if (array->sindex + 2 > array->size)\n    array->array = (char **)xrealloc\n      (array->array, (array->size += array->growth_rate) * array->width);\n\n  array->array[array->sindex++] = element;\n  array->array[array->sindex] = (char *)NULL;\n}\n\n \nvoid\narray_free (array)\n     ARRAY *array;\n{\n  if (array->array)\n    free (array->array);\n\n  free (array);\n}\n\n \n \n \n \n \n\n \ntypedef int Function ();\ntypedef int mk_handler_func_t PARAMS((char *, DEF_FILE *, char *));\n\n \ntypedef struct {\n  char *directive;\n  mk_handler_func_t *function;\n} HANDLER_ENTRY;\n\nextern int builtin_handler PARAMS((char *, DEF_FILE *, char *));\nextern int function_handler PARAMS((char *, DEF_FILE *, char *));\nextern int short_doc_handler PARAMS((char *, DEF_FILE *, char *));\nextern int comment_handler PARAMS((char *, DEF_FILE *, char *));\nextern int depends_on_handler PARAMS((char *, DEF_FILE *, char *));\nextern int produces_handler PARAMS((char *, DEF_FILE *, char *));\nextern int end_handler PARAMS((char *, DEF_FILE *, char *));\nextern int docname_handler PARAMS((char *, DEF_FILE *, char *));\n\nHANDLER_ENTRY handlers[] = {\n  { \"BUILTIN\", builtin_handler },\n  { \"DOCNAME\", docname_handler },\n  { \"FUNCTION\", function_handler },\n  { \"SHORT_DOC\", short_doc_handler },\n  { \"$\", comment_handler },\n  { \"COMMENT\", comment_handler },\n  { \"DEPENDS_ON\", depends_on_handler },\n  { \"PRODUCES\", produces_handler },\n  { \"END\", end_handler },\n  { (char *)NULL, (mk_handler_func_t *)NULL }\n};\n\n \nHANDLER_ENTRY *\nfind_directive (directive)\n     char *directive;\n{\n  register int i;\n\n  for (i = 0; handlers[i].directive; i++)\n    if (strcmp (handlers[i].directive, directive) == 0)\n      return (&handlers[i]);\n\n  return ((HANDLER_ENTRY *)NULL);\n}\n\n \nstatic int building_builtin = 0;\n\n \nint output_cpp_line_info = 0;\n\n \nvoid\nextract_info (filename, structfile, externfile)\n     char *filename;\n     FILE *structfile, *externfile;\n{\n  register int i;\n  DEF_FILE *defs;\n  struct stat finfo;\n  size_t file_size;\n  char *buffer, *line;\n  int fd, nr;\n\n  if (stat (filename, &finfo) == -1)\n    file_error (filename);\n\n  fd = open (filename, O_RDONLY, 0666);\n\n  if (fd == -1)\n    file_error (filename);\n\n  file_size = (size_t)finfo.st_size;\n  buffer = xmalloc (1 + file_size);\n\n  if ((nr = read (fd, buffer, file_size)) < 0)\n    file_error (filename);\n\n   \n  if (nr < file_size)\n    file_size = nr;\n\n  close (fd);\n\n  if (nr == 0)\n    {\n      fprintf (stderr, \"mkbuiltins: %s: skipping zero-length file\\n\", filename);\n      free (buffer);\n      return;\n    }\n\n   \n  defs = (DEF_FILE *)xmalloc (sizeof (DEF_FILE));\n  defs->filename = filename;\n  defs->lines = array_create (sizeof (char *));\n  defs->line_number = 0;\n  defs->production = (char *)NULL;\n  defs->output = (FILE *)NULL;\n  defs->builtins = (ARRAY *)NULL;\n\n   \n  i = 0;\n  while (i < file_size)\n    {\n      array_add (&buffer[i], defs->lines);\n\n      while (i < file_size && buffer[i] != '\\n')\n\ti++;\n      buffer[i++] = '\\0';\n    }\n\n   \n  output_cpp_line_info = 1;\n\n   \n  for (i = 0; line = defs->lines->array[i]; i++)\n    {\n      defs->line_number = i;\n\n      if (*line == '$')\n\t{\n\t  register int j;\n\t  char *directive;\n\t  HANDLER_ENTRY *handler;\n\n\t   \n\t  for (j = 0; line[j] && !whitespace (line[j]); j++);\n\n\t  directive = xmalloc (j);\n\t  strncpy (directive, line + 1, j - 1);\n\t  directive[j -1] = '\\0';\n\n\t   \n\t  handler = find_directive (directive);\n\n\t  if (!handler)\n\t    {\n\t      line_error (defs, \"Unknown directive `%s'\", directive);\n\t      free (directive);\n\t      continue;\n\t    }\n\t  else\n\t    {\n\t       \n\t      while (whitespace (line[j]))\n\t\tj++;\n\n\t       \n\t      (*(handler->function)) (directive, defs, line + j);\n\t    }\n\t  free (directive);\n\t}\n      else\n\t{\n\t  if (building_builtin)\n\t    add_documentation (defs, line);\n\t  else if (defs->output)\n\t    {\n\t      if (output_cpp_line_info)\n\t\t{\n\t\t   \n\t\t  if (defs->filename[0] == '/')\n\t\t    fprintf (defs->output, \"#line %d \\\"%s\\\"\\n\",\n\t\t\t     defs->line_number + 1, defs->filename);\n\t\t  else\n\t\t    fprintf (defs->output, \"#line %d \\\"%s%s\\\"\\n\",\n\t\t\t     defs->line_number + 1,\n\t\t\t     error_directory ? error_directory : \"./\",\n\t\t\t     defs->filename);\n\t\t  output_cpp_line_info = 0;\n\t\t}\n\n\t      fprintf (defs->output, \"%s\\n\", line);\n\t    }\n\t}\n    }\n\n   \n  if (defs->output)\n    fclose (defs->output);\n\n   \n  write_builtins (defs, structfile, externfile);\n\n  free (buffer);\n  free_defs (defs);\n}\n\n#define free_safely(x) if (x) free (x)\n\nstatic void\nfree_builtin (builtin)\n     BUILTIN_DESC *builtin;\n{\n  register int i;\n\n  free_safely (builtin->name);\n  free_safely (builtin->function);\n  free_safely (builtin->shortdoc);\n  free_safely (builtin->docname);\n\n  if (builtin->longdoc)\n    array_free (builtin->longdoc);\n\n  if (builtin->dependencies)\n    {\n      for (i = 0; builtin->dependencies->array[i]; i++)\n\tfree (builtin->dependencies->array[i]);\n      array_free (builtin->dependencies);\n    }\n}\n\n \nvoid\nfree_defs (defs)\n     DEF_FILE *defs;\n{\n  register int i;\n  register BUILTIN_DESC *builtin;\n\n  if (defs->production)\n    free (defs->production);\n\n  if (defs->lines)\n    array_free (defs->lines);\n\n  if (defs->builtins)\n    {\n      for (i = 0; builtin = (BUILTIN_DESC *)defs->builtins->array[i]; i++)\n\t{\n\t  free_builtin (builtin);\n\t  free (builtin);\n\t}\n      array_free (defs->builtins);\n    }\n  free (defs);\n}\n\n \n \n \n \n \n\n \nchar *\nstrip_whitespace (string)\n     char *string;\n{\n  while (whitespace (*string))\n      string++;\n\n  remove_trailing_whitespace (string);\n  return (string);\n}\n\n \nvoid\nremove_trailing_whitespace (string)\n     char *string;\n{\n  register int i;\n\n  i = strlen (string) - 1;\n\n  while (i > 0 && whitespace (string[i]))\n    i--;\n\n  string[++i] = '\\0';\n}\n\n \nchar *\nget_arg (for_whom, defs, string)\n     char *for_whom, *string;\n     DEF_FILE *defs;\n{\n  char *new;\n\n  new = strip_whitespace (string);\n\n  if (!*new)\n    line_error (defs, \"%s requires an argument\", for_whom);\n\n  return (savestring (new));\n}\n\n \nvoid\nmust_be_building (directive, defs)\n     char *directive;\n     DEF_FILE *defs;\n{\n  if (!building_builtin)\n    line_error (defs, \"%s must be inside of a $BUILTIN block\", directive);\n}\n\n \nBUILTIN_DESC *\ncurrent_builtin (directive, defs)\n     char *directive;\n     DEF_FILE *defs;\n{\n  must_be_building (directive, defs);\n  if (defs->builtins)\n    return ((BUILTIN_DESC *)defs->builtins->array[defs->builtins->sindex - 1]);\n  else\n    return ((BUILTIN_DESC *)NULL);\n}\n\n \nvoid\nadd_documentation (defs, line)\n     DEF_FILE *defs;\n     char *line;\n{\n  register BUILTIN_DESC *builtin;\n\n  builtin = current_builtin (\"(implied LONGDOC)\", defs);\n\n  remove_trailing_whitespace (line);\n\n  if (!*line && !builtin->longdoc)\n    return;\n\n  if (!builtin->longdoc)\n    builtin->longdoc = array_create (sizeof (char *));\n\n  array_add (line, builtin->longdoc);\n}\n\n \nint\nbuiltin_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  BUILTIN_DESC *new;\n  char *name;\n\n   \n  if (building_builtin)\n    {\n      line_error (defs, \"%s found before $END\", self);\n      return (-1);\n    }\n\n  output_cpp_line_info++;\n\n   \n  name = get_arg (self, defs, arg);\n\n   \n  if (!defs->builtins)\n    defs->builtins = array_create (sizeof (BUILTIN_DESC *));\n\n  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));\n  new->name = name;\n  new->function = (char *)NULL;\n  new->shortdoc = (char *)NULL;\n  new->docname = (char *)NULL;\n  new->longdoc = (ARRAY *)NULL;\n  new->dependencies = (ARRAY *)NULL;\n  new->flags = 0;\n\n  if (is_special_builtin (name))\n    new->flags |= BUILTIN_FLAG_SPECIAL;\n  if (is_assignment_builtin (name))\n    new->flags |= BUILTIN_FLAG_ASSIGNMENT;\n  if (is_localvar_builtin (name))\n    new->flags |= BUILTIN_FLAG_LOCALVAR;\n  if (is_posix_builtin (name))\n    new->flags |= BUILTIN_FLAG_POSIX_BUILTIN;\n  if (is_arrayvar_builtin (name))\n    new->flags |= BUILTIN_FLAG_ARRAYREF_ARG;\n\n  array_add ((char *)new, defs->builtins);\n  building_builtin = 1;\n\n  return (0);\n}\n\n \nint\nfunction_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  register BUILTIN_DESC *builtin;\n\n  builtin = current_builtin (self, defs);\n\n  if (builtin == 0)\n    {\n      line_error (defs, \"syntax error: no current builtin for $FUNCTION directive\");\n      exit (1);\n    }\n  if (builtin->function)\n    line_error (defs, \"%s already has a function (%s)\",\n\t\tbuiltin->name, builtin->function);\n  else\n    builtin->function = get_arg (self, defs, arg);\n\n  return (0);\n}\n\n \nint\ndocname_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  register BUILTIN_DESC *builtin;\n\n  builtin = current_builtin (self, defs);\n\n  if (builtin->docname)\n    line_error (defs, \"%s already had a docname (%s)\",\n\t\tbuiltin->name, builtin->docname);\n  else\n    builtin->docname = get_arg (self, defs, arg);\n\n  return (0);\n}\n\n \nint\nshort_doc_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  register BUILTIN_DESC *builtin;\n\n  builtin = current_builtin (self, defs);\n\n  if (builtin->shortdoc)\n    line_error (defs, \"%s already has short documentation (%s)\",\n\t\tbuiltin->name, builtin->shortdoc);\n  else\n    builtin->shortdoc = get_arg (self, defs, arg);\n\n  return (0);\n}\n\n \nint\ncomment_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  return (0);\n}\n\n \nint\ndepends_on_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  register BUILTIN_DESC *builtin;\n  char *dependent;\n\n  builtin = current_builtin (self, defs);\n  dependent = get_arg (self, defs, arg);\n\n  if (!builtin->dependencies)\n    builtin->dependencies = array_create (sizeof (char *));\n\n  array_add (dependent, builtin->dependencies);\n\n  return (0);\n}\n\n \nint\nproduces_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n   \n  if (only_documentation)\n    return (0);\n\n  output_cpp_line_info++;\n\n  if (defs->production)\n    line_error (defs, \"%s already has a %s definition\", defs->filename, self);\n  else\n    {\n      defs->production = get_arg (self, defs, arg);\n\n      if (inhibit_production)\n\treturn (0);\n\n      defs->output = fopen (defs->production, \"w\");\n\n      if (!defs->output)\n\tfile_error (defs->production);\n\n      fprintf (defs->output, \"/* %s, created from %s. */\\n\",\n\t       defs->production, defs->filename);\n    }\n  return (0);\n}\n\n \nint\nend_handler (self, defs, arg)\n     char *self;\n     DEF_FILE *defs;\n     char *arg;\n{\n  must_be_building (self, defs);\n  building_builtin = 0;\n  return (0);\n}\n\n \n \n \n \n \n\n \nvoid\nline_error (defs, format, arg1, arg2)\n     DEF_FILE *defs;\n     char *format, *arg1, *arg2;\n{\n  if (defs->filename[0] != '/')\n    fprintf (stderr, \"%s\", error_directory ? error_directory : \"./\");\n  fprintf (stderr, \"%s:%d:\", defs->filename, defs->line_number + 1);\n  fprintf (stderr, format, arg1, arg2);\n  fprintf (stderr, \"\\n\");\n  fflush (stderr);\n}\n\n \nvoid\nfile_error (filename)\n     char *filename;\n{\n  perror (filename);\n  exit (2);\n}\n\n \n \n \n \n \n\nstatic void memory_error_and_abort ();\n\nstatic char *\nxmalloc (bytes)\n     int bytes;\n{\n  char *temp = (char *)malloc (bytes);\n\n  if (!temp)\n    memory_error_and_abort ();\n  return (temp);\n}\n\nstatic char *\nxrealloc (pointer, bytes)\n     char *pointer;\n     int bytes;\n{\n  char *temp;\n\n  if (!pointer)\n    temp = (char *)malloc (bytes);\n  else\n    temp = (char *)realloc (pointer, bytes);\n\n  if (!temp)\n    memory_error_and_abort ();\n\n  return (temp);\n}\n\nstatic void\nmemory_error_and_abort ()\n{\n  fprintf (stderr, \"mkbuiltins: out of virtual memory\\n\");\n  abort ();\n}\n\n \n \n \n \n \n\n \nBUILTIN_DESC *\ncopy_builtin (builtin)\n     BUILTIN_DESC *builtin;\n{\n  BUILTIN_DESC *new;\n\n  new = (BUILTIN_DESC *)xmalloc (sizeof (BUILTIN_DESC));\n\n  new->name = savestring (builtin->name);\n  new->shortdoc = savestring (builtin->shortdoc);\n  new->longdoc = copy_string_array (builtin->longdoc);\n  new->dependencies = copy_string_array (builtin->dependencies);\n\n  new->function =\n    builtin->function ? savestring (builtin->function) : (char *)NULL;\n  new->docname =\n    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;\n\n  return (new);\n}\n\n \nvoid\nsave_builtin (builtin)\n     BUILTIN_DESC *builtin;\n{\n  BUILTIN_DESC *newbuiltin;\n\n  newbuiltin = copy_builtin (builtin);\n\n   \n  if (!saved_builtins)\n      saved_builtins = array_create (sizeof (BUILTIN_DESC *));\n\n  array_add ((char *)newbuiltin, saved_builtins);\n}\n\n \n#define STRING_ARRAY\t0x01\n#define TEXINFO\t\t0x02\n#define PLAINTEXT\t0x04\n#define HELPFILE\t0x08\n\nchar *structfile_header[] = {\n  \"/* builtins.c -- the built in shell commands. */\",\n  \"\",\n  \"/* This file is manufactured by ./mkbuiltins, and should not be\",\n  \"   edited by hand.  See the source to mkbuiltins for details. */\",\n  \"\",\n  \"/* Copyright (C) 1987-2022 Free Software Foundation, Inc.\",\n  \"\",\n  \"   This file is part of GNU Bash, the Bourne Again SHell.\",\n  \"\",\n  \"   Bash is free software: you can redistribute it and/or modify\",\n  \"   it under the terms of the GNU General Public License as published by\",\n  \"   the Free Software Foundation, either version 3 of the License, or\",\n  \"   (at your option) any later version.\",\n  \"\",\n  \"   Bash is distributed in the hope that it will be useful,\",\n  \"   but WITHOUT ANY WARRANTY; without even the implied warranty of\",\n  \"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\",\n  \"   GNU General Public License for more details.\",\n  \"\",\n  \"   You should have received a copy of the GNU General Public License\",\n  \"   along with Bash.  If not, see <http://www.gnu.org/licenses/>.\",\n  \"*/\",\n  \"\",\n  \"/* The list of shell builtins.  Each element is name, function, flags,\",\n  \"   long-doc, short-doc.  The long-doc field contains a pointer to an array\",\n  \"   of help lines.  The function takes a WORD_LIST *; the first word in the\",\n  \"   list is the first arg to the command.  The list has already had word\",\n  \"   expansion performed.\",\n  \"\",\n  \"   Functions which need to look at only the simple commands (e.g.\",\n  \"   the enable_builtin ()), should ignore entries where\",\n  \"   (array[i].function == (sh_builtin_func_t *)NULL).  Such entries are for\",\n  \"   the list of shell reserved control structures, like `if' and `while'.\",\n  \"   The end of the list is denoted with a NULL name field. */\",\n  \"\",\n  \"/* TRANSLATORS: Please do not translate command names in descriptions */\",\n  \"\",\n  \"#include \\\"../builtins.h\\\"\",\n  (char *)NULL\n  };\n\nchar *structfile_footer[] = {\n  \"  { (char *)0x0, (sh_builtin_func_t *)0x0, 0, (char **)0x0, (char *)0x0, (char *)0x0 }\",\n  \"};\",\n  \"\",\n  \"struct builtin *shell_builtins = static_shell_builtins;\",\n  \"struct builtin *current_builtin;\",\n  \"\",\n  \"int num_shell_builtins =\",\n  \"\\tsizeof (static_shell_builtins) / sizeof (struct builtin) - 1;\",\n  (char *)NULL\n};\n\n \nvoid\nwrite_file_headers (structfile, externfile)\n     FILE *structfile, *externfile;\n{\n  register int i;\n\n  if (structfile)\n    {\n      for (i = 0; structfile_header[i]; i++)\n\tfprintf (structfile, \"%s\\n\", structfile_header[i]);\n\n      fprintf (structfile, \"#include \\\"%s\\\"\\n\",\n\t       include_filename ? include_filename : \"builtext.h\");\n\n      fprintf (structfile, \"#include \\\"bashintl.h\\\"\\n\");\n\n      fprintf (structfile, \"\\nstruct builtin static_shell_builtins[] = {\\n\");\n    }\n\n  if (externfile)\n    fprintf (externfile,\n\t     \"/* %s - The list of builtins found in libbuiltins.a. */\\n\",\n\t     include_filename ? include_filename : \"builtext.h\");\n}\n\n \nvoid\nwrite_file_footers (structfile, externfile)\n     FILE *structfile, *externfile;\n{\n  register int i;\n\n   \n  if (structfile)\n    {\n      for (i = 0; structfile_footer[i]; i++)\n\tfprintf (structfile, \"%s\\n\", structfile_footer[i]);\n    }\n}\n\n \nvoid\nwrite_builtins (defs, structfile, externfile)\n     DEF_FILE *defs;\n     FILE *structfile, *externfile;\n{\n  register int i;\n\n   \n  if (defs->builtins)\n    {\n      register BUILTIN_DESC *builtin;\n\n      for (i = 0; i < defs->builtins->sindex; i++)\n\t{\n\t  builtin = (BUILTIN_DESC *)defs->builtins->array[i];\n\n\t   \n\t  if (!only_documentation)\n\t    {\n\t      if (builtin->dependencies)\n\t\t{\n\t\t  write_ifdefs (externfile, builtin->dependencies->array);\n\t\t  write_ifdefs (structfile, builtin->dependencies->array);\n\t\t}\n\n\t       \n\t      if (externfile)\n\t\t{\n\t\t  if (builtin->function)\n\t\t    fprintf (externfile, \"extern int %s PARAMS((WORD_LIST *));\\n\",\n\t\t\t     builtin->function);\n\n\t\t  fprintf (externfile, \"extern char * const %s_doc[];\\n\",\n\t\t\t   document_name (builtin));\n\t\t}\n\n\t       \n\t      if (structfile)\n\t\t{\n\t\t  fprintf (structfile, \"  { \\\"%s\\\", \", builtin->name);\n\n\t\t  if (builtin->function && inhibit_functions == 0)\n\t\t    fprintf (structfile, \"%s, \", builtin->function);\n\t\t  else\n\t\t    fprintf (structfile, \"(sh_builtin_func_t *)0x0, \");\n\n\t\t  fprintf (structfile, \"%s%s%s%s%s%s, %s_doc,\\n\",\n\t\t    \"BUILTIN_ENABLED | STATIC_BUILTIN\",\n\t\t    (builtin->flags & BUILTIN_FLAG_SPECIAL) ? \" | SPECIAL_BUILTIN\" : \"\",\n\t\t    (builtin->flags & BUILTIN_FLAG_ASSIGNMENT) ? \" | ASSIGNMENT_BUILTIN\" : \"\",\n\t\t    (builtin->flags & BUILTIN_FLAG_LOCALVAR) ? \" | LOCALVAR_BUILTIN\" : \"\",\n\t\t    (builtin->flags & BUILTIN_FLAG_POSIX_BUILTIN) ? \" | POSIX_BUILTIN\" : \"\",\n\t\t    (builtin->flags & BUILTIN_FLAG_ARRAYREF_ARG) ? \" | ARRAYREF_BUILTIN\" : \"\",\n\t\t    document_name (builtin));\n\n\t\t   \n\t\t  if (builtin->shortdoc && strcmp (builtin->name, builtin->shortdoc) == 0)\n\t\t    {\n\t\t      if (inhibit_functions)\n\t\t\tfprintf (structfile, \"     \\\"%s\\\", \\\"%s\\\" },\\n\",\n\t\t\t  builtin->shortdoc ? builtin->shortdoc : builtin->name,\n\t\t\t  document_name (builtin));\n\t\t      else\n\t\t\tfprintf (structfile, \"     \\\"%s\\\", (char *)NULL },\\n\",\n\t\t\t  builtin->shortdoc ? builtin->shortdoc : builtin->name);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (inhibit_functions)\n\t\t\tfprintf (structfile, \"     N_(\\\"%s\\\"), \\\"%s\\\" },\\n\",\n\t\t\t  builtin->shortdoc ? builtin->shortdoc : builtin->name,\n\t\t\t  document_name (builtin));\n\t\t      else\n\t\t\tfprintf (structfile, \"     N_(\\\"%s\\\"), (char *)NULL },\\n\",\n\t\t\t  builtin->shortdoc ? builtin->shortdoc : builtin->name);\n\t\t    }\n\t\t}\n\n\t      if (structfile || separate_helpfiles)\n\t\t \n\t\tsave_builtin (builtin);\n\n\t       \n\t      if (builtin->dependencies)\n\t\t{\n\t\t  if (externfile)\n\t\t    write_endifs (externfile, builtin->dependencies->array);\n\n\t\t  if (structfile)\n\t\t    write_endifs (structfile, builtin->dependencies->array);\n\t\t}\n\t    }\n\n\t  if (documentation_file)\n\t    {\n\t      fprintf (documentation_file, \"@item %s\\n\", builtin->name);\n\t      write_documentation\n\t\t(documentation_file, builtin->longdoc->array, 0, TEXINFO);\n\t    }\n\t}\n    }\n}\n\n \nvoid\nwrite_longdocs (stream, builtins)\n     FILE *stream;\n     ARRAY *builtins;\n{\n  register int i;\n  register BUILTIN_DESC *builtin;\n  char *dname;\n  char *sarray[2];\n\n  for (i = 0; i < builtins->sindex; i++)\n    {\n      builtin = (BUILTIN_DESC *)builtins->array[i];\n\n      if (builtin->dependencies)\n\twrite_ifdefs (stream, builtin->dependencies->array);\n\n       \n      dname = document_name (builtin);\n      fprintf (stream, \"char * const %s_doc[] =\", dname);\n\n      if (separate_helpfiles)\n\t{\n\t  int l = strlen (helpfile_directory) + strlen (dname) + 1;\n\t  sarray[0] = (char *)xmalloc (l + 1);\n\t  sprintf (sarray[0], \"%s/%s\", helpfile_directory, dname);\n\t  sarray[1] = (char *)NULL;\n\t  write_documentation (stream, sarray, 0, STRING_ARRAY|HELPFILE);\n\t  free (sarray[0]);\n\t}\n      else\n\twrite_documentation (stream, builtin->longdoc->array, 0, STRING_ARRAY);\n\n      if (builtin->dependencies)\n\twrite_endifs (stream, builtin->dependencies->array);\n\n    }\n}\n\nvoid\nwrite_dummy_declarations (stream, builtins)\n     FILE *stream;\n     ARRAY *builtins;\n{\n  register int i;\n  BUILTIN_DESC *builtin;\n\n  for (i = 0; structfile_header[i]; i++)\n    fprintf (stream, \"%s\\n\", structfile_header[i]);\n\n  for (i = 0; i < builtins->sindex; i++)\n    {\n      builtin = (BUILTIN_DESC *)builtins->array[i];\n\n       \n      fprintf (stream, \"int %s () { return (0); }\\n\", builtin->function);\n    }\n}\n\n \nvoid\nwrite_ifdefs (stream, defines)\n     FILE *stream;\n     char **defines;\n{\n  register int i;\n\n  if (!stream)\n    return;\n\n  fprintf (stream, \"#if \");\n\n  for (i = 0; defines[i]; i++)\n    {\n      char *def = defines[i];\n\n      if (*def == '!')\n\tfprintf (stream, \"!defined (%s)\", def + 1);\n      else\n\tfprintf (stream, \"defined (%s)\", def);\n\n      if (defines[i + 1])\n\tfprintf (stream, \" && \");\n    }\n  fprintf (stream, \"\\n\");\n}\n\n \nvoid\nwrite_endifs (stream, defines)\n     FILE *stream;\n     char **defines;\n{\n  register int i;\n\n  if (!stream)\n    return;\n\n  fprintf (stream, \"#endif /* \");\n\n  for (i = 0; defines[i]; i++)\n    {\n      fprintf (stream, \"%s\", defines[i]);\n\n      if (defines[i + 1])\n\tfprintf (stream, \" && \");\n    }\n\n  fprintf (stream, \" */\\n\");\n}\n\n \nvoid\nwrite_documentation (stream, documentation, indentation, flags)\n     FILE *stream;\n     char **documentation;\n     int indentation, flags;\n{\n  register int i, j;\n  register char *line;\n  int string_array, texinfo, base_indent, filename_p;\n\n  if (stream == 0)\n    return;\n\n  string_array = flags & STRING_ARRAY;\n  filename_p = flags & HELPFILE;\n\n  if (string_array)\n    {\n      fprintf (stream, \" {\\n#if defined (HELP_BUILTIN)\\n\");\t \n      if (single_longdoc_strings)\n\t{\n\t  if (filename_p == 0)\n\t    {\n\t      if (documentation && documentation[0] && documentation[0][0])\n\t\tfprintf (stream,  \"N_(\\\"\");\n\t      else\n\t\tfprintf (stream, \"N_(\\\" \");\t\t \n\t    }\n\t  else\n\t    fprintf (stream, \"\\\"\");\n\t}\n    }\n\n  base_indent = (string_array && single_longdoc_strings && filename_p == 0) ? BASE_INDENT : 0;\n\n  for (i = 0, texinfo = (flags & TEXINFO); documentation && (line = documentation[i]); i++)\n    {\n       \n      if (*line == '#')\n\t{\n\t  if (string_array && filename_p == 0 && single_longdoc_strings == 0)\n\t    fprintf (stream, \"%s\\n\", line);\n\t  continue;\n\t}\n\n       \n      if (string_array && single_longdoc_strings == 0)\n\t{\n\t  if (filename_p == 0)\n\t    {\n\t      if (line[0])\t      \n\t\tfprintf (stream, \"  N_(\\\"\");\n\t      else\n\t\tfprintf (stream, \"  N_(\\\" \");\t\t \n\t    }\n\t  else\n\t    fprintf (stream, \"  \\\"\");\n\t}\n\n      if (indentation)\n\tfor (j = 0; j < indentation; j++)\n\t  fprintf (stream, \" \");\n\n       \n      if (i == 0)\n\tindentation += base_indent;\n\n      if (string_array)\n\t{\n\t  for (j = 0; line[j]; j++)\n\t    {\n\t      switch (line[j])\n\t\t{\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t  fprintf (stream, \"\\\\%c\", line[j]);\n\t\t  break;\n\n\t\tdefault:\n\t\t  fprintf (stream, \"%c\", line[j]);\n\t\t}\n\t    }\n\n\t   \n\t  if (single_longdoc_strings == 0)\n\t    {\n\t      if (filename_p == 0)\n\t\tfprintf (stream, \"\\\"),\\n\");\n\t      else\n\t\tfprintf (stream, \"\\\",\\n\");\n\t    }\n\t  else if (documentation[i+1])\n\t     \n\t    fprintf (stream, \"\\\\n\\\\\\n\");\n\t}\n      else if (texinfo)\n\t{\n\t  for (j = 0; line[j]; j++)\n\t    {\n\t      switch (line[j])\n\t\t{\n\t\tcase '@':\n\t\tcase '{':\n\t\tcase '}':\n\t\t  fprintf (stream, \"@%c\", line[j]);\n\t\t  break;\n\n\t\tdefault:\n\t\t  fprintf (stream, \"%c\", line[j]);\n\t\t}\n\t    }\n\t  fprintf (stream, \"\\n\");\n\t}\n      else\n\tfprintf (stream, \"%s\\n\", line);\n    }\n\n   \n  if (string_array && single_longdoc_strings)\n    {\n      if (filename_p == 0)\n\tfprintf (stream, \"\\\"),\\n\");\n      else\n\tfprintf (stream, \"\\\",\\n\");\n    }\n\n  if (string_array)\n    fprintf (stream, \"#endif /* HELP_BUILTIN */\\n  (char *)NULL\\n};\\n\");\n}\n\nint\nwrite_helpfiles (builtins)\n     ARRAY *builtins;\n{\n  char *helpfile, *bname;\n  FILE *helpfp;\n  int i, hdlen;\n  BUILTIN_DESC *builtin;\t\n\n  i = mkdir (\"helpfiles\", 0777);\n  if (i < 0 && errno != EEXIST)\n    {\n      fprintf (stderr, \"write_helpfiles: helpfiles: cannot create directory\\n\");\n      return -1;\n    }\n\n  hdlen = strlen (\"helpfiles/\");\n  for (i = 0; i < builtins->sindex; i++)\n    {\n      builtin = (BUILTIN_DESC *)builtins->array[i];\n\n      bname = document_name (builtin);\n      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);\n      sprintf (helpfile, \"helpfiles/%s\", bname);\n\n      helpfp = fopen (helpfile, \"w\");\n      if (helpfp == 0)\n\t{\n\t  fprintf (stderr, \"write_helpfiles: cannot open %s\\n\", helpfile);\n\t  free (helpfile);\n\t  continue;\n\t}\n\n      write_documentation (helpfp, builtin->longdoc->array, 4, PLAINTEXT);\n\n      fflush (helpfp);\n      fclose (helpfp);\n      free (helpfile);\n    }\n  return 0;\n}      \n      \t        \nstatic int\n_find_in_table (name, name_table)\n     char *name, *name_table[];\n{\n  register int i;\n\n  for (i = 0; name_table[i]; i++)\n    if (strcmp (name, name_table[i]) == 0)\n      return 1;\n  return 0;\n}\n\nstatic int\nis_special_builtin (name)\n     char *name;\n{\n  return (_find_in_table (name, special_builtins));\n}\n\nstatic int\nis_assignment_builtin (name)\n     char *name;\n{\n  return (_find_in_table (name, assignment_builtins));\n}\n\nstatic int\nis_localvar_builtin (name)\n     char *name;\n{\n  return (_find_in_table (name, localvar_builtins));\n}\n\nstatic int\nis_posix_builtin (name)\n     char *name;\n{\n  return (_find_in_table (name, posix_builtins));\n}\n\nstatic int\nis_arrayvar_builtin (name)\n     char *name;\n{\n  return (_find_in_table (name, arrayvar_builtins));\n}\n\n#if !defined (HAVE_RENAME)\nstatic int\nrename (from, to)\n     char *from, *to;\n{\n  unlink (to);\n  if (link (from, to) < 0)\n    return (-1);\n  unlink (from);\n  return (0);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}