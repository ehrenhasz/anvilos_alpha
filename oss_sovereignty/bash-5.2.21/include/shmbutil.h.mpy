{
  "module_name": "shmbutil.h",
  "hash_id": "9fae1b6a29c075ba2d257aa7a3ab5d21a8f28526b4611fe306c868eb347cee08",
  "original_prompt": "Ingested from bash-5.2.21/include/shmbutil.h",
  "human_readable_source": " \n\n \n                                 \n#if !defined (_SH_MBUTIL_H_)\n#define _SH_MBUTIL_H_\n\n#include \"stdc.h\"\n\n \n#include <config.h>\n\n#if defined (HANDLE_MULTIBYTE)\n#include \"shmbchar.h\"\n\nextern size_t xwcsrtombs PARAMS((char *, const wchar_t **, size_t, mbstate_t *));\nextern size_t xmbsrtowcs PARAMS((wchar_t *, const char **, size_t, mbstate_t *));\nextern size_t xdupmbstowcs PARAMS((wchar_t **, char ***, const char *));\n\nextern size_t mbstrlen PARAMS((const char *));\n\nextern char *xstrchr PARAMS((const char *, int));\n\nextern int locale_mb_cur_max;\t \nextern int locale_utf8locale;\t \n\n#ifndef MB_INVALIDCH\n#define MB_INVALIDCH(x)\t\t((x) == (size_t)-1 || (x) == (size_t)-2)\n#define MB_NULLWCH(x)\t\t((x) == 0)\n#endif\n\n#define MBSLEN(s)\t(((s) && (s)[0]) ? ((s)[1] ? mbstrlen (s) : 1) : 0)\n#define MB_STRLEN(s)\t((MB_CUR_MAX > 1) ? MBSLEN (s) : STRLEN (s))\n\n#define MBLEN(s, n)\t((MB_CUR_MAX > 1) ? mblen ((s), (n)) : 1)\n#define MBRLEN(s, n, p)\t((MB_CUR_MAX > 1) ? mbrlen ((s), (n), (p)) : 1)\n\n#define UTF8_SINGLEBYTE(c)\t(((c) & 0x80) == 0)\n#define UTF8_MBFIRSTCHAR(c)\t(((c) & 0xc0) == 0xc0)\n#define UTF8_MBCHAR(c)\t\t(((c) & 0xc0) == 0x80)\n\n#else  \n\n#undef MB_LEN_MAX\n#undef MB_CUR_MAX\n\n#define MB_LEN_MAX\t1\n#define MB_CUR_MAX\t1\n\n#undef xstrchr\n#define xstrchr(s, c)\tstrchr(s, c)\n\n#ifndef MB_INVALIDCH\n#define MB_INVALIDCH(x)\t\t(0)\n#define MB_NULLWCH(x)\t\t(0)\n#endif\n\n#define MB_STRLEN(s)\t\t(STRLEN(s))\n\n#define MBLEN(s, n)\t\t1\n#define MBRLEN(s, n, p)\t\t1\n\n#ifndef wchar_t\n#  define wchar_t\tint\n#endif\n\n#define UTF8_SINGLEBYTE(c)\t(1)\n#define UTF8_MBFIRSTCHAR(c)\t(0)\n\n#endif  \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define DECLARE_MBSTATE \\\n\tmbstate_t state; \\\n\tmemset (&state, '\\0', sizeof (mbstate_t))\n#else\n#  define DECLARE_MBSTATE\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define INITIALIZE_MBSTATE memset (&state, '\\0', sizeof (mbstate_t))\n#else\n#  define INITIALIZE_MBSTATE\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define ADVANCE_CHAR(_str, _strsize, _i) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _f; \\\n\\\n\t    _f = is_basic ((_str)[_i]); \\\n\t    if (_f) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && (((_str)[_i] & 0x80) == 0)) \\\n\t      mblength = (_str)[_i] != 0; \\\n\t    else \\\n\t      { \\\n\t        state_bak = state; \\\n\t        mblength = mbrlen ((_str) + (_i), (_strsize) - (_i), &state); \\\n\t      } \\\n\\\n\t    if (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\t(_i)++; \\\n\t      } \\\n\t    else if (mblength == 0) \\\n\t      (_i)++; \\\n\t    else \\\n\t      (_i) += mblength; \\\n\t  } \\\n\telse \\\n\t  (_i)++; \\\n      } \\\n    while (0)\n#else\n#  define ADVANCE_CHAR(_str, _strsize, _i)\t(_i)++\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define ADVANCE_CHAR_P(_str, _strsize) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _f; \\\n\\\n\t    _f = is_basic (*(_str)); \\\n\t    if (_f) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && ((*(_str) & 0x80) == 0)) \\\n\t      mblength = *(_str) != 0; \\\n\t    else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_str), (_strsize), &state); \\\n\t      } \\\n\\\n\t    if (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    else \\\n\t      (_str) += (mblength < 1) ? 0 : (mblength - 1); \\\n\t  } \\\n      } \\\n    while (0)\n#else\n#  define ADVANCE_CHAR_P(_str, _strsize)\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define BACKUP_CHAR(_str, _strsize, _i) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _x, _p;   \\\n\\\n\t    _x = _p = 0; \\\n\t    while (_x < (_i)) \\\n\t      { \\\n\t        state_bak = state; \\\n\t        mblength = mbrlen ((_str) + (_x), (_strsize) - (_x), &state); \\\n\\\n\t\tif (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t\t  { \\\n\t\t    state = state_bak; \\\n\t\t    _x++; \\\n\t\t  } \\\n\t\telse if (mblength == 0) \\\n\t\t  _x++; \\\n\t\telse \\\n\t\t  { \\\n\t\t    _p = _x;   \\\n\t\t    _x += mblength; \\\n\t\t  } \\\n\t      } \\\n\t    (_i) = _p; \\\n\t  } \\\n\telse \\\n\t  (_i)--; \\\n      } \\\n    while (0)\n#else\n#  define BACKUP_CHAR(_str, _strsize, _i)\t(_i)--\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define BACKUP_CHAR_P(_base, _strsize, _str) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    char *_x, _p;   \\\n\\\n\t    _x = _p = _base; \\\n\t    while (_x < (_str)) \\\n\t      { \\\n\t        state_bak = state; \\\n\t        mblength = mbrlen (_x, (_strsize) - _x, &state); \\\n\\\n\t\tif (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t\t  { \\\n\t\t    state = state_bak; \\\n\t\t    _x++; \\\n\t\t  } \\\n\t\telse if (mblength == 0) \\\n\t\t  _x++; \\\n\t\telse \\\n\t\t  { \\\n\t\t    _p = _x;   \\\n\t\t    _x += mblength; \\\n\t\t  } \\\n\t      } \\\n\t    (_str) = _p; \\\n\t  } \\\n\telse \\\n\t  (_str)--; \\\n      } \\\n    while (0)\n#else\n#  define BACKUP_CHAR_P(_base, _strsize, _str) (_str)--\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define COPY_CHAR_P(_dst, _src, _srcend) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _k; \\\n\\\n\t    _k = is_basic (*(_src)); \\\n\t    if (_k) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && ((*(_src) & 0x80) == 0)) \\\n\t      mblength = *(_src) != 0; \\\n\t    else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src), (_srcend) - (_src), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    else \\\n\t      mblength = (mblength < 1) ? 1 : mblength; \\\n\\\n\t    for (_k = 0; _k < mblength; _k++) \\\n\t      *(_dst)++ = *(_src)++; \\\n\t  } \\\n\telse \\\n\t  *(_dst)++ = *(_src)++; \\\n      } \\\n    while (0)\n#else\n#  define COPY_CHAR_P(_dst, _src, _srcend)\t*(_dst)++ = *(_src)++\n#endif   \n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define COPY_CHAR_I(_dst, _di, _src, _srcend, _si) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _k; \\\n\\\n\t    _k = is_basic ((_src)[(_si)]); \\\n\t    if (_k) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && ((_src)[(_si)] & 0x80) == 0) \\\n\t      mblength = (_src)[(_si)] != 0; \\\n\t    else \\\n\t      {\\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src) + (_si), (_srcend) - ((_src)+(_si)), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    else \\\n\t      mblength = (mblength < 1) ? 1 : mblength; \\\n\\\n\t    for (_k = 0; _k < mblength; _k++) \\\n\t      _dst[_di++] = _src[_si++]; \\\n\t  } \\\n\telse \\\n\t  _dst[_di++] = _src[_si++]; \\\n      } \\\n    while (0)\n#else\n#  define COPY_CHAR_I(_dst, _di, _src, _srcend, _si)\t_dst[_di++] = _src[_si++]\n#endif   \n\n \n\n#if defined (HANDLE_MULTIBYTE)\n#  define SCOPY_CHAR_I(_dst, _escchar, _sc, _src, _si, _slen) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _i; \\\n\\\n\t    _i = is_basic ((_src)[(_si)]); \\\n\t    if (_i) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && ((_src)[(_si)] & 0x80) == 0) \\\n\t      mblength = (_src)[(_si)] != 0; \\\n\t    else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src) + (_si), (_slen) - (_si), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    else \\\n\t      mblength = (mblength < 1) ? 1 : mblength; \\\n\\\n\t    temp = xmalloc (mblength + 2); \\\n\t    temp[0] = _escchar; \\\n\t    for (_i = 0; _i < mblength; _i++) \\\n\t      temp[_i + 1] = _src[_si++]; \\\n\t    temp[mblength + 1] = '\\0'; \\\n\\\n\t    goto add_string; \\\n\t  } \\\n\telse \\\n\t  { \\\n\t    _dst[0] = _escchar; \\\n\t    _dst[1] = _sc; \\\n\t  } \\\n      } \\\n    while (0)\n#else\n#  define SCOPY_CHAR_I(_dst, _escchar, _sc, _src, _si, _slen) \\\n    _dst[0] = _escchar; \\\n    _dst[1] = _sc\n#endif   \n\n#if defined (HANDLE_MULTIBYTE)\n#  define SCOPY_CHAR_M(_dst, _src, _srcend, _si) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\t    int _i; \\\n\\\n\t    _i = is_basic (*((_src) + (_si))); \\\n\t    if (_i) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && (((_src)[_si] & 0x80) == 0)) \\\n              mblength = (_src)[_si] != 0; \\\n\t    else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src) + (_si), (_srcend) - ((_src) + (_si)), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-2 || mblength == (size_t)-1) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    else \\\n\t      mblength = (mblength < 1) ? 1 : mblength; \\\n\\\n\t    FASTCOPY(((_src) + (_si)), (_dst), mblength); \\\n\\\n\t    (_dst) += mblength; \\\n\t    (_si) += mblength; \\\n\t  } \\\n\telse \\\n\t  { \\\n\t    *(_dst)++ = _src[(_si)]; \\\n\t    (_si)++; \\\n\t  } \\\n      } \\\n    while (0)\n#else\n#  define SCOPY_CHAR_M(_dst, _src, _srcend, _si) \\\n\t*(_dst)++ = _src[(_si)]; \\\n\t(_si)++\n#endif   \n\n#if HANDLE_MULTIBYTE\n#  define SADD_MBCHAR(_dst, _src, _si, _srcsize) \\\n    do \\\n      { \\\n\tif (locale_mb_cur_max > 1) \\\n\t  { \\\n\t    int i; \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\\\n\t    i = is_basic (*((_src) + (_si))); \\\n\t    if (i) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && (((_src)[_si] & 0x80) == 0)) \\\n\t      mblength = (_src)[_si] != 0; \\\n\t    else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src) + (_si), (_srcsize) - (_si), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-1 || mblength == (size_t)-2) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    if (mblength < 1) \\\n\t      mblength = 1; \\\n\\\n\t    _dst = (char *)xmalloc (mblength + 1); \\\n\t    for (i = 0; i < mblength; i++) \\\n\t      (_dst)[i] = (_src)[(_si)++]; \\\n\t    (_dst)[mblength] = '\\0'; \\\n\\\n\t    goto add_string; \\\n\t  } \\\n      } \\\n    while (0)\n\n#else\n#  define SADD_MBCHAR(_dst, _src, _si, _srcsize)\n#endif\n\n \n#if defined (HANDLE_MULTIBYTE)\n#  define SADD_MBQCHAR_BODY(_dst, _src, _si, _srcsize) \\\n\\\n\t    int i; \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\\\n\t    i = is_basic (*((_src) + (_si))); \\\n\t    if (i) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && (((_src)[_si] & 0x80) == 0)) \\\n\t      mblength = (_src)[_si] != 0; \\\n\t    else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src) + (_si), (_srcsize) - (_si), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-1 || mblength == (size_t)-2) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    if (mblength < 1) \\\n\t      mblength = 1; \\\n\\\n\t    (_dst) = (char *)xmalloc (mblength + 2); \\\n\t    (_dst)[0] = CTLESC; \\\n\t    for (i = 0; i < mblength; i++) \\\n\t      (_dst)[i+1] = (_src)[(_si)++]; \\\n\t    (_dst)[mblength+1] = '\\0'; \\\n\\\n\t    goto add_string\n\n#  define SADD_MBCHAR_BODY(_dst, _src, _si, _srcsize) \\\n\\\n\t    int i; \\\n\t    mbstate_t state_bak; \\\n\t    size_t mblength; \\\n\\\n\t    i = is_basic (*((_src) + (_si))); \\\n\t    if (i) \\\n\t      mblength = 1; \\\n\t    else if (locale_utf8locale && (((_src)[_si] & 0x80) == 0)) \\\n              mblength = (_src)[_si] != 0; \\\n            else \\\n\t      { \\\n\t\tstate_bak = state; \\\n\t\tmblength = mbrlen ((_src) + (_si), (_srcsize) - (_si), &state); \\\n\t      } \\\n\t    if (mblength == (size_t)-1 || mblength == (size_t)-2) \\\n\t      { \\\n\t\tstate = state_bak; \\\n\t\tmblength = 1; \\\n\t      } \\\n\t    if (mblength < 1) \\\n\t      mblength = 1; \\\n\\\n\t    (_dst) = (char *)xmalloc (mblength + 1); \\\n\t    for (i = 0; i < mblength; i++) \\\n\t      (_dst)[i+1] = (_src)[(_si)++]; \\\n\t    (_dst)[mblength+1] = '\\0'; \\\n\\\n\t    goto add_string\n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}