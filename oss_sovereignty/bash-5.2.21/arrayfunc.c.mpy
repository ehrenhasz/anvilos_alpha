{
  "module_name": "arrayfunc.c",
  "hash_id": "5b4b11a96c293a1567ca1f8225615d807bf9e29fe4aefc3121146817f0ffab19",
  "original_prompt": "Ingested from bash-5.2.21/arrayfunc.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (ARRAY_VARS)\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n#include <stdio.h>\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"pathexp.h\"\n\n#include \"shmbutil.h\"\n#if defined (HAVE_MBSTR_H) && defined (HAVE_MBSCHR)\n#  include <mbstr.h>\t\t \n#endif\n\n#include \"builtins/common.h\"\n\n#ifndef LBRACK\n#  define LBRACK '['\n#  define RBRACK ']'\n#endif\n\n \nint assoc_expand_once = 0;\n\n \nint array_expand_once = 0;\n\nstatic SHELL_VAR *bind_array_var_internal PARAMS((SHELL_VAR *, arrayind_t, char *, char *, int));\nstatic SHELL_VAR *assign_array_element_internal PARAMS((SHELL_VAR *, char *, char *, char *, int, char *, int, array_eltstate_t *));\n\nstatic void assign_assoc_from_kvlist PARAMS((SHELL_VAR *, WORD_LIST *, HASH_TABLE *, int));\n\nstatic char *quote_assign PARAMS((const char *));\nstatic void quote_array_assignment_chars PARAMS((WORD_LIST *));\nstatic char *quote_compound_array_word PARAMS((char *, int));\nstatic char *array_value_internal PARAMS((const char *, int, int, array_eltstate_t *));\n\n \nconst char * const bash_badsub_errmsg = N_(\"bad array subscript\");\n\n \n \n \n \n \n\n \nSHELL_VAR *\nconvert_var_to_array (var)\n     SHELL_VAR *var;\n{\n  char *oldval;\n  ARRAY *array;\n\n  oldval = value_cell (var);\n  array = array_create ();\n  if (oldval)\n    array_insert (array, 0, oldval);\n\n  FREE (value_cell (var));\n  var_setarray (var, array);\n\n   \n  var->dynamic_value = (sh_var_value_func_t *)NULL;\n  var->assign_func = (sh_var_assign_func_t *)NULL;\n\n  INVALIDATE_EXPORTSTR (var);\n  if (exported_p (var))\n    array_needs_making++;\n\n  VSETATTR (var, att_array);\n  if (oldval)\n    VUNSETATTR (var, att_invisible);\n\n   \n  VUNSETATTR (var, att_assoc);\n\n   \n  VUNSETATTR (var, att_nameref);\n\n  return var;\n}\n\n \nSHELL_VAR *\nconvert_var_to_assoc (var)\n     SHELL_VAR *var;\n{\n  char *oldval;\n  HASH_TABLE *hash;\n\n  oldval = value_cell (var);\n  hash = assoc_create (0);\n  if (oldval)\n    assoc_insert (hash, savestring (\"0\"), oldval);\n\n  FREE (value_cell (var));\n  var_setassoc (var, hash);\n\n   \n  var->dynamic_value = (sh_var_value_func_t *)NULL;\n  var->assign_func = (sh_var_assign_func_t *)NULL;\n\n  INVALIDATE_EXPORTSTR (var);\n  if (exported_p (var))\n    array_needs_making++;\n\n  VSETATTR (var, att_assoc);\n  if (oldval)\n    VUNSETATTR (var, att_invisible);\n\n   \n  VUNSETATTR (var, att_array);\n\n   \n  VUNSETATTR (var, att_nameref);\n\n  return var;\n}\n\nchar *\nmake_array_variable_value (entry, ind, key, value, flags)\n     SHELL_VAR *entry;\n     arrayind_t ind;\n     char *key;\n     char *value;\n     int flags;\n{\n  SHELL_VAR *dentry;\n  char *newval;\n\n   \n  if (flags & ASS_APPEND)\n    {\n      dentry = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));\n      dentry->name = savestring (entry->name);\n      if (assoc_p (entry))\n\tnewval = assoc_reference (assoc_cell (entry), key);\n      else\n\tnewval = array_reference (array_cell (entry), ind);\n      if (newval)\n\tdentry->value = savestring (newval);\n      else\n\t{\n\t  dentry->value = (char *)xmalloc (1);\n\t  dentry->value[0] = '\\0';\n\t}\n      dentry->exportstr = 0;\n      dentry->attributes = entry->attributes & ~(att_array|att_assoc|att_exported);\n       \n      newval = make_variable_value (dentry, value, flags);\t \n      dispose_variable (dentry);\n    }\n  else\n    newval = make_variable_value (entry, value, flags);\n\n  return newval;\n}\n\n \nstatic SHELL_VAR *\nbind_assoc_var_internal (entry, hash, key, value, flags)\n     SHELL_VAR *entry;\n     HASH_TABLE *hash;\n     char *key;\n     char *value;\n     int flags;\n{\n  char *newval;\n\n   \n  newval = make_array_variable_value (entry, 0, key, value, flags);\n\n  if (entry->assign_func)\n    (*entry->assign_func) (entry, newval, 0, key);\n  else\n    assoc_insert (hash, key, newval);\n\n  FREE (newval);\n\n  VUNSETATTR (entry, att_invisible);\t \n\n   \n  return (entry);\n}\n\n \nstatic SHELL_VAR *\nbind_array_var_internal (entry, ind, key, value, flags)\n     SHELL_VAR *entry;\n     arrayind_t ind;\n     char *key;\n     char *value;\n     int flags;\n{\n  char *newval;\n\n  newval = make_array_variable_value (entry, ind, key, value, flags);\n\n  if (entry->assign_func)\n    (*entry->assign_func) (entry, newval, ind, key);\n  else if (assoc_p (entry))\n    assoc_insert (assoc_cell (entry), key, newval);\n  else\n    array_insert (array_cell (entry), ind, newval);\n  FREE (newval);\n\n  VUNSETATTR (entry, att_invisible);\t \n\n   \n  return (entry);\n}\n\n \nSHELL_VAR *\nbind_array_variable (name, ind, value, flags)\n     char *name;\n     arrayind_t ind;\n     char *value;\n     int flags;\n{\n  SHELL_VAR *entry;\n\n  entry = find_shell_variable (name);\n\n  if (entry == (SHELL_VAR *) 0)\n    {\n       \n      entry = find_variable_nameref_for_create (name, 0);\n      if (entry == INVALID_NAMEREF_VALUE)\n\treturn ((SHELL_VAR *)0);\n      if (entry && nameref_p (entry))\n\tentry = make_new_array_variable (nameref_cell (entry));\n    }\n  if (entry == (SHELL_VAR *) 0)\n    entry = make_new_array_variable (name);\n  else if ((readonly_p (entry) && (flags&ASS_FORCE) == 0) || noassign_p (entry))\n    {\n      if (readonly_p (entry))\n\terr_readonly (name);\n      return (entry);\n    }\n  else if (array_p (entry) == 0)\n    entry = convert_var_to_array (entry);\n\n   \n  return (bind_array_var_internal (entry, ind, 0, value, flags));\n}\n\nSHELL_VAR *\nbind_array_element (entry, ind, value, flags)\n     SHELL_VAR *entry;\n     arrayind_t ind;\n     char *value;\n     int flags;\n{\n  return (bind_array_var_internal (entry, ind, 0, value, flags));\n}\n                    \nSHELL_VAR *\nbind_assoc_variable (entry, name, key, value, flags)\n     SHELL_VAR *entry;\n     char *name;\n     char *key;\n     char *value;\n     int flags;\n{\n  if ((readonly_p (entry) && (flags&ASS_FORCE) == 0) || noassign_p (entry))\n    {\n      if (readonly_p (entry))\n\terr_readonly (name);\n      return (entry);\n    }\n\n  return (bind_assoc_var_internal (entry, assoc_cell (entry), key, value, flags));\n}\n\ninline void\ninit_eltstate (array_eltstate_t *estatep)\n{\n  if (estatep)\n    {\n      estatep->type = ARRAY_INVALID;\n      estatep->subtype = 0;\n      estatep->key = estatep->value = 0;\n      estatep->ind = INTMAX_MIN;\n    }\n}\n\ninline void\nflush_eltstate (array_eltstate_t *estatep)\n{\n  if (estatep)\n    FREE (estatep->key);\n}\n\n \nSHELL_VAR *\nassign_array_element (name, value, flags, estatep)\n     char *name, *value;\n     int flags;\n     array_eltstate_t *estatep;\n{\n  char *sub, *vname;\n  int sublen, isassoc, avflags;\n  SHELL_VAR *entry;\n\n  avflags = 0;\n  if (flags & ASS_NOEXPAND)\n    avflags |= AV_NOEXPAND;\n  if (flags & ASS_ONEWORD)\n    avflags |= AV_ONEWORD;\n  vname = array_variable_name (name, avflags, &sub, &sublen);\n\n  if (vname == 0)\n    return ((SHELL_VAR *)NULL);\n\n  entry = find_variable (vname);\n  isassoc = entry && assoc_p (entry);\n\n   \n  if (((isassoc == 0 || (flags & (ASS_NOEXPAND|ASS_ALLOWALLSUB)) == 0) &&\n\t(ALL_ELEMENT_SUB (sub[0]) && sub[1] == ']')) ||\n      (sublen <= 1) ||\n      (sub[sublen] != '\\0'))\t\t \n    {\n      free (vname);\n      err_badarraysub (name);\n      return ((SHELL_VAR *)NULL);\n    }\n\n  entry = assign_array_element_internal (entry, name, vname, sub, sublen, value, flags, estatep);\n\n#if ARRAY_EXPORT\n  if (entry && exported_p (entry))\n    {\n      INVALIDATE_EXPORTSTR (entry);\n      array_needs_making = 1;\n    }\n#endif\n\n  free (vname);\n  return entry;\n}\n\nstatic SHELL_VAR *\nassign_array_element_internal (entry, name, vname, sub, sublen, value, flags, estatep)\n     SHELL_VAR *entry;\n     char *name;\t\t \n     char *vname;\n     char *sub;\n     int sublen;\n     char *value;\n     int flags;\n     array_eltstate_t *estatep;\n{\n  char *akey, *nkey;\n  arrayind_t ind;\n  char *newval;\n\n   \n\n  if (entry && assoc_p (entry))\n    {\n      sub[sublen-1] = '\\0';\n      if ((flags & ASS_NOEXPAND) == 0)\n\takey = expand_subscript_string (sub, 0);\t \n      else\n\takey = savestring (sub);\n      sub[sublen-1] = ']';\n      if (akey == 0 || *akey == 0)\n\t{\n\t  err_badarraysub (name);\n\t  FREE (akey);\n\t  return ((SHELL_VAR *)NULL);\n\t}\n      if (estatep)\n\tnkey = savestring (akey);\t \n      entry = bind_assoc_variable (entry, vname, akey, value, flags);\n      if (estatep)\n\t{\n\t  estatep->type = ARRAY_ASSOC;\n\t  estatep->key = nkey;\n\t  estatep->value = entry ? assoc_reference (assoc_cell (entry), nkey) : 0;\n\t}\n    }\n  else\n    {\n      ind = array_expand_index (entry, sub, sublen, 0);\n       \n      if (entry && ind < 0)\n\tind = (array_p (entry) ? array_max_index (array_cell (entry)) : 0) + 1 + ind;\n      if (ind < 0)\n\t{\n\t  err_badarraysub (name);\n\t  return ((SHELL_VAR *)NULL);\n\t}\n      entry = bind_array_variable (vname, ind, value, flags);\n      if (estatep)\n\t{\n\t  estatep->type = ARRAY_INDEXED;\n\t  estatep->ind = ind;\n\t  estatep->value = entry ? array_reference (array_cell (entry), ind) : 0;\n\t}\n    }\n\n  return (entry);\n}\n\n \nSHELL_VAR *\nfind_or_make_array_variable (name, flags)\n     char *name;\n     int flags;\n{\n  SHELL_VAR *var;\n\n  var = find_variable (name);\n  if (var == 0)\n    {\n       \n      var = find_variable_last_nameref (name, 1);\n      if (var && nameref_p (var) && invisible_p (var))\n\t{\n\t  internal_warning (_(\"%s: removing nameref attribute\"), name);\n\t  VUNSETATTR (var, att_nameref);\n\t}\n      if (var && nameref_p (var))\n\t{\n\t  if (valid_nameref_value (nameref_cell (var), 2) == 0)\n\t    {\n\t      sh_invalidid (nameref_cell (var));\n\t      return ((SHELL_VAR *)NULL);\n\t    }\n\t  var = (flags & 2) ? make_new_assoc_variable (nameref_cell (var)) : make_new_array_variable (nameref_cell (var));\n\t}\n    }\n\n  if (var == 0)\n    var = (flags & 2) ? make_new_assoc_variable (name) : make_new_array_variable (name);\n  else if ((flags & 1) && (readonly_p (var) || noassign_p (var)))\n    {\n      if (readonly_p (var))\n\terr_readonly (name);\n      return ((SHELL_VAR *)NULL);\n    }\n  else if ((flags & 2) && array_p (var))\n    {\n      set_exit_status (EXECUTION_FAILURE);\n      report_error (_(\"%s: cannot convert indexed to associative array\"), name);\n      return ((SHELL_VAR *)NULL);\n    }\n  else if (flags & 2)\n    var = assoc_p (var) ? var : convert_var_to_assoc (var);\n  else if (array_p (var) == 0 && assoc_p (var) == 0)\n    var = convert_var_to_array (var);\n\n  return (var);\n}\n  \n \nSHELL_VAR *\nassign_array_from_string (name, value, flags)\n     char *name, *value;\n     int flags;\n{\n  SHELL_VAR *var;\n  int vflags;\n\n  vflags = 1;\n  if (flags & ASS_MKASSOC)\n    vflags |= 2;\n\n  var = find_or_make_array_variable (name, vflags);\n  if (var == 0)\n    return ((SHELL_VAR *)NULL);\n\n  return (assign_array_var_from_string (var, value, flags));\n}\n\n \nSHELL_VAR *\nassign_array_var_from_word_list (var, list, flags)\n     SHELL_VAR *var;\n     WORD_LIST *list;\n     int flags;\n{\n  register arrayind_t i;\n  register WORD_LIST *l;\n  ARRAY *a;\n\n  a = array_cell (var);\n  i = (flags & ASS_APPEND) ? array_max_index (a) + 1 : 0;\n\n  for (l = list; l; l = l->next, i++)\n    bind_array_var_internal (var, i, 0, l->word->word, flags & ~ASS_APPEND);\n\n  VUNSETATTR (var, att_invisible);\t \n\n  return var;\n}\n\nWORD_LIST *\nexpand_compound_array_assignment (var, value, flags)\n     SHELL_VAR *var;\n     char *value;\n     int flags;\n{\n  WORD_LIST *list, *nlist;\n  char *val;\n  int ni;\n\n   \n  if (*value == '(')\t \n    {\n      ni = 1;\n      val = extract_array_assignment_list (value, &ni);\n      if (val == 0)\n\treturn (WORD_LIST *)NULL;\n    }\n  else\n    val = value;\n\n   \n   \n   \n  list = parse_string_to_word_list (val, 1, \"array assign\");\n\n   \n   \n  for (nlist = list; nlist; nlist = nlist->next)\n    if ((nlist->word->flags & W_QUOTED) == 0)\n      remove_quoted_escapes (nlist->word->word);\n\n   \n  if (var && assoc_p (var))\n    {\n      if (val != value)\n\tfree (val);\n      return list;\n    }\n\n   \n  if (list)\n    quote_array_assignment_chars (list);\n\n   \n  nlist = list ? expand_words_no_vars (list) : (WORD_LIST *)NULL;\n\n  dispose_words (list);\n\n  if (val != value)\n    free (val);\n\n  return nlist;\n}\n\n#if ASSOC_KVPAIR_ASSIGNMENT\nstatic void\nassign_assoc_from_kvlist (var, nlist, h, flags)\n     SHELL_VAR *var;\n     WORD_LIST *nlist;\n     HASH_TABLE *h;\n     int flags;\n{\n  WORD_LIST *list;\n  char *akey, *aval, *k, *v;\n\n  for (list = nlist; list; list = list->next)\n    {\n      k = list->word->word;\n      v = list->next ? list->next->word->word : 0;\n\n      if (list->next)\n        list = list->next;\n\n      akey = expand_subscript_string (k, 0);\n      if (akey == 0 || *akey == 0)\n\t{\n\t  err_badarraysub (k);\n\t  FREE (akey);\n\t  continue;\n\t}\t      \n\n      aval = expand_subscript_string (v, 0);\n      if (aval == 0)\n\t{\n\t  aval = (char *)xmalloc (1);\n\t  aval[0] = '\\0';\t \n\t}\n\n      bind_assoc_var_internal (var, h, akey, aval, flags);\n      free (aval);\n    }\n}\n\n  \nint\nkvpair_assignment_p (l)\n     WORD_LIST *l;\n{\n  return (l && (l->word->flags & W_ASSIGNMENT) == 0 && l->word->word[0] != '[');\t \n}\n\nchar *\nexpand_and_quote_kvpair_word (w)\n     char *w;\n{\n  char *r, *s, *t;\n\n  t = w ? expand_subscript_string (w, 0) : 0;\n  s = (t && strchr (t, CTLESC)) ? quote_escapes (t) : t;\n  r = sh_single_quote (s ? s : \"\");\n  if (s != t)\n    free (s);\n  free (t);\n  return r;\n}\n#endif\n     \n \nvoid\nassign_compound_array_list (var, nlist, flags)\n     SHELL_VAR *var;\n     WORD_LIST *nlist;\n     int flags;\n{\n  ARRAY *a;\n  HASH_TABLE *h, *nhash;\n  WORD_LIST *list;\n  char *w, *val, *nval, *savecmd;\n  int len, iflags, free_val;\n  arrayind_t ind, last_ind;\n  char *akey;\n\n  a = (var && array_p (var)) ? array_cell (var) : (ARRAY *)0;\n  nhash = h = (var && assoc_p (var)) ? assoc_cell (var) : (HASH_TABLE *)0;\n\n  akey = (char *)0;\n  ind = 0;\n\n   \n  if ((flags & ASS_APPEND) == 0)\n    {\n      if (a && array_p (var))\n\tarray_flush (a);\n      else if (h && assoc_p (var))\n\tnhash = assoc_create (h->nbuckets);\n    }\n\n  last_ind = (a && (flags & ASS_APPEND)) ? array_max_index (a) + 1 : 0;\n\n#if ASSOC_KVPAIR_ASSIGNMENT\n  if (assoc_p (var) && kvpair_assignment_p (nlist))\n    {\n      iflags = flags & ~ASS_APPEND;\n      assign_assoc_from_kvlist (var, nlist, nhash, iflags);\n      if (nhash && nhash != h)\n\t{\n\t  h = assoc_cell (var);\n\t  var_setassoc (var, nhash);\n\t  assoc_dispose (h);\n\t}\n      return;\n    }\n#endif\n\n  for (list = nlist; list; list = list->next)\n    {\n       \n      iflags = flags & ~ASS_APPEND;\n      w = list->word->word;\n\n       \n      if ((list->word->flags & W_ASSIGNMENT) && w[0] == '[')\n\t{\n\t   \n\t  len = skipsubscript (w, 0, 0);\n\n\t   \n \t  if (w[len] != ']' || (w[len+1] != '=' && (w[len+1] != '+' || w[len+2] != '=')))\n\t    {\n\t      if (assoc_p (var))\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  continue;\n\t\t}\n\t      nval = make_variable_value (var, w, flags);\n\t      if (var->assign_func)\n\t\t(*var->assign_func) (var, nval, last_ind, 0);\n\t      else\n\t\tarray_insert (a, last_ind, nval);\n\t      FREE (nval);\n\t      last_ind++;\n\t      continue;\n\t    }\n\n\t  if (len == 1)\n\t    {\n\t      err_badarraysub (w);\n\t      continue;\n\t    }\n\n\t  if (ALL_ELEMENT_SUB (w[1]) && len == 2 && array_p (var))\n\t    {\n\t      set_exit_status (EXECUTION_FAILURE);\n\t      report_error (_(\"%s: cannot assign to non-numeric index\"), w);\n\t      continue;\n\t    }\n\n\t  if (array_p (var))\n\t    {\n\t      ind = array_expand_index (var, w + 1, len, 0);\n\t       \n\t      if (ind < 0)\n\t\tind = array_max_index (array_cell (var)) + 1 + ind;\n\t      if (ind < 0)\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  continue;\n\t\t}\n\n\t      last_ind = ind;\n\t    }\n\t  else if (assoc_p (var))\n\t    {\n\t       \n\t      w[len] = '\\0';\t \n\t      akey = expand_subscript_string (w+1, 0);\n\t      w[len] = ']';\n\t       \n\t      if (akey == 0 || *akey == 0)\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  FREE (akey);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t   \n\t  if (w[len + 1] == '+' && w[len + 2] == '=')\n\t    {\n\t      iflags |= ASS_APPEND;\n\t      val = w + len + 3;\n\t    }\n\t  else\n\t    val = w + len + 2;\t    \n\t}\n      else if (assoc_p (var))\n\t{\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  report_error (_(\"%s: %s: must use subscript when assigning associative array\"), var->name, w);\n\t  continue;\n\t}\n      else\t\t \n\t{\n\t  ind = last_ind;\n\t  val = w;\n\t}\n\n      free_val = 0;\n       \n      if (assoc_p (var))\n\t{\n\t  val = expand_subscript_string (val, 0);\n\t  if (val == 0)\n\t    {\n\t      val = (char *)xmalloc (1);\n\t      val[0] = '\\0';\t \n\t    }\n\t  free_val = 1;\n\t}\n\n      savecmd = this_command_name;\n      if (integer_p (var))\n\tthis_command_name = (char *)NULL;\t \n      if (assoc_p (var))\n\tbind_assoc_var_internal (var, nhash, akey, val, iflags);\n      else\n\tbind_array_var_internal (var, ind, akey, val, iflags);\n      last_ind++;\n      this_command_name = savecmd;\n\n      if (free_val)\n\tfree (val);\n    }\n\n  if (assoc_p (var) && nhash && nhash != h)\n    {\n      h = assoc_cell (var);\n      var_setassoc (var, nhash);\n      assoc_dispose (h);\n    }\n}\n\n \nSHELL_VAR *\nassign_array_var_from_string (var, value, flags)\n     SHELL_VAR *var;\n     char *value;\n     int flags;\n{\n  WORD_LIST *nlist;\n\n  if (value == 0)\n    return var;\n\n  nlist = expand_compound_array_assignment (var, value, flags);\n  assign_compound_array_list (var, nlist, flags);\n\n  if (nlist)\n    dispose_words (nlist);\n\n  if (var)\n    VUNSETATTR (var, att_invisible);\t \n\n  return (var);\n}\n\n \nstatic char *\nquote_assign (string)\n     const char *string;\n{\n  size_t slen;\n  int saw_eq;\n  char *temp, *t, *subs;\n  const char *s, *send;\n  int ss, se;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n\n  t = temp = (char *)xmalloc (slen * 2 + 1);\n  saw_eq = 0;\n  for (s = string; *s; )\n    {\n      if (*s == '=')\n\tsaw_eq = 1;\n      if (saw_eq == 0 && *s == '[')\t\t \n\t{\n\t  ss = s - string;\n\t  se = skipsubscript (string, ss, 0);\n\t  subs = substring (s, ss, se);\n\t  *t++ = '\\\\';\n\t  strcpy (t, subs);\n\t  t += se - ss;\n\t  *t++ = '\\\\';\n\t  *t++ = ']';\n\t  s += se + 1;\n\t  free (subs);\n\t  continue;\n\t}\n      if (saw_eq == 0 && (glob_char_p (s) || isifs (*s)))\n\t*t++ = '\\\\';\n\n      COPY_CHAR_P (t, s, send);\n    }\n  *t = '\\0';\n  return temp;\n}\n\n \nstatic char *\nquote_compound_array_word (w, type)\n     char *w;\n     int type;\n{\n  char *nword, *sub, *value, *t;\n  int ind, wlen, i;\n\n  if (w[0] != LBRACK)\n    return (sh_single_quote (w));\t \n  ind = skipsubscript (w, 0, 0);\n  if (w[ind] != RBRACK)\n    return (sh_single_quote (w));\t \n\n  wlen = strlen (w);\n  w[ind] = '\\0';\n  t = (strchr (w+1, CTLESC)) ? quote_escapes (w+1) : w+1;\n  sub = sh_single_quote (t);\n  if (t != w+1)\n   free (t);\n  w[ind] = RBRACK;\n\n  nword = xmalloc (wlen * 4 + 5);\t \n  nword[0] = LBRACK;\n  i = STRLEN (sub);\n  memcpy (nword+1, sub, i);\n  free (sub);\n  i++;\t\t\t\t \n  nword[i++] = w[ind++];\t \n  if (w[ind] == '+')\n    nword[i++] = w[ind++];\n  nword[i++] = w[ind++];\n  t = (strchr (w+ind, CTLESC)) ? quote_escapes (w+ind) : w+ind;\n  value = sh_single_quote (t);\n  if (t != w+ind)\n   free (t);\n  strcpy (nword + i, value);\n\n  return nword;\n}\n\n \nchar *\nexpand_and_quote_assoc_word (w, type)\n     char *w;\n     int type;\n{\n  char *nword, *key, *value, *s, *t;\n  int ind, wlen, i;\n\n  if (w[0] != LBRACK)\n    return (sh_single_quote (w));\t \n  ind = skipsubscript (w, 0, 0);\n  if (w[ind] != RBRACK)\n    return (sh_single_quote (w));\t \n\n  w[ind] = '\\0';\n  t = expand_subscript_string (w+1, 0);\n  s = (t && strchr (t, CTLESC)) ? quote_escapes (t) : t;\n  key = sh_single_quote (s ? s : \"\");\n  if (s != t)\n    free (s);\n  w[ind] = RBRACK;\n  free (t);\n\n  wlen = STRLEN (key);\n  nword = xmalloc (wlen + 5);\n  nword[0] = LBRACK;\n  memcpy (nword+1, key, wlen);\n  i = wlen + 1;\t\t\t \n\n  nword[i++] = w[ind++];\t \n  if (w[ind] == '+')\n    nword[i++] = w[ind++];\n  nword[i++] = w[ind++];\n\n  t = expand_subscript_string (w+ind, 0);\n  s = (t && strchr (t, CTLESC)) ? quote_escapes (t) : t;\n  value = sh_single_quote (s ? s : \"\");\n  if (s != t)\n    free (s);\n  free (t);\n  nword = xrealloc (nword, wlen + 5 + STRLEN (value));\n  strcpy (nword + i, value);\n\n  free (key);\n  free (value);\n\n  return nword;\n}\n\n \nvoid\nquote_compound_array_list (list, type)\n     WORD_LIST *list;\n     int type;\n{\n  char *s, *t;\n  WORD_LIST *l;\n\n  for (l = list; l; l = l->next)\n    {\n      if (l->word == 0 || l->word->word == 0)\n\tcontinue;\t \n      if ((l->word->flags & W_ASSIGNMENT) == 0)\n\t{\n\t  s = (strchr (l->word->word, CTLESC)) ? quote_escapes (l->word->word) : l->word->word;\n\t  t = sh_single_quote (s);\n\t  if (s != l->word->word)\n\t    free (s);\n\t}\n      else \n\tt = quote_compound_array_word (l->word->word, type);\n      free (l->word->word);\n      l->word->word = t;\n    }\n}\n\n \nstatic void\nquote_array_assignment_chars (list)\n     WORD_LIST *list;\n{\n  char *nword;\n  WORD_LIST *l;\n\n  for (l = list; l; l = l->next)\n    {\n      if (l->word == 0 || l->word->word == 0 || l->word->word[0] == '\\0')\n\tcontinue;\t \n       \n      if ((l->word->flags & W_ASSIGNMENT) == 0)\n\tcontinue;\n      if (l->word->word[0] != '[' || mbschr (l->word->word, '=') == 0)  \n\tcontinue;\n\n      nword = quote_assign (l->word->word);\n      free (l->word->word);\n      l->word->word = nword;\n      l->word->flags |= W_NOGLOB;\t \n    }\n}\n\n \n\n \n \nint\nunbind_array_element (var, sub, flags)\n     SHELL_VAR *var;\n     char *sub;\n     int flags;\n{\n  arrayind_t ind;\n  char *akey;\n  ARRAY_ELEMENT *ae;\n\n   \n\n  if (ALL_ELEMENT_SUB (sub[0]) && sub[1] == 0)\n    {\n      if (array_p (var) || assoc_p (var))\n\t{\n\t  if (flags & VA_ALLOWALL)\n\t    {\n\t      unbind_variable (var->name);\t \n\t      return (0);\n\t    }\n\t   \n\t}\n      else\n\treturn -2;\t \n    }\n\n  if (assoc_p (var))\n    {\n      akey = (flags & VA_NOEXPAND) ? sub : expand_subscript_string (sub, 0);\n      if (akey == 0 || *akey == 0)\n\t{\n\t  builtin_error (\"[%s]: %s\", sub, _(bash_badsub_errmsg));\n\t  FREE (akey);\n\t  return -1;\n\t}\n      assoc_remove (assoc_cell (var), akey);\n      if (akey != sub)\n\tfree (akey);\n    }\n  else if (array_p (var))\n    {\n      if (ALL_ELEMENT_SUB (sub[0]) && sub[1] == 0)\n\t{\n\t   \n\t   \n\t  if (shell_compatibility_level <= 51)\n\t    {\n\t      unbind_variable (name_cell (var));\n\t      return 0;\n\t    }\n\t  else  \n\t    {\n\t      array_flush (array_cell (var));\n\t      return 0;\n\t    }\n\t   \n\t}\n      ind = array_expand_index (var, sub, strlen (sub) + 1, 0);\n       \n      if (ind < 0)\n\tind = array_max_index (array_cell (var)) + 1 + ind;\n      if (ind < 0)\n\t{\n\t  builtin_error (\"[%s]: %s\", sub, _(bash_badsub_errmsg));\n\t  return -1;\n\t}\n      ae = array_remove (array_cell (var), ind);\n      if (ae)\n\tarray_dispose_element (ae);\n    }\n  else\t \n    {\n      akey = this_command_name;\n      ind = array_expand_index (var, sub, strlen (sub) + 1, 0);\n      this_command_name = akey;\n      if (ind == 0)\n\t{\n\t  unbind_variable (var->name);\n\t  return (0);\n\t}\n      else\n\treturn -2;\t \n    }\n\n  return 0;\n}\n\n \nvoid\nprint_array_assignment (var, quoted)\n     SHELL_VAR *var;\n     int quoted;\n{\n  char *vstr;\n\n  vstr = array_to_assign (array_cell (var), quoted);\n\n  if (vstr == 0)\n    printf (\"%s=%s\\n\", var->name, quoted ? \"'()'\" : \"()\");\n  else\n    {\n      printf (\"%s=%s\\n\", var->name, vstr);\n      free (vstr);\n    }\n}\n\n \nvoid\nprint_assoc_assignment (var, quoted)\n     SHELL_VAR *var;\n     int quoted;\n{\n  char *vstr;\n\n  vstr = assoc_to_assign (assoc_cell (var), quoted);\n\n  if (vstr == 0)\n    printf (\"%s=%s\\n\", var->name, quoted ? \"'()'\" : \"()\");\n  else\n    {\n      printf (\"%s=%s\\n\", var->name, vstr);\n      free (vstr);\n    }\n}\n\n \n \n \n \n \n\n \n\n \n\n \n \nint\ntokenize_array_reference (name, flags, subp)\n     char *name;\n     int flags;\n     char **subp;\n{\n  char *t;\n  int r, len, isassoc, ssflags;\n  SHELL_VAR *entry;\n\n  t = mbschr (name, '[');\t \n  isassoc = 0;\n  if (t)\n    {\n      *t = '\\0';\n      r = legal_identifier (name);\n      if (flags & VA_NOEXPAND)\t \n\tisassoc = (entry = find_variable (name)) && assoc_p (entry);      \n      *t = '[';\n      if (r == 0)\n\treturn 0;\n\n      ssflags = 0;\n      if (isassoc && ((flags & (VA_NOEXPAND|VA_ONEWORD)) == (VA_NOEXPAND|VA_ONEWORD)))\n\tlen = strlen (t) - 1;\n      else if (isassoc)\n\t{\n\t  if (flags & VA_NOEXPAND)\n\t    ssflags |= 1;\n\t  len = skipsubscript (t, 0, ssflags);\n\t}\n      else\n\t \n\tlen = skipsubscript (t, 0, 0);\t\t \n\n      if (t[len] != ']' || len == 1 || t[len+1] != '\\0')\n\treturn 0;\n\n#if 0\n       \n      for (r = 1; r < len; r++)\n\tif (whitespace (t[r]) == 0)\n\t  break;\n      if (r == len)\n\treturn 0;  \n#endif\n\n      if (subp)\n\t{\n\t  t[0] = t[len] = '\\0';\n\t  *subp = t + 1;\n\t}\n\n       \n      return 1;\n    }\n  return 0;\n}\n\n \n\n \nint\nvalid_array_reference (name, flags)\n     const char *name;\n     int flags;\n{\n  return tokenize_array_reference ((char *)name, flags, (char **)NULL);\n}\n\n \narrayind_t\narray_expand_index (var, s, len, flags)\n     SHELL_VAR *var;\n     char *s;\n     int len;\n     int flags;\n{\n  char *exp, *t, *savecmd;\n  int expok, eflag;\n  arrayind_t val;\n\n  exp = (char *)xmalloc (len);\n  strncpy (exp, s, len - 1);\n  exp[len - 1] = '\\0';\n#if 0\t \n  if ((flags & AV_NOEXPAND) == 0)\n    t = expand_arith_string (exp, Q_DOUBLE_QUOTES|Q_ARITH|Q_ARRAYSUB);\t \n  else\n    t = exp;\n#else\n  t = expand_arith_string (exp, Q_DOUBLE_QUOTES|Q_ARITH|Q_ARRAYSUB);\t \n#endif\n  savecmd = this_command_name;\n  this_command_name = (char *)NULL;\n  eflag = (shell_compatibility_level > 51) ? 0 : EXP_EXPANDED;\n  val = evalexp (t, eflag, &expok);\t \n  this_command_name = savecmd;\n  if (t != exp)\n    free (t);\n  free (exp);\n  if (expok == 0)\n    {\n      set_exit_status (EXECUTION_FAILURE);\n\n      if (no_longjmp_on_fatal_error)\n\treturn 0;\n      top_level_cleanup ();      \n      jump_to_top_level (DISCARD);\n    }\n  return val;\n}\n\n \nchar *\narray_variable_name (s, flags, subp, lenp)\n     const char *s;\n     int flags;\n     char **subp;\n     int *lenp;\n{\n  char *t, *ret;\n  int ind, ni, ssflags;\n\n  t = mbschr (s, '[');\n  if (t == 0)\n    {\n      if (subp)\n      \t*subp = t;\n      if (lenp)\n\t*lenp = 0;\n      return ((char *)NULL);\n    }\n  ind = t - s;\n  if ((flags & (AV_NOEXPAND|AV_ONEWORD)) == (AV_NOEXPAND|AV_ONEWORD))\n    ni = strlen (s) - 1;\n  else\n    {\n      ssflags = 0;\n      if (flags & AV_NOEXPAND)\n\tssflags |= 1;\n      ni = skipsubscript (s, ind, ssflags);\n    }\n  if (ni <= ind + 1 || s[ni] != ']')\n    {\n      err_badarraysub (s);\n      if (subp)\n      \t*subp = t;\n      if (lenp)\n\t*lenp = 0;\n      return ((char *)NULL);\n    }\n\n  *t = '\\0';\n  ret = savestring (s);\n  *t++ = '[';\t\t \n\n  if (subp)\n    *subp = t;\n  if (lenp)\n    *lenp = ni - ind;\n\n  return ret;\n}\n\n \nSHELL_VAR *\narray_variable_part (s, flags, subp, lenp)\n     const char *s;\n     int flags;\n     char **subp;\n     int *lenp;\n{\n  char *t;\n  SHELL_VAR *var;\n\n  t = array_variable_name (s, flags, subp, lenp);\n  if (t == 0)\n    return ((SHELL_VAR *)NULL);\n  var = find_variable (t);\t\t \n\n  free (t);\n  return var;\t \n}\n\n#define INDEX_ERROR() \\\n  do \\\n    { \\\n      if (var) \\\n\terr_badarraysub (var->name); \\\n      else \\\n\t{ \\\n\t  t[-1] = '\\0'; \\\n\t  err_badarraysub (s); \\\n\t  t[-1] = '[';\t \\\n\t} \\\n      return ((char *)NULL); \\\n    } \\\n  while (0)\n\n \nstatic char *\narray_value_internal (s, quoted, flags, estatep)\n     const char *s;\n     int quoted, flags;\n     array_eltstate_t *estatep;\n{\n  int len, isassoc, subtype;\n  arrayind_t ind;\n  char *akey;\n  char *retval, *t, *temp;\n  WORD_LIST *l;\n  SHELL_VAR *var;\n\n  var = array_variable_part (s, flags, &t, &len);\t \n\n   \n#if 0\n  if (var == 0)\n    return (char *)NULL;\n#endif\n\n  if (len == 0)\n    return ((char *)NULL);\t \n\n  isassoc = var && assoc_p (var);\n   \n  akey = 0;\n  subtype = 0;\n  if (estatep)\n    estatep->value = (char *)NULL;\n\n   \n  if ((isassoc == 0 || (flags & AV_ATSTARKEYS) == 0) && ALL_ELEMENT_SUB (t[0]) && t[1] == ']')\n    {\n      if (estatep)\n\testatep->subtype = (t[0] == '*') ? 1 : 2;\n      if ((flags & AV_ALLOWALL) == 0)\n\t{\n\t  err_badarraysub (s);\n\t  return ((char *)NULL);\n\t}\n      else if (var == 0 || value_cell (var) == 0)\n\treturn ((char *)NULL);\n      else if (invisible_p (var))\n\treturn ((char *)NULL);\n      else if (array_p (var) == 0 && assoc_p (var) == 0)\n        {\n          if (estatep)\n\t    estatep->type = ARRAY_SCALAR;\n\t  l = add_string_to_list (value_cell (var), (WORD_LIST *)NULL);\n        }\n      else if (assoc_p (var))\n\t{\n\t  if (estatep)\n\t    estatep->type = ARRAY_ASSOC;\n\t  l = assoc_to_word_list (assoc_cell (var));\n\t  if (l == (WORD_LIST *)NULL)\n\t    return ((char *)NULL);\n\t}\n      else\n\t{\n\t  if (estatep)\n\t    estatep->type = ARRAY_INDEXED;\n\t  l = array_to_word_list (array_cell (var));\n\t  if (l == (WORD_LIST *)NULL)\n\t    return ((char *) NULL);\n\t}\n\n       \n      if (t[0] == '*' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t{\n\t  temp = string_list_dollar_star (l, quoted, (flags & AV_ASSIGNRHS) ? PF_ASSIGNRHS : 0);\n\t  retval = quote_string (temp);\n\t  free (temp);\n\t}\n      else\t \n\tretval = string_list_dollar_at (l, quoted, (flags & AV_ASSIGNRHS) ? PF_ASSIGNRHS : 0);\n\n      dispose_words (l);\n    }\n  else\n    {\n      if (estatep)\n\testatep->subtype = 0;\n      if (var == 0 || array_p (var) || assoc_p (var) == 0)\n\t{\n\t  if ((flags & AV_USEIND) == 0 || estatep == 0)\n\t    {\n\t      ind = array_expand_index (var, t, len, flags);\n\t      if (ind < 0)\n\t\t{\n\t\t   \n\t\t  if (var && array_p (var))\n\t\t    ind = array_max_index (array_cell (var)) + 1 + ind;\n\t\t  if (ind < 0)\n\t\t    INDEX_ERROR();\n\t\t}\n\t      if (estatep)\n\t\testatep->ind = ind;\n\t    }\n\t  else if (estatep && (flags & AV_USEIND))\n\t    ind = estatep->ind;\n\t  if (estatep && var)\n\t    estatep->type = array_p (var) ? ARRAY_INDEXED : ARRAY_SCALAR;\n\t}\n      else if (assoc_p (var))\n\t{\n\t  t[len - 1] = '\\0';\n\t  if (estatep)\n\t    estatep->type = ARRAY_ASSOC;\n\t  if ((flags & AV_USEIND) && estatep && estatep->key)\n\t    akey = savestring (estatep->key);\n\t  else if ((flags & AV_NOEXPAND) == 0)\n\t    akey = expand_subscript_string (t, 0);\t \n\t  else\n\t    akey = savestring (t);\n\t  t[len - 1] = ']';\n\t  if (akey == 0 || *akey == 0)\n\t    {\n\t      FREE (akey);\n\t      INDEX_ERROR();\n\t    }\n\t}\n\n      if (var == 0 || value_cell (var) == 0)\n\t{\n\t  FREE (akey);\n\t  return ((char *)NULL);\n\t}\n      else if (invisible_p (var))\n\t{\n\t  FREE (akey);\n\t  return ((char *)NULL);\n\t}\n      if (array_p (var) == 0 && assoc_p (var) == 0)\n\tretval = (ind == 0) ? value_cell (var) : (char *)NULL;\n      else if (assoc_p (var))\n        {\n\t  retval = assoc_reference (assoc_cell (var), akey);\n\t  if (estatep && estatep->key && (flags & AV_USEIND))\n\t    free (akey);\t\t \n\t  else if (estatep)\n\t    estatep->key = akey;\t \n\t  else\t\t\t\t \n\t    free (akey);\n        }\n      else\n\tretval = array_reference (array_cell (var), ind);\n\n      if (estatep)\n\testatep->value = retval;\n    }\n\n  return retval;\n}\n\n \nchar *\narray_value (s, quoted, flags, estatep)\n     const char *s;\n     int quoted, flags;\n     array_eltstate_t *estatep;\n{\n  char *retval;\n\n  retval = array_value_internal (s, quoted, flags|AV_ALLOWALL, estatep);\n  return retval;\n}\n\n \nchar *\nget_array_value (s, flags, estatep)\n     const char *s;\n     int flags;\n     array_eltstate_t *estatep;\n{\n  char *retval;\n\n  retval = array_value_internal (s, 0, flags, estatep);\n  return retval;\n}\n\nchar *\narray_keys (s, quoted, pflags)\n     char *s;\n     int quoted, pflags;\n{\n  int len;\n  char *retval, *t, *temp;\n  WORD_LIST *l;\n  SHELL_VAR *var;\n\n  var = array_variable_part (s, 0, &t, &len);\n\n   \n  if (var == 0 || ALL_ELEMENT_SUB (t[0]) == 0 || t[1] != ']')\n    return (char *)NULL;\n\n  if (var_isset (var) == 0 || invisible_p (var))\n    return (char *)NULL;\n\n  if (array_p (var) == 0 && assoc_p (var) == 0)\n    l = add_string_to_list (\"0\", (WORD_LIST *)NULL);\n  else if (assoc_p (var))\n    l = assoc_keys_to_word_list (assoc_cell (var));\n  else\n    l = array_keys_to_word_list (array_cell (var));\n  if (l == (WORD_LIST *)NULL)\n    return ((char *) NULL);\n\n  retval = string_list_pos_params (t[0], l, quoted, pflags);\n\n  dispose_words (l);\n  return retval;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}