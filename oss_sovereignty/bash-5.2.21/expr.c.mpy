{
  "module_name": "expr.c",
  "hash_id": "5a32eb82ab43bf07cdb94d5df8d15f65a3f9c029dedb31216dff1edce97e0909",
  "original_prompt": "Ingested from bash-5.2.21/expr.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"config.h\"\n\n#include <stdio.h>\n#include \"bashansi.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"chartypes.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"arrayfunc.h\"\n#include \"execute_cmd.h\"\n#include \"flags.h\"\n#include \"subst.h\"\n#include \"typemax.h\"\t\t \n\n \n#define cr_whitespace(c) (whitespace(c) || ((c) == '\\n'))\n\n \n#define EXPR_STACK_GROW_SIZE 10\n\n \n#define MAX_EXPR_RECURSION_LEVEL 1024\n\n \n\n#define EQEQ\t1\t \n#define NEQ\t2\t \n#define LEQ\t3\t \n#define GEQ\t4\t \n#define STR\t5\t \n#define NUM\t6\t \n#define LAND\t7\t \n#define LOR\t8\t \n#define LSH\t9\t \n#define RSH    10\t \n#define OP_ASSIGN 11\t \n#define COND\t12\t \n#define POWER\t13\t \n#define PREINC\t14\t \n#define PREDEC\t15\t \n#define POSTINC\t16\t \n#define POSTDEC\t17\t \n#define EQ\t'='\n#define GT\t'>'\n#define LT\t'<'\n#define PLUS\t'+'\n#define MINUS\t'-'\n#define MUL\t'*'\n#define DIV\t'/'\n#define MOD\t'%'\n#define NOT\t'!'\n#define LPAR\t'('\n#define RPAR\t')'\n#define BAND\t'&'\t \n#define BOR\t'|'\t \n#define BXOR\t'^'\t \n#define BNOT\t'~'\t \n#define QUES\t'?'\n#define COL\t':'\n#define COMMA\t','\n\n \n#define EXP_LOWEST\texpcomma\n\n#ifndef MAX_INT_LEN\n#  define MAX_INT_LEN 32\n#endif\n\nstruct lvalue\n{\n  char *tokstr;\t\t \n  intmax_t tokval;\t \n  SHELL_VAR *tokvar;\t \n  intmax_t ind;\t\t \n};\n\n \ntypedef struct {\n  int curtok, lasttok;\n  char *expression, *tp, *lasttp;\n  intmax_t tokval;\n  char *tokstr;\n  int noeval;\n  struct lvalue lval;\n} EXPR_CONTEXT;\n\nstatic char\t*expression;\t \nstatic char\t*tp;\t\t \nstatic char\t*lasttp;\t \nstatic int\tcurtok;\t\t \nstatic int\tlasttok;\t \nstatic int\tassigntok;\t \nstatic char\t*tokstr;\t \nstatic intmax_t\ttokval;\t\t \nstatic int\tnoeval;\t\t \nstatic procenv_t evalbuf;\n\n \nstatic int\talready_expanded;\n\nstatic struct lvalue curlval = {0, 0, 0, -1};\nstatic struct lvalue lastlval = {0, 0, 0, -1};\n\nstatic int\t_is_arithop PARAMS((int));\nstatic void\treadtok PARAMS((void));\t \n\nstatic void\tinit_lvalue PARAMS((struct lvalue *));\nstatic struct lvalue *alloc_lvalue PARAMS((void));\nstatic void\tfree_lvalue PARAMS((struct lvalue *));\n\nstatic intmax_t\texpr_streval PARAMS((char *, int, struct lvalue *));\nstatic intmax_t\tstrlong PARAMS((char *));\nstatic void\tevalerror PARAMS((const char *));\n\nstatic void\tpushexp PARAMS((void));\nstatic void\tpopexp PARAMS((void));\nstatic void\texpr_unwind PARAMS((void));\nstatic void\texpr_bind_variable PARAMS((char *, char *));\n#if defined (ARRAY_VARS)\nstatic void\texpr_bind_array_element PARAMS((char *, arrayind_t, char *));\n#endif\n\nstatic intmax_t subexpr PARAMS((char *));\n\nstatic intmax_t\texpcomma PARAMS((void));\nstatic intmax_t expassign PARAMS((void));\nstatic intmax_t\texpcond PARAMS((void));\nstatic intmax_t explor PARAMS((void));\nstatic intmax_t expland PARAMS((void));\nstatic intmax_t\texpbor PARAMS((void));\nstatic intmax_t\texpbxor PARAMS((void));\nstatic intmax_t\texpband PARAMS((void));\nstatic intmax_t exp5 PARAMS((void));\nstatic intmax_t exp4 PARAMS((void));\nstatic intmax_t expshift PARAMS((void));\nstatic intmax_t exp3 PARAMS((void));\nstatic intmax_t expmuldiv PARAMS((void));\nstatic intmax_t\texppower PARAMS((void));\nstatic intmax_t exp1 PARAMS((void));\nstatic intmax_t exp0 PARAMS((void));\n\n \nstatic EXPR_CONTEXT **expr_stack;\nstatic int expr_depth;\t\t    \nstatic int expr_stack_size;\t    \n\n#if defined (ARRAY_VARS)\nextern const char * const bash_badsub_errmsg;\n#endif\n\n#define SAVETOK(X) \\\n  do { \\\n    (X)->curtok = curtok; \\\n    (X)->lasttok = lasttok; \\\n    (X)->tp = tp; \\\n    (X)->lasttp = lasttp; \\\n    (X)->tokval = tokval; \\\n    (X)->tokstr = tokstr; \\\n    (X)->noeval = noeval; \\\n    (X)->lval = curlval; \\\n  } while (0)\n\n#define RESTORETOK(X) \\\n  do { \\\n    curtok = (X)->curtok; \\\n    lasttok = (X)->lasttok; \\\n    tp = (X)->tp; \\\n    lasttp = (X)->lasttp; \\\n    tokval = (X)->tokval; \\\n    tokstr = (X)->tokstr; \\\n    noeval = (X)->noeval; \\\n    curlval = (X)->lval; \\\n  } while (0)\n\n \nstatic void\npushexp ()\n{\n  EXPR_CONTEXT *context;\n\n  if (expr_depth >= MAX_EXPR_RECURSION_LEVEL)\n    evalerror (_(\"expression recursion level exceeded\"));\n\n  if (expr_depth >= expr_stack_size)\n    {\n      expr_stack_size += EXPR_STACK_GROW_SIZE;\n      expr_stack = (EXPR_CONTEXT **)xrealloc (expr_stack, expr_stack_size * sizeof (EXPR_CONTEXT *));\n    }\n\n  context = (EXPR_CONTEXT *)xmalloc (sizeof (EXPR_CONTEXT));\n\n  context->expression = expression;\n  SAVETOK(context);\n\n  expr_stack[expr_depth++] = context;\n}\n\n \nstatic void\npopexp ()\n{\n  EXPR_CONTEXT *context;\n\n  if (expr_depth <= 0)\n    {\n       \n      expression = lasttp = 0;\n      evalerror (_(\"recursion stack underflow\"));\n    }\n\n  context = expr_stack[--expr_depth];\n\n  expression = context->expression;\n  RESTORETOK (context);\n\n  free (context);\n}\n\nstatic void\nexpr_unwind ()\n{\n  while (--expr_depth > 0)\n    {\n      if (expr_stack[expr_depth]->tokstr)\n\tfree (expr_stack[expr_depth]->tokstr);\n\n      if (expr_stack[expr_depth]->expression)\n\tfree (expr_stack[expr_depth]->expression);\n\n      free (expr_stack[expr_depth]);\n    }\n  if (expr_depth == 0)\n    free (expr_stack[expr_depth]);\t \n\n  noeval = 0;\t \n}\n\nstatic void\nexpr_bind_variable (lhs, rhs)\n     char *lhs, *rhs;\n{\n  SHELL_VAR *v;\n  int aflags;\n\n  if (lhs == 0 || *lhs == 0)\n    return;\t\t \n\n#if defined (ARRAY_VARS)\n  aflags = (assoc_expand_once && already_expanded) ? ASS_NOEXPAND : 0;\n  aflags |= ASS_ALLOWALLSUB;\t\t \n#else\n  aflags = 0;\n#endif\n  v = bind_int_variable (lhs, rhs, aflags);\n  if (v && (readonly_p (v) || noassign_p (v)))\n    sh_longjmp (evalbuf, 1);\t \n  stupidly_hack_special_variables (lhs);\n}\n\n#if defined (ARRAY_VARS)\n \nstatic int\nexpr_skipsubscript (vp, cp)\n     char *vp, *cp;\n{\n  int flags, isassoc;\n  SHELL_VAR *entry;\n\n  isassoc = 0;\n  entry = 0;\n  if (assoc_expand_once & already_expanded)\n    {\n      *cp = '\\0';\n      isassoc = legal_identifier (vp) && (entry = find_variable (vp)) && assoc_p (entry);\n      *cp = '[';\t \n    }\n  flags = (isassoc && assoc_expand_once && already_expanded) ? VA_NOEXPAND : 0;\n  return (skipsubscript (cp, 0, flags));\n}\n\n \nstatic void\nexpr_bind_array_element (tok, ind, rhs)\n     char *tok;\n     arrayind_t ind;\n     char *rhs;\n{\n  char *lhs, *vname;\n  size_t llen;\n  char ibuf[INT_STRLEN_BOUND (arrayind_t) + 1], *istr;\n\n  istr = fmtumax (ind, 10, ibuf, sizeof (ibuf), 0);\n  vname = array_variable_name (tok, 0, (char **)NULL, (int *)NULL);\n\n  llen = strlen (vname) + sizeof (ibuf) + 3;\n  lhs = xmalloc (llen);\n\n  sprintf (lhs, \"%s[%s]\", vname, istr);\t\t \n  \n \n  expr_bind_variable (lhs, rhs);\n  free (vname);\n  free (lhs);\n}\n#endif  \n\n \nintmax_t\nevalexp (expr, flags, validp)\n     char *expr;\n     int flags;\n     int *validp;\n{\n  intmax_t val;\n  int c;\n  procenv_t oevalbuf;\n\n  val = 0;\n  noeval = 0;\n  already_expanded = (flags&EXP_EXPANDED);\n\n  FASTCOPY (evalbuf, oevalbuf, sizeof (evalbuf));\n\n  c = setjmp_nosigs (evalbuf);\n\n  if (c)\n    {\n      FREE (tokstr);\n      FREE (expression);\n      tokstr = expression = (char *)NULL;\n\n      expr_unwind ();\n      expr_depth = 0;\t \n\n       \n      FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));\n\n      if (validp)\n\t*validp = 0;\n      return (0);\n    }\n\n  val = subexpr (expr);\n\n  if (validp)\n    *validp = 1;\n\n  FASTCOPY (oevalbuf, evalbuf, sizeof (evalbuf));\n\n  return (val);\n}\n\nstatic intmax_t\nsubexpr (expr)\n     char *expr;\n{\n  intmax_t val;\n  char *p;\n\n  for (p = expr; p && *p && cr_whitespace (*p); p++)\n    ;\n\n  if (p == NULL || *p == '\\0')\n    return (0);\n\n  pushexp ();\n  expression = savestring (expr);\n  tp = expression;\n\n  curtok = lasttok = 0;\n  tokstr = (char *)NULL;\n  tokval = 0;\n  init_lvalue (&curlval);\n  lastlval = curlval;\n\n  readtok ();\n\n  val = EXP_LOWEST ();\n\n   \n  if (curtok != 0)\n    evalerror (_(\"syntax error in expression\"));\n\n  FREE (tokstr);\n  FREE (expression);\n\n  popexp ();\n\n  return val;\n}\n\nstatic intmax_t\nexpcomma ()\n{\n  register intmax_t value;\n\n  value = expassign ();\n  while (curtok == COMMA)\n    {\n      readtok ();\n      value = expassign ();\n    }\n\n  return value;\n}\n  \nstatic intmax_t\nexpassign ()\n{\n  register intmax_t value;\n  char *lhs, *rhs;\n  arrayind_t lind;\n#if defined (HAVE_IMAXDIV)\n  imaxdiv_t idiv;\n#endif\n\n  value = expcond ();\n  if (curtok == EQ || curtok == OP_ASSIGN)\n    {\n      int special, op;\n      intmax_t lvalue;\n\n      special = curtok == OP_ASSIGN;\n\n      if (lasttok != STR)\n\tevalerror (_(\"attempted assignment to non-variable\"));\n\n      if (special)\n\t{\n\t  op = assigntok;\t\t \n\t  lvalue = value;\n\t}\n\n      if (tokstr == 0)\n\tevalerror (_(\"syntax error in variable assignment\"));\n\n       \n      lhs = savestring (tokstr);\n       \n      lind = curlval.ind;\n      readtok ();\n      value = expassign ();\n\n      if (special)\n\t{\n\t  if ((op == DIV || op == MOD) && value == 0)\n\t    {\n\t      if (noeval == 0)\n\t\tevalerror (_(\"division by 0\"));\n\t      else\n\t        value = 1;\n\t    }\n\n\t  switch (op)\n\t    {\n\t    case MUL:\n\t       \n\t      lvalue *= value;\n\t      break;\n\t    case DIV:\n\t    case MOD:\n\t      if (lvalue == INTMAX_MIN && value == -1)\n\t\tlvalue = (op == DIV) ? INTMAX_MIN : 0;\n\t      else\n#if HAVE_IMAXDIV\n\t\t{\n\t\t  idiv = imaxdiv (lvalue, value);\n\t\t  lvalue = (op == DIV) ? idiv.quot : idiv.rem;\n\t\t}\n#else\n\t        lvalue = (op == DIV) ? lvalue / value : lvalue % value;\n#endif\n\t      break;\n\t    case PLUS:\n\t      lvalue += value;\n\t      break;\n\t    case MINUS:\n\t      lvalue -= value;\n\t      break;\n\t    case LSH:\n\t      lvalue <<= value;\n\t      break;\n\t    case RSH:\n\t      lvalue >>= value;\n\t      break;\n\t    case BAND:\n\t      lvalue &= value;\n\t      break;\n\t    case BOR:\n\t      lvalue |= value;\n\t      break;\n\t    case BXOR:\n\t      lvalue ^= value;\n\t      break;\n\t    default:\n\t      free (lhs);\n\t      evalerror (_(\"bug: bad expassign token\"));\n\t      break;\n\t    }\n\t  value = lvalue;\n\t}\n\n      rhs = itos (value);\n      if (noeval == 0)\n\t{\n#if defined (ARRAY_VARS)\n\t  if (lind != -1)\n\t    expr_bind_array_element (lhs, lind, rhs);\n\t  else\n#endif\n\t    expr_bind_variable (lhs, rhs);\n\t}\n      if (curlval.tokstr && curlval.tokstr == tokstr)\n\tinit_lvalue (&curlval);\n\n      free (rhs);\n      free (lhs);\n      FREE (tokstr);\n      tokstr = (char *)NULL;\t\t \n    }\n\n  return (value);\n}\n\n \nstatic intmax_t\nexpcond ()\n{\n  intmax_t cval, val1, val2, rval;\n  int set_noeval;\n\n  set_noeval = 0;\n  rval = cval = explor ();\n  if (curtok == QUES)\t\t \n    {\n      if (cval == 0)\n\t{\n\t  set_noeval = 1;\n\t  noeval++;\n\t}\n\n      readtok ();\n      if (curtok == 0 || curtok == COL)\n\tevalerror (_(\"expression expected\"));\n\n      val1 = EXP_LOWEST ();\n\n      if (set_noeval)\n\tnoeval--;\n      if (curtok != COL)\n\tevalerror (_(\"`:' expected for conditional expression\"));\n\n      set_noeval = 0;\n      if (cval)\n \t{\n \t  set_noeval = 1;\n\t  noeval++;\n \t}\n\n      readtok ();\n      if (curtok == 0)\n\tevalerror (_(\"expression expected\"));\n      val2 = expcond ();\n\n      if (set_noeval)\n\tnoeval--;\n      rval = cval ? val1 : val2;\n      lasttok = COND;\n    }\n  return rval;\n}\n\n \nstatic intmax_t\nexplor ()\n{\n  register intmax_t val1, val2;\n  int set_noeval;\n\n  val1 = expland ();\n\n  while (curtok == LOR)\n    {\n      set_noeval = 0;\n      if (val1 != 0)\n\t{\n\t  noeval++;\n\t  set_noeval = 1;\n\t}\n      readtok ();\n      val2 = expland ();\n      if (set_noeval)\n\tnoeval--;\n      val1 = val1 || val2;\n      lasttok = LOR;\n    }\n\n  return (val1);\n}\n\n \nstatic intmax_t\nexpland ()\n{\n  register intmax_t val1, val2;\n  int set_noeval;\n\n  val1 = expbor ();\n\n  while (curtok == LAND)\n    {\n      set_noeval = 0;\n      if (val1 == 0)\n\t{\n\t  set_noeval = 1;\n\t  noeval++;\n\t}\n      readtok ();\n      val2 = expbor ();\n      if (set_noeval)\n\tnoeval--;\n      val1 = val1 && val2;\n      lasttok = LAND;\n    }\n\n  return (val1);\n}\n\n \nstatic intmax_t\nexpbor ()\n{\n  register intmax_t val1, val2;\n\n  val1 = expbxor ();\n\n  while (curtok == BOR)\n    {\n      readtok ();\n      val2 = expbxor ();\n      val1 = val1 | val2;\n      lasttok = NUM;\n    }\n\n  return (val1);\n}\n\n \nstatic intmax_t\nexpbxor ()\n{\n  register intmax_t val1, val2;\n\n  val1 = expband ();\n\n  while (curtok == BXOR)\n    {\n      readtok ();\n      val2 = expband ();\n      val1 = val1 ^ val2;\n      lasttok = NUM;\n    }\n\n  return (val1);\n}\n\n \nstatic intmax_t\nexpband ()\n{\n  register intmax_t val1, val2;\n\n  val1 = exp5 ();\n\n  while (curtok == BAND)\n    {\n      readtok ();\n      val2 = exp5 ();\n      val1 = val1 & val2;\n      lasttok = NUM;\n    }\n\n  return (val1);\n}\n\nstatic intmax_t\nexp5 ()\n{\n  register intmax_t val1, val2;\n\n  val1 = exp4 ();\n\n  while ((curtok == EQEQ) || (curtok == NEQ))\n    {\n      int op = curtok;\n\n      readtok ();\n      val2 = exp4 ();\n      if (op == EQEQ)\n\tval1 = (val1 == val2);\n      else if (op == NEQ)\n\tval1 = (val1 != val2);\n      lasttok = NUM;\n    }\n  return (val1);\n}\n\nstatic intmax_t\nexp4 ()\n{\n  register intmax_t val1, val2;\n\n  val1 = expshift ();\n  while ((curtok == LEQ) ||\n\t (curtok == GEQ) ||\n\t (curtok == LT) ||\n\t (curtok == GT))\n    {\n      int op = curtok;\n\n      readtok ();\n      val2 = expshift ();\n\n      if (op == LEQ)\n\tval1 = val1 <= val2;\n      else if (op == GEQ)\n\tval1 = val1 >= val2;\n      else if (op == LT)\n\tval1 = val1 < val2;\n      else\t\t\t \n\tval1 = val1 > val2;\n      lasttok = NUM;\n    }\n  return (val1);\n}\n\n \nstatic intmax_t\nexpshift ()\n{\n  register intmax_t val1, val2;\n\n  val1 = exp3 ();\n\n  while ((curtok == LSH) || (curtok == RSH))\n    {\n      int op = curtok;\n\n      readtok ();\n      val2 = exp3 ();\n\n      if (op == LSH)\n\tval1 = val1 << val2;\n      else\n\tval1 = val1 >> val2;\n      lasttok = NUM;\n    }\n\n  return (val1);\n}\n\nstatic intmax_t\nexp3 ()\n{\n  register intmax_t val1, val2;\n\n  val1 = expmuldiv ();\n\n  while ((curtok == PLUS) || (curtok == MINUS))\n    {\n      int op = curtok;\n\n      readtok ();\n      val2 = expmuldiv ();\n\n      if (op == PLUS)\n\tval1 += val2;\n      else if (op == MINUS)\n\tval1 -= val2;\n      lasttok = NUM;\n    }\n  return (val1);\n}\n\nstatic intmax_t\nexpmuldiv ()\n{\n  register intmax_t val1, val2;\n#if defined (HAVE_IMAXDIV)\n  imaxdiv_t idiv;\n#endif\n\n  val1 = exppower ();\n\n  while ((curtok == MUL) ||\n\t (curtok == DIV) ||\n\t (curtok == MOD))\n    {\n      int op = curtok;\n      char *stp, *sltp;\n\n      stp = tp;\n      readtok ();\n\n      val2 = exppower ();\n\n       \n      if (((op == DIV) || (op == MOD)) && (val2 == 0))\n\t{\n\t  if (noeval == 0)\n\t    {\n\t      sltp = lasttp;\n\t      lasttp = stp;\n\t      while (lasttp && *lasttp && whitespace (*lasttp))\n\t\tlasttp++;\n\t      evalerror (_(\"division by 0\"));\n\t      lasttp = sltp;\n\t    }\n\t  else\n\t    val2 = 1;\n\t}\n      else if (op == MOD && val1 == INTMAX_MIN && val2 == -1)\n\t{\n\t  val1 = 0;\n\t  continue;\n\t}\n      else if (op == DIV && val1 == INTMAX_MIN && val2 == -1)\n\tval2 = 1;\n\n      if (op == MUL)\n\tval1 *= val2;\n      else if (op == DIV || op == MOD)\n#if defined (HAVE_IMAXDIV)\n\t{\n\t  idiv = imaxdiv (val1, val2);\n\t  val1 = (op == DIV) ? idiv.quot : idiv.rem;\n\t}\n#else\n\tval1 = (op == DIV) ? val1 / val2 : val1 % val2;\n#endif\n      lasttok = NUM;\n    }\n  return (val1);\n}\n\nstatic intmax_t\nipow (base, exp)\n     intmax_t base, exp;\n{\n  intmax_t result;\n\n  result = 1;\n  while (exp)\n    {\n      if (exp & 1)\n\tresult *= base;\n      exp >>= 1;\n      base *= base;\n    }\n  return result;\n}\n\nstatic intmax_t\nexppower ()\n{\n  register intmax_t val1, val2, c;\n\n  val1 = exp1 ();\n  while (curtok == POWER)\n    {\n      readtok ();\n      val2 = exppower ();\t \n      lasttok = NUM;\n      if (val2 == 0)\n\treturn (1);\n      if (val2 < 0)\n\tevalerror (_(\"exponent less than 0\"));\n      val1 = ipow (val1, val2);\n    }\n  return (val1);\n}\n\nstatic intmax_t\nexp1 ()\n{\n  register intmax_t val;\n\n  if (curtok == NOT)\n    {\n      readtok ();\n      val = !exp1 ();\n      lasttok = NUM;\n    }\n  else if (curtok == BNOT)\n    {\n      readtok ();\n      val = ~exp1 ();\n      lasttok = NUM;\n    }\n  else if (curtok == MINUS)\n    {\n      readtok ();\n      val = - exp1 ();\n      lasttok = NUM;\n    }\n  else if (curtok == PLUS)\n    {\n      readtok ();\n      val = exp1 ();\n      lasttok = NUM;\n    }\n  else\n    val = exp0 ();\n\n  return (val);\n}\n\nstatic intmax_t\nexp0 ()\n{\n  register intmax_t val = 0, v2;\n  char *vincdec;\n  int stok;\n  EXPR_CONTEXT ec;\n\n   \n  if (curtok == PREINC || curtok == PREDEC)\n    {\n      stok = lasttok = curtok;\n      readtok ();\n      if (curtok != STR)\n\t \n\tevalerror (_(\"identifier expected after pre-increment or pre-decrement\"));\n\n      v2 = tokval + ((stok == PREINC) ? 1 : -1);\n      vincdec = itos (v2);\n      if (noeval == 0)\n\t{\n#if defined (ARRAY_VARS)\n\t  if (curlval.ind != -1)\n\t    expr_bind_array_element (curlval.tokstr, curlval.ind, vincdec);\n\t  else\n#endif\n\t    if (tokstr)\n\t      expr_bind_variable (tokstr, vincdec);\n\t}\n      free (vincdec);\n      val = v2;\n\n      curtok = NUM;\t \n      readtok ();\n    }\n  else if (curtok == LPAR)\n    {\n       \n      readtok ();\n      val = EXP_LOWEST ();\n\n      if (curtok != RPAR)  \n\tevalerror (_(\"missing `)'\"));\n\n       \n      readtok ();\n    }\n  else if ((curtok == NUM) || (curtok == STR))\n    {\n      val = tokval;\n      if (curtok == STR)\n\t{\n\t  SAVETOK (&ec);\n\t  tokstr = (char *)NULL;\t \n          noeval = 1;\n          readtok ();\n          stok = curtok;\n\n\t   \n \t  if (stok == POSTINC || stok == POSTDEC)\n \t    {\n \t       \n \t      tokstr = ec.tokstr;\n \t      noeval = ec.noeval;\n \t      curlval = ec.lval;\n \t      lasttok = STR;\t \n\n\t      v2 = val + ((stok == POSTINC) ? 1 : -1);\n\t      vincdec = itos (v2);\n\t      if (noeval == 0)\n\t\t{\n#if defined (ARRAY_VARS)\n\t\t  if (curlval.ind != -1)\n\t\t    expr_bind_array_element (curlval.tokstr, curlval.ind, vincdec);\n\t\t  else\n#endif\n\t\t    expr_bind_variable (tokstr, vincdec);\n\t\t}\n\t      free (vincdec);\n\t      curtok = NUM;\t \n \t    }\n \t  else\n \t    {\n\t       \n\t      if (stok == STR)\t \n\t\tFREE (tokstr);\n\t      RESTORETOK (&ec);\n \t    }\n\t}\n\t  \n      readtok ();\n    }\n  else\n    evalerror (_(\"syntax error: operand expected\"));\n\n  return (val);\n}\n\nstatic void\ninit_lvalue (lv)\n     struct lvalue *lv;\n{\n  lv->tokstr = 0;\n  lv->tokvar = 0;\n  lv->tokval = lv->ind = -1;\n}\n\nstatic struct lvalue *\nalloc_lvalue ()\n{\n  struct lvalue *lv;\n\n  lv = xmalloc (sizeof (struct lvalue));\n  init_lvalue (lv);\n  return (lv);\n}\n\nstatic void\nfree_lvalue (lv)\n     struct lvalue *lv;\n{\n  free (lv);\t\t \n}\n\nstatic intmax_t\nexpr_streval (tok, e, lvalue)\n     char *tok;\n     int e;\n     struct lvalue *lvalue;\n{\n  SHELL_VAR *v;\n  char *value;\n  intmax_t tval;\n  int initial_depth;\n#if defined (ARRAY_VARS)\n  arrayind_t ind;\n  int tflag, aflag;\n  array_eltstate_t es;\n#endif\n\n \n   \n  if (noeval)\n    return (0);\n\n  initial_depth = expr_depth;\n\n#if defined (ARRAY_VARS)\n  tflag = (assoc_expand_once && already_expanded) ? AV_NOEXPAND : 0;\t \n#endif\n\n   \n#if defined (ARRAY_VARS)\n  aflag = tflag;\t \n  if (shell_compatibility_level > 51)\n    aflag |= AV_ATSTARKEYS;\n  v = (e == ']') ? array_variable_part (tok, tflag, (char **)0, (int *)0) : find_variable (tok);\n#else\n  v = find_variable (tok);\n#endif\n  if (v == 0 && e != ']')\n    v = find_variable_last_nameref (tok, 0);  \n\n  if ((v == 0 || invisible_p (v)) && unbound_vars_is_error)\n    {\n#if defined (ARRAY_VARS)\n      value = (e == ']') ? array_variable_name (tok, tflag, (char **)0, (int *)0) : tok;\n#else\n      value = tok;\n#endif\n\n      set_exit_status (EXECUTION_FAILURE);\n      err_unboundvar (value);\n\n#if defined (ARRAY_VARS)\n      if (e == ']')\n\tFREE (value);\t \n#endif\n\n      if (no_longjmp_on_fatal_error && interactive_shell)\n\tsh_longjmp (evalbuf, 1);\n\n      if (interactive_shell)\n\t{\n\t  expr_unwind ();\n\t  top_level_cleanup ();\n\t  jump_to_top_level (DISCARD);\n\t}\n      else\n\tjump_to_top_level (FORCE_EOF);\n    }\n\n#if defined (ARRAY_VARS)\n  init_eltstate (&es);\n  es.ind = -1;\n   \n  value = (e == ']') ? get_array_value (tok, aflag, &es) : get_variable_value (v);\n  ind = es.ind;\n  flush_eltstate (&es);\n#else\n  value = get_variable_value (v);\n#endif\n\n  if (expr_depth < initial_depth)\n    {\n      if (no_longjmp_on_fatal_error && interactive_shell)\n\tsh_longjmp (evalbuf, 1);\n      return (0);\n    }\n\n  tval = (value && *value) ? subexpr (value) : 0;\n\n  if (lvalue)\n    {\n      lvalue->tokstr = tok;\t \n      lvalue->tokval = tval;\n      lvalue->tokvar = v;\t \n#if defined (ARRAY_VARS)\n      lvalue->ind = ind;\n#else\n      lvalue->ind = -1;\n#endif\n    }\n\t  \n  return (tval);\n}\n\nstatic int\n_is_multiop (c)\n     int c;\n{\n  switch (c)\n    {\n    case EQEQ:\n    case NEQ:\n    case LEQ:\n    case GEQ:\n    case LAND:\n    case LOR:\n    case LSH:\n    case RSH:\n    case OP_ASSIGN:\n    case COND:\n    case POWER:\n    case PREINC:\n    case PREDEC:\n    case POSTINC:\n    case POSTDEC:\n      return 1;\n    default:\n      return 0;\n    }\n}\n\nstatic int\n_is_arithop (c)\n     int c;\n{\n  switch (c)\n    {\n    case EQ:\n    case GT:\n    case LT:\n    case PLUS:\n    case MINUS:\n    case MUL:\n    case DIV:\n    case MOD:\n    case NOT:\n    case LPAR:\n    case RPAR:\n    case BAND:\n    case BOR:\n    case BXOR:\n    case BNOT:\n      return 1;\t\t \n    case QUES:\n    case COL:\n    case COMMA:\n      return 1;\t\t \n    default:\n      return 0;\t\t \n    }\n}\n\n \nstatic void\nreadtok ()\n{\n  register char *cp, *xp;\n  register unsigned char c, c1;\n  register int e;\n  struct lvalue lval;\n\n   \n  cp = tp;\n  c = e = 0;\n  while (cp && (c = *cp) && (cr_whitespace (c)))\n    cp++;\n\n  if (c)\n    cp++;\n\n  if (c == '\\0')\n    {\n      lasttok = curtok;\n      curtok = 0;\n      tp = cp;\n      return;\n    }\n  lasttp = tp = cp - 1;\n\n  if (legal_variable_starter (c))\n    {\n       \n      char *savecp;\n      EXPR_CONTEXT ec;\n      int peektok;\n\n      while (legal_variable_char (c))\n\tc = *cp++;\n\n      c = *--cp;\n\n#if defined (ARRAY_VARS)\n      if (c == '[')\n\t{\n\t  e = expr_skipsubscript (tp, cp);\t\t \n\t  if (cp[e] == ']')\n\t    {\n\t      cp += e + 1;\n\t      c = *cp;\n\t      e = ']';\n\t    }\n\t  else\n\t    evalerror (bash_badsub_errmsg);\n\t}\n#endif  \n\n      *cp = '\\0';\n       \n      if (curlval.tokstr && curlval.tokstr == tokstr)\n\tinit_lvalue (&curlval);\n\n      FREE (tokstr);\n      tokstr = savestring (tp);\n      *cp = c;\n\n       \n      SAVETOK (&ec);\n      tokstr = (char *)NULL;\t \n      tp = savecp = cp;\n      noeval = 1;\n      curtok = STR;\n      readtok ();\n      peektok = curtok;\n      if (peektok == STR)\t \n\tFREE (tokstr);\n      RESTORETOK (&ec);\n      cp = savecp;\n\n       \n      if (lasttok == PREINC || lasttok == PREDEC || peektok != EQ)\n        {\n          lastlval = curlval;\n\t  tokval = expr_streval (tokstr, e, &curlval);\n        }\n      else\n\ttokval = 0;\n\n      lasttok = curtok;\n      curtok = STR;\n    }\n  else if (DIGIT(c))\n    {\n      while (ISALNUM (c) || c == '#' || c == '@' || c == '_')\n\tc = *cp++;\n\n      c = *--cp;\n      *cp = '\\0';\n\n      tokval = strlong (tp);\n      *cp = c;\n      lasttok = curtok;\n      curtok = NUM;\n    }\n  else\n    {\n      c1 = *cp++;\n      if ((c == EQ) && (c1 == EQ))\n\tc = EQEQ;\n      else if ((c == NOT) && (c1 == EQ))\n\tc = NEQ;\n      else if ((c == GT) && (c1 == EQ))\n\tc = GEQ;\n      else if ((c == LT) && (c1 == EQ))\n\tc = LEQ;\n      else if ((c == LT) && (c1 == LT))\n\t{\n\t  if (*cp == '=')\t \n\t    {\n\t      assigntok = LSH;\n\t      c = OP_ASSIGN;\n\t      cp++;\n\t    }\n\t  else\n\t    c = LSH;\n\t}\n      else if ((c == GT) && (c1 == GT))\n\t{\n\t  if (*cp == '=')\n\t    {\n\t      assigntok = RSH;\t \n\t      c = OP_ASSIGN;\n\t      cp++;\n\t    }\n\t  else\n\t    c = RSH;\n\t}\n      else if ((c == BAND) && (c1 == BAND))\n\tc = LAND;\n      else if ((c == BOR) && (c1 == BOR))\n\tc = LOR;\n      else if ((c == '*') && (c1 == '*'))\n\tc = POWER;\n      else if ((c == '-' || c == '+') && c1 == c && curtok == STR)\n\tc = (c == '-') ? POSTDEC : POSTINC;\n#if STRICT_ARITH_PARSING\n      else if ((c == '-' || c == '+') && c1 == c && curtok == NUM)\n#else\n      else if ((c == '-' || c == '+') && c1 == c && curtok == NUM && (lasttok == PREINC || lasttok == PREDEC))\n#endif\n\t{\n\t   \n\t   \n\t  if (c == '-')\n\t    evalerror (\"--: assignment requires lvalue\");\n\t  else\n\t    evalerror (\"++: assignment requires lvalue\");\n\t}\n      else if ((c == '-' || c == '+') && c1 == c)\n\t{\n\t   \n\t  xp = cp;\n\t  while (xp && *xp && cr_whitespace (*xp))\n\t    xp++;\n\t  if (legal_variable_starter ((unsigned char)*xp))\n\t    c = (c == '-') ? PREDEC : PREINC;\n\t  else\n\t     \n#if STRICT_ARITH_PARSING\n\t    {\n\t       \n\t       \n\t      if (c == '-')\n\t\tevalerror (\"--: assignment requires lvalue\");\n\t      else\n\t\tevalerror (\"++: assignment requires lvalue\");\n\t    }\n#else\n\t    cp--;\t \n#endif\n\t}\n      else if (c1 == EQ && member (c, \"*/%+-&^|\"))\n\t{\n\t  assigntok = c;\t \n\t  c = OP_ASSIGN;\n\t}\n      else if (_is_arithop (c) == 0)\n\t{\n\t  cp--;\n\t   \n\t  if (curtok == 0 || _is_arithop (curtok) || _is_multiop (curtok))\n\t    evalerror (_(\"syntax error: operand expected\"));\n\t  else\n\t    evalerror (_(\"syntax error: invalid arithmetic operator\"));\n\t}\n      else\n\tcp--;\t\t\t \n\n       \n      lasttok = curtok;\n      curtok = c;\n    }\n  tp = cp;\n}\n\nstatic void\nevalerror (msg)\n     const char *msg;\n{\n  char *name, *t;\n\n  name = this_command_name;\n  for (t = expression; t && whitespace (*t); t++)\n    ;\n  internal_error (_(\"%s%s%s: %s (error token is \\\"%s\\\")\"),\n\t\t   name ? name : \"\", name ? \": \" : \"\",\n\t\t   t ? t : \"\", msg, (lasttp && *lasttp) ? lasttp : \"\");\n  sh_longjmp (evalbuf, 1);\n}\n\n \n\n#define VALID_NUMCHAR(c)\t(ISALNUM(c) || ((c) == '_') || ((c) == '@'))\n\nstatic intmax_t\nstrlong (num)\n     char *num;\n{\n  register char *s;\n  register unsigned char c;\n  int base, foundbase;\n  intmax_t val, pval;\n\n  s = num;\n\n  base = 10;\n  foundbase = 0;\n  if (*s == '0')\n    {\n      s++;\n\n      if (*s == '\\0')\n\treturn 0;\n\n        \n      if (*s == 'x' || *s == 'X')\n\t{\n\t  base = 16;\n\t  s++;\n#if STRICT_ARITH_PARSING\n\t  if (*s == 0)\n\t    evalerror (_(\"invalid number\"));\n#endif\t    \n\t}\n      else\n\tbase = 8;\n      foundbase++;\n    }\n\n  val = 0;\n  for (c = *s++; c; c = *s++)\n    {\n      if (c == '#')\n\t{\n\t  if (foundbase)\n\t    evalerror (_(\"invalid number\"));\n\n\t   \n\t  if (val < 2 || val > 64)\n\t    evalerror (_(\"invalid arithmetic base\"));\n\n\t  base = val;\n\t  val = 0;\n\t  foundbase++;\n\n\t   \n\t  if (VALID_NUMCHAR (*s) == 0)\n\t    evalerror (_(\"invalid integer constant\"));\n\t}\n      else if (VALID_NUMCHAR (c))\n\t{\n\t  if (DIGIT(c))\n\t    c = TODIGIT(c);\n\t  else if (c >= 'a' && c <= 'z')\n\t    c -= 'a' - 10;\n\t  else if (c >= 'A' && c <= 'Z')\n\t    c -= 'A' - ((base <= 36) ? 10 : 36);\n\t  else if (c == '@')\n\t    c = 62;\n\t  else if (c == '_')\n\t    c = 63;\n\n\t  if (c >= base)\n\t    evalerror (_(\"value too great for base\"));\n\n#ifdef CHECK_OVERFLOW\n\t  pval = val;\n\t  val = (val * base) + c;\n\t  if (val < 0 || val < pval)\t \n\t    return INTMAX_MAX;\n#else\n\t  val = (val * base) + c;\n#endif\n\t}\n      else\n\tbreak;\n    }\n\n  return (val);\n}\n\n#if defined (EXPR_TEST)\nvoid *\nxmalloc (n)\n     int n;\n{\n  return (malloc (n));\n}\n\nvoid *\nxrealloc (s, n)\n     char *s;\n     int n;\n{\n  return (realloc (s, n));\n}\n\nSHELL_VAR *find_variable () { return 0;}\nSHELL_VAR *bind_variable () { return 0; }\n\nchar *get_string_value () { return 0; }\n\nprocenv_t top_level;\n\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  register int i;\n  intmax_t v;\n  int expok;\n\n  if (setjmp (top_level))\n    exit (0);\n\n  for (i = 1; i < argc; i++)\n    {\n      v = evalexp (argv[i], 0, &expok);\n      if (expok == 0)\n\tfprintf (stderr, _(\"%s: expression error\\n\"), argv[i]);\n      else\n\tprintf (\"'%s' -> %ld\\n\", argv[i], v);\n    }\n  exit (0);\n}\n\nint\nbuiltin_error (format, arg1, arg2, arg3, arg4, arg5)\n     char *format;\n{\n  fprintf (stderr, \"expr: \");\n  fprintf (stderr, format, arg1, arg2, arg3, arg4, arg5);\n  fprintf (stderr, \"\\n\");\n  return 0;\n}\n\nchar *\nitos (n)\n     intmax_t n;\n{\n  return (\"42\");\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}