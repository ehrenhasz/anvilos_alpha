{
  "module_name": "trap.c",
  "hash_id": "1831a6a682b83ed5cf86fdcb0793bde7ebf547262636b2f07ee98f60ef38534c",
  "original_prompt": "Ingested from bash-5.2.21/trap.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashtypes.h\"\n#include \"bashansi.h\"\n\n#include <stdio.h>\n#include <errno.h>\n\n#include \"bashintl.h\"\n\n#include <signal.h>\n\n#include \"trap.h\"\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"flags.h\"\n#include \"parser.h\"\n#include \"input.h\"\t \n#include \"jobs.h\"\n#include \"signames.h\"\n#include \"builtins.h\"\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\n\n#if defined (READLINE)\n#  include <readline/readline.h>\n#  include \"bashline.h\"\n#endif\n\n#ifndef errno\nextern int errno;\n#endif\n\n \n#define SIG_INHERITED   0x0\t \n#define SIG_TRAPPED     0x1\t \n#define SIG_HARD_IGNORE 0x2\t \n#define SIG_SPECIAL     0x4\t \n#define SIG_NO_TRAP     0x8\t \n#define SIG_INPROGRESS\t0x10\t \n#define SIG_CHANGED\t0x20\t \n#define SIG_IGNORED\t0x40\t \n\n#define SPECIAL_TRAP(s)\t((s) == EXIT_TRAP || (s) == DEBUG_TRAP || (s) == ERROR_TRAP || (s) == RETURN_TRAP)\n\n \nstatic int sigmodes[BASH_NSIG];\n\nstatic void free_trap_command (int);\nstatic void change_signal (int, char *);\n\nstatic int _run_trap_internal (int, char *);\n\nstatic void free_trap_string (int);\nstatic void reset_signal (int);\nstatic void restore_signal (int);\nstatic void reset_or_restore_signal_handlers (sh_resetsig_func_t *);\nstatic void reinit_trap (int);\n\nstatic void trap_if_untrapped (int, char *);\n\n \n\nextern volatile int from_return_trap;\nextern int waiting_for_child;\n\nextern WORD_LIST *subst_assign_varlist;\n\n \nSigHandler *original_signals[NSIG];\n\n \nchar *trap_list[BASH_NSIG];\n\n \nint pending_traps[NSIG];\n\n \nint running_trap;\n\n \nint trap_saved_exit_value;\n\n \nint wait_signal_received;\n\nint trapped_signal_received;\n\n \nint suppress_debug_trap_verbose = 0;\n\n#define GETORIGSIG(sig) \\\n  do { \\\n    original_signals[sig] = (SigHandler *)set_signal_handler (sig, SIG_DFL); \\\n    set_signal_handler (sig, original_signals[sig]); \\\n    if (original_signals[sig] == SIG_IGN) \\\n      sigmodes[sig] |= SIG_HARD_IGNORE; \\\n  } while (0)\n\n#define SETORIGSIG(sig,handler) \\\n  do { \\\n    original_signals[sig] = handler; \\\n    if (original_signals[sig] == SIG_IGN) \\\n      sigmodes[sig] |= SIG_HARD_IGNORE; \\\n  } while (0)\n\n#define GET_ORIGINAL_SIGNAL(sig) \\\n  if (sig && sig < NSIG && original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER) \\\n    GETORIGSIG(sig)\n\nvoid\ninitialize_traps ()\n{\n  register int i;\n\n  initialize_signames();\n\n  trap_list[EXIT_TRAP] = trap_list[DEBUG_TRAP] = trap_list[ERROR_TRAP] = trap_list[RETURN_TRAP] = (char *)NULL;\n  sigmodes[EXIT_TRAP] = sigmodes[DEBUG_TRAP] = sigmodes[ERROR_TRAP] = sigmodes[RETURN_TRAP] = SIG_INHERITED;\n  original_signals[EXIT_TRAP] = IMPOSSIBLE_TRAP_HANDLER;\n\n  for (i = 1; i < NSIG; i++)\n    {\n      pending_traps[i] = 0;\n      trap_list[i] = (char *)DEFAULT_SIG;\n      sigmodes[i] = SIG_INHERITED;\t \n      original_signals[i] = IMPOSSIBLE_TRAP_HANDLER;\n    }\n\n   \n#if defined (SIGCHLD)\n  GETORIGSIG (SIGCHLD);\n  sigmodes[SIGCHLD] |= (SIG_SPECIAL | SIG_NO_TRAP);\n#endif  \n\n  GETORIGSIG (SIGINT);\n  sigmodes[SIGINT] |= SIG_SPECIAL;\n\n#if defined (__BEOS__)\n   \n  original_signals[SIGINT] = SIG_DFL;\n  sigmodes[SIGINT] &= ~SIG_HARD_IGNORE;\n#endif\n\n  GETORIGSIG (SIGQUIT);\n  sigmodes[SIGQUIT] |= SIG_SPECIAL;\n\n  if (interactive)\n    {\n      GETORIGSIG (SIGTERM);\n      sigmodes[SIGTERM] |= SIG_SPECIAL;\n    }\n\n  get_original_tty_job_signals ();\n}\n\n#ifdef DEBUG\n \nstatic char *\ntrap_handler_string (sig)\n     int sig;\n{\n  if (trap_list[sig] == (char *)DEFAULT_SIG)\n    return \"DEFAULT_SIG\";\n  else if (trap_list[sig] == (char *)IGNORE_SIG)\n    return \"IGNORE_SIG\";\n  else if (trap_list[sig] == (char *)IMPOSSIBLE_TRAP_HANDLER)\n    return \"IMPOSSIBLE_TRAP_HANDLER\";\n  else if (trap_list[sig])\n    return trap_list[sig];\n  else\n    return \"NULL\";\n}\n#endif\n\n \nchar *\nsignal_name (sig)\n     int sig;\n{\n  char *ret;\n\n   \n  ret = (sig >= BASH_NSIG || sig < 0 || signal_names[sig] == NULL)\n\t? _(\"invalid signal number\")\n\t: signal_names[sig];\n\n  return ret;\n}\n\n \nint\ndecode_signal (string, flags)\n     char *string;\n     int flags;\n{\n  intmax_t sig;\n  char *name;\n\n  if (legal_number (string, &sig))\n    return ((sig >= 0 && sig < NSIG) ? (int)sig : NO_SIG);\n\n#if defined (SIGRTMIN) && defined (SIGRTMAX)\n  if (STREQN (string, \"SIGRTMIN+\", 9) || ((flags & DSIG_NOCASE) && strncasecmp (string, \"SIGRTMIN+\", 9) == 0))\n    {\n      if (legal_number (string+9, &sig) && sig >= 0 && sig <= SIGRTMAX - SIGRTMIN)\n\treturn (SIGRTMIN + sig);\n      else\n\treturn NO_SIG;\n    }\n  else if (STREQN (string, \"RTMIN+\", 6) || ((flags & DSIG_NOCASE) && strncasecmp (string, \"RTMIN+\", 6) == 0))\n    {\n      if (legal_number (string+6, &sig) && sig >= 0 && sig <= SIGRTMAX - SIGRTMIN)\n\treturn (SIGRTMIN + sig);\n      else\n\treturn NO_SIG;\n    }\n#endif  \n\n   \n  for (sig = 0; sig < BASH_NSIG; sig++)\n    {\n      name = signal_names[sig];\n      if (name == 0 || name[0] == '\\0')\n\tcontinue;\n\n       \n      if (STREQN (name, \"SIG\", 3))\n\t{\n\t  name += 3;\n\n\t  if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)\n\t    return ((int)sig);\n\t  else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)\n\t    return ((int)sig);\n\t   \n\t  else if ((flags & DSIG_SIGPREFIX) == 0)\n\t    continue;\n\t}\n\n       \n      name = signal_names[sig];\n      if ((flags & DSIG_NOCASE) && strcasecmp (string, name) == 0)\n\treturn ((int)sig);\n      else if ((flags & DSIG_NOCASE) == 0 && strcmp (string, name) == 0)\n\treturn ((int)sig);\n    }\n\n  return (NO_SIG);\n}\n\n \nstatic int catch_flag;\n\nvoid\nrun_pending_traps ()\n{\n  register int sig;\n  int x;\n  volatile int old_exit_value, old_running;\n  WORD_LIST *save_subst_varlist;\n  HASH_TABLE *save_tempenv;\n  sh_parser_state_t pstate;\n  volatile int save_return_catch_flag, function_code;\n  procenv_t save_return_catch;\n  char *trap_command, *old_trap;\n#if defined (ARRAY_VARS)\n  ARRAY *ps;\n#endif\n\n  if (catch_flag == 0)\t\t \n    return;\n\n  if (running_trap > 0)\n    {\n      internal_debug (\"run_pending_traps: recursive invocation while running trap for signal %d\", running_trap-1);\n#if defined (SIGWINCH)\n      if (running_trap == SIGWINCH+1 && pending_traps[SIGWINCH])\n\treturn;\t\t\t \n#endif\n       \n      if (evalnest_max > 0 && evalnest > evalnest_max)\n\t{\n\t  internal_error (_(\"trap handler: maximum trap handler level exceeded (%d)\"), evalnest_max);\n\t  evalnest = 0;\n\t  jump_to_top_level (DISCARD);\n\t}\n    }\n\n  catch_flag = trapped_signal_received = 0;\n\n   \n  trap_saved_exit_value = old_exit_value = last_command_exit_value;\n#if defined (ARRAY_VARS)\n  ps = save_pipestatus_array ();\n#endif\n  old_running = running_trap;\n\n  for (sig = 1; sig < NSIG; sig++)\n    {\n       \n      if (pending_traps[sig])\n\t{\n\t   \n\t  running_trap = sig + 1;\n\n\t  if (sig == SIGINT)\n\t    {\n\t      pending_traps[sig] = 0;\t \n\t       \n\t      run_interrupt_trap (0);\n\t      CLRINTERRUPT;\t \n\t    }\n#if defined (JOB_CONTROL) && defined (SIGCHLD)\n\t  else if (sig == SIGCHLD &&\n\t\t   trap_list[SIGCHLD] != (char *)IMPOSSIBLE_TRAP_HANDLER &&\n\t\t   (sigmodes[SIGCHLD] & SIG_INPROGRESS) == 0)\n\t    {\n\t      sigmodes[SIGCHLD] |= SIG_INPROGRESS;\n\t       \n\t      evalnest++;\n\t      x = pending_traps[sig];\n\t      pending_traps[sig] = 0;\n\t      run_sigchld_trap (x);\t \n\t      running_trap = 0;\n\t      evalnest--;\n\t      sigmodes[SIGCHLD] &= ~SIG_INPROGRESS;\n\t       \n\t      continue;\n\t    }\n\t  else if (sig == SIGCHLD &&\n\t\t   trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER &&\n\t\t   (sigmodes[SIGCHLD] & SIG_INPROGRESS) != 0)\n\t    {\n\t       \n\t      running_trap = 0;\n\t       \n\t      continue;\t\t\t\t\t \n\t    }\n\t  else if (sig == SIGCHLD && (sigmodes[SIGCHLD] & SIG_INPROGRESS))\n\t    {\n\t       \n\t      running_trap = 0;\t\t \n\t       \n\t      continue;\n\t    }\n#endif\n\t  else if (trap_list[sig] == (char *)DEFAULT_SIG ||\n\t\t   trap_list[sig] == (char *)IGNORE_SIG ||\n\t\t   trap_list[sig] == (char *)IMPOSSIBLE_TRAP_HANDLER)\n\t    {\n\t       \n\t      internal_warning (_(\"run_pending_traps: bad value in trap_list[%d]: %p\"),\n\t\t\t\tsig, trap_list[sig]);\n\t      if (trap_list[sig] == (char *)DEFAULT_SIG)\n\t\t{\n\t\t  internal_warning (_(\"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself\"), sig, signal_name (sig));\n\t\t  kill (getpid (), sig);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      old_trap = trap_list[sig];\n\t      trap_command = savestring (old_trap);\n\n\t      save_parser_state (&pstate);\n\t      save_subst_varlist = subst_assign_varlist;\n\t      subst_assign_varlist = 0;\n\t      save_tempenv = temporary_env;\n\t      temporary_env = 0;\t \n\n#if defined (JOB_CONTROL)\n\t      save_pipeline (1);\t \n#endif\n\t       \n\t      pending_traps[sig] = 0;\n\t      evalnest++;\n\n\t      function_code = 0;\n\t      save_return_catch_flag = return_catch_flag;\n\t      if (return_catch_flag)\n\t\t{\n\t\t  COPY_PROCENV (return_catch, save_return_catch);\n\t\t  function_code = setjmp_nosigs (return_catch);\n\t\t}\n\n\t      if (function_code == 0)\n\t         \n\t\tx = parse_and_execute (trap_command, \"trap\", SEVAL_NONINT|SEVAL_NOHIST|SEVAL_RESETLINE|SEVAL_NOOPTIMIZE);\n\t      else\n\t\t{\n\t\t  parse_and_execute_cleanup (sig + 1);\t \n\t\t  x = return_catch_value;\n\t\t}\n\n\t      evalnest--;\n#if defined (JOB_CONTROL)\n\t      restore_pipeline (1);\n#endif\n\n\t      subst_assign_varlist = save_subst_varlist;\n\t      restore_parser_state (&pstate);\n\t      temporary_env = save_tempenv;\n\n\t      if (save_return_catch_flag)\n\t\t{\n\t\t  return_catch_flag = save_return_catch_flag;\n\t\t  return_catch_value = x;\n\t\t  COPY_PROCENV (save_return_catch, return_catch);\n\t\t  if (function_code)\n\t\t    {\n\t\t      running_trap = old_running;\t\t \n\t\t       \n\t\t      sh_longjmp (return_catch, 1);\n\t\t    }\n\t\t}\n\t    }\n\n\t  pending_traps[sig] = 0;\t \n\t  running_trap = old_running;\n\t}\n    }\n\n#if defined (ARRAY_VARS)\n  restore_pipestatus_array (ps);\n#endif\n  last_command_exit_value = old_exit_value;\n}\n\n \nvoid\nset_trap_state (sig)\n     int sig;\n{\n  catch_flag = 1;\n  pending_traps[sig]++;\n  trapped_signal_received = sig;\n}\n    \nsighandler\ntrap_handler (sig)\n     int sig;\n{\n  int oerrno;\n\n  if ((sigmodes[sig] & SIG_TRAPPED) == 0)\n    {\n      internal_debug (\"trap_handler: signal %d: signal not trapped\", sig);\n      SIGRETURN (0);\n    }\n\n   \n  if ((subshell_environment & SUBSHELL_IGNTRAP) && trap_list[sig] != (char *)IGNORE_SIG)\n    {\n      sigset_t mask;\n\n       \n      if (original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER)\n\toriginal_signals[sig] = SIG_DFL;\n\n      restore_signal (sig);\n\n       \n      sigemptyset (&mask);\n      sigprocmask (SIG_SETMASK, (sigset_t *)NULL, &mask);\n      sigdelset (&mask, sig);\n      sigprocmask (SIG_SETMASK, &mask, (sigset_t *)NULL);\n\n      kill (getpid (), sig);\n\n      SIGRETURN (0);\n    }\n\n  if ((sig >= NSIG) ||\n      (trap_list[sig] == (char *)DEFAULT_SIG) ||\n      (trap_list[sig] == (char *)IGNORE_SIG))\n    programming_error (_(\"trap_handler: bad signal %d\"), sig);\n  else\n    {\n      oerrno = errno;\n#if defined (MUST_REINSTALL_SIGHANDLERS)\n#  if defined (JOB_CONTROL) && defined (SIGCHLD)\n      if (sig != SIGCHLD)\n#  endif  \n      set_signal_handler (sig, trap_handler);\n#endif  \n\n      set_trap_state (sig);\n\n      if (this_shell_builtin && (this_shell_builtin == wait_builtin))\n\t{\n\t  wait_signal_received = sig;\n\t  if (waiting_for_child && wait_intr_flag)\n\t    sh_longjmp (wait_intr_buf, 1);\n\t}\n\n#if defined (READLINE)\n       \n      if (RL_ISSTATE (RL_STATE_SIGHANDLER))\n        bashline_set_event_hook ();\n#endif\n\n      errno = oerrno;\n    }\n  \n  SIGRETURN (0);\n}\n\nint\nnext_pending_trap (start)\n     int start;\n{\n  register int i;\n\n  for (i = start; i < NSIG; i++)\n    if (pending_traps[i])\n      return i;\n  return -1;\n}\n\nint\nfirst_pending_trap ()\n{\n  return (next_pending_trap (1));\n}\n\n \nint\nany_signals_trapped ()\n{\n  register int i;\n\n  for (i = 1; i < NSIG; i++)\n    if ((sigmodes[i] & SIG_TRAPPED) && (sigmodes[i] & SIG_IGNORED) == 0)\n      return i;\n  return -1;\n}\n\nvoid\nclear_pending_traps ()\n{\n  register int i;\n\n  for (i = 1; i < NSIG; i++)\n    pending_traps[i] = 0;\n}\n\nvoid\ncheck_signals ()\n{\n   \n  check_read_timeout ();\t \n  QUIT;\n}\n\n \nvoid\ncheck_signals_and_traps ()\n{\n  check_signals ();\n\n  run_pending_traps ();\n}\n\n#if defined (JOB_CONTROL) && defined (SIGCHLD)\n\n#ifdef INCLUDE_UNUSED\n \nvoid\nset_sigchld_trap (command_string)\n     char *command_string;\n{\n  set_signal (SIGCHLD, command_string);\n}\n#endif\n\n \nvoid\nmaybe_set_sigchld_trap (command_string)\n     char *command_string;\n{\n  if ((sigmodes[SIGCHLD] & SIG_TRAPPED) == 0 && trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER)\n    set_signal (SIGCHLD, command_string);\n}\n\n \nvoid\nset_impossible_sigchld_trap ()\n{\n  restore_default_signal (SIGCHLD);\n  change_signal (SIGCHLD, (char *)IMPOSSIBLE_TRAP_HANDLER);\n  sigmodes[SIGCHLD] &= ~SIG_TRAPPED;\t \n}\n\n \nvoid\nqueue_sigchld_trap (nchild)\n     int nchild;\n{\n  if (nchild > 0)\n    {\n      catch_flag = 1;\n      pending_traps[SIGCHLD] += nchild;\n      trapped_signal_received = SIGCHLD;\n    }\n}\n#endif  \n\n \nstatic inline void\ntrap_if_untrapped (sig, command)\n     int sig;\n     char *command;\n{\n  if ((sigmodes[sig] & SIG_TRAPPED) == 0)\n    set_signal (sig, command);\n}\n\nvoid\nset_debug_trap (command)\n     char *command;\n{\n  set_signal (DEBUG_TRAP, command);\n}\n\n \nvoid\nmaybe_set_debug_trap (command)\n     char *command;\n{\n  trap_if_untrapped (DEBUG_TRAP, command);\n}\n\nvoid\nset_error_trap (command)\n     char *command;\n{\n  set_signal (ERROR_TRAP, command);\n}\n\nvoid\nmaybe_set_error_trap (command)\n     char *command;\n{\n  trap_if_untrapped (ERROR_TRAP, command);\n}\n\nvoid\nset_return_trap (command)\n     char *command;\n{\n  set_signal (RETURN_TRAP, command);\n}\n\nvoid\nmaybe_set_return_trap (command)\n     char *command;\n{\n  trap_if_untrapped (RETURN_TRAP, command);\n}\n\n#ifdef INCLUDE_UNUSED\nvoid\nset_sigint_trap (command)\n     char *command;\n{\n  set_signal (SIGINT, command);\n}\n#endif\n\n \nSigHandler *\nset_sigint_handler ()\n{\n  if (sigmodes[SIGINT] & SIG_HARD_IGNORE)\n    return ((SigHandler *)SIG_IGN);\n\n  else if (sigmodes[SIGINT] & SIG_IGNORED)\n    return ((SigHandler *)set_signal_handler (SIGINT, SIG_IGN));  \n\n  else if (sigmodes[SIGINT] & SIG_TRAPPED)\n    return ((SigHandler *)set_signal_handler (SIGINT, trap_handler));\n\n   \n  else if (interactive)\t \n    return (set_signal_handler (SIGINT, sigint_sighandler));\n  else\n    return (set_signal_handler (SIGINT, termsig_sighandler));\n}\n\n \nSigHandler *\ntrap_to_sighandler (sig)\n     int sig;\n{\n  if (sigmodes[sig] & (SIG_IGNORED|SIG_HARD_IGNORE))\n    return (SIG_IGN);\n  else if (sigmodes[sig] & SIG_TRAPPED)\n    return (trap_handler);\n  else\n    return (SIG_DFL);\n}\n\n \nvoid\nset_signal (sig, string)\n     int sig;\n     char *string;\n{\n  sigset_t set, oset;\n\n  if (SPECIAL_TRAP (sig))\n    {\n      change_signal (sig, savestring (string));\n      if (sig == EXIT_TRAP && interactive == 0)\n\tinitialize_terminating_signals ();\n      return;\n    }\n\n   \n  if (sigmodes[sig] & SIG_HARD_IGNORE)\n    return;\n\n   \n  if ((sigmodes[sig] & SIG_TRAPPED) == 0)\n    {\n       \n      if (original_signals[sig] == IMPOSSIBLE_TRAP_HANDLER)\n        GETORIGSIG (sig);\n      if (original_signals[sig] == SIG_IGN)\n\treturn;\n    }\n\n   \n  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)\n    {\n      BLOCK_SIGNAL (sig, set, oset);\n      change_signal (sig, savestring (string));\n      set_signal_handler (sig, trap_handler);\n      UNBLOCK_SIGNAL (oset);\n    }\n  else\n    change_signal (sig, savestring (string));\n}\n\nstatic void\nfree_trap_command (sig)\n     int sig;\n{\n  if ((sigmodes[sig] & SIG_TRAPPED) && trap_list[sig] &&\n      (trap_list[sig] != (char *)IGNORE_SIG) &&\n      (trap_list[sig] != (char *)DEFAULT_SIG) &&\n      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))\n    free (trap_list[sig]);\n}\n\n \nstatic void\nchange_signal (sig, value)\n     int sig;\n     char *value;\n{\n  if ((sigmodes[sig] & SIG_INPROGRESS) == 0)\n    free_trap_command (sig);\n  trap_list[sig] = value;\n\n  sigmodes[sig] |= SIG_TRAPPED;\n  if (value == (char *)IGNORE_SIG)\n    sigmodes[sig] |= SIG_IGNORED;\n  else\n    sigmodes[sig] &= ~SIG_IGNORED;\n  if (sigmodes[sig] & SIG_INPROGRESS)\n    sigmodes[sig] |= SIG_CHANGED;\n}\n\nvoid\nget_original_signal (sig)\n     int sig;\n{\n   \n  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)\n    GETORIGSIG (sig);\n}\n\nvoid\nget_all_original_signals ()\n{\n  register int i;\n\n  for (i = 1; i < NSIG; i++)\n    GET_ORIGINAL_SIGNAL (i);\n}\n\nvoid\nset_original_signal (sig, handler)\n     int sig;\n     SigHandler *handler;\n{\n  if (sig > 0 && sig < NSIG && original_signals[sig] == (SigHandler *)IMPOSSIBLE_TRAP_HANDLER)\n    SETORIGSIG (sig, handler);\n}\n\n \nvoid\nrestore_default_signal (sig)\n     int sig;\n{\n  if (SPECIAL_TRAP (sig))\n    {\n      if ((sig != DEBUG_TRAP && sig != ERROR_TRAP && sig != RETURN_TRAP) ||\n\t  (sigmodes[sig] & SIG_INPROGRESS) == 0)\n\tfree_trap_command (sig);\n      trap_list[sig] = (char *)NULL;\n      sigmodes[sig] &= ~SIG_TRAPPED;\n      if (sigmodes[sig] & SIG_INPROGRESS)\n\tsigmodes[sig] |= SIG_CHANGED;\n      return;\n    }\n\n  GET_ORIGINAL_SIGNAL (sig);\n\n   \n  if (sigmodes[sig] & SIG_HARD_IGNORE)\n    return;\n\n   \n   \n  if (((sigmodes[sig] & SIG_TRAPPED) == 0) &&\n      (sig != SIGCHLD || (sigmodes[sig] & SIG_INPROGRESS) == 0 || trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER))\n    return;\n\n   \n  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)\n    set_signal_handler (sig, original_signals[sig]);\n\n   \n  change_signal (sig, (char *)DEFAULT_SIG);\n\n   \n  sigmodes[sig] &= ~SIG_TRAPPED;\n}\n\n \nvoid\nignore_signal (sig)\n     int sig;\n{\n  if (SPECIAL_TRAP (sig) && ((sigmodes[sig] & SIG_IGNORED) == 0))\n    {\n      change_signal (sig, (char *)IGNORE_SIG);\n      return;\n    }\n\n  GET_ORIGINAL_SIGNAL (sig);\n\n   \n  if (sigmodes[sig] & SIG_HARD_IGNORE)\n    return;\n\n   \n  if (sigmodes[sig] & SIG_IGNORED)\n    return;\n\n   \n  if ((sigmodes[sig] & SIG_NO_TRAP) == 0)\n    set_signal_handler (sig, SIG_IGN);\n\n   \n  change_signal (sig, (char *)IGNORE_SIG);\n}\n\n \nint\nrun_exit_trap ()\n{\n  char *trap_command;\n  int code, function_code, retval;\n#if defined (ARRAY_VARS)\n  ARRAY *ps;\n#endif\n\n  trap_saved_exit_value = last_command_exit_value;\n#if defined (ARRAY_VARS)\n  ps = save_pipestatus_array ();\n#endif\n  function_code = 0;\n\n   \n  if ((sigmodes[EXIT_TRAP] & SIG_TRAPPED) &&\n      (sigmodes[EXIT_TRAP] & (SIG_IGNORED|SIG_INPROGRESS)) == 0)\n    {\n      trap_command = savestring (trap_list[EXIT_TRAP]);\n      sigmodes[EXIT_TRAP] &= ~SIG_TRAPPED;\n      sigmodes[EXIT_TRAP] |= SIG_INPROGRESS;\n\n      retval = trap_saved_exit_value;\n      running_trap = 1;\n\n      code = setjmp_nosigs (top_level);\n\n       \n      if (return_catch_flag)\n\tfunction_code = setjmp_nosigs (return_catch);\n\n      if (code == 0 && function_code == 0)\n\t{\n\t  reset_parser ();\n\t  parse_and_execute (trap_command, \"exit trap\", SEVAL_NONINT|SEVAL_NOHIST|SEVAL_RESETLINE|SEVAL_NOOPTIMIZE);\n\t}\n      else if (code == ERREXIT)\n\tretval = last_command_exit_value;\n      else if (code == EXITPROG || code == EXITBLTIN)\n\tretval = last_command_exit_value;\n      else if (function_code != 0)\n        retval = return_catch_value;\n      else\n\tretval = trap_saved_exit_value;\n\n      running_trap = 0;\n#if defined (ARRAY_VARS)\n      array_dispose (ps);\n#endif\n\n      return retval;\n    }\n\n#if defined (ARRAY_VARS)\n  restore_pipestatus_array (ps);\n#endif\n  return (trap_saved_exit_value);\n}\n\nvoid\nrun_trap_cleanup (sig)\n     int sig;\n{\n   \n  sigmodes[sig] &= ~(SIG_INPROGRESS|SIG_CHANGED);\n}\n\n#define RECURSIVE_SIG(s) (SPECIAL_TRAP(s) == 0)\n\n \nstatic int\n_run_trap_internal (sig, tag)\n     int sig;\n     char *tag;\n{\n  char *trap_command, *old_trap;\n  int trap_exit_value;\n  volatile int save_return_catch_flag, function_code;\n  int old_modes, old_running, old_int;\n  int flags;\n  procenv_t save_return_catch;\n  WORD_LIST *save_subst_varlist;\n  HASH_TABLE *save_tempenv;\n  sh_parser_state_t pstate;\n#if defined (ARRAY_VARS)\n  ARRAY *ps;\n#endif\n\n  old_modes = old_running = -1;\n\n  trap_exit_value = function_code = 0;\n  trap_saved_exit_value = last_command_exit_value;\n   \n  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0) &&\n      (trap_list[sig] != (char *)IMPOSSIBLE_TRAP_HANDLER) &&\n#if 1\n       \n      (RECURSIVE_SIG (sig) || (sigmodes[sig] & SIG_INPROGRESS) == 0))\n#else\n      ((sigmodes[sig] & SIG_INPROGRESS) == 0))\n#endif\n    {\n      old_trap = trap_list[sig];\n      old_modes = sigmodes[sig];\n      old_running = running_trap;\n\n      sigmodes[sig] |= SIG_INPROGRESS;\n      sigmodes[sig] &= ~SIG_CHANGED;\t\t \n      trap_command =  savestring (old_trap);\n\n      running_trap = sig + 1;\n\n      old_int = interrupt_state;\t \n      CLRINTERRUPT;\n\n#if defined (ARRAY_VARS)\n      ps = save_pipestatus_array ();\n#endif\n\n      save_parser_state (&pstate);\n      save_subst_varlist = subst_assign_varlist;\n      subst_assign_varlist = 0;\n      save_tempenv = temporary_env;\n      temporary_env = 0;\t \n\n#if defined (JOB_CONTROL)\n      if (sig != DEBUG_TRAP)\t \n\tsave_pipeline (1);\t \n#endif\n\n       \n      save_return_catch_flag = return_catch_flag;\n      if (return_catch_flag)\n\t{\n\t  COPY_PROCENV (return_catch, save_return_catch);\n\t  function_code = setjmp_nosigs (return_catch);\n\t}\n\n      flags = SEVAL_NONINT|SEVAL_NOHIST|SEVAL_NOOPTIMIZE;\n      if (sig != DEBUG_TRAP && sig != RETURN_TRAP && sig != ERROR_TRAP)\n\tflags |= SEVAL_RESETLINE;\n      evalnest++;\n      if (function_code == 0)\n        {\n\t  parse_and_execute (trap_command, tag, flags);\n\t  trap_exit_value = last_command_exit_value;\n        }\n      else\n        trap_exit_value = return_catch_value;\n      evalnest--;\n\n#if defined (JOB_CONTROL)\n      if (sig != DEBUG_TRAP)\t \n\trestore_pipeline (1);\n#endif\n\n      subst_assign_varlist = save_subst_varlist;\n      restore_parser_state (&pstate);\n\n#if defined (ARRAY_VARS)\n      restore_pipestatus_array (ps);\n#endif\n\n      temporary_env = save_tempenv;\n\n      if ((old_modes & SIG_INPROGRESS) == 0)\n\tsigmodes[sig] &= ~SIG_INPROGRESS;\n\n      running_trap = old_running;\n      interrupt_state = old_int;\n\n      if (sigmodes[sig] & SIG_CHANGED)\n\t{\n#if 0\n\t   \n\t  if (SPECIAL_TRAP (sig) == 0)\n#endif\n\t    free (old_trap);\n\t  sigmodes[sig] &= ~SIG_CHANGED;\n\n\t  CHECK_TERMSIG;\t \n\t}\n\n      if (save_return_catch_flag)\n\t{\n\t  return_catch_flag = save_return_catch_flag;\n\t  return_catch_value = trap_exit_value;\n\t  COPY_PROCENV (save_return_catch, return_catch);\n\t  if (function_code)\n\t    {\n#if 0\n\t      from_return_trap = sig == RETURN_TRAP;\n#endif\n\t      sh_longjmp (return_catch, 1);\n\t    }\n\t}\n    }\n\n  return trap_exit_value;\n}\n\nint\nrun_debug_trap ()\n{\n  int trap_exit_value, old_verbose;\n  pid_t save_pgrp;\n#if defined (PGRP_PIPE)\n  int save_pipe[2];\n#endif\n\n   \n  trap_exit_value = 0;\n  if ((sigmodes[DEBUG_TRAP] & SIG_TRAPPED) && ((sigmodes[DEBUG_TRAP] & SIG_IGNORED) == 0) && ((sigmodes[DEBUG_TRAP] & SIG_INPROGRESS) == 0))\n    {\n#if defined (JOB_CONTROL)\n      save_pgrp = pipeline_pgrp;\n      pipeline_pgrp = 0;\n      save_pipeline (1);\n#  if defined (PGRP_PIPE)\n      save_pgrp_pipe (save_pipe, 1);\n#  endif\n      stop_making_children ();\n#endif\n\n      old_verbose = echo_input_at_read;\n      echo_input_at_read = suppress_debug_trap_verbose ? 0 : echo_input_at_read;\n\n      trap_exit_value = _run_trap_internal (DEBUG_TRAP, \"debug trap\");\n\n      echo_input_at_read = old_verbose;\n\n#if defined (JOB_CONTROL)\n      pipeline_pgrp = save_pgrp;\n      restore_pipeline (1);\n#  if defined (PGRP_PIPE)\n      close_pgrp_pipe ();\n      restore_pgrp_pipe (save_pipe);\n#  endif\n      if (pipeline_pgrp > 0 && ((subshell_environment & (SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0))\n\tgive_terminal_to (pipeline_pgrp, 1);\n\n      notify_and_cleanup ();\n#endif\n      \n#if defined (DEBUGGER)\n       \n      if (debugging_mode && trap_exit_value == 2 && return_catch_flag)\n\t{\n\t  return_catch_value = trap_exit_value;\n\t  sh_longjmp (return_catch, 1);\n\t}\n#endif\n    }\n  return trap_exit_value;\n}\n\nvoid\nrun_error_trap ()\n{\n  if ((sigmodes[ERROR_TRAP] & SIG_TRAPPED) && ((sigmodes[ERROR_TRAP] & SIG_IGNORED) == 0) && (sigmodes[ERROR_TRAP] & SIG_INPROGRESS) == 0)\n    _run_trap_internal (ERROR_TRAP, \"error trap\");\n}\n\nvoid\nrun_return_trap ()\n{\n  int old_exit_value;\n\n#if 0\n  if ((sigmodes[DEBUG_TRAP] & SIG_TRAPPED) && (sigmodes[DEBUG_TRAP] & SIG_INPROGRESS))\n    return;\n#endif\n\n  if ((sigmodes[RETURN_TRAP] & SIG_TRAPPED) && ((sigmodes[RETURN_TRAP] & SIG_IGNORED) == 0) && (sigmodes[RETURN_TRAP] & SIG_INPROGRESS) == 0)\n    {\n      old_exit_value = last_command_exit_value;\n      _run_trap_internal (RETURN_TRAP, \"return trap\");\n      last_command_exit_value = old_exit_value;\n    }\n}\n\n \nvoid\nrun_interrupt_trap (will_throw)\n     int will_throw;\t \n{\n  if (will_throw && running_trap > 0)\n    run_trap_cleanup (running_trap - 1);\n  pending_traps[SIGINT] = 0;\t \n  catch_flag = 0;\n  _run_trap_internal (SIGINT, \"interrupt trap\");\n}\n\n \nvoid\nfree_trap_strings ()\n{\n  register int i;\n\n  for (i = 0; i < NSIG; i++)\n    {\n      if (trap_list[i] != (char *)IGNORE_SIG)\n\tfree_trap_string (i);\n    }\n  for (i = NSIG; i < BASH_NSIG; i++)\n    {\n       \n      if ((sigmodes[i] & SIG_TRAPPED) == 0)\n\t{\n\t  free_trap_string (i);\n\t  trap_list[i] = (char *)NULL;\n\t}\n    }\n}\n\n \nstatic void\nfree_trap_string (sig)\n     int sig;\n{\n  change_signal (sig, (char *)DEFAULT_SIG);\n  sigmodes[sig] &= ~SIG_TRAPPED;\t\t \n}\n\n \nstatic void\nreset_signal (sig)\n     int sig;\n{\n  set_signal_handler (sig, original_signals[sig]);\n  sigmodes[sig] &= ~SIG_TRAPPED;\t\t \n}\n\n \nstatic void\nrestore_signal (sig)\n     int sig;\n{\n  set_signal_handler (sig, original_signals[sig]);\n  change_signal (sig, (char *)DEFAULT_SIG);\n  sigmodes[sig] &= ~SIG_TRAPPED;\n}\n\nstatic void\nreset_or_restore_signal_handlers (reset)\n     sh_resetsig_func_t *reset;\n{\n  register int i;\n\n   \n  if (sigmodes[EXIT_TRAP] & SIG_TRAPPED)\n    {\n      sigmodes[EXIT_TRAP] &= ~SIG_TRAPPED;\t \n      if (reset != reset_signal)\n\t{\n\t  free_trap_command (EXIT_TRAP);\n\t  trap_list[EXIT_TRAP] = (char *)NULL;\n\t}\n    }\n\n  for (i = 1; i < NSIG; i++)\n    {\n      if (sigmodes[i] & SIG_TRAPPED)\n\t{\n\t  if (trap_list[i] == (char *)IGNORE_SIG)\n\t    set_signal_handler (i, SIG_IGN);\n\t  else\n\t    (*reset) (i);\n\t}\n      else if (sigmodes[i] & SIG_SPECIAL)\n\t(*reset) (i);\n      pending_traps[i] = 0;\t \n    }\n\n   \n  if (function_trace_mode == 0)\n    {\n      sigmodes[DEBUG_TRAP] &= ~SIG_TRAPPED;\n      sigmodes[RETURN_TRAP] &= ~SIG_TRAPPED;\n    }\n  if (error_trace_mode == 0)\n    sigmodes[ERROR_TRAP] &= ~SIG_TRAPPED;\n}\n\n \nvoid\nreset_signal_handlers ()\n{\n  reset_or_restore_signal_handlers (reset_signal);\n}\n\n \nvoid\nrestore_original_signals ()\n{\n  reset_or_restore_signal_handlers (restore_signal);\n}\n\n \nstatic void\nreinit_trap (sig)\n     int sig;\n{\n  sigmodes[sig] |= SIG_TRAPPED;\n  if (trap_list[sig] == (char *)IGNORE_SIG)\n    sigmodes[sig] |= SIG_IGNORED;\n  else\n    sigmodes[sig] &= ~SIG_IGNORED;\n  if (sigmodes[sig] & SIG_INPROGRESS)\n    sigmodes[sig] |= SIG_CHANGED;\n}\n\n \nvoid\nrestore_traps ()\n{\n  char *trapstr;\n  int i;\n\n   \n  trapstr = trap_list[EXIT_TRAP];\n  if (trapstr)\n    reinit_trap (EXIT_TRAP);\n\n   \n  trapstr = trap_list[DEBUG_TRAP];\n  if (trapstr && function_trace_mode == 0)\n    reinit_trap (DEBUG_TRAP);\n  trapstr = trap_list[RETURN_TRAP];\n  if (trapstr && function_trace_mode == 0)\n    reinit_trap (RETURN_TRAP);\n  trapstr = trap_list[ERROR_TRAP];\n  if (trapstr && error_trace_mode == 0)\n    reinit_trap (ERROR_TRAP);\n\n   \n  for (i = 1; i < NSIG; i++)\n    {\n      trapstr = trap_list[i];\n      if (sigmodes[i] & SIG_SPECIAL)\n\t{\n\t  if (trapstr && trapstr != (char *)DEFAULT_SIG)\n\t    reinit_trap (i);\n\t  if (trapstr == (char *)IGNORE_SIG && (sigmodes[i] & SIG_NO_TRAP) == 0)\n\t    set_signal_handler (i, SIG_IGN);\n\t}\n      else if (trapstr == (char *)IGNORE_SIG)\n\t{\n\t  reinit_trap (i);\n\t  if ((sigmodes[i] & SIG_NO_TRAP) == 0)\n\t    set_signal_handler (i, SIG_IGN);\n\t}\n      else if (trapstr != (char *)DEFAULT_SIG)\n         \n\tset_signal (i, trapstr);\n\n      pending_traps[i] = 0;\t \n    }\n}\n\n \nint\nmaybe_call_trap_handler (sig)\n     int sig;\n{\n   \n  if ((sigmodes[sig] & SIG_TRAPPED) && ((sigmodes[sig] & SIG_IGNORED) == 0))\n    {\n      switch (sig)\n\t{\n\tcase SIGINT:\n\t  run_interrupt_trap (0);\n\t  break;\n\tcase EXIT_TRAP:\n\t  run_exit_trap ();\n\t  break;\n\tcase DEBUG_TRAP:\n\t  run_debug_trap ();\n\t  break;\n\tcase ERROR_TRAP:\n\t  run_error_trap ();\n\t  break;\n\tdefault:\n\t  trap_handler (sig);\n\t  break;\n\t}\n      return (1);\n    }\n  else\n    return (0);\n}\n\nint\nsignal_is_trapped (sig)\n     int sig;\n{\n  return (sigmodes[sig] & SIG_TRAPPED);\n}\n\nint\nsignal_is_pending (sig)\n     int sig;\n{\n  return (pending_traps[sig]);\n}\n\nint\nsignal_is_special (sig)\n     int sig;\n{\n  return (sigmodes[sig] & SIG_SPECIAL);\n}\n\nint\nsignal_is_ignored (sig)\n     int sig;\n{\n  return (sigmodes[sig] & SIG_IGNORED);\n}\n\nint\nsignal_is_hard_ignored (sig)\n     int sig;\n{\n  return (sigmodes[sig] & SIG_HARD_IGNORE);\n}\n\nvoid\nset_signal_hard_ignored (sig)\n     int sig;\n{\n  sigmodes[sig] |= SIG_HARD_IGNORE;\n  original_signals[sig] = SIG_IGN;\n}\n\nvoid\nset_signal_ignored (sig)\n     int sig;\n{\n  original_signals[sig] = SIG_IGN;\n}\n\nint\nsignal_in_progress (sig)\n     int sig;\n{\n  return (sigmodes[sig] & SIG_INPROGRESS);\n}\n\n#if 0  \nint\nblock_trapped_signals (maskp, omaskp)\n     sigset_t *maskp;\n     sigset_t *omaskp;\n{\n  int i;\n\n  sigemptyset (maskp);\n  for (i = 1; i < NSIG; i++)\n    if (sigmodes[i] & SIG_TRAPPED)\n      sigaddset (maskp, i);\n  return (sigprocmask (SIG_BLOCK, maskp, omaskp));\n}\n\nint\nunblock_trapped_signals (maskp)\n     sigset_t *maskp;\n{\n  return (sigprocmask (SIG_SETMASK, maskp, 0));\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}