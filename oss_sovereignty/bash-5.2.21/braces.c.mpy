{
  "module_name": "braces.c",
  "hash_id": "4a942a97bbba15fe76b4d55308ef602a2bbcae67af8e0fbac38167cfe1fc5803",
  "original_prompt": "Ingested from bash-5.2.21/braces.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"config.h\"\n\n#if defined (BRACE_EXPANSION)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <errno.h>\n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#if defined (SHELL)\n#  include \"shell.h\"\n#else\n#  if defined (TEST)\ntypedef char *WORD_DESC;\ntypedef char **WORD_LIST;\n#define _(X)\tX\n#  endif  \n#endif  \n\n#include \"typemax.h\"\t\t \n#include \"general.h\"\n#include \"shmbutil.h\"\n#include \"chartypes.h\"\n\n#ifndef errno\nextern int errno;\n#endif\n\n#define brace_whitespace(c) (!(c) || (c) == ' ' || (c) == '\\t' || (c) == '\\n')\n\n#define BRACE_SEQ_SPECIFIER\t\"..\"\n\nextern int asprintf PARAMS((char **, const char *, ...)) __attribute__((__format__ (printf, 2, 3)));\n\n \n\n \nstatic const int brace_arg_separator = ',';\n\n#if defined (PARAMS)\nstatic int brace_gobbler PARAMS((char *, size_t, int *, int));\nstatic char **expand_amble PARAMS((char *, size_t, int));\nstatic char **expand_seqterm PARAMS((char *, size_t));\nstatic char **mkseq PARAMS((intmax_t, intmax_t, intmax_t, int, int));\nstatic char **array_concat PARAMS((char **, char **));\n#else\nstatic int brace_gobbler ();\nstatic char **expand_amble ();\nstatic char **expand_seqterm ();\nstatic char **mkseq();\nstatic char **array_concat ();\n#endif\n\n#if 0\nstatic void\ndump_result (a)\n     char **a;\n{\n  int i;\n\n  for (i = 0; a[i]; i++)\n    printf (\"dump_result: a[%d] = -%s-\\n\", i, a[i]);\n}\n#endif\n\n \nchar **\nbrace_expand (text)\n     char *text;\n{\n  register int start;\n  size_t tlen;\n  char *preamble, *postamble, *amble;\n  size_t alen;\n  char **tack, **result;\n  int i, j, c, c1;\n\n  DECLARE_MBSTATE;\n\n   \n  tlen = strlen (text);\n  i = 0;\n#if defined (CSH_BRACE_COMPAT)\n  c = brace_gobbler (text, tlen, &i, '{');\t \n#else\n   \n  do\n    {\n      c = brace_gobbler (text, tlen, &i, '{');\t \n      c1 = c;\n       \n      if (c)\n\t{\n\t  start = j = i + 1;\t \n\t  c = brace_gobbler (text, tlen, &j, '}');\n\t  if (c == 0)\t\t \n\t    {\n\t      i++;\n\t      c = c1;\n\t      continue;\n\t    }\n\t  else\t\t\t \n\t    {\n\t      c = c1;\n\t      break;\n\t    }\n\t}\n      else\n\tbreak;\n    }\n  while (c);\n#endif  \n\n  preamble = (char *)xmalloc (i + 1);\n  if (i > 0)\n    strncpy (preamble, text, i);\n  preamble[i] = '\\0';\n\n  result = (char **)xmalloc (2 * sizeof (char *));\n  result[0] = preamble;\n  result[1] = (char *)NULL;\n\n   \n  if (c != '{')\n    return (result);\n\n   \n  start = ++i;\n  c = brace_gobbler (text, tlen, &i, '}');\n\n   \n  if (c == 0)\n    {\n#if defined (NOTDEF)\n       \n      j = start;\n      while (j < i)\n\t{\n\t  if (text[j] == '\\\\')\n\t    {\n\t      j++;\n\t      ADVANCE_CHAR (text, tlen, j);\n\t      continue;\n\t    }\n\n\t  if (text[j] == brace_arg_separator)\n\t    {\t \n\t      strvec_dispose (result);\n\t      set_exit_status (EXECUTION_FAILURE);\n\t      report_error (\"no closing `%c' in %s\", '}', text);\n\t      throw_to_top_level ();\n\t    }\n\t  ADVANCE_CHAR (text, tlen, j);\n\t}\n#endif\n      free (preamble);\t\t \n      result[0] = savestring (text);\n      return (result);\n    }\n\n#if defined (SHELL)\n  amble = substring (text, start, i);\n  alen = i - start;\n#else\n  amble = (char *)xmalloc (1 + (i - start));\n  strncpy (amble, &text[start], (i - start));\n  alen = i - start;\n  amble[alen] = '\\0';\n#endif\n\n#if defined (SHELL)\n  INITIALIZE_MBSTATE;\n\n   \n  j = 0;\n  while (amble[j])\n    {\n      if (amble[j] == '\\\\')\n\t{\n\t  j++;\n\t  ADVANCE_CHAR (amble, alen, j);\n\t  continue;\n\t}\n\n      if (amble[j] == brace_arg_separator)\n\tbreak;\n\n      ADVANCE_CHAR (amble, alen, j);\n    }\n\n  if (amble[j] == 0)\n    {\n      tack = expand_seqterm (amble, alen);\n      if (tack)\n\tgoto add_tack;\n      else if (text[i + 1])\n\t{\n\t   \n\t  tack = strvec_create (2);\n\t  tack[0] = savestring (text+start-1);\n\t  tack[0][i-start+2] = '\\0';\n\t  tack[1] = (char *)0;\n\t  goto add_tack;\n\t}\n      else\n\t{\n\t  free (amble);\n\t  free (preamble);\n\t  result[0] = savestring (text);\n\t  return (result);\n\t}\n    }\n#endif  \n\n  tack = expand_amble (amble, alen, 0);\nadd_tack:\n  result = array_concat (result, tack);\n  free (amble);\n  if (tack != result)\n    strvec_dispose (tack);\n\n  postamble = text + i + 1;\n\n  if (postamble && *postamble)\n    {\n      tack = brace_expand (postamble);\n      result = array_concat (result, tack);\n      if (tack != result)\n\tstrvec_dispose (tack);\n    }\n\n  return (result);\n}\n\n \nstatic char **\nexpand_amble (text, tlen, flags)\n     char *text;\n     size_t tlen;\n     int flags;\n{\n  char **result, **partial, **tresult;\n  char *tem;\n  int start, i, c;\n\n#if defined (SHELL)\n  DECLARE_MBSTATE;\n#endif\n\n  result = (char **)NULL;\n\n  start = i = 0;\n  c = 1;\n  while (c)\n    {\n      c = brace_gobbler (text, tlen, &i, brace_arg_separator);\n#if defined (SHELL)\n      tem = substring (text, start, i);\n#else\n      tem = (char *)xmalloc (1 + (i - start));\n      strncpy (tem, &text[start], (i - start));\n      tem[i - start] = '\\0';\n#endif\n\n      partial = brace_expand (tem);\n\n      if (!result)\n\tresult = partial;\n      else\n\t{\n\t  register int lr, lp, j;\n\n\t  lr = strvec_len (result);\n\t  lp = strvec_len (partial);\n\n\t  tresult = strvec_mresize (result, lp + lr + 1);\n\t  if (tresult == 0)\n\t    {\n\t      internal_error (_(\"brace expansion: cannot allocate memory for %s\"), tem);\n\t      free (tem);\n\t      strvec_dispose (partial);\n\t      strvec_dispose (result);\n\t      result = (char **)NULL;\n\t      return result;\n\t    }\n\t  else\n\t    result = tresult;\n\n\t  for (j = 0; j < lp; j++)\n\t    result[lr + j] = partial[j];\n\n\t  result[lr + j] = (char *)NULL;\n\t  free (partial);\n\t}\n      free (tem);\n#if defined (SHELL)\n      ADVANCE_CHAR (text, tlen, i);\n#else\n      i++;\n#endif\n      start = i;\n    }\n  return (result);\n}\n\n#define ST_BAD\t0\n#define ST_INT\t1\n#define ST_CHAR\t2\n#define ST_ZINT\t3\n\nstatic char **\nmkseq (start, end, incr, type, width)\n     intmax_t start, end, incr;\n     int type, width;\n{\n  intmax_t n, prevn;\n  int i, nelem;\n  char **result, *t;\n\n  if (incr == 0)\n    incr = 1;\n\n  if (start > end && incr > 0)\n    incr = -incr;\n  else if (start < end && incr < 0)\n    {\n      if (incr == INTMAX_MIN)\t\t \n\treturn ((char **)NULL);\n      incr = -incr;\n    }\n\n   \n  if (SUBOVERFLOW (end, start, INTMAX_MIN+3, INTMAX_MAX-2))\n    return ((char **)NULL);\n\n  prevn = sh_imaxabs (end - start);\n   \n  if (INT_MAX == INTMAX_MAX && (ADDOVERFLOW (prevn, 2, INT_MIN, INT_MAX)))\n    return ((char **)NULL);\n   \n  else if (ADDOVERFLOW ((prevn/sh_imaxabs(incr)), 1, INTMAX_MIN, INTMAX_MAX))\n    return ((char **)NULL);\n\n   \n   \n  if ((prevn / sh_imaxabs (incr)) > INT_MAX - 3)\t \n    return ((char **)NULL);\n  nelem = (prevn / sh_imaxabs(incr)) + 1;\n  result = strvec_mcreate (nelem + 1);\n  if (result == 0)\n    {\n      internal_error (_(\"brace expansion: failed to allocate memory for %u elements\"), (unsigned int)nelem);\n      return ((char **)NULL);\n    }\n\n   \n  i = 0;\n  n = start;\n  do\n    {\n#if defined (SHELL)\n      if (ISINTERRUPT)\n        {\n          result[i] = (char *)NULL;\n          strvec_dispose (result);\n          result = (char **)NULL;\n        }\n      QUIT;\n#endif\n      if (type == ST_INT)\n\tresult[i++] = t = itos (n);\n      else if (type == ST_ZINT)\n\t{\n\t  int len, arg;\n\t  arg = n;\n\t  len = asprintf (&t, \"%0*d\", width, arg);\n\t  result[i++] = t;\n\t}\n      else\n\t{\n\t  if (t = (char *)malloc (2))\n\t    {\n\t      t[0] = n;\n\t      t[1] = '\\0';\n\t    }\n\t  result[i++] = t;\n\t}\n\n       \n      if (t == 0)\n\t{\n\t  char *p, lbuf[INT_STRLEN_BOUND(intmax_t) + 1];\n\n\t   \n\t  p = inttostr (n, lbuf, sizeof (lbuf));\n\t  internal_error (_(\"brace expansion: failed to allocate memory for `%s'\"), p);\n\t  strvec_dispose (result);\n\t  return ((char **)NULL);\n\t}\n\n       \n      if (ADDOVERFLOW (n, incr, INTMAX_MIN, INTMAX_MAX))\n        break;\n\n      n += incr;\n\n      if ((incr < 0 && n < end) || (incr > 0 && n > end))\n\tbreak;\n    }\n  while (1);\n\n  result[i] = (char *)0;\n  return (result);\n}\n\nstatic char **\nexpand_seqterm (text, tlen)\n     char *text;\n     size_t tlen;\n{\n  char *t, *lhs, *rhs;\n  int lhs_t, rhs_t, lhs_l, rhs_l, width;\n  intmax_t lhs_v, rhs_v, incr;\n  intmax_t tl, tr;\n  char **result, *ep, *oep;\n\n  t = strstr (text, BRACE_SEQ_SPECIFIER);\n  if (t == 0)\n    return ((char **)NULL);\n\n  lhs_l = t - text;\t\t \n  lhs = substring (text, 0, lhs_l);\n  rhs = substring (text, lhs_l + sizeof(BRACE_SEQ_SPECIFIER) - 1, tlen);\n\n  if (lhs[0] == 0 || rhs[0] == 0)\n    {\n      free (lhs);\n      free (rhs);\n      return ((char **)NULL);\n    }\n\n   \n  lhs_t = (legal_number (lhs, &tl)) ? ST_INT :\n  \t\t((ISALPHA (lhs[0]) && lhs[1] == 0) ?  ST_CHAR : ST_BAD);\n\n   \n  ep = 0;\n  if (ISDIGIT (rhs[0]) || ((rhs[0] == '+' || rhs[0] == '-') && ISDIGIT (rhs[1])))\n    {\n      rhs_t = ST_INT;\n      errno = 0;\n      tr = strtoimax (rhs, &ep, 10);\n      if (errno == ERANGE || (ep && *ep != 0 && *ep != '.'))\n\trhs_t = ST_BAD;\t\t\t \n    }\n  else if (ISALPHA (rhs[0]) && (rhs[1] == 0 || rhs[1] == '.'))\n    {\n      rhs_t = ST_CHAR;\n      ep = rhs + 1;\n    }\n  else\n    {\n      rhs_t = ST_BAD;\n      ep = 0;\n    }\n\n  incr = 1;\n  if (rhs_t != ST_BAD)\n    {\n      oep = ep;\n      errno = 0;\n      if (ep && *ep == '.' && ep[1] == '.' && ep[2])\n\tincr = strtoimax (ep + 2, &ep, 10);\n      if (*ep != 0 || errno == ERANGE)\n\trhs_t = ST_BAD;\t\t\t \n      tlen -= ep - oep;\n    }\n\n  if (lhs_t != rhs_t || lhs_t == ST_BAD || rhs_t == ST_BAD)\n    {\n      free (lhs);\n      free (rhs);\n      return ((char **)NULL);\n    }\n\n   \n  \n  if (lhs_t == ST_CHAR)\n    {\n      lhs_v = (unsigned char)lhs[0];\n      rhs_v = (unsigned char)rhs[0];\n      width = 1;\n    }\n  else\n    {\n      lhs_v = tl;\t\t \n      rhs_v = tr;\n\n       \n      rhs_l = tlen - lhs_l - sizeof (BRACE_SEQ_SPECIFIER) + 1;\n      width = 0;\n      if (lhs_l > 1 && lhs[0] == '0')\n\twidth = lhs_l, lhs_t = ST_ZINT;\n      if (lhs_l > 2 && lhs[0] == '-' && lhs[1] == '0')\n\twidth = lhs_l, lhs_t = ST_ZINT;\n      if (rhs_l > 1 && rhs[0] == '0' && width < rhs_l)\n\twidth = rhs_l, lhs_t = ST_ZINT;\n      if (rhs_l > 2 && rhs[0] == '-' && rhs[1] == '0' && width < rhs_l)\n\twidth = rhs_l, lhs_t = ST_ZINT;\n\n      if (width < lhs_l && lhs_t == ST_ZINT)\n        width = lhs_l;\n      if (width < rhs_l && lhs_t == ST_ZINT)\n        width = rhs_l;\n    }\n\n  result = mkseq (lhs_v, rhs_v, incr, lhs_t, width);\n\n  free (lhs);\n  free (rhs);\n\n  return (result);\n}\n\n \n \nstatic int\nbrace_gobbler (text, tlen, indx, satisfy)\n     char *text;\n     size_t tlen;\n     int *indx;\n     int satisfy;\n{\n  register int i, c, quoted, level, commas, pass_next;\n#if defined (SHELL)\n  int si;\n  char *t;\n#endif\n  DECLARE_MBSTATE;\n\n  level = quoted = pass_next = 0;\n#if defined (CSH_BRACE_COMPAT)\n  commas = 1;\n#else\n  commas = (satisfy == '}') ? 0 : 1;\n#endif\n\n  i = *indx;\n  while (c = text[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n#if defined (SHELL)\n\t  ADVANCE_CHAR (text, tlen, i);\n#else\n\t  i++;\n#endif\n\t  continue;\n\t}\n\n       \n      if (c == '\\\\' && (quoted == 0 || quoted == '\"' || quoted == '`'))\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n\n#if defined (SHELL)\n       \n      if (c == '$' && text[i+1] == '{' && quoted != '\\'')\t\t \n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  if (quoted == 0)\n\t    level++;\n\t  continue;\n\t}\n#endif\n\n      if (quoted)\n\t{\n\t  if (c == quoted)\n\t    quoted = 0;\n#if defined (SHELL)\n\t   \n\t  if (quoted == '\"' && c == '$' && text[i+1] == '(')\t \n\t    goto comsub;\n#endif\n#if defined (SHELL)\n\t  ADVANCE_CHAR (text, tlen, i);\n#else\n\t  i++;\n#endif\n\t  continue;\n\t}\n\n      if (c == '\"' || c == '\\'' || c == '`')\n\t{\n\t  quoted = c;\n\t  i++;\n\t  continue;\n\t}\n\n#if defined (SHELL)\n       \n      if ((c == '$' || c == '<' || c == '>') && text[i+1] == '(')\t\t\t \n\t{\ncomsub:\n\t  si = i + 2;\n\t  t = extract_command_subst (text, &si, 0);\n\t  i = si;\n\t  free (t);\n\t  i++;\n\t  continue;\n\t}\n#endif\n\n      if (c == satisfy && level == 0 && quoted == 0 && commas > 0)\n\t{\n\t   \n\t  if (c == '{' &&\n\t      ((!i || brace_whitespace (text[i - 1])) &&\n\t       (brace_whitespace (text[i + 1]) || text[i + 1] == '}')))\n\t    {\n\t      i++;\n\t      continue;\n\t    }\n\n\t    break;\n\t}\n\n      if (c == '{')\n\tlevel++;\n      else if (c == '}' && level)\n\tlevel--;\n#if !defined (CSH_BRACE_COMPAT)\n      else if (satisfy == '}' && c == brace_arg_separator && level == 0)\n\tcommas++;\n      else if (satisfy == '}' && STREQN (text+i, BRACE_SEQ_SPECIFIER, 2) &&\n      \t\ttext[i+2] != satisfy && level == 0)\n\tcommas++;\n#endif\n\n#if defined (SHELL)\n      ADVANCE_CHAR (text, tlen, i);\n#else\n      i++;\n#endif\n    }\n\n  *indx = i;\n  return (c);\n}\n\n \nstatic char **\narray_concat (arr1, arr2)\n     char **arr1, **arr2;\n{\n  register int i, j, len, len1, len2;\n  register char **result;\n\n  if (arr1 == 0)\n    return (arr2);\t\t \n\n  if (arr2 == 0)\n    return (arr1);\t\t \n\n   \n  if (arr1[0] && arr1[0][0] == 0 && arr1[1] == 0)\n    {\n      strvec_dispose (arr1);\n      return (arr2);\t\t \n    }\n\n  if (arr2[0] && arr2[0][0] == 0 && arr2[1] == 0)\n    return (arr1);\t\t \n\n  len1 = strvec_len (arr1);\n  len2 = strvec_len (arr2);\n\n  result = (char **)malloc ((1 + (len1 * len2)) * sizeof (char *));\n  if (result == 0)\n    return (result);\n\n  len = 0;\n  for (i = 0; i < len1; i++)\n    {\n      int strlen_1 = strlen (arr1[i]);\n\n      for (j = 0; j < len2; j++)\n\t{\n\t  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));\n\t  strcpy (result[len], arr1[i]);\n\t  strcpy (result[len] + strlen_1, arr2[j]);\n\t  len++;\n\t}\n      free (arr1[i]);\n    }\n  free (arr1);\n\n  result[len] = (char *)NULL;\n  return (result);\n}\n\n#if defined (TEST)\n#include <stdio.h>\n\nvoid *\nxmalloc(n)\n     size_t n;\n{\n  return (malloc (n));\n}\n\nvoid *\nxrealloc(p, n)\n     void *p;\n     size_t n;\n{\n  return (realloc (p, n));\n}\n\nint\ninternal_error (format, arg1, arg2)\n     char *format, *arg1, *arg2;\n{\n  fprintf (stderr, format, arg1, arg2);\n  fprintf (stderr, \"\\n\");\n}\n      \nmain ()\n{\n  char example[256];\n\n  for (;;)\n    {\n      char **result;\n      int i;\n\n      fprintf (stderr, \"brace_expand> \");\n\n      if ((!fgets (example, 256, stdin)) ||\n\t  (strncmp (example, \"quit\", 4) == 0))\n\tbreak;\n\n      if (strlen (example))\n\texample[strlen (example) - 1] = '\\0';\n\n      result = brace_expand (example);\n\n      for (i = 0; result[i]; i++)\n\tprintf (\"%s\\n\", result[i]);\n\n      strvec_dispose (result);\n    }\n}\n\f\n \n\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}