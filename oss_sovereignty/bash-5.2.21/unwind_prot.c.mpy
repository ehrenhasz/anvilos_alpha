{
  "module_name": "unwind_prot.c",
  "hash_id": "889682d2d8dff9dc5def449f7d3ef95b7105975252a421c64af2fafd2fbcd562",
  "original_prompt": "Ingested from bash-5.2.21/unwind_prot.c",
  "human_readable_source": " \n\n \n\n \n\n \n \n \n \n \n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include \"bashansi.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#if defined (HAVE_STDDEF_H)\n#  include <stddef.h>\n#endif\n\n#ifndef offsetof\n#  define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n\n#include \"command.h\"\n#include \"general.h\"\n#include \"unwind_prot.h\"\n#include \"sig.h\"\n#include \"quit.h\"\n#include \"bashintl.h\"\t \n#include \"error.h\"\t \n#include \"ocache.h\"\n\n \ntypedef struct {\n  char *variable;\n  int size;\n  char desired_setting[1];  \n} SAVED_VAR;\n\n \ntypedef union uwp {\n  struct uwp_head {\n    union uwp *next;\n    Function *cleanup;\n  } head;\n  struct {\n    struct uwp_head uwp_head;\n    char *v;\n  } arg;\n  struct {\n    struct uwp_head uwp_head;\n    SAVED_VAR v;\n  } sv;\n} UNWIND_ELT;\n\nstatic void without_interrupts PARAMS((VFunction *, char *, char *));\nstatic void unwind_frame_discard_internal PARAMS((char *, char *));\nstatic void unwind_frame_run_internal PARAMS((char *, char *));\nstatic void add_unwind_protect_internal PARAMS((Function *, char *));\nstatic void remove_unwind_protect_internal PARAMS((char *, char *));\nstatic void run_unwind_protects_internal PARAMS((char *, char *));\nstatic void clear_unwind_protects_internal PARAMS((char *, char *));\nstatic inline void restore_variable PARAMS((SAVED_VAR *));\nstatic void unwind_protect_mem_internal PARAMS((char *, char *));\n\nstatic UNWIND_ELT *unwind_protect_list = (UNWIND_ELT *)NULL;\n\n \n#define UWCACHESIZE\t128\n\nsh_obj_cache_t uwcache = {0, 0, 0};\n\n#if 0\n#define uwpalloc(elt)\t(elt) = (UNWIND_ELT *)xmalloc (sizeof (UNWIND_ELT))\n#define uwpfree(elt)\tfree(elt)\n#else\n#define uwpalloc(elt)\tocache_alloc (uwcache, UNWIND_ELT, elt)\n#define uwpfree(elt)\tocache_free (uwcache, UNWIND_ELT, elt)\n#endif\n\nvoid\nuwp_init ()\n{\n  ocache_create (uwcache, UNWIND_ELT, UWCACHESIZE);\n}\n\n \nstatic void\nwithout_interrupts (function, arg1, arg2)\n     VFunction *function;\n     char *arg1, *arg2;\n{\n  (*function)(arg1, arg2);\n}\n\n \nvoid\nbegin_unwind_frame (tag)\n     char *tag;\n{\n  add_unwind_protect ((Function *)NULL, tag);\n}\n\n \nvoid\ndiscard_unwind_frame (tag)\n     char *tag;\n{\n  if (unwind_protect_list)\n    without_interrupts (unwind_frame_discard_internal, tag, (char *)NULL);\n}\n\n \nvoid\nrun_unwind_frame (tag)\n     char *tag;\n{\n  if (unwind_protect_list)\n    without_interrupts (unwind_frame_run_internal, tag, (char *)NULL);\n}\n\n \nvoid\nadd_unwind_protect (cleanup, arg)\n     Function *cleanup;\n     char *arg;\n{\n  without_interrupts (add_unwind_protect_internal, (char *)cleanup, arg);\n}\n\n \nvoid\nremove_unwind_protect ()\n{\n  if (unwind_protect_list)\n    without_interrupts\n      (remove_unwind_protect_internal, (char *)NULL, (char *)NULL);\n}\n\n \nvoid\nrun_unwind_protects ()\n{\n  if (unwind_protect_list)\n    without_interrupts\n      (run_unwind_protects_internal, (char *)NULL, (char *)NULL);\n}\n\n \nvoid\nclear_unwind_protect_list (flags)\n     int flags;\n{\n  char *flag;\n\n  if (unwind_protect_list)\n    {\n      flag = flags ? \"\" : (char *)NULL;\n      without_interrupts\n        (clear_unwind_protects_internal, flag, (char *)NULL);\n    }\n}\n\nint\nhave_unwind_protects ()\n{\n  return (unwind_protect_list != 0);\n}\n\nint\nunwind_protect_tag_on_stack (tag)\n     const char *tag;\n{\n  UNWIND_ELT *elt;\n\n  elt = unwind_protect_list;\n  while (elt)\n    {\n      if (elt->head.cleanup == 0 && STREQ (elt->arg.v, tag))\n\treturn 1;\n      elt = elt->head.next;\n    }\n  return 0;\n}\n\n \n \n \n \n \n\nstatic void\nadd_unwind_protect_internal (cleanup, arg)\n     Function *cleanup;\n     char *arg;\n{\n  UNWIND_ELT *elt;\n\n  uwpalloc (elt);\n  elt->head.next = unwind_protect_list;\n  elt->head.cleanup = cleanup;\n  elt->arg.v = arg;\n  unwind_protect_list = elt;\n}\n\nstatic void\nremove_unwind_protect_internal (ignore1, ignore2)\n     char *ignore1, *ignore2;\n{\n  UNWIND_ELT *elt;\n\n  elt = unwind_protect_list;\n  if (elt)\n    {\n      unwind_protect_list = unwind_protect_list->head.next;\n      uwpfree (elt);\n    }\n}\n\nstatic void\nrun_unwind_protects_internal (ignore1, ignore2)\n     char *ignore1, *ignore2;\n{\n  unwind_frame_run_internal ((char *) NULL, (char *) NULL);\n}\n\nstatic void\nclear_unwind_protects_internal (flag, ignore)\n     char *flag, *ignore;\n{\n  if (flag)\n    {\n      while (unwind_protect_list)\n\tremove_unwind_protect_internal ((char *)NULL, (char *)NULL);\n    }\n  unwind_protect_list = (UNWIND_ELT *)NULL;\n}\n\nstatic void\nunwind_frame_discard_internal (tag, ignore)\n     char *tag, *ignore;\n{\n  UNWIND_ELT *elt;\n  int found;\n\n  found = 0;\n  while (elt = unwind_protect_list)\n    {\n      unwind_protect_list = unwind_protect_list->head.next;\n      if (elt->head.cleanup == 0 && (STREQ (elt->arg.v, tag)))\n\t{\n\t  uwpfree (elt);\n\t  found = 1;\n\t  break;\n\t}\n      else\n\tuwpfree (elt);\n    }\n\n  if (found == 0)\n    internal_warning (_(\"unwind_frame_discard: %s: frame not found\"), tag);\n}\n\n \nstatic inline void\nrestore_variable (sv)\n     SAVED_VAR *sv;\n{\n  FASTCOPY (sv->desired_setting, sv->variable, sv->size);\n}\n\nstatic void\nunwind_frame_run_internal (tag, ignore)\n     char *tag, *ignore;\n{\n  UNWIND_ELT *elt;\n  int found;\n\n  found = 0;\n  while (elt = unwind_protect_list)\n    {\n      unwind_protect_list = elt->head.next;\n\n       \n      if (elt->head.cleanup == 0)\n\t{\n\t  if (tag && STREQ (elt->arg.v, tag))\n\t    {\n\t      uwpfree (elt);\n\t      found = 1;\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  if (elt->head.cleanup == (Function *) restore_variable)\n\t    restore_variable (&elt->sv.v);\n\t  else\n\t    (*(elt->head.cleanup)) (elt->arg.v);\n\t}\n\n      uwpfree (elt);\n    }\n  if (tag && found == 0)\n    internal_warning (_(\"unwind_frame_run: %s: frame not found\"), tag);\n}\n\nstatic void\nunwind_protect_mem_internal (var, psize)\n     char *var;\n     char *psize;\n{\n  int size, allocated;\n  UNWIND_ELT *elt;\n\n  size = *(int *) psize;\n  allocated = size + offsetof (UNWIND_ELT, sv.v.desired_setting[0]);\n  if (allocated < sizeof (UNWIND_ELT))\n    allocated = sizeof (UNWIND_ELT);\n  elt = (UNWIND_ELT *)xmalloc (allocated);\n  elt->head.next = unwind_protect_list;\n  elt->head.cleanup = (Function *) restore_variable;\n  elt->sv.v.variable = var;\n  elt->sv.v.size = size;\n  FASTCOPY (var, elt->sv.v.desired_setting, size);\n  unwind_protect_list = elt;\n}\n\n \nvoid\nunwind_protect_mem (var, size)\n     char *var;\n     int size;\n{\n  without_interrupts (unwind_protect_mem_internal, var, (char *) &size);\n}\n\n#if defined (DEBUG)\n#include <stdio.h>\n\nvoid\nprint_unwind_protect_tags ()\n{\n  UNWIND_ELT *elt;\n\n  elt = unwind_protect_list;\n  while (elt)\n    {\n      if (elt->head.cleanup == 0)\n        fprintf(stderr, \"tag: %s\\n\", elt->arg.v);\n      elt = elt->head.next;\n    }\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}