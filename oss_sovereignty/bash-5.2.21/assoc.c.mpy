{
  "module_name": "assoc.c",
  "hash_id": "a7542e36855b036508abbfc9575fda829bef51960915099d437d00775fd1c537",
  "original_prompt": "Ingested from bash-5.2.21/assoc.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (ARRAY_VARS)\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"bashansi.h\"\n\n#include \"shell.h\"\n#include \"array.h\"\n#include \"assoc.h\"\n#include \"builtins/common.h\"\n\nstatic WORD_LIST *assoc_to_word_list_internal PARAMS((HASH_TABLE *, int));\n\n \n\nvoid\nassoc_dispose (hash)\n     HASH_TABLE *hash;\n{\n  if (hash)\n    {\n      hash_flush (hash, 0);\n      hash_dispose (hash);\n    }\n}\n\nvoid\nassoc_flush (hash)\n     HASH_TABLE *hash;\n{\n  hash_flush (hash, 0);\n}\n\nint\nassoc_insert (hash, key, value)\n     HASH_TABLE *hash;\n     char *key;\n     char *value;\n{\n  BUCKET_CONTENTS *b;\n\n  b = hash_search (key, hash, HASH_CREATE);\n  if (b == 0)\n    return -1;\n   \n  if (b->key != key)\n    free (key);\n  FREE (b->data);\n  b->data = value ? savestring (value) : (char *)0;\n  return (0);\n}\n\n \nPTR_T\nassoc_replace (hash, key, value)\n     HASH_TABLE *hash;\n     char *key;\n     char *value;\n{\n  BUCKET_CONTENTS *b;\n  PTR_T t;\n\n  b = hash_search (key, hash, HASH_CREATE);\n  if (b == 0)\n    return (PTR_T)0;\n   \n  if (b->key != key)\n    free (key);\n  t = b->data;\n  b->data = value ? savestring (value) : (char *)0;\n  return t;\n}\n\nvoid\nassoc_remove (hash, string)\n     HASH_TABLE *hash;\n     char *string;\n{\n  BUCKET_CONTENTS *b;\n\n  b = hash_remove (string, hash, 0);\n  if (b)\n    {\n      free ((char *)b->data);\n      free (b->key);\n      free (b);\n    }\n}\n\nchar *\nassoc_reference (hash, string)\n     HASH_TABLE *hash;\n     char *string;\n{\n  BUCKET_CONTENTS *b;\n\n  if (hash == 0)\n    return (char *)0;\n\n  b = hash_search (string, hash, 0);\n  return (b ? (char *)b->data : 0);\n}\n\n \nHASH_TABLE *\nassoc_quote (h)\n     HASH_TABLE *h;\n{\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *t;\n\n  if (h == 0 || assoc_empty (h))\n    return ((HASH_TABLE *)NULL);\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tt = quote_string ((char *)tlist->data);\n\tFREE (tlist->data);\n\ttlist->data = t;\n      }\n\n  return h;\n}\n\n \nHASH_TABLE *\nassoc_quote_escapes (h)\n     HASH_TABLE *h;\n{\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *t;\n\n  if (h == 0 || assoc_empty (h))\n    return ((HASH_TABLE *)NULL);\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tt = quote_escapes ((char *)tlist->data);\n\tFREE (tlist->data);\n\ttlist->data = t;\n      }\n\n  return h;\n}\n\nHASH_TABLE *\nassoc_dequote (h)\n     HASH_TABLE *h;\n{\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *t;\n\n  if (h == 0 || assoc_empty (h))\n    return ((HASH_TABLE *)NULL);\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tt = dequote_string ((char *)tlist->data);\n\tFREE (tlist->data);\n\ttlist->data = t;\n      }\n\n  return h;\n}\n\nHASH_TABLE *\nassoc_dequote_escapes (h)\n     HASH_TABLE *h;\n{\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *t;\n\n  if (h == 0 || assoc_empty (h))\n    return ((HASH_TABLE *)NULL);\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tt = dequote_escapes ((char *)tlist->data);\n\tFREE (tlist->data);\n\ttlist->data = t;\n      }\n\n  return h;\n}\n\nHASH_TABLE *\nassoc_remove_quoted_nulls (h)\n     HASH_TABLE *h;\n{\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *t;\n\n  if (h == 0 || assoc_empty (h))\n    return ((HASH_TABLE *)NULL);\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tt = remove_quoted_nulls ((char *)tlist->data);\n\ttlist->data = t;\n      }\n\n  return h;\n}\n\n \nchar *\nassoc_subrange (hash, start, nelem, starsub, quoted, pflags)\n     HASH_TABLE *hash;\n     arrayind_t start, nelem;\n     int starsub, quoted, pflags;\n{\n  WORD_LIST *l, *save, *h, *t;\n  int i, j;\n  char *ret;\n\n  if (assoc_empty (hash))\n    return ((char *)NULL);\n\n  save = l = assoc_to_word_list (hash);\n  if (save == 0)\n    return ((char *)NULL);\n\n  for (i = 1; l && i < start; i++)\n    l = l->next;\n  if (l == 0)\n    {\n      dispose_words (save);\n      return ((char *)NULL);\n    }\n  for (j = 0,h = t = l; l && j < nelem; j++)\n    {\n      t = l;\n      l = l->next;\n    }\n\n  t->next = (WORD_LIST *)NULL;\n\n  ret = string_list_pos_params (starsub ? '*' : '@', h, quoted, pflags);\n\n  if (t != l)\n    t->next = l;\n\n  dispose_words (save);\n  return (ret);\n\n}\n\nchar *\nassoc_patsub (h, pat, rep, mflags)\n     HASH_TABLE *h;\n     char *pat, *rep;\n     int mflags;\n{\n  char\t*t;\n  int pchar, qflags, pflags;\n  WORD_LIST *wl, *save;\n\n  if (h == 0 || assoc_empty (h))\n    return ((char *)NULL);\n\n  wl = assoc_to_word_list (h);\n  if (wl == 0)\n    return (char *)NULL;\n\n  for (save = wl; wl; wl = wl->next)\n    {\n      t = pat_subst (wl->word->word, pat, rep, mflags);\n      FREE (wl->word->word);\n      wl->word->word = t;\n    }\n\n  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';\n  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;\n  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;\n\n  t = string_list_pos_params (pchar, save, qflags, pflags);\n  dispose_words (save);\n\n  return t;\n}\n\nchar *\nassoc_modcase (h, pat, modop, mflags)\n     HASH_TABLE *h;\n     char *pat;\n     int modop;\n     int mflags;\n{\n  char\t*t;\n  int pchar, qflags, pflags;\n  WORD_LIST *wl, *save;\n\n  if (h == 0 || assoc_empty (h))\n    return ((char *)NULL);\n\n  wl = assoc_to_word_list (h);\n  if (wl == 0)\n    return ((char *)NULL);\n\n  for (save = wl; wl; wl = wl->next)\n    {\n      t = sh_modcase (wl->word->word, pat, modop);\n      FREE (wl->word->word);\n      wl->word->word = t;\n    }\n\n  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';\n  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;\n  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;\n\n  t = string_list_pos_params (pchar, save, qflags, pflags);\n  dispose_words (save);\n\n  return t;\n}\n\nchar *\nassoc_to_kvpair (hash, quoted)\n     HASH_TABLE *hash;\n     int quoted;\n{\n  char *ret;\n  char *istr, *vstr;\n  int i, rsize, rlen, elen;\n  BUCKET_CONTENTS *tlist;\n\n  if (hash == 0 || assoc_empty (hash))\n    return (char *)0;\n\n  ret = xmalloc (rsize = 128);\n  ret[rlen = 0] = '\\0';\n\n  for (i = 0; i < hash->nbuckets; i++)\n    for (tlist = hash_items (i, hash); tlist; tlist = tlist->next)\n      {\n\tif (ansic_shouldquote (tlist->key))\n\t  istr = ansic_quote (tlist->key, 0, (int *)0);\n\telse if (sh_contains_shell_metas (tlist->key))\n\t  istr = sh_double_quote (tlist->key);\n\telse if (ALL_ELEMENT_SUB (tlist->key[0]) && tlist->key[1] == '\\0')\n\t  istr = sh_double_quote (tlist->key);\t\n\telse\n\t  istr = tlist->key;\t\n\n\tvstr = tlist->data ? (ansic_shouldquote ((char *)tlist->data) ?\n\t\t\t\tansic_quote ((char *)tlist->data, 0, (int *)0) :\n\t\t\t\tsh_double_quote ((char *)tlist->data))\n\t\t\t   : (char *)0;\n\n\telen = STRLEN (istr) + 4 + STRLEN (vstr);\n\tRESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);\n\n\tstrcpy (ret+rlen, istr);\n\trlen += STRLEN (istr);\n\tret[rlen++] = ' ';\n\tif (vstr)\n\t  {\n\t    strcpy (ret + rlen, vstr);\n\t    rlen += STRLEN (vstr);\n\t  }\n\telse\n\t  {\n\t    strcpy (ret + rlen, \"\\\"\\\"\");\n\t    rlen += 2;\n\t  }\n\tret[rlen++] = ' ';\n\n\tif (istr != tlist->key)\n\t  FREE (istr);\n\n\tFREE (vstr);\n    }\n\n  RESIZE_MALLOCED_BUFFER (ret, rlen, 1, rsize, 8);\n  ret[rlen] = '\\0';\n\n  if (quoted)\n    {\n      vstr = sh_single_quote (ret);\n      free (ret);\n      ret = vstr;\n    }\n\n  return ret;\n}\n\nchar *\nassoc_to_assign (hash, quoted)\n     HASH_TABLE *hash;\n     int quoted;\n{\n  char *ret;\n  char *istr, *vstr;\n  int i, rsize, rlen, elen;\n  BUCKET_CONTENTS *tlist;\n\n  if (hash == 0 || assoc_empty (hash))\n    return (char *)0;\n\n  ret = xmalloc (rsize = 128);\n  ret[0] = '(';\n  rlen = 1;\n\n  for (i = 0; i < hash->nbuckets; i++)\n    for (tlist = hash_items (i, hash); tlist; tlist = tlist->next)\n      {\n\tif (ansic_shouldquote (tlist->key))\n\t  istr = ansic_quote (tlist->key, 0, (int *)0);\n\telse if (sh_contains_shell_metas (tlist->key))\n\t  istr = sh_double_quote (tlist->key);\n\telse if (ALL_ELEMENT_SUB (tlist->key[0]) && tlist->key[1] == '\\0')\n\t  istr = sh_double_quote (tlist->key);\t\n\telse\n\t  istr = tlist->key;\t\n\n\tvstr = tlist->data ? (ansic_shouldquote ((char *)tlist->data) ?\n\t\t\t\tansic_quote ((char *)tlist->data, 0, (int *)0) :\n\t\t\t\tsh_double_quote ((char *)tlist->data))\n\t\t\t   : (char *)0;\n\n\telen = STRLEN (istr) + 8 + STRLEN (vstr);\n\tRESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);\n\n\tret[rlen++] = '[';\n\tstrcpy (ret+rlen, istr);\n\trlen += STRLEN (istr);\n\tret[rlen++] = ']';\n\tret[rlen++] = '=';\n\tif (vstr)\n\t  {\n\t    strcpy (ret + rlen, vstr);\n\t    rlen += STRLEN (vstr);\n\t  }\n\tret[rlen++] = ' ';\n\n\tif (istr != tlist->key)\n\t  FREE (istr);\n\n\tFREE (vstr);\n    }\n\n  RESIZE_MALLOCED_BUFFER (ret, rlen, 1, rsize, 8);\n  ret[rlen++] = ')';\n  ret[rlen] = '\\0';\n\n  if (quoted)\n    {\n      vstr = sh_single_quote (ret);\n      free (ret);\n      ret = vstr;\n    }\n\n  return ret;\n}\n\nstatic WORD_LIST *\nassoc_to_word_list_internal (h, t)\n     HASH_TABLE *h;\n     int t;\n{\n  WORD_LIST *list;\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *w;\n\n  if (h == 0 || assoc_empty (h))\n    return((WORD_LIST *)NULL);\n  list = (WORD_LIST *)NULL;\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tw = (t == 0) ? (char *)tlist->data : (char *)tlist->key;\n\tlist = make_word_list (make_bare_word(w), list);\n      }\n  return (REVERSE_LIST(list, WORD_LIST *));\n}\n\nWORD_LIST *\nassoc_to_word_list (h)\n     HASH_TABLE *h;\n{\n  return (assoc_to_word_list_internal (h, 0));\n}\n\nWORD_LIST *\nassoc_keys_to_word_list (h)\n     HASH_TABLE *h;\n{\n  return (assoc_to_word_list_internal (h, 1));\n}\n\nWORD_LIST *\nassoc_to_kvpair_list (h)\n     HASH_TABLE *h;\n{\n  WORD_LIST *list;\n  int i;\n  BUCKET_CONTENTS *tlist;\n  char *k, *v;\n\n  if (h == 0 || assoc_empty (h))\n    return((WORD_LIST *)NULL);\n  list = (WORD_LIST *)NULL;\n  \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n      \tk = (char *)tlist->key;\n      \tv = (char *)tlist->data;\n\tlist = make_word_list (make_bare_word (k), list);\n\tlist = make_word_list (make_bare_word (v), list);\n      }\n  return (REVERSE_LIST(list, WORD_LIST *));\n}\n\nchar *\nassoc_to_string (h, sep, quoted)\n     HASH_TABLE *h;\n     char *sep;\n     int quoted;\n{\n  BUCKET_CONTENTS *tlist;\n  int i;\n  char *result, *t, *w;\n  WORD_LIST *list, *l;\n\n  if (h == 0)\n    return ((char *)NULL);\n  if (assoc_empty (h))\n    return (savestring (\"\"));\n\n  result = NULL;\n  l = list = NULL;\n   \n  for (i = 0; i < h->nbuckets; i++)\n    for (tlist = hash_items (i, h); tlist; tlist = tlist->next)\n      {\n\tw = (char *)tlist->data;\n\tif (w == 0)\n\t  continue;\n\tt = quoted ? quote_string (w) : savestring (w);\n\tlist = make_word_list (make_bare_word(t), list);\n\tFREE (t);\n      }\n\n  l = REVERSE_LIST(list, WORD_LIST *);\n\n  result = l ? string_list_internal (l, sep) : savestring (\"\");\n  dispose_words (l);  \n\n  return result;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}