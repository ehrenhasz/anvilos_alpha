{
  "module_name": "mailcheck.c",
  "hash_id": "b50d357500f06cab6966e76752b6fe18ed82474ab21f4ffd152ac0bbe2e3a9d5",
  "original_prompt": "Ingested from bash-5.2.21/mailcheck.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include <stdio.h>\n#include \"bashtypes.h\"\n#include \"posixstat.h\"\n#if defined (HAVE_SYS_PARAM_H)\n#  include <sys/param.h>\n#endif\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n#include \"posixtime.h\"\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"execute_cmd.h\"\n#include \"mailcheck.h\"\n#include <tilde/tilde.h>\n\n \n#define MBOX_INITIALIZED\t0x01\n\nextern time_t shell_start_time;\n\nextern int mailstat PARAMS((const char *, struct stat *));\n\ntypedef struct _fileinfo {\n  char *name;\n  char *msg;\n  time_t access_time;\n  time_t mod_time;\n  off_t file_size;\n  int flags;\n} FILEINFO;\n\n \nstatic FILEINFO **mailfiles = (FILEINFO **)NULL;\n\n \nstatic int mailfiles_count;\n\n \nstatic time_t last_time_mail_checked = 0;\n\n \nint mail_warning;\n\nstatic int find_mail_file PARAMS((char *));\nstatic void init_mail_file PARAMS((int));\nstatic void update_mail_file PARAMS((int));\nstatic int add_mail_file PARAMS((char *, char *));\n\nstatic FILEINFO *alloc_mail_file PARAMS((char *, char *));\nstatic void dispose_mail_file PARAMS((FILEINFO *));\n\nstatic int file_mod_date_changed PARAMS((int));\nstatic int file_access_date_changed PARAMS((int));\nstatic int file_has_grown PARAMS((int));\n\nstatic char *parse_mailpath_spec PARAMS((char *));\n\n \nint\ntime_to_check_mail ()\n{\n  char *temp;\n  time_t now;\n  intmax_t seconds;\n\n  temp = get_string_value (\"MAILCHECK\");\n\n   \n  if (temp == 0 || legal_number (temp, &seconds) == 0 || seconds < 0)\n    return (0);\n\n  now = NOW;\n   \n  return (seconds == 0 || ((now - last_time_mail_checked) >= seconds));\n}\n\n \nvoid\nreset_mail_timer ()\n{\n  last_time_mail_checked = NOW;\n}\n\n \nstatic int\nfind_mail_file (file)\n     char *file;\n{\n  register int i;\n\n  for (i = 0; i < mailfiles_count; i++)\n    if (STREQ (mailfiles[i]->name, file))\n      return i;\n\n  return -1;\n}\n\n#define RESET_MAIL_FILE(i) \\\n  do \\\n    { \\\n      mailfiles[i]->access_time = mailfiles[i]->mod_time = 0; \\\n      mailfiles[i]->file_size = 0; \\\n      mailfiles[i]->flags = 0; \\\n    } \\\n  while (0)\n\n#define UPDATE_MAIL_FILE(i, finfo) \\\n  do \\\n    { \\\n      mailfiles[i]->access_time = finfo.st_atime; \\\n      mailfiles[i]->mod_time = finfo.st_mtime; \\\n      mailfiles[i]->file_size = finfo.st_size; \\\n      mailfiles[i]->flags |= MBOX_INITIALIZED; \\\n    } \\\n  while (0)\n\nstatic void\ninit_mail_file (i)\n     int i;\n{\n  mailfiles[i]->access_time = mailfiles[i]->mod_time = last_time_mail_checked ? last_time_mail_checked : shell_start_time;\n  mailfiles[i]->file_size = 0;\n  mailfiles[i]->flags = 0;\n}\n\nstatic void\nupdate_mail_file (i)\n     int i;\n{\n  char *file;\n  struct stat finfo;\n\n  file = mailfiles[i]->name;\n  if (mailstat (file, &finfo) == 0)\n    UPDATE_MAIL_FILE (i, finfo);\n  else\n    RESET_MAIL_FILE (i);\n}\n\n \nstatic int\nadd_mail_file (file, msg)\n     char *file, *msg;\n{\n  struct stat finfo;\n  char *filename;\n  int i;\n\n  filename = full_pathname (file);\n  i = find_mail_file (filename);\n  if (i >= 0)\n    {\n      if (mailstat (filename, &finfo) == 0)\n\tUPDATE_MAIL_FILE (i, finfo);\n\n      free (filename);\n      return i;\n    }\n\n  i = mailfiles_count++;\n  mailfiles = (FILEINFO **)xrealloc\n\t\t(mailfiles, mailfiles_count * sizeof (FILEINFO *));\n\n  mailfiles[i] = alloc_mail_file (filename, msg);\n  init_mail_file (i);\n\n  return i;\n}\n\n \nvoid\nreset_mail_files ()\n{\n  register int i;\n\n  for (i = 0; i < mailfiles_count; i++)\n    RESET_MAIL_FILE (i);\n}\n\nstatic FILEINFO *\nalloc_mail_file (filename, msg)\n     char *filename, *msg;\n{\n  FILEINFO *mf;\n\n  mf = (FILEINFO *)xmalloc (sizeof (FILEINFO));\n  mf->name = filename;\n  mf->msg = msg ? savestring (msg) : (char *)NULL;\n  mf->flags = 0;\n\n  return mf;\n}\n\nstatic void\ndispose_mail_file (mf)\n     FILEINFO *mf;\n{\n  free (mf->name);\n  FREE (mf->msg);\n  free (mf);\n}\n\n \nvoid\nfree_mail_files ()\n{\n  register int i;\n\n  for (i = 0; i < mailfiles_count; i++)\n    dispose_mail_file (mailfiles[i]);\n\n  if (mailfiles)\n    free (mailfiles);\n\n  mailfiles_count = 0;\n  mailfiles = (FILEINFO **)NULL;\n}\n\nvoid\ninit_mail_dates ()\n{\n  if (mailfiles == 0)\n    remember_mail_dates ();\n}\n\n \nstatic int\nfile_mod_date_changed (i)\n     int i;\n{\n  time_t mtime;\n  struct stat finfo;\n  char *file;\n\n  file = mailfiles[i]->name;\n  mtime = mailfiles[i]->mod_time;\n\n  if (mailstat (file, &finfo) != 0)\n    return (0);\n\n  if (finfo.st_size > 0)\n    return (mtime < finfo.st_mtime);\n\n  if (finfo.st_size == 0 && mailfiles[i]->file_size > 0)\n    UPDATE_MAIL_FILE (i, finfo);\n\n  return (0);\n}\n\n \nstatic int\nfile_access_date_changed (i)\n     int i;\n{\n  time_t atime;\n  struct stat finfo;\n  char *file;\n\n  file = mailfiles[i]->name;\n  atime = mailfiles[i]->access_time;\n\n  if (mailstat (file, &finfo) != 0)\n    return (0);\n\n  if (finfo.st_size > 0)\n    return (atime < finfo.st_atime);\n\n  return (0);\n}\n\n \nstatic int\nfile_has_grown (i)\n     int i;\n{\n  off_t size;\n  struct stat finfo;\n  char *file;\n\n  file = mailfiles[i]->name;\n  size = mailfiles[i]->file_size;\n\n  return ((mailstat (file, &finfo) == 0) && (finfo.st_size > size));\n}\n\n \nstatic char *\nparse_mailpath_spec (str)\n     char *str;\n{\n  char *s;\n  int pass_next;\n\n  for (s = str, pass_next = 0; s && *s; s++)\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  continue;\n\t}\n      if (*s == '\\\\')\n\t{\n\t  pass_next++;\n\t  continue;\n\t}\n      if (*s == '?' || *s == '%')\n\treturn s;\n    }\n  return ((char *)NULL);\n}\n\nchar *\nmake_default_mailpath ()\n{\n#if defined (DEFAULT_MAIL_DIRECTORY)\n  char *mp;\n\n  get_current_user_info ();\n  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));\n  strcpy (mp, DEFAULT_MAIL_DIRECTORY);\n  mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';\n  strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY), current_user.user_name);\n  return (mp);\n#else\n  return ((char *)NULL);\n#endif\n}\n\n \n\nvoid\nremember_mail_dates ()\n{\n  char *mailpaths;\n  char *mailfile, *mp;\n  int i = 0;\n\n  mailpaths = get_string_value (\"MAILPATH\");\n\n   \n  if (mailpaths == 0 && (mailpaths = get_string_value (\"MAIL\")))\n    {\n      add_mail_file (mailpaths, (char *)NULL);\n      return;\n    }\n\n  if (mailpaths == 0)\n    {\n      mailpaths = make_default_mailpath ();\n      if (mailpaths)\n\t{\n\t  add_mail_file (mailpaths, (char *)NULL);\n\t  free (mailpaths);\n\t}\n      return;\n    }\n\n  while (mailfile = extract_colon_unit (mailpaths, &i))\n    {\n      mp = parse_mailpath_spec (mailfile);\n      if (mp && *mp)\n\t*mp++ = '\\0';\n      add_mail_file (mailfile, mp);\n      free (mailfile);\n    }\n}\n\n \n\n \nvoid\ncheck_mail ()\n{\n  char *current_mail_file, *message;\n  int i, use_user_notification;\n  char *dollar_underscore, *temp;\n\n  dollar_underscore = get_string_value (\"_\");\n  if (dollar_underscore)\n    dollar_underscore = savestring (dollar_underscore);\n\n  for (i = 0; i < mailfiles_count; i++)\n    {\n      current_mail_file = mailfiles[i]->name;\n\n      if (*current_mail_file == '\\0')\n\tcontinue;\n\n      if (file_mod_date_changed (i))\n\t{\n\t  int file_is_bigger;\n\n\t  use_user_notification = mailfiles[i]->msg != (char *)NULL;\n\t  message = mailfiles[i]->msg ? mailfiles[i]->msg : _(\"You have mail in $_\");\n\n\t  bind_variable (\"_\", current_mail_file, 0);\n\n#define atime mailfiles[i]->access_time\n#define mtime mailfiles[i]->mod_time\n\n\t   \n\t  file_is_bigger = file_has_grown (i);\n\n\t  update_mail_file (i);\n\n\t   \n\t  if ((atime >= mtime) && !file_is_bigger)\n\t    continue;\n\n\t   \n\t  if (use_user_notification == 0 && (atime < mtime) && file_is_bigger)\n\t    message = _(\"You have new mail in $_\");\n#undef atime\n#undef mtime\n\n\t  if (temp = expand_string_to_string (message, Q_DOUBLE_QUOTES))\n\t    {\n\t      puts (temp);\n\t      free (temp);\n\t    }\n\t  else\n\t    putchar ('\\n');\n\t}\n\n      if (mail_warning && file_access_date_changed (i))\n\t{\n\t  update_mail_file (i);\n\t  printf (_(\"The mail in %s has been read\\n\"), current_mail_file);\n\t}\n    }\n\n  if (dollar_underscore)\n    {\n      bind_variable (\"_\", dollar_underscore, 0);\n      free (dollar_underscore);\n    }\n  else\n    unbind_variable (\"_\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}