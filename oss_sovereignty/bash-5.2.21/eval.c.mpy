{
  "module_name": "eval.c",
  "hash_id": "8d901b9493cc10cb547bfd50e8125cd527bf0e6a3011020ba8e2f839ec33d610",
  "original_prompt": "Ingested from bash-5.2.21/eval.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include <stdio.h>\n\n#include <signal.h>\n\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"parser.h\"\n#include \"flags.h\"\n#include \"trap.h\"\n\n#include \"builtins/common.h\"\n\n#include \"input.h\"\n#include \"execute_cmd.h\"\n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#endif\n\nstatic void send_pwd_to_eterm PARAMS((void));\nstatic sighandler alrm_catcher PARAMS((int));\n\n \nint\nreader_loop ()\n{\n  int our_indirection_level;\n  COMMAND * volatile current_command;\n\n  USE_VAR(current_command);\n\n  current_command = (COMMAND *)NULL;\n\n  our_indirection_level = ++indirection_level;\n\n  if (just_one_command)\n    reset_readahead_token ();\n\n  while (EOF_Reached == 0)\n    {\n      int code;\n\n      code = setjmp_nosigs (top_level);\n\n#if defined (PROCESS_SUBSTITUTION)\n      unlink_fifo_list ();\n#endif  \n\n       \n      if (interactive_shell && signal_is_ignored (SIGINT) == 0 && signal_is_trapped (SIGINT) == 0)\n\tset_signal_handler (SIGINT, sigint_sighandler);\n\n      if (code != NOT_JUMPED)\n\t{\n\t  indirection_level = our_indirection_level;\n\n\t  switch (code)\n\t    {\n\t       \n\t    case ERREXIT:\n\t      if (exit_immediately_on_error)\n\t\treset_local_contexts ();\t \n\t    case FORCE_EOF:\n\t    case EXITPROG:\n\t    case EXITBLTIN:\n\t      current_command = (COMMAND *)NULL;\n\t      EOF_Reached = EOF;\n\t      goto exec_done;\n\n\t    case DISCARD:\n\t       \n\t      if (last_command_exit_value == 0)\n\t\tset_exit_status (EXECUTION_FAILURE);\n\t      if (subshell_environment)\n\t\t{\n\t\t  current_command = (COMMAND *)NULL;\n\t\t  EOF_Reached = EOF;\n\t\t  goto exec_done;\n\t\t}\n\t       \n\t      if (current_command)\n\t\t{\n\t\t  dispose_command (current_command);\n\t\t  current_command = (COMMAND *)NULL;\n\t\t}\n\n\t      restore_sigmask ();\n\t      break;\n\n\t    default:\n\t      command_error (\"reader_loop\", CMDERR_BADJUMP, code, 0);\n\t    }\n\t}\n\n      executing = 0;\n      if (temporary_env)\n\tdispose_used_env_vars ();\n\n#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)\n       \n      (void) alloca (0);\n#endif\n\n      if (read_command () == 0)\n\t{\n\t  if (interactive_shell == 0 && read_but_dont_execute)\n\t    {\n\t      set_exit_status (last_command_exit_value);\n\t      dispose_command (global_command);\n\t      global_command = (COMMAND *)NULL;\n\t    }\n\t  else if (current_command = global_command)\n\t    {\n\t      global_command = (COMMAND *)NULL;\n\n\t       \n\t      if (interactive && ps0_prompt)\n\t\t{\n\t\t  char *ps0_string;\n\n\t\t  ps0_string = decode_prompt_string (ps0_prompt);\n\t\t  if (ps0_string && *ps0_string)\n\t\t    {\n\t\t      fprintf (stderr, \"%s\", ps0_string);\n\t\t      fflush (stderr);\n\t\t    }\n\t\t  free (ps0_string);\n\t\t}\n\n\t      current_command_number++;\n\n\t      executing = 1;\n\t      stdin_redir = 0;\n\n\t      execute_command (current_command);\n\n\t    exec_done:\n\t      QUIT;\n\n\t      if (current_command)\n\t\t{\n\t\t  dispose_command (current_command);\n\t\t  current_command = (COMMAND *)NULL;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t   \n\t  if (interactive == 0)\n\t    EOF_Reached = EOF;\n\t}\n      if (just_one_command)\n\tEOF_Reached = EOF;\n    }\n  indirection_level--;\n  return (last_command_exit_value);\n}\n\n \nint\npretty_print_loop ()\n{\n  COMMAND *current_command;\n  char *command_to_print;\n  int code;\n  int global_posix_mode, last_was_newline;\n\n  global_posix_mode = posixly_correct;\n  last_was_newline = 0;\n  while (EOF_Reached == 0)\n    {\n      code = setjmp_nosigs (top_level);\n      if (code)\n        return (EXECUTION_FAILURE);\n      if (read_command() == 0)\n\t{\n\t  current_command = global_command;\n\t  global_command = 0;\n\t  posixly_correct = 1;\t\t\t \n\t  if (current_command && (command_to_print = make_command_string (current_command)))\n\t    {\n\t      printf (\"%s\\n\", command_to_print);\t \n\t      last_was_newline = 0;\n\t    }\n\t  else if (last_was_newline == 0)\n\t    {\n\t       printf (\"\\n\");\n\t       last_was_newline = 1;\n\t    }\n\t  posixly_correct = global_posix_mode;\n\t  dispose_command (current_command);\n\t}\n      else\n\treturn (EXECUTION_FAILURE);\n    }\n    \n  return (EXECUTION_SUCCESS);\n}\n\nstatic sighandler\nalrm_catcher(i)\n     int i;\n{\n  char *msg;\n\n  msg = _(\"\\007timed out waiting for input: auto-logout\\n\");\n  write (1, msg, strlen (msg));\n\n  bash_logout ();\t \n  jump_to_top_level (EXITPROG);\n  SIGRETURN (0);\n}\n\n \nstatic void\nsend_pwd_to_eterm ()\n{\n  char *pwd, *f;\n\n  f = 0;\n  pwd = get_string_value (\"PWD\");\n  if (pwd == 0)\n    f = pwd = get_working_directory (\"eterm\");\n  fprintf (stderr, \"\\032/%s\\n\", pwd);\n  free (f);\n}\n\n#if defined (ARRAY_VARS)\n \nint\nexecute_array_command (a, v)\n     ARRAY *a;\n     void *v;\n{\n  char *tag;\n  char **argv;\n  int argc, i;\n\n  tag = (char *)v;\n  argc = 0;\n  argv = array_to_argv (a, &argc);\n  for (i = 0; i < argc; i++)\n    {\n      if (argv[i] && argv[i][0])\n\texecute_variable_command (argv[i], tag);\n    }\n  strvec_dispose (argv);\n  return 0;\n}\n#endif\n  \nstatic void\nexecute_prompt_command ()\n{\n  char *command_to_execute;\n  SHELL_VAR *pcv;\n#if defined (ARRAY_VARS)\n  ARRAY *pcmds;\n#endif\n\n  pcv = find_variable (\"PROMPT_COMMAND\");\n  if (pcv  == 0 || var_isset (pcv) == 0 || invisible_p (pcv))\n    return;\n#if defined (ARRAY_VARS)\n  if (array_p (pcv))\n    {\n      if ((pcmds = array_cell (pcv)) && array_num_elements (pcmds) > 0)\n\texecute_array_command (pcmds, \"PROMPT_COMMAND\");\n      return;\n    }\n  else if (assoc_p (pcv))\n    return;\t \n#endif\n\n  command_to_execute = value_cell (pcv);\n  if (command_to_execute && *command_to_execute)\n    execute_variable_command (command_to_execute, \"PROMPT_COMMAND\");\n}\n\n \nint\nparse_command ()\n{\n  int r;\n\n  need_here_doc = 0;\n  run_pending_traps ();\n\n   \n   \n  if (interactive && bash_input.type != st_string && parser_expanding_alias() == 0)\n    {\n#if defined (READLINE)\n      if (no_line_editing || (bash_input.type == st_stdin && parser_will_prompt ()))\n#endif\n        execute_prompt_command ();\n\n      if (running_under_emacs == 2)\n\tsend_pwd_to_eterm ();\t \n    }\n\n  current_command_line_count = 0;\n  r = yyparse ();\n\n  if (need_here_doc)\n    gather_here_documents ();\n\n  return (r);\n}\n\n \nint\nread_command ()\n{\n  SHELL_VAR *tmout_var;\n  int tmout_len, result;\n  SigHandler *old_alrm;\n\n  set_current_prompt_level (1);\n  global_command = (COMMAND *)NULL;\n\n   \n  tmout_var = (SHELL_VAR *)NULL;\n  tmout_len = 0;\n  old_alrm = (SigHandler *)NULL;\n\n  if (interactive)\n    {\n      tmout_var = find_variable (\"TMOUT\");\n\n      if (tmout_var && var_isset (tmout_var))\n\t{\n\t  tmout_len = atoi (value_cell (tmout_var));\n\t  if (tmout_len > 0)\n\t    {\n\t      old_alrm = set_signal_handler (SIGALRM, alrm_catcher);\n\t      alarm (tmout_len);\n\t    }\n\t}\n    }\n\n  QUIT;\n\n  current_command_line_count = 0;\n  result = parse_command ();\n\n  if (interactive && tmout_var && (tmout_len > 0))\n    {\n      alarm(0);\n      set_signal_handler (SIGALRM, old_alrm);\n    }\n\n  return (result);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}