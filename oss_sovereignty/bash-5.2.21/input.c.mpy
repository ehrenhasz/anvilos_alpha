{
  "module_name": "input.c",
  "hash_id": "ed9e3e0849ce9ea020a95550dd12da455ba50ebf8d804e07007c4ebfbf77cb2f",
  "original_prompt": "Ingested from bash-5.2.21/input.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#if !defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n#include \"filecntl.h\"\n#include \"posixstat.h\"\n#include <stdio.h>\n#include <errno.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"input.h\"\n#include \"externs.h\"\n#include \"trap.h\"\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#if defined (EAGAIN)\n#  define X_EAGAIN EAGAIN\n#else\n#  define X_EAGAIN -99\n#endif\n\n#if defined (EWOULDBLOCK)\n#  define X_EWOULDBLOCK EWOULDBLOCK\n#else\n#  define X_EWOULDBLOCK -99\n#endif\n\nextern void termsig_handler PARAMS((int));\n\n \n\nstatic char localbuf[1024];\nstatic int local_index = 0, local_bufused = 0;\n\n \nint\ngetc_with_restart (stream)\n     FILE *stream;\n{\n  unsigned char uc;\n\n  CHECK_TERMSIG;\n\n   \n  if (local_index == local_bufused || local_bufused == 0)\n    {\n      while (1)\n\t{\n\t  QUIT;\n\t  run_pending_traps ();\n\n\t  local_bufused = read (fileno (stream), localbuf, sizeof(localbuf));\n\t  if (local_bufused > 0)\n\t    break;\n\t  else if (local_bufused == 0)\n\t    {\n\t      local_index = 0;\n\t      return EOF;\n\t    }\n\t  else if (errno == X_EAGAIN || errno == X_EWOULDBLOCK)\n\t    {\n\t      if (sh_unset_nodelay_mode (fileno (stream)) < 0)\n\t\t{\n\t\t  sys_error (_(\"cannot reset nodelay mode for fd %d\"), fileno (stream));\n\t\t  local_index = local_bufused = 0;\n\t\t  return EOF;\n\t\t}\n\t      continue;\n\t    }\n\t  else if (errno != EINTR)\n\t    {\n\t      local_index = local_bufused = 0;\n\t      return EOF;\n\t    }\n\t  else if (interrupt_state || terminating_signal)\t \n\t    local_index = local_bufused = 0;\n\t}\n      local_index = 0;\n    }\n  uc = localbuf[local_index++];\n  return uc;\n}\n\nint\nungetc_with_restart (c, stream)\n     int c;\n     FILE *stream;\n{\n  if (local_index == 0 || c == EOF)\n    return EOF;\n  localbuf[--local_index] = c;\n  return c;\n}\n\n#if defined (BUFFERED_INPUT)\n\n \n\n#if defined (USING_BASH_MALLOC)\n#  define MAX_INPUT_BUFFER_SIZE\t8172\n#else\n#  define MAX_INPUT_BUFFER_SIZE\t8192\n#endif\n\n#if !defined (SEEK_CUR)\n#  define SEEK_CUR 1\n#endif  \n\n#ifdef max\n#  undef max\n#endif\n#define max(a, b)\t(((a) > (b)) ? (a) : (b))\n#ifdef min\n#  undef min\n#endif\n#define min(a, b)\t((a) > (b) ? (b) : (a))\n\nint bash_input_fd_changed;\n\n \nstatic BUFFERED_STREAM **buffers = (BUFFERED_STREAM **)NULL;\nstatic int nbuffers;\n\n#define ALLOCATE_BUFFERS(n) \\\n\tdo { if ((n) >= nbuffers) allocate_buffers (n); } while (0)\n\n \nstatic void\nallocate_buffers (n)\n     int n;\n{\n  register int i, orig_nbuffers;\n\n  orig_nbuffers = nbuffers;\n  nbuffers = n + 20;\n  buffers = (BUFFERED_STREAM **)xrealloc\n    (buffers, nbuffers * sizeof (BUFFERED_STREAM *));\n\n   \n  for (i = orig_nbuffers; i < nbuffers; i++)\n    buffers[i] = (BUFFERED_STREAM *)NULL;\n}\n\n \nstatic BUFFERED_STREAM *\nmake_buffered_stream (fd, buffer, bufsize)\n     int fd;\n     char *buffer;\n     size_t bufsize;\n{\n  BUFFERED_STREAM *bp;\n\n  bp = (BUFFERED_STREAM *)xmalloc (sizeof (BUFFERED_STREAM));\n  ALLOCATE_BUFFERS (fd);\n  buffers[fd] = bp;\n  bp->b_fd = fd;\n  bp->b_buffer = buffer;\n  bp->b_size = bufsize;\n  bp->b_used = bp->b_inputp = bp->b_flag = 0;\n  if (bufsize == 1)\n    bp->b_flag |= B_UNBUFF;\n  if (O_TEXT && (fcntl (fd, F_GETFL) & O_TEXT) != 0)\n    bp->b_flag |= B_TEXT;\n  return (bp);\n}\n\n \nstatic BUFFERED_STREAM *\ncopy_buffered_stream (bp)\n     BUFFERED_STREAM *bp;\n{\n  BUFFERED_STREAM *nbp;\n\n  if (!bp)\n    return ((BUFFERED_STREAM *)NULL);\n\n  nbp = (BUFFERED_STREAM *)xmalloc (sizeof (BUFFERED_STREAM));\n  xbcopy ((char *)bp, (char *)nbp, sizeof (BUFFERED_STREAM));\n  return (nbp);\n}\n\nint\nset_bash_input_fd (fd)\n     int fd;\n{\n  if (bash_input.type == st_bstream)\n    bash_input.location.buffered_fd = fd;\n  else if (interactive_shell == 0)\n    default_buffered_input = fd;\n  return 0;\n}\n\nint\nfd_is_bash_input (fd)\n     int fd;\n{\n  if (bash_input.type == st_bstream && bash_input.location.buffered_fd == fd)\n    return 1;\n  else if (interactive_shell == 0 && default_buffered_input == fd)\n    return 1;\n  return 0;\n}\n\n \nint\nsave_bash_input (fd, new_fd)\n     int fd, new_fd;\n{\n  int nfd;\n\n   \n  if (buffers[fd])\n    sync_buffered_stream (fd);\n\n   \n  nfd = (new_fd == -1) ? fcntl (fd, F_DUPFD, 10) : new_fd;\n  if (nfd == -1)\n    {\n      if (fcntl (fd, F_GETFD, 0) == 0)\n\tsys_error (_(\"cannot allocate new file descriptor for bash input from fd %d\"), fd);\n      return -1;\n    }\n\n  if (nfd < nbuffers && buffers[nfd])\n    {\n       \n      internal_error (_(\"save_bash_input: buffer already exists for new fd %d\"), nfd);\n      if (buffers[nfd]->b_flag & B_SHAREDBUF)\n\tbuffers[nfd]->b_buffer = (char *)NULL;\n      free_buffered_stream (buffers[nfd]);\n    }\n\n   \n  if (bash_input.type == st_bstream)\n    {\n      bash_input.location.buffered_fd = nfd;\n      fd_to_buffered_stream (nfd);\n      close_buffered_fd (fd);\t \n    }\n  else\n     \n    bash_input_fd_changed++;\n\n  if (default_buffered_input == fd)\n    default_buffered_input = nfd;\n\n  SET_CLOSE_ON_EXEC (nfd);\n  return nfd;\n}\n\n \nint\ncheck_bash_input (fd)\n     int fd;\n{\n  if (fd_is_bash_input (fd))\n    {\n      if (fd > 0)\n\treturn ((save_bash_input (fd, -1) == -1) ? -1 : 0);\n      else if (fd == 0)\n        return ((sync_buffered_stream (fd) == -1) ? -1 : 0);\n    }\n  return 0;\n}\n      \n \nint\nduplicate_buffered_stream (fd1, fd2)\n     int fd1, fd2;\n{\n  int is_bash_input, m;\n\n  if (fd1 == fd2)\n    return 0;\n\n  m = max (fd1, fd2);\n  ALLOCATE_BUFFERS (m);\n\n   \n  is_bash_input = (bash_input.type == st_bstream) &&\n\t\t  (bash_input.location.buffered_fd == fd2);\n\n  if (buffers[fd2])\n    {\n       \n      if (buffers[fd1] && buffers[fd1]->b_buffer && buffers[fd1]->b_buffer == buffers[fd2]->b_buffer)\n\tbuffers[fd2] = (BUFFERED_STREAM *)NULL;\n       \n      else if (buffers[fd2]->b_flag & B_SHAREDBUF)\n\t{\n\t  buffers[fd2]->b_buffer = (char *)NULL;\n\t  free_buffered_stream (buffers[fd2]);\n\t}\n      else\n\tfree_buffered_stream (buffers[fd2]);\n    }\n  buffers[fd2] = copy_buffered_stream (buffers[fd1]);\n  if (buffers[fd2])\n    buffers[fd2]->b_fd = fd2;\n\n  if (is_bash_input)\n    {\n      if (!buffers[fd2])\n\tfd_to_buffered_stream (fd2);\n      buffers[fd2]->b_flag |= B_WASBASHINPUT;\n    }\n\n  if (fd_is_bash_input (fd1) || (buffers[fd1] && (buffers[fd1]->b_flag & B_SHAREDBUF)))\n    buffers[fd2]->b_flag |= B_SHAREDBUF;\n\n  return (fd2);\n}\n\n \n#define fd_is_seekable(fd) (lseek ((fd), 0L, SEEK_CUR) >= 0)\n\n \nBUFFERED_STREAM *\nfd_to_buffered_stream (fd)\n     int fd;\n{\n  char *buffer;\n  size_t size;\n  struct stat sb;\n\n  if (fstat (fd, &sb) < 0)\n    {\n      close (fd);\n      return ((BUFFERED_STREAM *)NULL);\n    }\n\n  size = (fd_is_seekable (fd)) ? min (sb.st_size, MAX_INPUT_BUFFER_SIZE) : 1;\n  if (size == 0)\n    size = 1;\n  buffer = (char *)xmalloc (size);\n\n  return (make_buffered_stream (fd, buffer, size));\n}\n\n \nBUFFERED_STREAM *\nopen_buffered_stream (file)\n     char *file;\n{\n  int fd;\n\n  fd = open (file, O_RDONLY);\n  return ((fd >= 0) ? fd_to_buffered_stream (fd) : (BUFFERED_STREAM *)NULL);\n}\n\n \nvoid\nfree_buffered_stream (bp)\n     BUFFERED_STREAM *bp;\n{\n  int n;\n\n  if (!bp)\n    return;\n\n  n = bp->b_fd;\n  if (bp->b_buffer)\n    free (bp->b_buffer);\n  free (bp);\n  buffers[n] = (BUFFERED_STREAM *)NULL;\n}\n\n \nint\nclose_buffered_stream (bp)\n     BUFFERED_STREAM *bp;\n{\n  int fd;\n\n  if (!bp)\n    return (0);\n  fd = bp->b_fd;\n  if (bp->b_flag & B_SHAREDBUF)\n    bp->b_buffer = (char *)NULL;\n  free_buffered_stream (bp);\n  return (close (fd));\n}\n\n \nint\nclose_buffered_fd (fd)\n     int fd;\n{\n  if (fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (fd >= nbuffers || !buffers || !buffers[fd])\n    return (close (fd));\n  return (close_buffered_stream (buffers[fd]));\n}\n\n \nBUFFERED_STREAM *\nset_buffered_stream (fd, bp)\n     int fd;\n     BUFFERED_STREAM *bp;\n{\n  BUFFERED_STREAM *ret;\n\n  ret = buffers[fd];\n  buffers[fd] = bp;\n  return ret;\n}\n\n \nstatic int\nb_fill_buffer (bp)\n     BUFFERED_STREAM *bp;\n{\n  ssize_t nr;\n  off_t o;\n\n  CHECK_TERMSIG;\n   \n  if ((bp->b_flag & (B_TEXT | B_UNBUFF)) == B_TEXT)\n    {\n      o = lseek (bp->b_fd, 0, SEEK_CUR);\n      nr = zread (bp->b_fd, bp->b_buffer, bp->b_size);\n      if (nr > 0 && nr < lseek (bp->b_fd, 0, SEEK_CUR) - o)\n\t{\n\t  lseek (bp->b_fd, o, SEEK_SET);\n\t  bp->b_flag |= B_UNBUFF;\n\t  bp->b_size = 1;\n\t  nr = zread (bp->b_fd, bp->b_buffer, bp->b_size);\n\t}\n    }\n  else\n    nr = zread (bp->b_fd, bp->b_buffer, bp->b_size);\n  if (nr <= 0)\n    {\n      bp->b_used = bp->b_inputp = 0;\n      bp->b_buffer[0] = 0;\n      if (nr == 0)\n\tbp->b_flag |= B_EOF;\n      else\n\tbp->b_flag |= B_ERROR;\n      return (EOF);\n    }\n\n  bp->b_used = nr;\n  bp->b_inputp = 0;\n  return (bp->b_buffer[bp->b_inputp++] & 0xFF);\n}\n\n \n#define bufstream_getc(bp) \\\n  (bp->b_inputp == bp->b_used || !bp->b_used) \\\n  \t\t? b_fill_buffer (bp) \\\n\t\t: bp->b_buffer[bp->b_inputp++] & 0xFF\n\n \nstatic int\nbufstream_ungetc(c, bp)\n     int c;\n     BUFFERED_STREAM *bp;\n{\n  if (c == EOF || bp == 0 || bp->b_inputp == 0)\n    return (EOF);\n\n  bp->b_buffer[--bp->b_inputp] = c;\n  return (c);\n}\n\n \nint\nsync_buffered_stream (bfd)\n     int bfd;\n{\n  BUFFERED_STREAM *bp;\n  off_t chars_left;\n\n  if (buffers == 0 || (bp = buffers[bfd]) == 0)\n    return (-1);\n\n  chars_left = bp->b_used - bp->b_inputp;\n  if (chars_left)\n    lseek (bp->b_fd, -chars_left, SEEK_CUR);\n  bp->b_used = bp->b_inputp = 0;\n  return (0);\n}\n\nint\nbuffered_getchar ()\n{\n  CHECK_TERMSIG;\n\n  if (bash_input.location.buffered_fd < 0 || buffers[bash_input.location.buffered_fd] == 0)\n    return EOF;\n\n#if !defined (DJGPP)\n  return (bufstream_getc (buffers[bash_input.location.buffered_fd]));\n#else\n   \n  int ch;\n  while ((ch = bufstream_getc (buffers[bash_input.location.buffered_fd])) == '\\r')\n    ;\n  return ch;\n#endif\n}\n\nint\nbuffered_ungetchar (c)\n     int c;\n{\n  return (bufstream_ungetc (c, buffers[bash_input.location.buffered_fd]));\n}\n\n \nvoid\nwith_input_from_buffered_stream (bfd, name)\n     int bfd;\n     char *name;\n{\n  INPUT_STREAM location;\n  BUFFERED_STREAM *bp;\n\n  location.buffered_fd = bfd;\n   \n  bp = fd_to_buffered_stream (bfd);\n  init_yy_io (bp == 0 ? return_EOF : buffered_getchar,\n\t      buffered_ungetchar, st_bstream, name, location);\n}\n\n#if defined (TEST)\nvoid *\nxmalloc(s)\nint s;\n{\n\treturn (malloc (s));\n}\n\nvoid *\nxrealloc(s, size)\nchar\t*s;\nint\tsize;\n{\n\tif (!s)\n\t\treturn(malloc (size));\n\telse\n\t\treturn(realloc (s, size));\n}\n\nvoid\ninit_yy_io ()\n{\n}\n\nprocess(bp)\nBUFFERED_STREAM *bp;\n{\n\tint c;\n\n\twhile ((c = bufstream_getc(bp)) != EOF)\n\t\tputchar(c);\n}\n\nBASH_INPUT bash_input;\n\nstruct stat dsb;\t\t \n\n \nmain(argc, argv)\nint\targc;\nchar\t**argv;\n{\n\tregister int i;\n\tBUFFERED_STREAM *bp;\n\n\tif (argc == 1) {\n\t\tbp = fd_to_buffered_stream (0);\n\t\tprocess(bp);\n\t\texit(0);\n\t}\n\tfor (i = 1; i < argc; i++) {\n\t\tif (argv[i][0] == '-' && argv[i][1] == '\\0') {\n\t\t\tbp = fd_to_buffered_stream (0);\n\t\t\tif (!bp)\n\t\t\t\tcontinue;\n\t\t\tprocess(bp);\n\t\t\tfree_buffered_stream (bp);\n\t\t} else {\n\t\t\tbp = open_buffered_stream (argv[i]);\n\t\t\tif (!bp)\n\t\t\t\tcontinue;\n\t\t\tprocess(bp);\n\t\t\tclose_buffered_stream (bp);\n\t\t}\n\t}\n\texit(0);\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}