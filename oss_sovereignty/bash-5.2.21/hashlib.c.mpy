{
  "module_name": "hashlib.c",
  "hash_id": "67e68370690e512a172dbe8b2c2886514d0f6c7c5bce3f7ceb6b9f18d373d893",
  "original_prompt": "Ingested from bash-5.2.21/hashlib.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"bashansi.h\"\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n\n#include \"shell.h\"\n#include \"hashlib.h\"\n\n \n#define HASH_REHASH_MULTIPLIER\t4\n#define HASH_REHASH_FACTOR\t2\n\n#define HASH_SHOULDGROW(table) \\\n  ((table)->nentries >= (table)->nbuckets * HASH_REHASH_FACTOR)\n\n \n#define HASH_SHOULDSHRINK(table) \\\n  (((table)->nbuckets > DEFAULT_HASH_BUCKETS) && \\\n   ((table)->nentries < (table)->nbuckets / HASH_REHASH_MULTIPLIER))\n\n \n#define HASH_BUCKET(s, t, h) (((h) = hash_string (s)) & ((t)->nbuckets - 1))\n\nstatic BUCKET_CONTENTS *copy_bucket_array PARAMS((BUCKET_CONTENTS *, sh_string_func_t *));\n\nstatic void hash_rehash PARAMS((HASH_TABLE *, int));\nstatic void hash_grow PARAMS((HASH_TABLE *));\nstatic void hash_shrink PARAMS((HASH_TABLE *));\n\n \nHASH_TABLE *\nhash_create (buckets)\n     int buckets;\n{\n  HASH_TABLE *new_table;\n  register int i;\n\n  new_table = (HASH_TABLE *)xmalloc (sizeof (HASH_TABLE));\n  if (buckets == 0)\n    buckets = DEFAULT_HASH_BUCKETS;\n\n  new_table->bucket_array =\n    (BUCKET_CONTENTS **)xmalloc (buckets * sizeof (BUCKET_CONTENTS *));\n  new_table->nbuckets = buckets;\n  new_table->nentries = 0;\n\n  for (i = 0; i < buckets; i++)\n    new_table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;\n\n  return (new_table);\n}\n\nint\nhash_size (table)\n     HASH_TABLE *table;\n{\n  return (HASH_ENTRIES(table));\n}\n\nstatic BUCKET_CONTENTS *\ncopy_bucket_array (ba, cpdata)\n     BUCKET_CONTENTS *ba;\n     sh_string_func_t *cpdata;\t \n{\n  BUCKET_CONTENTS *new_bucket, *n, *e;\n\n  if (ba == 0)\n    return ((BUCKET_CONTENTS *)0);\n\n  for (n = (BUCKET_CONTENTS *)0, e = ba; e; e = e->next)\n    {\n      if (n == 0)\n        {\n          new_bucket = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));\n          n = new_bucket;\n        }\n      else\n        {\n          n->next = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));\n          n = n->next;\n        }\n\n      n->key = savestring (e->key);\n      n->data = e->data ? (cpdata ? (*cpdata) (e->data) : savestring (e->data))\n\t\t\t: NULL;\n      n->khash = e->khash;\n      n->times_found = e->times_found;\n      n->next = (BUCKET_CONTENTS *)NULL;\n    }\n\n  return new_bucket;  \n}\n\nstatic void\nhash_rehash (table, nsize)\n     HASH_TABLE *table;\n     int nsize;\n{\n  int osize, i, j;\n  BUCKET_CONTENTS **old_bucket_array, *item, *next;\n\n  if (table == NULL || nsize == table->nbuckets)\n    return;\n\n  osize = table->nbuckets;\n  old_bucket_array = table->bucket_array;\n\n  table->nbuckets = nsize;\n  table->bucket_array = (BUCKET_CONTENTS **)xmalloc (table->nbuckets * sizeof (BUCKET_CONTENTS *));\n  for (i = 0; i < table->nbuckets; i++)\n    table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;\n\n  for (j = 0; j < osize; j++)\n    {\n      for (item = old_bucket_array[j]; item; item = next)\n\t{\n\t  next = item->next;\n\t  i = item->khash & (table->nbuckets - 1);\n\t  item->next = table->bucket_array[i];\n\t  table->bucket_array[i] = item;\n\t}\n    }\n\n  free (old_bucket_array);\n}\n\nstatic void\nhash_grow (table)\n     HASH_TABLE *table;\n{\n  int nsize;\n\n  nsize = table->nbuckets * HASH_REHASH_MULTIPLIER;\n  if (nsize > 0)\t\t \n    hash_rehash (table, nsize);\n}\n\nstatic void\nhash_shrink (table)\n     HASH_TABLE *table;\n{\n  int nsize;\n\n  nsize = table->nbuckets / HASH_REHASH_MULTIPLIER;\n  hash_rehash (table, nsize);\n}\n\nHASH_TABLE *\nhash_copy (table, cpdata)\n     HASH_TABLE *table;\n     sh_string_func_t *cpdata;\n{\n  HASH_TABLE *new_table;\n  int i;\n\n  if (table == 0)\n    return ((HASH_TABLE *)NULL);\n\n  new_table = hash_create (table->nbuckets);\n\n  for (i = 0; i < table->nbuckets; i++)\n    new_table->bucket_array[i] = copy_bucket_array (table->bucket_array[i], cpdata);\n\n  new_table->nentries = table->nentries;\n  return new_table;\n}\n\n \n\n#define FNV_OFFSET 2166136261\n#define FNV_PRIME 16777619\n\n \n\n \nunsigned int\nhash_string (s)\n     const char *s;\n{\n  register unsigned int i;\n\n  for (i = FNV_OFFSET; *s; s++)\n    {\n       \n\n       \n      i += (i<<1) + (i<<4) + (i<<7) + (i<<8) + (i<<24);\n      i ^= *s;\n    }\n\n  return i;\n}\n\n \n\nint\nhash_bucket (string, table)\n     const char *string;\n     HASH_TABLE *table;\n{\n  unsigned int h;\n\n  return (HASH_BUCKET (string, table, h));\n}\n\n \nBUCKET_CONTENTS *\nhash_search (string, table, flags)\n     const char *string;\n     HASH_TABLE *table;\n     int flags;\n{\n  BUCKET_CONTENTS *list;\n  int bucket;\n  unsigned int hv;\n\n  if (table == 0 || ((flags & HASH_CREATE) == 0 && HASH_ENTRIES (table) == 0))\n    return (BUCKET_CONTENTS *)NULL;\n\n  bucket = HASH_BUCKET (string, table, hv);\n\n  for (list = table->bucket_array ? table->bucket_array[bucket] : 0; list; list = list->next)\n    {\n       \n      if (hv == list->khash && STREQ (list->key, string))\n\t{\n\t  list->times_found++;\n\t  return (list);\n\t}\n    }\n\n  if (flags & HASH_CREATE)\n    {\n      if (HASH_SHOULDGROW (table))\n\t{\n\t  hash_grow (table);\n\t  bucket = HASH_BUCKET (string, table, hv);\n\t}\n\n      list = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));\n      list->next = table->bucket_array[bucket];\n      table->bucket_array[bucket] = list;\n\n      list->data = NULL;\n      list->key = (char *)string;\t \n      list->khash = hv;\n      list->times_found = 0;\n\n      table->nentries++;\n      return (list);\n    }\n      \n  return (BUCKET_CONTENTS *)NULL;\n}\n\n \nBUCKET_CONTENTS *\nhash_remove (string, table, flags)\n     const char *string;\n     HASH_TABLE *table;\n     int flags;\n{\n  int bucket;\n  BUCKET_CONTENTS *prev, *temp;\n  unsigned int hv;\n\n  if (table == 0 || HASH_ENTRIES (table) == 0)\n    return (BUCKET_CONTENTS *)NULL;\n\n  bucket = HASH_BUCKET (string, table, hv);\n  prev = (BUCKET_CONTENTS *)NULL;\n  for (temp = table->bucket_array[bucket]; temp; temp = temp->next)\n    {\n      if (hv == temp->khash && STREQ (temp->key, string))\n\t{\n\t  if (prev)\n\t    prev->next = temp->next;\n\t  else\n\t    table->bucket_array[bucket] = temp->next;\n\n\t  table->nentries--;\n\t  return (temp);\n\t}\n      prev = temp;\n    }\n  return ((BUCKET_CONTENTS *) NULL);\n}\n\n \nBUCKET_CONTENTS *\nhash_insert (string, table, flags)\n     char *string;\n     HASH_TABLE *table;\n     int flags;\n{\n  BUCKET_CONTENTS *item;\n  int bucket;\n  unsigned int hv;\n\n  if (table == 0)\n    table = hash_create (0);\n\n  item = (flags & HASH_NOSRCH) ? (BUCKET_CONTENTS *)NULL\n  \t\t\t       : hash_search (string, table, 0);\n\n  if (item == 0)\n    {\n      if (HASH_SHOULDGROW (table))\n\thash_grow (table);\n\n      bucket = HASH_BUCKET (string, table, hv);\n\n      item = (BUCKET_CONTENTS *)xmalloc (sizeof (BUCKET_CONTENTS));\n      item->next = table->bucket_array[bucket];\n      table->bucket_array[bucket] = item;\n\n      item->data = NULL;\n      item->key = string;\n      item->khash = hv;\n      item->times_found = 0;\n\n      table->nentries++;\n    }\n\n  return (item);\n}\n\n \nvoid\nhash_flush (table, free_data)\n     HASH_TABLE *table;\n     sh_free_func_t *free_data;\n{\n  int i;\n  register BUCKET_CONTENTS *bucket, *item;\n\n  if (table == 0 || HASH_ENTRIES (table) == 0)\n    return;\n\n  for (i = 0; i < table->nbuckets; i++)\n    {\n      bucket = table->bucket_array[i];\n\n      while (bucket)\n\t{\n\t  item = bucket;\n\t  bucket = bucket->next;\n\n\t  if (free_data)\n\t    (*free_data) (item->data);\n\t  else\n\t    free (item->data);\n\t  free (item->key);\n\t  free (item);\n\t}\n      table->bucket_array[i] = (BUCKET_CONTENTS *)NULL;\n    }\n\n  table->nentries = 0;\n}\n\n \nvoid\nhash_dispose (table)\n     HASH_TABLE *table;\n{\n  free (table->bucket_array);\n  free (table);\n}\n\nvoid\nhash_walk (table, func)\n     HASH_TABLE *table;\n     hash_wfunc *func;\n{\n  register int i;\n  BUCKET_CONTENTS *item;\n\n  if (table == 0 || HASH_ENTRIES (table) == 0)\n    return;\n\n  for (i = 0; i < table->nbuckets; i++)\n    {\n      for (item = hash_items (i, table); item; item = item->next)\n\tif ((*func) (item) < 0)\n\t  return;\n    }\n}\n\n#if defined (DEBUG) || defined (TEST_HASHING)\nvoid\nhash_pstats (table, name)\n     HASH_TABLE *table;\n     char *name;\n{\n  register int slot, bcount;\n  register BUCKET_CONTENTS *bc;\n\n  if (name == 0)\n    name = \"unknown hash table\";\n\n  fprintf (stderr, \"%s: %d buckets; %d items\\n\", name, table->nbuckets, table->nentries);\n\n   \n  for (slot = 0; slot < table->nbuckets; slot++)\n    {\n      bc = hash_items (slot, table);\n\n      fprintf (stderr, \"\\tslot %3d: \", slot);\n      for (bcount = 0; bc; bc = bc->next)\n\tbcount++;\n\n      fprintf (stderr, \"%d\\n\", bcount);\n    }\n}\n#endif\n\n#ifdef TEST_HASHING\n\n \n#undef NULL\n#include <stdio.h>\n\n#ifndef NULL\n#define NULL 0\n#endif\n\nHASH_TABLE *table, *ntable;\n\nint interrupt_immediately = 0;\nint running_trap = 0;\n\nint\nsignal_is_trapped (s)\n     int s;\n{\n  return (0);\n}\n\nvoid\nprogramming_error (const char *format, ...)\n{\n  abort();\n}\n\nvoid\nfatal_error (const char *format, ...)\n{\n  abort();\n}\n\nvoid\ninternal_warning (const char *format, ...)\n{\n}\n\nint\nmain ()\n{\n  char string[256];\n  int count = 0;\n  BUCKET_CONTENTS *tt;\n\n#if defined (TEST_NBUCKETS)\n  table = hash_create (TEST_NBUCKETS);\n#else\n  table = hash_create (0);\n#endif\n\n  for (;;)\n    {\n      char *temp_string;\n      if (fgets (string, sizeof (string), stdin) == 0)\n\tbreak;\n      if (!*string)\n\tbreak;\n      temp_string = savestring (string);\n      tt = hash_insert (temp_string, table, 0);\n      if (tt->times_found)\n\t{\n\t  fprintf (stderr, \"You have already added item `%s'\\n\", string);\n\t  free (temp_string);\n\t}\n      else\n\t{\n\t  count++;\n\t}\n    }\n\n  hash_pstats (table, \"hash test\");\n\n  ntable = hash_copy (table, (sh_string_func_t *)NULL);\n  hash_flush (table, (sh_free_func_t *)NULL);\n  hash_pstats (ntable, \"hash copy test\");\n\n  exit (0);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}