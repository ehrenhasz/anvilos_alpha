{
  "module_name": "bracecomp.c",
  "hash_id": "7b27d69e48cbc613d5b700664a19c106b4a75d5410f8a3a15fab5872d9426fad",
  "original_prompt": "Ingested from bash-5.2.21/bracecomp.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"config.h\"\n\n#if defined (BRACE_EXPANSION) && defined (READLINE)\n\n#include <stdio.h>\n\n#if defined (HAVE_UNISTD_H)\n#  ifdef _MINIX\n#    include <sys/types.h>\n#  endif\n#  include <unistd.h>\n#endif\n\n#include \"bashansi.h\"\n#include \"shmbutil.h\"\n\n#include \"shell.h\"\n#include <readline/readline.h>\n\nstatic int _strcompare PARAMS((char **, char **));\n\n \nstatic int\nstring_gcd (s1, s2)\n     char *s1, *s2;\n{\n  register int i;\n\n  if (s1 == NULL || s2 == NULL)\n    return (0);\n\n  for (i = 0; *s1 && *s2; ++s1, ++s2, ++i)\n    {\n      if (*s1 != *s2)\n\tbreak;\n    }\n\n  return (i);\n}\n\nstatic char *\nreally_munge_braces (array, real_start, real_end, gcd_zero)\n     char **array;\n     int real_start, real_end, gcd_zero;\n{\n  int start, end, gcd;\n  char *result, *subterm, *x;\n  int result_size, flag, tlen;\n\n  flag = 0;\n\n  if (real_start == real_end)\n    {\n      x = array[real_start] ? sh_backslash_quote (array[real_start] + gcd_zero, 0, 0)\n \t\t\t    : sh_backslash_quote (array[0], 0, 0);\n      return x;\n    }\n\n  result = (char *)xmalloc (result_size = 16);\n  *result = '\\0';\n\n  for (start = real_start; start < real_end; start = end + 1)\n    {\n      gcd = strlen (array[start]);\n      for (end = start + 1; end < real_end; end++)\n\t{\n\t  int temp;\n\n\t  temp = string_gcd (array[start], array[end]);\n\n\t  if (temp <= gcd_zero)\n\t    break;\n\n\t  gcd = temp;\n\t}\n      end--;\n\n      if (gcd_zero == 0 && start == real_start && end != (real_end - 1))\n\t{\n\t   \n\t  result_size += 1;\n\t  result = (char *)xrealloc (result, result_size);\n\t  result[0] = '{'; result[1] = '\\0';\n\t  flag++;\n\t}\n\n       \n      if (start == end)\n\t{\n\t  x = savestring (array[start] + gcd_zero);\n\t  subterm = sh_backslash_quote (x, 0, 0);\n\t  free (x);\n\t}\n      else\n\t{\n\t   \n\t  tlen = gcd - gcd_zero;\n\t  x = (char *)xmalloc (tlen + 1);\n\t  strncpy (x, array[start] + gcd_zero, tlen);\n\t  x[tlen] = '\\0';\n\t  subterm = sh_backslash_quote (x, 0, 0);\n\t  free (x);\n\t  result_size += strlen (subterm) + 1;\n\t  result = (char *)xrealloc (result, result_size);\n\t  strcat (result, subterm);\n\t  free (subterm);\n\t  strcat (result, \"{\");\n\t  subterm = really_munge_braces (array, start, end + 1, gcd);\n\t  subterm[strlen (subterm) - 1] = '}';\n\t}\n\n      result_size += strlen (subterm) + 1;\n      result = (char *)xrealloc (result, result_size);\n      strcat (result, subterm);\n      strcat (result, \",\");\n      free (subterm);\n    }\n\n  if (gcd_zero == 0)\n    result[strlen (result) - 1] = flag ? '}' : '\\0';\n  return (result);\n}\n\nstatic int\n_strcompare (s1, s2)\n     char **s1, **s2;\n{\n  int result;\n\n  result = **s1 - **s2;\n  if (result == 0)\n    result = strcmp (*s1, *s2);\n\n  return result;\n}\n\nstatic int\nhack_braces_completion (names)\n     char **names;\n{\n  register int i;\n  char *temp;\n\n  i = strvec_len (names);\n  if (MB_CUR_MAX > 1 && i > 2)\n    qsort (names+1, i-1, sizeof (char *), (QSFUNC *)_strcompare);\n      \n  temp = really_munge_braces (names, 1, i, 0);\n\n  for (i = 0; names[i]; ++i)\n    {\n      free (names[i]);\n      names[i] = NULL;\n    }\n  names[0] = temp;\n  return 0;\n}\n\n \nint\nbash_brace_completion (count, ignore)\n     int count, ignore;\n{\n  rl_compignore_func_t *orig_ignore_func;\n  rl_compentry_func_t *orig_entry_func;\n  rl_quote_func_t *orig_quoting_func;\n  rl_completion_func_t *orig_attempt_func;\n  int orig_quoting_desired, r;\n\n  orig_ignore_func = rl_ignore_some_completions_function;\n  orig_attempt_func = rl_attempted_completion_function;\n  orig_entry_func = rl_completion_entry_function;\n  orig_quoting_func = rl_filename_quoting_function;\n  orig_quoting_desired = rl_filename_quoting_desired;\n\n  rl_completion_entry_function = rl_filename_completion_function;\n  rl_attempted_completion_function = (rl_completion_func_t *)NULL;\n  rl_ignore_some_completions_function = hack_braces_completion;\n  rl_filename_quoting_function = (rl_quote_func_t *)NULL;\n  rl_filename_quoting_desired = 0;\n\n  r = rl_complete_internal (TAB);\n\n  rl_ignore_some_completions_function = orig_ignore_func;\n  rl_attempted_completion_function = orig_attempt_func;\n  rl_completion_entry_function = orig_entry_func;\n  rl_filename_quoting_function = orig_quoting_func;\n  rl_filename_quoting_desired = orig_quoting_desired;\n\n  return r;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}