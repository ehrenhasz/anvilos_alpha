{
  "module_name": "jobs.c",
  "hash_id": "7bf106f6e07c9fd8d0b718d00863e23a71a406d9eeb81afe58ad4423cb8ff66b",
  "original_prompt": "Ingested from bash-5.2.21/jobs.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include \"trap.h\"\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include \"posixtime.h\"\n\n#if defined (HAVE_SYS_RESOURCE_H) && defined (HAVE_WAIT3) && !defined (_POSIX_VERSION) && !defined (RLIMTYPE)\n#  include <sys/resource.h>\n#endif  \n\n#if defined (HAVE_SYS_FILE_H)\n#  include <sys/file.h>\n#endif\n\n#include \"filecntl.h\"\n#include <sys/ioctl.h>\n#if defined (HAVE_SYS_PARAM_H)\n#include <sys/param.h>\n#endif\n\n#if defined (BUFFERED_INPUT)\n#  include \"input.h\"\n#endif\n\n \n#include \"shtty.h\"\n\n \n \n\n \n#if defined (hpux) && !defined (TERMIOS_TTY_DRIVER)\n#  include <bsdtty.h>\n#endif  \n\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n#include \"shell.h\"\n#include \"parser.h\"\n#include \"jobs.h\"\n#include \"execute_cmd.h\"\n#include \"flags.h\"\n\n#include \"typemax.h\"\n\n#include \"builtins/builtext.h\"\n#include \"builtins/common.h\"\n\n#if defined (READLINE)\n# include <readline/readline.h>\n#endif\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n#if !defined (HAVE_KILLPG)\nextern int killpg PARAMS((pid_t, int));\n#endif\n\n#if !DEFAULT_CHILD_MAX\n#  define DEFAULT_CHILD_MAX 4096\n#endif\n\n#if !MAX_CHILD_MAX\n#  define MAX_CHILD_MAX 32768\n#endif\n\n#if !defined (DEBUG)\n#define MAX_JOBS_IN_ARRAY 4096\t\t \n#else\n#define MAX_JOBS_IN_ARRAY 128\t\t \n#endif\n\n \n#define PIDSTAT_TABLE_SZ 4096\n#define BGPIDS_TABLE_SZ 512\n\n \n#define DEL_WARNSTOPPED\t\t1\t \n#define DEL_NOBGPID\t\t2\t \n\n \n\n#if defined (ultrix) && defined (mips) && defined (_POSIX_VERSION)\n#  define WAITPID(pid, statusp, options) \\\n\twait3 ((union wait *)statusp, options, (struct rusage *)0)\n#else\n#  if defined (_POSIX_VERSION) || defined (HAVE_WAITPID)\n#    define WAITPID(pid, statusp, options) \\\n\twaitpid ((pid_t)pid, statusp, options)\n#  else\n#    if defined (HAVE_WAIT3)\n#      define WAITPID(pid, statusp, options) \\\n\twait3 (statusp, options, (struct rusage *)0)\n#    else\n#      define WAITPID(pid, statusp, options) \\\n\twait3 (statusp, options, (int *)0)\n#    endif  \n#  endif  \n#endif  \n\n \n#if defined (GETPGRP_VOID)\n#  define getpgid(p) getpgrp ()\n#else\n#  define getpgid(p) getpgrp (p)\n#endif  \n\n \n#if defined (MUST_REINSTALL_SIGHANDLERS)\n#  define REINSTALL_SIGCHLD_HANDLER signal (SIGCHLD, sigchld_handler)\n#else\n#  define REINSTALL_SIGCHLD_HANDLER\n#endif  \n\n \n#if !defined (WCONTINUED) || defined (WCONTINUED_BROKEN)\n#  undef WCONTINUED\n#  define WCONTINUED 0\n#endif\n#if !defined (WIFCONTINUED)\n#  define WIFCONTINUED(s)\t(0)\n#endif\n\n \n#define JOB_SLOTS 8\n\ntypedef int sh_job_map_func_t PARAMS((JOB *, int, int, int));\n\n \nextern WORD_LIST *subst_assign_varlist;\n\nextern SigHandler **original_signals;\n\nextern void set_original_signal PARAMS((int, SigHandler *));\n\nstatic struct jobstats zerojs = { -1L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NO_JOB, NO_JOB, 0, 0 };\nstruct jobstats js = { -1L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NO_JOB, NO_JOB, 0, 0 };\n\nps_index_t pidstat_table[PIDSTAT_TABLE_SZ];\nstruct bgpids bgpids = { 0, 0, 0, 0 };\n\nstruct procchain procsubs = { 0, 0, 0 };\n\n \nJOB **jobs = (JOB **)NULL;\n\n#if 0\n \nint job_slots = 0;\n#endif\n\n \nint shell_tty = -1;\n\n \npid_t shell_pgrp = NO_PID;\n\n \npid_t terminal_pgrp = NO_PID;\n\n \npid_t original_pgrp = NO_PID;\n\n \npid_t pipeline_pgrp = (pid_t)0;\n\n#if defined (PGRP_PIPE)\n \nint pgrp_pipe[2] = { -1, -1 };\n#endif\n\n \nvolatile pid_t last_made_pid = NO_PID;\n\n \nvolatile pid_t last_asynchronous_pid = NO_PID;\n\n \nPROCESS *the_pipeline = (PROCESS *)NULL;\n\n \nint job_control = 1;\n\n \nint running_in_background = 0;\n\n \nint already_making_children = 0;\n\n \nint check_window_size = CHECKWINSIZE_DEFAULT;\n\nPROCESS *last_procsub_child = (PROCESS *)NULL;\n\n \n\nvoid debug_print_pgrps (void);\n\nstatic sighandler wait_sigint_handler PARAMS((int));\nstatic sighandler sigchld_handler PARAMS((int));\nstatic sighandler sigcont_sighandler PARAMS((int));\nstatic sighandler sigstop_sighandler PARAMS((int));\n\nstatic int waitchld PARAMS((pid_t, int));\n\nstatic PROCESS *find_pid_in_pipeline PARAMS((pid_t, PROCESS *, int));\nstatic PROCESS *find_pipeline PARAMS((pid_t, int, int *));\nstatic PROCESS *find_process PARAMS((pid_t, int, int *));\n\nstatic char *current_working_directory PARAMS((void));\nstatic char *job_working_directory PARAMS((void));\nstatic char *j_strsignal PARAMS((int));\nstatic char *printable_job_status PARAMS((int, PROCESS *, int));\n\nstatic PROCESS *find_last_proc PARAMS((int, int));\nstatic pid_t find_last_pid PARAMS((int, int));\n\nstatic int set_new_line_discipline PARAMS((int));\nstatic int map_over_jobs PARAMS((sh_job_map_func_t *, int, int));\nstatic int job_last_stopped PARAMS((int));\nstatic int job_last_running PARAMS((int));\nstatic int most_recent_job_in_state PARAMS((int, JOB_STATE));\nstatic int find_job PARAMS((pid_t, int, PROCESS **));\nstatic int print_job PARAMS((JOB *, int, int, int));\nstatic int process_exit_status PARAMS((WAIT));\nstatic int process_exit_signal PARAMS((WAIT));\nstatic int set_job_status_and_cleanup PARAMS((int));\n\nstatic WAIT job_signal_status PARAMS((int));\nstatic WAIT raw_job_exit_status PARAMS((int));\n\nstatic void notify_of_job_status PARAMS((void));\nstatic void reset_job_indices PARAMS((void));\nstatic void cleanup_dead_jobs PARAMS((void));\nstatic int processes_in_job PARAMS((int));\nstatic void realloc_jobs_list PARAMS((void));\nstatic int compact_jobs_list PARAMS((int));\nstatic void add_process PARAMS((char *, pid_t));\nstatic void print_pipeline PARAMS((PROCESS *, int, int, FILE *));\nstatic void pretty_print_job PARAMS((int, int, FILE *));\nstatic void set_current_job PARAMS((int));\nstatic void reset_current PARAMS((void));\nstatic void set_job_running PARAMS((int));\nstatic void setjstatus PARAMS((int));\nstatic int maybe_give_terminal_to PARAMS((pid_t, pid_t, int));\nstatic void mark_all_jobs_as_dead PARAMS((void));\nstatic void mark_dead_jobs_as_notified PARAMS((int));\nstatic void restore_sigint_handler PARAMS((void));\n#if defined (PGRP_PIPE)\nstatic void pipe_read PARAMS((int *));\n#endif\n\n \n\nstatic ps_index_t *pshash_getbucket PARAMS((pid_t));\nstatic void pshash_delindex PARAMS((ps_index_t));\n\n \nstatic struct pidstat *bgp_add PARAMS((pid_t, int));\nstatic int bgp_delete PARAMS((pid_t));\nstatic void bgp_clear PARAMS((void));\nstatic int bgp_search PARAMS((pid_t));\n\nstatic struct pipeline_saver *alloc_pipeline_saver PARAMS((void));\n\nstatic ps_index_t bgp_getindex PARAMS((void));\nstatic void bgp_resize PARAMS((void));\t \n\n#if defined (ARRAY_VARS)\nstatic int *pstatuses;\t\t \nstatic int statsize;\n#endif\n\n \nstatic int sigchld;\nstatic int queue_sigchld;\n\n#define QUEUE_SIGCHLD(os)\t(os) = sigchld, queue_sigchld++\n\n \n#define UNQUEUE_SIGCHLD(os) \\\n\tdo { \\\n\t  queue_sigchld--; \\\n\t  if (queue_sigchld == 0 && os != sigchld) \\\n\t    { \\\n\t      queue_sigchld = 1; \\\n\t      waitchld (-1, 0); \\\n\t      queue_sigchld = 0; \\\n\t    } \\\n\t} while (0)\n\nstatic SigHandler *old_tstp, *old_ttou, *old_ttin;\nstatic SigHandler *old_cont = (SigHandler *)SIG_DFL;\n\n \nstatic struct pipeline_saver *saved_pipeline;\nstatic int saved_already_making_children;\n\n \nstatic int jobs_list_frozen;\n\nstatic char retcode_name_buffer[64];\n\n#if !defined (_POSIX_VERSION)\n\n \n#define setpgid(pid, pgrp)\tsetpgrp (pid, pgrp)\n#define tcsetpgrp(fd, pgrp)\tioctl ((fd), TIOCSPGRP, &(pgrp))\n\npid_t\ntcgetpgrp (fd)\n     int fd;\n{\n  pid_t pgrp;\n\n   \n  if (ioctl (fd, TIOCGPGRP, &pgrp) < 0)\n    return (-1);\n  return (pgrp);\n}\n\n#endif  \n\n \nvoid\ninit_job_stats ()\n{\n  js = zerojs;\n}\n\n \nstatic char *\ncurrent_working_directory ()\n{\n  char *dir;\n  static char d[PATH_MAX];\n\n  dir = get_string_value (\"PWD\");\n\n  if (dir == 0 && the_current_working_directory && no_symbolic_links)\n    dir = the_current_working_directory;\n\n  if (dir == 0)\n    {\n      dir = getcwd (d, sizeof(d));\n      if (dir)\n\tdir = d;\n    }\n\n  return (dir == 0) ? \"<unknown>\" : dir;\n}\n\n \nstatic char *\njob_working_directory ()\n{\n  char *dir;\n\n  dir = get_string_value (\"PWD\");\n  if (dir)\n    return (savestring (dir));\n\n  dir = get_working_directory (\"job-working-directory\");\n  if (dir)\n    return (dir);\n\n  return (savestring (\"<unknown>\"));\n}\n\nvoid\nmaking_children ()\n{\n  if (already_making_children)\n    return;\n\n  already_making_children = 1;\n  start_pipeline ();\n}\n\nvoid\nstop_making_children ()\n{\n  already_making_children = 0;\n}\n\nvoid\ncleanup_the_pipeline ()\n{\n  PROCESS *disposer;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  disposer = the_pipeline;\n  the_pipeline = (PROCESS *)NULL;\n  UNBLOCK_CHILD (oset);\n\n  if (disposer)\n    discard_pipeline (disposer);\n}\n\n \nvoid\ndiscard_last_procsub_child ()\n{\n  PROCESS *disposer;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  disposer = last_procsub_child;\n  last_procsub_child = (PROCESS *)NULL;\n  UNBLOCK_CHILD (oset);\n\n  if (disposer)\n    discard_pipeline (disposer);\n}\n\nstatic struct pipeline_saver *\nalloc_pipeline_saver ()\n{\n  struct pipeline_saver *ret;\n\n  ret = (struct pipeline_saver *)xmalloc (sizeof (struct pipeline_saver));\n  ret->pipeline = 0;\n  ret->next = 0;\n  return ret;\n}\n\nvoid\nsave_pipeline (clear)\n     int clear;\n{\n  sigset_t set, oset;\n  struct pipeline_saver *saver;\n\n  BLOCK_CHILD (set, oset);\n  saver = alloc_pipeline_saver ();\n  saver->pipeline = the_pipeline;\n  saver->next = saved_pipeline;\n  saved_pipeline = saver;\n  if (clear)\n    the_pipeline = (PROCESS *)NULL;\n  saved_already_making_children = already_making_children;\n  UNBLOCK_CHILD (oset);\n}\n\nPROCESS *\nrestore_pipeline (discard)\n     int discard;\n{\n  PROCESS *old_pipeline;\n  sigset_t set, oset;\n  struct pipeline_saver *saver;\n\n  BLOCK_CHILD (set, oset);\n  old_pipeline = the_pipeline;\n  the_pipeline = saved_pipeline->pipeline;\n  saver = saved_pipeline;\n  saved_pipeline = saved_pipeline->next;\n  free (saver);\n  already_making_children = saved_already_making_children;\n  UNBLOCK_CHILD (oset);\n\n  if (discard && old_pipeline)\n    {\n      discard_pipeline (old_pipeline);\n      return ((PROCESS *)NULL);\n    }\n  return old_pipeline;\n}\n\n \nvoid\nstart_pipeline ()\n{\n  if (the_pipeline)\n    {\n      cleanup_the_pipeline ();\n       \n      if (pipeline_pgrp != shell_pgrp)\n\tpipeline_pgrp = 0;\n#if defined (PGRP_PIPE)\n      sh_closepipe (pgrp_pipe);\n#endif\n    }\n\n#if defined (PGRP_PIPE)\n  if (job_control)\n    {\n      if (pipe (pgrp_pipe) == -1)\n\tsys_error (_(\"start_pipeline: pgrp pipe\"));\n    }\n#endif\n}\n\n \nint\nstop_pipeline (async, deferred)\n     int async;\n     COMMAND *deferred;\n{\n  register int i, j;\n  JOB *newjob;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n\n#if defined (PGRP_PIPE)\n   \n  sh_closepipe (pgrp_pipe);\n#endif\n\n  cleanup_dead_jobs ();\n\n  if (js.j_jobslots == 0)\n    {\n      js.j_jobslots = JOB_SLOTS;\n      jobs = (JOB **)xmalloc (js.j_jobslots * sizeof (JOB *));\n\n       \n      for (i = 0; i < js.j_jobslots; i++)\n\tjobs[i] = (JOB *)NULL;\n\n      js.j_firstj = js.j_lastj = js.j_njobs = 0;\n    }\n\n   \n   \n   \n  if (interactive)\n    {\n      for (i = js.j_jobslots; i; i--)\n\tif (jobs[i - 1])\n\t  break;\n    }\n  else\n    {\n#if 0\n       \n      for (i = js.j_lastj+1; i != js.j_lastj; i++)\n\t{\n\t  if (i >= js.j_jobslots)\n\t    i = 0;\n\t  if (jobs[i] == 0)\n\t    break;\n\t}\t\n      if (i == js.j_lastj)\n        i = js.j_jobslots;\n#else\n       \n      for (i = js.j_lastj ? js.j_lastj + 1 : js.j_lastj; i < js.j_jobslots; i++)\n\tif (jobs[i] == 0)\n\t  break;\n#endif\n    }\n\n   \n\n   \n  if ((interactive_shell == 0 || subshell_environment) && i == js.j_jobslots && js.j_jobslots >= MAX_JOBS_IN_ARRAY)\n    i = compact_jobs_list (0);\n\n   \n  if (i == js.j_jobslots)\n    {\n      js.j_jobslots += JOB_SLOTS;\n      jobs = (JOB **)xrealloc (jobs, (js.j_jobslots * sizeof (JOB *)));\n\n      for (j = i; j < js.j_jobslots; j++)\n\tjobs[j] = (JOB *)NULL;\n    }\n\n   \n  if (the_pipeline)\n    {\n      register PROCESS *p;\n      int any_running, any_stopped, n;\n\n      newjob = (JOB *)xmalloc (sizeof (JOB));\n\n      for (n = 1, p = the_pipeline; p->next != the_pipeline; n++, p = p->next)\n\t;\n      p->next = (PROCESS *)NULL;\n      newjob->pipe = REVERSE_LIST (the_pipeline, PROCESS *);\n      for (p = newjob->pipe; p->next; p = p->next)\n\t;\n      p->next = newjob->pipe;\n\n      the_pipeline = (PROCESS *)NULL;\n      newjob->pgrp = pipeline_pgrp;\n\n       \n      if (pipeline_pgrp != shell_pgrp)\n\tpipeline_pgrp = 0;\n\n      newjob->flags = 0;\n      if (pipefail_opt)\n\tnewjob->flags |= J_PIPEFAIL;\n\n       \n      if (job_control)\n\tnewjob->flags |= J_JOBCONTROL;\n\n       \n      p = newjob->pipe;\n      any_running = any_stopped = 0;\n      do\n\t{\n\t  any_running |= PRUNNING (p);\n\t  any_stopped |= PSTOPPED (p);\n\t  p = p->next;\n\t}\n      while (p != newjob->pipe);\n\n      newjob->state = any_running ? JRUNNING : (any_stopped ? JSTOPPED : JDEAD);\n      newjob->wd = job_working_directory ();\n      newjob->deferred = deferred;\n\n      newjob->j_cleanup = (sh_vptrfunc_t *)NULL;\n      newjob->cleanarg = (PTR_T) NULL;\n\n      jobs[i] = newjob;\n      if (newjob->state == JDEAD && (newjob->flags & J_FOREGROUND))\n\tsetjstatus (i);\n      if (newjob->state == JDEAD)\n\t{\n\t  js.c_reaped += n;\t \n\t  js.j_ndead++;\n\t}\n      js.c_injobs += n;\n\n      js.j_lastj = i;\n      js.j_njobs++;\n    }\n  else\n    newjob = (JOB *)NULL;\n\n  if (newjob)\n    js.j_lastmade = newjob;\n\n  if (async)\n    {\n      if (newjob)\n\t{\n\t  newjob->flags &= ~J_FOREGROUND;\n\t  newjob->flags |= J_ASYNC;\n\t  js.j_lastasync = newjob;\n\t}\n      reset_current ();\n    }\n  else\n    {\n      if (newjob)\n\t{\n\t  newjob->flags |= J_FOREGROUND;\n\t   \n\t  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0 && running_in_background == 0)\n\t    maybe_give_terminal_to (shell_pgrp, newjob->pgrp, 0);\n\t}\n    }\n\n  stop_making_children ();\n  UNBLOCK_CHILD (oset);\n  return (newjob ? i : js.j_current);\n}\n\n \n\n \nstatic void\nbgp_resize ()\n{\n  ps_index_t nsize, nsize_cur, nsize_max;\n  ps_index_t psi;\n\n  if (bgpids.nalloc == 0)\n    {\n       \n      for (psi = 0; psi < PIDSTAT_TABLE_SZ; psi++)\n        pidstat_table[psi] = NO_PIDSTAT;\n      nsize = BGPIDS_TABLE_SZ;\t \n      bgpids.head = 0;\n    }\n  else\n    nsize = bgpids.nalloc;\n\n  nsize_max = TYPE_MAXIMUM (ps_index_t);\n  nsize_cur = (ps_index_t)js.c_childmax;\n  if (nsize_cur < 0)\t\t\t\t \n    nsize_cur = MAX_CHILD_MAX;\n\n  while (nsize > 0 && nsize < nsize_cur)\t \n    nsize <<= 1;\n  if (nsize > nsize_max || nsize <= 0)\t\t \n    nsize = nsize_max;\n  if (nsize > MAX_CHILD_MAX)\n    nsize = nsize_max = MAX_CHILD_MAX;\t\t \n\n  if (bgpids.nalloc < nsize_cur && bgpids.nalloc < nsize_max)\n    {\n      bgpids.storage = (struct pidstat *)xrealloc (bgpids.storage, nsize * sizeof (struct pidstat));\n\n      for (psi = bgpids.nalloc; psi < nsize; psi++)\n\tbgpids.storage[psi].pid = NO_PID;\n\n      bgpids.nalloc = nsize;\n\n    }\n  else if (bgpids.head >= bgpids.nalloc)\t \n    bgpids.head = 0;\n}\n\nstatic ps_index_t\nbgp_getindex ()\n{\n  if (bgpids.nalloc < (ps_index_t)js.c_childmax || bgpids.head >= bgpids.nalloc)\n    bgp_resize ();\n\n  pshash_delindex (bgpids.head);\t\t \n  return bgpids.head++;\n}\n\nstatic ps_index_t *\npshash_getbucket (pid)\n     pid_t pid;\n{\n  unsigned long hash;\t\t \n\n  hash = pid * 0x9e370001UL;\n  return (&pidstat_table[hash % PIDSTAT_TABLE_SZ]);\n}\n\nstatic struct pidstat *\nbgp_add (pid, status)\n     pid_t pid;\n     int status;\n{\n  ps_index_t *bucket, psi;\n  struct pidstat *ps;\n\n   \n\n  bucket = pshash_getbucket (pid);\t \n  psi = bgp_getindex ();\t\t \n\n   \n  if (psi == *bucket)\n    {\n      internal_debug (\"hashed pid %d (pid %d) collides with bgpids.head, skipping\", psi, pid);\n      bgpids.storage[psi].pid = NO_PID;\t\t \n      psi = bgp_getindex ();\t\t\t \n    }\n\n  ps = &bgpids.storage[psi];\n\n  ps->pid = pid;\n  ps->status = status;\n  ps->bucket_next = *bucket;\n  ps->bucket_prev = NO_PIDSTAT;\n\n  bgpids.npid++;\n\n#if 0\n  if (bgpids.npid > js.c_childmax)\n    bgp_prune ();\n#endif\n\n  if (ps->bucket_next != NO_PIDSTAT)\n    bgpids.storage[ps->bucket_next].bucket_prev = psi;\n\n  *bucket = psi;\t\t \n\n  return ps;\n}\n\nstatic void\npshash_delindex (psi)\n     ps_index_t psi;\n{\n  struct pidstat *ps;\n  ps_index_t *bucket;\n\n  ps = &bgpids.storage[psi];\n  if (ps->pid == NO_PID)\n    return;\n\n  if (ps->bucket_next != NO_PIDSTAT)\n    bgpids.storage[ps->bucket_next].bucket_prev = ps->bucket_prev;\n  if (ps->bucket_prev != NO_PIDSTAT)\n    bgpids.storage[ps->bucket_prev].bucket_next = ps->bucket_next;\n  else\n    {\n      bucket = pshash_getbucket (ps->pid);\n      *bucket = ps->bucket_next;\t \n    }\n\n   \n  ps->pid = NO_PID;\n  ps->bucket_next = ps->bucket_prev = NO_PIDSTAT;\n}\n\nstatic int\nbgp_delete (pid)\n     pid_t pid;\n{\n  ps_index_t psi, orig_psi;\n\n  if (bgpids.storage == 0 || bgpids.nalloc == 0 || bgpids.npid == 0)\n    return 0;\n\n   \n  for (orig_psi = psi = *(pshash_getbucket (pid)); psi != NO_PIDSTAT; psi = bgpids.storage[psi].bucket_next)\n    {\n      if (bgpids.storage[psi].pid == pid)\n\tbreak;\n      if (orig_psi == bgpids.storage[psi].bucket_next)\t \n\t{\n\t  internal_warning (_(\"bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next\"), psi);\n\t  return 0;\n\t}\n    }\n\n  if (psi == NO_PIDSTAT)\n    return 0;\t\t \n\n#if 0\n  itrace(\"bgp_delete: deleting %d\", pid);\n#endif\n\n  pshash_delindex (psi);\t \n\n  bgpids.npid--;\n  return 1;\n}\n\n \nstatic void\nbgp_clear ()\n{\n  if (bgpids.storage == 0 || bgpids.nalloc == 0)\n    return;\n\n  free (bgpids.storage);\n\n  bgpids.storage = 0;\n  bgpids.nalloc = 0;\n  bgpids.head = 0;\n\n  bgpids.npid = 0;\n}\n\n \nstatic int\nbgp_search (pid)\n     pid_t pid;\n{\n  ps_index_t psi, orig_psi;\n\n  if (bgpids.storage == 0 || bgpids.nalloc == 0 || bgpids.npid == 0)\n    return -1;\n\n   \n  for (orig_psi = psi = *(pshash_getbucket (pid)); psi != NO_PIDSTAT; psi = bgpids.storage[psi].bucket_next)\n    {\n      if (bgpids.storage[psi].pid == pid)\n\treturn (bgpids.storage[psi].status);\n      if (orig_psi == bgpids.storage[psi].bucket_next)\t \n\t{\n\t  internal_warning (_(\"bgp_search: LOOP: psi (%d) == storage[psi].bucket_next\"), psi);\n\t  return -1;\n\t}\n    }\n\n  return -1;\n}\n\n#if 0\nstatic void\nbgp_prune ()\n{\n  return;\n}\n#endif\n\n \nvoid\nsave_proc_status (pid, status)\n     pid_t pid;\n     int status;\n{\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  bgp_add (pid, status);\n  UNBLOCK_CHILD (oset);  \n}\n\n#if defined (PROCESS_SUBSTITUTION)\n \n\nstatic void\nprocsub_free (p)\n     PROCESS *p;\n{\n  FREE (p->command);\n  free (p);\n}\n    \nPROCESS *\nprocsub_add (p)\n     PROCESS *p;\n{\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  if (procsubs.head == 0)\n    {\n      procsubs.head = procsubs.end = p;\n      procsubs.nproc = 0;\n    }\n  else\n    {\n      procsubs.end->next = p;\n      procsubs.end = p;\n    }\n  procsubs.nproc++;\n  UNBLOCK_CHILD (oset);\n\n  return p;\n}\n\nPROCESS *\nprocsub_search (pid)\n     pid_t pid;\n{\n  PROCESS *p;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  for (p = procsubs.head; p; p = p->next)\n    if (p->pid == pid)\n      break;\n  UNBLOCK_CHILD (oset);\n\n  return p;\n}\n\nPROCESS *\nprocsub_delete (pid)\n     pid_t pid;\n{\n  PROCESS *p, *prev;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  for (p = prev = procsubs.head; p; prev = p, p = p->next)\n    if (p->pid == pid)\n      {\n\tprev->next = p->next;\n\tbreak;\n      }\n\n  if (p == 0)\n    {\n      UNBLOCK_CHILD (oset);\n      return p;\n    }\n\n  if (p == procsubs.head)\n    procsubs.head = procsubs.head->next;\n  else if (p == procsubs.end)\n    procsubs.end = prev;\n\n  procsubs.nproc--;\n  if (procsubs.nproc == 0)\n    procsubs.head = procsubs.end = 0;\n  else if (procsubs.nproc == 1)\t\t \n    procsubs.end = procsubs.head;\n\n   \n  bgp_add (p->pid, process_exit_status (p->status));\n  UNBLOCK_CHILD (oset);\n  return (p);  \n}\n\nint\nprocsub_waitpid (pid)\n     pid_t pid;\n{\n  PROCESS *p;\n  int r;\n\n  p = procsub_search (pid);\n  if (p == 0)\n    return -1;\n  if (p->running == PS_DONE)\n    return (p->status);\n  r = wait_for (p->pid, 0);\n  return (r);\t\t\t \n}\n\nvoid\nprocsub_waitall ()\n{\n  PROCESS *p;\n  int r;\n\n  for (p = procsubs.head; p; p = p->next)\n    {\n      if (p->running == PS_DONE)\n\tcontinue;\n      r = wait_for (p->pid, 0);\n    }\n}\n\nvoid\nprocsub_clear ()\n{\n  PROCESS *p, *ps;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n  \n  for (ps = procsubs.head; ps; )\n    {\n      p = ps;\n      ps = ps->next;\n      procsub_free (p);\n    }\n  procsubs.head = procsubs.end = 0;\n  procsubs.nproc = 0;        \n  UNBLOCK_CHILD (oset);\n}\n\n \nvoid\nprocsub_prune ()\n{\n  PROCESS *ohead, *oend, *ps, *p;\n  int onproc;\n\n  if (procsubs.nproc == 0)\n    return;\n\n  ohead = procsubs.head;\n  oend = procsubs.end;\n  onproc = procsubs.nproc;\n\n  procsubs.head = procsubs.end = 0;\n  procsubs.nproc = 0;\n\n  for (p = ohead; p; )\n    {\n      ps = p->next;\n      p->next = 0;\n      if (p->running == PS_DONE)\n\t{\n\t  bgp_add (p->pid, process_exit_status (p->status));\n\t  procsub_free (p);\n\t}\n      else\n\tprocsub_add (p);\n      p = ps;\n    }\n}\n#endif\n\n \nstatic void\nreset_job_indices ()\n{\n  int old;\n\n  if (jobs[js.j_firstj] == 0)\n    {\n      old = js.j_firstj++;\n      if (old >= js.j_jobslots)\n\told = js.j_jobslots - 1;\n      while (js.j_firstj != old)\n\t{\n\t  if (js.j_firstj >= js.j_jobslots)\n\t    js.j_firstj = 0;\n\t  if (jobs[js.j_firstj] || js.j_firstj == old)\t \n\t    break;\n\t  js.j_firstj++;\n\t}\n      if (js.j_firstj == old)\n\tjs.j_firstj = js.j_lastj = js.j_njobs = 0;\n    }\n  if (jobs[js.j_lastj] == 0)\n    {\n      old = js.j_lastj--;\n      if (old < 0)\n\told = 0;\n      while (js.j_lastj != old)\n\t{\n\t  if (js.j_lastj < 0)\n\t    js.j_lastj = js.j_jobslots - 1;\n\t  if (jobs[js.j_lastj] || js.j_lastj == old)\t \n\t    break;\n\t  js.j_lastj--;\n\t}\n      if (js.j_lastj == old)\n\tjs.j_firstj = js.j_lastj = js.j_njobs = 0;\n    }\n}\n      \n \nstatic void\ncleanup_dead_jobs ()\n{\n  register int i;\n  int os;\n  PROCESS *discard;\n\n  if (js.j_jobslots == 0 || jobs_list_frozen)\n    return;\n\n  QUEUE_SIGCHLD(os);\n\n   \n  for (i = 0; i < js.j_jobslots; i++)\n    {\n      if (i < js.j_firstj && jobs[i])\n\tINTERNAL_DEBUG ((\"cleanup_dead_jobs: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n      if (i > js.j_lastj && jobs[i])\n\tINTERNAL_DEBUG((\"cleanup_dead_jobs: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i))\n\tdelete_job (i, 0);\n    }\n\n#if defined (PROCESS_SUBSTITUTION)\n  procsub_prune ();\n  last_procsub_child = (PROCESS *)NULL;\n#endif\n\n#if defined (COPROCESS_SUPPORT)\n  coproc_reap ();\n#endif\n\n  UNQUEUE_SIGCHLD(os);\n}\n\nstatic int\nprocesses_in_job (job)\n     int job;\n{\n  int nproc;\n  register PROCESS *p;\n\n  nproc = 0;\n  p = jobs[job]->pipe;\n  do\n    {\n      p = p->next;\n      nproc++;\n    }\n  while (p != jobs[job]->pipe);\n\n  return nproc;\n}\n\nstatic void\ndelete_old_job (pid)\n     pid_t pid;\n{\n  PROCESS *p;\n  int job;\n\n  job = find_job (pid, 0, &p);\n  if (job != NO_JOB)\n    {\n      INTERNAL_DEBUG ((\"delete_old_job: found pid %d in job %d with state %d\", pid, job, jobs[job]->state));\n      if (JOBSTATE (job) == JDEAD)\n\tdelete_job (job, DEL_NOBGPID);\n      else\n\t{\n\t  internal_debug (_(\"forked pid %d appears in running job %d\"), pid, job+1);\n\t  if (p)\n\t    p->pid = 0;\n\t}\n    }\n}\n\n \nstatic void\nrealloc_jobs_list ()\n{\n  sigset_t set, oset;\n  int nsize, i, j, ncur, nprev;\n  JOB **nlist;\n\n  ncur = nprev = NO_JOB;\n  nsize = ((js.j_njobs + JOB_SLOTS - 1) / JOB_SLOTS);\n  nsize *= JOB_SLOTS;\n  i = js.j_njobs % JOB_SLOTS;\n  if (i == 0 || i > (JOB_SLOTS >> 1))\n    nsize += JOB_SLOTS;\n\n  BLOCK_CHILD (set, oset);\n  nlist = (js.j_jobslots == nsize) ? jobs : (JOB **) xmalloc (nsize * sizeof (JOB *));\n\n  js.c_reaped = js.j_ndead = 0;\n  for (i = j = 0; i < js.j_jobslots; i++)\n    if (jobs[i])\n      {\n\tif (i == js.j_current)\n\t  ncur = j;\n\tif (i == js.j_previous)\n\t  nprev = j;\n\tnlist[j++] = jobs[i];\n\tif (jobs[i]->state == JDEAD)\n\t  {\n\t    js.j_ndead++;\n\t    js.c_reaped += processes_in_job (i);\n\t  }\n      }\n\n#if 0\n  itrace (\"realloc_jobs_list: resize jobs list from %d to %d\", js.j_jobslots, nsize);\n  itrace (\"realloc_jobs_list: j_lastj changed from %d to %d\", js.j_lastj, (j > 0) ? j - 1 : 0);\n  itrace (\"realloc_jobs_list: j_njobs changed from %d to %d\", js.j_njobs, j);\n  itrace (\"realloc_jobs_list: js.j_ndead %d js.c_reaped %d\", js.j_ndead, js.c_reaped);\n#endif\n\n  js.j_firstj = 0;\n  js.j_lastj = (j > 0) ? j - 1 : 0;\n  js.j_njobs = j;\n  js.j_jobslots = nsize;\n\n   \n  for ( ; j < nsize; j++)\n    nlist[j] = (JOB *)NULL;\n\n  if (jobs != nlist)\n    {\n      free (jobs);\n      jobs = nlist;\n    }\n\n  if (ncur != NO_JOB)\n    js.j_current = ncur;\n  if (nprev != NO_JOB)\n    js.j_previous = nprev;\n\n   \n  if (js.j_current == NO_JOB || js.j_previous == NO_JOB || js.j_current > js.j_lastj || js.j_previous > js.j_lastj)\n    reset_current ();\n\n#if 0\n  itrace (\"realloc_jobs_list: reset js.j_current (%d) and js.j_previous (%d)\", js.j_current, js.j_previous);\n#endif\n\n  UNBLOCK_CHILD (oset);\n}\n\n \nstatic int\ncompact_jobs_list (flags)\n     int flags;\n{\n  if (js.j_jobslots == 0 || jobs_list_frozen)\n    return js.j_jobslots;\n\n  reap_dead_jobs ();\n  realloc_jobs_list ();\n\n#if 0\n  itrace(\"compact_jobs_list: returning %d\", (js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);\n#endif\n\n  return ((js.j_lastj || jobs[js.j_lastj]) ? js.j_lastj + 1 : 0);\n}\n\n \nvoid\ndelete_job (job_index, dflags)\n     int job_index, dflags;\n{\n  register JOB *temp;\n  PROCESS *proc;\n  int ndel;\n\n  if (js.j_jobslots == 0 || jobs_list_frozen)\n    return;\n\n  if ((dflags & DEL_WARNSTOPPED) && subshell_environment == 0 && STOPPED (job_index))\n    internal_warning (_(\"deleting stopped job %d with process group %ld\"), job_index+1, (long)jobs[job_index]->pgrp);\n  temp = jobs[job_index];\n  if (temp == 0)\n    return;\n\n  if ((dflags & DEL_NOBGPID) == 0 && (temp->flags & (J_ASYNC|J_FOREGROUND)) == J_ASYNC)\n    {\n      proc = find_last_proc (job_index, 0);\n      if (proc)\n\tbgp_add (proc->pid, process_exit_status (proc->status));\n    }\n\n  jobs[job_index] = (JOB *)NULL;\n  if (temp == js.j_lastmade)\n    js.j_lastmade = 0;\n  else if (temp == js.j_lastasync)\n    js.j_lastasync = 0;\n\n  free (temp->wd);\n  ndel = discard_pipeline (temp->pipe);\n\n  js.c_injobs -= ndel;\n  if (temp->state == JDEAD)\n    {\n       \n      js.c_reaped -= ndel;\t \n      js.j_ndead--;\n      if (js.c_reaped < 0)\n\t{\n\t  INTERNAL_DEBUG ((\"delete_job (%d pgrp %d): js.c_reaped (%d) < 0 ndel = %d js.j_ndead = %d\", job_index, temp->pgrp, js.c_reaped, ndel, js.j_ndead));\n\t  js.c_reaped = 0;\n\t}\n    }\n\n  if (temp->deferred)\n    dispose_command (temp->deferred);\n\n  free (temp);\n\n  js.j_njobs--;\n  if (js.j_njobs == 0)\n    js.j_firstj = js.j_lastj = 0;\n  else if (jobs[js.j_firstj] == 0 || jobs[js.j_lastj] == 0)\n    reset_job_indices ();\n\n  if (job_index == js.j_current || job_index == js.j_previous)\n    reset_current ();\n}\n\n \nvoid\nnohup_job (job_index)\n     int job_index;\n{\n  register JOB *temp;\n\n  if (js.j_jobslots == 0)\n    return;\n\n  if (temp = jobs[job_index])\n    temp->flags |= J_NOHUP;\n}\n\n \nint\ndiscard_pipeline (chain)\n     register PROCESS *chain;\n{\n  register PROCESS *this, *next;\n  int n;\n\n  this = chain;\n  n = 0;\n  do\n    {\n      next = this->next;\n      FREE (this->command);\n      free (this);\n      n++;\n      this = next;\n    }\n  while (this != chain);\n\n  return n;\n}\n\n \nstatic void\nadd_process (name, pid)\n     char *name;\n     pid_t pid;\n{\n  PROCESS *t, *p;\n\n#if defined (RECYCLES_PIDS)\n  int j;\n  p = find_process (pid, 0, &j);\n  if (p)\n    {\n      if (j == NO_JOB)\n\tinternal_debug (\"add_process: process %5ld (%s) in the_pipeline\", (long)p->pid, p->command);\n      if (PALIVE (p))\n\tinternal_warning (_(\"add_process: pid %5ld (%s) marked as still alive\"), (long)p->pid, p->command);\n      p->running = PS_RECYCLED;\t\t \n    }\n#endif\n\n  t = (PROCESS *)xmalloc (sizeof (PROCESS));\n  t->next = the_pipeline;\n  t->pid = pid;\n  WSTATUS (t->status) = 0;\n  t->running = PS_RUNNING;\n  t->command = name;\n  the_pipeline = t;\n\n  if (t->next == 0)\n    t->next = t;\n  else\n    {\n      p = t->next;\n      while (p->next != t->next)\n\tp = p->next;\n      p->next = t;\n    }\n}\n\n \nvoid\nappend_process (name, pid, status, jid)\n     char *name;\n     pid_t pid;\n     int status;\n     int jid;\n{\n  PROCESS *t, *p;\n\n  t = (PROCESS *)xmalloc (sizeof (PROCESS));\n  t->next = (PROCESS *)NULL;\n  t->pid = pid;\n   \n  t->status = (status & 0xff) << WEXITSTATUS_OFFSET;\n  t->running = PS_DONE;\n  t->command = name;\n\n  js.c_reaped++;\t \n\n  for (p = jobs[jid]->pipe; p->next != jobs[jid]->pipe; p = p->next)\n    ;\n  p->next = t;\n  t->next = jobs[jid]->pipe;\n}\n\n#if 0\n \nint\nrotate_the_pipeline ()\n{\n  PROCESS *p;\n\n  if (the_pipeline->next == the_pipeline)\n    return;\n  for (p = the_pipeline; p->next != the_pipeline; p = p->next)\n    ;\n  the_pipeline = p;\n}\n\n \nint\nreverse_the_pipeline ()\n{\n  PROCESS *p, *n;\n\n  if (the_pipeline->next == the_pipeline)\n    return;\n\n  for (p = the_pipeline; p->next != the_pipeline; p = p->next)\n    ;\n  p->next = (PROCESS *)NULL;\n\n  n = REVERSE_LIST (the_pipeline, PROCESS *);\n\n  the_pipeline = n;\n  for (p = the_pipeline; p->next; p = p->next)\n    ;\n  p->next = the_pipeline;\n}\n#endif\n\n \nstatic int\nmap_over_jobs (func, arg1, arg2)\n     sh_job_map_func_t *func;\n     int arg1, arg2;\n{\n  register int i;\n  int result;\n  sigset_t set, oset;\n\n  if (js.j_jobslots == 0)\n    return 0;\n\n  BLOCK_CHILD (set, oset);\n\n   \n  for (i = result = 0; i < js.j_jobslots; i++)\n    {\n      if (i < js.j_firstj && jobs[i])\n\tINTERNAL_DEBUG ((\"map_over_jobs: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n      if (i > js.j_lastj && jobs[i])\n\tINTERNAL_DEBUG ((\"map_over_jobs: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n      if (jobs[i])\n\t{\n\t  result = (*func)(jobs[i], arg1, arg2, i);\n\t  if (result)\n\t    break;\n\t}\n    }\n\n  UNBLOCK_CHILD (oset);\n\n  return (result);\n}\n\n \nvoid\nterminate_current_pipeline ()\n{\n  if (pipeline_pgrp && pipeline_pgrp != shell_pgrp)\n    {\n      killpg (pipeline_pgrp, SIGTERM);\n      killpg (pipeline_pgrp, SIGCONT);\n    }\n}\n\n \nvoid\nterminate_stopped_jobs ()\n{\n  register int i;\n\n   \n  for (i = 0; i < js.j_jobslots; i++)\n    {\n      if (jobs[i] && STOPPED (i))\n\t{\n\t  killpg (jobs[i]->pgrp, SIGTERM);\n\t  killpg (jobs[i]->pgrp, SIGCONT);\n\t}\n    }\n}\n\n \nvoid\nhangup_all_jobs ()\n{\n  register int i;\n\n   \n  for (i = 0; i < js.j_jobslots; i++)\n    {\n      if (jobs[i])\n\t{\n\t  if  (jobs[i]->flags & J_NOHUP)\n\t    continue;\n\t  killpg (jobs[i]->pgrp, SIGHUP);\n\t  if (STOPPED (i))\n\t    killpg (jobs[i]->pgrp, SIGCONT);\n\t}\n    }\n}\n\nvoid\nkill_current_pipeline ()\n{\n  stop_making_children ();\n  start_pipeline ();\n}\n\nstatic PROCESS *\nfind_pid_in_pipeline (pid, pipeline, alive_only)\n     pid_t pid;\n     PROCESS *pipeline;\n     int alive_only;\n{\n  PROCESS *p;\n\n  p = pipeline;\n  do\n    {\n       \n      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))\n\treturn (p);\n\n      p = p->next;\n    }\n  while (p != pipeline);\n  return ((PROCESS *)NULL);\n}\n\n \nstatic PROCESS *\nfind_pipeline (pid, alive_only, jobp)\n     pid_t pid;\n     int alive_only;\n     int *jobp;\t\t \n{\n  int job;\n  PROCESS *p;\n  struct pipeline_saver *save;\n\n   \n  p = (PROCESS *)NULL;\n  if (jobp)\n    *jobp = NO_JOB;\n\n  if (the_pipeline && (p = find_pid_in_pipeline (pid, the_pipeline, alive_only)))\n    return (p);\n\n   \n  for (save = saved_pipeline; save; save = save->next)\n    if (save->pipeline && (p = find_pid_in_pipeline (pid, save->pipeline, alive_only)))\n      return (p);\n\n#if defined (PROCESS_SUBSTITUTION)\n  if (procsubs.nproc > 0 && (p = procsub_search (pid)) && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))\n    return (p);\n#endif\n\n  job = find_job (pid, alive_only, &p);\n  if (jobp)\n    *jobp = job;\n  return (job == NO_JOB) ? (PROCESS *)NULL : jobs[job]->pipe;\n}\n\n \nstatic PROCESS *\nfind_process (pid, alive_only, jobp)\n     pid_t pid;\n     int alive_only;\n     int *jobp;\t\t \n{\n  PROCESS *p;\n\n  p = find_pipeline (pid, alive_only, jobp);\n  while (p && p->pid != pid)\n    p = p->next;\n  return p;\n}\n\n \nstatic int\nfind_job (pid, alive_only, procp)\n     pid_t pid;\n     int alive_only;\n     PROCESS **procp;\n{\n  register int i;\n  PROCESS *p;\n\n   \n  for (i = 0; i < js.j_jobslots; i++)\n    {\n      if (i < js.j_firstj && jobs[i])\n\tINTERNAL_DEBUG ((\"find_job: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n      if (i > js.j_lastj && jobs[i])\n\tINTERNAL_DEBUG ((\"find_job: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n      if (jobs[i])\n\t{\n\t  p = jobs[i]->pipe;\n\n\t  do\n\t    {\n\t      if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))\n\t\t{\n\t\t  if (procp)\n\t\t    *procp = p;\n\t\t  return (i);\n\t\t}\n\n\t      p = p->next;\n\t    }\n\t  while (p != jobs[i]->pipe);\n\t}\n    }\n\n  return (NO_JOB);\n}\n\n \nint\nget_job_by_pid (pid, block, procp)\n     pid_t pid;\n     int block;\n     PROCESS **procp;\n{\n  int job;\n  sigset_t set, oset;\n\n  if (block)\n    BLOCK_CHILD (set, oset);\n\n  job = find_job (pid, 0, procp);\n\n  if (block)\n    UNBLOCK_CHILD (oset);\n\n  return job;\n}\n\n \nvoid\ndescribe_pid (pid)\n     pid_t pid;\n{\n  int job;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n\n  job = find_job (pid, 0, NULL);\n\n  if (job != NO_JOB)\n    fprintf (stderr, \"[%d] %ld\\n\", job + 1, (long)pid);\n  else\n    programming_error (_(\"describe_pid: %ld: no such pid\"), (long)pid);\n\n  UNBLOCK_CHILD (oset);\n}\n\nstatic char *\nj_strsignal (s)\n     int s;\n{\n  char *x;\n\n  x = strsignal (s);\n  if (x == 0)\n    {\n      x = retcode_name_buffer;\n      snprintf (x, sizeof(retcode_name_buffer), _(\"Signal %d\"), s);\n    }\n  return x;\n}\n\nstatic char *\nprintable_job_status (j, p, format)\n     int j;\n     PROCESS *p;\n     int format;\n{\n  static char *temp;\n  int es;\n\n  temp = _(\"Done\");\n\n  if (STOPPED (j) && format == 0)\n    {\n      if (posixly_correct == 0 || p == 0 || (WIFSTOPPED (p->status) == 0))\n\ttemp = _(\"Stopped\");\n      else\n\t{\n\t  temp = retcode_name_buffer;\n\t  snprintf (temp, sizeof(retcode_name_buffer), _(\"Stopped(%s)\"), signal_name (WSTOPSIG (p->status)));\n\t}\n    }\n  else if (RUNNING (j))\n    temp = _(\"Running\");\n  else\n    {\n      if (WIFSTOPPED (p->status))\n\ttemp = j_strsignal (WSTOPSIG (p->status));\n      else if (WIFSIGNALED (p->status))\n\ttemp = j_strsignal (WTERMSIG (p->status));\n      else if (WIFEXITED (p->status))\n\t{\n\t  temp = retcode_name_buffer;\n\t  es = WEXITSTATUS (p->status);\n\t  if (es == 0)\n\t    {\n\t      strncpy (temp, _(\"Done\"), sizeof (retcode_name_buffer) - 1);\n\t      temp[sizeof (retcode_name_buffer) - 1] = '\\0';\n\t    }\n\t  else if (posixly_correct)\n\t    snprintf (temp, sizeof(retcode_name_buffer), _(\"Done(%d)\"), es);\n\t  else\n\t    snprintf (temp, sizeof(retcode_name_buffer), _(\"Exit %d\"), es);\n\t}\n      else\n\ttemp = _(\"Unknown status\");\n    }\n\n  return temp;\n}\n\n \n\n \nstatic void\nprint_pipeline (p, job_index, format, stream)\n     PROCESS *p;\n     int job_index, format;\n     FILE *stream;\n{\n  PROCESS *first, *last, *show;\n  int es, name_padding;\n  char *temp;\n\n  if (p == 0)\n    return;\n\n  first = last = p;\n  while (last->next != first)\n    last = last->next;\n\n  for (;;)\n    {\n      if (p != first)\n\tfprintf (stream, format ? \"     \" : \" |\");\n\n      if (format != JLIST_STANDARD)\n\tfprintf (stream, \"%5ld\", (long)p->pid);\n\n      fprintf (stream, \" \");\n\n      if (format > -1 && job_index >= 0)\n\t{\n\t  show = format ? p : last;\n\t  temp = printable_job_status (job_index, show, format);\n\n\t  if (p != first)\n\t    {\n\t      if (format)\n\t\t{\n\t\t  if (show->running == first->running &&\n\t\t      WSTATUS (show->status) == WSTATUS (first->status))\n\t\t    temp = \"\";\n\t\t}\n\t      else\n\t\ttemp = (char *)NULL;\n\t    }\n\n\t  if (temp)\n\t    {\n\t      fprintf (stream, \"%s\", temp);\n\n\t      es = STRLEN (temp);\n\t      if (es == 0)\n\t\tes = 2;\t \n\t      name_padding = LONGEST_SIGNAL_DESC - es;\n\n\t      fprintf (stream, \"%*s\", name_padding, \"\");\n\n\t      if ((WIFSTOPPED (show->status) == 0) &&\n\t\t  (WIFCONTINUED (show->status) == 0) &&\n\t\t  WIFCORED (show->status))\n\t\tfprintf (stream, _(\"(core dumped) \"));\n\t    }\n\t}\n\n      if (p != first && format)\n\tfprintf (stream, \"| \");\n\n      if (p->command)\n\tfprintf (stream, \"%s\", p->command);\n\n      if (p == last && job_index >= 0)\n\t{\n\t  temp = current_working_directory ();\n\n\t  if (RUNNING (job_index) && (IS_FOREGROUND (job_index) == 0))\n\t    fprintf (stream, \" &\");\n\n\t  if (strcmp (temp, jobs[job_index]->wd) != 0)\n\t    fprintf (stream,\n\t      _(\"  (wd: %s)\"), polite_directory_format (jobs[job_index]->wd));\n\t}\n\n      if (format || (p == last))\n\t{\n\t   \n\t  if (asynchronous_notification && interactive)\n\t    putc ('\\r', stream);\n\t  fprintf (stream, \"\\n\");\n\t}\n\n      if (p == last)\n\tbreak;\n      p = p->next;\n    }\n  fflush (stream);\n}\n\n \nstatic void\npretty_print_job (job_index, format, stream)\n     int job_index, format;\n     FILE *stream;\n{\n  register PROCESS *p;\n\n   \n  if (format == JLIST_PID_ONLY)\n    {\n      fprintf (stream, \"%ld\\n\", (long)jobs[job_index]->pipe->pid);\n      return;\n    }\n\n  if (format == JLIST_CHANGED_ONLY)\n    {\n      if (IS_NOTIFIED (job_index))\n\treturn;\n      format = JLIST_STANDARD;\n    }\n\n  if (format != JLIST_NONINTERACTIVE)\n    fprintf (stream, \"[%d]%c \", job_index + 1,\n\t      (job_index == js.j_current) ? '+':\n\t\t(job_index == js.j_previous) ? '-' : ' ');\n\n  if (format == JLIST_NONINTERACTIVE)\n    format = JLIST_LONG;\n\n  p = jobs[job_index]->pipe;\n\n  print_pipeline (p, job_index, format, stream);\n\n   \n  jobs[job_index]->flags |= J_NOTIFIED;\n}\n\nstatic int\nprint_job (job, format, state, job_index)\n     JOB *job;\n     int format, state, job_index;\n{\n  if (state == -1 || (JOB_STATE)state == job->state)\n    pretty_print_job (job_index, format, stdout);\n  return (0);\n}\n\nvoid\nlist_one_job (job, format, ignore, job_index)\n     JOB *job;\n     int format, ignore, job_index;\n{\n  pretty_print_job (job_index, format, stdout);\n  cleanup_dead_jobs ();\n}\n\nvoid\nlist_stopped_jobs (format)\n     int format;\n{\n  cleanup_dead_jobs ();\n  map_over_jobs (print_job, format, (int)JSTOPPED);\n}\n\nvoid\nlist_running_jobs (format)\n     int format;\n{\n  cleanup_dead_jobs ();\n  map_over_jobs (print_job, format, (int)JRUNNING);\n}\n\n \nvoid\nlist_all_jobs (format)\n     int format;\n{\n  cleanup_dead_jobs ();\n  map_over_jobs (print_job, format, -1);\n}\n\n \npid_t\nmake_child (command, flags)\n     char *command;\n     int flags;\n{\n  int async_p, forksleep;\n  sigset_t set, oset, termset, chldset, oset_copy;\n  pid_t pid;\n  SigHandler *oterm;\n\n  sigemptyset (&oset_copy);\n  sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &oset_copy);\n  sigaddset (&oset_copy, SIGTERM);\n\n   \n  sigemptyset (&set);\n  sigaddset (&set, SIGCHLD);\n  sigaddset (&set, SIGINT);\n  sigaddset (&set, SIGTERM);\n\n  sigemptyset (&oset);\n  sigprocmask (SIG_BLOCK, &set, &oset);\n\n   \n  if (interactive_shell)\n    oterm = set_signal_handler (SIGTERM, SIG_DFL);\n\n  making_children ();\n\n  async_p = (flags & FORK_ASYNC);\n  forksleep = 1;\n\n#if defined (BUFFERED_INPUT)\n   \n  if (default_buffered_input != -1 &&\n      (!async_p || default_buffered_input > 0))\n    sync_buffered_stream (default_buffered_input);\n#endif  \n\n   \n  while ((pid = fork ()) < 0 && errno == EAGAIN && forksleep < FORKSLEEP_MAX)\n    {\n       \n       \n      sigprocmask (SIG_SETMASK, &oset_copy, (sigset_t *)NULL);\n       \n      waitchld (-1, 0);\n\n      errno = EAGAIN;\t\t \n      sys_error (\"fork: retry\");\n\n      if (sleep (forksleep) != 0)\n\tbreak;\n      forksleep <<= 1;\n\n      if (interrupt_state)\n\tbreak;\n      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);\n    }\n\n  if (pid != 0)\n    if (interactive_shell)\n      set_signal_handler (SIGTERM, oterm);\n\n  if (pid < 0)\n    {\n      sys_error (\"fork\");\n\n       \n      terminate_current_pipeline ();\n\n       \n      if (the_pipeline)\n\tkill_current_pipeline ();\n\n      set_exit_status (EX_NOEXEC);\n      throw_to_top_level ();\t \n    }\n\n  if (pid == 0)\n    {\n       \n      pid_t mypid;\n\n      subshell_environment |= SUBSHELL_IGNTRAP;\n\n       \n      mypid = getpid ();\n#if defined (BUFFERED_INPUT)\n       \n      unset_bash_input (0);\n#endif  \n\n      CLRINTERRUPT;\t \n\n       \n      restore_sigmask ();\n  \n      if (job_control)\n\t{\n\t   \n\n\t  if (pipeline_pgrp == 0)\t \n\t    pipeline_pgrp = mypid;\n\n\t   \n\t  if (pipeline_pgrp == shell_pgrp)\n\t    ignore_tty_job_signals ();\n\t  else\n\t    default_tty_job_signals ();\n\n\t   \n\t   \n\t  if (setpgid (mypid, pipeline_pgrp) < 0)\n\t    sys_error (_(\"child setpgid (%ld to %ld)\"), (long)mypid, (long)pipeline_pgrp);\n\n\t   \n\t  if ((flags & FORK_NOTERM) == 0 && async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&(SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0) && running_in_background == 0)\n\t    give_terminal_to (pipeline_pgrp, 0);\n\n#if defined (PGRP_PIPE)\n\t  if (pipeline_pgrp == mypid)\n\t    pipe_read (pgrp_pipe);\n#endif\n\t}\n      else\t\t\t \n\t{\n\t  if (pipeline_pgrp == 0)\n\t    pipeline_pgrp = shell_pgrp;\n\n\t   \n\n\t  default_tty_job_signals ();\n\t}\n\n#if defined (PGRP_PIPE)\n       \n      sh_closepipe (pgrp_pipe);\n#endif  \n\n       \n\n#if defined (RECYCLES_PIDS)\n      if (last_asynchronous_pid == mypid)\n\t \n\tlast_asynchronous_pid = 1;\n#endif\n    }\n  else\n    {\n       \n\n      if (job_control)\n\t{\n\t  if (pipeline_pgrp == 0)\n\t    {\n\t      pipeline_pgrp = pid;\n\t       \n\t       \n\t    }\n\t   \n\t  setpgid (pid, pipeline_pgrp);\n\t}\n      else\n\t{\n\t  if (pipeline_pgrp == 0)\n\t    pipeline_pgrp = shell_pgrp;\n\t}\n\n       \n      add_process (command, pid);\n\n      if (async_p)\n\tlast_asynchronous_pid = pid;\n#if defined (RECYCLES_PIDS)\n      else if (last_asynchronous_pid == pid)\n\t \n\tlast_asynchronous_pid = 1;\n#endif\n\n       \n      delete_old_job (pid);\n\n       \n      bgp_delete (pid);\t\t \n\n      last_made_pid = pid;\n\n       \n      js.c_totforked++;\n      js.c_living++;\n\n       \n      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);\n    }\n\n  return (pid);\n}\n\n \nvoid\nignore_tty_job_signals ()\n{\n  set_signal_handler (SIGTSTP, SIG_IGN);\n  set_signal_handler (SIGTTIN, SIG_IGN);\n  set_signal_handler (SIGTTOU, SIG_IGN);\n}\n\n \nvoid\ndefault_tty_job_signals ()\n{\n  if (signal_is_trapped (SIGTSTP) == 0 && signal_is_hard_ignored (SIGTSTP))\n    set_signal_handler (SIGTSTP, SIG_IGN);\n  else\n    set_signal_handler (SIGTSTP, SIG_DFL);\n\n  if (signal_is_trapped (SIGTTIN) == 0 && signal_is_hard_ignored (SIGTTIN))\n    set_signal_handler (SIGTTIN, SIG_IGN);\n  else\n    set_signal_handler (SIGTTIN, SIG_DFL);\n\n  if (signal_is_trapped (SIGTTOU) == 0 && signal_is_hard_ignored (SIGTTOU))\n    set_signal_handler (SIGTTOU, SIG_IGN);\n  else\n    set_signal_handler (SIGTTOU, SIG_DFL);\n}\n\n \nvoid\nget_original_tty_job_signals ()\n{\n  static int fetched = 0;\n\n  if (fetched == 0)\n    {\n      if (interactive_shell)\n\t{\n\t  set_original_signal (SIGTSTP, SIG_DFL);\n\t  set_original_signal (SIGTTIN, SIG_DFL);\n\t  set_original_signal (SIGTTOU, SIG_DFL);\n\t}\n      else\n\t{\n\t  get_original_signal (SIGTSTP);\n\t  get_original_signal (SIGTTIN);\n\t  get_original_signal (SIGTTOU);\n\t}\n      fetched = 1;\n    }\n}\n\n \n\nstatic TTYSTRUCT shell_tty_info;\n\n#if defined (NEW_TTY_DRIVER)\nstatic struct tchars shell_tchars;\nstatic struct ltchars shell_ltchars;\n#endif  \n\n#if defined (NEW_TTY_DRIVER) && defined (DRAIN_OUTPUT)\n \n\nstatic int ttspeeds[] =\n{\n  0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,\n  1800, 2400, 4800, 9600, 19200, 38400\n};\n\nstatic void\ndraino (fd, ospeed)\n     int fd, ospeed;\n{\n  register int delay = ttspeeds[ospeed];\n  int n;\n\n  if (!delay)\n    return;\n\n  while ((ioctl (fd, TIOCOUTQ, &n) == 0) && n)\n    {\n      if (n > (delay / 100))\n\t{\n\t  struct timeval tv;\n\n\t  n *= 10;\t\t \n\t  tv.tv_sec = n / delay;\n\t  tv.tv_usec = ((n % delay) * 1000000) / delay;\n\t  select (fd, (fd_set *)0, (fd_set *)0, (fd_set *)0, &tv);\n\t}\n      else\n\tbreak;\n    }\n}\n#endif  \n\n \n#define input_tty() (shell_tty != -1) ? shell_tty : fileno (stderr)\n\n \nint\nget_tty_state ()\n{\n  int tty;\n\n  tty = input_tty ();\n  if (tty != -1)\n    {\n#if defined (NEW_TTY_DRIVER)\n      ioctl (tty, TIOCGETP, &shell_tty_info);\n      ioctl (tty, TIOCGETC, &shell_tchars);\n      ioctl (tty, TIOCGLTC, &shell_ltchars);\n#endif  \n\n#if defined (TERMIO_TTY_DRIVER)\n      ioctl (tty, TCGETA, &shell_tty_info);\n#endif  \n\n#if defined (TERMIOS_TTY_DRIVER)\n      if (tcgetattr (tty, &shell_tty_info) < 0)\n\t{\n#if 0\n\t   \n\t  if (interactive)\n\t    sys_error (\"[%ld: %d (%d)] tcgetattr\", (long)getpid (), shell_level, tty);\n#endif\n\t  return -1;\n\t}\n#endif  \n      if (check_window_size)\n\tget_new_window_size (0, (int *)0, (int *)0);\n    }\n  return 0;\n}\n\n \nint\nset_tty_state ()\n{\n  int tty;\n\n  tty = input_tty ();\n  if (tty != -1)\n    {\n#if defined (NEW_TTY_DRIVER)\n#  if defined (DRAIN_OUTPUT)\n      draino (tty, shell_tty_info.sg_ospeed);\n#  endif  \n      ioctl (tty, TIOCSETN, &shell_tty_info);\n      ioctl (tty, TIOCSETC, &shell_tchars);\n      ioctl (tty, TIOCSLTC, &shell_ltchars);\n#endif  \n\n#if defined (TERMIO_TTY_DRIVER)\n      ioctl (tty, TCSETAW, &shell_tty_info);\n#endif  \n\n#if defined (TERMIOS_TTY_DRIVER)\n      if (tcsetattr (tty, TCSADRAIN, &shell_tty_info) < 0)\n\t{\n\t   \n\t  if (interactive)\n\t    sys_error (\"[%ld: %d (%d)] tcsetattr\", (long)getpid (), shell_level, tty);\n\t  return -1;\n\t}\n#endif  \n    }\n  return 0;\n}\n\n \nstatic PROCESS *\nfind_last_proc (job, block)\n     int job;\n     int block;\n{\n  register PROCESS *p;\n  sigset_t set, oset;\n\n  if (block)\n    BLOCK_CHILD (set, oset);\n\n  p = jobs[job]->pipe;\n  while (p && p->next != jobs[job]->pipe)\n    p = p->next;\n\n  if (block)\n    UNBLOCK_CHILD (oset);\n\n  return (p);\n}\n\nstatic pid_t\nfind_last_pid (job, block)\n     int job;\n     int block;\n{\n  PROCESS *p;\n\n  p = find_last_proc (job, block);\n   \n  return p->pid;\n}     \n\n \n\nint\nwait_for_single_pid (pid, flags)\n     pid_t pid;\n     int flags;\n{\n  register PROCESS *child;\n  sigset_t set, oset;\n  int r, job, alive;\n\n  BLOCK_CHILD (set, oset);\n  child = find_pipeline (pid, 0, (int *)NULL);\n  UNBLOCK_CHILD (oset);\n\n  if (child == 0)\n    {\n      r = bgp_search (pid);\n      if (r >= 0)\n\treturn r;\n    }\n\n  if (child == 0)\n    {\n      if (flags & JWAIT_PERROR)\n\tinternal_error (_(\"wait: pid %ld is not a child of this shell\"), (long)pid);\n      return (257);\n    }\n\n  alive = 0;\n  do\n    {\n      r = wait_for (pid, 0);\n      if ((flags & JWAIT_FORCE) == 0)\n\tbreak;\n\n      BLOCK_CHILD (set, oset);\n      alive = PALIVE (child);\n      UNBLOCK_CHILD (oset);\n    }\n  while (alive);\n\n   \n  BLOCK_CHILD (set, oset);\n  job = find_job (pid, 0, NULL);\n  if (job != NO_JOB && jobs[job] && DEADJOB (job))\n    jobs[job]->flags |= J_NOTIFIED;\n  UNBLOCK_CHILD (oset);\n\n   \n  if (posixly_correct)\n    {\n      cleanup_dead_jobs ();\n      bgp_delete (pid);\n    }\n\n   \n  CHECK_WAIT_INTR;\n\n  return r;\n}\n\n \nint\nwait_for_background_pids (ps)\n     struct procstat *ps;\n{\n  register int i, r;\n  int any_stopped, check_async, njobs;\n  sigset_t set, oset;\n  pid_t pid;\n\n  for (njobs = any_stopped = 0, check_async = 1;;)\n    {\n      BLOCK_CHILD (set, oset);\n\n       \n       \n      for (i = 0; i < js.j_jobslots; i++)\n\t{\n\t  if (i < js.j_firstj && jobs[i])\n\t    INTERNAL_DEBUG ((\"wait_for_background_pids: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n\t  if (i > js.j_lastj && jobs[i])\n\t    INTERNAL_DEBUG ((\"wait_for_background_pids: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n\t  if (jobs[i] && STOPPED (i))\n\t    {\n\t      builtin_warning (\"job %d[%d] stopped\", i+1, find_last_pid (i, 0));\n\t      any_stopped = 1;\n\t    }\n\n\t  if (jobs[i] && RUNNING (i) && IS_FOREGROUND (i) == 0)\n\t    break;\n\t}\n      if (i == js.j_jobslots)\n\t{\n\t  UNBLOCK_CHILD (oset);\n\t  break;\n\t}\n\n       \n      pid = find_last_pid (i, 0);\n      UNBLOCK_CHILD (oset);\n      QUIT;\n      errno = 0;\t\t \n      r = wait_for_single_pid (pid, JWAIT_PERROR);\n      if (ps)\n\t{\n\t  ps->pid = pid;\n\t  ps->status = (r < 0 || r > 256) ? 127 : r;\n\t}\n      if (r == -1 && errno == ECHILD)\n\t{\n\t   \n\t  check_async = 0;\n\t  mark_all_jobs_as_dead ();\n\t}\n      njobs++;\n    }\n\n#if defined (PROCESS_SUBSTITUTION)\n  procsub_waitall ();\n#endif\n      \n   \n  mark_dead_jobs_as_notified (1);\n  cleanup_dead_jobs ();\n  bgp_clear ();\n\n  return njobs;\n}\n\n \n#define INVALID_SIGNAL_HANDLER (SigHandler *)wait_for_background_pids\nstatic SigHandler *old_sigint_handler = INVALID_SIGNAL_HANDLER;\n\nstatic int wait_sigint_received;\nstatic int child_caught_sigint;\n\nint waiting_for_child;\n\n \nvoid\nwait_sigint_cleanup ()\n{\n  queue_sigchld = 0;\n  waiting_for_child = 0;\n  restore_sigint_handler ();\n}\n\nstatic void\nrestore_sigint_handler ()\n{\n  if (old_sigint_handler != INVALID_SIGNAL_HANDLER)\n    {\n      set_signal_handler (SIGINT, old_sigint_handler);\n      old_sigint_handler = INVALID_SIGNAL_HANDLER;\n      waiting_for_child = 0;\n    }\n}\n\n \nstatic sighandler\nwait_sigint_handler (sig)\n     int sig;\n{\n  SigHandler *sigint_handler;\n\n  if (this_shell_builtin && this_shell_builtin == wait_builtin)\n    {\n      set_exit_status (128+SIGINT);\n      restore_sigint_handler ();\n       \n      if (this_shell_builtin && this_shell_builtin == wait_builtin &&\n\t  signal_is_trapped (SIGINT) &&\n\t  ((sigint_handler = trap_to_sighandler (SIGINT)) == trap_handler))\n\t{\n\t  trap_handler (SIGINT);\t \n\t  wait_signal_received = SIGINT;\n\t  if (wait_intr_flag)\n\t    sh_longjmp (wait_intr_buf, 1);\n\t  else\n\t     \n\t    SIGRETURN (0);\n\t}\n      else  \n\tkill (getpid (), SIGINT);\n    }\n\n   \n  if (waiting_for_child)\n    wait_sigint_received = 1;\n  else\n    {\n      set_exit_status (128+SIGINT);\n      restore_sigint_handler ();\n      kill (getpid (), SIGINT);\n    }\n\n   \n  SIGRETURN (0);\n}\n\nstatic int\nprocess_exit_signal (status)\n     WAIT status;\n{\n  return (WIFSIGNALED (status) ? WTERMSIG (status) : 0);\n}\n\nstatic int\nprocess_exit_status (status)\n     WAIT status;\n{\n  if (WIFSIGNALED (status))\n    return (128 + WTERMSIG (status));\n  else if (WIFSTOPPED (status) == 0)\n    return (WEXITSTATUS (status));\n  else\n    return (EXECUTION_SUCCESS);\n}\n\nstatic WAIT\njob_signal_status (job)\n     int job;\n{\n  register PROCESS *p;\n  WAIT s;\n\n  p = jobs[job]->pipe;\n  do\n    {\n      s = p->status;\n      if (WIFSIGNALED(s) || WIFSTOPPED(s))\n\tbreak;\n      p = p->next;\n    }\n  while (p != jobs[job]->pipe);\n\n  return s;\n}\n  \n \nstatic WAIT\nraw_job_exit_status (job)\n     int job;\n{\n  register PROCESS *p;\n  int fail;\n  WAIT ret;\n\n  if (jobs[job]->flags & J_PIPEFAIL)\n    {\n      fail = 0;\n      p = jobs[job]->pipe;\n      do\n\t{\n\t  if (WSTATUS (p->status) != EXECUTION_SUCCESS)\n\t    fail = WSTATUS(p->status);\n\t  p = p->next;\n\t}\n      while (p != jobs[job]->pipe);\n      WSTATUS (ret) = fail;\n      return ret;\n    }\n\n  for (p = jobs[job]->pipe; p->next != jobs[job]->pipe; p = p->next)\n    ;\n  return (p->status);\n}\n\n \nint\njob_exit_status (job)\n     int job;\n{\n  return (process_exit_status (raw_job_exit_status (job)));\n}\n\nint\njob_exit_signal (job)\n     int job;\n{\n  return (process_exit_signal (raw_job_exit_status (job)));\n}\n\n#define FIND_CHILD(pid, child) \\\n  do \\\n    { \\\n      child = find_pipeline (pid, 0, (int *)NULL); \\\n      if (child == 0) \\\n\t{ \\\n\t  give_terminal_to (shell_pgrp, 0); \\\n\t  UNBLOCK_CHILD (oset); \\\n\t  internal_error (_(\"wait_for: No record of process %ld\"), (long)pid); \\\n\t  restore_sigint_handler (); \\\n\t  return (termination_state = 127); \\\n\t} \\\n    } \\\n  while (0)\n\n \nint\nwait_for (pid, flags)\n     pid_t pid;\n     int flags;\n{\n  int job, termination_state, r;\n  WAIT s;\n  register PROCESS *child;\n  sigset_t set, oset;\n\n   \n  child = 0;\n  BLOCK_CHILD (set, oset);\n\n   \n\n   \n  wait_sigint_received = child_caught_sigint = 0;\n  if (job_control == 0 || (subshell_environment&SUBSHELL_COMSUB))\n    {\n      SigHandler *temp_sigint_handler;\n\n      temp_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);\n      if (temp_sigint_handler == wait_sigint_handler)\n\tinternal_debug (\"wait_for: recursively setting old_sigint_handler to wait_sigint_handler: running_trap = %d\", running_trap);\n      else\n\told_sigint_handler = temp_sigint_handler;\n      waiting_for_child = 0;\n      if (old_sigint_handler == SIG_IGN)\n\tset_signal_handler (SIGINT, old_sigint_handler);\n    }\n\n  termination_state = last_command_exit_value;\n\n  if (interactive && job_control == 0)\n    QUIT;\n   \n  CHECK_TERMSIG;\n\n   \n  CHECK_WAIT_INTR;\n\n   \n\n  job = NO_JOB;\n  do\n    {\n      if (pid != ANY_PID)\n\tFIND_CHILD (pid, child);\n\n       \n      if (job == NO_JOB && pid != ANY_PID)\t \n\tjob = find_job (pid, 0, NULL);\n\n       \n\n      if (pid == ANY_PID || PRUNNING(child) || (job != NO_JOB && RUNNING (job)))\n\t{\n\t  int old_waiting;\n\n\t  queue_sigchld = 1;\n\t  old_waiting = waiting_for_child;\n\t  waiting_for_child = 1;\n\t   \n\t  CHECK_WAIT_INTR;\n\t  r = waitchld (pid, 1);\t \n\t  waiting_for_child = old_waiting;\n#if 0\nitrace(\"wait_for: blocking wait for %d returns %d child = %p\", (int)pid, r, child);\n#endif\n\t  queue_sigchld = 0;\n\t  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)\n\t    {\n\t      termination_state = -1;\n\t       \n\t      restore_sigint_handler ();\n\t      goto wait_for_return;\n\t    }\n\n\t   \n\t  if (r == -1 && errno == ECHILD)\n\t    {\n\t      if (child)\n\t\t{\n\t\t  child->running = PS_DONE;\n\t\t  WSTATUS (child->status) = 0;\t \n\t\t}\n\t      js.c_living = 0;\t\t \n\t      if (job != NO_JOB)\n\t\t{\n\t\t  jobs[job]->state = JDEAD;\n\t\t  js.c_reaped++;\n\t\t  js.j_ndead++;\n\t\t}\n\t      if (pid == ANY_PID)\n\t\t{\n\t\t  termination_state = -1;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n       \n      if (interactive && job_control == 0)\n\tQUIT;\n       \n      CHECK_TERMSIG;\n\n       \n      CHECK_WAIT_INTR;\n\n      if (pid == ANY_PID)\n\t{\n\t   \n\t  restore_sigint_handler ();\n\t  goto wait_for_return;\n\t}\n    }\n  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));\n\n   \n  restore_sigint_handler ();\n\n   \n  termination_state = (job != NO_JOB) ? job_exit_status (job)\n\t\t\t\t      : (child ? process_exit_status (child->status) : EXECUTION_SUCCESS);\n  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)\n\t\t\t\t\t     : (child ? process_exit_signal (child->status) : 0);\n\n   \n  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || (child && WIFSTOPPED (child->status)))\n    termination_state = 128 + WSTOPSIG (child->status);\n\n  if (job == NO_JOB || IS_JOBCONTROL (job))\n    {\n       \n#if 0\nif (job == NO_JOB)\n  itrace(\"wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)\", (long)shell_pgrp);\n#endif\n       \n      if ((flags & JWAIT_NOTERM) == 0 && running_in_background == 0 &&\n\t  (job == NO_JOB || IS_ASYNC (job) == 0 || IS_FOREGROUND (job)) &&\n\t  (subshell_environment & (SUBSHELL_ASYNC|SUBSHELL_PIPE)) == 0)\n\tgive_terminal_to (shell_pgrp, 0);\n    }\n\n   \n  if (job != NO_JOB)\n    {\n      if (interactive_shell && subshell_environment == 0)\n\t{\n\t   \n\t  s = job_signal_status (job);\n\n\t  if (WIFSIGNALED (s) || WIFSTOPPED (s))\n\t    {\n\t      set_tty_state ();\n\n\t       \n\t      if (check_window_size && (job == js.j_current || IS_FOREGROUND (job)))\n\t\tget_new_window_size (0, (int *)0, (int *)0);\n\t    }\n\t  else\n#if defined (READLINE)\n\t     \n\t    if (RL_ISSTATE (RL_STATE_COMPLETING|RL_STATE_DISPATCHING|RL_STATE_TERMPREPPED) == 0)\n#endif\n\t    get_tty_state ();\n\n\t   \n\t  if (job_control && IS_JOBCONTROL (job) && IS_FOREGROUND (job) &&\n\t\tWIFSIGNALED (s) && WTERMSIG (s) == SIGINT)\n\t    {\n\t       \n\t      if (signal_is_trapped (SIGINT) == 0 && (loop_level || (shell_compatibility_level > 32 && executing_list)))\n\t\tADDINTERRUPT;\n\t       \n\t      else if (signal_is_trapped (SIGINT) && loop_level)\n\t\tADDINTERRUPT;\n\t       \n\t      else if (interactive_shell && signal_is_trapped (SIGINT) == 0 && sourcelevel)\n\t\tADDINTERRUPT;\n\t      else\n\t\t{\n\t\t  putchar ('\\n');\n\t\t  fflush (stdout);\n\t\t}\n\t    }\n\t}\n      else if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PIPE)) && wait_sigint_received)\n\t{\n\t   \n\t  if (child_caught_sigint == 0 && signal_is_trapped (SIGINT) == 0)\n\t    {\n\t      UNBLOCK_CHILD (oset);\n\t      old_sigint_handler = set_signal_handler (SIGINT, SIG_DFL);\n\t      if (old_sigint_handler == SIG_IGN)\n\t\trestore_sigint_handler ();\n\t      else\n\t\tkill (getpid (), SIGINT);\n\t    }\n\t}\n      else if (interactive_shell == 0 && subshell_environment == 0 && IS_FOREGROUND (job))\n\t{\n\t  s = job_signal_status (job);\n\n\t   \n\t  if (job_control && IS_JOBCONTROL (job) && WIFSIGNALED (s) && WTERMSIG (s) == SIGINT)\n\t    {\n\t      ADDINTERRUPT;\t \n\t    }\n\n\t  if (check_window_size)\n\t    get_new_window_size (0, (int *)0, (int *)0);\n\t}\n\n       \n      if (DEADJOB (job) && IS_FOREGROUND (job)  )\n\tsetjstatus (job);\n\n       \n      notify_and_cleanup ();\n    }\n\nwait_for_return:\n\n  UNBLOCK_CHILD (oset);\n\n  return (termination_state);\n}\n\n \nint\nwait_for_job (job, flags, ps)\n     int job, flags;\n     struct procstat *ps;\n{\n  pid_t pid;\n  int r, state;\n  sigset_t set, oset;\n\n  BLOCK_CHILD(set, oset);\n  state = JOBSTATE (job);\n  if (state == JSTOPPED)\n    internal_warning (_(\"wait_for_job: job %d is stopped\"), job+1);\n\n  pid = find_last_pid (job, 0);\n  UNBLOCK_CHILD(oset);\n\n  do\n    {\n      r = wait_for (pid, 0);\n      if (r == -1 && errno == ECHILD)\n\tmark_all_jobs_as_dead ();\n\n      CHECK_WAIT_INTR;\n\n      if ((flags & JWAIT_FORCE) == 0)\n\tbreak;\n\n      BLOCK_CHILD (set, oset);\n      state = (job != NO_JOB && jobs[job]) ? JOBSTATE (job) : JDEAD;\n      UNBLOCK_CHILD (oset);\n    }\n  while (state != JDEAD);\n\n   \n  BLOCK_CHILD (set, oset);\n  if (job != NO_JOB && jobs[job] && DEADJOB (job))\n    jobs[job]->flags |= J_NOTIFIED;\n  UNBLOCK_CHILD (oset);\n\n  if (ps)\n    {\n      ps->pid = pid;\n      ps->status = (r < 0) ? 127 : r;\n    }\n  return r;\n}\n\n \nint\nwait_for_any_job (flags, ps)\n     int flags;\n     struct procstat *ps;\n{\n  pid_t pid;\n  int i, r;\n  sigset_t set, oset;\n\n  if (jobs_list_frozen)\n    return -1;\n\n   \n  BLOCK_CHILD (set, oset);\n  for (i = 0; i < js.j_jobslots; i++)\n    {\n      if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)\n\tcontinue;\t\t \n      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i) == 0)\n\t{\nreturn_job:\n\t  r = job_exit_status (i);\n\t  pid = find_last_pid (i, 0);\n\t  if (ps)\n\t    {\n\t      ps->pid = pid;\n\t      ps->status = r;\n\t    }\n\t  notify_of_job_status ();\t\t \n\t  delete_job (i, 0);\n#if defined (COPROCESS_SUPPORT)\n\t  coproc_reap ();\n#endif\n\t  UNBLOCK_CHILD (oset);\n\t  return r;\n\t}\n    }\n  UNBLOCK_CHILD (oset);\n\n   \n  for (;;)\n    {\n       \n      BLOCK_CHILD (set, oset);\n      for (i = 0; i < js.j_jobslots; i++)\n\tif (jobs[i] && RUNNING (i) && IS_FOREGROUND (i) == 0)\n\t  break;\n      if (i == js.j_jobslots)\n\t{\n\t  UNBLOCK_CHILD (oset);\n\t  return -1;\n\t}\n\n      UNBLOCK_CHILD (oset);\n\n      QUIT;\n      CHECK_TERMSIG;\n      CHECK_WAIT_INTR;\n\n      errno = 0;\n      r = wait_for (ANY_PID, 0);\t \n      if (r == -1 && errno == ECHILD)\n\tmark_all_jobs_as_dead ();\n\t\n       \n      BLOCK_CHILD (set, oset);\n      for (i = 0; i < js.j_jobslots; i++)\n\t{\n\t  if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)\n\t    continue;\t\t \n\t  if (jobs[i] && DEADJOB (i))\n\t    goto return_job;\n\t}\n      UNBLOCK_CHILD (oset);\n    }\n\n  return -1;\n}\n\n \nvoid\nnotify_and_cleanup ()\n{\n  if (jobs_list_frozen)\n    return;\n\n  if (interactive || interactive_shell == 0 || sourcelevel)\n    notify_of_job_status ();\n\n  cleanup_dead_jobs ();\n}\n\n \nvoid\nreap_dead_jobs ()\n{\n  mark_dead_jobs_as_notified (0);\n  cleanup_dead_jobs ();\n}\n\n \nstatic int\nmost_recent_job_in_state (job, state)\n     int job;\n     JOB_STATE state;\n{\n  register int i, result;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n\n  for (result = NO_JOB, i = job - 1; i >= 0; i--)\n    {\n      if (jobs[i] && (JOBSTATE (i) == state))\n\t{\n\t  result = i;\n\t  break;\n\t}\n    }\n\n  UNBLOCK_CHILD (oset);\n\n  return (result);\n}\n\n \nstatic int\njob_last_stopped (job)\n     int job;\n{\n  return (most_recent_job_in_state (job, JSTOPPED));\n}\n\n \nstatic int\njob_last_running (job)\n     int job;\n{\n  return (most_recent_job_in_state (job, JRUNNING));\n}\n\n \nstatic void\nset_current_job (job)\n     int job;\n{\n  int candidate;\n\n  if (js.j_current != job)\n    {\n      js.j_previous = js.j_current;\n      js.j_current = job;\n    }\n\n   \n  if (js.j_previous != js.j_current &&\n      js.j_previous != NO_JOB &&\n      jobs[js.j_previous] &&\n      STOPPED (js.j_previous))\n    return;\n\n   \n  candidate = NO_JOB;\n  if (STOPPED (js.j_current))\n    {\n      candidate = job_last_stopped (js.j_current);\n\n      if (candidate != NO_JOB)\n\t{\n\t  js.j_previous = candidate;\n\t  return;\n\t}\n    }\n\n   \n\n  candidate = RUNNING (js.j_current) ? job_last_running (js.j_current)\n\t\t\t\t    : job_last_running (js.j_jobslots);\n\n  if (candidate != NO_JOB)\n    {\n      js.j_previous = candidate;\n      return;\n    }\n\n   \n  js.j_previous = js.j_current;\n}\n\n \n\n \n\nstatic void\nreset_current ()\n{\n  int candidate;\n\n  if (js.j_jobslots && js.j_current != NO_JOB && jobs[js.j_current] && STOPPED (js.j_current))\n    candidate = js.j_current;\n  else\n    {\n      candidate = NO_JOB;\n\n       \n      if (js.j_previous != NO_JOB && jobs[js.j_previous] && STOPPED (js.j_previous))\n\tcandidate = js.j_previous;\n\n       \n      if (candidate == NO_JOB)\n\tcandidate = job_last_stopped (js.j_jobslots);\n\n       \n      if (candidate == NO_JOB)\n\tcandidate = job_last_running (js.j_jobslots);\n    }\n\n   \n  if (candidate != NO_JOB)\n    set_current_job (candidate);\n  else\n    js.j_current = js.j_previous = NO_JOB;\n}\n\n \nstatic void\nset_job_running (job)\n     int job;\n{\n  register PROCESS *p;\n\n   \n  p = jobs[job]->pipe;\n\n  do\n    {\n      if (WIFSTOPPED (p->status))\n\tp->running = PS_RUNNING;\t \n      p = p->next;\n    }\n  while (p != jobs[job]->pipe);\n\n   \n  JOBSTATE (job) = JRUNNING;\n}\n\n \nint\nstart_job (job, foreground)\n     int job, foreground;\n{\n  register PROCESS *p;\n  int already_running;\n  sigset_t set, oset;\n  char *wd, *s;\n  static TTYSTRUCT save_stty;\n\n  BLOCK_CHILD (set, oset);\n\n  if ((subshell_environment & SUBSHELL_COMSUB) && (pipeline_pgrp == shell_pgrp))\n    {\n      internal_error (_(\"%s: no current jobs\"), this_command_name);\n      UNBLOCK_CHILD (oset);\n      return (-1);\n    }\n\n  if (DEADJOB (job))\n    {\n      internal_error (_(\"%s: job has terminated\"), this_command_name);\n      UNBLOCK_CHILD (oset);\n      return (-1);\n    }\n\n  already_running = RUNNING (job);\n\n  if (foreground == 0 && already_running)\n    {\n      internal_error (_(\"%s: job %d already in background\"), this_command_name, job + 1);\n      UNBLOCK_CHILD (oset);\n      return (0);\t\t \n    }\n\n  wd = current_working_directory ();\n\n   \n  jobs[job]->flags &= ~J_NOTIFIED;\n\n  if (foreground)\n    {\n      set_current_job (job);\n      jobs[job]->flags |= J_FOREGROUND;\n    }\n\n   \n  p = jobs[job]->pipe;\n\n  if (foreground == 0)\n    {\n       \n      if (posixly_correct == 0)\n\ts = (job == js.j_current) ? \"+ \": ((job == js.j_previous) ? \"- \" : \" \");       \n      else\n\ts = \" \";\n      printf (\"[%d]%s\", job + 1, s);\n    }\n\n  do\n    {\n      printf (\"%s%s\",\n\t       p->command ? p->command : \"\",\n\t       p->next != jobs[job]->pipe? \" | \" : \"\");\n      p = p->next;\n    }\n  while (p != jobs[job]->pipe);\n\n  if (foreground == 0)\n    printf (\" &\");\n\n  if (strcmp (wd, jobs[job]->wd) != 0)\n    printf (\"\t(wd: %s)\", polite_directory_format (jobs[job]->wd));\n\n  printf (\"\\n\");\n\n   \n  if (already_running == 0)\n    set_job_running (job);\n\n   \n  if (foreground)\n    {\n      get_tty_state ();\n      save_stty = shell_tty_info;\n      jobs[job]->flags &= ~J_ASYNC;\t \n       \n      if (IS_JOBCONTROL (job))\n\tgive_terminal_to (jobs[job]->pgrp, 0);\n    }\n  else\n    jobs[job]->flags &= ~J_FOREGROUND;\n\n   \n  if (already_running == 0)\n    {\n      jobs[job]->flags |= J_NOTIFIED;\n      killpg (jobs[job]->pgrp, SIGCONT);\n    }\n\n  if (foreground)\n    {\n      pid_t pid;\n      int st;\n\n      pid = find_last_pid (job, 0);\n      UNBLOCK_CHILD (oset);\n      st = wait_for (pid, 0);\n      shell_tty_info = save_stty;\n      set_tty_state ();\n      return (st);\n    }\n  else\n    {\n      reset_current ();\n      UNBLOCK_CHILD (oset);\n      return (0);\n    }\n}\n\n \nint\nkill_pid (pid, sig, group)\n     pid_t pid;\n     int sig, group;\n{\n  register PROCESS *p;\n  int job, result, negative;\n  sigset_t set, oset;\n\n  if (pid < -1)\n    {\n      pid = -pid;\n      group = negative = 1;\n    }\n  else\n    negative = 0;\n\n  result = EXECUTION_SUCCESS;\n  if (group)\n    {\n      BLOCK_CHILD (set, oset);\n      p = find_pipeline (pid, 0, &job);\n\n      if (job != NO_JOB)\n\t{\n\t  jobs[job]->flags &= ~J_NOTIFIED;\n\n\t   \n\n\t   \n\t  if (negative && jobs[job]->pgrp == shell_pgrp)\n\t    result = killpg (pid, sig);\n\t   \n\t  else if (jobs[job]->pgrp == shell_pgrp)\t \n\t    {\n\t      p = jobs[job]->pipe;\n\t      do\n\t\t{\n\t\t  if (PALIVE (p) == 0)\n\t\t    continue;\t\t \n\t\t  kill (p->pid, sig);\n\t\t  if (PEXITED (p) && (sig == SIGTERM || sig == SIGHUP))\n\t\t    kill (p->pid, SIGCONT);\n\t\t  p = p->next;\n\t\t}\n\t      while  (p != jobs[job]->pipe);\n\t    }\n\t  else\n\t    {\n\t      result = killpg (jobs[job]->pgrp, sig);\n\t      if (p && STOPPED (job) && (sig == SIGTERM || sig == SIGHUP))\n\t\tkillpg (jobs[job]->pgrp, SIGCONT);\n\t       \n\t      if (p && STOPPED (job) && (sig == SIGCONT))\n\t\t{\n\t\t  set_job_running (job);\n\t\t  jobs[job]->flags &= ~J_FOREGROUND;\n\t\t  jobs[job]->flags |= J_NOTIFIED;\n\t\t}\n\t    }\n\t}\n      else\n\tresult = killpg (pid, sig);\n\n      UNBLOCK_CHILD (oset);\n    }\n  else\n    result = kill (pid, sig);\n\n  return (result);\n}\n\n \nstatic sighandler\nsigchld_handler (sig)\n     int sig;\n{\n  int n, oerrno;\n\n  oerrno = errno;\n  REINSTALL_SIGCHLD_HANDLER;\n  sigchld++;\n  n = 0;\n  if (queue_sigchld == 0)\n    n = waitchld (-1, 0);\n  errno = oerrno;\n  SIGRETURN (n);\n}\n\n \nstatic int\nwaitchld (wpid, block)\n     pid_t wpid;\n     int block;\n{\n  WAIT status;\n  PROCESS *child;\n  pid_t pid;\n  int ind;\n\n  int call_set_current, last_stopped_job, job, children_exited, waitpid_flags;\n  static int wcontinued = WCONTINUED;\t \n\n  call_set_current = children_exited = 0;\n  last_stopped_job = NO_JOB;\n\n  do\n    {\n       \n      waitpid_flags = (job_control && subshell_environment == 0)\n\t\t\t? (WUNTRACED|wcontinued)\n\t\t\t: 0;\n      if (sigchld || block == 0)\n\twaitpid_flags |= WNOHANG;\n\n       \n      CHECK_TERMSIG;\n       \n      CHECK_WAIT_INTR;\n\n      if (block == 1 && queue_sigchld == 0 && (waitpid_flags & WNOHANG) == 0)\n\t{\n\t  internal_warning (_(\"waitchld: turning on WNOHANG to avoid indefinite block\"));\n\t  waitpid_flags |= WNOHANG;\n\t}\n\n      pid = WAITPID (-1, &status, waitpid_flags);\n\n#if 0\nif (wpid != -1 && block)\n  itrace(\"waitchld: blocking waitpid returns %d\", pid);\n#endif\n#if 0\nif (wpid != -1)\n  itrace(\"waitchld: %s waitpid returns %d\", block?\"blocking\":\"non-blocking\", pid);\n#endif\n       \n      if (wcontinued && pid < 0 && errno == EINVAL)\n\t{\n\t  wcontinued = 0;\n\t  continue;\t \n\t}\n\n       \n      if (sigchld > 0 && (waitpid_flags & WNOHANG))\n\tsigchld--;\n\n       \n      if (pid < 0 && errno == ECHILD)\n\t{\n\t  if (children_exited == 0)\n\t    return -1;\n\t  else\n\t    break;\n\t}\n\n#if 0\nitrace(\"waitchld: waitpid returns %d block = %d children_exited = %d\", pid, block, children_exited);\n#endif\n       \n      CHECK_TERMSIG;\n      CHECK_WAIT_INTR;\n\n       \n      if (pid < 0 && errno == EINTR && wait_sigint_received)\n\tchild_caught_sigint = 1;\n\n      if (pid <= 0)\n\tcontinue;\t \n\n       \n      if (wait_sigint_received && (WIFSIGNALED (status) == 0 || WTERMSIG (status) != SIGINT))\n\tchild_caught_sigint = 1;\n\n       \n      if (WIFSIGNALED (status) && WTERMSIG (status) == SIGINT)\n\tchild_caught_sigint = 0;\n\n       \n      if (WIFCONTINUED(status) == 0)\n\t{\n\t  children_exited++;\n\t  js.c_living--;\n\t}\n\n       \n      child = find_process (pid, 1, &job);\t \n\n#if defined (COPROCESS_SUPPORT)\n      coproc_pidchk (pid, WSTATUS(status));\n#endif\n\n#if defined (PROCESS_SUBSTITUTION)\n       \n      if ((ind = find_procsub_child (pid)) >= 0)\n\tset_procsub_status (ind, pid, WSTATUS (status));\n#endif\n\n       \n      if (child == 0)\n\t{\n\t  if (WIFEXITED (status) || WIFSIGNALED (status))\n\t    js.c_reaped++;\n\t  continue;\n\t}\n\n       \n      child->status = status;\n      child->running = WIFCONTINUED(status) ? PS_RUNNING : PS_DONE;\n\n      if (PEXITED (child))\n\t{\n\t  js.c_totreaped++;\n\t  if (job != NO_JOB)\n\t    js.c_reaped++;\n\t}\n\n      if (job == NO_JOB)\n\tcontinue;\n\n      call_set_current += set_job_status_and_cleanup (job);\n\n      if (STOPPED (job))\n\tlast_stopped_job = job;\n      else if (DEADJOB (job) && last_stopped_job == job)\n\tlast_stopped_job = NO_JOB;\n    }\n  while ((sigchld || block == 0) && pid > (pid_t)0);\n\n   \n  if (call_set_current)\n    {\n      if (last_stopped_job != NO_JOB)\n\tset_current_job (last_stopped_job);\n      else\n\treset_current ();\n    }\n\n   \n  if (children_exited &&\n      (signal_is_trapped (SIGCHLD) || trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER) &&\n      trap_list[SIGCHLD] != (char *)IGNORE_SIG)\n    {\n      if (posixly_correct && this_shell_builtin && this_shell_builtin == wait_builtin)\n\t{\n\t   \n\t  queue_sigchld_trap (children_exited);\n\t  wait_signal_received = SIGCHLD;\n\t   \n\t  if (sigchld == 0 && wait_intr_flag)\n\t    sh_longjmp (wait_intr_buf, 1);\n\t}\n       \n      else if (sigchld)\t \n\tqueue_sigchld_trap (children_exited);\n      else if (signal_in_progress (SIGCHLD))\n\tqueue_sigchld_trap (children_exited);     \n      else if (trap_list[SIGCHLD] == (char *)IMPOSSIBLE_TRAP_HANDLER)\n\tqueue_sigchld_trap (children_exited);\n      else if (running_trap)\n\tqueue_sigchld_trap (children_exited);\n      else if (this_shell_builtin == wait_builtin)\n\trun_sigchld_trap (children_exited);\t \n      else\n\tqueue_sigchld_trap (children_exited);\n    }\n\n   \n  if (asynchronous_notification && interactive && executing_builtin == 0)\n    notify_of_job_status ();\n\n  return (children_exited);\n}\n\n \nstatic int\nset_job_status_and_cleanup (job)\n     int job;\n{\n  PROCESS *child;\n  int tstatus, job_state, any_stopped, any_tstped, call_set_current;\n  SigHandler *temp_handler;\n\n  child = jobs[job]->pipe;\n  jobs[job]->flags &= ~J_NOTIFIED;\n\n  call_set_current = 0;\n\n   \n\n   \n  job_state = any_stopped = any_tstped = 0;\n  do\n    {\n      job_state |= PRUNNING (child);\n#if 0\n      if (PEXITED (child) && (WIFSTOPPED (child->status)))\n#else\n       \n      if (PSTOPPED (child))\n#endif\n\t{\n\t  any_stopped = 1;\n\t  any_tstped |= job_control && (WSTOPSIG (child->status) == SIGTSTP);\n\t}\n      child = child->next;\n    }\n  while (child != jobs[job]->pipe);\n\n   \n  if (job_state != 0 && JOBSTATE(job) != JSTOPPED)\n    return 0;\n\n   \n\n   \n  if (any_stopped)\n    {\n      jobs[job]->state = JSTOPPED;\n      jobs[job]->flags &= ~J_FOREGROUND;\n      call_set_current++;\n       \n      if (any_tstped && loop_level)\n\tbreaking = loop_level;\n    }\n  else if (job_state != 0)\t \n    {\n      jobs[job]->state = JRUNNING;\n      call_set_current++;\n    }\n  else\n    {\n      jobs[job]->state = JDEAD;\n      js.j_ndead++;\n\n#if 0\n      if (IS_FOREGROUND (job))\n\tsetjstatus (job);\n#endif\n\n       \n      if (jobs[job]->j_cleanup)\n\t{\n\t  (*jobs[job]->j_cleanup) (jobs[job]->cleanarg);\n\t  jobs[job]->j_cleanup = (sh_vptrfunc_t *)NULL;\n\t}\n    }\n\n   \n\n  if (JOBSTATE (job) == JDEAD)\n    {\n       \n      if (wait_sigint_received && interactive_shell == 0 &&\n\t  child_caught_sigint && IS_FOREGROUND (job) &&\n\t  signal_is_trapped (SIGINT))\n\t{\n\t  int old_frozen;\n\t  wait_sigint_received = 0;\n\t  last_command_exit_value = process_exit_status (child->status);\n\n\t  old_frozen = jobs_list_frozen;\n\t  jobs_list_frozen = 1;\n\t  tstatus = maybe_call_trap_handler (SIGINT);\n\t  jobs_list_frozen = old_frozen;\n\t}\n\n       \n      else if (wait_sigint_received &&\n\t      child_caught_sigint == 0 &&\n\t      IS_FOREGROUND (job) && IS_JOBCONTROL (job) == 0)\n\t{\n\t  int old_frozen;\n\n\t  wait_sigint_received = 0;\n\n\t   \n\t  if (signal_is_trapped (SIGINT))\n\t    last_command_exit_value = process_exit_status (child->status);\n\n\t   \n\t  old_frozen = jobs_list_frozen;\n\t  jobs_list_frozen = 1;\n\t  tstatus = maybe_call_trap_handler (SIGINT);\n\t  jobs_list_frozen = old_frozen;\n\t  if (tstatus == 0 && old_sigint_handler != INVALID_SIGNAL_HANDLER)\n\t    {\n\t       \n\n\t      temp_handler = old_sigint_handler;\n\n\t       \n\t      if (temp_handler == trap_handler && signal_is_trapped (SIGINT) == 0)\n\t\t  temp_handler = trap_to_sighandler (SIGINT);\n\t      restore_sigint_handler ();\n\t      if (temp_handler == SIG_DFL)\n\t\ttermsig_handler (SIGINT);\t \n\t      else if (temp_handler != SIG_IGN)\n\t\t(*temp_handler) (SIGINT);\n\t    }\n\t}\n    }\n\n  return call_set_current;\n}\n\n \nstatic void\nsetjstatus (j)\n     int j;\n{\n#if defined (ARRAY_VARS)\n  register int i;\n  register PROCESS *p;\n\n  for (i = 1, p = jobs[j]->pipe; p->next != jobs[j]->pipe; p = p->next, i++)\n    ;\n  i++;\n  if (statsize < i)\n    {\n      pstatuses = (int *)xrealloc (pstatuses, i * sizeof (int));\n      statsize = i;\n    }\n  i = 0;\n  p = jobs[j]->pipe;\n  do\n    {\n      pstatuses[i++] = process_exit_status (p->status);\n      p = p->next;\n    }\n  while (p != jobs[j]->pipe);\n\n  pstatuses[i] = -1;\t \n  set_pipestatus_array (pstatuses, i);\n#endif\n}\n\nvoid\nrun_sigchld_trap (nchild)\n     int nchild;\n{\n  char *trap_command;\n  int i;\n\n   \n  trap_command = savestring (trap_list[SIGCHLD]);\n\n  begin_unwind_frame (\"SIGCHLD trap\");\n  unwind_protect_int (last_command_exit_value);\n  unwind_protect_int (last_command_exit_signal);\n  unwind_protect_var (last_made_pid);\n  unwind_protect_int (jobs_list_frozen);\n  unwind_protect_pointer (the_pipeline);\n  unwind_protect_pointer (subst_assign_varlist);\n  unwind_protect_pointer (this_shell_builtin);\n  unwind_protect_pointer (temporary_env);\n\n   \n  add_unwind_protect (xfree, trap_command);\n  add_unwind_protect (maybe_set_sigchld_trap, trap_command);\n\n  subst_assign_varlist = (WORD_LIST *)NULL;\n  the_pipeline = (PROCESS *)NULL;\n  temporary_env = 0;\t \n\n  running_trap = SIGCHLD + 1;\n\n  set_impossible_sigchld_trap ();\n  jobs_list_frozen = 1;\n  for (i = 0; i < nchild; i++)\n    {\n      parse_and_execute (savestring (trap_command), \"trap\", SEVAL_NOHIST|SEVAL_RESETLINE|SEVAL_NOOPTIMIZE);\n    }\n\n  run_unwind_frame (\"SIGCHLD trap\");\n  running_trap = 0;\n}\n\n \nstatic void\nnotify_of_job_status ()\n{\n  register int job, termsig;\n  char *dir;\n  sigset_t set, oset;\n  WAIT s;\n\n  if (jobs == 0 || js.j_jobslots == 0)\n    return;\n\n  if (old_ttou != 0)\n    {\n      sigemptyset (&set);\n      sigaddset (&set, SIGCHLD);\n      sigaddset (&set, SIGTTOU);\n      sigemptyset (&oset);\n      sigprocmask (SIG_BLOCK, &set, &oset);\n    }\n  else\n    queue_sigchld++;\n\n   \n  for (job = 0, dir = (char *)NULL; job < js.j_jobslots; job++)\n    {\n      if (jobs[job] && IS_NOTIFIED (job) == 0)\n\t{\n\t  s = raw_job_exit_status (job);\n\t  termsig = WTERMSIG (s);\n\n\t   \n\t  if (startup_state == 0 && WIFSIGNALED (s) == 0 &&\n\t\t((DEADJOB (job) && IS_FOREGROUND (job) == 0) || STOPPED (job)))\n\t    continue;\n\t  \n\t   \n\t  if ((job_control == 0 && interactive_shell) ||\n\t      (startup_state == 2 && (subshell_environment & SUBSHELL_COMSUB)) ||\n\t      (startup_state == 2 && posixly_correct && (subshell_environment & SUBSHELL_COMSUB) == 0))\n\t    {\n\t       \n\t      if (DEADJOB (job) && (interactive_shell || (find_last_pid (job, 0) != last_asynchronous_pid)))\n\t\tjobs[job]->flags |= J_NOTIFIED;\n\t      continue;\n\t    }\n\n\t   \n\t  switch (JOBSTATE (job))\n\t    {\n\t    case JDEAD:\n\t      if (interactive_shell == 0 && termsig && WIFSIGNALED (s) &&\n\t\t  termsig != SIGINT &&\n#if defined (DONT_REPORT_SIGTERM)\n\t\t  termsig != SIGTERM &&\n#endif\n#if defined (DONT_REPORT_SIGPIPE)\n\t\t  termsig != SIGPIPE &&\n#endif\n\t\t  signal_is_trapped (termsig) == 0)\n\t\t{\n\t\t   \n\t\t  fprintf (stderr, _(\"%s: line %d: \"), get_name_for_error (), (line_number == 0) ? 1 : line_number);\n\t\t  pretty_print_job (job, JLIST_NONINTERACTIVE, stderr);\n\t\t}\n\t      else if (IS_FOREGROUND (job))\n\t\t{\n#if !defined (DONT_REPORT_SIGPIPE)\n\t\t  if (termsig && WIFSIGNALED (s) && termsig != SIGINT)\n#else\n\t\t  if (termsig && WIFSIGNALED (s) && termsig != SIGINT && termsig != SIGPIPE)\n#endif\n\t\t    {\n\t\t      fprintf (stderr, \"%s\", j_strsignal (termsig));\n\n\t\t      if (WIFCORED (s))\n\t\t\tfprintf (stderr, _(\" (core dumped)\"));\n\n\t\t      fprintf (stderr, \"\\n\");\n\t\t    }\n\t\t}\n\t      else if (job_control)\t \n\t\t{\n\t\t  if (dir == 0)\n\t\t    dir = current_working_directory ();\n\t\t  pretty_print_job (job, JLIST_STANDARD, stderr);\n\t\t  if (dir && strcmp (dir, jobs[job]->wd) != 0)\n\t\t    fprintf (stderr,\n\t\t\t     _(\"(wd now: %s)\\n\"), polite_directory_format (dir));\n\t\t}\n\n\t      jobs[job]->flags |= J_NOTIFIED;\n\t      break;\n\n\t    case JSTOPPED:\n\t      fprintf (stderr, \"\\n\");\n\t      if (dir == 0)\n\t\tdir = current_working_directory ();\n\t      pretty_print_job (job, JLIST_STANDARD, stderr);\n\t      if (dir && (strcmp (dir, jobs[job]->wd) != 0))\n\t\tfprintf (stderr,\n\t\t\t _(\"(wd now: %s)\\n\"), polite_directory_format (dir));\n\t      jobs[job]->flags |= J_NOTIFIED;\n\t      break;\n\n\t    case JRUNNING:\n\t    case JMIXED:\n\t      break;\n\n\t    default:\n\t      programming_error (\"notify_of_job_status\");\n\t    }\n\t}\n    }\n  if (old_ttou != 0)\n    sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);\n  else\n    queue_sigchld--;\n}\n\n \nint\ninitialize_job_control (force)\n     int force;\n{\n  pid_t t;\n  int t_errno, tty_sigs;\n\n  t_errno = -1;\n  shell_pgrp = getpgid (0);\n\n  if (shell_pgrp == -1)\n    {\n      sys_error (_(\"initialize_job_control: getpgrp failed\"));\n      exit (1);\n    }\n\n   \n  if (interactive == 0 && force == 0)\n    {\n      job_control = 0;\n      original_pgrp = NO_PID;\n      shell_tty = fileno (stderr);\n      terminal_pgrp = tcgetpgrp (shell_tty);\t \n    }\n  else\n    {\n      shell_tty = -1;\n\n       \n      if (forced_interactive && isatty (fileno (stderr)) == 0)\n\tshell_tty = open (\"/dev/tty\", O_RDWR|O_NONBLOCK);\n\n       \n      if (shell_tty == -1)\n\tshell_tty = dup (fileno (stderr));\t \n\n      if (shell_tty != -1)\n\tshell_tty = move_to_high_fd (shell_tty, 1, -1);\n\n       \n      if (shell_pgrp == 0)\n\t{\n\t  shell_pgrp = getpid ();\n\t  setpgid (0, shell_pgrp);\n\t  if (shell_tty != -1)\n\t    tcsetpgrp (shell_tty, shell_pgrp);\n\t}\n\n      tty_sigs = 0;\n      while ((terminal_pgrp = tcgetpgrp (shell_tty)) != -1)\n\t{\n\t  if (shell_pgrp != terminal_pgrp)\n\t    {\n\t      SigHandler *ottin;\n\n\t      CHECK_TERMSIG;\n\t      ottin = set_signal_handler (SIGTTIN, SIG_DFL);\n\t      kill (0, SIGTTIN);\n\t      set_signal_handler (SIGTTIN, ottin);\n\t      if (tty_sigs++ > 16)\n\t\t{\n\t\t  sys_error (_(\"initialize_job_control: no job control in background\"));\n\t\t  job_control = 0;\n\t\t  original_pgrp = terminal_pgrp;\t \n\t\t  goto just_bail;\n\t\t}\n\t      continue;\n\t    }\n\t  break;\n\t}\n\n      if (terminal_pgrp == -1)\n\tt_errno = errno;\n\n       \n      if (set_new_line_discipline (shell_tty) < 0)\n\t{\n\t  sys_error (_(\"initialize_job_control: line discipline\"));\n\t  job_control = 0;\n\t}\n      else\n\t{\n\t  original_pgrp = shell_pgrp;\n\t  shell_pgrp = getpid ();\n\n\t  if ((original_pgrp != shell_pgrp) && (setpgid (0, shell_pgrp) < 0))\n\t    {\n\t      sys_error (_(\"initialize_job_control: setpgid\"));\n\t      shell_pgrp = original_pgrp;\n\t    }\n\n\t  job_control = 1;\n\n\t   \n\t  if (shell_pgrp != original_pgrp && shell_pgrp != terminal_pgrp)\n\t    {\n\t      if (give_terminal_to (shell_pgrp, 0) < 0)\n\t\t{\n\t\t  t_errno = errno;\n\t\t  setpgid (0, original_pgrp);\n\t\t  shell_pgrp = original_pgrp;\n\t\t  errno = t_errno;\n\t\t  sys_error (_(\"cannot set terminal process group (%d)\"), shell_pgrp);\n\t\t  job_control = 0;\n\t\t}\n\t    }\n\n\t  if (job_control && ((t = tcgetpgrp (shell_tty)) == -1 || t != shell_pgrp))\n\t    {\n\t      if (t_errno != -1)\n\t\terrno = t_errno;\n\t      sys_error (_(\"cannot set terminal process group (%d)\"), t);\n\t      job_control = 0;\n\t    }\n\t}\n      if (job_control == 0)\n\tinternal_error (_(\"no job control in this shell\"));\n    }\n\njust_bail:\n  running_in_background = terminal_pgrp != shell_pgrp;\n\n  if (shell_tty != fileno (stderr))\n    SET_CLOSE_ON_EXEC (shell_tty);\n\n  set_signal_handler (SIGCHLD, sigchld_handler);\n\n  change_flag ('m', job_control ? '-' : '+');\n\n  if (interactive)\n    get_tty_state ();\n\n  set_maxchild (0);\n\n  return job_control;\n}\n\n#ifdef DEBUG\nvoid\ndebug_print_pgrps ()\n{\n  itrace(\"original_pgrp = %ld shell_pgrp = %ld terminal_pgrp = %ld\",\n\t (long)original_pgrp, (long)shell_pgrp, (long)terminal_pgrp);\n  itrace(\"tcgetpgrp(%d) -> %ld, getpgid(0) -> %ld\",\n\t shell_tty, (long)tcgetpgrp (shell_tty), (long)getpgid(0));\n  itrace(\"pipeline_pgrp -> %ld\", (long)pipeline_pgrp);\n}\n#endif\n\n \nstatic int\nset_new_line_discipline (tty)\n     int tty;\n{\n#if defined (NEW_TTY_DRIVER)\n  int ldisc;\n\n  if (ioctl (tty, TIOCGETD, &ldisc) < 0)\n    return (-1);\n\n  if (ldisc != NTTYDISC)\n    {\n      ldisc = NTTYDISC;\n\n      if (ioctl (tty, TIOCSETD, &ldisc) < 0)\n\treturn (-1);\n    }\n  return (0);\n#endif  \n\n#if defined (TERMIO_TTY_DRIVER)\n#  if defined (TERMIO_LDISC) && (NTTYDISC)\n  if (ioctl (tty, TCGETA, &shell_tty_info) < 0)\n    return (-1);\n\n  if (shell_tty_info.c_line != NTTYDISC)\n    {\n      shell_tty_info.c_line = NTTYDISC;\n      if (ioctl (tty, TCSETAW, &shell_tty_info) < 0)\n\treturn (-1);\n    }\n#  endif  \n  return (0);\n#endif  \n\n#if defined (TERMIOS_TTY_DRIVER)\n#  if defined (TERMIOS_LDISC) && defined (NTTYDISC)\n  if (tcgetattr (tty, &shell_tty_info) < 0)\n    return (-1);\n\n  if (shell_tty_info.c_line != NTTYDISC)\n    {\n      shell_tty_info.c_line = NTTYDISC;\n      if (tcsetattr (tty, TCSADRAIN, &shell_tty_info) < 0)\n\treturn (-1);\n    }\n#  endif  \n  return (0);\n#endif  \n\n#if !defined (NEW_TTY_DRIVER) && !defined (TERMIO_TTY_DRIVER) && !defined (TERMIOS_TTY_DRIVER)\n  return (-1);\n#endif\n}\n\n \nvoid\ninitialize_job_signals ()\n{\n  if (interactive)\n    {\n      set_signal_handler (SIGINT, sigint_sighandler);\n      set_signal_handler (SIGTSTP, SIG_IGN);\n      set_signal_handler (SIGTTOU, SIG_IGN);\n      set_signal_handler (SIGTTIN, SIG_IGN);\n    }\n  else if (job_control)\n    {\n      old_tstp = set_signal_handler (SIGTSTP, sigstop_sighandler);\n      old_ttin = set_signal_handler (SIGTTIN, sigstop_sighandler);\n      old_ttou = set_signal_handler (SIGTTOU, sigstop_sighandler);\n    }\n   \n}\n\n \nstatic sighandler\nsigcont_sighandler (sig)\n     int sig;\n{\n  initialize_job_signals ();\n  set_signal_handler (SIGCONT, old_cont);\n  kill (getpid (), SIGCONT);\n\n  SIGRETURN (0);\n}\n\n \nstatic sighandler\nsigstop_sighandler (sig)\n     int sig;\n{\n  set_signal_handler (SIGTSTP, old_tstp);\n  set_signal_handler (SIGTTOU, old_ttou);\n  set_signal_handler (SIGTTIN, old_ttin);\n\n  old_cont = set_signal_handler (SIGCONT, sigcont_sighandler);\n\n  give_terminal_to (shell_pgrp, 0);\n\n  kill (getpid (), sig);\n\n  SIGRETURN (0);\n}\n\n \nint\ngive_terminal_to (pgrp, force)\n     pid_t pgrp;\n     int force;\n{\n  sigset_t set, oset;\n  int r, e;\n\n  r = 0;\n  if (job_control || force)\n    {\n      sigemptyset (&set);\n      sigaddset (&set, SIGTTOU);\n      sigaddset (&set, SIGTTIN);\n      sigaddset (&set, SIGTSTP);\n      sigaddset (&set, SIGCHLD);\n      sigemptyset (&oset);\n      sigprocmask (SIG_BLOCK, &set, &oset);\n\n      if (tcsetpgrp (shell_tty, pgrp) < 0)\n\t{\n\t   \n#if 0\n\t  sys_error (\"tcsetpgrp(%d) failed: pid %ld to pgrp %ld\",\n\t    shell_tty, (long)getpid(), (long)pgrp);\n#endif\n\t  r = -1;\n\t  e = errno;\n\t}\n      else\n\tterminal_pgrp = pgrp;\n      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);\n    }\n\n  if (r == -1)\n    errno = e;\n\n  return r;\n}\n\n \nstatic int\nmaybe_give_terminal_to (opgrp, npgrp, flags)\n     pid_t opgrp, npgrp;\n     int flags;\n{\n  int tpgrp;\n\n  tpgrp = tcgetpgrp (shell_tty);\n  if (tpgrp < 0 && errno == ENOTTY)\n    return -1;\n  if (tpgrp == npgrp)\n    {\n      terminal_pgrp = npgrp;\n      return 0;\n    }\n  else if (tpgrp != opgrp)\n    {\n      internal_debug (\"%d: maybe_give_terminal_to: terminal pgrp == %d shell pgrp = %d new pgrp = %d in_background = %d\", (int)getpid(), tpgrp, opgrp, npgrp, running_in_background);\n      return -1;\n    }\n  else\n    return (give_terminal_to (npgrp, flags));     \n}\n\n \nvoid\ndelete_all_jobs (running_only)\n     int running_only;\n{\n  register int i;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n\n   \n  if (js.j_jobslots)\n    {\n      js.j_current = js.j_previous = NO_JOB;\n\n       \n      for (i = 0; i < js.j_jobslots; i++)\n\t{\n\t  if (i < js.j_firstj && jobs[i])\n\t    INTERNAL_DEBUG ((\"delete_all_jobs: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n\t  if (i > js.j_lastj && jobs[i])\n\t    INTERNAL_DEBUG ((\"delete_all_jobs: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n\t  if (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))\n\t     \n\t    delete_job (i, DEL_WARNSTOPPED|DEL_NOBGPID);\n\t}\n      if (running_only == 0)\n\t{\n\t  free ((char *)jobs);\n\t  js.j_jobslots = 0;\n\t  js.j_firstj = js.j_lastj = js.j_njobs = 0;\n\t}\n    }\n\n  if (running_only == 0)\n    bgp_clear ();\n\n  UNBLOCK_CHILD (oset);\n}\n\n \nvoid\nnohup_all_jobs (running_only)\n     int running_only;\n{\n  register int i;\n  sigset_t set, oset;\n\n  BLOCK_CHILD (set, oset);\n\n  if (js.j_jobslots)\n    {\n       \n      for (i = 0; i < js.j_jobslots; i++)\n\tif (jobs[i] && (running_only == 0 || (running_only && RUNNING(i))))\n\t  nohup_job (i);\n    }\n\n  UNBLOCK_CHILD (oset);\n}\n\nint\ncount_all_jobs ()\n{\n  int i, n;\n  sigset_t set, oset;\n\n   \n  BLOCK_CHILD (set, oset);\n   \n  for (i = n = 0; i < js.j_jobslots; i++)\n    {\n      if (i < js.j_firstj && jobs[i])\n\tINTERNAL_DEBUG ((\"count_all_jobs: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n      if (i > js.j_lastj && jobs[i])\n\tINTERNAL_DEBUG ((\"count_all_jobs: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n      if (jobs[i] && DEADJOB(i) == 0)\n\tn++;\n    }\n  UNBLOCK_CHILD (oset);\n  return n;\n}\n\nstatic void\nmark_all_jobs_as_dead ()\n{\n  register int i;\n  sigset_t set, oset;\n\n  if (js.j_jobslots == 0)\n    return;\n\n  BLOCK_CHILD (set, oset);\n\n   \n  for (i = 0; i < js.j_jobslots; i++)\n    if (jobs[i])\n      {\n\tjobs[i]->state = JDEAD;\n\tjs.j_ndead++;\n      }\n\n  UNBLOCK_CHILD (oset);\n}\n\n \nstatic void\nmark_dead_jobs_as_notified (force)\n     int force;\n{\n  register int i, ndead, ndeadproc;\n  sigset_t set, oset;\n\n  if (js.j_jobslots == 0)\n    return;\n\n  BLOCK_CHILD (set, oset);\n\n   \n  if (force)\n    {\n     \n      for (i = 0; i < js.j_jobslots; i++)\n\t{\n\t  if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))\n\t    jobs[i]->flags |= J_NOTIFIED;\n\t}\n      UNBLOCK_CHILD (oset);\n      return;\n    }\n\n   \n\n   \n   \n  for (i = ndead = ndeadproc = 0; i < js.j_jobslots; i++)\n    {\n      if (i < js.j_firstj && jobs[i])\n\tINTERNAL_DEBUG ((\"mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n      if (i > js.j_lastj && jobs[i])\n\tINTERNAL_DEBUG ((\"mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n      if (jobs[i] && DEADJOB (i))\n\t{\n\t  ndead++;\n\t  ndeadproc += processes_in_job (i);\n\t}\n    }\n\n# if 0\n  if (ndeadproc != js.c_reaped)\n    itrace(\"mark_dead_jobs_as_notified: ndeadproc (%d) != js.c_reaped (%d)\", ndeadproc, js.c_reaped);\n# endif\n  if (ndead != js.j_ndead)\n    INTERNAL_DEBUG ((\"mark_dead_jobs_as_notified: ndead (%d) != js.j_ndead (%d)\", ndead, js.j_ndead));\n\n  if (js.c_childmax < 0)\n    set_maxchild (0);\n\n   \n  if (ndeadproc <= js.c_childmax)\n    {\n      UNBLOCK_CHILD (oset);\n      return;\n    }\n\n#if 0\nitrace(\"mark_dead_jobs_as_notified: child_max = %d ndead = %d ndeadproc = %d\", js.c_childmax, ndead, ndeadproc);\n#endif\n\n   \n   \n  for (i = 0; i < js.j_jobslots; i++)\n    {\n      if (jobs[i] && DEADJOB (i) && (interactive_shell || (find_last_pid (i, 0) != last_asynchronous_pid)))\n\t{\n\t  if (i < js.j_firstj && jobs[i])\n\t    INTERNAL_DEBUG ((\"mark_dead_jobs_as_notified: job %d non-null before js.j_firstj (%d)\", i, js.j_firstj));\n\t  if (i > js.j_lastj && jobs[i])\n\t    INTERNAL_DEBUG ((\"mark_dead_jobs_as_notified: job %d non-null after js.j_lastj (%d)\", i, js.j_lastj));\n\n\t   \n\t  if ((ndeadproc -= processes_in_job (i)) <= js.c_childmax)\n\t    break;\n\t  jobs[i]->flags |= J_NOTIFIED;\n\t}\n    }\n\n  UNBLOCK_CHILD (oset);\n}\n\n \nint\nfreeze_jobs_list ()\n{\n  int o;\n\n  o = jobs_list_frozen;\n  jobs_list_frozen = 1;\n  return o;\n}\n\nvoid\nunfreeze_jobs_list ()\n{\n  jobs_list_frozen = 0;\n}\n\nvoid\nset_jobs_list_frozen (s)\n     int s;\n{\n  jobs_list_frozen = s;\n}\n\n \nint\nset_job_control (arg)\n     int arg;\n{\n  int old;\n\n  old = job_control;\n  job_control = arg;\n\n  if (terminal_pgrp == NO_PID && shell_tty >= 0)\n    terminal_pgrp = tcgetpgrp (shell_tty);\n\n   \n  if (job_control != old && job_control)\n    shell_pgrp = getpgid (0);  \n\n  running_in_background = (terminal_pgrp != shell_pgrp);\n\n#if 0\n  if (interactive_shell == 0 && running_in_background == 0 && job_control != old)\n    {\n      if (job_control)\n\tinitialize_job_signals ();\n      else\n\tdefault_tty_job_signals ();\n    }\n#endif\n\n   \n  if (job_control != old && job_control)\n    pipeline_pgrp = 0;\n\n  return (old);\n}\n\n \nvoid\nwithout_job_control ()\n{\n  stop_making_children ();\n  start_pipeline ();\n#if defined (PGRP_PIPE)\n  sh_closepipe (pgrp_pipe);\n#endif\n  delete_all_jobs (0);\n  set_job_control (0);\n}\n\n \nvoid\nend_job_control ()\n{\n  if (job_control)\n    terminate_stopped_jobs ();\n\n  if (original_pgrp >= 0 && terminal_pgrp != original_pgrp)\n    give_terminal_to (original_pgrp, 1);\n\n  if (original_pgrp >= 0 && setpgid (0, original_pgrp) == 0)\n    shell_pgrp = original_pgrp;\n}\n\n \nvoid\nrestart_job_control ()\n{\n  if (shell_tty != -1)\n    close (shell_tty);\n  initialize_job_control (0);\n}\n\n \nvoid\nset_maxchild (nchild)\n     int nchild;\n{\n  static int lmaxchild = -1;\n\n   \n  if (lmaxchild < 0)\n    {\n      errno = 0;\n      lmaxchild = getmaxchild ();\n      if (lmaxchild < 0 && errno == 0)\n        lmaxchild = MAX_CHILD_MAX;\t\t \n    }\n  if (lmaxchild < 0)\n    lmaxchild = DEFAULT_CHILD_MAX;\n\n   \n  if (nchild < lmaxchild)\n    nchild = lmaxchild;\n  else if (nchild > MAX_CHILD_MAX)\n    nchild = MAX_CHILD_MAX;\n\n  js.c_childmax = nchild;\n}\n\n \nvoid\nset_sigchld_handler ()\n{\n  set_signal_handler (SIGCHLD, sigchld_handler);\n}\n\n#if defined (PGRP_PIPE)\n \nstatic void\npipe_read (pp)\n     int *pp;\n{\n  char ch;\n\n  if (pp[1] >= 0)\n    {\n      close (pp[1]);\n      pp[1] = -1;\n    }\n\n  if (pp[0] >= 0)\n    {\n      while (read (pp[0], &ch, 1) == -1 && errno == EINTR)\n\t;\n    }\n}\n\n \nvoid\nclose_pgrp_pipe ()\n{\n  sh_closepipe (pgrp_pipe);\n}\n\nvoid\nsave_pgrp_pipe (p, clear)\n     int *p;\n     int clear;\n{\n  p[0] = pgrp_pipe[0];\n  p[1] = pgrp_pipe[1];\n  if (clear)\n    pgrp_pipe[0] = pgrp_pipe[1] = -1;\n}\n\nvoid\nrestore_pgrp_pipe (p)\n     int *p;\n{\n  pgrp_pipe[0] = p[0];\n  pgrp_pipe[1] = p[1];\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}