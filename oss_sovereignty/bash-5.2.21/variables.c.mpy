{
  "module_name": "variables.c",
  "hash_id": "888fa66baacf06a9dbc7ac1837f04570b2c74127080c76f184886810e45d492b",
  "original_prompt": "Ingested from bash-5.2.21/variables.c",
  "human_readable_source": " \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include \"posixstat.h\"\n#include \"posixtime.h\"\n\n#if defined (__QNX__)\n#  if defined (__QNXNTO__)\n#    include <sys/netmgr.h>\n#  else\n#    include <sys/vc.h>\n#  endif  \n#endif  \n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include \"chartypes.h\"\n#if defined (HAVE_PWD_H)\n#  include <pwd.h>\n#endif\n#include \"bashansi.h\"\n#include \"bashintl.h\"\n#include \"filecntl.h\"\n\n#define NEED_XTRACE_SET_DECL\n\n#include \"shell.h\"\n#include \"parser.h\"\n#include \"flags.h\"\n#include \"execute_cmd.h\"\n#include \"findcmd.h\"\n#include \"mailcheck.h\"\n#include \"input.h\"\n#include \"hashcmd.h\"\n#include \"pathexp.h\"\n#include \"alias.h\"\n#include \"jobs.h\"\n\n#include \"version.h\"\n\n#include \"builtins/getopt.h\"\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\n\n#if defined (READLINE)\n#  include \"bashline.h\"\n#  include <readline/readline.h>\n#else\n#  include <tilde/tilde.h>\n#endif\n\n#if defined (HISTORY)\n#  include \"bashhist.h\"\n#  include <readline/history.h>\n#endif  \n\n#if defined (PROGRAMMABLE_COMPLETION)\n#  include \"pcomplete.h\"\n#endif\n\n#define VARIABLES_HASH_BUCKETS\t1024\t \n#define FUNCTIONS_HASH_BUCKETS\t512\n#define TEMPENV_HASH_BUCKETS\t4\t \n\n#define BASHFUNC_PREFIX\t\t\"BASH_FUNC_\"\n#define BASHFUNC_PREFLEN\t10\t \n#define BASHFUNC_SUFFIX\t\t\"%%\"\n#define BASHFUNC_SUFFLEN\t2\t \n\n#if ARRAY_EXPORT\n#define BASHARRAY_PREFIX\t\"BASH_ARRAY_\"\n#define BASHARRAY_PREFLEN\t11\n#define BASHARRAY_SUFFIX\t\"%%\"\n#define BASHARRAY_SUFFLEN\t2\n\n#define BASHASSOC_PREFIX\t\"BASH_ASSOC_\"\n#define BASHASSOC_PREFLEN\t11\n#define BASHASSOC_SUFFIX\t\"%%\"\t \n#define BASHASSOC_SUFFLEN\t2\n#endif\n\n \n\n#define FV_FORCETEMPENV\t\t0x01\n#define FV_SKIPINVISIBLE\t0x02\n#define FV_NODYNAMIC\t\t0x04\n\nextern char **environ;\n\n \nextern time_t shell_start_time;\nextern struct timeval shellstart;\n\n \nVAR_CONTEXT *global_variables = (VAR_CONTEXT *)NULL;\n\n \nVAR_CONTEXT *shell_variables = (VAR_CONTEXT *)NULL;\n\n \nHASH_TABLE *shell_functions = (HASH_TABLE *)NULL;\n\nHASH_TABLE *invalid_env = (HASH_TABLE *)NULL;\n\n#if defined (DEBUGGER)\n \nHASH_TABLE *shell_function_defs = (HASH_TABLE *)NULL;\n#endif\n\n \nint variable_context = 0;\n\n \nint localvar_inherit = 0;\n\n \nint localvar_unset = 0;\n\n \nHASH_TABLE *temporary_env = (HASH_TABLE *)NULL;\n\n \nint tempenv_assign_error;\n\n \nchar *dollar_vars[10];\nWORD_LIST *rest_of_args = (WORD_LIST *)NULL;\nint posparam_count = 0;\n\n \npid_t dollar_dollar_pid;\n\n \nint array_needs_making = 1;\n\n \nint shell_level = 0;\n\n \nchar **export_env = (char **)NULL;\nstatic int export_env_index;\nstatic int export_env_size;\n\n#if defined (READLINE)\nstatic int winsize_assignment;\t\t \n#endif\n\nSHELL_VAR nameref_invalid_value;\nstatic SHELL_VAR nameref_maxloop_value;\n\nstatic HASH_TABLE *last_table_searched;\t \nstatic VAR_CONTEXT *last_context_searched;\n\n \nstatic void create_variable_tables PARAMS((void));\n\nstatic void set_machine_vars PARAMS((void));\nstatic void set_home_var PARAMS((void));\nstatic void set_shell_var PARAMS((void));\nstatic char *get_bash_name PARAMS((void));\nstatic void initialize_shell_level PARAMS((void));\nstatic void uidset PARAMS((void));\n#if defined (ARRAY_VARS)\nstatic void make_vers_array PARAMS((void));\n#endif\n\nstatic SHELL_VAR *null_assign PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *null_array_assign PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\n#endif\nstatic SHELL_VAR *get_self PARAMS((SHELL_VAR *));\n\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *init_dynamic_array_var PARAMS((char *, sh_var_value_func_t *, sh_var_assign_func_t *, int));\nstatic SHELL_VAR *init_dynamic_assoc_var PARAMS((char *, sh_var_value_func_t *, sh_var_assign_func_t *, int));\n#endif\n\nstatic inline SHELL_VAR *set_int_value (SHELL_VAR *, intmax_t, int);\nstatic inline SHELL_VAR *set_string_value (SHELL_VAR *, const char *, int);\n\nstatic SHELL_VAR *assign_seconds PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\nstatic SHELL_VAR *get_seconds PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *init_seconds_var PARAMS((void));\n\nstatic SHELL_VAR *assign_random PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\nstatic SHELL_VAR *get_random PARAMS((SHELL_VAR *));\n\nstatic SHELL_VAR *get_urandom PARAMS((SHELL_VAR *));\n\nstatic SHELL_VAR *assign_lineno PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\nstatic SHELL_VAR *get_lineno PARAMS((SHELL_VAR *));\n\nstatic SHELL_VAR *assign_subshell PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\nstatic SHELL_VAR *get_subshell PARAMS((SHELL_VAR *));\n\nstatic SHELL_VAR *get_epochseconds PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *get_epochrealtime PARAMS((SHELL_VAR *));\n\nstatic SHELL_VAR *get_bashpid PARAMS((SHELL_VAR *));\n\nstatic SHELL_VAR *get_bash_argv0 PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *assign_bash_argv0 PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\nstatic void set_argv0 PARAMS((void));\n\n#if defined (HISTORY)\nstatic SHELL_VAR *get_histcmd PARAMS((SHELL_VAR *));\n#endif\n\n#if defined (READLINE)\nstatic SHELL_VAR *get_comp_wordbreaks PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *assign_comp_wordbreaks PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\n#endif\n\n#if defined (PUSHD_AND_POPD) && defined (ARRAY_VARS)\nstatic SHELL_VAR *assign_dirstack PARAMS((SHELL_VAR *, char *, arrayind_t, char *));\nstatic SHELL_VAR *get_dirstack PARAMS((SHELL_VAR *));\n#endif\n\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *get_groupset PARAMS((SHELL_VAR *));\n#  if defined (DEBUGGER)\nstatic SHELL_VAR *get_bashargcv PARAMS((SHELL_VAR *));\n#  endif\nstatic SHELL_VAR *build_hashcmd PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *get_hashcmd PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *assign_hashcmd PARAMS((SHELL_VAR *,  char *, arrayind_t, char *));\n#  if defined (ALIAS)\nstatic SHELL_VAR *build_aliasvar PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *get_aliasvar PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *assign_aliasvar PARAMS((SHELL_VAR *,  char *, arrayind_t, char *));\n#  endif\n#endif\n\nstatic SHELL_VAR *get_funcname PARAMS((SHELL_VAR *));\nstatic SHELL_VAR *init_funcname_var PARAMS((void));\n\nstatic void initialize_dynamic_variables PARAMS((void));\n\nstatic SHELL_VAR *bind_invalid_envvar PARAMS((const char *, char *, int));\n\nstatic int var_sametype PARAMS((SHELL_VAR *, SHELL_VAR *));\n\nstatic SHELL_VAR *hash_lookup PARAMS((const char *, HASH_TABLE *));\nstatic SHELL_VAR *new_shell_variable PARAMS((const char *));\nstatic SHELL_VAR *make_new_variable PARAMS((const char *, HASH_TABLE *));\nstatic SHELL_VAR *bind_variable_internal PARAMS((const char *, char *, HASH_TABLE *, int, int));\n\nstatic void dispose_variable_value PARAMS((SHELL_VAR *));\nstatic void free_variable_hash_data PARAMS((PTR_T));\n\nstatic VARLIST *vlist_alloc PARAMS((int));\nstatic VARLIST *vlist_realloc PARAMS((VARLIST *, int));\nstatic void vlist_add PARAMS((VARLIST *, SHELL_VAR *, int));\n\nstatic void flatten PARAMS((HASH_TABLE *, sh_var_map_func_t *, VARLIST *, int));\n\nstatic int qsort_var_comp PARAMS((SHELL_VAR **, SHELL_VAR **));\n\nstatic SHELL_VAR **vapply PARAMS((sh_var_map_func_t *));\nstatic SHELL_VAR **fapply PARAMS((sh_var_map_func_t *));\n\nstatic int visible_var PARAMS((SHELL_VAR *));\nstatic int visible_and_exported PARAMS((SHELL_VAR *));\nstatic int export_environment_candidate PARAMS((SHELL_VAR *));\nstatic int local_and_exported PARAMS((SHELL_VAR *));\nstatic int visible_variable_in_context PARAMS((SHELL_VAR *));\nstatic int variable_in_context PARAMS((SHELL_VAR *));\n#if defined (ARRAY_VARS)\nstatic int visible_array_vars PARAMS((SHELL_VAR *));\n#endif\n\nstatic SHELL_VAR *find_variable_internal PARAMS((const char *, int));\n\nstatic SHELL_VAR *find_nameref_at_context PARAMS((SHELL_VAR *, VAR_CONTEXT *));\nstatic SHELL_VAR *find_variable_nameref_context PARAMS((SHELL_VAR *, VAR_CONTEXT *, VAR_CONTEXT **));\nstatic SHELL_VAR *find_variable_last_nameref_context PARAMS((SHELL_VAR *, VAR_CONTEXT *, VAR_CONTEXT **));\n\nstatic SHELL_VAR *bind_tempenv_variable PARAMS((const char *, char *));\nstatic void push_posix_temp_var PARAMS((PTR_T));\nstatic void push_temp_var PARAMS((PTR_T));\nstatic void propagate_temp_var PARAMS((PTR_T));\nstatic void dispose_temporary_env PARAMS((sh_free_func_t *));     \n\nstatic inline char *mk_env_string PARAMS((const char *, const char *, int));\nstatic char **make_env_array_from_var_list PARAMS((SHELL_VAR **));\nstatic char **make_var_export_array PARAMS((VAR_CONTEXT *));\nstatic char **make_func_export_array PARAMS((void));\nstatic void add_temp_array_to_env PARAMS((char **, int, int));\n\nstatic int n_shell_variables PARAMS((void));\nstatic int set_context PARAMS((SHELL_VAR *));\n\nstatic void push_func_var PARAMS((PTR_T));\nstatic void push_builtin_var PARAMS((PTR_T));\nstatic void push_exported_var PARAMS((PTR_T));\n\nstatic void delete_local_contexts PARAMS((VAR_CONTEXT *));\n\n \nstatic inline void push_posix_tempvar_internal PARAMS((SHELL_VAR *, int));\n\nstatic inline int find_special_var PARAMS((const char *));\n\nstatic void\ncreate_variable_tables ()\n{\n  if (shell_variables == 0)\n    {\n      shell_variables = global_variables = new_var_context ((char *)NULL, 0);\n      shell_variables->scope = 0;\n      shell_variables->table = hash_create (VARIABLES_HASH_BUCKETS);\n    }\n\n  if (shell_functions == 0)\n    shell_functions = hash_create (FUNCTIONS_HASH_BUCKETS);\n\n#if defined (DEBUGGER)\n  if (shell_function_defs == 0)\n    shell_function_defs = hash_create (FUNCTIONS_HASH_BUCKETS);\n#endif\n}\n\n \nvoid\ninitialize_shell_variables (env, privmode)\n     char **env;\n     int privmode;\n{\n  char *name, *string, *temp_string;\n  int c, char_index, string_index, string_length, ro;\n  SHELL_VAR *temp_var;\n\n  create_variable_tables ();\n\n  for (string_index = 0; env && (string = env[string_index++]); )\n    {\n      char_index = 0;\n      name = string;\n      while ((c = *string++) && c != '=')\n\t;\n      if (string[-1] == '=')\n\tchar_index = string - name - 1;\n\n       \n      if (char_index == 0)\n\tcontinue;\n\n       \n      name[char_index] = '\\0';\n       \n\n      temp_var = (SHELL_VAR *)NULL;\n\n#if defined (FUNCTION_IMPORT)\n       \n      if (privmode == 0 && read_but_dont_execute == 0 && \n          STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&\n          STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&\n\t  STREQN (\"() {\", string, 4))\n\t{\n\t  size_t namelen;\n\t  char *tname;\t\t \n\n\t  namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;\n\n\t  tname = name + BASHFUNC_PREFLEN;\t \n\t  tname[namelen] = '\\0';\t\t \n\n\t  string_length = strlen (string);\n\t  temp_string = (char *)xmalloc (namelen + string_length + 2);\n\n\t  memcpy (temp_string, tname, namelen);\n\t  temp_string[namelen] = ' ';\n\t  memcpy (temp_string + namelen + 1, string, string_length + 1);\n\n\t   \n\t  if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname)))\n\t    parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);\n\t  else\n\t    free (temp_string);\t\t \n\n\t  if (temp_var = find_function (tname))\n\t    {\n\t      VSETATTR (temp_var, (att_exported|att_imported));\n\t      array_needs_making = 1;\n\t    }\n\t  else\n\t    {\n\t      if (temp_var = bind_invalid_envvar (name, string, 0))\n\t\t{\n\t\t  VSETATTR (temp_var, (att_exported | att_imported | att_invisible));\n\t\t  array_needs_making = 1;\n\t\t}\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      report_error (_(\"error importing function definition for `%s'\"), tname);\n\t    }\n\n\t   \n\t  tname[namelen] = BASHFUNC_SUFFIX[0];\n\t}\n      else\n#endif  \n#if defined (ARRAY_VARS)\n#  if ARRAY_EXPORT\n       \n      if (STREQN (BASHARRAY_PREFIX, name, BASHARRAY_PREFLEN) &&\n\t  STREQN (BASHARRAY_SUFFIX, name + char_index - BASHARRAY_SUFFLEN, BASHARRAY_SUFFLEN) &&\n\t  *string == '(' && string[1] == '[' && string[strlen (string) - 1] == ')')\n\t{\n\t  size_t namelen;\n\t  char *tname;\t\t \n\n\t  namelen = char_index - BASHARRAY_PREFLEN - BASHARRAY_SUFFLEN;\n\n\t  tname = name + BASHARRAY_PREFLEN;\t \n\t  tname[namelen] = '\\0';\t\t \n\t  \n\t  string_length = 1;\n\t  temp_string = extract_array_assignment_list (string, &string_length);\n\t  temp_var = assign_array_from_string (tname, temp_string, 0);\n\t  FREE (temp_string);\n\t  if (temp_var)\n\t    {\n\t      VSETATTR (temp_var, (att_exported | att_imported));\n\t      array_needs_making = 1;\n\t    }\n\t}\n      else if (STREQN (BASHASSOC_PREFIX, name, BASHASSOC_PREFLEN) &&\n\t  STREQN (BASHASSOC_SUFFIX, name + char_index - BASHASSOC_SUFFLEN, BASHASSOC_SUFFLEN) &&\n\t  *string == '(' && string[1] == '[' && string[strlen (string) - 1] == ')')\n\t{\n\t  size_t namelen;\n\t  char *tname;\t\t \n\n\t  namelen = char_index - BASHASSOC_PREFLEN - BASHASSOC_SUFFLEN;\n\n\t  tname = name + BASHASSOC_PREFLEN;\t \n\t  tname[namelen] = '\\0';\t\t \n\n\t   \n\t  temp_var = find_or_make_array_variable (tname, 2);\n\t  if (temp_var)\n\t    {\n\t      string_length = 1;\n\t      temp_string = extract_array_assignment_list (string, &string_length);\n\t      temp_var = assign_array_var_from_string (temp_var, temp_string, 0);\n\t    }\n\t  FREE (temp_string);\n\t  if (temp_var)\n\t    {\n\t      VSETATTR (temp_var, (att_exported | att_imported));\n\t      array_needs_making = 1;\n\t    }\n\t}\n      else\n#  endif  \n#endif\n\t{\n\t  ro = 0;\n\t   \n\t  if (  STREQ (name, \"SHELLOPTS\"))\n\t    {\n\t      temp_var = find_variable (\"SHELLOPTS\");\n\t      ro = temp_var && readonly_p (temp_var);\n\t      if (temp_var)\n\t\tVUNSETATTR (temp_var, att_readonly);\n\t    }\n\t  if (legal_identifier (name))\n\t    {\n\t      temp_var = bind_variable (name, string, 0);\n\t      if (temp_var)\n\t\t{\n\t\t  VSETATTR (temp_var, (att_exported | att_imported));\n\t\t  if (ro)\n\t\t    VSETATTR (temp_var, att_readonly);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      temp_var = bind_invalid_envvar (name, string, 0);\n\t      if (temp_var)\n\t\tVSETATTR (temp_var, (att_exported | att_imported | att_invisible));\n\t    }\n\t  if (temp_var)\n\t    array_needs_making = 1;\n\t}\n\n      name[char_index] = '=';\n       \n      if (temp_var && function_p (temp_var) == 0)\t \n\t{\n\t  CACHE_IMPORTSTR (temp_var, name);\n\t}\n    }\n\n  set_pwd ();\n\n   \n  temp_var = set_if_not (\"_\", dollar_vars[0]);\n\n   \n  dollar_dollar_pid = getpid ();\n\n   \n  temp_var = set_if_not (\"PATH\", DEFAULT_PATH_VALUE);\n  temp_var = set_if_not (\"TERM\", \"dumb\");\n\n#if defined (__QNX__)\n   \n  {\n    char node_name[22];\n#  if defined (__QNXNTO__)\n    netmgr_ndtostr(ND2S_LOCAL_STR, ND_LOCAL_NODE, node_name, sizeof(node_name));\n#  else\n    qnx_nidtostr (getnid (), node_name, sizeof (node_name));\n#  endif\n    temp_var = bind_variable (\"NODE\", node_name, 0);\n    if (temp_var)\n      set_auto_export (temp_var);\n  }\n#endif\n\n   \n  if (interactive_shell)\n    {\n#if defined (PROMPT_STRING_DECODE)\n      set_if_not (\"PS1\", primary_prompt);\n#else\n      if (current_user.uid == -1)\n\tget_current_user_info ();\n      set_if_not (\"PS1\", current_user.euid == 0 ? \"# \" : primary_prompt);\n#endif\n      set_if_not (\"PS2\", secondary_prompt);\n    }\n\n  if (current_user.euid == 0)\n    bind_variable (\"PS4\", \"+ \", 0);\n  else\n    set_if_not (\"PS4\", \"+ \");\n\n   \n  temp_var = bind_variable (\"IFS\", \" \\t\\n\", 0);\n  setifs (temp_var);\n\n   \n  set_machine_vars ();\n\n   \n  if (interactive_shell)\n    {\n      temp_var = set_if_not (\"MAILCHECK\", posixly_correct ? \"600\" : \"60\");\n      VSETATTR (temp_var, att_integer);\n    }\n\n   \n  initialize_shell_level ();\n\n  set_ppid ();\n\n  set_argv0 ();\n\n   \n  temp_var = bind_variable (\"OPTIND\", \"1\", 0);\n  VSETATTR (temp_var, att_integer);\n  getopts_reset (0);\n  bind_variable (\"OPTERR\", \"1\", 0);\n  sh_opterr = 1;\n\n  if (login_shell == 1 && posixly_correct == 0)\n    set_home_var ();\n\n   \n  name = get_bash_name ();\n  temp_var = bind_variable (\"BASH\", name, 0);\n  free (name);\n\n   \n  set_shell_var ();\n\n   \n  bind_variable (\"BASH_VERSION\", shell_version_string (), 0);\n#if defined (ARRAY_VARS)\n  make_vers_array ();\n#endif\n\n  if (command_execution_string)\n    bind_variable (\"BASH_EXECUTION_STRING\", command_execution_string, 0);\n\n   \n  temp_var = find_variable (\"POSIXLY_CORRECT\");\n  if (!temp_var)\n    temp_var = find_variable (\"POSIX_PEDANTIC\");\n  if (temp_var && imported_p (temp_var))\n    sv_strict_posix (temp_var->name);\n\n#if defined (HISTORY)\n   \n  if (remember_on_history)\n    {\n      name = bash_tilde_expand (posixly_correct ? \"~/.sh_history\" : \"~/.bash_history\", 0);\n\n      set_if_not (\"HISTFILE\", name);\n      free (name);\n    }\n#endif  \n\n   \n  seedrand ();\n  seedrand32 ();\n\n   \n  if (interactive_shell)\n    {\n      temp_var = find_variable (\"IGNOREEOF\");\n      if (!temp_var)\n\ttemp_var = find_variable (\"ignoreeof\");\n      if (temp_var && imported_p (temp_var))\n\tsv_ignoreeof (temp_var->name);\n    }\n\n#if defined (HISTORY)\n  if (interactive_shell && remember_on_history)\n    {\n      sv_history_control (\"HISTCONTROL\");\n      sv_histignore (\"HISTIGNORE\");\n      sv_histtimefmt (\"HISTTIMEFORMAT\");\n    }\n#endif  \n\n#if defined (READLINE) && defined (STRICT_POSIX)\n   \n  if (interactive_shell && posixly_correct && no_line_editing == 0)\n    rl_prefer_env_winsize = 1;\n#endif  \n\n   \n  uidset ();\n\n  temp_var = set_if_not (\"BASH_LOADABLES_PATH\", DEFAULT_LOADABLE_BUILTINS_PATH);\n\n  temp_var = find_variable (\"BASH_XTRACEFD\");\n  if (temp_var && imported_p (temp_var))\n    sv_xtracefd (temp_var->name);\n\n  sv_shcompat (\"BASH_COMPAT\");\n\n   \n  sv_funcnest (\"FUNCNEST\");\n\n   \n  initialize_dynamic_variables ();\n}\n\n \n \n \n \n \n\nstatic void\nset_machine_vars ()\n{\n  SHELL_VAR *temp_var;\n\n  temp_var = set_if_not (\"HOSTTYPE\", HOSTTYPE);\n  temp_var = set_if_not (\"OSTYPE\", OSTYPE);\n  temp_var = set_if_not (\"MACHTYPE\", MACHTYPE);\n\n  temp_var = set_if_not (\"HOSTNAME\", current_host_name);\n}\n\n \n\n \nchar *\nsh_get_home_dir ()\n{\n  if (current_user.home_dir == 0)\n    get_current_user_info ();\n  return current_user.home_dir;\n}\n\nstatic void\nset_home_var ()\n{\n  SHELL_VAR *temp_var;\n\n  temp_var = find_variable (\"HOME\");\n  if (temp_var == 0)\n    temp_var = bind_variable (\"HOME\", sh_get_home_dir (), 0);\n#if 0\n  VSETATTR (temp_var, att_exported);\n#endif\n}\n\n \nstatic void\nset_shell_var ()\n{\n  SHELL_VAR *temp_var;\n\n  temp_var = find_variable (\"SHELL\");\n  if (temp_var == 0)\n    {\n      if (current_user.shell == 0)\n\tget_current_user_info ();\n      temp_var = bind_variable (\"SHELL\", current_user.shell, 0);\n    }\n#if 0\n  VSETATTR (temp_var, att_exported);\n#endif\n}\n\nstatic char *\nget_bash_name ()\n{\n  char *name;\n\n  if ((login_shell == 1) && RELPATH(shell_name))\n    {\n      if (current_user.shell == 0)\n\tget_current_user_info ();\n      name = savestring (current_user.shell);\n    }\n  else if (ABSPATH(shell_name))\n    name = savestring (shell_name);\n  else if (shell_name[0] == '.' && shell_name[1] == '/')\n    {\n       \n      char *cdir;\n      int len;\n\n      cdir = get_string_value (\"PWD\");\n      if (cdir)\n\t{\n\t  len = strlen (cdir);\n\t  name = (char *)xmalloc (len + strlen (shell_name) + 1);\n\t  strcpy (name, cdir);\n\t  strcpy (name + len, shell_name + 1);\n\t}\n      else\n\tname = savestring (shell_name);\n    }\n  else\n    {\n      char *tname;\n      int s;\n\n      tname = find_user_command (shell_name);\n\n      if (tname == 0)\n\t{\n\t   \n\t  s = file_status (shell_name);\n\t  if (s & FS_EXECABLE)\n\t    {\n\t      tname = make_absolute (shell_name, get_string_value (\"PWD\"));\n\t      if (*shell_name == '.')\n\t\t{\n\t\t  name = sh_canonpath (tname, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\t\t  if (name == 0)\n\t\t    name = tname;\n\t\t  else\n\t\t    free (tname);\n\t\t}\n\t     else\n\t\tname = tname;\n\t    }\n\t  else\n\t    {\n\t      if (current_user.shell == 0)\n\t\tget_current_user_info ();\n\t      name = savestring (current_user.shell);\n\t    }\n\t}\n      else\n\t{\n\t  name = full_pathname (tname);\n\t  free (tname);\n\t}\n    }\n\n  return (name);\n}\n\nvoid\nadjust_shell_level (change)\n     int change;\n{\n  char new_level[5], *old_SHLVL;\n  intmax_t old_level;\n  SHELL_VAR *temp_var;\n\n  old_SHLVL = get_string_value (\"SHLVL\");\n  if (old_SHLVL == 0 || *old_SHLVL == '\\0' || legal_number (old_SHLVL, &old_level) == 0)\n    old_level = 0;\n\n  shell_level = old_level + change;\n  if (shell_level < 0)\n    shell_level = 0;\n  else if (shell_level >= 1000)\n    {\n      internal_warning (_(\"shell level (%d) too high, resetting to 1\"), shell_level);\n      shell_level = 1;\n    }\n\n   \n  if (shell_level < 10)\n    {\n      new_level[0] = shell_level + '0';\n      new_level[1] = '\\0';\n    }\n  else if (shell_level < 100)\n    {\n      new_level[0] = (shell_level / 10) + '0';\n      new_level[1] = (shell_level % 10) + '0';\n      new_level[2] = '\\0';\n    }\n  else if (shell_level < 1000)\n    {\n      new_level[0] = (shell_level / 100) + '0';\n      old_level = shell_level % 100;\n      new_level[1] = (old_level / 10) + '0';\n      new_level[2] = (old_level % 10) + '0';\n      new_level[3] = '\\0';\n    }\n\n  temp_var = bind_variable (\"SHLVL\", new_level, 0);\n  set_auto_export (temp_var);\n}\n\nstatic void\ninitialize_shell_level ()\n{\n  adjust_shell_level (1);\n}\n\n \n\nvoid\nset_pwd ()\n{\n  SHELL_VAR *temp_var, *home_var;\n  char *temp_string, *home_string, *current_dir;\n\n  home_var = find_variable (\"HOME\");\n  home_string = home_var ? value_cell (home_var) : (char *)NULL;\n\n  temp_var = find_variable (\"PWD\");\n   \n  if (temp_var && imported_p (temp_var) &&\n      (temp_string = value_cell (temp_var)) &&\n      temp_string[0] == '/' &&\n      same_file (temp_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    {\n      current_dir = sh_canonpath (temp_string, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n      if (current_dir == 0)\n\tcurrent_dir = get_working_directory (\"shell_init\");\n      else\n\tset_working_directory (current_dir);\n      if (posixly_correct && current_dir)\n\t{\n\t  temp_var = bind_variable (\"PWD\", current_dir, 0);\n\t  set_auto_export (temp_var);\n\t}  \n      free (current_dir);\n    }\n  else if (home_string && interactive_shell && login_shell &&\n\t   same_file (home_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    {\n      set_working_directory (home_string);\n      temp_var = bind_variable (\"PWD\", home_string, 0);\n      set_auto_export (temp_var);\n    }\n  else\n    {\n      temp_string = get_working_directory (\"shell-init\");\n      if (temp_string)\n\t{\n\t  temp_var = bind_variable (\"PWD\", temp_string, 0);\n\t  set_auto_export (temp_var);\n\t  free (temp_string);\n\t}\n    }\n\n   \n  temp_var = find_variable (\"OLDPWD\");\n#if defined (OLDPWD_CHECK_DIRECTORY)\n  if (temp_var == 0 || value_cell (temp_var) == 0 || file_isdir (value_cell (temp_var)) == 0)\n#else\n  if (temp_var == 0 || value_cell (temp_var) == 0)\n#endif\n    {\n      temp_var = bind_variable (\"OLDPWD\", (char *)NULL, 0);\n      VSETATTR (temp_var, (att_exported | att_invisible));\n    }\n}\n\n \nvoid\nset_ppid ()\n{\n  char namebuf[INT_STRLEN_BOUND(pid_t) + 1], *name;\n  SHELL_VAR *temp_var;\n\n  name = inttostr (getppid (), namebuf, sizeof(namebuf));\n  temp_var = find_variable (\"PPID\");\n  if (temp_var)\n    VUNSETATTR (temp_var, (att_readonly | att_exported));\n  temp_var = bind_variable (\"PPID\", name, 0);\n  VSETATTR (temp_var, (att_readonly | att_integer));\n}\n\nstatic void\nuidset ()\n{\n  char buff[INT_STRLEN_BOUND(uid_t) + 1], *b;\n  register SHELL_VAR *v;\n\n  b = inttostr (current_user.uid, buff, sizeof (buff));\n  v = find_variable (\"UID\");\n  if (v == 0)\n    {\n      v = bind_variable (\"UID\", b, 0);\n      VSETATTR (v, (att_readonly | att_integer));\n    }\n\n  if (current_user.euid != current_user.uid)\n    b = inttostr (current_user.euid, buff, sizeof (buff));\n\n  v = find_variable (\"EUID\");\n  if (v == 0)\n    {\n      v = bind_variable (\"EUID\", b, 0);\n      VSETATTR (v, (att_readonly | att_integer));\n    }\n}\n\n#if defined (ARRAY_VARS)\nstatic void\nmake_vers_array ()\n{\n  SHELL_VAR *vv;\n  ARRAY *av;\n  char *s, d[32], b[INT_STRLEN_BOUND(int) + 1];\n\n  unbind_variable_noref (\"BASH_VERSINFO\");\n\n  vv = make_new_array_variable (\"BASH_VERSINFO\");\n  av = array_cell (vv);\n  strcpy (d, dist_version);\n  s = strchr (d, '.');\n  if (s)\n    *s++ = '\\0';\n  array_insert (av, 0, d);\n  array_insert (av, 1, s);\n  s = inttostr (patch_level, b, sizeof (b));\n  array_insert (av, 2, s);\n  s = inttostr (build_version, b, sizeof (b));\n  array_insert (av, 3, s);\n  array_insert (av, 4, release_status);\n  array_insert (av, 5, MACHTYPE);\n\n  VSETATTR (vv, att_readonly);\n}\n#endif  \n\n \nvoid\nsh_set_lines_and_columns (lines, cols)\n     int lines, cols;\n{\n  char val[INT_STRLEN_BOUND(int) + 1], *v;\n\n#if defined (READLINE)\n   \n  if (winsize_assignment)\n    return;\n#endif\n\n  v = inttostr (lines, val, sizeof (val));\n  bind_variable (\"LINES\", v, 0);\n\n  v = inttostr (cols, val, sizeof (val));\n  bind_variable (\"COLUMNS\", v, 0);\n}\n\n \n \n \n \n \n\n \nvoid\nprint_var_list (list)\n     register SHELL_VAR **list;\n{\n  register int i;\n  register SHELL_VAR *var;\n\n  for (i = 0; list && (var = list[i]); i++)\n    if (invisible_p (var) == 0)\n      print_assignment (var);\n}\n\n \nvoid\nprint_func_list (list)\n     register SHELL_VAR **list;\n{\n  register int i;\n  register SHELL_VAR *var;\n\n  for (i = 0; list && (var = list[i]); i++)\n    {\n      printf (\"%s \", var->name);\n      print_var_function (var);\n      printf (\"\\n\");\n    }\n}\n      \n \nvoid\nprint_assignment (var)\n     SHELL_VAR *var;\n{\n  if (var_isset (var) == 0)\n    return;\n\n  if (function_p (var))\n    {\n      printf (\"%s\", var->name);\n      print_var_function (var);\n      printf (\"\\n\");\n    }\n#if defined (ARRAY_VARS)\n  else if (array_p (var))\n    print_array_assignment (var, 0);\n  else if (assoc_p (var))\n    print_assoc_assignment (var, 0);\n#endif  \n  else\n    {\n      printf (\"%s=\", var->name);\n      print_var_value (var, 1);\n      printf (\"\\n\");\n    }\n}\n\n \nvoid\nprint_var_value (var, quote)\n     SHELL_VAR *var;\n     int quote;\n{\n  char *t;\n\n  if (var_isset (var) == 0)\n    return;\n\n  if (quote && posixly_correct == 0 && ansic_shouldquote (value_cell (var)))\n    {\n      t = ansic_quote (value_cell (var), 0, (int *)0);\n      printf (\"%s\", t);\n      free (t);\n    }\n  else if (quote && sh_contains_shell_metas (value_cell (var)))\n    {\n      t = sh_single_quote (value_cell (var));\n      printf (\"%s\", t);\n      free (t);\n    }\n  else\n    printf (\"%s\", value_cell (var));\n}\n\n \nvoid\nprint_var_function (var)\n     SHELL_VAR *var;\n{\n  char *x;\n\n  if (function_p (var) && var_isset (var))\n    {\n      x = named_function_string ((char *)NULL, function_cell(var), FUNC_MULTILINE|FUNC_EXTERNAL);\n      printf (\"%s\", x);\n    }\n}\n\n \n \n \n \n \n\n \n\n#define INIT_DYNAMIC_VAR(var, val, gfunc, afunc) \\\n  do \\\n    { \\\n      v = bind_variable (var, (val), 0); \\\n      v->dynamic_value = gfunc; \\\n      v->assign_func = afunc; \\\n    } \\\n  while (0)\n\n#define INIT_DYNAMIC_ARRAY_VAR(var, gfunc, afunc) \\\n  do \\\n    { \\\n      v = make_new_array_variable (var); \\\n      v->dynamic_value = gfunc; \\\n      v->assign_func = afunc; \\\n    } \\\n  while (0)\n\n#define INIT_DYNAMIC_ASSOC_VAR(var, gfunc, afunc) \\\n  do \\\n    { \\\n      v = make_new_assoc_variable (var); \\\n      v->dynamic_value = gfunc; \\\n      v->assign_func = afunc; \\\n    } \\\n  while (0)\n\nstatic SHELL_VAR *\nnull_assign (self, value, unused, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  return (self);\n}\n\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *\nnull_array_assign (self, value, ind, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t ind;\n     char *key;\n{\n  return (self);\n}\n#endif\n\n \nstatic SHELL_VAR *\nget_self (self)\n     SHELL_VAR *self;\n{\n  return (self);\n}\n\n#if defined (ARRAY_VARS)\n \nstatic SHELL_VAR *\ninit_dynamic_array_var (name, getfunc, setfunc, attrs)\n     char *name;\n     sh_var_value_func_t *getfunc;\n     sh_var_assign_func_t *setfunc;\n     int attrs;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (name);\n  if (v)\n    return (v);\n  INIT_DYNAMIC_ARRAY_VAR (name, getfunc, setfunc);\n  if (attrs)\n    VSETATTR (v, attrs);\n  return v;\n}\n\nstatic SHELL_VAR *\ninit_dynamic_assoc_var (name, getfunc, setfunc, attrs)\n     char *name;\n     sh_var_value_func_t *getfunc;\n     sh_var_assign_func_t *setfunc;\n     int attrs;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (name);\n  if (v)\n    return (v);\n  INIT_DYNAMIC_ASSOC_VAR (name, getfunc, setfunc);\n  if (attrs)\n    VSETATTR (v, attrs);\n  return v;\n}\n#endif\n\n \nstatic inline SHELL_VAR *\nset_int_value (SHELL_VAR *var, intmax_t value, int flags)\n{\n  char *p;\n\n  p = itos (value);\n  FREE (value_cell (var));\n  var_setvalue (var, p);\n  if (flags & 1)\n    VSETATTR (var, att_integer);\n  return (var);\n}\n\nstatic inline SHELL_VAR *\nset_string_value (SHELL_VAR *var, const char *value, int flags)\n{\n  char *p;\n\n  if (value && *value)\n    p = savestring (value);\n  else\n    {\n      p = (char *)xmalloc (1);\n      p[0] = '\\0';\n    }\n  FREE (value_cell (var));\n  var_setvalue (var, p);\n  return (var);\n}\n\n \nstatic intmax_t seconds_value_assigned;\n\nstatic SHELL_VAR *\nassign_seconds (self, value, unused, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  intmax_t nval;\n  int expok;\n\n  if (integer_p (self))\n    nval = evalexp (value, 0, &expok);\n  else\n    expok = legal_number (value, &nval);\n  seconds_value_assigned = expok ? nval : 0;\n  gettimeofday (&shellstart, NULL);\n  shell_start_time = shellstart.tv_sec;\n  return (set_int_value (self, nval, integer_p (self) != 0));\n}\n\nstatic SHELL_VAR *\nget_seconds (var)\n     SHELL_VAR *var;\n{\n  time_t time_since_start;\n  struct timeval tv;\n\n  gettimeofday(&tv, NULL);\n  time_since_start = tv.tv_sec - shell_start_time;\n  return (set_int_value (var, seconds_value_assigned + time_since_start, 1));\n}\n\nstatic SHELL_VAR *\ninit_seconds_var ()\n{\n  SHELL_VAR *v;\n\n  v = find_variable (\"SECONDS\");\n  if (v)\n    {\n      if (legal_number (value_cell(v), &seconds_value_assigned) == 0)\n\tseconds_value_assigned = 0;\n    }\n  INIT_DYNAMIC_VAR (\"SECONDS\", (v ? value_cell (v) : (char *)NULL), get_seconds, assign_seconds);\n  return v;      \n}\n\n \n\nint last_random_value;\nstatic int seeded_subshell = 0;\n\nstatic SHELL_VAR *\nassign_random (self, value, unused, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  intmax_t seedval;\n  int expok;\n\n  if (integer_p (self))\n    seedval = evalexp (value, 0, &expok);\n  else\n    expok = legal_number (value, &seedval);\n  if (expok == 0)\n    return (self);\n  sbrand (seedval);\n  if (subshell_environment)\n    seeded_subshell = getpid ();\n  return (set_int_value (self, seedval, integer_p (self) != 0));\n}\n\nint\nget_random_number ()\n{\n  int rv, pid;\n\n   \n  pid = getpid ();\n  if (subshell_environment && seeded_subshell != pid)\n    {\n      seedrand ();\n      seeded_subshell = pid;\n    }\n\n  do\n    rv = brand ();\n  while (rv == last_random_value);\n\n  return (last_random_value = rv);\n}\n\nstatic SHELL_VAR *\nget_random (var)\n     SHELL_VAR *var;\n{\n  int rv;\n\n  rv = get_random_number ();\n  return (set_int_value (var, rv, 1));\n}\n\nstatic SHELL_VAR *\nget_urandom (var)\n     SHELL_VAR *var;\n{\n  u_bits32_t rv;\n\n  rv = get_urandom32 ();\n  return (set_int_value (var, rv, 1));\n}\n\nstatic SHELL_VAR *\nassign_lineno (var, value, unused, key)\n     SHELL_VAR *var;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  intmax_t new_value;\n\n  if (value == 0 || *value == '\\0' || legal_number (value, &new_value) == 0)\n    new_value = 0;\n  line_number = line_number_base = new_value;\n  return (set_int_value (var, line_number, integer_p (var) != 0));\n}\n\n \nstatic SHELL_VAR *\nget_lineno (var)\n     SHELL_VAR *var;\n{\n  int ln;\n\n  ln = executing_line_number ();\n  return (set_int_value (var, ln, 0));\n}\n\nstatic SHELL_VAR *\nassign_subshell (var, value, unused, key)\n     SHELL_VAR *var;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  intmax_t new_value;\n\n  if (value == 0 || *value == '\\0' || legal_number (value, &new_value) == 0)\n    new_value = 0;\n  subshell_level = new_value;\n  return var;\n}\n\nstatic SHELL_VAR *\nget_subshell (var)\n     SHELL_VAR *var;\n{\n  return (set_int_value (var, subshell_level, 0));\n}\n\nstatic SHELL_VAR *\nget_epochseconds (var)\n     SHELL_VAR *var;\n{\n  intmax_t now;\n\n  now = NOW;\n  return (set_int_value (var, now, 0));\n}\n\nstatic SHELL_VAR *\nget_epochrealtime (var)\n     SHELL_VAR *var;\n{\n  char buf[32];\n  struct timeval tv;\n\n  gettimeofday (&tv, NULL);\n  snprintf (buf, sizeof (buf), \"%u%c%06u\", (unsigned)tv.tv_sec,\n\t\t\t\t\t   locale_decpoint (),\n\t\t\t\t\t   (unsigned)tv.tv_usec);\n\n  return (set_string_value (var, buf, 0));\n}\n\nstatic SHELL_VAR *\nget_bashpid (var)\n     SHELL_VAR *var;\n{\n  int pid;\n\n  pid = getpid ();\n  return (set_int_value (var, pid, 1));\n}\n\nstatic SHELL_VAR *\nget_bash_argv0 (var)\n     SHELL_VAR *var;\n{\n  return (set_string_value (var, dollar_vars[0], 0));\n}\n\nstatic char *static_shell_name = 0;\n\nstatic SHELL_VAR *\nassign_bash_argv0 (var, value, unused, key)\n     SHELL_VAR *var;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  size_t vlen;\n\n  if (value == 0)\n    return var;\n\n  FREE (dollar_vars[0]);\n  dollar_vars[0] = savestring (value);\n\n   \n  vlen = STRLEN (value);\n  static_shell_name = xrealloc (static_shell_name, vlen + 1);\n  strcpy (static_shell_name, value);\n  \n  shell_name = static_shell_name;\n  return var;\n}\n\nstatic void\nset_argv0 ()\n{\n  SHELL_VAR *v;\n\n  v = find_variable (\"BASH_ARGV0\");\n  if (v && imported_p (v))\n    assign_bash_argv0 (v, value_cell (v), 0, 0);\n}\n  \nstatic SHELL_VAR *\nget_bash_command (var)\n     SHELL_VAR *var;\n{\n  char *p;\n\n  p = the_printed_command_except_trap ? the_printed_command_except_trap : \"\";\n  return (set_string_value (var, p, 0));\n}\n\n#if defined (HISTORY)\nstatic SHELL_VAR *\nget_histcmd (var)\n     SHELL_VAR *var;\n{\n  int n;\n\n   \n  n = history_number () - executing;\n  return (set_int_value (var, n, 0));\n}\n#endif\n\n#if defined (READLINE)\n \nstatic SHELL_VAR *\nget_comp_wordbreaks (var)\n     SHELL_VAR *var;\n{\n   \n  if (rl_completer_word_break_characters == 0 && bash_readline_initialized == 0)\n    enable_hostname_completion (perform_hostname_completion);\n\n  return (set_string_value (var, rl_completer_word_break_characters, 0));\n}\n\n \nstatic SHELL_VAR *\nassign_comp_wordbreaks (self, value, unused, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t unused;\n     char *key;\n{\n  if (rl_completer_word_break_characters &&\n      rl_completer_word_break_characters != rl_basic_word_break_characters)\n    free ((void *)rl_completer_word_break_characters);\n\n  rl_completer_word_break_characters = savestring (value);\n  return self;\n}\n#endif  \n\n#if defined (PUSHD_AND_POPD) && defined (ARRAY_VARS)\nstatic SHELL_VAR *\nassign_dirstack (self, value, ind, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t ind;\n     char *key;\n{\n  set_dirstack_element (ind, 1, value);\n  return self;\n}\n\nstatic SHELL_VAR *\nget_dirstack (self)\n     SHELL_VAR *self;\n{\n  ARRAY *a;\n  WORD_LIST *l;\n\n  l = get_directory_stack (0);\n  a = array_from_word_list (l);\n  array_dispose (array_cell (self));\n  dispose_words (l);\n  var_setarray (self, a);\n  return self;\n}\n#endif  \n\n#if defined (ARRAY_VARS)\n \nstatic SHELL_VAR *\nget_groupset (self)\n     SHELL_VAR *self;\n{\n  register int i;\n  int ng;\n  ARRAY *a;\n  static char **group_set = (char **)NULL;\n\n  if (group_set == 0)\n    {\n      group_set = get_group_list (&ng);\n      a = array_cell (self);\n      for (i = 0; i < ng; i++)\n\tarray_insert (a, i, group_set[i]);\n    }\n  return (self);\n}\n\n#  if defined (DEBUGGER)\nstatic SHELL_VAR *\nget_bashargcv (self)\n     SHELL_VAR *self;\n{\n  static int self_semaphore = 0;\n\n   \n  if (self_semaphore == 0 && variable_context == 0 && debugging_mode == 0)\t \n    {\n      self_semaphore = 1;\n      init_bash_argv ();\n      self_semaphore = 0;\n    }\n  return self;\n}\n#  endif\n\nstatic SHELL_VAR *\nbuild_hashcmd (self)\n     SHELL_VAR *self;\n{\n  HASH_TABLE *h;\n  int i;\n  char *k, *v;\n  BUCKET_CONTENTS *item;\n\n  h = assoc_cell (self);\n  if (h)\n    assoc_dispose (h);\n\n  if (hashed_filenames == 0 || HASH_ENTRIES (hashed_filenames) == 0)\n    {\n      var_setvalue (self, (char *)NULL);\n      return self;\n    }\n\n  h = assoc_create (hashed_filenames->nbuckets);\n  for (i = 0; i < hashed_filenames->nbuckets; i++)\n    {\n      for (item = hash_items (i, hashed_filenames); item; item = item->next)\n\t{\n\t  k = savestring (item->key);\n\t  v = pathdata(item)->path;\n\t  assoc_insert (h, k, v);\n\t}\n    }\n\n  var_setvalue (self, (char *)h);\n  return self;\n}\n\nstatic SHELL_VAR *\nget_hashcmd (self)\n     SHELL_VAR *self;\n{\n  build_hashcmd (self);\n  return (self);\n}\n\nstatic SHELL_VAR *\nassign_hashcmd (self, value, ind, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t ind;\n     char *key;\n{\n#if defined (RESTRICTED_SHELL)\n  char *full_path;\n\n  if (restricted)\n    {\n      if (strchr (value, '/'))\n\t{\n\t  sh_restricted (value);\n\t  return (SHELL_VAR *)NULL;\n\t}\n       \n      full_path = find_user_command (value);\n      if (full_path == 0 || *full_path == 0 || executable_file (full_path) == 0)\n\t{\n\t  sh_notfound (value);\n\t  free (full_path);\n\t  return ((SHELL_VAR *)NULL);\n\t}\n      free (full_path);\n    }\n#endif\n  phash_insert (key, value, 0, 0);\n  return (build_hashcmd (self));\n}\n\n#if defined (ALIAS)\nstatic SHELL_VAR *\nbuild_aliasvar (self)\n     SHELL_VAR *self;\n{\n  HASH_TABLE *h;\n  int i;\n  char *k, *v;\n  BUCKET_CONTENTS *item;\n\n  h = assoc_cell (self);\n  if (h)\n    assoc_dispose (h);\n\n  if (aliases == 0 || HASH_ENTRIES (aliases) == 0)\n    {\n      var_setvalue (self, (char *)NULL);\n      return self;\n    }\n\n  h = assoc_create (aliases->nbuckets);\n  for (i = 0; i < aliases->nbuckets; i++)\n    {\n      for (item = hash_items (i, aliases); item; item = item->next)\n\t{\n\t  k = savestring (item->key);\n\t  v = ((alias_t *)(item->data))->value;\n\t  assoc_insert (h, k, v);\n\t}\n    }\n\n  var_setvalue (self, (char *)h);\n  return self;\n}\n\nstatic SHELL_VAR *\nget_aliasvar (self)\n     SHELL_VAR *self;\n{\n  build_aliasvar (self);\n  return (self);\n}\n\nstatic SHELL_VAR *\nassign_aliasvar (self, value, ind, key)\n     SHELL_VAR *self;\n     char *value;\n     arrayind_t ind;\n     char *key;\n{\n  if (legal_alias_name (key, 0) == 0)\n    {\n       report_error (_(\"`%s': invalid alias name\"), key);\n       return (self);\n    }\n  add_alias (key, value);\n  return (build_aliasvar (self));\n}\n#endif  \n\n#endif  \n\n \nstatic SHELL_VAR *\nget_funcname (self)\n     SHELL_VAR *self;\n{\n#if ! defined (ARRAY_VARS)\n  if (variable_context && this_shell_function)\n    return (set_string_value (self, this_shell_function->name, 0));\n#endif\n  return (self);\n}\n\nvoid\nmake_funcname_visible (on_or_off)\n     int on_or_off;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (\"FUNCNAME\");\n  if (v == 0 || v->dynamic_value == 0)\n    return;\n\n  if (on_or_off)\n    VUNSETATTR (v, att_invisible);\n  else\n    VSETATTR (v, att_invisible);\n}\n\nstatic SHELL_VAR *\ninit_funcname_var ()\n{\n  SHELL_VAR *v;\n\n  v = find_variable (\"FUNCNAME\");\n  if (v)\n    return v;\n#if defined (ARRAY_VARS)\n  INIT_DYNAMIC_ARRAY_VAR (\"FUNCNAME\", get_funcname, null_array_assign);\n#else\n  INIT_DYNAMIC_VAR (\"FUNCNAME\", (char *)NULL, get_funcname, null_assign);\n#endif\n  VSETATTR (v, att_invisible|att_noassign);\n  return v;\n}\n\nstatic void\ninitialize_dynamic_variables ()\n{\n  SHELL_VAR *v;\n\n  v = init_seconds_var ();\n\n  INIT_DYNAMIC_VAR (\"BASH_ARGV0\", (char *)NULL, get_bash_argv0, assign_bash_argv0);\n\n  INIT_DYNAMIC_VAR (\"BASH_COMMAND\", (char *)NULL, get_bash_command, (sh_var_assign_func_t *)NULL);\n  INIT_DYNAMIC_VAR (\"BASH_SUBSHELL\", (char *)NULL, get_subshell, assign_subshell);\n\n  INIT_DYNAMIC_VAR (\"RANDOM\", (char *)NULL, get_random, assign_random);\n  VSETATTR (v, att_integer);\n  INIT_DYNAMIC_VAR (\"SRANDOM\", (char *)NULL, get_urandom, (sh_var_assign_func_t *)NULL);\n  VSETATTR (v, att_integer);  \n  INIT_DYNAMIC_VAR (\"LINENO\", (char *)NULL, get_lineno, assign_lineno);\n  VSETATTR (v, att_regenerate);\n\n  INIT_DYNAMIC_VAR (\"BASHPID\", (char *)NULL, get_bashpid, null_assign);\n  VSETATTR (v, att_integer);\n\n  INIT_DYNAMIC_VAR (\"EPOCHSECONDS\", (char *)NULL, get_epochseconds, null_assign);\n  VSETATTR (v, att_regenerate);\n  INIT_DYNAMIC_VAR (\"EPOCHREALTIME\", (char *)NULL, get_epochrealtime, null_assign);\n  VSETATTR (v, att_regenerate);\n\n#if defined (HISTORY)\n  INIT_DYNAMIC_VAR (\"HISTCMD\", (char *)NULL, get_histcmd, (sh_var_assign_func_t *)NULL);\n  VSETATTR (v, att_integer);\n#endif\n\n#if defined (READLINE)\n  INIT_DYNAMIC_VAR (\"COMP_WORDBREAKS\", (char *)NULL, get_comp_wordbreaks, assign_comp_wordbreaks);\n#endif\n\n#if defined (PUSHD_AND_POPD) && defined (ARRAY_VARS)\n  v = init_dynamic_array_var (\"DIRSTACK\", get_dirstack, assign_dirstack, 0);\n#endif  \n\n#if defined (ARRAY_VARS)\n  v = init_dynamic_array_var (\"GROUPS\", get_groupset, null_array_assign, att_noassign);\n\n#  if defined (DEBUGGER)\n  v = init_dynamic_array_var (\"BASH_ARGC\", get_bashargcv, null_array_assign, att_noassign|att_nounset);\n  v = init_dynamic_array_var (\"BASH_ARGV\", get_bashargcv, null_array_assign, att_noassign|att_nounset);\n#  endif  \n  v = init_dynamic_array_var (\"BASH_SOURCE\", get_self, null_array_assign, att_noassign|att_nounset);\n  v = init_dynamic_array_var (\"BASH_LINENO\", get_self, null_array_assign, att_noassign|att_nounset);\n\n  v = init_dynamic_assoc_var (\"BASH_CMDS\", get_hashcmd, assign_hashcmd, att_nofree);\n#  if defined (ALIAS)\n  v = init_dynamic_assoc_var (\"BASH_ALIASES\", get_aliasvar, assign_aliasvar, att_nofree);\n#  endif\n#endif\n\n  v = init_funcname_var ();\n}\n\n \n \n \n \n \n\n#if 0\t \nint\nvar_isset (var)\n     SHELL_VAR *var;\n{\n  return (var->value != 0);\n}\n\nint\nvar_isunset (var)\n     SHELL_VAR *var;\n{\n  return (var->value == 0);\n}\n#endif\n\n \n\nstatic SHELL_VAR *\nhash_lookup (name, hashed_vars)\n     const char *name;\n     HASH_TABLE *hashed_vars;\n{\n  BUCKET_CONTENTS *bucket;\n\n  bucket = hash_search (name, hashed_vars, 0);\n   \n  if (bucket)\n    last_table_searched = hashed_vars;\n  return (bucket ? (SHELL_VAR *)bucket->data : (SHELL_VAR *)NULL);\n}\n\nSHELL_VAR *\nvar_lookup (name, vcontext)\n     const char *name;\n     VAR_CONTEXT *vcontext;\n{\n  VAR_CONTEXT *vc;\n  SHELL_VAR *v;\n\n  v = (SHELL_VAR *)NULL;\n  for (vc = vcontext; vc; vc = vc->down)\n    if (v = hash_lookup (name, vc->table))\n      break;\n\n  return v;\n}\n\n \n\nSHELL_VAR *\nfind_variable_internal (name, flags)\n     const char *name;\n     int flags;\n{\n  SHELL_VAR *var;\n  int search_tempenv, force_tempenv;\n  VAR_CONTEXT *vc;\n\n  var = (SHELL_VAR *)NULL;\n\n  force_tempenv = (flags & FV_FORCETEMPENV);\n\n   \n  search_tempenv = force_tempenv || (expanding_redir == 0 && subshell_environment);\n\n  if (search_tempenv && temporary_env)\t\t\n    var = hash_lookup (name, temporary_env);\n\n  if (var == 0)\n    {\n      if ((flags & FV_SKIPINVISIBLE) == 0)\n\tvar = var_lookup (name, shell_variables);\n      else\n\t{\n\t   \n\t  for (vc = shell_variables; vc; vc = vc->down)\n\t    {\n\t      var = hash_lookup (name, vc->table);\n\t      if (var && invisible_p (var))\n\t\tvar = 0;\n\t      if (var)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (var == 0)\n    return ((SHELL_VAR *)NULL);\n\n  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);\n}\n\n \nSHELL_VAR *\nfind_variable_nameref (v)\n     SHELL_VAR *v;\n{\n  int level, flags;\n  char *newname;\n  SHELL_VAR *orig, *oldv;\n\n  level = 0;\n  orig = v;\n  while (v && nameref_p (v))\n    {\n      level++;\n      if (level > NAMEREF_MAX)\n\treturn ((SHELL_VAR *)0);\t \n      newname = nameref_cell (v);\n      if (newname == 0 || *newname == '\\0')\n\treturn ((SHELL_VAR *)0);\n      oldv = v;\n      flags = 0;\n      if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))\n\tflags |= FV_FORCETEMPENV;\n       \n      v = find_variable_internal (newname, flags);\n      if (v == orig || v == oldv)\n\t{\n\t  internal_warning (_(\"%s: circular name reference\"), orig->name);\n#if 1\n\t   \n\t  if (variable_context && v->context)\n\t    return (find_global_variable_noref (v->name));\n\t  else\n#endif\n\t  return ((SHELL_VAR *)0);\n\t}\n    }\n  return v;\n}\n\n \nSHELL_VAR *\nfind_variable_last_nameref (name, vflags)\n     const char *name;\n     int vflags;\n{\n  SHELL_VAR *v, *nv;\n  char *newname;\n  int level, flags;\n\n  nv = v = find_variable_noref (name);\n  level = 0;\n  while (v && nameref_p (v))\n    {\n      level++;\n      if (level > NAMEREF_MAX)\n        return ((SHELL_VAR *)0);\t \n      newname = nameref_cell (v);\n      if (newname == 0 || *newname == '\\0')\n\treturn ((vflags && invisible_p (v)) ? v : (SHELL_VAR *)0);\n      nv = v;\n      flags = 0;\n      if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))\n\tflags |= FV_FORCETEMPENV;\n       \n      v = find_variable_internal (newname, flags);\n    }\n  return nv;\n}\n\n \nSHELL_VAR *\nfind_global_variable_last_nameref (name, vflags)\n     const char *name;\n     int vflags;\n{\n  SHELL_VAR *v, *nv;\n  char *newname;\n  int level;\n\n  nv = v = find_global_variable_noref (name);\n  level = 0;\n  while (v && nameref_p (v))\n    {\n      level++;\n      if (level > NAMEREF_MAX)\n        return ((SHELL_VAR *)0);\t \n      newname = nameref_cell (v);\n      if (newname == 0 || *newname == '\\0')\n\treturn ((vflags && invisible_p (v)) ? v : (SHELL_VAR *)0);\n      nv = v;\n       \n      v = find_global_variable_noref (newname);\n    }\n  return nv;\n}\n\nstatic SHELL_VAR *\nfind_nameref_at_context (v, vc)\n     SHELL_VAR *v;\n     VAR_CONTEXT *vc;\n{\n  SHELL_VAR *nv, *nv2;\n  char *newname;\n  int level;\n\n  nv = v;\n  level = 1;\n  while (nv && nameref_p (nv))\n    {\n      level++;\n      if (level > NAMEREF_MAX)\n        return (&nameref_maxloop_value);\n      newname = nameref_cell (nv);\n      if (newname == 0 || *newname == '\\0')\n        return ((SHELL_VAR *)NULL);      \n      nv2 = hash_lookup (newname, vc->table);\n      if (nv2 == 0)\n        break;\n      nv = nv2;\n    }\n  return nv;\n}\n\n \nstatic SHELL_VAR *\nfind_variable_nameref_context (v, vc, nvcp)\n     SHELL_VAR *v;\n     VAR_CONTEXT *vc;\n     VAR_CONTEXT **nvcp;\n{\n  SHELL_VAR *nv, *nv2;\n  VAR_CONTEXT *nvc;\n\n   \n  for (nv = v, nvc = vc; nvc; nvc = nvc->down)\n    {\n      nv2 = find_nameref_at_context (nv, nvc);\n      if (nv2 == &nameref_maxloop_value)\n\treturn (nv2);\t\t\t \n      if (nv2 == 0)\n        continue;\n      nv = nv2;\n      if (*nvcp)\n        *nvcp = nvc;\n      if (nameref_p (nv) == 0)\n        break;\n    }\n  return (nameref_p (nv) ? (SHELL_VAR *)NULL : nv);\n}\n\n \nstatic SHELL_VAR *\nfind_variable_last_nameref_context (v, vc, nvcp)\n     SHELL_VAR *v;\n     VAR_CONTEXT *vc;\n     VAR_CONTEXT **nvcp;\n{\n  SHELL_VAR *nv, *nv2;\n  VAR_CONTEXT *nvc;\n\n   \n  for (nv = v, nvc = vc; nvc; nvc = nvc->down)\n    {\n      nv2 = find_nameref_at_context (nv, nvc);\n      if (nv2 == &nameref_maxloop_value)\n\treturn (nv2);\t\t\t \n      if (nv2 == 0)\n\tcontinue;\n      nv = nv2;\n      if (*nvcp)\n        *nvcp = nvc;\n    }\n  return (nameref_p (nv) ? nv : (SHELL_VAR *)NULL);\n}\n\nSHELL_VAR *\nfind_variable_nameref_for_create (name, flags)\n     const char *name;\n     int flags;\n{\n  SHELL_VAR *var;\n\n   \n  var = find_variable_last_nameref (name, 1);\n  if ((flags&1) && var && nameref_p (var) && invisible_p (var))\n    {\n      internal_warning (_(\"%s: removing nameref attribute\"), name);\n      VUNSETATTR (var, att_nameref);\n    }\n  if (var && nameref_p (var))\n    {\n      if (legal_identifier (nameref_cell (var)) == 0)\n\t{\n\t  sh_invalidid (nameref_cell (var) ? nameref_cell (var) : \"\");\n\t  return ((SHELL_VAR *)INVALID_NAMEREF_VALUE);\n\t}\n    }\n  return (var);\n}\n\nSHELL_VAR *\nfind_variable_nameref_for_assignment (name, flags)\n     const char *name;\n     int flags;\n{\n  SHELL_VAR *var;\n\n   \n  var = find_variable_last_nameref (name, 1);\n  if (var && nameref_p (var) && invisible_p (var))\t \n    {\n      internal_warning (_(\"%s: removing nameref attribute\"), name);\n      VUNSETATTR (var, att_nameref);\n    }\n  if (var && nameref_p (var))\n    {\n      if (valid_nameref_value (nameref_cell (var), 1) == 0)\n\t{\n\t  sh_invalidid (nameref_cell (var) ? nameref_cell (var) : \"\");\n\t  return ((SHELL_VAR *)INVALID_NAMEREF_VALUE);\n\t}\n    }\n  return (var);\n}\n\n \nchar *\nnameref_transform_name (name, flags)\n     char *name;\n     int flags;\n{\n  SHELL_VAR *v;\n  char *newname;\n\n  v = 0;\n  if (flags & ASS_MKLOCAL)\n    {\n      v = find_variable_last_nameref (name, 1);\n       \n      if (v && v->context != variable_context)\n\tv = 0;\n    }\n  else if (flags & ASS_MKGLOBAL)\n    v = (flags & ASS_CHKLOCAL) ? find_variable_last_nameref (name, 1)\n\t\t\t       : find_global_variable_last_nameref (name, 1);\n  if (v && nameref_p (v) && valid_nameref_value (nameref_cell (v), 1))\n    return nameref_cell (v);\n  return name;\n}\n\n \nSHELL_VAR *\nfind_variable_tempenv (name)\n     const char *name;\n{\n  SHELL_VAR *var;\n\n  var = find_variable_internal (name, FV_FORCETEMPENV);\n  if (var && nameref_p (var))\n    var = find_variable_nameref (var);\n  return (var);\n}\n\n \nSHELL_VAR *\nfind_variable_notempenv (name)\n     const char *name;\n{\n  SHELL_VAR *var;\n\n  var = find_variable_internal (name, 0);\n  if (var && nameref_p (var))\n    var = find_variable_nameref (var);\n  return (var);\n}\n\nSHELL_VAR *\nfind_global_variable (name)\n     const char *name;\n{\n  SHELL_VAR *var;\n\n  var = var_lookup (name, global_variables);\n  if (var && nameref_p (var))\n    var = find_variable_nameref (var);\t \n\n  if (var == 0)\n    return ((SHELL_VAR *)NULL);\n\n  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);\n}\n\nSHELL_VAR *\nfind_global_variable_noref (name)\n     const char *name;\n{\n  SHELL_VAR *var;\n\n  var = var_lookup (name, global_variables);\n\n  if (var == 0)\n    return ((SHELL_VAR *)NULL);\n\n  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);\n}\n\nSHELL_VAR *\nfind_shell_variable (name)\n     const char *name;\n{\n  SHELL_VAR *var;\n\n  var = var_lookup (name, shell_variables);\n  if (var && nameref_p (var))\n    var = find_variable_nameref (var);\n\n  if (var == 0)\n    return ((SHELL_VAR *)NULL);\n\n  return (var->dynamic_value ? (*(var->dynamic_value)) (var) : var);\n}\n\n \nSHELL_VAR *\nfind_variable (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n  int flags;\n\n  last_table_searched = 0;\n  flags = 0;\n  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))\n    flags |= FV_FORCETEMPENV;\n  v = find_variable_internal (name, flags);\n  if (v && nameref_p (v))\n    v = find_variable_nameref (v);\n  return v;\n}\n\n \nSHELL_VAR *\nfind_variable_no_invisible (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n  int flags;\n\n  last_table_searched = 0;\n  flags = FV_SKIPINVISIBLE;\n  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))\n    flags |= FV_FORCETEMPENV;\n  v = find_variable_internal (name, flags);\n  if (v && nameref_p (v))\n    v = find_variable_nameref (v);\n  return v;\n}\n\n \nSHELL_VAR *\nfind_variable_for_assignment (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n  int flags;\n\n  last_table_searched = 0;\n  flags = 0;\n  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))\n    flags |= FV_FORCETEMPENV;\n  v = find_variable_internal (name, flags);\n  if (v && nameref_p (v))\n    v = find_variable_nameref (v);\n  return v;\n}\n\nSHELL_VAR *\nfind_variable_noref (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n  int flags;\n\n  flags = 0;\n  if (expanding_redir == 0 && (assigning_in_environment || executing_builtin))\n    flags |= FV_FORCETEMPENV;\n  v = find_variable_internal (name, flags);\n  return v;\n}\n\n \nSHELL_VAR *\nfind_function (name)\n     const char *name;\n{\n  return (hash_lookup (name, shell_functions));\n}\n\n \nFUNCTION_DEF *\nfind_function_def (name)\n     const char *name;\n{\n#if defined (DEBUGGER)\n  return ((FUNCTION_DEF *)hash_lookup (name, shell_function_defs));\n#else\n  return ((FUNCTION_DEF *)0);\n#endif\n}\n\n \nchar *\nget_variable_value (var)\n     SHELL_VAR *var;\n{\n  if (var == 0)\n    return ((char *)NULL);\n#if defined (ARRAY_VARS)\n  else if (array_p (var))\n    return (array_reference (array_cell (var), 0));\n  else if (assoc_p (var))\n    return (assoc_reference (assoc_cell (var), \"0\"));\n#endif\n  else\n    return (value_cell (var));\n}\n\n \nchar *\nget_string_value (var_name)\n     const char *var_name;\n{\n  SHELL_VAR *var;\n\n  var = find_variable (var_name);\n  return ((var) ? get_variable_value (var) : (char *)NULL);\n}\n\n \nchar *\nsh_get_env_value (v)\n     const char *v;\n{\n  return get_string_value (v);\n}\n\n \n \n \n \n \n\nstatic int\nvar_sametype (v1, v2)\n     SHELL_VAR *v1;\n     SHELL_VAR *v2;\n{\n  if (v1 == 0 || v2 == 0)\n    return 0;\n#if defined (ARRAY_VARS)\n  else if (assoc_p (v1) && assoc_p (v2))\n    return 1;\n  else if (array_p (v1) && array_p (v2))\n    return 1;\n  else if (array_p (v1) || array_p (v2))\n    return 0;\n  else if (assoc_p (v1) || assoc_p (v2))\n    return 0;\n#endif\n  else\n    return 1;\n}\n\nint\nvalidate_inherited_value (var, type)\n     SHELL_VAR *var;\n     int type;\n{\n#if defined (ARRAY_VARS)\n  if (type == att_array && assoc_p (var))\n    return 0;\n  else if (type == att_assoc && array_p (var))\n    return 0;\n  else\n#endif\n  return 1;\t \n}\n\n \nSHELL_VAR *\nset_if_not (name, value)\n     char *name, *value;\n{\n  SHELL_VAR *v;\n\n  if (shell_variables == 0)\n    create_variable_tables ();\n\n  v = find_variable (name);\n  if (v == 0)\n    v = bind_variable_internal (name, value, global_variables->table, HASH_NOSRCH, 0);\n  return (v);\n}\n\n \nSHELL_VAR *\nmake_local_variable (name, flags)\n     const char *name;\n     int flags;\n{\n  SHELL_VAR *new_var, *old_var, *old_ref;\n  VAR_CONTEXT *vc;\n  int was_tmpvar;\n  char *old_value;\n\n   \n  old_ref = find_variable_noref (name);\n  if (old_ref && nameref_p (old_ref) == 0)\n    old_ref = 0;\n   \n  old_var = find_variable (name);\n  if (old_ref == 0 && old_var && local_p (old_var) && old_var->context == variable_context)\n    return (old_var);\n\n   \n  if (old_ref && local_p (old_ref) && old_ref->context == variable_context)\n    return (old_ref);\n\n   \n  if (old_ref)\n    old_var = old_ref;\n\n  was_tmpvar = old_var && tempvar_p (old_var);\n   \n   \n  if (was_tmpvar && old_var->context == variable_context && last_table_searched != temporary_env)\n    {\n      VUNSETATTR (old_var, att_invisible);\t \n       \n      new_var = old_var;\n       \n      for (vc = shell_variables; vc; vc = vc->down)\n\tif (vc_isfuncenv (vc) && vc->scope == variable_context)\n\t  break;\n      goto set_local_var_flags;\n\n      return (old_var);\n    }\n\n   \n  old_value = was_tmpvar ? value_cell (old_var) : (char *)NULL;\n\n  for (vc = shell_variables; vc; vc = vc->down)\n    if (vc_isfuncenv (vc) && vc->scope == variable_context)\n      break;\n\n  if (vc == 0)\n    {\n      internal_error (_(\"make_local_variable: no function context at current scope\"));\n      return ((SHELL_VAR *)NULL);\n    }\n  else if (vc->table == 0)\n    vc->table = hash_create (TEMPENV_HASH_BUCKETS);\n\n   \n  if (old_var && (noassign_p (old_var) ||\n\t\t (readonly_p (old_var) && old_var->context == 0)))\n    {\n      if (readonly_p (old_var))\n\tsh_readonly (name);\n      else if (noassign_p (old_var))\n\tbuiltin_error (_(\"%s: variable may not be assigned value\"), name);\n#if 0\n       \n      if (readonly_p (old_var))\n#endif\n\treturn ((SHELL_VAR *)NULL);\n    }\n\n  if (old_var == 0)\n    new_var = make_new_variable (name, vc->table);\n  else\n    {\n      new_var = make_new_variable (name, vc->table);\n\n       \n       \n       \n      if (was_tmpvar)\n\tvar_setvalue (new_var, savestring (old_value));\n      else if (localvar_inherit || (flags & MKLOC_INHERIT))\n\t{\n\t   \n#if defined (ARRAY_VARS)\n\t  if (assoc_p (old_var))\n\t    var_setassoc (new_var, assoc_copy (assoc_cell (old_var)));\n\t  else if (array_p (old_var))\n\t    var_setarray (new_var, array_copy (array_cell (old_var)));\n\t  else if (value_cell (old_var))\n#else\n\t  if (value_cell (old_var))\n#endif\n\t    var_setvalue (new_var, savestring (value_cell (old_var)));\n\t  else\n\t    var_setvalue (new_var, (char *)NULL);\n\t}\n\n      if (localvar_inherit || (flags & MKLOC_INHERIT))\n\t{\n\t   \n\t  new_var->attributes = old_var->attributes & ~att_nameref;\n\t  new_var->dynamic_value = old_var->dynamic_value;\n\t  new_var->assign_func = old_var->assign_func;\n\t}\n      else\n\t \n\tnew_var->attributes = exported_p (old_var) ? att_exported : 0;\n    }\n\nset_local_var_flags:\n  vc->flags |= VC_HASLOCAL;\n\n  new_var->context = variable_context;\n  VSETATTR (new_var, att_local);\n\n  if (ifsname (name))\n    setifs (new_var);\n\n   \n  if (was_tmpvar == 0 && value_cell (new_var) == 0)\n    VSETATTR (new_var, att_invisible);\t \n  return (new_var);\n}\n\n \nstatic SHELL_VAR *\nnew_shell_variable (name)\n     const char *name;\n{\n  SHELL_VAR *entry;\n\n  entry = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));\n\n  entry->name = savestring (name);\n  var_setvalue (entry, (char *)NULL);\n  CLEAR_EXPORTSTR (entry);\n\n  entry->dynamic_value = (sh_var_value_func_t *)NULL;\n  entry->assign_func = (sh_var_assign_func_t *)NULL;\n\n  entry->attributes = 0;\n\n   \n  entry->context = 0;\n\n  return (entry);\n}\n\n \nstatic SHELL_VAR *\nmake_new_variable (name, table)\n     const char *name;\n     HASH_TABLE *table;\n{\n  SHELL_VAR *entry;\n  BUCKET_CONTENTS *elt;\n\n  entry = new_shell_variable (name);\n\n   \n  if (shell_variables == 0)\n    create_variable_tables ();\n\n  elt = hash_insert (savestring (name), table, HASH_NOSRCH);\n  elt->data = (PTR_T)entry;\n\n  return entry;\n}\n\n#if defined (ARRAY_VARS)\nSHELL_VAR *\nmake_new_array_variable (name)\n     char *name;\n{\n  SHELL_VAR *entry;\n  ARRAY *array;\n\n  entry = make_new_variable (name, global_variables->table);\n  array = array_create ();\n\n  var_setarray (entry, array);\n  VSETATTR (entry, att_array);\n  return entry;\n}\n\nSHELL_VAR *\nmake_local_array_variable (name, flags)\n     char *name;\n     int flags;\n{\n  SHELL_VAR *var;\n  ARRAY *array;\n  int assoc_ok;\n\n  assoc_ok = flags & MKLOC_ASSOCOK;\n\n  var = make_local_variable (name, flags & MKLOC_INHERIT);\t \n   \n  if (var == 0 || array_p (var) || (assoc_ok && assoc_p (var)))\n    return var;\n\n   \n  if (localvar_inherit && assoc_p (var))\n    {\n      internal_warning (_(\"%s: cannot inherit value from incompatible type\"), name);\n      VUNSETATTR (var, att_assoc);\n      dispose_variable_value (var);\n      array = array_create ();\n      var_setarray (var, array);\n    }\n  else if (localvar_inherit)\n    var = convert_var_to_array (var);\t\t \n  else\n    {\n      dispose_variable_value (var);\n      array = array_create ();\n      var_setarray (var, array);\n    }\n\n  VSETATTR (var, att_array);\n  return var;\n}\n\nSHELL_VAR *\nmake_new_assoc_variable (name)\n     char *name;\n{\n  SHELL_VAR *entry;\n  HASH_TABLE *hash;\n\n  entry = make_new_variable (name, global_variables->table);\n  hash = assoc_create (ASSOC_HASH_BUCKETS);\n\n  var_setassoc (entry, hash);\n  VSETATTR (entry, att_assoc);\n  return entry;\n}\n\nSHELL_VAR *\nmake_local_assoc_variable (name, flags)\n     char *name;\n     int flags;\n{\n  SHELL_VAR *var;\n  HASH_TABLE *hash;\n  int array_ok;\n\n  array_ok = flags & MKLOC_ARRAYOK;\n\n  var = make_local_variable (name, flags & MKLOC_INHERIT);\t \n   \n  if (var == 0 || assoc_p (var) || (array_ok && array_p (var)))\n    return var;\n\n   \n  if (localvar_inherit && array_p (var))\n    {\n      internal_warning (_(\"%s: cannot inherit value from incompatible type\"), name);\n      VUNSETATTR (var, att_array);\n      dispose_variable_value (var);\n      hash = assoc_create (ASSOC_HASH_BUCKETS);\n      var_setassoc (var, hash);\n    }\n  else if (localvar_inherit)\n    var = convert_var_to_assoc (var);\t\t \n  else\n    {\n      dispose_variable_value (var);\n      hash = assoc_create (ASSOC_HASH_BUCKETS);\n      var_setassoc (var, hash);\n    }\n\n  VSETATTR (var, att_assoc);\n  return var;\n}\n#endif\n\nchar *\nmake_variable_value (var, value, flags)\n     SHELL_VAR *var;\n     char *value;\n     int flags;\n{\n  char *retval, *oval;\n  intmax_t lval, rval;\n  int expok, olen, op;\n\n   \n  if ((flags & ASS_NOEVAL) == 0 && integer_p (var))\n    {\n      if (flags & ASS_APPEND)\n\t{\n\t  oval = value_cell (var);\n\t  lval = evalexp (oval, 0, &expok);\t \n\t  if (expok == 0)\n\t    {\n\t      if (flags & ASS_NOLONGJMP)\n\t\tgoto make_value;\n\t      else\n\t\t{\n\t\t  top_level_cleanup ();\n\t\t  jump_to_top_level (DISCARD);\n\t\t}\n\t    }\n\t}\n      rval = evalexp (value, 0, &expok);\n      if (expok == 0)\n\t{\n\t  if (flags & ASS_NOLONGJMP)\n\t    goto make_value;\n\t  else\n\t    {\n\t      top_level_cleanup ();\n\t      jump_to_top_level (DISCARD);\n\t    }\n\t}\n       \n      if (flags & ASS_APPEND)\n\trval += lval;\n      retval = itos (rval);\n    }\n#if defined (CASEMOD_ATTRS)\n  else if ((flags & ASS_NOEVAL) == 0 && (capcase_p (var) || uppercase_p (var) || lowercase_p (var)))\n    {\n      if (flags & ASS_APPEND)\n\t{\n\t  oval = get_variable_value (var);\n\t  if (oval == 0)\t \n\t    oval = \"\";\n\t  olen = STRLEN (oval);\n\t  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);\n\t  strcpy (retval, oval);\n\t  if (value)\n\t    strcpy (retval+olen, value);\n\t}\n      else if (*value)\n\tretval = savestring (value);\n      else\n\t{\n\t  retval = (char *)xmalloc (1);\n\t  retval[0] = '\\0';\n\t}\n      op = capcase_p (var) ? CASE_CAPITALIZE\n\t\t\t : (uppercase_p (var) ? CASE_UPPER : CASE_LOWER);\n      oval = sh_modcase (retval, (char *)0, op);\n      free (retval);\n      retval = oval;\n    }\n#endif  \n  else if (value)\n    {\nmake_value:\n      if (flags & ASS_APPEND)\n\t{\n\t  oval = get_variable_value (var);\n\t  if (oval == 0)\t \n\t    oval = \"\";\n\t  olen = STRLEN (oval);\n\t  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);\n\t  strcpy (retval, oval);\n\t  if (value)\n\t    strcpy (retval+olen, value);\n\t}\n      else if (*value)\n\tretval = savestring (value);\n      else\n\t{\n\t  retval = (char *)xmalloc (1);\n\t  retval[0] = '\\0';\n\t}\n    }\n  else\n    retval = (char *)NULL;\n\n  return retval;\n}\n\n \nstatic int\ncan_optimize_assignment (entry, value, aflags)\n     SHELL_VAR *entry;\n     char *value;\n     int aflags;\n{\n  if ((aflags & ASS_APPEND) == 0)\n    return 0;\n#if defined (ARRAY_VARS)\n  if (array_p (entry) || assoc_p (entry))\n    return 0;\n#endif\n  if (integer_p (entry) || uppercase_p (entry) || lowercase_p (entry) || capcase_p (entry))\n    return 0;\n  if (readonly_p (entry) || noassign_p (entry))\n    return 0;\n  return 1;\n}\n\n \nstatic SHELL_VAR *\noptimized_assignment (entry, value, aflags)\n     SHELL_VAR *entry;\n     char *value;\n     int aflags;\n{\n  size_t len, vlen;\n  char *v, *new;\n\n  v = value_cell (entry);\n  len = STRLEN (v);\n  vlen = STRLEN (value);\n\n  new = (char *)xrealloc (v, len + vlen + 8);\t \n  if (vlen == 1)\n    {\n      new[len] = *value;\n      new[len+1] = '\\0';\n    }\n  else\n    strcpy (new + len, value);\n  var_setvalue (entry, new);\n  return entry;\n}\n\n \nstatic SHELL_VAR *\nbind_variable_internal (name, value, table, hflags, aflags)\n     const char *name;\n     char *value;\n     HASH_TABLE *table;\n     int hflags, aflags;\n{\n  char *newval, *tname;\n  SHELL_VAR *entry, *tentry;\n\n  entry = (hflags & HASH_NOSRCH) ? (SHELL_VAR *)NULL : hash_lookup (name, table);\n   \n  if (entry && nameref_p (entry) && (invisible_p (entry) == 0) && table == global_variables->table)\n    {\n      entry = find_global_variable (entry->name);\n       \n      if (entry == 0)\n\tentry = find_variable_last_nameref (name, 0);\t \n      if (entry == 0)\t\t\t\t\t \n        return (entry);\n    }\n\n   \n  if (entry && invisible_p (entry) && nameref_p (entry))\n    {\n      if ((aflags & ASS_FORCE) == 0 && value && valid_nameref_value (value, 0) == 0)\n\t{\n\t  sh_invalidid (value);\n\t  return ((SHELL_VAR *)NULL);\n\t}\n      goto assign_value;\n    }\n  else if (entry && nameref_p (entry))\n    {\n      newval = nameref_cell (entry);\t \n      if (valid_nameref_value (newval, 0) == 0)\n\t{\n\t  sh_invalidid (newval);\n\t  return ((SHELL_VAR *)NULL);\n\t}\n#if defined (ARRAY_VARS)\n       \n      if (valid_array_reference (newval, 0))\n\t{\n\t  tname = array_variable_name (newval, 0, (char **)0, (int *)0);\n\t  if (tname && (tentry = find_variable_noref (tname)) && nameref_p (tentry))\n\t    {\n\t       \n\t      internal_warning (_(\"%s: removing nameref attribute\"), name_cell (tentry));\n\t      FREE (value_cell (tentry));\t\t \n\t      var_setvalue (tentry, (char *)NULL);\n\t      VUNSETATTR (tentry, att_nameref);\n\t    }\n\t  free (tname);\n\n\t   \n\n\t  entry = assign_array_element (newval, value, aflags|ASS_NAMEREF, (array_eltstate_t *)0);\n\t  if (entry == 0)\n\t    return entry;\n\t}\n      else\n#endif\n\t{\n\t  entry = make_new_variable (newval, table);\n\t  var_setvalue (entry, make_variable_value (entry, value, aflags));\n\t}\n    }\n  else if (entry == 0)\n    {\n      entry = make_new_variable (name, table);\n      var_setvalue (entry, make_variable_value (entry, value, aflags));  \n    }\n  else if (entry->assign_func)\t \n    {\n      if ((readonly_p (entry) && (aflags & ASS_FORCE) == 0) || noassign_p (entry))\n\t{\n\t  if (readonly_p (entry))\n\t    err_readonly (name_cell (entry));\n\t  return (entry);\n\t}\n\n      INVALIDATE_EXPORTSTR (entry);\n      newval = (aflags & ASS_APPEND) ? make_variable_value (entry, value, aflags) : value;\n      if (assoc_p (entry))\n\tentry = (*(entry->assign_func)) (entry, newval, -1, savestring (\"0\"));\n      else if (array_p (entry))\n\tentry = (*(entry->assign_func)) (entry, newval, 0, 0);\n      else\n\tentry = (*(entry->assign_func)) (entry, newval, -1, 0);\n      if (newval != value)\n\tfree (newval);\n      return (entry);\n    }\n  else\n    {\nassign_value:\n      if ((readonly_p (entry) && (aflags & ASS_FORCE) == 0) || noassign_p (entry))\n\t{\n\t  if (readonly_p (entry))\n\t    err_readonly (name_cell (entry));\n\t  return (entry);\n\t}\n\n       \n      VUNSETATTR (entry, att_invisible);\n\n       \n      if (can_optimize_assignment (entry, value, aflags))\n\t{\n\t  INVALIDATE_EXPORTSTR (entry);\n\t  optimized_assignment (entry, value, aflags);\n\n\t  if (mark_modified_vars)\n\t    VSETATTR (entry, att_exported);\n\n\t  if (exported_p (entry))\n\t    array_needs_making = 1;\n\n\t  return (entry);\n\t}\n\n#if defined (ARRAY_VARS)\n      if (assoc_p (entry) || array_p (entry))\n        newval = make_array_variable_value (entry, 0, \"0\", value, aflags);\n      else\n#endif\n      newval = make_variable_value (entry, value, aflags);\t \n\n       \n      INVALIDATE_EXPORTSTR (entry);\n\n#if defined (ARRAY_VARS)\n       \n       \n      if (assoc_p (entry))\n\t{\n\t  assoc_insert (assoc_cell (entry), savestring (\"0\"), newval);\n\t  free (newval);\n\t}\n      else if (array_p (entry))\n\t{\n\t  array_insert (array_cell (entry), 0, newval);\n\t  free (newval);\n\t}\n      else\n#endif\n\t{\n\t  FREE (value_cell (entry));\n\t  var_setvalue (entry, newval);\n\t}\n    }\n\n  if (mark_modified_vars)\n    VSETATTR (entry, att_exported);\n\n  if (exported_p (entry))\n    array_needs_making = 1;\n\n  return (entry);\n}\n\t\n \n\nSHELL_VAR *\nbind_variable (name, value, flags)\n     const char *name;\n     char *value;\n     int flags;\n{\n  SHELL_VAR *v, *nv;\n  VAR_CONTEXT *vc, *nvc;\n\n  if (shell_variables == 0)\n    create_variable_tables ();\n\n   \n  if (temporary_env && value)\t\t \n    bind_tempenv_variable (name, value);\n\n   \n  for (vc = shell_variables; vc; vc = vc->down)\n    {\n      if (vc_isfuncenv (vc) || vc_isbltnenv (vc))\n\t{\n\t  v = hash_lookup (name, vc->table);\n\t  nvc = vc;\n\t  if (v && nameref_p (v))\n\t    {\n\t       \n\t      nv = find_variable_nameref_context (v, vc, &nvc);\n\t      if (nv == 0)\n\t\t{\n\t\t  nv = find_variable_last_nameref_context (v, vc, &nvc);\n\t\t  if (nv && nameref_p (nv))\n\t\t    {\n\t\t       \n\t\t      if (nameref_cell (nv) == 0)\n\t\t\treturn (bind_variable_internal (nv->name, value, nvc->table, 0, flags));\n#if defined (ARRAY_VARS)\n\t\t      else if (valid_array_reference (nameref_cell (nv), 0))\n\t\t\treturn (assign_array_element (nameref_cell (nv), value, flags, (array_eltstate_t *)0));\n\t\t      else\n#endif\n\t\t      return (bind_variable_internal (nameref_cell (nv), value, nvc->table, 0, flags));\n\t\t    }\n\t\t  else if (nv == &nameref_maxloop_value)\n\t\t    {\n\t\t      internal_warning (_(\"%s: circular name reference\"), v->name);\n\t\t      return (bind_global_variable (v->name, value, flags));\n\t\t    }\n\t\t  else\n\t\t    v = nv;\n\t\t}\n\t      else if (nv == &nameref_maxloop_value)\n\t\t{\n\t\t  internal_warning (_(\"%s: circular name reference\"), v->name);\n\t\t  return (bind_global_variable (v->name, value, flags));\n\t\t}\n\t      else\n\t        v = nv;\n\t    }\n\t  if (v)\n\t    return (bind_variable_internal (v->name, value, nvc->table, 0, flags));\n\t}\n    }\n   \n  return (bind_variable_internal (name, value, global_variables->table, 0, flags));\n}\n\nSHELL_VAR *\nbind_global_variable (name, value, flags)\n     const char *name;\n     char *value;\n     int flags;\n{\n  if (shell_variables == 0)\n    create_variable_tables ();\n\n   \n  return (bind_variable_internal (name, value, global_variables->table, 0, flags));\n}\n\nstatic SHELL_VAR *\nbind_invalid_envvar (name, value, flags)\n     const char *name;\n     char *value;\n     int flags;\n{\n  if (invalid_env == 0)\n    invalid_env = hash_create (64);\t \n  return (bind_variable_internal (name, value, invalid_env, HASH_NOSRCH, flags));\n}\n\n \nSHELL_VAR *\nbind_variable_value (var, value, aflags)\n     SHELL_VAR *var;\n     char *value;\n     int aflags;\n{\n  char *t;\n  int invis;\n\n  invis = invisible_p (var);\n  VUNSETATTR (var, att_invisible);\n\n  if (var->assign_func)\n    {\n       \n      t = (aflags & ASS_APPEND) ? make_variable_value (var, value, aflags) : value;\n      (*(var->assign_func)) (var, t, -1, 0);\n      if (t != value && t)\n\tfree (t);      \n    }\n  else\n    {\n      t = make_variable_value (var, value, aflags);\n      if ((aflags & (ASS_NAMEREF|ASS_FORCE)) == ASS_NAMEREF && check_selfref (name_cell (var), t, 0))\n\t{\n\t  if (variable_context)\n\t    internal_warning (_(\"%s: circular name reference\"), name_cell (var));\n\t  else\n\t    {\n\t      internal_error (_(\"%s: nameref variable self references not allowed\"), name_cell (var));\n\t      free (t);\n\t      if (invis)\n\t\tVSETATTR (var, att_invisible);\t \n\t      return ((SHELL_VAR *)NULL);\n\t    }\n\t}\n      if ((aflags & ASS_NAMEREF) && (valid_nameref_value (t, 0) == 0))\n\t{\n\t  free (t);\n\t  if (invis)\n\t    VSETATTR (var, att_invisible);\t \n\t  return ((SHELL_VAR *)NULL);\n\t}\n      FREE (value_cell (var));\n      var_setvalue (var, t);\n    }\n\n  INVALIDATE_EXPORTSTR (var);\n\n  if (mark_modified_vars)\n    VSETATTR (var, att_exported);\n\n  if (exported_p (var))\n    array_needs_making = 1;\n\n  return (var);\n}\n\n \n\nSHELL_VAR *\nbind_int_variable (lhs, rhs, flags)\n     char *lhs, *rhs;\n     int flags;\n{\n  register SHELL_VAR *v;\n  int isint, isarr, implicitarray, vflags, avflags;\n\n  isint = isarr = implicitarray = 0;\n#if defined (ARRAY_VARS)\n   \n  vflags = (flags & ASS_NOEXPAND) ? VA_NOEXPAND : 0;\n  if (flags & ASS_ONEWORD)\n    vflags |= VA_ONEWORD;\n  if (valid_array_reference (lhs, vflags))\n    {\n      isarr = 1;\n      avflags = 0;\n       \n      if (flags & ASS_NOEXPAND)\n\tavflags |= AV_NOEXPAND;\n      if (flags & ASS_ONEWORD)\n\tavflags |= AV_ONEWORD;\n      v = array_variable_part (lhs, avflags, (char **)0, (int *)0);\n    }\n  else if (legal_identifier (lhs) == 0)\n    {\n      sh_invalidid (lhs);\n      return ((SHELL_VAR *)NULL);      \n    }\n  else\n#endif\n    v = find_variable (lhs);\n\n  if (v)\n    {\n      isint = integer_p (v);\n      VUNSETATTR (v, att_integer);\n#if defined (ARRAY_VARS)\n      if (array_p (v) && isarr == 0)\n\timplicitarray = 1;\n#endif\n    }\n\n#if defined (ARRAY_VARS)\n  if (isarr)\n    v = assign_array_element (lhs, rhs, flags, (array_eltstate_t *)0);\n  else if (implicitarray)\n    v = bind_array_variable (lhs, 0, rhs, 0);\t \n  else\n#endif\n    v = bind_variable (lhs, rhs, 0);\t \n\n  if (v)\n    {\n      if (isint)\n\tVSETATTR (v, att_integer);\n      VUNSETATTR (v, att_invisible);\n    }\n\n  if (v && nameref_p (v))\n    internal_warning (_(\"%s: assigning integer to name reference\"), lhs);\n     \n  return (v);\n}\n\nSHELL_VAR *\nbind_var_to_int (var, val, flags)\n     char *var;\n     intmax_t val;\n     int flags;\n{\n  char ibuf[INT_STRLEN_BOUND (intmax_t) + 1], *p;\n\n  p = fmtulong (val, 10, ibuf, sizeof (ibuf), 0);\n  return (bind_int_variable (var, p, flags));\n}\n\n \nSHELL_VAR *\nbind_function (name, value)\n     const char *name;\n     COMMAND *value;\n{\n  SHELL_VAR *entry;\n\n  entry = find_function (name);\n  if (entry == 0)\n    {\n      BUCKET_CONTENTS *elt;\n\n      elt = hash_insert (savestring (name), shell_functions, HASH_NOSRCH);\n      entry = new_shell_variable (name);\n      elt->data = (PTR_T)entry;\n    }\n  else\n    INVALIDATE_EXPORTSTR (entry);\n\n  if (var_isset (entry))\n    dispose_command (function_cell (entry));\n\n  if (value)\n    var_setfunc (entry, copy_command (value));\n  else\n    var_setfunc (entry, 0);\n\n  VSETATTR (entry, att_function);\n\n  if (mark_modified_vars)\n    VSETATTR (entry, att_exported);\n\n  VUNSETATTR (entry, att_invisible);\t\t \n\n  if (exported_p (entry))\n    array_needs_making = 1;\n\n#if defined (PROGRAMMABLE_COMPLETION)\n  set_itemlist_dirty (&it_functions);\n#endif\n\n  return (entry);\n}\n\n#if defined (DEBUGGER)\n \nvoid\nbind_function_def (name, value, flags)\n     const char *name;\n     FUNCTION_DEF *value;\n     int flags;\n{\n  FUNCTION_DEF *entry;\n  BUCKET_CONTENTS *elt;\n  COMMAND *cmd;\n\n  entry = find_function_def (name);\n  if (entry && (flags & 1))\n    {\n      dispose_function_def_contents (entry);\n      entry = copy_function_def_contents (value, entry);\n    }\n  else if (entry)\n    return;\n  else\n    {\n      cmd = value->command;\n      value->command = 0;\n      entry = copy_function_def (value);\n      value->command = cmd;\n\n      elt = hash_insert (savestring (name), shell_function_defs, HASH_NOSRCH);\n      elt->data = (PTR_T *)entry;\n    }\n}\n#endif  \n\n \nint\nassign_in_env (word, flags)\n     WORD_DESC *word;\n     int flags;\n{\n  int offset, aflags;\n  char *name, *temp, *value, *newname;\n  SHELL_VAR *var;\n  const char *string;\n\n  string = word->word;\n\n  aflags = 0;\n  offset = assignment (string, 0);\n  newname = name = savestring (string);\n  value = (char *)NULL;\n\n  if (name[offset] == '=')\n    {\n      name[offset] = 0;\n\n       \n      if (name[offset - 1] == '+')\n\t{\n\t  name[offset - 1] = '\\0';\n\t  aflags |= ASS_APPEND;\n\t}\n\n      if (legal_identifier (name) == 0)\n\t{\n\t  sh_invalidid (name);\n\t  free (name);\n\t  return (0);\n\t}\n  \n      var = find_variable (name);\n      if (var == 0)\n\t{\n\t  var = find_variable_last_nameref (name, 1);\n\t   \n\t   \n\t  if (var && nameref_p (var) && valid_nameref_value (nameref_cell (var), 2))\n\t    {\n\t      newname = nameref_cell (var);\n\t      var = 0;\t\t \n\t    }\n\t}\n      else\n        newname = name_cell (var);\t \n\t  \n      if (var && (readonly_p (var) || noassign_p (var)))\n\t{\n\t  if (readonly_p (var))\n\t    err_readonly (name);\n\t  free (name);\n  \t  return (0);\n\t}\n      temp = name + offset + 1;\n\n      value = expand_assignment_string_to_string (temp, 0);\n\n      if (var && (aflags & ASS_APPEND))\n\t{\n\t  if (value == 0)\n\t    {\n\t      value = (char *)xmalloc (1);\t \n\t      value[0] = '\\0';\n\t    }\n\t  temp = make_variable_value (var, value, aflags);\n\t  FREE (value);\n\t  value = temp;\n\t}\n    }\n\n  if (temporary_env == 0)\n    temporary_env = hash_create (TEMPENV_HASH_BUCKETS);\n\n  var = hash_lookup (newname, temporary_env);\n  if (var == 0)\n    var = make_new_variable (newname, temporary_env);\n  else\n    FREE (value_cell (var));\n\n  if (value == 0)\n    {\n      value = (char *)xmalloc (1);\t \n      value[0] = '\\0';\n    }\n\n  var_setvalue (var, value);\n  var->attributes |= (att_exported|att_tempvar);\n  var->context = variable_context;\t \n\n  INVALIDATE_EXPORTSTR (var);\n  var->exportstr = mk_env_string (newname, value, 0);\n\n  array_needs_making = 1;\n\n  if (flags)\n    {\n      if (STREQ (newname, \"POSIXLY_CORRECT\") || STREQ (newname, \"POSIX_PEDANDTIC\"))\n\tsave_posix_options ();\t\t \n      stupidly_hack_special_variables (newname);\n    }\n\n  if (echo_command_at_execute)\n     \n    xtrace_print_assignment (name, value, 0, 1);\n\n  free (name);\n  return 1;\n}\n\n \n \n \n \n \n\n#ifdef INCLUDE_UNUSED\n \nSHELL_VAR *\ncopy_variable (var)\n     SHELL_VAR *var;\n{\n  SHELL_VAR *copy = (SHELL_VAR *)NULL;\n\n  if (var)\n    {\n      copy = (SHELL_VAR *)xmalloc (sizeof (SHELL_VAR));\n\n      copy->attributes = var->attributes;\n      copy->name = savestring (var->name);\n\n      if (function_p (var))\n\tvar_setfunc (copy, copy_command (function_cell (var)));\n#if defined (ARRAY_VARS)\n      else if (array_p (var))\n\tvar_setarray (copy, array_copy (array_cell (var)));\n      else if (assoc_p (var))\n\tvar_setassoc (copy, assoc_copy (assoc_cell (var)));\n#endif\n      else if (nameref_cell (var))\t \n\tvar_setref (copy, savestring (nameref_cell (var)));\n      else if (value_cell (var))\t \n\tvar_setvalue (copy, savestring (value_cell (var)));\n      else\n\tvar_setvalue (copy, (char *)NULL);\n\n      copy->dynamic_value = var->dynamic_value;\n      copy->assign_func = var->assign_func;\n\n      copy->exportstr = COPY_EXPORTSTR (var);\n\n      copy->context = var->context;\n    }\n  return (copy);\n}\n#endif\n\n \n \n \n \n \n\n \nstatic void\ndispose_variable_value (var)\n     SHELL_VAR *var;\n{\n  if (function_p (var))\n    dispose_command (function_cell (var));\n#if defined (ARRAY_VARS)\n  else if (array_p (var))\n    array_dispose (array_cell (var));\n  else if (assoc_p (var))\n    assoc_dispose (assoc_cell (var));\n#endif\n  else if (nameref_p (var))\n    FREE (nameref_cell (var));\n  else\n    FREE (value_cell (var));\n}\n\nvoid\ndispose_variable (var)\n     SHELL_VAR *var;\n{\n  if (var == 0)\n    return;\n\n  if (nofree_p (var) == 0)\n    dispose_variable_value (var);\n\n  FREE_EXPORTSTR (var);\n\n  free (var->name);\n\n  if (exported_p (var))\n    array_needs_making = 1;\n\n  free (var);\n}\n\n \nint\nunbind_variable (name)\n     const char *name;\n{\n  SHELL_VAR *v, *nv;\n  int r;\n\n  v = var_lookup (name, shell_variables);\n  nv = (v && nameref_p (v)) ? find_variable_nameref (v) : (SHELL_VAR *)NULL;\n\n  r = nv ? makunbound (nv->name, shell_variables) : makunbound (name, shell_variables);\n  return r;\n}\n\n \nint\nunbind_nameref (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n\n  v = var_lookup (name, shell_variables);\n  if (v && nameref_p (v))\n    return makunbound (name, shell_variables);\n  return 0;\n}\n\n \nint\nunbind_variable_noref (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n\n  v = var_lookup (name, shell_variables);\n  if (v)\n    return makunbound (name, shell_variables);\n  return 0;\n}\n\nint\nunbind_global_variable (name)\n     const char *name;\n{\n  SHELL_VAR *v, *nv;\n  int r;\n\n  v = var_lookup (name, global_variables);\n   \n  nv = (v && nameref_p (v)) ? find_variable_nameref (v) : (SHELL_VAR *)NULL;\n\n  r = nv ? makunbound (nv->name, shell_variables) : makunbound (name, global_variables);\n  return r;\n}\n\nint\nunbind_global_variable_noref (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n\n  v = var_lookup (name, global_variables);\n  if (v)\n    return makunbound (name, global_variables);\n  return 0;\n}\n \nint\ncheck_unbind_variable (name)\n     const char *name;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (name);\n  if (v && readonly_p (v))\n    {\n      internal_error (_(\"%s: cannot unset: readonly %s\"), name, \"variable\");\n      return -2;\n    }\n  else if (v && non_unsettable_p (v))\n    {\n      internal_error (_(\"%s: cannot unset\"), name);\n      return -2;\n    }\n  return (unbind_variable (name));\n}\n\n \nint\nunbind_func (name)\n     const char *name;\n{\n  BUCKET_CONTENTS *elt;\n  SHELL_VAR *func;\n\n  elt = hash_remove (name, shell_functions, 0);\n\n  if (elt == 0)\n    return -1;\n\n#if defined (PROGRAMMABLE_COMPLETION)\n  set_itemlist_dirty (&it_functions);\n#endif\n\n  func = (SHELL_VAR *)elt->data;\n  if (func)\n    {\n      if (exported_p (func))\n\tarray_needs_making++;\n      dispose_variable (func);\n    }\n\n  free (elt->key);\n  free (elt);\n\n  return 0;  \n}\n\n#if defined (DEBUGGER)\nint\nunbind_function_def (name)\n     const char *name;\n{\n  BUCKET_CONTENTS *elt;\n  FUNCTION_DEF *funcdef;\n\n  elt = hash_remove (name, shell_function_defs, 0);\n\n  if (elt == 0)\n    return -1;\n\n  funcdef = (FUNCTION_DEF *)elt->data;\n  if (funcdef)\n    dispose_function_def (funcdef);\n\n  free (elt->key);\n  free (elt);\n\n  return 0;  \n}\n#endif  \n\nint\ndelete_var (name, vc)\n     const char *name;\n     VAR_CONTEXT *vc;\n{\n  BUCKET_CONTENTS *elt;\n  SHELL_VAR *old_var;\n  VAR_CONTEXT *v;\n\n  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)\n    if (elt = hash_remove (name, v->table, 0))\n      break;\n\n  if (elt == 0)\n    return (-1);\n\n  old_var = (SHELL_VAR *)elt->data;\n  free (elt->key);\n  free (elt);\n\n  dispose_variable (old_var);\n  return (0);\n}\n\n \nint\nmakunbound (name, vc)\n     const char *name;\n     VAR_CONTEXT *vc;\n{\n  BUCKET_CONTENTS *elt, *new_elt;\n  SHELL_VAR *old_var;\n  VAR_CONTEXT *v;\n  char *t;\n\n  for (elt = (BUCKET_CONTENTS *)NULL, v = vc; v; v = v->down)\n    if (elt = hash_remove (name, v->table, 0))\n      break;\n\n  if (elt == 0)\n    return (-1);\n\n  old_var = (SHELL_VAR *)elt->data;\n\n  if (old_var && exported_p (old_var))\n    array_needs_making++;\n\n   \n  if (old_var && local_p (old_var) &&\n\t(old_var->context == variable_context || (localvar_unset && old_var->context < variable_context)))\n    {\n      if (nofree_p (old_var))\n\tvar_setvalue (old_var, (char *)NULL);\n#if defined (ARRAY_VARS)\n      else if (array_p (old_var))\n\tarray_dispose (array_cell (old_var));\n      else if (assoc_p (old_var))\n\tassoc_dispose (assoc_cell (old_var));\n#endif\n      else if (nameref_p (old_var))\n\tFREE (nameref_cell (old_var));\n      else\n\tFREE (value_cell (old_var));\n        \n      old_var->attributes = (exported_p (old_var) && tempvar_p (old_var)) ? att_exported : 0;\n      VSETATTR (old_var, att_local);\n      VSETATTR (old_var, att_invisible);\n      var_setvalue (old_var, (char *)NULL);\n      INVALIDATE_EXPORTSTR (old_var);\n\n      new_elt = hash_insert (savestring (old_var->name), v->table, 0);\n      new_elt->data = (PTR_T)old_var;\n      stupidly_hack_special_variables (old_var->name);\n\n      free (elt->key);\n      free (elt);\n      return (0);\n    }\n\n   \n  t = savestring (name);\n\n  free (elt->key);\n  free (elt);\n\n  dispose_variable (old_var);\n  stupidly_hack_special_variables (t);\n  free (t);\n\n  return (0);\n}\n\n \nvoid\nkill_all_local_variables ()\n{\n  VAR_CONTEXT *vc;\n\n  for (vc = shell_variables; vc; vc = vc->down)\n    if (vc_isfuncenv (vc) && vc->scope == variable_context)\n      break;\n  if (vc == 0)\n    return;\t\t \n\n  if (vc->table && vc_haslocals (vc))\n    {\n      delete_all_variables (vc->table);\n      hash_dispose (vc->table);\n    }\n  vc->table = (HASH_TABLE *)NULL;\n}\n\nstatic void\nfree_variable_hash_data (data)\n     PTR_T data;\n{\n  SHELL_VAR *var;\n\n  var = (SHELL_VAR *)data;\n  dispose_variable (var);\n}\n\n \nvoid\ndelete_all_variables (hashed_vars)\n     HASH_TABLE *hashed_vars;\n{\n  hash_flush (hashed_vars, free_variable_hash_data);\n}\n\n \n \n \n \n \n\n#define FIND_OR_MAKE_VARIABLE(name, entry) \\\n  do \\\n    { \\\n      entry = find_variable (name); \\\n      if (!entry) \\\n\t{ \\\n\t  entry = bind_variable (name, \"\", 0); \\\n\t  if (entry) entry->attributes |= att_invisible; \\\n\t} \\\n    } \\\n  while (0)\n\n \nvoid\nset_var_read_only (name)\n     char *name;\n{\n  SHELL_VAR *entry;\n\n  FIND_OR_MAKE_VARIABLE (name, entry);\n  VSETATTR (entry, att_readonly);\n}\n\n#ifdef INCLUDE_UNUSED\n \nvoid\nset_func_read_only (name)\n     const char *name;\n{\n  SHELL_VAR *entry;\n\n  entry = find_function (name);\n  if (entry)\n    VSETATTR (entry, att_readonly);\n}\n\n \nvoid\nset_var_auto_export (name)\n     char *name;\n{\n  SHELL_VAR *entry;\n\n  FIND_OR_MAKE_VARIABLE (name, entry);\n  set_auto_export (entry);\n}\n\n \nvoid\nset_func_auto_export (name)\n     const char *name;\n{\n  SHELL_VAR *entry;\n\n  entry = find_function (name);\n  if (entry)\n    set_auto_export (entry);\n}\n#endif\n\n \n \n \n \n \n\nstatic VARLIST *\nvlist_alloc (nentries)\n     int nentries;\n{\n  VARLIST  *vlist;\n\n  vlist = (VARLIST *)xmalloc (sizeof (VARLIST));\n  vlist->list = (SHELL_VAR **)xmalloc ((nentries + 1) * sizeof (SHELL_VAR *));\n  vlist->list_size = nentries;\n  vlist->list_len = 0;\n  vlist->list[0] = (SHELL_VAR *)NULL;\n\n  return vlist;\n}\n\nstatic VARLIST *\nvlist_realloc (vlist, n)\n     VARLIST *vlist;\n     int n;\n{\n  if (vlist == 0)\n    return (vlist = vlist_alloc (n));\n  if (n > vlist->list_size)\n    {\n      vlist->list_size = n;\n      vlist->list = (SHELL_VAR **)xrealloc (vlist->list, (vlist->list_size + 1) * sizeof (SHELL_VAR *));\n    }\n  return vlist;\n}\n\nstatic void\nvlist_add (vlist, var, flags)\n     VARLIST *vlist;\n     SHELL_VAR *var;\n     int flags;\n{\n  register int i;\n\n  for (i = 0; i < vlist->list_len; i++)\n    if (STREQ (var->name, vlist->list[i]->name))\n      break;\n  if (i < vlist->list_len)\n    return;\n\n  if (i >= vlist->list_size)\n    vlist = vlist_realloc (vlist, vlist->list_size + 16);\n\n  vlist->list[vlist->list_len++] = var;\n  vlist->list[vlist->list_len] = (SHELL_VAR *)NULL;\n}\n\n \nSHELL_VAR **\nmap_over (function, vc)\n     sh_var_map_func_t *function;\n     VAR_CONTEXT *vc;\n{\n  VAR_CONTEXT *v;\n  VARLIST *vlist;\n  SHELL_VAR **ret;\n  int nentries;\n\n  for (nentries = 0, v = vc; v; v = v->down)\n    nentries += HASH_ENTRIES (v->table);\n\n  if (nentries == 0)\n    return (SHELL_VAR **)NULL;\n\n  vlist = vlist_alloc (nentries);\n\n  for (v = vc; v; v = v->down)\n    flatten (v->table, function, vlist, 0);\n\n  ret = vlist->list;\n  free (vlist);\n  return ret;\n}\n\nSHELL_VAR **\nmap_over_funcs (function)\n     sh_var_map_func_t *function;\n{\n  VARLIST *vlist;\n  SHELL_VAR **ret;\n\n  if (shell_functions == 0 || HASH_ENTRIES (shell_functions) == 0)\n    return ((SHELL_VAR **)NULL);\n\n  vlist = vlist_alloc (HASH_ENTRIES (shell_functions));\n\n  flatten (shell_functions, function, vlist, 0);\n\n  ret = vlist->list;\n  free (vlist);\n  return ret;\n}\n\n \nstatic void\nflatten (var_hash_table, func, vlist, flags)\n     HASH_TABLE *var_hash_table;\n     sh_var_map_func_t *func;\n     VARLIST *vlist;\n     int flags;\n{\n  register int i;\n  register BUCKET_CONTENTS *tlist;\n  int r;\n  SHELL_VAR *var;\n\n  if (var_hash_table == 0 || (HASH_ENTRIES (var_hash_table) == 0) || (vlist == 0 && func == 0))\n    return;\n\n  for (i = 0; i < var_hash_table->nbuckets; i++)\n    {\n      for (tlist = hash_items (i, var_hash_table); tlist; tlist = tlist->next)\n\t{\n\t  var = (SHELL_VAR *)tlist->data;\n\n\t  r = func ? (*func) (var) : 1;\n\t  if (r && vlist)\n\t    vlist_add (vlist, var, flags);\n\t}\n    }\n}\n\nvoid\nsort_variables (array)\n     SHELL_VAR **array;\n{\n  qsort (array, strvec_len ((char **)array), sizeof (SHELL_VAR *), (QSFUNC *)qsort_var_comp);\n}\n\nstatic int\nqsort_var_comp (var1, var2)\n     SHELL_VAR **var1, **var2;\n{\n  int result;\n\n  if ((result = (*var1)->name[0] - (*var2)->name[0]) == 0)\n    result = strcmp ((*var1)->name, (*var2)->name);\n\n  return (result);\n}\n\n \nstatic SHELL_VAR **\nvapply (func)\n     sh_var_map_func_t *func;\n{\n  SHELL_VAR **list;\n\n  list = map_over (func, shell_variables);\n  if (list  )\n    sort_variables (list);\n  return (list);\n}\n\n \nstatic SHELL_VAR **\nfapply (func)\n     sh_var_map_func_t *func;\n{\n  SHELL_VAR **list;\n\n  list = map_over_funcs (func);\n  if (list  )\n    sort_variables (list);\n  return (list);\n}\n\n \nSHELL_VAR **\nall_shell_variables ()\n{\n  return (vapply ((sh_var_map_func_t *)NULL));\n}\n\n \nSHELL_VAR **\nall_shell_functions ()\n{\n  return (fapply ((sh_var_map_func_t *)NULL));\n}\n\nstatic int\nvisible_var (var)\n     SHELL_VAR *var;\n{\n  return (invisible_p (var) == 0);\n}\n\nSHELL_VAR **\nall_visible_functions ()\n{\n  return (fapply (visible_var));\n}\n\nSHELL_VAR **\nall_visible_variables ()\n{\n  return (vapply (visible_var));\n}\n\n \nstatic int\nvisible_and_exported (var)\n     SHELL_VAR *var;\n{\n  return (invisible_p (var) == 0 && exported_p (var));\n}\n\n \nstatic int\nexport_environment_candidate (var)\n     SHELL_VAR *var;\n{\n  return (exported_p (var) && (invisible_p (var) == 0 || imported_p (var)));\n}\n\n \nstatic int\nlocal_and_exported (var)\n     SHELL_VAR *var;\n{\n  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context && exported_p (var));\n}\n\nSHELL_VAR **\nall_exported_variables ()\n{\n  return (vapply (visible_and_exported));\n}\n\nSHELL_VAR **\nlocal_exported_variables ()\n{\n  return (vapply (local_and_exported));\n}\n\nstatic int\nvariable_in_context (var)\n     SHELL_VAR *var;\n{\n  return (local_p (var) && var->context == variable_context);\n}\n\nstatic int\nvisible_variable_in_context (var)\n     SHELL_VAR *var;\n{\n  return (invisible_p (var) == 0 && local_p (var) && var->context == variable_context);\n}\n\nSHELL_VAR **\nall_local_variables (visible_only)\n     int visible_only;\n{\n  VARLIST *vlist;\n  SHELL_VAR **ret;\n  VAR_CONTEXT *vc;\n\n  vc = shell_variables;\n  for (vc = shell_variables; vc; vc = vc->down)\n    if (vc_isfuncenv (vc) && vc->scope == variable_context)\n      break;\n\n  if (vc == 0)\n    {\n      internal_error (_(\"all_local_variables: no function context at current scope\"));\n      return (SHELL_VAR **)NULL;\n    }\n  if (vc->table == 0 || HASH_ENTRIES (vc->table) == 0 || vc_haslocals (vc) == 0)\n    return (SHELL_VAR **)NULL;\n    \n  vlist = vlist_alloc (HASH_ENTRIES (vc->table));\n\n  if (visible_only)\n    flatten (vc->table, visible_variable_in_context, vlist, 0);\n  else\n    flatten (vc->table, variable_in_context, vlist, 0);\n\n  ret = vlist->list;\n  free (vlist);\n  if (ret)\n    sort_variables (ret);\n  return ret;\n}\n\n#if defined (ARRAY_VARS)\n \nstatic int\nvisible_array_vars (var)\n     SHELL_VAR *var;\n{\n  return (invisible_p (var) == 0 && (array_p (var) || assoc_p (var)));\n}\n\nSHELL_VAR **\nall_array_variables ()\n{\n  return (vapply (visible_array_vars));\n}\n#endif  \n\nchar **\nall_variables_matching_prefix (prefix)\n     const char *prefix;\n{\n  SHELL_VAR **varlist;\n  char **rlist;\n  int vind, rind, plen;\n\n  plen = STRLEN (prefix);\n  varlist = all_visible_variables ();\n  for (vind = 0; varlist && varlist[vind]; vind++)\n    ;\n  if (varlist == 0 || vind == 0)\n    return ((char **)NULL);\n  rlist = strvec_create (vind + 1);\n  for (vind = rind = 0; varlist[vind]; vind++)\n    {\n      if (plen == 0 || STREQN (prefix, varlist[vind]->name, plen))\n\trlist[rind++] = savestring (varlist[vind]->name);\n    }\n  rlist[rind] = (char *)0;\n  free (varlist);\n\n  return rlist;\n}\n\n \n \n \n \n \n\n \nstatic SHELL_VAR *\nbind_tempenv_variable (name, value)\n     const char *name;\n     char *value;\n{\n  SHELL_VAR *var;\n\n  var = temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL;\n\n  if (var)\n    {\n      FREE (value_cell (var));\n      var_setvalue (var, savestring (value));\n      INVALIDATE_EXPORTSTR (var);\n    }\n\n  return (var);\n}\n\n \nSHELL_VAR *\nfind_tempenv_variable (name)\n     const char *name;\n{\n  return (temporary_env ? hash_lookup (name, temporary_env) : (SHELL_VAR *)NULL);\n}\n\nchar **tempvar_list;\nint tvlist_ind;\n\n \nstatic void\npush_posix_temp_var (data)\n     PTR_T data;\n{\n  SHELL_VAR *var, *v;\n  HASH_TABLE *binding_table;\n\n  var = (SHELL_VAR *)data;\n\n   \n  v = bind_variable (var->name, value_cell (var), ASS_FORCE|ASS_NOLONGJMP);\n\n   \n\n   \n  binding_table = v->context ? shell_variables->table : global_variables->table;\n\n   \n  if (v->context == 0)\n    var->attributes &= ~(att_tempvar|att_propagate);\n\n  if (v)\n    {\n      v->attributes |= var->attributes;\t\t \n       \n      if (v->context > 0 && local_p (v) == 0)\n\tv->attributes |= att_propagate;\n      else\n\tv->attributes &= ~att_propagate;\n    }\n\n  if (find_special_var (var->name) >= 0)\n    tempvar_list[tvlist_ind++] = savestring (var->name);\n\n  dispose_variable (var);\n}\n\n \nstatic void\npush_temp_var (data)\n     PTR_T data;\n{\n  SHELL_VAR *var, *v;\n  HASH_TABLE *binding_table;\n\n  var = (SHELL_VAR *)data;\n\n  binding_table = shell_variables->table;\n  if (binding_table == 0)\n    {\n      if (shell_variables == global_variables)\n\t \n\tbinding_table = shell_variables->table = global_variables->table = hash_create (VARIABLES_HASH_BUCKETS);\n      else\n\tbinding_table = shell_variables->table = hash_create (TEMPENV_HASH_BUCKETS);\n    }\n\n  v = bind_variable_internal (var->name, value_cell (var), binding_table, 0, ASS_FORCE|ASS_NOLONGJMP);\n\n   \n  if (v)\n    v->context = shell_variables->scope;\n\n  if (binding_table == global_variables->table)\t\t \n    var->attributes &= ~(att_tempvar|att_propagate);\n  else\n    {\n      var->attributes |= att_propagate;\t\t\t \n      if  (binding_table == shell_variables->table)\n\tshell_variables->flags |= VC_HASTMPVAR;\n    }\n  if (v)\n    v->attributes |= var->attributes;\n\n  if (find_special_var (var->name) >= 0)\n    tempvar_list[tvlist_ind++] = savestring (var->name);\n\n  dispose_variable (var);\n}\n\n \nstatic void\npropagate_temp_var (data)\n     PTR_T data;\n{\n  SHELL_VAR *var;\n\n  var = (SHELL_VAR *)data;\n  if (tempvar_p (var) && (var->attributes & att_propagate))\n    push_temp_var (data);\n  else\n    {\n      if (find_special_var (var->name) >= 0)\n\ttempvar_list[tvlist_ind++] = savestring (var->name);\n      dispose_variable (var);\n    }\n}\n\n \nstatic void\ndispose_temporary_env (pushf)\n     sh_free_func_t *pushf;\n{\n  int i;\n  HASH_TABLE *disposer;\n\n  tempvar_list = strvec_create (HASH_ENTRIES (temporary_env) + 1);\n  tempvar_list[tvlist_ind = 0] = 0;\n\n  disposer = temporary_env;\n  temporary_env = (HASH_TABLE *)NULL;\n\n  hash_flush (disposer, pushf);\n  hash_dispose (disposer);\n\n  tempvar_list[tvlist_ind] = 0;\n\n  array_needs_making = 1;\n\n  for (i = 0; i < tvlist_ind; i++)\n    stupidly_hack_special_variables (tempvar_list[i]);\n\n  strvec_dispose (tempvar_list);\n  tempvar_list = 0;\n  tvlist_ind = 0;\n}\n\nvoid\ndispose_used_env_vars ()\n{\n  if (temporary_env)\n    {\n      dispose_temporary_env (propagate_temp_var);\n      maybe_make_export_env ();\n    }\n}\n\n \nvoid\nmerge_temporary_env ()\n{\n  if (temporary_env)\n    dispose_temporary_env (posixly_correct ? push_posix_temp_var : push_temp_var);\n}\n\n \nvoid\nmerge_function_temporary_env ()\n{\n  if (temporary_env)\n    dispose_temporary_env (push_temp_var);\n}\n\nvoid\nflush_temporary_env ()\n{\n  if (temporary_env)\n    {\n      hash_flush (temporary_env, free_variable_hash_data);\n      hash_dispose (temporary_env);\n      temporary_env = (HASH_TABLE *)NULL;\n    }\n}\n\n \n \n \n \n \n\nstatic inline char *\nmk_env_string (name, value, attributes)\n     const char *name, *value;\n     int attributes;\n{\n  size_t name_len, value_len;\n  char\t*p, *q, *t;\n  int isfunc, isarray;\n\n  name_len = strlen (name);\n  value_len = STRLEN (value);\n\n  isfunc = attributes & att_function;\n#if defined (ARRAY_VARS) && defined (ARRAY_EXPORT)\n  isarray = attributes & (att_array|att_assoc);\n#endif\n\n   \n  if (isfunc && value)\n    {\n      p = (char *)xmalloc (BASHFUNC_PREFLEN + name_len + BASHFUNC_SUFFLEN + value_len + 2);\n      q = p;\n      memcpy (q, BASHFUNC_PREFIX, BASHFUNC_PREFLEN);\n      q += BASHFUNC_PREFLEN;\n      memcpy (q, name, name_len);\n      q += name_len;\n      memcpy (q, BASHFUNC_SUFFIX, BASHFUNC_SUFFLEN);\n      q += BASHFUNC_SUFFLEN;\n    }\n#if defined (ARRAY_VARS) && defined (ARRAY_EXPORT)\n  else if (isarray && value)\n    {\n      if (attributes & att_assoc)\n\tp = (char *)xmalloc (BASHASSOC_PREFLEN + name_len + BASHASSOC_SUFFLEN + value_len + 2);\n      else\n\tp = (char *)xmalloc (BASHARRAY_PREFLEN + name_len + BASHARRAY_SUFFLEN + value_len + 2);\n      q = p;\n      if (attributes & att_assoc)\n\t{\n\t  memcpy (q, BASHASSOC_PREFIX, BASHASSOC_PREFLEN);\n\t  q += BASHASSOC_PREFLEN;\n\t}\n      else\n\t{\n\t  memcpy (q, BASHARRAY_PREFIX, BASHARRAY_PREFLEN);\n\t  q += BASHARRAY_PREFLEN;\n\t}\n      memcpy (q, name, name_len);\n      q += name_len;\n       \n      if (attributes & att_assoc)\n        {\n\t  memcpy (q, BASHASSOC_SUFFIX, BASHASSOC_SUFFLEN);\n\t  q += BASHARRAY_SUFFLEN;\n        }\n      else\n        {\n\t  memcpy (q, BASHARRAY_SUFFIX, BASHARRAY_SUFFLEN);\n\t  q += BASHARRAY_SUFFLEN;\n        }\n    }\n#endif  \n  else\n    {\n      p = (char *)xmalloc (2 + name_len + value_len);\n      memcpy (p, name, name_len);\n      q = p + name_len;\n    }\n\n  q[0] = '=';\n  if (value && *value)\n    {\n      if (isfunc)\n\t{\n\t  t = dequote_escapes (value);\n\t  value_len = STRLEN (t);\n\t  memcpy (q + 1, t, value_len + 1);\n\t  free (t);\n\t}\n      else\n\tmemcpy (q + 1, value, value_len + 1);\n    }\n  else\n    q[1] = '\\0';\n\n  return (p);\n}\n\n#ifdef DEBUG\n \nstatic int\nvalid_exportstr (v)\n     SHELL_VAR *v;\n{\n  char *s;\n\n  s = v->exportstr;\n  if (s == 0)\n    {\n      internal_error (_(\"%s has null exportstr\"), v->name);\n      return (0);\n    }\n  if (legal_variable_starter ((unsigned char)*s) == 0)\n    {\n      internal_error (_(\"invalid character %d in exportstr for %s\"), *s, v->name);\n      return (0);\n    }\n  for (s = v->exportstr + 1; s && *s; s++)\n    {\n      if (*s == '=')\n\tbreak;\n      if (legal_variable_char ((unsigned char)*s) == 0)\n\t{\n\t  internal_error (_(\"invalid character %d in exportstr for %s\"), *s, v->name);\n\t  return (0);\n\t}\n    }\n  if (*s != '=')\n    {\n      internal_error (_(\"no `=' in exportstr for %s\"), v->name);\n      return (0);\n    }\n  return (1);\n}\n#endif\n\n#if defined (ARRAY_VARS)\n#  define USE_EXPORTSTR (value == var->exportstr && array_p (var) == 0 && assoc_p (var) == 0)\n#else\n#  define USE_EXPORTSTR (value == var->exportstr)\n#endif\n\nstatic char **\nmake_env_array_from_var_list (vars)\n     SHELL_VAR **vars;\n{\n  register int i, list_index;\n  register SHELL_VAR *var;\n  char **list, *value;\n\n  list = strvec_create ((1 + strvec_len ((char **)vars)));\n\n  for (i = 0, list_index = 0; var = vars[i]; i++)\n    {\n#if defined (__CYGWIN__)\n       \n      INVALIDATE_EXPORTSTR (var);\n#endif\n\n       \n      if (regen_p (var) && var->dynamic_value)\n\t{\n\t  var = (*(var->dynamic_value)) (var);\n\t  INVALIDATE_EXPORTSTR (var);\n\t}\n\n      if (var->exportstr)\n\tvalue = var->exportstr;\n      else if (function_p (var))\n\tvalue = named_function_string ((char *)NULL, function_cell (var), 0);\n#if defined (ARRAY_VARS)\n      else if (array_p (var))\n#  if ARRAY_EXPORT\n\tvalue = array_to_assign (array_cell (var), 0);\n#  else\n\tcontinue;\t \n#  endif  \n      else if (assoc_p (var))\n#  if ARRAY_EXPORT\n\tvalue = assoc_to_assign (assoc_cell (var), 0);\n#  else\n\tcontinue;\t \n#  endif  \n#endif\n      else\n\tvalue = value_cell (var);\n\n      if (value)\n\t{\n\t   \n\t  list[list_index] = USE_EXPORTSTR ? savestring (value)\n\t\t\t\t\t   : mk_env_string (var->name, value, var->attributes);\n\n\t  if (USE_EXPORTSTR == 0)\n\t    SAVE_EXPORTSTR (var, list[list_index]);\n\n\t  list_index++;\n#undef USE_EXPORTSTR\n\n#if defined (ARRAY_VARS) && defined (ARRAY_EXPORT)\n\t  if (array_p (var) || assoc_p (var))\n\t    free (value);\n#endif\n\t}\n    }\n\n  list[list_index] = (char *)NULL;\n  return (list);\n}\n\n \nstatic char **\nmake_var_export_array (vcxt)\n     VAR_CONTEXT *vcxt;\n{\n  char **list;\n  SHELL_VAR **vars;\n\n#if 0\n  vars = map_over (visible_and_exported, vcxt);\n#else\n  vars = map_over (export_environment_candidate, vcxt);\n#endif\n\n  if (vars == 0)\n    return (char **)NULL;\n\n  list = make_env_array_from_var_list (vars);\n\n  free (vars);\n  return (list);\n}\n\nstatic char **\nmake_func_export_array ()\n{\n  char **list;\n  SHELL_VAR **vars;\n\n  vars = map_over_funcs (visible_and_exported);\n  if (vars == 0)\n    return (char **)NULL;\n\n  list = make_env_array_from_var_list (vars);\n\n  free (vars);\n  return (list);\n}\n\n \n#define add_to_export_env(envstr,do_alloc) \\\ndo \\\n  { \\\n    if (export_env_index >= (export_env_size - 1)) \\\n      { \\\n\texport_env_size += 16; \\\n\texport_env = strvec_resize (export_env, export_env_size); \\\n\tenviron = export_env; \\\n      } \\\n    export_env[export_env_index++] = (do_alloc) ? savestring (envstr) : envstr; \\\n    export_env[export_env_index] = (char *)NULL; \\\n  } while (0)\n\n \nchar **\nadd_or_supercede_exported_var (assign, do_alloc)\n     char *assign;\n     int do_alloc;\n{\n  register int i;\n  int equal_offset;\n\n  equal_offset = assignment (assign, 0);\n  if (equal_offset == 0)\n    return (export_env);\n\n   \n  if (assign[equal_offset + 1] == '(' &&\n     strncmp (assign + equal_offset + 2, \") {\", 3) == 0)\t\t \n    equal_offset += 4;\n\n  for (i = 0; i < export_env_index; i++)\n    {\n      if (STREQN (assign, export_env[i], equal_offset + 1))\n\t{\n\t  free (export_env[i]);\n\t  export_env[i] = do_alloc ? savestring (assign) : assign;\n\t  return (export_env);\n\t}\n    }\n  add_to_export_env (assign, do_alloc);\n  return (export_env);\n}\n\nstatic void\nadd_temp_array_to_env (temp_array, do_alloc, do_supercede)\n     char **temp_array;\n     int do_alloc, do_supercede;\n{\n  register int i;\n\n  if (temp_array == 0)\n    return;\n\n  for (i = 0; temp_array[i]; i++)\n    {\n      if (do_supercede)\n\texport_env = add_or_supercede_exported_var (temp_array[i], do_alloc);\n      else\n\tadd_to_export_env (temp_array[i], do_alloc);\n    }\n\n  free (temp_array);\n}\n\n \n\nstatic int\nn_shell_variables ()\n{\n  VAR_CONTEXT *vc;\n  int n;\n\n  for (n = 0, vc = shell_variables; vc; vc = vc->down)\n    n += HASH_ENTRIES (vc->table);\n  return n;\n}\n\nint\nchkexport (name)\n     char *name;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (name);\n  if (v && exported_p (v))\n    {\n      array_needs_making = 1;\n      maybe_make_export_env ();\n      return 1;\n    }\n  return 0;\n}\n\nvoid\nmaybe_make_export_env ()\n{\n  register char **temp_array;\n  int new_size;\n  VAR_CONTEXT *tcxt, *icxt;\n\n  if (array_needs_making)\n    {\n      if (export_env)\n\tstrvec_flush (export_env);\n\n       \n      new_size = n_shell_variables () + HASH_ENTRIES (shell_functions) + 1 +\n\t\t HASH_ENTRIES (temporary_env) + HASH_ENTRIES (invalid_env);\n      if (new_size > export_env_size)\n\t{\n\t  export_env_size = new_size;\n\t  export_env = strvec_resize (export_env, export_env_size);\n\t  environ = export_env;\n\t}\n      export_env[export_env_index = 0] = (char *)NULL;\n\n       \n      if (temporary_env)\n\t{\n\t  tcxt = new_var_context ((char *)NULL, 0);\n\t  tcxt->table = temporary_env;\n\t  tcxt->down = shell_variables;\n\t}\n      else\n\ttcxt = shell_variables;\n\n      if (invalid_env)\n\t{\n\t  icxt = new_var_context ((char *)NULL, 0);\n\t  icxt->table = invalid_env;\n\t  icxt->down = tcxt;\n\t}\n      else\n\ticxt = tcxt;\n      \n      temp_array = make_var_export_array (icxt);\n      if (temp_array)\n\tadd_temp_array_to_env (temp_array, 0, 0);\n\n      if (icxt != tcxt)\n\tfree (icxt);\n\n      if (tcxt != shell_variables)\n\tfree (tcxt);\n\n#if defined (RESTRICTED_SHELL)\n       \n      temp_array = restricted ? (char **)0 : make_func_export_array ();\n#else\n      temp_array = make_func_export_array ();\n#endif\n      if (temp_array)\n\tadd_temp_array_to_env (temp_array, 0, 0);\n\n      array_needs_making = 0;\n    }\n}\n\n \nvoid\nupdate_export_env_inplace (env_prefix, preflen, value)\n     char *env_prefix;\n     int preflen;\n     char *value;\n{\n  char *evar;\n\n  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);\n  strcpy (evar, env_prefix);\n  if (value)\n    strcpy (evar + preflen, value);\n  export_env = add_or_supercede_exported_var (evar, 0);\n}\n\n \nvoid\nput_command_name_into_env (command_name)\n     char *command_name;\n{\n  update_export_env_inplace (\"_=\", 2, command_name);\n}\n\n \n \n \n \n \n\n \n\nVAR_CONTEXT *\nnew_var_context (name, flags)\n     char *name;\n     int flags;\n{\n  VAR_CONTEXT *vc;\n\n  vc = (VAR_CONTEXT *)xmalloc (sizeof (VAR_CONTEXT));\n  vc->name = name ? savestring (name) : (char *)NULL;\n  vc->scope = variable_context;\n  vc->flags = flags;\n\n  vc->up = vc->down = (VAR_CONTEXT *)NULL;\n  vc->table = (HASH_TABLE *)NULL;\n\n  return vc;\n}\n\n \nvoid\ndispose_var_context (vc)\n     VAR_CONTEXT *vc;\n{\n  FREE (vc->name);\n\n  if (vc->table)\n    {\n      delete_all_variables (vc->table);\n      hash_dispose (vc->table);\n    }\n\n  free (vc);\n}\n\n \nstatic int\nset_context (var)\n     SHELL_VAR *var;\n{\n  return (var->context = variable_context);\n}\n\n \nVAR_CONTEXT *\npush_var_context (name, flags, tempvars)\n     char *name;\n     int flags;\n     HASH_TABLE *tempvars;\n{\n  VAR_CONTEXT *vc;\n  int posix_func_behavior;\n\n   \n  posix_func_behavior = 0;\n\n  vc = new_var_context (name, flags);\n   \n  if (posix_func_behavior && (flags & VC_FUNCENV) && tempvars == temporary_env)\n    merge_temporary_env ();\n  else if (tempvars)\n    {\n      vc->table = tempvars;\n       \n       \n      flatten (tempvars, set_context, (VARLIST *)NULL, 0);\n      vc->flags |= VC_HASTMPVAR;\n    }\n  vc->down = shell_variables;\n  shell_variables->up = vc;\n\n  return (shell_variables = vc);\n}\n\n \n\nstatic inline void\npush_posix_tempvar_internal (var, isbltin)\n     SHELL_VAR *var;\n     int isbltin;\n{\n  SHELL_VAR *v;\n  int posix_var_behavior;\n\n   \n  posix_var_behavior = posixly_correct && isbltin;\n  v = 0;\n\n  if (local_p (var) && STREQ (var->name, \"-\"))\n    {\n      set_current_options (value_cell (var));\n      set_shellopts ();\n    }\n   \n  else if (tempvar_p (var) && posix_var_behavior)\n    {\n       \n      v = bind_variable (var->name, value_cell (var), ASS_FORCE|ASS_NOLONGJMP);\n      if (v)\n\t{\n\t  v->attributes |= var->attributes;\n\t  if (v->context == 0)\n\t    v->attributes &= ~(att_tempvar|att_propagate);\n\t   \n\t}\n    }\n  else if (tempvar_p (var) && propagate_p (var))\n    {\n       \n      if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->table == 0)\n\tshell_variables->table = hash_create (VARIABLES_HASH_BUCKETS);\n      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);\n       \n      if (v)\n\tv->context = shell_variables->scope;\n      if (shell_variables == global_variables)\n\tvar->attributes &= ~(att_tempvar|att_propagate);\n      else\n\tshell_variables->flags |= VC_HASTMPVAR;\n      if (v)\n\tv->attributes |= var->attributes;\n    }\n  else\n    stupidly_hack_special_variables (var->name);\t \n\n#if defined (ARRAY_VARS)\n  if (v && (array_p (var) || assoc_p (var)))\n    {\n      FREE (value_cell (v));\n      if (array_p (var))\n\tvar_setarray (v, array_copy (array_cell (var)));\n      else\n\tvar_setassoc (v, assoc_copy (assoc_cell (var)));\n    }\n#endif\t  \n\n  dispose_variable (var);\n}\n\nstatic void\npush_func_var (data)\n     PTR_T data;\n{\n  SHELL_VAR *var;\n\n  var = (SHELL_VAR *)data;\n  push_posix_tempvar_internal (var, 0);\n}\n\nstatic void\npush_builtin_var (data)\n     PTR_T data;\n{\n  SHELL_VAR *var;\n\n  var = (SHELL_VAR *)data;\n  push_posix_tempvar_internal (var, 1);\n}\n\n \nvoid\npop_var_context ()\n{\n  VAR_CONTEXT *ret, *vcxt;\n\n  vcxt = shell_variables;\n  if (vc_isfuncenv (vcxt) == 0)\n    {\n      internal_error (_(\"pop_var_context: head of shell_variables not a function context\"));\n      return;\n    }\n\n  if (ret = vcxt->down)\n    {\n      ret->up = (VAR_CONTEXT *)NULL;\n      shell_variables = ret;\n      if (vcxt->table)\n\thash_flush (vcxt->table, push_func_var);\n      dispose_var_context (vcxt);\n    }\n  else\n    internal_error (_(\"pop_var_context: no global_variables context\"));\n}\n\nstatic void\ndelete_local_contexts (vcxt)\n     VAR_CONTEXT *vcxt;\n{\n  VAR_CONTEXT *v, *t;\n\n  for (v = vcxt; v != global_variables; v = t)\n    {\n      t = v->down;\n      dispose_var_context (v);\n    }\n}\n\n \nvoid\ndelete_all_contexts (vcxt)\n     VAR_CONTEXT *vcxt;\n{\n  delete_local_contexts (vcxt);\n  delete_all_variables (global_variables->table);\n  shell_variables = global_variables;\n}\n\n \nvoid\nreset_local_contexts ()\n{\n  delete_local_contexts (shell_variables);\n  shell_variables = global_variables;\n  variable_context = 0;\n}\n\n \n \n \n \n \n\nVAR_CONTEXT *\npush_scope (flags, tmpvars)\n     int flags;\n     HASH_TABLE *tmpvars;\n{\n  return (push_var_context ((char *)NULL, flags, tmpvars));\n}\n\nstatic void\npush_exported_var (data)\n     PTR_T data;\n{\n  SHELL_VAR *var, *v;\n\n  var = (SHELL_VAR *)data;\n\n   \n   \n  if (tempvar_p (var) && exported_p (var) && (var->attributes & att_propagate))\n    {\n      var->attributes &= ~att_tempvar;\t\t \n      v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);\n      if (shell_variables == global_variables)\n\tvar->attributes &= ~att_propagate;\n      if (v)\n\t{\n\t  v->attributes |= var->attributes;\n\t  v->context = shell_variables->scope;\n\t}\n    }\n  else\n    stupidly_hack_special_variables (var->name);\t \n\n  dispose_variable (var);\n}\n\n \nvoid\npop_scope (is_special)\n     int is_special;\n{\n  VAR_CONTEXT *vcxt, *ret;\n  int is_bltinenv;\n\n  vcxt = shell_variables;\n  if (vc_istempscope (vcxt) == 0)\n    {\n      internal_error (_(\"pop_scope: head of shell_variables not a temporary environment scope\"));\n      return;\n    }\n  is_bltinenv = vc_isbltnenv (vcxt);\t \n\n  ret = vcxt->down;\n  if (ret)\n    ret->up = (VAR_CONTEXT *)NULL;\n\n  shell_variables = ret;\n\n   \n  FREE (vcxt->name);\n  if (vcxt->table)\n    {\n      if (is_special)\n\thash_flush (vcxt->table, push_builtin_var);\n      else\n\thash_flush (vcxt->table, push_exported_var);\n      hash_dispose (vcxt->table);\n    }\n  free (vcxt);\n\n  sv_ifs (\"IFS\");\t \n}\n\n \n \n \n \n \n\nstruct saved_dollar_vars {\n  char **first_ten;\n  WORD_LIST *rest;\n  int count;\n};\n\nstatic struct saved_dollar_vars *dollar_arg_stack = (struct saved_dollar_vars *)NULL;\nstatic int dollar_arg_stack_slots;\nstatic int dollar_arg_stack_index;\n\n \nstatic char **\nsave_dollar_vars ()\n{\n  char **ret;\n  int i;\n\n  ret = strvec_create (10);\n  for (i = 1; i < 10; i++)\n    {\n      ret[i] = dollar_vars[i];\n      dollar_vars[i] = (char *)NULL;\n    }\n  return ret;\n}\n\nstatic void\nrestore_dollar_vars (args)\n     char **args;\n{\n  int i;\n\n  for (i = 1; i < 10; i++)\n    dollar_vars[i] = args[i];\n}\n\nstatic void\nfree_dollar_vars ()\n{\n  int i;\n\n  for (i = 1; i < 10; i++)\n    {\n      FREE (dollar_vars[i]);\n      dollar_vars[i] = (char *)NULL;\n    }\n}\n\nstatic void\nfree_saved_dollar_vars (args)\n     char **args;\n{\n  int i;\n\n  for (i = 1; i < 10; i++)\n    FREE (args[i]);\n}\n\n \nvoid\nclear_dollar_vars ()\n{\n  free_dollar_vars ();\n  dispose_words (rest_of_args);\n\n  rest_of_args = (WORD_LIST *)NULL;\n  posparam_count = 0;\n}\n\n \nvoid\npush_context (name, is_subshell, tempvars)\n     char *name;\t \n     int is_subshell;\n     HASH_TABLE *tempvars;\n{\n  if (is_subshell == 0)\n    push_dollar_vars ();\n  variable_context++;\n  push_var_context (name, VC_FUNCENV, tempvars);\n}\n\n \nvoid\npop_context ()\n{\n  pop_dollar_vars ();\n  variable_context--;\n  pop_var_context ();\n\n  sv_ifs (\"IFS\");\t\t \n}\n\n \nvoid\npush_dollar_vars ()\n{\n  if (dollar_arg_stack_index + 2 > dollar_arg_stack_slots)\n    {\n      dollar_arg_stack = (struct saved_dollar_vars *)\n\txrealloc (dollar_arg_stack, (dollar_arg_stack_slots += 10)\n\t\t  * sizeof (struct saved_dollar_vars));\n    }\n\n  dollar_arg_stack[dollar_arg_stack_index].count = posparam_count;\n  dollar_arg_stack[dollar_arg_stack_index].first_ten = save_dollar_vars ();\n  dollar_arg_stack[dollar_arg_stack_index++].rest = rest_of_args;\n  rest_of_args = (WORD_LIST *)NULL;\n  posparam_count = 0;\n  \n  dollar_arg_stack[dollar_arg_stack_index].first_ten = (char **)NULL;\n  dollar_arg_stack[dollar_arg_stack_index].rest = (WORD_LIST *)NULL;  \n}\n\n \nvoid\npop_dollar_vars ()\n{\n  if (dollar_arg_stack == 0 || dollar_arg_stack_index == 0)\n    return;\n\n   \n  clear_dollar_vars ();\n\n  rest_of_args = dollar_arg_stack[--dollar_arg_stack_index].rest;\n  restore_dollar_vars (dollar_arg_stack[dollar_arg_stack_index].first_ten);\n  free (dollar_arg_stack[dollar_arg_stack_index].first_ten);\n  posparam_count = dollar_arg_stack[dollar_arg_stack_index].count;\n\n  dollar_arg_stack[dollar_arg_stack_index].first_ten = (char **)NULL;\n  dollar_arg_stack[dollar_arg_stack_index].rest = (WORD_LIST *)NULL;\n  dollar_arg_stack[dollar_arg_stack_index].count = 0;\n\n  set_dollar_vars_unchanged ();\n  invalidate_cached_quoted_dollar_at ();\n}\n\nvoid\ndispose_saved_dollar_vars ()\n{\n  if (dollar_arg_stack == 0 || dollar_arg_stack_index == 0)\n    return;\n\n  dispose_words (dollar_arg_stack[--dollar_arg_stack_index].rest);    \n  free_saved_dollar_vars (dollar_arg_stack[dollar_arg_stack_index].first_ten);\t\n  free (dollar_arg_stack[dollar_arg_stack_index].first_ten);\n\n  dollar_arg_stack[dollar_arg_stack_index].first_ten = (char **)NULL;  \n  dollar_arg_stack[dollar_arg_stack_index].rest = (WORD_LIST *)NULL;\n  dollar_arg_stack[dollar_arg_stack_index].count = 0;\n}\n\n \nvoid\ninit_bash_argv ()\n{\n  if (bash_argv_initialized == 0)\n    {\n      save_bash_argv ();\n      bash_argv_initialized = 1;\n    }\n}\n\nvoid\nsave_bash_argv ()\n{\n  WORD_LIST *list;\n\n  list = list_rest_of_args ();\n  push_args (list);\n  dispose_words (list);\n}\n\n \n\nvoid\npush_args (list)\n     WORD_LIST *list;\n{\n#if defined (ARRAY_VARS) && defined (DEBUGGER)\n  SHELL_VAR *bash_argv_v, *bash_argc_v;\n  ARRAY *bash_argv_a, *bash_argc_a;\n  WORD_LIST *l;\n  arrayind_t i;\n  char *t;\n\n  GET_ARRAY_FROM_VAR (\"BASH_ARGV\", bash_argv_v, bash_argv_a);\n  GET_ARRAY_FROM_VAR (\"BASH_ARGC\", bash_argc_v, bash_argc_a);\n\n  for (l = list, i = 0; l; l = l->next, i++)\n    array_push (bash_argv_a, l->word->word);\n\n  t = itos (i);\n  array_push (bash_argc_a, t);\n  free (t);\n#endif  \n}\n\n \nvoid\npop_args ()\n{\n#if defined (ARRAY_VARS) && defined (DEBUGGER)\n  SHELL_VAR *bash_argv_v, *bash_argc_v;\n  ARRAY *bash_argv_a, *bash_argc_a;\n  ARRAY_ELEMENT *ce;\n  intmax_t i;\n\n  GET_ARRAY_FROM_VAR (\"BASH_ARGV\", bash_argv_v, bash_argv_a);\n  GET_ARRAY_FROM_VAR (\"BASH_ARGC\", bash_argc_v, bash_argc_a);\n\n  ce = array_unshift_element (bash_argc_a);\n  if (ce == 0 || legal_number (element_value (ce), &i) == 0)\n    i = 0;\n\n  for ( ; i > 0; i--)\n    array_pop (bash_argv_a);\n  array_dispose_element (ce);\n#endif  \n}\n\n \n\n \n\n \n\n#define SET_INT_VAR(name, intvar)  intvar = find_variable (name) != 0\n\n \nstruct name_and_function {\n  char *name;\n  sh_sv_func_t *function;\n};\n\nstatic struct name_and_function special_vars[] = {\n  { \"BASH_COMPAT\", sv_shcompat },\n  { \"BASH_XTRACEFD\", sv_xtracefd },\n\n#if defined (JOB_CONTROL)\n  { \"CHILD_MAX\", sv_childmax },\n#endif\n\n#if defined (READLINE)\n#  if defined (STRICT_POSIX)\n  { \"COLUMNS\", sv_winsize },\n#  endif\n  { \"COMP_WORDBREAKS\", sv_comp_wordbreaks },\n#endif\n\n  { \"EXECIGNORE\", sv_execignore },\n\n  { \"FUNCNEST\", sv_funcnest },\n\n  { \"GLOBIGNORE\", sv_globignore },\n\n#if defined (HISTORY)\n  { \"HISTCONTROL\", sv_history_control },\n  { \"HISTFILESIZE\", sv_histsize },\n  { \"HISTIGNORE\", sv_histignore },\n  { \"HISTSIZE\", sv_histsize },\n  { \"HISTTIMEFORMAT\", sv_histtimefmt },\n#endif\n\n#if defined (__CYGWIN__)\n  { \"HOME\", sv_home },\n#endif\n\n#if defined (READLINE)\n  { \"HOSTFILE\", sv_hostfile },\n#endif\n\n  { \"IFS\", sv_ifs },\n  { \"IGNOREEOF\", sv_ignoreeof },\n\n  { \"LANG\", sv_locale },\n  { \"LC_ALL\", sv_locale },\n  { \"LC_COLLATE\", sv_locale },\n  { \"LC_CTYPE\", sv_locale },\n  { \"LC_MESSAGES\", sv_locale },\n  { \"LC_NUMERIC\", sv_locale },\n  { \"LC_TIME\", sv_locale },\n\n#if defined (READLINE) && defined (STRICT_POSIX)\n  { \"LINES\", sv_winsize },\n#endif\n\n  { \"MAIL\", sv_mail },\n  { \"MAILCHECK\", sv_mail },\n  { \"MAILPATH\", sv_mail },\n\n  { \"OPTERR\", sv_opterr },\n  { \"OPTIND\", sv_optind },\n\n  { \"PATH\", sv_path },\n  { \"POSIXLY_CORRECT\", sv_strict_posix },\n\n#if defined (READLINE)\n  { \"TERM\", sv_terminal },\n  { \"TERMCAP\", sv_terminal },\n  { \"TERMINFO\", sv_terminal },\n#endif  \n\n  { \"TEXTDOMAIN\", sv_locale },\n  { \"TEXTDOMAINDIR\", sv_locale },\n\n#if defined (HAVE_TZSET)\n  { \"TZ\", sv_tz },\n#endif\n\n#if defined (HISTORY) && defined (BANG_HISTORY)\n  { \"histchars\", sv_histchars },\n#endif  \n\n  { \"ignoreeof\", sv_ignoreeof },\n\n  { (char *)0, (sh_sv_func_t *)0 }\n};\n\n#define N_SPECIAL_VARS\t(sizeof (special_vars) / sizeof (special_vars[0]) - 1)\n\nstatic int\nsv_compare (sv1, sv2)\n     struct name_and_function *sv1, *sv2;\n{\n  int r;\n\n  if ((r = sv1->name[0] - sv2->name[0]) == 0)\n    r = strcmp (sv1->name, sv2->name);\n  return r;\n}\n\nstatic inline int\nfind_special_var (name)\n     const char *name;\n{\n  register int i, r;\n\n  for (i = 0; special_vars[i].name; i++)\n    {\n      r = special_vars[i].name[0] - name[0];\n      if (r == 0)\n\tr = strcmp (special_vars[i].name, name);\n      if (r == 0)\n\treturn i;\n      else if (r > 0)\n\t \n\tbreak;\n    }\n  return -1;\n}\n\n \nvoid\nstupidly_hack_special_variables (name)\n     char *name;\n{\n  static int sv_sorted = 0;\n  int i;\n\n  if (sv_sorted == 0)\t \n    {\n      qsort (special_vars, N_SPECIAL_VARS, sizeof (special_vars[0]),\n\t\t(QSFUNC *)sv_compare);\n      sv_sorted = 1;\n    }\n\n  i = find_special_var (name);\n  if (i != -1)\n    (*(special_vars[i].function)) (name);\n}\n\n \nvoid\nreinit_special_variables ()\n{\n#if defined (READLINE)\n  sv_comp_wordbreaks (\"COMP_WORDBREAKS\");\n#endif\n  sv_globignore (\"GLOBIGNORE\");\n  sv_opterr (\"OPTERR\");\n}\n\nvoid\nsv_ifs (name)\n     char *name;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (\"IFS\");\n  setifs (v);\n}\n\n \nvoid\nsv_path (name)\n     char *name;\n{\n   \n  phash_flush ();\n}\n\n \nvoid\nsv_mail (name)\n     char *name;\n{\n   \n  if (name[4] == 'C')   \n    reset_mail_timer ();\n  else\n    {\n      free_mail_files ();\n      remember_mail_dates ();\n    }\n}\n\nvoid\nsv_funcnest (name)\n     char *name;\n{\n  SHELL_VAR *v;\n  intmax_t num;\n\n  v = find_variable (name);\n  if (v == 0)\n    funcnest_max = 0;\n  else if (legal_number (value_cell (v), &num) == 0)\n    funcnest_max = 0;\n  else\n    funcnest_max = num;\n}\n\n \nvoid\nsv_execignore (name)\n     char *name;\n{\n  setup_exec_ignore (name);\n}\n\n \nvoid\nsv_globignore (name)\n     char *name;\n{\n  if (privileged_mode == 0)\n    setup_glob_ignore (name);\n}\n\n#if defined (READLINE)\nvoid\nsv_comp_wordbreaks (name)\n     char *name;\n{\n  SHELL_VAR *sv;\n\n  sv = find_variable (name);\n  if (sv == 0)\n    reset_completer_word_break_chars ();\n}\n\n \nvoid\nsv_terminal (name)\n     char *name;\n{\n  if (interactive_shell && no_line_editing == 0)\n    rl_reset_terminal (get_string_value (\"TERM\"));\n}\n\nvoid\nsv_hostfile (name)\n     char *name;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (name);\n  if (v == 0)\n    clear_hostname_list ();\n  else\n    hostname_list_initialized = 0;\n}\n\n#if defined (STRICT_POSIX)\n \nvoid\nsv_winsize (name)\n     char *name;\n{\n  SHELL_VAR *v;\n  intmax_t xd;\n  int d;\n\n  if (posixly_correct == 0 || interactive_shell == 0 || no_line_editing)\n    return;\n\n  v = find_variable (name);\n  if (v == 0 || var_isset (v) == 0)\n    rl_reset_screen_size ();\n  else\n    {\n      if (legal_number (value_cell (v), &xd) == 0)\n\treturn;\n      winsize_assignment = 1;\n      d = xd;\t\t\t \n      if (name[0] == 'L')\t \n\trl_set_screen_size (d, -1);\n      else\t\t\t \n\trl_set_screen_size (-1, d);\n      winsize_assignment = 0;\n    }\n}\n#endif  \n#endif  \n\n \n#if defined (__CYGWIN__)\nsv_home (name)\n     char *name;\n{\n  array_needs_making = 1;\n  maybe_make_export_env ();\n}\n#endif\n\n#if defined (HISTORY)\n \nvoid\nsv_histsize (name)\n     char *name;\n{\n  char *temp;\n  intmax_t num;\n  int hmax;\n\n  temp = get_string_value (name);\n\n  if (temp && *temp)\n    {\n      if (legal_number (temp, &num))\n\t{\n\t  hmax = num;\n\t  if (hmax < 0 && name[4] == 'S')\n\t    unstifle_history ();\t \n\t  else if (name[4] == 'S')\n\t    {\n\t      stifle_history (hmax);\n\t      hmax = where_history ();\n\t      if (history_lines_this_session > hmax)\n\t\thistory_lines_this_session = hmax;\n\t    }\n\t  else if (hmax >= 0)\t \n\t    {\n\t      history_truncate_file (get_string_value (\"HISTFILE\"), hmax);\n\t       \n\t      if (hmax < history_lines_in_file)\n\t\thistory_lines_in_file = hmax;\n\t    }\n\t}\n    }\n  else if (name[4] == 'S')\n    unstifle_history ();\n}\n\n \nvoid\nsv_histignore (name)\n     char *name;\n{\n  setup_history_ignore (name);\n}\n\n \nvoid\nsv_history_control (name)\n     char *name;\n{\n  char *temp;\n  char *val;\n  int tptr;\n\n  history_control = 0;\n  temp = get_string_value (name);\n\n  if (temp == 0 || *temp == 0)\n    return;\n\n  tptr = 0;\n  while (val = extract_colon_unit (temp, &tptr))\n    {\n      if (STREQ (val, \"ignorespace\"))\n\thistory_control |= HC_IGNSPACE;\n      else if (STREQ (val, \"ignoredups\"))\n\thistory_control |= HC_IGNDUPS;\n      else if (STREQ (val, \"ignoreboth\"))\n\thistory_control |= HC_IGNBOTH;\n      else if (STREQ (val, \"erasedups\"))\n\thistory_control |= HC_ERASEDUPS;\n\n      free (val);\n    }\n}\n\n#if defined (BANG_HISTORY)\n \nvoid\nsv_histchars (name)\n     char *name;\n{\n  char *temp;\n\n  temp = get_string_value (name);\n  if (temp)\n    {\n      history_expansion_char = *temp;\n      if (temp[0] && temp[1])\n\t{\n\t  history_subst_char = temp[1];\n\t  if (temp[2])\n\t      history_comment_char = temp[2];\n\t}\n    }\n  else\n    {\n      history_expansion_char = '!';\n      history_subst_char = '^';\n      history_comment_char = '#';\n    }\n}\n#endif  \n\nvoid\nsv_histtimefmt (name)\n     char *name;\n{\n  SHELL_VAR *v;\n\n  if (v = find_variable (name))\n    {\n      if (history_comment_char == 0)\n\thistory_comment_char = '#';\n    }\n  history_write_timestamps = (v != 0);\n}\n#endif  \n\n#if defined (HAVE_TZSET)\nvoid\nsv_tz (name)\n     char *name;\n{\n  SHELL_VAR *v;\n\n  v = find_variable (name);\n  if (v && exported_p (v))\n    array_needs_making = 1;\n  else if (v == 0)\n    array_needs_making = 1;\n\n  if (array_needs_making)\n    {\n      maybe_make_export_env ();  \n      tzset ();\n    }\n}\n#endif\n\n \nvoid\nsv_ignoreeof (name)\n     char *name;\n{\n  SHELL_VAR *tmp_var;\n  char *temp;\n\n  eof_encountered = 0;\n\n  tmp_var = find_variable (name);\n  ignoreeof = tmp_var && var_isset (tmp_var);\n  temp = tmp_var ? value_cell (tmp_var) : (char *)NULL;\n  if (temp)\n    eof_encountered_limit = (*temp && all_digits (temp)) ? atoi (temp) : 10;\n  set_shellopts ();\t \n}\n\nvoid\nsv_optind (name)\n     char *name;\n{\n  SHELL_VAR *var;\n  char *tt;\n  int s;\n\n  var = find_variable (\"OPTIND\");\n  tt = var ? get_variable_value (var) : (char *)NULL;\n\n   \n  if (tt && *tt)\n    {\n      s = atoi (tt);\n\n       \n      if (s < 0 || s == 1)\n\ts = 0;\n    }\n  else\n    s = 0;\n  getopts_reset (s);\n}\n\nvoid\nsv_opterr (name)\n     char *name;\n{\n  char *tt;\n\n  tt = get_string_value (\"OPTERR\");\n  sh_opterr = (tt && *tt) ? atoi (tt) : 1;\n}\n\nvoid\nsv_strict_posix (name)\n     char *name;\n{\n  SHELL_VAR *var;\n\n  var = find_variable (name);\n  posixly_correct = var && var_isset (var);\n  posix_initialize (posixly_correct);\n#if defined (READLINE)\n  if (interactive_shell)\n    posix_readline_initialize (posixly_correct);\n#endif  \n  set_shellopts ();\t \n}\n\nvoid\nsv_locale (name)\n     char *name;\n{\n  char *v;\n  int r;\n\n  v = get_string_value (name);\n  if (name[0] == 'L' && name[1] == 'A')\t \n    r = set_lang (name, v);\n  else\n    r = set_locale_var (name, v);\t\t \n\n#if 1\n  if (r == 0 && posixly_correct)\n    set_exit_status (EXECUTION_FAILURE);\n#endif\n}\n\n#if defined (ARRAY_VARS)\nvoid\nset_pipestatus_array (ps, nproc)\n     int *ps;\n     int nproc;\n{\n  SHELL_VAR *v;\n  ARRAY *a;\n  ARRAY_ELEMENT *ae;\n  register int i;\n  char *t, tbuf[INT_STRLEN_BOUND(int) + 1];\n\n  v = find_variable (\"PIPESTATUS\");\n  if (v == 0)\n    v = make_new_array_variable (\"PIPESTATUS\");\n  if (array_p (v) == 0)\n    return;\t\t \n  a = array_cell (v);\n\n  if (a == 0 || array_num_elements (a) == 0)\n    {\n      for (i = 0; i < nproc; i++)\t \n\t{\n\t  t = inttostr (ps[i], tbuf, sizeof (tbuf));\n\t  array_insert (a, i, t);\n\t}\n      return;\n    }\n\n   \n  if (array_num_elements (a) == nproc && nproc == 1)\n    {\n#ifndef ALT_ARRAY_IMPLEMENTATION\n      ae = element_forw (a->head);\n#else\n      ae = a->elements[0];\n#endif\n      ARRAY_ELEMENT_REPLACE (ae, itos (ps[0]));\n    }\n  else if (array_num_elements (a) <= nproc)\n    {\n       \n#ifndef ALT_ARRAY_IMPLEMENTATION\n      ae = a->head;\n#endif\n      for (i = 0; i < array_num_elements (a); i++)\n\t{\n#ifndef ALT_ARRAY_IMPLEMENTATION\n\t  ae = element_forw (ae);\n#else\n\t  ae = a->elements[i];\n#endif\n\t  ARRAY_ELEMENT_REPLACE (ae, itos (ps[i]));\n\t}\n       \n      for ( ; i < nproc; i++)\n\t{\n\t  t = inttostr (ps[i], tbuf, sizeof (tbuf));\n\t  array_insert (a, i, t);\n\t}\n    }\n  else\n    {\n#ifndef ALT_ARRAY_IMPLEMENTATION\n       \t  \n      array_flush (a);\n      for (i = 0; i < nproc; i++)\n\t{\n\t  t = inttostr (ps[i], tbuf, sizeof (tbuf));\n\t  array_insert (a, i, t);\n\t}\n#else\n       \n      for (i = 0; i < nproc; i++)\n\t{\n\t  ae = a->elements[i];\n\t  ARRAY_ELEMENT_REPLACE (ae, itos (ps[i]));\n\t}\n      for ( ; i <= array_max_index (a); i++)\n\t{\n\t  array_dispose_element (a->elements[i]);\n\t  a->elements[i] = (ARRAY_ELEMENT *)NULL;\n\t}\n\n       \n      set_max_index (a, nproc - 1);\n      set_first_index (a, 0);\n      set_num_elements (a, nproc);\n#endif  \n    }\n}\n\nARRAY *\nsave_pipestatus_array ()\n{\n  SHELL_VAR *v;\n  ARRAY *a;\n\n  v = find_variable (\"PIPESTATUS\");\n  if (v == 0 || array_p (v) == 0 || array_cell (v) == 0)\n    return ((ARRAY *)NULL);\n    \n  a = array_copy (array_cell (v));\n\n  return a;\n}\n\nvoid\nrestore_pipestatus_array (a)\n     ARRAY *a;\n{\n  SHELL_VAR *v;\n  ARRAY *a2;\n\n  v = find_variable (\"PIPESTATUS\");\n   \n  if (v == 0 || array_p (v) == 0 || array_cell (v) == 0)\n    return;\n\n  a2 = array_cell (v);\n  var_setarray (v, a); \n\n  array_dispose (a2);\n}\n#endif\n\nvoid\nset_pipestatus_from_exit (s)\n     int s;\n{\n#if defined (ARRAY_VARS)\n  static int v[2] = { 0, -1 };\n\n  v[0] = s;\n  set_pipestatus_array (v, 1);\n#endif\n}\n\nvoid\nsv_xtracefd (name)\n     char *name;\n{\n  SHELL_VAR *v;\n  char *t, *e;\n  int fd;\n  FILE *fp;\n\n  v = find_variable (name);\n  if (v == 0)\n    {\n      xtrace_reset ();\n      return;\n    }\n\n  t = value_cell (v);\n  if (t == 0 || *t == 0)\n    xtrace_reset ();\n  else\n    {\n      fd = (int)strtol (t, &e, 10);\n      if (e != t && *e == '\\0' && sh_validfd (fd))\n\t{\n\t  fp = fdopen (fd, \"w\");\n\t  if (fp == 0)\n\t    internal_error (_(\"%s: %s: cannot open as FILE\"), name, value_cell (v));\n\t  else\n\t    xtrace_set (fd, fp);\n\t}\n      else\n\tinternal_error (_(\"%s: %s: invalid value for trace file descriptor\"), name, value_cell (v));\n    }\n}\n\n#define MIN_COMPAT_LEVEL 31\n\nvoid\nsv_shcompat (name)\n     char *name;\n{\n  SHELL_VAR *v;\n  char *val;\n  int tens, ones, compatval;\n\n  v = find_variable (name);\n  if (v == 0)\n    {\n      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;\n      set_compatibility_opts ();\n      return;\n    }\n  val = value_cell (v);\n  if (val == 0 || *val == '\\0')\n    {\n      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;\n      set_compatibility_opts ();\n      return;\n    }\n   \n  if (ISDIGIT (val[0]) && val[1] == '.' && ISDIGIT (val[2]) && val[3] == 0)\n    {\n      tens = val[0] - '0';\n      ones = val[2] - '0';\n      compatval = tens*10 + ones;\n    }\n   \n  else if (ISDIGIT (val[0]) && ISDIGIT (val[1]) && val[2] == 0)\n    {\n      tens = val[0] - '0';\n      ones = val[1] - '0';\n      compatval = tens*10 + ones;\n    }\n  else\n    {\ncompat_error:\n      internal_error (_(\"%s: %s: compatibility value out of range\"), name, val);\n      shell_compatibility_level = DEFAULT_COMPAT_LEVEL;\n      set_compatibility_opts ();\n      return;\n    }\n\n  if (compatval < MIN_COMPAT_LEVEL || compatval > DEFAULT_COMPAT_LEVEL)\n    goto compat_error;\n\n  shell_compatibility_level = compatval;\n  set_compatibility_opts ();\n}\n\n#if defined (JOB_CONTROL)\nvoid\nsv_childmax (name)\n     char *name;\n{\n  char *tt;\n  int s;\n\n  tt = get_string_value (name);\n  s = (tt && *tt) ? atoi (tt) : 0;\n  set_maxchild (s);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}