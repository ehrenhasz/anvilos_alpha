{
  "module_name": "subst.c",
  "hash_id": "7d8563236622cd0bebd94b4e268ea2be53799f78125b2ff79d39d4152153dc5d",
  "original_prompt": "Ingested from bash-5.2.21/subst.c",
  "human_readable_source": " \n\n \n\n \n\n#include \"config.h\"\n\n#include \"bashtypes.h\"\n#include <stdio.h>\n#include \"chartypes.h\"\n#if defined (HAVE_PWD_H)\n#  include <pwd.h>\n#endif\n#include <signal.h>\n#include <errno.h>\n\n#if defined (HAVE_UNISTD_H)\n#  include <unistd.h>\n#endif\n\n#define NEED_FPURGE_DECL\n\n#include \"bashansi.h\"\n#include \"posixstat.h\"\n#include \"bashintl.h\"\n\n#include \"shell.h\"\n#include \"parser.h\"\n#include \"redir.h\"\n#include \"flags.h\"\n#include \"jobs.h\"\n#include \"execute_cmd.h\"\n#include \"filecntl.h\"\n#include \"trap.h\"\n#include \"pathexp.h\"\n#include \"mailcheck.h\"\n\n#include \"shmbutil.h\"\n#if defined (HAVE_MBSTR_H) && defined (HAVE_MBSCHR)\n#  include <mbstr.h>\t\t \n#endif\n#include \"typemax.h\"\n\n#include \"builtins/getopt.h\"\n#include \"builtins/common.h\"\n\n#include \"builtins/builtext.h\"\n\n#include <tilde/tilde.h>\n#include <glob/strmatch.h>\n\n#if !defined (errno)\nextern int errno;\n#endif  \n\n \n#define DEFAULT_INITIAL_ARRAY_SIZE 112\n#define DEFAULT_ARRAY_SIZE 128\n\n \n#define VT_VARIABLE\t0\n#define VT_POSPARMS\t1\n#define VT_ARRAYVAR\t2\n#define VT_ARRAYMEMBER\t3\n#define VT_ASSOCVAR\t4\n\n#define VT_STARSUB\t128\t \n\n \n#define ST_BACKSL\t0x01\n#define ST_CTLESC\t0x02\n#define ST_SQUOTE\t0x04\t \n#define ST_DQUOTE\t0x08\t \n\n \n#define LBRACE\t\t'{'\n#define RBRACE\t\t'}'\n#define LPAREN\t\t'('\n#define RPAREN\t\t')'\n#define LBRACK\t\t'['\n#define RBRACK\t\t']'\n\n#if defined (HANDLE_MULTIBYTE)\n#define WLPAREN\t\tL'('\n#define WRPAREN\t\tL')'\n#endif\n\n#define DOLLAR_AT_STAR(c)\t((c) == '@' || (c) == '*')\n#define STR_DOLLAR_AT_STAR(s)\t(DOLLAR_AT_STAR ((s)[0]) && (s)[1] == '\\0')\n\n \n#define VALID_SPECIAL_LENGTH_PARAM(c) \\\n  ((c) == '-' || (c) == '?' || (c) == '#' || (c) == '@')\n\n \n#define VALID_INDIR_PARAM(c) \\\n  ((posixly_correct == 0 && (c) == '#') || (posixly_correct == 0 && (c) == '?') || (c) == '@' || (c) == '*')\n\n \n#define VALID_PARAM_EXPAND_CHAR(c) (sh_syntaxtab[(unsigned char)c] & CSUBSTOP)\n\n \n#define SPECIAL_VAR(name, wi) \\\n (*name && ((DIGIT (*name) && all_digits (name)) || \\\n      (name[1] == '\\0' && (sh_syntaxtab[(unsigned char)*name] & CSPECVAR)) || \\\n      (wi && name[2] == '\\0' && VALID_INDIR_PARAM (name[1]))))\n\n \n\n#define CHECK_STRING_OVERRUN(oind, ind, len, ch) \\\n  if (ind >= len) \\\n    { \\\n      oind = len; \\\n      ch = 0; \\\n      break; \\\n    } \\\n  else \\\n\n \ntypedef WORD_LIST *EXPFUNC PARAMS((char *, int));\n\n \npid_t last_command_subst_pid = NO_PID;\npid_t current_command_subst_pid = NO_PID;\n\n \nSHELL_VAR *ifs_var;\nchar *ifs_value;\nunsigned char ifs_cmap[UCHAR_MAX + 1];\nint ifs_is_set, ifs_is_null;\n\n#if defined (HANDLE_MULTIBYTE)\nunsigned char ifs_firstc[MB_LEN_MAX];\nsize_t ifs_firstc_len;\n#else\nunsigned char ifs_firstc;\n#endif\n\n \nint inherit_errexit = 0;\n\n \nint assigning_in_environment;\n\n \nWORD_LIST *subst_assign_varlist = (WORD_LIST *)NULL;\n\n \nint no_longjmp_on_fatal_error = 0;\n\n \nint allow_null_glob_expansion;\n\n \nint fail_glob_expansion;\n\n \nint patsub_replacement = 1;\n\n \nextern struct fd_bitmap *current_fds_to_close;\nextern int wordexp_only;\nextern int singlequote_translations;\nextern int extended_quote;\n\n#if defined (JOB_CONTROL) && defined (PROCESS_SUBSTITUTION)\nextern PROCESS *last_procsub_child;\n#endif\n\n#if !defined (HAVE_WCSDUP) && defined (HANDLE_MULTIBYTE)\nextern wchar_t *wcsdup PARAMS((const wchar_t *));\n#endif\n\n#if 0\n \nchar *glob_argv_flags;\nstatic int glob_argv_flags_size;\n#endif\n\nstatic WORD_LIST *cached_quoted_dollar_at = 0;\n\n \nstatic WORD_LIST expand_word_error, expand_word_fatal;\nstatic WORD_DESC expand_wdesc_error, expand_wdesc_fatal;\nstatic char expand_param_error, expand_param_fatal, expand_param_unset;\nstatic char extract_string_error, extract_string_fatal;\n\n \nstatic int expand_no_split_dollar_star = 0;\n\n \nstatic WORD_LIST *garglist = (WORD_LIST *)NULL;\n\nstatic char *quoted_substring PARAMS((char *, int, int));\nstatic int quoted_strlen PARAMS((char *));\nstatic char *quoted_strchr PARAMS((char *, int, int));\n\nstatic char *expand_string_if_necessary PARAMS((char *, int, EXPFUNC *));\nstatic inline char *expand_string_to_string_internal PARAMS((char *, int, EXPFUNC *));\nstatic WORD_LIST *call_expand_word_internal PARAMS((WORD_DESC *, int, int, int *, int *));\nstatic WORD_LIST *expand_string_internal PARAMS((char *, int));\nstatic WORD_LIST *expand_string_leave_quoted PARAMS((char *, int));\nstatic WORD_LIST *expand_string_for_rhs PARAMS((char *, int, int, int, int *, int *));\nstatic WORD_LIST *expand_string_for_pat PARAMS((char *, int, int *, int *));\n\nstatic char *quote_escapes_internal PARAMS((const char *, int));\n\nstatic WORD_LIST *list_quote_escapes PARAMS((WORD_LIST *));\nstatic WORD_LIST *list_dequote_escapes PARAMS((WORD_LIST *));\n\nstatic char *make_quoted_char PARAMS((int));\nstatic WORD_LIST *quote_list PARAMS((WORD_LIST *));\n\nstatic int unquoted_substring PARAMS((char *, char *));\nstatic int unquoted_member PARAMS((int, char *));\n\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *do_compound_assignment PARAMS((char *, char *, int));\n#endif\nstatic int do_assignment_internal PARAMS((const WORD_DESC *, int));\n\nstatic char *string_extract_verbatim PARAMS((char *, size_t, int *, char *, int));\nstatic char *string_extract PARAMS((char *, int *, char *, int));\nstatic char *string_extract_double_quoted PARAMS((char *, int *, int));\nstatic inline char *string_extract_single_quoted PARAMS((char *, int *, int));\nstatic inline int skip_single_quoted PARAMS((const char *, size_t, int, int));\nstatic int skip_double_quoted PARAMS((char *, size_t, int, int));\nstatic char *extract_delimited_string PARAMS((char *, int *, char *, char *, char *, int));\nstatic char *extract_heredoc_dolbrace_string PARAMS((char *, int *, int, int));\nstatic char *extract_dollar_brace_string PARAMS((char *, int *, int, int));\nstatic int skip_matched_pair PARAMS((const char *, int, int, int, int));\n\nstatic char *pos_params PARAMS((char *, int, int, int, int));\n\nstatic unsigned char *mb_getcharlens PARAMS((char *, int));\n\nstatic char *remove_upattern PARAMS((char *, char *, int));\n#if defined (HANDLE_MULTIBYTE) \nstatic wchar_t *remove_wpattern PARAMS((wchar_t *, size_t, wchar_t *, int));\n#endif\nstatic char *remove_pattern PARAMS((char *, char *, int));\n\nstatic int match_upattern PARAMS((char *, char *, int, char **, char **));\n#if defined (HANDLE_MULTIBYTE)\nstatic int match_wpattern PARAMS((wchar_t *, char **, size_t, wchar_t *, int, char **, char **));\n#endif\nstatic int match_pattern PARAMS((char *, char *, int, char **, char **));\nstatic int getpatspec PARAMS((int, char *));\nstatic char *getpattern PARAMS((char *, int, int));\nstatic char *variable_remove_pattern PARAMS((char *, char *, int, int));\nstatic char *list_remove_pattern PARAMS((WORD_LIST *, char *, int, int, int));\nstatic char *parameter_list_remove_pattern PARAMS((int, char *, int, int));\n#ifdef ARRAY_VARS\nstatic char *array_remove_pattern PARAMS((SHELL_VAR *, char *, int, int, int));\n#endif\nstatic char *parameter_brace_remove_pattern PARAMS((char *, char *, array_eltstate_t *, char *, int, int, int));\n\nstatic char *string_var_assignment PARAMS((SHELL_VAR *, char *));\n#if defined (ARRAY_VARS)\nstatic char *array_var_assignment PARAMS((SHELL_VAR *, int, int, int));\n#endif\nstatic char *pos_params_assignment PARAMS((WORD_LIST *, int, int));\nstatic char *string_transform PARAMS((int, SHELL_VAR *, char *));\nstatic char *list_transform PARAMS((int, SHELL_VAR *, WORD_LIST *, int, int));\nstatic char *parameter_list_transform PARAMS((int, int, int));\n#if defined ARRAY_VARS\nstatic char *array_transform PARAMS((int, SHELL_VAR *, int, int));\n#endif\nstatic char *parameter_brace_transform PARAMS((char *, char *, array_eltstate_t *, char *, int, int, int, int));\nstatic int valid_parameter_transform PARAMS((char *));\n\nstatic char *process_substitute PARAMS((char *, int));\n\nstatic char *optimize_cat_file PARAMS((REDIRECT *, int, int, int *));\nstatic char *read_comsub PARAMS((int, int, int, int *));\n\n#ifdef ARRAY_VARS\nstatic arrayind_t array_length_reference PARAMS((char *));\n#endif\n\nstatic int valid_brace_expansion_word PARAMS((char *, int));\nstatic int chk_atstar PARAMS((char *, int, int, int *, int *));\nstatic int chk_arithsub PARAMS((const char *, int));\n\nstatic WORD_DESC *parameter_brace_expand_word PARAMS((char *, int, int, int, array_eltstate_t *));\nstatic char *parameter_brace_find_indir PARAMS((char *, int, int, int));\nstatic WORD_DESC *parameter_brace_expand_indir PARAMS((char *, int, int, int, int *, int *));\nstatic WORD_DESC *parameter_brace_expand_rhs PARAMS((char *, char *, int, int, int, int *, int *));\nstatic void parameter_brace_expand_error PARAMS((char *, char *, int));\n\nstatic int valid_length_expression PARAMS((char *));\nstatic intmax_t parameter_brace_expand_length PARAMS((char *));\n\nstatic char *skiparith PARAMS((char *, int));\nstatic int verify_substring_values PARAMS((SHELL_VAR *, char *, char *, int, intmax_t *, intmax_t *));\nstatic int get_var_and_type PARAMS((char *, char *, array_eltstate_t *, int, int, SHELL_VAR **, char **));\nstatic char *mb_substring PARAMS((char *, int, int));\nstatic char *parameter_brace_substring PARAMS((char *, char *, array_eltstate_t *, char *, int, int, int));\n\nstatic int shouldexp_replacement PARAMS((char *));\n\nstatic char *pos_params_pat_subst PARAMS((char *, char *, char *, int));\n\nstatic char *expand_string_for_patsub PARAMS((char *, int));\nstatic char *parameter_brace_patsub PARAMS((char *, char *, array_eltstate_t *, char *, int, int, int));\n\nstatic char *pos_params_casemod PARAMS((char *, char *, int, int));\nstatic char *parameter_brace_casemod PARAMS((char *, char *, array_eltstate_t *, int, char *, int, int, int));\n\nstatic WORD_DESC *parameter_brace_expand PARAMS((char *, int *, int, int, int *, int *));\nstatic WORD_DESC *param_expand PARAMS((char *, int *, int, int *, int *, int *, int *, int));\n\nstatic WORD_LIST *expand_word_internal PARAMS((WORD_DESC *, int, int, int *, int *));\n\nstatic WORD_LIST *word_list_split PARAMS((WORD_LIST *));\n\nstatic void exp_jump_to_top_level PARAMS((int));\n\nstatic WORD_LIST *separate_out_assignments PARAMS((WORD_LIST *));\nstatic WORD_LIST *glob_expand_word_list PARAMS((WORD_LIST *, int));\n#ifdef BRACE_EXPANSION\nstatic WORD_LIST *brace_expand_word_list PARAMS((WORD_LIST *, int));\n#endif\n#if defined (ARRAY_VARS)\nstatic int make_internal_declare PARAMS((char *, char *, char *));\nstatic void expand_compound_assignment_word PARAMS((WORD_LIST *, int));\nstatic WORD_LIST *expand_declaration_argument PARAMS((WORD_LIST *, WORD_LIST *));\n#endif\nstatic WORD_LIST *shell_expand_word_list PARAMS((WORD_LIST *, int));\nstatic WORD_LIST *expand_word_list_internal PARAMS((WORD_LIST *, int));\n\nstatic int do_assignment_statements PARAMS((WORD_LIST *, char *, int));\n\n \n \n \n \n \n\n#if defined (DEBUG)\nvoid\ndump_word_flags (flags)\n     int flags;\n{\n  int f;\n\n  f = flags;\n  fprintf (stderr, \"%d -> \", f);\n  if (f & W_ARRAYIND)\n    {\n      f &= ~W_ARRAYIND;\n      fprintf (stderr, \"W_ARRAYIND%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSIGNASSOC)\n    {\n      f &= ~W_ASSIGNASSOC;\n      fprintf (stderr, \"W_ASSIGNASSOC%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSIGNARRAY)\n    {\n      f &= ~W_ASSIGNARRAY;\n      fprintf (stderr, \"W_ASSIGNARRAY%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_SAWQUOTEDNULL)\n    {\n      f &= ~W_SAWQUOTEDNULL;\n      fprintf (stderr, \"W_SAWQUOTEDNULL%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOPROCSUB)\n    {\n      f &= ~W_NOPROCSUB;\n      fprintf (stderr, \"W_NOPROCSUB%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_DQUOTE)\n    {\n      f &= ~W_DQUOTE;\n      fprintf (stderr, \"W_DQUOTE%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_HASQUOTEDNULL)\n    {\n      f &= ~W_HASQUOTEDNULL;\n      fprintf (stderr, \"W_HASQUOTEDNULL%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSIGNARG)\n    {\n      f &= ~W_ASSIGNARG;\n      fprintf (stderr, \"W_ASSIGNARG%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSNBLTIN)\n    {\n      f &= ~W_ASSNBLTIN;\n      fprintf (stderr, \"W_ASSNBLTIN%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSNGLOBAL)\n    {\n      f &= ~W_ASSNGLOBAL;\n      fprintf (stderr, \"W_ASSNGLOBAL%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_COMPASSIGN)\n    {\n      f &= ~W_COMPASSIGN;\n      fprintf (stderr, \"W_COMPASSIGN%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_EXPANDRHS)\n    {\n      f &= ~W_EXPANDRHS;\n      fprintf (stderr, \"W_EXPANDRHS%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOTILDE)\n    {\n      f &= ~W_NOTILDE;\n      fprintf (stderr, \"W_NOTILDE%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSIGNRHS)\n    {\n      f &= ~W_ASSIGNRHS;\n      fprintf (stderr, \"W_ASSIGNRHS%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOASSNTILDE)\n    {\n      f &= ~W_NOASSNTILDE;\n      fprintf (stderr, \"W_NOASSNTILDE%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOCOMSUB)\n    {\n      f &= ~W_NOCOMSUB;\n      fprintf (stderr, \"W_NOCOMSUB%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ARRAYREF)\n    {\n      f &= ~W_ARRAYREF;\n      fprintf (stderr, \"W_ARRAYREF%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_DOLLARAT)\n    {\n      f &= ~W_DOLLARAT;\n      fprintf (stderr, \"W_DOLLARAT%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_TILDEEXP)\n    {\n      f &= ~W_TILDEEXP;\n      fprintf (stderr, \"W_TILDEEXP%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOSPLIT2)\n    {\n      f &= ~W_NOSPLIT2;\n      fprintf (stderr, \"W_NOSPLIT2%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOSPLIT)\n    {\n      f &= ~W_NOSPLIT;\n      fprintf (stderr, \"W_NOSPLIT%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOBRACE)\n    {\n      f &= ~W_NOBRACE;\n      fprintf (stderr, \"W_NOBRACE%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_NOGLOB)\n    {\n      f &= ~W_NOGLOB;\n      fprintf (stderr, \"W_NOGLOB%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_SPLITSPACE)\n    {\n      f &= ~W_SPLITSPACE;\n      fprintf (stderr, \"W_SPLITSPACE%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_ASSIGNMENT)\n    {\n      f &= ~W_ASSIGNMENT;\n      fprintf (stderr, \"W_ASSIGNMENT%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_QUOTED)\n    {\n      f &= ~W_QUOTED;\n      fprintf (stderr, \"W_QUOTED%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_HASDOLLAR)\n    {\n      f &= ~W_HASDOLLAR;\n      fprintf (stderr, \"W_HASDOLLAR%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_COMPLETE)\n    {\n      f &= ~W_COMPLETE;\n      fprintf (stderr, \"W_COMPLETE%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_CHKLOCAL)\n    {\n      f &= ~W_CHKLOCAL;\n      fprintf (stderr, \"W_CHKLOCAL%s\", f ? \"|\" : \"\");\n    }\n  if (f & W_FORCELOCAL)\n    {\n      f &= ~W_FORCELOCAL;\n      fprintf (stderr, \"W_FORCELOCAL%s\", f ? \"|\" : \"\");\n    }\n\n  fprintf (stderr, \"\\n\");\n  fflush (stderr);\n}\n#endif\n\n#ifdef INCLUDE_UNUSED\nstatic char *\nquoted_substring (string, start, end)\n     char *string;\n     int start, end;\n{\n  register int len, l;\n  register char *result, *s, *r;\n\n  len = end - start;\n\n   \n  for (s = string, l = 0; *s && l < start; )\n    {\n      if (*s == CTLESC)\n\t{\n\t  s++;\n\t  continue;\n\t}\n      l++;\n      if (*s == 0)\n\tbreak;\n    }\n\n  r = result = (char *)xmalloc (2*len + 1);       \n\n   \n  s = string + l;\n  for (l = 0; l < len; s++)\n    {\n      if (*s == CTLESC)\n\t*r++ = *s++;\n      *r++ = *s;\n      l++;\n      if (*s == 0)\n\tbreak;\n    }\n  *r = '\\0';\n  return result;\n}\n#endif\n\n#ifdef INCLUDE_UNUSED\n \nstatic int\nquoted_strlen (s)\n     char *s;\n{\n  register char *p;\n  int i;\n\n  i = 0;\n  for (p = s; *p; p++)\n    {\n      if (*p == CTLESC)\n\t{\n\t  p++;\n\t  if (*p == 0)\n\t    return (i + 1);\n\t}\n      i++;\n    }\n\n  return i;\n}\n#endif\n\n#ifdef INCLUDE_UNUSED\n \nstatic char *\nquoted_strchr (s, c, flags)\n     char *s;\n     int c, flags;\n{\n  register char *p;\n\n  for (p = s; *p; p++)\n    {\n      if (((flags & ST_BACKSL) && *p == '\\\\')\n\t    || ((flags & ST_CTLESC) && *p == CTLESC))\n\t{\n\t  p++;\n\t  if (*p == '\\0')\n\t    return ((char *)NULL);\n\t  continue;\n\t}\n      else if (*p == c)\n\treturn p;\n    }\n  return ((char *)NULL);\n}\n\n \nstatic int\nunquoted_member (character, string)\n     int character;\n     char *string;\n{\n  size_t slen;\n  int sindex, c;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  sindex = 0;\n  while (c = string[sindex])\n    {\n      if (c == character)\n\treturn (1);\n\n      switch (c)\n\t{\n\tdefault:\n\t  ADVANCE_CHAR (string, slen, sindex);\n\t  break;\n\n\tcase '\\\\':\n\t  sindex++;\n\t  if (string[sindex])\n\t    ADVANCE_CHAR (string, slen, sindex);\n\t  break;\n\n\tcase '\\'':\n\t  sindex = skip_single_quoted (string, slen, ++sindex, 0);\n\t  break;\n\n\tcase '\"':\n\t  sindex = skip_double_quoted (string, slen, ++sindex, 0);\n\t  break;\n\t}\n    }\n  return (0);\n}\n\n \nstatic int\nunquoted_substring (substr, string)\n     char *substr, *string;\n{\n  size_t slen;\n  int sindex, c, sublen;\n  DECLARE_MBSTATE;\n\n  if (substr == 0 || *substr == '\\0')\n    return (0);\n\n  slen = strlen (string);\n  sublen = strlen (substr);\n  for (sindex = 0; c = string[sindex]; )\n    {\n      if (STREQN (string + sindex, substr, sublen))\n\treturn (1);\n\n      switch (c)\n\t{\n\tcase '\\\\':\n\t  sindex++;\n\t  if (string[sindex])\n\t    ADVANCE_CHAR (string, slen, sindex);\n\t  break;\n\n\tcase '\\'':\n\t  sindex = skip_single_quoted (string, slen, ++sindex, 0);\n\t  break;\n\n\tcase '\"':\n\t  sindex = skip_double_quoted (string, slen, ++sindex, 0);\n\t  break;\n\n\tdefault:\n\t  ADVANCE_CHAR (string, slen, sindex);\n\t  break;\n\t}\n    }\n  return (0);\n}\n#endif\n\n \n\n \nINLINE char *\nsub_append_string (source, target, indx, size)\n     char *source, *target;\n     size_t *indx;\n     size_t *size;\n{\n  if (source)\n    {\n      size_t n, srclen;\n\n      srclen = STRLEN (source);\n      if (srclen >= (*size - *indx))\n\t{\n\t  n = srclen + *indx;\n\t  n = (n + DEFAULT_ARRAY_SIZE) - (n % DEFAULT_ARRAY_SIZE);\n\t  target = (char *)xrealloc (target, (*size = n));\n\t}\n\n      FASTCOPY (source, target + *indx, srclen);\n      *indx += srclen;\n      target[*indx] = '\\0';\n\n      free (source);\n    }\n  return (target);\n}\n\n#if 0\n \n \nchar *\nsub_append_number (number, target, indx, size)\n     intmax_t number;\n     char *target;\n     size_t *indx;\n     size_t *size;\n{\n  char *temp;\n\n  temp = itos (number);\n  return (sub_append_string (temp, target, indx, size));\n}\n#endif\n\n \nstatic char *\nstring_extract (string, sindex, charlist, flags)\n     char *string;\n     int *sindex;\n     char *charlist;\n     int flags;\n{\n  register int c, i;\n  int found;\n  size_t slen;\n  char *temp;\n  DECLARE_MBSTATE;\n\n  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;\n  i = *sindex;\n  found = 0;\n  while (c = string[i])\n    {\n      if (c == '\\\\')\n\t{\n\t  if (string[i + 1])\n\t    i++;\n\t  else\n\t    break;\n\t}\n#if defined (ARRAY_VARS)\n      else if ((flags & SX_VARNAME) && c == LBRACK)\n\t{\n\t  int ni;\n\t   \n\t  ni = skipsubscript (string, i, 0);\n\t  if (string[ni] == RBRACK)\n\t    i = ni;\n\t}\n#endif\n      else if (MEMBER (c, charlist))\n\t{\n\t  found = 1;\n\t  break;\n\t}\n\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n   \n  if ((flags & SX_REQMATCH) && found == 0)\n    {\n      *sindex = i;\n      return (&extract_string_error);\n    }\n  \n  temp = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);\n  *sindex = i;\n  \n  return (temp);\n}\n\n \nstatic char *\nstring_extract_double_quoted (string, sindex, flags)\n     char *string;\n     int *sindex, flags;\n{\n  size_t slen;\n  char *send;\n  int j, i, t;\n  unsigned char c;\n  char *temp, *ret;\t\t \n  int pass_next, backquote, si;\t \n  int dquote;\n  int stripdq;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + *sindex) + *sindex;\n  send = string + slen;\n\n  stripdq = (flags & SX_STRIPDQ);\n\n  pass_next = backquote = dquote = 0;\n  temp = (char *)xmalloc (1 + slen - *sindex);\n\n  j = 0;\n  i = *sindex;\n  while (c = string[i])\n    {\n       \n      if (pass_next)\n\t{\n\t   \n\t   \n\n\t   \n\t  if ((stripdq == 0 && c != '\"') ||\n\t      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))\n\t    temp[j++] = '\\\\';\n\t  pass_next = 0;\n\nadd_one_character:\n\t  COPY_CHAR_I (temp, j, string, send, i);\n\t  continue;\n\t}\n\n       \n      if (c == '\\\\')\n\t{\n\t  pass_next++;\n\t  i++;\n\t  continue;\n\t}\n\n       \n      if (backquote)\n\t{\n\t  if (c == '`')\n\t    backquote = 0;\n\t  temp[j++] = c;\t \n\t  i++;\n\t  continue;\n\t}\n\n      if (c == '`')\n\t{\n\t  temp[j++] = c;\n\t  backquote++;\n\t  i++;\n\t  continue;\n\t}\n\n       \n      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))\n\t{\n\t  int free_ret = 1;\n\n\t  si = i + 2;\n\t  if (string[i + 1] == LPAREN)\n\t    ret = extract_command_subst (string, &si, (flags & SX_COMPLETE));\n\t  else\n\t    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);\n\n\t  temp[j++] = '$';\n\t  temp[j++] = string[i + 1];\n\n\t   \n\t  if (ret == 0 && no_longjmp_on_fatal_error)\n\t    {\n\t      free_ret = 0;\n\t      ret = string + i + 2;\n\t    }\n\n\t   \n\t  for (t = 0; ret[t]; t++, j++)\n\t    temp[j] = ret[t];\n\t  temp[j] = string[si];\n\n\t  if (si < i + 2)\t \n\t    i += 2;\n\t  else if (string[si])\n\t    {\n\t      j++;\n\t      i = si + 1;\n\t    }\n\t  else\n\t    i = si;\n\n\t  if (free_ret)\n\t    free (ret);\n\t  continue;\n\t}\n\n       \n      if (c != '\"')\n\tgoto add_one_character;\n\n       \n      if (stripdq)\n\t{\n\t  dquote ^= 1;\n\t  i++;\n\t  continue;\n\t}\n\n      break;\n    }\n  temp[j] = '\\0';\n\n   \n  if (c)\n    i++;\n  *sindex = i;\n\n  return (temp);\n}\n\n \nstatic int\nskip_double_quoted (string, slen, sind, flags)\n     char *string;\n     size_t slen;\n     int sind;\n     int flags;\n{\n  int c, i;\n  char *ret;\n  int pass_next, backquote, si;\n  DECLARE_MBSTATE;\n\n  pass_next = backquote = 0;\n  i = sind;\n  while (c = string[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next++;\n\t  i++;\n\t  continue;\n\t}\n      else if (backquote)\n\t{\n\t  if (c == '`')\n\t    backquote = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '`')\n\t{\n\t  backquote++;\n\t  i++;\n\t  continue;\n\t}\n      else if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))\n\t{\n\t  si = i + 2;\n\t  if (string[i + 1] == LPAREN)\n\t    ret = extract_command_subst (string, &si, SX_NOALLOC|(flags&SX_COMPLETE));\n\t  else\n\t    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, SX_NOALLOC);\n\n\t   \n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  i = si + 1;\n\t  continue;\n\t}\n      else if (c != '\"')\n\t{\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else\n\tbreak;\n    }\n\n  if (c)\n    i++;\n\n  return (i);\n}\n\n \nstatic inline char *\nstring_extract_single_quoted (string, sindex, allowesc)\n     char *string;\n     int *sindex;\n     int allowesc;\n{\n  register int i;\n  size_t slen;\n  char *t;\n  int pass_next;\n  DECLARE_MBSTATE;\n\n   \n  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 0;\n  i = *sindex;\n  pass_next = 0;\n  while (string[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      if (allowesc && string[i] == '\\\\')\n\tpass_next++;\n      else if (string[i] == '\\'')\n        break;\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  t = substring (string, *sindex, i);\n\n  if (string[i])\n    i++;\n  *sindex = i;\n\n  return (t);\n}\n\n \nstatic inline int\nskip_single_quoted (string, slen, sind, flags)\n     const char *string;\n     size_t slen;\n     int sind;\n     int flags;\n{\n  register int c;\n  DECLARE_MBSTATE;\n\n  c = sind;\n  while (string[c] && string[c] != '\\'')\n    {\n      if ((flags & SX_COMPLETE) && string[c] == '\\\\' && string[c+1] == '\\'' && string[c+2])\n\tADVANCE_CHAR (string, slen, c);\n      ADVANCE_CHAR (string, slen, c);\n    }\n\n  if (string[c])\n    c++;\n  return c;\n}\n\n \nstatic char *\nstring_extract_verbatim (string, slen, sindex, charlist, flags)\n     char *string;\n     size_t slen;\n     int *sindex;\n     char *charlist;\n     int flags;\n{\n  register int i;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t *wcharlist;\n#endif\n  int c;\n  char *temp;\n  DECLARE_MBSTATE;\n\n  if ((flags & SX_NOCTLESC) && charlist[0] == '\\'' && charlist[1] == '\\0')\n    {\n      temp = string_extract_single_quoted (string, sindex, 0);\n      --*sindex;\t \n      return temp;\n    }\n\n   \n  if (*charlist == 0)\n    {\n      temp = string + *sindex;\n      c = (*sindex == 0) ? slen : STRLEN (temp);\n      temp = savestring (temp);\n      *sindex += c;\n      return temp;\n    }\n\n  i = *sindex;\n#if defined (HANDLE_MULTIBYTE)\n  wcharlist = 0;\n#endif\n  while (c = string[i])\n    {\n#if defined (HANDLE_MULTIBYTE)\n      size_t mblength;\n#endif\n      if ((flags & SX_NOCTLESC) == 0 && c == CTLESC)\n\t{\n\t  i += 2;\n\t  CHECK_STRING_OVERRUN (i, i, slen, c);\n\t  continue;\n\t}\n       \n      else if ((flags & SX_NOESCCTLNUL) == 0 && c == CTLESC && string[i+1] == CTLNUL)\n\t{\n\t  i += 2;\n\t  CHECK_STRING_OVERRUN (i, i, slen, c);\n\t  continue;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (locale_utf8locale && slen > i && UTF8_SINGLEBYTE (string[i]))\n\tmblength = (string[i] != 0) ? 1 : 0;\n      else\n\tmblength = MBLEN (string + i, slen - i);\n      if (mblength > 1)\n\t{\n\t  wchar_t wc;\n\t  mblength = mbtowc (&wc, string + i, slen - i);\n\t  if (MB_INVALIDCH (mblength))\n\t    {\n\t      if (MEMBER (c, charlist))\n\t\tbreak;\n\t    }\n\t  else\n\t    {\n\t      if (wcharlist == 0)\n\t\t{\n\t\t  size_t len;\n\t\t  len = mbstowcs (wcharlist, charlist, 0);\n\t\t  if (len == -1)\n\t\t    len = 0;\n\t\t  wcharlist = (wchar_t *)xmalloc (sizeof (wchar_t) * (len + 1));\n\t\t  mbstowcs (wcharlist, charlist, len + 1);\n\t\t}\n\n\t      if (wcschr (wcharlist, wc))\n\t\tbreak;\n\t    }\n\t}\n      else\t\t\n#endif\n      if (MEMBER (c, charlist))\n\tbreak;\n\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  FREE (wcharlist);\n#endif\n\n  temp = substring (string, *sindex, i);\n  *sindex = i;\n\n  return (temp);\n}\n\n \nchar *\nextract_command_subst (string, sindex, xflags)\n     char *string;\n     int *sindex;\n     int xflags;\n{\n  char *ret;\n\n  if (string[*sindex] == LPAREN || (xflags & SX_COMPLETE))\n    return (extract_delimited_string (string, sindex, \"$(\", \"(\", \")\", xflags|SX_COMMAND));  \n  else\n    {\n      xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);\n      ret = xparse_dolparen (string, string+*sindex, sindex, xflags);\n      return ret;\n    }\n}\n\n \nchar *\nextract_arithmetic_subst (string, sindex)\n     char *string;\n     int *sindex;\n{\n  return (extract_delimited_string (string, sindex, \"$[\", \"[\", \"]\", 0));  \n}\n\n#if defined (PROCESS_SUBSTITUTION)\n   \nchar *\nextract_process_subst (string, starter, sindex, xflags)\n     char *string;\n     char *starter;\n     int *sindex;\n     int xflags;\n{\n#if 0\n   \n  return (extract_delimited_string (string, sindex, starter, \"(\", \")\", SX_COMMAND));\n#else\n  xflags |= (no_longjmp_on_fatal_error ? SX_NOLONGJMP : 0);\n  return (xparse_dolparen (string, string+*sindex, sindex, xflags));\n#endif\n}\n#endif  \n\n#if defined (ARRAY_VARS)\n \nchar *\nextract_array_assignment_list (string, sindex)\n     char *string;\n     int *sindex;\n{\n  int slen;\n  char *ret;\n\n  slen = strlen (string);\n  if (string[slen - 1] == RPAREN)\n   {\n      ret = substring (string, *sindex, slen - 1);\n      *sindex = slen - 1;\n      return ret;\n    }\n  return 0;  \n}\n#endif\n\n \nstatic char *\nextract_delimited_string (string, sindex, opener, alt_opener, closer, flags)\n     char *string;\n     int *sindex;\n     char *opener, *alt_opener, *closer;\n     int flags;\n{\n  int i, c, si;\n  size_t slen;\n  char *t, *result;\n  int pass_character, nesting_level, in_comment;\n  int len_closer, len_opener, len_alt_opener;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + *sindex) + *sindex;\n  len_opener = STRLEN (opener);\n  len_alt_opener = STRLEN (alt_opener);\n  len_closer = STRLEN (closer);\n\n  pass_character = in_comment = 0;\n\n  nesting_level = 1;\n  i = *sindex;\n\n  while (nesting_level)\n    {\n      c = string[i];\n\n       \n      if (i > slen)\n\t{\n\t  i = slen;\n\t  c = string[i = slen];\n\t  break;\n\t}\n\n      if (c == 0)\n\tbreak;\n\n      if (in_comment)\n\t{\n\t  if (c == '\\n')\n\t    in_comment = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n\n      if (pass_character)\t \n\t{\n\t  pass_character = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n\n       \n      if ((flags & SX_COMMAND) && c == '#' && (i == 0 || string[i - 1] == '\\n' || shellblank (string[i - 1])))\n\t{\n          in_comment = 1;\n          ADVANCE_CHAR (string, slen, i);\n          continue;\n\t}\n        \n      if (c == CTLESC || c == '\\\\')\n\t{\n\t  pass_character++;\n\t  i++;\n\t  continue;\n\t}\n\n       \n      if ((flags & SX_COMMAND) && string[i] == '$' && string[i+1] == LPAREN)\n        {\n          si = i + 2;\n          t = extract_command_subst (string, &si, flags|SX_NOALLOC);\n          CHECK_STRING_OVERRUN (i, si, slen, c);\n          i = si + 1;\n          continue;\n        }\n\n       \n      if (STREQN (string + i, opener, len_opener))\n\t{\n\t  si = i + len_opener;\n\t  t = extract_delimited_string (string, &si, opener, alt_opener, closer, flags|SX_NOALLOC);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n       \n      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))\n\t{\n\t  si = i + len_alt_opener;\n\t  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n       \n      if (STREQN (string + i, closer, len_closer))\n\t{\n\t  i += len_closer - 1;\t \n\t  nesting_level--;\n\t  if (nesting_level == 0)\n\t    break;\n\t}\n\n       \n      if (c == '`')\n\t{\n\t  si = i + 1;\n\t  t = string_extract (string, &si, \"`\", flags|SX_NOALLOC);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n       \n      if (c == '\\'' || c == '\"')\n\t{\n\t  si = i + 1;\n\t  i = (c == '\\'') ? skip_single_quoted (string, slen, si, 0)\n\t\t\t  : skip_double_quoted (string, slen, si, 0);\n\t  continue;\n\t}\n\n       \n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  if (c == 0 && nesting_level)\n    {\n      if (no_longjmp_on_fatal_error == 0)\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  report_error (_(\"bad substitution: no closing `%s' in %s\"), closer, string);\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n      else\n\t{\n\t  *sindex = i;\n\t  return (char *)NULL;\n\t}\n    }\n\n  si = i - *sindex - len_closer + 1;\n  if (flags & SX_NOALLOC)\n    result = (char *)NULL;\n  else    \n    {\n      result = (char *)xmalloc (1 + si);\n      strncpy (result, string + *sindex, si);\n      result[si] = '\\0';\n    }\n  *sindex = i;\n\n  return (result);\n}\n\n \nstatic char *\nextract_heredoc_dolbrace_string (string, sindex, quoted, flags)\n     char *string;\n     int *sindex, quoted, flags;\n{\n  register int i, c;\n  size_t slen, tlen, result_index, result_size;\n  int pass_character, nesting_level, si, dolbrace_state;\n  char *result, *t, *send;\n  DECLARE_MBSTATE;\n\n  pass_character = 0;\n  nesting_level = 1;\n  slen = strlen (string + *sindex) + *sindex;\n  send = string + slen;\n\n  result_size = slen;\n  result_index = 0;\n  result = xmalloc (result_size + 1);\n\n   \n  dolbrace_state = DOLBRACE_QUOTE;\n\n  i = *sindex;\n  while (c = string[i])\n    {\n      if (pass_character)\n\t{\n\t  pass_character = 0;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, locale_mb_cur_max + 1, result_size, 64);\n\t  COPY_CHAR_I (result, result_index, string, send, i);\n\t  continue;\n\t}\n\n       \n      if (c == CTLESC || c == '\\\\')\n\t{\n\t  pass_character++;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, 2, result_size, 64);\n\t  result[result_index++] = c;\n\t  i++;\n\t  continue;\n\t}\n\n       \n      if (c == '$' && string[i+1] == '\\'')\n\t{\n\t  char *ttrans;\n\t  int ttranslen;\n\n\t  if ((posixly_correct || extended_quote == 0) && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2)\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, 64);\n\t      result[result_index++] = '$';\n\t      result[result_index++] = '\\'';\n\t      i += 2;\n\t      continue;\n\t    }\n\n\t  si = i + 2;\n\t  t = string_extract_single_quoted (string, &si, 1);\t \n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  tlen = si - i - 2;\t \n\t  ttrans = ansiexpand (t, 0, tlen, &ttranslen);\n\t  free (t);\n\n\t   \n\t  if (dolbrace_state == DOLBRACE_QUOTE || dolbrace_state == DOLBRACE_QUOTE2)\n\t    {\n\t      t = sh_single_quote (ttrans);\n\t      tlen = strlen (t);\n\t      free (ttrans);\n\t    }\n\t  else if (extended_quote)  \n\t    {\n\t       \n\t      t = ttrans;\n\t      tlen = strlen (t);\n\t    }\n\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, tlen + 1, result_size, 64);\n\t  strncpy (result + result_index, t, tlen);\n\t  result_index += tlen;\n\t  free (t);\n\t  i = si;\n\t  continue;\n\t}\n\n#if defined (TRANSLATABLE_STRINGS)\n      if (c == '$' && string[i+1] == '\"')\n\t{\n\t  char *ttrans;\n\t  int ttranslen;\n\n\t  si = i + 2;\n\t  t = string_extract_double_quoted (string, &si, flags);\t \n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  tlen = si - i - 2;\t \n\t  ttrans = locale_expand (t, 0, tlen, line_number, &ttranslen);\n\t  free (t);\n\n\t  t = singlequote_translations ? sh_single_quote (ttrans) : sh_mkdoublequoted (ttrans, ttranslen, 0);\n\t  tlen = strlen (t);\n\t  free (ttrans);\n\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, tlen + 1, result_size, 64);\n\t  strncpy (result + result_index, t, tlen);\n\t  result_index += tlen;\n\t  free (t);\n\t  i = si;\n\t  continue;\n\t}\n#endif  \n\n      if (c == '$' && string[i+1] == LBRACE)\n\t{\n\t  nesting_level++;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, 3, result_size, 64);\n\t  result[result_index++] = c;\n\t  result[result_index++] = string[i+1];\n\t  i += 2;\n\t  if (dolbrace_state == DOLBRACE_QUOTE || dolbrace_state == DOLBRACE_QUOTE2 || dolbrace_state == DOLBRACE_WORD)\n\t    dolbrace_state = DOLBRACE_PARAM;\n\t  continue;\n\t}\n\n      if (c == RBRACE)\n\t{\n\t  nesting_level--;\n\t  if (nesting_level == 0)\n\t    break;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, 2, result_size, 64);\n\t  result[result_index++] = c;\n\t  i++;\n\t  continue;\n\t}\n\n       \n      if (c == '`')\n\t{\n\t  si = i + 1;\n\t  t = string_extract (string, &si, \"`\", flags);\t \n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  tlen = si - i - 1;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, tlen + 3, result_size, 64);\n\t  result[result_index++] = c;\n\t  strncpy (result + result_index, t, tlen);\n\t  result_index += tlen;\n\t  result[result_index++] = string[si];\n\t  free (t);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n       \n      if (string[i] == '$' && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  t = extract_command_subst (string, &si, flags);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  tlen = si - i - 2;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, tlen + 4, result_size, 64);\n\t  result[result_index++] = c;\n\t  result[result_index++] = LPAREN;\n\t  strncpy (result + result_index, t, tlen);\n\t  result_index += tlen;\n\t  result[result_index++] = string[si];\n\t  free (t);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n#if defined (PROCESS_SUBSTITUTION)\n       \n      if ((string[i] == '<' || string[i] == '>') && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  t = extract_process_subst (string, (string[i] == '<' ? \"<(\" : \">)\"), &si, flags);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  tlen = si - i - 2;\n\t  RESIZE_MALLOCED_BUFFER (result, result_index, tlen + 4, result_size, 64);\n\t  result[result_index++] = c;\n\t  result[result_index++] = LPAREN;\n\t  strncpy (result + result_index, t, tlen);\n\t  result_index += tlen;\n\t  result[result_index++] = string[si];\n\t  free (t);\n\t  i = si + 1;\n\t  continue;\n\t}\n#endif\n\n      if (c == '\\'' && posixly_correct && shell_compatibility_level > 42 && dolbrace_state != DOLBRACE_QUOTE)\n\t{\n\t  COPY_CHAR_I (result, result_index, string, send, i);\n\t  continue;\n\t}\n\n       \n      if (c == '\"' || c == '\\'')\n\t{\n\t  si = i + 1;\n\t  if (c == '\"')\n\t    t = string_extract_double_quoted (string, &si, flags);\n\t  else\n\t    t = string_extract_single_quoted (string, &si, 0);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  tlen = si - i - 2;\t \n\t  RESIZE_MALLOCED_BUFFER (result, result_index, tlen + 3, result_size, 64);\n\t  result[result_index++] = c;\n\t  strncpy (result + result_index, t, tlen);\n\t  result_index += tlen;\n\t  result[result_index++] = string[si - 1];\n\t  free (t);\n\t  i = si;\n\t  continue;\n\t}\n\n       \n      COPY_CHAR_I (result, result_index, string, send, i);\n\n       \n      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)\n\tdolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE2;\t \n      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n       \n      else if (dolbrace_state == DOLBRACE_PARAM && strchr (\"#%^,~:-=?+/\", c) != 0)\n\tdolbrace_state = DOLBRACE_OP;\n      else if (dolbrace_state == DOLBRACE_OP && strchr (\"#%^,~:-=?+/\", c) == 0)\n\tdolbrace_state = DOLBRACE_WORD;\n    }\n\n  if (c == 0 && nesting_level)\n    {\n      free (result);\n      if (no_longjmp_on_fatal_error == 0)\n\t{\t\t\t \n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  report_error (_(\"bad substitution: no closing `%s' in %s\"), \"}\", string);\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n      else\n\t{\n\t  *sindex = i;\n\t  return ((char *)NULL);\n\t}\n    }\n\n  *sindex = i;\n  result[result_index] = '\\0';\n\n  return (result);\n}\n\n#define PARAMEXPNEST_MAX\t32\t\nstatic int dbstate[PARAMEXPNEST_MAX];\n\n \n \nstatic char *\nextract_dollar_brace_string (string, sindex, quoted, flags)\n     char *string;\n     int *sindex, quoted, flags;\n{\n  register int i, c;\n  size_t slen;\n  int pass_character, nesting_level, si, dolbrace_state;\n  char *result, *t;\n  DECLARE_MBSTATE;\n\n   \n  dolbrace_state = (flags & SX_WORD) ? DOLBRACE_WORD : DOLBRACE_PARAM;\n  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && (flags & SX_POSIXEXP))\n    dolbrace_state = DOLBRACE_QUOTE;\n\n  if (quoted == Q_HERE_DOCUMENT && dolbrace_state == DOLBRACE_QUOTE && (flags & SX_NOALLOC) == 0)\n    return (extract_heredoc_dolbrace_string (string, sindex, quoted, flags));\n\n  dbstate[0] = dolbrace_state;\n\n  pass_character = 0;\n  nesting_level = 1;\n  slen = strlen (string + *sindex) + *sindex;\n\n  i = *sindex;\n  while (c = string[i])\n    {\n      if (pass_character)\n\t{\n\t  pass_character = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n\n       \n      if (c == CTLESC || c == '\\\\')\n\t{\n\t  pass_character++;\n\t  i++;\n\t  continue;\n\t}\n\n      if (string[i] == '$' && string[i+1] == LBRACE)\n\t{\n\t  if (nesting_level < PARAMEXPNEST_MAX)\n\t    dbstate[nesting_level] = dolbrace_state;\n\t  nesting_level++;\n\t  i += 2;\n\t  if (dolbrace_state == DOLBRACE_QUOTE || dolbrace_state == DOLBRACE_WORD)\n\t    dolbrace_state = DOLBRACE_PARAM;\n\t  continue;\n\t}\n\n      if (c == RBRACE)\n\t{\n\t  nesting_level--;\n\t  if (nesting_level == 0)\n\t    break;\n\t  dolbrace_state = (nesting_level < PARAMEXPNEST_MAX) ? dbstate[nesting_level] : dbstate[0];\t \n\t  i++;\n\t  continue;\n\t}\n\n       \n      if (c == '`')\n\t{\n\t  si = i + 1;\n\t  t = string_extract (string, &si, \"`\", flags|SX_NOALLOC);\n\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  i = si + 1;\n\t  continue;\n\t}\n\n       \n      if (string[i] == '$' && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  t = extract_command_subst (string, &si, flags|SX_NOALLOC);\n\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  i = si + 1;\n\t  continue;\n\t}\n\n#if defined (PROCESS_SUBSTITUTION)\n       \n      if ((string[i] == '<' || string[i] == '>') && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  t = extract_process_subst (string, (string[i] == '<' ? \"<(\" : \">)\"), &si, flags|SX_NOALLOC);\n\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  i = si + 1;\n\t  continue;\n\t}\n#endif\n\n       \n      if (c == '\"')\n\t{\n\t  si = i + 1;\n\t  i = skip_double_quoted (string, slen, si, 0);\n\t   \n\t  continue;\n\t}\n\n      if (c == '\\'')\n\t{\n \n\t  if (posixly_correct && shell_compatibility_level > 42 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t    ADVANCE_CHAR (string, slen, i);\n\t  else\n\t    {\n\t      si = i + 1;\n\t      i = skip_single_quoted (string, slen, si, 0);\n\t    }\n\n          continue;\n\t}\n\n#if defined (ARRAY_VARS)\n      if (c == LBRACK && dolbrace_state == DOLBRACE_PARAM)\n\t{\n\t  si = skipsubscript (string, i, 0);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  if (string[si] == RBRACK)\n\t    c = string[i = si];\n\t}\n#endif\n\n       \n      ADVANCE_CHAR (string, slen, i);\n\n       \n      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)\n\tdolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE2;\t \n      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n       \n      else if (dolbrace_state == DOLBRACE_PARAM && strchr (\"#%^,~:-=?+/\", c) != 0)\n\tdolbrace_state = DOLBRACE_OP;\n      else if (dolbrace_state == DOLBRACE_OP && strchr (\"#%^,~:-=?+/\", c) == 0)\n\tdolbrace_state = DOLBRACE_WORD;\n    }\n\n  if (c == 0 && nesting_level)\n    {\n      if (no_longjmp_on_fatal_error == 0)\n\t{\t\t\t \n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  report_error (_(\"bad substitution: no closing `%s' in %s\"), \"}\", string);\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n      else\n\t{\n\t  *sindex = i;\n\t  return ((char *)NULL);\n\t}\n    }\n\n  result = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);\n  *sindex = i;\n\n  return (result);\n}\n\n \nchar *\nde_backslash (string)\n     char *string;\n{\n  register size_t slen;\n  register int i, j, prev_i;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  i = j = 0;\n\n   \n  while (i < slen)\n    {\n      if (string[i] == '\\\\' && (string[i + 1] == '`' || string[i + 1] == '\\\\' ||\n\t\t\t      string[i + 1] == '$'))\n\ti++;\n      prev_i = i;\n      ADVANCE_CHAR (string, slen, i);\n      if (j < prev_i)\n\tdo string[j++] = string[prev_i++]; while (prev_i < i);\n      else\n\tj = i;\n    }\n  string[j] = '\\0';\n\n  return (string);\n}\n\n#if 0\n \n \nvoid\nunquote_bang (string)\n     char *string;\n{\n  register int i, j;\n  register char *temp;\n\n  temp = (char *)xmalloc (1 + strlen (string));\n\n  for (i = 0, j = 0; (temp[j] = string[i]); i++, j++)\n    {\n      if (string[i] == '\\\\' && string[i + 1] == '!')\n\t{\n\t  temp[j] = '!';\n\t  i++;\n\t}\n    }\n  strcpy (string, temp);\n  free (temp);\n}\n#endif\n\n#define CQ_RETURN(x) do { no_longjmp_on_fatal_error = oldjmp; return (x); } while (0)\n\n \nstatic int\nskip_matched_pair (string, start, open, close, flags)\n     const char *string;\n     int start, open, close, flags;\n{\n  int i, pass_next, backq, si, c, count, oldjmp;\n  size_t slen;\n  char *temp, *ss;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + start) + start;\n  oldjmp = no_longjmp_on_fatal_error;\n  no_longjmp_on_fatal_error = 1;\n\n   \n  i = (flags & 2) ? start : start + 1;\n  count = 1;\n  pass_next = backq = 0;\n  ss = (char *)string;\n  while (c = string[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (c == 0)\n\t    CQ_RETURN(i);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq)\n\t{\n\t  if (c == '`')\n\t    backq = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && c == '`')\n\t{\n\t  backq = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && c == open)\n\t{\n\t  count++;\n\t  i++;\n\t  continue;\n\t}\n      else if (c == close)\n\t{\n\t  count--;\n\t  if (count == 0)\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && (c == '\\'' || c == '\"'))\n\t{\n\t  i = (c == '\\'') ? skip_single_quoted (ss, slen, ++i, 0)\n\t\t\t  : skip_double_quoted (ss, slen, ++i, 0);\n\t   \n\t}\n      else if ((flags & 1) == 0 && c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t   \n\t  if (string[i+1] == LPAREN)\n\t    temp = extract_delimited_string (ss, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND);  \n\t  else\n\t    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);\n\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t \n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(i);\n}\n\n#if defined (ARRAY_VARS)\n \nint\nskipsubscript (string, start, flags)\n     const char *string;\n     int start, flags;\n{\n  return (skip_matched_pair (string, start, '[', ']', flags));\n}\n#endif\n\n \nint\nskip_to_delim (string, start, delims, flags)\n     char *string;\n     int start;\n     char *delims;\n     int flags;\n{\n  int i, pass_next, backq, dquote, si, c, oldjmp;\n  int invert, skipquote, skipcmd, noprocsub, completeflag;\n  int arithexp, skipcol;\n  size_t slen;\n  char *temp, open[3];\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + start) + start;\n  oldjmp = no_longjmp_on_fatal_error;\n  if (flags & SD_NOJMP)\n    no_longjmp_on_fatal_error = 1;\n  invert = (flags & SD_INVERT);\n  skipcmd = (flags & SD_NOSKIPCMD) == 0;\n  noprocsub = (flags & SD_NOPROCSUB);\n  completeflag = (flags & SD_COMPLETE) ? SX_COMPLETE : 0;\n\n  arithexp = (flags & SD_ARITHEXP);\n  skipcol = 0;\n\n  i = start;\n  pass_next = backq = dquote = 0;\n  while (c = string[i])\n    {\n       \n      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\\'' || c =='\"'));\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (c == 0)\n\t    CQ_RETURN(i);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq)\n\t{\n\t  if (c == '`')\n\t    backq = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '`')\n\t{\n\t  backq = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (arithexp && skipcol && c == ':')\n\t{\n\t  skipcol--;\n\t  i++;\n\t  continue;\n\t}\n      else if (arithexp && c == '?')\n\t{\n\t  skipcol++;\n\t  i++;\n\t  continue;\n\t}\n      else if (skipquote == 0 && invert == 0 && member (c, delims))\n\tbreak;\n       \n       \n      else if (completeflag && i > 0 && string[i-1] == '$' && c == '\\'')\n\ti = skip_single_quoted (string, slen, ++i, SX_COMPLETE);\n      else if (c == '\\'')\n\ti = skip_single_quoted (string, slen, ++i, 0);\n      else if (c == '\"')\n\ti = skip_double_quoted (string, slen, ++i, completeflag);\n      else if (c == LPAREN && arithexp)\n        {\n          si = i + 1;\n          if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  temp = extract_delimited_string (string, &si, \"(\", \"(\", \")\", SX_NOALLOC);  \n\t  i = si;\n\t  if (string[i] == '\\0')\t \n\t    break;\n\t  i++;\n\t  continue;         \n        }\n      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  if (string[i+1] == LPAREN)\n\t    temp = extract_delimited_string (string, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND|completeflag);  \n\t  else\n\t    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  i = si;\n\t  if (string[i] == '\\0')\t \n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#if defined (PROCESS_SUBSTITUTION)\n      else if (skipcmd && noprocsub == 0 && (c == '<' || c == '>') && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  temp = extract_delimited_string (string, &si, (c == '<') ? \"<(\" : \">(\", \"(\", \")\", SX_COMMAND|SX_NOALLOC);  \n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  i = si;\n\t  if (string[i] == '\\0')\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif  \n#if defined (EXTENDED_GLOB)\n      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, \"?*+!@\"))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  open[0] = c;\n\t  open[1] = LPAREN;\n\t  open[2] = '\\0';\n\t  temp = extract_delimited_string (string, &si, open, \"(\", \")\", SX_NOALLOC);  \n\n\t  CHECK_STRING_OVERRUN (i, si, slen, c);\n\t  i = si;\n\t  if (string[i] == '\\0')\t \n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif\n      else if ((flags & SD_GLOB) && c == LBRACK)\n\t{\n\t  si = i + 1;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  temp = extract_delimited_string (string, &si, \"[\", \"[\", \"]\", SX_NOALLOC);  \n\n\t  i = si;\n\t  if (string[i] == '\\0')\t \n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else if ((skipquote || invert) && (member (c, delims) == 0))\n\tbreak;\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(i);\n}\n\n#if defined (BANG_HISTORY)\n \nint\nskip_to_histexp (string, start, delims, flags)\n     char *string;\n     int start;\n     char *delims;\n     int flags;\n{\n  int i, pass_next, backq, dquote, c, oldjmp;\n  int histexp_comsub, histexp_backq, old_dquote;\n  size_t slen;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + start) + start;\n  oldjmp = no_longjmp_on_fatal_error;\n  if (flags & SD_NOJMP)\n    no_longjmp_on_fatal_error = 1;\n\n  histexp_comsub = histexp_backq = old_dquote = 0;\n\n  i = start;\n  pass_next = backq = dquote = 0;\n  while (c = string[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (c == 0)\n\t    CQ_RETURN(i);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq && c == '`')\n\t{\n\t  backq = 0;\n\t  histexp_backq--;\n\t  dquote = old_dquote;\n\t  i++;\n\t  continue;\n\t}\n      else if (c == '`')\n\t{\n\t  backq = 1;\n\t  histexp_backq++;\n\t  old_dquote = dquote;\t\t \n\t  dquote = 0;\n\t  i++;\n\t  continue;\n\t}\n       \n      else if (dquote && c == delims[0] && string[i+1] == '\"')\n\t{\n\t  i++;\n\t  continue;\n\t}\n      else if (c == delims[0])\n\tbreak;\n       \n      else if (dquote && c == '\\'')\n        {\n          i++;\n          continue;\n        }\n      else if (c == '\\'')\n\ti = skip_single_quoted (string, slen, ++i, 0);\n       \n      else if (posixly_correct == 0 && c == '\"')\n\t{\n\t  dquote = 1 - dquote;\n\t  i++;\n\t  continue;\n\t}     \n      else if (c == '\"')\n\ti = skip_double_quoted (string, slen, ++i, 0);\n#if defined (PROCESS_SUBSTITUTION)\n      else if ((c == '$' || c == '<' || c == '>') && string[i+1] == LPAREN && string[i+2] != LPAREN)\n#else\n      else if (c == '$' && string[i+1] == LPAREN && string[i+2] != LPAREN)\n#endif\n        {\n\t  if (string[i+2] == '\\0')\n\t    CQ_RETURN(i+2);\n\t  i += 2;\n\t  histexp_comsub++;\n\t  old_dquote = dquote;\n\t  dquote = 0;\n        }\n      else if (histexp_comsub && c == RPAREN)\n\t{\n\t  histexp_comsub--;\n\t  dquote = old_dquote;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq)\t\t \n\t{\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(i);\n}\n#endif  \n\n#if defined (READLINE)\n \n\nint\nchar_is_quoted (string, eindex)\n     char *string;\n     int eindex;\n{\n  int i, pass_next, c, oldjmp;\n  size_t slen;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  oldjmp = no_longjmp_on_fatal_error;\n  no_longjmp_on_fatal_error = 1;\n  i = pass_next = 0;\n\n   \n  if (current_command_line_count > 0 && dstack.delimiter_depth > 0)\n    {\n      c = dstack.delimiters[dstack.delimiter_depth - 1];\n      if (c == '\\'')\n\ti = skip_single_quoted (string, slen, 0, 0);\n      else if (c == '\"')\n\ti = skip_double_quoted (string, slen, 0, SX_COMPLETE);\n      if (i > eindex)\n\tCQ_RETURN (1);\n    }\n\n  while (i <= eindex)\n    {\n      c = string[i];\n\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (i >= eindex)\t \n\t    CQ_RETURN(1);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (c == '$' && string[i+1] == '\\'' && string[i+2])\n\t{\n\t  i += 2;\n\t  i = skip_single_quoted (string, slen, i, SX_COMPLETE);\n\t  if (i > eindex)\n\t    CQ_RETURN (i);\n\t}\n      else if (c == '\\'' || c == '\"')\n\t{\n\t  i = (c == '\\'') ? skip_single_quoted (string, slen, ++i, 0)\n\t\t\t  : skip_double_quoted (string, slen, ++i, SX_COMPLETE);\n\t  if (i > eindex)\n\t    CQ_RETURN(1);\n\t   \n\t}\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(0);\n}\n\nint\nunclosed_pair (string, eindex, openstr)\n     char *string;\n     int eindex;\n     char *openstr;\n{\n  int i, pass_next, openc, olen;\n  size_t slen;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  olen = strlen (openstr);\n  i = pass_next = openc = 0;\n  while (i <= eindex)\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (i >= eindex)\t \n\t    return 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (string[i] == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (STREQN (string + i, openstr, olen))\n\t{\n\t  openc = 1 - openc;\n\t  i += olen;\n\t}\n       \n      else if (string[i] == '\\'' || string[i] == '\"')\n\t{\n\t  i = (string[i] == '\\'') ? skip_single_quoted (string, slen, i, 0)\n\t\t\t\t  : skip_double_quoted (string, slen, i, SX_COMPLETE);\n\t  if (i > eindex)\n\t    return 0;\n\t}\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n  return (openc);\n}\n\n \nWORD_LIST *\nsplit_at_delims (string, slen, delims, sentinel, flags, nwp, cwp)\n     char *string;\n     int slen;\n     const char *delims;\n     int sentinel, flags;\n     int *nwp, *cwp;\n{\n  int ts, te, i, nw, cw, ifs_split, dflags;\n  char *token, *d, *d2;\n  WORD_LIST *ret, *tl;\n\n  if (string == 0 || *string == '\\0')\n    {\n      if (nwp)\n\t*nwp = 0;\n      if (cwp)\n\t*cwp = 0;\t\n      return ((WORD_LIST *)NULL);\n    }\n\n  d = (delims == 0) ? ifs_value : (char *)delims;\n  ifs_split = delims == 0;\n\n   \n  d2 = 0;\n  if (delims)\n    {\n      size_t slength;\n#if defined (HANDLE_MULTIBYTE)\n      size_t mblength = 1;\n#endif\n      DECLARE_MBSTATE;\n\n      slength = strlen (delims);\n      d2 = (char *)xmalloc (slength + 1);\n      i = ts = 0;\n      while (delims[i])\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  mbstate_t state_bak;\n\t  state_bak = state;\n\t  mblength = MBRLEN (delims + i, slength, &state);\n\t  if (MB_INVALIDCH (mblength))\n\t    state = state_bak;\n\t  else if (mblength > 1)\n\t    {\n\t      memcpy (d2 + ts, delims + i, mblength);\n\t      ts += mblength;\n\t      i += mblength;\n\t      slength -= mblength;\n\t      continue;\n\t    }\n#endif\n\t  if (whitespace (delims[i]) == 0)\n\t    d2[ts++] = delims[i];\n\n\t  i++;\n\t  slength--;\n\t}\n      d2[ts] = '\\0';\n    }\n\n  ret = (WORD_LIST *)NULL;\n\n   \n  for (i = 0; member (string[i], d) && spctabnl (string[i]); i++)\n    ;\n  if (string[i] == '\\0')\n    {\n      FREE (d2);\n      return (ret);\n    }\n\n  ts = i;\n  nw = 0;\n  cw = -1;\n  dflags = flags|SD_NOJMP;\n  while (1)\n    {\n      te = skip_to_delim (string, ts, d, dflags);\n\n       \n      if (ts == te && d2 && member (string[ts], d2))\n\t{\n\t  te = ts + 1;\n\t   \n\t  if (ifs_split)\n\t    while (member (string[te], d) && spctabnl (string[te]) && ((flags&SD_NOQUOTEDELIM) == 0 || (string[te] != '\\'' && string[te] != '\"')))\n\t      te++;\n\t  else\n\t    while (member (string[te], d2) && ((flags&SD_NOQUOTEDELIM) == 0 || (string[te] != '\\'' && string[te] != '\"')))\n\t      te++;\n\t}\n\n      token = substring (string, ts, te);\n\n      ret = add_string_to_list (token, ret);\t \n      free (token);\n      nw++;\n\n      if (sentinel >= ts && sentinel <= te)\n\tcw = nw;\n\n       \n      if (cwp && cw == -1 && sentinel == ts-1)\n\tcw = nw;\n\n       \n      if (cwp && cw == -1 && sentinel < ts)\n\t{\n\t  tl = make_word_list (make_word (\"\"), ret->next);\n\t  ret->next = tl;\n\t  cw = nw;\n\t  nw++;\n\t}\n\n      if (string[te] == 0)\n\tbreak;\n\n      i = te;\n       \n      while (member (string[i], d) && (ifs_split || spctabnl(string[i])) && ((flags&SD_NOQUOTEDELIM) == 0 || (string[te] != '\\'' && string[te] != '\"')))\n\ti++;\n\n      if (string[i])\n\tts = i;\n      else\n\tbreak;\n    }\n\n   \n  if (cwp && cw == -1 && (sentinel >= slen || sentinel >= te))\n    {\n      if (whitespace (string[sentinel - 1]))\n\t{\n\t  token = \"\";\n\t  ret = add_string_to_list (token, ret);\n\t  nw++;\n\t}\n      cw = nw;\n    }\n\n  if (nwp)\n    *nwp = nw;\n  if (cwp)\n    *cwp = cw;\n\n  FREE (d2);\n\n  return (REVERSE_LIST (ret, WORD_LIST *));\n}\n#endif  \n\n#if 0\n \n \nchar *\nassignment_name (string)\n     char *string;\n{\n  int offset;\n  char *temp;\n\n  offset = assignment (string, 0);\n  if (offset == 0)\n    return (char *)NULL;\n  temp = substring (string, 0, offset);\n  return (temp);\n}\n#endif\n\n \n \n \n \n \n\n \nchar *\nstring_list_internal (list, sep)\n     WORD_LIST *list;\n     char *sep;\n{\n  register WORD_LIST *t;\n  char *result, *r;\n  size_t word_len, sep_len, result_size;\n\n  if (list == 0)\n    return ((char *)NULL);\n\n   \n  if (list->next == 0)\n    return (savestring (list->word->word));\n\n   \n  sep_len = STRLEN (sep);\n  result_size = 0;\n\n  for (t = list; t; t = t->next)\n    {\n      if (t != list)\n\tresult_size += sep_len;\n      result_size += strlen (t->word->word);\n    }\n\n  r = result = (char *)xmalloc (result_size + 1);\n\n  for (t = list; t; t = t->next)\n    {\n      if (t != list && sep_len)\n\t{\n\t  if (sep_len > 1)\n\t    {\n\t      FASTCOPY (sep, r, sep_len);\n\t      r += sep_len;\n\t    }\n\t  else\n\t    *r++ = sep[0];\n\t}\n\n      word_len = strlen (t->word->word);\n      FASTCOPY (t->word->word, r, word_len);\n      r += word_len;\n    }\n\n  *r = '\\0';\n  return (result);\n}\n\n \nchar *\nstring_list (list)\n     WORD_LIST *list;\n{\n  return (string_list_internal (list, \" \"));\n}\n\n \nchar *\nifs_firstchar (lenp)\n     int *lenp;\n{\n  char *ret;\n  int len;\n\n  ret = xmalloc (MB_LEN_MAX + 1);\n#if defined (HANDLE_MULTIBYTE)\n  if (ifs_firstc_len == 1)\n    {\n      ret[0] = ifs_firstc[0];\n      ret[1] = '\\0';\n      len = ret[0] ? 1 : 0;\n    }\n  else\n    {\n      memcpy (ret, ifs_firstc, ifs_firstc_len);\n      ret[len = ifs_firstc_len] = '\\0';\n    }\n#else\n  ret[0] = ifs_firstc;\n  ret[1] = '\\0';\n  len = ret[0] ? 0 : 1;\n#endif\n\n  if (lenp)\n    *lenp = len;\n\n  return ret;\n}\n\n \n \nchar *\nstring_list_dollar_star (list, quoted, flags)\n     WORD_LIST *list;\n     int quoted, flags;\n{\n  char *ret;\n#if defined (HANDLE_MULTIBYTE)\n#  if defined (__GNUC__)\n  char sep[MB_CUR_MAX + 1];\n#  else\n  char *sep = 0;\n#  endif\n#else\n  char sep[2];\n#endif\n\n#if defined (HANDLE_MULTIBYTE)\n#  if !defined (__GNUC__)\n  sep = (char *)xmalloc (MB_CUR_MAX + 1);\n#  endif  \n  if (ifs_firstc_len == 1)\n    {\n      sep[0] = ifs_firstc[0];\n      sep[1] = '\\0';\n    }\n  else\n    {\n      memcpy (sep, ifs_firstc, ifs_firstc_len);\n      sep[ifs_firstc_len] = '\\0';\n    }\n#else\n  sep[0] = ifs_firstc;\n  sep[1] = '\\0';\n#endif\n\n  ret = string_list_internal (list, sep);\n#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)\n  free (sep);\n#endif\n  return ret;\n}\n\n \nchar *\nstring_list_dollar_at (list, quoted, flags)\n     WORD_LIST *list;\n     int quoted;\n     int flags;\n{\n  char *ifs, *ret;\n#if defined (HANDLE_MULTIBYTE)\n#  if defined (__GNUC__)\n  char sep[MB_CUR_MAX + 1];\n#  else\n  char *sep = 0;\n#  endif  \n#else\n  char sep[2];\n#endif\n  WORD_LIST *tlist;\n\n   \n  ifs = ifs_var ? value_cell (ifs_var) : (char *)0;\n\n#if defined (HANDLE_MULTIBYTE)\n#  if !defined (__GNUC__)\n  sep = (char *)xmalloc (MB_CUR_MAX + 1);\n#  endif  \n   \n  if (flags & PF_ASSIGNRHS)\n    {\n      sep[0] = ' ';\n      sep[1] = '\\0';\n    }\n  else if (ifs && *ifs)\n    {\n      if (ifs_firstc_len == 1)\n\t{\n\t  sep[0] = ifs_firstc[0];\n\t  sep[1] = '\\0';\n\t}\n      else\n\t{\n\t  memcpy (sep, ifs_firstc, ifs_firstc_len);\n\t  sep[ifs_firstc_len] = '\\0';\n\t}\n    }\n  else\n    {\n      sep[0] = ' ';\n      sep[1] = '\\0';\n    }\n#else\t \n   \n  sep[0] = ((flags & PF_ASSIGNRHS) || ifs == 0 || *ifs == 0) ? ' ' : *ifs;\n  sep[1] = '\\0';\n#endif\t \n\n   \n  tlist = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))\n\t\t? quote_list (list)\n\t\t: list_quote_escapes (list);\n\n  ret = string_list_internal (tlist, sep);\n#if defined (HANDLE_MULTIBYTE) && !defined (__GNUC__)\n  free (sep);\n#endif\n  return ret;\n}\n\n \n \nchar *\nstring_list_pos_params (pchar, list, quoted, pflags)\n     int pchar;\n     WORD_LIST *list;\n     int quoted, pflags;\n{\n  char *ret;\n  WORD_LIST *tlist;\n\n  if (pchar == '*' && (quoted & Q_DOUBLE_QUOTES))\n    {\n      tlist = quote_list (list);\n      word_list_remove_quoted_nulls (tlist);\n      ret = string_list_dollar_star (tlist, 0, 0);\n    }\n  else if (pchar == '*' && (quoted & Q_HERE_DOCUMENT))\n    {\n      tlist = quote_list (list);\n      word_list_remove_quoted_nulls (tlist);\n      ret = string_list (tlist);\n    }\n  else if (pchar == '*' && quoted == 0 && ifs_is_null)\t \n    ret = expand_no_split_dollar_star ? string_list_dollar_star (list, quoted, 0) : string_list_dollar_at (list, quoted, 0);\t \n  else if (pchar == '*' && quoted == 0 && (pflags & PF_ASSIGNRHS))\t \n    ret = expand_no_split_dollar_star ? string_list_dollar_star (list, quoted, 0) : string_list_dollar_at (list, quoted, 0);\t \n  else if (pchar == '*')\n    {\n       \n      ret = string_list_dollar_star (list, quoted, 0);\n    }\n  else if (pchar == '@' && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n     \n    ret = string_list_dollar_at (list, quoted, 0);\n  else if (pchar == '@' && quoted == 0 && ifs_is_null)\t \n    ret = string_list_dollar_at (list, quoted, 0);\t \n  else if (pchar == '@' && quoted == 0 && (pflags & PF_ASSIGNRHS))\n    ret = string_list_dollar_at (list, quoted, pflags);\t \n  else if (pchar == '@')\n    ret = string_list_dollar_star (list, quoted, 0);\n  else\n    ret = string_list ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? quote_list (list) : list);\n\n  return ret;\n}\n\n \n\n \n\n \n#define issep(c) \\\n\t(((separators)[0]) ? ((separators)[1] ? isifs(c) \\\n\t\t\t\t\t      : (c) == (separators)[0]) \\\n\t\t\t   : 0)\n\n \n#define ifs_whitespace(c)\tISSPACE(c)\n\n \n#define ifs_whitesep(c)\t((sh_style_split || separators == 0) ? spctabnl (c) \\\n\t\t\t\t\t\t\t     : ifs_whitespace (c))\n\nWORD_LIST *\nlist_string (string, separators, quoted)\n     register char *string, *separators;\n     int quoted;\n{\n  WORD_LIST *result;\n  WORD_DESC *t;\n  char *current_word, *s;\n  int sindex, sh_style_split, whitesep, xflags, free_word;\n  size_t slen;\n\n  if (!string || !*string)\n    return ((WORD_LIST *)NULL);\n\n  sh_style_split = separators && separators[0] == ' ' &&\n\t\t\t\t separators[1] == '\\t' &&\n\t\t\t\t separators[2] == '\\n' &&\n\t\t\t\t separators[3] == '\\0';\n  for (xflags = 0, s = ifs_value; s && *s; s++)\n    {\n      if (*s == CTLESC) xflags |= SX_NOCTLESC;\n      else if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;\n    }\n\n  slen = 0;\n   \n#if 0\n  if (!quoted || !separators || !*separators)\n#else\n   \n  if (!quoted && separators && *separators)\n#endif\n    {\n      for (s = string; *s && issep (*s) && ifs_whitespace (*s); s++);\n\n      if (!*s)\n\treturn ((WORD_LIST *)NULL);\n\n      string = s;\n    }\n\n   \n  slen = STRLEN (string);\n  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )\n    {\n       \n      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);\n      if (current_word == 0)\n\tbreak;\n\n      free_word = 1;\t \n\n       \n      if (QUOTED_NULL (current_word))\n\t{\n\t  t = alloc_word_desc ();\n\t  t->word = make_quoted_char ('\\0');\n\t  t->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  result = make_word_list (t, result);\n\t}\n      else if (current_word[0] != '\\0')\n\t{\n\t   \n\t  remove_quoted_nulls (current_word);\n\n\t   \n\t  t = alloc_word_desc ();\n\t  t->word = current_word;\n\t  result = make_word_list (t, result);\n\t  free_word = 0;\n\t  result->word->flags &= ~W_HASQUOTEDNULL;\t \n\t  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))\n\t    result->word->flags |= W_QUOTED;\n\t   \n\t  if (current_word == 0 || current_word[0] == '\\0')\n\t    result->word->flags |= W_SAWQUOTEDNULL;\n\t}\n\n       \n      else if (!sh_style_split && !ifs_whitespace (string[sindex]))\n\t{\n\t  t = alloc_word_desc ();\n\t  t->word = make_quoted_char ('\\0');\n\t  t->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  result = make_word_list (t, result);\n\t}\n\n      if (free_word)\n\tfree (current_word);\n\n       \n      whitesep = string[sindex] && ifs_whitesep (string[sindex]);\n\n       \n      if (string[sindex])\n\t{\n\t  DECLARE_MBSTATE;\n\t  ADVANCE_CHAR (string, slen, sindex);\n\t}\n\n       \n      while (string[sindex] && ifs_whitesep (string[sindex]) && issep (string[sindex]))\n\tsindex++;\n\n       \n      if (string[sindex] && whitesep && issep (string[sindex]) && !ifs_whitesep (string[sindex]))\n\t{\n\t  sindex++;\n\t   \n\t  while (string[sindex] && ifs_whitesep (string[sindex]) && isifs (string[sindex]))\n\t    sindex++;\n\t}\n    }\n  return (REVERSE_LIST (result, WORD_LIST *));\n}\n\n \n\n \n#define islocalsep(c)\t(local_cmap[(unsigned char)(c)] != 0)\n\nchar *\nget_word_from_string (stringp, separators, endptr)\n     char **stringp, *separators, **endptr;\n{\n  register char *s;\n  char *current_word;\n  int sindex, sh_style_split, whitesep, xflags;\n  unsigned char local_cmap[UCHAR_MAX+1];\t \n  size_t slen;\n\n  if (!stringp || !*stringp || !**stringp)\n    return ((char *)NULL);\n\n  sh_style_split = separators && separators[0] == ' ' &&\n\t\t\t\t separators[1] == '\\t' &&\n\t\t\t\t separators[2] == '\\n' &&\n\t\t\t\t separators[3] == '\\0';\n  memset (local_cmap, '\\0', sizeof (local_cmap));\n  for (xflags = 0, s = separators; s && *s; s++)\n    {\n      if (*s == CTLESC) xflags |= SX_NOCTLESC;\n      if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;\n      local_cmap[(unsigned char)*s] = 1;\t \n    }\n\n  s = *stringp;\n  slen = 0;\n\n   \n  if (sh_style_split || separators == 0)\n    for (; *s && spctabnl (*s) && islocalsep (*s); s++);\n  else\n    for (; *s && ifs_whitespace (*s) && islocalsep (*s); s++);\n\n   \n  if (!*s)\n    {\n      *stringp = s;\n      if (endptr)\n\t*endptr = s;\n      return ((char *)NULL);\n    }\n\n   \n  sindex = 0;\n   \n  slen = STRLEN (s);\n  current_word = string_extract_verbatim (s, slen, &sindex, separators, xflags);\n\n   \n  if (endptr)\n    *endptr = s + sindex;\n\n   \n  whitesep = s[sindex] && ifs_whitesep (s[sindex]);\n\n   \n  if (s[sindex])\n    {\n      DECLARE_MBSTATE;\n      ADVANCE_CHAR (s, slen, sindex);\n    }\n\n   \n  while (s[sindex] && spctabnl (s[sindex]) && islocalsep (s[sindex]))\n    sindex++;\n\n   \n  if (s[sindex] && whitesep && islocalsep (s[sindex]) && !ifs_whitesep (s[sindex]))\n    {\n      sindex++;\n       \n      while (s[sindex] && ifs_whitesep (s[sindex]) && islocalsep(s[sindex]))\n\tsindex++;\n    }\n\n   \n  *stringp = s + sindex;\n  return (current_word);\n}\n\n \nchar *\nstrip_trailing_ifs_whitespace (string, separators, saw_escape)\n     char *string, *separators;\n     int saw_escape;\n{\n  char *s;\n\n  s = string + STRLEN (string) - 1;\n  while (s > string && ((spctabnl (*s) && isifs (*s)) ||\n\t\t\t(saw_escape && *s == CTLESC && spctabnl (s[1]))))\n    s--;\n  *++s = '\\0';\n  return string;\n}\n\n#if 0\n \n \nWORD_LIST *\nlist_string_with_quotes (string)\n     char *string;\n{\n  WORD_LIST *list;\n  char *token, *s;\n  size_t s_len;\n  int c, i, tokstart, len;\n\n  for (s = string; s && *s && spctabnl (*s); s++)\n    ;\n  if (s == 0 || *s == 0)\n    return ((WORD_LIST *)NULL);\n\n  s_len = strlen (s);\n  tokstart = i = 0;\n  list = (WORD_LIST *)NULL;\n  while (1)\n    {\n      c = s[i];\n      if (c == '\\\\')\n\t{\n\t  i++;\n\t  if (s[i])\n\t    i++;\n\t}\n      else if (c == '\\'')\n\ti = skip_single_quoted (s, s_len, ++i, 0);\n      else if (c == '\"')\n\ti = skip_double_quoted (s, s_len, ++i, 0);\n      else if (c == 0 || spctabnl (c))\n\t{\n\t   \n\t  token = substring (s, tokstart, i);\n\t  list = add_string_to_list (token, list);\n\t  free (token);\n\t  while (spctabnl (s[i]))\n\t    i++;\n\t  if (s[i])\n\t    tokstart = i;\n\t  else\n\t    break;\n\t}\n      else\n\ti++;\t \n    }\n  return (REVERSE_LIST (list, WORD_LIST *));\n}\n#endif\n\n \n \n \n \n \n\n#if defined (ARRAY_VARS)\nstatic SHELL_VAR *\ndo_compound_assignment (name, value, flags)\n     char *name, *value;\n     int flags;\n{\n  SHELL_VAR *v;\n  int mklocal, mkassoc, mkglobal, chklocal;\n  WORD_LIST *list;\n  char *newname;\t \n\n  mklocal = flags & ASS_MKLOCAL;\n  mkassoc = flags & ASS_MKASSOC;\n  mkglobal = flags & ASS_MKGLOBAL;\n  chklocal = flags & ASS_CHKLOCAL;\n\n  if (mklocal && variable_context)\n    {\n      v = find_variable (name);\t\t \n      newname = (v == 0) ? nameref_transform_name (name, flags) : v->name;\n      if (v && ((readonly_p (v) && (flags & ASS_FORCE) == 0) || noassign_p (v)))\n\t{\n\t  if (readonly_p (v))\n\t    err_readonly (name);\n\t  return (v);\t \n\t}\n      list = expand_compound_array_assignment (v, value, flags);\n      if (mkassoc)\n\tv = make_local_assoc_variable (newname, 0);\n      else if (v == 0 || (array_p (v) == 0 && assoc_p (v) == 0) || v->context != variable_context)\n        v = make_local_array_variable (newname, 0);\n      if (v)\n\tassign_compound_array_list (v, list, flags);\n      if (list)\n\tdispose_words (list);\n    }\n   \n  else if (mkglobal && variable_context)\n    {\n      v = chklocal ? find_variable (name) : 0;\n      if (v && (local_p (v) == 0 || v->context != variable_context))\n\tv = 0;\n      if (v == 0)\n        v = find_global_variable (name);\n      if (v && ((readonly_p (v) && (flags & ASS_FORCE) == 0) || noassign_p (v)))\n\t{\n\t  if (readonly_p (v))\n\t    err_readonly (name);\n\t  return (v);\t \n\t}\n       \n      newname = (v == 0) ? nameref_transform_name (name, flags) : name;\n      list = expand_compound_array_assignment (v, value, flags);\n      if (v == 0 && mkassoc)\n\tv = make_new_assoc_variable (newname);\n      else if (v && mkassoc && assoc_p (v) == 0)\n\tv = convert_var_to_assoc (v);\n      else if (v == 0)\n\tv = make_new_array_variable (newname);\n      else if (v && mkassoc == 0 && array_p (v) == 0)\n\tv = convert_var_to_array (v);\n      if (v)\n\tassign_compound_array_list (v, list, flags);\n      if (list)\n\tdispose_words (list);\n    }\n  else\n    {\n      v = assign_array_from_string (name, value, flags);\n      if (v && ((readonly_p (v) && (flags & ASS_FORCE) == 0) || noassign_p (v)))\n\t{\n\t  if (readonly_p (v))\n\t    err_readonly (name);\n\t  return (v);\t \n\t}\n    }\n\n  return (v);\n}\n#endif\n\n \nstatic int\ndo_assignment_internal (word, expand)\n     const WORD_DESC *word;\n     int expand;\n{\n  int offset, appendop, assign_list, aflags, retval;\n  char *name, *value, *temp;\n  SHELL_VAR *entry;\n#if defined (ARRAY_VARS)\n  char *t;\n  int ni;\n#endif\n  const char *string;\n\n  if (word == 0 || word->word == 0)\n    return 0;\n\n  appendop = assign_list = aflags = 0;\n  string = word->word;\n  offset = assignment (string, 0);\n  name = savestring (string);\n  value = (char *)NULL;\n\n  if (name[offset] == '=')\n    {\n      if (name[offset - 1] == '+')\n\t{\n\t  appendop = 1;\n\t  name[offset - 1] = '\\0';\n\t}\n\n      name[offset] = 0;\t\t \n      temp = name + offset + 1;\n\n#if defined (ARRAY_VARS)\n      if (expand && (word->flags & W_COMPASSIGN))\n\t{\n\t  assign_list = ni = 1;\n\t  value = extract_array_assignment_list (temp, &ni);\n\t}\n      else\n#endif\n      if (expand && temp[0])\n\tvalue = expand_string_if_necessary (temp, 0, expand_string_assignment);\n      else\n\tvalue = savestring (temp);\n    }\n\n  if (value == 0)\n    {\n      value = (char *)xmalloc (1);\n      value[0] = '\\0';\n    }\n\n  if (echo_command_at_execute)\n    {\n      if (appendop)\n\tname[offset - 1] = '+';\n      xtrace_print_assignment (name, value, assign_list, 1);\n      if (appendop)\n\tname[offset - 1] = '\\0';\n    }\n\n#define ASSIGN_RETURN(r)\tdo { FREE (value); free (name); return (r); } while (0)\n\n  if (appendop)\n    aflags |= ASS_APPEND;\n\n#if defined (ARRAY_VARS)\n  if (t = mbschr (name, LBRACK))\n    {\n      if (assign_list)\n\t{\n\t  report_error (_(\"%s: cannot assign list to array member\"), name);\n\t  ASSIGN_RETURN (0);\n\t}\n      aflags |= ASS_ALLOWALLSUB;\t \n      entry = assign_array_element (name, value, aflags, (array_eltstate_t *)0);\n      if (entry == 0)\n\tASSIGN_RETURN (0);\n    }\n  else if (assign_list)\n    {\n      if ((word->flags & W_ASSIGNARG) && (word->flags & W_CHKLOCAL))\n\taflags |= ASS_CHKLOCAL;\n      if ((word->flags & W_ASSIGNARG) && (word->flags & W_ASSNGLOBAL) == 0)\n\taflags |= ASS_MKLOCAL;\n      if ((word->flags & W_ASSIGNARG) && (word->flags & W_ASSNGLOBAL))\n\taflags |= ASS_MKGLOBAL;\n      if (word->flags & W_ASSIGNASSOC)\n\taflags |= ASS_MKASSOC;\n      entry = do_compound_assignment (name, value, aflags);\n    }\n  else\n#endif  \n  entry = bind_variable (name, value, aflags);\n\n  if (entry)\n    stupidly_hack_special_variables (entry->name);\t \n  else\n    stupidly_hack_special_variables (name);\n\n   \n  if (entry == 0 || readonly_p (entry))\n    retval = 0;\t\t \n  else if (noassign_p (entry))\n    {\n      set_exit_status (EXECUTION_FAILURE);\n      retval = 1;\t \n    }\n  else\n    retval = 1;\n\n  if (entry && retval != 0 && noassign_p (entry) == 0)\n    VUNSETATTR (entry, att_invisible);\n\n  ASSIGN_RETURN (retval);\n}\n\n \nint\ndo_assignment (string)\n     char *string;\n{\n  WORD_DESC td;\n\n  td.flags = W_ASSIGNMENT;\n  td.word = string;\n\n  return do_assignment_internal (&td, 1);\n}\n\nint\ndo_word_assignment (word, flags)\n     WORD_DESC *word;\n     int flags;\n{\n  return do_assignment_internal (word, 1);\n}\n\n \nint\ndo_assignment_no_expand (string)\n     char *string;\n{\n  WORD_DESC td;\n\n  td.flags = W_ASSIGNMENT;\n  td.word = string;\n\n  return (do_assignment_internal (&td, 0));\n}\n\n \n\n \nWORD_LIST *\nlist_rest_of_args ()\n{\n  register WORD_LIST *list, *args;\n  int i;\n\n   \n  for (i = 1, list = (WORD_LIST *)NULL; i < 10 && dollar_vars[i]; i++)\n    list = make_word_list (make_bare_word (dollar_vars[i]), list);\n\n  for (args = rest_of_args; args; args = args->next)\n    list = make_word_list (make_bare_word (args->word->word), list);\n\n  return (REVERSE_LIST (list, WORD_LIST *));\n}\n\n \nchar *\nget_dollar_var_value (ind)\n     intmax_t ind;\n{\n  char *temp;\n  WORD_LIST *p;\n\n  if (ind < 10)\n    temp = dollar_vars[ind] ? savestring (dollar_vars[ind]) : (char *)NULL;\n  else\t \n    {\n      ind -= 10;\n      for (p = rest_of_args; p && ind--; p = p->next)\n\t;\n      temp = p ? savestring (p->word->word) : (char *)NULL;\n    }\n  return (temp);\n}\n\n \nchar *\nstring_rest_of_args (dollar_star)\n     int dollar_star;\n{\n  register WORD_LIST *list;\n  char *string;\n\n  list = list_rest_of_args ();\n  string = dollar_star ? string_list_dollar_star (list, 0, 0) : string_list (list);\n  dispose_words (list);\n  return (string);\n}\n\n \nstatic char *\npos_params (string, start, end, quoted, pflags)\n     char *string;\n     int start, end, quoted, pflags;\n{\n  WORD_LIST *save, *params, *h, *t;\n  char *ret;\n  int i;\n\n   \n  if (start == end)\n    return ((char *)NULL);\n\n  save = params = list_rest_of_args ();\n  if (save == 0 && start > 0)\n    return ((char *)NULL);\n\n  if (start == 0)\t\t \n    {\n      t = make_word_list (make_word (dollar_vars[0]), params);\n      save = params = t;\n    }\n\n  for (i = start ? 1 : 0; params && i < start; i++)\n    params = params->next;\n  if (params == 0)\n    {\n      dispose_words (save);\n      return ((char *)NULL);\n    }\n  for (h = t = params; params && i < end; i++)\n    {\n      t = params;\n      params = params->next;\n    }\n  t->next = (WORD_LIST *)NULL;\n\n  ret = string_list_pos_params (string[0], h, quoted, pflags);\n\n  if (t != params)\n    t->next = params;\n\n  dispose_words (save);\n  return (ret);\n}\n\n \n \n \n \n \n\n#if defined (PROCESS_SUBSTITUTION)\n#define EXP_CHAR(s) (s == '$' || s == '`' || s == '<' || s == '>' || s == CTLESC || s == '~')\n#else\n#define EXP_CHAR(s) (s == '$' || s == '`' || s == CTLESC || s == '~')\n#endif\n\n \n#define ARITH_EXP_CHAR(s) (s == '$' || s == '`' || s == CTLESC || s == '~')\n\n \nstatic char *\nexpand_string_if_necessary (string, quoted, func)\n     char *string;\n     int quoted;\n     EXPFUNC *func;\n{\n  WORD_LIST *list;\n  size_t slen;\n  int i, saw_quote;\n  char *ret;\n  DECLARE_MBSTATE;\n\n   \n  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;\n  i = saw_quote = 0;\n  while (string[i])\n    {\n      if (EXP_CHAR (string[i]))\n\tbreak;\n      else if (string[i] == '\\'' || string[i] == '\\\\' || string[i] == '\"')\n\tsaw_quote = 1;\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  if (string[i])\n    {\n      list = (*func) (string, quoted);\n      if (list)\n\t{\n\t  ret = string_list (list);\n\t  dispose_words (list);\n\t}\n      else\n\tret = (char *)NULL;\n    }\n  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n    ret = string_quote_removal (string, quoted);\n  else\n    ret = savestring (string);\n\n  return ret;\n}\n\nstatic inline char *\nexpand_string_to_string_internal (string, quoted, func)\n     char *string;\n     int quoted;\n     EXPFUNC *func;\n{\n  WORD_LIST *list;\n  char *ret;\n\n  if (string == 0 || *string == '\\0')\n    return ((char *)NULL);\n\n  list = (*func) (string, quoted);\n  if (list)\n    {\n      ret = string_list (list);\n      dispose_words (list);\n    }\n  else\n    ret = (char *)NULL;\n\n  return (ret);\n}\n\nchar *\nexpand_string_to_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  return (expand_string_to_string_internal (string, quoted, expand_string));\n}\n\nchar *\nexpand_string_unsplit_to_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  return (expand_string_to_string_internal (string, quoted, expand_string_unsplit));\n}\n\nchar *\nexpand_assignment_string_to_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  return (expand_string_to_string_internal (string, quoted, expand_string_assignment));\n}\n\n \nstatic char *\nquote_string_for_repl (string, flags)\n     char *string;\n     int flags;\n{\n  size_t slen;\n  char *result, *t;\n  const char *s, *send;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n\n  result = (char *)xmalloc (slen * 2 + 1);\n\n  if (string[0] == CTLESC && string[1] == 0)\n    {\n      result[0] = CTLESC;\n      result[1] = '\\0';\n      return (result);\n    }\n\n   \n\n  for (s = string, t = result; *s; )\n    {\n       \n      if (*s == CTLESC && (s[1] == '&' || s[1] == '\\\\'))\n        {\n          *t++ = '\\\\';\n          s++;\n          *t++ = *s++;\n          continue;\n        }\n       \n      if (*s == CTLESC)\n        {\n\t  s++;\n\t  if (*s == '\\0')\n\t    break;\n        }\n      COPY_CHAR_P (t, s, send);\n    }\n\n  *t = '\\0';\n  return (result);\n}\n\t\n \nstatic char *\nexpand_string_for_patsub (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_LIST *value;\n  char *ret, *t;\n\n  if (string == 0 || *string == '\\0')\n    return (char *)NULL;\n\n  value = expand_string_for_pat (string, quoted, (int *)0, (int *)0);\n\n  if (value && value->word)\n    {\n      remove_quoted_nulls (value->word->word);\t \n      value->word->flags &= ~W_HASQUOTEDNULL;\n    }\n\n  if (value)\n    {\n      t = (value->next) ? string_list (value) : value->word->word;\n      ret = quote_string_for_repl (t, quoted);\n      if (t != value->word->word)\n\tfree (t);\n      dispose_words (value);\n    }\n  else\n    ret = (char *)NULL;\n\n  return (ret);\n}\n\nchar *\nexpand_arith_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_DESC td;\n  WORD_LIST *list, *tlist;\n  size_t slen;\n  int i, saw_quote;\n  char *ret;\n  DECLARE_MBSTATE;\n\n   \n  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;\n  i = saw_quote = 0;\n  while (string[i])\n    {\n      if (ARITH_EXP_CHAR (string[i]))\n\tbreak;\n      else if (string[i] == '\\'' || string[i] == '\\\\' || string[i] == '\"')\n\tsaw_quote = string[i];\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  if (string[i])\n    {\n       \n      td.flags = W_NOPROCSUB|W_NOTILDE;\t \n#if 0\t \n      if (quoted & Q_ARRAYSUB)\n\ttd.flags |= W_NOCOMSUB;\n#endif\n      td.word = savestring (string);\n      list = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);\n       \n      if (list)\n\t{\n\t  tlist = word_list_split (list);\n\t  dispose_words (list);\n\t  list = tlist;\n\t  if (list)\n\t    dequote_list (list);\n\t}\n       \n      if (list)\n\t{\n\t  ret = string_list (list);\n\t  dispose_words (list);\n\t}\n      else\n\tret = (char *)NULL;\n      FREE (td.word);\n    }\n  else if (saw_quote && (quoted & Q_ARITH))\n    ret = string_quote_removal (string, quoted);\n  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n    ret = string_quote_removal (string, quoted);\n  else\n    ret = savestring (string);\n\n  return ret;\n}\n\n#if defined (COND_COMMAND)\n \nchar *\nremove_backslashes (string)\n     char *string;\n{\n  char *r, *ret, *s;\n\n  r = ret = (char *)xmalloc (strlen (string) + 1);\n  for (s = string; s && *s; )\n    {\n      if (*s == '\\\\')\n\ts++;\n      if (*s == 0)\n\tbreak;\n      *r++ = *s++;\n    }\n  *r = '\\0';\n  return ret;\n}\n\n \n \nchar *\ncond_expand_word (w, special)\n     WORD_DESC *w;\n     int special;\n{\n  char *r, *p;\n  WORD_LIST *l;\n  int qflags;\n\n  if (w->word == 0 || w->word[0] == '\\0')\n    return ((char *)NULL);\n\n  expand_no_split_dollar_star = 1;\n  w->flags |= W_NOSPLIT2;\n  qflags = (special == 3) ? Q_ARITH : 0;\n  l = call_expand_word_internal (w, qflags, 0, (int *)0, (int *)0);\n  expand_no_split_dollar_star = 0;\n  if (l)\n    {\n      if (special == 0)\t\t\t \n\t{\n\t  if (l->word)\n\t    word_list_remove_quoted_nulls (l);\n\t  dequote_list (l);\n\t  r = string_list (l);\n\t}\n      else if (special == 3)\t\t \n\t{\n\t  if (l->word)\n\t    word_list_remove_quoted_nulls (l);\t \n\t  dequote_list (l);\n\t  r = string_list (l);\n\t}\n      else\n\t{\n\t   \n\t  qflags = QGLOB_CVTNULL|QGLOB_CTLESC;\n\t  if (special == 2)\n\t    qflags |= QGLOB_REGEXP;\n\t  word_list_remove_quoted_nulls (l);\n\t  p = string_list (l);\n\t  r = quote_string_for_globbing (p, qflags);\n\t  free (p);\n\t}\n      dispose_words (l);\n    }\n  else\n    r = (char *)NULL;\n\n  return r;\n}\n#endif\n\n \nchar *\nexpand_string_dollar_quote (string, flags)\n     char *string;\n     int flags;\n{\n  size_t slen, retind, retsize;\n  int sindex, c, translen, peekc, news;\n  char *ret, *trans, *send, *t;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n  sindex = 0;\n\n  retsize = slen + 1;\n  ret = xmalloc (retsize);\n  retind = 0;\n\n  while (c = string[sindex])\n    {\n      switch (c)\n\t{\n\tdefault:\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, locale_mb_cur_max + 1, retsize, 64);\n\t  COPY_CHAR_I (ret, retind, string, send, sindex);\n\t  break;\n\n\tcase '\\\\':\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, locale_mb_cur_max + 2, retsize, 64);\n\t  ret[retind++] = string[sindex++];\n\n\t  if (string[sindex])\n\t    COPY_CHAR_I (ret, retind, string, send, sindex);\n\t  break;\n\n\tcase '\\'':\n\tcase '\"':\n\t  if (c == '\\'')\n\t    news = skip_single_quoted (string, slen, ++sindex, SX_COMPLETE);\n\t  else\n\t    news = skip_double_quoted (string, slen, ++sindex, SX_COMPLETE);\n\t  translen = news - sindex - 1;\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, translen + 3, retsize, 64);\n\t  ret[retind++] = c;\n\t  if (translen > 0)\n\t    {\n\t      strncpy (ret + retind, string + sindex, translen);\n\t      retind += translen;\n\t    }\n\t  if (news > sindex && string[news - 1] == c)\n\t    ret[retind++] = c;\n\t  sindex = news;\n\t  break;\n\n\tcase CTLESC:\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, locale_mb_cur_max + 2, retsize, 64);\n\t  if (flags)\n\t    ret[retind++] = string[sindex++];\n\t  if (string[sindex])\n\t    COPY_CHAR_I (ret, retind, string, send, sindex);\n\t  break;\n\n\tcase '$':\n\t  peekc = string[++sindex];\n#if defined (TRANSLATABLE_STRINGS)\n\t  if (peekc != '\\'' && peekc != '\"')\n#else\n\t  if (peekc != '\\'')\n#endif\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (ret, retind, 2, retsize, 16);\n\t      ret[retind++] = c;\n\t      break;\n\t    }\n\t  if (string[sindex + 1] == '\\0')\t \t\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (ret, retind, 3, retsize, 16);\n\t      ret[retind++] = c;\n\t      ret[retind++] = peekc;\n\t      sindex++;\n\t      break;\n\t    }\n\t  if (peekc == '\\'')\n\t    {\n\t       \n\t       \n\t      news = skip_single_quoted (string, slen, ++sindex, SX_COMPLETE);\n\t       \n\t      if (news > sindex && string[news] == '\\0' && string[news-1] != peekc)\n\t\t{\n\t\t  RESIZE_MALLOCED_BUFFER (ret, retind, 3, retsize, 16);\n\t\t  ret[retind++] = c;\n\t\t  ret[retind++] = peekc;\n\t\t  continue;\n\t\t}\n\t      t = substring (string, sindex, news - 1);\n\t      trans = ansiexpand (t, 0, news-sindex-1, &translen);\n\t      free (t);\n\t      t = sh_single_quote (trans);\n\t      sindex = news;\n\t    }\n#if defined (TRANSLATABLE_STRINGS)\n\t  else\n\t    {\n\t      news = ++sindex;\n\t      t = string_extract_double_quoted (string, &news, SX_COMPLETE);\n\t       \n\t      if (news > sindex && string[news] == '\\0' && string[news-1] != peekc)\n\t\t{\n\t\t  RESIZE_MALLOCED_BUFFER (ret, retind, 3, retsize, 16);\n\t\t  ret[retind++] = c;\n\t\t  ret[retind++] = peekc;\n\t\t  free (t);\n\t\t  continue;\n\t\t}\n\t      trans = locale_expand (t, 0, news-sindex, 0, &translen);\n\t      free (t);\n\t      if (singlequote_translations &&\n\t\t    ((news-sindex-1) != translen || STREQN (t, trans, translen) == 0))\n\t\tt = sh_single_quote (trans);\n\t      else\n\t\tt = sh_mkdoublequoted (trans, translen, 0);\n\t      sindex = news;\n\t    }\n#endif  \n\t  free (trans);\n\t  trans = t;\n\t  translen = strlen (trans);\n\n\t  RESIZE_MALLOCED_BUFFER (ret, retind, translen + 1, retsize, 128);\n\t  strcpy (ret + retind, trans);\n\t  retind += translen;\n\t  FREE (trans);\n\t  break;\n\t}\n    }\n\n  ret[retind] = 0;\n  return ret;\n}\n\n \nstatic WORD_LIST *\ncall_expand_word_internal (w, q, i, c, e)\n     WORD_DESC *w;\n     int q, i, *c, *e;\n{\n  WORD_LIST *result;\n\n  result = expand_word_internal (w, q, i, c, e);\n  if (result == &expand_word_error || result == &expand_word_fatal)\n    {\n       \n      w->word = (char *)NULL;\n      last_command_exit_value = EXECUTION_FAILURE;\n      exp_jump_to_top_level ((result == &expand_word_error) ? DISCARD : FORCE_EOF);\n       \n      return (NULL);\n    }\n  else\n    return (result);\n}\n\n \nstatic WORD_LIST *\nexpand_string_internal (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_DESC td;\n  WORD_LIST *tresult;\n\n  if (string == 0 || *string == 0)\n    return ((WORD_LIST *)NULL);\n\n  td.flags = 0;\n  td.word = savestring (string);\n\n  tresult = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);\n\n  FREE (td.word);\n  return (tresult);\n}\n\n \nWORD_LIST *\nexpand_string_unsplit (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_LIST *value;\n\n  if (string == 0 || *string == '\\0')\n    return ((WORD_LIST *)NULL);\n\n  expand_no_split_dollar_star = 1;\n  value = expand_string_internal (string, quoted);\n  expand_no_split_dollar_star = 0;\n\n  if (value)\n    {\n      if (value->word)\n\t{\n\t  remove_quoted_nulls (value->word->word);\t \n\t  value->word->flags &= ~W_HASQUOTEDNULL;\n\t}\n      dequote_list (value);\n    }\n  return (value);\n}\n\n \nWORD_LIST *\nexpand_string_assignment (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_DESC td;\n  WORD_LIST *value;\n\n  if (string == 0 || *string == '\\0')\n    return ((WORD_LIST *)NULL);\n\n  expand_no_split_dollar_star = 1;\n\n#if 0\n   \n  td.flags = W_ASSIGNRHS|W_NOSPLIT2;\t\t \n#else\n  td.flags = W_ASSIGNRHS;\n#endif\n  td.flags |= (W_NOGLOB|W_TILDEEXP);\n  td.word = savestring (string);\n  value = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);\n  FREE (td.word);\n\n  expand_no_split_dollar_star = 0;\n\n  if (value)\n    {\n      if (value->word)\n\t{\n\t  remove_quoted_nulls (value->word->word);\t \n\t  value->word->flags &= ~W_HASQUOTEDNULL;\n\t}\n      dequote_list (value);\n    }\n  return (value);\n}\n\n \nWORD_LIST *\nexpand_prompt_string (string, quoted, wflags)\n     char *string;\n     int quoted;\n     int wflags;\n{\n  WORD_LIST *value;\n  WORD_DESC td;\n\n  if (string == 0 || *string == 0)\n    return ((WORD_LIST *)NULL);\n\n  td.flags = wflags;\n  td.word = savestring (string);\n\n  no_longjmp_on_fatal_error = 1;\n  value = expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);\n  no_longjmp_on_fatal_error = 0;\n\n  if (value == &expand_word_error || value == &expand_word_fatal)\n    {\n      value = make_word_list (make_bare_word (string), (WORD_LIST *)NULL);\n      return value;\n    }\n  FREE (td.word);\n  if (value)\n    {\n      if (value->word)\n\t{\n\t  remove_quoted_nulls (value->word->word);\t \n\t  value->word->flags &= ~W_HASQUOTEDNULL;\n\t}\n      dequote_list (value);\n    }\n  return (value);\n}\n\n \nstatic WORD_LIST *\nexpand_string_leave_quoted (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_LIST *tlist;\n  WORD_LIST *tresult;\n\n  if (string == 0 || *string == '\\0')\n    return ((WORD_LIST *)NULL);\n\n  tlist = expand_string_internal (string, quoted);\n\n  if (tlist)\n    {\n      tresult = word_list_split (tlist);\n      dispose_words (tlist);\n      return (tresult);\n    }\n  return ((WORD_LIST *)NULL);\n}\n\n \nstatic WORD_LIST *\nexpand_string_for_rhs (string, quoted, op, pflags, dollar_at_p, expanded_p)\n     char *string;\n     int quoted, op, pflags;\n     int *dollar_at_p, *expanded_p;\n{\n  WORD_DESC td;\n  WORD_LIST *tresult;\n  int old_nosplit;\n\n  if (string == 0 || *string == '\\0')\n    return (WORD_LIST *)NULL;\n\n   \n   \n   \n  old_nosplit = expand_no_split_dollar_star;\n  expand_no_split_dollar_star = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || op == '=' || ifs_is_null == 0;\t \n  td.flags = W_EXPANDRHS;\t\t \n  td.flags |= W_NOSPLIT2;\t\t \n  if (pflags & PF_ASSIGNRHS)\t\t \n    td.flags |= W_ASSIGNRHS;\n  if (op == '=')\n#if 0\n    td.flags |= W_ASSIGNRHS;\t\t \n#else\n    td.flags |= W_ASSIGNRHS|W_NOASSNTILDE;\t\t \n#endif\n  td.word = savestring (string);\n  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, expanded_p);\n  expand_no_split_dollar_star = old_nosplit;\n  free (td.word);\n\n  return (tresult);\n}\n\n \nstatic WORD_LIST *\nexpand_string_for_pat (string, quoted, dollar_at_p, expanded_p)\n     char *string;\n     int quoted, *dollar_at_p, *expanded_p;\n{\n  WORD_DESC td;\n  WORD_LIST *tresult;\n  int oexp;\n\n  if (string == 0 || *string == '\\0')\n    return (WORD_LIST *)NULL;\n\n  oexp = expand_no_split_dollar_star;\n  expand_no_split_dollar_star = 1;\n  td.flags = W_NOSPLIT2;\t\t \n  td.word = savestring (string);\n  tresult = call_expand_word_internal (&td, quoted, 1, dollar_at_p, expanded_p);\n  expand_no_split_dollar_star = oexp;\n  free (td.word);\n\n  return (tresult);\n}\n\n \nWORD_LIST *\nexpand_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_LIST *result;\n\n  if (string == 0 || *string == '\\0')\n    return ((WORD_LIST *)NULL);\n\n  result = expand_string_leave_quoted (string, quoted);\n  return (result ? dequote_list (result) : result);\n}\n\n \n\n \n\nWORD_LIST *\nexpand_word (word, quoted)\n     WORD_DESC *word;\n     int quoted;\n{\n  WORD_LIST *result, *tresult;\n\n  tresult = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);\n  result = word_list_split (tresult);\n  dispose_words (tresult);\n  return (result ? dequote_list (result) : result);\n}\n\n \nWORD_LIST *\nexpand_word_unsplit (word, quoted)\n     WORD_DESC *word;\n     int quoted;\n{\n  WORD_LIST *result;\n\n  result = expand_word_leave_quoted (word, quoted);\n  return (result ? dequote_list (result) : result);\n}\n\n \nWORD_LIST *\nexpand_word_leave_quoted (word, quoted)\n     WORD_DESC *word;\n     int quoted;\n{\n  WORD_LIST *result;\n\n  expand_no_split_dollar_star = 1;\n  if (ifs_is_null)\n    word->flags |= W_NOSPLIT;\n  word->flags |= W_NOSPLIT2;\n  result = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);\n  expand_no_split_dollar_star = 0;\n\n  return result;\n}\n\n \n\n \n\n \nstatic char *\nquote_escapes_internal (string, flags)\n     const char *string;\n     int flags;\n{\n  const char *s, *send;\n  char *t, *result;\n  size_t slen;\n  int quote_spaces, skip_ctlesc, skip_ctlnul, nosplit;\n  DECLARE_MBSTATE; \n\n  slen = strlen (string);\n  send = string + slen;\n\n  quote_spaces = (ifs_value && *ifs_value == 0);\n  nosplit = (flags & PF_NOSPLIT2);\n\n  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)\n    {\n      skip_ctlesc |= (nosplit == 0 && *s == CTLESC);\n      skip_ctlnul |= (nosplit == 0 && *s == CTLNUL);\n    }\n\n  t = result = (char *)xmalloc ((slen * 2) + 1);\n  s = string;\n\n  while (*s)\n    {\n      if ((skip_ctlesc == 0 && *s == CTLESC) || (skip_ctlnul == 0 && *s == CTLNUL) || (quote_spaces && *s == ' '))\n\t*t++ = CTLESC;\n      COPY_CHAR_P (t, s, send);\n    }\n  *t = '\\0';\n\n  return (result);\n}\n\nchar *\nquote_escapes (string)\n     const char *string;\n{\n  return (quote_escapes_internal (string, 0));\n}\n\nchar *\nquote_rhs (string)\n     const char *string;\n{\n  return (quote_escapes_internal (string, PF_NOSPLIT2));\n}\n\nstatic WORD_LIST *\nlist_quote_escapes (list)\n     WORD_LIST *list;\n{\n  register WORD_LIST *w;\n  char *t;\n\n  for (w = list; w; w = w->next)\n    {\n      t = w->word->word;\n      w->word->word = quote_escapes (t);\n      free (t);\n    }\n  return list;\n}\n\n \nchar *\ndequote_escapes (string)\n     const char *string;\n{\n  const char *s, *send;\n  char *t, *result;\n  size_t slen;\n  int quote_spaces;\n  DECLARE_MBSTATE;\n\n  if (string == 0)\n    return (char *)0;\n\n  slen = strlen (string);\n  send = string + slen;\n\n  t = result = (char *)xmalloc (slen + 1);\n\n  if (strchr (string, CTLESC) == 0)\n    return (strcpy (result, string));\n\n  quote_spaces = (ifs_value && *ifs_value == 0);\n\n  s = string;\n  while (*s)\n    {\n      if (*s == CTLESC && (s[1] == CTLESC || s[1] == CTLNUL || (quote_spaces && s[1] == ' ')))\n\t{\n\t  s++;\n\t  if (*s == '\\0')\n\t    break;\n\t}\n      COPY_CHAR_P (t, s, send);\n    }\n  *t = '\\0';\n\n  return result;\n}\n\n#if defined (INCLUDE_UNUSED)\nstatic WORD_LIST *\nlist_dequote_escapes (list)\n     WORD_LIST *list;\n{\n  register WORD_LIST *w;\n  char *t;\n\n  for (w = list; w; w = w->next)\n    {\n      t = w->word->word;\n      w->word->word = dequote_escapes (t);\n      free (t);\n    }\n  return list;\n}\n#endif\n\n \nstatic char *\nmake_quoted_char (c)\n     int c;\n{\n  char *temp;\n\n  temp = (char *)xmalloc (3);\n  if (c == 0)\n    {\n      temp[0] = CTLNUL;\n      temp[1] = '\\0';\n    }\n  else\n    {\n      temp[0] = CTLESC;\n      temp[1] = c;\n      temp[2] = '\\0';\n    }\n  return (temp);\n}\n\n \nchar *\nquote_string (string)\n     char *string;\n{\n  register char *t;\n  size_t slen;\n  char *result, *send;\n\n  if (*string == 0)\n    {\n      result = (char *)xmalloc (2);\n      result[0] = CTLNUL;\n      result[1] = '\\0';\n    }\n  else\n    {\n      DECLARE_MBSTATE;\n\n      slen = strlen (string);\n      send = string + slen;\n\n      result = (char *)xmalloc ((slen * 2) + 1);\n\n      for (t = result; string < send; )\n\t{\n\t  *t++ = CTLESC;\n\t  COPY_CHAR_P (t, string, send);\n\t}\n      *t = '\\0';\n    }\n  return (result);\n}\n\n \nchar *\ndequote_string (string)\n     char *string;\n{\n  register char *s, *t;\n  size_t slen;\n  char *result, *send;\n  DECLARE_MBSTATE;\n\n  if (string[0] == CTLESC && string[1] == 0)\n    internal_debug (\"dequote_string: string with bare CTLESC\");\n\n  slen = STRLEN (string);\n\n  t = result = (char *)xmalloc (slen + 1);\n\n  if (QUOTED_NULL (string))\n    {\n      result[0] = '\\0';\n      return (result);\n    }\n\n   \n  if (string[0] == CTLESC && string[1] == 0)\n    {\n      result[0] = CTLESC;\n      result[1] = '\\0';\n      return (result);\n    }\n\n   \n  if (strchr (string, CTLESC) == NULL)\n    return (strcpy (result, string));\n\n  send = string + slen;\n  s = string;\n  while (*s)\n    {\n      if (*s == CTLESC)\n\t{\n\t  s++;\n\t  if (*s == '\\0')\n\t    break;\n\t}\n      COPY_CHAR_P (t, s, send);\n    }\n\n  *t = '\\0';\n  return (result);\n}\n\n \nstatic WORD_LIST *\nquote_list (list)\n     WORD_LIST *list;\n{\n  register WORD_LIST *w;\n  char *t;\n\n  for (w = list; w; w = w->next)\n    {\n      t = w->word->word;\n      w->word->word = quote_string (t);\n      if (*t == 0)\n\tw->word->flags |= W_HASQUOTEDNULL;\t \n      w->word->flags |= W_QUOTED;\n      free (t);\n    }\n  return list;\n}\n\nWORD_DESC *\ndequote_word (word)\n     WORD_DESC *word;\n{\n  register char *s;\n\n  s = dequote_string (word->word);\n  if (QUOTED_NULL (word->word))\n    word->flags &= ~W_HASQUOTEDNULL;\n  free (word->word);\n  word->word = s;\n\n  return word;\n}\n\n \nWORD_LIST *\ndequote_list (list)\n     WORD_LIST *list;\n{\n  register char *s;\n  register WORD_LIST *tlist;\n\n  for (tlist = list; tlist; tlist = tlist->next)\n    {\n      s = dequote_string (tlist->word->word);\n      if (QUOTED_NULL (tlist->word->word))\n\ttlist->word->flags &= ~W_HASQUOTEDNULL;\n      free (tlist->word->word);\n      tlist->word->word = s;\n    }\n  return list;\n}\n\n \nchar *\nremove_quoted_escapes (string)\n     char *string;\n{\n  char *t;\n\n  if (string)\n    {\n      t = dequote_escapes (string);\n      strcpy (string, t);\n      free (t);\n    }\n\n  return (string);\n}\n\n \nchar *\nremove_quoted_ifs (string)\n     char *string;\n{\n  register size_t slen;\n  register int i, j;\n  char *ret, *send;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string);\n  send = string + slen;\n\n  i = j = 0;\n  ret = (char *)xmalloc (slen + 1);\n\n  while (i < slen)\n    {\n      if (string[i] == CTLESC)\n\t{\n\t  i++;\n\t  if (string[i] == 0 || isifs (string[i]) == 0)\n\t    ret[j++] = CTLESC;\n\t  if (i == slen)\n\t    break;\n\t}\n\n      COPY_CHAR_I (ret, j, string, send, i);\n    }\n  ret[j] = '\\0';\n\n  return (ret);\n}\n\nchar *\nremove_quoted_nulls (string)\n     char *string;\n{\n  register size_t slen;\n  register int i, j, prev_i;\n  DECLARE_MBSTATE;\n\n  if (strchr (string, CTLNUL) == 0)\t\t \n    return string;\t\t\t\t \n\n  slen = strlen (string);\n  i = j = 0;\n\n  while (i < slen)\n    {\n      if (string[i] == CTLESC)\n\t{\n\t   \n\t  i++;\n\t  string[j++] = CTLESC;\n\t  if (i == slen)\n\t    break;\n\t}\n      else if (string[i] == CTLNUL)\n\t{\n\t  i++;\n\t  continue;\n\t}\n\n      prev_i = i;\n      ADVANCE_CHAR (string, slen, i);\t\t \n      if (j < prev_i)\n\t{\n\t  do string[j++] = string[prev_i++]; while (prev_i < i);\n\t}\n      else\n\tj = i;\n    }\n  string[j] = '\\0';\n\n  return (string);\n}\n\n \nvoid\nword_list_remove_quoted_nulls (list)\n     WORD_LIST *list;\n{\n  register WORD_LIST *t;\n\n  for (t = list; t; t = t->next)\n    {\n      remove_quoted_nulls (t->word->word);\n      t->word->flags &= ~W_HASQUOTEDNULL;\n    }\n}\n\n \n \n \n \n \n\n#if defined (HANDLE_MULTIBYTE)\n# ifdef INCLUDE_UNUSED\nstatic unsigned char *\nmb_getcharlens (string, len)\n     char *string;\n     int len;\n{\n  int i, offset, last;\n  unsigned char *ret;\n  char *p;\n  DECLARE_MBSTATE;\n\n  i = offset = 0;\n  last = 0;\n  ret = (unsigned char *)xmalloc (len);\n  memset (ret, 0, len);\n  while (string[last])\n    {\n      ADVANCE_CHAR (string, len, offset);\n      ret[last] = offset - last;\n      last = offset;\n    }\n  return ret;\n}\n#  endif\n#endif\n\n \n\n#define RP_LONG_LEFT\t1\n#define RP_SHORT_LEFT\t2\n#define RP_LONG_RIGHT\t3\n#define RP_SHORT_RIGHT\t4\n\n \nstatic char *\nremove_upattern (param, pattern, op)\n     char *param, *pattern;\n     int op;\n{\n  register size_t len;\n  register char *end;\n  register char *p, *ret, c;\n\n  len = STRLEN (param);\n  end = param + len;\n\n  switch (op)\n    {\n      case RP_LONG_LEFT:\t \n\tfor (p = end; p >= param; p--)\n\t  {\n\t    c = *p; *p = '\\0';\n\t    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\t*p = c;\n\t\treturn (savestring (p));\n\t      }\n\t    *p = c;\n\n\t  }\n\tbreak;\n\n      case RP_SHORT_LEFT:\t \n\tfor (p = param; p <= end; p++)\n\t  {\n\t    c = *p; *p = '\\0';\n\t    if (strmatch (pattern, param, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\t*p = c;\n\t\treturn (savestring (p));\n\t      }\n\t    *p = c;\n\t  }\n\tbreak;\n\n      case RP_LONG_RIGHT:\t \n\tfor (p = param; p <= end; p++)\n\t  {\n\t    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\tc = *p; *p = '\\0';\n\t\tret = savestring (param);\n\t\t*p = c;\n\t\treturn (ret);\n\t      }\n\t  }\n\tbreak;\n\n      case RP_SHORT_RIGHT:\t \n\tfor (p = end; p >= param; p--)\n\t  {\n\t    if (strmatch (pattern, p, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\tc = *p; *p = '\\0';\n\t\tret = savestring (param);\n\t\t*p = c;\n\t\treturn (ret);\n\t      }\n\t  }\n\tbreak;\n    }\n\n  return (param);\t \n}\n\n#if defined (HANDLE_MULTIBYTE)\n \nstatic wchar_t *\nremove_wpattern (wparam, wstrlen, wpattern, op)\n     wchar_t *wparam;\n     size_t wstrlen;\n     wchar_t *wpattern;\n     int op;\n{\n  wchar_t wc, *ret;\n  int n;\n\n  switch (op)\n    {\n      case RP_LONG_LEFT:\t \n        for (n = wstrlen; n >= 0; n--)\n\t  {\n\t    wc = wparam[n]; wparam[n] = L'\\0';\n\t    if (wcsmatch (wpattern, wparam, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\twparam[n] = wc;\n\t\treturn (wcsdup (wparam + n));\n\t      }\n\t    wparam[n] = wc;\n\t  }\n\tbreak;\n\n      case RP_SHORT_LEFT:\t \n\tfor (n = 0; n <= wstrlen; n++)\n\t  {\n\t    wc = wparam[n]; wparam[n] = L'\\0';\n\t    if (wcsmatch (wpattern, wparam, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\twparam[n] = wc;\n\t\treturn (wcsdup (wparam + n));\n\t      }\n\t    wparam[n] = wc;\n\t  }\n\tbreak;\n\n      case RP_LONG_RIGHT:\t \n        for (n = 0; n <= wstrlen; n++)\n\t  {\n\t    if (wcsmatch (wpattern, wparam + n, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\twc = wparam[n]; wparam[n] = L'\\0';\n\t\tret = wcsdup (wparam);\n\t\twparam[n] = wc;\n\t\treturn (ret);\n\t      }\n\t  }\n\tbreak;\n\n      case RP_SHORT_RIGHT:\t \n\tfor (n = wstrlen; n >= 0; n--)\n\t  {\n\t    if (wcsmatch (wpattern, wparam + n, FNMATCH_EXTFLAG) != FNM_NOMATCH)\n\t      {\n\t\twc = wparam[n]; wparam[n] = L'\\0';\n\t\tret = wcsdup (wparam);\n\t\twparam[n] = wc;\n\t\treturn (ret);\n\t      }\n\t  }\n\tbreak;\n    }\n\n  return (wparam);\t \n}\n#endif  \n\nstatic char *\nremove_pattern (param, pattern, op)\n     char *param, *pattern;\n     int op;\n{\n  char *xret;\n\n  if (param == NULL)\n    return (param);\n  if (*param == '\\0' || pattern == NULL || *pattern == '\\0')\t \n    return (savestring (param));\n\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX > 1)\n    {\n      wchar_t *ret, *oret;\n      size_t n;\n      wchar_t *wparam, *wpattern;\n      mbstate_t ps;\n\n       \n\n      n = xdupmbstowcs (&wpattern, NULL, pattern);\n      if (n == (size_t)-1)\n\t{\n\t  xret = remove_upattern (param, pattern, op);\n\t  return ((xret == param) ? savestring (param) : xret);\n\t}\n      n = xdupmbstowcs (&wparam, NULL, param);\n\n      if (n == (size_t)-1)\n\t{\n\t  free (wpattern);\n\t  xret = remove_upattern (param, pattern, op);\n\t  return ((xret == param) ? savestring (param) : xret);\n\t}\n      oret = ret = remove_wpattern (wparam, n, wpattern, op);\n       \n      if (ret == wparam)\n        {\n          free (wparam);\n          free (wpattern);\n          return (savestring (param));\n        }\n\n      free (wparam);\n      free (wpattern);\n\n      n = strlen (param);\n      xret = (char *)xmalloc (n + 1);\n      memset (&ps, '\\0', sizeof (mbstate_t));\n      n = wcsrtombs (xret, (const wchar_t **)&ret, n, &ps);\n      xret[n] = '\\0';\t\t \n      free (oret);\n      return xret;      \n    }\n  else\n#endif\n    {\n      xret = remove_upattern (param, pattern, op);\n      return ((xret == param) ? savestring (param) : xret);\n    }\n}\n\n \nstatic int\nmatch_upattern (string, pat, mtype, sp, ep)\n     char *string, *pat;\n     int mtype;\n     char **sp, **ep;\n{\n  int c, mlen;\n  size_t len;\n  register char *p, *p1, *npat;\n  char *end;\n\n   \n   \n  len = STRLEN (pat);\n  if (pat[0] != '*' || (pat[0] == '*' && pat[1] == LPAREN && extended_glob) || pat[len - 1] != '*')\n    {\n      int unescaped_backslash;\n      char *pp;\n\n      p = npat = (char *)xmalloc (len + 3);\n      p1 = pat;\n      if ((mtype != MATCH_BEG) && (*p1 != '*' || (*p1 == '*' && p1[1] == LPAREN && extended_glob)))\n\t*p++ = '*';\n      while (*p1)\n\t*p++ = *p1++;\n#if 1\n       \n       \n      if ((mtype != MATCH_END) && (p1[-1] == '*' && (unescaped_backslash = p1[-2] == '\\\\')))\n\t{\n\t  pp = p1 - 3;\n\t  while (pp >= pat && *pp-- == '\\\\')\n\t    unescaped_backslash = 1 - unescaped_backslash;\n\t  if (unescaped_backslash)\n\t    *p++ = '*';\n\t}\n      else if (mtype != MATCH_END && p1[-1] != '*')\n\t*p++ = '*';\n#else \n      if (p1[-1] != '*' || p1[-2] == '\\\\')\n\t*p++ = '*';\n#endif\n      *p = '\\0';\n    }\n  else\n    npat = pat;\n  c = strmatch (npat, string, FNMATCH_EXTFLAG | FNMATCH_IGNCASE);\n  if (npat != pat)\n    free (npat);\n  if (c == FNM_NOMATCH)\n    return (0);\n\n  len = STRLEN (string);\n  end = string + len;\n\n  mlen = umatchlen (pat, len);\n  if (mlen > (int)len)\n    return (0);\n\n  switch (mtype)\n    {\n    case MATCH_ANY:\n      for (p = string; p <= end; p++)\n\t{\n\t  if (match_pattern_char (pat, p, FNMATCH_IGNCASE))\n\t    {\n\t      p1 = (mlen == -1) ? end : p + mlen;\n\t       \n\t      if (p1 > end)\n\t\tbreak;\n\t      for ( ; p1 >= p; p1--)\n\t\t{\n\t\t  c = *p1; *p1 = '\\0';\n\t\t  if (strmatch (pat, p, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)\n\t\t    {\n\t\t      *p1 = c;\n\t\t      *sp = p;\n\t\t      *ep = p1;\n\t\t      return 1;\n\t\t    }\n\t\t  *p1 = c;\n#if 1\n\t\t   \n\t\t  if (mlen != -1)\n\t\t    break;\n#endif\n\t\t}\n\t    }\n\t}\n\n      return (0);\n\n    case MATCH_BEG:\n      if (match_pattern_char (pat, string, FNMATCH_IGNCASE) == 0)\n\treturn (0);\n\n      for (p = (mlen == -1) ? end : string + mlen; p >= string; p--)\n\t{\n\t  c = *p; *p = '\\0';\n\t  if (strmatch (pat, string, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)\n\t    {\n\t      *p = c;\n\t      *sp = string;\n\t      *ep = p;\n\t      return 1;\n\t    }\n\t  *p = c;\n\t   \n\t  if (mlen != -1)\n\t    break;\n\t}\n\n      return (0);\n\n    case MATCH_END:\n      for (p = end - ((mlen == -1) ? len : mlen); p <= end; p++)\n\t{\n\t  if (strmatch (pat, p, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)\n\t    {\n\t      *sp = p;\n\t      *ep = end;\n\t      return 1;\n\t    }\n\t   \n\t  if (mlen != -1)\n\t    break;\n\t}\n\n      return (0);\n    }\n\n  return (0);\n}\n\n#if defined (HANDLE_MULTIBYTE)\n\n#define WFOLD(c) (match_ignore_case && iswupper (c) ? towlower (c) : (c))\n\n \nstatic int\nmatch_wpattern (wstring, indices, wstrlen, wpat, mtype, sp, ep)\n     wchar_t *wstring;\n     char **indices;\n     size_t wstrlen;\n     wchar_t *wpat;\n     int mtype;\n     char **sp, **ep;\n{\n  wchar_t wc, *wp, *nwpat, *wp1;\n  size_t len;\n  int mlen;\n  int n, n1, n2, simple;\n\n  simple = (wpat[0] != L'\\\\' && wpat[0] != L'*' && wpat[0] != L'?' && wpat[0] != L'[');\n#if defined (EXTENDED_GLOB)\n  if (extended_glob)\n    simple &= (wpat[1] != L'(' || (wpat[0] != L'*' && wpat[0] != L'?' && wpat[0] != L'+' && wpat[0] != L'!' && wpat[0] != L'@'));  \n#endif\n\n   \n  len = wcslen (wpat);\n  if (wpat[0] != L'*' || (wpat[0] == L'*' && wpat[1] == WLPAREN && extended_glob) || wpat[len - 1] != L'*')\n    {\n      int unescaped_backslash;\n      wchar_t *wpp;\n\n      wp = nwpat = (wchar_t *)xmalloc ((len + 3) * sizeof (wchar_t));\n      wp1 = wpat;\n      if (*wp1 != L'*' || (*wp1 == '*' && wp1[1] == WLPAREN && extended_glob))\n\t*wp++ = L'*';\n      while (*wp1 != L'\\0')\n\t*wp++ = *wp1++;\n#if 1\n       \n      if (wp1[-1] == L'*' && (unescaped_backslash = wp1[-2] == L'\\\\'))\n        {\n          wpp = wp1 - 3;\n          while (wpp >= wpat && *wpp-- == L'\\\\')\n            unescaped_backslash = 1 - unescaped_backslash;\n          if (unescaped_backslash)\n            *wp++ = L'*';\n        }\n      else if (wp1[-1] != L'*')\n        *wp++ = L'*';\n#else      \n      if (wp1[-1] != L'*' || wp1[-2] == L'\\\\')\n        *wp++ = L'*';\n#endif\n      *wp = '\\0';\n    }\n  else\n    nwpat = wpat;\n  len = wcsmatch (nwpat, wstring, FNMATCH_EXTFLAG | FNMATCH_IGNCASE);\n  if (nwpat != wpat)\n    free (nwpat);\n  if (len == FNM_NOMATCH)\n    return (0);\n\n  mlen = wmatchlen (wpat, wstrlen);\n  if (mlen > (int)wstrlen)\n    return (0);\n\n \n  switch (mtype)\n    {\n    case MATCH_ANY:\n      for (n = 0; n <= wstrlen; n++)\n\t{\n\t  n2 = simple ? (WFOLD(*wpat) == WFOLD(wstring[n])) : match_pattern_wchar (wpat, wstring + n, FNMATCH_IGNCASE);\n\t  if (n2)\n\t    {\n\t      n1 = (mlen == -1) ? wstrlen : n + mlen;\n\t      if (n1 > wstrlen)\n\t        break;\n\n\t      for ( ; n1 >= n; n1--)\n\t\t{\n\t\t  wc = wstring[n1]; wstring[n1] = L'\\0';\n\t\t  if (wcsmatch (wpat, wstring + n, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)\n\t\t    {\n\t\t      wstring[n1] = wc;\n\t\t      *sp = indices[n];\n\t\t      *ep = indices[n1];\n\t\t      return 1;\n\t\t    }\n\t\t  wstring[n1] = wc;\n\t\t   \n\t\t  if (mlen != -1)\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n      return (0);\n\n    case MATCH_BEG:\n      if (match_pattern_wchar (wpat, wstring, FNMATCH_IGNCASE) == 0)\n\treturn (0);\n\n      for (n = (mlen == -1) ? wstrlen : mlen; n >= 0; n--)\n\t{\n\t  wc = wstring[n]; wstring[n] = L'\\0';\n\t  if (wcsmatch (wpat, wstring, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)\n\t    {\n\t      wstring[n] = wc;\n\t      *sp = indices[0];\n\t      *ep = indices[n];\n\t      return 1;\n\t    }\n\t  wstring[n] = wc;\n\t   \n\t  if (mlen != -1)\n\t    break;\n\t}\n\n      return (0);\n\n    case MATCH_END:\n      for (n = wstrlen - ((mlen == -1) ? wstrlen : mlen); n <= wstrlen; n++)\n\t{\n\t  if (wcsmatch (wpat, wstring + n, FNMATCH_EXTFLAG | FNMATCH_IGNCASE) == 0)\n\t    {\n\t      *sp = indices[n];\n\t      *ep = indices[wstrlen];\n\t      return 1;\n\t    }\n\t   \n\t  if (mlen != -1)\n\t    break;\n\t}\n\n      return (0);\n    }\n\n  return (0);\n}\n#undef WFOLD\n#endif  \n\nstatic int\nmatch_pattern (string, pat, mtype, sp, ep)\n     char *string, *pat;\n     int mtype;\n     char **sp, **ep;\n{\n#if defined (HANDLE_MULTIBYTE)\n  int ret;\n  size_t n;\n  wchar_t *wstring, *wpat;\n  char **indices;\n#endif\n\n  if (string == 0 || pat == 0 || *pat == 0)\n    return (0);\n\n#if defined (HANDLE_MULTIBYTE)\n  if (MB_CUR_MAX > 1)\n    {\n      if (mbsmbchar (string) == 0 && mbsmbchar (pat) == 0)\n        return (match_upattern (string, pat, mtype, sp, ep));\n\n      n = xdupmbstowcs (&wpat, NULL, pat);\n      if (n == (size_t)-1)\n\treturn (match_upattern (string, pat, mtype, sp, ep));\n      n = xdupmbstowcs (&wstring, &indices, string);\n      if (n == (size_t)-1)\n\t{\n\t  free (wpat);\n\t  return (match_upattern (string, pat, mtype, sp, ep));\n\t}\n      ret = match_wpattern (wstring, indices, n, wpat, mtype, sp, ep);\n\n      free (wpat);\n      free (wstring);\n      free (indices);\n\n      return (ret);\n    }\n  else\n#endif\n    return (match_upattern (string, pat, mtype, sp, ep));\n}\n\nstatic int\ngetpatspec (c, value)\n     int c;\n     char *value;\n{\n  if (c == '#')\n    return ((*value == '#') ? RP_LONG_LEFT : RP_SHORT_LEFT);\n  else\t \n    return ((*value == '%') ? RP_LONG_RIGHT : RP_SHORT_RIGHT);\n}\n\n \nstatic char *\ngetpattern (value, quoted, expandpat)\n     char *value;\n     int quoted, expandpat;\n{\n  char *pat, *tword;\n  WORD_LIST *l;\n#if 0\n  int i;\n#endif\n   \n#if 0\n  if (expandpat && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *tword)\n    {\n      i = 0;\n      pat = string_extract_double_quoted (tword, &i, SX_STRIPDQ);\n      free (tword);\n      tword = pat;\n    }\n#endif\n\n   \n  l = *value ? expand_string_for_pat (value,\n\t\t\t\t      (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) ? Q_PATQUOTE : quoted,\n\t\t\t\t      (int *)NULL, (int *)NULL)\n\t     : (WORD_LIST *)0;\n  if (l)\n    word_list_remove_quoted_nulls (l);\n  pat = string_list (l);\n  dispose_words (l);\n  if (pat)\n    {\n      tword = quote_string_for_globbing (pat, QGLOB_CVTNULL);\n      free (pat);\n      pat = tword;\n    }\n  return (pat);\n}\n\n#if 0\n \nstatic char *\nvariable_remove_pattern (value, pattern, patspec, quoted)\n     char *value, *pattern;\n     int patspec, quoted;\n{\n  char *tword;\n\n  tword = remove_pattern (value, pattern, patspec);\n\n  return (tword);\n}\n#endif\n\nstatic char *\nlist_remove_pattern (list, pattern, patspec, itype, quoted)\n     WORD_LIST *list;\n     char *pattern;\n     int patspec, itype, quoted;\n{\n  WORD_LIST *new, *l;\n  WORD_DESC *w;\n  char *tword;\n\n  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)\n    {\n      tword = remove_pattern (l->word->word, pattern, patspec);\n      w = alloc_word_desc ();\n      w->word = tword ? tword : savestring (\"\");\n      new = make_word_list (w, new);\n    }\n\n  l = REVERSE_LIST (new, WORD_LIST *);\n  tword = string_list_pos_params (itype, l, quoted, 0);\n  dispose_words (l);\n\n  return (tword);\n}\n\nstatic char *\nparameter_list_remove_pattern (itype, pattern, patspec, quoted)\n     int itype;\n     char *pattern;\n     int patspec, quoted;\n{\n  char *ret;\n  WORD_LIST *list;\n\n  list = list_rest_of_args ();\n  if (list == 0)\n    return ((char *)NULL);\n  ret = list_remove_pattern (list, pattern, patspec, itype, quoted);\n  dispose_words (list);\n  return (ret);\n}\n\n#if defined (ARRAY_VARS)\nstatic char *\narray_remove_pattern (var, pattern, patspec, starsub, quoted)\n     SHELL_VAR *var;\n     char *pattern;\n     int patspec;\n     int starsub;\t \n     int quoted;\n{\n  ARRAY *a;\n  HASH_TABLE *h;\n  int itype;\n  char *ret;\n  WORD_LIST *list;\n  SHELL_VAR *v;\n\n  v = var;\t\t \n\n  itype = starsub ? '*' : '@';\n\n  a = (v && array_p (v)) ? array_cell (v) : 0;\n  h = (v && assoc_p (v)) ? assoc_cell (v) : 0;\n  \n  list = a ? array_to_word_list (a) : (h ? assoc_to_word_list (h) : 0);\n  if (list == 0)\n   return ((char *)NULL);\n  ret = list_remove_pattern (list, pattern, patspec, itype, quoted);\n  dispose_words (list);\n\n  return ret;\n}\n#endif  \n\nstatic char *\nparameter_brace_remove_pattern (varname, value, estatep, patstr, rtype, quoted, flags)\n     char *varname, *value;\n     array_eltstate_t *estatep;\n     char *patstr;\n     int rtype, quoted, flags;\n{\n  int vtype, patspec, starsub;\n  char *temp1, *val, *pattern, *oname;\n  SHELL_VAR *v;\n\n  if (value == 0)\n    return ((char *)NULL);\n\n  oname = this_command_name;\n  this_command_name = varname;\n\n  vtype = get_var_and_type (varname, value, estatep, quoted, flags, &v, &val);\n  if (vtype == -1)\n    {\n      this_command_name = oname;\n      return ((char *)NULL);\n    }\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n  patspec = getpatspec (rtype, patstr);\n  if (patspec == RP_LONG_LEFT || patspec == RP_LONG_RIGHT)\n    patstr++;\n\n   \n  temp1 = savestring (patstr);\n  pattern = getpattern (temp1, quoted, 1);\n  free (temp1);\n\n  temp1 = (char *)NULL;\t\t \n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp1 = remove_pattern (val, pattern, patspec);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp1)\n\t{\n\t  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t\t\t? quote_string (temp1)\n\t\t\t: quote_escapes (temp1);\n\t  free (temp1);\n\t  temp1 = val;\n\t}\n      break;\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n      temp1 = array_remove_pattern (v, pattern, patspec, starsub, quoted);\n      if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n\t{\n\t  val = quote_escapes (temp1);\n\t  free (temp1);\n\t  temp1 = val;\n\t}\n      break;\n#endif\n    case VT_POSPARMS:\n      temp1 = parameter_list_remove_pattern (varname[0], pattern, patspec, quoted);\n      if (temp1 && quoted == 0 && ifs_is_null)\n\t{\n\t   \n\t}\n      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n\t{\n\t  val = quote_escapes (temp1);\n\t  free (temp1);\n\t  temp1 = val;\n\t}\n      break;\n    }\n\n  this_command_name = oname;\n\n  FREE (pattern);\n  return temp1;\n}    \n\n#if defined (PROCESS_SUBSTITUTION)\n\nstatic void reap_some_procsubs PARAMS((int));\n\n \n \n \n \n \n\n#if !defined (HAVE_DEV_FD)\n \n#define FIFO_INCR 20\n\n \nstruct temp_fifo {\n  char *file;\n  pid_t proc;\n};\n\nstatic struct temp_fifo *fifo_list = (struct temp_fifo *)NULL;\nstatic int nfifo;\nstatic int fifo_list_size;\n\nvoid\nclear_fifo_list ()\n{\n  int i;\n\n  for (i = 0; i < fifo_list_size; i++)\n    {\n      if (fifo_list[i].file)\n\tfree (fifo_list[i].file);\n      fifo_list[i].file = NULL;\n      fifo_list[i].proc = 0;\n    }\n  nfifo = 0;\n}\n\nvoid *\ncopy_fifo_list (sizep)\n     int *sizep;\n{\n  if (sizep)\n    *sizep = 0;\n  return (void *)NULL;\n}\n\nstatic void\nadd_fifo_list (pathname)\n     char *pathname;\n{\n  int osize, i;\n\n  if (nfifo >= fifo_list_size - 1)\n    {\n      osize = fifo_list_size;\n      fifo_list_size += FIFO_INCR;\n      fifo_list = (struct temp_fifo *)xrealloc (fifo_list,\n\t\t\t\tfifo_list_size * sizeof (struct temp_fifo));\n      for (i = osize; i < fifo_list_size; i++)\n\t{\n\t  fifo_list[i].file = (char *)NULL;\n\t  fifo_list[i].proc = 0;\t \n\t}\n    }\n\n  fifo_list[nfifo].file = savestring (pathname);\n  nfifo++;\n}\n\nvoid\nunlink_fifo (i)\n     int i;\n{\n  if ((fifo_list[i].proc == (pid_t)-1) || (fifo_list[i].proc > 0 && (kill(fifo_list[i].proc, 0) == -1)))\n    {\n      unlink (fifo_list[i].file);\n      free (fifo_list[i].file);\n      fifo_list[i].file = (char *)NULL;\n      fifo_list[i].proc = 0;\n    }\n}\n\nvoid\nunlink_fifo_list ()\n{\n  int saved, i, j;\n\n  if (nfifo == 0)\n    return;\n\n  for (i = saved = 0; i < nfifo; i++)\n    {\n      if ((fifo_list[i].proc == (pid_t)-1) || (fifo_list[i].proc > 0 && (kill(fifo_list[i].proc, 0) == -1)))\n\t{\n\t  unlink (fifo_list[i].file);\n\t  free (fifo_list[i].file);\n\t  fifo_list[i].file = (char *)NULL;\n\t  fifo_list[i].proc = 0;\n\t}\n      else\n\tsaved++;\n    }\n\n   \n  if (saved)\n    {\n      for (i = j = 0; i < nfifo; i++)\n\tif (fifo_list[i].file)\n\t  {\n\t    if (i != j)\n\t      {\n\t\tfifo_list[j].file = fifo_list[i].file;\n\t\tfifo_list[j].proc = fifo_list[i].proc;\n\t\tfifo_list[i].file = (char *)NULL;\n\t\tfifo_list[i].proc = 0;\n\t      }\n\t    j++;\n\t  }\n      nfifo = j;\n    }\n  else\n    nfifo = 0;\n}\n\nvoid\nunlink_all_fifos ()\n{\n  int i, fd;\n\n  if (nfifo == 0)\n    return;\n\n  for (i = 0; i < nfifo; i++)\n    {\n      fifo_list[i].proc = (pid_t)-1;\n#if defined (O_NONBLOCK)\n      fd = open (fifo_list[i].file, O_RDWR|O_NONBLOCK);\n#else\n      fd = -1;\n#endif\n      unlink_fifo (i);\n      if (fd >= 0)\n\tclose (fd);\n    }\n\n  nfifo = 0;\n}\n\n \nvoid\nclose_new_fifos (list, lsize)\n     void *list;\n     int lsize;\n{\n  int i;\n  char *plist;\n\n  if (list == 0)\n    {\n      unlink_fifo_list ();\n      return;\n    }\n\n  for (plist = (char *)list, i = 0; i < lsize; i++)\n    if (plist[i] == 0 && i < fifo_list_size && fifo_list[i].proc != -1)\n      unlink_fifo (i);\n\n  for (i = lsize; i < fifo_list_size; i++)\n    unlink_fifo (i);  \n}\n\nint\nfind_procsub_child (pid)\n     pid_t pid;\n{\n  int i;\n\n  for (i = 0; i < nfifo; i++)\n    if (fifo_list[i].proc == pid)\n      return i;\n  return -1;\n}\n\nvoid\nset_procsub_status (ind, pid, status)\n     int ind;\n     pid_t pid;\n     int status;\n{\n  if (ind >= 0 && ind < nfifo)\n    fifo_list[ind].proc = (pid_t)-1;\t\t \n}\n\n \nstatic void\nreap_some_procsubs (max)\n     int max;\n{\n  int i;\n\n  for (i = 0; i < max; i++)\n    if (fifo_list[i].proc == (pid_t)-1)\t \n      unlink_fifo (i);\n}\n\nvoid\nreap_procsubs ()\n{\n  reap_some_procsubs (nfifo);\n}\n\n#if 0\n \nvoid\nwait_procsubs ()\n{\n  int i, r;\n\n  for (i = 0; i < nfifo; i++)\n    {\n      if (fifo_list[i].proc != (pid_t)-1 && fifo_list[i].proc > 0)\n\t{\n\t  r = wait_for (fifo_list[i].proc, 0);\n\t  save_proc_status (fifo_list[i].proc, r);\n\t  fifo_list[i].proc = (pid_t)-1;\n\t}\n    }\n}\n#endif\n\nint\nfifos_pending ()\n{\n  return nfifo;\n}\n\nint\nnum_fifos ()\n{\n  return nfifo;\n}\n\nstatic char *\nmake_named_pipe ()\n{\n  char *tname;\n\n  tname = sh_mktmpname (\"sh-np\", MT_USERANDOM|MT_USETMPDIR);\n  if (mkfifo (tname, 0600) < 0)\n    {\n      free (tname);\n      return ((char *)NULL);\n    }\n\n  add_fifo_list (tname);\n  return (tname);\n}\n\n#else  \n\n \n \n\nstatic pid_t *dev_fd_list = (pid_t *)NULL;\nstatic int nfds;\nstatic int totfds;\t \n\nvoid\nclear_fifo (i)\n     int i;\n{\n  if (dev_fd_list[i])\n    {\n      dev_fd_list[i] = 0;\n      nfds--;\n    }\n}\n\nvoid\nclear_fifo_list ()\n{\n  register int i;\n\n  if (nfds == 0)\n    return;\n\n  for (i = 0; nfds && i < totfds; i++)\n    clear_fifo (i);\n\n  nfds = 0;\n}\n\nvoid *\ncopy_fifo_list (sizep)\n     int *sizep;\n{\n  void *ret;\n\n  if (nfds == 0 || totfds == 0)\n    {\n      if (sizep)\n\t*sizep = 0;\n      return (void *)NULL;\n    }\n\n  if (sizep)\n    *sizep = totfds;\n  ret = xmalloc (totfds * sizeof (pid_t));\n  return (memcpy (ret, dev_fd_list, totfds * sizeof (pid_t)));\n}\n\nstatic void\nadd_fifo_list (fd)\n     int fd;\n{\n  if (dev_fd_list == 0 || fd >= totfds)\n    {\n      int ofds;\n\n      ofds = totfds;\n      totfds = getdtablesize ();\n      if (totfds < 0 || totfds > 256)\n\ttotfds = 256;\n      if (fd >= totfds)\n\ttotfds = fd + 2;\n\n      dev_fd_list = (pid_t *)xrealloc (dev_fd_list, totfds * sizeof (dev_fd_list[0]));\n       \n      memset (dev_fd_list + ofds, '\\0', (totfds - ofds) * sizeof (pid_t));\n    }\n\n  dev_fd_list[fd] = 1;\t\t \n  nfds++;\n}\n\nint\nfifos_pending ()\n{\n  return 0;\t \n}\n\nint\nnum_fifos ()\n{\n  return nfds;\n}\n\nvoid\nunlink_fifo (fd)\n     int fd;\n{\n  if (dev_fd_list[fd])\n    {\n      close (fd);\n      dev_fd_list[fd] = 0;\n      nfds--;\n    }\n}\n\nvoid\nunlink_fifo_list ()\n{\n  register int i;\n\n  if (nfds == 0)\n    return;\n\n  for (i = totfds-1; nfds && i >= 0; i--)\n    unlink_fifo (i);\n\n  nfds = 0;\n}\n\nvoid\nunlink_all_fifos ()\n{\n  unlink_fifo_list ();\n}\n\n \nvoid\nclose_new_fifos (list, lsize)\n     void *list;\n     int lsize;\n{\n  int i;\n  pid_t *plist;\n\n  if (list == 0)\n    {\n      unlink_fifo_list ();\n      return;\n    }\n\n  for (plist = (pid_t *)list, i = 0; i < lsize; i++)\n    if (plist[i] == 0 && i < totfds && dev_fd_list[i])\n      unlink_fifo (i);\n\n  for (i = lsize; i < totfds; i++)\n    unlink_fifo (i);  \n}\n\nint\nfind_procsub_child (pid)\n     pid_t pid;\n{\n  int i;\n\n  if (nfds == 0)\n    return -1;\n\n  for (i = 0; i < totfds; i++)\n    if (dev_fd_list[i] == pid)\n      return i;\n\n  return -1;\n}\n\nvoid\nset_procsub_status (ind, pid, status)\n     int ind;\n     pid_t pid;\n     int status;\n{\n  if (ind >= 0 && ind < totfds)\n    dev_fd_list[ind] = (pid_t)-1;\t\t \n}\n\n \nstatic void\nreap_some_procsubs (max)\n     int max;\n{\n  int i;\n\n  for (i = 0; nfds > 0 && i < max; i++)\n    if (dev_fd_list[i] == (pid_t)-1)\n      unlink_fifo (i);\n}\n\nvoid\nreap_procsubs ()\n{\n  reap_some_procsubs (totfds);\n}\n\n#if 0\n \nvoid\nwait_procsubs ()\n{\n  int i, r;\n\n  for (i = 0; nfds > 0 && i < totfds; i++)\n    {\n      if (dev_fd_list[i] != (pid_t)-1 && dev_fd_list[i] > 0)\n\t{\n\t  r = wait_for (dev_fd_list[i], 0);\n\t  save_proc_status (dev_fd_list[i], r);\n\t  dev_fd_list[i] = (pid_t)-1;\n\t}\n    }\n}\n#endif\n\n#if defined (NOTDEF)\nprint_dev_fd_list ()\n{\n  register int i;\n\n  fprintf (stderr, \"pid %ld: dev_fd_list:\", (long)getpid ());\n  fflush (stderr);\n\n  for (i = 0; i < totfds; i++)\n    {\n      if (dev_fd_list[i])\n\tfprintf (stderr, \" %d\", i);\n    }\n  fprintf (stderr, \"\\n\");\n}\n#endif  \n\nstatic char *\nmake_dev_fd_filename (fd)\n     int fd;\n{\n  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;\n\n  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);\n\n  strcpy (ret, DEV_FD_PREFIX);\n  p = inttostr (fd, intbuf, sizeof (intbuf));\n  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);\n\n  add_fifo_list (fd);\n  return (ret);\n}\n\n#endif  \n\n \n\nstatic char *\nprocess_substitute (string, open_for_read_in_child)\n     char *string;\n     int open_for_read_in_child;\n{\n  char *pathname;\n  int fd, result, rc, function_value;\n  pid_t old_pid, pid;\n#if defined (HAVE_DEV_FD)\n  int parent_pipe_fd, child_pipe_fd;\n  int fildes[2];\n#endif  \n#if defined (JOB_CONTROL)\n  pid_t old_pipeline_pgrp;\n#endif\n\n  if (!string || !*string || wordexp_only)\n    return ((char *)NULL);\n\n#if !defined (HAVE_DEV_FD)\n  pathname = make_named_pipe ();\n#else  \n  if (pipe (fildes) < 0)\n    {\n      sys_error (\"%s\", _(\"cannot make pipe for process substitution\"));\n      return ((char *)NULL);\n    }\n   \n  parent_pipe_fd = fildes[open_for_read_in_child];\n  child_pipe_fd = fildes[1 - open_for_read_in_child];\n   \n  parent_pipe_fd = move_to_high_fd (parent_pipe_fd, 1, 64);\n\n  pathname = make_dev_fd_filename (parent_pipe_fd);\n#endif  \n\n  if (pathname == 0)\n    {\n      sys_error (\"%s\", _(\"cannot make pipe for process substitution\"));\n      return ((char *)NULL);\n    }\n\n  old_pid = last_made_pid;\n\n#if defined (JOB_CONTROL)\n  old_pipeline_pgrp = pipeline_pgrp;\n  if (pipeline_pgrp == 0 || (subshell_environment & (SUBSHELL_PIPE|SUBSHELL_FORK|SUBSHELL_ASYNC)) == 0)\n    pipeline_pgrp = shell_pgrp;\n  save_pipeline (1);\n#endif  \n\n  pid = make_child ((char *)NULL, FORK_ASYNC);\n  if (pid == 0)\n    {\n#if 0\n      int old_interactive;\n\n      old_interactive = interactive;\n#endif\n       \n      interactive = 0;\n\n      reset_terminating_signals ();\t \n      free_pushed_string_input ();\n       \n      restore_original_signals ();\t \n      subshell_environment &= ~SUBSHELL_IGNTRAP;\n      QUIT;\t \n      setup_async_signals ();\n#if 0\n      if (open_for_read_in_child == 0 && old_interactive && (bash_input.type == st_stdin || bash_input.type == st_stream))\n\tasync_redirect_stdin ();\n#endif\n\n      subshell_environment |= SUBSHELL_COMSUB|SUBSHELL_PROCSUB|SUBSHELL_ASYNC;\n\n       \n      change_flag ('v', FLAG_OFF);\n\n       \n      if (expanding_redir)\n        flush_temporary_env ();\n    }\n\n#if defined (JOB_CONTROL)\n  set_sigchld_handler ();\n  stop_making_children ();\n   \n  pipeline_pgrp = old_pipeline_pgrp;\n#else\n  stop_making_children ();\n#endif  \n\n  if (pid < 0)\n    {\n      sys_error (\"%s\", _(\"cannot make child for process substitution\"));\n      free (pathname);\n#if defined (HAVE_DEV_FD)\n      close (parent_pipe_fd);\n      close (child_pipe_fd);\n#endif  \n#if defined (JOB_CONTROL)\n      restore_pipeline (1);\n#endif\n      return ((char *)NULL);\n    }\n\n  if (pid > 0)\n    {\n#if defined (JOB_CONTROL)\n      last_procsub_child = restore_pipeline (0);\n       \n      last_procsub_child->next = 0;\n      procsub_add (last_procsub_child);\n#endif\n\n#if defined (HAVE_DEV_FD)\n      dev_fd_list[parent_pipe_fd] = pid;\n#else\n      fifo_list[nfifo-1].proc = pid;\n#endif\n\n      last_made_pid = old_pid;\n\n#if defined (JOB_CONTROL) && defined (PGRP_PIPE)\n      close_pgrp_pipe ();\n#endif  \n\n#if defined (HAVE_DEV_FD)\n      close (child_pipe_fd);\n#endif  \n\n      return (pathname);\n    }\n\n  set_sigint_handler ();\n\n#if defined (JOB_CONTROL)\n   \n  set_job_control (0);\n\n   \n  procsub_clear ();\n\n   \n\n  if (pipeline_pgrp != shell_pgrp)\n    pipeline_pgrp = getpid ();\n#endif  \n\n#if !defined (HAVE_DEV_FD)\n   \n  fd = open (pathname, open_for_read_in_child ? O_RDONLY : O_WRONLY);\n  if (fd < 0)\n    {\n       \n      if (open_for_read_in_child)\n\tsys_error (_(\"cannot open named pipe %s for reading\"), pathname);\n      else\n\tsys_error (_(\"cannot open named pipe %s for writing\"), pathname);\n\n      exit (127);\n    }\n  if (open_for_read_in_child)\n    {\n      if (sh_unset_nodelay_mode (fd) < 0)\n\t{\n\t  sys_error (_(\"cannot reset nodelay mode for fd %d\"), fd);\n\t  exit (127);\n\t}\n    }\n#else  \n  fd = child_pipe_fd;\n#endif  \n\n   \n  if (open_for_read_in_child == 0)\n    fpurge (stdout);\n\n  if (dup2 (fd, open_for_read_in_child ? 0 : 1) < 0)\n    {\n      sys_error (_(\"cannot duplicate named pipe %s as fd %d\"), pathname,\n\topen_for_read_in_child ? 0 : 1);\n      exit (127);\n    }\n\n  if (fd != (open_for_read_in_child ? 0 : 1))\n    close (fd);\n\n   \n  if (current_fds_to_close)\n    {\n      close_fd_bitmap (current_fds_to_close);\n      current_fds_to_close = (struct fd_bitmap *)NULL;\n    }\n\n#if defined (HAVE_DEV_FD)\n   \n  close (parent_pipe_fd);\n  dev_fd_list[parent_pipe_fd] = 0;\n#endif  \n\n   \n  expanding_redir = 0;\n\n  remove_quoted_escapes (string);\n\n  startup_state = 2;\t \n  parse_and_execute_level = 0;\n\n   \n  result = setjmp_nosigs (top_level);\n\n   \n  if (result == 0 && return_catch_flag)\n    function_value = setjmp_nosigs (return_catch);\n  else\n    function_value = 0;\n\n  if (result == ERREXIT)\n    rc = last_command_exit_value;\n  else if (result == EXITPROG || result == EXITBLTIN)\n    rc = last_command_exit_value;\n  else if (result)\n    rc = EXECUTION_FAILURE;\n  else if (function_value)\n    rc = return_catch_value;\n  else\n    {\n      subshell_level++;\n      rc = parse_and_execute (string, \"process substitution\", (SEVAL_NONINT|SEVAL_NOHIST));\n       \n    }\n\n#if !defined (HAVE_DEV_FD)\n   \n  close (open_for_read_in_child ? 0 : 1);\n#endif  \n\n  last_command_exit_value = rc;\n  rc = run_exit_trap ();\n  exit (rc);\n   \n}\n#endif  \n\n \n \n \n \n \n\n#define COMSUB_PIPEBUF\t4096\n\nstatic char *\noptimize_cat_file (r, quoted, flags, flagp)\n     REDIRECT *r;\n     int quoted, flags, *flagp;\n{\n  char *ret;\n  int fd;\n\n  fd = open_redir_file (r, (char **)0);\n  if (fd < 0)\n    return &expand_param_error;\n\n  ret = read_comsub (fd, quoted, flags, flagp);\n  close (fd);\n\n  return ret;\n}\n\nstatic char *\nread_comsub (fd, quoted, flags, rflag)\n     int fd, quoted, flags;\n     int *rflag;\n{\n  char *istring, buf[COMSUB_PIPEBUF], *bufp;\n  int c, tflag, skip_ctlesc, skip_ctlnul;\n  int mb_cur_max;\n  size_t istring_index;\n  size_t istring_size;\n  ssize_t bufn;\n  int nullbyte;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n  wchar_t wc;\n  size_t mblen;\n  int i;\n#endif\n\n  istring = (char *)NULL;\n  istring_index = istring_size = bufn = tflag = 0;\n\n  skip_ctlesc = ifs_cmap[CTLESC];\n  skip_ctlnul = ifs_cmap[CTLNUL];\n\n  mb_cur_max = MB_CUR_MAX;\n  nullbyte = 0;\n\n   \n  while (1)\n    {\n      if (fd < 0)\n\tbreak;\n      if (--bufn <= 0)\n\t{\n\t  bufn = zread (fd, buf, sizeof (buf));\n\t  if (bufn <= 0) \n\t    break;\n\t  bufp = buf;\n\t}\n      c = *bufp++;\n\n      if (c == 0)\n\t{\n#if 1\n\t  if (nullbyte == 0)\n\t    {\n\t      internal_warning (\"%s\", _(\"command substitution: ignored null byte in input\"));\n\t      nullbyte = 1;\n\t    }\n#endif\n\t  continue;\n\t}\n\n       \n      RESIZE_MALLOCED_BUFFER (istring, istring_index, mb_cur_max+1, istring_size, 512);\n\n       \n      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))  )\n\tistring[istring_index++] = CTLESC;\n      else if ((flags & PF_ASSIGNRHS) && skip_ctlesc && c == CTLESC)\n\tistring[istring_index++] = CTLESC;\n       \n      else if (skip_ctlesc == 0 && c == CTLESC)\n\tistring[istring_index++] = CTLESC;\n      else if ((skip_ctlnul == 0 && c == CTLNUL) || (c == ' ' && (ifs_value && *ifs_value == 0)))\n\tistring[istring_index++] = CTLESC;\n\n#if defined (HANDLE_MULTIBYTE)\n      if ((locale_utf8locale && (c & 0x80)) ||\n\t  (locale_utf8locale == 0 && mb_cur_max > 1 && (unsigned char)c > 127))\n\t{\n\t   \n\t   \n\t  memset (&ps, '\\0', sizeof (mbstate_t));\n\t  mblen = mbrtowc (&wc, bufp-1, bufn, &ps);\n\t  if (MB_INVALIDCH (mblen) || mblen == 0 || mblen == 1)\n\t    istring[istring_index++] = c;\n\t  else\n\t    {\n\t      istring[istring_index++] = c;\n\t      for (i = 0; i < mblen-1; i++)\n\t\tistring[istring_index++] = *bufp++;\n\t      bufn -= mblen - 1;\n\t    }\n\t  continue;\n\t}\n#endif\n\n      istring[istring_index++] = c;\n    }\n\n  if (istring)\n    istring[istring_index] = '\\0';\n\n   \n  if (istring_index == 0)\n    {\n      FREE (istring);\n      if (rflag)\n\t*rflag = tflag;\n      return (char *)NULL;\n    }\n\n   \n  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n    {\n      while (istring_index > 0)\n\t{\n\t  if (istring[istring_index - 1] == '\\n')\n\t    {\n\t      --istring_index;\n\n\t       \n\t      if (istring[istring_index - 1] == CTLESC)\n\t\t--istring_index;\n\t    }\n\t  else\n\t    break;\n\t}\n      istring[istring_index] = '\\0';\n    }\n  else\n    strip_trailing (istring, istring_index - 1, 1);\n\n  if (rflag)\n    *rflag = tflag;\n  return istring;\n}\n\n \nWORD_DESC *\ncommand_substitute (string, quoted, flags)\n     char *string;\n     int quoted;\n     int flags;\n{\n  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;\n  char *istring, *s;\n  int result, fildes[2], function_value, pflags, rc, tflag, fork_flags;\n  WORD_DESC *ret;\n  sigset_t set, oset;\n\n  istring = (char *)NULL;\n\n   \n  for (s = string; s && *s && (shellblank (*s) || *s == '\\n'); s++)\n    ;\n  if (s == 0 || *s == 0)\n    return ((WORD_DESC *)NULL);\n\n  if (*s == '<' && (s[1] != '<' && s[1] != '>' && s[1] != '&'))\n    {\n      COMMAND *cmd;\n\n      cmd = parse_string_to_command (string, 0);\t \n      if (cmd && can_optimize_cat_file (cmd))\n\t{\n\t  tflag = 0;\n\t  istring = optimize_cat_file (cmd->value.Simple->redirects, quoted, flags, &tflag);\n\t  if (istring == &expand_param_error)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      istring = 0;\n\t    }\n\t  else\n\t    last_command_exit_value = EXECUTION_SUCCESS;\t \n\t  last_command_subst_pid = dollar_dollar_pid;\n\n\t  dispose_command (cmd);\t  \n\t  ret = alloc_word_desc ();\n\t  ret->word = istring;\n\t  ret->flags = tflag;\n\n\t  return ret;\n\t}\n      dispose_command (cmd);\n    }\n\n  if (wordexp_only && read_but_dont_execute)\n    {\n      last_command_exit_value = EX_WEXPCOMSUB;\n      jump_to_top_level (EXITPROG);\n    }\n\n   \n  if (subst_assign_varlist == 0 || garglist == 0)\n    maybe_make_export_env ();\t \n\n   \n  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;\n\n  old_pid = last_made_pid;\n\n   \n  if (pipe (fildes) < 0)\n    {\n      sys_error (\"%s\", _(\"cannot make pipe for command substitution\"));\n      goto error_exit;\n    }\n\n#if defined (JOB_CONTROL)\n  old_pipeline_pgrp = pipeline_pgrp;\n   \n  if ((subshell_environment & (SUBSHELL_FORK|SUBSHELL_PIPE)) == 0)\n    pipeline_pgrp = shell_pgrp;\n  cleanup_the_pipeline ();\n#endif  \n\n  old_async_pid = last_asynchronous_pid;\n  fork_flags = (subshell_environment&SUBSHELL_ASYNC) ? FORK_ASYNC : 0;\n  pid = make_child ((char *)NULL, fork_flags|FORK_NOTERM);\n  last_asynchronous_pid = old_async_pid;\n\n  if (pid == 0)\n    {\n       \n      reset_signal_handlers ();\n      if (ISINTERRUPT)\n\t{\n\t  kill (getpid (), SIGINT);\n\t  CLRINTERRUPT;\t\t \n\t}\t\n      QUIT;\t \n      subshell_environment |= SUBSHELL_RESETTRAP;\n      subshell_environment &= ~SUBSHELL_IGNTRAP;\n    }\n\n#if defined (JOB_CONTROL)\n   \n  set_sigchld_handler ();\n  stop_making_children ();\n  if (pid != 0)\n    pipeline_pgrp = old_pipeline_pgrp;\n#else\n  stop_making_children ();\n#endif  \n\n  if (pid < 0)\n    {\n      sys_error (_(\"cannot make child for command substitution\"));\n    error_exit:\n\n      last_made_pid = old_pid;\n\n      FREE (istring);\n      close (fildes[0]);\n      close (fildes[1]);\n      return ((WORD_DESC *)NULL);\n    }\n\n  if (pid == 0)\n    {\n       \n      interactive = 0;\n\n#if defined (JOB_CONTROL)\n       \n      if (pipeline_pgrp > 0 && pipeline_pgrp != shell_pgrp)\n\tshell_pgrp = pipeline_pgrp;\n#endif\n\n      set_sigint_handler ();\t \n\n      free_pushed_string_input ();\n\n       \n      fpurge (stdout);\n\n      if (dup2 (fildes[1], 1) < 0)\n\t{\n\t  sys_error (\"%s\", _(\"command_substitute: cannot duplicate pipe as fd 1\"));\n\t  exit (EXECUTION_FAILURE);\n\t}\n\n       \n      if ((fildes[1] != fileno (stdin)) &&\n\t  (fildes[1] != fileno (stdout)) &&\n\t  (fildes[1] != fileno (stderr)))\n\tclose (fildes[1]);\n\n      if ((fildes[0] != fileno (stdin)) &&\n\t  (fildes[0] != fileno (stdout)) &&\n\t  (fildes[0] != fileno (stderr)))\n\tclose (fildes[0]);\n\n#ifdef __CYGWIN__\n       \n      freopen (NULL, \"w\", stdout);\n      sh_setlinebuf (stdout);\n#endif  \n\n       \n      subshell_environment |= SUBSHELL_COMSUB;\n\n       \n      change_flag ('v', FLAG_OFF);\n\n       \n      if (inherit_errexit == 0)\n        {\n          builtin_ignoring_errexit = 0;\n\t  change_flag ('e', FLAG_OFF);\n        }\n      set_shellopts ();\n\n       \n      if (expanding_redir)\n\t{\n\t  flush_temporary_env ();\n\t  expanding_redir = 0;\n\t}\n\n      remove_quoted_escapes (string);\n\n       \n      if (expand_aliases && (flags & PF_BACKQUOTE) == 0)\n        expand_aliases = posixly_correct == 0;\n\n      startup_state = 2;\t \n      parse_and_execute_level = 0;\n\n       \n      result = setjmp_nosigs (top_level);\n\n       \n      if (result == 0 && return_catch_flag)\n\tfunction_value = setjmp_nosigs (return_catch);\n      else\n\tfunction_value = 0;\n\n      if (result == ERREXIT)\n\trc = last_command_exit_value;\n      else if (result == EXITPROG || result == EXITBLTIN)\n\trc = last_command_exit_value;\n      else if (result)\n\trc = EXECUTION_FAILURE;\n      else if (function_value)\n\trc = return_catch_value;\n      else\n\t{\n\t  subshell_level++;\n\t  rc = parse_and_execute (string, \"command substitution\", pflags|SEVAL_NOHIST);\n\t   \n\t}\n\n      last_command_exit_value = rc;\n      rc = run_exit_trap ();\n#if defined (PROCESS_SUBSTITUTION)\n      unlink_fifo_list ();\n#endif\n      exit (rc);\n    }\n  else\n    {\n      int dummyfd;\n\n#if defined (JOB_CONTROL) && defined (PGRP_PIPE)\n      close_pgrp_pipe ();\n#endif  \n\n      close (fildes[1]);\n\n      begin_unwind_frame (\"read-comsub\");\n      dummyfd = fildes[0];\n      add_unwind_protect (close, dummyfd);\n\n       \n      BLOCK_SIGNAL (SIGINT, set, oset);\n      tflag = 0;\n      istring = read_comsub (fildes[0], quoted, flags, &tflag);\n\n      close (fildes[0]);\n      discard_unwind_frame (\"read-comsub\");\n      UNBLOCK_SIGNAL (oset);\n\n      current_command_subst_pid = pid;\n      last_command_exit_value = wait_for (pid, JWAIT_NOTERM);\n      last_command_subst_pid = pid;\n      last_made_pid = old_pid;\n\n#if defined (JOB_CONTROL)\n       \n      if (last_command_exit_value == (128 + SIGINT) && last_command_exit_signal == SIGINT)\n\tkill (getpid (), SIGINT);\n#endif  \n\n      ret = alloc_word_desc ();\n      ret->word = istring;\n      ret->flags = tflag;\n\n      return ret;\n    }\n}\n\n \n\n#if defined (ARRAY_VARS)\n\nstatic arrayind_t\narray_length_reference (s)\n     char *s;\n{\n  int len;\n  arrayind_t ind;\n  char *akey;\n  char *t, c;\n  ARRAY *array;\n  HASH_TABLE *h;\n  SHELL_VAR *var;\n\n  var = array_variable_part (s, 0, &t, &len);\n\n   \n  if ((var == 0 || invisible_p (var) || (assoc_p (var) == 0 && array_p (var) == 0)) && unbound_vars_is_error)\n    {\n      c = *--t;\n      *t = '\\0';\n      set_exit_status (EXECUTION_FAILURE);\n      err_unboundvar (s);\n      *t = c;\n      return (-1);\n    }\n  else if (var == 0 || invisible_p (var))\n    return 0;\n\n   \n\n  array = array_p (var) ? array_cell (var) : (ARRAY *)NULL;\n  h = assoc_p (var) ? assoc_cell (var) : (HASH_TABLE *)NULL;\n\n  if (ALL_ELEMENT_SUB (t[0]) && t[1] == RBRACK)\n    {\n      if (assoc_p (var))\n\treturn (h ? assoc_num_elements (h) : 0);\n      else if (array_p (var))\n\treturn (array ? array_num_elements (array) : 0);\n      else\n\treturn (var_isset (var) ? 1 : 0);\n    }\n\n  if (assoc_p (var))\n    {\n      t[len - 1] = '\\0';\n      akey = expand_subscript_string (t, 0);\t \n      t[len - 1] = RBRACK;\n      if (akey == 0 || *akey == 0)\n\t{\n\t  err_badarraysub (t);\n\t  FREE (akey);\n\t  return (-1);\n\t}\n      t = assoc_reference (assoc_cell (var), akey);\n      free (akey);\n    }\n  else\n    {\n      ind = array_expand_index (var, t, len, 0);\n       \n      if (var && array_p (var) && ind < 0)\n\tind = array_max_index (array_cell (var)) + 1 + ind;\n      if (ind < 0)\n\t{\n\t  err_badarraysub (t);\n\t  return (-1);\n\t}\n      if (array_p (var))\n\tt = array_reference (array, ind);\n      else\n\tt = (ind == 0) ? value_cell (var) : (char *)NULL;\n    }\n\n  len = MB_STRLEN (t);\n  return (len);\n}\n#endif  \n\nstatic int\nvalid_brace_expansion_word (name, var_is_special)\n     char *name;\n     int var_is_special;\n{\n  if (DIGIT (*name) && all_digits (name))\n    return 1;\n  else if (var_is_special)\n    return 1;\n#if defined (ARRAY_VARS)\n  else if (valid_array_reference (name, 0))\n    return 1;\n#endif  \n  else if (legal_identifier (name))\n    return 1;\n  else\n    return 0;\n}\n\nstatic int\nchk_atstar (name, quoted, pflags, quoted_dollar_atp, contains_dollar_at)\n     char *name;\n     int quoted, pflags;\n     int *quoted_dollar_atp, *contains_dollar_at;\n{\n  char *temp1;\n\n  if (name == 0)\n    {\n      if (quoted_dollar_atp)\n\t*quoted_dollar_atp = 0;\n      if (contains_dollar_at)\n\t*contains_dollar_at = 0;\n      return 0;\n    }\n\n   \n  if (name[0] == '@' && name[1] == 0)\n    {\n      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t*quoted_dollar_atp = 1;\n      if (contains_dollar_at)\n\t*contains_dollar_at = 1;\n      return 1;\n    }\n  else if (name[0] == '*' && name[1] == '\\0' && quoted == 0)\n    {\n       \n      if (contains_dollar_at && expand_no_split_dollar_star == 0)\n\t*contains_dollar_at = 1;\n      return 1;\n    }\n\n   \n#if defined (ARRAY_VARS)\n  else if (valid_array_reference (name, 0))\n    {\n      temp1 = mbschr (name, LBRACK);\n      if (temp1 && temp1[1] == '@' && temp1[2] == RBRACK)\n\t{\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t    *quoted_dollar_atp = 1;\n\t  if (contains_dollar_at)\n\t    *contains_dollar_at = 1;\n\t  return 1;\n\t}\n       \n      if (temp1 && temp1[1] == '*' && temp1[2] == RBRACK && quoted == 0)\n\t{\n\t  if (contains_dollar_at)\n\t    *contains_dollar_at = 1;\n\t  return 1;\n\t}\n    }\n#endif\n  return 0;\n}\n\n \nstatic WORD_DESC *\nparameter_brace_expand_word (name, var_is_special, quoted, pflags, estatep)\n     char *name;\n     int var_is_special, quoted, pflags;\n     array_eltstate_t *estatep;\n{\n  WORD_DESC *ret;\n  char *temp, *tt;\n  intmax_t arg_index;\n  SHELL_VAR *var;\n  int rflags;\n  array_eltstate_t es;\n\n  ret = 0;\n  temp = 0;\n  rflags = 0;\n\n#if defined (ARRAY_VARS)\n  if (estatep)\n    es = *estatep;\t \n  else\n    {\n      init_eltstate (&es);\n      es.ind = INTMAX_MIN;\n    }\n#endif\n\n     \n  if (legal_number (name, &arg_index))\n    {\n      tt = get_dollar_var_value (arg_index);\n      if (tt)\n \ttemp = (*tt && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n \t\t  ? quote_string (tt)\n \t\t  : quote_escapes (tt);\n      else\n        temp = (char *)NULL;\n      FREE (tt);\n    }\n  else if (var_is_special)       \n    {\n      int sindex;\n      tt = (char *)xmalloc (2 + strlen (name));\n      tt[sindex = 0] = '$';\n      strcpy (tt + 1, name);\n\n      ret = param_expand (tt, &sindex, quoted, (int *)NULL, (int *)NULL,\n\t\t\t  (int *)NULL, (int *)NULL, pflags);\n\n       \n      if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && STR_DOLLAR_AT_STAR (name) &&\n\t  ret && ret->word && QUOTED_NULL (ret->word))\n\tret->flags |= W_HASQUOTEDNULL;\n\n      free (tt);\n    }\n#if defined (ARRAY_VARS)\n  else if (valid_array_reference (name, 0))\n    {\nexpand_arrayref:\n      var = array_variable_part (name, 0, &tt, (int *)0);\n       \n      if (pflags & PF_ASSIGNRHS)\n\t{\n\t  if (ALL_ELEMENT_SUB (tt[0]) && tt[1] == RBRACK)\n\t    {\n\t       \n\t      if (var && (array_p (var) || assoc_p (var)))\n\t\ttemp = array_value (name, quoted|Q_DOUBLE_QUOTES, AV_ASSIGNRHS, &es);\n\t      else\t\t\n\t\ttemp = array_value (name, quoted, 0, &es);\n\t    }\n\t  else\n\t    temp = array_value (name, quoted, 0, &es);\n\t}\n       \n      else if (pflags & PF_NOSPLIT2)\n\t{\n\t   \n#if defined (HANDLE_MULTIBYTE)\n          if (tt[0] == '@' && tt[1] == RBRACK && var && quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc[0] != ' ')\n#else\n\t  if (tt[0] == '@' && tt[1] == RBRACK && var && quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc != ' ')\n#endif\n\t    temp = array_value (name, Q_DOUBLE_QUOTES, AV_ASSIGNRHS, &es);\n\t  else if (tt[0] == '@' && tt[1] == RBRACK)\n\t    temp = array_value (name, quoted, 0, &es);\n\t  else if (tt[0] == '*' && tt[1] == RBRACK && expand_no_split_dollar_star && ifs_is_null)\n\t    temp = array_value (name, Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT, 0, &es);\n\t  else if (tt[0] == '*' && tt[1] == RBRACK)\n\t    temp = array_value (name, quoted, 0, &es);\n\t  else\n\t    temp = array_value (name, quoted, 0, &es);\n\t}\t  \t  \n      else if (tt[0] == '*' && tt[1] == RBRACK && expand_no_split_dollar_star && ifs_is_null)\n\ttemp = array_value (name, Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT, 0, &es);\n      else\n\ttemp = array_value (name, quoted, 0, &es);\n      if (es.subtype == 0 && temp)\n\t{\n\t  temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t\t    ? quote_string (temp)\n\t\t    : quote_escapes (temp);\n\t  rflags |= W_ARRAYIND;\n\t}\n       \n      else if (es.subtype == 1 && temp && QUOTED_NULL (temp) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\trflags |= W_HASQUOTEDNULL;\n      else if (es.subtype == 2 && temp && QUOTED_NULL (temp) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\trflags |= W_HASQUOTEDNULL;\n\n      if (estatep)\n\t*estatep = es;\t \n      else\n\tflush_eltstate (&es);\n    }\n#endif\n  else if (var = find_variable (name))\n    {\n      if (var_isset (var) && invisible_p (var) == 0)\n\t{\n#if defined (ARRAY_VARS)\n\t   \n\t  tt = (char *)NULL;\n\t  if ((pflags & PF_ALLINDS) && assoc_p (var))\n\t    tt = temp = assoc_empty (assoc_cell (var)) ? (char *)NULL : assoc_to_string (assoc_cell (var), \" \", quoted);\n\t  else if ((pflags & PF_ALLINDS) && array_p (var))\n\t    tt = temp = array_empty (array_cell (var)) ? (char *)NULL : array_to_string (array_cell (var), \" \", quoted);\n\t  else if (assoc_p (var))\n\t    temp = assoc_reference (assoc_cell (var), \"0\");\n\t  else if (array_p (var))\n\t    temp = array_reference (array_cell (var), 0);\n\t  else\n\t    temp = value_cell (var);\n#else\n\t  temp = value_cell (var);\n#endif\n\n\t  if (temp)\n\t    temp = (*temp && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t\t      ? quote_string (temp)\n\t\t      : ((pflags & PF_ASSIGNRHS) ? quote_rhs (temp)\n\t\t\t\t\t\t : quote_escapes (temp));\n\t  FREE (tt);\n\t}\n      else\n\ttemp = (char *)NULL;\n    }\n  else if (var = find_variable_last_nameref (name, 0))\n    {\n      temp = nameref_cell (var);\n#if defined (ARRAY_VARS)\n       \n      if (temp && *temp && valid_array_reference (temp, 0))\n\t{\n\t  name = temp;\n\t  goto expand_arrayref;\n\t}\n      else\n#endif\n       \n      if (temp && *temp && legal_identifier (temp) == 0)\n        {\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  report_error (_(\"%s: invalid variable name for name reference\"), temp);\n\t  temp = &expand_param_error;\n        }\n      else\n\ttemp = (char *)NULL;\n    }\n  else\n    temp = (char *)NULL;\n\n  if (ret == 0)\n    {\n      ret = alloc_word_desc ();\n      ret->word = temp;\n      ret->flags |= rflags;\n    }\n  return ret;\n}\n\nstatic char *\nparameter_brace_find_indir (name, var_is_special, quoted, find_nameref)\n     char *name;\n     int var_is_special, quoted, find_nameref;\n{\n  char *temp, *t;\n  WORD_DESC *w;\n  SHELL_VAR *v;\n  int pflags, oldex;\n\n  if (find_nameref && var_is_special == 0 && (v = find_variable_last_nameref (name, 0)) &&\n      nameref_p (v) && (t = nameref_cell (v)) && *t)\n    return (savestring (t));\n\n   \n  pflags = PF_IGNUNBOUND;\n   \n  if (var_is_special)\n    {\n      pflags |= PF_ASSIGNRHS;\t \n      oldex = expand_no_split_dollar_star;\n      expand_no_split_dollar_star = 1;\n    }\n  w = parameter_brace_expand_word (name, var_is_special, quoted, pflags, 0);\n  if (var_is_special)\n    expand_no_split_dollar_star = oldex;\n\n  t = w->word;\n   \n  if (t)\n    {\n      temp = ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || var_is_special)\n\t\t? dequote_string (t)\n\t\t: dequote_escapes (t);\n      free (t);\n      t = temp;\n    }\n  dispose_word_desc (w);\n\n  return t;\n}\n  \n \nstatic WORD_DESC *\nparameter_brace_expand_indir (name, var_is_special, quoted, pflags, quoted_dollar_atp, contains_dollar_at)\n     char *name;\n     int var_is_special, quoted, pflags;\n     int *quoted_dollar_atp, *contains_dollar_at;\n{\n  char *t;\n  WORD_DESC *w;\n  SHELL_VAR *v;\n\n   \n  if (var_is_special == 0 && (v = find_variable_last_nameref (name, 0)))\n    {\n      if (nameref_p (v) && (t = nameref_cell (v)) && *t)\n\t{\n\t  w = alloc_word_desc ();\n\t  w->word = savestring (t);\n\t  w->flags = 0;\n\t  return w;\n\t}\n    }\n\n   \n  if (legal_identifier (name) && v == 0)\n    {\n      report_error (_(\"%s: invalid indirect expansion\"), name);\n      w = alloc_word_desc ();\n      w->word = &expand_param_error;\n      w->flags = 0;\n      return (w);\n    }\n      \n  t = parameter_brace_find_indir (name, var_is_special, quoted, 0);\n\n  chk_atstar (t, quoted, pflags, quoted_dollar_atp, contains_dollar_at);\n\n#if defined (ARRAY_VARS)\n   \n  if (t == 0 && valid_array_reference (name, 0))\n    {\n      v = array_variable_part (name, 0, (char **)0, (int *)0);\n      if (v == 0)\n\t{\n\t  report_error (_(\"%s: invalid indirect expansion\"), name);\n\t  w = alloc_word_desc ();\n\t  w->word = &expand_param_error;\n\t  w->flags = 0;\n\t  return (w);\n\t}\n      else\n        return (WORD_DESC *)NULL;      \n    }\n#endif\n\n  if (t == 0)\n    return (WORD_DESC *)NULL;\n\n  if (valid_brace_expansion_word (t, SPECIAL_VAR (t, 0)) == 0)\n    {\n      report_error (_(\"%s: invalid variable name\"), t);\n      free (t);\n      w = alloc_word_desc ();\n      w->word = &expand_param_error;\n      w->flags = 0;\n      return (w);\n    }\n\t\n  w = parameter_brace_expand_word (t, SPECIAL_VAR(t, 0), quoted, pflags, 0);\n  free (t);\n\n  return w;\n}\n\n \nstatic WORD_DESC *\nparameter_brace_expand_rhs (name, value, op, quoted, pflags, qdollaratp, hasdollarat)\n     char *name, *value;\n     int op, quoted, pflags, *qdollaratp, *hasdollarat;\n{\n  WORD_DESC *w;\n  WORD_LIST *l, *tl;\n  char *t, *t1, *temp, *vname, *newval;\n  int l_hasdollat, sindex, arrayref;\n  SHELL_VAR *v;\n  array_eltstate_t es;\n\n \n   \n  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && *value)\n    {\n      sindex = 0;\n      temp = string_extract_double_quoted (value, &sindex, SX_STRIPDQ);\n    }\n  else\n    temp = value;\n\n  w = alloc_word_desc ();\n  l_hasdollat = 0;\n  l = *temp ? expand_string_for_rhs (temp, quoted, op, pflags, &l_hasdollat, (int *)NULL)\n\t    : (WORD_LIST *)0;\n  if (hasdollarat)\n    *hasdollarat = l_hasdollat || (l && l->next);\n  if (temp != value)\n    free (temp);\n\n   \n  for (tl = l; tl; tl = tl->next)\n    {\n      if (tl->word && (tl->word->word == 0 || tl->word->word[0] == 0) &&\n\t    (tl->word->flags | W_SAWQUOTEDNULL))\n\t{\n\t  t = make_quoted_char ('\\0');\n\t  FREE (tl->word->word);\n\t  tl->word->word = t;\n\t  tl->word->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  tl->word->flags &= ~W_SAWQUOTEDNULL;\n\t}\n    }\n\n  if (l)\n    {\n       \n      if (qdollaratp && ((l_hasdollat && quoted) || l->next))\n\t{\n \n\t  *qdollaratp = 1;\n\t}\n\n       \n      if (l->next && ifs_is_null)\n\t{\n\t  temp = string_list_internal (l, \" \");\n\t  w->flags |= W_SPLITSPACE;\n\t}\n      else if (l_hasdollat || l->next)\n\ttemp = string_list_dollar_star (l, quoted, 0);\n      else\n\t{\n\t  temp = string_list (l);\n\t  if (temp && (QUOTED_NULL (temp) == 0) && (l->word->flags & W_SAWQUOTEDNULL))\n\t    w->flags |= W_SAWQUOTEDNULL;\t \n\t}\n\n       \n      if (l->next == 0 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp) && QUOTED_NULL (l->word->word) && (l->word->flags & W_HASQUOTEDNULL))\n\t{\n\t  w->flags |= W_HASQUOTEDNULL;\n \n\t   \n\t  if (qdollaratp && l_hasdollat)\n\t    *qdollaratp = 0;\n\t}\n      dispose_words (l);\n    }\n  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && l_hasdollat)\n    {\n       \n       \n\n       \n      temp = make_quoted_char ('\\0');\n      w->flags |= W_HASQUOTEDNULL;\n \n    }\n  else\n    temp = (char *)NULL;\n\n  if (op == '-' || op == '+')\n    {\n      w->word = temp;\n      return w;\n    }\n\n   \n  t1 = temp ? dequote_string (temp) : savestring (\"\");\n  free (temp);\n\n   \n  vname = name;\n  if (*name == '!' &&\n      (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1]) || VALID_INDIR_PARAM (name[1])))\n    {\n      vname = parameter_brace_find_indir (name + 1, SPECIAL_VAR (name, 1), quoted, 1);\n      if (vname == 0 || *vname == 0)\n\t{\n\t  report_error (_(\"%s: invalid indirect expansion\"), name);\n\t  free (vname);\n\t  free (t1);\n\t  dispose_word (w);\n\t  return &expand_wdesc_error;\n\t}\n      if (legal_identifier (vname) == 0)\n\t{\n\t  report_error (_(\"%s: invalid variable name\"), vname);\n\t  free (vname);\n\t  free (t1);\n\t  dispose_word (w);\n\t  return &expand_wdesc_error;\n\t}\n    }\n    \n  arrayref = 0;\n#if defined (ARRAY_VARS)\n  if (valid_array_reference (vname, 0))\n    {\n      init_eltstate (&es);\n      v = assign_array_element (vname, t1, ASS_ALLOWALLSUB, &es);\n      arrayref = 1;\n      newval = es.value;\n    }\n  else\n#endif  \n  v = bind_variable (vname, t1, 0);\n\n  if (v == 0 || readonly_p (v) || noassign_p (v))\t \n    {\n      if ((v == 0 || readonly_p (v)) && interactive_shell == 0 && posixly_correct)\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  exp_jump_to_top_level (FORCE_EOF);\n\t}\n      else\n\t{\n\t  if (vname != name)\n\t    free (vname);\n\t  last_command_exit_value = EX_BADUSAGE;\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n    }\n\n  stupidly_hack_special_variables (vname);\n\n   \n  if (shell_compatibility_level > 51)\n    {\n      FREE (t1);\n#if defined (ARRAY_VARS)\n      if (arrayref)\n\t{\n\t  t1 = newval;\n\t  flush_eltstate (&es);\n\t}\n      else\n        t1 = get_variable_value (v);\n#else\n      t1 = value_cell (v);\n#endif\n    }\n\n  if (vname != name)\n    free (vname);\n\n   \n\n   \n  w->word = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) ? quote_string (t1) : quote_escapes (t1);\n   \n  if (w->word && w->word[0] && QUOTED_NULL (w->word) == 0)\n    w->flags &= ~W_SAWQUOTEDNULL;\n\n   \n  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && QUOTED_NULL (w->word))\n    w->flags |= W_HASQUOTEDNULL;\n\n  return w;\n}\n\n \nstatic void\nparameter_brace_expand_error (name, value, check_null)\n     char *name, *value;\n     int check_null;\n{\n  WORD_LIST *l;\n  char *temp;\n\n  set_exit_status (EXECUTION_FAILURE);\t \n  if (value && *value)\n    {\n      l = expand_string (value, 0);\n      temp =  string_list (l);\n      report_error (\"%s: %s\", name, temp ? temp : \"\");\t \n      FREE (temp);\n      dispose_words (l);\n    }\n  else if (check_null == 0)\n    report_error (_(\"%s: parameter not set\"), name);\n  else\n    report_error (_(\"%s: parameter null or not set\"), name);\n\n   \n  free (name);\n  FREE (value);\n}\n\n \nstatic int\nvalid_length_expression (name)\n     char *name;\n{\n  return (name[1] == '\\0' ||\t\t\t\t\t \n\t  ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\\0') ||   \n\t  (DIGIT (name[1]) && all_digits (name + 1)) ||\t \n#if defined (ARRAY_VARS)\n\t  valid_array_reference (name + 1, 0) ||\t\t \n#endif\n\t  legal_identifier (name + 1));\t\t\t\t \n}\n\n \nstatic intmax_t\nparameter_brace_expand_length (name)\n     char *name;\n{\n  char *t, *newname;\n  intmax_t number, arg_index;\n  WORD_LIST *list;\n  SHELL_VAR *var;\n\n  var = (SHELL_VAR *)NULL;\n\n  if (name[1] == '\\0')\t\t\t \n    number = number_of_args ();\n  else if (DOLLAR_AT_STAR (name[1]) && name[2] == '\\0')\t \n    number = number_of_args ();\n  else if ((sh_syntaxtab[(unsigned char) name[1]] & CSPECVAR) && name[2] == '\\0')\n    {\n       \n      switch (name[1])\n\t{\n\tcase '-':\n\t  t = which_set_flags ();\n\t  break;\n\tcase '?':\n\t  t = itos (last_command_exit_value);\n\t  break;\n\tcase '$':\n\t  t = itos (dollar_dollar_pid);\n\t  break;\n\tcase '!':\n\t  if (last_asynchronous_pid == NO_PID)\n\t    t = (char *)NULL;\t \n\t  else\n\t    t = itos (last_asynchronous_pid);\n\t  break;\n\tcase '#':\n\t  t = itos (number_of_args ());\n\t  break;\n\t}\n      number = STRLEN (t);\n      FREE (t);\n    }\n#if defined (ARRAY_VARS)\n  else if (valid_array_reference (name + 1, 0))\n    number = array_length_reference (name + 1);\n#endif  \n  else\n    {\n      number = 0;\n\n      if (legal_number (name + 1, &arg_index))\t\t \n\t{\n\t  t = get_dollar_var_value (arg_index);\n\t  if (t == 0 && unbound_vars_is_error)\n\t    return INTMAX_MIN;\n\t  number = MB_STRLEN (t);\n\t  FREE (t);\n\t}\n#if defined (ARRAY_VARS)\n      else if ((var = find_variable (name + 1)) && (invisible_p (var) == 0) && (array_p (var) || assoc_p (var)))\n\t{\n\t  if (assoc_p (var))\n\t    t = assoc_reference (assoc_cell (var), \"0\");\n\t  else\n\t    t = array_reference (array_cell (var), 0);\n\t  if (t == 0 && unbound_vars_is_error)\n\t    return INTMAX_MIN;\n\t  number = MB_STRLEN (t);\n\t}\n#endif\n       \n      else if ((var || (var = find_variable (name + 1))) &&\n      \t\tinvisible_p (var) == 0 &&\n\t\tarray_p (var) == 0 && assoc_p (var) == 0 &&\n\t\tvar->dynamic_value == 0)\n\tnumber = value_cell (var) ? MB_STRLEN (value_cell (var)) : 0;\n      else if (var == 0 && unbound_vars_is_error == 0)\n\tnumber = 0;\n      else\t\t\t\t \n\t{\n\t  newname = savestring (name);\n\t  newname[0] = '$';\n\t  list = expand_string (newname, Q_DOUBLE_QUOTES);\n\t  t = list ? string_list (list) : (char *)NULL;\n\t  free (newname);\n\t  if (list)\n\t    dispose_words (list);\n\n\t  number = t ? MB_STRLEN (t) : 0;\n\t  FREE (t);\n\t}\n    }\n\n  return (number);\n}\n\n \n\nstatic char *\nskiparith (substr, delim)\n     char *substr;\n     int delim;\n{\n  int i;\n  char delims[2];\n\n  delims[0] = delim;\n  delims[1] = '\\0';\n\n  i = skip_to_delim (substr, 0, delims, SD_ARITHEXP);\n  return (substr + i);\n}\n\n \nstatic int\nverify_substring_values (v, value, substr, vtype, e1p, e2p)\n     SHELL_VAR *v;\n     char *value, *substr;\n     int vtype;\n     intmax_t *e1p, *e2p;\n{\n  char *t, *temp1, *temp2;\n  arrayind_t len;\n  int expok, eflag;\n#if defined (ARRAY_VARS)\n ARRAY *a;\n HASH_TABLE *h;\n#endif\n\n   \n  t = skiparith (substr, ':');\n  if (*t && *t == ':')\n    *t = '\\0';\n  else\n    t = (char *)0;\n\n  temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES|Q_ARITH);\n  eflag = (shell_compatibility_level > 51) ? 0 : EXP_EXPANDED;\n\n  *e1p = evalexp (temp1, eflag, &expok);\n  free (temp1);\n  if (expok == 0)\n    return (0);\n\n  len = -1;\t \n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      len = MB_STRLEN (value);\n      break;\n    case VT_POSPARMS:\n      len = number_of_args () + 1;\n      if (*e1p == 0)\n\tlen++;\t\t \n      break;\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n       \n      if (assoc_p (v))\n\t{\n\t  h = assoc_cell (v);\n\t  len = assoc_num_elements (h) + (*e1p < 0);\n\t}\n      else\n\t{\n\t  a = (ARRAY *)value;\n\t  len = array_max_index (a) + (*e1p < 0);\t \n\t}\n      break;\n#endif\n    }\n\n  if (len == -1)\t \n    return -1;\n\n  if (*e1p < 0)\t\t \n    *e1p += len;\n\n  if (*e1p > len || *e1p < 0)\n    return (-1);\n\n#if defined (ARRAY_VARS)\n   \n  if (vtype == VT_ARRAYVAR)\n    len = assoc_p (v) ? assoc_num_elements (h) : array_num_elements (a);\n#endif\n\n  if (t)\n    {\n      t++;\n      temp2 = savestring (t);\n      temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES|Q_ARITH);\n      free (temp2);\n      t[-1] = ':';\n      *e2p = evalexp (temp1, eflag, &expok);\n      free (temp1);\n      if (expok == 0)\n\treturn (0);\n\n       \n#if 1\n      if ((vtype == VT_ARRAYVAR || vtype == VT_POSPARMS) && *e2p < 0)\n#else  \n      if (vtype == VT_ARRAYVAR && *e2p < 0)\n#endif\n\t{\n\t  internal_error (_(\"%s: substring expression < 0\"), t);\n\t  return (0);\n\t}\n#if defined (ARRAY_VARS)\n       \n      if (vtype != VT_ARRAYVAR)\n#endif\n\t{\n\t  if (*e2p < 0)\n\t    {\n\t      *e2p += len;\n\t      if (*e2p < 0 || *e2p < *e1p)\n\t\t{\n\t\t  internal_error (_(\"%s: substring expression < 0\"), t);\n\t\t  return (0);\n\t\t}\n\t    }\n\t  else\n\t    *e2p += *e1p;\t\t \n\t  if (*e2p > len)\n\t    *e2p = len;\n\t}\n    }\n  else\n    *e2p = len;\n\n  return (1);\n}\n\n \nstatic int\nget_var_and_type (varname, value, estatep, quoted, flags, varp, valp)\n     char *varname, *value;\n     array_eltstate_t *estatep;\n     int quoted, flags;\n     SHELL_VAR **varp;\n     char **valp;\n{\n  int vtype, want_indir;\n  char *temp, *vname;\n  SHELL_VAR *v;\n\n  want_indir = *varname == '!' &&\n    (legal_variable_starter ((unsigned char)varname[1]) || DIGIT (varname[1])\n\t\t\t\t\t|| VALID_INDIR_PARAM (varname[1]));\n  if (want_indir)\n    vname = parameter_brace_find_indir (varname+1, SPECIAL_VAR (varname, 1), quoted, 1);\n     \n  else\n    vname = varname;\n\n  if (vname == 0)\n    {\n      vtype = VT_VARIABLE;\n      *varp = (SHELL_VAR *)NULL;\n      *valp = (char *)NULL;\n      return (vtype);\n    }\n\n   \n  vtype = STR_DOLLAR_AT_STAR (vname);\n  if (vtype == VT_POSPARMS && vname[0] == '*')\n    vtype |= VT_STARSUB;\n  *varp = (SHELL_VAR *)NULL;\n\n#if defined (ARRAY_VARS)\n  if (valid_array_reference (vname, 0))\n    {\n      v = array_variable_part (vname, 0, &temp, (int *)0);\n       \n      if (estatep && (flags & AV_USEIND) == 0)\n\testatep->ind = INTMAX_MIN;\n\n      if (v && invisible_p (v))\n\t{\n\t  vtype = VT_ARRAYMEMBER;\n\t  *varp = (SHELL_VAR *)NULL;\n\t  *valp = (char *)NULL;\n\t}\n      if (v && (array_p (v) || assoc_p (v)))\n\t{\n\t  if (ALL_ELEMENT_SUB (temp[0]) && temp[1] == RBRACK)\n\t    {\n\t       \n\t      vtype = VT_ARRAYVAR;\n\t      if (temp[0] == '*')\n\t\tvtype |= VT_STARSUB;\n\t      *valp = array_p (v) ? (char *)array_cell (v) : (char *)assoc_cell (v);\n\t    }\n\t  else\n\t    {\n\t      vtype = VT_ARRAYMEMBER;\n\t      *valp = array_value (vname, Q_DOUBLE_QUOTES, flags, estatep);\n\t    }\n\t  *varp = v;\n\t}\n      else if (v && (ALL_ELEMENT_SUB (temp[0]) && temp[1] == RBRACK))\n\t{\n\t  vtype = VT_VARIABLE;\n\t  *varp = v;\n\t  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))\n\t    *valp = value ? dequote_string (value) : (char *)NULL;\n\t  else\n\t    *valp = value ? dequote_escapes (value) : (char *)NULL;\n\t}\n      else\n\t{\n\t  vtype = VT_ARRAYMEMBER;\n\t  *varp = v;\n\t  *valp = array_value (vname, Q_DOUBLE_QUOTES, flags, estatep);\n\t}\n    }\n  else if ((v = find_variable (vname)) && (invisible_p (v) == 0) && (assoc_p (v) || array_p (v)))\n    {\n      vtype = VT_ARRAYMEMBER;\n      *varp = v;\n      *valp = assoc_p (v) ? assoc_reference (assoc_cell (v), \"0\") : array_reference (array_cell (v), 0);\n    }\n  else\n#endif\n    {\n      if (value && vtype == VT_VARIABLE)\n\t{\n\t  *varp = find_variable (vname);\n\t  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))\n\t    *valp = dequote_string (value);\n\t  else\n\t    *valp = dequote_escapes (value);\n\t}\n      else\n\t*valp = value;\n    }\n\n  if (want_indir)\n    free (vname);\n\n  return vtype;\n}\n\n \n \n \n \n \n\nstatic char *\nstring_var_assignment (v, s)\n     SHELL_VAR *v;\n     char *s;\n{\n  char flags[MAX_ATTRIBUTES], *ret, *val;\n  int i;\n\n  val = (v && (invisible_p (v) || var_isset (v) == 0)) ? (char *)NULL : sh_quote_reusable (s, 0);\n  i = var_attribute_string (v, 0, flags);\n  if (i == 0 && val == 0)\n    return (char *)NULL;\n\n  ret = (char *)xmalloc (i + STRLEN (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);\n  if (i > 0 && val == 0)\n    sprintf (ret, \"declare -%s %s\", flags, v->name);\n  else if (i > 0)\n    sprintf (ret, \"declare -%s %s=%s\", flags, v->name, val);\n  else\n    sprintf (ret, \"%s=%s\", v->name, val);\n  free (val);\n  return ret;\n}\n\n#if defined (ARRAY_VARS)\nstatic char *\narray_var_assignment (v, itype, quoted, atype)\n     SHELL_VAR *v;\n     int itype, quoted, atype;\n{\n  char *ret, *val, flags[MAX_ATTRIBUTES];\n  int i;\n\n  if (v == 0)\n    return (char *)NULL;\n  if (atype == 2)\n    val = array_p (v) ? array_to_kvpair (array_cell (v), 0)\n\t\t      : assoc_to_kvpair (assoc_cell (v), 0);\n  else\n    val = array_p (v) ? array_to_assign (array_cell (v), 0)\n\t\t      : assoc_to_assign (assoc_cell (v), 0);\n\n  if (val == 0 && (invisible_p (v) || var_isset (v) == 0))\n    ;\t \n  else if (val == 0)\n    {\n      val = (char *)xmalloc (3);\n      val[0] = LPAREN;\n      val[1] = RPAREN;\n      val[2] = 0;\n    }\n  else\n    {\n      ret = (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) ? quote_string (val) : quote_escapes (val);\n      free (val);\n      val = ret;\n    }\n\n  if (atype == 2)\n    return val;\n\n  i = var_attribute_string (v, 0, flags);\n  ret = (char *)xmalloc (i + STRLEN (val) + strlen (v->name) + 16);\n  if (val)\n    sprintf (ret, \"declare -%s %s=%s\", flags, v->name, val);\n  else\n    sprintf (ret, \"declare -%s %s\", flags, v->name);\n  free (val);\n  return ret;\n}\n#endif\n\nstatic char *\npos_params_assignment (list, itype, quoted)\n     WORD_LIST *list;\n     int itype;\n     int quoted;\n{\n  char *temp, *ret;\n\n   \n  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);\n  ret = (char *)xmalloc (strlen (temp) + 8);\n  strcpy (ret, \"set -- \");\n  strcpy (ret + 7, temp);\n  free (temp);\n  return ret;\n}\n\nstatic char *\nstring_transform (xc, v, s)\n     int xc;\n     SHELL_VAR *v;\n     char *s;\n{\n  char *ret, flags[MAX_ATTRIBUTES], *t;\n  int i;\n\n  if (((xc == 'A' || xc == 'a') && v == 0))\n    return (char *)NULL;\n  else if (xc != 'a' && xc != 'A' && s == 0)\n    return (char *)NULL;\n\n  switch (xc)\n    {\n       \n      case 'a':\n\ti = var_attribute_string (v, 0, flags);\n\tret = (i > 0) ? savestring (flags) : (char *)NULL;\n\tbreak;\n      case 'A':\n\tret = string_var_assignment (v, s);\n\tbreak;\n      case 'K':\n      case 'k':\n\tret = sh_quote_reusable (s, 0);\n\tbreak;\n       \n      case 'E':\n\tt = ansiexpand (s, 0, strlen (s), (int *)0);\n\tret = dequote_escapes (t);\n\tfree (t);\n\tbreak;\n      case 'P':\n\tret = decode_prompt_string (s);\n\tbreak;\n      case 'Q':\n\tret = sh_quote_reusable (s, 0);\n\tbreak;\n      case 'U':\n\tret = sh_modcase (s, 0, CASE_UPPER);\n\tbreak;\n      case 'u':\n\tret = sh_modcase (s, 0, CASE_UPFIRST);\t \n \tbreak;\n      case 'L':\n \tret = sh_modcase (s, 0, CASE_LOWER);\n \tbreak;\n      default:\n\tret = (char *)NULL;\n\tbreak;\n    }\n  return ret;\n}\n\nstatic char *\nlist_transform (xc, v, list, itype, quoted)\n     int xc;\n     SHELL_VAR *v;\n     WORD_LIST *list;\n     int itype, quoted;\n{\n  WORD_LIST *new, *l;\n  WORD_DESC *w;\n  char *tword;\n  int qflags;\n\n  for (new = (WORD_LIST *)NULL, l = list; l; l = l->next)\n    {\n      tword = string_transform (xc, v, l->word->word);\n      w = alloc_word_desc ();\n      w->word = tword ? tword : savestring (\"\");\t \n      new = make_word_list (w, new);\n    }\n  l = REVERSE_LIST (new, WORD_LIST *);\n\n  qflags = quoted;\n   \n  if (itype == '*' && expand_no_split_dollar_star && ifs_is_null)\n    qflags |= Q_DOUBLE_QUOTES;\t\t \n\n  tword = string_list_pos_params (itype, l, qflags, 0);\n  dispose_words (l);\n\n  return (tword);\n}\n\nstatic char *\nparameter_list_transform (xc, itype, quoted)\n     int xc;\n     int itype;\n     int quoted;\n{\n  char *ret;\n  WORD_LIST *list;\n\n  list = list_rest_of_args ();\n  if (list == 0)\n    return ((char *)NULL);\n  if (xc == 'A')\n    ret = pos_params_assignment (list, itype, quoted);\n  else\n    ret = list_transform (xc, (SHELL_VAR *)0, list, itype, quoted);\n  dispose_words (list);\n  return (ret);\n}\n\n#if defined (ARRAY_VARS)\nstatic char *\narray_transform (xc, var, starsub, quoted)\n     int xc;\n     SHELL_VAR *var;\n     int starsub;\t \n     int quoted;\n{\n  ARRAY *a;\n  HASH_TABLE *h;\n  int itype, qflags;\n  char *ret;\n  WORD_LIST *list;\n  SHELL_VAR *v;\n\n  v = var;\t \n\n  itype = starsub ? '*' : '@';\n\n  if (xc == 'A')\n    return (array_var_assignment (v, itype, quoted, 1));\n  else if (xc == 'K')\n    return (array_var_assignment (v, itype, quoted, 2));\n\n   \n  if (xc == 'a' && (invisible_p (v) || var_isset (v) == 0))\n    {\n      char flags[MAX_ATTRIBUTES];\n      int i;\n\n      i = var_attribute_string (v, 0, flags);\n      return ((i > 0) ? savestring (flags) : (char *)NULL);\n    }\n\n  a = (v && array_p (v)) ? array_cell (v) : 0;\n  h = (v && assoc_p (v)) ? assoc_cell (v) : 0;\n\n   \n  if (xc == 'k')\n    {\n      if (v == 0)\n\treturn ((char *)NULL);\n      list = array_p (v) ? array_to_kvpair_list (a) : assoc_to_kvpair_list (h);\n      qflags = quoted;\n       \n      if (itype == '*' && expand_no_split_dollar_star && ifs_is_null)\n\tqflags |= Q_DOUBLE_QUOTES;\t\t \n\n      ret = string_list_pos_params (itype, list, qflags, 0);\n      dispose_words (list);\n      return ret;\n    }\n\n  list = a ? array_to_word_list (a) : (h ? assoc_to_word_list (h) : 0);\n  if (list == 0)\n   return ((char *)NULL);\n  ret = list_transform (xc, v, list, itype, quoted);\n  dispose_words (list);\n\n  return ret;\n}\n#endif  \n\nstatic int\nvalid_parameter_transform (xform)\n     char *xform;\n{\n  if (xform[1])\n    return 0;\n\n   \n  switch (xform[0])\n    {\n    case 'a':\t\t \n    case 'A':\t\t \n    case 'K':\t\t \n    case 'k':\t\t \n    case 'E':\t\t \n    case 'P':\t\t \n    case 'Q':\t\t \n    case 'U':\t\t \n    case 'u':\t\t \n    case 'L':\t\t \n      return 1;\n    default:\n      return 0;\n    }\n}\n      \nstatic char *\nparameter_brace_transform (varname, value, estatep, xform, rtype, quoted, pflags, flags)\n     char *varname, *value;\n     array_eltstate_t *estatep;\n     char *xform;\n     int rtype, quoted, pflags, flags;\n{\n  int vtype, xc, starsub;\n  char *temp1, *val, *oname;\n  SHELL_VAR *v;\n\n  xc = xform[0];\n  if (value == 0 && xc != 'A' && xc != 'a')\n    return ((char *)NULL);\n\n  oname = this_command_name;\n  this_command_name = varname;\n\n  vtype = get_var_and_type (varname, value, estatep, quoted, flags, &v, &val);\n  if (vtype == -1)\n    {\n      this_command_name = oname;\n      return ((char *)NULL);\n    }\n\n  if (xform[0] == 0 || valid_parameter_transform (xform) == 0)\n    {\n      this_command_name = oname;\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      return (interactive_shell ? &expand_param_error : &expand_param_fatal);\n    }\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n   \n  if ((xc == 'a' || xc == 'A') && vtype == VT_VARIABLE && varname && v == 0)\n    v = find_variable (varname);\n\n  temp1 = (char *)NULL;\t\t \n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp1 = string_transform (xc, v, val);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp1)\n\t{\n\t  val = (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t\t\t? quote_string (temp1)\n\t\t\t: quote_escapes (temp1);\n\t  free (temp1);\n\t  temp1 = val;\n\t}\n      break;\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n      temp1 = array_transform (xc, v, starsub, quoted);\n      if (temp1 && quoted == 0 && ifs_is_null)\n\t{\n\t\t \n\t}\n      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n\t{\n\t  val = quote_escapes (temp1);\n\t  free (temp1);\n\t  temp1 = val;\n\t}\n      break;\n#endif\n    case VT_POSPARMS:\n      temp1 = parameter_list_transform (xc, varname[0], quoted);\n      if (temp1 && quoted == 0 && ifs_is_null)\n\t{\n\t\t \n\t}\n      else if (temp1 && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n\t{\n\t  val = quote_escapes (temp1);\n\t  free (temp1);\n\t  temp1 = val;\n\t}\n      break;\n    }\n\n  this_command_name = oname;\n  return temp1;\n}\n\n \n \n \n \n \n\n#if defined (HANDLE_MULTIBYTE)\n \nstatic char *\nmb_substring (string, s, e)\n     char *string;\n     int s, e;\n{\n  char *tt;\n  int start, stop, i;\n  size_t slen;\n  DECLARE_MBSTATE;\n\n  start = 0;\n   \n  slen = (MB_CUR_MAX > 1) ? STRLEN (string) : 0;\n\n  i = s;\n  while (string[start] && i--)\n    ADVANCE_CHAR (string, slen, start);\n  stop = start;\n  i = e - s;\n  while (string[stop] && i--)\n    ADVANCE_CHAR (string, slen, stop);\n  tt = substring (string, start, stop);\n  return tt;\n}\n#endif\n  \n \n\nstatic char *\nparameter_brace_substring (varname, value, estatep, substr, quoted, pflags, flags)\n     char *varname, *value;\n     array_eltstate_t *estatep;\n     char *substr;\n     int quoted, pflags, flags;\n{\n  intmax_t e1, e2;\n  int vtype, r, starsub;\n  char *temp, *val, *tt, *oname;\n  SHELL_VAR *v;\n\n  if (value == 0 && ((varname[0] != '@' && varname[0] != '*') || varname[1]))\n    return ((char *)NULL);\n\n  oname = this_command_name;\n  this_command_name = varname;\n\n  vtype = get_var_and_type (varname, value, estatep, quoted, flags, &v, &val);\n  if (vtype == -1)\n    {\n      this_command_name = oname;\n      return ((char *)NULL);\n    }\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n  r = verify_substring_values (v, val, substr, vtype, &e1, &e2);\n  this_command_name = oname;\n  if (r <= 0)\n    {\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      return ((r == 0) ? &expand_param_error : (char *)NULL);\n    }\n\n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1)\n\ttt = mb_substring (val, e1, e2);\n      else\n#endif\n      tt = substring (val, e1, e2);\n\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))\n\ttemp = quote_string (tt);\n      else\n\ttemp = tt ? quote_escapes (tt) : (char *)NULL;\n      FREE (tt);\n      break;\n    case VT_POSPARMS:\n    case VT_ARRAYVAR:\n      if (vtype == VT_POSPARMS)\n\ttt = pos_params (varname, e1, e2, quoted, pflags);\n#if defined (ARRAY_VARS)\n         \n      else if (assoc_p (v))\n\t \t\n\ttt = assoc_subrange (assoc_cell (v), e1, e2, starsub, quoted, pflags);\n      else\n\t \n\ttt = array_subrange (array_cell (v), e1, e2, starsub, quoted, pflags);\n#endif\n       \n      if (tt && quoted == 0 && ifs_is_null)\n\t{\n\t  temp = tt;\t \n\t}\n      else if (tt && quoted == 0 && (pflags & PF_ASSIGNRHS))\n\t{\n\t  temp = tt;\t \n\t}\n      else if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)\n\t{\n\t  temp = tt ? quote_escapes (tt) : (char *)NULL;\n\t  FREE (tt);\n\t}\n      else\n\ttemp = tt;\n      break;\n\n    default:\n      temp = (char *)NULL;\n    }\n\n  return temp;\n}\n\n \n \n \n \n \n\nstatic int\nshouldexp_replacement (s)\n     char *s;\n{\n  size_t slen;\n  int sindex, c;\n  DECLARE_MBSTATE;\n\n  sindex = 0;\n  slen = STRLEN (s);\n  while (c = s[sindex])\n    {\n      if (c == '\\\\')\n\t{\n\t  sindex++;\n\t  if (s[sindex] == 0)\n\t    return 0;\n\t   \n\t  if (s[sindex] == '&')\n\t    return 1;\n\t  if (s[sindex] == '\\\\')\n\t    return 1;\n\t}\n      else if (c == '&')\n\treturn 1;\n      ADVANCE_CHAR (s, slen, sindex);\n    }\n  return 0;\n}\n\nchar *\npat_subst (string, pat, rep, mflags)\n     char *string, *pat, *rep;\n     int mflags;\n{\n  char *ret, *s, *e, *str, *rstr, *mstr, *send;\n  int rptr, mtype, rxpand, mlen;\n  size_t rsize, l, replen, rslen;\n  DECLARE_MBSTATE;\n\n  if (string == 0)\n    return (savestring (\"\"));\n\n  mtype = mflags & MATCH_TYPEMASK;\n  rxpand = mflags & MATCH_EXPREP;\n\n   \n  if ((pat == 0 || *pat == 0) && (mtype == MATCH_BEG || mtype == MATCH_END))\n    {\n      rstr = (mflags & MATCH_EXPREP) ? strcreplace (rep, '&', \"\", 2) : rep;\n      rslen = STRLEN (rstr);\n      l = STRLEN (string);\n      ret = (char *)xmalloc (rslen + l + 2);\n      if (rslen == 0)\n\tstrcpy (ret, string);\n      else if (mtype == MATCH_BEG)\n\t{\n\t  strcpy (ret, rstr);\n\t  strcpy (ret + rslen, string);\n\t}\n      else\n\t{\n\t  strcpy (ret, string);\n\t  strcpy (ret + l, rstr);\n\t}\n      if (rstr != rep)\n\tfree (rstr);\n      return (ret);\n    }\n  else if (*string == 0 && (match_pattern (string, pat, mtype, &s, &e) != 0))\n    return (mflags & MATCH_EXPREP) ? strcreplace (rep, '&', \"\", 2)\n\t\t\t\t   : (rep ? savestring (rep) : savestring (\"\"));\n\n  ret = (char *)xmalloc (rsize = 64);\n  ret[0] = '\\0';\n  send = string + strlen (string);\n\n  for (replen = STRLEN (rep), rptr = 0, str = string; *str;)\n    {\n      if (match_pattern (str, pat, mtype, &s, &e) == 0)\n\tbreak;\n      l = s - str;\n\n      if (rep && rxpand)\n        {\n\t  int x;\n\t  mlen = e - s;\n\t  mstr = xmalloc (mlen + 1);\n\t  for (x = 0; x < mlen; x++)\n\t    mstr[x] = s[x];\n\t  mstr[mlen] = '\\0';\n\t  rstr = strcreplace (rep, '&', mstr, 2);\n\t  free (mstr);\n\t  rslen = strlen (rstr);\n        }\n      else\n\t{\n\t  rstr = rep;\n\t  rslen = replen;\n\t}\n        \n      RESIZE_MALLOCED_BUFFER (ret, rptr, (l + rslen), rsize, 64);\n\n       \n      if (l)\n\t{\n\t  strncpy (ret + rptr, str, l);\n\t  rptr += l;\n\t}\n      if (replen)\n\t{\n\t  strncpy (ret + rptr, rstr, rslen);\n\t  rptr += rslen;\n\t}\n      str = e;\t\t \n\n      if (rstr != rep)\n\tfree (rstr);\n\n      if (((mflags & MATCH_GLOBREP) == 0) || mtype != MATCH_ANY)\n\tbreak;\n\n      if (s == e)\n\t{\n\t   \n\t  char *p, *origp, *origs;\n\t  size_t clen;\n\n\t  RESIZE_MALLOCED_BUFFER (ret, rptr, locale_mb_cur_max, rsize, 64);\n#if defined (HANDLE_MULTIBYTE)\n\t  p = origp = ret + rptr;\n\t  origs = str;\n\t  COPY_CHAR_P (p, str, send);\n\t  rptr += p - origp;\n\t  e += str - origs;\n#else\n\t  ret[rptr++] = *str++;\n\t  e++;\t\t \n#endif\n\t}\n    }\n\n   \n  if (str && *str)\n    {\n      l = send - str + 1;\n      RESIZE_MALLOCED_BUFFER (ret, rptr, l, rsize, 64);\n      strcpy (ret + rptr, str);\n    }\n  else\n    ret[rptr] = '\\0';\n\n  return ret;\n}\n\n \nstatic char *\npos_params_pat_subst (string, pat, rep, mflags)\n     char *string, *pat, *rep;\n     int mflags;\n{\n  WORD_LIST *save, *params;\n  WORD_DESC *w;\n  char *ret;\n  int pchar, qflags, pflags;\n\n  save = params = list_rest_of_args ();\n  if (save == 0)\n    return ((char *)NULL);\n\n  for ( ; params; params = params->next)\n    {\n      ret = pat_subst (params->word->word, pat, rep, mflags);\n      w = alloc_word_desc ();\n      w->word = ret ? ret : savestring (\"\");\n      dispose_word (params->word);\n      params->word = w;\n    }\n\n  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';\n  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;\n  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;\n\n   \n  if (pchar == '*' && (mflags & MATCH_ASSIGNRHS) && expand_no_split_dollar_star && ifs_is_null)\n    qflags |= Q_DOUBLE_QUOTES;\t\t \n\n  ret = string_list_pos_params (pchar, save, qflags, pflags);\n  dispose_words (save);\n\n  return (ret);\n}\n\n \nstatic char *\nparameter_brace_patsub (varname, value, estatep, patsub, quoted, pflags, flags)\n     char *varname, *value;\n     array_eltstate_t *estatep;\n     char *patsub;\n     int quoted, pflags, flags;\n{\n  int vtype, mflags, starsub, delim;\n  char *val, *temp, *pat, *rep, *p, *lpatsub, *tt, *oname;\n  SHELL_VAR *v;\n\n  if (value == 0)\n    return ((char *)NULL);\n\n  oname = this_command_name;\n  this_command_name = varname;\t\t \n\n  vtype = get_var_and_type (varname, value, estatep, quoted, flags, &v, &val);\n  if (vtype == -1)\n    {\n      this_command_name = oname;\n      return ((char *)NULL);\n    }\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n  mflags = 0;\n   \n  if (*patsub == '/')\n    {\n      mflags |= MATCH_GLOBREP;\n      patsub++;\n    }\n\n   \n  lpatsub = savestring (patsub);\n\n  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n    mflags |= MATCH_QUOTED;\n\n  if (starsub)\n    mflags |= MATCH_STARSUB;\n\n  if (pflags & PF_ASSIGNRHS)\n    mflags |= MATCH_ASSIGNRHS;\n\n   \n  delim = skip_to_delim (lpatsub, ((*patsub == '/') ? 1 : 0), \"/\", 0);\n  if (lpatsub[delim] == '/')\n    {\n      lpatsub[delim] = 0;\n      rep = lpatsub + delim + 1;\n    }\n  else\n    rep = (char *)NULL;\n\n  if (rep && *rep == '\\0')\n    rep = (char *)NULL;\n\n   \n  pat = getpattern (lpatsub, quoted, 1);\n\n  if (rep)\n    {\n       \n      if (shell_compatibility_level > 42 && patsub_replacement == 0)\n\trep = expand_string_if_necessary (rep, quoted & ~(Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT), expand_string_unsplit);\n      else if (shell_compatibility_level > 42 && patsub_replacement)\n\trep = expand_string_for_patsub (rep, quoted & ~(Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT));\n             \n      else if ((mflags & MATCH_QUOTED) == 0)\n\trep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);\n      else\n\trep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);\n\n       \n      if (patsub_replacement && rep && *rep && shouldexp_replacement (rep))\n\tmflags |= MATCH_EXPREP;\n\n    }\n\n   \n  p = pat;\n  if (mflags & MATCH_GLOBREP)\n    mflags |= MATCH_ANY;\n  else if (pat && pat[0] == '#')\n    {\n      mflags |= MATCH_BEG;\n      p++;\n    }\n  else if (pat && pat[0] == '%')\n    {\n      mflags |= MATCH_END;\n      p++;\n    }\n  else\n    mflags |= MATCH_ANY;\n\n   \n\n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp = pat_subst (val, p, rep, mflags);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp)\n\t{\n\t  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n    case VT_POSPARMS:\n       \n      if ((pflags & PF_NOSPLIT2) && (mflags & MATCH_STARSUB))\n        mflags |= MATCH_ASSIGNRHS;\n      temp = pos_params_pat_subst (val, p, rep, mflags);\n      if (temp && quoted == 0 && ifs_is_null)\n\t{\n\t   \n\t}\n      else if (temp && quoted == 0 && (pflags & PF_ASSIGNRHS))\n\t{\n\t   \n\t}\n      else if (temp && (mflags & MATCH_QUOTED) == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n       \n      if ((mflags & MATCH_STARSUB) && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)\n\tmflags |= MATCH_QUOTED;\t\t \n\n       \n      if (assoc_p (v))\n\ttemp = assoc_patsub (assoc_cell (v), p, rep, mflags);\n      else\n\ttemp = array_patsub (array_cell (v), p, rep, mflags);\n\n      if (temp && quoted == 0 && ifs_is_null)\n\t{\n\t   \n\t}\n      else if (temp && (mflags & MATCH_QUOTED) == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n#endif\n    }\n\n  FREE (pat);\n  FREE (rep);\n  free (lpatsub);\n\n  this_command_name = oname;\n\n  return temp;\n}\n\n \n \n \n \n \n\n \n\nstatic char *\npos_params_modcase (string, pat, modop, mflags)\n     char *string, *pat;\n     int modop;\n     int mflags;\n{\n  WORD_LIST *save, *params;\n  WORD_DESC *w;\n  char *ret;\n  int pchar, qflags, pflags;\n\n  save = params = list_rest_of_args ();\n  if (save == 0)\n    return ((char *)NULL);\n\n  for ( ; params; params = params->next)\n    {\n      ret = sh_modcase (params->word->word, pat, modop);\n      w = alloc_word_desc ();\n      w->word = ret ? ret : savestring (\"\");\n      dispose_word (params->word);\n      params->word = w;\n    }\n\n  pchar = (mflags & MATCH_STARSUB) == MATCH_STARSUB ? '*' : '@';\n  qflags = (mflags & MATCH_QUOTED) == MATCH_QUOTED ? Q_DOUBLE_QUOTES : 0;\n  pflags = (mflags & MATCH_ASSIGNRHS) == MATCH_ASSIGNRHS ? PF_ASSIGNRHS : 0;\n\n   \n  if (pchar == '*' && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)\n    qflags |= Q_DOUBLE_QUOTES;\t\t \n\n  ret = string_list_pos_params (pchar, save, qflags, pflags);\n  dispose_words (save);\n\n  return (ret);\n}\n\n \nstatic char *\nparameter_brace_casemod (varname, value, estatep, modspec, patspec, quoted, pflags, flags)\n     char *varname, *value;\n     array_eltstate_t *estatep;\n     int modspec;\n     char *patspec;\n     int quoted, pflags, flags;\n{\n  int vtype, starsub, modop, mflags, x;\n  char *val, *temp, *pat, *p, *lpat, *tt, *oname;\n  SHELL_VAR *v;\n\n  if (value == 0)\n    return ((char *)NULL);\n\n  oname = this_command_name;\n  this_command_name = varname;\n\n  vtype = get_var_and_type (varname, value, estatep, quoted, flags, &v, &val);\n  if (vtype == -1)\n    {\n      this_command_name = oname;\n      return ((char *)NULL);\n    }\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n  modop = 0;\n  mflags = 0;\n  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n    mflags |= MATCH_QUOTED;\n  if (starsub)\n    mflags |= MATCH_STARSUB;\n  if (pflags & PF_ASSIGNRHS)\n    mflags |= MATCH_ASSIGNRHS;\n  \n  p = patspec;\n  if (modspec == '^')\n    {\n      x = p && p[0] == modspec;\n      modop = x ? CASE_UPPER : CASE_UPFIRST;\n      p += x;\n    }\n  else if (modspec == ',')\n    {\n      x = p && p[0] == modspec;\n      modop = x ? CASE_LOWER : CASE_LOWFIRST;\n      p += x;\n    }\n  else if (modspec == '~')\n    {\n      x = p && p[0] == modspec;\n      modop = x ? CASE_TOGGLEALL : CASE_TOGGLE;\n      p += x;\n    }\n    \n  lpat = p ? savestring (p) : 0;\n   \n  pat = lpat ? getpattern (lpat, quoted, 1) : 0;\n\n   \n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp = sh_modcase (val, pat, modop);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp)\n\t{\n\t  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n\n    case VT_POSPARMS:\n      temp = pos_params_modcase (val, pat, modop, mflags);\n      if (temp && quoted == 0 && ifs_is_null)\n\t{\n\t   \n\t}\n      else if (temp && (mflags & MATCH_QUOTED) == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n       \n      if ((mflags & MATCH_STARSUB) && (mflags & MATCH_ASSIGNRHS) && ifs_is_null)\n\tmflags |= MATCH_QUOTED;\t\t \n\n      temp = assoc_p (v) ? assoc_modcase (assoc_cell (v), pat, modop, mflags)\n\t\t\t : array_modcase (array_cell (v), pat, modop, mflags);\n\n      if (temp && quoted == 0 && ifs_is_null)\n\t{\n\t   \n\t}\n      else if (temp && (mflags & MATCH_QUOTED) == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n\n      break;\n#endif\n    }\n\n  FREE (pat);\n  free (lpat);\n\n  this_command_name = oname;\n\n  return temp;\n}\n\n \nstatic int\nchk_arithsub (s, len)\n     const char *s;\n     int len;\n{\n  int i, count;\n  DECLARE_MBSTATE;\n\n  i = count = 0;\n  while (i < len)\n    {\n      if (s[i] == LPAREN)\n\tcount++;\n      else if (s[i] == RPAREN)\n\t{\n\t  count--;\n\t  if (count < 0)\n\t    return 0;\n\t}\n\n      switch (s[i])\n\t{\n\tdefault:\n\t  ADVANCE_CHAR (s, len, i);\n\t  break;\n\n\tcase '\\\\':\n\t  i++;\n\t  if (s[i])\n\t    ADVANCE_CHAR (s, len, i);\n\t  break;\n\n\tcase '\\'':\n\t  i = skip_single_quoted (s, len, ++i, 0);\n\t  break;\n\n\tcase '\"':\n\t  i = skip_double_quoted ((char *)s, len, ++i, 0);\n\t  break;\n\t}\n    }\n\n  return (count == 0);\n}\n\n \n \n \n \n \n\n \nstatic WORD_DESC *\nparameter_brace_expand (string, indexp, quoted, pflags, quoted_dollar_atp, contains_dollar_at)\n     char *string;\n     int *indexp, quoted, pflags, *quoted_dollar_atp, *contains_dollar_at;\n{\n  int check_nullness, var_is_set, var_is_null, var_is_special;\n  int want_substring, want_indir, want_patsub, want_casemod, want_attributes;\n  char *name, *value, *temp, *temp1;\n  WORD_DESC *tdesc, *ret;\n  int t_index, sindex, c, tflag, modspec, local_pflags, all_element_arrayref;\n  intmax_t number;\n  array_eltstate_t es;\n\n  temp = temp1 = value = (char *)NULL;\n  var_is_set = var_is_null = var_is_special = check_nullness = 0;\n  want_substring = want_indir = want_patsub = want_casemod = want_attributes = 0;\n\n  local_pflags = 0;\n  all_element_arrayref = 0;\n\n  sindex = *indexp;\n  t_index = ++sindex;\n   \n  if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))\t\t \n    name = string_extract (string, &t_index, \"}\", SX_VARNAME);\n  else\n#if defined (CASEMOD_EXPANSIONS)\n     \n#  if defined (CASEMOD_TOGGLECASE)\n    name = string_extract (string, &t_index, \"#%^,~:-=?+/@}\", SX_VARNAME);\n#  else\n    name = string_extract (string, &t_index, \"#%^,:-=?+/@}\", SX_VARNAME);\n#  endif  \n#else\n    name = string_extract (string, &t_index, \"#%:-=?+/@}\", SX_VARNAME);\n#endif  \n\n   \n  if (*name == 0 && sindex == t_index && string[sindex] == '@')\n    {\n      name = (char *)xrealloc (name, 2);\n      name[0] = '@';\n      name[1] = '\\0';\n      t_index++;\n    }\n  else if (*name == '!' && t_index > sindex && string[t_index] == '@' && string[t_index+1] == RBRACE)\n    {\n      name = (char *)xrealloc (name, t_index - sindex + 2);\n      name[t_index - sindex] = '@';\n      name[t_index - sindex + 1] = '\\0';\n      t_index++;\n    }\n\n  ret = 0;\n  tflag = 0;\n\n#if defined (ARRAY_VARS)\n  init_eltstate (&es);\n#endif\n  es.ind = INTMAX_MIN;\t \n\n   \n  if ((sindex == t_index && VALID_SPECIAL_LENGTH_PARAM (string[t_index])) ||\n      (sindex == t_index && string[sindex] == '#' && VALID_SPECIAL_LENGTH_PARAM (string[sindex + 1])) ||\n      (sindex == t_index - 1 && string[sindex] == '!' && VALID_INDIR_PARAM (string[t_index])))\n    {\n      t_index++;\n      temp1 = string_extract (string, &t_index, \"#%:-=?+/@}\", 0);\n      name = (char *)xrealloc (name, 3 + (strlen (temp1)));\n      *name = string[sindex];\n      if (string[sindex] == '!')\n\t{\n\t   \n\t  name[1] = string[sindex + 1];\n\t  strcpy (name + 2, temp1);\n\t}\n      else\t\n\tstrcpy (name + 1, temp1);\n      free (temp1);\n    }\n  sindex = t_index;\n\n   \n  if (c = string[sindex])\n    sindex++;\n\n   \n  if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))\n    {\n      check_nullness++;\n      if (c = string[sindex])\n\tsindex++;\n    }\n  else if (c == ':' && string[sindex] != RBRACE)\n    want_substring = 1;\n  else if (c == '/'  )\t \n    want_patsub = 1;\n#if defined (CASEMOD_EXPANSIONS)\n  else if (c == '^' || c == ',' || c == '~')\n    {\n      modspec = c;\n      want_casemod = 1;\n    }\n#endif\n  else if (c == '@' && (string[sindex] == 'a' || string[sindex] == 'A') && string[sindex+1] == RBRACE)\n    {\n       \n      want_attributes = 1;\n      local_pflags |= PF_ALLINDS;\n    }\n\n   \n   \n  if (name[0] == '#' && name[1] == '\\0' && check_nullness == 0 &&\n\tVALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)\n    {\n      name = (char *)xrealloc (name, 3);\n      name[1] = c;\n      name[2] = '\\0';\n      c = string[sindex++];\n    }\n\n   \n  if (name[0] == '#' && name[1] == '\\0' && check_nullness == 0 &&\n\tmember (c, \"%:=+/\") && string[sindex] == RBRACE)\n    {\n      temp = (char *)NULL;\n      goto bad_substitution;\t \n    }\n\n   \n  want_indir = *name == '!' &&\n    (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])\n\t\t\t\t\t|| VALID_INDIR_PARAM (name[1]));\n\n   \n\n   \n  if (SPECIAL_VAR (name, want_indir))\n    var_is_special++;\n\n   \n  if (*name == '#' && name[1])\n    {\n       \n      if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))\n\t{\n\t  temp = (char *)NULL;\n\t  goto bad_substitution;\t \n\t}\n\n      number = parameter_brace_expand_length (name);\n      if (number == INTMAX_MIN && unbound_vars_is_error)\n\t{\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  err_unboundvar (name+1);\n\t  free (name);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n      free (name);\n\n      *indexp = sindex;\n      if (number < 0)\n        return (&expand_wdesc_error);\n      else\n\t{\n\t  ret = alloc_word_desc ();\n\t  ret->word = itos (number);\n\t  return ret;\n\t}\n    }\n\n   \n  if (name[0] == '@' && name[1] == '\\0')\n    {\n      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t*quoted_dollar_atp = 1;\n\n      if (contains_dollar_at)\n\t*contains_dollar_at = 1;\n\n      tflag |= W_DOLLARAT;\n    }\n\n   \n  if (want_indir && string[sindex - 1] == RBRACE &&\n      (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&\n      legal_variable_starter ((unsigned char) name[1]))\n    {\n      char **x;\n      WORD_LIST *xlist;\n\n      temp1 = savestring (name + 1);\n      number = strlen (temp1);\n      temp1[number - 1] = '\\0';\n      x = all_variables_matching_prefix (temp1);\n      xlist = strvec_to_word_list (x, 0, 0);\n      if (string[sindex - 2] == '*')\n\ttemp = string_list_dollar_star (xlist, quoted, 0);\n      else\n\t{\n\t  temp = string_list_dollar_at (xlist, quoted, 0);\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t    *quoted_dollar_atp = 1;\n\t  if (contains_dollar_at)\n\t    *contains_dollar_at = 1;\n\n\t  tflag |= W_DOLLARAT;\n\t}\n      free (x);\n      dispose_words (xlist);\n      free (temp1);\n      *indexp = sindex;\n\n      free (name);\n\n      ret = alloc_word_desc ();\n      ret->word = temp;\n      ret->flags = tflag;\t \n      return ret;\n    }\n\n#if defined (ARRAY_VARS)      \n   \n  if (want_indir && string[sindex - 1] == RBRACE &&\n      string[sindex - 2] == RBRACK && valid_array_reference (name+1, 0))\n    {\n      char *x, *x1;\n\n      temp1 = savestring (name + 1);\n      x = array_variable_name (temp1, 0, &x1, (int *)0);\n      FREE (x);\n      if (ALL_ELEMENT_SUB (x1[0]) && x1[1] == RBRACK)\n\t{\n\t  temp = array_keys (temp1, quoted, pflags);\t \n\t  if (x1[0] == '@')\n\t    {\n\t      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t\t*quoted_dollar_atp = 1;\n\t      if (contains_dollar_at)\n\t\t*contains_dollar_at = 1;\n\n\t      tflag |= W_DOLLARAT;\n\t    }\t    \n\n\t  free (name);\n\t  free (temp1);\n\t  *indexp = sindex;\n\n\t  ret = alloc_word_desc ();\n\t  ret->word = temp;\n\t  ret->flags = tflag;\t \n\t  return ret;\n\t}\n\n      free (temp1);\n    }\n#endif  \n      \n   \n  if (valid_brace_expansion_word (want_indir ? name + 1 : name,\n\t\t\t\t\tvar_is_special) == 0)\n    {\n      temp = (char *)NULL;\n      goto bad_substitution;\t\t \n    }\n\n  if (want_indir)\n    {\n      tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, pflags|local_pflags, quoted_dollar_atp, contains_dollar_at);\n      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)\n\t{\n\t  temp = (char *)NULL;\n\t  goto bad_substitution;\n\t}\n\n       \n      if (tdesc && tdesc->flags)\n\ttdesc->flags &= ~W_ARRAYIND;\n\n       \n      if (contains_dollar_at && *contains_dollar_at)\n\tall_element_arrayref = 1;\n    }\n  else\n    {\n      local_pflags |= PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS));\n      tdesc = parameter_brace_expand_word (name, var_is_special, quoted, local_pflags, &es);\n    }\n\n  if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)\n    {\n      tflag = 0;\n      tdesc = 0;\n    }\n\n  if (tdesc)\n    {\n      temp = tdesc->word;\n      tflag = tdesc->flags;\n      dispose_word_desc (tdesc);\n    }\n  else\n    temp = (char *)0;\n\n  if (temp == &expand_param_error || temp == &expand_param_fatal)\n    {\n      FREE (name);\n      FREE (value);\n      return (temp == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);\n    }\n\n#if defined (ARRAY_VARS)\n  if (valid_array_reference (name, 0))\n    {\n      int qflags;\n      char *t;\n\n      qflags = quoted;\n       \n\n      if (pflags & PF_ASSIGNRHS)\n\tqflags |= Q_DOUBLE_QUOTES;\n       \n      t = mbschr (name, LBRACK);\n      if (t && ALL_ELEMENT_SUB (t[1]) && t[2] == RBRACK)\n\t{\n\t  all_element_arrayref = 1;\n\t  if (expand_no_split_dollar_star && t[1] == '*')\t \n\t    qflags |= Q_DOUBLE_QUOTES;\n\t}\n      chk_atstar (name, qflags, pflags, quoted_dollar_atp, contains_dollar_at);\n    }\n#endif\n\n  var_is_set = temp != (char *)0;\n  var_is_null = check_nullness && (var_is_set == 0 || *temp == 0);\n   \n  if (check_nullness)\n    var_is_null |= var_is_set && var_is_special && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp);\n#if defined (ARRAY_VARS)\n  if (check_nullness)\n    var_is_null |= var_is_set && \n\t\t   (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) &&\n\t\t   QUOTED_NULL (temp) &&\n\t\t   valid_array_reference (name, 0) &&\n\t\t   chk_atstar (name, 0, 0, (int *)0, (int *)0);\n#endif\n\n   \n  if (c && c != RBRACE)\n    {\n       \n      value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#' || c =='/' || c == '^' || c == ',' || c ==':') ? SX_POSIXEXP|SX_WORD : SX_WORD);\n      if (string[sindex] == RBRACE)\n\tsindex++;\n      else\n\tgoto bad_substitution;\t\t \n    }\n  else\n    value = (char *)NULL;\n\n  *indexp = sindex;\n\n   \n  if (want_substring || want_patsub || want_casemod || c == '@' || c == '#' || c == '%' || c == RBRACE)\n    {\n      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]) && all_element_arrayref == 0)\n\t{\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  err_unboundvar (name);\n\t  FREE (value);\n\t  FREE (temp);\n\t  free (name);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n    }\n    \n   \n  if (want_substring)\n    {\n      temp1 = parameter_brace_substring (name, temp, &es, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      FREE (value);\n      FREE (temp);\n#if defined (ARRAY_VARS)\n      flush_eltstate (&es);\n#endif\n\n      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)\n        {\n          FREE (name);\n\t  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);\n        }\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n       \n      if (temp1 &&\n          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&\n\t  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 &&\n\t\t(pflags & PF_ASSIGNRHS))\n\tret->flags |= W_SPLITSPACE;\t \t\n       \n      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)\n\tret->flags |= W_SPLITSPACE;\t \n\n      FREE (name);\n      return ret;\n    }\n  else if (want_patsub)\n    {\n      temp1 = parameter_brace_patsub (name, temp, &es, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      FREE (value);\n      FREE (temp);\n#if defined (ARRAY_VARS)\n      flush_eltstate (&es);\n#endif\n\n      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)\n        {\n          FREE (name);\n\t  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);\n        }\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 && \n          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&\n\t  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n       \n      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)\n\tret->flags |= W_SPLITSPACE;\t \n\n      FREE (name);\n      return ret;\n    }\n#if defined (CASEMOD_EXPANSIONS)\n  else if (want_casemod)\n    {\n      temp1 = parameter_brace_casemod (name, temp, &es, modspec, value, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      FREE (value);\n      FREE (temp);\n#if defined (ARRAY_VARS)\n      flush_eltstate (&es);\n#endif\n\n      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)\n        {\n          FREE (name);\n\t  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);\n        }\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 &&\n          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&\n\t  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n       \n      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)\n\tret->flags |= W_SPLITSPACE;\t \n\n      FREE (name);\n      return ret;\n    }\n#endif\n\n   \n  switch (c)\n    {\n    default:\n    case '\\0':\nbad_substitution:\n      set_exit_status (EXECUTION_FAILURE);\n      report_error (_(\"%s: bad substitution\"), string ? string : \"??\");\n      FREE (value);\n      FREE (temp);\n      free (name);\n#if defined (ARRAY_VARS)\n      flush_eltstate (&es);\n#endif\n      if (shell_compatibility_level <= 43)\n\treturn &expand_wdesc_error;\n      else\n\treturn ((posixly_correct && interactive_shell == 0) ? &expand_wdesc_fatal : &expand_wdesc_error);\n\n    case RBRACE:\n      break;\n\n    case '@':\n      temp1 = parameter_brace_transform (name, temp, &es, value, c, quoted, pflags, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      free (temp);\n      free (value);\n#if defined (ARRAY_VARS)\n      flush_eltstate (&es);\n#endif\n\n      if (temp1 == &expand_param_error || temp1 == &expand_param_fatal)\n\t{\n\t  free (name);\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  report_error (_(\"%s: bad substitution\"), string ? string : \"??\");\n\t  return (temp1 == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n       \n      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)\n\tret->flags |= W_SPLITSPACE;\t \n\n      free (name);\n      return ret;\n\n    case '#':\t \n    case '%':\t \n      if (value == 0 || *value == '\\0' || temp == 0 || *temp == '\\0')\n\t{\n\t  FREE (value);\n\t  break;\n\t}\n      temp1 = parameter_brace_remove_pattern (name, temp, &es, value, c, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      free (temp);\n      free (value);\n#if defined (ARRAY_VARS)\n      flush_eltstate (&es);\n#endif\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n       \n      else if (temp1 && (name[0] == '*' && name[1] == 0) && quoted == 0 && ifs_is_null)\n\tret->flags |= W_SPLITSPACE;\t \n\n      free (name);\n      return ret;\n\n    case '-':\n    case '=':\n    case '?':\n    case '+':\n      if (var_is_set && var_is_null == 0)\n\t{\n\t   \n\t  if (c == '+')\n\t    {\n\t       \n\t      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t\t*quoted_dollar_atp = 0;\n\t      if (contains_dollar_at)\n\t\t*contains_dollar_at = 0;\n\n\t      FREE (temp);\n\t      if (value)\n\t\t{\n\t\t   \n\t\t  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t\t    quoted |= Q_DOLBRACE;\n\t\t  ret = parameter_brace_expand_rhs (name, value, c,\n\t\t\t\t\t\t    quoted,\n\t\t\t\t\t\t    pflags,\n\t\t\t\t\t\t    quoted_dollar_atp,\n\t\t\t\t\t\t    contains_dollar_at);\n\t\t   \n\t\t  free (value);\n\t\t}\n\t      else\n\t\ttemp = (char *)NULL;\n\t    }\n\t  else\n\t    {\n\t      FREE (value);\n\t    }\n\t   \n\t}\n      else\t \n\t{\n\t   \n\t  if (c == '+' && temp && QUOTED_NULL (temp) &&\n\t      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    tflag |= W_HASQUOTEDNULL;\n\n\t  FREE (temp);\n\t  temp = (char *)NULL;\n\t  if (c == '=' && var_is_special)\n\t    {\n\t      set_exit_status (EXECUTION_FAILURE);\n\t      report_error (_(\"$%s: cannot assign in this way\"), name);\n\t      free (name);\n\t      free (value);\n#if defined (ARRAY_VARS)\n\t      flush_eltstate (&es);\n#endif\n\t      return &expand_wdesc_error;\n\t    }\n\t  else if (c == '?')\n\t    {\n\t      parameter_brace_expand_error (name, value, check_nullness);\n#if defined (ARRAY_VARS)\n\t      flush_eltstate (&es);\n#endif\n\t      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t    }\n\t  else if (c != '+')\n\t    {\n\t       \n\t      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t\t*quoted_dollar_atp = 0;\n\t      if (contains_dollar_at)\n\t\t*contains_dollar_at = 0;\n\n\t       \n\t      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t\tquoted |= Q_DOLBRACE;\n\t      ret = parameter_brace_expand_rhs (name, value, c, quoted, pflags,\n\t\t\t\t\t\tquoted_dollar_atp,\n\t\t\t\t\t\tcontains_dollar_at);\n\t       \n\t    }\n\t  free (value);\n\t}\n\n      break;\n    }\n  free (name);\n#if defined (ARRAY_VARS)\n  flush_eltstate (&es);\n#endif\n\n  if (ret == 0)\n    {\n      ret = alloc_word_desc ();\n      ret->flags = tflag;\n      ret->word = temp;\n    }\n  return (ret);\n}\n\n \nstatic WORD_DESC *\nparam_expand (string, sindex, quoted, expanded_something,\n\t      contains_dollar_at, quoted_dollar_at_p, had_quoted_null_p,\n\t      pflags)\n     char *string;\n     int *sindex, quoted, *expanded_something, *contains_dollar_at;\n     int *quoted_dollar_at_p, *had_quoted_null_p, pflags;\n{\n  char *temp, *temp1, uerror[3], *savecmd;\n  int zindex, t_index, expok, eflag;\n  unsigned char c;\n  intmax_t number;\n  SHELL_VAR *var;\n  WORD_LIST *list, *l;\n  WORD_DESC *tdesc, *ret;\n  int tflag, nullarg;\n\n \n  zindex = *sindex;\n  c = string[++zindex];\n\n  temp = (char *)NULL;\n  ret = tdesc = (WORD_DESC *)NULL;\n  tflag = 0;\n\n   \n  switch (c)\n    {\n     \n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      temp1 = dollar_vars[TODIGIT (c)];\n       \n      if (unbound_vars_is_error && temp1 == (char *)NULL)\n\t{\n\t  uerror[0] = '$';\n\t  uerror[1] = c;\n\t  uerror[2] = '\\0';\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  err_unboundvar (uerror);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n      if (temp1)\n\ttemp = (*temp1 && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t\t  ? quote_string (temp1)\n\t\t  : quote_escapes (temp1);\n      else\n\ttemp = (char *)NULL;\n\n      break;\n\n     \n    case '$':\n      temp = itos (dollar_dollar_pid);\n      break;\n\n     \n    case '#':\n      temp = itos (number_of_args ());\n      break;\n\n     \n    case '?':\n      temp = itos (last_command_exit_value);\n      break;\n\n     \n    case '-':\n      temp = which_set_flags ();\n      break;\n\n       \n    case '!':\n       \n      if (last_asynchronous_pid == NO_PID)\n\t{\n\t  if (expanded_something)\n\t    *expanded_something = 0;\n\t  temp = (char *)NULL;\n\t  if (unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)\n\t    {\n\t      uerror[0] = '$';\n\t      uerror[1] = c;\n\t      uerror[2] = '\\0';\n\t      set_exit_status (EXECUTION_FAILURE);\n\t      err_unboundvar (uerror);\n\t      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t    }\n\t}\n      else\n\ttemp = itos (last_asynchronous_pid);\n      break;\n\n     \n    case '*':\t\t \n      list = list_rest_of_args ();\n\n#if 0\n       \n\n      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)\n\t{\n\t  uerror[0] = '$';\n\t  uerror[1] = '*';\n\t  uerror[2] = '\\0';\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  err_unboundvar (uerror);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n#endif\n\n       \n      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && list == 0)\n\ttemp = (char *)NULL;\n      else if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES|Q_PATQUOTE))\n\t{\n\t   \n\t  temp = (quoted & (Q_DOUBLE_QUOTES|Q_PATQUOTE)) ? string_list_dollar_star (list, quoted, 0) : string_list (list);\n\t  if (temp)\n\t    {\n\t      temp1 = (quoted & Q_DOUBLE_QUOTES) ? quote_string (temp) : temp;\n\t      if (*temp == 0)\n\t\ttflag |= W_HASQUOTEDNULL;\n\t      if (temp != temp1)\n\t\tfree (temp);\n\t      temp = temp1;\n\t    }\n\t}\n      else\n\t{\n\t   \n\t  if (expand_no_split_dollar_star && quoted == 0 && ifs_is_set == 0 && (pflags & PF_ASSIGNRHS))\n\t    {\n\t       \n\t      temp1 = string_list_dollar_star (list, quoted, pflags);\n\t      temp = temp1 ? quote_string (temp1) : temp1;\n\t       \n\t      if (temp1 && *temp1 == 0 && QUOTED_NULL (temp))\n\t\ttflag |= W_SAWQUOTEDNULL;\n\t      FREE (temp1);\n\t    }\n\t  else if (expand_no_split_dollar_star && quoted == 0 && ifs_is_null && (pflags & PF_ASSIGNRHS))\n\t    {\n\t       \n\t      temp1 = string_list_dollar_star (list, quoted, pflags);\n\t      temp = temp1 ? quote_escapes (temp1) : temp1;\n\t      FREE (temp1);\n\t    }\n\t  else if (expand_no_split_dollar_star && quoted == 0 && ifs_is_set && ifs_is_null == 0 && (pflags & PF_ASSIGNRHS))\n\t    {\n\t       \n\t      temp1 = string_list_dollar_star (list, quoted, pflags);\n\t      temp = temp1 ? quote_string (temp1) : temp1;\n\n\t       \n\t      if (temp1 && *temp1 == 0 && QUOTED_NULL (temp))\n\t\ttflag |= W_SAWQUOTEDNULL;\n\t      FREE (temp1);\n\t    }\n\t   \n#  if defined (HANDLE_MULTIBYTE)\n\t  else if (expand_no_split_dollar_star && ifs_firstc[0] == 0)\n#  else\n\t  else if (expand_no_split_dollar_star && ifs_firstc == 0)\n#  endif\n\t     \n\t    temp = string_list_dollar_star (list, quoted, 0);\n\t  else\n\t    {\n\t      temp = string_list_dollar_at (list, quoted, 0);\n\t       \n#if 0\n\t      if (quoted == 0 && (ifs_is_set == 0 || ifs_is_null))\n#else\t \n\t      if (quoted == 0 && ifs_is_null)\n#endif\n\t\ttflag |= W_SPLITSPACE;\n\t       \n\t      else if (temp && quoted == 0 && ifs_is_set && (pflags & PF_ASSIGNRHS))\n\t\t{\n\t\t  temp1 = quote_string (temp);\n\t\t  free (temp);\n\t\t  temp = temp1;\n\t\t}\n\t    }\n\n\t  if (expand_no_split_dollar_star == 0 && contains_dollar_at)\n\t    *contains_dollar_at = 1;\n\t}\n\n      dispose_words (list);\n      break;\n\n     \n    case '@':\t\t \n      list = list_rest_of_args ();\n\n#if 0\n       \n\n      if (list == 0 && unbound_vars_is_error && (pflags & PF_IGNUNBOUND) == 0)\n\t{\n\t  uerror[0] = '$';\n\t  uerror[1] = '@';\n\t  uerror[2] = '\\0';\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  err_unboundvar (uerror);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n#endif\n\n      for (nullarg = 0, l = list; l; l = l->next)\n\t{\n\t  if (l->word && (l->word->word == 0 || l->word->word[0] == 0))\n\t    nullarg = 1;\n\t}\n\n       \n       \n      if (quoted_dollar_at_p && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t*quoted_dollar_at_p = 1;\n      if (contains_dollar_at)\n\t*contains_dollar_at = 1;\n\n       \n       \n\n       \n      if (pflags & PF_ASSIGNRHS)\n\t{\n\t  temp = string_list_dollar_at (list, (quoted|Q_DOUBLE_QUOTES), pflags);\n\t  if (nullarg)\n\t    tflag |= W_HASQUOTEDNULL;\t \n\t}\n\n       \n      else if (pflags & PF_NOSPLIT2)\n        {\n#if defined (HANDLE_MULTIBYTE)\n\t  if (quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc[0] != ' ')\n#else\n\t  if (quoted == 0 && ifs_is_set && ifs_is_null == 0 && ifs_firstc != ' ')\n#endif\n\t     \n\t    temp = string_list_dollar_at (list, Q_DOUBLE_QUOTES, pflags);\n\t  else\n\t    temp = string_list_dollar_at (list, quoted, pflags);\n\t}\n      else\n\ttemp = string_list_dollar_at (list, quoted, pflags);\n\n      tflag |= W_DOLLARAT;\n      dispose_words (list);\n      break;\n\n    case LBRACE:\n      tdesc = parameter_brace_expand (string, &zindex, quoted, pflags,\n\t\t\t\t      quoted_dollar_at_p,\n\t\t\t\t      contains_dollar_at);\n\n      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)\n\treturn (tdesc);\n      temp = tdesc ? tdesc->word : (char *)0;\n\n       \n       \n       \n      if (tdesc && tdesc->word && (tdesc->flags & W_HASQUOTEDNULL) && QUOTED_NULL (temp))\n\t{\n\t  if (had_quoted_null_p)\n\t    *had_quoted_null_p = 1;\n\t  if (*quoted_dollar_at_p == 0)\n\t    {\n\t      free (temp);\n\t      tdesc->word = temp = (char *)NULL;\n\t    }\n\t    \n\t}\n\n      ret = tdesc;\n      goto return0;\n\n     \n    case LPAREN:\n       \n      t_index = zindex + 1;\n       \n      temp = extract_command_subst (string, &t_index, (pflags&PF_COMPLETE) ? SX_COMPLETE : 0);\n      zindex = t_index;\n\n       \n      if (temp && *temp == LPAREN)\n\t{\n\t  char *temp2;\n\t  temp1 = temp + 1;\n\t  temp2 = savestring (temp1);\n\t  t_index = strlen (temp2) - 1;\n\n\t  if (temp2[t_index] != RPAREN)\n\t    {\n\t      free (temp2);\n\t      goto comsub;\n\t    }\n\n\t   \n\t  temp2[t_index] = '\\0';\n\n\t  if (chk_arithsub (temp2, t_index) == 0)\n\t    {\n\t      free (temp2);\n#if 0\n\t      internal_warning (_(\"future versions of the shell will force evaluation as an arithmetic substitution\"));\n#endif\n\t      goto comsub;\n\t    }\n\n\t   \n\t  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES|Q_ARITH);\n\t  free (temp2);\n\narithsub:\n\t   \n\t  savecmd = this_command_name;\n\t  this_command_name = (char *)NULL;\n\n\t  eflag = (shell_compatibility_level > 51) ? 0 : EXP_EXPANDED;\n\t  number = evalexp (temp1, eflag, &expok);\n\t  this_command_name = savecmd;\n\t  free (temp);\n\t  free (temp1);\n\t  if (expok == 0)\n\t    {\n\t      if (interactive_shell == 0 && posixly_correct)\n\t\t{\n\t\t  set_exit_status (EXECUTION_FAILURE);\n\t\t  return (&expand_wdesc_fatal);\n\t\t}\n\t      else\n\t\treturn (&expand_wdesc_error);\n\t    }\n\t  temp = itos (number);\n\t  break;\n\t}\n\ncomsub:\n      if (pflags & PF_NOCOMSUB)\n\t \n\ttemp1 = substring (string, *sindex, zindex+1);\n      else\n\t{\n\t  tdesc = command_substitute (temp, quoted, pflags&PF_ASSIGNRHS);\n\t  temp1 = tdesc ? tdesc->word : (char *)NULL;\n\t  if (tdesc)\n\t    dispose_word_desc (tdesc);\n\t}\n      FREE (temp);\n      temp = temp1;\n      break;\n\n     \n    case '[':\t\t \n       \n      t_index = zindex + 1;\n      temp = extract_arithmetic_subst (string, &t_index);\n      zindex = t_index;\n      if (temp == 0)\n\t{\n\t  temp = savestring (string);\n\t  if (expanded_something)\n\t    *expanded_something = 0;\n\t  goto return0;\n\t}\t  \n\n        \n      temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES|Q_ARITH);\n\n      goto arithsub;\n\n    default:\n       \n      temp = (char *)NULL;\n\n      for (t_index = zindex; (c = string[zindex]) && legal_variable_char (c); zindex++)\n\t;\n      temp1 = (zindex > t_index) ? substring (string, t_index, zindex) : (char *)NULL;\n\n       \n      if (temp1 == 0 || *temp1 == '\\0')\n\t{\n\t  FREE (temp1);\n\t  temp = (char *)xmalloc (2);\n\t  temp[0] = '$';\n\t  temp[1] = '\\0';\n\t  if (expanded_something)\n\t    *expanded_something = 0;\n\t  goto return0;\n\t}\n\n       \n      var = find_variable (temp1);\n\n      if (var && invisible_p (var) == 0 && var_isset (var))\n\t{\n#if defined (ARRAY_VARS)\n\t  if (assoc_p (var) || array_p (var))\n\t    {\n\t      temp = array_p (var) ? array_reference (array_cell (var), 0)\n\t\t\t\t   : assoc_reference (assoc_cell (var), \"0\");\n\t      if (temp)\n\t\ttemp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t\t\t  ? quote_string (temp)\n\t\t\t  : quote_escapes (temp);\n\t      else if (unbound_vars_is_error)\n\t\tgoto unbound_variable;\n\t    }\n\t  else\n#endif\n\t    {\n\t      temp = value_cell (var);\n\n\t      temp = (*temp && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t\t\t? quote_string (temp)\n\t\t\t: ((pflags & PF_ASSIGNRHS) ? quote_rhs (temp)\n\t\t\t\t\t\t   : quote_escapes (temp));\n\t    }\n\n\t  free (temp1);\n\n\t  goto return0;\n\t}\n      else if (var && (invisible_p (var) || var_isset (var) == 0))\n\ttemp = (char *)NULL;\n      else if ((var = find_variable_last_nameref (temp1, 0)) && var_isset (var) && invisible_p (var) == 0)\n\t{\n\t  temp = nameref_cell (var);\n#if defined (ARRAY_VARS)\n\t  if (temp && *temp && valid_array_reference (temp, 0))\n\t    {\n\t      chk_atstar (temp, quoted, pflags, quoted_dollar_at_p, contains_dollar_at);\n\t      tdesc = parameter_brace_expand_word (temp, SPECIAL_VAR (temp, 0), quoted, pflags, 0);\n\t      if (tdesc == &expand_wdesc_error || tdesc == &expand_wdesc_fatal)\n\t\treturn (tdesc);\n\t      ret = tdesc;\n\t      goto return0;\n\t    }\n\t  else\n#endif\n\t   \n\t  if (temp && *temp && legal_identifier (temp) == 0)\n\t    {\n\t      set_exit_status (EXECUTION_FAILURE);\n\t      report_error (_(\"%s: invalid variable name for name reference\"), temp);\n\t      return (&expand_wdesc_error);\t \n\t    }\n\t  else\n\t    temp = (char *)NULL;\n\t}\n\n      temp = (char *)NULL;\n\nunbound_variable:\n      if (unbound_vars_is_error)\n\t{\n\t  set_exit_status (EXECUTION_FAILURE);\n\t  err_unboundvar (temp1);\n\t}\n      else\n\t{\n\t  free (temp1);\n\t  goto return0;\n\t}\n\n      free (temp1);\n      set_exit_status (EXECUTION_FAILURE);\n      return ((unbound_vars_is_error && interactive_shell == 0)\n\t\t? &expand_wdesc_fatal\n\t\t: &expand_wdesc_error);\n    }\n\n  if (string[zindex])\n    zindex++;\n\nreturn0:\n  *sindex = zindex;\n\n  if (ret == 0)\n    {\n      ret = alloc_word_desc ();\n      ret->flags = tflag;\t \n      ret->word = temp;\n    }\n  return ret;\n}\n\n#if defined (ARRAY_VARS)\n \nstatic char abstab[256] = { '\\1' };\n\n \nchar *\nexpand_subscript_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_DESC td;\n  WORD_LIST *tlist;\n  int oe;\n  char *ret;\n\n  if (string == 0 || *string == 0)\n    return (char *)NULL;\n\n  oe = expand_no_split_dollar_star;\n  ret = (char *)NULL;\n\n  td.flags = W_NOPROCSUB|W_NOTILDE|W_NOSPLIT2;\t \n  td.word = savestring (string);\t\t \n\n  expand_no_split_dollar_star = 1;\n  tlist = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);\n  expand_no_split_dollar_star = oe;\n\n  if (tlist)\n    {\n      if (tlist->word)\n\t{\n\t  remove_quoted_nulls (tlist->word->word);\n\t  tlist->word->flags &= ~W_HASQUOTEDNULL;\n\t}\n      dequote_list (tlist);\n      ret = string_list (tlist);\n      dispose_words (tlist);\n    }\n\n  free (td.word);\n  return (ret);\n}\n\n \nstatic char *\nexpand_array_subscript (string, sindex, quoted, flags)\n     char *string;\n     int *sindex;\n     int quoted, flags;\n{\n  char *ret, *exp, *t;\n  size_t slen;\n  int si, ni;\n\n  si = *sindex;\n  slen = STRLEN (string);\n\n  if (abstab[0] == '\\1')\n    {\n       \n      memset (abstab, '\\0', sizeof (abstab));\n      abstab[LBRACK] = abstab[RBRACK] = 1;\n      abstab['$'] = abstab['`'] = abstab['~'] = 1;\n      abstab['\\\\'] = abstab['\\''] = 1;\n      abstab['\"'] = 1;\t \n       \n    }\n\n   \n  ni = skipsubscript (string, si, 0);\n   \n  if (ni >= slen || string[ni] != RBRACK || (ni - si) == 1 ||\n      (string[ni+1] != '\\0' && (quoted & Q_ARITH) == 0))\n    {\n       \n      INTERNAL_DEBUG ((\"expand_array_subscript: bad subscript string: `%s'\", string+si));\n      ret = (char *)xmalloc (2);\t \n      ret[0] = string[si];\n      ret[1] = '\\0';\n      *sindex = si + 1;\n      return ret;\n    }\n\n   \n  exp = substring (string, si+1, ni);\n  t = expand_subscript_string (exp, quoted & ~(Q_ARITH|Q_DOUBLE_QUOTES));\n  free (exp);\n  exp = t ? sh_backslash_quote (t, abstab, 0) : savestring (\"\");\n  free (t);\n\n  slen = STRLEN (exp);\n  ret = xmalloc (slen + 2 + 1);\n  ret[0] ='[';\n  strcpy (ret + 1, exp);\n  ret[slen + 1] = ']';\n  ret[slen + 2] = '\\0';\n\n  free (exp);\n  *sindex = ni + 1;\n\n  return ret;\n}\n#endif\n\nvoid\ninvalidate_cached_quoted_dollar_at ()\n{\n  dispose_words (cached_quoted_dollar_at);\n  cached_quoted_dollar_at = 0;\n}\n\n \n\n \n#define UNQUOTED\t 0\n#define PARTIALLY_QUOTED 1\n#define WHOLLY_QUOTED    2\n\nstatic WORD_LIST *\nexpand_word_internal (word, quoted, isexp, contains_dollar_at, expanded_something)\n     WORD_DESC *word;\n     int quoted, isexp;\n     int *contains_dollar_at;\n     int *expanded_something;\n{\n  WORD_LIST *list;\n  WORD_DESC *tword;\n\n   \n  char *istring;\n\n   \n  size_t istring_size;\n\n   \n  size_t istring_index;\n\n   \n  char *temp, *temp1;\n\n   \n  register char *string;\n\n   \n  size_t string_size;\n\n   \n  int sindex;\n\n   \n  int quoted_dollar_at;\n\n   \n  int quoted_state;\n\n   \n  int had_quoted_null;\n  int has_quoted_ifs;\t\t \n  int has_dollar_at, temp_has_dollar_at;\n  int internal_tilde;\n  int split_on_spaces;\n  int local_expanded;\n  int tflag;\n  int pflags;\t\t\t \n  int mb_cur_max;\n\n  int assignoff;\t\t \n\n  register unsigned char c;\t \n  int t_index;\t\t\t \n\n  char twochars[2];\n\n  DECLARE_MBSTATE;\n\n   \n  if (STREQ (word->word, \"\\\"$@\\\"\") &&\n      (word->flags == (W_HASDOLLAR|W_QUOTED)) &&\n      dollar_vars[1])\t\t \n    {\n      if (contains_dollar_at)\n\t*contains_dollar_at = 1;\n      if (expanded_something)\n\t*expanded_something = 1;\n      if (cached_quoted_dollar_at)\n\treturn (copy_word_list (cached_quoted_dollar_at));\n      list = list_rest_of_args ();\n      list = quote_list (list);\n      cached_quoted_dollar_at = copy_word_list (list);\n      return (list);\n    }\n\n  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);\n  istring[istring_index = 0] = '\\0';\n  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;\n  has_quoted_ifs = 0;\n  split_on_spaces = 0;\n  internal_tilde = 0;\t\t \n  quoted_state = UNQUOTED;\n\n  string = word->word;\n  if (string == 0)\n    goto finished_with_string;\n  mb_cur_max = MB_CUR_MAX;\n\n   \n  string_size = (mb_cur_max > 1) ? strlen (string) : 1;\n\n  if (contains_dollar_at)\n    *contains_dollar_at = 0;\n\n  assignoff = -1;\n\n   \n\n  for (sindex = 0; ;)\n    {\n      c = string[sindex];\n\n       \n      switch (c)\n\t{\n\tcase '\\0':\n\t  goto finished_with_string;\n\n\tcase CTLESC:\n\t  sindex++;\n#if HANDLE_MULTIBYTE\n\t  if (mb_cur_max > 1 && string[sindex])\n\t    {\n\t      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);\n\t    }\n\t  else\n#endif\n\t    {\n\t      temp = (char *)xmalloc (3);\n\t      temp[0] = CTLESC;\n\t      temp[1] = c = string[sindex];\n\t      temp[2] = '\\0';\n\t    }\n\ndollar_add_string:\n\t  if (string[sindex])\n\t    sindex++;\n\nadd_string:\n\t  if (temp)\n\t    {\n\t      istring = sub_append_string (temp, istring, &istring_index, &istring_size);\n\t      temp = (char *)0;\n\t    }\n\n\t  break;\n\n#if defined (PROCESS_SUBSTITUTION)\n\t   \n\tcase '<':\n\tcase '>':\n\t  {\n\t        \n\t    if (string[++sindex] != LPAREN || (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (word->flags & W_NOPROCSUB))\n\t      {\n\t\tsindex--;\t \n\t\tgoto add_character;\n\t      }\n\t    else\n\t      t_index = sindex + 1;  \n\n\t    temp1 = extract_process_subst (string, (c == '<') ? \"<(\" : \">(\", &t_index, 0);  \n\t    sindex = t_index;\n\n\t     \n\t    temp = temp1 ? process_substitute (temp1, (c == '>')) : (char *)0;\n\n\t    FREE (temp1);\n\n\t    goto dollar_add_string;\n\t  }\n#endif  \n\n#if defined (ARRAY_VARS)\n\tcase '[':\t\t \n\t  if ((quoted & Q_ARITH) == 0 || shell_compatibility_level <= 51)\n\t    {\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\t  else\n\t    {\n\t      temp = expand_array_subscript (string, &sindex, quoted, word->flags);\n\t      goto add_string;\n\t    }\n#endif\n\n\tcase '=':\n\t   \t\n\t  if (word->flags & (W_ASSIGNRHS|W_NOTILDE))\n\t    {\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\t   \n\t  if ((word->flags & W_ASSIGNMENT) &&\n\t      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&\n\t      assignoff == -1 && sindex > 0)\n\t    assignoff = sindex;\n\t  if (sindex == assignoff && string[sindex+1] == '~')\t \n\t    internal_tilde = 1;\n\n\t  if (word->flags & W_ASSIGNARG)\n\t    word->flags |= W_ASSIGNRHS;\t\t \n\n\t  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t    {\n\t      has_quoted_ifs++;\n\t      goto add_ifs_character;\n\t    }\n\t  else\n\t    goto add_character;\n\n\tcase ':':\n\t  if (word->flags & (W_NOTILDE|W_NOASSNTILDE))\n\t    {\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\n\t  if ((word->flags & (W_ASSIGNMENT|W_ASSIGNRHS)) &&\n\t      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&\n\t      string[sindex+1] == '~')\n\t    internal_tilde = 1;\n\n\t  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t    goto add_ifs_character;\n\t  else\n\t    goto add_character;\n\n\tcase '~':\n\t   \n\n\t  if ((word->flags & W_NOTILDE) ||\n\t      (sindex > 0 && (internal_tilde == 0)) ||\n\t      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    {\n\t      internal_tilde = 0;\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\n\t  if (word->flags & W_ASSIGNRHS)\n\t    tflag = 2;\n\t  else if (word->flags & (W_ASSIGNMENT|W_TILDEEXP))\n\t    tflag = 1;\n\t  else\n\t    tflag = 0;\n\n\t  temp = bash_tilde_find_word (string + sindex, tflag, &t_index);\n\t    \n\t  internal_tilde = 0;\n\n\t  if (temp && *temp && t_index > 0)\n\t    {\n\t      temp1 = bash_tilde_expand (temp, tflag);\n\t      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))\n\t\t{\n\t\t  FREE (temp);\n\t\t  FREE (temp1);\n\t\t  goto add_character;\t\t \n\t\t}\n\t      free (temp);\n\t      temp = temp1;\n\t      sindex += t_index;\n\t      goto add_quoted_string;\t\t \n\t    }\n\t  else\n\t    {\n\t      FREE (temp);\n\t      goto add_character;\n\t    }\n\t\n\tcase '$':\n\t  if (expanded_something)\n\t    *expanded_something = 1;\n\t  local_expanded = 1;\n\n\t  temp_has_dollar_at = 0;\n\t  pflags = (word->flags & W_NOCOMSUB) ? PF_NOCOMSUB : 0;\n\t  if (word->flags & W_NOSPLIT2)\n\t    pflags |= PF_NOSPLIT2;\n\t  if (word->flags & W_ASSIGNRHS)\n\t    pflags |= PF_ASSIGNRHS;\n\t  if (word->flags & W_COMPLETE)\n\t    pflags |= PF_COMPLETE;\n\n\t  tword = param_expand (string, &sindex, quoted, expanded_something,\n\t\t\t       &temp_has_dollar_at, &quoted_dollar_at,\n\t\t\t       &had_quoted_null, pflags);\n\t  has_dollar_at += temp_has_dollar_at;\n\t  split_on_spaces += (tword->flags & W_SPLITSPACE);\n\n\t  if (tword == &expand_wdesc_error || tword == &expand_wdesc_fatal)\n\t    {\n\t      free (string);\n\t      free (istring);\n\t      return ((tword == &expand_wdesc_error) ? &expand_word_error\n\t\t\t\t\t\t     : &expand_word_fatal);\n\t    }\n\t  if (contains_dollar_at && has_dollar_at)\n\t    *contains_dollar_at = 1;\n\n\t  if (tword && (tword->flags & W_HASQUOTEDNULL))\n\t    had_quoted_null = 1;\t\t \n\t  if (tword && (tword->flags & W_SAWQUOTEDNULL))\n\t    had_quoted_null = 1;\t\t \n\n\t  temp = tword ? tword->word : (char *)NULL;\n\t  dispose_word_desc (tword);\n\n\t   \n\t  if (had_quoted_null && temp && QUOTED_NULL (temp))\n\t    {\n\t      FREE (temp);\n\t      temp = (char *)NULL;\n\t    }\n\n\t  goto add_string;\n\t  break;\n\n\tcase '`':\t\t \n\t  {\n\t    t_index = sindex++;\n\n\t    temp = string_extract (string, &sindex, \"`\", (word->flags & W_COMPLETE) ? SX_COMPLETE : SX_REQMATCH);\n\t     \n\t    if (temp == &extract_string_error || temp == &extract_string_fatal)\n\t      {\n\t\tif (sindex - 1 == t_index)\n\t\t  {\n\t\t    sindex = t_index;\n\t\t    goto add_character;\n\t\t  }\n\t\tset_exit_status (EXECUTION_FAILURE);\n\t\treport_error (_(\"bad substitution: no closing \\\"`\\\" in %s\") , string+t_index);\n\t\tfree (string);\n\t\tfree (istring);\n\t\treturn ((temp == &extract_string_error) ? &expand_word_error\n\t\t\t\t\t\t\t: &expand_word_fatal);\n\t      }\n\t\t\n\t    if (expanded_something)\n\t      *expanded_something = 1;\n\t    local_expanded = 1;\n\n\t    if (word->flags & W_NOCOMSUB)\n\t       \n\t      temp1 = substring (string, t_index, sindex + 1);\n\t    else\n\t      {\n\t\tde_backslash (temp);\n\t\ttword = command_substitute (temp, quoted, PF_BACKQUOTE);\n\t\ttemp1 = tword ? tword->word : (char *)NULL;\n\t\tif (tword)\n\t\t  dispose_word_desc (tword);\n\t      }\n\t    FREE (temp);\n\t    temp = temp1;\n\t    goto dollar_add_string;\n\t  }\n\n\tcase '\\\\':\n\t  if (string[sindex + 1] == '\\n')\n\t    {\n\t      sindex += 2;\n\t      continue;\n\t    }\n\n\t  c = string[++sindex];\n\n\t   \n\t  if ((quoted & Q_HERE_DOCUMENT) && (quoted & Q_DOLBRACE) && c == '\"')\n\t    tflag = CBSDQUOTE;\t\t \n\t  else if (quoted & Q_HERE_DOCUMENT)\n\t    tflag = CBSHDOC;\n\t  else if (quoted & Q_DOUBLE_QUOTES)\n\t    tflag = CBSDQUOTE;\n\t  else\n\t    tflag = 0;\n\n\t   \n\t  if ((quoted & Q_DOLBRACE) && c == RBRACE)\n\t    {\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\t   \n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0) && isexp == 0 && isifs (c))\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t      DEFAULT_ARRAY_SIZE);\n\t      istring[istring_index++] = CTLESC;\n\t      istring[istring_index++] = '\\\\';\n\t      istring[istring_index] = '\\0';\n\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && c == 0)\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t      DEFAULT_ARRAY_SIZE);\n\t      istring[istring_index++] = CTLESC;\n\t      istring[istring_index++] = '\\\\';\n\t      istring[istring_index] = '\\0';\n\t      break;\t      \n\t    }\n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))\n\t    {\n\t      SCOPY_CHAR_I (twochars, '\\\\', c, string, sindex, string_size);\n\t    }\n\t  else if (c == 0)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\t\t \n\t      goto add_character;\n\t    }\n\t  else\n\t    {\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\n\t  sindex++;\nadd_twochars:\n\t   \n\t  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t  DEFAULT_ARRAY_SIZE);\n\t  istring[istring_index++] = twochars[0];\n\t  istring[istring_index++] = twochars[1];\n\t  istring[istring_index] = '\\0';\n\n\t  break;\n\n\tcase '\"':\n\t   \n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) && ((quoted & Q_ARITH) == 0))\n\t    goto add_character;\n\n\t  t_index = ++sindex;\n\t  temp = string_extract_double_quoted (string, &sindex, (word->flags & W_COMPLETE) ? SX_COMPLETE : 0);\n\n\t   \n\t  quoted_state = (t_index == 1 && string[sindex] == '\\0')\n\t\t\t    ? WHOLLY_QUOTED\n\t\t\t    : PARTIALLY_QUOTED;\n\n\t  if (temp && *temp)\n\t    {\n\t      tword = alloc_word_desc ();\n\t      tword->word = temp;\n\n\t      if (word->flags & W_ASSIGNARG)\n\t\ttword->flags |= word->flags & (W_ASSIGNARG|W_ASSIGNRHS);  \n\t      if (word->flags & W_COMPLETE)\n\t\ttword->flags |= W_COMPLETE;\t \n\t      if (word->flags & W_NOCOMSUB)\n\t\ttword->flags |= W_NOCOMSUB;\n\t      if (word->flags & W_NOPROCSUB)\n\t\ttword->flags |= W_NOPROCSUB;\n\n\t      if (word->flags & W_ASSIGNRHS)\n\t\ttword->flags |= W_ASSIGNRHS;\n\n\t      temp = (char *)NULL;\n\n\t      temp_has_dollar_at = 0;\t \n\t       \n\t       \n\t      list = expand_word_internal (tword, Q_DOUBLE_QUOTES|(quoted&Q_ARITH), 0, &temp_has_dollar_at, (int *)NULL);\n\t      has_dollar_at += temp_has_dollar_at;\n\n\t      if (list == &expand_word_error || list == &expand_word_fatal)\n\t\t{\n\t\t  free (istring);\n\t\t  free (string);\n\t\t   \n\t\t  tword->word = (char *)NULL;\n\t\t  dispose_word (tword);\n\t\t  return list;\n\t\t}\n\n\t      dispose_word (tword);\n\n\t       \n\t      if (list == 0 && temp_has_dollar_at)\t \n\t\t{\n\t\t  quoted_dollar_at++;\n\t\t  break;\n\t\t}\n\n\t       \n\t      if (list && list->word && list->next == 0 && (list->word->flags & W_HASQUOTEDNULL))\n\t\t{\n\t\t  if (had_quoted_null && temp_has_dollar_at)\n\t\t    quoted_dollar_at++;\n\t\t  had_quoted_null = 1;\t\t \n\t\t}\n\n\t       \n\t      if (list)\n\t\tdequote_list (list);\n\n\t      if (temp_has_dollar_at)\t\t \n\t\t{\n\t\t  quoted_dollar_at++;\n\t\t  if (contains_dollar_at)\n\t\t    *contains_dollar_at = 1;\n\t\t  if (expanded_something)\n\t\t    *expanded_something = 1;\n\t\t  local_expanded = 1;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t       \n\t      FREE (temp);\n\t      list = (WORD_LIST *)NULL;\n\t      had_quoted_null = 1;\t \n\t    }\n\n\t   \n\t  if (list)\n\t    {\n\t      if (list->next)\n\t\t{\n\t\t   \n\t\t  temp = quoted_dollar_at\n\t\t\t\t? string_list_dollar_at (list, Q_DOUBLE_QUOTES, 0)\n\t\t\t\t: string_list (quote_list (list));\n\t\t  dispose_words (list);\n\t\t  goto add_string;\n\t\t}\n\t      else\n\t\t{\n\t\t  temp = savestring (list->word->word);\n\t\t  tflag = list->word->flags;\n\t\t  dispose_words (list);\n\n\t\t   \n\t\t   \n\t\t  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)\n\t\t    remove_quoted_nulls (temp);\t \n\t\t}\n\t    }\n\t  else\n\t    temp = (char *)NULL;\n\n\t  if (temp == 0 && quoted_state == PARTIALLY_QUOTED)\n\t    had_quoted_null = 1;\t \n\n\t   \n\t  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && quoted == 0 && (word->flags & (W_NOSPLIT|W_EXPANDRHS|W_ASSIGNRHS)) == W_EXPANDRHS)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\n\t      had_quoted_null = 1;\n\t      goto add_character;\n\t    }\n\t  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))\n\t    continue;\n\n\tadd_quoted_string:\n\n\t  if (temp)\n\t    {\n\t      temp1 = temp;\n\t      temp = quote_string (temp);\n\t      free (temp1);\n\t      goto add_string;\n\t    }\n\t  else\n\t    {\n\t       \n\t      c = CTLNUL;\n\t      sindex--;\t\t \n\t      had_quoted_null = 1;\t \n\t      goto add_character;\n\t    }\n\n\t   \n\n\tcase '\\'':\n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    goto add_character;\n\n\t  t_index = ++sindex;\n\t  temp = string_extract_single_quoted (string, &sindex, 0);\n\n\t   \n\t  quoted_state = (t_index == 1 && string[sindex] == '\\0')\n\t\t\t    ? WHOLLY_QUOTED\n\t\t\t    : PARTIALLY_QUOTED;\n\n\t   \n\t  if (*temp == '\\0')\n\t    {\n\t      free (temp);\n\t      temp = (char *)NULL;\n\t    }\n\t  else\n\t    remove_quoted_escapes (temp);\t \n\n\t  if (temp == 0 && quoted_state == PARTIALLY_QUOTED)\n\t    had_quoted_null = 1;\t \n\n\t   \n\t  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && quoted == 0 && (word->flags & (W_NOSPLIT|W_EXPANDRHS|W_ASSIGNRHS)) == W_EXPANDRHS)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\n\t      goto add_character;\n\t    }\n\n\t  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED) && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))\n\t    continue;\n\n\t   \n\t  if (temp == 0)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\t\t \n\t      goto add_character;\n\t    }\n\t  else\n\t    goto add_quoted_string;\n\n\t   \n\n\tcase ' ':\n\t   \n\t  if (ifs_is_null || split_on_spaces || ((word->flags & (W_NOSPLIT|W_NOSPLIT2|W_ASSIGNRHS)) && (word->flags & W_EXPANDRHS) == 0))\n\t    {\n\t      if (string[sindex])\n\t\tsindex++;\n\t      twochars[0] = CTLESC;\n\t      twochars[1] = c;\n\t      goto add_twochars;\n\t    }\n\t   \n\t  \n\tdefault:\n\t   \nadd_ifs_character:\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c) && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0))\n\t    {\n\t      if ((quoted&(Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0)\n\t\thas_quoted_ifs++;\nadd_quoted_character:\n\t      if (string[sindex])\t \n\t\tsindex++;\n\t      if (c == 0)\n\t\t{\n\t\t  c = CTLNUL;\n\t\t  goto add_character;\n\t\t}\n\t      else\n\t\t{\n#if HANDLE_MULTIBYTE\n\t\t   \n\t\t  if (mb_cur_max > 1)\n\t\t    sindex--;\n\n\t\t  if (mb_cur_max > 1)\n\t\t    {\n\t\t      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);\n\t\t    }\n\t\t  else\n#endif\n\t\t    {\n\t\t      twochars[0] = CTLESC;\n\t\t      twochars[1] = c;\n\t\t      goto add_twochars;\n\t\t    }\n\t\t}\n\t    }\n\n\t  SADD_MBCHAR (temp, string, sindex, string_size);\n\nadd_character:\n\t  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,\n\t\t\t\t  DEFAULT_ARRAY_SIZE);\n\t  istring[istring_index++] = c;\n\t  istring[istring_index] = '\\0';\n\n\t   \n\t  sindex++;\n\t}\n    }\n\nfinished_with_string:\n   \n\n   \n\n   \n\n   \n\n  if (*istring == '\\0')\n    {\n#if 0\n      if (quoted_dollar_at == 0 && (had_quoted_null || quoted_state == PARTIALLY_QUOTED))\n#else\n      if (had_quoted_null || (quoted_dollar_at == 0 && quoted_state == PARTIALLY_QUOTED))\n#endif\n\t{\n\t  istring[0] = CTLNUL;\n\t  istring[1] = '\\0';\n\t  tword = alloc_word_desc ();\n\t  tword->word = istring;\n\t  istring = 0;\t\t \n\t  tword->flags |= W_HASQUOTEDNULL;\t\t \n\t  list = make_word_list (tword, (WORD_LIST *)NULL);\n\t  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t    tword->flags |= W_QUOTED;\n\t}\n       \n       \n      else  if (quoted_state == UNQUOTED || quoted_dollar_at)\n\tlist = (WORD_LIST *)NULL;\n      else\n\tlist = (WORD_LIST *)NULL;\n    }\n  else if (word->flags & W_NOSPLIT)\n    {\n      tword = alloc_word_desc ();\n      tword->word = istring;\n      if (had_quoted_null && QUOTED_NULL (istring))\n\ttword->flags |= W_HASQUOTEDNULL;\n      istring = 0;\t\t \n      if (word->flags & W_ASSIGNMENT)\n\ttword->flags |= W_ASSIGNMENT;\t \n      if (word->flags & W_COMPASSIGN)\n\ttword->flags |= W_COMPASSIGN;\t \n      if (word->flags & W_NOGLOB)\n\ttword->flags |= W_NOGLOB;\t \n      if (word->flags & W_NOBRACE)\n\ttword->flags |= W_NOBRACE;\t \n      if (word->flags & W_ARRAYREF)\n\ttword->flags |= W_ARRAYREF;\n      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\ttword->flags |= W_QUOTED;\n      list = make_word_list (tword, (WORD_LIST *)NULL);\n    }\n  else if (word->flags & W_ASSIGNRHS)\n    {\n      list = list_string (istring, \"\", quoted);\n      tword = list->word;\n      if (had_quoted_null && QUOTED_NULL (istring))\n\ttword->flags |= W_HASQUOTEDNULL;\n      free (list);\n      free (istring);\n      istring = 0;\t\t\t \n      goto set_word_flags;\n    }\n  else\n    {\n      char *ifs_chars;\n\n      ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;\n\n       \n      if (split_on_spaces)\n\t{\n\t   \n\t  if (ifs_is_set == 0)\n\t    list = list_string (istring, \" \\t\\n\", 1);\t \n\t  else\n\t    list = list_string (istring, \" \", 1);\t \n\t}\n\n       \n      else if (has_dollar_at && quoted_dollar_at == 0 && ifs_chars && quoted == 0 && (word->flags & W_NOSPLIT2))\n\t{\n\t  tword = alloc_word_desc ();\n\t   \n\t  if (*ifs_chars && *ifs_chars != ' ')\n\t    {\n\t       \n\t      list = list_string (istring, *ifs_chars ? ifs_chars : \" \", 1);\n\t       \n\t      tword->word = string_list (list);\t\n\t    }\n\t  else\n\t    tword->word = istring;\n\t  if (had_quoted_null && QUOTED_NULL (istring))\n\t    tword->flags |= W_HASQUOTEDNULL;\t \n\t  if (tword->word != istring)\n\t    free (istring);\n\t  istring = 0;\t\t\t \n\t  goto set_word_flags;\n\t}\n      else if (has_dollar_at && ifs_chars)\n\tlist = list_string (istring, *ifs_chars ? ifs_chars : \" \", 1);\n      else\n\t{\n\t  tword = alloc_word_desc ();\n\t  if (expanded_something && *expanded_something == 0 && has_quoted_ifs)\n\t    tword->word = remove_quoted_ifs (istring);\n\t  else\n\t    tword->word = istring;\n\t  if (had_quoted_null && QUOTED_NULL (istring))\t \n\t    tword->flags |= W_HASQUOTEDNULL;\t \n\t  else if (had_quoted_null)\n\t    tword->flags |= W_SAWQUOTEDNULL;\t \n\t  if (tword->word != istring)\n\t    free (istring);\n\t  istring = 0;\t\t\t \nset_word_flags:\n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))\n\t    tword->flags |= W_QUOTED;\n\t  if (word->flags & W_ASSIGNMENT)\n\t    tword->flags |= W_ASSIGNMENT;\n\t  if (word->flags & W_COMPASSIGN)\n\t    tword->flags |= W_COMPASSIGN;\n\t  if (word->flags & W_NOGLOB)\n\t    tword->flags |= W_NOGLOB;\n\t  if (word->flags & W_NOBRACE)\n\t    tword->flags |= W_NOBRACE;\n\t  if (word->flags & W_ARRAYREF)\n\t    tword->flags |= W_ARRAYREF;\n\t  list = make_word_list (tword, (WORD_LIST *)NULL);\n\t}\n    }\n\n  free (istring);\n  return (list);\n}\n\n \n \n \n \n \n\n \nchar *\nstring_quote_removal (string, quoted)\n     char *string;\n     int quoted;\n{\n  size_t slen;\n  char *r, *result_string, *temp, *send;\n  int sindex, tindex, dquote;\n  unsigned char c;\n  DECLARE_MBSTATE;\n\n   \n  slen = strlen (string);\n  send = string + slen;\n\n  r = result_string = (char *)xmalloc (slen + 1);\n\n  for (dquote = sindex = 0; c = string[sindex];)\n    {\n      switch (c)\n\t{\n\tcase '\\\\':\n\t  c = string[++sindex];\n\t  if (c == 0)\n\t    {\n\t      *r++ = '\\\\';\n\t      break;\n\t    }\n\t  if (((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote) && (sh_syntaxtab[c] & CBSDQUOTE) == 0)\n\t    *r++ = '\\\\';\n\t   \n\n\tdefault:\n\t  SCOPY_CHAR_M (r, string, send, sindex);\n\t  break;\n\n\tcase '\\'':\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || dquote)\n\t    {\n\t      *r++ = c;\n\t      sindex++;\n\t      break;\n\t    }\n\t  tindex = sindex + 1;\n\t  temp = string_extract_single_quoted (string, &tindex, 0);\n\t  if (temp)\n\t    {\n\t      strcpy (r, temp);\n\t      r += strlen (r);\n\t      free (temp);\n\t    }\n\t  sindex = tindex;\n\t  break;\n\n\tcase '\"':\n\t  dquote = 1 - dquote;\n\t  sindex++;\n\t  break;\n\t}\n    }\n    *r = '\\0';\n    return (result_string);\n}\n\n#if 0\n \n \nWORD_DESC *\nword_quote_removal (word, quoted)\n     WORD_DESC *word;\n     int quoted;\n{\n  WORD_DESC *w;\n  char *t;\n\n  t = string_quote_removal (word->word, quoted);\n  w = alloc_word_desc ();\n  w->word = t ? t : savestring (\"\");\n  return (w);\n}\n\n \nWORD_LIST *\nword_list_quote_removal (list, quoted)\n     WORD_LIST *list;\n     int quoted;\n{\n  WORD_LIST *result, *t, *tresult, *e;\n\n  for (t = list, result = (WORD_LIST *)NULL; t; t = t->next)\n    {\n      tresult = make_word_list (word_quote_removal (t->word, quoted), (WORD_LIST *)NULL);\n#if 0\n      result = (WORD_LIST *) list_append (result, tresult);\n#else\n      if (result == 0)\n\tresult = e = tresult;\n      else\n\t{\n\t  e->next = tresult;\n\t  while (e->next)\n\t    e = e->next;\n\t}\n#endif\n    }\n  return (result);\n}\n#endif\n\n \n\nvoid\nsetifs (v)\n     SHELL_VAR *v;\n{\n  char *t;\n  unsigned char uc;\n\n  ifs_var = v;\n  ifs_value = (v && value_cell (v)) ? value_cell (v) : \" \\t\\n\";\n\n  ifs_is_set = ifs_var != 0;\n  ifs_is_null = ifs_is_set && (*ifs_value == 0);\n\n   \n  memset (ifs_cmap, '\\0', sizeof (ifs_cmap));\n  for (t = ifs_value ; t && *t; t++)\n    {\n      uc = *t;\n      ifs_cmap[uc] = 1;\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  if (ifs_value == 0)\n    {\n      ifs_firstc[0] = '\\0';\t \n      ifs_firstc_len = 1;\n    }\n  else\n    {\n      if (locale_utf8locale && UTF8_SINGLEBYTE (*ifs_value))\n\tifs_firstc_len = (*ifs_value != 0) ? 1 : 0;\n      else\n\t{\n\t  size_t ifs_len;\n\t  ifs_len = strnlen (ifs_value, MB_CUR_MAX);\n\t  ifs_firstc_len = MBLEN (ifs_value, ifs_len);\n\t}\n      if (ifs_firstc_len == 1 || ifs_firstc_len == 0 || MB_INVALIDCH (ifs_firstc_len))\n\t{\n\t  ifs_firstc[0] = ifs_value[0];\n\t  ifs_firstc[1] = '\\0';\n\t  ifs_firstc_len = 1;\n\t}\n      else\n\tmemcpy (ifs_firstc, ifs_value, ifs_firstc_len);\n    }\n#else\n  ifs_firstc = ifs_value ? *ifs_value : 0;\n#endif\n}\n\nchar *\ngetifs ()\n{\n  return ifs_value;\n}\n\n \nWORD_LIST *\nword_split (w, ifs_chars)\n     WORD_DESC *w;\n     char *ifs_chars;\n{\n  WORD_LIST *result;\n\n  if (w)\n    {\n      char *xifs;\n\n      xifs = ((w->flags & W_QUOTED) || ifs_chars == 0) ? \"\" : ifs_chars;\n      result = list_string (w->word, xifs, w->flags & W_QUOTED);\n    }\n  else\n    result = (WORD_LIST *)NULL;\n\n  return (result);\n}\n\n \nstatic WORD_LIST *\nword_list_split (list)\n     WORD_LIST *list;\n{\n  WORD_LIST *result, *t, *tresult, *e;\n  WORD_DESC *w;\n\n  for (t = list, result = (WORD_LIST *)NULL; t; t = t->next)\n    {\n      tresult = word_split (t->word, ifs_value);\n       \n      if (tresult == 0 && t->word && (t->word->flags & W_SAWQUOTEDNULL))\t \n\t{\n\t  w = alloc_word_desc ();\n\t  w->word = (char *)xmalloc (1);\n\t  w->word[0] = '\\0';\n\t  tresult = make_word_list (w, (WORD_LIST *)NULL);\n\t}\n#if defined (ARRAY_VARS)\n       \n      if (tresult && tresult->next == 0 && t->next == 0 && (t->word->flags & W_ARRAYREF) && STREQ (t->word->word, tresult->word->word))\n\ttresult->word->flags |= W_ARRAYREF;\n#endif\n      if (result == 0)\n        result = e = tresult;\n      else\n\t{\n\t  e->next = tresult;\n\t  while (e->next)\n\t    e = e->next;\n\t}\n    }\n  return (result);\n}\n\n \n\n \nstatic void\nexp_jump_to_top_level (v)\n     int v;\n{\n  set_pipestatus_from_exit (last_command_exit_value);\n\n   \n  expand_no_split_dollar_star = 0;\t \n  if (expanding_redir)\n    undo_partial_redirects ();\n  expanding_redir = 0;\n  assigning_in_environment = 0;\n\n  if (parse_and_execute_level == 0)\n    top_level_cleanup ();\t\t\t \n\n  jump_to_top_level (v);\n}\n\n \n#define PREPEND_LIST(nlist, elist) \\\n\tdo { nlist->next = elist; elist = nlist; } while (0)\n\n \nstatic WORD_LIST *\nseparate_out_assignments (tlist)\n     WORD_LIST *tlist;\n{\n  register WORD_LIST *vp, *lp;\n\n  if (tlist == 0)\n    return ((WORD_LIST *)NULL);\n\n  if (subst_assign_varlist)\n    dispose_words (subst_assign_varlist);\t \n\n  subst_assign_varlist = (WORD_LIST *)NULL;\n  vp = lp = tlist;\n\n   \n  while (lp && (lp->word->flags & W_ASSIGNMENT))\n    {\n      vp = lp;\n      lp = lp->next;\n    }\n\n   \n  if (lp != tlist)\n    {\n      subst_assign_varlist = tlist;\n       \n      vp->next = (WORD_LIST *)NULL;\t \n      tlist = lp;\t\t\t \n    }\n\n   \n   \n  if (!tlist)\n     \n    return ((WORD_LIST *)NULL);\n\n   \n   \n\n   \n  if (place_keywords_in_env)\n    {\n      WORD_LIST *tp;\t \n\n      tp = tlist;\n      lp = tlist->next;\n\n       \n       \n      while (lp)\n\t{\n\t  if (lp->word->flags & W_ASSIGNMENT)\n\t    {\n\t       \n\t      if (!subst_assign_varlist)\n\t\tsubst_assign_varlist = vp = lp;\n\t      else\n\t\t{\n\t\t  vp->next = lp;\n\t\t  vp = lp;\n\t\t}\n\n\t       \n\t      tp->next = lp->next;\n\t       \n\t      lp->next = (WORD_LIST *)NULL;\n\t      lp = tp->next;\n\t    }\n\t  else\n\t    {\n\t      tp = lp;\n\t      lp = lp->next;\n\t    }\n\t}\n    }\n  return (tlist);\n}\n\n#define WEXP_VARASSIGN\t0x001\n#define WEXP_BRACEEXP\t0x002\n#define WEXP_TILDEEXP\t0x004\n#define WEXP_PARAMEXP\t0x008\n#define WEXP_PATHEXP\t0x010\n\n \n#define WEXP_ALL\t(WEXP_VARASSIGN|WEXP_BRACEEXP|WEXP_TILDEEXP|WEXP_PARAMEXP|WEXP_PATHEXP)\n\n \n#define WEXP_NOVARS\t(WEXP_BRACEEXP|WEXP_TILDEEXP|WEXP_PARAMEXP|WEXP_PATHEXP)\n\n \n#define WEXP_SHELLEXP\t(WEXP_BRACEEXP|WEXP_TILDEEXP|WEXP_PARAMEXP)\n\n \n\nWORD_LIST *\nexpand_words (list)\n     WORD_LIST *list;\n{\n  return (expand_word_list_internal (list, WEXP_ALL));\n}\n\n \nWORD_LIST *\nexpand_words_no_vars (list)\n     WORD_LIST *list;\n{\n  return (expand_word_list_internal (list, WEXP_NOVARS));\n}\n\nWORD_LIST *\nexpand_words_shellexp (list)\n     WORD_LIST *list;\n{\n  return (expand_word_list_internal (list, WEXP_SHELLEXP));\n}\n\nstatic WORD_LIST *\nglob_expand_word_list (tlist, eflags)\n     WORD_LIST *tlist;\n     int eflags;\n{\n  char **glob_array, *temp_string;\n  register int glob_index;\n  WORD_LIST *glob_list, *output_list, *disposables, *next;\n  WORD_DESC *tword;\n  int x;\n\n  output_list = disposables = (WORD_LIST *)NULL;\n  glob_array = (char **)NULL;\n  while (tlist)\n    {\n       \n      next = tlist->next;\n\n       \n      if ((tlist->word->flags & W_NOGLOB) == 0 &&\n\t  unquoted_glob_pattern_p (tlist->word->word))\n\t{\n\t  glob_array = shell_glob_filename (tlist->word->word, QGLOB_CTLESC);\t \n\n\t   \n\n\t  if (glob_array == 0 || GLOB_FAILED (glob_array))\n\t    {\n\t      glob_array = (char **)xmalloc (sizeof (char *));\n\t      glob_array[0] = (char *)NULL;\n\t    }\n\n\t   \n\t  if (glob_array[0] == NULL)\n\t    {\n\t      temp_string = dequote_string (tlist->word->word);\n\t      free (tlist->word->word);\n\t      tlist->word->word = temp_string;\n\t    }\n\n\t   \n\t  glob_list = (WORD_LIST *)NULL;\n\t  for (glob_index = 0; glob_array[glob_index]; glob_index++)\n\t    {\n\t      tword = make_bare_word (glob_array[glob_index]);\n\t      glob_list = make_word_list (tword, glob_list);\n\t    }\n\n\t  if (glob_list)\n\t    {\n\t      output_list = (WORD_LIST *)list_append (glob_list, output_list);\n\t      PREPEND_LIST (tlist, disposables);\n\t    }\n\t  else if (fail_glob_expansion != 0)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      report_error (_(\"no match: %s\"), tlist->word->word);\n\t      exp_jump_to_top_level (DISCARD);\n\t    }\n\t  else if (allow_null_glob_expansion == 0)\n\t    {\n\t       \n\t      PREPEND_LIST (tlist, output_list);\n\t    }\n\t  else\n\t    {\n\t       \n\t      PREPEND_LIST (tlist, disposables);\n\t    }\n\t}\n      else\n\t{\n\t   \n\t  temp_string = dequote_string (tlist->word->word);\n\t  free (tlist->word->word);\n\t  tlist->word->word = temp_string;\n\t  PREPEND_LIST (tlist, output_list);\n\t}\n\n      strvec_dispose (glob_array);\n      glob_array = (char **)NULL;\n\n      tlist = next;\n    }\n\n  if (disposables)\n    dispose_words (disposables);\n\n  if (output_list)\n    output_list = REVERSE_LIST (output_list, WORD_LIST *);\n\n  return (output_list);\n}\n\n#if defined (BRACE_EXPANSION)\nstatic WORD_LIST *\nbrace_expand_word_list (tlist, eflags)\n     WORD_LIST *tlist;\n     int eflags;\n{\n  register char **expansions;\n  char *temp_string;\n  WORD_LIST *disposables, *output_list, *next;\n  WORD_DESC *w;\n  int eindex;\n\n  for (disposables = output_list = (WORD_LIST *)NULL; tlist; tlist = next)\n    {\n      next = tlist->next;\n\n      if (tlist->word->flags & W_NOBRACE)\n        {\n \n\t  PREPEND_LIST (tlist, output_list);\n\t  continue;\n        }\n\n      if ((tlist->word->flags & (W_COMPASSIGN|W_ASSIGNARG)) == (W_COMPASSIGN|W_ASSIGNARG))\n        {\n \n\t  PREPEND_LIST (tlist, output_list);\n\t  continue;\n        }\n\n       \n      if (mbschr (tlist->word->word, LBRACE))\n\t{\n\t  expansions = brace_expand (tlist->word->word);\n\n\t  for (eindex = 0; temp_string = expansions[eindex]; eindex++)\n\t    {\n\t      w = alloc_word_desc ();\n\t      w->word = temp_string;\n\n\t       \n\t      if (STREQ (temp_string, tlist->word->word))\n\t\tw->flags = tlist->word->flags;\n\t      else\n\t\tw = make_word_flags (w, temp_string);\n\n\t      output_list = make_word_list (w, output_list);\n\t    }\n\t  free (expansions);\n\n\t   \n\t  PREPEND_LIST (tlist, disposables);\n\t}\n      else\n\tPREPEND_LIST (tlist, output_list);\n    }\n\n  if (disposables)\n    dispose_words (disposables);\n\n  if (output_list)\n    output_list = REVERSE_LIST (output_list, WORD_LIST *);\n\n  return (output_list);\n}\n#endif\n\n#if defined (ARRAY_VARS)\n \nstatic int\nmake_internal_declare (word, option, cmd)\n     char *word;\n     char *option;\n     char *cmd;\n{\n  int t, r;\n  WORD_LIST *wl;\n  WORD_DESC *w;\n\n  w = make_word (word);\n\n  t = assignment (w->word, 0);\n  if (w->word[t] == '=')\n    {\n      w->word[t] = '\\0';\n      if (w->word[t - 1] == '+')\t \n\tw->word[t - 1] = '\\0';\n    }\n\n  wl = make_word_list (w, (WORD_LIST *)NULL);\n  wl = make_word_list (make_word (option), wl);\n\n  r = declare_builtin (wl);\n\n  dispose_words (wl);\n  return r;\n}  \n\n \n\nstatic WORD_LIST *\nexpand_oneword (value, flags)\n     char *value;\n     int flags;\n{\n  WORD_LIST *l, *nl;\n  char *t;\n  int kvpair;\n  \n  if (flags == 0)\n    {\n       \n      l = expand_compound_array_assignment ((SHELL_VAR *)NULL, value, flags);\n       \n      quote_compound_array_list (l, flags);\n      return l;\n    }\n  else\n    {\n       \n      l = parse_string_to_word_list (value, 1, \"array assign\");\n#if ASSOC_KVPAIR_ASSIGNMENT\n      kvpair = kvpair_assignment_p (l);\n#endif\n\n       \n      for (nl = l; nl; nl = nl->next)\n\t{\n#if ASSOC_KVPAIR_ASSIGNMENT\n\t  if (kvpair)\n\t     \n\t    t = expand_and_quote_kvpair_word (nl->word->word);\n\t  else\n#endif\n\t  if ((nl->word->flags & W_ASSIGNMENT) == 0)\n\t    t = sh_single_quote (nl->word->word ? nl->word->word : \"\");\n\t  else\n\t    t = expand_and_quote_assoc_word (nl->word->word, flags);\n\t  free (nl->word->word);\n\t  nl->word->word = t;\n\t}\n      return l;\n    }\n}\n\n \nstatic void\nexpand_compound_assignment_word (tlist, flags)\n     WORD_LIST *tlist;\n     int flags;\n{\n  WORD_LIST *l;\n  int wlen, oind, t;\n  char *value, *temp;\n\n \n  t = assignment (tlist->word->word, 0);\n\n   \n  oind = 1;\n  value = extract_array_assignment_list (tlist->word->word + t + 1, &oind);\n   \n  l = expand_oneword (value, flags);\n  free (value);\n\n  value = string_list (l);\n  dispose_words (l);\n\n  wlen = STRLEN (value);\n\n   \n  temp = xmalloc (t + 3 + wlen + 1);\t \n  memcpy (temp, tlist->word->word, ++t);\n  temp[t++] = '(';\n  if (value)\n    memcpy (temp + t, value, wlen);\n  t += wlen;\n  temp[t++] = ')';\n  temp[t] = '\\0';\n \n\n  free (tlist->word->word);\n  tlist->word->word = temp;\n\n  free (value);\n}\n\n \nstatic WORD_LIST *\nexpand_declaration_argument (tlist, wcmd)\n     WORD_LIST *tlist, *wcmd;\n{\n  char opts[16], omap[128];\n  int t, opti, oind, skip, inheriting;\n  WORD_LIST *l;\n\n  inheriting = localvar_inherit;\n  opti = 0;\n  if (tlist->word->flags & (W_ASSIGNASSOC|W_ASSNGLOBAL|W_CHKLOCAL|W_ASSIGNARRAY))\n    opts[opti++] = '-';\n\n  if ((tlist->word->flags & (W_ASSIGNASSOC|W_ASSNGLOBAL)) == (W_ASSIGNASSOC|W_ASSNGLOBAL))\n    {\n      opts[opti++] = 'g';\n      opts[opti++] = 'A';\n    }\n  else if (tlist->word->flags & W_ASSIGNASSOC)\n    {\n      opts[opti++] = 'A';\n    }\n  else if ((tlist->word->flags & (W_ASSIGNARRAY|W_ASSNGLOBAL)) == (W_ASSIGNARRAY|W_ASSNGLOBAL))\n    {\n      opts[opti++] = 'g';\n      opts[opti++] = 'a';\n    }\n  else if (tlist->word->flags & W_ASSIGNARRAY)\n    {\n      opts[opti++] = 'a';\n    }\n  else if (tlist->word->flags & W_ASSNGLOBAL)\n    opts[opti++] = 'g';\n\n  if (tlist->word->flags & W_CHKLOCAL)\n    opts[opti++] = 'G';\n\n   \n\n  memset (omap, '\\0', sizeof (omap));\n  for (l = wcmd->next; l != tlist; l = l->next)\n    {\n      int optchar;\n\n      if (l->word->word[0] != '-' && l->word->word[0] != '+')\n\tbreak;\t \n      if (l->word->word[0] == '-' && l->word->word[1] == '-' && l->word->word[2] == 0)\n\tbreak;\t \n      optchar = l->word->word[0];\n      for (oind = 1; l->word->word[oind]; oind++)\n\tswitch (l->word->word[oind])\n\t  {\n\t    case 'I':\n\t      inheriting = 1;\n\t    case 'i':\n\t    case 'l':\n\t    case 'u':\n\t    case 'c':\n\t      omap[l->word->word[oind]] = 1;\n\t      if (opti == 0)\n\t\topts[opti++] = optchar;\n\t      break;\n\t    default:\n\t      break;\n\t  }\n    }\n\n  for (oind = 0; oind < sizeof (omap); oind++)\n    if (omap[oind])\n      opts[opti++] = oind;\n\n   \n  if ((tlist->word->flags & (W_ASSIGNASSOC|W_ASSIGNARRAY)) == 0)\n    {\n      if (opti == 0)\n\t{\n\t  opts[opti++] = '-';\n          opts[opti++] = '-';\n\t}\n    }\n  opts[opti] = '\\0';\n\n   \n  expand_compound_assignment_word (tlist, (tlist->word->flags & W_ASSIGNASSOC) ? 1 : 0);\n\n  skip = 0;\n  if (opti > 0)\n    {\n      t = make_internal_declare (tlist->word->word, opts, wcmd ? wcmd->word->word : (char *)0);\n      if (t != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = t;\n\t  if (tlist->word->flags & W_FORCELOCAL)\t \n\t    skip = 1;\n\t  else\n\t    exp_jump_to_top_level (DISCARD);\n\t}\n    }\n\n  if (skip == 0)\n    {\n      t = do_word_assignment (tlist->word, 0);\n      if (t == 0)\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n    }\n\n   \n  t = assignment (tlist->word->word, 0);\n  tlist->word->word[t] = '\\0';\n  if (tlist->word->word[t - 1] == '+')\n    tlist->word->word[t - 1] = '\\0';\t \n  tlist->word->flags &= ~(W_ASSIGNMENT|W_NOSPLIT|W_COMPASSIGN|W_ASSIGNARG|W_ASSIGNASSOC|W_ASSIGNARRAY);\n\n  return (tlist);\n}\n#endif  \n\nstatic WORD_LIST *\nshell_expand_word_list (tlist, eflags)\n     WORD_LIST *tlist;\n     int eflags;\n{\n  WORD_LIST *expanded, *orig_list, *new_list, *next, *temp_list, *wcmd;\n  int expanded_something, has_dollar_at;\n\n   \n  wcmd = new_list = (WORD_LIST *)NULL;\n\n  for (orig_list = tlist; tlist; tlist = next)\n    {\n      if (wcmd == 0 && (tlist->word->flags & W_ASSNBLTIN))\n\twcmd = tlist;\n\t\n      next = tlist->next;\n\n#if defined (ARRAY_VARS)\n       \n      if ((tlist->word->flags & (W_COMPASSIGN|W_ASSIGNARG)) == (W_COMPASSIGN|W_ASSIGNARG))\n\texpand_declaration_argument (tlist, wcmd);\n#endif\n\n      expanded_something = 0;\n      expanded = expand_word_internal\n\t(tlist->word, 0, 0, &has_dollar_at, &expanded_something);\n\n      if (expanded == &expand_word_error || expanded == &expand_word_fatal)\n\t{\n\t   \n\t  tlist->word->word = (char *)NULL;\n\n\t   \n\t  dispose_words (orig_list);\n\t   \n\t  dispose_words (new_list);\n\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  if (expanded == &expand_word_error)\n\t    exp_jump_to_top_level (DISCARD);\n\t  else\n\t    exp_jump_to_top_level (FORCE_EOF);\n\t}\n\n       \n      if (expanded_something && (tlist->word->flags & W_NOSPLIT) == 0)\n\t{\n\t  temp_list = word_list_split (expanded);\n\t  dispose_words (expanded);\n\t}\n      else\n\t{\n\t   \n\t  word_list_remove_quoted_nulls (expanded);\n\t  temp_list = expanded;\n\t}\n\n      expanded = REVERSE_LIST (temp_list, WORD_LIST *);\n      new_list = (WORD_LIST *)list_append (expanded, new_list);\n    }\n\n  if (orig_list)  \n    dispose_words (orig_list);\n\n  if (new_list)\n    new_list = REVERSE_LIST (new_list, WORD_LIST *);\n\n  return (new_list);\n}\n\n \nstatic int\ndo_assignment_statements (varlist, command, is_nullcmd)\n     WORD_LIST *varlist;\n     char *command;\n     int is_nullcmd;\n{\n  WORD_LIST *temp_list;\n  char *savecmd;\n  sh_wassign_func_t *assign_func;\n  int is_special_builtin, is_builtin_or_func, tint;\n\n   \n  assign_func = is_nullcmd ? do_word_assignment : assign_in_env;\n  tempenv_assign_error = 0;\n\n  is_builtin_or_func = command && (find_shell_builtin (command) || find_function (command));\n   \n  is_special_builtin = posixly_correct && command && find_special_builtin (command);\n\n  savecmd = this_command_name;\n  for (temp_list = varlist; temp_list; temp_list = temp_list->next)\n    {\n      this_command_name = (char *)NULL;\n      assigning_in_environment = is_nullcmd == 0;\n      tint = (*assign_func) (temp_list->word, is_builtin_or_func);\n      assigning_in_environment = 0;\n      this_command_name = savecmd;\n\n       \n      if (tint == 0)\n\t{\n\t  if (is_nullcmd)\t \n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n#if defined (STRICT_POSIX)\n\t      if (posixly_correct && interactive_shell == 0)\n#else\n\t      if (posixly_correct && interactive_shell == 0 && executing_command_builtin == 0)\n#endif\n\t        exp_jump_to_top_level (FORCE_EOF);\n\t      else\n\t\texp_jump_to_top_level (DISCARD);\n\t    }\n\t   \n\t  else if (posixly_correct)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n#if defined (STRICT_POSIX)\n\t      exp_jump_to_top_level ((interactive_shell == 0) ? FORCE_EOF : DISCARD);\n#else\n\t      if (interactive_shell == 0 && is_special_builtin)\n\t\texp_jump_to_top_level (FORCE_EOF);\n\t      else if (interactive_shell == 0)\n\t\texp_jump_to_top_level (DISCARD);\t \n\t      else\n\t\texp_jump_to_top_level (DISCARD);\n#endif\n\t    }\n\t  else\n\t    tempenv_assign_error++;\n\t}\n    }\n  return (tempenv_assign_error);\n}\n\n \nstatic WORD_LIST *\nexpand_word_list_internal (list, eflags)\n     WORD_LIST *list;\n     int eflags;\n{\n  WORD_LIST *new_list, *temp_list;\n\n  tempenv_assign_error = 0;\n  if (list == 0)\n    return ((WORD_LIST *)NULL);\n\n  garglist = new_list = copy_word_list (list);\n  if (eflags & WEXP_VARASSIGN)\n    {\n      garglist = new_list = separate_out_assignments (new_list);\n      if (new_list == 0)\n\t{\n\t  if (subst_assign_varlist)\n\t    do_assignment_statements (subst_assign_varlist, (char *)NULL, 1);\n\t    \n\t  dispose_words (subst_assign_varlist);\n\t  subst_assign_varlist = (WORD_LIST *)NULL;\n\n\t  return ((WORD_LIST *)NULL);\n\t}\n    }\n\n   \n\n#if defined (BRACE_EXPANSION)\n   \n  if ((eflags & WEXP_BRACEEXP) && brace_expansion && new_list)\n    new_list = brace_expand_word_list (new_list, eflags);\n#endif  \n\n   \n  new_list = shell_expand_word_list (new_list, eflags);\n\n   \n  if (new_list)\n    {\n      if ((eflags & WEXP_PATHEXP) && disallow_filename_globbing == 0)\n\t \n\tnew_list = glob_expand_word_list (new_list, eflags);\n      else\n\t \n\tnew_list = dequote_list (new_list);\n    }\n\n  if ((eflags & WEXP_VARASSIGN) && subst_assign_varlist)\n    {\n      do_assignment_statements (subst_assign_varlist, (new_list && new_list->word) ? new_list->word->word : (char *)NULL, new_list == 0);\n\n      dispose_words (subst_assign_varlist);\n      subst_assign_varlist = (WORD_LIST *)NULL;\n    }\n\n  return (new_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}