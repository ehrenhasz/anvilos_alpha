{
  "module_name": "uniq.c",
  "hash_id": "40d781ea95a19bc13ea2084d908b89ca17e6cc21ff076df36dff1b30271df8f7",
  "original_prompt": "Ingested from coreutils-9.4/src/uniq.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"linebuffer.h\"\n#include \"fadvise.h\"\n#include \"posixver.h\"\n#include \"stdio--.h\"\n#include \"xstrtol.h\"\n#include \"memcasecmp.h\"\n#include \"quote.h\"\n\n \n#define PROGRAM_NAME \"uniq\"\n\n#define AUTHORS \\\n  proper_name (\"Richard M. Stallman\"), \\\n  proper_name (\"David MacKenzie\")\n\n#define SWAP_LINES(A, B)\t\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      struct linebuffer *_tmp;\t\t\t\\\n      _tmp = (A);\t\t\t\t\\\n      (A) = (B);\t\t\t\t\\\n      (B) = _tmp;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n  while (0)\n\n \nstatic size_t skip_fields;\n\n \nstatic size_t skip_chars;\n\n \nstatic size_t check_chars;\n\nenum countmode\n{\n  count_occurrences,\t\t \n  count_none\t\t\t \n};\n\n \nstatic enum countmode countmode;\n\n \nstatic bool output_unique;\nstatic bool output_first_repeated;\nstatic bool output_later_repeated;\n\n \nstatic bool ignore_case;\n\nenum delimit_method\n{\n   \n  DM_NONE,\n\n   \n  DM_PREPEND,\n\n   \n  DM_SEPARATE\n};\n\nstatic char const *const delimit_method_string[] =\n{\n  \"none\", \"prepend\", \"separate\", nullptr\n};\n\nstatic enum delimit_method const delimit_method_map[] =\n{\n  DM_NONE, DM_PREPEND, DM_SEPARATE\n};\n\n \nstatic enum delimit_method delimit_groups;\n\nenum grouping_method\n{\n   \n  GM_NONE,\n\n   \n  GM_PREPEND,\n\n   \n  GM_APPEND,\n\n   \n  GM_SEPARATE,\n\n   \n  GM_BOTH\n};\n\nstatic char const *const grouping_method_string[] =\n{\n  \"prepend\", \"append\", \"separate\", \"both\", nullptr\n};\n\nstatic enum grouping_method const grouping_method_map[] =\n{\n  GM_PREPEND, GM_APPEND, GM_SEPARATE, GM_BOTH\n};\n\nstatic enum grouping_method grouping = GM_NONE;\n\nenum\n{\n  GROUP_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const longopts[] =\n{\n  {\"count\", no_argument, nullptr, 'c'},\n  {\"repeated\", no_argument, nullptr, 'd'},\n  {\"all-repeated\", optional_argument, nullptr, 'D'},\n  {\"group\", optional_argument, nullptr, GROUP_OPTION},\n  {\"ignore-case\", no_argument, nullptr, 'i'},\n  {\"unique\", no_argument, nullptr, 'u'},\n  {\"skip-fields\", required_argument, nullptr, 'f'},\n  {\"skip-chars\", required_argument, nullptr, 's'},\n  {\"check-chars\", required_argument, nullptr, 'w'},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [INPUT [OUTPUT]]\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nFilter adjacent matching lines from INPUT (or standard input),\\n\\\nwriting to OUTPUT (or standard output).\\n\\\n\\n\\\nWith no options, matching lines are merged to the first occurrence.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n     fputs (_(\"\\\n  -c, --count           prefix lines by the number of occurrences\\n\\\n  -d, --repeated        only print duplicate lines, one for each group\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -D                    print all duplicate lines\\n\\\n      --all-repeated[=METHOD]  like -D, but allow separating groups\\n\\\n                                 with an empty line;\\n\\\n                                 METHOD={none(default),prepend,separate}\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -f, --skip-fields=N   avoid comparing the first N fields\\n\\\n\"), stdout);\n     fputs (_(\"\\\n      --group[=METHOD]  show all items, separating groups with an empty line;\\n\\\n                          METHOD={separate(default),prepend,append,both}\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -i, --ignore-case     ignore differences in case when comparing\\n\\\n  -s, --skip-chars=N    avoid comparing the first N characters\\n\\\n  -u, --unique          only print unique lines\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated     line delimiter is NUL, not newline\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -w, --check-chars=N   compare no more than N characters in lines\\n\\\n\"), stdout);\n     fputs (HELP_OPTION_DESCRIPTION, stdout);\n     fputs (VERSION_OPTION_DESCRIPTION, stdout);\n     fputs (_(\"\\\n\\n\\\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\\n\\\ncharacters.  Fields are skipped before chars.\\n\\\n\"), stdout);\n     fputs (_(\"\\\n\\n\\\nNote: 'uniq' does not detect repeated lines unless they are adjacent.\\n\\\nYou may want to sort the input first, or use 'sort -u' without 'uniq'.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic bool\nstrict_posix2 (void)\n{\n  int posix_ver = posix2_version ();\n  return 200112 <= posix_ver && posix_ver < 200809;\n}\n\n/* Convert OPT to size_t, reporting an error using MSGID if OPT is\n   invalid.  Silently convert too-large values to SIZE_MAX.  */\n\nstatic size_t\nsize_opt (char const *opt, char const *msgid)\n{\n  uintmax_t size;\n\n  switch (xstrtoumax (opt, nullptr, 10, &size, \"\"))\n    {\n    case LONGINT_OK:\n    case LONGINT_OVERFLOW:\n      break;\n\n    default:\n      error (EXIT_FAILURE, 0, \"%s: %s\", opt, _(msgid));\n    }\n\n  return MIN (size, SIZE_MAX);\n}\n\n/* Given a linebuffer LINE,\n   return a pointer to the beginning of the line's field to be compared. */\n\nATTRIBUTE_PURE\nstatic char *\nfind_field (struct linebuffer const *line)\n{\n  size_t count;\n  char const *lp = line->buffer;\n  size_t size = line->length - 1;\n  size_t i = 0;\n\n  for (count = 0; count < skip_fields && i < size; count++)\n    {\n      while (i < size && field_sep (lp[i]))\n        i++;\n      while (i < size && !field_sep (lp[i]))\n        i++;\n    }\n\n  i += MIN (skip_chars, size - i);\n\n  return line->buffer + i;\n}\n\n/* Return false if two strings OLD and NEW match, true if not.\n   OLD and NEW point not to the beginnings of the lines\n   but rather to the beginnings of the fields to compare.\n   OLDLEN and NEWLEN are their lengths. */\n\nstatic bool\ndifferent (char *old, char *new, size_t oldlen, size_t newlen)\n{\n  if (check_chars < oldlen)\n    oldlen = check_chars;\n  if (check_chars < newlen)\n    newlen = check_chars;\n\n  if (ignore_case)\n    return oldlen != newlen || memcasecmp (old, new, oldlen);\n  else\n    return oldlen != newlen || memcmp (old, new, oldlen);\n}\n\n/* Output the line in linebuffer LINE to standard output\n   provided that the switches say it should be output.\n   MATCH is true if the line matches the previous line.\n   If requested, print the number of times it occurred, as well;\n   LINECOUNT + 1 is the number of times that the line occurred. */\n\nstatic void\nwriteline (struct linebuffer const *line,\n           bool match, uintmax_t linecount)\n{\n  if (! (linecount == 0 ? output_unique\n         : !match ? output_first_repeated\n         : output_later_repeated))\n    return;\n\n  if (countmode == count_occurrences)\n    printf (\"%7\" PRIuMAX \" \", linecount + 1);\n\n  if (fwrite (line->buffer, sizeof (char), line->length, stdout)\n      != line->length)\n    write_error ();\n}\n\n/* Process input file INFILE with output to OUTFILE.\n   If either is \"-\", use the standard I/O stream for it instead. */\n\nstatic void\ncheck_file (char const *infile, char const *outfile, char delimiter)\n{\n  struct linebuffer lb1, lb2;\n  struct linebuffer *thisline, *prevline;\n\n  if (! (STREQ (infile, \"-\") || freopen (infile, \"r\", stdin)))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n  if (! (STREQ (outfile, \"-\") || freopen (outfile, \"w\", stdout)))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (outfile));\n\n  fadvise (stdin, FADVISE_SEQUENTIAL);\n\n  thisline = &lb1;\n  prevline = &lb2;\n\n  initbuffer (thisline);\n  initbuffer (prevline);\n\n  /* The duplication in the following 'if' and 'else' blocks is an\n     optimization to distinguish between when we can print input\n     lines immediately (1. & 2.) or not.\n\n     1. --group => all input lines are printed.\n        checking for unique/duplicated lines is used only for printing\n        group separators.\n\n     2. The default case in which none of these options has been specified:\n          --count, --repeated,  --all-repeated, --unique\n        In the default case, this optimization lets uniq output each different\n        line right away, without waiting to see if the next one is different.\n\n     3. All other cases.\n  */\n  if (output_unique && output_first_repeated && countmode == count_none)\n    {\n      char *prevfield = nullptr;\n      size_t prevlen;\n      bool first_group_printed = false;\n\n      while (!feof (stdin))\n        {\n          char *thisfield;\n          size_t thislen;\n          bool new_group;\n\n          if (readlinebuffer_delim (thisline, stdin, delimiter) == 0)\n            break;\n\n          thisfield = find_field (thisline);\n          thislen = thisline->length - 1 - (thisfield - thisline->buffer);\n\n          new_group = (!prevfield\n                       || different (thisfield, prevfield, thislen, prevlen));\n\n          if (new_group && grouping != GM_NONE\n              && (grouping == GM_PREPEND || grouping == GM_BOTH\n                  || (first_group_printed && (grouping == GM_APPEND\n                                              || grouping == GM_SEPARATE))))\n            putchar (delimiter);\n\n          if (new_group || grouping != GM_NONE)\n            {\n              if (fwrite (thisline->buffer, sizeof (char), thisline->length,\n                  stdout) != thisline->length)\n                write_error ();\n\n              SWAP_LINES (prevline, thisline);\n              prevfield = thisfield;\n              prevlen = thislen;\n              first_group_printed = true;\n            }\n        }\n      if ((grouping == GM_BOTH || grouping == GM_APPEND) && first_group_printed)\n        putchar (delimiter);\n    }\n  else\n    {\n      char *prevfield;\n      size_t prevlen;\n      uintmax_t match_count = 0;\n      bool first_delimiter = true;\n\n      if (readlinebuffer_delim (prevline, stdin, delimiter) == 0)\n        goto closefiles;\n      prevfield = find_field (prevline);\n      prevlen = prevline->length - 1 - (prevfield - prevline->buffer);\n\n      while (!feof (stdin))\n        {\n          bool match;\n          char *thisfield;\n          size_t thislen;\n          if (readlinebuffer_delim (thisline, stdin, delimiter) == 0)\n            {\n              if (ferror (stdin))\n                goto closefiles;\n              break;\n            }\n          thisfield = find_field (thisline);\n          thislen = thisline->length - 1 - (thisfield - thisline->buffer);\n          match = !different (thisfield, prevfield, thislen, prevlen);\n          match_count += match;\n\n          if (match_count == UINTMAX_MAX)\n            {\n              if (count_occurrences)\n                error (EXIT_FAILURE, 0, _(\"too many repeated lines\"));\n              match_count--;\n            }\n\n          if (delimit_groups != DM_NONE)\n            {\n              if (!match)\n                {\n                  if (match_count) /* a previous match */\n                    first_delimiter = false; /* Only used when DM_SEPARATE */\n                }\n              else if (match_count == 1)\n                {\n                  if ((delimit_groups == DM_PREPEND)\n                      || (delimit_groups == DM_SEPARATE\n                          && !first_delimiter))\n                    putchar (delimiter);\n                }\n            }\n\n          if (!match || output_later_repeated)\n            {\n              writeline (prevline, match, match_count);\n              SWAP_LINES (prevline, thisline);\n              prevfield = thisfield;\n              prevlen = thislen;\n              if (!match)\n                match_count = 0;\n            }\n        }\n\n      writeline (prevline, false, match_count);\n    }\n\n closefiles:\n  if (ferror (stdin) || fclose (stdin) != 0)\n    error (EXIT_FAILURE, errno, _(\"error reading %s\"), quoteaf (infile));\n\n  /* stdout is handled via the atexit-invoked close_stdout function.  */\n\n  free (lb1.buffer);\n  free (lb2.buffer);\n}\n\nenum Skip_field_option_type\n  {\n    SFO_NONE,\n    SFO_OBSOLETE,\n    SFO_NEW\n  };\n\nint\nmain (int argc, char **argv)\n{\n  int optc = 0;\n  bool posixly_correct = (getenv (\"POSIXLY_CORRECT\") != nullptr);\n  enum Skip_field_option_type skip_field_option_type = SFO_NONE;\n  unsigned int nfiles = 0;\n  char const *file[2];\n  char delimiter = '\\n';\t/* change with --zero-terminated, -z */\n  bool output_option_used = false;   /* if true, one of -u/-d/-D/-c was used */\n\n  file[0] = file[1] = \"-\";\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  skip_chars = 0;\n  skip_fields = 0;\n  check_chars = SIZE_MAX;\n  output_unique = output_first_repeated = true;\n  output_later_repeated = false;\n  countmode = count_none;\n  delimit_groups = DM_NONE;\n\n  while (true)\n    {\n      /* Parse an operand with leading \"+\" as a file after \"--\" was\n         seen; or if pedantic and a file was seen; or if not\n         obsolete.  */\n\n      if (optc == -1\n          || (posixly_correct && nfiles != 0)\n          || ((optc = getopt_long (argc, argv,\n                                   \"-0123456789Dcdf:is:uw:z\",\n                                   longopts, nullptr))\n              == -1))\n        {\n          if (argc <= optind)\n            break;\n          if (nfiles == 2)\n            {\n              error (0, 0, _(\"extra operand %s\"), quote (argv[optind]));\n              usage (EXIT_FAILURE);\n            }\n          file[nfiles++] = argv[optind++];\n        }\n      else switch (optc)\n        {\n        case 1:\n          {\n            uintmax_t size;\n            if (optarg[0] == '+'\n                && ! strict_posix2 ()\n                && xstrtoumax (optarg, nullptr, 10, &size, \"\") == LONGINT_OK\n                && size <= SIZE_MAX)\n              skip_chars = size;\n            else if (nfiles == 2)\n              {\n                error (0, 0, _(\"extra operand %s\"), quote (optarg));\n                usage (EXIT_FAILURE);\n              }\n            else\n              file[nfiles++] = optarg;\n          }\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          {\n            if (skip_field_option_type == SFO_NEW)\n              skip_fields = 0;\n\n            if (!DECIMAL_DIGIT_ACCUMULATE (skip_fields, optc - '0', size_t))\n              skip_fields = SIZE_MAX;\n\n            skip_field_option_type = SFO_OBSOLETE;\n          }\n          break;\n\n        case 'c':\n          countmode = count_occurrences;\n          output_option_used = true;\n          break;\n\n        case 'd':\n          output_unique = false;\n          output_option_used = true;\n          break;\n\n        case 'D':\n          output_unique = false;\n          output_later_repeated = true;\n          if (optarg == nullptr)\n            delimit_groups = DM_NONE;\n          else\n            delimit_groups = XARGMATCH (\"--all-repeated\", optarg,\n                                        delimit_method_string,\n                                        delimit_method_map);\n          output_option_used = true;\n          break;\n\n        case GROUP_OPTION:\n          if (optarg == nullptr)\n            grouping = GM_SEPARATE;\n          else\n            grouping = XARGMATCH (\"--group\", optarg,\n                                  grouping_method_string,\n                                  grouping_method_map);\n          break;\n\n        case 'f':\n          skip_field_option_type = SFO_NEW;\n          skip_fields = size_opt (optarg,\n                                  N_(\"invalid number of fields to skip\"));\n          break;\n\n        case 'i':\n          ignore_case = true;\n          break;\n\n        case 's':\n          skip_chars = size_opt (optarg,\n                                 N_(\"invalid number of bytes to skip\"));\n          break;\n\n        case 'u':\n          output_first_repeated = false;\n          output_option_used = true;\n          break;\n\n        case 'w':\n          check_chars = size_opt (optarg,\n                                  N_(\"invalid number of bytes to compare\"));\n          break;\n\n        case 'z':\n          delimiter = '\\0';\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  /* Note we could allow --group with -D at least, and that would\n     avoid the need to specify a grouping method to --all-repeated.\n     It was thought best to avoid deprecating those parameters though\n     and keep --group separate to other options.  */\n  if (grouping != GM_NONE && output_option_used)\n    {\n      error (0, 0, _(\"--group is mutually exclusive with -c/-d/-D/-u\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (grouping != GM_NONE && countmode != count_none)\n    {\n      error (0, 0,\n           _(\"grouping and printing repeat counts is meaningless\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (countmode == count_occurrences && output_later_repeated)\n    {\n      error (0, 0,\n           _(\"printing all duplicated lines and repeat counts is meaningless\"));\n      usage (EXIT_FAILURE);\n    }\n\n  check_file (file[0], file[1], delimiter);\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}