{
  "module_name": "sum.c",
  "hash_id": "c267acc53070cb2f5ae2eaa597bbd623ad56104c63c95371fe6f7b0b2db87ec0",
  "original_prompt": "Ingested from coreutils-9.4/src/sum.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <stdio.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"human.h\"\n#include \"sum.h\"\n\n#include <byteswap.h>\n#ifdef WORDS_BIGENDIAN\n# define SWAP(n) (n)\n#else\n# define SWAP(n) bswap_16 (n)\n#endif\n\n \n\nint\nbsd_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  int ret = -1;\n  size_t sum, n;\n  int checksum = 0;\t \n  uintmax_t total_bytes = 0;\t \n  static const size_t buffer_length = 32768;\n  uint8_t *buffer = malloc (buffer_length);\n\n  if (! buffer)\n    return -1;\n\n   \n  while (true)\n  {\n    sum = 0;\n\n     \n    while (true)\n    {\n      n = fread (buffer + sum, 1, buffer_length - sum, stream);\n      sum += n;\n\n      if (buffer_length == sum)\n        break;\n\n      if (n == 0)\n        {\n          if (ferror (stream))\n            goto cleanup_buffer;\n          goto final_process;\n        }\n\n      if (feof (stream))\n        goto final_process;\n    }\n\n    for (size_t i = 0; i < sum; i++)\n      {\n        checksum = (checksum >> 1) + ((checksum & 1) << 15);\n        checksum += buffer[i];\n        checksum &= 0xffff;\t \n      }\n    if (total_bytes + sum < total_bytes)\n      {\n        errno = EOVERFLOW;\n        goto cleanup_buffer;\n      }\n    total_bytes += sum;\n  }\n\nfinal_process:;\n\n  for (size_t i = 0; i < sum; i++)\n    {\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += buffer[i];\n      checksum &= 0xffff;\t \n    }\n  if (total_bytes + sum < total_bytes)\n    {\n      errno = EOVERFLOW;\n      goto cleanup_buffer;\n    }\n  total_bytes += sum;\n\n  memcpy (resstream, &checksum, sizeof checksum);\n  *length = total_bytes;\n  ret = 0;\ncleanup_buffer:\n  free (buffer);\n  return ret;\n}\n\n \n\nint\nsysv_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  int ret = -1;\n  size_t sum, n;\n  uintmax_t total_bytes = 0;\n  static const size_t buffer_length = 32768;\n  uint8_t *buffer = malloc (buffer_length);\n\n  if (! buffer)\n    return -1;\n\n   \n  unsigned int s = 0;\n\n   \n  while (true)\n  {\n    sum = 0;\n\n     \n    while (true)\n    {\n      n = fread (buffer + sum, 1, buffer_length - sum, stream);\n      sum += n;\n\n      if (buffer_length == sum)\n        break;\n\n      if (n == 0)\n        {\n          if (ferror (stream))\n            goto cleanup_buffer;\n          goto final_process;\n        }\n\n      if (feof (stream))\n        goto final_process;\n    }\n\n    for (size_t i = 0; i < sum; i++)\n      s += buffer[i];\n    if (total_bytes + sum < total_bytes)\n      {\n        errno = EOVERFLOW;\n        goto cleanup_buffer;\n      }\n    total_bytes += sum;\n  }\n\nfinal_process:;\n\n  for (size_t i = 0; i < sum; i++)\n    s += buffer[i];\n  if (total_bytes + sum < total_bytes)\n    {\n      errno = EOVERFLOW;\n      goto cleanup_buffer;\n    }\n  total_bytes += sum;\n\n  int r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  int checksum = (r & 0xffff) + (r >> 16);\n\n  memcpy (resstream, &checksum, sizeof checksum);\n  *length = total_bytes;\n  ret = 0;\ncleanup_buffer:\n  free (buffer);\n  return ret;\n}\n\n \n\nvoid\noutput_bsd (char const *file, int binary_file, void const *digest,\n            bool raw, bool tagged, unsigned char delim, bool args,\n            uintmax_t length)\n{\n  if (raw)\n    {\n       \n      uint16_t out_int = *(int *)digest;\n      out_int = SWAP (out_int);\n      fwrite (&out_int, 1, 16/8, stdout);\n      return;\n    }\n\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  printf (\"%05d %5s\", *(int *)digest,\n          human_readable (length, hbuf, human_ceiling, 1, 1024));\n  if (args)\n    printf (\" %s\", file);\n  putchar (delim);\n}\n\n \n\nvoid\noutput_sysv (char const *file, int binary_file, void const *digest,\n             bool raw, bool tagged, unsigned char delim, bool args,\n             uintmax_t length)\n{\n  if (raw)\n    {\n       \n      uint16_t out_int = *(int *)digest;\n      out_int = SWAP (out_int);\n      fwrite (&out_int, 1, 16/8, stdout);\n      return;\n    }\n\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  printf (\"%d %s\", *(int *)digest,\n          human_readable (length, hbuf, human_ceiling, 1, 512));\n  if (args)\n    printf (\" %s\", file);\n  putchar (delim);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}