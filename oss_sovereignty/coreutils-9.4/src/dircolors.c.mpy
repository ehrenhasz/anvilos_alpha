{
  "module_name": "dircolors.c",
  "hash_id": "fae92b6b04d9a21ee510c20dba72ad3920065adb0c76e3e36ae87614d55fc540",
  "original_prompt": "Ingested from coreutils-9.4/src/dircolors.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"dircolors\"\n\n#define AUTHORS proper_name (\"H. Peter Anvin\")\n\n#define obstack_chunk_alloc malloc\n#define obstack_chunk_free free\n\nenum Shell_syntax\n{\n  SHELL_SYNTAX_BOURNE,\n  SHELL_SYNTAX_C,\n  SHELL_SYNTAX_UNKNOWN\n};\n\n#define APPEND_CHAR(C) obstack_1grow (&lsc_obstack, C)\n\n \nstatic struct obstack lsc_obstack;\n\nstatic char const *const slack_codes[] =\n{\n  \"NORMAL\", \"NORM\", \"FILE\", \"RESET\", \"DIR\", \"LNK\", \"LINK\",\n  \"SYMLINK\", \"ORPHAN\", \"MISSING\", \"FIFO\", \"PIPE\", \"SOCK\", \"BLK\", \"BLOCK\",\n  \"CHR\", \"CHAR\", \"DOOR\", \"EXEC\", \"LEFT\", \"LEFTCODE\", \"RIGHT\", \"RIGHTCODE\",\n  \"END\", \"ENDCODE\", \"SUID\", \"SETUID\", \"SGID\", \"SETGID\", \"STICKY\",\n  \"OTHER_WRITABLE\", \"OWR\", \"STICKY_OTHER_WRITABLE\", \"OWT\", \"CAPABILITY\",\n  \"MULTIHARDLINK\", \"CLRTOEOL\", nullptr\n};\n\nstatic char const *const ls_codes[] =\n{\n  \"no\", \"no\", \"fi\", \"rs\", \"di\", \"ln\", \"ln\", \"ln\", \"or\", \"mi\", \"pi\", \"pi\",\n  \"so\", \"bd\", \"bd\", \"cd\", \"cd\", \"do\", \"ex\", \"lc\", \"lc\", \"rc\", \"rc\", \"ec\", \"ec\",\n  \"su\", \"su\", \"sg\", \"sg\", \"st\", \"ow\", \"ow\", \"tw\", \"tw\", \"ca\", \"mh\", \"cl\",\n  nullptr\n};\nstatic_assert (ARRAY_CARDINALITY (slack_codes) == ARRAY_CARDINALITY (ls_codes));\n\n \nstatic bool print_ls_colors;\n\n \nenum\n{\n  PRINT_LS_COLORS_OPTION = CHAR_MAX + 1,\n};\n\nstatic struct option const long_options[] =\n  {\n    {\"bourne-shell\", no_argument, nullptr, 'b'},\n    {\"sh\", no_argument, nullptr, 'b'},\n    {\"csh\", no_argument, nullptr, 'c'},\n    {\"c-shell\", no_argument, nullptr, 'c'},\n    {\"print-database\", no_argument, nullptr, 'p'},\n    {\"print-ls-colors\", no_argument, nullptr, PRINT_LS_COLORS_OPTION},\n    {GETOPT_HELP_OPTION_DECL},\n    {GETOPT_VERSION_OPTION_DECL},\n    {nullptr, 0, nullptr, 0}\n  };\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [FILE]\\n\"), program_name);\n      fputs (_(\"\\\nOutput commands to set the LS_COLORS environment variable.\\n\\\n\\n\\\nDetermine format of output:\\n\\\n  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\\n\\\n  -c, --csh, --c-shell        output C shell code to set LS_COLORS\\n\\\n  -p, --print-database        output defaults\\n\\\n      --print-ls-colors       output fully escaped colors for display\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nIf FILE is specified, read it to determine which colors to use for which\\n\\\nfile types and extensions.  Otherwise, a precompiled database is used.\\n\\\nFor details on the format of these files, run 'dircolors --print-database'.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\n/* If the SHELL environment variable is set to 'csh' or 'tcsh,'\n   assume C shell.  Else Bourne shell.  */\n\nstatic enum Shell_syntax\nguess_shell_syntax (void)\n{\n  char *shell;\n\n  shell = getenv (\"SHELL\");\n  if (shell == nullptr || *shell == '\\0')\n    return SHELL_SYNTAX_UNKNOWN;\n\n  shell = last_component (shell);\n\n  if (STREQ (shell, \"csh\") || STREQ (shell, \"tcsh\"))\n    return SHELL_SYNTAX_C;\n\n  return SHELL_SYNTAX_BOURNE;\n}\n\nstatic void\nparse_line (char const *line, char **keyword, char **arg)\n{\n  char const *p;\n  char const *keyword_start;\n  char const *arg_start;\n\n  *keyword = nullptr;\n  *arg = nullptr;\n\n  for (p = line; isspace (to_uchar (*p)); ++p)\n    continue;\n\n  /* Ignore blank lines and shell-style comments.  */\n  if (*p == '\\0' || *p == '#')\n    return;\n\n  keyword_start = p;\n\n  while (!isspace (to_uchar (*p)) && *p != '\\0')\n    {\n      ++p;\n    }\n\n  *keyword = ximemdup0 (keyword_start, p - keyword_start);\n  if (*p  == '\\0')\n    return;\n\n  do\n    {\n      ++p;\n    }\n  while (isspace (to_uchar (*p)));\n\n  if (*p == '\\0' || *p == '#')\n    return;\n\n  arg_start = p;\n\n  while (*p != '\\0' && *p != '#')\n    ++p;\n\n  for (--p; isspace (to_uchar (*p)); --p)\n    continue;\n  ++p;\n\n  *arg = ximemdup0 (arg_start, p - arg_start);\n}\n\n/* Accumulate STR to LS_COLORS data.\n   If outputting shell syntax, then escape appropriately.  */\n\nstatic void\nappend_quoted (char const *str)\n{\n  bool need_backslash = true;\n\n  while (*str != '\\0')\n    {\n      if (! print_ls_colors)\n        switch (*str)\n          {\n          case '\\'':\n            APPEND_CHAR ('\\'');\n            APPEND_CHAR ('\\\\');\n            APPEND_CHAR ('\\'');\n            need_backslash = true;\n            break;\n\n          case '\\\\':\n          case '^':\n            need_backslash = !need_backslash;\n            break;\n\n          case ':':\n          case '=':\n            if (need_backslash)\n              APPEND_CHAR ('\\\\');\n            FALLTHROUGH;\n\n          default:\n            need_backslash = true;\n            break;\n          }\n\n      APPEND_CHAR (*str);\n      ++str;\n    }\n}\n\n/* Accumulate entry to LS_COLORS data.\n   Use shell syntax unless PRINT_LS_COLORS is set.  */\n\nstatic void\nappend_entry (char prefix, char const *item, char const *arg)\n{\n  if (print_ls_colors)\n    {\n      append_quoted (\"\\x1B[\");\n      append_quoted (arg);\n      APPEND_CHAR ('m');\n    }\n  if (prefix)\n    APPEND_CHAR (prefix);\n  append_quoted (item);\n  APPEND_CHAR (print_ls_colors ? '\\t' : '=');\n  append_quoted (arg);\n  if (print_ls_colors)\n    append_quoted (\"\\x1B[0m\");\n  APPEND_CHAR (print_ls_colors ? '\\n' : ':');\n}\n\n/* Read the file open on FP (with name FILENAME).  First, look for a\n   'TERM name' directive where name matches the current terminal type.\n   Once found, translate and accumulate the associated directives onto\n   the global obstack LSC_OBSTACK.  Give a diagnostic\n   upon failure (unrecognized keyword is the only way to fail here).\n   Return true if successful.  */\n\nstatic bool\ndc_parse_stream (FILE *fp, char const *filename)\n{\n  idx_t line_number = 0;\n  char const *next_G_line = G_line;\n  char *input_line = nullptr;\n  size_t input_line_size = 0;\n  char const *line;\n  char const *term;\n  char const *colorterm;\n  bool ok = true;\n\n  /* State for the parser.  */\n  enum { ST_TERMNO, ST_TERMYES, ST_TERMSURE, ST_GLOBAL } state = ST_GLOBAL;\n\n  /* Get terminal type */\n  term = getenv (\"TERM\");\n  if (term == nullptr || *term == '\\0')\n    term = \"none\";\n\n  /* Also match $COLORTERM.  */\n  colorterm = getenv (\"COLORTERM\");\n  if (colorterm == nullptr)\n    colorterm = \"\";  /* Doesn't match default \"?*\"  */\n\n  while (true)\n    {\n      char *keywd, *arg;\n      bool unrecognized;\n\n      ++line_number;\n\n      if (fp)\n        {\n          if (getline (&input_line, &input_line_size, fp) <= 0)\n            {\n              if (ferror (fp))\n                {\n                  error (0, errno, _(\"%s: read error\"), quotef (filename));\n                  ok = false;\n                }\n              free (input_line);\n              break;\n            }\n          line = input_line;\n        }\n      else\n        {\n          if (next_G_line == G_line + sizeof G_line)\n            break;\n          line = next_G_line;\n          next_G_line += strlen (next_G_line) + 1;\n        }\n\n      parse_line (line, &keywd, &arg);\n\n      if (keywd == nullptr)\n        continue;\n\n      if (arg == nullptr)\n        {\n          error (0, 0, _(\"%s:%td: invalid line;  missing second token\"),\n                 quotef (filename), line_number);\n          ok = false;\n          free (keywd);\n          continue;\n        }\n\n      unrecognized = false;\n      if (c_strcasecmp (keywd, \"TERM\") == 0)\n        {\n          if (state != ST_TERMSURE)\n            state = fnmatch (arg, term, 0) == 0 ? ST_TERMSURE : ST_TERMNO;\n        }\n      else if (c_strcasecmp (keywd, \"COLORTERM\") == 0)\n        {\n          if (state != ST_TERMSURE)\n            state = fnmatch (arg, colorterm, 0) == 0 ? ST_TERMSURE : ST_TERMNO;\n        }\n      else\n        {\n          if (state == ST_TERMSURE)\n            state = ST_TERMYES;  /* Another {COLOR,}TERM can cancel.  */\n\n          if (state != ST_TERMNO)\n            {\n              if (keywd[0] == '.')\n                append_entry ('*', keywd, arg);\n              else if (keywd[0] == '*')\n                append_entry (0, keywd, arg);\n              else if (c_strcasecmp (keywd, \"OPTIONS\") == 0\n                       || c_strcasecmp (keywd, \"COLOR\") == 0\n                       || c_strcasecmp (keywd, \"EIGHTBIT\") == 0)\n                {\n                  /* Ignore.  */\n                }\n              else\n                {\n                  int i;\n\n                  for (i = 0; slack_codes[i] != nullptr; ++i)\n                    if (c_strcasecmp (keywd, slack_codes[i]) == 0)\n                      break;\n\n                  if (slack_codes[i] != nullptr)\n                    append_entry (0, ls_codes[i], arg);\n                  else\n                    unrecognized = true;\n                }\n            }\n          else\n            unrecognized = true;\n        }\n\n      if (unrecognized && (state == ST_TERMSURE || state == ST_TERMYES))\n        {\n          error (0, 0, _(\"%s:%td: unrecognized keyword %s\"),\n                 (filename ? quotef (filename) : _(\"<internal>\")),\n                 line_number, keywd);\n          ok = false;\n        }\n\n      free (keywd);\n      free (arg);\n    }\n\n  return ok;\n}\n\nstatic bool\ndc_parse_file (char const *filename)\n{\n  bool ok;\n\n  if (! STREQ (filename, \"-\") && freopen (filename, \"r\", stdin) == nullptr)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  ok = dc_parse_stream (stdin, filename);\n\n  if (fclose (stdin) != 0)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  return ok;\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool ok = true;\n  int optc;\n  enum Shell_syntax syntax = SHELL_SYNTAX_UNKNOWN;\n  bool print_database = false;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"bcp\", long_options, nullptr)) != -1)\n    switch (optc)\n      {\n      case 'b':\t/* Bourne shell syntax.  */\n        syntax = SHELL_SYNTAX_BOURNE;\n        break;\n\n      case 'c':\t/* C shell syntax.  */\n        syntax = SHELL_SYNTAX_C;\n        break;\n\n      case 'p':\n        print_database = true;\n        break;\n\n      case PRINT_LS_COLORS_OPTION:\n        print_ls_colors = true;\n        break;\n\n      case_GETOPT_HELP_CHAR;\n\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n      default:\n        usage (EXIT_FAILURE);\n      }\n\n  argc -= optind;\n  argv += optind;\n\n  /* It doesn't make sense to use --print with either of\n     --bourne or --c-shell.  */\n  if ((print_database | print_ls_colors) && syntax != SHELL_SYNTAX_UNKNOWN)\n    {\n      error (0, 0,\n             _(\"the options to output non shell syntax,\\n\"\n               \"and to select a shell syntax are mutually exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (print_database && print_ls_colors)\n    {\n      error (0, 0,\n             _(\"options --print-database and --print-ls-colors \"\n               \"are mutually exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if ((!print_database) < argc)\n    {\n      error (0, 0, _(\"extra operand %s\"),\n             quote (argv[!print_database]));\n      if (print_database)\n        fprintf (stderr, \"%s\\n\",\n                 _(\"file operands cannot be combined with \"\n                   \"--print-database (-p)\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (print_database)\n    {\n      char const *p = G_line;\n      while (p - G_line < sizeof G_line)\n        {\n          puts (p);\n          p += strlen (p) + 1;\n        }\n    }\n  else\n    {\n      /* If shell syntax was not explicitly specified, try to guess it. */\n      if (syntax == SHELL_SYNTAX_UNKNOWN && ! print_ls_colors)\n        {\n          syntax = guess_shell_syntax ();\n          if (syntax == SHELL_SYNTAX_UNKNOWN)\n            error (EXIT_FAILURE, 0,\n                   _(\"no SHELL environment variable,\"\n                     \" and no shell type option given\"));\n        }\n\n      obstack_init (&lsc_obstack);\n      if (argc == 0)\n        ok = dc_parse_stream (nullptr, nullptr);\n      else\n        ok = dc_parse_file (argv[0]);\n\n      if (ok)\n        {\n          size_t len = obstack_object_size (&lsc_obstack);\n          char *s = obstack_finish (&lsc_obstack);\n          char const *prefix;\n          char const *suffix;\n\n          if (syntax == SHELL_SYNTAX_BOURNE)\n            {\n              prefix = \"LS_COLORS='\";\n              suffix = \"';\\nexport LS_COLORS\\n\";\n            }\n          else\n            {\n              prefix = \"setenv LS_COLORS '\";\n              suffix = \"'\\n\";\n            }\n          if (! print_ls_colors)\n            fputs (prefix, stdout);\n          fwrite (s, 1, len, stdout);\n          if (! print_ls_colors)\n            fputs (suffix, stdout);\n        }\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}