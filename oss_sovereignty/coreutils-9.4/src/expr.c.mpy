{
  "module_name": "expr.c",
  "hash_id": "acf0edc9a0959010876314094c8c3249cdce3db7b1443dc6af08b607cc4b3f0d",
  "original_prompt": "Ingested from coreutils-9.4/src/expr.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include \"system.h\"\n\n#include <gmp.h>\n#include <regex.h>\n#include \"long-options.h\"\n#include \"mbuiter.h\"\n#include \"strnumcmp.h\"\n#include \"xstrtol.h\"\n\n \nstatic_assert (SIZE_MAX <= ULONG_MAX);\n\n \n#define PROGRAM_NAME \"expr\"\n\n#define AUTHORS \\\n  proper_name (\"Mike Parker\"), \\\n  proper_name (\"James Youngman\"), \\\n  proper_name (\"Paul Eggert\")\n\n \nenum\n  {\n     \n    EXPR_INVALID = 2,\n\n     \n    EXPR_FAILURE\n  };\n\n \nenum valtype\n{\n  integer,\n  string\n};\ntypedef enum valtype TYPE;\n\n \nstruct valinfo\n{\n  TYPE type;\t\t\t \n  union\n  {\t\t\t\t \n    mpz_t i;\n    char *s;\n  } u;\n};\ntypedef struct valinfo VALUE;\n\n \nstatic char **args;\n\nstatic VALUE *eval (bool);\nstatic bool nomoreargs (void);\nstatic bool null (VALUE *v);\nstatic void printv (VALUE *v);\n\n\n \nstatic size_t\nmbs_logical_cspn (char const *s, char const *accept)\n{\n  size_t idx = 0;\n\n  if (accept[0] == '\\0')\n    return 0;\n\n   \n  if (MB_CUR_MAX > 1)\n    {\n      mbui_iterator_t iter;\n\n      for (mbui_init (iter, s); mbui_avail (iter); mbui_advance (iter))\n        {\n          ++idx;\n          if (mb_len (mbui_cur (iter)) == 1)\n            {\n              if (mbschr (accept, *mbui_cur_ptr (iter)))\n                return idx;\n            }\n          else\n            {\n              mbui_iterator_t aiter;\n\n              for (mbui_init (aiter, accept);\n                   mbui_avail (aiter);\n                   mbui_advance (aiter))\n                if (mb_equal (mbui_cur (aiter), mbui_cur (iter)))\n                  return idx;\n            }\n        }\n\n       \n      return 0;\n    }\n  else\n    {\n       \n      size_t i = strcspn (s, accept);\n      return (s[i] ? i + 1 : 0);\n    }\n}\n\n \nstatic char *\nmbs_logical_substr (char const *s, size_t pos, size_t len)\n{\n  char *v, *vlim;\n\n  size_t blen = strlen (s);  \n  size_t llen = (MB_CUR_MAX > 1) ? mbslen (s) : blen;  \n\n  if (llen < pos || pos == 0 || len == 0 || len == SIZE_MAX)\n    return xstrdup (\"\");\n\n   \n  size_t vlen = MIN (len, llen - pos + 1);\n\n  if (MB_CUR_MAX == 1)\n    {\n       \n      v = xmalloc (vlen + 1);\n      vlim = mempcpy (v, s + pos - 1, vlen);\n    }\n  else\n    {\n       \n\n       \n      vlim = v = xmalloc (blen + 1);\n\n      mbui_iterator_t iter;\n      size_t idx=1;\n      for (mbui_init (iter, s);\n           mbui_avail (iter) && vlen > 0;\n           mbui_advance (iter), ++idx)\n        {\n           \n          if (idx < pos)\n            continue;\n\n           \n          --vlen;\n          vlim = mempcpy (vlim, mbui_cur_ptr (iter), mb_len (mbui_cur (iter)));\n        }\n    }\n  *vlim = '\\0';\n  return v;\n}\n\n \nstatic size_t\nmbs_offset_to_chars (char const *s, size_t ofs)\n{\n  mbui_iterator_t iter;\n  size_t c = 0;\n  for (mbui_init (iter, s); mbui_avail (iter); mbui_advance (iter))\n    {\n      ptrdiff_t d = mbui_cur_ptr (iter) - s;\n      if (d >= ofs)\n        break;\n      ++c;\n    }\n  return c;\n}\n\n\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s EXPRESSION\\n\\\n  or:  %s OPTION\\n\\\n\"),\n              program_name, program_name);\n      putchar ('\\n');\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nPrint the value of EXPRESSION to standard output.  A blank line below\\n\\\nseparates increasing precedence groups.  EXPRESSION may be:\\n\\\n\\n\\\n  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\\n\\\n\\n\\\n  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  ARG1 < ARG2       ARG1 is less than ARG2\\n\\\n  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\\n\\\n  ARG1 = ARG2       ARG1 is equal to ARG2\\n\\\n  ARG1 != ARG2      ARG1 is unequal to ARG2\\n\\\n  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\\n\\\n  ARG1 > ARG2       ARG1 is greater than ARG2\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\\n\\\n  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\\n\\\n\"), stdout);\n      /* Tell xgettext that the \"% A\" below is not a printf-style\n         format string:  xgettext:no-c-format */\n      fputs (_(\"\\\n\\n\\\n  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\\n\\\n  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\\n\\\n  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  STRING : REGEXP   anchored pattern match of REGEXP in STRING\\n\\\n\\n\\\n  match STRING REGEXP        same as STRING : REGEXP\\n\\\n  substr STRING POS LENGTH   substring of STRING, POS counted from 1\\n\\\n  index STRING CHARS         index in STRING where any CHARS is found, or 0\\n\\\n  length STRING              length of STRING\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  + TOKEN                    interpret TOKEN as a string, even if it is a\\n\\\n                               keyword like 'match' or an operator like '/'\\n\\\n\\n\\\n  ( EXPRESSION )             value of EXPRESSION\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nBeware that many operators need to be escaped or quoted for shells.\\n\\\nComparisons are arithmetic if both ARGs are numbers, else lexicographical.\\n\\\nPattern matches return the string matched between \\\\( and \\\\) or null; if\\n\\\n\\\\( and \\\\) are not used, they return the number of characters matched or 0.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nExit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is null\\n\\\nor 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n\nint\nmain (int argc, char **argv)\n{\n  VALUE *v;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXPR_FAILURE);\n  atexit (close_stdout);\n\n  parse_long_options (argc, argv, PROGRAM_NAME, PACKAGE_NAME, VERSION,\n                      usage, AUTHORS, (char const *) nullptr);\n\n  /* The above handles --help and --version.\n     Since there is no other invocation of getopt, handle '--' here.  */\n  if (1 < argc && STREQ (argv[1], \"--\"))\n    {\n      --argc;\n      ++argv;\n    }\n\n  if (argc <= 1)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXPR_INVALID);\n    }\n\n  args = argv + 1;\n\n  v = eval (true);\n  if (!nomoreargs ())\n    error (EXPR_INVALID, 0, _(\"syntax error: unexpected argument %s\"),\n           quotearg_n_style (0, locale_quoting_style, *args));\n\n  printv (v);\n\n  main_exit (null (v));\n}\n\n/* Return a VALUE for I.  */\n\nstatic VALUE *\nint_value (unsigned long int i)\n{\n  VALUE *v = xmalloc (sizeof *v);\n  v->type = integer;\n  mpz_init_set_ui (v->u.i, i);\n  return v;\n}\n\n/* Return a VALUE for S.  */\n\nstatic VALUE *\nstr_value (char const *s)\n{\n  VALUE *v = xmalloc (sizeof *v);\n  v->type = string;\n  v->u.s = xstrdup (s);\n  return v;\n}\n\n/* Free VALUE V, including structure components.  */\n\nstatic void\nfreev (VALUE *v)\n{\n  if (v->type == string)\n    free (v->u.s);\n  else\n    mpz_clear (v->u.i);\n  free (v);\n}\n\n/* Print VALUE V.  */\n\nstatic void\nprintv (VALUE *v)\n{\n  switch (v->type)\n    {\n    case integer:\n      mpz_out_str (stdout, 10, v->u.i);\n      putchar ('\\n');\n      break;\n    case string:\n      puts (v->u.s);\n      break;\n    default:\n      unreachable ();\n    }\n}\n\n/* Return true if V is a null-string or zero-number.  */\n\nATTRIBUTE_PURE\nstatic bool\nnull (VALUE *v)\n{\n  switch (v->type)\n    {\n    case integer:\n      return mpz_sgn (v->u.i) == 0;\n    case string:\n      {\n        char const *cp = v->u.s;\n        if (*cp == '\\0')\n          return true;\n\n        cp += (*cp == '-');\n\n        do\n          {\n            if (*cp != '0')\n              return false;\n          }\n        while (*++cp);\n\n        return true;\n      }\n    default:\n      unreachable ();\n    }\n}\n\n/* Return true if CP takes the form of an integer.  */\n\nATTRIBUTE_PURE\nstatic bool\nlooks_like_integer (char const *cp)\n{\n  cp += (*cp == '-');\n\n  do\n    if (! ISDIGIT (*cp))\n      return false;\n  while (*++cp);\n\n  return true;\n}\n\n/* Coerce V to a string value (can't fail).  */\n\nstatic void\ntostring (VALUE *v)\n{\n  switch (v->type)\n    {\n    case integer:\n      {\n        char *s = mpz_get_str (nullptr, 10, v->u.i);\n        mpz_clear (v->u.i);\n        v->u.s = s;\n        v->type = string;\n      }\n      break;\n    case string:\n      break;\n    default:\n      unreachable ();\n    }\n}\n\n/* Coerce V to an integer value.  Return true on success, false on failure.  */\n\nstatic bool\ntoarith (VALUE *v)\n{\n  switch (v->type)\n    {\n    case integer:\n      return true;\n    case string:\n      {\n        char *s = v->u.s;\n\n        if (! looks_like_integer (s))\n          return false;\n        if (mpz_init_set_str (v->u.i, s, 10) != 0)\n          error (EXPR_FAILURE, ERANGE, \"%s\", (s));\n        free (s);\n        v->type = integer;\n        return true;\n      }\n    default:\n      unreachable ();\n    }\n}\n\n/* Extract a size_t value from an integer value I.\n   If the value is negative, return SIZE_MAX.\n   If the value is too large, return SIZE_MAX - 1.  */\nstatic size_t\ngetsize (mpz_t i)\n{\n  if (mpz_sgn (i) < 0)\n    return SIZE_MAX;\n  if (mpz_fits_ulong_p (i))\n    {\n      unsigned long int ul = mpz_get_ui (i);\n      if (ul < SIZE_MAX)\n        return ul;\n    }\n  return SIZE_MAX - 1;\n}\n\n/* Return true and advance if the next token matches STR exactly.\n   STR must not be null.  */\n\nstatic bool\nnextarg (char const *str)\n{\n  if (*args == nullptr)\n    return false;\n  else\n    {\n      bool r = STREQ (*args, str);\n      args += r;\n      return r;\n    }\n}\n\n/* Return true if there no more tokens.  */\n\nstatic bool\nnomoreargs (void)\n{\n  return *args == 0;\n}\n\n/* Report missing operand.\n   There is an implicit assumption that there was a previous argument,\n   and (args-1) is valid. */\nstatic void\nrequire_more_args (void)\n{\n  if (nomoreargs ())\n    error (EXPR_INVALID, 0, _(\"syntax error: missing argument after %s\"),\n           quotearg_n_style (0, locale_quoting_style, *(args - 1)));\n}\n\n\n#ifdef EVAL_TRACE\n/* Print evaluation trace and args remaining.  */\n\nstatic void\ntrace (fxn)\n     char *fxn;\n{\n  char **a;\n\n  printf (\"%s:\", fxn);\n  for (a = args; *a; a++)\n    printf (\" %s\", *a);\n  putchar ('\\n');\n}\n#endif\n\n/* Do the : operator.\n   SV is the VALUE for the lhs (the string),\n   PV is the VALUE for the rhs (the pattern).  */\n\nstatic VALUE *\ndocolon (VALUE *sv, VALUE *pv)\n{\n  VALUE *v;\n  char const *errmsg;\n  struct re_pattern_buffer re_buffer;\n  char fastmap[UCHAR_MAX + 1];\n  struct re_registers re_regs;\n  regoff_t matchlen;\n\n  tostring (sv);\n  tostring (pv);\n\n  re_regs.num_regs = 0;\n  re_regs.start = nullptr;\n  re_regs.end = nullptr;\n\n  re_buffer.buffer = nullptr;\n  re_buffer.allocated = 0;\n  re_buffer.fastmap = fastmap;\n  re_buffer.translate = nullptr;\n  re_syntax_options =\n    RE_SYNTAX_POSIX_BASIC & ~RE_CONTEXT_INVALID_DUP & ~RE_NO_EMPTY_RANGES;\n  errmsg = re_compile_pattern (pv->u.s, strlen (pv->u.s), &re_buffer);\n  if (errmsg)\n    error (EXPR_INVALID, 0, \"%s\", (errmsg));\n  re_buffer.newline_anchor = 0;\n\n  matchlen = re_match (&re_buffer, sv->u.s, strlen (sv->u.s), 0, &re_regs);\n  if (0 <= matchlen)\n    {\n      /* Were \\(...\\) used? */\n      if (re_buffer.re_nsub > 0)\n        {\n          if (re_regs.end[1] < 0)\n            v = str_value (\"\");\n          else\n            {\n              sv->u.s[re_regs.end[1]] = '\\0';\n              v = str_value (sv->u.s + re_regs.start[1]);\n            }\n        }\n      else\n        {\n          /* In multibyte locales, convert the matched offset (=number of bytes)\n             to the number of matched characters. */\n          size_t i = (MB_CUR_MAX == 1\n                      ? matchlen\n                      : mbs_offset_to_chars (sv->u.s, matchlen));\n          v = int_value (i);\n        }\n    }\n  else if (matchlen == -1)\n    {\n      /* Match failed -- return the right kind of null.  */\n      if (re_buffer.re_nsub > 0)\n        v = str_value (\"\");\n      else\n        v = int_value (0);\n    }\n  else\n    error (EXPR_FAILURE,\n           matchlen == -2 ? errno : EOVERFLOW,\n           _(\"error in regular expression matcher\"));\n\n  if (0 < re_regs.num_regs)\n    {\n      free (re_regs.start);\n      free (re_regs.end);\n    }\n  re_buffer.fastmap = nullptr;\n  regfree (&re_buffer);\n  return v;\n}\n\n/* Handle bare operands and ( expr ) syntax.  */\n\nstatic VALUE *\neval7 (bool evaluate)\n{\n  VALUE *v;\n\n#ifdef EVAL_TRACE\n  trace (\"eval7\");\n#endif\n  require_more_args ();\n\n  if (nextarg (\"(\"))\n    {\n      v = eval (evaluate);\n      if (nomoreargs ())\n        error (EXPR_INVALID, 0, _(\"syntax error: expecting ')' after %s\"),\n               quotearg_n_style (0, locale_quoting_style, *(args - 1)));\n      if (!nextarg (\")\"))\n        error (EXPR_INVALID, 0, _(\"syntax error: expecting ')' instead of %s\"),\n               quotearg_n_style (0, locale_quoting_style, *args));\n      return v;\n    }\n\n  if (nextarg (\")\"))\n    error (EXPR_INVALID, 0, _(\"syntax error: unexpected ')'\"));\n\n  return str_value (*args++);\n}\n\n/* Handle match, substr, index, and length keywords, and quoting \"+\".  */\n\nstatic VALUE *\neval6 (bool evaluate)\n{\n  VALUE *l;\n  VALUE *r;\n  VALUE *v;\n  VALUE *i1;\n  VALUE *i2;\n\n#ifdef EVAL_TRACE\n  trace (\"eval6\");\n#endif\n  if (nextarg (\"+\"))\n    {\n      require_more_args ();\n      return str_value (*args++);\n    }\n  else if (nextarg (\"length\"))\n    {\n      r = eval6 (evaluate);\n      tostring (r);\n      v = int_value (mbslen (r->u.s));\n      freev (r);\n      return v;\n    }\n  else if (nextarg (\"match\"))\n    {\n      l = eval6 (evaluate);\n      r = eval6 (evaluate);\n      if (evaluate)\n        {\n          v = docolon (l, r);\n          freev (l);\n        }\n      else\n        v = l;\n      freev (r);\n      return v;\n    }\n  else if (nextarg (\"index\"))\n    {\n      size_t pos;\n\n      l = eval6 (evaluate);\n      r = eval6 (evaluate);\n      tostring (l);\n      tostring (r);\n      pos = mbs_logical_cspn (l->u.s, r->u.s);\n      v = int_value (pos);\n      freev (l);\n      freev (r);\n      return v;\n    }\n  else if (nextarg (\"substr\"))\n    {\n      l = eval6 (evaluate);\n      i1 = eval6 (evaluate);\n      i2 = eval6 (evaluate);\n      tostring (l);\n\n      if (!toarith (i1) || !toarith (i2))\n        v = str_value (\"\");\n      else\n        {\n          size_t pos = getsize (i1->u.i);\n          size_t len = getsize (i2->u.i);\n\n          char *s = mbs_logical_substr (l->u.s, pos, len);\n          v = str_value (s);\n          free (s);\n        }\n      freev (l);\n      freev (i1);\n      freev (i2);\n      return v;\n    }\n  else\n    return eval7 (evaluate);\n}\n\n/* Handle : operator (pattern matching).\n   Calls docolon to do the real work.  */\n\nstatic VALUE *\neval5 (bool evaluate)\n{\n  VALUE *l;\n  VALUE *r;\n  VALUE *v;\n\n#ifdef EVAL_TRACE\n  trace (\"eval5\");\n#endif\n  l = eval6 (evaluate);\n  while (true)\n    {\n      if (nextarg (\":\"))\n        {\n          r = eval6 (evaluate);\n          if (evaluate)\n            {\n              v = docolon (l, r);\n              freev (l);\n              l = v;\n            }\n          freev (r);\n        }\n      else\n        return l;\n    }\n}\n\n/* Handle *, /, % operators.  */\n\nstatic VALUE *\neval4 (bool evaluate)\n{\n  VALUE *l;\n  VALUE *r;\n  enum { multiply, divide, mod } fxn;\n\n#ifdef EVAL_TRACE\n  trace (\"eval4\");\n#endif\n  l = eval5 (evaluate);\n  while (true)\n    {\n      if (nextarg (\"*\"))\n        fxn = multiply;\n      else if (nextarg (\"/\"))\n        fxn = divide;\n      else if (nextarg (\"%\"))\n        fxn = mod;\n      else\n        return l;\n      r = eval5 (evaluate);\n      if (evaluate)\n        {\n          if (!toarith (l) || !toarith (r))\n            error (EXPR_INVALID, 0, _(\"non-integer argument\"));\n          if (fxn != multiply && mpz_sgn (r->u.i) == 0)\n            error (EXPR_INVALID, 0, _(\"division by zero\"));\n          ((fxn == multiply ? mpz_mul\n            : fxn == divide ? mpz_tdiv_q\n            : mpz_tdiv_r)\n           (l->u.i, l->u.i, r->u.i));\n        }\n      freev (r);\n    }\n}\n\n/* Handle +, - operators.  */\n\nstatic VALUE *\neval3 (bool evaluate)\n{\n  VALUE *l;\n  VALUE *r;\n  enum { plus, minus } fxn;\n\n#ifdef EVAL_TRACE\n  trace (\"eval3\");\n#endif\n  l = eval4 (evaluate);\n  while (true)\n    {\n      if (nextarg (\"+\"))\n        fxn = plus;\n      else if (nextarg (\"-\"))\n        fxn = minus;\n      else\n        return l;\n      r = eval4 (evaluate);\n      if (evaluate)\n        {\n          if (!toarith (l) || !toarith (r))\n            error (EXPR_INVALID, 0, _(\"non-integer argument\"));\n          (fxn == plus ? mpz_add : mpz_sub) (l->u.i, l->u.i, r->u.i);\n        }\n      freev (r);\n    }\n}\n\n/* Handle comparisons.  */\n\nstatic VALUE *\neval2 (bool evaluate)\n{\n  VALUE *l;\n\n#ifdef EVAL_TRACE\n  trace (\"eval2\");\n#endif\n  l = eval3 (evaluate);\n  while (true)\n    {\n      VALUE *r;\n      enum\n        {\n          less_than, less_equal, equal, not_equal, greater_equal, greater_than\n        } fxn;\n      bool val = false;\n\n      if (nextarg (\"<\"))\n        fxn = less_than;\n      else if (nextarg (\"<=\"))\n        fxn = less_equal;\n      else if (nextarg (\"=\") || nextarg (\"==\"))\n        fxn = equal;\n      else if (nextarg (\"!=\"))\n        fxn = not_equal;\n      else if (nextarg (\">=\"))\n        fxn = greater_equal;\n      else if (nextarg (\">\"))\n        fxn = greater_than;\n      else\n        return l;\n      r = eval3 (evaluate);\n\n      if (evaluate)\n        {\n          int cmp;\n          tostring (l);\n          tostring (r);\n\n          if (looks_like_integer (l->u.s) && looks_like_integer (r->u.s))\n            cmp = strintcmp (l->u.s, r->u.s);\n          else\n            {\n              errno = 0;\n              cmp = strcoll (l->u.s, r->u.s);\n\n              if (errno)\n                {\n                  error (0, errno, _(\"string comparison failed\"));\n                  error (0, 0, _(\"set LC_ALL='C' to work around the problem\"));\n                  error (EXPR_INVALID, 0,\n                         _(\"the strings compared were %s and %s\"),\n                         quotearg_n_style (0, locale_quoting_style, l->u.s),\n                         quotearg_n_style (1, locale_quoting_style, r->u.s));\n                }\n            }\n\n          switch (fxn)\n            {\n            case less_than:     val = (cmp <  0); break;\n            case less_equal:    val = (cmp <= 0); break;\n            case equal:         val = (cmp == 0); break;\n            case not_equal:     val = (cmp != 0); break;\n            case greater_equal: val = (cmp >= 0); break;\n            case greater_than:  val = (cmp >  0); break;\n            default: unreachable ();\n            }\n        }\n\n      freev (l);\n      freev (r);\n      l = int_value (val);\n    }\n}\n\n/* Handle &.  */\n\nstatic VALUE *\neval1 (bool evaluate)\n{\n  VALUE *l;\n  VALUE *r;\n\n#ifdef EVAL_TRACE\n  trace (\"eval1\");\n#endif\n  l = eval2 (evaluate);\n  while (true)\n    {\n      if (nextarg (\"&\"))\n        {\n          r = eval2 (evaluate && !null (l));\n          if (null (l) || null (r))\n            {\n              freev (l);\n              freev (r);\n              l = int_value (0);\n            }\n          else\n            freev (r);\n        }\n      else\n        return l;\n    }\n}\n\n/* Handle |.  */\n\nstatic VALUE *\neval (bool evaluate)\n{\n  VALUE *l;\n  VALUE *r;\n\n#ifdef EVAL_TRACE\n  trace (\"eval\");\n#endif\n  l = eval1 (evaluate);\n  while (true)\n    {\n      if (nextarg (\"|\"))\n        {\n          r = eval1 (evaluate && null (l));\n          if (null (l))\n            {\n              freev (l);\n              l = r;\n              if (null (l))\n                {\n                  freev (l);\n                  l = int_value (0);\n                }\n            }\n          else\n            freev (r);\n        }\n      else\n        return l;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}