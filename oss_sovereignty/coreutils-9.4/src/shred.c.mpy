{
  "module_name": "shred.c",
  "hash_id": "868fe25f4c9494c6c10d74ca265e26d11faa5de59ff5d98cf39047a35978c72d",
  "original_prompt": "Ingested from coreutils-9.4/src/shred.c",
  "human_readable_source": " \n\n \n\n \n#define PROGRAM_NAME \"shred\"\n\n#define AUTHORS proper_name (\"Colin Plumb\")\n\n#include <config.h>\n\n#include <getopt.h>\n#include <stdio.h>\n#include <setjmp.h>\n#include <sys/types.h>\n#if defined __linux__ && HAVE_SYS_MTIO_H\n# include <sys/mtio.h>\n#endif\n\n#include \"system.h\"\n#include \"alignalloc.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"xdectoint.h\"\n#include \"fcntl--.h\"\n#include \"human.h\"\n#include \"randint.h\"\n#include \"randread.h\"\n#include \"renameatu.h\"\n#include \"stat-size.h\"\n\n \nenum { DEFAULT_PASSES = 3 };\n\n \nenum { VERBOSE_UPDATE = 5 };\n\n \nenum { SECTOR_SIZE = 512 };\nenum { SECTOR_MASK = SECTOR_SIZE - 1 };\nstatic_assert (0 < SECTOR_SIZE && (SECTOR_SIZE & SECTOR_MASK) == 0);\n\nenum remove_method\n{\n  remove_none = 0,       \n  remove_unlink,         \n  remove_wipe,           \n  remove_wipesync        \n};\n\nstatic char const *const remove_args[] =\n{\n  \"unlink\", \"wipe\", \"wipesync\", nullptr\n};\n\nstatic enum remove_method const remove_methods[] =\n{\n  remove_unlink, remove_wipe, remove_wipesync\n};\n\nstruct Options\n{\n  bool force;\t\t \n  size_t n_iterations;\t \n  off_t size;\t\t \n  enum remove_method remove_file;  \n  bool verbose;\t\t \n  bool exact;\t\t \n  bool zero_fill;\t \n};\n\n \nenum\n{\n  RANDOM_SOURCE_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const long_opts[] =\n{\n  {\"exact\", no_argument, nullptr, 'x'},\n  {\"force\", no_argument, nullptr, 'f'},\n  {\"iterations\", required_argument, nullptr, 'n'},\n  {\"size\", required_argument, nullptr, 's'},\n  {\"random-source\", required_argument, nullptr, RANDOM_SOURCE_OPTION},\n  {\"remove\", optional_argument, nullptr, 'u'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {\"zero\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... FILE...\\n\"), program_name);\n      fputs (_(\"\\\nOverwrite the specified FILE(s) repeatedly, in order to make it harder\\n\\\nfor even very expensive hardware probing to recover the data.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nIf FILE is -, shred standard output.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      printf (_(\"\\\n  -f, --force    change permissions to allow writing if necessary\\n\\\n  -n, --iterations=N  overwrite N times instead of the default (%d)\\n\\\n      --random-source=FILE  get random bytes from FILE\\n\\\n  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\\n\\\n\"), DEFAULT_PASSES);\n      fputs (_(\"\\\n  -u             deallocate and remove file after overwriting\\n\\\n      --remove[=HOW]  like -u but give control on HOW to delete;  See below\\n\\\n  -v, --verbose  show progress\\n\\\n  -x, --exact    do not round file sizes up to the next full block;\\n\\\n                   this is the default for non-regular files\\n\\\n  -z, --zero     add a final overwrite with zeros to hide shredding\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nDelete FILE(s) if --remove (-u) is specified.  The default is not to remove\\n\\\nthe files because it is common to operate on device files like /dev/hda,\\n\\\nand those files usually should not be removed.\\n\\\nThe optional HOW parameter indicates how to remove a directory entry:\\n\\\n'unlink' => use a standard unlink call.\\n\\\n'wipe' => also first obfuscate bytes in the name.\\n\\\n'wipesync' => also sync each obfuscated byte to the device.\\n\\\nThe default mode is 'wipesync', but note it can be expensive.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\nCAUTION: shred assumes the file system and hardware overwrite data in place.\\n\\\nAlthough this is common, many platforms operate otherwise.  Also, backups\\n\\\nand mirrors may contain unremovable copies that will let a shredded file\\n\\\nbe recovered later.  See the GNU coreutils manual for details.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/*\n * Determine if pattern type is periodic or not.\n */\nstatic bool\nperiodic_pattern (int type)\n{\n  if (type <= 0)\n    return false;\n\n  unsigned char r[3];\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n\n  return (r[0] != r[1]) || (r[0] != r[2]);\n}\n\n/*\n * Fill a buffer with a fixed pattern.\n *\n * The buffer must be at least 3 bytes long, even if\n * size is less.  Larger sizes are filled exactly.\n */\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i <= size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n\n/*\n * Generate a 6-character (+ nul) pass name string\n * FIXME: allow translation of \"random\".\n */\n#define PASS_NAME_SIZE 7\nstatic void\npassname (unsigned char const *data, char name[PASS_NAME_SIZE])\n{\n  if (data)\n    sprintf (name, \"%02x%02x%02x\", data[0], data[1], data[2]);\n  else\n    memcpy (name, \"random\", PASS_NAME_SIZE);\n}\n\n/* Return true when it's ok to ignore an fsync or fdatasync\n   failure that set errno to ERRNO_VAL.  */\nstatic bool\nignorable_sync_errno (int errno_val)\n{\n  return (errno_val == EINVAL\n          || errno_val == EBADF\n          /* HP-UX does this */\n          || errno_val == EISDIR);\n}\n\n/* Request that all data for FD be transferred to the corresponding\n   storage device.  QNAME is the file name (quoted for colons).\n   Report any errors found.  Return 0 on success, -1\n   (setting errno) on failure.  It is not an error if fdatasync and/or\n   fsync is not supported for this file, or if the file is not a\n   writable file descriptor.  */\nstatic int\ndosync (int fd, char const *qname)\n{\n  int err;\n\n#if HAVE_FDATASYNC\n  if (fdatasync (fd) == 0)\n    return 0;\n  err = errno;\n  if ( ! ignorable_sync_errno (err))\n    {\n      error (0, err, _(\"%s: fdatasync failed\"), qname);\n      errno = err;\n      return -1;\n    }\n#endif\n\n  if (fsync (fd) == 0)\n    return 0;\n  err = errno;\n  if ( ! ignorable_sync_errno (err))\n    {\n      error (0, err, _(\"%s: fsync failed\"), qname);\n      errno = err;\n      return -1;\n    }\n\n  sync ();\n  return 0;\n}\n\n/* Turn on or off direct I/O mode for file descriptor FD, if possible.\n   Try to turn it on if ENABLE is true.  Otherwise, try to turn it off.  */\nstatic void\ndirect_mode (int fd, bool enable)\n{\n  if (O_DIRECT)\n    {\n      int fd_flags = fcntl (fd, F_GETFL);\n      if (0 < fd_flags)\n        {\n          int new_flags = (enable\n                           ? (fd_flags | O_DIRECT)\n                           : (fd_flags & ~O_DIRECT));\n          if (new_flags != fd_flags)\n            fcntl (fd, F_SETFL, new_flags);\n        }\n    }\n\n#if HAVE_DIRECTIO && defined DIRECTIO_ON && defined DIRECTIO_OFF\n  /* This is Solaris-specific.  */\n  directio (fd, enable ? DIRECTIO_ON : DIRECTIO_OFF);\n#endif\n}\n\n/* Rewind FD; its status is ST.  */\nstatic bool\ndorewind (int fd, struct stat const *st)\n{\n  if (S_ISCHR (st->st_mode))\n    {\n#if defined __linux__ && HAVE_SYS_MTIO_H\n      /* In the Linux kernel, lseek does not work on tape devices; it\n         returns a randomish value instead.  Try the low-level tape\n         rewind operation first.  */\n      struct mtop op;\n      op.mt_op = MTREW;\n      op.mt_count = 1;\n      if (ioctl (fd, MTIOCTOP, &op) == 0)\n        return true;\n#endif\n    }\n  off_t offset = lseek (fd, 0, SEEK_SET);\n  if (0 < offset)\n    errno = EINVAL;\n  return offset == 0;\n}\n\n/* By convention, negative sizes represent unknown values.  */\n\nstatic bool\nknown (off_t size)\n{\n  return 0 <= size;\n}\n\n/*\n * Do pass number K of N, writing *SIZEP bytes of the given pattern TYPE\n * to the file descriptor FD.  K and N are passed in only for verbose\n * progress message purposes.  If N == 0, no progress messages are printed.\n *\n * If *SIZEP == -1, the size is unknown, and it will be filled in as soon\n * as writing fails with ENOSPC.\n *\n * Return 1 on write error, -1 on other error, 0 on success.\n */\nstatic int\ndopass (int fd, struct stat const *st, char const *qname, off_t *sizep,\n        int type, struct randread_source *s,\n        unsigned long int k, unsigned long int n)\n{\n  off_t size = *sizep;\n  off_t offset;\t\t\t/* Current file position */\n  time_t thresh IF_LINT ( = 0);\t/* Time to maybe print next status update */\n  time_t now = 0;\t\t/* Current time */\n  size_t lim;\t\t\t/* Amount of data to try writing */\n  size_t soff;\t\t\t/* Offset into buffer for next write */\n  ssize_t ssize;\t\t/* Return value from write */\n\n  /* Fill pattern buffer.  Aligning it to a page so we can do direct I/O.  */\n  size_t page_size = getpagesize ();\n#define PERIODIC_OUTPUT_SIZE (60 * 1024)\n#define NONPERIODIC_OUTPUT_SIZE (64 * 1024)\n  static_assert (PERIODIC_OUTPUT_SIZE % 3 == 0);\n  size_t output_size = periodic_pattern (type)\n                       ? PERIODIC_OUTPUT_SIZE : NONPERIODIC_OUTPUT_SIZE;\n#define FILLPATTERN_SIZE (((output_size + 2) / 3) * 3) /* Multiple of 3 */\n  unsigned char *pbuf = xalignalloc (page_size, FILLPATTERN_SIZE);\n\n  char pass_string[PASS_NAME_SIZE];\t/* Name of current pass */\n  bool write_error = false;\n  bool other_error = false;\n\n  /* Printable previous offset into the file */\n  char previous_offset_buf[LONGEST_HUMAN_READABLE + 1];\n  char const *previous_human_offset;\n\n  /* As a performance tweak, avoid direct I/O for small sizes,\n     as it's just a performance rather then security consideration,\n     and direct I/O can often be unsupported for small non aligned sizes.  */\n  bool try_without_directio = 0 < size && size < output_size;\n  if (! try_without_directio)\n    direct_mode (fd, true);\n\n  if (! dorewind (fd, st))\n    {\n      error (0, errno, _(\"%s: cannot rewind\"), qname);\n      other_error = true;\n      goto free_pattern_mem;\n    }\n\n  /* Constant fill patterns need only be set up once. */\n  if (type >= 0)\n    {\n      lim = known (size) && size < FILLPATTERN_SIZE ? size : FILLPATTERN_SIZE;\n      fillpattern (type, pbuf, lim);\n      passname (pbuf, pass_string);\n    }\n  else\n    {\n      passname (0, pass_string);\n    }\n\n  /* Set position if first status update */\n  if (n)\n    {\n      error (0, 0, _(\"%s: pass %lu/%lu (%s)...\"), qname, k, n, pass_string);\n      thresh = time (nullptr) + VERBOSE_UPDATE;\n      previous_human_offset = \"\";\n    }\n\n  offset = 0;\n  while (true)\n    {\n      /* How much to write this time? */\n      lim = output_size;\n      if (known (size) && size - offset < output_size)\n        {\n          if (size < offset)\n            break;\n          lim = size - offset;\n          if (!lim)\n            break;\n        }\n      if (type < 0)\n        randread (s, pbuf, lim);\n      /* Loop to retry partial writes. */\n      for (soff = 0; soff < lim; soff += ssize)\n        {\n          ssize = write (fd, pbuf + soff, lim - soff);\n          if (ssize <= 0)\n            {\n              if (! known (size) && (ssize == 0 || errno == ENOSPC))\n                {\n                  /* We have found the end of the file.  */\n                  if (soff <= OFF_T_MAX - offset)\n                    *sizep = size = offset + soff;\n                  break;\n                }\n              else\n                {\n                  int errnum = errno;\n                  char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n\n                  /* Retry without direct I/O since this may not be supported\n                     at all on some (file) systems, or with the current size.\n                     I.e., a specified --size that is not aligned, or when\n                     dealing with slop at the end of a file with --exact.  */\n                  if (! try_without_directio && errno == EINVAL)\n                    {\n                      direct_mode (fd, false);\n                      ssize = 0;\n                      try_without_directio = true;\n                      continue;\n                    }\n                  error (0, errnum, _(\"%s: error writing at offset %s\"),\n                         qname, umaxtostr (offset + soff, buf));\n\n                  /* 'shred' is often used on bad media, before throwing it\n                     out.  Thus, it shouldn't give up on bad blocks.  This\n                     code works because lim is always a multiple of\n                     SECTOR_SIZE, except at the end.  This size constraint\n                     also enables direct I/O on some (file) systems.  */\n                  static_assert (PERIODIC_OUTPUT_SIZE % SECTOR_SIZE == 0);\n                  static_assert (NONPERIODIC_OUTPUT_SIZE % SECTOR_SIZE == 0);\n                  if (errnum == EIO && known (size)\n                      && (soff | SECTOR_MASK) < lim)\n                    {\n                      size_t soff1 = (soff | SECTOR_MASK) + 1;\n                      if (lseek (fd, offset + soff1, SEEK_SET) != -1)\n                        {\n                          /* Arrange to skip this block. */\n                          ssize = soff1 - soff;\n                          write_error = true;\n                          continue;\n                        }\n                      error (0, errno, _(\"%s: lseek failed\"), qname);\n                    }\n                  other_error = true;\n                  goto free_pattern_mem;\n                }\n            }\n        }\n\n      /* Okay, we have written \"soff\" bytes. */\n\n      if (OFF_T_MAX - offset < soff)\n        {\n          error (0, 0, _(\"%s: file too large\"), qname);\n          other_error = true;\n          goto free_pattern_mem;\n        }\n\n      offset += soff;\n\n      bool done = offset == size;\n\n      /* Time to print progress? */\n      if (n && ((done && *previous_human_offset)\n                || thresh <= (now = time (nullptr))))\n        {\n          char offset_buf[LONGEST_HUMAN_READABLE + 1];\n          char size_buf[LONGEST_HUMAN_READABLE + 1];\n          int human_progress_opts = (human_autoscale | human_SI\n                                     | human_base_1024 | human_B);\n          char const *human_offset\n            = human_readable (offset, offset_buf,\n                              human_floor | human_progress_opts, 1, 1);\n\n          if (done || !STREQ (previous_human_offset, human_offset))\n            {\n              if (! known (size))\n                error (0, 0, _(\"%s: pass %lu/%lu (%s)...%s\"),\n                       qname, k, n, pass_string, human_offset);\n              else\n                {\n                  uintmax_t off = offset;\n                  int percent = (size == 0\n                                 ? 100\n                                 : (off <= TYPE_MAXIMUM (uintmax_t) / 100\n                                    ? off * 100 / size\n                                    : off / (size / 100)));\n                  char const *human_size\n                    = human_readable (size, size_buf,\n                                      human_ceiling | human_progress_opts,\n                                      1, 1);\n                  if (done)\n                    human_offset = human_size;\n                  error (0, 0, _(\"%s: pass %lu/%lu (%s)...%s/%s %d%%\"),\n                         qname, k, n, pass_string, human_offset, human_size,\n                         percent);\n                }\n\n              strcpy (previous_offset_buf, human_offset);\n              previous_human_offset = previous_offset_buf;\n              thresh = now + VERBOSE_UPDATE;\n\n              /*\n               * Force periodic syncs to keep displayed progress accurate\n               * FIXME: Should these be present even if -v is not enabled,\n               * to keep the buffer cache from filling with dirty pages?\n               * It's a common problem with programs that do lots of writes,\n               * like mkfs.\n               */\n              if (dosync (fd, qname) != 0)\n                {\n                  if (errno != EIO)\n                    {\n                      other_error = true;\n                      goto free_pattern_mem;\n                    }\n                  write_error = true;\n                }\n            }\n        }\n    }\n\n  /* Force what we just wrote to hit the media. */\n  if (dosync (fd, qname) != 0)\n    {\n      if (errno != EIO)\n        {\n          other_error = true;\n          goto free_pattern_mem;\n        }\n      write_error = true;\n    }\n\nfree_pattern_mem:\n  alignfree (pbuf);\n\n  return other_error ? -1 : write_error;\n}\n\n/*\n * The passes start and end with a random pass, and the passes in between\n * are done in random order.  The idea is to deprive someone trying to\n * reverse the process of knowledge of the overwrite patterns, so they\n * have the additional step of figuring out what was done to the device\n * before they can try to reverse or cancel it.\n *\n * First, all possible 1-bit patterns.  There are two of them.\n * Then, all possible 2-bit patterns.  There are four, but the two\n * which are also 1-bit patterns can be omitted.\n * Then, all possible 3-bit patterns.  Likewise, 8-2 = 6.\n * Then, all possible 4-bit patterns.  16-4 = 12.\n *\n * The basic passes are:\n * 1-bit: 0x000, 0xFFF\n * 2-bit: 0x555, 0xAAA\n * 3-bit: 0x249, 0x492, 0x924, 0x6DB, 0xB6D, 0xDB6 (+ 1-bit)\n *        100100100100         110110110110\n *           9   2   4            D   B   6\n * 4-bit: 0x111, 0x222, 0x333, 0x444, 0x666, 0x777,\n *        0x888, 0x999, 0xBBB, 0xCCC, 0xDDD, 0xEEE (+ 1-bit, 2-bit)\n * Adding three random passes at the beginning, middle and end\n * produces the default 25-pass structure.\n *\n * The next extension would be to 5-bit and 6-bit patterns.\n * There are 30 uncovered 5-bit patterns and 64-8-2 = 46 uncovered\n * 6-bit patterns, so they would increase the time required\n * significantly.  4-bit patterns are enough for most purposes.\n *\n * The main gotcha is that this would require a trickier encoding,\n * since lcm(2,3,4) = 12 bits is easy to fit into an int, but\n * lcm(2,3,4,5) = 60 bits is not.\n *\n * One extension that is included is to complement the first bit in each\n * 512-byte block, to alter the phase of the encoded data in the more\n * complex encodings.  This doesn't apply to MFM, so the 1-bit patterns\n * are considered part of the 3-bit ones and the 2-bit patterns are\n * considered part of the 4-bit patterns.\n *\n *\n * How does the generalization to variable numbers of passes work?\n *\n * Here's how...\n * Have an ordered list of groups of passes.  Each group is a set.\n * Take as many groups as will fit, plus a random subset of the\n * last partial group, and place them into the passes list.\n * Then shuffle the passes list into random order and use that.\n *\n * One extra detail: if we can't include a large enough fraction of the\n * last group to be interesting, then just substitute random passes.\n *\n * If you want more passes than the entire list of groups can\n * provide, just start repeating from the beginning of the list.\n */\nstatic int const\n  patterns[] =\n{\n  -2,\t\t\t\t/* 2 random passes */\n  2, 0x000, 0xFFF,\t\t/* 1-bit */\n  2, 0x555, 0xAAA,\t\t/* 2-bit */\n  -1,\t\t\t\t/* 1 random pass */\n  6, 0x249, 0x492, 0x6DB, 0x924, 0xB6D, 0xDB6,\t/* 3-bit */\n  12, 0x111, 0x222, 0x333, 0x444, 0x666, 0x777,\n  0x888, 0x999, 0xBBB, 0xCCC, 0xDDD, 0xEEE,\t/* 4-bit */\n  -1,\t\t\t\t/* 1 random pass */\n        /* The following patterns have the first bit per block flipped */\n  8, 0x1000, 0x1249, 0x1492, 0x16DB, 0x1924, 0x1B6D, 0x1DB6, 0x1FFF,\n  14, 0x1111, 0x1222, 0x1333, 0x1444, 0x1555, 0x1666, 0x1777,\n  0x1888, 0x1999, 0x1AAA, 0x1BBB, 0x1CCC, 0x1DDD, 0x1EEE,\n  -1,\t\t\t\t/* 1 random pass */\n  0\t\t\t\t/* End */\n};\n\n/*\n * Generate a random wiping pass pattern with num passes.\n * This is a two-stage process.  First, the passes to include\n * are chosen, and then they are shuffled into the desired\n * order.\n */\nstatic void\ngenpattern (int *dest, size_t num, struct randint_source *s)\n{\n  size_t randpasses;\n  int const *p;\n  int *d;\n  size_t n;\n  size_t accum, top, swap;\n  int k;\n\n  if (!num)\n    return;\n\n  /* Stage 1: choose the passes to use */\n  p = patterns;\n  randpasses = 0;\n  d = dest;\t\t\t/* Destination for generated pass list */\n  n = num;\t\t\t/* Passes remaining to fill */\n\n  while (true)\n    {\n      k = *p++;\t\t\t/* Block descriptor word */\n      if (!k)\n        {\t\t\t/* Loop back to the beginning */\n          p = patterns;\n        }\n      else if (k < 0)\n        {\t\t\t/* -k random passes */\n          k = -k;\n          if ((size_t) k >= n)\n            {\n              randpasses += n;\n              break;\n            }\n          randpasses += k;\n          n -= k;\n        }\n      else if ((size_t) k <= n)\n        {\t\t\t/* Full block of patterns */\n          memcpy (d, p, k * sizeof (int));\n          p += k;\n          d += k;\n          n -= k;\n        }\n      else if (n < 2 || 3 * n < (size_t) k)\n        {\t\t\t/* Finish with random */\n          randpasses += n;\n          break;\n        }\n      else\n        {\t\t\t/* Pad out with n of the k available */\n          do\n            {\n              if (n == (size_t) k || randint_choose (s, k) < n)\n                {\n                  *d++ = *p;\n                  n--;\n                }\n              p++;\n              k--;\n            }\n          while (n);\n          break;\n        }\n    }\n  top = num - randpasses;\t/* Top of initialized data */\n  /* affirm (d == dest + top); */\n\n  /*\n   * We now have fixed patterns in the dest buffer up to\n   * \"top\", and we need to scramble them, with \"randpasses\"\n   * random passes evenly spaced among them.\n   *\n   * We want one at the beginning, one at the end, and\n   * evenly spaced in between.  To do this, we basically\n   * use Bresenham's line draw (a.k.a DDA) algorithm\n   * to draw a line with slope (randpasses-1)/(num-1).\n   * (We use a positive accumulator and count down to\n   * do this.)\n   *\n   * So for each desired output value, we do the following:\n   * - If it should be a random pass, copy the pass type\n   *   to top++, out of the way of the other passes, and\n   *   set the current pass to -1 (random).\n   * - If it should be a normal pattern pass, choose an\n   *   entry at random between here and top-1 (inclusive)\n   *   and swap the current entry with that one.\n   */\n  randpasses--;\t\t\t/* To speed up later math */\n  accum = randpasses;\t\t/* Bresenham DDA accumulator */\n  for (n = 0; n < num; n++)\n    {\n      if (accum <= randpasses)\n        {\n          accum += num - 1;\n          dest[top++] = dest[n];\n          dest[n] = -1;\n        }\n      else\n        {\n          swap = n + randint_choose (s, top - n);\n          k = dest[n];\n          dest[n] = dest[swap];\n          dest[swap] = k;\n        }\n      accum -= randpasses;\n    }\n  /* affirm (top == num); */\n}\n\n/*\n * The core routine to actually do the work.  This overwrites the first\n * size bytes of the given fd.  Return true if successful.\n */\nstatic bool\ndo_wipefd (int fd, char const *qname, struct randint_source *s,\n           struct Options const *flags)\n{\n  size_t i;\n  struct stat st;\n  off_t size;\t\t/* Size to write, size to read */\n  off_t i_size = 0;\t/* For small files, initial size to overwrite inode */\n  unsigned long int n;\t/* Number of passes for printing purposes */\n  int *passarray;\n  bool ok = true;\n  struct randread_source *rs;\n\n  n = 0;\t\t/* dopass takes n == 0 to mean \"don't print progress\" */\n  if (flags->verbose)\n    n = flags->n_iterations + flags->zero_fill;\n\n  if (fstat (fd, &st))\n    {\n      error (0, errno, _(\"%s: fstat failed\"), qname);\n      return false;\n    }\n\n  /* If we know that we can't possibly shred the file, give up now.\n     Otherwise, we may go into an infinite loop writing data before we\n     find that we can't rewind the device.  */\n  if ((S_ISCHR (st.st_mode) && isatty (fd))\n      || S_ISFIFO (st.st_mode)\n      || S_ISSOCK (st.st_mode))\n    {\n      error (0, 0, _(\"%s: invalid file type\"), qname);\n      return false;\n    }\n  else if (S_ISREG (st.st_mode) && st.st_size < 0)\n    {\n      error (0, 0, _(\"%s: file has negative size\"), qname);\n      return false;\n    }\n\n  /* Allocate pass array */\n  passarray = xnmalloc (flags->n_iterations, sizeof *passarray);\n\n  size = flags->size;\n  if (size == -1)\n    {\n      if (S_ISREG (st.st_mode))\n        {\n          size = st.st_size;\n\n          if (! flags->exact)\n            {\n              /* Round up to the nearest block size to clear slack space.  */\n              off_t remainder = size % ST_BLKSIZE (st);\n              if (size && size < ST_BLKSIZE (st))\n                i_size = size;\n              if (remainder != 0)\n                {\n                  off_t size_incr = ST_BLKSIZE (st) - remainder;\n                  size += MIN (size_incr, OFF_T_MAX - size);\n                }\n            }\n        }\n      else\n        {\n          /* The behavior of lseek is unspecified, but in practice if\n             it returns a positive number that's the size of this\n             device.  */\n          size = lseek (fd, 0, SEEK_END);\n          if (size <= 0)\n            {\n               \n              size = -1;\n            }\n        }\n    }\n  else if (S_ISREG (st.st_mode)\n           && st.st_size < MIN (ST_BLKSIZE (st), size))\n    i_size = st.st_size;\n\n   \n  genpattern (passarray, flags->n_iterations, s);\n\n  rs = randint_get_source (s);\n\n  while (true)\n    {\n      off_t pass_size;\n      unsigned long int pn = n;\n\n      if (i_size)\n        {\n          pass_size = i_size;\n          i_size = 0;\n          pn = 0;\n        }\n      else if (size)\n        {\n          pass_size = size;\n          size = 0;\n        }\n       \n      else\n        break;\n\n      for (i = 0; i < flags->n_iterations + flags->zero_fill; i++)\n        {\n          int err = 0;\n          int type = i < flags->n_iterations ? passarray[i] : 0;\n\n          err = dopass (fd, &st, qname, &pass_size, type, rs, i + 1, pn);\n\n          if (err)\n            {\n              ok = false;\n              if (err < 0)\n                goto wipefd_out;\n            }\n        }\n    }\n\n   \n\n  if (flags->remove_file && ftruncate (fd, 0) != 0\n      && (S_ISREG (st.st_mode) || S_TYPEISSHM (&st)))\n    {\n      error (0, errno, _(\"%s: error truncating\"), qname);\n      ok = false;\n      goto wipefd_out;\n    }\n\nwipefd_out:\n  free (passarray);\n  return ok;\n}\n\n \nstatic bool\nwipefd (int fd, char const *qname, struct randint_source *s,\n        struct Options const *flags)\n{\n  int fd_flags = fcntl (fd, F_GETFL);\n\n  if (fd_flags < 0)\n    {\n      error (0, errno, _(\"%s: fcntl failed\"), qname);\n      return false;\n    }\n  if (fd_flags & O_APPEND)\n    {\n      error (0, 0, _(\"%s: cannot shred append-only file descriptor\"), qname);\n      return false;\n    }\n  return do_wipefd (fd, qname, s, flags);\n}\n\n \n\n \nstatic char const nameset[] =\n\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.\";\n\n \n\nstatic bool\nincname (char *name, size_t len)\n{\n  while (len--)\n    {\n      char const *p = strchr (nameset, name[len]);\n\n       \n\n       \n      if (p[1])\n        {\n          name[len] = p[1];\n          return true;\n        }\n\n       \n      name[len] = nameset[0];\n    }\n\n  return false;\n}\n\n \nstatic bool\nwipename (char *oldname, char const *qoldname, struct Options const *flags)\n{\n  char *newname = xstrdup (oldname);\n  char *base = last_component (newname);\n  char *dir = dir_name (newname);\n  char *qdir = xstrdup (quotef (dir));\n  bool first = true;\n  bool ok = true;\n  int dir_fd = -1;\n\n  if (flags->remove_file == remove_wipesync)\n    dir_fd = open (dir, O_RDONLY | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n\n  if (flags->verbose)\n    error (0, 0, _(\"%s: removing\"), qoldname);\n\n  if (flags->remove_file != remove_unlink)\n    for (size_t len = base_len (base); len != 0; len--)\n      {\n        memset (base, nameset[0], len);\n        base[len] = 0;\n        bool rename_ok;\n        while (! (rename_ok = (renameatu (AT_FDCWD, oldname, AT_FDCWD, newname,\n                                          RENAME_NOREPLACE)\n                               == 0))\n               && errno == EEXIST && incname (base, len))\n          continue;\n        if (rename_ok)\n          {\n            if (0 <= dir_fd && dosync (dir_fd, qdir) != 0)\n              ok = false;\n            if (flags->verbose)\n              {\n                 \n                char const *old = first ? qoldname : oldname;\n                error (0, 0,\n                       _(\"%s: renamed to %s\"), old, newname);\n                first = false;\n              }\n            memcpy (oldname + (base - newname), base, len + 1);\n          }\n      }\n\n  if (unlink (oldname) != 0)\n    {\n      error (0, errno, _(\"%s: failed to remove\"), qoldname);\n      ok = false;\n    }\n  else if (flags->verbose)\n    error (0, 0, _(\"%s: removed\"), qoldname);\n  if (0 <= dir_fd)\n    {\n      if (dosync (dir_fd, qdir) != 0)\n        ok = false;\n      if (close (dir_fd) != 0)\n        {\n          error (0, errno, _(\"%s: failed to close\"), qdir);\n          ok = false;\n        }\n    }\n  free (newname);\n  free (dir);\n  free (qdir);\n  return ok;\n}\n\n \nstatic bool\nwipefile (char *name, char const *qname,\n          struct randint_source *s, struct Options const *flags)\n{\n  bool ok;\n  int fd;\n\n  fd = open (name, O_WRONLY | O_NOCTTY | O_BINARY);\n  if (fd < 0\n      && (errno == EACCES && flags->force)\n      && chmod (name, S_IWUSR) == 0)\n    fd = open (name, O_WRONLY | O_NOCTTY | O_BINARY);\n  if (fd < 0)\n    {\n      error (0, errno, _(\"%s: failed to open for writing\"), qname);\n      return false;\n    }\n\n  ok = do_wipefd (fd, qname, s, flags);\n  if (close (fd) != 0)\n    {\n      error (0, errno, _(\"%s: failed to close\"), qname);\n      ok = false;\n    }\n  if (ok && flags->remove_file)\n    ok = wipename (name, qname, flags);\n  return ok;\n}\n\n\n \nstatic struct randint_source *randint_source;\n\n \nstatic void\nclear_random_data (void)\n{\n  randint_all_free (randint_source);\n}\n\n\nint\nmain (int argc, char **argv)\n{\n  bool ok = true;\n  struct Options flags = { 0, };\n  char **file;\n  int n_files;\n  int c;\n  int i;\n  char const *random_source = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  flags.n_iterations = DEFAULT_PASSES;\n  flags.size = -1;\n\n  while ((c = getopt_long (argc, argv, \"fn:s:uvxz\", long_opts, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'f':\n          flags.force = true;\n          break;\n\n        case 'n':\n          flags.n_iterations = xdectoumax (optarg, 0,\n                                           MIN (ULONG_MAX,\n                                                SIZE_MAX / sizeof (int)), \"\",\n                                           _(\"invalid number of passes\"), 0);\n          break;\n\n        case RANDOM_SOURCE_OPTION:\n          if (random_source && !STREQ (random_source, optarg))\n            error (EXIT_FAILURE, 0, _(\"multiple random sources specified\"));\n          random_source = optarg;\n          break;\n\n        case 'u':\n          if (optarg == nullptr)\n            flags.remove_file = remove_wipesync;\n          else\n            flags.remove_file = XARGMATCH (\"--remove\", optarg,\n                                           remove_args, remove_methods);\n          break;\n\n        case 's':\n          flags.size = xnumtoumax (optarg, 0, 0, OFF_T_MAX, \"cbBkKMGTPEZYRQ0\",\n                                   _(\"invalid file size\"), 0);\n          break;\n\n        case 'v':\n          flags.verbose = true;\n          break;\n\n        case 'x':\n          flags.exact = true;\n          break;\n\n        case 'z':\n          flags.zero_fill = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  file = argv + optind;\n  n_files = argc - optind;\n\n  if (n_files == 0)\n    {\n      error (0, 0, _(\"missing file operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  randint_source = randint_all_new (random_source, SIZE_MAX);\n  if (! randint_source)\n    error (EXIT_FAILURE, errno, \"%s\",\n           quotef (random_source ? random_source : \"getrandom\"));\n  atexit (clear_random_data);\n\n  for (i = 0; i < n_files; i++)\n    {\n      char *qname = xstrdup (quotef (file[i]));\n      if (STREQ (file[i], \"-\"))\n        {\n          ok &= wipefd (STDOUT_FILENO, qname, randint_source, &flags);\n        }\n      else\n        {\n           \n          ok &= wipefile (file[i], qname, randint_source, &flags);\n        }\n      free (qname);\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}