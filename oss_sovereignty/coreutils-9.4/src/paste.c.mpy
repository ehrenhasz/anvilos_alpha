{
  "module_name": "paste.c",
  "hash_id": "403e2a67f87b5e69369ca8cb82346a3d7924b818761643ac04cd85b68d3b2471",
  "original_prompt": "Ingested from coreutils-9.4/src/paste.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"fadvise.h\"\n\n \n#define PROGRAM_NAME \"paste\"\n\n#define AUTHORS \\\n  proper_name (\"David M. Ihnat\"), \\\n  proper_name (\"David MacKenzie\")\n\n \n#define EMPTY_DELIM '\\0'\n\n \nstatic bool have_read_stdin;\n\n \nstatic bool serial_merge;\n\n \nstatic char *delims;\n\n \nstatic char const *delim_end;\n\nstatic unsigned char line_delim = '\\n';\n\nstatic struct option const longopts[] =\n{\n  {\"serial\", no_argument, nullptr, 's'},\n  {\"delimiters\", required_argument, nullptr, 'd'},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nstatic int\ncollapse_escapes (char const *strptr)\n{\n  char *strout = xstrdup (strptr);\n  bool backslash_at_end = false;\n\n  delims = strout;\n\n  while (*strptr)\n    {\n      if (*strptr != '\\\\')\t \n        *strout++ = *strptr++;\t \n      else\n        {\n          switch (*++strptr)\n            {\n            case '0':\n              *strout++ = EMPTY_DELIM;\n              break;\n\n            case 'b':\n              *strout++ = '\\b';\n              break;\n\n            case 'f':\n              *strout++ = '\\f';\n              break;\n\n            case 'n':\n              *strout++ = '\\n';\n              break;\n\n            case 'r':\n              *strout++ = '\\r';\n              break;\n\n            case 't':\n              *strout++ = '\\t';\n              break;\n\n            case 'v':\n              *strout++ = '\\v';\n              break;\n\n            case '\\\\':\n              *strout++ = '\\\\';\n              break;\n\n            case '\\0':\n              backslash_at_end = true;\n              goto done;\n\n            default:\n              *strout++ = *strptr;\n              break;\n            }\n          strptr++;\n        }\n    }\n\n done:\n\n  delim_end = strout;\n  return backslash_at_end ? 1 : 0;\n}\n\n \n\nstatic inline void\nxputchar (char c)\n{\n  if (putchar (c) < 0)\n    write_error ();\n}\n\n \n\nstatic bool\npaste_parallel (size_t nfiles, char **fnamptr)\n{\n  bool ok = true;\n   \n  char *delbuf = xmalloc (nfiles + 2);\n\n   \n  FILE **fileptr = xnmalloc (nfiles + 1, sizeof *fileptr);\n\n   \n  size_t files_open;\n\n   \n  bool opened_stdin = false;\n\n   \n\n  for (files_open = 0; files_open < nfiles; ++files_open)\n    {\n      if (STREQ (fnamptr[files_open], \"-\"))\n        {\n          have_read_stdin = true;\n          fileptr[files_open] = stdin;\n        }\n      else\n        {\n          fileptr[files_open] = fopen (fnamptr[files_open], \"r\");\n          if (fileptr[files_open] == nullptr)\n            error (EXIT_FAILURE, errno, \"%s\", quotef (fnamptr[files_open]));\n          else if (fileno (fileptr[files_open]) == STDIN_FILENO)\n            opened_stdin = true;\n          fadvise (fileptr[files_open], FADVISE_SEQUENTIAL);\n        }\n    }\n\n  if (opened_stdin && have_read_stdin)\n    error (EXIT_FAILURE, 0, _(\"standard input is closed\"));\n\n   \n\n  while (files_open)\n    {\n       \n      bool somedone = false;\n      char const *delimptr = delims;\n      size_t delims_saved = 0;\t \n\n      for (size_t i = 0; i < nfiles && files_open; i++)\n        {\n          int chr;\t\t\t \n          int err;\t\t\t \n          bool sometodo = false;\t \n\n          if (fileptr[i])\n            {\n              chr = getc (fileptr[i]);\n              err = errno;\n              if (chr != EOF && delims_saved)\n                {\n                  if (fwrite (delbuf, 1, delims_saved, stdout) != delims_saved)\n                    write_error ();\n                  delims_saved = 0;\n                }\n\n              while (chr != EOF)\n                {\n                  sometodo = true;\n                  if (chr == line_delim)\n                    break;\n                  xputchar (chr);\n                  chr = getc (fileptr[i]);\n                  err = errno;\n                }\n            }\n\n          if (! sometodo)\n            {\n               \n              if (fileptr[i])\n                {\n                  if (!ferror (fileptr[i]))\n                    err = 0;\n                  if (fileptr[i] == stdin)\n                    clearerr (fileptr[i]);  \n                  else if (fclose (fileptr[i]) == EOF && !err)\n                    err = errno;\n                  if (err)\n                    {\n                      error (0, err, \"%s\", quotef (fnamptr[i]));\n                      ok = false;\n                    }\n\n                  fileptr[i] = nullptr;\n                  files_open--;\n                }\n\n              if (i + 1 == nfiles)\n                {\n                   \n                  if (somedone)\n                    {\n                       \n                      if (delims_saved)\n                        {\n                          if (fwrite (delbuf, 1, delims_saved, stdout)\n                              != delims_saved)\n                            write_error ();\n                          delims_saved = 0;\n                        }\n                      xputchar (line_delim);\n                    }\n                  continue;\t \n                }\n              else\n                {\n                   \n                  if (*delimptr != EMPTY_DELIM)\n                    delbuf[delims_saved++] = *delimptr;\n                  if (++delimptr == delim_end)\n                    delimptr = delims;\n                }\n            }\n          else\n            {\n               \n              somedone = true;\n\n               \n              if (i + 1 != nfiles)\n                {\n                  if (chr != line_delim && chr != EOF)\n                    xputchar (chr);\n                  if (*delimptr != EMPTY_DELIM)\n                    xputchar (*delimptr);\n                  if (++delimptr == delim_end)\n                    delimptr = delims;\n                }\n              else\n                {\n                   \n                  char c = (chr == EOF ? line_delim : chr);\n                  xputchar (c);\n                }\n            }\n        }\n    }\n  free (fileptr);\n  free (delbuf);\n  return ok;\n}\n\n \n\nstatic bool\npaste_serial (size_t nfiles, char **fnamptr)\n{\n  bool ok = true;\t \n  int charnew, charold;  \n  char const *delimptr;\t \n  FILE *fileptr;\t \n\n  for (; nfiles; nfiles--, fnamptr++)\n    {\n      int saved_errno;\n      bool is_stdin = STREQ (*fnamptr, \"-\");\n      if (is_stdin)\n        {\n          have_read_stdin = true;\n          fileptr = stdin;\n        }\n      else\n        {\n          fileptr = fopen (*fnamptr, \"r\");\n          if (fileptr == nullptr)\n            {\n              error (0, errno, \"%s\", quotef (*fnamptr));\n              ok = false;\n              continue;\n            }\n          fadvise (fileptr, FADVISE_SEQUENTIAL);\n        }\n\n      delimptr = delims;\t \n\n      charold = getc (fileptr);\n      saved_errno = errno;\n      if (charold != EOF)\n        {\n           \n\n          while ((charnew = getc (fileptr)) != EOF)\n            {\n               \n              if (charold == line_delim)\n                {\n                  if (*delimptr != EMPTY_DELIM)\n                    xputchar (*delimptr);\n\n                  if (++delimptr == delim_end)\n                    delimptr = delims;\n                }\n              else\n                xputchar (charold);\n\n              charold = charnew;\n            }\n          saved_errno = errno;\n\n           \n          xputchar (charold);\n        }\n\n      if (charold != line_delim)\n        xputchar (line_delim);\n\n      if (!ferror (fileptr))\n        saved_errno = 0;\n      if (is_stdin)\n        clearerr (fileptr);\t \n      else if (fclose (fileptr) != 0 && !saved_errno)\n        saved_errno = errno;\n      if (saved_errno)\n        {\n          error (0, saved_errno, \"%s\", quotef (*fnamptr));\n          ok = false;\n        }\n    }\n  return ok;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nWrite lines consisting of the sequentially corresponding lines from\\n\\\neach FILE, separated by TABs, to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\\n\\\n  -s, --serial            paste one file at a time instead of in parallel\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      /* FIXME: add a couple of examples.  */\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  char const *delim_arg = \"\\t\";\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  have_read_stdin = false;\n  serial_merge = false;\n\n  while ((optc = getopt_long (argc, argv, \"d:sz\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'd':\n          /* Delimiter character(s). */\n          delim_arg = (optarg[0] == '\\0' ? \"\\\\0\" : optarg);\n          break;\n\n        case 's':\n          serial_merge = true;\n          break;\n\n        case 'z':\n          line_delim = '\\0';\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  int nfiles = argc - optind;\n  if (nfiles == 0)\n    {\n      argv[optind] = bad_cast (\"-\");\n      nfiles++;\n    }\n\n  if (collapse_escapes (delim_arg))\n    {\n      /* Don't use the quote() quoting style, because that would double the\n         number of displayed backslashes, making the diagnostic look bogus.  */\n      error (EXIT_FAILURE, 0,\n             _(\"delimiter list ends with an unescaped backslash: %s\"),\n             quotearg_n_style_colon (0, c_maybe_quoting_style, delim_arg));\n    }\n\n  bool ok = ((serial_merge ? paste_serial : paste_parallel)\n             (nfiles, &argv[optind]));\n\n  free (delims);\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    error (EXIT_FAILURE, errno, \"-\");\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}