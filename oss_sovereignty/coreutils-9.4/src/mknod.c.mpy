{
  "module_name": "mknod.c",
  "hash_id": "0300545f317c5efe9d0e05e5e7c81d23372ac4bc38dfd6195cf19aa85ed36f20",
  "original_prompt": "Ingested from coreutils-9.4/src/mknod.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <selinux/label.h>\n\n#include \"system.h\"\n#include \"modechange.h\"\n#include \"quote.h\"\n#include \"selinux.h\"\n#include \"smack.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"mknod\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic struct option const longopts[] =\n{\n  {GETOPT_SELINUX_CONTEXT_OPTION_DECL},\n  {\"mode\", required_argument, nullptr, 'm'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\\n\"),\n              program_name);\n      fputs (_(\"\\\nCreate the special file NAME of the given TYPE.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -Z                   set the SELinux security context to default type\\n\\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n\\\n                         or SMACK security context to CTX\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nBoth MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\\n\\\nmust be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\\n\\\nit is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\\n\\\notherwise, as decimal.  TYPE may be:\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  b      create a block (buffered) special file\\n\\\n  c, u   create a character (unbuffered) special file\\n\\\n  p      create a FIFO\\n\\\n\"), stdout);\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  mode_t newmode;\n  char const *specified_mode = nullptr;\n  int optc;\n  size_t expected_operands;\n  mode_t node_type;\n  char const *scontext = nullptr;\n  struct selabel_handle *set_security_context = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"m:Z\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'm':\n          specified_mode = optarg;\n          break;\n        case 'Z':\n          if (is_smack_enabled ())\n            {\n              /* We don't yet support -Z to restore context with SMACK.  */\n              scontext = optarg;\n            }\n          else if (is_selinux_enabled () > 0)\n            {\n              if (optarg)\n                scontext = optarg;\n              else\n                {\n                  set_security_context = selabel_open (SELABEL_CTX_FILE,\n                                                       nullptr, 0);\n                  if (! set_security_context)\n                    error (0, errno, _(\"warning: ignoring --context\"));\n                }\n            }\n          else if (optarg)\n            {\n              error (0, 0,\n                     _(\"warning: ignoring --context; \"\n                       \"it requires an SELinux/SMACK-enabled kernel\"));\n            }\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  newmode = MODE_RW_UGO;\n  if (specified_mode)\n    {\n      mode_t umask_value;\n      struct mode_change *change = mode_compile (specified_mode);\n      if (!change)\n        error (EXIT_FAILURE, 0, _(\"invalid mode\"));\n      umask_value = umask (0);\n      umask (umask_value);\n      newmode = mode_adjust (newmode, false, umask_value, change, nullptr);\n      free (change);\n      if (newmode & ~S_IRWXUGO)\n        error (EXIT_FAILURE, 0,\n               _(\"mode must specify only file permission bits\"));\n    }\n\n  /* If the number of arguments is 0 or 1,\n     or (if it's 2 or more and the second one starts with 'p'), then there\n     must be exactly two operands.  Otherwise, there must be four.  */\n  expected_operands = (argc <= optind\n                       || (optind + 1 < argc && argv[optind + 1][0] == 'p')\n                       ? 2 : 4);\n\n  if (argc - optind < expected_operands)\n    {\n      if (argc <= optind)\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      if (expected_operands == 4 && argc - optind == 2)\n        fprintf (stderr, \"%s\\n\",\n                 _(\"Special files require major and minor device numbers.\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (expected_operands < argc - optind)\n    {\n      error (0, 0, _(\"extra operand %s\"),\n             quote (argv[optind + expected_operands]));\n      if (expected_operands == 2 && argc - optind == 4)\n        fprintf (stderr, \"%s\\n\",\n                 _(\"Fifos do not have major and minor device numbers.\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (scontext)\n    {\n      int ret = 0;\n      if (is_smack_enabled ())\n        ret = smack_set_label_for_self (scontext);\n      else\n        ret = setfscreatecon (scontext);\n\n      if (ret < 0)\n        error (EXIT_FAILURE, errno,\n               _(\"failed to set default file creation context to %s\"),\n               quote (scontext));\n    }\n\n  /* Only check the first character, to allow mnemonic usage like\n     'mknod /dev/rst0 character 18 0'. */\n\n  switch (argv[optind + 1][0])\n    {\n    case 'b':\t\t\t/* 'block' or 'buffered' */\n#ifndef S_IFBLK\n      error (EXIT_FAILURE, 0, _(\"block special files not supported\"));\n#else\n      node_type = S_IFBLK;\n#endif\n      goto block_or_character;\n\n    case 'c':\t\t\t/* 'character' */\n    case 'u':\t\t\t/* 'unbuffered' */\n#ifndef S_IFCHR\n      error (EXIT_FAILURE, 0, _(\"character special files not supported\"));\n#else\n      node_type = S_IFCHR;\n#endif\n      goto block_or_character;\n\n    block_or_character:\n      {\n        char const *s_major = argv[optind + 2];\n        char const *s_minor = argv[optind + 3];\n        uintmax_t i_major, i_minor;\n        dev_t device;\n\n        if (xstrtoumax (s_major, nullptr, 0, &i_major, \"\") != LONGINT_OK\n            || i_major != (major_t) i_major)\n          error (EXIT_FAILURE, 0,\n                 _(\"invalid major device number %s\"), quote (s_major));\n\n        if (xstrtoumax (s_minor, nullptr, 0, &i_minor, \"\") != LONGINT_OK\n            || i_minor != (minor_t) i_minor)\n          error (EXIT_FAILURE, 0,\n                 _(\"invalid minor device number %s\"), quote (s_minor));\n\n        device = makedev (i_major, i_minor);\n#ifdef NODEV\n        if (device == NODEV)\n          error (EXIT_FAILURE, 0, _(\"invalid device %s %s\"),\n                 s_major, s_minor);\n#endif\n\n        if (set_security_context)\n          defaultcon (set_security_context, argv[optind], node_type);\n\n        if (mknod (argv[optind], newmode | node_type, device) != 0)\n          error (EXIT_FAILURE, errno, \"%s\", quotef (argv[optind]));\n      }\n      break;\n\n    case 'p':\t\t\t/* 'pipe' */\n      if (set_security_context)\n        defaultcon (set_security_context, argv[optind], S_IFIFO);\n      if (mkfifo (argv[optind], newmode) != 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (argv[optind]));\n      break;\n\n    default:\n      error (0, 0, _(\"invalid device type %s\"), quote (argv[optind + 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (specified_mode && lchmod (argv[optind], newmode) != 0)\n    error (EXIT_FAILURE, errno, _(\"cannot set permissions of %s\"),\n           quoteaf (argv[optind]));\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}