{
  "module_name": "copy.c",
  "hash_id": "58aa67c886a6d03c7a9fb4e3323c9fdff8ca4de878fe14ee684e26c5e42f58e0",
  "original_prompt": "Ingested from coreutils-9.4/src/copy.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdckdint.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <selinux/selinux.h>\n\n#if HAVE_HURD_H\n# include <hurd.h>\n#endif\n#if HAVE_PRIV_H\n# include <priv.h>\n#endif\n\n#include \"system.h\"\n#include \"acl.h\"\n#include \"alignalloc.h\"\n#include \"assure.h\"\n#include \"backupfile.h\"\n#include \"buffer-lcm.h\"\n#include \"canonicalize.h\"\n#include \"copy.h\"\n#include \"cp-hash.h\"\n#include \"fadvise.h\"\n#include \"fcntl--.h\"\n#include \"file-set.h\"\n#include \"filemode.h\"\n#include \"filenamecat.h\"\n#include \"force-link.h\"\n#include \"full-write.h\"\n#include \"hash.h\"\n#include \"hash-triple.h\"\n#include \"ignore-value.h\"\n#include \"ioblksize.h\"\n#include \"quote.h\"\n#include \"renameatu.h\"\n#include \"root-uid.h\"\n#include \"same.h\"\n#include \"savedir.h\"\n#include \"stat-size.h\"\n#include \"stat-time.h\"\n#include \"utimecmp.h\"\n#include \"utimens.h\"\n#include \"write-any-file.h\"\n#include \"areadlink.h\"\n#include \"yesno.h\"\n#include \"selinux.h\"\n\n#ifndef USE_XATTR\n# define USE_XATTR false\n#endif\n\n#if USE_XATTR\n# include <attr/error_context.h>\n# include <attr/libattr.h>\n# include <stdarg.h>\n# include \"verror.h\"\n#endif\n\n#if HAVE_LINUX_FALLOC_H\n# include <linux/falloc.h>\n#endif\n\n \n#ifdef HAVE_LINUX_FS_H\n# include <linux/fs.h>\n#endif\n\n#if !defined FICLONE && defined __linux__\n# define FICLONE _IOW (0x94, 9, int)\n#endif\n\n#if HAVE_FCLONEFILEAT && !USE_XATTR\n# include <sys/clonefile.h>\n#endif\n\n#ifndef HAVE_FCHOWN\n# define HAVE_FCHOWN false\n# define fchown(fd, uid, gid) (-1)\n#endif\n\n#ifndef USE_ACL\n# define USE_ACL 0\n#endif\n\n#define SAME_OWNER(A, B) ((A).st_uid == (B).st_uid)\n#define SAME_GROUP(A, B) ((A).st_gid == (B).st_gid)\n#define SAME_OWNER_AND_GROUP(A, B) (SAME_OWNER (A, B) && SAME_GROUP (A, B))\n\n \n#if (defined HAVE_LINKAT && ! LINKAT_SYMLINK_NOTSUP) || ! LINK_FOLLOWS_SYMLINKS\n# define CAN_HARDLINK_SYMLINKS 1\n#else\n# define CAN_HARDLINK_SYMLINKS 0\n#endif\n\nstruct dir_list\n{\n  struct dir_list *parent;\n  ino_t ino;\n  dev_t dev;\n};\n\n \n#define DEST_INFO_INITIAL_CAPACITY 61\n\nstatic bool copy_internal (char const *src_name, char const *dst_name,\n                           int dst_dirfd, char const *dst_relname,\n                           int nonexistent_dst, struct stat const *parent,\n                           struct dir_list *ancestors,\n                           const struct cp_options *x,\n                           bool command_line_arg,\n                           bool *first_dir_created_per_command_line_arg,\n                           bool *copy_into_self,\n                           bool *rename_succeeded);\nstatic bool owner_failure_ok (struct cp_options const *x);\n\n \nstatic char const *top_level_src_name;\nstatic char const *top_level_dst_name;\n\nenum copy_debug_val\n  {\n   COPY_DEBUG_UNKNOWN,\n   COPY_DEBUG_NO,\n   COPY_DEBUG_YES,\n   COPY_DEBUG_EXTERNAL,\n   COPY_DEBUG_EXTERNAL_INTERNAL,\n   COPY_DEBUG_AVOIDED,\n   COPY_DEBUG_UNSUPPORTED,\n  };\n\n \nstatic struct copy_debug\n{\n  enum copy_debug_val offload;\n  enum copy_debug_val reflink;\n  enum copy_debug_val sparse_detection;\n} copy_debug;\n\nstatic const char*\ncopy_debug_string (enum copy_debug_val debug_val)\n{\n  switch (debug_val)\n    {\n    case COPY_DEBUG_NO: return \"no\";\n    case COPY_DEBUG_YES: return \"yes\";\n    case COPY_DEBUG_AVOIDED: return \"avoided\";\n    case COPY_DEBUG_UNSUPPORTED: return \"unsupported\";\n    default: return \"unknown\";\n    }\n}\n\nstatic const char*\ncopy_debug_sparse_string (enum copy_debug_val debug_val)\n{\n  switch (debug_val)\n    {\n    case COPY_DEBUG_NO: return \"no\";\n    case COPY_DEBUG_YES: return \"zeros\";\n    case COPY_DEBUG_EXTERNAL: return \"SEEK_HOLE\";\n    case COPY_DEBUG_EXTERNAL_INTERNAL: return \"SEEK_HOLE + zeros\";\n    default: return \"unknown\";\n    }\n}\n\n \nstatic void\nemit_debug (const struct cp_options *x)\n{\n  if (! x->hard_link && ! x->symbolic_link && x->data_copy_required)\n    printf (\"copy offload: %s, reflink: %s, sparse detection: %s\\n\",\n            copy_debug_string (copy_debug.offload),\n            copy_debug_string (copy_debug.reflink),\n            copy_debug_sparse_string (copy_debug.sparse_detection));\n}\n\n#ifndef DEV_FD_MIGHT_BE_CHR\n# define DEV_FD_MIGHT_BE_CHR false\n#endif\n\n \nstatic int\nfollow_fstatat (int dirfd, char const *filename, struct stat *st, int flags)\n{\n  int result = fstatat (dirfd, filename, st, flags);\n\n  if (DEV_FD_MIGHT_BE_CHR && result == 0 && !(flags & AT_SYMLINK_NOFOLLOW)\n      && S_ISCHR (st->st_mode))\n    {\n      static dev_t stdin_rdev;\n      static signed char stdin_rdev_status;\n      if (stdin_rdev_status == 0)\n        {\n          struct stat stdin_st;\n          if (stat (\"/dev/stdin\", &stdin_st) == 0 && S_ISCHR (stdin_st.st_mode)\n              && minor (stdin_st.st_rdev) == STDIN_FILENO)\n            {\n              stdin_rdev = stdin_st.st_rdev;\n              stdin_rdev_status = 1;\n            }\n          else\n            stdin_rdev_status = -1;\n        }\n      if (0 < stdin_rdev_status && major (stdin_rdev) == major (st->st_rdev))\n        result = fstat (minor (st->st_rdev), st);\n    }\n\n  return result;\n}\n\n \n\nstatic int\npunch_hole (int fd, off_t offset, off_t length)\n{\n  int ret = 0;\n \n#if HAVE_FALLOCATE + 0\n# if defined FALLOC_FL_PUNCH_HOLE && defined FALLOC_FL_KEEP_SIZE\n  ret = fallocate (fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n                   offset, length);\n  if (ret < 0 && (is_ENOTSUP (errno) || errno == ENOSYS))\n    ret = 0;\n# endif\n#endif\n  return ret;\n}\n\n \n\nstatic bool\ncreate_hole (int fd, char const *name, bool punch_holes, off_t size)\n{\n  off_t file_end = lseek (fd, size, SEEK_CUR);\n\n  if (file_end < 0)\n    {\n      error (0, errno, _(\"cannot lseek %s\"), quoteaf (name));\n      return false;\n    }\n\n   \n  if (punch_holes && punch_hole (fd, file_end - size, size) < 0)\n    {\n      error (0, errno, _(\"error deallocating %s\"), quoteaf (name));\n      return false;\n    }\n\n  return true;\n}\n\n\n \n\nstatic bool\nis_terminal_error (int err)\n{\n  return err == EIO || err == ENOMEM || err == ENOSPC || err == EDQUOT;\n}\n\n \n\nstatic bool\nis_CLONENOTSUP (int err)\n{\n  return err == ENOSYS || err == ENOTTY || is_ENOTSUP (err)\n         || err == EINVAL || err == EBADF\n         || err == EXDEV || err == ETXTBSY\n         || err == EPERM || err == EACCES;\n}\n\n\n \nstatic bool\nsparse_copy (int src_fd, int dest_fd, char **abuf, size_t buf_size,\n             size_t hole_size, bool punch_holes, bool allow_reflink,\n             char const *src_name, char const *dst_name,\n             uintmax_t max_n_read, off_t *total_n_read,\n             bool *last_write_made_hole)\n{\n  *last_write_made_hole = false;\n  *total_n_read = 0;\n\n  if (copy_debug.sparse_detection == COPY_DEBUG_UNKNOWN)\n    copy_debug.sparse_detection = hole_size ? COPY_DEBUG_YES : COPY_DEBUG_NO;\n  else if (hole_size && copy_debug.sparse_detection == COPY_DEBUG_EXTERNAL)\n    copy_debug.sparse_detection = COPY_DEBUG_EXTERNAL_INTERNAL;\n\n   \n  if (!hole_size && allow_reflink)\n    while (max_n_read)\n      {\n         \n        ssize_t copy_max = MIN (SSIZE_MAX, SIZE_MAX) >> 30 << 30;\n        ssize_t n_copied = copy_file_range (src_fd, nullptr, dest_fd, nullptr,\n                                            MIN (max_n_read, copy_max), 0);\n        if (n_copied == 0)\n          {\n             \n            if (*total_n_read == 0)\n              break;\n            copy_debug.offload = COPY_DEBUG_YES;\n            return true;\n          }\n        if (n_copied < 0)\n          {\n            copy_debug.offload = COPY_DEBUG_UNSUPPORTED;\n\n             \n            if (*total_n_read == 0 && is_CLONENOTSUP (errno))\n              break;\n\n             \n            if (*total_n_read == 0 && errno == ENOENT)\n              break;\n\n            if (errno == EINTR)\n              n_copied = 0;\n            else\n              {\n                error (0, errno, _(\"error copying %s to %s\"),\n                       quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n                return false;\n              }\n          }\n        copy_debug.offload = COPY_DEBUG_YES;\n        max_n_read -= n_copied;\n        *total_n_read += n_copied;\n      }\n  else\n    copy_debug.offload = COPY_DEBUG_AVOIDED;\n\n\n  bool make_hole = false;\n  off_t psize = 0;\n\n  while (max_n_read)\n    {\n      if (!*abuf)\n        *abuf = xalignalloc (getpagesize (), buf_size);\n      char *buf = *abuf;\n      ssize_t n_read = read (src_fd, buf, MIN (max_n_read, buf_size));\n      if (n_read < 0)\n        {\n          if (errno == EINTR)\n            continue;\n          error (0, errno, _(\"error reading %s\"), quoteaf (src_name));\n          return false;\n        }\n      if (n_read == 0)\n        break;\n      max_n_read -= n_read;\n      *total_n_read += n_read;\n\n       \n      size_t csize = hole_size ? hole_size : buf_size;\n      char *cbuf = buf;\n      char *pbuf = buf;\n\n      while (n_read)\n        {\n          bool prev_hole = make_hole;\n          csize = MIN (csize, n_read);\n\n          if (hole_size && csize)\n            make_hole = is_nul (cbuf, csize);\n\n          bool transition = (make_hole != prev_hole) && psize;\n          bool last_chunk = (n_read == csize && ! make_hole) || ! csize;\n\n          if (transition || last_chunk)\n            {\n              if (! transition)\n                psize += csize;\n\n              if (! prev_hole)\n                {\n                  if (full_write (dest_fd, pbuf, psize) != psize)\n                    {\n                      error (0, errno, _(\"error writing %s\"),\n                             quoteaf (dst_name));\n                      return false;\n                    }\n                }\n              else\n                {\n                  if (! create_hole (dest_fd, dst_name, punch_holes, psize))\n                    return false;\n                }\n\n              pbuf = cbuf;\n              psize = csize;\n\n              if (last_chunk)\n                {\n                  if (! csize)\n                    n_read = 0;  \n\n                  if (transition)\n                    csize = 0;   \n                  else\n                    psize = 0;   \n                }\n            }\n          else   \n            {\n              if (ckd_add (&psize, psize, csize))\n                {\n                  error (0, 0, _(\"overflow reading %s\"), quoteaf (src_name));\n                  return false;\n                }\n            }\n\n          n_read -= csize;\n          cbuf += csize;\n        }\n\n      *last_write_made_hole = make_hole;\n\n       \n    }\n\n   \n  if (make_hole && ! create_hole (dest_fd, dst_name, punch_holes, psize))\n    return false;\n  else\n    return true;\n}\n\n \nstatic inline int\nclone_file (int dest_fd, int src_fd)\n{\n#ifdef FICLONE\n  return ioctl (dest_fd, FICLONE, src_fd);\n#else\n  (void) dest_fd;\n  (void) src_fd;\n  errno = ENOTSUP;\n  return -1;\n#endif\n}\n\n \nstatic bool\nwrite_zeros (int fd, off_t n_bytes)\n{\n  static char *zeros;\n  static size_t nz = IO_BUFSIZE;\n\n   \n  if (zeros == nullptr)\n    {\n      static char fallback[1024];\n      zeros = calloc (nz, 1);\n      if (zeros == nullptr)\n        {\n          zeros = fallback;\n          nz = sizeof fallback;\n        }\n    }\n\n  while (n_bytes)\n    {\n      size_t n = MIN (nz, n_bytes);\n      if ((full_write (fd, zeros, n)) != n)\n        return false;\n      n_bytes -= n;\n    }\n\n  return true;\n}\n\n#ifdef SEEK_HOLE\n \n\nstatic bool\nlseek_copy (int src_fd, int dest_fd, char **abuf, size_t buf_size,\n            size_t hole_size, off_t ext_start, off_t src_total_size,\n            enum Sparse_type sparse_mode,\n            bool allow_reflink,\n            char const *src_name, char const *dst_name)\n{\n  off_t last_ext_start = 0;\n  off_t last_ext_len = 0;\n  off_t dest_pos = 0;\n  bool wrote_hole_at_eof = true;\n\n  copy_debug.sparse_detection = COPY_DEBUG_EXTERNAL;\n\n  while (0 <= ext_start)\n    {\n      off_t ext_end = lseek (src_fd, ext_start, SEEK_HOLE);\n      if (ext_end < 0)\n        {\n          if (errno != ENXIO)\n            goto cannot_lseek;\n          ext_end = src_total_size;\n          if (ext_end <= ext_start)\n            {\n               \n              src_total_size = lseek (src_fd, 0, SEEK_END);\n              if (src_total_size < 0)\n                goto cannot_lseek;\n\n               \n              if (src_total_size <= ext_start)\n                break;\n\n              ext_end = src_total_size;\n            }\n        }\n       \n      if (src_total_size < ext_end)\n        src_total_size = ext_end;\n\n      if (lseek (src_fd, ext_start, SEEK_SET) < 0)\n        goto cannot_lseek;\n\n      wrote_hole_at_eof = false;\n      off_t ext_hole_size = ext_start - last_ext_start - last_ext_len;\n\n      if (ext_hole_size)\n        {\n          if (sparse_mode != SPARSE_NEVER)\n            {\n              if (! create_hole (dest_fd, dst_name,\n                                 sparse_mode == SPARSE_ALWAYS,\n                                 ext_hole_size))\n                return false;\n              wrote_hole_at_eof = true;\n            }\n          else\n            {\n               \n              if (! write_zeros (dest_fd, ext_hole_size))\n                {\n                  error (0, errno, _(\"%s: write failed\"),\n                         quotef (dst_name));\n                  return false;\n                }\n            }\n        }\n\n      off_t ext_len = ext_end - ext_start;\n      last_ext_start = ext_start;\n      last_ext_len = ext_len;\n\n       \n      off_t n_read;\n      bool read_hole;\n      if ( ! sparse_copy (src_fd, dest_fd, abuf, buf_size,\n                          sparse_mode != SPARSE_ALWAYS ? 0 : hole_size,\n                          true, allow_reflink, src_name, dst_name,\n                          ext_len, &n_read, &read_hole))\n        return false;\n\n      dest_pos = ext_start + n_read;\n      if (n_read)\n        wrote_hole_at_eof = read_hole;\n      if (n_read < ext_len)\n        {\n           \n          src_total_size = dest_pos;\n          break;\n        }\n\n      ext_start = lseek (src_fd, dest_pos, SEEK_DATA);\n      if (ext_start < 0 && errno != ENXIO)\n        goto cannot_lseek;\n    }\n\n   \n  if ((dest_pos < src_total_size || wrote_hole_at_eof)\n      && ! (sparse_mode == SPARSE_NEVER\n            ? write_zeros (dest_fd, src_total_size - dest_pos)\n            : ftruncate (dest_fd, src_total_size) == 0))\n    {\n      error (0, errno, _(\"failed to extend %s\"), quoteaf (dst_name));\n      return false;\n    }\n\n  if (sparse_mode == SPARSE_ALWAYS && dest_pos < src_total_size\n      && punch_hole (dest_fd, dest_pos, src_total_size - dest_pos) < 0)\n    {\n      error (0, errno, _(\"error deallocating %s\"), quoteaf (dst_name));\n      return false;\n    }\n\n  return true;\n\n cannot_lseek:\n  error (0, errno, _(\"cannot lseek %s\"), quoteaf (src_name));\n  return false;\n}\n#endif\n\n \n \n\nATTRIBUTE_PURE\nstatic bool\nis_ancestor (const struct stat *sb, const struct dir_list *ancestors)\n{\n  while (ancestors != 0)\n    {\n      if (ancestors->ino == sb->st_ino && ancestors->dev == sb->st_dev)\n        return true;\n      ancestors = ancestors->parent;\n    }\n  return false;\n}\n\nstatic bool\nerrno_unsupported (int err)\n{\n  return err == ENOTSUP || err == ENODATA;\n}\n\n#if USE_XATTR\nATTRIBUTE_FORMAT ((printf, 2, 3))\nstatic void\ncopy_attr_error (MAYBE_UNUSED struct error_context *ctx,\n                 char const *fmt, ...)\n{\n  if (!errno_unsupported (errno))\n    {\n      int err = errno;\n      va_list ap;\n\n       \n      va_start (ap, fmt);\n      verror (0, err, fmt, ap);\n      va_end (ap);\n    }\n}\n\nATTRIBUTE_FORMAT ((printf, 2, 3))\nstatic void\ncopy_attr_allerror (MAYBE_UNUSED struct error_context *ctx,\n                    char const *fmt, ...)\n{\n  int err = errno;\n  va_list ap;\n\n   \n  va_start (ap, fmt);\n  verror (0, err, fmt, ap);\n  va_end (ap);\n}\n\nstatic char const *\ncopy_attr_quote (MAYBE_UNUSED struct error_context *ctx, char const *str)\n{\n  return quoteaf (str);\n}\n\nstatic void\ncopy_attr_free (MAYBE_UNUSED struct error_context *ctx,\n                MAYBE_UNUSED char const *str)\n{\n}\n\n \nstatic int\ncheck_selinux_attr (char const *name, struct error_context *ctx)\n{\n  return STRNCMP_LIT (name, \"security.selinux\")\n         && attr_copy_check_permissions (name, ctx);\n}\n\n \n\nstatic bool\ncopy_attr (char const *src_path, int src_fd,\n           char const *dst_path, int dst_fd, struct cp_options const *x)\n{\n  bool all_errors = (!x->data_copy_required || x->require_preserve_xattr);\n  bool some_errors = (!all_errors && !x->reduce_diagnostics);\n  int (*check) (char const *, struct error_context *)\n    = (x->preserve_security_context || x->set_security_context\n       ? check_selinux_attr : nullptr);\n\n# if 4 < __GNUC__ + (8 <= __GNUC_MINOR__)\n   \n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wsuggest-attribute=format\"\n# endif\n  struct error_context *ctx\n    = (all_errors || some_errors\n       ? (&(struct error_context) {\n           .error = all_errors ? copy_attr_allerror : copy_attr_error,\n           .quote = copy_attr_quote,\n           .quote_free = copy_attr_free\n         })\n       : nullptr);\n# if 4 < __GNUC__ + (8 <= __GNUC_MINOR__)\n#  pragma GCC diagnostic pop\n# endif\n\n  return ! (0 <= src_fd && 0 <= dst_fd\n            ? attr_copy_fd (src_path, src_fd, dst_path, dst_fd, check, ctx)\n            : attr_copy_file (src_path, dst_path, check, ctx));\n}\n#else  \n\nstatic bool\ncopy_attr (MAYBE_UNUSED char const *src_path,\n           MAYBE_UNUSED int src_fd,\n           MAYBE_UNUSED char const *dst_path,\n           MAYBE_UNUSED int dst_fd,\n           MAYBE_UNUSED struct cp_options const *x)\n{\n  return true;\n}\n#endif  \n\n \n\nstatic bool\ncopy_dir (char const *src_name_in, char const *dst_name_in,\n          int dst_dirfd, char const *dst_relname_in, bool new_dst,\n          const struct stat *src_sb, struct dir_list *ancestors,\n          const struct cp_options *x,\n          bool *first_dir_created_per_command_line_arg,\n          bool *copy_into_self)\n{\n  char *name_space;\n  char *namep;\n  struct cp_options non_command_line_options = *x;\n  bool ok = true;\n\n  name_space = savedir (src_name_in, SAVEDIR_SORT_FASTREAD);\n  if (name_space == nullptr)\n    {\n       \n      error (0, errno, _(\"cannot access %s\"), quoteaf (src_name_in));\n      return false;\n    }\n\n   \n  if (x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)\n    non_command_line_options.dereference = DEREF_NEVER;\n\n  bool new_first_dir_created = false;\n  namep = name_space;\n  while (*namep != '\\0')\n    {\n      bool local_copy_into_self;\n      char *src_name = file_name_concat (src_name_in, namep, nullptr);\n      char *dst_name = file_name_concat (dst_name_in, namep, nullptr);\n      bool first_dir_created = *first_dir_created_per_command_line_arg;\n      bool rename_succeeded;\n\n      ok &= copy_internal (src_name, dst_name, dst_dirfd,\n                           dst_name + (dst_relname_in - dst_name_in),\n                           new_dst, src_sb,\n                           ancestors, &non_command_line_options, false,\n                           &first_dir_created,\n                           &local_copy_into_self, &rename_succeeded);\n      *copy_into_self |= local_copy_into_self;\n\n      free (dst_name);\n      free (src_name);\n\n       \n      if (local_copy_into_self)\n        break;\n\n      new_first_dir_created |= first_dir_created;\n      namep += strlen (namep) + 1;\n    }\n  free (name_space);\n  *first_dir_created_per_command_line_arg = new_first_dir_created;\n\n  return ok;\n}\n\n \n\nstatic int\nset_owner (const struct cp_options *x, char const *dst_name,\n           int dst_dirfd, char const *dst_relname, int dest_desc,\n           struct stat const *src_sb, bool new_dst,\n           struct stat const *dst_sb)\n{\n  uid_t uid = src_sb->st_uid;\n  gid_t gid = src_sb->st_gid;\n\n   \n\n  if (!new_dst && (x->preserve_mode || x->move_mode || x->set_mode))\n    {\n      mode_t old_mode = dst_sb->st_mode;\n      mode_t new_mode =\n        (x->preserve_mode || x->move_mode ? src_sb->st_mode : x->mode);\n      mode_t restrictive_temp_mode = old_mode & new_mode & S_IRWXU;\n\n      if ((USE_ACL\n           || (old_mode & CHMOD_MODE_BITS\n               & (~new_mode | S_ISUID | S_ISGID | S_ISVTX)))\n          && qset_acl (dst_name, dest_desc, restrictive_temp_mode) != 0)\n        {\n          if (! owner_failure_ok (x))\n            error (0, errno, _(\"clearing permissions for %s\"),\n                   quoteaf (dst_name));\n          return -x->require_preserve;\n        }\n    }\n\n  if (HAVE_FCHOWN && dest_desc != -1)\n    {\n      if (fchown (dest_desc, uid, gid) == 0)\n        return 1;\n      if (errno == EPERM || errno == EINVAL)\n        {\n           \n          int saved_errno = errno;\n          ignore_value (fchown (dest_desc, -1, gid));\n          errno = saved_errno;\n        }\n    }\n  else\n    {\n      if (lchownat (dst_dirfd, dst_relname, uid, gid) == 0)\n        return 1;\n      if (errno == EPERM || errno == EINVAL)\n        {\n           \n          int saved_errno = errno;\n          ignore_value (lchownat (dst_dirfd, dst_relname, -1, gid));\n          errno = saved_errno;\n        }\n    }\n\n  if (! chown_failure_ok (x))\n    {\n      error (0, errno, _(\"failed to preserve ownership for %s\"),\n             quoteaf (dst_name));\n      if (x->require_preserve)\n        return -1;\n    }\n\n  return 0;\n}\n\n \n\nstatic void\nset_author (char const *dst_name, int dest_desc, const struct stat *src_sb)\n{\n#if HAVE_STRUCT_STAT_ST_AUTHOR\n   \n\n   \n  file_t file = (dest_desc < 0\n                 ? file_name_lookup (dst_name, 0, 0)\n                 : getdport (dest_desc));\n  if (file == MACH_PORT_NULL)\n    error (0, errno, _(\"failed to lookup file %s\"), quoteaf (dst_name));\n  else\n    {\n      error_t err = file_chauthor (file, src_sb->st_author);\n      if (err)\n        error (0, err, _(\"failed to preserve authorship for %s\"),\n               quoteaf (dst_name));\n      mach_port_deallocate (mach_task_self (), file);\n    }\n#else\n  (void) dst_name;\n  (void) dest_desc;\n  (void) src_sb;\n#endif\n}\n\n \n\nbool\nset_process_security_ctx (char const *src_name, char const *dst_name,\n                          mode_t mode, bool new_dst, const struct cp_options *x)\n{\n  if (x->preserve_security_context)\n    {\n       \n      bool all_errors = !x->data_copy_required || x->require_preserve_context;\n      bool some_errors = !all_errors && !x->reduce_diagnostics;\n      char *con;\n\n      if (0 <= lgetfilecon (src_name, &con))\n        {\n          if (setfscreatecon (con) < 0)\n            {\n              if (all_errors || (some_errors && !errno_unsupported (errno)))\n                error (0, errno,\n                       _(\"failed to set default file creation context to %s\"),\n                       quote (con));\n              if (x->require_preserve_context)\n                {\n                  freecon (con);\n                  return false;\n                }\n            }\n          freecon (con);\n        }\n      else\n        {\n          if (all_errors || (some_errors && !errno_unsupported (errno)))\n            {\n              error (0, errno,\n                     _(\"failed to get security context of %s\"),\n                     quoteaf (src_name));\n            }\n          if (x->require_preserve_context)\n            return false;\n        }\n    }\n  else if (x->set_security_context)\n    {\n       \n      if (new_dst && defaultcon (x->set_security_context, dst_name, mode) < 0\n          && ! ignorable_ctx_err (errno))\n        {\n          error (0, errno,\n                 _(\"failed to set default file creation context for %s\"),\n                 quoteaf (dst_name));\n        }\n    }\n\n  return true;\n}\n\n \n\nbool\nset_file_security_ctx (char const *dst_name,\n                       bool recurse, const struct cp_options *x)\n{\n  bool all_errors = (!x->data_copy_required\n                     || x->require_preserve_context);\n  bool some_errors = !all_errors && !x->reduce_diagnostics;\n\n  if (! restorecon (x->set_security_context, dst_name, recurse))\n    {\n      if (all_errors || (some_errors && !errno_unsupported (errno)))\n        error (0, errno, _(\"failed to set the security context of %s\"),\n               quoteaf_n (0, dst_name));\n      return false;\n    }\n\n  return true;\n}\n\n \n\nstatic int\nfchmod_or_lchmod (int desc, int dirfd, char const *name, mode_t mode)\n{\n#if HAVE_FCHMOD\n  if (0 <= desc)\n    return fchmod (desc, mode);\n#endif\n  return lchmodat (dirfd, name, mode);\n}\n\n#ifndef HAVE_STRUCT_STAT_ST_BLOCKS\n# define HAVE_STRUCT_STAT_ST_BLOCKS 0\n#endif\n\n \nenum scantype\n  {\n    \n   ERROR_SCANTYPE,\n\n    \n   PLAIN_SCANTYPE,\n\n    \n   ZERO_SCANTYPE,\n\n    \n   LSEEK_SCANTYPE,\n  };\n\n \nunion scan_inference\n{\n   \n  off_t ext_start;\n};\n\n \nstatic enum scantype\ninfer_scantype (int fd, struct stat const *sb,\n                union scan_inference *scan_inference)\n{\n  scan_inference->ext_start = -1;   \n\n   \n  if (! (HAVE_STRUCT_STAT_ST_BLOCKS\n         && S_ISREG (sb->st_mode)\n         && ST_NBLOCKS (*sb) < sb->st_size / ST_NBLOCKSIZE))\n    return PLAIN_SCANTYPE;\n\n#ifdef SEEK_HOLE\n  off_t ext_start = lseek (fd, 0, SEEK_DATA);\n  if (0 <= ext_start || errno == ENXIO)\n    {\n      scan_inference->ext_start = ext_start;\n      return LSEEK_SCANTYPE;\n    }\n  else if (errno != EINVAL && !is_ENOTSUP (errno))\n    return ERROR_SCANTYPE;\n#endif\n\n  return ZERO_SCANTYPE;\n}\n\n#if HAVE_FCLONEFILEAT && !USE_XATTR\n# include <sys/acl.h>\n \nstatic bool\nfd_has_acl (int fd)\n{\n   \n  bool has_acl = false;\n  acl_t acl = acl_get_fd_np (fd, ACL_TYPE_EXTENDED);\n  if (acl)\n    {\n      acl_entry_t ace;\n      has_acl = 0 <= acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n      acl_free (acl);\n    }\n  return has_acl;\n}\n#endif\n\n \n\nstatic bool\nhandle_clone_fail (int dst_dirfd, char const *dst_relname,\n                   char const *src_name, char const *dst_name,\n                   int dest_desc, bool new_dst, enum Reflink_type reflink_mode)\n{\n   \n  bool report_failure = is_terminal_error (errno);\n\n  if (reflink_mode == REFLINK_ALWAYS || report_failure)\n    error (0, errno, _(\"failed to clone %s from %s\"),\n           quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n\n   \n  if (new_dst  \n      && reflink_mode == REFLINK_ALWAYS\n      && ((! report_failure) || lseek (dest_desc, 0, SEEK_END) == 0)\n      && unlinkat (dst_dirfd, dst_relname, 0) != 0 && errno != ENOENT)\n    error (0, errno, _(\"cannot remove %s\"), quoteaf (dst_name));\n\n  if (! report_failure)\n    copy_debug.reflink = COPY_DEBUG_UNSUPPORTED;\n\n  if (reflink_mode == REFLINK_ALWAYS || report_failure)\n    return false;\n\n  return true;\n}\n\n\n \n\nstatic bool\ncopy_reg (char const *src_name, char const *dst_name,\n          int dst_dirfd, char const *dst_relname,\n          const struct cp_options *x,\n          mode_t dst_mode, mode_t omitted_permissions, bool *new_dst,\n          struct stat const *src_sb)\n{\n  char *buf = nullptr;\n  int dest_desc;\n  int dest_errno;\n  int source_desc;\n  mode_t src_mode = src_sb->st_mode;\n  mode_t extra_permissions;\n  struct stat sb;\n  struct stat src_open_sb;\n  union scan_inference scan_inference;\n  bool return_val = true;\n  bool data_copy_required = x->data_copy_required;\n  bool preserve_xattr = USE_XATTR & x->preserve_xattr;\n\n  copy_debug.offload = COPY_DEBUG_UNKNOWN;\n  copy_debug.reflink = x->reflink_mode ? COPY_DEBUG_UNKNOWN : COPY_DEBUG_NO;\n  copy_debug.sparse_detection = COPY_DEBUG_UNKNOWN;\n\n  source_desc = open (src_name,\n                      (O_RDONLY | O_BINARY\n                       | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));\n  if (source_desc < 0)\n    {\n      error (0, errno, _(\"cannot open %s for reading\"), quoteaf (src_name));\n      return false;\n    }\n\n  if (fstat (source_desc, &src_open_sb) != 0)\n    {\n      error (0, errno, _(\"cannot fstat %s\"), quoteaf (src_name));\n      return_val = false;\n      goto close_src_desc;\n    }\n\n   \n  if (! SAME_INODE (*src_sb, src_open_sb))\n    {\n      error (0, 0,\n             _(\"skipping file %s, as it was replaced while being copied\"),\n             quoteaf (src_name));\n      return_val = false;\n      goto close_src_desc;\n    }\n\n   \n  if (! *new_dst)\n    {\n      int open_flags =\n        O_WRONLY | O_BINARY | (data_copy_required ? O_TRUNC : 0);\n      dest_desc = openat (dst_dirfd, dst_relname, open_flags);\n      dest_errno = errno;\n\n       \n      if (0 <= dest_desc\n          && (x->set_security_context || x->preserve_security_context))\n        {\n          if (! set_file_security_ctx (dst_name, false, x))\n            {\n              if (x->require_preserve_context)\n                {\n                  return_val = false;\n                  goto close_src_and_dst_desc;\n                }\n            }\n        }\n\n      if (dest_desc < 0 && dest_errno != ENOENT\n          && x->unlink_dest_after_failed_open)\n        {\n          if (unlinkat (dst_dirfd, dst_relname, 0) == 0)\n            {\n              if (x->verbose)\n                printf (_(\"removed %s\\n\"), quoteaf (dst_name));\n            }\n          else if (errno != ENOENT)\n            {\n              error (0, errno, _(\"cannot remove %s\"), quoteaf (dst_name));\n              return_val = false;\n              goto close_src_desc;\n            }\n\n          dest_errno = ENOENT;\n        }\n\n      if (dest_desc < 0 && dest_errno == ENOENT)\n        {\n           \n          if (x->set_security_context)\n            {\n              if (! set_process_security_ctx (src_name, dst_name, dst_mode,\n                                              true, x))\n                {\n                  return_val = false;\n                  goto close_src_desc;\n                }\n            }\n\n           \n          *new_dst = true;\n        }\n    }\n\n  if (*new_dst)\n    {\n#if HAVE_FCLONEFILEAT && !USE_XATTR\n# ifndef CLONE_ACL\n#  define CLONE_ACL 0  \n# endif\n# ifndef CLONE_NOOWNERCOPY\n#  define CLONE_NOOWNERCOPY 0  \n# endif\n       \n      if (data_copy_required && x->reflink_mode\n          && (CLONE_NOOWNERCOPY || x->preserve_ownership))\n        {\n           \n          mode_t cloned_mode_bits = S_ISVTX | S_IRWXUGO;\n          mode_t cloned_mode = src_mode & cloned_mode_bits;\n          mode_t desired_mode\n            = (x->preserve_mode ? src_mode & CHMOD_MODE_BITS\n               : x->set_mode ? x->mode\n               : ((x->explicit_no_preserve_mode ? MODE_RW_UGO : dst_mode)\n                  & ~ cached_umask ()));\n          if (! (cloned_mode & ~desired_mode))\n            {\n              int fc_flags\n                = (CLONE_NOFOLLOW\n                   | (x->preserve_mode ? CLONE_ACL : 0)\n                   | (x->preserve_ownership ? 0 : CLONE_NOOWNERCOPY));\n              int s = fclonefileat (source_desc, dst_dirfd, dst_relname,\n                                    fc_flags);\n              if (s != 0 && (fc_flags & CLONE_ACL) && errno == EINVAL)\n                {\n                  fc_flags &= ~CLONE_ACL;\n                  s = fclonefileat (source_desc, dst_dirfd, dst_relname,\n                                    fc_flags);\n                }\n              if (s == 0)\n                {\n                  copy_debug.reflink = COPY_DEBUG_YES;\n\n                   \n\n                  if (!x->preserve_timestamps)\n                    {\n                      struct timespec timespec[2];\n                      timespec[0].tv_nsec = timespec[1].tv_nsec = UTIME_NOW;\n                      if (utimensat (dst_dirfd, dst_relname, timespec,\n                                     AT_SYMLINK_NOFOLLOW)\n                          != 0)\n                        {\n                          error (0, errno, _(\"updating times for %s\"),\n                                 quoteaf (dst_name));\n                          return_val = false;\n                          goto close_src_desc;\n                        }\n                    }\n\n                  extra_permissions = desired_mode & ~cloned_mode;\n                  if (!extra_permissions\n                      && (!x->preserve_mode || (fc_flags & CLONE_ACL)\n                          || !fd_has_acl (source_desc)))\n                    {\n                      goto close_src_desc;\n                    }\n\n                   \n                  omitted_permissions = 0;\n                  dest_desc = -1;\n                  goto set_dest_mode;\n                }\n              if (! handle_clone_fail (dst_dirfd, dst_relname, src_name,\n                                       dst_name,\n                                       -1, false  ,\n                                       x->reflink_mode))\n                {\n                  return_val = false;\n                  goto close_src_desc;\n                }\n            }\n          else\n            copy_debug.reflink = COPY_DEBUG_AVOIDED;\n        }\n      else if (data_copy_required && x->reflink_mode)\n        {\n          if (! CLONE_NOOWNERCOPY)\n            copy_debug.reflink = COPY_DEBUG_AVOIDED;\n        }\n#endif\n\n       \n      mode_t open_mode =\n        ((dst_mode & ~omitted_permissions)\n         | (preserve_xattr && !x->owner_privileges ? S_IWUSR : 0));\n      extra_permissions = open_mode & ~dst_mode;  \n\n      int open_flags = O_WRONLY | O_CREAT | O_BINARY;\n      dest_desc = openat (dst_dirfd, dst_relname, open_flags | O_EXCL,\n                          open_mode);\n      dest_errno = errno;\n\n       \n      if (dest_desc < 0 && dest_errno == EEXIST && ! x->move_mode)\n        {\n          char dummy[1];\n          if (0 <= readlinkat (dst_dirfd, dst_relname, dummy, sizeof dummy))\n            {\n              if (x->open_dangling_dest_symlink)\n                {\n                  dest_desc = openat (dst_dirfd, dst_relname,\n                                      open_flags, open_mode);\n                  dest_errno = errno;\n                }\n              else\n                {\n                  error (0, 0, _(\"not writing through dangling symlink %s\"),\n                         quoteaf (dst_name));\n                  return_val = false;\n                  goto close_src_desc;\n                }\n            }\n        }\n\n       \n      if (dest_desc < 0 && dest_errno == EISDIR\n          && *dst_name && dst_name[strlen (dst_name) - 1] == '/')\n        dest_errno = ENOTDIR;\n    }\n  else\n    {\n      omitted_permissions = extra_permissions = 0;\n    }\n\n  if (dest_desc < 0)\n    {\n      error (0, dest_errno, _(\"cannot create regular file %s\"),\n             quoteaf (dst_name));\n      return_val = false;\n      goto close_src_desc;\n    }\n\n   \n  if (data_copy_required && x->reflink_mode)\n    {\n      if (clone_file (dest_desc, source_desc) == 0)\n        {\n          data_copy_required = false;\n          copy_debug.reflink = COPY_DEBUG_YES;\n        }\n      else\n        {\n          if (! handle_clone_fail (dst_dirfd, dst_relname, src_name, dst_name,\n                                   dest_desc, *new_dst, x->reflink_mode))\n           {\n             return_val = false;\n             goto close_src_and_dst_desc;\n           }\n        }\n    }\n\n  if (! (data_copy_required | x->preserve_ownership | extra_permissions))\n    sb.st_mode = 0;\n  else if (fstat (dest_desc, &sb) != 0)\n    {\n      error (0, errno, _(\"cannot fstat %s\"), quoteaf (dst_name));\n      return_val = false;\n      goto close_src_and_dst_desc;\n    }\n\n   \n  mode_t temporary_mode = sb.st_mode | extra_permissions;\n  if (temporary_mode != sb.st_mode\n      && (fchmod_or_lchmod (dest_desc, dst_dirfd, dst_relname, temporary_mode)\n          != 0))\n    extra_permissions = 0;\n\n  if (data_copy_required)\n    {\n       \n      size_t buf_size = io_blksize (sb);\n      size_t hole_size = ST_BLKSIZE (sb);\n\n       \n      enum scantype scantype = infer_scantype (source_desc, &src_open_sb,\n                                               &scan_inference);\n      if (scantype == ERROR_SCANTYPE)\n        {\n          error (0, errno, _(\"cannot lseek %s\"), quoteaf (src_name));\n          return_val = false;\n          goto close_src_and_dst_desc;\n        }\n      bool make_holes\n        = (S_ISREG (sb.st_mode)\n           && (x->sparse_mode == SPARSE_ALWAYS\n               || (x->sparse_mode == SPARSE_AUTO\n                   && scantype != PLAIN_SCANTYPE)));\n\n      fdadvise (source_desc, 0, 0, FADVISE_SEQUENTIAL);\n\n       \n      if (! make_holes)\n        {\n           \n          size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX);\n          size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,\n                                    blcm_max);\n\n           \n          if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)\n            buf_size = src_open_sb.st_size + 1;\n\n           \n          buf_size += blcm - 1;\n          buf_size -= buf_size % blcm;\n          if (buf_size == 0 || blcm_max < buf_size)\n            buf_size = blcm;\n        }\n\n      off_t n_read;\n      bool wrote_hole_at_eof = false;\n      if (! (\n#ifdef SEEK_HOLE\n             scantype == LSEEK_SCANTYPE\n             ? lseek_copy (source_desc, dest_desc, &buf, buf_size, hole_size,\n                           scan_inference.ext_start, src_open_sb.st_size,\n                           make_holes ? x->sparse_mode : SPARSE_NEVER,\n                           x->reflink_mode != REFLINK_NEVER,\n                           src_name, dst_name)\n             :\n#endif\n               sparse_copy (source_desc, dest_desc, &buf, buf_size,\n                            make_holes ? hole_size : 0,\n                            x->sparse_mode == SPARSE_ALWAYS,\n                            x->reflink_mode != REFLINK_NEVER,\n                            src_name, dst_name, UINTMAX_MAX, &n_read,\n                            &wrote_hole_at_eof)))\n        {\n          return_val = false;\n          goto close_src_and_dst_desc;\n        }\n      else if (wrote_hole_at_eof && ftruncate (dest_desc, n_read) < 0)\n        {\n          error (0, errno, _(\"failed to extend %s\"), quoteaf (dst_name));\n          return_val = false;\n          goto close_src_and_dst_desc;\n        }\n    }\n\n  if (x->preserve_timestamps)\n    {\n      struct timespec timespec[2];\n      timespec[0] = get_stat_atime (src_sb);\n      timespec[1] = get_stat_mtime (src_sb);\n\n      if (fdutimensat (dest_desc, dst_dirfd, dst_relname, timespec, 0) != 0)\n        {\n          error (0, errno, _(\"preserving times for %s\"), quoteaf (dst_name));\n          if (x->require_preserve)\n            {\n              return_val = false;\n              goto close_src_and_dst_desc;\n            }\n        }\n    }\n\n   \n  if (x->preserve_ownership && ! SAME_OWNER_AND_GROUP (*src_sb, sb))\n    {\n      switch (set_owner (x, dst_name, dst_dirfd, dst_relname, dest_desc,\n                         src_sb, *new_dst, &sb))\n        {\n        case -1:\n          return_val = false;\n          goto close_src_and_dst_desc;\n\n        case 0:\n          src_mode &= ~ (S_ISUID | S_ISGID | S_ISVTX);\n          break;\n        }\n    }\n\n  if (preserve_xattr)\n    {\n      if (!copy_attr (src_name, source_desc, dst_name, dest_desc, x)\n          && x->require_preserve_xattr)\n        return_val = false;\n    }\n\n  set_author (dst_name, dest_desc, src_sb);\n\n#if HAVE_FCLONEFILEAT && !USE_XATTR\nset_dest_mode:\n#endif\n  if (x->preserve_mode || x->move_mode)\n    {\n      if (copy_acl (src_name, source_desc, dst_name, dest_desc, src_mode) != 0\n          && x->require_preserve)\n        return_val = false;\n    }\n  else if (x->set_mode)\n    {\n      if (set_acl (dst_name, dest_desc, x->mode) != 0)\n        return_val = false;\n    }\n  else if (x->explicit_no_preserve_mode && *new_dst)\n    {\n      if (set_acl (dst_name, dest_desc, MODE_RW_UGO & ~cached_umask ()) != 0)\n        return_val = false;\n    }\n  else if (omitted_permissions | extra_permissions)\n    {\n      omitted_permissions &= ~ cached_umask ();\n      if ((omitted_permissions | extra_permissions)\n          && (fchmod_or_lchmod (dest_desc, dst_dirfd, dst_relname,\n                                dst_mode & ~ cached_umask ())\n              != 0))\n        {\n          error (0, errno, _(\"preserving permissions for %s\"),\n                 quoteaf (dst_name));\n          if (x->require_preserve)\n            return_val = false;\n        }\n    }\n\n  if (dest_desc < 0)\n    goto close_src_desc;\n\nclose_src_and_dst_desc:\n  if (close (dest_desc) < 0)\n    {\n      error (0, errno, _(\"failed to close %s\"), quoteaf (dst_name));\n      return_val = false;\n    }\nclose_src_desc:\n  if (close (source_desc) < 0)\n    {\n      error (0, errno, _(\"failed to close %s\"), quoteaf (src_name));\n      return_val = false;\n    }\n\n   \n  if (x->debug)\n    emit_debug (x);\n\n  alignfree (buf);\n  return return_val;\n}\n\n \n\nstatic bool\nsame_file_ok (char const *src_name, struct stat const *src_sb,\n              int dst_dirfd, char const *dst_relname, struct stat const *dst_sb,\n              const struct cp_options *x, bool *return_now)\n{\n  const struct stat *src_sb_link;\n  const struct stat *dst_sb_link;\n  struct stat tmp_dst_sb;\n  struct stat tmp_src_sb;\n\n  bool same_link;\n  bool same = SAME_INODE (*src_sb, *dst_sb);\n\n  *return_now = false;\n\n   \n  if (same && x->hard_link)\n    {\n      *return_now = true;\n      return true;\n    }\n\n  if (x->dereference == DEREF_NEVER)\n    {\n      same_link = same;\n\n       \n      if (S_ISLNK (src_sb->st_mode) && S_ISLNK (dst_sb->st_mode))\n        {\n          bool sn = same_nameat (AT_FDCWD, src_name, dst_dirfd, dst_relname);\n          if ( ! sn)\n            {\n               \n              if (x->backup_type != no_backups)\n                return true;\n\n               \n              if (same_link)\n                {\n                  *return_now = true;\n                  return ! x->move_mode;\n                }\n            }\n\n          return ! sn;\n        }\n\n      src_sb_link = src_sb;\n      dst_sb_link = dst_sb;\n    }\n  else\n    {\n      if (!same)\n        return true;\n\n      if (fstatat (dst_dirfd, dst_relname, &tmp_dst_sb,\n                   AT_SYMLINK_NOFOLLOW) != 0\n          || lstat (src_name, &tmp_src_sb) != 0)\n        return true;\n\n      src_sb_link = &tmp_src_sb;\n      dst_sb_link = &tmp_dst_sb;\n\n      same_link = SAME_INODE (*src_sb_link, *dst_sb_link);\n\n       \n      if (S_ISLNK (src_sb_link->st_mode) && S_ISLNK (dst_sb_link->st_mode)\n          && x->unlink_dest_before_opening)\n        return true;\n    }\n\n   \n  if (x->backup_type != no_backups)\n    {\n      if (!same_link)\n        {\n           \n\n           \n          if ( ! x->move_mode\n               && x->dereference != DEREF_NEVER\n               && S_ISLNK (src_sb_link->st_mode)\n               && ! S_ISLNK (dst_sb_link->st_mode))\n            return false;\n\n          return true;\n        }\n\n       \n      return ! same_nameat (AT_FDCWD, src_name, dst_dirfd, dst_relname);\n    }\n\n#if 0\n   \n\n   \n  if (x->hard_link\n      || !S_ISLNK (src_sb_link->st_mode)\n      || S_ISLNK (dst_sb_link->st_mode))\n    return true;\n\n  if (x->dereference != DEREF_NEVER)\n    return true;\n#endif\n\n  if (x->move_mode || x->unlink_dest_before_opening)\n    {\n       \n      if (S_ISLNK (dst_sb_link->st_mode))\n        return true;\n\n       \n      if (same_link\n          && 1 < dst_sb_link->st_nlink\n          && ! same_nameat (AT_FDCWD, src_name, dst_dirfd, dst_relname))\n        return ! x->move_mode;\n    }\n\n   \n  if (!S_ISLNK (src_sb_link->st_mode) && !S_ISLNK (dst_sb_link->st_mode))\n    {\n      if (!SAME_INODE (*src_sb_link, *dst_sb_link))\n        return true;\n\n       \n      if (x->hard_link)\n        {\n          *return_now = true;\n          return true;\n        }\n    }\n\n   \n  if (x->move_mode\n      && S_ISLNK (src_sb->st_mode)\n      && 1 < dst_sb_link->st_nlink)\n    {\n      char *abs_src = canonicalize_file_name (src_name);\n      if (abs_src)\n        {\n          bool result = ! same_nameat (AT_FDCWD, abs_src,\n                                       dst_dirfd, dst_relname);\n          free (abs_src);\n          return result;\n        }\n    }\n\n   \n  if (x->symbolic_link && S_ISLNK (dst_sb_link->st_mode))\n    return true;\n\n  if (x->dereference == DEREF_NEVER)\n    {\n      if ( ! S_ISLNK (src_sb_link->st_mode))\n        tmp_src_sb = *src_sb_link;\n      else if (stat (src_name, &tmp_src_sb) != 0)\n        return true;\n\n      if ( ! S_ISLNK (dst_sb_link->st_mode))\n        tmp_dst_sb = *dst_sb_link;\n      else if (fstatat (dst_dirfd, dst_relname, &tmp_dst_sb, 0) != 0)\n        return true;\n\n      if ( ! SAME_INODE (tmp_src_sb, tmp_dst_sb))\n        return true;\n\n      if (x->hard_link)\n        {\n           \n          *return_now = ! S_ISLNK (dst_sb_link->st_mode);\n          return true;\n        }\n    }\n\n  return false;\n}\n\n \nstatic bool\nwritable_destination (int dst_dirfd, char const *dst_relname, mode_t mode)\n{\n  return (S_ISLNK (mode)\n          || can_write_any_file ()\n          || faccessat (dst_dirfd, dst_relname, W_OK, AT_EACCESS) == 0);\n}\n\nstatic bool\noverwrite_ok (struct cp_options const *x, char const *dst_name,\n              int dst_dirfd, char const *dst_relname,\n              struct stat const *dst_sb)\n{\n  if (! writable_destination (dst_dirfd, dst_relname, dst_sb->st_mode))\n    {\n      char perms[12];\t\t \n      strmode (dst_sb->st_mode, perms);\n      perms[10] = '\\0';\n      fprintf (stderr,\n               (x->move_mode || x->unlink_dest_before_opening\n                || x->unlink_dest_after_failed_open)\n               ? _(\"%s: replace %s, overriding mode %04lo (%s)? \")\n               : _(\"%s: unwritable %s (mode %04lo, %s); try anyway? \"),\n               program_name, quoteaf (dst_name),\n               (unsigned long int) (dst_sb->st_mode & CHMOD_MODE_BITS),\n               &perms[1]);\n    }\n  else\n    {\n      fprintf (stderr, _(\"%s: overwrite %s? \"),\n               program_name, quoteaf (dst_name));\n    }\n\n  return yesno ();\n}\n\n \nextern void\ndest_info_init (struct cp_options *x)\n{\n  x->dest_info\n    = hash_initialize (DEST_INFO_INITIAL_CAPACITY,\n                       nullptr,\n                       triple_hash,\n                       triple_compare,\n                       triple_free);\n  if (! x->dest_info)\n    xalloc_die ();\n}\n\n \nextern void\nsrc_info_init (struct cp_options *x)\n{\n\n   \n  x->src_info\n    = hash_initialize (DEST_INFO_INITIAL_CAPACITY,\n                       nullptr,\n                       triple_hash_no_name,\n                       triple_compare,\n                       triple_free);\n  if (! x->src_info)\n    xalloc_die ();\n}\n\n \nstatic bool\nabandon_move (const struct cp_options *x,\n              char const *dst_name,\n              int dst_dirfd, char const *dst_relname,\n              struct stat const *dst_sb)\n{\n  affirm (x->move_mode);\n  return (x->interactive == I_ALWAYS_NO\n          || x->interactive == I_ALWAYS_SKIP\n          || ((x->interactive == I_ASK_USER\n               || (x->interactive == I_UNSPECIFIED\n                   && x->stdin_tty\n                   && ! writable_destination (dst_dirfd, dst_relname,\n                                              dst_sb->st_mode)))\n              && ! overwrite_ok (x, dst_name, dst_dirfd, dst_relname, dst_sb)));\n}\n\n \nstatic void\nemit_verbose (char const *src, char const *dst, char const *backup_dst_name)\n{\n  printf (\"%s -> %s\", quoteaf_n (0, src), quoteaf_n (1, dst));\n  if (backup_dst_name)\n    printf (_(\" (backup: %s)\"), quoteaf (backup_dst_name));\n  putchar ('\\n');\n}\n\n \nstatic void\nrestore_default_fscreatecon_or_die (void)\n{\n  if (setfscreatecon (nullptr) != 0)\n    error (EXIT_FAILURE, errno,\n           _(\"failed to restore the default file creation context\"));\n}\n\n \nstatic char *\nsubst_suffix (char const *str, char const *suffix, char const *newsuffix)\n{\n  idx_t prefixlen = suffix - str;\n  idx_t newsuffixsize = strlen (newsuffix) + 1;\n  char *r = ximalloc (prefixlen + newsuffixsize);\n  memcpy (r + prefixlen, newsuffix, newsuffixsize);\n  return memcpy (r, str, prefixlen);\n}\n\n \nstatic bool\ncreate_hard_link (char const *src_name, int src_dirfd, char const *src_relname,\n                  char const *dst_name, int dst_dirfd, char const *dst_relname,\n                  bool replace, bool verbose, bool dereference)\n{\n  int err = force_linkat (src_dirfd, src_relname, dst_dirfd, dst_relname,\n                          dereference ? AT_SYMLINK_FOLLOW : 0,\n                          replace, -1);\n  if (0 < err)\n    {\n\n      char *a_src_name = nullptr;\n      if (!src_name)\n        src_name = a_src_name = subst_suffix (dst_name, dst_relname,\n                                              src_relname);\n      error (0, err, _(\"cannot create hard link %s to %s\"),\n             quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n      free (a_src_name);\n      return false;\n    }\n  if (err < 0 && verbose)\n    printf (_(\"removed %s\\n\"), quoteaf (dst_name));\n  return true;\n}\n\n \nATTRIBUTE_PURE\nstatic inline bool\nshould_dereference (const struct cp_options *x, bool command_line_arg)\n{\n  return x->dereference == DEREF_ALWAYS\n         || (x->dereference == DEREF_COMMAND_LINE_ARGUMENTS\n             && command_line_arg);\n}\n\n \nstatic bool\nsource_is_dst_backup (char const *srcbase, struct stat const *src_st,\n                      int dst_dirfd, char const *dst_relname)\n{\n  size_t srcbaselen = strlen (srcbase);\n  char const *dstbase = last_component (dst_relname);\n  size_t dstbaselen = strlen (dstbase);\n  size_t suffixlen = strlen (simple_backup_suffix);\n  if (! (srcbaselen == dstbaselen + suffixlen\n         && memcmp (srcbase, dstbase, dstbaselen) == 0\n         && STREQ (srcbase + dstbaselen, simple_backup_suffix)))\n    return false;\n  char *dst_back = subst_suffix (dst_relname,\n                                 dst_relname + strlen (dst_relname),\n                                 simple_backup_suffix);\n  struct stat dst_back_sb;\n  int dst_back_status = fstatat (dst_dirfd, dst_back, &dst_back_sb, 0);\n  free (dst_back);\n  return dst_back_status == 0 && SAME_INODE (*src_st, dst_back_sb);\n}\n\n \nstatic bool\ncopy_internal (char const *src_name, char const *dst_name,\n               int dst_dirfd, char const *dst_relname,\n               int nonexistent_dst,\n               struct stat const *parent,\n               struct dir_list *ancestors,\n               const struct cp_options *x,\n               bool command_line_arg,\n               bool *first_dir_created_per_command_line_arg,\n               bool *copy_into_self,\n               bool *rename_succeeded)\n{\n  struct stat src_sb;\n  struct stat dst_sb;\n  mode_t src_mode IF_LINT ( = 0);\n  mode_t dst_mode IF_LINT ( = 0);\n  mode_t dst_mode_bits;\n  mode_t omitted_permissions;\n  bool restore_dst_mode = false;\n  char *earlier_file = nullptr;\n  char *dst_backup = nullptr;\n  char const *drelname = *dst_relname ? dst_relname : \".\";\n  bool delayed_ok;\n  bool copied_as_regular = false;\n  bool dest_is_symlink = false;\n  bool have_dst_lstat = false;\n\n   \n  bool new_dst = 0 < nonexistent_dst;\n\n  *copy_into_self = false;\n\n  int rename_errno = x->rename_errno;\n  if (x->move_mode)\n    {\n      if (rename_errno < 0)\n        rename_errno = (renameatu (AT_FDCWD, src_name, dst_dirfd, drelname,\n                                   RENAME_NOREPLACE)\n                        ? errno : 0);\n      nonexistent_dst = *rename_succeeded = new_dst = rename_errno == 0;\n    }\n\n  if (rename_errno == 0\n      ? !x->last_file\n      : rename_errno != EEXIST\n        || (x->interactive != I_ALWAYS_NO && x->interactive != I_ALWAYS_SKIP))\n    {\n      char const *name = rename_errno == 0 ? dst_name : src_name;\n      int dirfd = rename_errno == 0 ? dst_dirfd : AT_FDCWD;\n      char const *relname = rename_errno == 0 ? drelname : src_name;\n      int fstatat_flags\n        = x->dereference == DEREF_NEVER ? AT_SYMLINK_NOFOLLOW : 0;\n      if (follow_fstatat (dirfd, relname, &src_sb, fstatat_flags) != 0)\n        {\n          error (0, errno, _(\"cannot stat %s\"), quoteaf (name));\n          return false;\n        }\n\n      src_mode = src_sb.st_mode;\n\n      if (S_ISDIR (src_mode) && !x->recursive)\n        {\n          error (0, 0, ! x->install_mode  \n                 ? _(\"-r not specified; omitting directory %s\")\n                 : _(\"omitting directory %s\"),\n                 quoteaf (src_name));\n          return false;\n        }\n    }\n  else\n    {\n#if defined lint && (defined __clang__ || defined __COVERITY__)\n      affirm (x->move_mode);\n      memset (&src_sb, 0, sizeof src_sb);\n#endif\n    }\n\n   \n  if (command_line_arg && x->src_info)\n    {\n      if ( ! S_ISDIR (src_mode)\n           && x->backup_type == no_backups\n           && seen_file (x->src_info, src_name, &src_sb))\n        {\n          error (0, 0, _(\"warning: source file %s specified more than once\"),\n                 quoteaf (src_name));\n          return true;\n        }\n\n      record_file (x->src_info, src_name, &src_sb);\n    }\n\n  bool dereference = should_dereference (x, command_line_arg);\n\n  if (nonexistent_dst <= 0)\n    {\n      if (! (rename_errno == EEXIST\n             && (x->interactive == I_ALWAYS_NO\n                 || x->interactive == I_ALWAYS_SKIP)))\n        {\n           \n          bool use_lstat\n            = ((! S_ISREG (src_mode)\n                && (! x->copy_as_regular\n                    || S_ISDIR (src_mode) || S_ISLNK (src_mode)))\n               || x->move_mode || x->symbolic_link || x->hard_link\n               || x->backup_type != no_backups\n               || x->unlink_dest_before_opening);\n          int fstatat_flags = use_lstat ? AT_SYMLINK_NOFOLLOW : 0;\n          if (!use_lstat && nonexistent_dst < 0)\n            new_dst = true;\n          else if (follow_fstatat (dst_dirfd, drelname, &dst_sb, fstatat_flags)\n                   == 0)\n            {\n              have_dst_lstat = use_lstat;\n              rename_errno = EEXIST;\n            }\n          else\n            {\n              if (errno == ELOOP && x->unlink_dest_after_failed_open)\n                 ;\n              else if (errno != ENOENT)\n                {\n                  error (0, errno, _(\"cannot stat %s\"), quoteaf (dst_name));\n                  return false;\n                }\n              else\n                new_dst = true;\n            }\n        }\n\n      if (rename_errno == EEXIST)\n        {\n          bool return_now = false;\n          bool return_val = true;\n          bool skipped = false;\n\n          if ((x->interactive != I_ALWAYS_NO && x->interactive != I_ALWAYS_SKIP)\n              && ! same_file_ok (src_name, &src_sb, dst_dirfd, drelname,\n                                 &dst_sb, x, &return_now))\n            {\n              error (0, 0, _(\"%s and %s are the same file\"),\n                     quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n              return false;\n            }\n\n          if (x->update && !S_ISDIR (src_mode))\n            {\n               \n              int options = ((x->preserve_timestamps\n                              && ! (x->move_mode\n                                    && dst_sb.st_dev == src_sb.st_dev))\n                             ? UTIMECMP_TRUNCATE_SOURCE\n                             : 0);\n\n              if (0 <= utimecmpat (dst_dirfd, dst_relname, &dst_sb,\n                                   &src_sb, options))\n                {\n                   \n                  if (rename_succeeded)\n                    *rename_succeeded = true;\n\n                   \n                  earlier_file = remember_copied (dst_relname, src_sb.st_ino,\n                                                  src_sb.st_dev);\n                  if (earlier_file)\n                    {\n                       \n                      if (! create_hard_link (nullptr, dst_dirfd, earlier_file,\n                                              dst_name, dst_dirfd, dst_relname,\n                                              true,\n                                              x->verbose, dereference))\n                        {\n                          goto un_backup;\n                        }\n                    }\n\n                  skipped = true;\n                  goto skip;\n                }\n            }\n\n           \n          if (x->move_mode)\n            {\n              if (abandon_move (x, dst_name, dst_dirfd, drelname, &dst_sb))\n                {\n                   \n                  if (rename_succeeded)\n                    *rename_succeeded = true;\n\n                  skipped = true;\n                  return_val = x->interactive == I_ALWAYS_SKIP;\n                }\n            }\n          else\n            {\n              if (! S_ISDIR (src_mode)\n                  && (x->interactive == I_ALWAYS_NO\n                      || x->interactive == I_ALWAYS_SKIP\n                      || (x->interactive == I_ASK_USER\n                          && ! overwrite_ok (x, dst_name, dst_dirfd,\n                                             dst_relname, &dst_sb))))\n                {\n                  skipped = true;\n                  return_val = x->interactive == I_ALWAYS_SKIP;\n                }\n            }\n\nskip:\n          if (skipped)\n            {\n              if (x->interactive == I_ALWAYS_NO)\n                error (0, 0, _(\"not replacing %s\"), quoteaf (dst_name));\n              else if (x->debug)\n                printf (_(\"skipped %s\\n\"), quoteaf (dst_name));\n\n              return_now = true;\n            }\n\n          if (return_now)\n            return return_val;\n\n          if (!S_ISDIR (dst_sb.st_mode))\n            {\n              if (S_ISDIR (src_mode))\n                {\n                  if (x->move_mode && x->backup_type != no_backups)\n                    {\n                       \n                    }\n                  else\n                    {\n                      error (0, 0,\n                       _(\"cannot overwrite non-directory %s with directory %s\"),\n                             quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n                      return false;\n                    }\n                }\n\n               \n              if (command_line_arg\n                  && x->backup_type != numbered_backups\n                  && seen_file (x->dest_info, dst_relname, &dst_sb))\n                {\n                  error (0, 0,\n                         _(\"will not overwrite just-created %s with %s\"),\n                         quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n                  return false;\n                }\n            }\n\n          if (!S_ISDIR (src_mode))\n            {\n              if (S_ISDIR (dst_sb.st_mode))\n                {\n                  if (x->move_mode && x->backup_type != no_backups)\n                    {\n                       \n                    }\n                  else\n                    {\n                      error (0, 0,\n                         _(\"cannot overwrite directory %s with non-directory\"),\n                             quoteaf (dst_name));\n                      return false;\n                    }\n                }\n            }\n\n          if (x->move_mode)\n            {\n               \n              if (S_ISDIR (src_sb.st_mode) && !S_ISDIR (dst_sb.st_mode)\n                  && x->backup_type == no_backups)\n                {\n                  error (0, 0,\n                       _(\"cannot move directory onto non-directory: %s -> %s\"),\n                         quotef_n (0, src_name), quotef_n (0, dst_name));\n                  return false;\n                }\n            }\n\n          char const *srcbase;\n          if (x->backup_type != no_backups\n               \n              && ! dot_or_dotdot (srcbase = last_component (src_name))\n               \n              && (x->move_mode || ! S_ISDIR (dst_sb.st_mode)))\n            {\n               \n              if (x->backup_type != numbered_backups\n                  && source_is_dst_backup (srcbase, &src_sb,\n                                           dst_dirfd, dst_relname))\n                {\n                  char const *fmt;\n                  fmt = (x->move_mode\n                 ? _(\"backing up %s might destroy source;  %s not moved\")\n                 : _(\"backing up %s might destroy source;  %s not copied\"));\n                  error (0, 0, fmt,\n                         quoteaf_n (0, dst_name),\n                         quoteaf_n (1, src_name));\n                  return false;\n                }\n\n              char *tmp_backup = backup_file_rename (dst_dirfd, dst_relname,\n                                                     x->backup_type);\n\n               \n              if (tmp_backup)\n                {\n                  idx_t dirlen = dst_relname - dst_name;\n                  idx_t backupsize = strlen (tmp_backup) + 1;\n                  dst_backup = alloca (dirlen + backupsize);\n                  memcpy (mempcpy (dst_backup, dst_name, dirlen),\n                          tmp_backup, backupsize);\n                  free (tmp_backup);\n                }\n              else if (errno != ENOENT)\n                {\n                  error (0, errno, _(\"cannot backup %s\"), quoteaf (dst_name));\n                  return false;\n                }\n              new_dst = true;\n            }\n          else if (! S_ISDIR (dst_sb.st_mode)\n                    \n                   && ! x->move_mode\n                   && (x->unlink_dest_before_opening\n                       || (x->data_copy_required\n                           && ((x->preserve_links && 1 < dst_sb.st_nlink)\n                               || (x->dereference == DEREF_NEVER\n                                   && ! S_ISREG (src_sb.st_mode))))\n                      ))\n            {\n              if (unlinkat (dst_dirfd, dst_relname, 0) != 0 && errno != ENOENT)\n                {\n                  error (0, errno, _(\"cannot remove %s\"), quoteaf (dst_name));\n                  return false;\n                }\n              new_dst = true;\n              if (x->verbose)\n                printf (_(\"removed %s\\n\"), quoteaf (dst_name));\n            }\n        }\n    }\n\n   \n  if (command_line_arg\n      && x->dest_info\n      && ! x->move_mode\n      && x->backup_type == no_backups)\n    {\n      bool lstat_ok = true;\n      struct stat tmp_buf;\n      struct stat *dst_lstat_sb;\n\n       \n      if (have_dst_lstat)\n        dst_lstat_sb = &dst_sb;\n      else if (fstatat (dst_dirfd, drelname, &tmp_buf, AT_SYMLINK_NOFOLLOW)\n               == 0)\n        dst_lstat_sb = &tmp_buf;\n      else\n        lstat_ok = false;\n\n       \n      if (lstat_ok\n          && S_ISLNK (dst_lstat_sb->st_mode)\n          && seen_file (x->dest_info, dst_relname, dst_lstat_sb))\n        {\n          error (0, 0,\n                 _(\"will not copy %s through just-created symlink %s\"),\n                 quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n          return false;\n        }\n    }\n\n   \n  if (x->verbose && !x->move_mode && !S_ISDIR (src_mode))\n    emit_verbose (src_name, dst_name, dst_backup);\n\n   \n\n  if (rename_errno == 0)\n    earlier_file = nullptr;\n  else if (x->recursive && S_ISDIR (src_mode))\n    {\n      if (command_line_arg)\n        earlier_file = remember_copied (dst_relname,\n                                        src_sb.st_ino, src_sb.st_dev);\n      else\n        earlier_file = src_to_dest_lookup (src_sb.st_ino, src_sb.st_dev);\n    }\n  else if (x->move_mode && src_sb.st_nlink == 1)\n    {\n      earlier_file = src_to_dest_lookup (src_sb.st_ino, src_sb.st_dev);\n    }\n  else if (x->preserve_links\n           && !x->hard_link\n           && (1 < src_sb.st_nlink\n               || (command_line_arg\n                   && x->dereference == DEREF_COMMAND_LINE_ARGUMENTS)\n               || x->dereference == DEREF_ALWAYS))\n    {\n      earlier_file = remember_copied (dst_relname,\n                                      src_sb.st_ino, src_sb.st_dev);\n    }\n\n   \n\n  if (earlier_file)\n    {\n       \n      if (S_ISDIR (src_mode))\n        {\n           \n          if (same_nameat (AT_FDCWD, src_name, dst_dirfd, earlier_file))\n            {\n              error (0, 0, _(\"cannot copy a directory, %s, into itself, %s\"),\n                     quoteaf_n (0, top_level_src_name),\n                     quoteaf_n (1, top_level_dst_name));\n              *copy_into_self = true;\n              goto un_backup;\n            }\n          else if (same_nameat (dst_dirfd, dst_relname,\n                                dst_dirfd, earlier_file))\n            {\n              error (0, 0, _(\"warning: source directory %s \"\n                             \"specified more than once\"),\n                     quoteaf (top_level_src_name));\n               \n              if (x->move_mode && rename_succeeded)\n                *rename_succeeded = true;\n               \n              return true;\n            }\n          else if (x->dereference == DEREF_ALWAYS\n                   || (command_line_arg\n                       && x->dereference == DEREF_COMMAND_LINE_ARGUMENTS))\n            {\n               \n            }\n          else\n            {\n              char *earlier = subst_suffix (dst_name, dst_relname,\n                                            earlier_file);\n              error (0, 0, _(\"will not create hard link %s to directory %s\"),\n                     quoteaf_n (0, dst_name), quoteaf_n (1, earlier));\n              free (earlier);\n              goto un_backup;\n            }\n        }\n      else\n        {\n          if (! create_hard_link (nullptr, dst_dirfd, earlier_file,\n                                  dst_name, dst_dirfd, dst_relname,\n                                  true, x->verbose, dereference))\n            goto un_backup;\n\n          return true;\n        }\n    }\n\n  if (x->move_mode)\n    {\n      if (rename_errno == EEXIST)\n        rename_errno = (renameat (AT_FDCWD, src_name, dst_dirfd, drelname) == 0\n                        ? 0 : errno);\n\n      if (rename_errno == 0)\n        {\n          if (x->verbose)\n            {\n              printf (_(\"renamed \"));\n              emit_verbose (src_name, dst_name, dst_backup);\n            }\n\n          if (x->set_security_context)\n            {\n               \n              (void) set_file_security_ctx (dst_name, true, x);\n            }\n\n          if (rename_succeeded)\n            *rename_succeeded = true;\n\n          if (command_line_arg && !x->last_file)\n            {\n               \n               \n              record_file (x->dest_info, dst_relname, &src_sb);\n            }\n\n          return true;\n        }\n\n       \n\n       \n      if (rename_errno == EINVAL)\n        {\n           \n          error (0, 0, _(\"cannot move %s to a subdirectory of itself, %s\"),\n                 quoteaf_n (0, top_level_src_name),\n                 quoteaf_n (1, top_level_dst_name));\n\n           \n\n          *copy_into_self = true;\n           \n          return true;\n        }\n\n       \n      if (rename_errno != EXDEV || x->no_copy)\n        {\n           \n          char const *quoted_dst_name = quoteaf_n (1, dst_name);\n          switch (rename_errno)\n            {\n            case EDQUOT: case EEXIST: case EISDIR: case EMLINK:\n            case ENOSPC: case ETXTBSY:\n#if ENOTEMPTY != EEXIST\n            case ENOTEMPTY:\n#endif\n               \n              error (0, rename_errno, _(\"cannot overwrite %s\"),\n                     quoted_dst_name);\n              break;\n\n            default:\n              error (0, rename_errno, _(\"cannot move %s to %s\"),\n                     quoteaf_n (0, src_name), quoted_dst_name);\n              break;\n            }\n          forget_created (src_sb.st_ino, src_sb.st_dev);\n          return false;\n        }\n\n       \n      if ((unlinkat (dst_dirfd, drelname,\n                     S_ISDIR (src_mode) ? AT_REMOVEDIR : 0)\n           != 0)\n          && errno != ENOENT)\n        {\n          error (0, errno,\n             _(\"inter-device move failed: %s to %s; unable to remove target\"),\n                 quoteaf_n (0, src_name), quoteaf_n (1, dst_name));\n          forget_created (src_sb.st_ino, src_sb.st_dev);\n          return false;\n        }\n\n      if (x->verbose && !S_ISDIR (src_mode))\n        {\n          printf (_(\"copied \"));\n          emit_verbose (src_name, dst_name, dst_backup);\n        }\n      new_dst = true;\n    }\n\n   \n  dst_mode_bits = (x->set_mode ? x->mode : src_mode) & CHMOD_MODE_BITS;\n  omitted_permissions =\n    (dst_mode_bits\n     & (x->preserve_ownership ? S_IRWXG | S_IRWXO\n        : S_ISDIR (src_mode) ? S_IWGRP | S_IWOTH\n        : 0));\n\n  delayed_ok = true;\n\n   \n  if (! set_process_security_ctx (src_name, dst_name, src_mode, new_dst, x))\n    return false;\n\n  if (S_ISDIR (src_mode))\n    {\n      struct dir_list *dir;\n\n       \n\n      if (is_ancestor (&src_sb, ancestors))\n        {\n          error (0, 0, _(\"cannot copy cyclic symbolic link %s\"),\n                 quoteaf (src_name));\n          goto un_backup;\n        }\n\n       \n\n      dir = alloca (sizeof *dir);\n      dir->parent = ancestors;\n      dir->ino = src_sb.st_ino;\n      dir->dev = src_sb.st_dev;\n\n      if (new_dst || !S_ISDIR (dst_sb.st_mode))\n        {\n           \n          mode_t mode = dst_mode_bits & ~omitted_permissions;\n          if (mkdirat (dst_dirfd, drelname, mode) != 0)\n            {\n              error (0, errno, _(\"cannot create directory %s\"),\n                     quoteaf (dst_name));\n              goto un_backup;\n            }\n\n           \n\n          if (fstatat (dst_dirfd, drelname, &dst_sb, AT_SYMLINK_NOFOLLOW) != 0)\n            {\n              error (0, errno, _(\"cannot stat %s\"), quoteaf (dst_name));\n              goto un_backup;\n            }\n          else if ((dst_sb.st_mode & S_IRWXU) != S_IRWXU)\n            {\n               \n\n              dst_mode = dst_sb.st_mode;\n              restore_dst_mode = true;\n\n              if (lchmodat (dst_dirfd, drelname, dst_mode | S_IRWXU) != 0)\n                {\n                  error (0, errno, _(\"setting permissions for %s\"),\n                         quoteaf (dst_name));\n                  goto un_backup;\n                }\n            }\n\n           \n          if (!*first_dir_created_per_command_line_arg)\n            {\n              remember_copied (dst_relname, dst_sb.st_ino, dst_sb.st_dev);\n              *first_dir_created_per_command_line_arg = true;\n            }\n\n          if (x->verbose)\n            {\n              if (x->move_mode)\n                printf (_(\"created directory %s\\n\"), quoteaf (dst_name));\n              else\n                emit_verbose (src_name, dst_name, nullptr);\n            }\n        }\n      else\n        {\n          omitted_permissions = 0;\n\n           \n          if (x->set_security_context || x->preserve_security_context)\n            if (! set_file_security_ctx (dst_name, false, x))\n              {\n                if (x->require_preserve_context)\n                  goto un_backup;\n              }\n        }\n\n       \n      if (x->one_file_system && parent && parent->st_dev != src_sb.st_dev)\n        {\n           \n        }\n      else\n        {\n           \n          delayed_ok = copy_dir (src_name, dst_name, dst_dirfd, dst_relname,\n                                 new_dst, &src_sb, dir, x,\n                                 first_dir_created_per_command_line_arg,\n                                 copy_into_self);\n        }\n    }\n  else if (x->symbolic_link)\n    {\n      dest_is_symlink = true;\n      if (*src_name != '/')\n        {\n           \n          struct stat dot_sb;\n          struct stat dst_parent_sb;\n          char *dst_parent;\n          bool in_current_dir;\n\n          dst_parent = dir_name (dst_relname);\n\n          in_current_dir = ((dst_dirfd == AT_FDCWD && STREQ (\".\", dst_parent))\n                             \n                            || stat (\".\", &dot_sb) != 0\n                            || (fstatat (dst_dirfd, dst_parent, &dst_parent_sb,\n                                         0) != 0)\n                            || SAME_INODE (dot_sb, dst_parent_sb));\n          free (dst_parent);\n\n          if (! in_current_dir)\n            {\n              error (0, 0,\n           _(\"%s: can make relative symbolic links only in current directory\"),\n                     quotef (dst_name));\n              goto un_backup;\n            }\n        }\n\n      int err = force_symlinkat (src_name, dst_dirfd, dst_relname,\n                                 x->unlink_dest_after_failed_open, -1);\n      if (0 < err)\n        {\n          error (0, err, _(\"cannot create symbolic link %s to %s\"),\n                 quoteaf_n (0, dst_name), quoteaf_n (1, src_name));\n          goto un_backup;\n        }\n    }\n\n   \n  else if (x->hard_link\n           && !(! CAN_HARDLINK_SYMLINKS && S_ISLNK (src_mode)\n                && x->dereference == DEREF_NEVER))\n    {\n      bool replace = (x->unlink_dest_after_failed_open\n                      || x->interactive == I_ASK_USER);\n      if (! create_hard_link (src_name, AT_FDCWD, src_name,\n                              dst_name, dst_dirfd, dst_relname,\n                              replace, false, dereference))\n        goto un_backup;\n    }\n  else if (S_ISREG (src_mode)\n           || (x->copy_as_regular && !S_ISLNK (src_mode)))\n    {\n      copied_as_regular = true;\n       \n      if (! copy_reg (src_name, dst_name, dst_dirfd, dst_relname,\n                      x, dst_mode_bits & S_IRWXUGO,\n                      omitted_permissions, &new_dst, &src_sb))\n        goto un_backup;\n    }\n  else if (S_ISFIFO (src_mode))\n    {\n       \n      mode_t mode = src_mode & ~omitted_permissions;\n      if (mknodat (dst_dirfd, dst_relname, mode, 0) != 0)\n        if (mkfifoat (dst_dirfd, dst_relname, mode & ~S_IFIFO) != 0)\n          {\n            error (0, errno, _(\"cannot create fifo %s\"), quoteaf (dst_name));\n            goto un_backup;\n          }\n    }\n  else if (S_ISBLK (src_mode) || S_ISCHR (src_mode) || S_ISSOCK (src_mode))\n    {\n      mode_t mode = src_mode & ~omitted_permissions;\n      if (mknodat (dst_dirfd, dst_relname, mode, src_sb.st_rdev) != 0)\n        {\n          error (0, errno, _(\"cannot create special file %s\"),\n                 quoteaf (dst_name));\n          goto un_backup;\n        }\n    }\n  else if (S_ISLNK (src_mode))\n    {\n      char *src_link_val = areadlink_with_size (src_name, src_sb.st_size);\n      dest_is_symlink = true;\n      if (src_link_val == nullptr)\n        {\n          error (0, errno, _(\"cannot read symbolic link %s\"),\n                 quoteaf (src_name));\n          goto un_backup;\n        }\n\n      int symlink_err = force_symlinkat (src_link_val, dst_dirfd, dst_relname,\n                                         x->unlink_dest_after_failed_open, -1);\n      if (0 < symlink_err && x->update && !new_dst && S_ISLNK (dst_sb.st_mode)\n          && dst_sb.st_size == strlen (src_link_val))\n        {\n           \n          char *dest_link_val =\n            areadlinkat_with_size (dst_dirfd, dst_relname, dst_sb.st_size);\n          if (dest_link_val)\n            {\n              if (STREQ (dest_link_val, src_link_val))\n                symlink_err = 0;\n              free (dest_link_val);\n            }\n        }\n      free (src_link_val);\n      if (0 < symlink_err)\n        {\n          error (0, symlink_err, _(\"cannot create symbolic link %s\"),\n                 quoteaf (dst_name));\n          goto un_backup;\n        }\n\n      if (x->preserve_security_context)\n        restore_default_fscreatecon_or_die ();\n\n      if (x->preserve_ownership)\n        {\n           \n          if (HAVE_LCHOWN\n              && (lchownat (dst_dirfd, dst_relname,\n                            src_sb.st_uid, src_sb.st_gid)\n                  != 0)\n              && ! chown_failure_ok (x))\n            {\n              error (0, errno, _(\"failed to preserve ownership for %s\"),\n                     dst_name);\n              if (x->require_preserve)\n                goto un_backup;\n            }\n          else\n            {\n               \n            }\n        }\n    }\n  else\n    {\n      error (0, 0, _(\"%s has unknown file type\"), quoteaf (src_name));\n      goto un_backup;\n    }\n\n   \n  if (!new_dst && !x->copy_as_regular && !S_ISDIR (src_mode)\n      && (x->set_security_context || x->preserve_security_context))\n    {\n      if (! set_file_security_ctx (dst_name, false, x))\n        {\n           if (x->require_preserve_context)\n             goto un_backup;\n        }\n    }\n\n  if (command_line_arg && x->dest_info)\n    {\n       \n      struct stat sb;\n      if (fstatat (dst_dirfd, drelname, &sb, AT_SYMLINK_NOFOLLOW) == 0)\n        record_file (x->dest_info, dst_relname, &sb);\n    }\n\n   \n  if (x->hard_link && ! S_ISDIR (src_mode)\n      && !(! CAN_HARDLINK_SYMLINKS && S_ISLNK (src_mode)\n           && x->dereference == DEREF_NEVER))\n    return delayed_ok;\n\n  if (copied_as_regular)\n    return delayed_ok;\n\n   \n\n   \n\n  if (x->preserve_timestamps)\n    {\n      struct timespec timespec[2];\n      timespec[0] = get_stat_atime (&src_sb);\n      timespec[1] = get_stat_mtime (&src_sb);\n\n      int utimensat_flags = dest_is_symlink ? AT_SYMLINK_NOFOLLOW : 0;\n      if (utimensat (dst_dirfd, drelname, timespec, utimensat_flags) != 0)\n        {\n          error (0, errno, _(\"preserving times for %s\"), quoteaf (dst_name));\n          if (x->require_preserve)\n            return false;\n        }\n    }\n\n   \n  if (!dest_is_symlink && x->preserve_ownership\n      && (new_dst || !SAME_OWNER_AND_GROUP (src_sb, dst_sb)))\n    {\n      switch (set_owner (x, dst_name, dst_dirfd, drelname, -1,\n                         &src_sb, new_dst, &dst_sb))\n        {\n        case -1:\n          return false;\n\n        case 0:\n          src_mode &= ~ (S_ISUID | S_ISGID | S_ISVTX);\n          break;\n        }\n    }\n\n   \n  if (x->preserve_xattr && ! copy_attr (src_name, -1, dst_name, -1, x)\n      && x->require_preserve_xattr)\n    return false;\n\n   \n  if (dest_is_symlink)\n    return delayed_ok;\n\n  set_author (dst_name, -1, &src_sb);\n\n  if (x->preserve_mode || x->move_mode)\n    {\n      if (copy_acl (src_name, -1, dst_name, -1, src_mode) != 0\n          && x->require_preserve)\n        return false;\n    }\n  else if (x->set_mode)\n    {\n      if (set_acl (dst_name, -1, x->mode) != 0)\n        return false;\n    }\n  else if (x->explicit_no_preserve_mode && new_dst)\n    {\n      int default_permissions = S_ISDIR (src_mode) || S_ISSOCK (src_mode)\n                                ? S_IRWXUGO : MODE_RW_UGO;\n      if (set_acl (dst_name, -1, default_permissions & ~cached_umask ()) != 0)\n        return false;\n    }\n  else\n    {\n      if (omitted_permissions)\n        {\n          omitted_permissions &= ~ cached_umask ();\n\n          if (omitted_permissions && !restore_dst_mode)\n            {\n               \n              if (new_dst && (fstatat (dst_dirfd, drelname, &dst_sb,\n                                       AT_SYMLINK_NOFOLLOW)\n                              != 0))\n                {\n                  error (0, errno, _(\"cannot stat %s\"), quoteaf (dst_name));\n                  return false;\n                }\n              dst_mode = dst_sb.st_mode;\n              if (omitted_permissions & ~dst_mode)\n                restore_dst_mode = true;\n            }\n        }\n\n      if (restore_dst_mode)\n        {\n          if (lchmodat (dst_dirfd, drelname, dst_mode | omitted_permissions)\n              != 0)\n            {\n              error (0, errno, _(\"preserving permissions for %s\"),\n                     quoteaf (dst_name));\n              if (x->require_preserve)\n                return false;\n            }\n        }\n    }\n\n  return delayed_ok;\n\nun_backup:\n\n  if (x->preserve_security_context)\n    restore_default_fscreatecon_or_die ();\n\n   \n  if (earlier_file == nullptr)\n    forget_created (src_sb.st_ino, src_sb.st_dev);\n\n  if (dst_backup)\n    {\n      char const *dst_relbackup = &dst_backup[dst_relname - dst_name];\n      if (renameat (dst_dirfd, dst_relbackup, dst_dirfd, drelname) != 0)\n        error (0, errno, _(\"cannot un-backup %s\"), quoteaf (dst_name));\n      else\n        {\n          if (x->verbose)\n            printf (_(\"%s -> %s (unbackup)\\n\"),\n                    quoteaf_n (0, dst_backup), quoteaf_n (1, dst_name));\n        }\n    }\n  return false;\n}\n\nstatic void\nvalid_options (const struct cp_options *co)\n{\n  affirm (VALID_BACKUP_TYPE (co->backup_type));\n  affirm (VALID_SPARSE_MODE (co->sparse_mode));\n  affirm (VALID_REFLINK_MODE (co->reflink_mode));\n  affirm (!(co->hard_link && co->symbolic_link));\n  affirm (!\n          (co->reflink_mode == REFLINK_ALWAYS\n           && co->sparse_mode != SPARSE_AUTO));\n}\n\n \n\nextern bool\ncopy (char const *src_name, char const *dst_name,\n      int dst_dirfd, char const *dst_relname,\n      int nonexistent_dst, const struct cp_options *options,\n      bool *copy_into_self, bool *rename_succeeded)\n{\n  valid_options (options);\n\n   \n  top_level_src_name = src_name;\n  top_level_dst_name = dst_name;\n\n  bool first_dir_created_per_command_line_arg = false;\n  return copy_internal (src_name, dst_name, dst_dirfd, dst_relname,\n                        nonexistent_dst, nullptr, nullptr,\n                        options, true,\n                        &first_dir_created_per_command_line_arg,\n                        copy_into_self, rename_succeeded);\n}\n\n \n\nextern void\ncp_options_default (struct cp_options *x)\n{\n  memset (x, 0, sizeof *x);\n#ifdef PRIV_FILE_CHOWN\n  {\n    priv_set_t *pset = priv_allocset ();\n    if (!pset)\n      xalloc_die ();\n    if (getppriv (PRIV_EFFECTIVE, pset) == 0)\n      {\n        x->chown_privileges = priv_ismember (pset, PRIV_FILE_CHOWN);\n        x->owner_privileges = priv_ismember (pset, PRIV_FILE_OWNER);\n      }\n    priv_freeset (pset);\n  }\n#else\n  x->chown_privileges = x->owner_privileges = (geteuid () == ROOT_UID);\n#endif\n  x->rename_errno = -1;\n}\n\n \n\nextern bool\nchown_failure_ok (struct cp_options const *x)\n{\n   \n\n  return ((errno == EPERM || errno == EINVAL) && !x->chown_privileges);\n}\n\n \n\nstatic bool\nowner_failure_ok (struct cp_options const *x)\n{\n  return ((errno == EPERM || errno == EINVAL) && !x->owner_privileges);\n}\n\n \nextern mode_t\ncached_umask (void)\n{\n  static mode_t mask = (mode_t) -1;\n  if (mask == (mode_t) -1)\n    {\n      mask = umask (0);\n      umask (mask);\n    }\n  return mask;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}