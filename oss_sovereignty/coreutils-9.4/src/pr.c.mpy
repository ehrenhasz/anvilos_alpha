{
  "module_name": "pr.c",
  "hash_id": "32009cf7984ae0fcea7753ef41bbf616cf1e5d05bfca151211c737b7254fc6bd",
  "original_prompt": "Ingested from coreutils-9.4/src/pr.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <getopt.h>\n#include <stdckdint.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"fadvise.h\"\n#include \"hard-locale.h\"\n#include \"mbswidth.h\"\n#include \"quote.h\"\n#include \"stat-time.h\"\n#include \"stdio--.h\"\n#include \"strftime.h\"\n#include \"xstrtol.h\"\n#include \"xstrtol-error.h\"\n#include \"xdectoint.h\"\n\n \n#define PROGRAM_NAME \"pr\"\n\n#define AUTHORS \\\n  proper_name (\"Pete TerMaat\"), \\\n  proper_name (\"Roland Huebner\")\n\n \n#define ANYWHERE\t0\n\n \n\n \n\nstruct COLUMN;\nstruct COLUMN\n  {\n    FILE *fp;\t\t\t \n    char const *name;\t\t \n    enum\n      {\n        OPEN,\n        FF_FOUND,\t\t \n        ON_HOLD,\t\t \n        CLOSED\n      }\n    status;\t\t\t \n\n     \n    bool (*print_func) (struct COLUMN *);\n\n     \n    void (*char_func) (char);\n\n    int current_line;\t\t \n    int lines_stored;\t\t \n    int lines_to_print;\t\t \n    int start_position;\t\t \n    bool numbered;\n    bool full_page_printed;\t \n\n     \n  };\n\ntypedef struct COLUMN COLUMN;\n\nstatic int char_to_clump (char c);\nstatic bool read_line (COLUMN *p);\nstatic bool print_page (void);\nstatic bool print_stored (COLUMN *p);\nstatic bool open_file (char *name, COLUMN *p);\nstatic bool skip_to_page (uintmax_t page);\nstatic void print_header (void);\nstatic void pad_across_to (int position);\nstatic void add_line_number (COLUMN *p);\nstatic void getoptnum (char const *n_str, int min, int *num,\n                       char const *errfmt);\nstatic void getoptarg (char *arg, char switch_char, char *character,\n                       int *number);\nstatic void print_files (int number_of_files, char **av);\nstatic void init_parameters (int number_of_files);\nstatic void init_header (char const *filename, int desc);\nstatic bool init_fps (int number_of_files, char **av);\nstatic void init_funcs (void);\nstatic void init_store_cols (void);\nstatic void store_columns (void);\nstatic void balance (int total_stored);\nstatic void store_char (char c);\nstatic void pad_down (unsigned int lines);\nstatic void read_rest_of_line (COLUMN *p);\nstatic void skip_read (COLUMN *p, int column_number);\nstatic void print_char (char c);\nstatic void cleanup (void);\nstatic void print_sep_string (void);\nstatic void separator_string (char const *optarg_S);\n\n \nstatic COLUMN *column_vector;\n\n \nstatic char *buff;\n\n \nstatic unsigned int buff_current;\n\n \nstatic size_t buff_allocated;\n\n \nstatic int *line_vector;\n\n \nstatic int *end_vector;\n\n \nstatic bool parallel_files = false;\n\n \nstatic bool align_empty_cols;\n\n \nstatic bool empty_line;\n\n \nstatic bool FF_only;\n\n \nstatic bool explicit_columns = false;\n\n \nstatic bool extremities = true;\n\n \nstatic bool keep_FF = false;\nstatic bool print_a_FF = false;\n\n \nstatic bool print_a_header;\n\n \nstatic bool use_form_feed = false;\n\n \nstatic bool have_read_stdin = false;\n\n \nstatic bool print_across_flag = false;\n\n \nstatic bool storing_columns = true;\n\n \n \nstatic bool balance_columns = false;\n\n \nstatic int lines_per_page = 66;\n\n \nenum { lines_per_header = 5 };\nstatic int lines_per_body;\nenum { lines_per_footer = 5 };\n\n \nstatic int chars_per_line = 72;\n\n \nstatic bool truncate_lines = false;\n\n \nstatic bool join_lines = false;\n\n \nstatic int chars_per_column;\n\n \nstatic bool untabify_input = false;\n\n \nstatic char input_tab_char = '\\t';\n\n \nstatic int chars_per_input_tab = 8;\n\n \nstatic bool tabify_output = false;\n\n \nstatic char output_tab_char = '\\t';\n\n \nstatic int chars_per_output_tab = 8;\n\n \nstatic int spaces_not_printed;\n\n \nstatic int chars_per_margin = 0;\n\n \nstatic int output_position;\n\n \nstatic int input_position;\n\n \nstatic bool failed_opens = false;\n\n \n#define TAB_WIDTH(c_, h_) ((c_) - ((h_) % (c_)))\n\n \n#define POS_AFTER_TAB(c_, h_) ((h_) + TAB_WIDTH (c_, h_))\n\n \nstatic int columns = 1;\n\n \nstatic uintmax_t first_page_number = 0;\nstatic uintmax_t last_page_number = UINTMAX_MAX;\n\n \nstatic int files_ready_to_read = 0;\n\n \nstatic uintmax_t page_number;\n\n \nstatic int line_number;\n\n \nstatic bool numbered_lines = false;\n\n \nstatic char number_separator = '\\t';\n\n \nstatic int line_count = 1;\n\n \nstatic bool skip_count = true;\n\n \nstatic int start_line_num = 1;\n\n \nstatic int chars_per_number = 5;\n\n \nstatic int number_width;\n\n \nstatic char *number_buff;\n\n \nstatic bool use_esc_sequence = false;\n\n \nstatic bool use_cntrl_prefix = false;\n\n \nstatic bool double_space = false;\n\n \nstatic int total_files = 0;\n\n \nstatic bool ignore_failed_opens = false;\n\n \nstatic bool use_col_separator = false;\n\n \nstatic char const *col_sep_string = \"\";\nstatic int col_sep_length = 0;\nstatic char *column_separator = (char *) \" \";\nstatic char *line_separator = (char *) \"\\t\";\n\n \nstatic int separators_not_printed;\n\n \nstatic int padding_not_printed;\n\n \nstatic bool pad_vertically;\n\n \nstatic char *custom_header;\n\n \nstatic char const *date_format;\n\n \nstatic timezone_t localtz;\n\n \nstatic char *date_text;\nstatic char const *file_text;\n\n \nstatic int header_width_available;\n\nstatic char *clump_buff;\n\n \nstatic bool last_line = false;\n\n \nenum\n{\n  COLUMNS_OPTION = CHAR_MAX + 1,\n  PAGES_OPTION\n};\n\nstatic char const short_options[] =\n  \"-0123456789D:FJN:S::TW:abcde::fh:i::l:mn::o:rs::tvw:\";\n\nstatic struct option const long_options[] =\n{\n  {\"pages\", required_argument, nullptr, PAGES_OPTION},\n  {\"columns\", required_argument, nullptr, COLUMNS_OPTION},\n  {\"across\", no_argument, nullptr, 'a'},\n  {\"show-control-chars\", no_argument, nullptr, 'c'},\n  {\"double-space\", no_argument, nullptr, 'd'},\n  {\"date-format\", required_argument, nullptr, 'D'},\n  {\"expand-tabs\", optional_argument, nullptr, 'e'},\n  {\"form-feed\", no_argument, nullptr, 'f'},\n  {\"header\", required_argument, nullptr, 'h'},\n  {\"output-tabs\", optional_argument, nullptr, 'i'},\n  {\"join-lines\", no_argument, nullptr, 'J'},\n  {\"length\", required_argument, nullptr, 'l'},\n  {\"merge\", no_argument, nullptr, 'm'},\n  {\"number-lines\", optional_argument, nullptr, 'n'},\n  {\"first-line-number\", required_argument, nullptr, 'N'},\n  {\"indent\", required_argument, nullptr, 'o'},\n  {\"no-file-warnings\", no_argument, nullptr, 'r'},\n  {\"separator\", optional_argument, nullptr, 's'},\n  {\"sep-string\", optional_argument, nullptr, 'S'},\n  {\"omit-header\", no_argument, nullptr, 't'},\n  {\"omit-pagination\", no_argument, nullptr, 'T'},\n  {\"show-nonprinting\", no_argument, nullptr, 'v'},\n  {\"width\", required_argument, nullptr, 'w'},\n  {\"page-width\", required_argument, nullptr, 'W'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nstatic _Noreturn void\ninteger_overflow (void)\n{\n  error (EXIT_FAILURE, 0, _(\"integer overflow\"));\n}\n\n \n\nATTRIBUTE_PURE\nstatic unsigned int\ncols_ready_to_print (void)\n{\n  COLUMN *q;\n  unsigned int i;\n  unsigned int n;\n\n  n = 0;\n  for (q = column_vector, i = 0; i < columns; ++q, ++i)\n    if (q->status == OPEN\n        || q->status == FF_FOUND\t \n        || (storing_columns && q->lines_stored > 0 && q->lines_to_print > 0))\n      ++n;\n  return n;\n}\n\n \n\nstatic bool\nfirst_last_page (int oi, char c, char const *pages)\n{\n  char *p;\n  uintmax_t first;\n  uintmax_t last = UINTMAX_MAX;\n  strtol_error err = xstrtoumax (pages, &p, 10, &first, \"\");\n  if (err != LONGINT_OK && err != LONGINT_INVALID_SUFFIX_CHAR)\n    xstrtol_fatal (err, oi, c, long_options, pages);\n\n  if (p == pages || !first)\n    return false;\n\n  if (*p == ':')\n    {\n      char const *p1 = p + 1;\n      err = xstrtoumax (p1, &p, 10, &last, \"\");\n      if (err != LONGINT_OK)\n        xstrtol_fatal (err, oi, c, long_options, pages);\n      if (p1 == p || last < first)\n        return false;\n    }\n\n  if (*p)\n    return false;\n\n  first_page_number = first;\n  last_page_number = last;\n  return true;\n}\n\n \n\nstatic void\nparse_column_count (char const *s)\n{\n  getoptnum (s, 1, &columns, _(\"invalid number of columns\"));\n  explicit_columns = true;\n}\n\n \n\nstatic void\nseparator_string (char const *optarg_S)\n{\n  size_t len = strlen (optarg_S);\n  if (INT_MAX < len)\n    integer_overflow ();\n  col_sep_length = len;\n  col_sep_string = optarg_S;\n}\n\nint\nmain (int argc, char **argv)\n{\n  unsigned int n_files;\n  bool old_options = false;\n  bool old_w = false;\n  bool old_s = false;\n  char **file_names;\n\n   \n  char *column_count_string = nullptr;\n  size_t n_digits = 0;\n  size_t n_alloc = 0;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  n_files = 0;\n  file_names = (argc > 1\n                ? xnmalloc (argc - 1, sizeof (char *))\n                : nullptr);\n\n  while (true)\n    {\n      int oi = -1;\n      int c = getopt_long (argc, argv, short_options, long_options, &oi);\n      if (c == -1)\n        break;\n\n      if (ISDIGIT (c))\n        {\n           \n          if (n_digits + 1 >= n_alloc)\n            column_count_string\n              = X2REALLOC (column_count_string, &n_alloc);\n          column_count_string[n_digits++] = c;\n          column_count_string[n_digits] = '\\0';\n          continue;\n        }\n\n      n_digits = 0;\n\n      switch (c)\n        {\n        case 1:\t\t\t \n           \n          if (! (first_page_number == 0\n                 && *optarg == '+' && first_last_page (-2, '+', optarg + 1)))\n            file_names[n_files++] = optarg;\n          break;\n\n        case PAGES_OPTION:\t \n          {\t\t\t \n            if (! optarg)\n              error (EXIT_FAILURE, 0,\n                     _(\"'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument\"));\n            else if (! first_last_page (oi, 0, optarg))\n              error (EXIT_FAILURE, 0, _(\"invalid page range %s\"),\n                     quote (optarg));\n            break;\n          }\n\n        case COLUMNS_OPTION:\t \n          {\n            parse_column_count (optarg);\n\n             \n            free (column_count_string);\n            column_count_string = nullptr;\n            n_alloc = 0;\n            break;\n          }\n\n        case 'a':\n          print_across_flag = true;\n          storing_columns = false;\n          break;\n        case 'b':\n          balance_columns = true;\n          break;\n        case 'c':\n          use_cntrl_prefix = true;\n          break;\n        case 'd':\n          double_space = true;\n          break;\n        case 'D':\n          date_format = optarg;\n          break;\n        case 'e':\n          if (optarg)\n            getoptarg (optarg, 'e', &input_tab_char,\n                       &chars_per_input_tab);\n           \n          untabify_input = true;\n          break;\n        case 'f':\n        case 'F':\n          use_form_feed = true;\n          break;\n        case 'h':\n          custom_header = optarg;\n          break;\n        case 'i':\n          if (optarg)\n            getoptarg (optarg, 'i', &output_tab_char,\n                       &chars_per_output_tab);\n           \n          tabify_output = true;\n          break;\n        case 'J':\n          join_lines = true;\n          break;\n        case 'l':\n          getoptnum (optarg, 1, &lines_per_page,\n                     _(\"'-l PAGE_LENGTH' invalid number of lines\"));\n          break;\n        case 'm':\n          parallel_files = true;\n          storing_columns = false;\n          break;\n        case 'n':\n          numbered_lines = true;\n          if (optarg)\n            getoptarg (optarg, 'n', &number_separator,\n                       &chars_per_number);\n          break;\n        case 'N':\n          skip_count = false;\n          getoptnum (optarg, INT_MIN, &start_line_num,\n                     _(\"'-N NUMBER' invalid starting line number\"));\n          break;\n        case 'o':\n          getoptnum (optarg, 0, &chars_per_margin,\n                     _(\"'-o MARGIN' invalid line offset\"));\n          break;\n        case 'r':\n          ignore_failed_opens = true;\n          break;\n        case 's':\n          old_options = true;\n          old_s = true;\n          if (!use_col_separator && optarg)\n            separator_string (optarg);\n          break;\n        case 'S':\n          old_s = false;\n           \n          col_sep_string = \"\";\n          col_sep_length = 0;\n          use_col_separator = true;\n          if (optarg)\n            separator_string (optarg);\n          break;\n        case 't':\n          extremities = false;\n          keep_FF = true;\n          break;\n        case 'T':\n          extremities = false;\n          keep_FF = false;\n          break;\n        case 'v':\n          use_esc_sequence = true;\n          break;\n        case 'w':\n          old_options = true;\n          old_w = true;\n          {\n            int tmp_cpl;\n            getoptnum (optarg, 1, &tmp_cpl,\n                       _(\"'-w PAGE_WIDTH' invalid number of characters\"));\n            if (! truncate_lines)\n              chars_per_line = tmp_cpl;\n          }\n          break;\n        case 'W':\n          old_w = false;\t\t\t \n          truncate_lines = true;\n          getoptnum (optarg, 1, &chars_per_line,\n                     _(\"'-W PAGE_WIDTH' invalid number of characters\"));\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n          break;\n        }\n    }\n\n  if (column_count_string)\n    {\n      parse_column_count (column_count_string);\n      free (column_count_string);\n    }\n\n  if (! date_format)\n    date_format = (getenv (\"POSIXLY_CORRECT\") && !hard_locale (LC_TIME)\n                   ? \"%b %e %H:%M %Y\"\n                   : \"%Y-%m-%d %H:%M\");\n\n  localtz = tzalloc (getenv (\"TZ\"));\n\n   \n  if (first_page_number == 0)\n    first_page_number = 1;\n\n  if (parallel_files && explicit_columns)\n    error (EXIT_FAILURE, 0,\n           _(\"cannot specify number of columns when printing in parallel\"));\n\n  if (parallel_files && print_across_flag)\n    error (EXIT_FAILURE, 0,\n           _(\"cannot specify both printing across and printing in parallel\"));\n\n \n\n  if (old_options)\n    {\n      if (old_w)\n        {\n          if (parallel_files || explicit_columns)\n            {\n               \n              truncate_lines = true;\n              if (old_s)\n                 \n                use_col_separator = true;\n            }\n          else\n             \n            join_lines = true;\n        }\n      else if (!use_col_separator)\n        {\n           \n          if (old_s && (parallel_files || explicit_columns))\n            {\n              if (!truncate_lines)\n                {\n                   \n                  join_lines = true;\n                  if (col_sep_length > 0)\n                     \n                    use_col_separator = true;\n                }\n              else\n                 \n                 \n                use_col_separator = true;\n            }\n        }\n    }\n\n  for (; optind < argc; optind++)\n    {\n      file_names[n_files++] = argv[optind];\n    }\n\n  if (n_files == 0)\n    {\n       \n      print_files (0, nullptr);\n    }\n  else\n    {\n      if (parallel_files)\n        print_files (n_files, file_names);\n      else\n        {\n          for (unsigned int i = 0; i < n_files; i++)\n            print_files (1, &file_names[i]);\n        }\n    }\n\n  cleanup ();\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    error (EXIT_FAILURE, errno, _(\"standard input\"));\n  main_exit (failed_opens ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\n \n\nstatic void\ngetoptnum (char const *n_str, int min, int *num, char const *err)\n{\n  intmax_t tnum = xdectoimax (n_str, min, INT_MAX, \"\", err, 0);\n  *num = tnum;\n}\n\n \n\nstatic void\ngetoptarg (char *arg, char switch_char, char *character, int *number)\n{\n  if (!*arg)\n    {\n      error (0, 0, _(\"'-%c': Invalid argument: %s\"), switch_char, quote (arg));\n      usage (EXIT_FAILURE);\n    }\n\n  if (!ISDIGIT (*arg))\n    *character = *arg++;\n  if (*arg)\n    {\n      long int tmp_long;\n      strtol_error e = xstrtol (arg, nullptr, 10, &tmp_long, \"\");\n      if (e == LONGINT_OK)\n        {\n          if (tmp_long <= 0)\n            e = LONGINT_INVALID;\n          else if (INT_MAX < tmp_long)\n            e = LONGINT_OVERFLOW;\n        }\n      if (e != LONGINT_OK)\n        {\n          error (0, e & LONGINT_OVERFLOW ? EOVERFLOW : 0,\n             _(\"'-%c' extra characters or invalid number in the argument: %s\"),\n                 switch_char, quote (arg));\n          usage (EXIT_FAILURE);\n        }\n      *number = tmp_long;\n    }\n}\n\n \n\nstatic void\ninit_parameters (int number_of_files)\n{\n  int chars_used_by_number = 0;\n\n  lines_per_body = lines_per_page - lines_per_header - lines_per_footer;\n  if (lines_per_body <= 0)\n    {\n      extremities = false;\n      keep_FF = true;\n    }\n  if (extremities == false)\n    lines_per_body = lines_per_page;\n\n  if (double_space)\n    lines_per_body = MAX (1, lines_per_body / 2);\n\n   \n  if (number_of_files == 0)\n    parallel_files = false;\n\n  if (parallel_files)\n    columns = number_of_files;\n\n   \n  if (storing_columns)\n    balance_columns = true;\n\n   \n  if (columns > 1)\n    {\n      if (!use_col_separator)\n        {\n           \n          if (join_lines)\n            col_sep_string = line_separator;\n          else\n            col_sep_string = column_separator;\n\n          col_sep_length = 1;\n          use_col_separator = true;\n        }\n       \n      else if (!join_lines && col_sep_length == 1 && *col_sep_string == '\\t')\n        col_sep_string = column_separator;\n\n      truncate_lines = true;\n      if (! (col_sep_length == 1 && *col_sep_string == '\\t'))\n        untabify_input = true;\n      tabify_output = true;\n    }\n  else\n    storing_columns = false;\n\n   \n  if (join_lines)\n    truncate_lines = false;\n\n  if (numbered_lines)\n    {\n      int chars_per_default_tab = 8;\n\n      line_count = start_line_num;\n\n       \n\n       \n      if (number_separator == '\\t')\n        number_width = (chars_per_number\n                        + TAB_WIDTH (chars_per_default_tab, chars_per_number));\n      else\n        number_width = chars_per_number + 1;\n\n       \n      if (parallel_files)\n        chars_used_by_number = number_width;\n    }\n\n  int sep_chars, useful_chars;\n  if (ckd_mul (&sep_chars, columns - 1, col_sep_length))\n    sep_chars = INT_MAX;\n  if (ckd_sub (&useful_chars, chars_per_line - chars_used_by_number,\n               sep_chars))\n    useful_chars = 0;\n  chars_per_column = useful_chars / columns;\n\n  if (chars_per_column < 1)\n    error (EXIT_FAILURE, 0, _(\"page width too narrow\"));\n\n  if (numbered_lines)\n    {\n      free (number_buff);\n      number_buff = xmalloc (MAX (chars_per_number,\n                                  INT_STRLEN_BOUND (line_number)) + 1);\n    }\n\n   \n  free (clump_buff);\n  clump_buff = xmalloc (MAX (8, chars_per_input_tab));\n}\n\n \n\nstatic bool\ninit_fps (int number_of_files, char **av)\n{\n  COLUMN *p;\n\n  total_files = 0;\n\n  free (column_vector);\n  column_vector = xnmalloc (columns, sizeof (COLUMN));\n\n  if (parallel_files)\n    {\n      int files_left = number_of_files;\n      for (p = column_vector; files_left--; ++p, ++av)\n        {\n          if (! open_file (*av, p))\n            {\n              --p;\n              --columns;\n            }\n        }\n      if (columns == 0)\n        return false;\n      init_header (\"\", -1);\n    }\n  else\n    {\n      p = column_vector;\n      if (number_of_files > 0)\n        {\n          if (! open_file (*av, p))\n            return false;\n          init_header (*av, fileno (p->fp));\n          p->lines_stored = 0;\n        }\n      else\n        {\n          p->name = _(\"standard input\");\n          p->fp = stdin;\n          have_read_stdin = true;\n          p->status = OPEN;\n          p->full_page_printed = false;\n          ++total_files;\n          init_header (\"\", -1);\n          p->lines_stored = 0;\n        }\n\n      char const *firstname = p->name;\n      FILE *firstfp = p->fp;\n      int i;\n      for (i = columns - 1, ++p; i; --i, ++p)\n        {\n          p->name = firstname;\n          p->fp = firstfp;\n          p->status = OPEN;\n          p->full_page_printed = false;\n          p->lines_stored = 0;\n        }\n    }\n  files_ready_to_read = total_files;\n  return true;\n}\n\n \n\nstatic void\ninit_funcs (void)\n{\n  int i, h, h_next;\n  COLUMN *p;\n\n  h = chars_per_margin;\n\n  if (!truncate_lines)\n    h_next = ANYWHERE;\n  else\n    {\n       \n      if (parallel_files && numbered_lines)\n        h_next = h + chars_per_column + number_width;\n      else\n        h_next = h + chars_per_column;\n    }\n\n   \n  h = h + col_sep_length;\n\n   \n\n  for (p = column_vector, i = 1; i < columns; ++p, ++i)\n    {\n      if (storing_columns)\t \n        {\n          p->char_func = store_char;\n          p->print_func = print_stored;\n        }\n      else\n         \n        {\n          p->char_func = print_char;\n          p->print_func = read_line;\n        }\n\n       \n      p->numbered = numbered_lines && (!parallel_files || i == 1);\n      p->start_position = h;\n\n       \n\n      if (!truncate_lines)\n        {\n          h = ANYWHERE;\n          h_next = ANYWHERE;\n        }\n      else\n        {\n          h = h_next + col_sep_length;\n          h_next = h + chars_per_column;\n        }\n    }\n\n   \n  if (storing_columns && balance_columns)\n    {\n      p->char_func = store_char;\n      p->print_func = print_stored;\n    }\n  else\n    {\n      p->char_func = print_char;\n      p->print_func = read_line;\n    }\n\n  p->numbered = numbered_lines && (!parallel_files || i == 1);\n  p->start_position = h;\n}\n\n \n\nstatic bool\nopen_file (char *name, COLUMN *p)\n{\n  if (STREQ (name, \"-\"))\n    {\n      p->name = _(\"standard input\");\n      p->fp = stdin;\n      have_read_stdin = true;\n    }\n  else\n    {\n      p->name = name;\n      p->fp = fopen (name, \"r\");\n    }\n  if (p->fp == nullptr)\n    {\n      failed_opens = true;\n      if (!ignore_failed_opens)\n        error (0, errno, \"%s\", quotef (name));\n      return false;\n    }\n  fadvise (p->fp, FADVISE_SEQUENTIAL);\n  p->status = OPEN;\n  p->full_page_printed = false;\n  ++total_files;\n  return true;\n}\n\n \n\nstatic void\nclose_file (COLUMN *p)\n{\n  COLUMN *q;\n  int i;\n\n  if (p->status == CLOSED)\n    return;\n\n  int err = errno;\n  if (!ferror (p->fp))\n    err = 0;\n  if (fileno (p->fp) == STDIN_FILENO)\n    clearerr (p->fp);\n  else if (fclose (p->fp) != 0 && !err)\n    err = errno;\n  if (err)\n    error (EXIT_FAILURE, err, \"%s\", quotef (p->name));\n\n  if (!parallel_files)\n    {\n      for (q = column_vector, i = columns; i; ++q, --i)\n        {\n          q->status = CLOSED;\n          if (q->lines_stored == 0)\n            {\n              q->lines_to_print = 0;\n            }\n        }\n    }\n  else\n    {\n      p->status = CLOSED;\n      p->lines_to_print = 0;\n    }\n\n  --files_ready_to_read;\n}\n\n \n\nstatic void\nhold_file (COLUMN *p)\n{\n  COLUMN *q;\n  int i;\n\n  if (!parallel_files)\n    for (q = column_vector, i = columns; i; ++q, --i)\n      {\n        if (storing_columns)\n          q->status = FF_FOUND;\n        else\n          q->status = ON_HOLD;\n      }\n  else\n    p->status = ON_HOLD;\n\n  p->lines_to_print = 0;\n  --files_ready_to_read;\n}\n\n \n\nstatic void\nreset_status (void)\n{\n  int i = columns;\n  COLUMN *p;\n\n  for (p = column_vector; i; --i, ++p)\n    if (p->status == ON_HOLD)\n      {\n        p->status = OPEN;\n        files_ready_to_read++;\n      }\n\n  if (storing_columns)\n    {\n      if (column_vector->status == CLOSED)\n         \n        files_ready_to_read = 0;\n      else\n        files_ready_to_read = 1;\n    }\n}\n\n \n\nstatic void\nprint_files (int number_of_files, char **av)\n{\n  init_parameters (number_of_files);\n  if (! init_fps (number_of_files, av))\n    return;\n  if (storing_columns)\n    init_store_cols ();\n\n  if (first_page_number > 1)\n    {\n      if (!skip_to_page (first_page_number))\n        return;\n      else\n        page_number = first_page_number;\n    }\n  else\n    page_number = 1;\n\n  init_funcs ();\n\n  line_number = line_count;\n  while (print_page ())\n    ;\n}\n\n \n\nstatic void\ninit_header (char const *filename, int desc)\n{\n  char *buf = nullptr;\n  struct stat st;\n  struct timespec t;\n  int ns;\n  struct tm tm;\n\n   \n  if (STREQ (filename, \"-\"))\n    desc = -1;\n  if (0 <= desc && fstat (desc, &st) == 0)\n    t = get_stat_mtime (&st);\n  else\n    {\n      static struct timespec timespec;\n      if (! timespec.tv_sec)\n        gettime (&timespec);\n      t = timespec;\n    }\n\n  ns = t.tv_nsec;\n  if (localtime_rz (localtz, &t.tv_sec, &tm))\n    {\n      size_t bufsize\n        = nstrftime (nullptr, SIZE_MAX, date_format, &tm, localtz, ns) + 1;\n      buf = xmalloc (bufsize);\n      nstrftime (buf, bufsize, date_format, &tm, localtz, ns);\n    }\n  else\n    {\n      char secbuf[INT_BUFSIZE_BOUND (intmax_t)];\n      buf = xmalloc (sizeof secbuf + MAX (10, INT_BUFSIZE_BOUND (int)));\n      sprintf (buf, \"%s.%09d\", timetostr (t.tv_sec, secbuf), ns);\n    }\n\n  free (date_text);\n  date_text = buf;\n  file_text = custom_header ? custom_header : desc < 0 ? \"\" : filename;\n  header_width_available = (chars_per_line\n                            - mbswidth (date_text, 0)\n                            - mbswidth (file_text, 0));\n}\n\n \n\nstatic void\ninit_page (void)\n{\n  int j;\n  COLUMN *p;\n\n  if (storing_columns)\n    {\n      store_columns ();\n      for (j = columns - 1, p = column_vector; j; --j, ++p)\n        {\n          p->lines_to_print = p->lines_stored;\n        }\n\n       \n      if (balance_columns)\n        {\n          p->lines_to_print = p->lines_stored;\n        }\n       \n      else\n        {\n          if (p->status == OPEN)\n            {\n              p->lines_to_print = lines_per_body;\n            }\n          else\n            p->lines_to_print = 0;\n        }\n    }\n  else\n    for (j = columns, p = column_vector; j; --j, ++p)\n      if (p->status == OPEN)\n        {\n          p->lines_to_print = lines_per_body;\n        }\n      else\n        p->lines_to_print = 0;\n}\n\n \n\nstatic void\nalign_column (COLUMN *p)\n{\n  padding_not_printed = p->start_position;\n  if (col_sep_length < padding_not_printed)\n    {\n      pad_across_to (padding_not_printed - col_sep_length);\n      padding_not_printed = ANYWHERE;\n    }\n\n  if (use_col_separator)\n    print_sep_string ();\n\n  if (p->numbered)\n    add_line_number (p);\n}\n\n \n\nstatic bool\nprint_page (void)\n{\n  int j;\n  int lines_left_on_page;\n  COLUMN *p;\n\n   \n  bool pv;\n\n  init_page ();\n\n  if (cols_ready_to_print () == 0)\n    return false;\n\n  if (extremities)\n    print_a_header = true;\n\n   \n  pad_vertically = false;\n  pv = false;\n\n  lines_left_on_page = lines_per_body;\n  if (double_space)\n    lines_left_on_page *= 2;\n\n  while (lines_left_on_page > 0 && cols_ready_to_print () > 0)\n    {\n      output_position = 0;\n      spaces_not_printed = 0;\n      separators_not_printed = 0;\n      pad_vertically = false;\n      align_empty_cols = false;\n      empty_line = true;\n\n      for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n        {\n          input_position = 0;\n          if (p->lines_to_print > 0 || p->status == FF_FOUND)\n            {\n              FF_only = false;\n              padding_not_printed = p->start_position;\n              if (!(p->print_func) (p))\n                read_rest_of_line (p);\n              pv |= pad_vertically;\n\n              --p->lines_to_print;\n              if (p->lines_to_print <= 0)\n                {\n                  if (cols_ready_to_print () == 0)\n                    break;\n                }\n\n               \n              if (parallel_files && p->status != OPEN)\n                {\n                  if (empty_line)\n                    align_empty_cols = true;\n                  else if (p->status == CLOSED\n                           || (p->status == ON_HOLD && FF_only))\n                    align_column (p);\n                }\n            }\n          else if (parallel_files)\n            {\n               \n              if (empty_line)\n                align_empty_cols = true;\n              else\n                align_column (p);\n            }\n\n           \n          if (use_col_separator)\n            ++separators_not_printed;\n        }\n\n      if (pad_vertically)\n        {\n          putchar ('\\n');\n          --lines_left_on_page;\n        }\n\n      if (cols_ready_to_print () == 0 && !extremities)\n        break;\n\n      if (double_space && pv)\n        {\n          putchar ('\\n');\n          --lines_left_on_page;\n        }\n    }\n\n  if (lines_left_on_page == 0)\n    for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n      if (p->status == OPEN)\n        p->full_page_printed = true;\n\n  pad_vertically = pv;\n\n  if (pad_vertically && extremities)\n    pad_down (lines_left_on_page + lines_per_footer);\n  else if (keep_FF && print_a_FF)\n    {\n      putchar ('\\f');\n      print_a_FF = false;\n    }\n\n  if (last_page_number < ++page_number)\n    return false;\t\t \n\n  reset_status ();\t\t \n\n  return true;\t\t\t \n}\n\n \n\nstatic void\ninit_store_cols (void)\n{\n  int total_lines, total_lines_1, chars_per_column_1, chars_if_truncate;\n  if (ckd_mul (&total_lines, lines_per_body, columns)\n      || ckd_add (&total_lines_1, total_lines, 1)\n      || ckd_add (&chars_per_column_1, chars_per_column, 1)\n      || ckd_mul (&chars_if_truncate, total_lines, chars_per_column_1))\n    integer_overflow ();\n\n  free (line_vector);\n   \n  line_vector = xnmalloc (total_lines_1, sizeof *line_vector);\n\n  free (end_vector);\n  end_vector = xnmalloc (total_lines, sizeof *end_vector);\n\n  free (buff);\n  buff = xnmalloc (chars_if_truncate, use_col_separator + 1);\n  buff_allocated = chars_if_truncate;   \n  buff_allocated *= use_col_separator + 1;\n}\n\n \n\nstatic void\nstore_columns (void)\n{\n  int i, j;\n  unsigned int line = 0;\n  unsigned int buff_start;\n  int last_col;\t\t \n  COLUMN *p;\n\n  buff_current = 0;\n  buff_start = 0;\n\n  if (balance_columns)\n    last_col = columns;\n  else\n    last_col = columns - 1;\n\n  for (i = 1, p = column_vector; i <= last_col; ++i, ++p)\n    p->lines_stored = 0;\n\n  for (i = 1, p = column_vector; i <= last_col && files_ready_to_read;\n       ++i, ++p)\n    {\n      p->current_line = line;\n      for (j = lines_per_body; j && files_ready_to_read; --j)\n\n        if (p->status == OPEN)\t \n          {\n            input_position = 0;\n\n            if (!read_line (p))\n              read_rest_of_line (p);\n\n            if (p->status == OPEN\n                || buff_start != buff_current)\n              {\n                ++p->lines_stored;\n                line_vector[line] = buff_start;\n                end_vector[line++] = input_position;\n                buff_start = buff_current;\n              }\n          }\n    }\n\n   \n  line_vector[line] = buff_start;\n\n  if (balance_columns)\n    balance (line);\n}\n\nstatic void\nbalance (int total_stored)\n{\n  COLUMN *p;\n  int i, lines;\n  int first_line = 0;\n\n  for (i = 1, p = column_vector; i <= columns; ++i, ++p)\n    {\n      lines = total_stored / columns;\n      if (i <= total_stored % columns)\n        ++lines;\n\n      p->lines_stored = lines;\n      p->current_line = first_line;\n\n      first_line += lines;\n    }\n}\n\n \n\nstatic void\nstore_char (char c)\n{\n  if (buff_current >= buff_allocated)\n    {\n       \n      buff = X2REALLOC (buff, &buff_allocated);\n    }\n  buff[buff_current++] = c;\n}\n\nstatic void\nadd_line_number (COLUMN *p)\n{\n  int i;\n  char *s;\n  int num_width;\n\n   \n  num_width = sprintf (number_buff, \"%*d\", chars_per_number, line_number);\n  line_number++;\n  s = number_buff + (num_width - chars_per_number);\n  for (i = chars_per_number; i > 0; i--)\n    (p->char_func) (*s++);\n\n  if (columns > 1)\n    {\n       \n      if (number_separator == '\\t')\n        {\n          i = number_width - chars_per_number;\n          while (i-- > 0)\n            (p->char_func) (' ');\n        }\n      else\n        (p->char_func) (number_separator);\n    }\n  else\n     \n    {\n      (p->char_func) (number_separator);\n      if (number_separator == '\\t')\n        output_position = POS_AFTER_TAB (chars_per_output_tab,\n                          output_position);\n    }\n\n  if (truncate_lines && !parallel_files)\n    input_position += number_width;\n}\n\n \n\nstatic void\npad_across_to (int position)\n{\n  int h = output_position;\n\n  if (tabify_output)\n    spaces_not_printed = position - output_position;\n  else\n    {\n      while (++h <= position)\n        putchar (' ');\n      output_position = position;\n    }\n}\n\n \n\nstatic void\npad_down (unsigned int lines)\n{\n  if (use_form_feed)\n    putchar ('\\f');\n  else\n    for (unsigned int i = lines; i; --i)\n      putchar ('\\n');\n}\n\n \n\nstatic void\nread_rest_of_line (COLUMN *p)\n{\n  int c;\n  FILE *f = p->fp;\n\n  while ((c = getc (f)) != '\\n')\n    {\n      if (c == '\\f')\n        {\n          if ((c = getc (f)) != '\\n')\n            ungetc (c, f);\n          if (keep_FF)\n            print_a_FF = true;\n          hold_file (p);\n          break;\n        }\n      else if (c == EOF)\n        {\n          close_file (p);\n          break;\n        }\n    }\n}\n\n \n\nstatic void\nskip_read (COLUMN *p, int column_number)\n{\n  int c;\n  FILE *f = p->fp;\n  int i;\n  bool single_ff = false;\n  COLUMN *q;\n\n   \n  if ((c = getc (f)) == '\\f' && p->full_page_printed)\n     \n    if ((c = getc (f)) == '\\n')\n      c = getc (f);\n\n  p->full_page_printed = false;\n\n   \n  if (c == '\\f')\n    single_ff = true;\n\n   \n  if (last_line)\n    p->full_page_printed = true;\n\n  while (c != '\\n')\n    {\n      if (c == '\\f')\n        {\n           \n          if (last_line)\n            {\n              if (!parallel_files)\n                for (q = column_vector, i = columns; i; ++q, --i)\n                  q->full_page_printed = false;\n              else\n                p->full_page_printed = false;\n            }\n\n          if ((c = getc (f)) != '\\n')\n            ungetc (c, f);\n          hold_file (p);\n          break;\n        }\n      else if (c == EOF)\n        {\n          close_file (p);\n          break;\n        }\n      c = getc (f);\n    }\n\n  if (skip_count)\n    if ((!parallel_files || column_number == 1) && !single_ff)\n      ++line_count;\n}\n\n \n\nstatic void\nprint_white_space (void)\n{\n  int h_new;\n  int h_old = output_position;\n  int goal = h_old + spaces_not_printed;\n\n  while (goal - h_old > 1\n         && (h_new = POS_AFTER_TAB (chars_per_output_tab, h_old)) <= goal)\n    {\n      putchar (output_tab_char);\n      h_old = h_new;\n    }\n  while (++h_old <= goal)\n    putchar (' ');\n\n  output_position = goal;\n  spaces_not_printed = 0;\n}\n\n \n\nstatic void\nprint_sep_string (void)\n{\n  char const *s = col_sep_string;\n  int l = col_sep_length;\n\n  if (separators_not_printed <= 0)\n    {\n       \n      if (spaces_not_printed > 0)\n        print_white_space ();\n    }\n  else\n    {\n      for (; separators_not_printed > 0; --separators_not_printed)\n        {\n          while (l-- > 0)\n            {\n               \n              if (*s == ' ')\n                {\n                   \n                  s++;\n                  ++spaces_not_printed;\n                }\n              else\n                {\n                  if (spaces_not_printed > 0)\n                    print_white_space ();\n                  putchar (*s++);\n                  ++output_position;\n                }\n            }\n           \n          if (spaces_not_printed > 0)\n            print_white_space ();\n        }\n    }\n}\n\n \n\nstatic void\nprint_clump (COLUMN *p, int n, char *clump)\n{\n  while (n--)\n    (p->char_func) (*clump++);\n}\n\n \n\nstatic void\nprint_char (char c)\n{\n  if (tabify_output)\n    {\n      if (c == ' ')\n        {\n          ++spaces_not_printed;\n          return;\n        }\n      else if (spaces_not_printed > 0)\n        print_white_space ();\n\n       \n      if (! isprint (to_uchar (c)))\n        {\n          if (c == '\\b')\n            --output_position;\n        }\n      else\n        ++output_position;\n    }\n  putchar (c);\n}\n\n \n\nstatic bool\nskip_to_page (uintmax_t page)\n{\n  for (uintmax_t n = 1; n < page; ++n)\n    {\n      COLUMN *p;\n      int j;\n\n      for (int i = 1; i < lines_per_body; ++i)\n        {\n          for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n            if (p->status == OPEN)\n              skip_read (p, j);\n        }\n      last_line = true;\n      for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n        if (p->status == OPEN)\n          skip_read (p, j);\n\n      if (storing_columns)\t \n        for (j = 1, p = column_vector; j <= columns; ++j, ++p)\n          if (p->status != CLOSED)\n            p->status = ON_HOLD;\n\n      reset_status ();\n      last_line = false;\n\n      if (files_ready_to_read < 1)\n        {\n           \n          error (0, 0,\n                 _(\"starting page number %\"PRIuMAX\n                   \" exceeds page count %\"PRIuMAX),\n                 page, n);\n          break;\n        }\n    }\n  return files_ready_to_read > 0;\n}\n\n \n\nstatic void\nprint_header (void)\n{\n  char page_text[256 + INT_STRLEN_BOUND (page_number)];\n  int available_width;\n  int lhs_spaces;\n  int rhs_spaces;\n\n  output_position = 0;\n  pad_across_to (chars_per_margin);\n  print_white_space ();\n\n  if (page_number == 0)\n    error (EXIT_FAILURE, 0, _(\"page number overflow\"));\n\n   \n  sprintf (page_text, _(\"Page %\"PRIuMAX), page_number);\n  available_width = header_width_available - mbswidth (page_text, 0);\n  available_width = MAX (0, available_width);\n  lhs_spaces = available_width >> 1;\n  rhs_spaces = available_width - lhs_spaces;\n\n  printf (\"\\n\\n%*s%s%*s%s%*s%s\\n\\n\\n\",\n          chars_per_margin, \"\",\n          date_text, lhs_spaces, \" \",\n          file_text, rhs_spaces, \" \", page_text);\n\n  print_a_header = false;\n  output_position = 0;\n}\n\n \n\nstatic bool\nread_line (COLUMN *p)\n{\n  int c;\n  int chars;\n  int last_input_position;\n  int j, k;\n  COLUMN *q;\n\n   \n  c = getc (p->fp);\n\n  last_input_position = input_position;\n\n  if (c == '\\f' && p->full_page_printed)\n    if ((c = getc (p->fp)) == '\\n')\n      c = getc (p->fp);\n  p->full_page_printed = false;\n\n  switch (c)\n    {\n    case '\\f':\n      if ((c = getc (p->fp)) != '\\n')\n        ungetc (c, p->fp);\n      FF_only = true;\n      if (print_a_header && !storing_columns)\n        {\n          pad_vertically = true;\n          print_header ();\n        }\n      else if (keep_FF)\n        print_a_FF = true;\n      hold_file (p);\n      return true;\n    case EOF:\n      close_file (p);\n      return true;\n    case '\\n':\n      break;\n    default:\n      chars = char_to_clump (c);\n    }\n\n  if (truncate_lines && input_position > chars_per_column)\n    {\n      input_position = last_input_position;\n      return false;\n    }\n\n  if (p->char_func != store_char)\n    {\n      pad_vertically = true;\n\n      if (print_a_header && !storing_columns)\n        print_header ();\n\n      if (parallel_files && align_empty_cols)\n        {\n           \n          k = separators_not_printed;\n          separators_not_printed = 0;\n          for (j = 1, q = column_vector; j <= k; ++j, ++q)\n            {\n              align_column (q);\n              separators_not_printed += 1;\n            }\n          padding_not_printed = p->start_position;\n          if (truncate_lines)\n            spaces_not_printed = chars_per_column;\n          else\n            spaces_not_printed = 0;\n          align_empty_cols = false;\n        }\n\n      if (col_sep_length < padding_not_printed)\n        {\n          pad_across_to (padding_not_printed - col_sep_length);\n          padding_not_printed = ANYWHERE;\n        }\n\n      if (use_col_separator)\n        print_sep_string ();\n    }\n\n  if (p->numbered)\n    add_line_number (p);\n\n  empty_line = false;\n  if (c == '\\n')\n    return true;\n\n  print_clump (p, chars, clump_buff);\n\n  while (true)\n    {\n      c = getc (p->fp);\n\n      switch (c)\n        {\n        case '\\n':\n          return true;\n        case '\\f':\n          if ((c = getc (p->fp)) != '\\n')\n            ungetc (c, p->fp);\n          if (keep_FF)\n            print_a_FF = true;\n          hold_file (p);\n          return true;\n        case EOF:\n          close_file (p);\n          return true;\n        }\n\n      last_input_position = input_position;\n      chars = char_to_clump (c);\n      if (truncate_lines && input_position > chars_per_column)\n        {\n          input_position = last_input_position;\n          return false;\n        }\n\n      print_clump (p, chars, clump_buff);\n    }\n}\n\n \n\nstatic bool\nprint_stored (COLUMN *p)\n{\n  COLUMN *q;\n\n  int line = p->current_line++;\n  char *first = &buff[line_vector[line]];\n   \n  char *last = &buff[line_vector[line + 1]];\n\n  pad_vertically = true;\n\n  if (print_a_header)\n    print_header ();\n\n  if (p->status == FF_FOUND)\n    {\n      int i;\n      for (i = 1, q = column_vector; i <= columns; ++i, ++q)\n        q->status = ON_HOLD;\n      if (column_vector->lines_to_print <= 0)\n        {\n          if (!extremities)\n            pad_vertically = false;\n          return true;\t\t \n        }\n    }\n\n  if (col_sep_length < padding_not_printed)\n    {\n      pad_across_to (padding_not_printed - col_sep_length);\n      padding_not_printed = ANYWHERE;\n    }\n\n  if (use_col_separator)\n    print_sep_string ();\n\n  while (first != last)\n    print_char (*first++);\n\n  if (spaces_not_printed == 0)\n    {\n      output_position = p->start_position + end_vector[line];\n      if (p->start_position - col_sep_length == chars_per_margin)\n        output_position -= col_sep_length;\n    }\n\n  return true;\n}\n\n \n\nstatic int\nchar_to_clump (char c)\n{\n  unsigned char uc = c;\n  char *s = clump_buff;\n  int i;\n  char esc_buff[4];\n  int width;\n  int chars;\n  int chars_per_c = 8;\n\n  if (c == input_tab_char)\n    chars_per_c = chars_per_input_tab;\n\n  if (c == input_tab_char || c == '\\t')\n    {\n      width = TAB_WIDTH (chars_per_c, input_position);\n\n      if (untabify_input)\n        {\n          for (i = width; i; --i)\n            *s++ = ' ';\n          chars = width;\n        }\n      else\n        {\n          *s = c;\n          chars = 1;\n        }\n\n    }\n  else if (! isprint (uc))\n    {\n      if (use_esc_sequence)\n        {\n          width = 4;\n          chars = 4;\n          *s++ = '\\\\';\n          sprintf (esc_buff, \"%03o\", uc);\n          for (i = 0; i <= 2; ++i)\n            *s++ = esc_buff[i];\n        }\n      else if (use_cntrl_prefix)\n        {\n          if (uc < 0200)\n            {\n              width = 2;\n              chars = 2;\n              *s++ = '^';\n              *s = c ^ 0100;\n            }\n          else\n            {\n              width = 4;\n              chars = 4;\n              *s++ = '\\\\';\n              sprintf (esc_buff, \"%03o\", uc);\n              for (i = 0; i <= 2; ++i)\n                *s++ = esc_buff[i];\n            }\n        }\n      else if (c == '\\b')\n        {\n          width = -1;\n          chars = 1;\n          *s = c;\n        }\n      else\n        {\n          width = 0;\n          chars = 1;\n          *s = c;\n        }\n    }\n  else\n    {\n      width = 1;\n      chars = 1;\n      *s = c;\n    }\n\n   \n  if (width < 0 && input_position == 0)\n    {\n      chars = 0;\n      input_position = 0;\n    }\n  else if (width < 0 && input_position <= -width)\n    input_position = 0;\n  else\n    input_position += width;\n\n  return chars;\n}\n\n \n\nstatic void\ncleanup (void)\n{\n  free (number_buff);\n  free (clump_buff);\n  free (column_vector);\n  free (line_vector);\n  free (end_vector);\n  free (buff);\n}\n\n \n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n\n      fputs (_(\"\\\nPaginate or columnate FILE(s) for printing.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\\n\\\n                    begin [stop] printing with page FIRST_[LAST_]PAGE\\n\\\n  -COLUMN, --columns=COLUMN\\n\\\n                    output COLUMN columns and print columns down,\\n\\\n                    unless -a is used. Balance number of lines in the\\n\\\n                    columns on each page\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -a, --across      print columns across rather than down, used together\\n\\\n                    with -COLUMN\\n\\\n  -c, --show-control-chars\\n\\\n                    use hat notation (^G) and octal backslash notation\\n\\\n  -d, --double-space\\n\\\n                    double space the output\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -D, --date-format=FORMAT\\n\\\n                    use FORMAT for the header date\\n\\\n  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\\n\\\n                    expand input CHARs (TABs) to tab WIDTH (8)\\n\\\n  -F, -f, --form-feed\\n\\\n                    use form feeds instead of newlines to separate pages\\n\\\n                    (by a 3-line page header with -F or a 5-line header\\n\\\n                    and trailer without -F)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -h, --header=HEADER\\n\\\n                    use a centered HEADER instead of filename in page header,\\n\\\n                    -h \\\"\\\" prints a blank line, don't use -h\\\"\\\"\\n\\\n  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\\n\\\n                    replace spaces with CHARs (TABs) to tab WIDTH (8)\\n\\\n  -J, --join-lines  merge full lines, turns off -W line truncation, no column\\n\\\n                    alignment, --sep-string[=STRING] sets separators\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -l, --length=PAGE_LENGTH\\n\\\n                    set the page length to PAGE_LENGTH (66) lines\\n\\\n                    (default number of lines of text 56, and with -F 63).\\n\\\n                    implies -t if PAGE_LENGTH <= 10\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -m, --merge       print all files in parallel, one in each column,\\n\\\n                    truncate lines, but join lines of full length with -J\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\\n\\\n                    number lines, use DIGITS (5) digits, then SEP (TAB),\\n\\\n                    default counting starts with 1st line of input file\\n\\\n  -N, --first-line-number=NUMBER\\n\\\n                    start counting with NUMBER at 1st line of first\\n\\\n                    page printed (see +FIRST_PAGE)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -o, --indent=MARGIN\\n\\\n                    offset each line with MARGIN (zero) spaces, do not\\n\\\n                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\\n\\\n  -r, --no-file-warnings\\n\\\n                    omit warning when a file cannot be opened\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -s[CHAR], --separator[=CHAR]\\n\\\n                    separate columns by a single character, default for CHAR\\n\\\n                    is the <TAB> character without -w and \\'no char\\' with -w.\\\n\\n\\\n                    -s[CHAR] turns off line truncation of all 3 column\\n\\\n                    options (-COLUMN|-a -COLUMN|-m) except -w is set\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -S[STRING], --sep-string[=STRING]\\n\\\n                    separate columns by STRING,\\n\\\n                    without -S: Default separator <TAB> with -J and <space>\\n\\\n                    otherwise (same as -S\\\" \\\"), no effect on column options\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t, --omit-header  omit page headers and trailers;\\n\\\n                     implied if PAGE_LENGTH <= 10\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -T, --omit-pagination\\n\\\n                    omit page headers and trailers, eliminate any pagination\\n\\\n                    by form feeds set in input files\\n\\\n  -v, --show-nonprinting\\n\\\n                    use octal backslash notation\\n\\\n  -w, --width=PAGE_WIDTH\\n\\\n                    set page width to PAGE_WIDTH (72) characters for\\n\\\n                    multiple text-column output only, -s[char] turns off (72)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -W, --page-width=PAGE_WIDTH\\n\\\n                    set page width to PAGE_WIDTH (72) characters always,\\n\\\n                    truncate lines, except -J option is set, no interference\\n\\\n                    with -S or -s\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}