{
  "module_name": "env.c",
  "hash_id": "c764bdb801c05a39bd4a6f021a842609c4d87a42d7817bfed2eb41ad994df941",
  "original_prompt": "Ingested from coreutils-9.4/src/env.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n#include <c-ctype.h>\n#include <signal.h>\n\n#include \"system.h\"\n#include \"operand2sig.h\"\n#include \"quote.h\"\n#include \"sig2str.h\"\n\n \n#define PROGRAM_NAME \"env\"\n\n#define AUTHORS \\\n  proper_name (\"Richard Mlynarik\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Assaf Gordon\")\n\n \nstatic char const **usvars;\nstatic size_t usvars_alloc;\nstatic idx_t usvars_used;\n\n \nstatic bool dev_debug;\n\n \nstatic char *varname;\nstatic idx_t vnlen;\n\n \nenum SIGNAL_MODE {\n  UNCHANGED = 0,\n  DEFAULT,        \n  DEFAULT_NOERR,  \n  IGNORE,         \n  IGNORE_NOERR    \n};\nstatic enum SIGNAL_MODE *signals;\n\n \nstatic sigset_t block_signals;\n\n \nstatic sigset_t unblock_signals;\n\n \nstatic bool sig_mask_changed;\n\n \nstatic bool report_signal_handling;\n\n \n#define C_ISSPACE_CHARS \" \\t\\n\\v\\f\\r\"\n\nstatic char const shortopts[] = \"+C:iS:u:v0\" C_ISSPACE_CHARS;\n\n \nenum\n{\n  DEFAULT_SIGNAL_OPTION = CHAR_MAX + 1,\n  IGNORE_SIGNAL_OPTION,\n  BLOCK_SIGNAL_OPTION,\n  LIST_SIGNAL_HANDLING_OPTION,\n};\n\nstatic struct option const longopts[] =\n{\n  {\"ignore-environment\", no_argument, nullptr, 'i'},\n  {\"null\", no_argument, nullptr, '0'},\n  {\"unset\", required_argument, nullptr, 'u'},\n  {\"chdir\", required_argument, nullptr, 'C'},\n  {\"default-signal\", optional_argument, nullptr, DEFAULT_SIGNAL_OPTION},\n  {\"ignore-signal\",  optional_argument, nullptr, IGNORE_SIGNAL_OPTION},\n  {\"block-signal\",   optional_argument, nullptr, BLOCK_SIGNAL_OPTION},\n  {\"list-signal-handling\", no_argument, nullptr,  LIST_SIGNAL_HANDLING_OPTION},\n  {\"debug\", no_argument, nullptr, 'v'},\n  {\"split-string\", required_argument, nullptr, 'S'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\\n\"),\n              program_name);\n      fputs (_(\"\\\nSet each NAME to VALUE in the environment and run COMMAND.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -i, --ignore-environment  start with an empty environment\\n\\\n  -0, --null           end each output line with NUL, not newline\\n\\\n  -u, --unset=NAME     remove variable from the environment\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -C, --chdir=DIR      change working directory to DIR\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -S, --split-string=S  process and split S into separate arguments;\\n\\\n                        used to pass multiple arguments on shebang lines\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --default-signal[=SIG]  reset handling of SIG signal(s) to the default\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --ignore-signal[=SIG]   set handling of SIG signal(s) to do nothing\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --list-signal-handling  list non default signal handling to stderr\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --debug          print verbose information for each processing step\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nA mere - implies -i.  If no COMMAND, print the resulting environment.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nSIG may be a signal name like 'PIPE', or a signal number like '13'.\\n\\\nWithout SIG, all known signals are included.  Multiple signals can be\\n\\\ncomma-separated.  An empty SIG argument is a no-op.\\n\\\n\"), stdout);\n      emit_exec_status (PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic void\nappend_unset_var (char const *var)\n{\n  if (usvars_used == usvars_alloc)\n    usvars = x2nrealloc (usvars, &usvars_alloc, sizeof *usvars);\n  usvars[usvars_used++] = var;\n}\n\nstatic void\nunset_envvars (void)\n{\n  for (idx_t i = 0; i < usvars_used; ++i)\n    {\n      devmsg (\"unset:    %s\\n\", usvars[i]);\n\n      if (unsetenv (usvars[i]))\n        error (EXIT_CANCELED, errno, _(\"cannot unset %s\"),\n               quote (usvars[i]));\n    }\n}\n\n/* Return a pointer to the end of a valid ${VARNAME} string, or nullptr.\n   'str' should point to the '$' character.\n   First letter in VARNAME must be alpha or underscore,\n   rest of letters are alnum or underscore.\n   Any other character is an error.  */\nATTRIBUTE_PURE\nstatic char const *\nscan_varname (char const *str)\n{\n  if (str[1] == '{' && (c_isalpha (str[2]) || str[2] == '_'))\n    {\n      char const *end = str + 3;\n      while (c_isalnum (*end) || *end == '_')\n        ++end;\n      if (*end == '}')\n        return end;\n    }\n\n  return nullptr;\n}\n\n/* Return a pointer to a static buffer containing the VARNAME as\n   extracted from a '${VARNAME}' string.\n   The returned string will be NUL terminated.\n   The returned pointer should not be freed.\n   Return nullptr if not a valid ${VARNAME} syntax.  */\nstatic char *\nextract_varname (char const *str)\n{\n  idx_t i;\n  char const *p;\n\n  p = scan_varname (str);\n  if (!p)\n    return nullptr;\n\n  /* -2 and +2 (below) account for the '${' prefix.  */\n  i = p - str - 2;\n\n  if (i >= vnlen)\n    {\n      vnlen = i + 1;\n      varname = xrealloc (varname, vnlen);\n    }\n\n  memcpy (varname, str + 2, i);\n  varname[i] = 0;\n\n  return varname;\n}\n\n/* Temporary buffer used by --split-string processing.  */\nstruct splitbuf\n{\n  /* Buffer address, arg count, and half the number of elements in the buffer.\n     ARGC and ARGV are as in 'main', and ARGC + 1 <= HALF_ALLOC so\n     that the upper half of ARGV can be used for string contents.\n     This may waste up to half the space but keeps the code simple,\n     which is better for this rarely-used but security-sensitive code.\n\n     ARGV[0] is not initialized; that is the caller's responsibility\n     after finalization.\n\n     During assembly, ARGV[I] (where 0 < I < ARGC) contains the offset\n     of the Ith string (relative to ARGV + HALF_ALLOC), so that\n     reallocating ARGV does not change the validity of its contents.\n     The integer offset is cast to char * during assembly, and is\n     converted to a true char * pointer on finalization.\n\n     During assembly, ARGV[ARGC] contains the offset of the first\n     unused string byte (relative to ARGV + HALF_ALLOC).  */\n  char **argv;\n  int argc;\n  idx_t half_alloc;\n\n  /* The number of extra argv slots to keep room for.  */\n  int extra_argc;\n\n  /* Whether processing should act as if the most recent character\n     seen was a separator.  */\n  bool sep;\n};\n\n/* Expand SS so that it has at least one more argv slot and at least\n   one more string byte.  */\nstatic void\nsplitbuf_grow (struct splitbuf *ss)\n{\n  idx_t old_half_alloc = ss->half_alloc;\n  idx_t string_bytes = (intptr_t) ss->argv[ss->argc];\n  ss->argv = xpalloc (ss->argv, &ss->half_alloc, 1,\n                      MIN (INT_MAX, IDX_MAX), 2 * sizeof *ss->argv);\n  memmove (ss->argv + ss->half_alloc, ss->argv + old_half_alloc, string_bytes);\n}\n\n/* In SS, append C to the last string.  */\nstatic void\nsplitbuf_append_byte (struct splitbuf *ss, char c)\n{\n  idx_t string_bytes = (intptr_t) ss->argv[ss->argc];\n  if (ss->half_alloc * sizeof *ss->argv <= string_bytes)\n    splitbuf_grow (ss);\n  ((char *) (ss->argv + ss->half_alloc))[string_bytes] = c;\n  ss->argv[ss->argc] = (char *) (intptr_t) (string_bytes + 1);\n}\n\n/* If SS's most recent character was a separator, finish off its\n   previous argument and start a new one.  */\nstatic void\ncheck_start_new_arg (struct splitbuf *ss)\n{\n  if (ss->sep)\n    {\n      splitbuf_append_byte (ss, '\\0');\n      int argc = ss->argc;\n      if (ss->half_alloc <= argc + ss->extra_argc + 1)\n        splitbuf_grow (ss);\n      ss->argv[argc + 1] = ss->argv[argc];\n      ss->argc = argc + 1;\n      ss->sep = false;\n    }\n}\n\n/* All additions to SS have been made.  Convert its offsets to pointers,\n   and return the resulting argument vector.  */\nstatic char **\nsplitbuf_finishup (struct splitbuf *ss)\n{\n  int argc = ss->argc;\n  char **argv = ss->argv;\n  char *stringbase = (char *) (ss->argv + ss->half_alloc);\n  for (int i = 1; i < argc; i++)\n    argv[i] = stringbase + (intptr_t) argv[i];\n  return argv;\n}\n\n/* Return a newly-allocated argv-like array,\n   by parsing and splitting the input 'str'.\n\n   'extra_argc' is the number of additional elements to allocate\n   in the array (on top of the number of args required to split 'str').\n\n   Store into *argc the number of arguments found (plus 1 for\n   the program name).\n\n   Example:\n     int argc;\n     char **argv = build_argv (\"A=B uname -k', 3, &argc);\n   Results in:\n     argc = 4\n     argv[0] = [not initialized]\n     argv[1] = \"A=B\"\n     argv[2] = \"uname\"\n     argv[3] = \"-k\"\n     argv[4,5,6,7] = [allocated due to extra_argc + 1, but not initialized]\n\n   To free allocated memory:\n     free (argv);\n   However, 'env' does not free since it's about to exec or exit anyway\n   and the complexity of keeping track of the storage that may have been\n   allocated via multiple calls to build_argv is not worth the hassle.  */\nstatic char **\nbuild_argv (char const *str, int extra_argc, int *argc)\n{\n  bool dq = false, sq = false;\n  struct splitbuf ss;\n  ss.argv = xnmalloc (extra_argc + 2, 2 * sizeof *ss.argv);\n  ss.argc = 1;\n  ss.half_alloc = extra_argc + 2;\n  ss.extra_argc = extra_argc;\n  ss.sep = true;\n  ss.argv[ss.argc] = 0;\n\n   \n  while (*str)\n    {\n      char newc = *str;  \n\n      switch (*str)\n        {\n        case '\\'':\n          if (dq)\n            break;\n          sq = !sq;\n          check_start_new_arg (&ss);\n          ++str;\n          continue;\n\n        case '\"':\n          if (sq)\n            break;\n          dq = !dq;\n          check_start_new_arg (&ss);\n          ++str;\n          continue;\n\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n           \n          if (sq || dq)\n            break;\n          ss.sep = true;\n          str += strspn (str, C_ISSPACE_CHARS);\n          continue;\n\n        case '#':\n          if (!ss.sep)\n            break;\n          goto eos;  \n\n        case '\\\\':\n           \n          if (sq && str[1] != '\\\\' && str[1] != '\\'')\n            break;\n\n           \n          newc = *++str;\n          switch (newc)\n            {\n            case '\"': case '#': case '$': case '\\'': case '\\\\':\n               \n              break;\n\n            case '_':\n              if (!dq)\n                {\n                  ++str;   \n                  ss.sep = true;\n                  continue;\n                }\n              newc = ' ';   \n              break;\n\n            case 'c':\n              if (dq)\n                error (EXIT_CANCELED, 0,\n                       _(\"'\\\\c' must not appear in double-quoted -S string\"));\n              goto eos;  \n\n            case 'f': newc = '\\f'; break;\n            case 'n': newc = '\\n'; break;\n            case 'r': newc = '\\r'; break;\n            case 't': newc = '\\t'; break;\n            case 'v': newc = '\\v'; break;\n\n            case '\\0':\n              error (EXIT_CANCELED, 0,\n                     _(\"invalid backslash at end of string in -S\"));\n\n            default:\n              error (EXIT_CANCELED, 0,\n                     _(\"invalid sequence '\\\\%c' in -S\"), newc);\n            }\n          break;\n\n        case '$':\n           \n          if (sq)\n            break;\n\n           \n          {\n            char *n = extract_varname (str);\n            if (!n)\n              error (EXIT_CANCELED, 0,\n                     _(\"only ${VARNAME} expansion is supported, error at: %s\"),\n                     str);\n\n            char *v = getenv (n);\n            if (v)\n              {\n                check_start_new_arg (&ss);\n                devmsg (\"expanding ${%s} into %s\\n\", n, quote (v));\n                for (; *v; v++)\n                  splitbuf_append_byte (&ss, *v);\n              }\n            else\n              devmsg (\"replacing ${%s} with null string\\n\", n);\n\n            str = strchr (str, '}') + 1;\n            continue;\n          }\n        }\n\n      check_start_new_arg (&ss);\n      splitbuf_append_byte (&ss, newc);\n      ++str;\n    }\n\n  if (dq || sq)\n    error (EXIT_CANCELED, 0, _(\"no terminating quote in -S string\"));\n\n eos:\n  splitbuf_append_byte (&ss, '\\0');\n  *argc = ss.argc;\n  return splitbuf_finishup (&ss);\n}\n\n \nstatic void\nparse_split_string (char const *str, int *orig_optind,\n                    int *orig_argc, char ***orig_argv)\n{\n  int extra_argc = *orig_argc - *orig_optind, newargc;\n  char **newargv = build_argv (str, extra_argc, &newargc);\n\n   \n  *newargv = (*orig_argv)[0];\n\n   \n  if (dev_debug && 1 < newargc)\n    {\n      devmsg (\"split -S:  %s\\n\", quote (str));\n      devmsg (\" into:    %s\\n\", quote (newargv[1]));\n      for (int i = 2; i < newargc; i++)\n        devmsg (\"     &    %s\\n\", quote (newargv[i]));\n    }\n\n   \n  memcpy (newargv + newargc, *orig_argv + *orig_optind,\n          (extra_argc + 1) * sizeof *newargv);\n\n   \n  *orig_argc = newargc + extra_argc;\n  *orig_argv = newargv;\n  *orig_optind = 0;  \n}\n\nstatic void\nparse_signal_action_params (char const *optarg, bool set_default)\n{\n  char signame[SIG2STR_MAX];\n  char *opt_sig;\n  char *optarg_writable;\n\n  if (! optarg)\n    {\n       \n      for (int i = 1 ; i <= SIGNUM_BOUND; i++)\n        if (sig2str (i, signame) == 0)\n          signals[i] = set_default ? DEFAULT_NOERR : IGNORE_NOERR;\n      return;\n    }\n\n  optarg_writable = xstrdup (optarg);\n\n  opt_sig = strtok (optarg_writable, \",\");\n  while (opt_sig)\n    {\n      int signum = operand2sig (opt_sig, signame);\n       \n      if (signum == 0)\n        error (0, 0, _(\"%s: invalid signal\"), quote (opt_sig));\n      if (signum <= 0)\n        usage (exit_failure);\n\n      signals[signum] = set_default ? DEFAULT : IGNORE;\n\n      opt_sig = strtok (nullptr, \",\");\n    }\n\n  free (optarg_writable);\n}\n\nstatic void\nreset_signal_handlers (void)\n{\n  for (int i = 1; i <= SIGNUM_BOUND; i++)\n    {\n      struct sigaction act;\n\n      if (signals[i] == UNCHANGED)\n        continue;\n\n      bool ignore_errors = (signals[i] == DEFAULT_NOERR\n                            || signals[i] == IGNORE_NOERR);\n\n      bool set_to_default = (signals[i] == DEFAULT\n                             || signals[i] == DEFAULT_NOERR);\n\n      int sig_err = sigaction (i, nullptr, &act);\n\n      if (sig_err && !ignore_errors)\n        error (EXIT_CANCELED, errno,\n               _(\"failed to get signal action for signal %d\"), i);\n\n      if (! sig_err)\n        {\n          act.sa_handler = set_to_default ? SIG_DFL : SIG_IGN;\n          sig_err = sigaction (i, &act, nullptr);\n          if (sig_err && !ignore_errors)\n            error (EXIT_CANCELED, errno,\n                   _(\"failed to set signal action for signal %d\"), i);\n        }\n\n      if (dev_debug)\n        {\n          char signame[SIG2STR_MAX];\n          sig2str (i, signame);\n          devmsg (\"Reset signal %s (%d) to %s%s\\n\",\n                  signame, i,\n                  set_to_default ? \"DEFAULT\" : \"IGNORE\",\n                  sig_err ? \" (failure ignored)\" : \"\");\n        }\n    }\n}\n\n\nstatic void\nparse_block_signal_params (char const *optarg, bool block)\n{\n  char signame[SIG2STR_MAX];\n  char *opt_sig;\n  char *optarg_writable;\n\n  if (! optarg)\n    {\n       \n      sigfillset (block ? &block_signals : &unblock_signals);\n      sigemptyset (block ? &unblock_signals : &block_signals);\n    }\n  else if (! sig_mask_changed)\n    {\n       \n      sigemptyset (&block_signals);\n      sigemptyset (&unblock_signals);\n    }\n\n  sig_mask_changed = true;\n\n  if (! optarg)\n    return;\n\n  optarg_writable = xstrdup (optarg);\n\n  opt_sig = strtok (optarg_writable, \",\");\n  while (opt_sig)\n    {\n      int signum = operand2sig (opt_sig, signame);\n       \n      if (signum == 0)\n        error (0, 0, _(\"%s: invalid signal\"), quote (opt_sig));\n      if (signum <= 0)\n        usage (exit_failure);\n\n      sigaddset (block ? &block_signals : &unblock_signals, signum);\n      sigdelset (block ? &unblock_signals : &block_signals, signum);\n\n      opt_sig = strtok (nullptr, \",\");\n    }\n\n  free (optarg_writable);\n}\n\nstatic void\nset_signal_proc_mask (void)\n{\n   \n  sigset_t set;\n  char const *debug_act;\n\n  sigemptyset (&set);\n\n  if (sigprocmask (0, nullptr, &set))\n    error (EXIT_CANCELED, errno, _(\"failed to get signal process mask\"));\n\n  for (int i = 1; i <= SIGNUM_BOUND; i++)\n    {\n      if (sigismember (&block_signals, i))\n        {\n          sigaddset (&set, i);\n          debug_act = \"BLOCK\";\n        }\n      else if (sigismember (&unblock_signals, i))\n        {\n          sigdelset (&set, i);\n          debug_act = \"UNBLOCK\";\n        }\n      else\n        {\n          debug_act = nullptr;\n        }\n\n      if (dev_debug && debug_act)\n        {\n          char signame[SIG2STR_MAX];\n          sig2str (i, signame);\n          devmsg (\"signal %s (%d) mask set to %s\\n\",\n                  signame, i, debug_act);\n        }\n    }\n\n  if (sigprocmask (SIG_SETMASK, &set, nullptr))\n    error (EXIT_CANCELED, errno, _(\"failed to set signal process mask\"));\n}\n\nstatic void\nlist_signal_handling (void)\n{\n  sigset_t set;\n  char signame[SIG2STR_MAX];\n\n  sigemptyset (&set);\n  if (sigprocmask (0, nullptr, &set))\n    error (EXIT_CANCELED, errno, _(\"failed to get signal process mask\"));\n\n  for (int i = 1; i <= SIGNUM_BOUND; i++)\n    {\n      struct sigaction act;\n      if (sigaction (i, nullptr, &act))\n        continue;\n\n      char const *ignored = act.sa_handler == SIG_IGN ? \"IGNORE\" : \"\";\n      char const *blocked = sigismember (&set, i) ? \"BLOCK\" : \"\";\n      char const *connect = *ignored && *blocked ? \",\" : \"\";\n\n      if (! *ignored && ! *blocked)\n        continue;\n\n      sig2str (i, signame);\n      fprintf (stderr, \"%-10s (%2d): %s%s%s\\n\", signame, i,\n               blocked, connect, ignored);\n    }\n}\n\nstatic void\ninitialize_signals (void)\n{\n  signals = xmalloc ((sizeof *signals) * (SIGNUM_BOUND + 1));\n\n  for (int i = 0 ; i <= SIGNUM_BOUND; i++)\n    signals[i] = UNCHANGED;\n\n  return;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  bool ignore_environment = false;\n  bool opt_nul_terminate_output = false;\n  char const *newdir = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXIT_CANCELED);\n  atexit (close_stdout);\n\n  initialize_signals ();\n\n  while ((optc = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'i':\n          ignore_environment = true;\n          break;\n        case 'u':\n          append_unset_var (optarg);\n          break;\n        case 'v':\n          dev_debug = true;\n          break;\n        case '0':\n          opt_nul_terminate_output = true;\n          break;\n        case DEFAULT_SIGNAL_OPTION:\n          parse_signal_action_params (optarg, true);\n          parse_block_signal_params (optarg, false);\n          break;\n        case IGNORE_SIGNAL_OPTION:\n          parse_signal_action_params (optarg, false);\n          break;\n        case BLOCK_SIGNAL_OPTION:\n          parse_block_signal_params (optarg, true);\n          break;\n        case LIST_SIGNAL_HANDLING_OPTION:\n          report_signal_handling = true;\n          break;\n        case 'C':\n          newdir = optarg;\n          break;\n        case 'S':\n          parse_split_string (optarg, &optind, &argc, &argv);\n          break;\n        case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n           \n          error (0, 0, _(\"invalid option -- '%c'\"), optc);\n          error (0, 0, _(\"use -[v]S to pass options in shebang lines\"));\n          usage (EXIT_CANCELED);\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_CANCELED);\n        }\n    }\n\n  if (optind < argc && STREQ (argv[optind], \"-\"))\n    {\n      ignore_environment = true;\n      ++optind;\n    }\n\n  if (ignore_environment)\n    {\n      devmsg (\"cleaning environ\\n\");\n      static char *dummy_environ[] = { nullptr };\n      environ = dummy_environ;\n    }\n  else\n    unset_envvars ();\n\n  char *eq;\n  while (optind < argc && (eq = strchr (argv[optind], '=')))\n    {\n      devmsg (\"setenv:   %s\\n\", argv[optind]);\n\n      if (putenv (argv[optind]))\n        {\n          *eq = '\\0';\n          error (EXIT_CANCELED, errno, _(\"cannot set %s\"),\n                 quote (argv[optind]));\n        }\n      optind++;\n    }\n\n  bool program_specified = optind < argc;\n\n  if (opt_nul_terminate_output && program_specified)\n    {\n      error (0, 0, _(\"cannot specify --null (-0) with command\"));\n      usage (EXIT_CANCELED);\n    }\n\n  if (newdir && ! program_specified)\n    {\n      error (0, 0, _(\"must specify command with --chdir (-C)\"));\n      usage (EXIT_CANCELED);\n    }\n\n  if (! program_specified)\n    {\n       \n      char *const *e = environ;\n      while (*e)\n        printf (\"%s%c\", *e++, opt_nul_terminate_output ? '\\0' : '\\n');\n      return EXIT_SUCCESS;\n    }\n\n  reset_signal_handlers ();\n  if (sig_mask_changed)\n    set_signal_proc_mask ();\n\n  if (report_signal_handling)\n    list_signal_handling ();\n\n  if (newdir)\n    {\n      devmsg (\"chdir:    %s\\n\", quoteaf (newdir));\n\n      if (chdir (newdir) != 0)\n        error (EXIT_CANCELED, errno, _(\"cannot change directory to %s\"),\n               quoteaf (newdir));\n    }\n\n  if (dev_debug)\n    {\n      devmsg (\"executing: %s\\n\", argv[optind]);\n      for (int i=optind; i<argc; ++i)\n        devmsg (\"   arg[%d]= %s\\n\", i-optind, quote (argv[i]));\n    }\n\n  execvp (argv[optind], &argv[optind]);\n\n  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n  error (0, errno, \"%s\", quote (argv[optind]));\n\n  if (exit_status == EXIT_ENOENT && strpbrk (argv[optind], C_ISSPACE_CHARS))\n    error (0, 0, _(\"use -[v]S to pass options in shebang lines\"));\n\n  main_exit (exit_status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}