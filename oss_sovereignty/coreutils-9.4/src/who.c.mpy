{
  "module_name": "who.c",
  "hash_id": "711873d5805971a7a2cd637f6fdbe12e2bb414e3c90d3b84ae33f7a27a08cfa5",
  "original_prompt": "Ingested from coreutils-9.4/src/who.c",
  "human_readable_source": " \n\n \n\n \n\n#include <config.h>\n#include <getopt.h>\n#include <stdckdint.h>\n#include <stdio.h>\n\n#include <sys/types.h>\n#include \"system.h\"\n\n#include \"c-ctype.h\"\n#include \"canon-host.h\"\n#include \"readutmp.h\"\n#include \"hard-locale.h\"\n#include \"quote.h\"\n\n#ifdef TTY_GROUP_NAME\n# include <grp.h>\n#endif\n\n \n#define PROGRAM_NAME \"who\"\n\n#define AUTHORS \\\n  proper_name (\"Joseph Arceneaux\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Michael Stone\")\n\n#ifdef RUN_LVL\n# define UT_TYPE_RUN_LVL(U) ((U)->ut_type == RUN_LVL)\n#else\n# define UT_TYPE_RUN_LVL(U) false\n#endif\n\n#ifdef INIT_PROCESS\n# define UT_TYPE_INIT_PROCESS(U) ((U)->ut_type == INIT_PROCESS)\n#else\n# define UT_TYPE_INIT_PROCESS(U) false\n#endif\n\n#ifdef LOGIN_PROCESS\n# define UT_TYPE_LOGIN_PROCESS(U) ((U)->ut_type == LOGIN_PROCESS)\n#else\n# define UT_TYPE_LOGIN_PROCESS(U) false\n#endif\n\n#ifdef DEAD_PROCESS\n# define UT_TYPE_DEAD_PROCESS(U) ((U)->ut_type == DEAD_PROCESS)\n#else\n# define UT_TYPE_DEAD_PROCESS(U) false\n#endif\n\n#ifdef NEW_TIME\n# define UT_TYPE_NEW_TIME(U) ((U)->ut_type == NEW_TIME)\n#else\n# define UT_TYPE_NEW_TIME(U) false\n#endif\n\n#define IDLESTR_LEN 6\n\n#if HAVE_STRUCT_XTMP_UT_PID\n# define PIDSTR_DECL_AND_INIT(Var, Utmp_ent) \\\n  char Var[INT_STRLEN_BOUND (Utmp_ent->ut_pid) + 1]; \\\n  sprintf (Var, \"%ld\", (long int) (Utmp_ent->ut_pid))\n#else\n# define PIDSTR_DECL_AND_INIT(Var, Utmp_ent) \\\n  char const *Var = \"\"\n#endif\n\n#if HAVE_STRUCT_XTMP_UT_ID\n# define UT_ID(U) ((U)->ut_id)\n#else\n# define UT_ID(U) \"??\"\n#endif\n\n \nstatic bool do_lookup;\n\n \nstatic bool short_list;\n\n \nstatic bool short_output;\n\n \nstatic bool include_idle;\n\n \nstatic bool include_heading;\n\n \nstatic bool include_mesg;\n\n \nstatic bool include_exit;\n\n \nstatic bool need_boottime;\n\n \nstatic bool need_deadprocs;\n\n \nstatic bool need_login;\n\n \nstatic bool need_initspawn;\n\n \nstatic bool need_clockchange;\n\n \nstatic bool need_runlevel;\n\n \nstatic bool need_users;\n\n \nstatic bool my_line_only;\n\n \nstatic char const *time_format;\nstatic int time_format_width;\n\n \nenum\n{\n  LOOKUP_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const longopts[] =\n{\n  {\"all\", no_argument, nullptr, 'a'},\n  {\"boot\", no_argument, nullptr, 'b'},\n  {\"count\", no_argument, nullptr, 'q'},\n  {\"dead\", no_argument, nullptr, 'd'},\n  {\"heading\", no_argument, nullptr, 'H'},\n  {\"login\", no_argument, nullptr, 'l'},\n  {\"lookup\", no_argument, nullptr, LOOKUP_OPTION},\n  {\"message\", no_argument, nullptr, 'T'},\n  {\"mesg\", no_argument, nullptr, 'T'},\n  {\"process\", no_argument, nullptr, 'p'},\n  {\"runlevel\", no_argument, nullptr, 'r'},\n  {\"short\", no_argument, nullptr, 's'},\n  {\"time\", no_argument, nullptr, 't'},\n  {\"users\", no_argument, nullptr, 'u'},\n  {\"writable\", no_argument, nullptr, 'T'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic char const *\nidle_string (time_t when, time_t boottime)\n{\n  static time_t now = TYPE_MINIMUM (time_t);\n\n  if (now == TYPE_MINIMUM (time_t))\n    time (&now);\n\n  int seconds_idle;\n  if (boottime < when && when <= now\n      && ! ckd_sub (&seconds_idle, now, when)\n      && seconds_idle < 24 * 60 * 60)\n    {\n      if (seconds_idle < 60)\n        return \"  .  \";\n      else\n        {\n          static char idle_hhmm[IDLESTR_LEN];\n          sprintf (idle_hhmm, \"%02d:%02d\",\n                   seconds_idle / (60 * 60),\n                   (seconds_idle % (60 * 60)) / 60);\n          return idle_hhmm;\n        }\n    }\n\n  return _(\" old \");\n}\n\n \nstatic char const *\ntime_string (struct gl_utmp const *utmp_ent)\n{\n  static char buf[INT_STRLEN_BOUND (intmax_t) + sizeof \"-%m-%d %H:%M\"];\n  struct tm *tmp = localtime (&utmp_ent->ut_ts.tv_sec);\n\n  if (tmp)\n    {\n      strftime (buf, sizeof buf, time_format, tmp);\n      return buf;\n    }\n  else\n    return timetostr (utmp_ent->ut_ts.tv_sec, buf);\n}\n\n \nstatic void\nprint_line (char const *user, const char state,\n            char const *line,\n            char const *time_str, char const *idle, char const *pid,\n            char const *comment, char const *exitstr)\n{\n  static char mesg[3] = { ' ', 'x', '\\0' };\n  char *buf;\n  char x_idle[1 + IDLESTR_LEN + 1];\n  char x_pid[1 + INT_STRLEN_BOUND (pid_t) + 1];\n  char *x_exitstr;\n  int err;\n\n  mesg[1] = state;\n\n  if (include_idle && !short_output && strlen (idle) < sizeof x_idle - 1)\n    sprintf (x_idle, \" %-6s\", idle);\n  else\n    *x_idle = '\\0';\n\n  if (!short_output && strlen (pid) < sizeof x_pid - 1)\n    sprintf (x_pid, \" %10s\", pid);\n  else\n    *x_pid = '\\0';\n\n  x_exitstr = xmalloc (include_exit ? 1 + MAX (12, strlen (exitstr)) + 1 : 1);\n  if (include_exit)\n    sprintf (x_exitstr, \" %-12s\", exitstr);\n  else\n    *x_exitstr = '\\0';\n\n  err = asprintf (&buf,\n                  \"%-8s\"\n                  \"%s\"\n                  \" %-12s\"\n                  \" %-*s\"\n                  \"%s\"\n                  \"%s\"\n                  \" %-8s\"\n                  \"%s\"\n                  ,\n                  user ? user : \"   .\",\n                  include_mesg ? mesg : \"\",\n                  line,\n                  time_format_width,\n                  time_str,\n                  x_idle,\n                  x_pid,\n                   \n                  comment,\n                  x_exitstr\n                  );\n  if (err == -1)\n    xalloc_die ();\n\n  {\n     \n    char *p = buf + strlen (buf);\n    while (*--p == ' ')\n       ;\n    *(p + 1) = '\\0';\n  }\n\n  puts (buf);\n  free (buf);\n  free (x_exitstr);\n}\n\n \nstatic bool\nis_tty_writable (struct stat const *pstat)\n{\n#ifdef TTY_GROUP_NAME\n   \nstatic void\nprint_user (struct gl_utmp const *utmp_ent, time_t boottime)\n{\n  struct stat stats;\n  time_t last_change;\n  char mesg;\n  char idlestr[IDLESTR_LEN + 1];\n  PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n  static char *hoststr;\n#if HAVE_STRUCT_XTMP_UT_HOST\n  static idx_t hostlen;\n#endif\n\n   \n  char *line = utmp_ent->ut_line;\n  char *space = strchr (line, ' ');\n  line = space ? space + 1 : line;\n\n  int dirfd;\n  if (IS_ABSOLUTE_FILE_NAME (line))\n    dirfd = AT_FDCWD;\n  else\n    {\n      static int dev_dirfd;\n      if (!dev_dirfd)\n        {\n          dev_dirfd = open (\"/dev\", O_PATHSEARCH | O_DIRECTORY);\n          if (dev_dirfd < 0)\n            dev_dirfd = AT_FDCWD - 1;\n        }\n      dirfd = dev_dirfd;\n    }\n\n  if (AT_FDCWD <= dirfd && fstatat (dirfd, line, &stats, 0) == 0)\n    {\n      mesg = is_tty_writable (&stats) ? '+' : '-';\n      last_change = stats.st_atime;\n    }\n  else\n    {\n      mesg = '?';\n      last_change = 0;\n    }\n\n  if (last_change)\n    sprintf (idlestr, \"%.*s\", IDLESTR_LEN, idle_string (last_change, boottime));\n  else\n    sprintf (idlestr, \"  ?\");\n\n#if HAVE_STRUCT_XTMP_UT_HOST\n  if (utmp_ent->ut_host[0])\n    {\n      char *host = nullptr;\n      char *display = nullptr;\n      char *ut_host = utmp_ent->ut_host;\n\n       \n      display = strchr (ut_host, ':');\n      if (display)\n        *display++ = '\\0';\n\n      if (*ut_host && do_lookup)\n        {\n           \n          host = canon_host (ut_host);\n        }\n\n      if (! host)\n        host = ut_host;\n\n      if (display)\n        {\n          idx_t needed = strlen (host) + strlen (display) + 4;\n          if (hostlen < needed)\n            {\n              free (hoststr);\n              hoststr = xpalloc (nullptr, &hostlen, needed - hostlen, -1, 1);\n            }\n          char *p = hoststr;\n          *p++ = '(';\n          p = stpcpy (p, host);\n          *p++ = ':';\n          strcpy (stpcpy (p, display), \")\");\n        }\n      else\n        {\n          idx_t needed = strlen (host) + 3;\n          if (hostlen < needed)\n            {\n              free (hoststr);\n              hoststr = xpalloc (nullptr, &hostlen, needed - hostlen, -1, 1);\n            }\n          char *p = hoststr;\n          *p++ = '(';\n          strcpy (stpcpy (p, host), \")\");\n        }\n\n      if (host != ut_host)\n        free (host);\n    }\n  else\n    {\n      if (hostlen < 1)\n        hoststr = xpalloc (hoststr, &hostlen, 1, -1, 1);\n      *hoststr = '\\0';\n    }\n#endif\n\n  print_line (utmp_ent->ut_user, mesg,\n              utmp_ent->ut_line,\n              time_string (utmp_ent), idlestr, pidstr,\n              hoststr ? hoststr : \"\", \"\");\n}\n\nstatic void\nprint_boottime (struct gl_utmp const *utmp_ent)\n{\n  print_line (\"\", ' ', _(\"system boot\"),\n              time_string (utmp_ent), \"\", \"\", \"\", \"\");\n}\n\nstatic char *\nmake_id_equals_comment (struct gl_utmp const *utmp_ent)\n{\n  char const *id = UT_ID (utmp_ent);\n  idx_t idlen = strlen (id);\n  char const *prefix = _(\"id=\");\n  idx_t prefixlen = strlen (prefix);\n  char *comment = xmalloc (prefixlen + idlen + 1);\n  char *p = mempcpy (comment, prefix, prefixlen);\n  p = mempcpy (p, id, idlen);\n  *p = '\\0';\n  return comment;\n}\n\nstatic void\nprint_deadprocs (struct gl_utmp const *utmp_ent)\n{\n  static char *exitstr;\n  char *comment = make_id_equals_comment (utmp_ent);\n  PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n\n  if (!exitstr)\n    exitstr = xmalloc (strlen (_(\"term=\"))\n                       + INT_STRLEN_BOUND (utmp_ent->ut_exit.e_termination) + 1\n                       + strlen (_(\"exit=\"))\n                       + INT_STRLEN_BOUND (utmp_ent->ut_exit.e_exit)\n                       + 1);\n  sprintf (exitstr, \"%s%d %s%d\", _(\"term=\"), utmp_ent->ut_exit.e_termination,\n           _(\"exit=\"), utmp_ent->ut_exit.e_exit);\n\n   \n\n  print_line (\"\", ' ', utmp_ent->ut_line,\n              time_string (utmp_ent), \"\", pidstr, comment, exitstr);\n  free (comment);\n}\n\nstatic void\nprint_login (struct gl_utmp const *utmp_ent)\n{\n  char *comment = make_id_equals_comment (utmp_ent);\n  PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n\n   \n\n  print_line (_(\"LOGIN\"), ' ', utmp_ent->ut_line,\n              time_string (utmp_ent), \"\", pidstr, comment, \"\");\n  free (comment);\n}\n\nstatic void\nprint_initspawn (struct gl_utmp const *utmp_ent)\n{\n  char *comment = make_id_equals_comment (utmp_ent);\n  PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n\n  print_line (\"\", ' ', utmp_ent->ut_line,\n              time_string (utmp_ent), \"\", pidstr, comment, \"\");\n  free (comment);\n}\n\nstatic void\nprint_clockchange (struct gl_utmp const *utmp_ent)\n{\n   \n  print_line (\"\", ' ', _(\"clock change\"),\n              time_string (utmp_ent), \"\", \"\", \"\", \"\");\n}\n\nstatic void\nprint_runlevel (struct gl_utmp const *utmp_ent)\n{\n  static char *runlevline, *comment;\n  unsigned char last = utmp_ent->ut_pid / 256;\n  unsigned char curr = utmp_ent->ut_pid % 256;\n\n  if (!runlevline)\n    runlevline = xmalloc (strlen (_(\"run-level\")) + 3);\n  sprintf (runlevline, \"%s %c\", _(\"run-level\"), curr);\n\n  if (!comment)\n    comment = xmalloc (strlen (_(\"last=\")) + 2);\n  sprintf (comment, \"%s%c\", _(\"last=\"), (last == 'N') ? 'S' : last);\n\n  print_line (\"\", ' ', runlevline, time_string (utmp_ent),\n              \"\", \"\", c_isprint (last) ? comment : \"\", \"\");\n\n  return;\n}\n\n \nstatic void\nlist_entries_who (idx_t n, struct gl_utmp const *utmp_buf)\n{\n  idx_t entries = 0;\n  char const *separator = \"\";\n\n  while (n--)\n    {\n      if (IS_USER_PROCESS (utmp_buf))\n        {\n          char *trimmed_name;\n\n          trimmed_name = extract_trimmed_name (utmp_buf);\n\n          printf (\"%s%s\", separator, trimmed_name);\n          free (trimmed_name);\n          separator = \" \";\n          entries++;\n        }\n      utmp_buf++;\n    }\n  printf (_(\"\\n# users=%td\\n\"), entries);\n}\n\nstatic void\nprint_heading (void)\n{\n  print_line (_(\"NAME\"), ' ', _(\"LINE\"), _(\"TIME\"), _(\"IDLE\"),\n              _(\"PID\"), _(\"COMMENT\"), _(\"EXIT\"));\n}\n\n \nstatic void\nscan_entries (idx_t n, struct gl_utmp const *utmp_buf)\n{\n  char *ttyname_b IF_LINT ( = nullptr);\n  time_t boottime = TYPE_MINIMUM (time_t);\n\n  if (include_heading)\n    print_heading ();\n\n  if (my_line_only)\n    {\n      ttyname_b = ttyname (STDIN_FILENO);\n      if (!ttyname_b)\n        return;\n      if (STRNCMP_LIT (ttyname_b, \"/dev/\") == 0)\n        ttyname_b += sizeof \"/dev/\" - 1;\t \n    }\n\n  while (n--)\n    {\n      if (!my_line_only\n          || STREQ (ttyname_b, utmp_buf->ut_line))\n        {\n          if (need_users && IS_USER_PROCESS (utmp_buf))\n            print_user (utmp_buf, boottime);\n          else if (need_runlevel && UT_TYPE_RUN_LVL (utmp_buf))\n            print_runlevel (utmp_buf);\n          else if (need_boottime && UT_TYPE_BOOT_TIME (utmp_buf))\n            print_boottime (utmp_buf);\n           \n          else if (need_clockchange && UT_TYPE_NEW_TIME (utmp_buf))\n            print_clockchange (utmp_buf);\n          else if (need_initspawn && UT_TYPE_INIT_PROCESS (utmp_buf))\n            print_initspawn (utmp_buf);\n          else if (need_login && UT_TYPE_LOGIN_PROCESS (utmp_buf))\n            print_login (utmp_buf);\n          else if (need_deadprocs && UT_TYPE_DEAD_PROCESS (utmp_buf))\n            print_deadprocs (utmp_buf);\n        }\n\n      if (UT_TYPE_BOOT_TIME (utmp_buf))\n        boottime = utmp_buf->ut_ts.tv_sec;\n\n      utmp_buf++;\n    }\n}\n\n \nstatic void\nwho (char const *filename, int options)\n{\n  idx_t n_users;\n  struct gl_utmp *utmp_buf;\n  if (short_list)\n    options |= READ_UTMP_USER_PROCESS;\n  if (read_utmp (filename, &n_users, &utmp_buf, options) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (filename));\n\n  if (short_list)\n    list_entries_who (n_users, utmp_buf);\n  else\n    scan_entries (n_users, utmp_buf);\n\n  free (utmp_buf);\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\\n\"), program_name);\n      fputs (_(\"\\\nPrint information about users who are currently logged in.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -a, --all         same as -b -d --login -p -r -t -T -u\\n\\\n  -b, --boot        time of last system boot\\n\\\n  -d, --dead        print dead processes\\n\\\n  -H, --heading     print line of column headings\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -l, --login       print system login processes\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --lookup      attempt to canonicalize hostnames via DNS\\n\\\n  -m                only hostname and user associated with stdin\\n\\\n  -p, --process     print active processes spawned by init\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -q, --count       all login names and number of users logged on\\n\\\n  -r, --runlevel    print current runlevel\\n\\\n  -s, --short       print only name, line, and time (default)\\n\\\n  -t, --time        print last system clock change\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -T, -w, --mesg    add user's message status as +, - or ?\\n\\\n  -u, --users       list users logged in\\n\\\n      --message     same as -T\\n\\\n      --writable    same as -T\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      printf (_(\"\\\n\\n\\\nIf FILE is not specified, use %s.  %s as FILE is common.\\n\\\nIf ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\\n\\\n\"), UTMP_FILE, WTMP_FILE);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  bool assumptions = true;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"abdlmpqrstuwHT\", longopts, nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'a':\n          need_boottime = true;\n          need_deadprocs = true;\n          need_login = true;\n          need_initspawn = true;\n          need_runlevel = true;\n          need_clockchange = true;\n          need_users = true;\n          include_mesg = true;\n          include_idle = true;\n          include_exit = true;\n          assumptions = false;\n          break;\n\n        case 'b':\n          need_boottime = true;\n          assumptions = false;\n          break;\n\n        case 'd':\n          need_deadprocs = true;\n          include_idle = true;\n          include_exit = true;\n          assumptions = false;\n          break;\n\n        case 'H':\n          include_heading = true;\n          break;\n\n        case 'l':\n          need_login = true;\n          include_idle = true;\n          assumptions = false;\n          break;\n\n        case 'm':\n          my_line_only = true;\n          break;\n\n        case 'p':\n          need_initspawn = true;\n          assumptions = false;\n          break;\n\n        case 'q':\n          short_list = true;\n          break;\n\n        case 'r':\n          need_runlevel = true;\n          include_idle = true;\n          assumptions = false;\n          break;\n\n        case 's':\n          short_output = true;\n          break;\n\n        case 't':\n          need_clockchange = true;\n          assumptions = false;\n          break;\n\n        case 'T':\n        case 'w':\n          include_mesg = true;\n          break;\n\n        case 'u':\n          need_users = true;\n          include_idle = true;\n          assumptions = false;\n          break;\n\n        case LOOKUP_OPTION:\n          do_lookup = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (assumptions)\n    {\n      need_users = true;\n      short_output = true;\n    }\n\n  if (include_exit)\n    {\n      short_output = false;\n    }\n\n  if (hard_locale (LC_TIME))\n    {\n      time_format = \"%Y-%m-%d %H:%M\";\n      time_format_width = 4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2;\n    }\n  else\n    {\n      time_format = \"%b %e %H:%M\";\n      time_format_width = 3 + 1 + 2 + 1 + 2 + 1 + 2;\n    }\n\n  switch (argc - optind)\n    {\n    case 2:\t\t\t/* who <blurf> <glop> */\n      my_line_only = true;\n      FALLTHROUGH;\n    case -1:\n    case 0:\t\t\t/* who */\n      who (UTMP_FILE, READ_UTMP_CHECK_PIDS);\n      break;\n\n    case 1:\t\t\t/* who <utmp file> */\n      who (argv[optind], 0);\n      break;\n\n    default:\t\t\t/* lose */\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 2]));\n      usage (EXIT_FAILURE);\n    }\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}