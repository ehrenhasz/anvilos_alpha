{
  "module_name": "basenc.c",
  "hash_id": "4c9badb37397c2f983ff971192648e273187080b4fd3d43561e961dfccdabd15",
  "original_prompt": "Ingested from coreutils-9.4/src/basenc.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"c-ctype.h\"\n#include \"fadvise.h\"\n#include \"quote.h\"\n#include \"xstrtol.h\"\n#include \"xdectoint.h\"\n#include \"xbinary-io.h\"\n\n#if BASE_TYPE == 42\n# define AUTHORS \\\n  proper_name (\"Simon Josefsson\"), \\\n  proper_name (\"Assaf Gordon\")\n#else\n# define AUTHORS proper_name (\"Simon Josefsson\")\n#endif\n\n#if BASE_TYPE == 32\n# include \"base32.h\"\n# define PROGRAM_NAME \"base32\"\n#elif BASE_TYPE == 64\n# include \"base64.h\"\n# define PROGRAM_NAME \"base64\"\n#elif BASE_TYPE == 42\n# include \"base32.h\"\n# include \"base64.h\"\n# include \"assure.h\"\n# define PROGRAM_NAME \"basenc\"\n#else\n# error missing/invalid BASE_TYPE definition\n#endif\n\n\n\n#if BASE_TYPE == 42\nenum\n{\n  BASE64_OPTION = CHAR_MAX + 1,\n  BASE64URL_OPTION,\n  BASE32_OPTION,\n  BASE32HEX_OPTION,\n  BASE16_OPTION,\n  BASE2MSBF_OPTION,\n  BASE2LSBF_OPTION,\n  Z85_OPTION\n};\n#endif\n\nstatic struct option const long_options[] =\n{\n  {\"decode\", no_argument, 0, 'd'},\n  {\"wrap\", required_argument, 0, 'w'},\n  {\"ignore-garbage\", no_argument, 0, 'i'},\n#if BASE_TYPE == 42\n  {\"base64\",    no_argument, 0, BASE64_OPTION},\n  {\"base64url\", no_argument, 0, BASE64URL_OPTION},\n  {\"base32\",    no_argument, 0, BASE32_OPTION},\n  {\"base32hex\", no_argument, 0, BASE32HEX_OPTION},\n  {\"base16\",    no_argument, 0, BASE16_OPTION},\n  {\"base2msbf\", no_argument, 0, BASE2MSBF_OPTION},\n  {\"base2lsbf\", no_argument, 0, BASE2LSBF_OPTION},\n  {\"z85\",       no_argument, 0, Z85_OPTION},\n#endif\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]\\n\\\n\"), program_name);\n\n#if BASE_TYPE == 42\n      fputs (_(\"\\\nbasenc encode or decode FILE, or standard input, to standard output.\\n\\\n\"), stdout);\n#else\n      printf (_(\"\\\nBase%d encode or decode FILE, or standard input, to standard output.\\n\\\n\"), BASE_TYPE);\n#endif\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n#if BASE_TYPE == 42\n      fputs (_(\"\\\n      --base64          same as 'base64' program (RFC4648 section 4)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --base64url       file- and url-safe base64 (RFC4648 section 5)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --base32          same as 'base32' program (RFC4648 section 6)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --base32hex       extended hex alphabet base32 (RFC4648 section 7)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --base16          hex encoding (RFC4648 section 8)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --base2msbf       bit string with most significant bit (msb) first\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --base2lsbf       bit string with least significant bit (lsb) first\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n  -d, --decode          decode data\\n\\\n  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\\n\\\n  -w, --wrap=COLS       wrap encoded lines after COLS character (default 76).\\n\\\n                          Use 0 to disable line wrapping\\n\\\n\"), stdout);\n#if BASE_TYPE == 42\n      fputs (_(\"\\\n      --z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\\n\\\n                        when encoding, input length must be a multiple of 4;\\n\\\n                        when decoding, input length must be a multiple of 5\\n\\\n\"), stdout);\n#endif\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n#if BASE_TYPE == 42\n      fputs (_(\"\\\n\\n\\\nWhen decoding, the input may contain newlines in addition to the bytes of\\n\\\nthe formal alphabet.  Use --ignore-garbage to attempt to recover\\n\\\nfrom any other non-alphabet bytes in the encoded stream.\\n\\\n\"), stdout);\n#else\n      printf (_(\"\\\n\\n\\\nThe data are encoded as described for the %s alphabet in RFC 4648.\\n\\\nWhen decoding, the input may contain newlines in addition to the bytes of\\n\\\nthe formal %s alphabet.  Use --ignore-garbage to attempt to recover\\n\\\nfrom any other non-alphabet bytes in the encoded stream.\\n\"),\n              PROGRAM_NAME, PROGRAM_NAME);\n#endif\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\n#define ENC_BLOCKSIZE (1024 * 3 * 10)\n\n#if BASE_TYPE == 32\n# define BASE_LENGTH BASE32_LENGTH\n/* Note that increasing this may decrease performance if --ignore-garbage\n   is used, because of the memmove operation below.  */\n# define DEC_BLOCKSIZE (1024 * 5)\n\n/* Ensure that BLOCKSIZE is a multiple of 5 and 8.  */\nstatic_assert (ENC_BLOCKSIZE % 40 == 0); /* Padding chars only on last block. */\nstatic_assert (DEC_BLOCKSIZE % 40 == 0); /* Complete encoded blocks are used. */\n\n# define base_encode base32_encode\n# define base_decode_context base32_decode_context\n# define base_decode_ctx_init base32_decode_ctx_init\n# define base_decode_ctx base32_decode_ctx\n# define isbase isbase32\n#elif BASE_TYPE == 64\n# define BASE_LENGTH BASE64_LENGTH\n/* Note that increasing this may decrease performance if --ignore-garbage\n   is used, because of the memmove operation below.  */\n# define DEC_BLOCKSIZE (1024 * 3)\n\n/* Ensure that BLOCKSIZE is a multiple of 3 and 4.  */\nstatic_assert (ENC_BLOCKSIZE % 12 == 0); /* Padding chars only on last block. */\nstatic_assert (DEC_BLOCKSIZE % 12 == 0); /* Complete encoded blocks are used. */\n\n# define base_encode base64_encode\n# define base_decode_context base64_decode_context\n# define base_decode_ctx_init base64_decode_ctx_init\n# define base_decode_ctx base64_decode_ctx\n# define isbase isbase64\n#elif BASE_TYPE == 42\n\n\n# define BASE_LENGTH base_length\n\n/* Note that increasing this may decrease performance if --ignore-garbage\n   is used, because of the memmove operation below.  */\n# define DEC_BLOCKSIZE (4200)\nstatic_assert (DEC_BLOCKSIZE % 40 == 0); /* complete encoded blocks for base32*/\nstatic_assert (DEC_BLOCKSIZE % 12 == 0); /* complete encoded blocks for base64*/\n\nstatic int (*base_length) (int i);\nstatic bool (*isbase) (char ch);\nstatic void (*base_encode) (char const *restrict in, idx_t inlen,\n                            char *restrict out, idx_t outlen);\n\nstruct base16_decode_context\n{\n  char nibble;\n  bool have_nibble;\n};\n\nstruct z85_decode_context\n{\n  int i;\n  unsigned char octets[5];\n};\n\nstruct base2_decode_context\n{\n  unsigned char octet;\n};\n\nstruct base_decode_context\n{\n  int i; /* will be updated manually */\n  union {\n    struct base64_decode_context base64;\n    struct base32_decode_context base32;\n    struct base16_decode_context base16;\n    struct base2_decode_context base2;\n    struct z85_decode_context z85;\n  } ctx;\n  char *inbuf;\n  idx_t bufsize;\n};\nstatic void (*base_decode_ctx_init) (struct base_decode_context *ctx);\nstatic bool (*base_decode_ctx) (struct base_decode_context *ctx,\n                                char const *restrict in, idx_t inlen,\n                                char *restrict out, idx_t *outlen);\n#endif\n\n\n\n\n#if BASE_TYPE == 42\n\nstatic int\nbase64_length_wrapper (int len)\n{\n  return BASE64_LENGTH (len);\n}\n\nstatic void\nbase64_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n{\n  base64_decode_ctx_init (&ctx->ctx.base64);\n}\n\nstatic bool\nbase64_decode_ctx_wrapper (struct base_decode_context *ctx,\n                           char const *restrict in, idx_t inlen,\n                           char *restrict out, idx_t *outlen)\n{\n  bool b = base64_decode_ctx (&ctx->ctx.base64, in, inlen, out, outlen);\n  ctx->i = ctx->ctx.base64.i;\n  return b;\n}\n\nstatic void\ninit_inbuf (struct base_decode_context *ctx)\n{\n  ctx->bufsize = DEC_BLOCKSIZE;\n  ctx->inbuf = xcharalloc (ctx->bufsize);\n}\n\nstatic void\nprepare_inbuf (struct base_decode_context *ctx, idx_t inlen)\n{\n  if (ctx->bufsize < inlen)\n    {\n      ctx->bufsize = inlen * 2;\n      ctx->inbuf = xnrealloc (ctx->inbuf, ctx->bufsize, sizeof (char));\n    }\n}\n\n\nstatic void\nbase64url_encode (char const *restrict in, idx_t inlen,\n                  char *restrict out, idx_t outlen)\n{\n  base64_encode (in, inlen, out, outlen);\n  /* translate 62nd and 63rd characters */\n  char *p = out;\n  while (outlen--)\n    {\n      if (*p == '+')\n        *p = '-';\n      else if (*p == '/')\n        *p = '_';\n      ++p;\n    }\n}\n\nstatic bool\nisbase64url (char ch)\n{\n  return (ch == '-' || ch == '_'\n          || (ch != '+' && ch != '/' && isbase64 (ch)));\n}\n\nstatic void\nbase64url_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n{\n  base64_decode_ctx_init (&ctx->ctx.base64);\n  init_inbuf (ctx);\n}\n\n\nstatic bool\nbase64url_decode_ctx_wrapper (struct base_decode_context *ctx,\n                              char const *restrict in, idx_t inlen,\n                              char *restrict out, idx_t *outlen)\n{\n  prepare_inbuf (ctx, inlen);\n  memcpy (ctx->inbuf, in, inlen);\n\n  /* translate 62nd and 63rd characters */\n  idx_t i = inlen;\n  char *p = ctx->inbuf;\n  while (i--)\n    {\n      if (*p == '+' || *p == '/')\n        {\n          *outlen = 0;\n          return false; /* reject base64 input */\n        }\n      else if (*p == '-')\n        *p = '+';\n      else if (*p == '_')\n        *p = '/';\n      ++p;\n    }\n\n  bool b = base64_decode_ctx (&ctx->ctx.base64, ctx->inbuf, inlen,\n                              out, outlen);\n  ctx->i = ctx->ctx.base64.i;\n\n  return b;\n}\n\n\n\nstatic int\nbase32_length_wrapper (int len)\n{\n  return BASE32_LENGTH (len);\n}\n\nstatic void\nbase32_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n{\n  base32_decode_ctx_init (&ctx->ctx.base32);\n}\n\nstatic bool\nbase32_decode_ctx_wrapper (struct base_decode_context *ctx,\n                           char const *restrict in, idx_t inlen,\n                           char *restrict out, idx_t *outlen)\n{\n  bool b = base32_decode_ctx (&ctx->ctx.base32, in, inlen, out, outlen);\n  ctx->i = ctx->ctx.base32.i;\n  return b;\n}\n\n/* ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\n     to\n   0123456789ABCDEFGHIJKLMNOPQRSTUV */\nstatic const char base32_norm_to_hex[32 + 9] = {\n/*0x32, 0x33, 0x34, 0x35, 0x36, 0x37, */\n  'Q',  'R',  'S',  'T',  'U',  'V',\n\n  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,\n\n/*0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, */\n  '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',\n\n/*0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, */\n  '8',  '9',  'A',  'B',  'C',  'D',  'E',  'F',\n\n/*0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, */\n  'G',  'H',  'I',  'J',  'K',  'L',  'M',  'N',\n\n/*0x59, 0x5a, */\n  'O',  'P',\n};\n\n/* 0123456789ABCDEFGHIJKLMNOPQRSTUV\n     to\n   ABCDEFGHIJKLMNOPQRSTUVWXYZ234567 */\nstatic const char base32_hex_to_norm[32 + 9] = {\n  /* from: 0x30 .. 0x39 ('0' to '9') */\n  /* to:*/ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n\n  0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,\n\n  /* from: 0x41 .. 0x4A ('A' to 'J') */\n  /* to:*/ 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n\n  /* from: 0x4B .. 0x54 ('K' to 'T') */\n  /* to:*/ 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5',\n\n  /* from: 0x55 .. 0x56 ('U' to 'V') */\n  /* to:*/ '6', '7'\n};\n\n\ninline static bool\nisbase32hex (char ch)\n{\n  return ('0' <= ch && ch <= '9') || ('A' <= ch && ch <= 'V');\n}\n\n\nstatic void\nbase32hex_encode (char const *restrict in, idx_t inlen,\n                  char *restrict out, idx_t outlen)\n{\n  base32_encode (in, inlen, out, outlen);\n\n  for (char *p = out; outlen--; p++)\n    {\n      affirm (0x32 <= *p && *p <= 0x5a);          /* LCOV_EXCL_LINE */\n      *p = base32_norm_to_hex[*p - 0x32];\n    }\n}\n\n\nstatic void\nbase32hex_decode_ctx_init_wrapper (struct base_decode_context *ctx)\n{\n  base32_decode_ctx_init (&ctx->ctx.base32);\n  init_inbuf (ctx);\n}\n\n\nstatic bool\nbase32hex_decode_ctx_wrapper (struct base_decode_context *ctx,\n                              char const *restrict in, idx_t inlen,\n                              char *restrict out, idx_t *outlen)\n{\n  prepare_inbuf (ctx, inlen);\n\n  idx_t i = inlen;\n  char *p = ctx->inbuf;\n  while (i--)\n    {\n      if (isbase32hex (*in))\n        *p = base32_hex_to_norm[ (int)*in - 0x30];\n      else\n        *p = *in;\n      ++p;\n      ++in;\n    }\n\n  bool b = base32_decode_ctx (&ctx->ctx.base32, ctx->inbuf, inlen,\n                              out, outlen);\n  ctx->i = ctx->ctx.base32.i;\n\n  return b;\n}\n\n\nstatic bool\nisbase16 (char ch)\n{\n  return ('0' <= ch && ch <= '9') || ('A' <= ch && ch <= 'F');\n}\n\nstatic int\nbase16_length (int len)\n{\n  return len * 2;\n}\n\nstatic const char base16[16] = \"0123456789ABCDEF\";\n\nstatic void\nbase16_encode (char const *restrict in, idx_t inlen,\n               char *restrict out, idx_t outlen)\n{\n  while (inlen--)\n    {\n      unsigned char c = *in;\n      *out++ = base16[c >> 4];\n      *out++ = base16[c & 0x0F];\n      ++in;\n    }\n}\n\n\nstatic void\nbase16_decode_ctx_init (struct base_decode_context *ctx)\n{\n  init_inbuf (ctx);\n  ctx->ctx.base16.have_nibble = false;\n  ctx->i = 1;\n}\n\n\nstatic bool\nbase16_decode_ctx (struct base_decode_context *ctx,\n                   char const *restrict in, idx_t inlen,\n                   char *restrict out, idx_t *outlen)\n{\n  bool ignore_lines = true;  /* for now, always ignore them */\n\n  *outlen = 0;\n\n  /* inlen==0 is request to flush output.\n     if there is a dangling high nibble - we are missing the low nibble,\n     so return false - indicating an invalid input.  */\n  if (inlen == 0)\n    return !ctx->ctx.base16.have_nibble;\n\n  while (inlen--)\n    {\n      if (ignore_lines && *in == '\\n')\n        {\n          ++in;\n          continue;\n        }\n\n      int nib = *in++;\n      if ('0' <= nib && nib <= '9')\n        nib -= '0';\n      else if ('A' <= nib && nib <= 'F')\n        nib -= 'A' - 10;\n      else\n        return false; /* garbage - return false */\n\n      if (ctx->ctx.base16.have_nibble)\n        {\n          /* have both nibbles, write octet */\n          *out++ = (ctx->ctx.base16.nibble << 4) + nib;\n          ++(*outlen);\n        }\n      else\n        {\n          /* Store higher nibble until next one arrives */\n          ctx->ctx.base16.nibble = nib;\n        }\n      ctx->ctx.base16.have_nibble = !ctx->ctx.base16.have_nibble;\n    }\n  return true;\n}\n\n\n\n\nstatic int\nz85_length (int len)\n{\n  /* Z85 does not allow padding, so no need to round to highest integer.  */\n  int outlen = (len * 5) / 4;\n  return outlen;\n}\n\nstatic bool\nisz85 (char ch)\n{\n  return c_isalnum (ch) || strchr (\".-:+=^! \n          if (i == 0)\n            return;\n\n           \n          error (EXIT_FAILURE, 0,\n                 _(\"invalid input (length must be multiple of 4 characters)\"));\n        }\n      else\n        {\n          quad[i++] = *in++;\n          --inlen;\n        }\n\n       \n      if (i == 4)\n        {\n          int_fast64_t val = quad[0];\n          val = (val << 24) + (quad[1] << 16) + (quad[2] << 8) + quad[3];\n\n          for (int j = 4; j >= 0; --j)\n            {\n              int c = val % 85;\n              val /= 85;\n\n               \n              if (outidx + j < outlen)\n                out[j] = z85_encoding[c];\n            }\n          out += 5;\n          outidx += 5;\n          i = 0;\n        }\n    }\n}\n\nstatic void\nz85_decode_ctx_init (struct base_decode_context *ctx)\n{\n  init_inbuf (ctx);\n  ctx->ctx.z85.i = 0;\n  ctx->i = 1;\n}\n\n\n# define Z85_LO_CTX_TO_32BIT_VAL(ctx) \\\n  (((ctx)->ctx.z85.octets[1] * 85 * 85 * 85) +      \\\n   ((ctx)->ctx.z85.octets[2] * 85 * 85) +\t    \\\n   ((ctx)->ctx.z85.octets[3] * 85) +\t\t    \\\n   ((ctx)->ctx.z85.octets[4]))\n\n\n# define Z85_HI_CTX_TO_32BIT_VAL(ctx) \\\n  ((int_fast64_t) (ctx)->ctx.z85.octets[0] * 85 * 85 * 85 * 85 )\n\n \nstatic signed char const z85_decoding[93] = {\n  68, -1,  84,  83, 82,  72, -1,                \n  75, 76,  70,  65, -1,  63, 62, 69,            \n  0,  1,   2,   3,  4,   5,  6,   7,  8,  9,    \n  64, -1,  73,  66, 74,  71, 81,                \n  36, 37,  38,  39, 40,  41, 42,  43, 44, 45,   \n  46, 47,  48,  49, 50,  51, 52,  53, 54, 55,   \n  56, 57,  58,  59, 60,  61,                    \n  77,  -1, 78,  67,  -1,  -1,                   \n  10, 11,  12,  13, 14,  15, 16,  17, 18, 19,   \n  20, 21,  22,  23, 24,  25, 26,  27, 28, 29,   \n  30, 31,  32,  33, 34,  35,                    \n  79, -1,  80                                   \n};\n\nstatic bool\nz85_decode_ctx (struct base_decode_context *ctx,\n                char const *restrict in, idx_t inlen,\n                char *restrict out, idx_t *outlen)\n{\n  bool ignore_lines = true;   \n\n  *outlen = 0;\n\n   \n  if (inlen == 0)\n    {\n      if (ctx->ctx.z85.i > 0)\n        {\n           \n          return false;\n        }\n      return true;\n    }\n\n  while (inlen--)\n    {\n      if (ignore_lines && *in == '\\n')\n        {\n          ++in;\n          continue;\n        }\n\n       \n      unsigned char c = *in;\n\n      if (c >= 33 && c <= 125)\n        {\n          signed char ch = z85_decoding[c - 33];\n          if (ch < 0)\n            return false;  \n          c = ch;\n        }\n      else\n        return false;  \n\n      ++in;\n\n      ctx->ctx.z85.octets[ctx->ctx.z85.i++] = c;\n      if (ctx->ctx.z85.i == 5)\n        {\n           \n          int_fast64_t val = Z85_LO_CTX_TO_32BIT_VAL (ctx);\n\n           \n\n          val += Z85_HI_CTX_TO_32BIT_VAL (ctx);\n          if ((val >> 24) & ~0xFF)\n            return false;\n\n          *out++ = val >> 24;\n          *out++ = (val >> 16) & 0xFF;\n          *out++ = (val >> 8) & 0xFF;\n          *out++ = val & 0xFF;\n\n          *outlen += 4;\n\n          ctx->ctx.z85.i = 0;\n        }\n    }\n  ctx->i = ctx->ctx.z85.i;\n  return true;\n}\n\n\ninline static bool\nisbase2 (char ch)\n{\n  return ch == '0' || ch == '1';\n}\n\nstatic int\nbase2_length (int len)\n{\n  return len * 8;\n}\n\n\ninline static void\nbase2msbf_encode (char const *restrict in, idx_t inlen,\n                  char *restrict out, idx_t outlen)\n{\n  while (inlen--)\n    {\n      unsigned char c = *in;\n      for (int i = 0; i < 8; i++)\n        {\n          *out++ = c & 0x80 ? '1' : '0';\n          c <<= 1;\n        }\n      outlen -= 8;\n      ++in;\n    }\n}\n\ninline static void\nbase2lsbf_encode (char const *restrict in, idx_t inlen,\n                  char *restrict out, idx_t outlen)\n{\n  while (inlen--)\n    {\n      unsigned char c = *in;\n      for (int i = 0; i < 8; i++)\n        {\n          *out++ = c & 0x01 ? '1' : '0';\n          c >>= 1;\n        }\n      outlen -= 8;\n      ++in;\n    }\n}\n\n\nstatic void\nbase2_decode_ctx_init (struct base_decode_context *ctx)\n{\n  init_inbuf (ctx);\n  ctx->ctx.base2.octet = 0;\n  ctx->i = 0;\n}\n\n\nstatic bool\nbase2lsbf_decode_ctx (struct base_decode_context *ctx,\n                      char const *restrict in, idx_t inlen,\n                      char *restrict out, idx_t *outlen)\n{\n  bool ignore_lines = true;   \n\n  *outlen = 0;\n\n   \n  if (inlen == 0)\n    return ctx->i == 0;\n\n  while (inlen--)\n    {\n      if (ignore_lines && *in == '\\n')\n        {\n          ++in;\n          continue;\n        }\n\n      if (!isbase2 (*in))\n        return false;\n\n      bool bit = (*in == '1');\n      ctx->ctx.base2.octet |= bit << ctx->i;\n      ++ctx->i;\n\n      if (ctx->i == 8)\n        {\n          *out++ = ctx->ctx.base2.octet;\n          ctx->ctx.base2.octet = 0;\n          ++*outlen;\n          ctx->i = 0;\n        }\n\n      ++in;\n    }\n\n  return true;\n}\n\nstatic bool\nbase2msbf_decode_ctx (struct base_decode_context *ctx,\n                      char const *restrict in, idx_t inlen,\n                      char *restrict out, idx_t *outlen)\n{\n  bool ignore_lines = true;   \n\n  *outlen = 0;\n\n   \n  if (inlen == 0)\n    return ctx->i == 0;\n\n  while (inlen--)\n    {\n      if (ignore_lines && *in == '\\n')\n        {\n          ++in;\n          continue;\n        }\n\n      if (!isbase2 (*in))\n        return false;\n\n      bool bit = (*in == '1');\n      if (ctx->i == 0)\n        ctx->i = 8;\n      --ctx->i;\n      ctx->ctx.base2.octet |= bit << ctx->i;\n\n      if (ctx->i == 0)\n        {\n          *out++ = ctx->ctx.base2.octet;\n          ctx->ctx.base2.octet = 0;\n          ++*outlen;\n          ctx->i = 0;\n        }\n\n      ++in;\n    }\n\n  return true;\n}\n\n#endif  \n\n\n\nstatic void\nwrap_write (char const *buffer, idx_t len,\n            idx_t wrap_column, idx_t *current_column, FILE *out)\n{\n  if (wrap_column == 0)\n    {\n       \n      if (fwrite (buffer, 1, len, stdout) < len)\n        write_error ();\n    }\n  else\n    for (idx_t written = 0; written < len; )\n      {\n        idx_t to_write = MIN (wrap_column - *current_column, len - written);\n\n        if (to_write == 0)\n          {\n            if (fputc ('\\n', out) == EOF)\n              write_error ();\n            *current_column = 0;\n          }\n        else\n          {\n            if (fwrite (buffer + written, 1, to_write, stdout) < to_write)\n              write_error ();\n            *current_column += to_write;\n            written += to_write;\n          }\n      }\n}\n\nstatic _Noreturn void\nfinish_and_exit (FILE *in, char const *infile)\n{\n  if (fclose (in) != 0)\n    {\n      if (STREQ (infile, \"-\"))\n        error (EXIT_FAILURE, errno, _(\"closing standard input\"));\n      else\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n    }\n\n  exit (EXIT_SUCCESS);\n}\n\nstatic _Noreturn void\ndo_encode (FILE *in, char const *infile, FILE *out, idx_t wrap_column)\n{\n  idx_t current_column = 0;\n  char *inbuf, *outbuf;\n  idx_t sum;\n\n  inbuf = xmalloc (ENC_BLOCKSIZE);\n  outbuf = xmalloc (BASE_LENGTH (ENC_BLOCKSIZE));\n\n  do\n    {\n      idx_t n;\n\n      sum = 0;\n      do\n        {\n          n = fread (inbuf + sum, 1, ENC_BLOCKSIZE - sum, in);\n          sum += n;\n        }\n      while (!feof (in) && !ferror (in) && sum < ENC_BLOCKSIZE);\n\n      if (sum > 0)\n        {\n           \n          base_encode (inbuf, sum, outbuf, BASE_LENGTH (sum));\n\n          wrap_write (outbuf, BASE_LENGTH (sum), wrap_column,\n                      &current_column, out);\n        }\n    }\n  while (!feof (in) && !ferror (in) && sum == ENC_BLOCKSIZE);\n\n   \n  if (wrap_column && current_column > 0 && fputc ('\\n', out) == EOF)\n    write_error ();\n\n  if (ferror (in))\n    error (EXIT_FAILURE, errno, _(\"read error\"));\n\n  finish_and_exit (in, infile);\n}\n\nstatic _Noreturn void\ndo_decode (FILE *in, char const *infile, FILE *out, bool ignore_garbage)\n{\n  char *inbuf, *outbuf;\n  idx_t sum;\n  struct base_decode_context ctx;\n\n  inbuf = xmalloc (BASE_LENGTH (DEC_BLOCKSIZE));\n  outbuf = xmalloc (DEC_BLOCKSIZE);\n\n#if BASE_TYPE == 42\n  ctx.inbuf = nullptr;\n#endif\n  base_decode_ctx_init (&ctx);\n\n  do\n    {\n      bool ok;\n\n      sum = 0;\n      do\n        {\n          idx_t n = fread (inbuf + sum,\n                           1, BASE_LENGTH (DEC_BLOCKSIZE) - sum, in);\n\n          if (ignore_garbage)\n            {\n              for (idx_t i = 0; n > 0 && i < n;)\n                {\n                  if (isbase (inbuf[sum + i]) || inbuf[sum + i] == '=')\n                    i++;\n                  else\n                    memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n                }\n            }\n\n          sum += n;\n\n          if (ferror (in))\n            error (EXIT_FAILURE, errno, _(\"read error\"));\n        }\n      while (sum < BASE_LENGTH (DEC_BLOCKSIZE) && !feof (in));\n\n       \n      for (int k = 0; k < 1 + !!feof (in); k++)\n        {\n          if (k == 1 && ctx.i == 0)\n            break;\n          idx_t n = DEC_BLOCKSIZE;\n          ok = base_decode_ctx (&ctx, inbuf, (k == 0 ? sum : 0), outbuf, &n);\n\n          if (fwrite (outbuf, 1, n, out) < n)\n            write_error ();\n\n          if (!ok)\n            error (EXIT_FAILURE, 0, _(\"invalid input\"));\n        }\n    }\n  while (!feof (in));\n\n  finish_and_exit (in, infile);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int opt;\n  FILE *input_fh;\n  char const *infile;\n\n   \n  bool decode = false;\n   \n  bool ignore_garbage = false;\n   \n  idx_t wrap_column = 76;\n\n#if BASE_TYPE == 42\n  int base_type = 0;\n#endif\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((opt = getopt_long (argc, argv, \"diw:\", long_options, nullptr)) != -1)\n    switch (opt)\n      {\n      case 'd':\n        decode = true;\n        break;\n\n      case 'w':\n        {\n          intmax_t w;\n          strtol_error s_err = xstrtoimax (optarg, nullptr, 10, &w, \"\");\n          if (LONGINT_OVERFLOW < s_err || w < 0)\n            error (EXIT_FAILURE, 0, \"%s: %s\",\n                   _(\"invalid wrap size\"), quote (optarg));\n          wrap_column = s_err == LONGINT_OVERFLOW || IDX_MAX < w ? 0 : w;\n        }\n        break;\n\n      case 'i':\n        ignore_garbage = true;\n        break;\n\n#if BASE_TYPE == 42\n      case BASE64_OPTION:\n      case BASE64URL_OPTION:\n      case BASE32_OPTION:\n      case BASE32HEX_OPTION:\n      case BASE16_OPTION:\n      case BASE2MSBF_OPTION:\n      case BASE2LSBF_OPTION:\n      case Z85_OPTION:\n        base_type = opt;\n        break;\n#endif\n\n      case_GETOPT_HELP_CHAR;\n\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n      default:\n        usage (EXIT_FAILURE);\n        break;\n      }\n\n#if BASE_TYPE == 42\n  switch (base_type)\n    {\n    case BASE64_OPTION:\n      base_length = base64_length_wrapper;\n      isbase = isbase64;\n      base_encode = base64_encode;\n      base_decode_ctx_init = base64_decode_ctx_init_wrapper;\n      base_decode_ctx = base64_decode_ctx_wrapper;\n      break;\n\n    case BASE64URL_OPTION:\n      base_length = base64_length_wrapper;\n      isbase = isbase64url;\n      base_encode = base64url_encode;\n      base_decode_ctx_init = base64url_decode_ctx_init_wrapper;\n      base_decode_ctx = base64url_decode_ctx_wrapper;\n      break;\n\n    case BASE32_OPTION:\n      base_length = base32_length_wrapper;\n      isbase = isbase32;\n      base_encode = base32_encode;\n      base_decode_ctx_init = base32_decode_ctx_init_wrapper;\n      base_decode_ctx = base32_decode_ctx_wrapper;\n      break;\n\n    case BASE32HEX_OPTION:\n      base_length = base32_length_wrapper;\n      isbase = isbase32hex;\n      base_encode = base32hex_encode;\n      base_decode_ctx_init = base32hex_decode_ctx_init_wrapper;\n      base_decode_ctx = base32hex_decode_ctx_wrapper;\n      break;\n\n    case BASE16_OPTION:\n      base_length = base16_length;\n      isbase = isbase16;\n      base_encode = base16_encode;\n      base_decode_ctx_init = base16_decode_ctx_init;\n      base_decode_ctx = base16_decode_ctx;\n      break;\n\n    case BASE2MSBF_OPTION:\n      base_length = base2_length;\n      isbase = isbase2;\n      base_encode = base2msbf_encode;\n      base_decode_ctx_init = base2_decode_ctx_init;\n      base_decode_ctx = base2msbf_decode_ctx;\n      break;\n\n    case BASE2LSBF_OPTION:\n      base_length = base2_length;\n      isbase = isbase2;\n      base_encode = base2lsbf_encode;\n      base_decode_ctx_init = base2_decode_ctx_init;\n      base_decode_ctx = base2lsbf_decode_ctx;\n      break;\n\n    case Z85_OPTION:\n      base_length = z85_length;\n      isbase = isz85;\n      base_encode = z85_encode;\n      base_decode_ctx_init = z85_decode_ctx_init;\n      base_decode_ctx = z85_decode_ctx;\n      break;\n\n    default:\n      error (0, 0, _(\"missing encoding type\"));\n      usage (EXIT_FAILURE);\n    }\n#endif\n\n  if (argc - optind > 1)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (optind < argc)\n    infile = argv[optind];\n  else\n    infile = \"-\";\n\n  if (STREQ (infile, \"-\"))\n    {\n      xset_binary_mode (STDIN_FILENO, O_BINARY);\n      input_fh = stdin;\n    }\n  else\n    {\n      input_fh = fopen (infile, \"rb\");\n      if (input_fh == nullptr)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n    }\n\n  fadvise (input_fh, FADVISE_SEQUENTIAL);\n\n  if (decode)\n    do_decode (input_fh, infile, stdout, ignore_garbage);\n  else\n    do_encode (input_fh, infile, stdout, wrap_column);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}