{
  "module_name": "mktemp.c",
  "hash_id": "9ba5b4ab423027bd26b211dfabdea9596f9d3819bad4b0535bf27f5cf8fcc469",
  "original_prompt": "Ingested from coreutils-9.4/src/mktemp.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <sys/types.h>\n#include <getopt.h>\n\n#include \"system.h\"\n\n#include \"close-stream.h\"\n#include \"filenamecat.h\"\n#include \"quote.h\"\n#include \"tempname.h\"\n\n \n#define PROGRAM_NAME \"mktemp\"\n\n#define AUTHORS \\\n  proper_name (\"Jim Meyering\"), \\\n  proper_name (\"Eric Blake\")\n\nstatic char const *default_template = \"tmp.XXXXXXXXXX\";\n\n \nenum\n{\n  SUFFIX_OPTION = CHAR_MAX + 1,\n};\n\nstatic struct option const longopts[] =\n{\n  {\"directory\", no_argument, nullptr, 'd'},\n  {\"quiet\", no_argument, nullptr, 'q'},\n  {\"dry-run\", no_argument, nullptr, 'u'},\n  {\"suffix\", required_argument, nullptr, SUFFIX_OPTION},\n  {\"tmpdir\", optional_argument, nullptr, 'p'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [TEMPLATE]\\n\"), program_name);\n      fputs (_(\"\\\nCreate a temporary file or directory, safely, and print its name.\\n\\\nTEMPLATE must contain at least 3 consecutive 'X's in last component.\\n\\\nIf TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\\n\\\n\"), stdout);\n      fputs (_(\"\\\nFiles are created u+rw, and directories u+rwx, minus umask restrictions.\\n\\\n\"), stdout);\n      fputs (\"\\n\", stdout);\n      fputs (_(\"\\\n  -d, --directory     create a directory, not a file\\n\\\n  -u, --dry-run       do not create anything; merely print a name (unsafe)\\n\\\n  -q, --quiet         suppress diagnostics about file/dir-creation failure\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a slash.\\n\\\n                        This option is implied if TEMPLATE does not end in X\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\\n\\\n                        specified, use $TMPDIR if set, else /tmp.  With\\n\\\n                        this option, TEMPLATE must not be an absolute name;\\n\\\n                        unlike with -t, TEMPLATE may contain slashes, but\\n\\\n                        mktemp creates only the final component\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t                  interpret TEMPLATE as a single file name component,\\n\\\n                        relative to a directory: $TMPDIR, if set; else the\\n\\\n                        directory specified via -p; else /tmp [deprecated]\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\nstatic size_t\ncount_consecutive_X_s (char const *s, size_t len)\n{\n  size_t n = 0;\n  for ( ; len && s[len - 1] == 'X'; len--)\n    ++n;\n  return n;\n}\n\nstatic int\nmkstemp_len (char *tmpl, size_t suff_len, size_t x_len, bool dry_run)\n{\n  return gen_tempname_len (tmpl, suff_len, 0, dry_run ? GT_NOCREATE : GT_FILE,\n                           x_len);\n}\n\nstatic int\nmkdtemp_len (char *tmpl, size_t suff_len, size_t x_len, bool dry_run)\n{\n  return gen_tempname_len (tmpl, suff_len, 0, dry_run ? GT_NOCREATE : GT_DIR,\n                           x_len);\n}\n\n/* True if we have already closed standard output.  */\nstatic bool stdout_closed;\n\n/* Avoid closing stdout twice.  Since we conditionally call\n   close_stream (stdout) in order to decide whether to clean up a\n   temporary file, the exit hook needs to know whether to do all of\n   close_stdout or just the stderr half.  */\nstatic void\nmaybe_close_stdout (void)\n{\n  if (!stdout_closed)\n    close_stdout ();\n  else if (close_stream (stderr) != 0)\n    _exit (EXIT_FAILURE);\n}\n\nint\nmain (int argc, char **argv)\n{\n  char const *dest_dir;\n  char const *dest_dir_arg = nullptr;\n  bool suppress_file_err = false;\n  int c;\n  char *template;\n  char *suffix = nullptr;\n  bool use_dest_dir = false;\n  bool deprecated_t_option = false;\n  bool create_directory = false;\n  bool dry_run = false;\n  int status = EXIT_SUCCESS;\n  size_t x_count;\n  size_t suffix_len;\n  char *dest_name;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (maybe_close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"dp:qtuV\", longopts, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'd':\n          create_directory = true;\n          break;\n        case 'p':\n          dest_dir_arg = optarg;\n          use_dest_dir = true;\n          break;\n        case 'q':\n          suppress_file_err = true;\n          break;\n        case 't':\n          use_dest_dir = true;\n          deprecated_t_option = true;\n          break;\n        case 'u':\n          dry_run = true;\n          break;\n\n        case SUFFIX_OPTION:\n          suffix = optarg;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case 'V': /* Undocumented alias, for compatibility with the original\n                     mktemp program.  */\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  int n_args = argc - optind;\n  if (2 <= n_args)\n    {\n      error (0, 0, _(\"too many templates\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (n_args == 0)\n    {\n      use_dest_dir = true;\n      template = (char *) default_template;\n    }\n  else\n    {\n      template = argv[optind];\n    }\n\n  if (suffix)\n    {\n      size_t len = strlen (template);\n      if (!len || template[len - 1] != 'X')\n        {\n          error (EXIT_FAILURE, 0,\n                 _(\"with --suffix, template %s must end in X\"),\n                 quote (template));\n        }\n      suffix_len = strlen (suffix);\n      dest_name = xcharalloc (len + suffix_len + 1);\n      memcpy (dest_name, template, len);\n      memcpy (dest_name + len, suffix, suffix_len + 1);\n      template = dest_name;\n      suffix = dest_name + len;\n    }\n  else\n    {\n      template = xstrdup (template);\n      suffix = strrchr (template, 'X');\n      if (!suffix)\n        suffix = strchr (template, '\\0');\n      else\n        suffix++;\n      suffix_len = strlen (suffix);\n    }\n\n  /* At this point, template is malloc'd, and suffix points into template.  */\n  if (suffix_len && last_component (suffix) != suffix)\n    {\n      error (EXIT_FAILURE, 0,\n             _(\"invalid suffix %s, contains directory separator\"),\n             quote (suffix));\n    }\n  x_count = count_consecutive_X_s (template, suffix - template);\n  if (x_count < 3)\n    error (EXIT_FAILURE, 0, _(\"too few X's in template %s\"), quote (template));\n\n  if (use_dest_dir)\n    {\n      if (deprecated_t_option)\n        {\n          char *env = getenv (\"TMPDIR\");\n          if (env && *env)\n            dest_dir = env;\n          else if (dest_dir_arg && *dest_dir_arg)\n            dest_dir = dest_dir_arg;\n          else\n            dest_dir = \"/tmp\";\n\n          if (last_component (template) != template)\n            error (EXIT_FAILURE, 0,\n                   _(\"invalid template, %s, contains directory separator\"),\n                   quote (template));\n        }\n      else\n        {\n          if (dest_dir_arg && *dest_dir_arg)\n            dest_dir = dest_dir_arg;\n          else\n            {\n              char *env = getenv (\"TMPDIR\");\n              dest_dir = (env && *env ? env : \"/tmp\");\n            }\n          if (IS_ABSOLUTE_FILE_NAME (template))\n            error (EXIT_FAILURE, 0,\n                   _(\"invalid template, %s; with --tmpdir,\"\n                     \" it may not be absolute\"),\n                   quote (template));\n        }\n\n      dest_name = file_name_concat (dest_dir, template, nullptr);\n      free (template);\n      template = dest_name;\n      /* Note that suffix is now invalid.  */\n    }\n\n  /* Make a copy to be used in case of diagnostic, since failing\n     mkstemp may leave the buffer in an undefined state.  */\n  dest_name = xstrdup (template);\n\n  if (create_directory)\n    {\n      int err = mkdtemp_len (dest_name, suffix_len, x_count, dry_run);\n      if (err != 0)\n        {\n          if (!suppress_file_err)\n            error (0, errno, _(\"failed to create directory via template %s\"),\n                   quote (template));\n          status = EXIT_FAILURE;\n        }\n    }\n  else\n    {\n      int fd = mkstemp_len (dest_name, suffix_len, x_count, dry_run);\n      if (fd < 0 || (!dry_run && close (fd) != 0))\n        {\n          if (!suppress_file_err)\n            error (0, errno, _(\"failed to create file via template %s\"),\n                   quote (template));\n          status = EXIT_FAILURE;\n        }\n    }\n\n  if (status == EXIT_SUCCESS)\n    {\n      puts (dest_name);\n      /* If we created a file, but then failed to output the file\n         name, we should clean up the mess before failing.  */\n      if (!dry_run && ((stdout_closed = true), close_stream (stdout) != 0))\n        {\n          int saved_errno = errno;\n          remove (dest_name);\n          if (!suppress_file_err)\n            error (0, saved_errno, _(\"write error\"));\n          status = EXIT_FAILURE;\n        }\n    }\n\n  main_exit (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}