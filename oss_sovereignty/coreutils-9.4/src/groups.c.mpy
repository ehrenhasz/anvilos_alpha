{
  "module_name": "groups.c",
  "hash_id": "1a44e8e51aae848a72fafed696cb41ea4e29db6f890e08ae090fa6edffbc69da",
  "original_prompt": "Ingested from coreutils-9.4/src/groups.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include <getopt.h>\n\n#include \"system.h\"\n#include \"group-list.h\"\n#include \"quote.h\"\n\n \n#define PROGRAM_NAME \"groups\"\n\n#define AUTHORS \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"James Youngman\")\n\n\nstatic struct option const longopts[] =\n{\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [USERNAME]...\\n\"), program_name);\n      fputs (_(\"\\\nPrint group memberships for each USERNAME or, if no USERNAME is specified, for\\\n\\n\\\nthe current process (which may differ if the groups database has changed).\\n\"),\n             stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  bool ok = true;\n  gid_t rgid, egid;\n  uid_t ruid;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  /* Processing the arguments this way makes groups.c behave differently to\n   * groups.sh if one of the arguments is \"--\".\n   */\n  while ((optc = getopt_long (argc, argv, \"\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind == argc)\n    {\n      /* No arguments.  Divulge the details of the current process. */\n      uid_t NO_UID = -1;\n      gid_t NO_GID = -1;\n\n      errno = 0;\n      ruid = getuid ();\n      if (ruid == NO_UID && errno)\n        error (EXIT_FAILURE, errno, _(\"cannot get real UID\"));\n\n      errno = 0;\n      egid = getegid ();\n      if (egid == NO_GID && errno)\n        error (EXIT_FAILURE, errno, _(\"cannot get effective GID\"));\n\n      errno = 0;\n      rgid = getgid ();\n      if (rgid == NO_GID && errno)\n        error (EXIT_FAILURE, errno, _(\"cannot get real GID\"));\n\n      if (!print_group_list (nullptr, ruid, rgid, egid, true, ' '))\n        ok = false;\n      putchar ('\\n');\n    }\n  else\n    {\n      /* At least one argument.  Divulge the details of the specified users.  */\n      for ( ; optind < argc; optind++)\n        {\n          struct passwd *pwd = getpwnam (argv[optind]);\n          if (pwd == nullptr)\n            {\n              error (0, 0, _(\"%s: no such user\"), quote (argv[optind]));\n              ok = false;\n              continue;\n            }\n          ruid = pwd->pw_uid;\n          rgid = egid = pwd->pw_gid;\n\n          printf (\"%s : \", argv[optind]);\n          if (!print_group_list (argv[optind], ruid, rgid, egid, true, ' '))\n            ok = false;\n          putchar ('\\n');\n        }\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}