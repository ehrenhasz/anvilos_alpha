{
  "module_name": "nl.c",
  "hash_id": "7fb68b7ac6c2838e66bb4f78c4adddfc28ede42a1afb00e9ce0973808d03fa65",
  "original_prompt": "Ingested from coreutils-9.4/src/nl.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdckdint.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n\n#include \"system.h\"\n\n#include <regex.h>\n\n#include \"fadvise.h\"\n#include \"linebuffer.h\"\n#include \"quote.h\"\n#include \"xdectoint.h\"\n\n \n#define PROGRAM_NAME \"nl\"\n\n#define AUTHORS \\\n  proper_name (\"Scott Bartram\"), \\\n  proper_name (\"David MacKenzie\")\n\n \n\n \nstatic char const FORMAT_RIGHT_NOLZ[] = \"%*\" PRIdMAX \"%s\";\n\n \nstatic char const FORMAT_RIGHT_LZ[] = \"%0*\" PRIdMAX \"%s\";\n\n \nstatic char const FORMAT_LEFT[] = \"%-*\" PRIdMAX \"%s\";\n\n \nstatic char DEFAULT_SECTION_DELIMITERS[] = \"\\\\:\";\n\n \nenum section\n{\n  Header, Body, Footer, Text\n};\n\n \nstatic char const *body_type = \"t\";\n\n \nstatic char const *header_type = \"n\";\n\n \nstatic char const *footer_type = \"n\";\n\n \nstatic char const *current_type;\n\n \nstatic struct re_pattern_buffer body_regex;\n\n \nstatic struct re_pattern_buffer header_regex;\n\n \nstatic struct re_pattern_buffer footer_regex;\n\n \nstatic char body_fastmap[UCHAR_MAX + 1];\nstatic char header_fastmap[UCHAR_MAX + 1];\nstatic char footer_fastmap[UCHAR_MAX + 1];\n\n \nstatic struct re_pattern_buffer *current_regex = nullptr;\n\n \nstatic char const *separator_str = \"\\t\";\n\n \nstatic char *section_del = DEFAULT_SECTION_DELIMITERS;\n\n \nstatic char *header_del = nullptr;\n\n \nstatic size_t header_del_len;\n\n \nstatic char *body_del = nullptr;\n\n \nstatic size_t body_del_len;\n\n \nstatic char *footer_del = nullptr;\n\n \nstatic size_t footer_del_len;\n\n \nstatic struct linebuffer line_buf;\n\n \nstatic char *print_no_line_fmt = nullptr;\n\n \nstatic intmax_t starting_line_number = 1;\n\n \nstatic intmax_t page_incr = 1;\n\n \nstatic bool reset_numbers = true;\n\n \nstatic intmax_t blank_join = 1;\n\n \nstatic int lineno_width = 6;\n\n \nstatic char const *lineno_format = FORMAT_RIGHT_NOLZ;\n\n \nstatic intmax_t line_no;\n\n \nstatic bool line_no_overflow;\n\n \nstatic bool have_read_stdin;\n\nstatic struct option const longopts[] =\n{\n  {\"header-numbering\", required_argument, nullptr, 'h'},\n  {\"body-numbering\", required_argument, nullptr, 'b'},\n  {\"footer-numbering\", required_argument, nullptr, 'f'},\n  {\"starting-line-number\", required_argument, nullptr, 'v'},\n  {\"line-increment\", required_argument, nullptr, 'i'},\n  {\"no-renumber\", no_argument, nullptr, 'p'},\n  {\"join-blank-lines\", required_argument, nullptr, 'l'},\n  {\"number-separator\", required_argument, nullptr, 's'},\n  {\"number-width\", required_argument, nullptr, 'w'},\n  {\"number-format\", required_argument, nullptr, 'n'},\n  {\"section-delimiter\", required_argument, nullptr, 'd'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nWrite each FILE to standard output, with line numbers added.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -b, --body-numbering=STYLE      use STYLE for numbering body lines\\n\\\n  -d, --section-delimiter=CC      use CC for logical page delimiters\\n\\\n  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -h, --header-numbering=STYLE    use STYLE for numbering header lines\\n\\\n  -i, --line-increment=NUMBER     line number increment at each line\\n\\\n  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one\\n\\\n  -n, --number-format=FORMAT      insert line numbers according to FORMAT\\n\\\n  -p, --no-renumber               do not reset line numbers for each section\\n\\\n  -s, --number-separator=STRING   add STRING after (possible) line number\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --starting-line-number=NUMBER  first line number for each section\\n\\\n  -w, --number-width=NUMBER       use NUMBER columns for line numbers\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nDefault options are: -bt -d'\\\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\\n\\\n\\n\\\nCC are two delimiter characters used to construct logical page delimiters;\\n\\\na missing second character implies ':'.  As a GNU extension one can specify\\n\\\nmore than two characters, and also specifying the empty string (-d '')\\n\\\ndisables section matching.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nSTYLE is one of:\\n\\\n\\n\\\n  a      number all lines\\n\\\n  t      number only nonempty lines\\n\\\n  n      number no lines\\n\\\n  pBRE   number only lines that contain a match for the basic regular\\n\\\n         expression, BRE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nFORMAT is one of:\\n\\\n\\n\\\n  ln     left justified, no leading zeros\\n\\\n  rn     right justified, no leading zeros\\n\\\n  rz     right justified, leading zeros\\n\\\n\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Set the command line flag TYPEP and possibly the regex pointer REGEXP,\n   according to 'optarg'.  */\n\nstatic bool\nbuild_type_arg (char const **typep,\n                struct re_pattern_buffer *regexp, char *fastmap)\n{\n  char const *errmsg;\n  bool rval = true;\n\n  switch (*optarg)\n    {\n    case 'a':\n    case 't':\n    case 'n':\n      *typep = optarg;\n      break;\n    case 'p':\n      *typep = optarg++;\n      regexp->buffer = nullptr;\n      regexp->allocated = 0;\n      regexp->fastmap = fastmap;\n      regexp->translate = nullptr;\n      re_syntax_options =\n        RE_SYNTAX_POSIX_BASIC & ~RE_CONTEXT_INVALID_DUP & ~RE_NO_EMPTY_RANGES;\n      errmsg = re_compile_pattern (optarg, strlen (optarg), regexp);\n      if (errmsg)\n        error (EXIT_FAILURE, 0, \"%s\", (errmsg));\n      break;\n    default:\n      rval = false;\n      break;\n    }\n  return rval;\n}\n\n/* Print the line number and separator; increment the line number. */\n\nstatic void\nprint_lineno (void)\n{\n  if (line_no_overflow)\n    error (EXIT_FAILURE, 0, _(\"line number overflow\"));\n\n  printf (lineno_format, lineno_width, line_no, separator_str);\n\n  if (ckd_add (&line_no, line_no, page_incr))\n    line_no_overflow = true;\n}\n\nstatic void\nreset_lineno (void)\n{\n  if (reset_numbers)\n    {\n      line_no = starting_line_number;\n      line_no_overflow = false;\n    }\n}\n\n/* Switch to a header section. */\n\nstatic void\nproc_header (void)\n{\n  current_type = header_type;\n  current_regex = &header_regex;\n  reset_lineno ();\n  putchar ('\\n');\n}\n\n/* Switch to a body section. */\n\nstatic void\nproc_body (void)\n{\n  current_type = body_type;\n  current_regex = &body_regex;\n  reset_lineno ();\n  putchar ('\\n');\n}\n\n/* Switch to a footer section. */\n\nstatic void\nproc_footer (void)\n{\n  current_type = footer_type;\n  current_regex = &footer_regex;\n  reset_lineno ();\n  putchar ('\\n');\n}\n\n/* Process a regular text line in 'line_buf'. */\n\nstatic void\nproc_text (void)\n{\n  static intmax_t blank_lines = 0;\t/* Consecutive blank lines so far. */\n\n  switch (*current_type)\n    {\n    case 'a':\n      if (blank_join > 1)\n        {\n          if (1 < line_buf.length || ++blank_lines == blank_join)\n            {\n              print_lineno ();\n              blank_lines = 0;\n            }\n          else\n            fputs (print_no_line_fmt, stdout);\n        }\n      else\n        print_lineno ();\n      break;\n    case 't':\n      if (1 < line_buf.length)\n        print_lineno ();\n      else\n        fputs (print_no_line_fmt, stdout);\n      break;\n    case 'n':\n      fputs (print_no_line_fmt, stdout);\n      break;\n    case 'p':\n      switch (re_search (current_regex, line_buf.buffer, line_buf.length - 1,\n                         0, line_buf.length - 1, nullptr))\n        {\n        case -2:\n          error (EXIT_FAILURE, errno, _(\"error in regular expression search\"));\n\n        case -1:\n          fputs (print_no_line_fmt, stdout);\n          break;\n\n        default:\n          print_lineno ();\n          break;\n        }\n    }\n  fwrite (line_buf.buffer, sizeof (char), line_buf.length, stdout);\n}\n\n/* Return the type of line in 'line_buf'. */\n\nstatic enum section\ncheck_section (void)\n{\n  size_t len = line_buf.length - 1;\n\n  if (len < 2 || footer_del_len < 2\n      || memcmp (line_buf.buffer, section_del, 2))\n    return Text;\n  if (len == header_del_len\n      && !memcmp (line_buf.buffer, header_del, header_del_len))\n    return Header;\n  if (len == body_del_len\n      && !memcmp (line_buf.buffer, body_del, body_del_len))\n    return Body;\n  if (len == footer_del_len\n      && !memcmp (line_buf.buffer, footer_del, footer_del_len))\n    return Footer;\n  return Text;\n}\n\n/* Read and process the file pointed to by FP. */\n\nstatic void\nprocess_file (FILE *fp)\n{\n  while (readlinebuffer (&line_buf, fp))\n    {\n      switch (check_section ())\n        {\n        case Header:\n          proc_header ();\n          break;\n        case Body:\n          proc_body ();\n          break;\n        case Footer:\n          proc_footer ();\n          break;\n        case Text:\n          proc_text ();\n          break;\n        }\n    }\n}\n\n/* Process file FILE to standard output.\n   Return true if successful.  */\n\nstatic bool\nnl_file (char const *file)\n{\n  FILE *stream;\n\n  if (STREQ (file, \"-\"))\n    {\n      have_read_stdin = true;\n      stream = stdin;\n      assume (stream);  /* Pacify GCC bug#109613.  */\n    }\n  else\n    {\n      stream = fopen (file, \"r\");\n      if (stream == nullptr)\n        {\n          error (0, errno, \"%s\", quotef (file));\n          return false;\n        }\n    }\n\n  fadvise (stream, FADVISE_SEQUENTIAL);\n\n  process_file (stream);\n\n  int err = errno;\n  if (!ferror (stream))\n    err = 0;\n  if (STREQ (file, \"-\"))\n    clearerr (stream);\t\t/* Also clear EOF. */\n  else if (fclose (stream) != 0 && !err)\n    err = errno;\n  if (err)\n    {\n      error (0, err, \"%s\", quotef (file));\n      return false;\n    }\n  return true;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n  size_t len;\n  bool ok = true;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  have_read_stdin = false;\n\n  while ((c = getopt_long (argc, argv, \"h:b:f:v:i:pl:s:w:n:d:\", longopts,\n                           nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'h':\n          if (! build_type_arg (&header_type, &header_regex, header_fastmap))\n            {\n              error (0, 0, _(\"invalid header numbering style: %s\"),\n                     quote (optarg));\n              ok = false;\n            }\n          break;\n        case 'b':\n          if (! build_type_arg (&body_type, &body_regex, body_fastmap))\n            {\n              error (0, 0, _(\"invalid body numbering style: %s\"),\n                     quote (optarg));\n              ok = false;\n            }\n          break;\n        case 'f':\n          if (! build_type_arg (&footer_type, &footer_regex, footer_fastmap))\n            {\n              error (0, 0, _(\"invalid footer numbering style: %s\"),\n                     quote (optarg));\n              ok = false;\n            }\n          break;\n        case 'v':\n          starting_line_number = xdectoimax (optarg, INTMAX_MIN, INTMAX_MAX, \"\",\n                                             _(\"invalid starting line number\"),\n                                             0);\n          break;\n        case 'i':\n          page_incr = xdectoimax (optarg, INTMAX_MIN, INTMAX_MAX, \"\",\n                                  _(\"invalid line number increment\"), 0);\n          break;\n        case 'p':\n          reset_numbers = false;\n          break;\n        case 'l':\n          blank_join = xdectoimax (optarg, 1, INTMAX_MAX, \"\",\n                                   _(\"invalid line number of blank lines\"), 0);\n          break;\n        case 's':\n          separator_str = optarg;\n          break;\n        case 'w':\n          lineno_width = xdectoimax (optarg, 1, INT_MAX, \"\",\n                                     _(\"invalid line number field width\"), 0);\n          break;\n        case 'n':\n          if (STREQ (optarg, \"ln\"))\n            lineno_format = FORMAT_LEFT;\n          else if (STREQ (optarg, \"rn\"))\n            lineno_format = FORMAT_RIGHT_NOLZ;\n          else if (STREQ (optarg, \"rz\"))\n            lineno_format = FORMAT_RIGHT_LZ;\n          else\n            {\n              error (0, 0, _(\"invalid line numbering format: %s\"),\n                     quote (optarg));\n              ok = false;\n            }\n          break;\n        case 'd':\n          len = strlen (optarg);\n          if (len == 1 || len == 2)  /* POSIX.  */\n            {\n              char *p = section_del;\n              while (*optarg)\n                *p++ = *optarg++;\n            }\n          else\n            section_del = optarg;  /* GNU extension.  */\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          ok = false;\n          break;\n        }\n    }\n\n  if (!ok)\n    usage (EXIT_FAILURE);\n\n  /* Initialize the section delimiters.  */\n  len = strlen (section_del);\n\n  header_del_len = len * 3;\n  header_del = xmalloc (header_del_len + 1);\n  stpcpy (stpcpy (stpcpy (header_del, section_del), section_del), section_del);\n\n  body_del_len = len * 2;\n  body_del = header_del + len;\n\n  footer_del_len = len;\n  footer_del = body_del + len;\n\n  /* Initialize the input buffer.  */\n  initbuffer (&line_buf);\n\n  /* Initialize the printf format for unnumbered lines. */\n  len = strlen (separator_str);\n  print_no_line_fmt = xmalloc (lineno_width + len + 1);\n  memset (print_no_line_fmt, ' ', lineno_width + len);\n  print_no_line_fmt[lineno_width + len] = '\\0';\n\n  line_no = starting_line_number;\n  current_type = body_type;\n  current_regex = &body_regex;\n\n  /* Main processing. */\n\n  if (optind == argc)\n    ok = nl_file (\"-\");\n  else\n    for (; optind < argc; optind++)\n      ok &= nl_file (argv[optind]);\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    error (EXIT_FAILURE, errno, \"-\");\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}