{
  "module_name": "rm.c",
  "hash_id": "d284d279b473faa1f6cdbc669cc9b9d816b72cf3c9e3f62e37e2fe4b065bb7e6",
  "original_prompt": "Ingested from coreutils-9.4/src/rm.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"remove.h\"\n#include \"root-dev-ino.h\"\n#include \"yesno.h\"\n#include \"priv-set.h\"\n\n \n#define PROGRAM_NAME \"rm\"\n\n#define AUTHORS \\\n  proper_name (\"Paul Rubin\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Richard M. Stallman\"), \\\n  proper_name (\"Jim Meyering\")\n\n \nenum\n{\n  INTERACTIVE_OPTION = CHAR_MAX + 1,\n  ONE_FILE_SYSTEM,\n  NO_PRESERVE_ROOT,\n  PRESERVE_ROOT,\n  PRESUME_INPUT_TTY_OPTION\n};\n\nenum interactive_type\n  {\n    interactive_never,\t\t \n    interactive_once,\t\t \n    interactive_always\t\t \n  };\n\nstatic struct option const long_opts[] =\n{\n  {\"force\", no_argument, nullptr, 'f'},\n  {\"interactive\", optional_argument, nullptr, INTERACTIVE_OPTION},\n\n  {\"one-file-system\", no_argument, nullptr, ONE_FILE_SYSTEM},\n  {\"no-preserve-root\", no_argument, nullptr, NO_PRESERVE_ROOT},\n  {\"preserve-root\", optional_argument, nullptr, PRESERVE_ROOT},\n\n   \n   \n  {\"-presume-input-tty\", no_argument, nullptr, PRESUME_INPUT_TTY_OPTION},\n\n  {\"recursive\", no_argument, nullptr, 'r'},\n  {\"dir\", no_argument, nullptr, 'd'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nstatic char const *const interactive_args[] =\n{\n  \"never\", \"no\", \"none\",\n  \"once\",\n  \"always\", \"yes\", nullptr\n};\nstatic enum interactive_type const interactive_types[] =\n{\n  interactive_never, interactive_never, interactive_never,\n  interactive_once,\n  interactive_always, interactive_always\n};\nARGMATCH_VERIFY (interactive_args, interactive_types);\n\n \n\nstatic void\ndiagnose_leading_hyphen (int argc, char **argv)\n{\n   \n\n  for (int i = 1; i < argc; i++)\n    {\n      char const *arg = argv[i];\n      struct stat st;\n\n      if (arg[0] == '-' && arg[1] && lstat (arg, &st) == 0)\n        {\n          fprintf (stderr,\n                   _(\"Try '%s ./%s' to remove the file %s.\\n\"),\n                   argv[0],\n                   quotearg_n_style (1, shell_escape_quoting_style, arg),\n                   quoteaf (arg));\n          break;\n        }\n    }\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [FILE]...\\n\"), program_name);\n      fputs (_(\"\\\nRemove (unlink) the FILE(s).\\n\\\n\\n\\\n  -f, --force           ignore nonexistent files and arguments, never prompt\\n\\\n  -i                    prompt before every removal\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -I                    prompt once before removing more than three files, or\\n\\\n                          when removing recursively; less intrusive than -i,\\n\\\n                          while still giving protection against most mistakes\\n\\\n      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\\n\\\n                          always (-i); without WHEN, prompt always\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --one-file-system  when removing a hierarchy recursively, skip any\\n\\\n                          directory that is on a file system different from\\n\\\n                          that of the corresponding command line argument\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --no-preserve-root  do not treat '/' specially\\n\\\n      --preserve-root[=all]  do not remove '/' (default);\\n\\\n                              with 'all', reject any command line argument\\n\\\n                              on a separate device from its parent\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -r, -R, --recursive   remove directories and their contents recursively\\n\\\n  -d, --dir             remove empty directories\\n\\\n  -v, --verbose         explain what is being done\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nBy default, rm does not remove directories.  Use the --recursive (-r or -R)\\n\\\noption to remove each listed directory, too, along with all of its contents.\\n\\\n\"), stdout);\n      printf (_(\"\\\n\\n\\\nTo remove a file whose name starts with a '-', for example '-foo',\\n\\\nuse one of these commands:\\n\\\n  %s -- -foo\\n\\\n\\n\\\n  %s ./-foo\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\n\\n\\\nNote that if you use rm to remove a file, it might be possible to recover\\n\\\nsome of its contents, given sufficient expertise and/or time.  For greater\\n\\\nassurance that the contents are truly unrecoverable, consider using shred(1).\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic void\nrm_option_init (struct rm_options *x)\n{\n  x->ignore_missing_files = false;\n  x->interactive = RMI_SOMETIMES;\n  x->one_file_system = false;\n  x->remove_empty_directories = false;\n  x->recursive = false;\n  x->root_dev_ino = nullptr;\n  x->preserve_all_root = false;\n  x->stdin_tty = isatty (STDIN_FILENO);\n  x->verbose = false;\n\n  /* Since this program exits immediately after calling 'rm', rm need not\n     expend unnecessary effort to preserve the initial working directory.  */\n  x->require_restore_cwd = false;\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool preserve_root = true;\n  struct rm_options x;\n  bool prompt_once = false;\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdin);\n\n  rm_option_init (&x);\n\n  /* Try to disable the ability to unlink a directory.  */\n  priv_set_remove_linkdir ();\n\n  while ((c = getopt_long (argc, argv, \"dfirvIR\", long_opts, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'd':\n          x.remove_empty_directories = true;\n          break;\n\n        case 'f':\n          x.interactive = RMI_NEVER;\n          x.ignore_missing_files = true;\n          prompt_once = false;\n          break;\n\n        case 'i':\n          x.interactive = RMI_ALWAYS;\n          x.ignore_missing_files = false;\n          prompt_once = false;\n          break;\n\n        case 'I':\n          x.interactive = RMI_SOMETIMES;\n          x.ignore_missing_files = false;\n          prompt_once = true;\n          break;\n\n        case 'r':\n        case 'R':\n          x.recursive = true;\n          break;\n\n        case INTERACTIVE_OPTION:\n          {\n            int i;\n            if (optarg)\n              i = XARGMATCH (\"--interactive\", optarg, interactive_args,\n                             interactive_types);\n            else\n              i = interactive_always;\n            switch (i)\n              {\n              case interactive_never:\n                x.interactive = RMI_NEVER;\n                prompt_once = false;\n                break;\n\n              case interactive_once:\n                x.interactive = RMI_SOMETIMES;\n                x.ignore_missing_files = false;\n                prompt_once = true;\n                break;\n\n              case interactive_always:\n                x.interactive = RMI_ALWAYS;\n                x.ignore_missing_files = false;\n                prompt_once = false;\n                break;\n              }\n            break;\n          }\n\n        case ONE_FILE_SYSTEM:\n          x.one_file_system = true;\n          break;\n\n        case NO_PRESERVE_ROOT:\n          if (! STREQ (argv[optind - 1], \"--no-preserve-root\"))\n            error (EXIT_FAILURE, 0,\n                   _(\"you may not abbreviate the --no-preserve-root option\"));\n          preserve_root = false;\n          break;\n\n        case PRESERVE_ROOT:\n          if (optarg)\n            {\n              if STREQ (optarg, \"all\")\n                x.preserve_all_root = true;\n              else\n                error (EXIT_FAILURE, 0,\n                       _(\"unrecognized --preserve-root argument: %s\"),\n                       quoteaf (optarg));\n            }\n          preserve_root = true;\n          break;\n\n        case PRESUME_INPUT_TTY_OPTION:\n          x.stdin_tty = true;\n          break;\n\n        case 'v':\n          x.verbose = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          diagnose_leading_hyphen (argc, argv);\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (argc <= optind)\n    {\n      if (x.ignore_missing_files)\n        return EXIT_SUCCESS;\n      else\n        {\n          error (0, 0, _(\"missing operand\"));\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (x.recursive && preserve_root)\n    {\n      static struct dev_ino dev_ino_buf;\n      x.root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n      if (x.root_dev_ino == nullptr)\n        error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n               quoteaf (\"/\"));\n    }\n\n  uintmax_t n_files = argc - optind;\n  char **file =  argv + optind;\n\n  if (prompt_once && (x.recursive || 3 < n_files))\n    {\n      fprintf (stderr,\n               (x.recursive\n                ? ngettext (\"%s: remove %\"PRIuMAX\" argument recursively? \",\n                            \"%s: remove %\"PRIuMAX\" arguments recursively? \",\n                            select_plural (n_files))\n                : ngettext (\"%s: remove %\"PRIuMAX\" argument? \",\n                            \"%s: remove %\"PRIuMAX\" arguments? \",\n                            select_plural (n_files))),\n               program_name, n_files);\n      if (!yesno ())\n        return EXIT_SUCCESS;\n    }\n\n  enum RM_status status = rm (file, &x);\n  affirm (VALID_STATUS (status));\n  return status == RM_ERROR ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}