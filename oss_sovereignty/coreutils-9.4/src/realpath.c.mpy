{
  "module_name": "realpath.c",
  "hash_id": "60d9587f8802d53b37a69ae83e744e6ad65f1a2071213c96e19bfc87412ea56a",
  "original_prompt": "Ingested from coreutils-9.4/src/realpath.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"canonicalize.h\"\n#include \"relpath.h\"\n\n \n#define PROGRAM_NAME \"realpath\"\n\n#define AUTHORS proper_name_lite (\"Padraig Brady\", \"P\\303\\241draig Brady\")\n\nenum\n{\n  RELATIVE_TO_OPTION = CHAR_MAX + 1,\n  RELATIVE_BASE_OPTION\n};\n\nstatic bool verbose = true;\nstatic bool logical;\nstatic bool use_nuls;\nstatic char const *can_relative_to;\nstatic char const *can_relative_base;\n\nstatic struct option const longopts[] =\n{\n  {\"canonicalize-existing\", no_argument, nullptr, 'e'},\n  {\"canonicalize-missing\", no_argument, nullptr, 'm'},\n  {\"relative-to\", required_argument, nullptr, RELATIVE_TO_OPTION},\n  {\"relative-base\", required_argument, nullptr, RELATIVE_BASE_OPTION},\n  {\"quiet\", no_argument, nullptr, 'q'},\n  {\"strip\", no_argument, nullptr, 's'},\n  {\"no-symlinks\", no_argument, nullptr, 's'},\n  {\"zero\", no_argument, nullptr, 'z'},\n  {\"logical\", no_argument, nullptr, 'L'},\n  {\"physical\", no_argument, nullptr, 'P'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... FILE...\\n\"), program_name);\n      fputs (_(\"\\\nPrint the resolved absolute file name;\\n\\\nall but the last component must exist\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -e, --canonicalize-existing  all components of the path must exist\\n\\\n  -m, --canonicalize-missing   no path components need exist or be a directory\\\n\\n\\\n  -L, --logical                resolve '..' components before symlinks\\n\\\n  -P, --physical               resolve symlinks as encountered (default)\\n\\\n  -q, --quiet                  suppress most error messages\\n\\\n      --relative-to=DIR        print the resolved path relative to DIR\\n\\\n      --relative-base=DIR      print absolute paths unless paths below DIR\\n\\\n  -s, --strip, --no-symlinks   don't expand symlinks\\n\\\n  -z, --zero                   end each output line with NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* A wrapper around canonicalize_filename_mode(),\n   to call it twice when in LOGICAL mode.  */\nstatic char *\nrealpath_canon (char const *fname, int can_mode)\n{\n  char *can_fname = canonicalize_filename_mode (fname, can_mode);\n  if (logical && can_fname)  /* canonicalize again to resolve symlinks.  */\n    {\n      can_mode &= ~CAN_NOLINKS;\n      char *can_fname2 = canonicalize_filename_mode (can_fname, can_mode);\n      free (can_fname);\n      return can_fname2;\n    }\n  return can_fname;\n}\n\n/* Test whether canonical prefix is parent or match of path.  */\nATTRIBUTE_PURE\nstatic bool\npath_prefix (char const *prefix, char const *path)\n{\n  /* We already know prefix[0] and path[0] are '/'.  */\n  prefix++;\n  path++;\n\n  /* '/' is the prefix of everything except '//' (since we know '//'\n     is only present after canonicalization if it is distinct).  */\n  if (!*prefix)\n    return *path != '/';\n\n  /* Likewise, '//' is a prefix of any double-slash path.  */\n  if (*prefix == '/' && !prefix[1])\n    return *path == '/';\n\n  /* Any other prefix has a non-slash portion.  */\n  while (*prefix && *path)\n    {\n      if (*prefix != *path)\n        break;\n      prefix++;\n      path++;\n    }\n  return (!*prefix && (*path == '/' || !*path));\n}\n\nstatic bool\nisdir (char const *path)\n{\n  struct stat sb;\n  if (stat (path, &sb) != 0)\n    error (EXIT_FAILURE, errno, _(\"cannot stat %s\"), quoteaf (path));\n  return S_ISDIR (sb.st_mode);\n}\n\nstatic bool\nprocess_path (char const *fname, int can_mode)\n{\n  char *can_fname = realpath_canon (fname, can_mode);\n  if (!can_fname)\n    {\n      if (verbose)\n        error (0, errno, \"%s\", quotef (fname));\n      return false;\n    }\n\n  if (!can_relative_to\n      || (can_relative_base && !path_prefix (can_relative_base, can_fname))\n      || (can_relative_to && !relpath (can_fname, can_relative_to, nullptr, 0)))\n    fputs (can_fname, stdout);\n\n  putchar (use_nuls ? '\\0' : '\\n');\n\n  free (can_fname);\n\n  return true;\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool ok = true;\n  int can_mode = CAN_ALL_BUT_LAST;\n  char const *relative_to = nullptr;\n  char const *relative_base = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while (true)\n    {\n      int c = getopt_long (argc, argv, \"eLmPqsz\", longopts, nullptr);\n      if (c == -1)\n        break;\n      switch (c)\n        {\n        case 'e':\n          can_mode &= ~CAN_MODE_MASK;\n          can_mode |= CAN_EXISTING;\n          break;\n        case 'm':\n          can_mode &= ~CAN_MODE_MASK;\n          can_mode |= CAN_MISSING;\n          break;\n        case 'L':\n          can_mode |= CAN_NOLINKS;\n          logical = true;\n          break;\n        case 's':\n          can_mode |= CAN_NOLINKS;\n          logical = false;\n          break;\n        case 'P':\n          can_mode &= ~CAN_NOLINKS;\n          logical = false;\n          break;\n        case 'q':\n          verbose = false;\n          break;\n        case 'z':\n          use_nuls = true;\n          break;\n        case RELATIVE_TO_OPTION:\n          relative_to = optarg;\n          break;\n        case RELATIVE_BASE_OPTION:\n          relative_base = optarg;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind >= argc)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (relative_base && !relative_to)\n    relative_to = relative_base;\n\n  bool need_dir = (can_mode & CAN_MODE_MASK) == CAN_EXISTING;\n  if (relative_to)\n    {\n      can_relative_to = realpath_canon (relative_to, can_mode);\n      if (!can_relative_to)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (relative_to));\n      if (need_dir && !isdir (can_relative_to))\n        error (EXIT_FAILURE, ENOTDIR, \"%s\", quotef (relative_to));\n    }\n  if (relative_base == relative_to)\n    can_relative_base = can_relative_to;\n  else if (relative_base)\n    {\n      char *base = realpath_canon (relative_base, can_mode);\n      if (!base)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (relative_base));\n      if (need_dir && !isdir (base))\n        error (EXIT_FAILURE, ENOTDIR, \"%s\", quotef (relative_base));\n       \n      if (path_prefix (base, can_relative_to))\n        can_relative_base = base;\n      else\n        {\n          free (base);\n          can_relative_base = can_relative_to;\n          can_relative_to = nullptr;\n        }\n    }\n\n  for (; optind < argc; ++optind)\n    ok &= process_path (argv[optind], can_mode);\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}