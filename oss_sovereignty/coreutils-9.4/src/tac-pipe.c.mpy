{
  "module_name": "tac-pipe.c",
  "hash_id": "bc1b9598430cc14c9c18a4b47e09973f9618aafe3bc5ba4e47d4d7832e5d5c6b",
  "original_prompt": "Ingested from coreutils-9.4/src/tac-pipe.c",
  "human_readable_source": " \n#include \"assure.h\"\n\n \n#define BUFFER_SIZE (8)\n\n#define LEN(X, I) ((X)->p[(I)].one_past_end - (X)->p[(I)].start)\n#define EMPTY(X) ((X)->n_bufs == 1 && LEN (X, 0) == 0)\n\n#define ONE_PAST_END(X, I) ((X)->p[(I)].one_past_end)\n\nstruct Line_ptr\n{\n  size_t i;\n  char *ptr;\n};\ntypedef struct Line_ptr Line_ptr;\n\nstruct B_pair\n{\n  char *start;\n  char *one_past_end;\n};\n\nstruct Buf\n{\n  size_t n_bufs;\n  struct obstack obs;\n  struct B_pair *p;\n};\ntypedef struct Buf Buf;\n\nstatic bool\nbuf_init_from_stdin (Buf *x, char eol_byte)\n{\n  bool last_byte_is_eol_byte = true;\n  bool ok = true;\n\n#define OBS (&(x->obs))\n  obstack_init (OBS);\n\n  while (true)\n    {\n      char *buf = (char *) malloc (BUFFER_SIZE);\n      size_t bytes_read;\n\n      if (buf == nullptr)\n        {\n           \n           \n          ok = false;\n          break;\n        }\n      bytes_read = full_read (STDIN_FILENO, buf, BUFFER_SIZE);\n      if (bytes_read != buffer_size && errno != 0)\n        error (EXIT_FAILURE, errno, _(\"read error\"));\n\n      {\n        struct B_pair bp;\n        bp.start = buf;\n        bp.one_past_end = buf + bytes_read;\n        obstack_grow (OBS, &bp, sizeof (bp));\n      }\n\n      if (bytes_read != 0)\n        last_byte_is_eol_byte = (buf[bytes_read - 1] == eol_byte);\n\n      if (bytes_read < BUFFER_SIZE)\n        break;\n    }\n\n  if (ok)\n    {\n       \n      if (!last_byte_is_eol_byte)\n        {\n          char *buf = malloc (1);\n          if (buf == nullptr)\n            {\n               \n              ok = false;\n            }\n          else\n            {\n              struct B_pair bp;\n              *buf = eol_byte;\n              bp.start = buf;\n              bp.one_past_end = buf + 1;\n              obstack_grow (OBS, &bp, sizeof (bp));\n            }\n        }\n    }\n\n  x->n_bufs = obstack_object_size (OBS) / sizeof (x->p[0]);\n  x->p = (struct B_pair *) obstack_finish (OBS);\n\n   \n  if (x->n_bufs >= 2\n      && x->p[x->n_bufs - 1].start == x->p[x->n_bufs - 1].one_past_end)\n    free (x->p[--(x->n_bufs)].start);\n\n  return ok;\n}\n\nstatic void\nbuf_free (Buf *x)\n{\n  for (size_t i = 0; i < x->n_bufs; i++)\n    free (x->p[i].start);\n  obstack_free (OBS, nullptr);\n}\n\nLine_ptr\nline_ptr_decrement (const Buf *x, const Line_ptr *lp)\n{\n  Line_ptr lp_new;\n\n  if (lp->ptr > x->p[lp->i].start)\n    {\n      lp_new.i = lp->i;\n      lp_new.ptr = lp->ptr - 1;\n    }\n  else\n    {\n      affirm (lp->i > 0);\n      lp_new.i = lp->i - 1;\n      lp_new.ptr = ONE_PAST_END (x, lp->i - 1) - 1;\n    }\n  return lp_new;\n}\n\nLine_ptr\nline_ptr_increment (const Buf *x, const Line_ptr *lp)\n{\n  Line_ptr lp_new;\n\n  affirm (lp->ptr <= ONE_PAST_END (x, lp->i) - 1);\n  if (lp->ptr < ONE_PAST_END (x, lp->i) - 1)\n    {\n      lp_new.i = lp->i;\n      lp_new.ptr = lp->ptr + 1;\n    }\n  else\n    {\n      affirm (lp->i < x->n_bufs - 1);\n      lp_new.i = lp->i + 1;\n      lp_new.ptr = x->p[lp->i + 1].start;\n    }\n  return lp_new;\n}\n\nstatic bool\nfind_bol (const Buf *x,\n          const Line_ptr *last_bol, Line_ptr *new_bol, char eol_byte)\n{\n  size_t i;\n  Line_ptr tmp;\n  char *last_bol_ptr;\n\n  if (last_bol->ptr == x->p[0].start)\n    return false;\n\n  tmp = line_ptr_decrement (x, last_bol);\n  last_bol_ptr = tmp.ptr;\n  i = tmp.i;\n  while (true)\n    {\n      char *nl = memrchr (x->p[i].start, last_bol_ptr, eol_byte);\n      if (nl)\n        {\n          Line_ptr nl_pos;\n          nl_pos.i = i;\n          nl_pos.ptr = nl;\n          *new_bol = line_ptr_increment (x, &nl_pos);\n          return true;\n        }\n\n      if (i == 0)\n        break;\n\n      --i;\n      last_bol_ptr = ONE_PAST_END (x, i);\n    }\n\n   \n  if (last_bol->ptr != x->p[0].start)\n    {\n      new_bol->i = 0;\n      new_bol->ptr = x->p[0].start;\n      return true;\n    }\n\n  return false;\n}\n\nstatic void\nprint_line (FILE *out_stream, const Buf *x,\n            const Line_ptr *bol, const Line_ptr *bol_next)\n{\n  for (size_t i = bol->i; i <= bol_next->i; i++)\n    {\n      char *a = (i == bol->i ? bol->ptr : x->p[i].start);\n      char *b = (i == bol_next->i ? bol_next->ptr : ONE_PAST_END (x, i));\n      fwrite (a, 1, b - a, out_stream);\n    }\n}\n\nstatic bool\ntac_mem ()\n{\n  Buf x;\n  Line_ptr bol;\n  char eol_byte = '\\n';\n\n  if (! buf_init_from_stdin (&x, eol_byte))\n    {\n      buf_free (&x);\n      return false;\n    }\n\n   \n  if (EMPTY (&x))\n    return true;\n\n   \n  bol.i = x.n_bufs - 1;\n  bol.ptr = ONE_PAST_END (&x, bol.i);\n\n  while (true)\n    {\n      Line_ptr new_bol;\n      if (! find_bol (&x, &bol, &new_bol, eol_byte))\n        break;\n      print_line (stdout, &x, &new_bol, &bol);\n      bol = new_bol;\n    }\n  return true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}