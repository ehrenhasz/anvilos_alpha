{
  "module_name": "join.c",
  "hash_id": "711f709faec49e4761b4e0b3568820f33c6e865ae301f15f205eff10ef4f4a9d",
  "original_prompt": "Ingested from coreutils-9.4/src/join.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <sys/types.h>\n#include <getopt.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"fadvise.h\"\n#include \"hard-locale.h\"\n#include \"linebuffer.h\"\n#include \"memcasecmp.h\"\n#include \"quote.h\"\n#include \"stdio--.h\"\n#include \"xmemcoll.h\"\n#include \"xstrtol.h\"\n#include \"argmatch.h\"\n\n \n#define PROGRAM_NAME \"join\"\n\n#define AUTHORS proper_name (\"Mike Haertel\")\n\n#define join system_join\n\n#define SWAPLINES(a, b) do { \\\n  struct line *tmp = a; \\\n  a = b; \\\n  b = tmp; \\\n} while (0);\n\n \nstruct outlist\n  {\n     \n    int file;\n\n     \n    idx_t field;\n\n    struct outlist *next;\n  };\n\n \nstruct field\n  {\n    char *beg;\t\t\t \n    idx_t len;\t\t\t \n  };\n\n \nstruct line\n  {\n    struct linebuffer buf;\t \n    idx_t nfields;\t\t \n    idx_t nfields_allocated;\t \n    struct field *fields;\n  };\n\n \nstruct seq\n  {\n    idx_t count;\t\t \n    idx_t alloc;\t\t \n    struct line **lines;\n  };\n\n \nstatic struct line *prevline[2] = {nullptr, nullptr};\n\n \nstatic uintmax_t line_no[2] = {0, 0};\n\n \nstatic char *g_names[2];\n\n \nstatic struct line *spareline[2] = {nullptr, nullptr};\n\n \nstatic bool hard_LC_COLLATE;\n\n \nstatic bool print_unpairables_1, print_unpairables_2;\n\n \nstatic bool print_pairables;\n\n \nstatic bool seen_unpairable;\n\n \nstatic bool issued_disorder_warning[2];\n\n \nstatic char const *empty_filler;\n\n \nstatic bool autoformat;\n \nstatic idx_t autocount_1;\nstatic idx_t autocount_2;\n\n \nstatic ptrdiff_t join_field_1 = -1;\nstatic ptrdiff_t join_field_2 = -1;\n\n \nstatic struct outlist outlist_head;\n\n \nstatic struct outlist *outlist_end = &outlist_head;\n\n \nstatic int tab = -1;\n\n \nstatic enum\n  {\n    CHECK_ORDER_DEFAULT,\n    CHECK_ORDER_ENABLED,\n    CHECK_ORDER_DISABLED\n  } check_input_order;\n\nenum\n{\n  CHECK_ORDER_OPTION = CHAR_MAX + 1,\n  NOCHECK_ORDER_OPTION,\n  HEADER_LINE_OPTION\n};\n\n\nstatic struct option const longopts[] =\n{\n  {\"ignore-case\", no_argument, nullptr, 'i'},\n  {\"check-order\", no_argument, nullptr, CHECK_ORDER_OPTION},\n  {\"nocheck-order\", no_argument, nullptr, NOCHECK_ORDER_OPTION},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {\"header\", no_argument, nullptr, HEADER_LINE_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic struct line uni_blank;\n\n \nstatic bool ignore_case;\n\n \nstatic bool join_header_lines;\n\n \nstatic char eolchar = '\\n';\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... FILE1 FILE2\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nFor each pair of input lines with identical join fields, write a line to\\n\\\nstandard output.  The default join field is the first, delimited by blanks.\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nWhen FILE1 or FILE2 (not both) is -, read standard input.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -a FILENUM             also print unpairable lines from file FILENUM, where\\n\\\n                           FILENUM is 1 or 2, corresponding to FILE1 or FILE2\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -e STRING              replace missing (empty) input fields with STRING;\\n\\\n                           I.e., missing fields specified with '-12jo' options\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -i, --ignore-case      ignore differences in case when comparing fields\\n\\\n  -j FIELD               equivalent to '-1 FIELD -2 FIELD'\\n\\\n  -o FORMAT              obey FORMAT while constructing output line\\n\\\n  -t CHAR                use CHAR as input and output field separator\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v FILENUM             like -a FILENUM, but suppress joined output lines\\n\\\n  -1 FIELD               join on this FIELD of file 1\\n\\\n  -2 FIELD               join on this FIELD of file 2\\n\\\n      --check-order      check that the input is correctly sorted, even\\n\\\n                           if all input lines are pairable\\n\\\n      --nocheck-order    do not check that the input is correctly sorted\\n\\\n      --header           treat the first line in each file as field headers,\\n\\\n                           print them without trying to pair them\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated  line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nUnless -t CHAR is given, leading blanks separate fields and are ignored,\\n\\\nelse fields are separated by CHAR.  Any FIELD is a field number counted\\n\\\nfrom 1.  FORMAT is one or more comma or blank separated specifications,\\n\\\neach being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\\n\\\nthe remaining fields from FILE1, the remaining fields from FILE2, all\\n\\\nseparated by CHAR.  If FORMAT is the keyword 'auto', then the first\\n\\\nline of each file determines the number of fields output for each line.\\n\\\n\\n\\\nImportant: FILE1 and FILE2 must be sorted on the join fields.\\n\\\nE.g., use \\\"sort -k 1b,1\\\" if 'join' has no options,\\n\\\nor use \\\"join -t ''\\\" if 'sort' has no options.\\n\\\nNote, comparisons honor the rules specified by 'LC_COLLATE'.\\n\\\nIf the input is not sorted and some lines cannot be joined, a\\n\\\nwarning message will be given.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Record a field in LINE, with location FIELD and size LEN.  */\n\nstatic void\nextract_field (struct line *line, char *field, idx_t len)\n{\n  if (line->nfields >= line->nfields_allocated)\n    line->fields = xpalloc (line->fields, &line->nfields_allocated, 1,\n                            -1, sizeof *line->fields);\n  line->fields[line->nfields].beg = field;\n  line->fields[line->nfields].len = len;\n  ++(line->nfields);\n}\n\n/* Fill in the 'fields' structure in LINE.  */\n\nstatic void\nxfields (struct line *line)\n{\n  char *ptr = line->buf.buffer;\n  char const *lim = ptr + line->buf.length - 1;\n\n  if (ptr == lim)\n    return;\n\n  if (0 <= tab && tab != '\\n')\n    {\n      char *sep;\n      for (; (sep = memchr (ptr, tab, lim - ptr)) != nullptr; ptr = sep + 1)\n        extract_field (line, ptr, sep - ptr);\n    }\n  else if (tab < 0)\n    {\n      /* Skip leading blanks before the first field.  */\n      while (field_sep (*ptr))\n        if (++ptr == lim)\n          return;\n\n      do\n        {\n          char *sep;\n          for (sep = ptr + 1; sep != lim && ! field_sep (*sep); sep++)\n            continue;\n          extract_field (line, ptr, sep - ptr);\n          if (sep == lim)\n            return;\n          for (ptr = sep + 1; ptr != lim && field_sep (*ptr); ptr++)\n            continue;\n        }\n      while (ptr != lim);\n    }\n\n  extract_field (line, ptr, lim - ptr);\n}\n\nstatic void\nfreeline (struct line *line)\n{\n  if (line == nullptr)\n    return;\n  free (line->fields);\n  line->fields = nullptr;\n  free (line->buf.buffer);\n  line->buf.buffer = nullptr;\n}\n\n/* Return <0 if the join field in LINE1 compares less than the one in LINE2;\n   >0 if it compares greater; 0 if it compares equal.\n   Report an error and exit if the comparison fails.\n   Use join fields JF_1 and JF_2 respectively.  */\n\nstatic int\nkeycmp (struct line const *line1, struct line const *line2,\n        idx_t jf_1, idx_t jf_2)\n{\n  /* Start of field to compare in each file.  */\n  char *beg1;\n  char *beg2;\n\n  idx_t len1;\n  idx_t len2;\t\t/* Length of fields to compare.  */\n  int diff;\n\n  if (jf_1 < line1->nfields)\n    {\n      beg1 = line1->fields[jf_1].beg;\n      len1 = line1->fields[jf_1].len;\n    }\n  else\n    {\n      beg1 = nullptr;\n      len1 = 0;\n    }\n\n  if (jf_2 < line2->nfields)\n    {\n      beg2 = line2->fields[jf_2].beg;\n      len2 = line2->fields[jf_2].len;\n    }\n  else\n    {\n      beg2 = nullptr;\n      len2 = 0;\n    }\n\n  if (len1 == 0)\n    return len2 == 0 ? 0 : -1;\n  if (len2 == 0)\n    return 1;\n\n  if (ignore_case)\n    {\n      /* FIXME: ignore_case does not work with NLS (in particular,\n         with multibyte chars).  */\n      diff = memcasecmp (beg1, beg2, MIN (len1, len2));\n    }\n  else\n    {\n      if (hard_LC_COLLATE)\n        return xmemcoll (beg1, len1, beg2, len2);\n      diff = memcmp (beg1, beg2, MIN (len1, len2));\n    }\n\n  if (diff)\n    return diff;\n  return (len1 > len2) - (len1 < len2);\n}\n\n/* Check that successive input lines PREV and CURRENT from input file\n   WHATFILE are presented in order, unless the user may be relying on\n   the GNU extension that input lines may be out of order if no input\n   lines are unpairable.\n\n   If the user specified --nocheck-order, the check is not made.\n   If the user specified --check-order, the problem is fatal.\n   Otherwise (the default), the message is simply a warning.\n\n   A message is printed at most once per input file. */\n\nstatic void\ncheck_order (const struct line *prev,\n             const struct line *current,\n             int whatfile)\n{\n  if (check_input_order != CHECK_ORDER_DISABLED\n      && ((check_input_order == CHECK_ORDER_ENABLED) || seen_unpairable))\n    {\n      if (!issued_disorder_warning[whatfile - 1])\n        {\n          idx_t join_field = whatfile == 1 ? join_field_1 : join_field_2;\n          if (keycmp (prev, current, join_field, join_field) > 0)\n            {\n              /* Exclude any trailing newline. */\n              idx_t len = current->buf.length;\n              if (0 < len && current->buf.buffer[len - 1] == '\\n')\n                --len;\n\n              /* If the offending line is longer than INT_MAX, output\n                 only the first INT_MAX bytes in this diagnostic.  */\n              len = MIN (INT_MAX, len);\n\n              error ((check_input_order == CHECK_ORDER_ENABLED\n                      ? EXIT_FAILURE : 0),\n                     0, _(\"%s:%\"PRIuMAX\": is not sorted: %.*s\"),\n                     g_names[whatfile - 1], line_no[whatfile - 1],\n                     (int) len, current->buf.buffer);\n\n              /* If we get to here, the message was merely a warning.\n                 Arrange to issue it only once per file.  */\n              issued_disorder_warning[whatfile - 1] = true;\n            }\n        }\n    }\n}\n\nstatic inline void\nreset_line (struct line *line)\n{\n  line->nfields = 0;\n}\n\nstatic struct line *\ninit_linep (struct line **linep)\n{\n  struct line *line = xzalloc (sizeof *line);\n  *linep = line;\n  return line;\n}\n\n/* Read a line from FP into LINE and split it into fields.\n   Return true if successful.  */\n\nstatic bool\nget_line (FILE *fp, struct line **linep, int which)\n{\n  struct line *line = *linep;\n\n  if (line == prevline[which - 1])\n    {\n      SWAPLINES (line, spareline[which - 1]);\n      *linep = line;\n    }\n\n  if (line)\n    reset_line (line);\n  else\n    line = init_linep (linep);\n\n  if (! readlinebuffer_delim (&line->buf, fp, eolchar))\n    {\n      if (ferror (fp))\n        error (EXIT_FAILURE, errno, _(\"read error\"));\n      freeline (line);\n      return false;\n    }\n  ++line_no[which - 1];\n\n  xfields (line);\n\n  if (prevline[which - 1])\n    check_order (prevline[which - 1], line, which);\n\n  prevline[which - 1] = line;\n  return true;\n}\n\nstatic void\nfree_spareline (void)\n{\n  for (idx_t i = 0; i < ARRAY_CARDINALITY (spareline); i++)\n    {\n      if (spareline[i])\n        {\n          freeline (spareline[i]);\n          free (spareline[i]);\n        }\n    }\n}\n\nstatic void\ninitseq (struct seq *seq)\n{\n  seq->count = 0;\n  seq->alloc = 0;\n  seq->lines = nullptr;\n}\n\n/* Read a line from FP and add it to SEQ.  Return true if successful.  */\n\nstatic bool\ngetseq (FILE *fp, struct seq *seq, int whichfile)\n{\n  if (seq->count == seq->alloc)\n    {\n      seq->lines = xpalloc (seq->lines, &seq->alloc, 1, -1, sizeof *seq->lines);\n      for (idx_t i = seq->count; i < seq->alloc; i++)\n        seq->lines[i] = nullptr;\n    }\n\n  if (get_line (fp, &seq->lines[seq->count], whichfile))\n    {\n      ++seq->count;\n      return true;\n    }\n  return false;\n}\n\n/* Read a line from FP and add it to SEQ, as the first item if FIRST is\n   true, else as the next.  */\nstatic bool\nadvance_seq (FILE *fp, struct seq *seq, bool first, int whichfile)\n{\n  if (first)\n    seq->count = 0;\n\n  return getseq (fp, seq, whichfile);\n}\n\nstatic void\ndelseq (struct seq *seq)\n{\n  for (idx_t i = 0; i < seq->alloc; i++)\n    {\n      freeline (seq->lines[i]);\n      free (seq->lines[i]);\n    }\n  free (seq->lines);\n}\n\n\n/* Print field N of LINE if it exists and is nonempty, otherwise\n   'empty_filler' if it is nonempty.  */\n\nstatic void\nprfield (idx_t n, struct line const *line)\n{\n  if (n < line->nfields)\n    {\n      idx_t len = line->fields[n].len;\n      if (len)\n        fwrite (line->fields[n].beg, 1, len, stdout);\n      else if (empty_filler)\n        fputs (empty_filler, stdout);\n    }\n  else if (empty_filler)\n    fputs (empty_filler, stdout);\n}\n\n/* Output all the fields in line, other than the join field.  */\n\nstatic void\nprfields (struct line const *line, idx_t join_field, idx_t autocount)\n{\n  idx_t i;\n  idx_t nfields = autoformat ? autocount : line->nfields;\n  char output_separator = tab < 0 ? ' ' : tab;\n\n  for (i = 0; i < join_field && i < nfields; ++i)\n    {\n      putchar (output_separator);\n      prfield (i, line);\n    }\n  for (i = join_field + 1; i < nfields; ++i)\n    {\n      putchar (output_separator);\n      prfield (i, line);\n    }\n}\n\n/* Print the join of LINE1 and LINE2.  */\n\nstatic void\nprjoin (struct line const *line1, struct line const *line2)\n{\n  const struct outlist *outlist;\n  char output_separator = tab < 0 ? ' ' : tab;\n  idx_t field;\n  struct line const *line;\n\n  outlist = outlist_head.next;\n  if (outlist)\n    {\n      const struct outlist *o;\n\n      o = outlist;\n      while (true)\n        {\n          if (o->file == 0)\n            {\n              if (line1 == &uni_blank)\n                {\n                  line = line2;\n                  field = join_field_2;\n                }\n              else\n                {\n                  line = line1;\n                  field = join_field_1;\n                }\n            }\n          else\n            {\n              line = (o->file == 1 ? line1 : line2);\n              field = o->field;\n            }\n          prfield (field, line);\n          o = o->next;\n          if (o == nullptr)\n            break;\n          putchar (output_separator);\n        }\n      putchar (eolchar);\n    }\n  else\n    {\n      if (line1 == &uni_blank)\n        {\n          line = line2;\n          field = join_field_2;\n        }\n      else\n        {\n          line = line1;\n          field = join_field_1;\n        }\n\n      /* Output the join field.  */\n      prfield (field, line);\n\n      /* Output other fields.  */\n      prfields (line1, join_field_1, autocount_1);\n      prfields (line2, join_field_2, autocount_2);\n\n      putchar (eolchar);\n    }\n\n  if (ferror (stdout))\n    write_error ();\n}\n\n/* Print the join of the files in FP1 and FP2.  */\n\nstatic void\njoin (FILE *fp1, FILE *fp2)\n{\n  struct seq seq1, seq2;\n  int diff;\n  bool eof1, eof2;\n\n  fadvise (fp1, FADVISE_SEQUENTIAL);\n  fadvise (fp2, FADVISE_SEQUENTIAL);\n\n  /* Read the first line of each file.  */\n  initseq (&seq1);\n  getseq (fp1, &seq1, 1);\n  initseq (&seq2);\n  getseq (fp2, &seq2, 2);\n\n  if (autoformat)\n    {\n      autocount_1 = seq1.count ? seq1.lines[0]->nfields : 0;\n      autocount_2 = seq2.count ? seq2.lines[0]->nfields : 0;\n    }\n\n  if (join_header_lines && (seq1.count || seq2.count))\n    {\n      struct line const *hline1 = seq1.count ? seq1.lines[0] : &uni_blank;\n      struct line const *hline2 = seq2.count ? seq2.lines[0] : &uni_blank;\n      prjoin (hline1, hline2);\n      prevline[0] = nullptr;\n      prevline[1] = nullptr;\n      if (seq1.count)\n        advance_seq (fp1, &seq1, true, 1);\n      if (seq2.count)\n        advance_seq (fp2, &seq2, true, 2);\n    }\n\n  while (seq1.count && seq2.count)\n    {\n      diff = keycmp (seq1.lines[0], seq2.lines[0],\n                     join_field_1, join_field_2);\n      if (diff < 0)\n        {\n          if (print_unpairables_1)\n            prjoin (seq1.lines[0], &uni_blank);\n          advance_seq (fp1, &seq1, true, 1);\n          seen_unpairable = true;\n          continue;\n        }\n      if (diff > 0)\n        {\n          if (print_unpairables_2)\n            prjoin (&uni_blank, seq2.lines[0]);\n          advance_seq (fp2, &seq2, true, 2);\n          seen_unpairable = true;\n          continue;\n        }\n\n      /* Keep reading lines from file1 as long as they continue to\n         match the current line from file2.  */\n      eof1 = false;\n      do\n        if (!advance_seq (fp1, &seq1, false, 1))\n          {\n            eof1 = true;\n            ++seq1.count;\n            break;\n          }\n      while (!keycmp (seq1.lines[seq1.count - 1], seq2.lines[0],\n                      join_field_1, join_field_2));\n\n      /* Keep reading lines from file2 as long as they continue to\n         match the current line from file1.  */\n      eof2 = false;\n      do\n        if (!advance_seq (fp2, &seq2, false, 2))\n          {\n            eof2 = true;\n            ++seq2.count;\n            break;\n          }\n      while (!keycmp (seq1.lines[0], seq2.lines[seq2.count - 1],\n                      join_field_1, join_field_2));\n\n      if (print_pairables)\n        {\n          for (idx_t i = 0; i < seq1.count - 1; ++i)\n            {\n              idx_t j;\n              for (j = 0; j < seq2.count - 1; ++j)\n                prjoin (seq1.lines[i], seq2.lines[j]);\n            }\n        }\n\n      if (!eof1)\n        {\n          SWAPLINES (seq1.lines[0], seq1.lines[seq1.count - 1]);\n          seq1.count = 1;\n        }\n      else\n        seq1.count = 0;\n\n      if (!eof2)\n        {\n          SWAPLINES (seq2.lines[0], seq2.lines[seq2.count - 1]);\n          seq2.count = 1;\n        }\n      else\n        seq2.count = 0;\n    }\n\n  /* If the user did not specify --nocheck-order, then we read the\n     tail ends of both inputs to verify that they are in order.  We\n     skip the rest of the tail once we have issued a warning for that\n     file, unless we actually need to print the unpairable lines.  */\n  struct line *line = nullptr;\n  bool checktail = false;\n\n  if (check_input_order != CHECK_ORDER_DISABLED\n      && !(issued_disorder_warning[0] && issued_disorder_warning[1]))\n    checktail = true;\n\n  if ((print_unpairables_1 || checktail) && seq1.count)\n    {\n      if (print_unpairables_1)\n        prjoin (seq1.lines[0], &uni_blank);\n      if (seq2.count)\n        seen_unpairable = true;\n      while (get_line (fp1, &line, 1))\n        {\n          if (print_unpairables_1)\n            prjoin (line, &uni_blank);\n          if (issued_disorder_warning[0] && !print_unpairables_1)\n            break;\n        }\n    }\n\n  if ((print_unpairables_2 || checktail) && seq2.count)\n    {\n      if (print_unpairables_2)\n        prjoin (&uni_blank, seq2.lines[0]);\n      if (seq1.count)\n        seen_unpairable = true;\n      while (get_line (fp2, &line, 2))\n        {\n          if (print_unpairables_2)\n            prjoin (&uni_blank, line);\n          if (issued_disorder_warning[1] && !print_unpairables_2)\n            break;\n        }\n    }\n\n  freeline (line);\n  free (line);\n\n  delseq (&seq1);\n  delseq (&seq2);\n}\n\n/* Add a field spec for field FIELD of file FILE to 'outlist'.  */\n\nstatic void\nadd_field (int file, idx_t field)\n{\n  struct outlist *o;\n\n  affirm (file == 0 || file == 1 || file == 2);\n  affirm (file != 0 || field == 0);\n\n  o = xmalloc (sizeof *o);\n  o->file = file;\n  o->field = field;\n  o->next = nullptr;\n\n  /* Add to the end of the list so the fields are in the right order.  */\n  outlist_end->next = o;\n  outlist_end = o;\n}\n\n/* Convert a string of decimal digits, STR (the 1-based join field number),\n   to an integral value.  Upon successful conversion, return one less\n   (the zero-based field number).  Silently convert too-large values\n   to PTRDIFF_MAX.  Otherwise, if a value cannot be converted, give a\n   diagnostic and exit.  */\n\nstatic idx_t\nstring_to_join_field (char const *str)\n{\n  intmax_t val;\n\n  strtol_error s_err = xstrtoimax (str, nullptr, 10, &val, \"\");\n  if (s_err == LONGINT_OVERFLOW || (s_err == LONGINT_OK && PTRDIFF_MAX < val))\n    val = PTRDIFF_MAX;\n  else if (s_err != LONGINT_OK || val <= 0)\n    error (EXIT_FAILURE, 0, _(\"invalid field number: %s\"), quote (str));\n\n  return val - 1;\n}\n\n/* Convert a single field specifier string, S, to a *FILE_INDEX, *FIELD_INDEX\n   pair.  In S, the field index string is 1-based; *FIELD_INDEX is zero-based.\n   If S is valid, return true.  Otherwise, give a diagnostic and exit.  */\n\nstatic void\ndecode_field_spec (char const *s, int *file_index, idx_t *field_index)\n{\n  /* The first character must be 0, 1, or 2.  */\n  switch (s[0])\n    {\n    case '0':\n      if (s[1])\n        {\n          /* '0' must be all alone -- no '.FIELD'.  */\n          error (EXIT_FAILURE, 0, _(\"invalid field specifier: %s\"), quote (s));\n        }\n      *file_index = 0;\n      *field_index = 0;\n      break;\n\n    case '1':\n    case '2':\n      if (s[1] != '.')\n        error (EXIT_FAILURE, 0, _(\"invalid field specifier: %s\"), quote (s));\n      *file_index = s[0] - '0';\n      *field_index = string_to_join_field (s + 2);\n      break;\n\n    default:\n      error (EXIT_FAILURE, 0,\n             _(\"invalid file number in field spec: %s\"), quote (s));\n    }\n}\n\n/* Add the comma or blank separated field spec(s) in STR to 'outlist'.  */\n\nstatic void\nadd_field_list (char *str)\n{\n  char *p = str;\n\n  do\n    {\n      int file_index;\n      idx_t field_index;\n      char const *spec_item = p;\n\n      p = strpbrk (p, \", \\t\");\n      if (p)\n        *p++ = '\\0';\n      decode_field_spec (spec_item, &file_index, &field_index);\n      add_field (file_index, field_index);\n    }\n  while (p);\n}\n\n/* Set the join field *VAR to VAL, but report an error if *VAR is set\n   more than once to incompatible values.  */\n\nstatic void\nset_join_field (ptrdiff_t *var, idx_t val)\n{\n  if (0 <= *var && *var != val)\n    error (EXIT_FAILURE, 0,\n           _(\"incompatible join fields %td, %td\"), *var, val);\n  *var = val;\n}\n\n/* Status of command-line arguments.  */\n\nenum operand_status\n  {\n    /* This argument must be an operand, i.e., one of the files to be\n       joined.  */\n    MUST_BE_OPERAND,\n\n    /* This might be the argument of the preceding -j1 or -j2 option,\n       or it might be an operand.  */\n    MIGHT_BE_J1_ARG,\n    MIGHT_BE_J2_ARG,\n\n    /* This might be the argument of the preceding -o option, or it might be\n       an operand.  */\n    MIGHT_BE_O_ARG\n  };\n\n/* Add NAME to the array of input file NAMES with operand statuses\n   OPERAND_STATUS; currently there are NFILES names in the list.  */\n\nstatic void\nadd_file_name (char *name, char *names[2],\n               int operand_status[2], int joption_count[2], int *nfiles,\n               int *prev_optc_status, int *optc_status)\n{\n  int n = *nfiles;\n\n  if (n == 2)\n    {\n      bool op0 = (operand_status[0] == MUST_BE_OPERAND);\n      char *arg = names[op0];\n      switch (operand_status[op0])\n        {\n        case MUST_BE_OPERAND:\n          error (0, 0, _(\"extra operand %s\"), quoteaf (name));\n          usage (EXIT_FAILURE);\n\n        case MIGHT_BE_J1_ARG:\n          joption_count[0]--;\n          set_join_field (&join_field_1, string_to_join_field (arg));\n          break;\n\n        case MIGHT_BE_J2_ARG:\n          joption_count[1]--;\n          set_join_field (&join_field_2, string_to_join_field (arg));\n          break;\n\n        case MIGHT_BE_O_ARG:\n          add_field_list (arg);\n          break;\n        }\n      if (!op0)\n        {\n          operand_status[0] = operand_status[1];\n          names[0] = names[1];\n        }\n      n = 1;\n    }\n\n  operand_status[n] = *prev_optc_status;\n  names[n] = name;\n  *nfiles = n + 1;\n  if (*prev_optc_status == MIGHT_BE_O_ARG)\n    *optc_status = MIGHT_BE_O_ARG;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc_status;\n  int prev_optc_status = MUST_BE_OPERAND;\n  int operand_status[2];\n  int joption_count[2] = { 0, 0 };\n  FILE *fp1, *fp2;\n  int optc;\n  int nfiles = 0;\n  int i;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  hard_LC_COLLATE = hard_locale (LC_COLLATE);\n\n  atexit (close_stdout);\n  atexit (free_spareline);\n\n  print_pairables = true;\n  seen_unpairable = false;\n  issued_disorder_warning[0] = issued_disorder_warning[1] = false;\n  check_input_order = CHECK_ORDER_DEFAULT;\n\n  while ((optc = getopt_long (argc, argv, \"-a:e:i1:2:j:o:t:v:z\",\n                              longopts, nullptr))\n         != -1)\n    {\n      optc_status = MUST_BE_OPERAND;\n\n      switch (optc)\n        {\n        case 'v':\n            print_pairables = false;\n            FALLTHROUGH;\n\n        case 'a':\n          {\n            long int val;\n            if (xstrtol (optarg, nullptr, 10, &val, \"\") != LONGINT_OK\n                || (val != 1 && val != 2))\n              error (EXIT_FAILURE, 0,\n                     _(\"invalid field number: %s\"), quote (optarg));\n            if (val == 1)\n              print_unpairables_1 = true;\n            else\n              print_unpairables_2 = true;\n          }\n          break;\n\n        case 'e':\n          if (empty_filler && ! STREQ (empty_filler, optarg))\n            error (EXIT_FAILURE, 0,\n                   _(\"conflicting empty-field replacement strings\"));\n          empty_filler = optarg;\n          break;\n\n        case 'i':\n          ignore_case = true;\n          break;\n\n        case '1':\n          set_join_field (&join_field_1, string_to_join_field (optarg));\n          break;\n\n        case '2':\n          set_join_field (&join_field_2, string_to_join_field (optarg));\n          break;\n\n        case 'j':\n          if ((optarg[0] == '1' || optarg[0] == '2') && !optarg[1]\n              && optarg == argv[optind - 1] + 2)\n            {\n              /* The argument was either \"-j1\" or \"-j2\".  */\n              bool is_j2 = (optarg[0] == '2');\n              joption_count[is_j2]++;\n              optc_status = MIGHT_BE_J1_ARG + is_j2;\n            }\n          else\n            {\n              set_join_field (&join_field_1, string_to_join_field (optarg));\n              set_join_field (&join_field_2, join_field_1);\n            }\n          break;\n\n        case 'o':\n          if (STREQ (optarg, \"auto\"))\n            autoformat = true;\n          else\n            {\n              add_field_list (optarg);\n              optc_status = MIGHT_BE_O_ARG;\n            }\n          break;\n\n        case 't':\n          {\n            unsigned char newtab = optarg[0];\n            if (! newtab)\n              newtab = '\\n'; /* '' => process the whole line.  */\n            else if (optarg[1])\n              {\n                if (STREQ (optarg, \"\\\\0\"))\n                  newtab = '\\0';\n                else\n                  error (EXIT_FAILURE, 0, _(\"multi-character tab %s\"),\n                         quote (optarg));\n              }\n            if (0 <= tab && tab != newtab)\n              error (EXIT_FAILURE, 0, _(\"incompatible tabs\"));\n            tab = newtab;\n          }\n          break;\n\n        case 'z':\n          eolchar = 0;\n          break;\n\n        case NOCHECK_ORDER_OPTION:\n          check_input_order = CHECK_ORDER_DISABLED;\n          break;\n\n        case CHECK_ORDER_OPTION:\n          check_input_order = CHECK_ORDER_ENABLED;\n          break;\n\n        case 1:\t\t/* Non-option argument.  */\n          add_file_name (optarg, g_names, operand_status, joption_count,\n                         &nfiles, &prev_optc_status, &optc_status);\n          break;\n\n        case HEADER_LINE_OPTION:\n          join_header_lines = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n\n      prev_optc_status = optc_status;\n    }\n\n  /* Process any operands after \"--\".  */\n  prev_optc_status = MUST_BE_OPERAND;\n  while (optind < argc)\n    add_file_name (argv[optind++], g_names, operand_status, joption_count,\n                   &nfiles, &prev_optc_status, &optc_status);\n\n  if (nfiles != 2)\n    {\n      if (nfiles == 0)\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  /* If \"-j1\" was specified and it turns out not to have had an argument,\n     treat it as \"-j 1\".  Likewise for -j2.  */\n  for (i = 0; i < 2; i++)\n    if (joption_count[i] != 0)\n      {\n        set_join_field (&join_field_1, i);\n        set_join_field (&join_field_2, i);\n      }\n\n  if (join_field_1 < 0)\n    join_field_1 = 0;\n  if (join_field_2 < 0)\n    join_field_2 = 0;\n\n  fp1 = STREQ (g_names[0], \"-\") ? stdin : fopen (g_names[0], \"r\");\n  if (!fp1)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (g_names[0]));\n  fp2 = STREQ (g_names[1], \"-\") ? stdin : fopen (g_names[1], \"r\");\n  if (!fp2)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (g_names[1]));\n  if (fp1 == fp2)\n    error (EXIT_FAILURE, errno, _(\"both files cannot be standard input\"));\n  join (fp1, fp2);\n\n  if (fclose (fp1) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (g_names[0]));\n  if (fclose (fp2) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (g_names[1]));\n\n  if (issued_disorder_warning[0] || issued_disorder_warning[1])\n    error (EXIT_FAILURE, 0, _(\"input is not in sorted order\"));\n  else\n    return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}