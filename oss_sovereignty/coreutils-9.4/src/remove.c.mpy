{
  "module_name": "remove.c",
  "hash_id": "f94b9d99e7c3175ce53324259b73a48dbcb2a9a8495f90911406a6f368e13771",
  "original_prompt": "Ingested from coreutils-9.4/src/remove.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"file-type.h\"\n#include \"filenamecat.h\"\n#include \"ignore-value.h\"\n#include \"remove.h\"\n#include \"root-dev-ino.h\"\n#include \"stat-time.h\"\n#include \"write-any-file.h\"\n#include \"xfts.h\"\n#include \"yesno.h\"\n\n \nenum Prompt_action\n  {\n    PA_DESCEND_INTO_DIR = 2,\n    PA_REMOVE_DIR\n  };\n\n \n#if ! HAVE_STRUCT_DIRENT_D_TYPE\n \n# undef DT_UNKNOWN\n# undef DT_DIR\n# undef DT_LNK\n# define DT_UNKNOWN 0\n# define DT_DIR 1\n# define DT_LNK 2\n#endif\n\n \nstatic int\ncache_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n#if HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n   \n  if (0 <= st->st_atim.tv_nsec)\n    return 0;\n  if (st->st_atim.tv_nsec == -1)\n    {\n      if (fstatat (fd, file, st, flag) == 0)\n        return 0;\n      st->st_atim.tv_nsec = -2;\n      st->st_ino = errno;\n    }\n  errno = st->st_ino;\n  return -1;\n#else\n  return fstatat (fd, file, st, flag);\n#endif\n}\n\n \nstatic inline struct stat *\ncache_stat_init (struct stat *st)\n{\n#if HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n  st->st_atim.tv_nsec = -1;\n#endif\n  return st;\n}\n\n \nstatic int\nwrite_protected_non_symlink (int fd_cwd,\n                             char const *file,\n                             struct stat *buf)\n{\n  if (can_write_any_file ())\n    return 0;\n  if (cache_fstatat (fd_cwd, file, buf, AT_SYMLINK_NOFOLLOW) != 0)\n    return -1;\n  if (S_ISLNK (buf->st_mode))\n    return 0;\n   \n\n   \n\n   \n\n  {\n    if (faccessat (fd_cwd, file, W_OK, AT_EACCESS) == 0)\n      return 0;\n\n    return errno == EACCES ? 1 : -1;\n  }\n}\n\n \nstatic int\nget_dir_status (FTS const *fts, FTSENT const *ent, int *dir_status)\n{\n  if (*dir_status == DS_UNKNOWN)\n    *dir_status = directory_status (fts->fts_cwd_fd, ent->fts_accpath);\n  return *dir_status;\n}\n\n \nstatic enum RM_status\nprompt (FTS const *fts, FTSENT const *ent, bool is_dir,\n        struct rm_options const *x, enum Prompt_action mode,\n        int *dir_status)\n{\n  int fd_cwd = fts->fts_cwd_fd;\n  char const *full_name = ent->fts_path;\n  char const *filename = ent->fts_accpath;\n  struct stat st;\n  struct stat *sbuf = &st;\n  cache_stat_init (sbuf);\n\n  int dirent_type = is_dir ? DT_DIR : DT_UNKNOWN;\n  int write_protected = 0;\n\n   \n  if (ent->fts_number)\n    return RM_USER_DECLINED;\n\n  if (x->interactive == RMI_NEVER)\n    return RM_OK;\n\n  int wp_errno = 0;\n  if (!x->ignore_missing_files\n      && (x->interactive == RMI_ALWAYS || x->stdin_tty)\n      && dirent_type != DT_LNK)\n    {\n      write_protected = write_protected_non_symlink (fd_cwd, filename, sbuf);\n      wp_errno = errno;\n    }\n\n  if (write_protected || x->interactive == RMI_ALWAYS)\n    {\n      if (0 <= write_protected && dirent_type == DT_UNKNOWN)\n        {\n          if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) == 0)\n            {\n              if (S_ISLNK (sbuf->st_mode))\n                dirent_type = DT_LNK;\n              else if (S_ISDIR (sbuf->st_mode))\n                dirent_type = DT_DIR;\n               \n            }\n          else\n            {\n               \n              write_protected = -1;\n              wp_errno = errno;\n            }\n        }\n\n      if (0 <= write_protected)\n        switch (dirent_type)\n          {\n          case DT_LNK:\n             \n            if (x->interactive != RMI_ALWAYS)\n              return RM_OK;\n            break;\n\n          case DT_DIR:\n              \n            if ( ! (x->recursive\n                    || (x->remove_empty_directories\n                        && get_dir_status (fts, ent, dir_status) != 0)))\n              {\n                write_protected = -1;\n                wp_errno = *dir_status <= 0 ? EISDIR : *dir_status;\n              }\n            break;\n          }\n\n      char const *quoted_name = quoteaf (full_name);\n\n      if (write_protected < 0)\n        {\n          error (0, wp_errno, _(\"cannot remove %s\"), quoted_name);\n          return RM_ERROR;\n        }\n\n       \n      if (dirent_type == DT_DIR\n          && mode == PA_DESCEND_INTO_DIR\n          && get_dir_status (fts, ent, dir_status) == DS_NONEMPTY)\n        fprintf (stderr,\n                 (write_protected\n                  ? _(\"%s: descend into write-protected directory %s? \")\n                  : _(\"%s: descend into directory %s? \")),\n                 program_name, quoted_name);\n      else if (0 < *dir_status)\n        {\n          if ( ! (x->remove_empty_directories && *dir_status == EACCES))\n            {\n              error (0, *dir_status, _(\"cannot remove %s\"), quoted_name);\n              return RM_ERROR;\n            }\n\n           \n          if (mode == PA_DESCEND_INTO_DIR)\n            return RM_OK;\n\n          fprintf (stderr,\n               _(\"%s: attempt removal of inaccessible directory %s? \"),\n                   program_name, quoted_name);\n        }\n      else\n        {\n          if (cache_fstatat (fd_cwd, filename, sbuf, AT_SYMLINK_NOFOLLOW) != 0)\n            {\n              error (0, errno, _(\"cannot remove %s\"), quoted_name);\n              return RM_ERROR;\n            }\n\n          fprintf (stderr,\n                   (write_protected\n                     \n                    ? _(\"%s: remove write-protected %s %s? \")\n                    : _(\"%s: remove %s %s? \")),\n                   program_name, file_type (sbuf), quoted_name);\n        }\n\n      return yesno () ? RM_USER_ACCEPTED : RM_USER_DECLINED;\n    }\n  return RM_OK;\n}\n\n \nstatic inline bool\nnonexistent_file_errno (int errnum)\n{\n   \n\n  switch (errnum)\n    {\n    case EILSEQ:\n    case EINVAL:\n    case ENOENT:\n    case ENOTDIR:\n      return true;\n    default:\n      return false;\n    }\n}\n\n \nstatic inline bool\nignorable_missing (struct rm_options const *x, int errnum)\n{\n  return x->ignore_missing_files && nonexistent_file_errno (errnum);\n}\n\n \nstatic void\nfts_skip_tree (FTS *fts, FTSENT *ent)\n{\n  fts_set (fts, ent, FTS_SKIP);\n   \n  ignore_value (fts_read (fts));\n}\n\n \nstatic void\nmark_ancestor_dirs (FTSENT *ent)\n{\n  FTSENT *p;\n  for (p = ent->fts_parent; FTS_ROOTLEVEL <= p->fts_level; p = p->fts_parent)\n    {\n      if (p->fts_number)\n        break;\n      p->fts_number = 1;\n    }\n}\n\n \nstatic enum RM_status\nexcise (FTS *fts, FTSENT *ent, struct rm_options const *x, bool is_dir)\n{\n  int flag = is_dir ? AT_REMOVEDIR : 0;\n  if (unlinkat (fts->fts_cwd_fd, ent->fts_accpath, flag) == 0)\n    {\n      if (x->verbose)\n        {\n          printf ((is_dir\n                   ? _(\"removed directory %s\\n\")\n                   : _(\"removed %s\\n\")), quoteaf (ent->fts_path));\n        }\n      return RM_OK;\n    }\n\n   \n  if (errno == EROFS)\n    {\n      struct stat st;\n      if ( ! (fstatat (fts->fts_cwd_fd, ent->fts_accpath, &st,\n                       AT_SYMLINK_NOFOLLOW)\n              && errno == ENOENT))\n        errno = EROFS;\n    }\n\n  if (ignorable_missing (x, errno))\n    return RM_OK;\n\n   \n  if (ent->fts_info == FTS_DNR\n      && (errno == ENOTEMPTY || errno == EISDIR || errno == ENOTDIR\n          || errno == EEXIST)\n      && ent->fts_errno != 0)\n    errno = ent->fts_errno;\n  error (0, errno, _(\"cannot remove %s\"), quoteaf (ent->fts_path));\n  mark_ancestor_dirs (ent);\n  return RM_ERROR;\n}\n\n \nstatic enum RM_status\nrm_fts (FTS *fts, FTSENT *ent, struct rm_options const *x)\n{\n  int dir_status = DS_UNKNOWN;\n\n  switch (ent->fts_info)\n    {\n    case FTS_D:\t\t\t \n      if (! x->recursive\n          && !(x->remove_empty_directories\n               && get_dir_status (fts, ent, &dir_status) != 0))\n        {\n           \n          int err = x->remove_empty_directories ? ENOTEMPTY : EISDIR;\n          error (0, err, _(\"cannot remove %s\"), quoteaf (ent->fts_path));\n          mark_ancestor_dirs (ent);\n          fts_skip_tree (fts, ent);\n          return RM_ERROR;\n        }\n\n       \n      if (ent->fts_level == FTS_ROOTLEVEL)\n        {\n           \n          if (dot_or_dotdot (last_component (ent->fts_accpath)))\n            {\n              error (0, 0,\n                     _(\"refusing to remove %s or %s directory: skipping %s\"),\n                     quoteaf_n (0, \".\"), quoteaf_n (1, \"..\"),\n                     quoteaf_n (2, ent->fts_path));\n              fts_skip_tree (fts, ent);\n              return RM_ERROR;\n            }\n\n           \n          if (ROOT_DEV_INO_CHECK (x->root_dev_ino, ent->fts_statp))\n            {\n              ROOT_DEV_INO_WARN (ent->fts_path);\n              fts_skip_tree (fts, ent);\n              return RM_ERROR;\n            }\n\n           \n          if (x->preserve_all_root)\n            {\n              bool failed = false;\n              char *parent = file_name_concat (ent->fts_accpath, \"..\", nullptr);\n              struct stat statbuf;\n\n              if (!parent || lstat (parent, &statbuf))\n                {\n                  error (0, 0,\n                         _(\"failed to stat %s: skipping %s\"),\n                         quoteaf_n (0, parent),\n                         quoteaf_n (1, ent->fts_accpath));\n                  failed = true;\n                }\n\n              free (parent);\n\n              if (failed || fts->fts_dev != statbuf.st_dev)\n                {\n                  if (! failed)\n                    {\n                      error (0, 0,\n                             _(\"skipping %s, since it's on a different device\"),\n                             quoteaf (ent->fts_path));\n                      error (0, 0, _(\"and --preserve-root=all is in effect\"));\n                    }\n                  fts_skip_tree (fts, ent);\n                  return RM_ERROR;\n                }\n            }\n        }\n\n      {\n        enum RM_status s = prompt (fts, ent, true  , x,\n                                   PA_DESCEND_INTO_DIR, &dir_status);\n\n        if (s == RM_USER_ACCEPTED && dir_status == DS_EMPTY)\n          {\n             \n            s = excise (fts, ent, x, true);\n            if (s == RM_OK)\n              fts_skip_tree (fts, ent);\n          }\n\n        if (! (s == RM_OK || s == RM_USER_ACCEPTED))\n          {\n            mark_ancestor_dirs (ent);\n            fts_skip_tree (fts, ent);\n          }\n\n        return s;\n      }\n\n    case FTS_F:\t\t\t \n    case FTS_NS:\t\t \n    case FTS_SL:\t\t \n    case FTS_SLNONE:\t\t \n    case FTS_DP:\t\t \n    case FTS_DNR:\t\t \n    case FTS_NSOK:\t\t \n    case FTS_DEFAULT:\t\t \n      {\n         \n        if (ent->fts_info == FTS_DP\n            && x->one_file_system\n            && FTS_ROOTLEVEL < ent->fts_level\n            && ent->fts_statp->st_dev != fts->fts_dev)\n          {\n            mark_ancestor_dirs (ent);\n            error (0, 0, _(\"skipping %s, since it's on a different device\"),\n                   quoteaf (ent->fts_path));\n            return RM_ERROR;\n          }\n\n        bool is_dir = ent->fts_info == FTS_DP || ent->fts_info == FTS_DNR;\n        enum RM_status s = prompt (fts, ent, is_dir, x, PA_REMOVE_DIR,\n                                   &dir_status);\n        if (! (s == RM_OK || s == RM_USER_ACCEPTED))\n          return s;\n        return excise (fts, ent, x, is_dir);\n      }\n\n    case FTS_DC:\t\t \n      emit_cycle_warning (ent->fts_path);\n      fts_skip_tree (fts, ent);\n      return RM_ERROR;\n\n    case FTS_ERR:\n       \n      error (0, ent->fts_errno, _(\"traversal failed: %s\"),\n             quotef (ent->fts_path));\n      fts_skip_tree (fts, ent);\n      return RM_ERROR;\n\n    default:\n      error (0, 0, _(\"unexpected failure: fts_info=%d: %s\\n\"\n                     \"please report to %s\"),\n             ent->fts_info,\n             quotef (ent->fts_path),\n             PACKAGE_BUGREPORT);\n      abort ();\n    }\n}\n\n \nenum RM_status\nrm (char *const *file, struct rm_options const *x)\n{\n  enum RM_status rm_status = RM_OK;\n\n  if (*file)\n    {\n      int bit_flags = (FTS_CWDFD\n                       | FTS_NOSTAT\n                       | FTS_PHYSICAL);\n\n      if (x->one_file_system)\n        bit_flags |= FTS_XDEV;\n\n      FTS *fts = xfts_open (file, bit_flags, nullptr);\n\n      while (true)\n        {\n          FTSENT *ent;\n\n          ent = fts_read (fts);\n          if (ent == nullptr)\n            {\n              if (errno != 0)\n                {\n                  error (0, errno, _(\"fts_read failed\"));\n                  rm_status = RM_ERROR;\n                }\n              break;\n            }\n\n          enum RM_status s = rm_fts (fts, ent, x);\n\n          affirm (VALID_STATUS (s));\n          UPDATE_STATUS (rm_status, s);\n        }\n\n      if (fts_close (fts) != 0)\n        {\n          error (0, errno, _(\"fts_close failed\"));\n          rm_status = RM_ERROR;\n        }\n    }\n\n  return rm_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}