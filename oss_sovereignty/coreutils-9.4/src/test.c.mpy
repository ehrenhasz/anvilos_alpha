{
  "module_name": "test.c",
  "hash_id": "aa4ffa076e7dc371224e0715ac4bf767d117e91bf77f3485a49a1e1c5f2566d3",
  "original_prompt": "Ingested from coreutils-9.4/src/test.c",
  "human_readable_source": " \n\n \n\n \n\n \n#if (__GNUC__ == 4 && 6 <= __GNUC_MINOR__) || 4 < __GNUC__\n# pragma GCC diagnostic ignored \"-Wsuggest-attribute=pure\"\n#endif\n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#define TEST_STANDALONE 1\n\n#ifndef LBRACKET\n# define LBRACKET 0\n#endif\n\n \n#if LBRACKET\n# define PROGRAM_NAME \"[\"\n#else\n# define PROGRAM_NAME \"test\"\n#endif\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"quote.h\"\n#include \"stat-time.h\"\n#include \"strnumcmp.h\"\n\n#include <stdarg.h>\n#include \"verror.h\"\n\n#if HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n\n \nenum { TEST_TRUE, TEST_FALSE, TEST_FAILURE };\n\n#if defined TEST_STANDALONE\n# define test_exit(val) exit (val)\n# define test_main_return(val) return val\n#else\n   static jmp_buf test_exit_buf;\n   static int test_error_return = 0;\n# define test_exit(val) test_error_return = val, longjmp (test_exit_buf, 1)\n# define test_main_return(val) test_exit (val)\n#endif  \n\nstatic int pos;\t\t \nstatic int argc;\t \nstatic char **argv;\t \n\nstatic bool unary_operator (void);\nstatic bool binary_operator (bool);\nstatic bool two_arguments (void);\nstatic bool three_arguments (void);\nstatic bool posixtest (int);\n\nstatic bool expr (void);\nstatic bool term (void);\nstatic bool and (void);\nstatic bool or (void);\n\nstatic void beyond (void);\n\nATTRIBUTE_FORMAT ((printf, 1, 2))\nstatic _Noreturn void\ntest_syntax_error (char const *format, ...)\n{\n  va_list ap;\n  va_start (ap, format);\n  verror (0, 0, format, ap);\n  test_exit (TEST_FAILURE);\n}\n\n \n\nstatic void\nadvance (bool f)\n{\n  ++pos;\n\n  if (f && pos >= argc)\n    beyond ();\n}\n\nstatic void\nunary_advance (void)\n{\n  advance (true);\n  ++pos;\n}\n\n \nstatic _Noreturn void\nbeyond (void)\n{\n  test_syntax_error (_(\"missing argument after %s\"), quote (argv[argc - 1]));\n}\n\n \nstatic char const *\nfind_int (char const *string)\n{\n  char const *p;\n  char const *number_start;\n\n  for (p = string; isblank (to_uchar (*p)); p++)\n    continue;\n\n  if (*p == '+')\n    {\n      p++;\n      number_start = p;\n    }\n  else\n    {\n      number_start = p;\n      p += (*p == '-');\n    }\n\n  if (ISDIGIT (*p++))\n    {\n      while (ISDIGIT (*p))\n        p++;\n      while (isblank (to_uchar (*p)))\n        p++;\n      if (!*p)\n        return number_start;\n    }\n\n  test_syntax_error (_(\"invalid integer %s\"), quote (string));\n}\n\n \nstatic bool\nget_mtime (char const *filename, struct timespec *mtime)\n{\n  struct stat finfo;\n  bool ok = (stat (filename, &finfo) == 0);\n  if (ok)\n    *mtime = get_stat_mtime (&finfo);\n  return ok;\n}\n\n \nstatic bool\nbinop (char const *s)\n{\n  return ((STREQ (s,   \"=\")) || (STREQ (s,  \"!=\")) || (STREQ (s, \"==\")) ||\n          (STREQ (s,   \"-nt\")) ||\n          (STREQ (s, \"-ot\")) || (STREQ (s, \"-ef\")) || (STREQ (s, \"-eq\")) ||\n          (STREQ (s, \"-ne\")) || (STREQ (s, \"-lt\")) || (STREQ (s, \"-le\")) ||\n          (STREQ (s, \"-gt\")) || (STREQ (s, \"-ge\")));\n}\n\n \nstatic bool\nterm (void)\n{\n  bool value;\n  bool negated = false;\n\n   \n  while (pos < argc && argv[pos][0] == '!' && argv[pos][1] == '\\0')\n    {\n      advance (true);\n      negated = !negated;\n    }\n\n  if (pos >= argc)\n    beyond ();\n\n   \n  if (argv[pos][0] == '(' && argv[pos][1] == '\\0')\n    {\n      int nargs;\n\n      advance (true);\n\n      for (nargs = 1;\n           pos + nargs < argc && ! STREQ (argv[pos + nargs], \")\");\n           nargs++)\n        if (nargs == 4)\n          {\n            nargs = argc - pos;\n            break;\n          }\n\n      value = posixtest (nargs);\n      if (argv[pos] == 0)\n        test_syntax_error (_(\"%s expected\"), quote (\")\"));\n      else\n        if (argv[pos][0] != ')' || argv[pos][1])\n          test_syntax_error (_(\"%s expected, found %s\"),\n                             quote_n (0, \")\"), quote_n (1, argv[pos]));\n      advance (false);\n    }\n\n   \n  else if (4 <= argc - pos && STREQ (argv[pos], \"-l\") && binop (argv[pos + 2]))\n    value = binary_operator (true);\n  else if (3 <= argc - pos && binop (argv[pos + 1]))\n    value = binary_operator (false);\n\n   \n  else if (argv[pos][0] == '-' && argv[pos][1] && argv[pos][2] == '\\0')\n    value = unary_operator ();\n  else\n    {\n      value = (argv[pos][0] != '\\0');\n      advance (false);\n    }\n\n  return negated ^ value;\n}\n\nstatic bool\nbinary_operator (bool l_is_l)\n{\n  int op;\n  struct stat stat_buf, stat_spare;\n   \n  bool r_is_l;\n\n  if (l_is_l)\n    advance (false);\n  op = pos + 1;\n\n  if ((op < argc - 2) && STREQ (argv[op + 1], \"-l\"))\n    {\n      r_is_l = true;\n      advance (false);\n    }\n  else\n    r_is_l = false;\n\n  if (argv[op][0] == '-')\n    {\n       \n      if ((((argv[op][1] == 'l' || argv[op][1] == 'g')\n            && (argv[op][2] == 'e' || argv[op][2] == 't'))\n           || (argv[op][1] == 'e' && argv[op][2] == 'q')\n           || (argv[op][1] == 'n' && argv[op][2] == 'e'))\n          && !argv[op][3])\n        {\n          char lbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n          char rbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n          char const *l = (l_is_l\n                           ? umaxtostr (strlen (argv[op - 1]), lbuf)\n                           : find_int (argv[op - 1]));\n          char const *r = (r_is_l\n                           ? umaxtostr (strlen (argv[op + 2]), rbuf)\n                           : find_int (argv[op + 1]));\n          int cmp = strintcmp (l, r);\n          bool xe_operator = (argv[op][2] == 'e');\n          pos += 3;\n          return (argv[op][1] == 'l' ? cmp < xe_operator\n                  : argv[op][1] == 'g' ? cmp > - xe_operator\n                  : (cmp != 0) == xe_operator);\n        }\n\n      switch (argv[op][1])\n        {\n        default:\n          break;\n\n        case 'n':\n          if (argv[op][2] == 't' && !argv[op][3])\n            {\n               \n              struct timespec lt, rt;\n              bool le, re;\n              pos += 3;\n              if (l_is_l || r_is_l)\n                test_syntax_error (_(\"-nt does not accept -l\"));\n              le = get_mtime (argv[op - 1], &lt);\n              re = get_mtime (argv[op + 1], &rt);\n              return le && (!re || timespec_cmp (lt, rt) > 0);\n            }\n          break;\n\n        case 'e':\n          if (argv[op][2] == 'f' && !argv[op][3])\n            {\n               \n              pos += 3;\n              if (l_is_l || r_is_l)\n                test_syntax_error (_(\"-ef does not accept -l\"));\n              return (stat (argv[op - 1], &stat_buf) == 0\n                      && stat (argv[op + 1], &stat_spare) == 0\n                      && stat_buf.st_dev == stat_spare.st_dev\n                      && stat_buf.st_ino == stat_spare.st_ino);\n            }\n          break;\n\n        case 'o':\n          if ('t' == argv[op][2] && '\\000' == argv[op][3])\n            {\n               \n              struct timespec lt, rt;\n              bool le, re;\n              pos += 3;\n              if (l_is_l || r_is_l)\n                test_syntax_error (_(\"-ot does not accept -l\"));\n              le = get_mtime (argv[op - 1], &lt);\n              re = get_mtime (argv[op + 1], &rt);\n              return re && (!le || timespec_cmp (lt, rt) < 0);\n            }\n          break;\n        }\n\n       \n      test_syntax_error (_(\"%s: unknown binary operator\"), quote (argv[op]));\n    }\n\n  if (argv[op][0] == '='\n      && (!argv[op][1] || ((argv[op][1] == '=') && !argv[op][2])))\n    {\n      bool value = STREQ (argv[pos], argv[pos + 2]);\n      pos += 3;\n      return value;\n    }\n\n  if (STREQ (argv[op], \"!=\"))\n    {\n      bool value = !STREQ (argv[pos], argv[pos + 2]);\n      pos += 3;\n      return value;\n    }\n\n   \n  affirm (false);\n}\n\nstatic bool\nunary_operator (void)\n{\n  struct stat stat_buf;\n\n  switch (argv[pos][1])\n    {\n    default:\n      test_syntax_error (_(\"%s: unary operator expected\"), quote (argv[pos]));\n\n       \n\n    case 'e':\t\t\t \n      unary_advance ();\n      return stat (argv[pos - 1], &stat_buf) == 0;\n\n    case 'r':\t\t\t \n      unary_advance ();\n      return euidaccess (argv[pos - 1], R_OK) == 0;\n\n    case 'w':\t\t\t \n      unary_advance ();\n      return euidaccess (argv[pos - 1], W_OK) == 0;\n\n    case 'x':\t\t\t \n      unary_advance ();\n      return euidaccess (argv[pos - 1], X_OK) == 0;\n\n    case 'N':   \n      {\n        unary_advance ();\n        if (stat (argv[pos - 1], &stat_buf) != 0)\n          return false;\n        struct timespec atime = get_stat_atime (&stat_buf);\n        struct timespec mtime = get_stat_mtime (&stat_buf);\n        return (timespec_cmp (mtime, atime) > 0);\n      }\n\n    case 'O':\t\t\t \n      {\n        unary_advance ();\n        if (stat (argv[pos - 1], &stat_buf) != 0)\n          return false;\n        errno = 0;\n        uid_t euid = geteuid ();\n        uid_t NO_UID = -1;\n        return ! (euid == NO_UID && errno) && euid == stat_buf.st_uid;\n      }\n\n    case 'G':\t\t\t \n      {\n        unary_advance ();\n        if (stat (argv[pos - 1], &stat_buf) != 0)\n          return false;\n        errno = 0;\n        gid_t egid = getegid ();\n        gid_t NO_GID = -1;\n        return ! (egid == NO_GID && errno) && egid == stat_buf.st_gid;\n      }\n\n    case 'f':\t\t\t \n      unary_advance ();\n       \n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && S_ISREG (stat_buf.st_mode));\n\n    case 'd':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && S_ISDIR (stat_buf.st_mode));\n\n    case 's':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && 0 < stat_buf.st_size);\n\n    case 'S':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && S_ISSOCK (stat_buf.st_mode));\n\n    case 'c':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && S_ISCHR (stat_buf.st_mode));\n\n    case 'b':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && S_ISBLK (stat_buf.st_mode));\n\n    case 'p':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && S_ISFIFO (stat_buf.st_mode));\n\n    case 'L':\t\t\t \n       \n\n    case 'h':\t\t\t \n      unary_advance ();\n      return (lstat (argv[pos - 1], &stat_buf) == 0\n              && S_ISLNK (stat_buf.st_mode));\n\n    case 'u':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && (stat_buf.st_mode & S_ISUID));\n\n    case 'g':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && (stat_buf.st_mode & S_ISGID));\n\n    case 'k':\t\t\t \n      unary_advance ();\n      return (stat (argv[pos - 1], &stat_buf) == 0\n              && (stat_buf.st_mode & S_ISVTX));\n\n    case 't':\t\t\t \n      {\n        long int fd;\n        char const *arg;\n        unary_advance ();\n        arg = find_int (argv[pos - 1]);\n        errno = 0;\n        fd = strtol (arg, nullptr, 10);\n        return (errno != ERANGE && 0 <= fd && fd <= INT_MAX && isatty (fd));\n      }\n\n    case 'n':\t\t\t \n      unary_advance ();\n      return argv[pos - 1][0] != 0;\n\n    case 'z':\t\t\t \n      unary_advance ();\n      return argv[pos - 1][0] == '\\0';\n    }\n}\n\n \nstatic bool\nand (void)\n{\n  bool value = true;\n\n  while (true)\n    {\n      value &= term ();\n      if (! (pos < argc && STREQ (argv[pos], \"-a\")))\n        return value;\n      advance (false);\n    }\n}\n\n \nstatic bool\nor (void)\n{\n  bool value = false;\n\n  while (true)\n    {\n      value |= and ();\n      if (! (pos < argc && STREQ (argv[pos], \"-o\")))\n        return value;\n      advance (false);\n    }\n}\n\n \nstatic bool\nexpr (void)\n{\n  if (pos >= argc)\n    beyond ();\n\n  return or ();\t\t \n}\n\nstatic bool\none_argument (void)\n{\n  return argv[pos++][0] != '\\0';\n}\n\nstatic bool\ntwo_arguments (void)\n{\n  bool value;\n\n  if (STREQ (argv[pos], \"!\"))\n    {\n      advance (false);\n      value = ! one_argument ();\n    }\n  else if (argv[pos][0] == '-'\n           && argv[pos][1] != '\\0'\n           && argv[pos][2] == '\\0')\n    {\n      value = unary_operator ();\n    }\n  else\n    beyond ();\n  return (value);\n}\n\nstatic bool\nthree_arguments (void)\n{\n  bool value;\n\n  if (binop (argv[pos + 1]))\n    value = binary_operator (false);\n  else if (STREQ (argv[pos], \"!\"))\n    {\n      advance (true);\n      value = !two_arguments ();\n    }\n  else if (STREQ (argv[pos], \"(\") && STREQ (argv[pos + 2], \")\"))\n    {\n      advance (false);\n      value = one_argument ();\n      advance (false);\n    }\n  else if (STREQ (argv[pos + 1], \"-a\") || STREQ (argv[pos + 1], \"-o\"))\n    value = expr ();\n  else\n    test_syntax_error (_(\"%s: binary operator expected\"),\n                       quote (argv[pos + 1]));\n  return (value);\n}\n\n \nstatic bool\nposixtest (int nargs)\n{\n  bool value;\n\n  switch (nargs)\n    {\n      case 1:\n        value = one_argument ();\n        break;\n\n      case 2:\n        value = two_arguments ();\n        break;\n\n      case 3:\n        value = three_arguments ();\n        break;\n\n      case 4:\n        if (STREQ (argv[pos], \"!\"))\n          {\n            advance (true);\n            value = !three_arguments ();\n            break;\n          }\n        if (STREQ (argv[pos], \"(\") && STREQ (argv[pos + 3], \")\"))\n          {\n            advance (false);\n            value = two_arguments ();\n            advance (false);\n            break;\n          }\n        FALLTHROUGH;\n      case 5:\n      default:\n        affirm (0 < nargs);\n        value = expr ();\n    }\n\n  return (value);\n}\n\n#if defined TEST_STANDALONE\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      fputs (_(\"\\\nUsage: test EXPRESSION\\n\\\n  or:  test\\n\\\n  or:  [ EXPRESSION ]\\n\\\n  or:  [ ]\\n\\\n  or:  [ OPTION\\n\\\n\"), stdout);\n      fputs (_(\"\\\nExit with the status determined by EXPRESSION.\\n\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nAn omitted EXPRESSION defaults to false.  Otherwise,\\n\\\nEXPRESSION is true or false and sets exit status.  It is one of:\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  ( EXPRESSION )               EXPRESSION is true\\n\\\n  ! EXPRESSION                 EXPRESSION is false\\n\\\n  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\\n\\\n  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -n STRING            the length of STRING is nonzero\\n\\\n  STRING               equivalent to -n STRING\\n\\\n  -z STRING            the length of STRING is zero\\n\\\n  STRING1 = STRING2    the strings are equal\\n\\\n  STRING1 != STRING2   the strings are not equal\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\\n\\\n  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\\n\\\n  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\\n\\\n  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\\n\\\n  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\\n\\\n  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\\n\\\n  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\\n\\\n  FILE1 -ot FILE2   FILE1 is older than FILE2\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -b FILE     FILE exists and is block special\\n\\\n  -c FILE     FILE exists and is character special\\n\\\n  -d FILE     FILE exists and is a directory\\n\\\n  -e FILE     FILE exists\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f FILE     FILE exists and is a regular file\\n\\\n  -g FILE     FILE exists and is set-group-ID\\n\\\n  -G FILE     FILE exists and is owned by the effective group ID\\n\\\n  -h FILE     FILE exists and is a symbolic link (same as -L)\\n\\\n  -k FILE     FILE exists and has its sticky bit set\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -L FILE     FILE exists and is a symbolic link (same as -h)\\n\\\n  -N FILE     FILE exists and has been modified since it was last read\\n\\\n  -O FILE     FILE exists and is owned by the effective user ID\\n\\\n  -p FILE     FILE exists and is a named pipe\\n\\\n  -r FILE     FILE exists and the user has read access\\n\\\n  -s FILE     FILE exists and has a size greater than zero\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -S FILE     FILE exists and is a socket\\n\\\n  -t FD       file descriptor FD is opened on a terminal\\n\\\n  -u FILE     FILE exists and its set-user-ID bit is set\\n\\\n  -w FILE     FILE exists and the user has write access\\n\\\n  -x FILE     FILE exists and the user has execute (or search) access\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nExcept for -h and -L, all FILE-related tests dereference symbolic links.\\n\\\nBeware that parentheses need to be escaped (e.g., by backslashes) for shells.\\n\\\nINTEGER may also be -l STRING, which evaluates to the length of STRING.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nNOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\\n\\\nEXPR2' or 'test EXPR1 || test EXPR2' instead.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nNOTE: [ honors the --help and --version options, but test does not.\\n\\\ntest treats each of those as it treats any other nonempty STRING.\\n\\\n\"), stdout);\n      printf (USAGE_BUILTIN_WARNING, _(\"test and/or [\"));\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n#endif  \n\n#if !defined TEST_STANDALONE\n# define main test_command\n#endif\n\n#define AUTHORS \\\n  proper_name (\"Kevin Braunsdorf\"), \\\n  proper_name (\"Matthew Bradburn\")\n\n \nint\nmain (int margc, char **margv)\n{\n  bool value;\n\n#if !defined TEST_STANDALONE\n  int code;\n\n  code = setjmp (test_exit_buf);\n\n  if (code)\n    return (test_error_return);\n#else  \n  initialize_main (&margc, &margv);\n  set_program_name (margv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (TEST_FAILURE);\n  atexit (close_stdout);\n#endif  \n\n  argv = margv;\n\n  if (LBRACKET)\n    {\n       \n      if (margc == 2)\n        {\n          if (STREQ (margv[1], \"--help\"))\n            usage (EXIT_SUCCESS);\n\n          if (STREQ (margv[1], \"--version\"))\n            {\n              version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version, AUTHORS,\n                           (char *) nullptr);\n              test_main_return (EXIT_SUCCESS);\n            }\n        }\n      if (margc < 2 || !STREQ (margv[margc - 1], \"]\"))\n        test_syntax_error (_(\"missing %s\"), quote (\"]\"));\n\n      --margc;\n    }\n\n  argc = margc;\n  pos = 1;\n\n  if (pos >= argc)\n    test_main_return (TEST_FALSE);\n\n  value = posixtest (argc - 1);\n\n  if (pos != argc)\n    test_syntax_error (_(\"extra argument %s\"), quote (argv[pos]));\n\n  test_main_return (value ? TEST_TRUE : TEST_FALSE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}