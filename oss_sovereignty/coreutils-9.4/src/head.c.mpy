{
  "module_name": "head.c",
  "hash_id": "ae5a3bcb5555ba921e233214f91559ef89d4ccaab638d9aed5c1ad256769d070",
  "original_prompt": "Ingested from coreutils-9.4/src/head.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n\n#include \"assure.h\"\n#include \"full-read.h\"\n#include \"quote.h\"\n#include \"safe-read.h\"\n#include \"stat-size.h\"\n#include \"xbinary-io.h\"\n#include \"xdectoint.h\"\n\n \n#define PROGRAM_NAME \"head\"\n\n#define AUTHORS \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\n \n#define DEFAULT_NUMBER 10\n\n \nstatic bool presume_input_pipe;\n\n \nstatic bool print_headers;\n\n \nstatic char line_end;\n\n \nenum header_mode\n{\n  multiple_files, always, never\n};\n\n \nstatic bool have_read_stdin;\n\nenum Copy_fd_status\n  {\n    COPY_FD_OK = 0,\n    COPY_FD_READ_ERROR,\n    COPY_FD_UNEXPECTED_EOF\n  };\n\n \nenum\n{\n  PRESUME_INPUT_PIPE_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const long_options[] =\n{\n  {\"bytes\", required_argument, nullptr, 'c'},\n  {\"lines\", required_argument, nullptr, 'n'},\n  {\"-presume-input-pipe\", no_argument, nullptr,\n   PRESUME_INPUT_PIPE_OPTION},  \n  {\"quiet\", no_argument, nullptr, 'q'},\n  {\"silent\", no_argument, nullptr, 'q'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      printf (_(\"\\\nPrint the first %d lines of each FILE to standard output.\\n\\\nWith more than one FILE, precede each with a header giving the file name.\\n\\\n\"), DEFAULT_NUMBER);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      printf (_(\"\\\n  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\\n\\\n                             with the leading '-', print all but the last\\n\\\n                             NUM bytes of each file\\n\\\n  -n, --lines=[-]NUM       print the first NUM lines instead of the first %d;\\n\\\n                             with the leading '-', print all but the last\\n\\\n                             NUM lines of each file\\n\\\n\"), DEFAULT_NUMBER);\n      fputs (_(\"\\\n  -q, --quiet, --silent    never print headers giving file names\\n\\\n  -v, --verbose            always print headers giving file names\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nNUM may have a multiplier suffix:\\n\\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\n\\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\n\\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic void\ndiagnose_copy_fd_failure (enum Copy_fd_status err, char const *filename)\n{\n  switch (err)\n    {\n    case COPY_FD_READ_ERROR:\n      error (0, errno, _(\"error reading %s\"), quoteaf (filename));\n      break;\n    case COPY_FD_UNEXPECTED_EOF:\n      error (0, errno, _(\"%s: file has shrunk too much\"), quotef (filename));\n      break;\n    default:\n      affirm (false);\n    }\n}\n\nstatic void\nwrite_header (char const *filename)\n{\n  static bool first_file = true;\n\n  printf (\"%s==> %s <==\\n\", (first_file ? \"\" : \"\\n\"), filename);\n  first_file = false;\n}\n\n/* Write N_BYTES from BUFFER to stdout.\n   Exit immediately on error with a single diagnostic.  */\n\nstatic void\nxwrite_stdout (char const *buffer, size_t n_bytes)\n{\n  if (n_bytes > 0 && fwrite (buffer, 1, n_bytes, stdout) < n_bytes)\n    {\n      clearerr (stdout); /* To avoid redundant close_stdout diagnostic.  */\n      fpurge (stdout);\n      error (EXIT_FAILURE, errno, _(\"error writing %s\"),\n             quoteaf (\"standard output\"));\n    }\n}\n\n/* Copy no more than N_BYTES from file descriptor SRC_FD to stdout.\n   Return an appropriate indication of success or read failure.  */\n\nstatic enum Copy_fd_status\ncopy_fd (int src_fd, uintmax_t n_bytes)\n{\n  char buf[BUFSIZ];\n  const size_t buf_size = sizeof (buf);\n\n  /* Copy the file contents.  */\n  while (0 < n_bytes)\n    {\n      size_t n_to_read = MIN (buf_size, n_bytes);\n      size_t n_read = safe_read (src_fd, buf, n_to_read);\n      if (n_read == SAFE_READ_ERROR)\n        return COPY_FD_READ_ERROR;\n\n      n_bytes -= n_read;\n\n      if (n_read == 0 && n_bytes != 0)\n        return COPY_FD_UNEXPECTED_EOF;\n\n      xwrite_stdout (buf, n_read);\n    }\n\n  return COPY_FD_OK;\n}\n\n/* Call lseek (FD, OFFSET, WHENCE), where file descriptor FD\n   corresponds to the file FILENAME.  WHENCE must be SEEK_SET or\n   SEEK_CUR.  Return the resulting offset.  Give a diagnostic and\n   return -1 if lseek fails.  */\n\nstatic off_t\nelseek (int fd, off_t offset, int whence, char const *filename)\n{\n  off_t new_offset = lseek (fd, offset, whence);\n  char buf[INT_BUFSIZE_BOUND (offset)];\n\n  if (new_offset < 0)\n    error (0, errno,\n           _(whence == SEEK_SET\n             ? N_(\"%s: cannot seek to offset %s\")\n             : N_(\"%s: cannot seek to relative offset %s\")),\n           quotef (filename),\n           offtostr (offset, buf));\n\n  return new_offset;\n}\n\n/* For an input file with name FILENAME and descriptor FD,\n   output all but the last N_ELIDE_0 bytes.\n   If CURRENT_POS is nonnegative, assume that the input file is\n   positioned at CURRENT_POS and that it should be repositioned to\n   just before the elided bytes before returning.\n   Return true upon success.\n   Give a diagnostic and return false upon error.  */\nstatic bool\nelide_tail_bytes_pipe (char const *filename, int fd, uintmax_t n_elide_0,\n                       off_t current_pos)\n{\n  size_t n_elide = n_elide_0;\n  uintmax_t desired_pos = current_pos;\n  bool ok = true;\n\n#ifndef HEAD_TAIL_PIPE_READ_BUFSIZE\n# define HEAD_TAIL_PIPE_READ_BUFSIZE BUFSIZ\n#endif\n#define READ_BUFSIZE HEAD_TAIL_PIPE_READ_BUFSIZE\n\n  /* If we're eliding no more than this many bytes, then it's ok to allocate\n     more memory in order to use a more time-efficient algorithm.\n     FIXME: use a fraction of available memory instead, as in sort.\n     FIXME: is this even worthwhile?  */\n#ifndef HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD\n# define HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD 1024 * 1024\n#endif\n\n#if HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD < 2 * READ_BUFSIZE\n  \"HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD must be at least 2 * READ_BUFSIZE\"\n#endif\n\n  if (SIZE_MAX < n_elide_0 + READ_BUFSIZE)\n    {\n      char umax_buf[INT_BUFSIZE_BOUND (n_elide_0)];\n      error (EXIT_FAILURE, 0, _(\"%s: number of bytes is too large\"),\n             umaxtostr (n_elide_0, umax_buf));\n    }\n\n  /* Two cases to consider...\n     1) n_elide is small enough that we can afford to double-buffer:\n        allocate 2 * (READ_BUFSIZE + n_elide) bytes\n     2) n_elide is too big for that, so we allocate only\n        (READ_BUFSIZE + n_elide) bytes\n\n     FIXME: profile, to see if double-buffering is worthwhile\n\n     CAUTION: do not fail (out of memory) when asked to elide\n     a ridiculous amount, but when given only a small input.  */\n\n  if (n_elide <= HEAD_TAIL_PIPE_BYTECOUNT_THRESHOLD)\n    {\n      bool first = true;\n      bool eof = false;\n      size_t n_to_read = READ_BUFSIZE + n_elide;\n      bool i;\n      char *b[2];\n      b[0] = xnmalloc (2, n_to_read);\n      b[1] = b[0] + n_to_read;\n\n      for (i = false; ! eof ; i = !i)\n        {\n          size_t n_read = full_read (fd, b[i], n_to_read);\n          size_t delta = 0;\n          if (n_read < n_to_read)\n            {\n              if (errno != 0)\n                {\n                  error (0, errno, _(\"error reading %s\"), quoteaf (filename));\n                  ok = false;\n                  break;\n                }\n\n              /* reached EOF */\n              if (n_read <= n_elide)\n                {\n                  if (first)\n                    {\n                      /* The input is no larger than the number of bytes\n                         to elide.  So there's nothing to output, and\n                         we're done.  */\n                    }\n                  else\n                    {\n                      delta = n_elide - n_read;\n                    }\n                }\n              eof = true;\n            }\n\n          /* Output any (but maybe just part of the) elided data from\n             the previous round.  */\n          if (! first)\n            {\n              desired_pos += n_elide - delta;\n              xwrite_stdout (b[!i] + READ_BUFSIZE, n_elide - delta);\n            }\n          first = false;\n\n          if (n_elide < n_read)\n            {\n              desired_pos += n_read - n_elide;\n              xwrite_stdout (b[i], n_read - n_elide);\n            }\n        }\n\n      free (b[0]);\n    }\n  else\n    {\n      /* Read blocks of size READ_BUFSIZE, until we've read at least n_elide\n         bytes.  Then, for each new buffer we read, also write an old one.  */\n\n      bool eof = false;\n      size_t n_read;\n      bool buffered_enough;\n      size_t i, i_next;\n      char **b = nullptr;\n      /* Round n_elide up to a multiple of READ_BUFSIZE.  */\n      size_t rem = READ_BUFSIZE - (n_elide % READ_BUFSIZE);\n      size_t n_elide_round = n_elide + rem;\n      size_t n_bufs = n_elide_round / READ_BUFSIZE + 1;\n      size_t n_alloc = 0;\n      size_t n_array_alloc = 0;\n\n      buffered_enough = false;\n      for (i = 0, i_next = 1; !eof; i = i_next, i_next = (i_next + 1) % n_bufs)\n        {\n          if (n_array_alloc == i)\n            {\n              /* reallocate between 16 and n_bufs entries.  */\n              if (n_array_alloc == 0)\n                n_array_alloc = MIN (n_bufs, 16);\n              else if (n_array_alloc <= n_bufs / 2)\n                n_array_alloc *= 2;\n              else\n                n_array_alloc = n_bufs;\n              b = xnrealloc (b, n_array_alloc, sizeof *b);\n            }\n\n          if (! buffered_enough)\n            {\n              b[i] = xmalloc (READ_BUFSIZE);\n              n_alloc = i + 1;\n            }\n          n_read = full_read (fd, b[i], READ_BUFSIZE);\n          if (n_read < READ_BUFSIZE)\n            {\n              if (errno != 0)\n                {\n                  error (0, errno, _(\"error reading %s\"), quoteaf (filename));\n                  ok = false;\n                  goto free_mem;\n                }\n              eof = true;\n            }\n\n          if (i + 1 == n_bufs)\n            buffered_enough = true;\n\n          if (buffered_enough)\n            {\n              desired_pos += n_read;\n              xwrite_stdout (b[i_next], n_read);\n            }\n        }\n\n      /* Output any remainder: rem bytes from b[i] + n_read.  */\n      if (rem)\n        {\n          if (buffered_enough)\n            {\n              size_t n_bytes_left_in_b_i = READ_BUFSIZE - n_read;\n              desired_pos += rem;\n              if (rem < n_bytes_left_in_b_i)\n                {\n                  xwrite_stdout (b[i] + n_read, rem);\n                }\n              else\n                {\n                  xwrite_stdout (b[i] + n_read, n_bytes_left_in_b_i);\n                  xwrite_stdout (b[i_next], rem - n_bytes_left_in_b_i);\n                }\n            }\n          else if (i + 1 == n_bufs)\n            {\n              /* This happens when n_elide < file_size < n_elide_round.\n\n                 |READ_BUF.|\n                 |                      |  rem |\n                 |---------!---------!---------!---------|\n                 |---- n_elide ---------|\n                 |                      | x |\n                 |                   |y |\n                 |---- file size -----------|\n                 |                   |n_read|\n                 |---- n_elide_round ----------|\n               */\n              size_t y = READ_BUFSIZE - rem;\n              size_t x = n_read - y;\n              desired_pos += x;\n              xwrite_stdout (b[i_next], x);\n            }\n        }\n\n    free_mem:\n      for (i = 0; i < n_alloc; i++)\n        free (b[i]);\n      free (b);\n    }\n\n  if (0 <= current_pos && elseek (fd, desired_pos, SEEK_SET, filename) < 0)\n    ok = false;\n  return ok;\n}\n\n/* For the file FILENAME with descriptor FD, output all but the last N_ELIDE\n   bytes.  If SIZE is nonnegative, this is a regular file positioned\n   at CURRENT_POS with SIZE bytes.  Return true on success.\n   Give a diagnostic and return false upon error.  */\n\n/* NOTE: if the input file shrinks by more than N_ELIDE bytes between\n   the length determination and the actual reading, then head fails.  */\n\nstatic bool\nelide_tail_bytes_file (char const *filename, int fd, uintmax_t n_elide,\n                       struct stat const *st, off_t current_pos)\n{\n  off_t size = st->st_size;\n  if (presume_input_pipe || current_pos < 0 || size <= ST_BLKSIZE (*st))\n    return elide_tail_bytes_pipe (filename, fd, n_elide, current_pos);\n  else\n    {\n      /* Be careful here.  The current position may actually be\n         beyond the end of the file.  */\n      off_t diff = size - current_pos;\n      off_t bytes_remaining = diff < 0 ? 0 : diff;\n\n      if (bytes_remaining <= n_elide)\n        return true;\n\n      enum Copy_fd_status err = copy_fd (fd, bytes_remaining - n_elide);\n      if (err == COPY_FD_OK)\n        return true;\n\n      diagnose_copy_fd_failure (err, filename);\n      return false;\n    }\n}\n\n/* For an input file with name FILENAME and descriptor FD,\n   output all but the last N_ELIDE_0 bytes.\n   If CURRENT_POS is nonnegative, the input file is positioned there\n   and should be repositioned to just before the elided bytes.\n   Buffer the specified number of lines as a linked list of LBUFFERs,\n   adding them as needed.  Return true if successful.  */\n\nstatic bool\nelide_tail_lines_pipe (char const *filename, int fd, uintmax_t n_elide,\n                       off_t current_pos)\n{\n  struct linebuffer\n  {\n    char buffer[BUFSIZ + 1];\n    size_t nbytes;\n    size_t nlines;\n    struct linebuffer *next;\n  };\n  uintmax_t desired_pos = current_pos;\n  typedef struct linebuffer LBUFFER;\n  LBUFFER *first, *last, *tmp;\n  size_t total_lines = 0;\t/* Total number of newlines in all buffers.  */\n  bool ok = true;\n  size_t n_read;\t\t/* Size in bytes of most recent read */\n\n  first = last = xmalloc (sizeof (LBUFFER));\n  first->nbytes = first->nlines = 0;\n  first->next = nullptr;\n  tmp = xmalloc (sizeof (LBUFFER));\n\n  /* Always read into a fresh buffer.\n     Read, (producing no output) until we've accumulated at least\n     n_elide newlines, or until EOF, whichever comes first.  */\n  while (true)\n    {\n      n_read = safe_read (fd, tmp->buffer, BUFSIZ);\n      if (n_read == 0 || n_read == SAFE_READ_ERROR)\n        break;\n\n      if (! n_elide)\n        {\n          desired_pos += n_read;\n          xwrite_stdout (tmp->buffer, n_read);\n          continue;\n        }\n\n      tmp->nbytes = n_read;\n      tmp->nlines = 0;\n      tmp->next = nullptr;\n\n      /* Count the number of newlines just read.  */\n      {\n        char *buffer_end = tmp->buffer + n_read;\n        *buffer_end = line_end;\n        char const *p = tmp->buffer;\n        while ((p = rawmemchr (p, line_end)) < buffer_end)\n          {\n            ++p;\n            ++tmp->nlines;\n          }\n      }\n      total_lines += tmp->nlines;\n\n      /* If there is enough room in the last buffer read, just append the new\n         one to it.  This is because when reading from a pipe, 'n_read' can\n         often be very small.  */\n      if (tmp->nbytes + last->nbytes < BUFSIZ)\n        {\n          memcpy (&last->buffer[last->nbytes], tmp->buffer, tmp->nbytes);\n          last->nbytes += tmp->nbytes;\n          last->nlines += tmp->nlines;\n        }\n      else\n        {\n          /* If there's not enough room, link the new buffer onto the end of\n             the list, then either free up the oldest buffer for the next\n             read if that would leave enough lines, or else malloc a new one.\n             Some compaction mechanism is possible but probably not\n             worthwhile.  */\n          last = last->next = tmp;\n          if (n_elide < total_lines - first->nlines)\n            {\n              desired_pos += first->nbytes;\n              xwrite_stdout (first->buffer, first->nbytes);\n              tmp = first;\n              total_lines -= first->nlines;\n              first = first->next;\n            }\n          else\n            tmp = xmalloc (sizeof (LBUFFER));\n        }\n    }\n\n  free (tmp);\n\n  if (n_read == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"error reading %s\"), quoteaf (filename));\n      ok = false;\n      goto free_lbuffers;\n    }\n\n  /* If we read any bytes at all, count the incomplete line\n     on files that don't end with a newline.  */\n  if (last->nbytes && last->buffer[last->nbytes - 1] != line_end)\n    {\n      ++last->nlines;\n      ++total_lines;\n    }\n\n  for (tmp = first; n_elide < total_lines - tmp->nlines; tmp = tmp->next)\n    {\n      desired_pos += tmp->nbytes;\n      xwrite_stdout (tmp->buffer, tmp->nbytes);\n      total_lines -= tmp->nlines;\n    }\n\n  /* Print the first 'total_lines - n_elide' lines of tmp->buffer.  */\n  if (n_elide < total_lines)\n    {\n      size_t n = total_lines - n_elide;\n      char const *buffer_end = tmp->buffer + tmp->nbytes;\n      char const *p = tmp->buffer;\n      while (n && (p = memchr (p, line_end, buffer_end - p)))\n        {\n          ++p;\n          ++tmp->nlines;\n          --n;\n        }\n      desired_pos += p - tmp->buffer;\n      xwrite_stdout (tmp->buffer, p - tmp->buffer);\n    }\n\nfree_lbuffers:\n  while (first)\n    {\n      tmp = first->next;\n      free (first);\n      first = tmp;\n    }\n\n  if (0 <= current_pos && elseek (fd, desired_pos, SEEK_SET, filename) < 0)\n    ok = false;\n  return ok;\n}\n\n/* Output all but the last N_LINES lines of the input stream defined by\n   FD, START_POS, and SIZE.\n   START_POS is the starting position of the read pointer for the file\n   associated with FD (may be nonzero).\n   SIZE is the file size in bytes.\n   Return true upon success.\n   Give a diagnostic and return false upon error.\n\n   NOTE: this code is very similar to that of tail.c's file_lines function.\n   Unfortunately, factoring out some common core looks like it'd result\n   in a less efficient implementation or a messy interface.  */\nstatic bool\nelide_tail_lines_seekable (char const *pretty_filename, int fd,\n                           uintmax_t n_lines,\n                           off_t start_pos, off_t size)\n{\n  char buffer[BUFSIZ];\n  size_t bytes_read;\n  off_t pos = size;\n\n  /* Set 'bytes_read' to the size of the last, probably partial, buffer;\n     0 < 'bytes_read' <= 'BUFSIZ'.  */\n  bytes_read = (pos - start_pos) % BUFSIZ;\n  if (bytes_read == 0)\n    bytes_read = BUFSIZ;\n  /* Make 'pos' a multiple of 'BUFSIZ' (0 if the file is short), so that all\n     reads will be on block boundaries, which might increase efficiency.  */\n  pos -= bytes_read;\n  if (elseek (fd, pos, SEEK_SET, pretty_filename) < 0)\n    return false;\n  bytes_read = safe_read (fd, buffer, bytes_read);\n  if (bytes_read == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n      return false;\n    }\n\n  /* n_lines == 0 case needs special treatment. */\n  const bool all_lines = !n_lines;\n\n  /* Count the incomplete line on files that don't end with a newline.  */\n  if (n_lines && bytes_read && buffer[bytes_read - 1] != line_end)\n    --n_lines;\n\n  while (true)\n    {\n      /* Scan backward, counting the newlines in this bufferfull.  */\n\n      size_t n = bytes_read;\n      while (n)\n        {\n          if (all_lines)\n            n -= 1;\n          else\n            {\n              char const *nl;\n              nl = memrchr (buffer, line_end, n);\n              if (nl == nullptr)\n                break;\n              n = nl - buffer;\n            }\n          if (n_lines-- == 0)\n            {\n              /* Found it.  */\n              /* If necessary, restore the file pointer and copy\n                 input to output up to position, POS.  */\n              if (start_pos < pos)\n                {\n                  enum Copy_fd_status err;\n                  if (elseek (fd, start_pos, SEEK_SET, pretty_filename) < 0)\n                    return false;\n\n                  err = copy_fd (fd, pos - start_pos);\n                  if (err != COPY_FD_OK)\n                    {\n                      diagnose_copy_fd_failure (err, pretty_filename);\n                      return false;\n                    }\n                }\n\n              /* Output the initial portion of the buffer\n                 in which we found the desired newline byte.  */\n              xwrite_stdout (buffer, n + 1);\n\n              /* Set file pointer to the byte after what we've output.  */\n              return 0 <= elseek (fd, pos + n + 1, SEEK_SET, pretty_filename);\n            }\n        }\n\n      /* Not enough newlines in that bufferfull.  */\n      if (pos == start_pos)\n        {\n          /* Not enough lines in the file.  */\n          return true;\n        }\n      pos -= BUFSIZ;\n      if (elseek (fd, pos, SEEK_SET, pretty_filename) < 0)\n        return false;\n\n      bytes_read = safe_read (fd, buffer, BUFSIZ);\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n          return false;\n        }\n\n      /* FIXME: is this dead code?\n         Consider the test, pos == start_pos, above. */\n      if (bytes_read == 0)\n        return true;\n    }\n}\n\n/* For the file FILENAME with descriptor FD, output all but the last N_ELIDE\n   lines.  If SIZE is nonnegative, this is a regular file positioned\n   at START_POS with SIZE bytes.  Return true on success.\n   Give a diagnostic and return nonzero upon error.  */\n\nstatic bool\nelide_tail_lines_file (char const *filename, int fd, uintmax_t n_elide,\n                       struct stat const *st, off_t current_pos)\n{\n  off_t size = st->st_size;\n  if (presume_input_pipe || current_pos < 0 || size <= ST_BLKSIZE (*st))\n    return elide_tail_lines_pipe (filename, fd, n_elide, current_pos);\n  else\n    {\n      /* Find the offset, OFF, of the Nth newline from the end,\n         but not counting the last byte of the file.\n         If found, write from current position to OFF, inclusive.\n         Otherwise, just return true.  */\n\n      return (size <= current_pos\n              || elide_tail_lines_seekable (filename, fd, n_elide,\n                                            current_pos, size));\n    }\n}\n\nstatic bool\nhead_bytes (char const *filename, int fd, uintmax_t bytes_to_write)\n{\n  char buffer[BUFSIZ];\n  size_t bytes_to_read = BUFSIZ;\n\n  while (bytes_to_write)\n    {\n      size_t bytes_read;\n      if (bytes_to_write < bytes_to_read)\n        bytes_to_read = bytes_to_write;\n      bytes_read = safe_read (fd, buffer, bytes_to_read);\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, _(\"error reading %s\"), quoteaf (filename));\n          return false;\n        }\n      if (bytes_read == 0)\n        break;\n      xwrite_stdout (buffer, bytes_read);\n      bytes_to_write -= bytes_read;\n    }\n  return true;\n}\n\nstatic bool\nhead_lines (char const *filename, int fd, uintmax_t lines_to_write)\n{\n  char buffer[BUFSIZ];\n\n  while (lines_to_write)\n    {\n      size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n      size_t bytes_to_write = 0;\n\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, _(\"error reading %s\"), quoteaf (filename));\n          return false;\n        }\n      if (bytes_read == 0)\n        break;\n      while (bytes_to_write < bytes_read)\n        if (buffer[bytes_to_write++] == line_end && --lines_to_write == 0)\n          {\n            off_t n_bytes_past_EOL = bytes_read - bytes_to_write;\n            /* If we have read more data than that on the specified number\n               of lines, try to seek back to the position we would have\n               gotten to had we been reading one byte at a time.  */\n            if (lseek (fd, -n_bytes_past_EOL, SEEK_CUR) < 0)\n              {\n                struct stat st;\n                if (fstat (fd, &st) != 0 || S_ISREG (st.st_mode))\n                  elseek (fd, -n_bytes_past_EOL, SEEK_CUR, filename);\n              }\n            break;\n          }\n      xwrite_stdout (buffer, bytes_to_write);\n    }\n  return true;\n}\n\nstatic bool\nhead (char const *filename, int fd, uintmax_t n_units, bool count_lines,\n      bool elide_from_end)\n{\n  if (print_headers)\n    write_header (filename);\n\n  if (elide_from_end)\n    {\n      off_t current_pos = -1;\n      struct stat st;\n      if (fstat (fd, &st) != 0)\n        {\n          error (0, errno, _(\"cannot fstat %s\"),\n                 quoteaf (filename));\n          return false;\n        }\n      if (! presume_input_pipe && usable_st_size (&st))\n        {\n          current_pos = elseek (fd, 0, SEEK_CUR, filename);\n          if (current_pos < 0)\n            return false;\n        }\n      if (count_lines)\n        return elide_tail_lines_file (filename, fd, n_units, &st, current_pos);\n      else\n        return elide_tail_bytes_file (filename, fd, n_units, &st, current_pos);\n    }\n  if (count_lines)\n    return head_lines (filename, fd, n_units);\n  else\n    return head_bytes (filename, fd, n_units);\n}\n\nstatic bool\nhead_file (char const *filename, uintmax_t n_units, bool count_lines,\n           bool elide_from_end)\n{\n  int fd;\n  bool ok;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fd = STDIN_FILENO;\n      filename = _(\"standard input\");\n      xset_binary_mode (STDIN_FILENO, O_BINARY);\n    }\n  else\n    {\n      fd = open (filename, O_RDONLY | O_BINARY);\n      if (fd < 0)\n        {\n          error (0, errno, _(\"cannot open %s for reading\"), quoteaf (filename));\n          return false;\n        }\n    }\n\n  ok = head (filename, fd, n_units, count_lines, elide_from_end);\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, _(\"failed to close %s\"), quoteaf (filename));\n      return false;\n    }\n  return ok;\n}\n\n/* Convert a string of decimal digits, N_STRING, with an optional suffix\n   to an integral value.  Upon successful conversion,\n   return that value.  If it cannot be converted, give a diagnostic and exit.\n   COUNT_LINES indicates whether N_STRING is a number of bytes or a number\n   of lines.  It is used solely to give a more specific diagnostic.  */\n\nstatic uintmax_t\nstring_to_integer (bool count_lines, char const *n_string)\n{\n  return xdectoumax (n_string, 0, UINTMAX_MAX, \"bkKmMGTPEZYRQ0\",\n                     count_lines ? _(\"invalid number of lines\")\n                                 : _(\"invalid number of bytes\"), 0);\n}\n\nint\nmain (int argc, char **argv)\n{\n  enum header_mode header_mode = multiple_files;\n  bool ok = true;\n  int c;\n  size_t i;\n\n  /* Number of items to print. */\n  uintmax_t n_units = DEFAULT_NUMBER;\n\n  /* If true, interpret the numeric argument as the number of lines.\n     Otherwise, interpret it as the number of bytes.  */\n  bool count_lines = true;\n\n  /* Elide the specified number of lines or bytes, counting from\n     the end of the file.  */\n  bool elide_from_end = false;\n\n  /* Initializer for file_list if no file-arguments\n     were specified on the command line.  */\n  static char const *const default_file_list[] = {\"-\", nullptr};\n  char const *const *file_list;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  have_read_stdin = false;\n\n  print_headers = false;\n\n  line_end = '\\n';\n\n  if (1 < argc && argv[1][0] == '-' && ISDIGIT (argv[1][1]))\n    {\n      char *a = argv[1];\n      char *n_string = ++a;\n      char *end_n_string;\n      char multiplier_char = 0;\n\n      /* Old option syntax; a dash, one or more digits, and one or\n         more option letters.  Move past the number. */\n      do ++a;\n      while (ISDIGIT (*a));\n\n      /* Pointer to the byte after the last digit.  */\n      end_n_string = a;\n\n      /* Parse any appended option letters. */\n      for (; *a; a++)\n        {\n          switch (*a)\n            {\n            case 'c':\n              count_lines = false;\n              multiplier_char = 0;\n              break;\n\n            case 'b':\n            case 'k':\n            case 'm':\n              count_lines = false;\n              multiplier_char = *a;\n              break;\n\n            case 'l':\n              count_lines = true;\n              break;\n\n            case 'q':\n              header_mode = never;\n              break;\n\n            case 'v':\n              header_mode = always;\n              break;\n\n            case 'z':\n              line_end = '\\0';\n              break;\n\n            default:\n              error (0, 0, _(\"invalid trailing option -- %c\"), *a);\n              usage (EXIT_FAILURE);\n            }\n        }\n\n      /* Append the multiplier character (if any) onto the end of\n         the digit string.  Then add NUL byte if necessary.  */\n      *end_n_string = multiplier_char;\n      if (multiplier_char)\n        *(++end_n_string) = 0;\n\n      n_units = string_to_integer (count_lines, n_string);\n\n      /* Make the options we just parsed invisible to getopt. */\n      argv[1] = argv[0];\n      argv++;\n      argc--;\n    }\n\n  while ((c = getopt_long (argc, argv, \"c:n:qvz0123456789\",\n                           long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case PRESUME_INPUT_PIPE_OPTION:\n          presume_input_pipe = true;\n          break;\n\n        case 'c':\n          count_lines = false;\n          elide_from_end = (*optarg == '-');\n          if (elide_from_end)\n            ++optarg;\n          n_units = string_to_integer (count_lines, optarg);\n          break;\n\n        case 'n':\n          count_lines = true;\n          elide_from_end = (*optarg == '-');\n          if (elide_from_end)\n            ++optarg;\n          n_units = string_to_integer (count_lines, optarg);\n          break;\n\n        case 'q':\n          header_mode = never;\n          break;\n\n        case 'v':\n          header_mode = always;\n          break;\n\n        case 'z':\n          line_end = '\\0';\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          if (ISDIGIT (c))\n            error (0, 0, _(\"invalid trailing option -- %c\"), c);\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (header_mode == always\n      || (header_mode == multiple_files && optind < argc - 1))\n    print_headers = true;\n\n  if ( ! count_lines && elide_from_end && OFF_T_MAX < n_units)\n    {\n      char umax_buf[INT_BUFSIZE_BOUND (n_units)];\n      error (EXIT_FAILURE, EOVERFLOW, \"%s: %s\", _(\"invalid number of bytes\"),\n             quote (umaxtostr (n_units, umax_buf)));\n    }\n\n  file_list = (optind < argc\n               ? (char const *const *) &argv[optind]\n               : default_file_list);\n\n  xset_binary_mode (STDOUT_FILENO, O_BINARY);\n\n  for (i = 0; file_list[i]; ++i)\n    ok &= head_file (file_list[i], n_units, count_lines, elide_from_end);\n\n  if (have_read_stdin && close (STDIN_FILENO) < 0)\n    error (EXIT_FAILURE, errno, \"-\");\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}