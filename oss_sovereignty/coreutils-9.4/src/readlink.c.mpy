{
  "module_name": "readlink.c",
  "hash_id": "0dc077dc338ab9be073639eb99d9953d461e3ee945ef9d50f69073518155afbb",
  "original_prompt": "Ingested from coreutils-9.4/src/readlink.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"canonicalize.h\"\n#include \"areadlink.h\"\n\n \n#define PROGRAM_NAME \"readlink\"\n\n#define AUTHORS proper_name (\"Dmitry V. Levin\")\n\n \nstatic bool no_newline;\n\n \nstatic bool verbose;\n\nstatic struct option const longopts[] =\n{\n  {\"canonicalize\", no_argument, nullptr, 'f'},\n  {\"canonicalize-existing\", no_argument, nullptr, 'e'},\n  {\"canonicalize-missing\", no_argument, nullptr, 'm'},\n  {\"no-newline\", no_argument, nullptr, 'n'},\n  {\"quiet\", no_argument, nullptr, 'q'},\n  {\"silent\", no_argument, nullptr, 's'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {\"zero\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... FILE...\\n\"), program_name);\n      fputs (_(\"Print value of a symbolic link or canonical file name\\n\\n\"),\n             stdout);\n      fputs (_(\"\\\n  -f, --canonicalize            canonicalize by following every symlink in\\n\\\n                                every component of the given name recursively;\\\n\\n\\\n                                all but the last component must exist\\n\\\n  -e, --canonicalize-existing   canonicalize by following every symlink in\\n\\\n                                every component of the given name recursively,\\\n\\n\\\n                                all components must exist\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -m, --canonicalize-missing    canonicalize by following every symlink in\\n\\\n                                every component of the given name recursively,\\\n\\n\\\n                                without requirements on components existence\\n\\\n  -n, --no-newline              do not output the trailing delimiter\\n\\\n  -q, --quiet\\n\\\n  -s, --silent                  suppress most error messages (on by default)\\n\\\n  -v, --verbose                 report error messages\\n\\\n  -z, --zero                    end each output line with NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  /* If not -1, use this method to canonicalize.  */\n  int can_mode = -1;\n  int status = EXIT_SUCCESS;\n  int optc;\n  bool use_nuls = false;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"efmnqsvz\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'e':\n          can_mode = CAN_EXISTING;\n          break;\n        case 'f':\n          can_mode = CAN_ALL_BUT_LAST;\n          break;\n        case 'm':\n          can_mode = CAN_MISSING;\n          break;\n        case 'n':\n          no_newline = true;\n          break;\n        case 'q':\n        case 's':\n          verbose = false;\n          break;\n        case 'v':\n          verbose = true;\n          break;\n        case 'z':\n          use_nuls = true;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind >= argc)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (argc - optind > 1)\n    {\n      if (no_newline)\n        error (0, 0, _(\"ignoring --no-newline with multiple arguments\"));\n      no_newline = false;\n    }\n\n  for (; optind < argc; ++optind)\n    {\n      char const *fname = argv[optind];\n      char *value = (can_mode != -1\n                     ? canonicalize_filename_mode (fname, can_mode)\n                     : areadlink_with_size (fname, 63));\n      if (value)\n        {\n          fputs (value, stdout);\n          if (! no_newline)\n            putchar (use_nuls ? '\\0' : '\\n');\n          free (value);\n        }\n      else\n        {\n          status = EXIT_FAILURE;\n          if (verbose)\n            error (0, errno, \"%s\", quotef (fname));\n        }\n    }\n\n  return status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}