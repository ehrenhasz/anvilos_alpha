{
  "module_name": "truncate.c",
  "hash_id": "455b9280d5020d8d229104b0c91167a0052dff5927256bb6445c15293357b61d",
  "original_prompt": "Ingested from coreutils-9.4/src/truncate.c",
  "human_readable_source": " \n\n#include <config.h>              \n#include <stdckdint.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"quote.h\"\n#include \"stat-size.h\"\n#include \"xdectoint.h\"\n\n \n#define PROGRAM_NAME \"truncate\"\n\n#define AUTHORS proper_name_lite (\"Padraig Brady\", \"P\\303\\241draig Brady\")\n\n \nstatic bool no_create;\n\n \nstatic bool block_mode;\n\n \nstatic char const *ref_file;\n\nstatic struct option const longopts[] =\n{\n  {\"no-create\", no_argument, nullptr, 'c'},\n  {\"io-blocks\", no_argument, nullptr, 'o'},\n  {\"reference\", required_argument, nullptr, 'r'},\n  {\"size\", required_argument, nullptr, 's'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\ntypedef enum\n{ rm_abs = 0, rm_rel, rm_min, rm_max, rm_rdn, rm_rup } rel_mode_t;\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s OPTION... FILE...\\n\"), program_name);\n      fputs (_(\"\\\nShrink or extend the size of each FILE to the specified size\\n\\\n\\n\\\nA FILE argument that does not exist is created.\\n\\\n\\n\\\nIf a FILE is larger than the specified size, the extra data is lost.\\n\\\nIf a FILE is shorter, it is extended and the sparse extended part (hole)\\n\\\nreads as zero bytes.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -c, --no-create        do not create any files\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -r, --reference=RFILE  base size on RFILE\\n\\\n  -s, --size=SIZE        set or adjust the file size by SIZE bytes\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_size_note ();\n      fputs (_(\"\\n\\\nSIZE may also be prefixed by one of the following modifying characters:\\n\\\n'+' extend by, '-' reduce by, '<' at most, '>' at least,\\n\\\n'/' round down to multiple of, '%' round up to multiple of.\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* return true on success, false on error.  */\nstatic bool\ndo_ftruncate (int fd, char const *fname, off_t ssize, off_t rsize,\n              rel_mode_t rel_mode)\n{\n  struct stat sb;\n  off_t nsize;\n\n  if ((block_mode || (rel_mode && rsize < 0)) && fstat (fd, &sb) != 0)\n    {\n      error (0, errno, _(\"cannot fstat %s\"), quoteaf (fname));\n      return false;\n    }\n  if (block_mode)\n    {\n      ptrdiff_t blksize = ST_BLKSIZE (sb);\n      intmax_t ssize0 = ssize;\n      if (ckd_mul (&ssize, ssize, blksize))\n        {\n          error (0, 0,\n                 _(\"overflow in %\" PRIdMAX\n                   \" * %\" PRIdPTR \" byte blocks for file %s\"),\n                 ssize0, blksize, quoteaf (fname));\n          return false;\n        }\n    }\n  if (rel_mode)\n    {\n      off_t fsize;\n\n      if (0 <= rsize)\n        fsize = rsize;\n      else\n        {\n          if (usable_st_size (&sb))\n            {\n              fsize = sb.st_size;\n              if (fsize < 0)\n                {\n                  /* Sanity check.  Overflow is the only reason I can think\n                     this would ever go negative. */\n                  error (0, 0, _(\"%s has unusable, apparently negative size\"),\n                         quoteaf (fname));\n                  return false;\n                }\n            }\n          else\n            {\n              fsize = lseek (fd, 0, SEEK_END);\n              if (fsize < 0)\n                {\n                  error (0, errno, _(\"cannot get the size of %s\"),\n                         quoteaf (fname));\n                  return false;\n                }\n            }\n        }\n\n      if (rel_mode == rm_min)\n        nsize = MAX (fsize, ssize);\n      else if (rel_mode == rm_max)\n        nsize = MIN (fsize, ssize);\n      else if (rel_mode == rm_rdn)\n        /* 0..ssize-1 -> 0 */\n        nsize = fsize - fsize % ssize;\n      else\n        {\n          if (rel_mode == rm_rup)\n            {\n              /* 1..ssize -> ssize */\n              off_t r = fsize % ssize;\n              ssize = r == 0 ? 0 : ssize - r;\n            }\n          if (ckd_add (&nsize, fsize, ssize))\n            {\n              error (0, 0, _(\"overflow extending size of file %s\"),\n                     quoteaf (fname));\n              return false;\n            }\n        }\n    }\n  else\n    nsize = ssize;\n  if (nsize < 0)\n    nsize = 0;\n\n  if (ftruncate (fd, nsize) != 0)\n    {\n      intmax_t s = nsize;\n      error (0, errno, _(\"failed to truncate %s at %\"PRIdMAX\" bytes\"),\n             quoteaf (fname), s);\n      return false;\n    }\n\n  return true;\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool got_size = false;\n  off_t size IF_LINT ( = 0);\n  off_t rsize = -1;\n  rel_mode_t rel_mode = rm_abs;\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"cor:s:\", longopts, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'c':\n          no_create = true;\n          break;\n\n        case 'o':\n          block_mode = true;\n          break;\n\n        case 'r':\n          ref_file = optarg;\n          break;\n\n        case 's':\n          /* skip any whitespace */\n          while (isspace (to_uchar (*optarg)))\n            optarg++;\n          switch (*optarg)\n            {\n            case '<':\n              rel_mode = rm_max;\n              optarg++;\n              break;\n            case '>':\n              rel_mode = rm_min;\n              optarg++;\n              break;\n            case '/':\n              rel_mode = rm_rdn;\n              optarg++;\n              break;\n            case '%':\n              rel_mode = rm_rup;\n              optarg++;\n              break;\n            }\n          /* skip any whitespace */\n          while (isspace (to_uchar (*optarg)))\n            optarg++;\n          if (*optarg == '+' || *optarg == '-')\n            {\n              if (rel_mode)\n                {\n                  error (0, 0, _(\"multiple relative modifiers specified\"));\n                  /* Note other combinations are flagged as invalid numbers */\n                  usage (EXIT_FAILURE);\n                }\n              rel_mode = rm_rel;\n            }\n          /* Support dd BLOCK size suffixes + lowercase g,t,m for bsd compat.\n             Note we don't support dd's b=512, c=1, w=2 or 21x512MiB formats. */\n          size = xdectoimax (optarg, OFF_T_MIN, OFF_T_MAX, \"EgGkKmMPQRtTYZ0\",\n                             _(\"Invalid number\"), 0);\n          /* Rounding to multiple of 0 is nonsensical */\n          if ((rel_mode == rm_rup || rel_mode == rm_rdn) && size == 0)\n            error (EXIT_FAILURE, 0, _(\"division by zero\"));\n          got_size = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  argv += optind;\n  argc -= optind;\n\n  /* must specify either size or reference file */\n  if (!ref_file && !got_size)\n    {\n      error (0, 0, _(\"you must specify either %s or %s\"),\n             quote_n (0, \"--size\"), quote_n (1, \"--reference\"));\n      usage (EXIT_FAILURE);\n    }\n  /* must specify a relative size with a reference file */\n  if (ref_file && got_size && !rel_mode)\n    {\n      error (0, 0, _(\"you must specify a relative %s with %s\"),\n             quote_n (0, \"--size\"), quote_n (1, \"--reference\"));\n      usage (EXIT_FAILURE);\n    }\n  /* block_mode without size is not valid */\n  if (block_mode && !got_size)\n    {\n      error (0, 0, _(\"%s was specified but %s was not\"),\n             quote_n (0, \"--io-blocks\"), quote_n (1, \"--size\"));\n      usage (EXIT_FAILURE);\n    }\n  /* must specify at least 1 file */\n  if (argc < 1)\n    {\n      error (0, 0, _(\"missing file operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (ref_file)\n    {\n      struct stat sb;\n      off_t file_size = -1;\n      if (stat (ref_file, &sb) != 0)\n        error (EXIT_FAILURE, errno, _(\"cannot stat %s\"), quoteaf (ref_file));\n      if (usable_st_size (&sb))\n        file_size = sb.st_size;\n      else\n        {\n          int ref_fd = open (ref_file, O_RDONLY);\n          if (0 <= ref_fd)\n            {\n              off_t file_end = lseek (ref_fd, 0, SEEK_END);\n              int saved_errno = errno;\n              close (ref_fd); /* ignore failure */\n              if (0 <= file_end)\n                file_size = file_end;\n              else\n                {\n                  /* restore, in case close clobbered it. */\n                  errno = saved_errno;\n                }\n            }\n        }\n      if (file_size < 0)\n        error (EXIT_FAILURE, errno, _(\"cannot get the size of %s\"),\n               quoteaf (ref_file));\n      if (!got_size)\n        size = file_size;\n      else\n        rsize = file_size;\n    }\n\n  int oflags = O_WRONLY | (no_create ? 0 : O_CREAT) | O_NONBLOCK;\n  bool errors = false;\n\n  for (char const *fname; (fname = *argv); argv++)\n    {\n      int fd = open (fname, oflags, MODE_RW_UGO);\n      if (fd < 0)\n        {\n          /* 'truncate -s0 -c no-such-file'  shouldn't gen error\n             'truncate -s0 no-such-dir/file' should gen ENOENT error\n             'truncate -s0 no-such-dir/' should gen EISDIR error\n             'truncate -s0 .' should gen EISDIR error */\n          if (!(no_create && errno == ENOENT))\n            {\n              error (0, errno, _(\"cannot open %s for writing\"),\n                     quoteaf (fname));\n              errors = true;\n            }\n        }\n      else\n        {\n          errors |= !do_ftruncate (fd, fname, size, rsize, rel_mode);\n          if (close (fd) != 0)\n            {\n              error (0, errno, _(\"failed to close %s\"), quoteaf (fname));\n              errors = true;\n            }\n        }\n    }\n\n  return errors ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}