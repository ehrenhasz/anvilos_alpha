{
  "module_name": "uptime.c",
  "hash_id": "9e1a9b7cd9854a8bbebfc339764786e5369f7a013b742bc75f6380a22f577c66",
  "original_prompt": "Ingested from coreutils-9.4/src/uptime.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <stdckdint.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n\n#include \"long-options.h\"\n#include \"quote.h\"\n#include \"readutmp.h\"\n#include \"fprintftime.h\"\n\n \n#define PROGRAM_NAME \"uptime\"\n\n#define AUTHORS \\\n  proper_name (\"Joseph Arceneaux\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Kaveh Ghazi\")\n\nstatic int\nprint_uptime (idx_t n, struct gl_utmp const *utmp_buf)\n{\n  int status = EXIT_SUCCESS;\n  time_t boot_time = 0;\n\n   \n  idx_t entries = 0;\n  for (idx_t i = 0; i < n; i++)\n    {\n      struct gl_utmp const *this = &utmp_buf[i];\n      entries += IS_USER_PROCESS (this);\n      if (UT_TYPE_BOOT_TIME (this))\n        boot_time = this->ut_ts.tv_sec;\n    }\n   \n  if (boot_time == 0)\n    {\n      error (0, errno, _(\"couldn't get boot time\"));\n      status = EXIT_FAILURE;\n    }\n\n  time_t time_now = time (nullptr);\n  struct tm *tmn = time_now == (time_t) -1 ? nullptr : localtime (&time_now);\n   \n  if (tmn)\n     \n    fprintftime (stdout, _(\" %H:%M:%S  \"), tmn, 0, 0);\n  else\n    {\n      printf (_(\" ??:????  \"));\n      status = EXIT_FAILURE;\n    }\n\n  intmax_t uptime;\n  if (time_now == (time_t) -1 || boot_time == 0\n      || ckd_sub (&uptime, time_now, boot_time) || uptime < 0)\n    {\n      printf (_(\"up ???? days ??:??,  \"));\n      status = EXIT_FAILURE;\n    }\n  else\n    {\n      intmax_t updays = uptime / 86400;\n      int uphours = uptime % 86400 / 3600;\n      int upmins = uptime % 86400 % 3600 / 60;\n      if (0 < updays)\n        printf (ngettext (\"up %\"PRIdMAX\" day %2d:%02d,  \",\n                          \"up %\"PRIdMAX\" days %2d:%02d,  \",\n                          select_plural (updays)),\n                updays, uphours, upmins);\n      else\n        printf (_(\"up  %2d:%02d,  \"), uphours, upmins);\n    }\n\n  printf (ngettext (\"%td user\", \"%td users\", select_plural (entries)),\n          entries);\n\n  double avg[3];\n  int loads = getloadavg (avg, 3);\n\n  if (loads == -1)\n    putchar ('\\n');\n  else\n    {\n      if (loads > 0)\n        printf (_(\",  load average: %.2f\"), avg[0]);\n      if (loads > 1)\n        printf (\", %.2f\", avg[1]);\n      if (loads > 2)\n        printf (\", %.2f\", avg[2]);\n      if (loads > 0)\n        putchar ('\\n');\n    }\n\n  return status;\n}\n\n \n\nstatic _Noreturn void\nuptime (char const *filename, int options)\n{\n  idx_t n_users;\n  struct gl_utmp *utmp_buf;\n  int read_utmp_status = (read_utmp (filename, &n_users, &utmp_buf, options) < 0\n                          ? EXIT_FAILURE : EXIT_SUCCESS);\n  if (read_utmp_status != EXIT_SUCCESS)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      n_users = 0;\n      utmp_buf = nullptr;\n    }\n\n  int print_uptime_status = print_uptime (n_users, utmp_buf);\n  exit (MAX (read_utmp_status, print_uptime_status));\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [FILE]\\n\"), program_name);\n      printf (_(\"\\\nPrint the current time, the length of time the system has been up,\\n\\\nthe number of users on the system, and the average number of jobs\\n\\\nin the run queue over the last 1, 5 and 15 minutes.\"));\n#ifdef __linux__\n      /* It would be better to introduce a configure test for this,\n         but such a test is hard to write.  For the moment then, we\n         have a hack which depends on the preprocessor used at compile\n         time to tell us what the running kernel is.  Ugh.  */\n      printf (_(\"  \\\nProcesses in\\n\\\nan uninterruptible sleep state also contribute to the load average.\\n\"));\n#else\n      printf (_(\"\\n\"));\n#endif\n      printf (_(\"\\\nIf FILE is not specified, use %s.  %s as FILE is common.\\n\\\n\\n\"),\n              UTMP_FILE, WTMP_FILE);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n                                   Version, true, usage, AUTHORS,\n                                   (char const *) nullptr);\n\n  switch (argc - optind)\n    {\n    case 0:\t\t\t/* uptime */\n      uptime (UTMP_FILE, READ_UTMP_CHECK_PIDS);\n      break;\n\n    case 1:\t\t\t/* uptime <utmp file> */\n      uptime (argv[optind], 0);\n      break;\n\n    default:\t\t\t/* lose */\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 1]));\n      usage (EXIT_FAILURE);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}