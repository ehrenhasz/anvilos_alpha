{
  "module_name": "tr.c",
  "hash_id": "151a23efd377fe35ebee70c0ad5b419fd96d5d5a561a77c8ba5da01888d59e26",
  "original_prompt": "Ingested from coreutils-9.4/src/tr.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"fadvise.h\"\n#include \"quote.h\"\n#include \"safe-read.h\"\n#include \"xbinary-io.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"tr\"\n\n#define AUTHORS proper_name (\"Jim Meyering\")\n\nenum { N_CHARS = UCHAR_MAX + 1 };\n\n \ntypedef uintmax_t count;\n\n \n#define BEGIN_STATE (UINTMAX_MAX - 1)\n\n \n#define NEW_ELEMENT (BEGIN_STATE + 1)\n\n \n#define REPEAT_COUNT_MAXIMUM BEGIN_STATE\n\n \nenum Char_class\n  {\n    CC_ALNUM = 0, CC_ALPHA = 1, CC_BLANK = 2, CC_CNTRL = 3,\n    CC_DIGIT = 4, CC_GRAPH = 5, CC_LOWER = 6, CC_PRINT = 7,\n    CC_PUNCT = 8, CC_SPACE = 9, CC_UPPER = 10, CC_XDIGIT = 11,\n    CC_NO_CLASS = 9999\n  };\n\n \nenum Upper_Lower_class\n  {\n    UL_LOWER,\n    UL_UPPER,\n    UL_NONE\n  };\n\n \nenum Range_element_type\n  {\n    RE_NORMAL_CHAR,\n    RE_RANGE,\n    RE_CHAR_CLASS,\n    RE_EQUIV_CLASS,\n    RE_REPEATED_CHAR\n  };\n\n \nstruct List_element\n  {\n    enum Range_element_type type;\n    struct List_element *next;\n    union\n      {\n        unsigned char normal_char;\n        struct\t\t\t \n          {\n            unsigned char first_char;\n            unsigned char last_char;\n          }\n        range;\n        enum Char_class char_class;\n        unsigned char equiv_code;\n        struct\t\t\t \n          {\n            unsigned char the_repeated_char;\n            count repeat_count;\n          }\n        repeated_char;\n      }\n    u;\n  };\n\n \nstruct Spec_list\n  {\n     \n    struct List_element *head;\n\n     \n    struct List_element *tail;\n\n     \n    count state;\n\n     \n    count length;\n\n     \n    size_t n_indefinite_repeats;\n\n     \n    struct List_element *indefinite_repeat_element;\n\n     \n    bool has_equiv_class;\n\n     \n    bool has_char_class;\n\n     \n    bool has_restricted_char_class;\n  };\n\n \nstruct E_string\n{\n  char *s;\n  bool *escaped;\n  size_t len;\n};\n\n \nstatic inline bool\nes_match (struct E_string const *es, size_t i, char c)\n{\n  return es->s[i] == c && !es->escaped[i];\n}\n\n \nstatic bool squeeze_repeats = false;\n\n \nstatic bool delete = false;\n\n \nstatic bool complement = false;\n\n \nstatic bool truncate_set1 = false;\n\n \nstatic bool translating;\n\nstatic char io_buf[BUFSIZ];\n\nstatic char const *const char_class_name[] =\n{\n  \"alnum\", \"alpha\", \"blank\", \"cntrl\", \"digit\", \"graph\",\n  \"lower\", \"print\", \"punct\", \"space\", \"upper\", \"xdigit\"\n};\n\n \nstatic bool in_squeeze_set[N_CHARS];\n\n \nstatic bool in_delete_set[N_CHARS];\n\n \nstatic char xlate[N_CHARS];\n\nstatic struct option const long_options[] =\n{\n  {\"complement\", no_argument, nullptr, 'c'},\n  {\"delete\", no_argument, nullptr, 'd'},\n  {\"squeeze-repeats\", no_argument, nullptr, 's'},\n  {\"truncate-set1\", no_argument, nullptr, 't'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... STRING1 [STRING2]\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nTranslate, squeeze, and/or delete characters from standard input,\\n\\\nwriting to standard output.  STRING1 and STRING2 specify arrays of\\n\\\ncharacters ARRAY1 and ARRAY2 that control the action.\\n\\\n\\n\\\n  -c, -C, --complement    use the complement of ARRAY1\\n\\\n  -d, --delete            delete characters in ARRAY1, do not translate\\n\\\n  -s, --squeeze-repeats   replace each sequence of a repeated character\\n\\\n                            that is listed in the last specified ARRAY,\\n\\\n                            with a single occurrence of that character\\n\\\n  -t, --truncate-set1     first truncate ARRAY1 to length of ARRAY2\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nARRAYs are specified as strings of characters.  Most represent themselves.\\n\\\nInterpreted sequences are:\\n\\\n\\n\\\n  \\\\NNN            character with octal value NNN (1 to 3 octal digits)\\n\\\n  \\\\\\\\              backslash\\n\\\n  \\\\a              audible BEL\\n\\\n  \\\\b              backspace\\n\\\n  \\\\f              form feed\\n\\\n  \\\\n              new line\\n\\\n  \\\\r              return\\n\\\n  \\\\t              horizontal tab\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  \\\\v              vertical tab\\n\\\n  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\\n\\\n  [CHAR*]         in ARRAY2, copies of CHAR until length of ARRAY1\\n\\\n  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\\n\\\n  [:alnum:]       all letters and digits\\n\\\n  [:alpha:]       all letters\\n\\\n  [:blank:]       all horizontal whitespace\\n\\\n  [:cntrl:]       all control characters\\n\\\n  [:digit:]       all digits\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  [:graph:]       all printable characters, not including space\\n\\\n  [:lower:]       all lower case letters\\n\\\n  [:print:]       all printable characters, including space\\n\\\n  [:punct:]       all punctuation characters\\n\\\n  [:space:]       all horizontal or vertical whitespace\\n\\\n  [:upper:]       all upper case letters\\n\\\n  [:xdigit:]      all hexadecimal digits\\n\\\n  [=CHAR=]        all characters which are equivalent to CHAR\\n\\\n\"), stdout);\n     fputs (_(\"\\\n\\n\\\nTranslation occurs if -d is not given and both STRING1 and STRING2 appear.\\n\\\n-t is only significant when translating.  ARRAY2 is extended to length of\\n\\\nARRAY1 by repeating its last character as necessary.  Excess characters\\n\\\nof ARRAY2 are ignored.  Character classes expand in unspecified order;\\n\\\nwhile translating, [:lower:] and [:upper:] may be used in pairs to\\n\\\nspecify case conversion.  Squeezing occurs after translation or deletion.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Return nonzero if the character C is a member of the\n   equivalence class containing the character EQUIV_CLASS.  */\n\nstatic inline bool\nis_equiv_class_member (unsigned char equiv_class, unsigned char c)\n{\n  return (equiv_class == c);\n}\n\n/* Return true if the character C is a member of the\n   character class CHAR_CLASS.  */\n\nATTRIBUTE_PURE\nstatic bool\nis_char_class_member (enum Char_class char_class, unsigned char c)\n{\n  int result;\n\n  switch (char_class)\n    {\n    case CC_ALNUM:\n      result = isalnum (c);\n      break;\n    case CC_ALPHA:\n      result = isalpha (c);\n      break;\n    case CC_BLANK:\n      result = isblank (c);\n      break;\n    case CC_CNTRL:\n      result = iscntrl (c);\n      break;\n    case CC_DIGIT:\n      result = isdigit (c);\n      break;\n    case CC_GRAPH:\n      result = isgraph (c);\n      break;\n    case CC_LOWER:\n      result = islower (c);\n      break;\n    case CC_PRINT:\n      result = isprint (c);\n      break;\n    case CC_PUNCT:\n      result = ispunct (c);\n      break;\n    case CC_SPACE:\n      result = isspace (c);\n      break;\n    case CC_UPPER:\n      result = isupper (c);\n      break;\n    case CC_XDIGIT:\n      result = isxdigit (c);\n      break;\n    default:\n      unreachable ();\n    }\n\n  return !! result;\n}\n\nstatic void\nes_free (struct E_string *es)\n{\n  free (es->s);\n  free (es->escaped);\n}\n\n/* Perform the first pass over each range-spec argument S, converting all\n   \\c and \\ddd escapes to their one-byte representations.  If an invalid\n   quote sequence is found print an error message and return false;\n   Otherwise set *ES to the resulting string and return true.\n   The resulting array of characters may contain zero-bytes;\n   however, on input, S is assumed to be null-terminated, and hence\n   cannot contain actual (non-escaped) zero bytes.  */\n\nstatic bool\nunquote (char const *s, struct E_string *es)\n{\n  size_t len = strlen (s);\n\n  es->s = xmalloc (len);\n  es->escaped = xcalloc (len, sizeof es->escaped[0]);\n\n  unsigned int j = 0;\n  for (unsigned int i = 0; s[i]; i++)\n    {\n      unsigned char c;\n      int oct_digit;\n\n      switch (s[i])\n        {\n        case '\\\\':\n          es->escaped[j] = true;\n          switch (s[i + 1])\n            {\n            case '\\\\':\n              c = '\\\\';\n              break;\n            case 'a':\n              c = '\\a';\n              break;\n            case 'b':\n              c = '\\b';\n              break;\n            case 'f':\n              c = '\\f';\n              break;\n            case 'n':\n              c = '\\n';\n              break;\n            case 'r':\n              c = '\\r';\n              break;\n            case 't':\n              c = '\\t';\n              break;\n            case 'v':\n              c = '\\v';\n              break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n              c = s[i + 1] - '0';\n              oct_digit = s[i + 2] - '0';\n              if (0 <= oct_digit && oct_digit <= 7)\n                {\n                  c = 8 * c + oct_digit;\n                  ++i;\n                  oct_digit = s[i + 2] - '0';\n                  if (0 <= oct_digit && oct_digit <= 7)\n                    {\n                      if (8 * c + oct_digit < N_CHARS)\n                        {\n                          c = 8 * c + oct_digit;\n                          ++i;\n                        }\n                      else\n                        {\n                          /* A 3-digit octal number larger than \\377 won't\n                             fit in 8 bits.  So we stop when adding the\n                             next digit would put us over the limit and\n                             give a warning about the ambiguity.  POSIX\n                             isn't clear on this, and we interpret this\n                             lack of clarity as meaning the resulting behavior\n                             is undefined, which means we're allowed to issue\n                             a warning.  */\n                          error (0, 0, _(\"warning: the ambiguous octal escape\\\n \\\\%c%c%c is being\\n\\tinterpreted as the 2-byte sequence \\\\0%c%c, %c\"),\n                                 s[i], s[i + 1], s[i + 2],\n                                 s[i], s[i + 1], s[i + 2]);\n                        }\n                    }\n                }\n              break;\n            case '\\0':\n              error (0, 0, _(\"warning: an unescaped backslash \"\n                             \"at end of string is not portable\"));\n              /* POSIX is not clear about this.  */\n              es->escaped[j] = false;\n              i--;\n              c = '\\\\';\n              break;\n            default:\n              c = s[i + 1];\n              break;\n            }\n          ++i;\n          es->s[j++] = c;\n          break;\n        default:\n          es->s[j++] = s[i];\n          break;\n        }\n    }\n  es->len = j;\n  return true;\n}\n\n/* If CLASS_STR is a valid character class string, return its index\n   in the global char_class_name array.  Otherwise, return CC_NO_CLASS.  */\n\nATTRIBUTE_PURE\nstatic enum Char_class\nlook_up_char_class (char const *class_str, size_t len)\n{\n  enum Char_class i;\n\n  for (i = 0; i < ARRAY_CARDINALITY (char_class_name); i++)\n    if (STREQ_LEN (class_str, char_class_name[i], len)\n        && strlen (char_class_name[i]) == len)\n      return i;\n  return CC_NO_CLASS;\n}\n\n/* Return a newly allocated string with a printable version of C.\n   This function is used solely for formatting error messages.  */\n\nstatic char *\nmake_printable_char (unsigned char c)\n{\n  char *buf = xmalloc (5);\n\n  if (isprint (c))\n    {\n      buf[0] = c;\n      buf[1] = '\\0';\n    }\n  else\n    {\n      sprintf (buf, \"\\\\%03o\", c);\n    }\n  return buf;\n}\n\n/* Return a newly allocated copy of S which is suitable for printing.\n   LEN is the number of characters in S.  Most non-printing\n   (isprint) characters are represented by a backslash followed by\n   3 octal digits.  However, the characters represented by \\c escapes\n   where c is one of [abfnrtv] are represented by their 2-character \\c\n   sequences.  This function is used solely for printing error messages.  */\n\nstatic char *\nmake_printable_str (char const *s, size_t len)\n{\n  /* Worst case is that every character expands to a backslash\n     followed by a 3-character octal escape sequence.  */\n  char *printable_buf = xnmalloc (len + 1, 4);\n  char *p = printable_buf;\n\n  for (size_t i = 0; i < len; i++)\n    {\n      char buf[5];\n      char const *tmp = nullptr;\n      unsigned char c = s[i];\n\n      switch (c)\n        {\n        case '\\\\':\n          tmp = \"\\\\\";\n          break;\n        case '\\a':\n          tmp = \"\\\\a\";\n          break;\n        case '\\b':\n          tmp = \"\\\\b\";\n          break;\n        case '\\f':\n          tmp = \"\\\\f\";\n          break;\n        case '\\n':\n          tmp = \"\\\\n\";\n          break;\n        case '\\r':\n          tmp = \"\\\\r\";\n          break;\n        case '\\t':\n          tmp = \"\\\\t\";\n          break;\n        case '\\v':\n          tmp = \"\\\\v\";\n          break;\n        default:\n          if (isprint (c))\n            {\n              buf[0] = c;\n              buf[1] = '\\0';\n            }\n          else\n            sprintf (buf, \"\\\\%03o\", c);\n          tmp = buf;\n          break;\n        }\n      p = stpcpy (p, tmp);\n    }\n  return printable_buf;\n}\n\n/* Append a newly allocated structure representing a\n   character C to the specification list LIST.  */\n\nstatic void\nappend_normal_char (struct Spec_list *list, unsigned char c)\n{\n  struct List_element *new = xmalloc (sizeof *new);\n  new->next = nullptr;\n  new->type = RE_NORMAL_CHAR;\n  new->u.normal_char = c;\n  list->tail->next = new;\n  list->tail = new;\n}\n\n/* Append a newly allocated structure representing the range\n   of characters from FIRST to LAST to the specification list LIST.\n   Return false if LAST precedes FIRST in the collating sequence,\n   true otherwise.  This means that '[c-c]' is acceptable.  */\n\nstatic bool\nappend_range (struct Spec_list *list, unsigned char first, unsigned char last)\n{\n  if (last < first)\n    {\n      char *tmp1 = make_printable_char (first);\n      char *tmp2 = make_printable_char (last);\n\n      error (0, 0,\n       _(\"range-endpoints of '%s-%s' are in reverse collating sequence order\"),\n             tmp1, tmp2);\n      free (tmp1);\n      free (tmp2);\n      return false;\n    }\n  struct List_element *new = xmalloc (sizeof *new);\n  new->next = nullptr;\n  new->type = RE_RANGE;\n  new->u.range.first_char = first;\n  new->u.range.last_char = last;\n  list->tail->next = new;\n  list->tail = new;\n  return true;\n}\n\n/* If CHAR_CLASS_STR is a valid character class string, append a\n   newly allocated structure representing that character class to the end\n   of the specification list LIST and return true.  If CHAR_CLASS_STR is not\n   a valid string return false.  */\n\nstatic bool\nappend_char_class (struct Spec_list *list,\n                   char const *char_class_str, size_t len)\n{\n  enum Char_class char_class = look_up_char_class (char_class_str, len);\n  if (char_class == CC_NO_CLASS)\n    return false;\n  struct List_element *new = xmalloc (sizeof *new);\n  new->next = nullptr;\n  new->type = RE_CHAR_CLASS;\n  new->u.char_class = char_class;\n  list->tail->next = new;\n  list->tail = new;\n  return true;\n}\n\n/* Append a newly allocated structure representing a [c*n]\n   repeated character construct to the specification list LIST.\n   THE_CHAR is the single character to be repeated, and REPEAT_COUNT\n   is a non-negative repeat count.  */\n\nstatic void\nappend_repeated_char (struct Spec_list *list, unsigned char the_char,\n                      count repeat_count)\n{\n  struct List_element *new = xmalloc (sizeof *new);\n  new->next = nullptr;\n  new->type = RE_REPEATED_CHAR;\n  new->u.repeated_char.the_repeated_char = the_char;\n  new->u.repeated_char.repeat_count = repeat_count;\n  list->tail->next = new;\n  list->tail = new;\n}\n\n/* Given a string, EQUIV_CLASS_STR, from a [=str=] context and\n   the length of that string, LEN, if LEN is exactly one, append\n   a newly allocated structure representing the specified\n   equivalence class to the specification list, LIST and return true.\n   If LEN is not 1, return false.  */\n\nstatic bool\nappend_equiv_class (struct Spec_list *list,\n                    char const *equiv_class_str, size_t len)\n{\n  if (len != 1)\n    return false;\n\n  struct List_element *new = xmalloc (sizeof *new);\n  new->next = nullptr;\n  new->type = RE_EQUIV_CLASS;\n  new->u.equiv_code = *equiv_class_str;\n  list->tail->next = new;\n  list->tail = new;\n  return true;\n}\n\n/* Search forward starting at START_IDX for the 2-char sequence\n   (PRE_BRACKET_CHAR,']') in the string P of length P_LEN.  If such\n   a sequence is found, set *RESULT_IDX to the index of the first\n   character and return true.  Otherwise return false.  P may contain\n   zero bytes.  */\n\nstatic bool\nfind_closing_delim (const struct E_string *es, size_t start_idx,\n                    char pre_bracket_char, size_t *result_idx)\n{\n  for (size_t i = start_idx; i < es->len - 1; i++)\n    if (es->s[i] == pre_bracket_char && es->s[i + 1] == ']'\n        && !es->escaped[i] && !es->escaped[i + 1])\n      {\n        *result_idx = i;\n        return true;\n      }\n  return false;\n}\n\n/* Parse the bracketed repeat-char syntax.  If the P_LEN characters\n   beginning with P[ START_IDX ] comprise a valid [c*n] construct,\n   then set *CHAR_TO_REPEAT, *REPEAT_COUNT, and *CLOSING_BRACKET_IDX\n   and return zero. If the second character following\n   the opening bracket is not '*' or if no closing bracket can be\n   found, return -1.  If a closing bracket is found and the\n   second char is '*', but the string between the '*' and ']' isn't\n   empty, an octal number, or a decimal number, print an error message\n   and return -2.  */\n\nstatic int\nfind_bracketed_repeat (const struct E_string *es, size_t start_idx,\n                       unsigned char *char_to_repeat, count *repeat_count,\n                       size_t *closing_bracket_idx)\n{\n  affirm (start_idx + 1 < es->len);\n  if (!es_match (es, start_idx + 1, '*'))\n    return -1;\n\n  for (size_t i = start_idx + 2; i < es->len && !es->escaped[i]; i++)\n    {\n      if (es->s[i] == ']')\n        {\n          size_t digit_str_len = i - start_idx - 2;\n\n          *char_to_repeat = es->s[start_idx];\n          if (digit_str_len == 0)\n            {\n              /* We've matched [c*] -- no explicit repeat count.  */\n              *repeat_count = 0;\n            }\n          else\n            {\n              /* Here, we have found [c*s] where s should be a string\n                 of octal (if it starts with '0') or decimal digits.  */\n              char const *digit_str = &es->s[start_idx + 2];\n              char *d_end;\n              if ((xstrtoumax (digit_str, &d_end, *digit_str == '0' ? 8 : 10,\n                               repeat_count, nullptr)\n                   != LONGINT_OK)\n                  || REPEAT_COUNT_MAXIMUM < *repeat_count\n                  || digit_str + digit_str_len != d_end)\n                {\n                  char *tmp = make_printable_str (digit_str, digit_str_len);\n                  error (0, 0,\n                         _(\"invalid repeat count %s in [c*n] construct\"),\n                         quote (tmp));\n                  free (tmp);\n                  return -2;\n                }\n            }\n          *closing_bracket_idx = i;\n          return 0;\n        }\n    }\n  return -1;\t\t\t/* No bracket found.  */\n}\n\n/* Return true if the string at ES->s[IDX] matches the regular\n   expression '\\*[0-9]*]', false otherwise.  The string does not\n   match if any of its characters are escaped.  */\n\nATTRIBUTE_PURE\nstatic bool\nstar_digits_closebracket (const struct E_string *es, size_t idx)\n{\n  if (!es_match (es, idx, '*'))\n    return false;\n\n  for (size_t i = idx + 1; i < es->len; i++)\n    if (!ISDIGIT (to_uchar (es->s[i])) || es->escaped[i])\n      return es_match (es, i, ']');\n  return false;\n}\n\n/* Convert string UNESCAPED_STRING (which has been preprocessed to\n   convert backslash-escape sequences) of length LEN characters into\n   a linked list of the following 5 types of constructs:\n      - [:str:] Character class where 'str' is one of the 12 valid strings.\n      - [=c=] Equivalence class where 'c' is any single character.\n      - [c*n] Repeat the single character 'c' 'n' times. n may be omitted.\n          However, if 'n' is present, it must be a non-negative octal or\n          decimal integer.\n      - r-s Range of characters from 'r' to 's'.  The second endpoint must\n          not precede the first in the current collating sequence.\n      - c Any other character is interpreted as itself.  */\n\nstatic bool\nbuild_spec_list (const struct E_string *es, struct Spec_list *result)\n{\n  char const *p = es->s;\n\n  /* The main for-loop below recognizes the 4 multi-character constructs.\n     A character that matches (in its context) none of the multi-character\n     constructs is classified as 'normal'.  Since all multi-character\n     constructs have at least 3 characters, any strings of length 2 or\n     less are composed solely of normal characters.  Hence, the index of\n     the outer for-loop runs only as far as LEN-2.  */\n  size_t i;\n  for (i = 0; i + 2 < es->len; /* empty */)\n    {\n      if (es_match (es, i, '['))\n        {\n          bool matched_multi_char_construct;\n          size_t closing_bracket_idx;\n          unsigned char char_to_repeat;\n          count repeat_count;\n          int err;\n\n          matched_multi_char_construct = true;\n          if (es_match (es, i + 1, ':') || es_match (es, i + 1, '='))\n            {\n              size_t closing_delim_idx;\n\n              if (find_closing_delim (es, i + 2, p[i + 1], &closing_delim_idx))\n                {\n                  size_t opnd_str_len = closing_delim_idx - 1 - (i + 2) + 1;\n                  char const *opnd_str = p + i + 2;\n\n                  if (opnd_str_len == 0)\n                    {\n                      if (p[i + 1] == ':')\n                        error (0, 0, _(\"missing character class name '[::]'\"));\n                      else\n                        error (0, 0,\n                               _(\"missing equivalence class character '[==]'\"));\n                      return false;\n                    }\n\n                  if (p[i + 1] == ':')\n                    {\n                      /* FIXME: big comment.  */\n                      if (!append_char_class (result, opnd_str, opnd_str_len))\n                        {\n                          if (star_digits_closebracket (es, i + 2))\n                            goto try_bracketed_repeat;\n                          else\n                            {\n                              char *tmp = make_printable_str (opnd_str,\n                                                              opnd_str_len);\n                              error (0, 0, _(\"invalid character class %s\"),\n                                     quote (tmp));\n                              free (tmp);\n                              return false;\n                            }\n                        }\n                    }\n                  else\n                    {\n                      /* FIXME: big comment.  */\n                      if (!append_equiv_class (result, opnd_str, opnd_str_len))\n                        {\n                          if (star_digits_closebracket (es, i + 2))\n                            goto try_bracketed_repeat;\n                          else\n                            {\n                              char *tmp = make_printable_str (opnd_str,\n                                                              opnd_str_len);\n                              error (0, 0,\n               _(\"%s: equivalence class operand must be a single character\"),\n                                     tmp);\n                              free (tmp);\n                              return false;\n                            }\n                        }\n                    }\n\n                  i = closing_delim_idx + 2;\n                  continue;\n                }\n              /* Else fall through.  This could be [:*] or [=*].  */\n            }\n\n        try_bracketed_repeat:\n\n          /* Determine whether this is a bracketed repeat range\n             matching the RE \\[.\\*(dec_or_oct_number)?].  */\n          err = find_bracketed_repeat (es, i + 1, &char_to_repeat,\n                                       &repeat_count,\n                                       &closing_bracket_idx);\n          if (err == 0)\n            {\n              append_repeated_char (result, char_to_repeat, repeat_count);\n              i = closing_bracket_idx + 1;\n            }\n          else if (err == -1)\n            {\n              matched_multi_char_construct = false;\n            }\n          else\n            {\n              /* Found a string that looked like [c*n] but the\n                 numeric part was invalid.  */\n              return false;\n            }\n\n          if (matched_multi_char_construct)\n            continue;\n\n          /* We reach this point if P does not match [:str:], [=c=],\n             [c*n], or [c*].  Now, see if P looks like a range '[-c'\n             (from '[' to 'c').  */\n        }\n\n      /* Look ahead one char for ranges like a-z.  */\n      if (es_match (es, i + 1, '-'))\n        {\n          if (!append_range (result, p[i], p[i + 2]))\n            return false;\n          i += 3;\n        }\n      else\n        {\n          append_normal_char (result, p[i]);\n          ++i;\n        }\n    }\n\n  /* Now handle the (2 or fewer) remaining characters p[i]..p[es->len - 1].  */\n  for (; i < es->len; i++)\n    append_normal_char (result, p[i]);\n\n  return true;\n}\n\n/* Advance past the current construct.\n   S->tail must be non-null.  */\nstatic void\nskip_construct (struct Spec_list *s)\n{\n  s->tail = s->tail->next;\n  s->state = NEW_ELEMENT;\n}\n\n/* Given a Spec_list S (with its saved state implicit in the values\n   of its members 'tail' and 'state'), return the next single character\n   in the expansion of S's constructs.  If the last character of S was\n   returned on the previous call or if S was empty, this function\n   returns -1.  For example, successive calls to get_next where S\n   represents the spec-string 'a-d[y*3]' will return the sequence\n   of values a, b, c, d, y, y, y, -1.  Finally, if the construct from\n   which the returned character comes is [:upper:] or [:lower:], the\n   parameter CLASS is given a value to indicate which it was.  Otherwise\n   CLASS is set to UL_NONE.  This value is used only when constructing\n   the translation table to verify that any occurrences of upper and\n   lower class constructs in the spec-strings appear in the same relative\n   positions.  */\n\nstatic int\nget_next (struct Spec_list *s, enum Upper_Lower_class *class)\n{\n  struct List_element *p;\n  int return_val;\n  int i;\n\n  if (class)\n    *class = UL_NONE;\n\n  if (s->state == BEGIN_STATE)\n    {\n      s->tail = s->head->next;\n      s->state = NEW_ELEMENT;\n    }\n\n  p = s->tail;\n  if (p == nullptr)\n    return -1;\n\n  switch (p->type)\n    {\n    case RE_NORMAL_CHAR:\n      return_val = p->u.normal_char;\n      s->state = NEW_ELEMENT;\n      s->tail = p->next;\n      break;\n\n    case RE_RANGE:\n      if (s->state == NEW_ELEMENT)\n        s->state = p->u.range.first_char;\n      else\n        ++(s->state);\n      return_val = s->state;\n      if (s->state == p->u.range.last_char)\n        {\n          s->tail = p->next;\n          s->state = NEW_ELEMENT;\n        }\n      break;\n\n    case RE_CHAR_CLASS:\n      if (class)\n        {\n          switch (p->u.char_class)\n            {\n            case CC_LOWER:\n              *class = UL_LOWER;\n              break;\n            case CC_UPPER:\n              *class = UL_UPPER;\n              break;\n            default:\n              break;\n            }\n        }\n\n      if (s->state == NEW_ELEMENT)\n        {\n          for (i = 0; i < N_CHARS; i++)\n            if (is_char_class_member (p->u.char_class, i))\n              break;\n          affirm (i < N_CHARS);\n          s->state = i;\n        }\n      assure (is_char_class_member (p->u.char_class, s->state));\n      return_val = s->state;\n      for (i = s->state + 1; i < N_CHARS; i++)\n        if (is_char_class_member (p->u.char_class, i))\n          break;\n      if (i < N_CHARS)\n        s->state = i;\n      else\n        {\n          s->tail = p->next;\n          s->state = NEW_ELEMENT;\n        }\n      break;\n\n    case RE_EQUIV_CLASS:\n      /* FIXME: this assumes that each character is alone in its own\n         equivalence class (which appears to be correct for my\n         LC_COLLATE.  But I don't know of any function that allows\n         one to determine a character's equivalence class.  */\n\n      return_val = p->u.equiv_code;\n      s->state = NEW_ELEMENT;\n      s->tail = p->next;\n      break;\n\n    case RE_REPEATED_CHAR:\n      /* Here, a repeat count of n == 0 means don't repeat at all.  */\n      if (p->u.repeated_char.repeat_count == 0)\n        {\n          s->tail = p->next;\n          s->state = NEW_ELEMENT;\n          return_val = get_next (s, class);\n        }\n      else\n        {\n          if (s->state == NEW_ELEMENT)\n            {\n              s->state = 0;\n            }\n          ++(s->state);\n          return_val = p->u.repeated_char.the_repeated_char;\n          if (s->state == p->u.repeated_char.repeat_count)\n            {\n              s->tail = p->next;\n              s->state = NEW_ELEMENT;\n            }\n        }\n      break;\n\n    default:\n      unreachable ();\n    }\n\n  return return_val;\n}\n\n/* This is a minor kludge.  This function is called from\n   get_spec_stats to determine the cardinality of a set derived\n   from a complemented string.  It's a kludge in that some of the\n   same operations are (duplicated) performed in set_initialize.  */\n\nstatic int\ncard_of_complement (struct Spec_list *s)\n{\n  int c;\n  int cardinality = N_CHARS;\n  bool in_set[N_CHARS] = { 0, };\n\n  s->state = BEGIN_STATE;\n  while ((c = get_next (s, nullptr)) != -1)\n    {\n      cardinality -= (!in_set[c]);\n      in_set[c] = true;\n    }\n  return cardinality;\n}\n\n/* Discard the lengths associated with a case conversion,\n   as using the actual number of upper or lower case characters\n   is problematic when they don't match in some locales.\n   Also ensure the case conversion classes in string2 are\n   aligned correctly with those in string1.\n   Note POSIX says the behavior of 'tr \"[:upper:]\" \"[:upper:]\"'\n   is undefined.  Therefore we allow it (unlike Solaris)\n   and treat it as a no-op.  */\n\nstatic void\nvalidate_case_classes (struct Spec_list *s1, struct Spec_list *s2)\n{\n  size_t n_upper = 0;\n  size_t n_lower = 0;\n  int c1 = 0;\n  int c2 = 0;\n  MAYBE_UNUSED count old_s1_len = s1->length, old_s2_len = s2->length;\n  struct List_element *s1_tail = s1->tail;\n  struct List_element *s2_tail = s2->tail;\n  bool s1_new_element = true;\n  bool s2_new_element = true;\n\n  if (complement || !s2->has_char_class)\n    return;\n\n  for (int i = 0; i < N_CHARS; i++)\n    {\n      if (isupper (i))\n        n_upper++;\n      if (islower (i))\n        n_lower++;\n    }\n\n  s1->state = BEGIN_STATE;\n  s2->state = BEGIN_STATE;\n\n  while (c1 != -1 && c2 != -1)\n    {\n      enum Upper_Lower_class class_s1, class_s2;\n\n      c1 = get_next (s1, &class_s1);\n      c2 = get_next (s2, &class_s2);\n\n      /* If c2 transitions to a new case class, then\n         c1 must also transition at the same time.  */\n      if (s2_new_element && class_s2 != UL_NONE\n          && !(s1_new_element && class_s1 != UL_NONE))\n        error (EXIT_FAILURE, 0,\n               _(\"misaligned [:upper:] and/or [:lower:] construct\"));\n\n      /* If case converting, quickly skip over the elements.  */\n      if (class_s2 != UL_NONE)\n        {\n          skip_construct (s1);\n          skip_construct (s2);\n          /* Discount insignificant/problematic lengths.  */\n          s1->length -= (class_s1 == UL_UPPER ? n_upper : n_lower) - 1;\n          s2->length -= (class_s2 == UL_UPPER ? n_upper : n_lower) - 1;\n        }\n\n      s1_new_element = s1->state == NEW_ELEMENT; /* Next element is new.  */\n      s2_new_element = s2->state == NEW_ELEMENT; /* Next element is new.  */\n    }\n\n  affirm (old_s1_len >= s1->length && old_s2_len >= s2->length);\n\n  s1->tail = s1_tail;\n  s2->tail = s2_tail;\n}\n\n/* Gather statistics about the spec-list S in preparation for the tests\n   in validate that determine the consistency of the specs.  This function\n   is called at most twice; once for string1, and again for any string2.\n   LEN_S1 < 0 indicates that this is the first call and that S represents\n   string1.  When LEN_S1 >= 0, it is the length of the expansion of the\n   constructs in string1, and we can use its value to resolve any\n   indefinite repeat construct in S (which represents string2).  Hence,\n   this function has the side-effect that it converts a valid [c*]\n   construct in string2 to [c*n] where n is large enough (or 0) to give\n   string2 the same length as string1.  For example, with the command\n   tr a-z 'A[\\n*]Z' on the second call to get_spec_stats, LEN_S1 would\n   be 26 and S (representing string2) would be converted to 'A[\\n*24]Z'.  */\n\nstatic void\nget_spec_stats (struct Spec_list *s)\n{\n  struct List_element *p;\n  count length = 0;\n\n  s->n_indefinite_repeats = 0;\n  s->has_equiv_class = false;\n  s->has_restricted_char_class = false;\n  s->has_char_class = false;\n  for (p = s->head->next; p; p = p->next)\n    {\n      count len = 0;\n      count new_length;\n\n      switch (p->type)\n        {\n        case RE_NORMAL_CHAR:\n          len = 1;\n          break;\n\n        case RE_RANGE:\n          affirm (p->u.range.last_char >= p->u.range.first_char);\n          len = p->u.range.last_char - p->u.range.first_char + 1;\n          break;\n\n        case RE_CHAR_CLASS:\n          s->has_char_class = true;\n          for (int i = 0; i < N_CHARS; i++)\n            if (is_char_class_member (p->u.char_class, i))\n              ++len;\n          switch (p->u.char_class)\n            {\n            case CC_UPPER:\n            case CC_LOWER:\n              break;\n            default:\n              s->has_restricted_char_class = true;\n              break;\n            }\n          break;\n\n        case RE_EQUIV_CLASS:\n          for (int i = 0; i < N_CHARS; i++)\n            if (is_equiv_class_member (p->u.equiv_code, i))\n              ++len;\n          s->has_equiv_class = true;\n          break;\n\n        case RE_REPEATED_CHAR:\n          if (p->u.repeated_char.repeat_count > 0)\n            len = p->u.repeated_char.repeat_count;\n          else\n            {\n              s->indefinite_repeat_element = p;\n              ++(s->n_indefinite_repeats);\n            }\n          break;\n\n        default:\n          unreachable ();\n        }\n\n      /* Check for arithmetic overflow in computing length.  Also, reject\n         any length greater than the maximum repeat count, in case the\n         length is later used to compute the repeat count for an\n         indefinite element.  */\n      new_length = length + len;\n      if (! (length <= new_length && new_length <= REPEAT_COUNT_MAXIMUM))\n        error (EXIT_FAILURE, 0, _(\"too many characters in set\"));\n      length = new_length;\n    }\n\n  s->length = length;\n}\n\nstatic void\nget_s1_spec_stats (struct Spec_list *s1)\n{\n  get_spec_stats (s1);\n  if (complement)\n    s1->length = card_of_complement (s1);\n}\n\nstatic void\nget_s2_spec_stats (struct Spec_list *s2, count len_s1)\n{\n  get_spec_stats (s2);\n  if (len_s1 >= s2->length && s2->n_indefinite_repeats == 1)\n    {\n      s2->indefinite_repeat_element->u.repeated_char.repeat_count =\n        len_s1 - s2->length;\n      s2->length = len_s1;\n    }\n}\n\nstatic void\nspec_init (struct Spec_list *spec_list)\n{\n  struct List_element *new = xmalloc (sizeof *new);\n  spec_list->head = spec_list->tail = new;\n  spec_list->head->next = nullptr;\n}\n\n/* This function makes two passes over the argument string S.  The first\n   one converts all \\c and \\ddd escapes to their one-byte representations.\n   The second constructs a linked specification list, SPEC_LIST, of the\n   characters and constructs that comprise the argument string.  If either\n   of these passes detects an error, this function returns false.  */\n\nstatic bool\nparse_str (char const *s, struct Spec_list *spec_list)\n{\n  struct E_string es;\n  bool ok = unquote (s, &es) && build_spec_list (&es, spec_list);\n  es_free (&es);\n  return ok;\n}\n\n/* Given two specification lists, S1 and S2, and assuming that\n   S1->length > S2->length, append a single [c*n] element to S2 where c\n   is the last character in the expansion of S2 and n is the difference\n   between the two lengths.\n   Upon successful completion, S2->length is set to S1->length.  The only\n   way this function can fail to make S2 as long as S1 is when S2 has\n   zero-length, since in that case, there is no last character to repeat.\n   So S2->length is required to be at least 1.  */\n\nstatic void\nstring2_extend (const struct Spec_list *s1, struct Spec_list *s2)\n{\n  struct List_element *p;\n  unsigned char char_to_repeat;\n\n  affirm (translating);\n  affirm (s1->length > s2->length);\n  affirm (s2->length > 0);\n\n  p = s2->tail;\n  switch (p->type)\n    {\n    case RE_NORMAL_CHAR:\n      char_to_repeat = p->u.normal_char;\n      break;\n    case RE_RANGE:\n      char_to_repeat = p->u.range.last_char;\n      break;\n    case RE_CHAR_CLASS:\n      /* Note BSD allows extending of classes in string2.  For example:\n           tr '[:upper:]0-9' '[:lower:]'\n         That's not portable however, contradicts POSIX and is dependent\n         on your collating sequence.  */\n      error (EXIT_FAILURE, 0,\n             _(\"when translating with string1 longer than string2,\\n\"\n               \"the latter string must not end with a character class\"));\n\n    case RE_REPEATED_CHAR:\n      char_to_repeat = p->u.repeated_char.the_repeated_char;\n      break;\n\n    case RE_EQUIV_CLASS:\n      /* This shouldn't happen, because validate exits with an error\n         if it finds an equiv class in string2 when translating.  */\n      affirm (false);\n\n    default:\n      unreachable ();\n    }\n\n  append_repeated_char (s2, char_to_repeat, s1->length - s2->length);\n  s2->length = s1->length;\n}\n\n/* Return true if S is a non-empty list in which exactly one\n   character (but potentially, many instances of it) appears.\n   E.g., [X*] or xxxxxxxx.  */\n\nstatic bool\nhomogeneous_spec_list (struct Spec_list *s)\n{\n  int b, c;\n\n  s->state = BEGIN_STATE;\n\n  if ((b = get_next (s, nullptr)) == -1)\n    return false;\n\n  while ((c = get_next (s, nullptr)) != -1)\n    if (c != b)\n      return false;\n\n  return true;\n}\n\n/* Die with an error message if S1 and S2 describe strings that\n   are not valid with the given command line switches.\n   A side effect of this function is that if a valid [c*] or\n   [c*0] construct appears in string2, it is converted to [c*n]\n   with a value for n that makes s2->length == s1->length.  By\n   the same token, if the --truncate-set1 option is not\n   given, S2 may be extended.  */\n\nstatic void\nvalidate (struct Spec_list *s1, struct Spec_list *s2)\n{\n  get_s1_spec_stats (s1);\n  if (s1->n_indefinite_repeats > 0)\n    error (EXIT_FAILURE, 0,\n           _(\"the [c*] repeat construct may not appear in string1\"));\n\n  if (s2)\n    {\n      get_s2_spec_stats (s2, s1->length);\n\n      if (s2->n_indefinite_repeats > 1)\n        error (EXIT_FAILURE, 0,\n               _(\"only one [c*] repeat construct may appear in string2\"));\n\n      if (translating)\n        {\n          if (s2->has_equiv_class)\n            error (EXIT_FAILURE, 0,\n                   _(\"[=c=] expressions may not appear in string2\"\n                     \" when translating\"));\n\n          if (s2->has_restricted_char_class)\n            error (EXIT_FAILURE, 0,\n                   _(\"when translating, the only character classes\"\n                     \" that may appear in\\n\"\n                     \"string2 are 'upper' and 'lower'\"));\n\n          validate_case_classes (s1, s2);\n\n          if (s1->length > s2->length)\n            {\n              if (!truncate_set1)\n                {\n                  /* string2 must be non-empty unless --truncate-set1 is\n                     given or string1 is empty.  */\n\n                  if (s2->length == 0)\n                    error (EXIT_FAILURE, 0,\n                           _(\"when not truncating set1,\"\n                             \" string2 must be non-empty\"));\n                  string2_extend (s1, s2);\n                }\n            }\n\n          if (complement && s1->has_char_class\n              && ! (s2->length == s1->length && homogeneous_spec_list (s2)))\n            error (EXIT_FAILURE, 0,\n                   _(\"when translating with complemented character classes,\\n\"\n                     \"string2 must map all characters in the domain to one\"));\n        }\n      else\n        /* Not translating.  */\n        {\n          if (s2->n_indefinite_repeats > 0)\n            error (EXIT_FAILURE, 0,\n                   _(\"the [c*] construct may appear in string2\"\n                     \" only when translating\"));\n        }\n    }\n}\n\n/* Read buffers of SIZE bytes via the function READER (if READER is\n   null, read from stdin) until EOF.  When non-null, READER is either\n   read_and_delete or read_and_xlate.  After each buffer is read, it is\n   processed and written to stdout.  The buffers are processed so that\n   multiple consecutive occurrences of the same character in the input\n   stream are replaced by a single occurrence of that character if the\n   character is in the squeeze set.  */\n\nstatic void\nsqueeze_filter (char *buf, size_t size, size_t (*reader) (char *, size_t))\n{\n  /* A value distinct from any character that may have been stored in a\n     buffer as the result of a block-read in the function squeeze_filter.  */\n  const int NOT_A_CHAR = INT_MAX;\n\n  int char_to_squeeze = NOT_A_CHAR;\n  size_t i = 0;\n  size_t nr = 0;\n\n  while (true)\n    {\n      if (i >= nr)\n        {\n          nr = reader (buf, size);\n          if (nr == 0)\n            break;\n          i = 0;\n        }\n\n      size_t begin = i;\n\n      if (char_to_squeeze == NOT_A_CHAR)\n        {\n          size_t out_len;\n          /* Here, by being a little tricky, we can get a significant\n             performance increase in most cases when the input is\n             reasonably large.  Since tr will modify the input only\n             if two consecutive (and identical) input characters are\n             in the squeeze set, we can step by two through the data\n             when searching for a character in the squeeze set.  This\n             means there may be a little more work in a few cases and\n             perhaps twice as much work in the worst cases where most\n             of the input is removed by squeezing repeats.  But most\n             uses of this functionality seem to remove less than 20-30%\n             of the input.  */\n          for (; i < nr && !in_squeeze_set[to_uchar (buf[i])]; i += 2)\n            continue;\n\n          /* There is a special case when i == nr and we've just\n             skipped a character (the last one in buf) that is in\n             the squeeze set.  */\n          if (i == nr && in_squeeze_set[to_uchar (buf[i - 1])])\n            --i;\n\n          if (i >= nr)\n            out_len = nr - begin;\n          else\n            {\n              char_to_squeeze = buf[i];\n              /* We're about to output buf[begin..i].  */\n              out_len = i - begin + 1;\n\n              /* But since we stepped by 2 in the loop above,\n                 out_len may be one too large.  */\n              if (i > 0 && buf[i - 1] == char_to_squeeze)\n                --out_len;\n\n              /* Advance i to the index of first character to be\n                 considered when looking for a char different from\n                 char_to_squeeze.  */\n              ++i;\n            }\n          if (out_len > 0\n              && fwrite (&buf[begin], 1, out_len, stdout) != out_len)\n            write_error ();\n        }\n\n      if (char_to_squeeze != NOT_A_CHAR)\n        {\n          /* Advance i to index of first char != char_to_squeeze\n             (or to nr if all the rest of the characters in this\n             buffer are the same as char_to_squeeze).  */\n          for (; i < nr && buf[i] == char_to_squeeze; i++)\n            continue;\n          if (i < nr)\n            char_to_squeeze = NOT_A_CHAR;\n          /* If (i >= nr) we've squeezed the last character in this buffer.\n             So now we have to read a new buffer and continue comparing\n             characters against char_to_squeeze.  */\n        }\n    }\n}\n\nstatic size_t\nplain_read (char *buf, size_t size)\n{\n  size_t nr = safe_read (STDIN_FILENO, buf, size);\n  if (nr == SAFE_READ_ERROR)\n    error (EXIT_FAILURE, errno, _(\"read error\"));\n  return nr;\n}\n\n/* Read buffers of SIZE bytes from stdin until one is found that\n   contains at least one character not in the delete set.  Store\n   in the array BUF, all characters from that buffer that are not\n   in the delete set, and return the number of characters saved\n   or 0 upon EOF.  */\n\nstatic size_t\nread_and_delete (char *buf, size_t size)\n{\n  size_t n_saved;\n\n  /* This enclosing do-while loop is to make sure that\n     we don't return zero (indicating EOF) when we've\n     just deleted all the characters in a buffer.  */\n  do\n    {\n      size_t nr = plain_read (buf, size);\n\n      if (nr == 0)\n        return 0;\n\n      /* This first loop may be a waste of code, but gives much\n         better performance when no characters are deleted in\n         the beginning of a buffer.  It just avoids the copying\n         of buf[i] into buf[n_saved] when it would be a NOP.  */\n\n      size_t i;\n      for (i = 0; i < nr && !in_delete_set[to_uchar (buf[i])]; i++)\n        continue;\n      n_saved = i;\n\n      for (++i; i < nr; i++)\n        if (!in_delete_set[to_uchar (buf[i])])\n          buf[n_saved++] = buf[i];\n    }\n  while (n_saved == 0);\n\n  return n_saved;\n}\n\n/* Read at most SIZE bytes from stdin into the array BUF.  Then\n   perform the in-place and one-to-one mapping specified by the global\n   array 'xlate'.  Return the number of characters read, or 0 upon EOF.  */\n\nstatic size_t\nread_and_xlate (char *buf, size_t size)\n{\n  size_t bytes_read = plain_read (buf, size);\n\n  for (size_t i = 0; i < bytes_read; i++)\n    buf[i] = xlate[to_uchar (buf[i])];\n\n  return bytes_read;\n}\n\n/* Initialize a boolean membership set, IN_SET, with the character\n   values obtained by traversing the linked list of constructs S\n   using the function 'get_next'.  IN_SET is expected to have been\n   initialized to all zeros by the caller.  If COMPLEMENT_THIS_SET\n   is true the resulting set is complemented.  */\n\nstatic void\nset_initialize (struct Spec_list *s, bool complement_this_set, bool *in_set)\n{\n  int c;\n\n  s->state = BEGIN_STATE;\n  while ((c = get_next (s, nullptr)) != -1)\n    in_set[c] = true;\n  if (complement_this_set)\n    for (size_t i = 0; i < N_CHARS; i++)\n      in_set[i] = (!in_set[i]);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n  int non_option_args;\n  int min_operands;\n  int max_operands;\n  struct Spec_list buf1, buf2;\n  struct Spec_list *s1 = &buf1;\n  struct Spec_list *s2 = &buf2;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"+AcCdst\", long_options, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'A':\n          /* Undocumented option, for compatibility with AIX.  */\n          setlocale (LC_COLLATE, \"C\");\n          setlocale (LC_CTYPE, \"C\");\n          break;\n\n        case 'c':\n        case 'C':\n          complement = true;\n          break;\n\n        case 'd':\n          delete = true;\n          break;\n\n        case 's':\n          squeeze_repeats = true;\n          break;\n\n        case 't':\n          truncate_set1 = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n          break;\n        }\n    }\n\n  non_option_args = argc - optind;\n  translating = (non_option_args == 2 && !delete);\n  min_operands = 1 + (delete == squeeze_repeats);\n  max_operands = 1 + (delete <= squeeze_repeats);\n\n  if (non_option_args < min_operands)\n    {\n      if (non_option_args == 0)\n        error (0, 0, _(\"missing operand\"));\n      else\n        {\n          error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n          fprintf (stderr, \"%s\\n\",\n                   _(squeeze_repeats\n                     ? N_(\"Two strings must be given when \"\n                          \"both deleting and squeezing repeats.\")\n                     : N_(\"Two strings must be given when translating.\")));\n        }\n      usage (EXIT_FAILURE);\n    }\n\n  if (max_operands < non_option_args)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + max_operands]));\n      if (non_option_args == 2)\n        fprintf (stderr, \"%s\\n\",\n                 _(\"Only one string may be given when \"\n                   \"deleting without squeezing repeats.\"));\n      usage (EXIT_FAILURE);\n    }\n\n  spec_init (s1);\n  if (!parse_str (argv[optind], s1))\n    main_exit (EXIT_FAILURE);\n\n  if (non_option_args == 2)\n    {\n      spec_init (s2);\n      if (!parse_str (argv[optind + 1], s2))\n        main_exit (EXIT_FAILURE);\n    }\n  else\n    s2 = nullptr;\n\n  validate (s1, s2);\n\n  /* Use binary I/O, since 'tr' is sometimes used to transliterate\n     non-printable characters, or characters which are stripped away\n     by text-mode reads (like CR and ^Z).  */\n  xset_binary_mode (STDIN_FILENO, O_BINARY);\n  xset_binary_mode (STDOUT_FILENO, O_BINARY);\n  fadvise (stdin, FADVISE_SEQUENTIAL);\n\n  if (squeeze_repeats && non_option_args == 1)\n    {\n      set_initialize (s1, complement, in_squeeze_set);\n      squeeze_filter (io_buf, sizeof io_buf, plain_read);\n    }\n  else if (delete && non_option_args == 1)\n    {\n      set_initialize (s1, complement, in_delete_set);\n\n      while (true)\n        {\n          size_t nr = read_and_delete (io_buf, sizeof io_buf);\n          if (nr == 0)\n            break;\n          if (fwrite (io_buf, 1, nr, stdout) != nr)\n            write_error ();\n        }\n    }\n  else if (squeeze_repeats && delete && non_option_args == 2)\n    {\n      set_initialize (s1, complement, in_delete_set);\n      set_initialize (s2, false, in_squeeze_set);\n      squeeze_filter (io_buf, sizeof io_buf, read_and_delete);\n    }\n  else if (translating)\n    {\n      if (complement)\n        {\n          bool *in_s1 = in_delete_set;\n\n          set_initialize (s1, false, in_s1);\n          s2->state = BEGIN_STATE;\n          for (int i = 0; i < N_CHARS; i++)\n            xlate[i] = i;\n          for (int i = 0; i < N_CHARS; i++)\n            {\n              if (!in_s1[i])\n                {\n                  int ch = get_next (s2, nullptr);\n                  affirm (ch != -1 || truncate_set1);\n                  if (ch == -1)\n                    {\n                      /* This will happen when tr is invoked like e.g.\n                         tr -cs A-Za-z0-9 '\\012'.  */\n                      break;\n                    }\n                  xlate[i] = ch;\n                }\n            }\n        }\n      else\n        {\n          int c1, c2;\n          enum Upper_Lower_class class_s1;\n          enum Upper_Lower_class class_s2;\n\n          for (int i = 0; i < N_CHARS; i++)\n            xlate[i] = i;\n          s1->state = BEGIN_STATE;\n          s2->state = BEGIN_STATE;\n          while (true)\n            {\n              c1 = get_next (s1, &class_s1);\n              c2 = get_next (s2, &class_s2);\n\n              if (class_s1 == UL_LOWER && class_s2 == UL_UPPER)\n                {\n                  for (int i = 0; i < N_CHARS; i++)\n                    if (islower (i))\n                      xlate[i] = toupper (i);\n                }\n              else if (class_s1 == UL_UPPER && class_s2 == UL_LOWER)\n                {\n                  for (int i = 0; i < N_CHARS; i++)\n                    if (isupper (i))\n                      xlate[i] = tolower (i);\n                }\n              else\n                {\n                  /* The following should have been checked by validate...  */\n                  if (c1 == -1 || c2 == -1)\n                    break;\n                  xlate[c1] = c2;\n                }\n\n              /* When case-converting, skip the elements as an optimization.  */\n              if (class_s2 != UL_NONE)\n                {\n                  skip_construct (s1);\n                  skip_construct (s2);\n                }\n            }\n          affirm (c1 == -1 || truncate_set1);\n        }\n      if (squeeze_repeats)\n        {\n          set_initialize (s2, false, in_squeeze_set);\n          squeeze_filter (io_buf, sizeof io_buf, read_and_xlate);\n        }\n      else\n        {\n          while (true)\n            {\n              size_t bytes_read = read_and_xlate (io_buf, sizeof io_buf);\n              if (bytes_read == 0)\n                break;\n              if (fwrite (io_buf, 1, bytes_read, stdout) != bytes_read)\n                write_error ();\n            }\n        }\n    }\n\n  if (close (STDIN_FILENO) != 0)\n    error (EXIT_FAILURE, errno, _(\"standard input\"));\n\n  main_exit (EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}