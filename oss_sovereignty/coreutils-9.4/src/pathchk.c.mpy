{
  "module_name": "pathchk.c",
  "hash_id": "b457f891dcf87f70285efe3fcb9a34bcb88fea032d286719b367c4757a221dad",
  "original_prompt": "Ingested from coreutils-9.4/src/pathchk.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"pathchk\"\n\n#define AUTHORS \\\n  proper_name (\"Paul Eggert\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\n#ifndef _POSIX_PATH_MAX\n# define _POSIX_PATH_MAX 256\n#endif\n#ifndef _POSIX_NAME_MAX\n# define _POSIX_NAME_MAX 14\n#endif\n\n#ifdef _XOPEN_NAME_MAX\n# define NAME_MAX_MINIMUM _XOPEN_NAME_MAX\n#else\n# define NAME_MAX_MINIMUM _POSIX_NAME_MAX\n#endif\n#ifdef _XOPEN_PATH_MAX\n# define PATH_MAX_MINIMUM _XOPEN_PATH_MAX\n#else\n# define PATH_MAX_MINIMUM _POSIX_PATH_MAX\n#endif\n\n#if ! (HAVE_PATHCONF && defined _PC_NAME_MAX && defined _PC_PATH_MAX)\n# ifndef _PC_NAME_MAX\n#  define _PC_NAME_MAX 0\n#  define _PC_PATH_MAX 1\n# endif\n# ifndef pathconf\n#  define pathconf(file, flag) \\\n     (flag == _PC_NAME_MAX ? NAME_MAX_MINIMUM : PATH_MAX_MINIMUM)\n# endif\n#endif\n\nstatic bool validate_file_name (char *, bool, bool);\n\n \nenum\n{\n  PORTABILITY_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const longopts[] =\n{\n  {\"portability\", no_argument, nullptr, PORTABILITY_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... NAME...\\n\"), program_name);\n      fputs (_(\"\\\nDiagnose invalid or non-portable file names.\\n\\\n\\n\\\n  -p                  check for most POSIX systems\\n\\\n  -P                  check for empty names and leading \\\"-\\\"\\n\\\n      --portability   check for all POSIX systems (equivalent to -p -P)\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool ok = true;\n  bool check_basic_portability = false;\n  bool check_extra_portability = false;\n  int optc;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"+pP\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case PORTABILITY_OPTION:\n          check_basic_portability = true;\n          check_extra_portability = true;\n          break;\n\n        case 'p':\n          check_basic_portability = true;\n          break;\n\n        case 'P':\n          check_extra_portability = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind == argc)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  for (; optind < argc; ++optind)\n    ok &= validate_file_name (argv[optind],\n                              check_basic_portability, check_extra_portability);\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n/* If FILE contains a component with a leading \"-\", report an error\n   and return false; otherwise, return true.  */\n\nstatic bool\nno_leading_hyphen (char const *file)\n{\n  char const *p;\n\n  for (p = file;  (p = strchr (p, '-'));  p++)\n    if (p == file || p[-1] == '/')\n      {\n        error (0, 0, _(\"leading '-' in a component of file name %s\"),\n               quoteaf (file));\n        return false;\n      }\n\n  return true;\n}\n\n/* If FILE (of length FILELEN) contains only portable characters,\n   return true, else report an error and return false.  */\n\nstatic bool\nportable_chars_only (char const *file, size_t filelen)\n{\n  size_t validlen = strspn (file,\n                            (\"/\"\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                             \"abcdefghijklmnopqrstuvwxyz\"\n                             \"0123456789._-\"));\n  char const *invalid = file + validlen;\n\n  if (*invalid)\n    {\n      mbstate_t mbstate = { 0, };\n      size_t charlen = mbrlen (invalid, filelen - validlen, &mbstate);\n      error (0, 0,\n             _(\"non-portable character %s in file name %s\"),\n             quotearg_n_style_mem (1, locale_quoting_style, invalid,\n                                   (charlen <= MB_LEN_MAX ? charlen : 1)),\n             quoteaf_n (0, file));\n      return false;\n    }\n\n  return true;\n}\n\n/* Return the address of the start of the next file name component in F.  */\n\nATTRIBUTE_PURE\nstatic char *\ncomponent_start (char *f)\n{\n  while (*f == '/')\n    f++;\n  return f;\n}\n\n/* Return the size of the file name component F.  F must be nonempty.  */\n\nATTRIBUTE_PURE\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n/* Make sure that\n   strlen (FILE) <= PATH_MAX\n   && strlen (each-existing-directory-in-FILE) <= NAME_MAX\n\n   If CHECK_BASIC_PORTABILITY is true, compare against _POSIX_PATH_MAX and\n   _POSIX_NAME_MAX instead, and make sure that FILE contains no\n   characters not in the POSIX portable filename character set, which\n   consists of A-Z, a-z, 0-9, ., _, - (plus / for separators).\n\n   If CHECK_BASIC_PORTABILITY is false, make sure that all leading directories\n   along FILE that exist are searchable.\n\n   If CHECK_EXTRA_PORTABILITY is true, check that file name components do not\n   begin with \"-\".\n\n   If either CHECK_BASIC_PORTABILITY or CHECK_EXTRA_PORTABILITY is true,\n   check that the file name is not empty.\n\n   Return true if all of these tests are successful, false if any fail.  */\n\nstatic bool\nvalidate_file_name (char *file, bool check_basic_portability,\n                    bool check_extra_portability)\n{\n  idx_t filelen = strlen (file);\n\n  /* Start of file name component being checked.  */\n  char *start;\n\n  /* True if component lengths need to be checked.  */\n  bool check_component_lengths;\n\n  /* True if the file is known to exist.  */\n  bool file_exists = false;\n\n  if (check_extra_portability && ! no_leading_hyphen (file))\n    return false;\n\n  if ((check_basic_portability || check_extra_portability)\n      && filelen == 0)\n    {\n      /* Fail, since empty names are not portable.  As of\n         2005-01-06 POSIX does not address whether \"pathchk -p ''\"\n         should (or is allowed to) fail, so this is not a\n         conformance violation.  */\n      error (0, 0, _(\"empty file name\"));\n      return false;\n    }\n\n  if (check_basic_portability)\n    {\n      if (! portable_chars_only (file, filelen))\n        return false;\n    }\n  else\n    {\n      /* Check whether a file name component is in a directory that\n         is not searchable, or has some other serious problem.\n         POSIX does not allow \"\" as a file name, but some non-POSIX\n         hosts do (as an alias for \".\"), so allow \"\" if lstat does.  */\n\n      struct stat st;\n      if (lstat (file, &st) == 0)\n        file_exists = true;\n      else if (errno != ENOENT || filelen == 0)\n        {\n          error (0, errno, \"%s\", quotef (file));\n          return false;\n        }\n    }\n\n  if (check_basic_portability\n      || (! file_exists && PATH_MAX_MINIMUM <= filelen))\n    {\n      idx_t maxsize;\n\n      if (check_basic_portability)\n        maxsize = _POSIX_PATH_MAX;\n      else\n        {\n          long int size;\n          char const *dir = (*file == '/' ? \"/\" : \".\");\n          errno = 0;\n          size = pathconf (dir, _PC_PATH_MAX);\n          if (size < 0 && errno != 0)\n            {\n              error (0, errno,\n                     _(\"%s: unable to determine maximum file name length\"),\n                     dir);\n              return false;\n            }\n          maxsize = MIN (size, MIN (SSIZE_MAX, IDX_MAX));\n        }\n\n      if (maxsize <= filelen)\n        {\n          error (0, 0, _(\"limit %td exceeded by length %td of file name %s\"),\n                 maxsize - 1, filelen, quoteaf (file));\n          return false;\n        }\n    }\n\n  /* Check whether pathconf (..., _PC_NAME_MAX) can be avoided, i.e.,\n     whether all file name components are so short that they are valid\n     in any file system on this platform.  If CHECK_BASIC_PORTABILITY, though,\n     it's more convenient to check component lengths below.  */\n\n  check_component_lengths = check_basic_portability;\n  if (! check_component_lengths && ! file_exists)\n    {\n      for (start = file; *(start = component_start (start)); )\n        {\n          size_t length = component_len (start);\n\n          if (NAME_MAX_MINIMUM < length)\n            {\n              check_component_lengths = true;\n              break;\n            }\n\n          start += length;\n        }\n    }\n\n  if (check_component_lengths)\n    {\n      /* The limit on file name components for the current component.\n         This defaults to NAME_MAX_MINIMUM, for the sake of non-POSIX\n         systems (NFS, say?) where pathconf fails on \".\" or \"/\" with\n         errno == ENOENT.  */\n      idx_t name_max = NAME_MAX_MINIMUM;\n\n      /* If nonzero, the known limit on file name components.  */\n      idx_t known_name_max = check_basic_portability ? _POSIX_NAME_MAX : 0;\n\n      for (start = file; *(start = component_start (start)); )\n        {\n          idx_t length;\n\n          if (known_name_max)\n            name_max = known_name_max;\n          else\n            {\n              long int len;\n              char const *dir = (start == file ? \".\" : file);\n              char c = *start;\n              errno = 0;\n              *start = '\\0';\n              len = pathconf (dir, _PC_NAME_MAX);\n              *start = c;\n              if (0 <= len)\n                name_max = MIN (len, MIN (SSIZE_MAX, IDX_MAX));\n              else\n                switch (errno)\n                  {\n                  case 0:\n                    /* There is no limit.  */\n                    name_max = IDX_MAX;\n                    break;\n\n                  case ENOENT:\n                    /* DIR does not exist; use its parent's maximum.  */\n                    known_name_max = name_max;\n                    break;\n\n                  default:\n                    *start = '\\0';\n                    error (0, errno, \"%s\", quotef (dir));\n                    *start = c;\n                    return false;\n                  }\n            }\n\n          length = component_len (start);\n\n          if (name_max < length)\n            {\n              char c = start[length];\n              start[length] = '\\0';\n              error (0, 0,\n                     _(\"limit %td exceeded by length %td \"\n                       \"of file name component %s\"),\n                     name_max, length, quote (start));\n              start[length] = c;\n              return false;\n            }\n\n          start += length;\n        }\n    }\n\n  return true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}