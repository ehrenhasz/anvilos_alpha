{
  "module_name": "tail.c",
  "hash_id": "595df357918405b3f1329d0300dd8ccb6ff2d42e3ac8208fd0981f5f580544a6",
  "original_prompt": "Ingested from coreutils-9.4/src/tail.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <signal.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"cl-strtod.h\"\n#include \"fcntl--.h\"\n#include \"iopoll.h\"\n#include \"isapipe.h\"\n#include \"posixver.h\"\n#include \"quote.h\"\n#include \"safe-read.h\"\n#include \"stat-size.h\"\n#include \"stat-time.h\"\n#include \"xbinary-io.h\"\n#include \"xdectoint.h\"\n#include \"xnanosleep.h\"\n#include \"xstrtol.h\"\n#include \"xstrtod.h\"\n\n#if HAVE_INOTIFY\n# include \"hash.h\"\n# include <poll.h>\n# include <sys/inotify.h>\n#endif\n\n \n#if defined __linux__ || defined __ANDROID__\n# include \"fs.h\"\n# include \"fs-is-local.h\"\n# if HAVE_SYS_STATFS_H\n#  include <sys/statfs.h>\n# elif HAVE_SYS_VFS_H\n#  include <sys/vfs.h>\n# endif\n#endif\n\n \n#define PROGRAM_NAME \"tail\"\n\n#define AUTHORS \\\n  proper_name (\"Paul Rubin\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Ian Lance Taylor\"), \\\n  proper_name (\"Jim Meyering\")\n\n \n#define DEFAULT_N_LINES 10\n\n \n#define COPY_TO_EOF UINTMAX_MAX\n#define COPY_A_BUFFER (UINTMAX_MAX - 1)\n\n \n#define DEFAULT_FOLLOW_MODE Follow_descriptor\n\nenum Follow_mode\n{\n   \n  Follow_name = 1,\n\n   \n  Follow_descriptor = 2\n};\n\n \n#define IS_TAILABLE_FILE_TYPE(Mode) \\\n  (S_ISREG (Mode) || S_ISFIFO (Mode) || S_ISSOCK (Mode) || S_ISCHR (Mode))\n\nstatic char const *const follow_mode_string[] =\n{\n  \"descriptor\", \"name\", nullptr\n};\n\nstatic enum Follow_mode const follow_mode_map[] =\n{\n  Follow_descriptor, Follow_name,\n};\n\nstruct File_spec\n{\n   \n  char *name;\n\n   \n  off_t size;\n  struct timespec mtime;\n  dev_t dev;\n  ino_t ino;\n  mode_t mode;\n\n   \n  bool ignore;\n\n   \n  bool remote;\n\n   \n  bool tailable;\n\n   \n  int fd;\n\n   \n  int errnum;\n\n   \n  int blocking;\n\n#if HAVE_INOTIFY\n   \n  int wd;\n\n   \n  int parent_wd;\n\n   \n  size_t basename_start;\n#endif\n\n   \n  uintmax_t n_unchanged_stats;\n};\n\n \nstatic bool reopen_inaccessible_files;\n\n \nstatic bool count_lines;\n\n \nstatic enum Follow_mode follow_mode = Follow_descriptor;\n\n \nstatic bool forever;\n\n \nstatic bool monitor_output;\n\n \nstatic bool from_start;\n\n \nstatic bool print_headers;\n\n \nstatic char line_end;\n\n \nenum header_mode\n{\n  multiple_files, always, never\n};\n\n \n#define DEFAULT_MAX_N_UNCHANGED_STATS_BETWEEN_OPENS 5\nstatic uintmax_t max_n_unchanged_stats_between_opens =\n  DEFAULT_MAX_N_UNCHANGED_STATS_BETWEEN_OPENS;\n\n \nstatic pid_t pid;\n\n \nstatic bool have_read_stdin;\n\n \nstatic bool presume_input_pipe;\n\n \nstatic bool disable_inotify;\n\n \nenum\n{\n  RETRY_OPTION = CHAR_MAX + 1,\n  MAX_UNCHANGED_STATS_OPTION,\n  PID_OPTION,\n  PRESUME_INPUT_PIPE_OPTION,\n  LONG_FOLLOW_OPTION,\n  DISABLE_INOTIFY_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"bytes\", required_argument, nullptr, 'c'},\n  {\"follow\", optional_argument, nullptr, LONG_FOLLOW_OPTION},\n  {\"lines\", required_argument, nullptr, 'n'},\n  {\"max-unchanged-stats\", required_argument, nullptr,\n   MAX_UNCHANGED_STATS_OPTION},\n  {\"-disable-inotify\", no_argument, nullptr,\n   DISABLE_INOTIFY_OPTION},  \n  {\"pid\", required_argument, nullptr, PID_OPTION},\n  {\"-presume-input-pipe\", no_argument, nullptr,\n   PRESUME_INPUT_PIPE_OPTION},  \n  {\"quiet\", no_argument, nullptr, 'q'},\n  {\"retry\", no_argument, nullptr, RETRY_OPTION},\n  {\"silent\", no_argument, nullptr, 'q'},\n  {\"sleep-interval\", required_argument, nullptr, 's'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      printf (_(\"\\\nPrint the last %d lines of each FILE to standard output.\\n\\\nWith more than one FILE, precede each with a header giving the file name.\\n\\\n\"), DEFAULT_N_LINES);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n     fputs (_(\"\\\n  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\\n\\\n                             output starting with byte NUM of each file\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -f, --follow[={name|descriptor}]\\n\\\n                           output appended data as the file grows;\\n\\\n                             an absent option argument means 'descriptor'\\n\\\n  -F                       same as --follow=name --retry\\n\\\n\"), stdout);\n     printf (_(\"\\\n  -n, --lines=[+]NUM       output the last NUM lines, instead of the last %d;\\n\\\n                             or use -n +NUM to skip NUM-1 lines at the start\\n\\\n\"),\n             DEFAULT_N_LINES\n             );\n     printf (_(\"\\\n      --max-unchanged-stats=N\\n\\\n                           with --follow=name, reopen a FILE which has not\\n\\\n                             changed size after N (default %d) iterations\\n\\\n                             to see if it has been unlinked or renamed\\n\\\n                             (this is the usual case of rotated log files);\\n\\\n                             with inotify, this option is rarely useful\\n\\\n\"),\n             DEFAULT_MAX_N_UNCHANGED_STATS_BETWEEN_OPENS\n             );\n     fputs (_(\"\\\n      --pid=PID            with -f, terminate after process ID, PID dies\\n\\\n  -q, --quiet, --silent    never output headers giving file names\\n\\\n      --retry              keep trying to open a file if it is inaccessible\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\\n\\\n                             (default 1.0) between iterations;\\n\\\n                             with inotify and --pid=P, check process P at\\n\\\n                             least once every N seconds\\n\\\n  -v, --verbose            always output headers giving file names\\n\\\n\"), stdout);\n     fputs (_(\"\\\n  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\\n\"), stdout);\n     fputs (HELP_OPTION_DESCRIPTION, stdout);\n     fputs (VERSION_OPTION_DESCRIPTION, stdout);\n     fputs (_(\"\\\n\\n\\\nNUM may have a multiplier suffix:\\n\\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\n\\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\n\\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\\n\\n\\\n\"), stdout);\n     fputs (_(\"\\\nWith --follow (-f), tail defaults to following the file descriptor, which\\n\\\nmeans that even if a tail'ed file is renamed, tail will continue to track\\n\\\nits end.  This default behavior is not desirable when you really want to\\n\\\ntrack the actual name of the file, not the file descriptor (e.g., log\\n\\\nrotation).  Use --follow=name in that case.  That causes tail to track the\\n\\\nnamed file in a way that accommodates renaming, removal and creation.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Ensure exit, either with SIGPIPE or EXIT_FAILURE status.  */\nstatic void\ndie_pipe (void)\n{\n  raise (SIGPIPE);\n  exit (EXIT_FAILURE);\n}\n\n/* If the output has gone away, then terminate\n   as we would if we had written to this output.  */\nstatic void\ncheck_output_alive (void)\n{\n  if (! monitor_output)\n    return;\n\n  if (iopoll (-1, STDOUT_FILENO, false) == IOPOLL_BROKEN_OUTPUT)\n    die_pipe ();\n}\n\nMAYBE_UNUSED static bool\nvalid_file_spec (struct File_spec const *f)\n{\n  /* Exactly one of the following subexpressions must be true. */\n  return ((f->fd == -1) ^ (f->errnum == 0));\n}\n\nstatic char const *\npretty_name (struct File_spec const *f)\n{\n  return (STREQ (f->name, \"-\") ? _(\"standard input\") : f->name);\n}\n\n/* Record a file F with descriptor FD, size SIZE, status ST, and\n   blocking status BLOCKING.  */\n\nstatic void\nrecord_open_fd (struct File_spec *f, int fd,\n                off_t size, struct stat const *st,\n                int blocking)\n{\n  f->fd = fd;\n  f->size = size;\n  f->mtime = get_stat_mtime (st);\n  f->dev = st->st_dev;\n  f->ino = st->st_ino;\n  f->mode = st->st_mode;\n  f->blocking = blocking;\n  f->n_unchanged_stats = 0;\n  f->ignore = false;\n}\n\n/* Close the file with descriptor FD and name FILENAME.  */\n\nstatic void\nclose_fd (int fd, char const *filename)\n{\n  if (fd != -1 && fd != STDIN_FILENO && close (fd))\n    {\n      error (0, errno, _(\"closing %s (fd=%d)\"), quoteaf (filename), fd);\n    }\n}\n\nstatic void\nwrite_header (char const *pretty_filename)\n{\n  static bool first_file = true;\n\n  printf (\"%s==> %s <==\\n\", (first_file ? \"\" : \"\\n\"), pretty_filename);\n  first_file = false;\n}\n\n/* Write N_BYTES from BUFFER to stdout.\n   Exit immediately on error with a single diagnostic.  */\n\nstatic void\nxwrite_stdout (char const *buffer, size_t n_bytes)\n{\n  if (n_bytes > 0 && fwrite (buffer, 1, n_bytes, stdout) < n_bytes)\n    {\n      clearerr (stdout); /* To avoid redundant close_stdout diagnostic.  */\n      error (EXIT_FAILURE, errno, _(\"error writing %s\"),\n             quoteaf (\"standard output\"));\n    }\n}\n\n/* Read and output N_BYTES of file PRETTY_FILENAME starting at the current\n   position in FD.  If N_BYTES is COPY_TO_EOF, then copy until end of file.\n   If N_BYTES is COPY_A_BUFFER, then copy at most one buffer's worth.\n   Return the number of bytes read from the file.  */\n\nstatic uintmax_t\ndump_remainder (bool want_header, char const *pretty_filename, int fd,\n                uintmax_t n_bytes)\n{\n  uintmax_t n_written;\n  uintmax_t n_remaining = n_bytes;\n\n  n_written = 0;\n  while (true)\n    {\n      char buffer[BUFSIZ];\n      size_t n = MIN (n_remaining, BUFSIZ);\n      size_t bytes_read = safe_read (fd, buffer, n);\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          if (errno != EAGAIN)\n            error (EXIT_FAILURE, errno, _(\"error reading %s\"),\n                   quoteaf (pretty_filename));\n          break;\n        }\n      if (bytes_read == 0)\n        break;\n      if (want_header)\n        {\n          write_header (pretty_filename);\n          want_header = false;\n        }\n      xwrite_stdout (buffer, bytes_read);\n      n_written += bytes_read;\n      if (n_bytes != COPY_TO_EOF)\n        {\n          n_remaining -= bytes_read;\n          if (n_remaining == 0 || n_bytes == COPY_A_BUFFER)\n            break;\n        }\n    }\n\n  return n_written;\n}\n\n/* Call lseek with the specified arguments, where file descriptor FD\n   corresponds to the file, FILENAME.\n   Give a diagnostic and exit nonzero if lseek fails.\n   Otherwise, return the resulting offset.  */\n\nstatic off_t\nxlseek (int fd, off_t offset, int whence, char const *filename)\n{\n  off_t new_offset = lseek (fd, offset, whence);\n  char buf[INT_BUFSIZE_BOUND (offset)];\n  char *s;\n\n  if (0 <= new_offset)\n    return new_offset;\n\n  s = offtostr (offset, buf);\n  switch (whence)\n    {\n    case SEEK_SET:\n      error (EXIT_FAILURE, errno, _(\"%s: cannot seek to offset %s\"),\n             quotef (filename), s);\n      break;\n    case SEEK_CUR:\n      error (EXIT_FAILURE, errno, _(\"%s: cannot seek to relative offset %s\"),\n             quotef (filename), s);\n      break;\n    case SEEK_END:\n      error (EXIT_FAILURE, errno,\n             _(\"%s: cannot seek to end-relative offset %s\"),\n             quotef (filename), s);\n      break;\n    default:\n      unreachable ();\n    }\n}\n\n/* Print the last N_LINES lines from the end of file FD.\n   Go backward through the file, reading 'BUFSIZ' bytes at a time (except\n   probably the first), until we hit the start of the file or have\n   read NUMBER newlines.\n   START_POS is the starting position of the read pointer for the file\n   associated with FD (may be nonzero).\n   END_POS is the file offset of EOF (one larger than offset of last byte).\n   Return true if successful.  */\n\nstatic bool\nfile_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n            off_t start_pos, off_t end_pos, uintmax_t *read_pos)\n{\n  char buffer[BUFSIZ];\n  size_t bytes_read;\n  off_t pos = end_pos;\n\n  if (n_lines == 0)\n    return true;\n\n  /* Set 'bytes_read' to the size of the last, probably partial, buffer;\n     0 < 'bytes_read' <= 'BUFSIZ'.  */\n  bytes_read = (pos - start_pos) % BUFSIZ;\n  if (bytes_read == 0)\n    bytes_read = BUFSIZ;\n  /* Make 'pos' a multiple of 'BUFSIZ' (0 if the file is short), so that all\n     reads will be on block boundaries, which might increase efficiency.  */\n  pos -= bytes_read;\n  xlseek (fd, pos, SEEK_SET, pretty_filename);\n  bytes_read = safe_read (fd, buffer, bytes_read);\n  if (bytes_read == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n      return false;\n    }\n  *read_pos = pos + bytes_read;\n\n  /* Count the incomplete line on files that don't end with a newline.  */\n  if (bytes_read && buffer[bytes_read - 1] != line_end)\n    --n_lines;\n\n  do\n    {\n      /* Scan backward, counting the newlines in this bufferfull.  */\n\n      size_t n = bytes_read;\n      while (n)\n        {\n          char const *nl;\n          nl = memrchr (buffer, line_end, n);\n          if (nl == nullptr)\n            break;\n          n = nl - buffer;\n          if (n_lines-- == 0)\n            {\n              /* If this newline isn't the last character in the buffer,\n                 output the part that is after it.  */\n              xwrite_stdout (nl + 1, bytes_read - (n + 1));\n              *read_pos += dump_remainder (false, pretty_filename, fd,\n                                           end_pos - (pos + bytes_read));\n              return true;\n            }\n        }\n\n      /* Not enough newlines in that bufferfull.  */\n      if (pos == start_pos)\n        {\n          /* Not enough lines in the file; print everything from\n             start_pos to the end.  */\n          xlseek (fd, start_pos, SEEK_SET, pretty_filename);\n          *read_pos = start_pos + dump_remainder (false, pretty_filename, fd,\n                                                  end_pos);\n          return true;\n        }\n      pos -= BUFSIZ;\n      xlseek (fd, pos, SEEK_SET, pretty_filename);\n\n      bytes_read = safe_read (fd, buffer, BUFSIZ);\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n          return false;\n        }\n\n      *read_pos = pos + bytes_read;\n    }\n  while (bytes_read > 0);\n\n  return true;\n}\n\n/* Print the last N_LINES lines from the end of the standard input,\n   open for reading as pipe FD.\n   Buffer the text as a linked list of LBUFFERs, adding them as needed.\n   Return true if successful.  */\n\nstatic bool\npipe_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n            uintmax_t *read_pos)\n{\n  struct linebuffer\n  {\n    char buffer[BUFSIZ];\n    size_t nbytes;\n    size_t nlines;\n    struct linebuffer *next;\n  };\n  typedef struct linebuffer LBUFFER;\n  LBUFFER *first, *last, *tmp;\n  size_t total_lines = 0;\t/* Total number of newlines in all buffers.  */\n  bool ok = true;\n  size_t n_read;\t\t/* Size in bytes of most recent read */\n\n  first = last = xmalloc (sizeof (LBUFFER));\n  first->nbytes = first->nlines = 0;\n  first->next = nullptr;\n  tmp = xmalloc (sizeof (LBUFFER));\n\n  /* Input is always read into a fresh buffer.  */\n  while (true)\n    {\n      n_read = safe_read (fd, tmp->buffer, BUFSIZ);\n      if (n_read == 0 || n_read == SAFE_READ_ERROR)\n        break;\n      tmp->nbytes = n_read;\n      *read_pos += n_read;\n      tmp->nlines = 0;\n      tmp->next = nullptr;\n\n      /* Count the number of newlines just read.  */\n      {\n        char const *buffer_end = tmp->buffer + n_read;\n        char const *p = tmp->buffer;\n        while ((p = memchr (p, line_end, buffer_end - p)))\n          {\n            ++p;\n            ++tmp->nlines;\n          }\n      }\n      total_lines += tmp->nlines;\n\n      /* If there is enough room in the last buffer read, just append the new\n         one to it.  This is because when reading from a pipe, 'n_read' can\n         often be very small.  */\n      if (tmp->nbytes + last->nbytes < BUFSIZ)\n        {\n          memcpy (&last->buffer[last->nbytes], tmp->buffer, tmp->nbytes);\n          last->nbytes += tmp->nbytes;\n          last->nlines += tmp->nlines;\n        }\n      else\n        {\n          /* If there's not enough room, link the new buffer onto the end of\n             the list, then either free up the oldest buffer for the next\n             read if that would leave enough lines, or else malloc a new one.\n             Some compaction mechanism is possible but probably not\n             worthwhile.  */\n          last = last->next = tmp;\n          if (total_lines - first->nlines > n_lines)\n            {\n              tmp = first;\n              total_lines -= first->nlines;\n              first = first->next;\n            }\n          else\n            tmp = xmalloc (sizeof (LBUFFER));\n        }\n    }\n\n  free (tmp);\n\n  if (n_read == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n      ok = false;\n      goto free_lbuffers;\n    }\n\n  /* If the file is empty, then bail out.  */\n  if (last->nbytes == 0)\n    goto free_lbuffers;\n\n  /* This prevents a core dump when the pipe contains no newlines.  */\n  if (n_lines == 0)\n    goto free_lbuffers;\n\n  /* Count the incomplete line on files that don't end with a newline.  */\n  if (last->buffer[last->nbytes - 1] != line_end)\n    {\n      ++last->nlines;\n      ++total_lines;\n    }\n\n  /* Run through the list, printing lines.  First, skip over unneeded\n     buffers.  */\n  for (tmp = first; total_lines - tmp->nlines > n_lines; tmp = tmp->next)\n    total_lines -= tmp->nlines;\n\n  /* Find the correct beginning, then print the rest of the file.  */\n  {\n    char const *beg = tmp->buffer;\n    char const *buffer_end = tmp->buffer + tmp->nbytes;\n    if (total_lines > n_lines)\n      {\n        /* Skip 'total_lines' - 'n_lines' newlines.  We made sure that\n           'total_lines' - 'n_lines' <= 'tmp->nlines'.  */\n        size_t j;\n        for (j = total_lines - n_lines; j; --j)\n          {\n            beg = rawmemchr (beg, line_end);\n            ++beg;\n          }\n      }\n\n    xwrite_stdout (beg, buffer_end - beg);\n  }\n\n  for (tmp = tmp->next; tmp; tmp = tmp->next)\n    xwrite_stdout (tmp->buffer, tmp->nbytes);\n\nfree_lbuffers:\n  while (first)\n    {\n      tmp = first->next;\n      free (first);\n      first = tmp;\n    }\n  return ok;\n}\n\n/* Print the last N_BYTES characters from the end of pipe FD.\n   This is a stripped down version of pipe_lines.\n   Return true if successful.  */\n\nstatic bool\npipe_bytes (char const *pretty_filename, int fd, uintmax_t n_bytes,\n            uintmax_t *read_pos)\n{\n  struct charbuffer\n  {\n    char buffer[BUFSIZ];\n    size_t nbytes;\n    struct charbuffer *next;\n  };\n  typedef struct charbuffer CBUFFER;\n  CBUFFER *first, *last, *tmp;\n  size_t i;\t\t\t/* Index into buffers.  */\n  size_t total_bytes = 0;\t/* Total characters in all buffers.  */\n  bool ok = true;\n  size_t n_read;\n\n  first = last = xmalloc (sizeof (CBUFFER));\n  first->nbytes = 0;\n  first->next = nullptr;\n  tmp = xmalloc (sizeof (CBUFFER));\n\n  /* Input is always read into a fresh buffer.  */\n  while (true)\n    {\n      n_read = safe_read (fd, tmp->buffer, BUFSIZ);\n      if (n_read == 0 || n_read == SAFE_READ_ERROR)\n        break;\n      *read_pos += n_read;\n      tmp->nbytes = n_read;\n      tmp->next = nullptr;\n\n      total_bytes += tmp->nbytes;\n      /* If there is enough room in the last buffer read, just append the new\n         one to it.  This is because when reading from a pipe, 'nbytes' can\n         often be very small.  */\n      if (tmp->nbytes + last->nbytes < BUFSIZ)\n        {\n          memcpy (&last->buffer[last->nbytes], tmp->buffer, tmp->nbytes);\n          last->nbytes += tmp->nbytes;\n        }\n      else\n        {\n          /* If there's not enough room, link the new buffer onto the end of\n             the list, then either free up the oldest buffer for the next\n             read if that would leave enough characters, or else malloc a new\n             one.  Some compaction mechanism is possible but probably not\n             worthwhile.  */\n          last = last->next = tmp;\n          if (total_bytes - first->nbytes > n_bytes)\n            {\n              tmp = first;\n              total_bytes -= first->nbytes;\n              first = first->next;\n            }\n          else\n            {\n              tmp = xmalloc (sizeof (CBUFFER));\n            }\n        }\n    }\n\n  free (tmp);\n\n  if (n_read == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n      ok = false;\n      goto free_cbuffers;\n    }\n\n  /* Run through the list, printing characters.  First, skip over unneeded\n     buffers.  */\n  for (tmp = first; total_bytes - tmp->nbytes > n_bytes; tmp = tmp->next)\n    total_bytes -= tmp->nbytes;\n\n  /* Find the correct beginning, then print the rest of the file.\n     We made sure that 'total_bytes' - 'n_bytes' <= 'tmp->nbytes'.  */\n  if (total_bytes > n_bytes)\n    i = total_bytes - n_bytes;\n  else\n    i = 0;\n  xwrite_stdout (&tmp->buffer[i], tmp->nbytes - i);\n\n  for (tmp = tmp->next; tmp; tmp = tmp->next)\n    xwrite_stdout (tmp->buffer, tmp->nbytes);\n\nfree_cbuffers:\n  while (first)\n    {\n      tmp = first->next;\n      free (first);\n      first = tmp;\n    }\n  return ok;\n}\n\n/* Skip N_BYTES characters from the start of pipe FD, and print\n   any extra characters that were read beyond that.\n   Return 1 on error, 0 if ok, -1 if EOF.  */\n\nstatic int\nstart_bytes (char const *pretty_filename, int fd, uintmax_t n_bytes,\n             uintmax_t *read_pos)\n{\n  char buffer[BUFSIZ];\n\n  while (0 < n_bytes)\n    {\n      size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n      if (bytes_read == 0)\n        return -1;\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n          return 1;\n        }\n      *read_pos += bytes_read;\n      if (bytes_read <= n_bytes)\n        n_bytes -= bytes_read;\n      else\n        {\n          size_t n_remaining = bytes_read - n_bytes;\n          /* Print extra characters if there are any.  */\n          xwrite_stdout (&buffer[n_bytes], n_remaining);\n          break;\n        }\n    }\n\n  return 0;\n}\n\n/* Skip N_LINES lines at the start of file or pipe FD, and print\n   any extra characters that were read beyond that.\n   Return 1 on error, 0 if ok, -1 if EOF.  */\n\nstatic int\nstart_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n             uintmax_t *read_pos)\n{\n  if (n_lines == 0)\n    return 0;\n\n  while (true)\n    {\n      char buffer[BUFSIZ];\n      size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n      if (bytes_read == 0) /* EOF */\n        return -1;\n      if (bytes_read == SAFE_READ_ERROR) /* error */\n        {\n          error (0, errno, _(\"error reading %s\"), quoteaf (pretty_filename));\n          return 1;\n        }\n\n      char *buffer_end = buffer + bytes_read;\n\n      *read_pos += bytes_read;\n\n      char *p = buffer;\n      while ((p = memchr (p, line_end, buffer_end - p)))\n        {\n          ++p;\n          if (--n_lines == 0)\n            {\n              if (p < buffer_end)\n                xwrite_stdout (p, buffer_end - p);\n              return 0;\n            }\n        }\n    }\n}\n\n \nstatic bool\nfremote (int fd, char const *name)\n{\n  bool remote = true;            \n\n#if HAVE_FSTATFS && HAVE_STRUCT_STATFS_F_TYPE \\\n && (defined __linux__ || defined __ANDROID__)\n  struct statfs buf;\n  int err = fstatfs (fd, &buf);\n  if (err != 0)\n    {\n       \n      if (errno != ENOSYS)\n        error (0, errno, _(\"cannot determine location of %s. \"\n                           \"reverting to polling\"), quoteaf (name));\n    }\n  else\n    {\n       \n      remote = is_local_fs_type (buf.f_type) <= 0;\n    }\n#endif\n\n  return remote;\n}\n\n \nstatic void\nrecheck (struct File_spec *f, bool blocking)\n{\n  struct stat new_stats;\n  bool ok = true;\n  bool is_stdin = (STREQ (f->name, \"-\"));\n  bool was_tailable = f->tailable;\n  int prev_errnum = f->errnum;\n  bool new_file;\n  int fd = (is_stdin\n            ? STDIN_FILENO\n            : open (f->name, O_RDONLY | (blocking ? 0 : O_NONBLOCK)));\n\n  affirm (valid_file_spec (f));\n\n   \n  f->tailable = !(reopen_inaccessible_files && fd == -1);\n\n  if (! disable_inotify && ! lstat (f->name, &new_stats)\n      && S_ISLNK (new_stats.st_mode))\n    {\n       \n      ok = false;\n      f->errnum = -1;\n      f->ignore = true;\n\n      error (0, 0, _(\"%s has been replaced with an untailable symbolic link\"),\n             quoteaf (pretty_name (f)));\n    }\n  else if (fd == -1 || fstat (fd, &new_stats) < 0)\n    {\n      ok = false;\n      f->errnum = errno;\n      if (!f->tailable)\n        {\n          if (was_tailable)\n            {\n               \n              error (0, f->errnum, _(\"%s has become inaccessible\"),\n                     quoteaf (pretty_name (f)));\n            }\n          else\n            {\n               \n            }\n        }\n      else if (prev_errnum != errno)\n        error (0, errno, \"%s\", quotef (pretty_name (f)));\n    }\n  else if (!IS_TAILABLE_FILE_TYPE (new_stats.st_mode))\n    {\n      ok = false;\n      f->errnum = -1;\n      f->tailable = false;\n      f->ignore = ! (reopen_inaccessible_files && follow_mode == Follow_name);\n      if (was_tailable || prev_errnum != f->errnum)\n        error (0, 0, _(\"%s has been replaced with an untailable file%s\"),\n               quoteaf (pretty_name (f)),\n               f->ignore ? _(\"; giving up on this name\") : \"\");\n    }\n  else if ((f->remote = fremote (fd, pretty_name (f))) && ! disable_inotify)\n    {\n      ok = false;\n      f->errnum = -1;\n      error (0, 0, _(\"%s has been replaced with an untailable remote file\"),\n             quoteaf (pretty_name (f)));\n      f->ignore = true;\n      f->remote = true;\n    }\n  else\n    {\n      f->errnum = 0;\n    }\n\n  new_file = false;\n  if (!ok)\n    {\n      close_fd (fd, pretty_name (f));\n      close_fd (f->fd, pretty_name (f));\n      f->fd = -1;\n    }\n  else if (prev_errnum && prev_errnum != ENOENT)\n    {\n      new_file = true;\n      affirm (f->fd == -1);\n      error (0, 0, _(\"%s has become accessible\"), quoteaf (pretty_name (f)));\n    }\n  else if (f->fd == -1)\n    {\n       \n      new_file = true;\n\n      error (0, 0,\n             _(\"%s has appeared;  following new file\"),\n             quoteaf (pretty_name (f)));\n    }\n  else if (f->ino != new_stats.st_ino || f->dev != new_stats.st_dev)\n    {\n       \n      new_file = true;\n\n      error (0, 0,\n             _(\"%s has been replaced;  following new file\"),\n             quoteaf (pretty_name (f)));\n\n       \n      close_fd (f->fd, pretty_name (f));\n\n    }\n  else\n    {\n       \n      close_fd (fd, pretty_name (f));\n    }\n\n   \n  if (new_file)\n    {\n       \n      record_open_fd (f, fd, 0, &new_stats, (is_stdin ? -1 : blocking));\n      if (S_ISREG (new_stats.st_mode))\n        xlseek (fd, 0, SEEK_SET, pretty_name (f));\n    }\n}\n\n \n\nstatic bool\nany_live_files (const struct File_spec *f, size_t n_files)\n{\n   \n  if (reopen_inaccessible_files && follow_mode == Follow_name)\n    return true;\n\n  for (size_t i = 0; i < n_files; i++)\n    {\n      if (0 <= f[i].fd)\n        return true;\n      else\n        {\n          if (! f[i].ignore && reopen_inaccessible_files)\n            return true;\n        }\n    }\n\n  return false;\n}\n\n \n\nstatic void\ntail_forever (struct File_spec *f, size_t n_files, double sleep_interval)\n{\n   \n  bool blocking = (pid == 0 && follow_mode == Follow_descriptor\n                   && n_files == 1 && f[0].fd != -1 && ! S_ISREG (f[0].mode));\n  size_t last;\n  bool writer_is_dead = false;\n\n  last = n_files - 1;\n\n  while (true)\n    {\n      size_t i;\n      bool any_input = false;\n\n      for (i = 0; i < n_files; i++)\n        {\n          int fd;\n          char const *name;\n          mode_t mode;\n          struct stat stats;\n          uintmax_t bytes_read;\n\n          if (f[i].ignore)\n            continue;\n\n          if (f[i].fd < 0)\n            {\n              recheck (&f[i], blocking);\n              continue;\n            }\n\n          fd = f[i].fd;\n          name = pretty_name (&f[i]);\n          mode = f[i].mode;\n\n          if (f[i].blocking != blocking)\n            {\n              int old_flags = fcntl (fd, F_GETFL);\n              int new_flags = old_flags | (blocking ? 0 : O_NONBLOCK);\n              if (old_flags < 0\n                  || (new_flags != old_flags\n                      && fcntl (fd, F_SETFL, new_flags) == -1))\n                {\n                   \n                  if (S_ISREG (f[i].mode) && errno == EPERM)\n                    {\n                       \n                    }\n                  else\n                    error (EXIT_FAILURE, errno,\n                           _(\"%s: cannot change nonblocking mode\"),\n                           quotef (name));\n                }\n              else\n                f[i].blocking = blocking;\n            }\n\n          bool read_unchanged = false;\n          if (!f[i].blocking)\n            {\n              if (fstat (fd, &stats) != 0)\n                {\n                  f[i].fd = -1;\n                  f[i].errnum = errno;\n                  error (0, errno, \"%s\", quotef (name));\n                  close (fd);  \n                  continue;\n                }\n\n              if (f[i].mode == stats.st_mode\n                  && (! S_ISREG (stats.st_mode) || f[i].size == stats.st_size)\n                  && timespec_cmp (f[i].mtime, get_stat_mtime (&stats)) == 0)\n                {\n                  if ((max_n_unchanged_stats_between_opens\n                       <= f[i].n_unchanged_stats++)\n                      && follow_mode == Follow_name)\n                    {\n                      recheck (&f[i], f[i].blocking);\n                      f[i].n_unchanged_stats = 0;\n                    }\n                  if (fd != f[i].fd || S_ISREG (stats.st_mode) || 1 < n_files)\n                    continue;\n                  else\n                    read_unchanged = true;\n                }\n\n              affirm (fd == f[i].fd);\n\n               \n\n              f[i].mtime = get_stat_mtime (&stats);\n              f[i].mode = stats.st_mode;\n\n               \n              if (! read_unchanged)\n                f[i].n_unchanged_stats = 0;\n\n               \n              if (S_ISREG (mode) && stats.st_size < f[i].size)\n                {\n                  error (0, 0, _(\"%s: file truncated\"), quotef (name));\n                   \n                  xlseek (fd, 0, SEEK_SET, name);\n                  f[i].size = 0;\n                }\n\n              if (i != last)\n                {\n                  if (print_headers)\n                    write_header (name);\n                  last = i;\n                }\n            }\n\n           \n          uintmax_t bytes_to_read;\n          if (f[i].blocking)\n            bytes_to_read = COPY_A_BUFFER;\n          else if (S_ISREG (mode) && f[i].remote)\n            bytes_to_read = stats.st_size - f[i].size;\n          else\n            bytes_to_read = COPY_TO_EOF;\n\n          bytes_read = dump_remainder (false, name, fd, bytes_to_read);\n\n          if (read_unchanged && bytes_read)\n            f[i].n_unchanged_stats = 0;\n\n          any_input |= (bytes_read != 0);\n          f[i].size += bytes_read;\n        }\n\n      if (! any_live_files (f, n_files))\n        {\n          error (0, 0, _(\"no files remaining\"));\n          break;\n        }\n\n      if ((!any_input || blocking) && fflush (stdout) != 0)\n        write_error ();\n\n      check_output_alive ();\n\n       \n      if (!any_input)\n        {\n          if (writer_is_dead)\n            break;\n\n           \n          writer_is_dead = (pid != 0\n                            && kill (pid, 0) != 0\n                             \n                            && errno != EPERM);\n\n          if (!writer_is_dead && xnanosleep (sleep_interval))\n            error (EXIT_FAILURE, errno, _(\"cannot read realtime clock\"));\n\n        }\n    }\n}\n\n#if HAVE_INOTIFY\n\n \n\nstatic bool\nany_remote_file (const struct File_spec *f, size_t n_files)\n{\n  for (size_t i = 0; i < n_files; i++)\n    if (0 <= f[i].fd && f[i].remote)\n      return true;\n  return false;\n}\n\n \n\nstatic bool\nany_non_remote_file (const struct File_spec *f, size_t n_files)\n{\n  for (size_t i = 0; i < n_files; i++)\n    if (0 <= f[i].fd && ! f[i].remote)\n      return true;\n  return false;\n}\n\n \n\nstatic bool\nany_symlinks (const struct File_spec *f, size_t n_files)\n{\n  struct stat st;\n  for (size_t i = 0; i < n_files; i++)\n    if (lstat (f[i].name, &st) == 0 && S_ISLNK (st.st_mode))\n      return true;\n  return false;\n}\n\n \n\nstatic bool\nany_non_regular_fifo (const struct File_spec *f, size_t n_files)\n{\n  for (size_t i = 0; i < n_files; i++)\n    if (0 <= f[i].fd && ! S_ISREG (f[i].mode) && ! S_ISFIFO (f[i].mode))\n      return true;\n  return false;\n}\n\n \n\nstatic bool\ntailable_stdin (const struct File_spec *f, size_t n_files)\n{\n  for (size_t i = 0; i < n_files; i++)\n    if (!f[i].ignore && STREQ (f[i].name, \"-\"))\n      return true;\n  return false;\n}\n\nstatic size_t\nwd_hasher (const void *entry, size_t tabsize)\n{\n  const struct File_spec *spec = entry;\n  return spec->wd % tabsize;\n}\n\nstatic bool\nwd_comparator (const void *e1, const void *e2)\n{\n  const struct File_spec *spec1 = e1;\n  const struct File_spec *spec2 = e2;\n  return spec1->wd == spec2->wd;\n}\n\n \nstatic void\ncheck_fspec (struct File_spec *fspec, struct File_spec **prev_fspec)\n{\n  struct stat stats;\n  char const *name;\n\n  if (fspec->fd == -1)\n    return;\n\n  name = pretty_name (fspec);\n\n  if (fstat (fspec->fd, &stats) != 0)\n    {\n      fspec->errnum = errno;\n      close_fd (fspec->fd, name);\n      fspec->fd = -1;\n      return;\n    }\n\n   \n  if (S_ISREG (fspec->mode) && stats.st_size < fspec->size)\n    {\n      error (0, 0, _(\"%s: file truncated\"), quotef (name));\n      xlseek (fspec->fd, 0, SEEK_SET, name);\n      fspec->size = 0;\n    }\n  else if (S_ISREG (fspec->mode) && stats.st_size == fspec->size\n           && timespec_cmp (fspec->mtime, get_stat_mtime (&stats)) == 0)\n    return;\n\n  bool want_header = print_headers && (fspec != *prev_fspec);\n\n  uintmax_t bytes_read = dump_remainder (want_header, name, fspec->fd,\n                                         COPY_TO_EOF);\n  fspec->size += bytes_read;\n\n  if (bytes_read)\n    {\n      *prev_fspec = fspec;\n      if (fflush (stdout) != 0)\n        write_error ();\n    }\n}\n\n \nstatic void\ntail_forever_inotify (int wd, struct File_spec *f, size_t n_files,\n                      double sleep_interval, Hash_table **wd_to_namep)\n{\n# if TAIL_TEST_SLEEP\n   \n  xnanosleep (1000000);\n# endif\n  unsigned int max_realloc = 3;\n\n   \n  Hash_table *wd_to_name;\n\n  bool found_watchable_file = false;\n  bool tailed_but_unwatchable = false;\n  bool found_unwatchable_dir = false;\n  bool no_inotify_resources = false;\n  bool writer_is_dead = false;\n  struct File_spec *prev_fspec;\n  size_t evlen = 0;\n  char *evbuf;\n  size_t evbuf_off = 0;\n  size_t len = 0;\n\n  wd_to_name = hash_initialize (n_files, nullptr, wd_hasher, wd_comparator,\n                                nullptr);\n  if (! wd_to_name)\n    xalloc_die ();\n  *wd_to_namep = wd_to_name;\n\n   \n  uint32_t inotify_wd_mask = IN_MODIFY;\n   \n  if (follow_mode == Follow_name)\n    inotify_wd_mask |= (IN_ATTRIB | IN_DELETE_SELF | IN_MOVE_SELF);\n\n   \n  size_t i;\n  for (i = 0; i < n_files; i++)\n    {\n      if (!f[i].ignore)\n        {\n          size_t fnlen = strlen (f[i].name);\n          if (evlen < fnlen)\n            evlen = fnlen;\n\n          f[i].wd = -1;\n\n          if (follow_mode == Follow_name)\n            {\n              size_t dirlen = dir_len (f[i].name);\n              char prev = f[i].name[dirlen];\n              f[i].basename_start = last_component (f[i].name) - f[i].name;\n\n              f[i].name[dirlen] = '\\0';\n\n                \n              f[i].parent_wd = inotify_add_watch (wd, dirlen ? f[i].name : \".\",\n                                                  (IN_CREATE | IN_DELETE\n                                                   | IN_MOVED_TO | IN_ATTRIB\n                                                   | IN_DELETE_SELF));\n\n              f[i].name[dirlen] = prev;\n\n              if (f[i].parent_wd < 0)\n                {\n                  if (errno != ENOSPC)  \n                    error (0, errno, _(\"cannot watch parent directory of %s\"),\n                           quoteaf (f[i].name));\n                  else\n                    error (0, 0, _(\"inotify resources exhausted\"));\n                  found_unwatchable_dir = true;\n                   \n                  break;\n                }\n            }\n\n          f[i].wd = inotify_add_watch (wd, f[i].name, inotify_wd_mask);\n\n          if (f[i].wd < 0)\n            {\n              if (f[i].fd != -1)   \n                tailed_but_unwatchable = true;\n              if (errno == ENOSPC || errno == ENOMEM)\n                {\n                  no_inotify_resources = true;\n                  error (0, 0, _(\"inotify resources exhausted\"));\n                  break;\n                }\n              else if (errno != f[i].errnum)\n                error (0, errno, _(\"cannot watch %s\"), quoteaf (f[i].name));\n              continue;\n            }\n\n          if (hash_insert (wd_to_name, &(f[i])) == nullptr)\n            xalloc_die ();\n\n          found_watchable_file = true;\n        }\n    }\n\n   \n  if (no_inotify_resources || found_unwatchable_dir\n      || (follow_mode == Follow_descriptor && tailed_but_unwatchable))\n    return;\n  if (follow_mode == Follow_descriptor && !found_watchable_file)\n    exit (EXIT_FAILURE);\n\n  prev_fspec = &(f[n_files - 1]);\n\n   \n  for (i = 0; i < n_files; i++)\n    {\n      if (! f[i].ignore)\n        {\n           \n          if (follow_mode == Follow_name)\n            recheck (&(f[i]), false);\n          else if (f[i].fd != -1)\n            {\n               \n              struct stat stats;\n\n              if (stat (f[i].name, &stats) == 0\n                  && (f[i].dev != stats.st_dev || f[i].ino != stats.st_ino))\n                {\n                  error (0, errno, _(\"%s was replaced\"),\n                         quoteaf (pretty_name (&(f[i]))));\n                  return;\n                }\n            }\n\n           \n          check_fspec (&f[i], &prev_fspec);\n        }\n    }\n\n  evlen += sizeof (struct inotify_event) + 1;\n  evbuf = xmalloc (evlen);\n\n   \n  while (true)\n    {\n      struct File_spec *fspec;\n      struct inotify_event *ev;\n      void *void_ev;\n\n       \n      if (follow_mode == Follow_name\n          && ! reopen_inaccessible_files\n          && hash_get_n_entries (wd_to_name) == 0)\n        error (EXIT_FAILURE, 0, _(\"no files remaining\"));\n\n      if (len <= evbuf_off)\n        {\n           \n\n          int file_change;\n          struct pollfd pfd[2];\n          do\n            {\n               \n              int delay = -1;\n\n              if (pid)\n                {\n                  if (writer_is_dead)\n                    exit (EXIT_SUCCESS);\n\n                  writer_is_dead = (kill (pid, 0) != 0 && errno != EPERM);\n\n                  if (writer_is_dead || sleep_interval <= 0)\n                    delay = 0;\n                  else if (sleep_interval < INT_MAX / 1000 - 1)\n                    {\n                       \n                      double ddelay = sleep_interval * 1000;\n                      delay = ddelay;\n                      delay += delay < ddelay;\n                    }\n                }\n\n              pfd[0].fd = wd;\n              pfd[0].events = POLLIN;\n              pfd[1].fd = STDOUT_FILENO;\n              pfd[1].events = pfd[1].revents = 0;\n              file_change = poll (pfd, monitor_output + 1, delay);\n            }\n          while (file_change == 0);\n\n          if (file_change < 0)\n            error (EXIT_FAILURE, errno,\n                   _(\"error waiting for inotify and output events\"));\n          if (pfd[1].revents)\n            die_pipe ();\n\n          len = safe_read (wd, evbuf, evlen);\n          evbuf_off = 0;\n\n           \n          if ((len == 0 || (len == SAFE_READ_ERROR && errno == EINVAL))\n              && max_realloc--)\n            {\n              len = 0;\n              evlen *= 2;\n              evbuf = xrealloc (evbuf, evlen);\n              continue;\n            }\n\n          if (len == 0 || len == SAFE_READ_ERROR)\n            error (EXIT_FAILURE, errno, _(\"error reading inotify event\"));\n        }\n\n      void_ev = evbuf + evbuf_off;\n      ev = void_ev;\n      evbuf_off += sizeof (*ev) + ev->len;\n\n       \n      if ((ev->mask & IN_DELETE_SELF) && ! ev->len)\n        {\n          for (i = 0; i < n_files; i++)\n            {\n              if (ev->wd == f[i].parent_wd)\n                {\n                  error (0, 0,\n                      _(\"directory containing watched file was removed\"));\n                  return;\n                }\n            }\n        }\n\n      if (ev->len)  \n        {\n          size_t j;\n          for (j = 0; j < n_files; j++)\n            {\n               \n              if (f[j].parent_wd == ev->wd\n                  && STREQ (ev->name, f[j].name + f[j].basename_start))\n                break;\n            }\n\n           \n          if (j == n_files)\n            continue;\n\n          fspec = &(f[j]);\n\n          int new_wd = -1;\n          bool deleting = !! (ev->mask & IN_DELETE);\n\n          if (! deleting)\n            {\n               \n              new_wd = inotify_add_watch (wd, f[j].name, inotify_wd_mask);\n            }\n\n          if (! deleting && new_wd < 0)\n            {\n              if (errno == ENOSPC || errno == ENOMEM)\n                {\n                  error (0, 0, _(\"inotify resources exhausted\"));\n                  return;  \n                }\n              else\n                {\n                   \n                  error (0, errno, _(\"cannot watch %s\"), quoteaf (f[j].name));\n                }\n               \n            }\n\n           \n          bool new_watch;\n          new_watch = (! deleting) && (fspec->wd < 0 || new_wd != fspec->wd);\n\n          if (new_watch)\n            {\n              if (0 <= fspec->wd)\n                {\n                  inotify_rm_watch (wd, fspec->wd);\n                  hash_remove (wd_to_name, fspec);\n                }\n\n              fspec->wd = new_wd;\n\n              if (new_wd == -1)\n                continue;\n\n               \n              struct File_spec *prev = hash_remove (wd_to_name, fspec);\n              if (prev && prev != fspec)\n                {\n                  if (follow_mode == Follow_name)\n                    recheck (prev, false);\n                  prev->wd = -1;\n                  close_fd (prev->fd, pretty_name (prev));\n                }\n\n              if (hash_insert (wd_to_name, fspec) == nullptr)\n                xalloc_die ();\n            }\n\n          if (follow_mode == Follow_name)\n            recheck (fspec, false);\n        }\n      else\n        {\n          struct File_spec key;\n          key.wd = ev->wd;\n          fspec = hash_lookup (wd_to_name, &key);\n        }\n\n      if (! fspec)\n        continue;\n\n      if (ev->mask & (IN_ATTRIB | IN_DELETE | IN_DELETE_SELF | IN_MOVE_SELF))\n        {\n           \n          if (ev->mask & IN_DELETE_SELF)\n            {\n              inotify_rm_watch (wd, fspec->wd);\n              hash_remove (wd_to_name, fspec);\n            }\n\n           \n\n          recheck (fspec, false);\n\n          continue;\n        }\n      check_fspec (fspec, &prev_fspec);\n    }\n}\n#endif\n\n \n\nstatic bool\ntail_bytes (char const *pretty_filename, int fd, uintmax_t n_bytes,\n            uintmax_t *read_pos)\n{\n  struct stat stats;\n\n  if (fstat (fd, &stats))\n    {\n      error (0, errno, _(\"cannot fstat %s\"), quoteaf (pretty_filename));\n      return false;\n    }\n\n  if (from_start)\n    {\n      if (! presume_input_pipe && n_bytes <= OFF_T_MAX\n          && ((S_ISREG (stats.st_mode)\n               && xlseek (fd, n_bytes, SEEK_CUR, pretty_filename) >= 0)\n              || lseek (fd, n_bytes, SEEK_CUR) != -1))\n        *read_pos += n_bytes;\n      else\n        {\n          int t = start_bytes (pretty_filename, fd, n_bytes, read_pos);\n          if (t)\n            return t < 0;\n        }\n      n_bytes = COPY_TO_EOF;\n    }\n  else\n    {\n      off_t end_pos = -1;\n      off_t current_pos = -1;\n\n      if (! presume_input_pipe && n_bytes <= OFF_T_MAX)\n        {\n          if (usable_st_size (&stats))\n            end_pos = stats.st_size;\n          else if ((current_pos = lseek (fd, -n_bytes, SEEK_END)) != -1)\n            end_pos = current_pos + n_bytes;\n        }\n      if (end_pos <= (off_t) ST_BLKSIZE (stats))\n        return pipe_bytes (pretty_filename, fd, n_bytes, read_pos);\n      if (current_pos == -1)\n        current_pos = xlseek (fd, 0, SEEK_CUR, pretty_filename);\n      if (current_pos < end_pos)\n        {\n          off_t bytes_remaining = end_pos - current_pos;\n\n          if (n_bytes < bytes_remaining)\n            {\n              current_pos = end_pos - n_bytes;\n              xlseek (fd, current_pos, SEEK_SET, pretty_filename);\n            }\n        }\n      *read_pos = current_pos;\n    }\n\n  *read_pos += dump_remainder (false, pretty_filename, fd, n_bytes);\n  return true;\n}\n\n \n\nstatic bool\ntail_lines (char const *pretty_filename, int fd, uintmax_t n_lines,\n            uintmax_t *read_pos)\n{\n  struct stat stats;\n\n  if (fstat (fd, &stats))\n    {\n      error (0, errno, _(\"cannot fstat %s\"), quoteaf (pretty_filename));\n      return false;\n    }\n\n  if (from_start)\n    {\n      int t = start_lines (pretty_filename, fd, n_lines, read_pos);\n      if (t)\n        return t < 0;\n      *read_pos += dump_remainder (false, pretty_filename, fd, COPY_TO_EOF);\n    }\n  else\n    {\n      off_t start_pos = -1;\n      off_t end_pos;\n\n       \n      if ( ! presume_input_pipe\n           && S_ISREG (stats.st_mode)\n           && (start_pos = lseek (fd, 0, SEEK_CUR)) != -1\n           && start_pos < (end_pos = lseek (fd, 0, SEEK_END)))\n        {\n          *read_pos = end_pos;\n          if (end_pos != 0\n              && ! file_lines (pretty_filename, fd, n_lines,\n                               start_pos, end_pos, read_pos))\n            return false;\n        }\n      else\n        {\n           \n          if (start_pos != -1)\n            xlseek (fd, start_pos, SEEK_SET, pretty_filename);\n\n          return pipe_lines (pretty_filename, fd, n_lines, read_pos);\n        }\n    }\n  return true;\n}\n\n \n\nstatic bool\ntail (char const *filename, int fd, uintmax_t n_units,\n      uintmax_t *read_pos)\n{\n  *read_pos = 0;\n  if (count_lines)\n    return tail_lines (filename, fd, n_units, read_pos);\n  else\n    return tail_bytes (filename, fd, n_units, read_pos);\n}\n\n \n\nstatic bool\ntail_file (struct File_spec *f, uintmax_t n_units)\n{\n  int fd;\n  bool ok;\n\n  bool is_stdin = (STREQ (f->name, \"-\"));\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fd = STDIN_FILENO;\n      xset_binary_mode (STDIN_FILENO, O_BINARY);\n    }\n  else\n    fd = open (f->name, O_RDONLY | O_BINARY);\n\n  f->tailable = !(reopen_inaccessible_files && fd == -1);\n\n  if (fd == -1)\n    {\n      if (forever)\n        {\n          f->fd = -1;\n          f->errnum = errno;\n          f->ignore = ! reopen_inaccessible_files;\n          f->ino = 0;\n          f->dev = 0;\n        }\n      error (0, errno, _(\"cannot open %s for reading\"),\n             quoteaf (pretty_name (f)));\n      ok = false;\n    }\n  else\n    {\n      uintmax_t read_pos;\n\n      if (print_headers)\n        write_header (pretty_name (f));\n      ok = tail (pretty_name (f), fd, n_units, &read_pos);\n      if (forever)\n        {\n          struct stat stats;\n\n#if TAIL_TEST_SLEEP\n           \n          xnanosleep (1);\n#endif\n          f->errnum = ok - 1;\n          if (fstat (fd, &stats) < 0)\n            {\n              ok = false;\n              f->errnum = errno;\n              error (0, errno, _(\"error reading %s\"),\n                     quoteaf (pretty_name (f)));\n            }\n          else if (!IS_TAILABLE_FILE_TYPE (stats.st_mode))\n            {\n              ok = false;\n              f->errnum = -1;\n              f->tailable = false;\n              f->ignore = ! reopen_inaccessible_files;\n              error (0, 0, _(\"%s: cannot follow end of this type of file%s\"),\n                     quotef (pretty_name (f)),\n                     f->ignore ? _(\"; giving up on this name\") : \"\");\n            }\n\n          if (!ok)\n            {\n              f->ignore = ! reopen_inaccessible_files;\n              close_fd (fd, pretty_name (f));\n              f->fd = -1;\n            }\n          else\n            {\n               \n              record_open_fd (f, fd, read_pos, &stats, (is_stdin ? -1 : 1));\n              f->remote = fremote (fd, pretty_name (f));\n            }\n        }\n      else\n        {\n          if (!is_stdin && close (fd))\n            {\n              error (0, errno, _(\"error reading %s\"),\n                     quoteaf (pretty_name (f)));\n              ok = false;\n            }\n        }\n    }\n\n  return ok;\n}\n\n \n\nstatic bool\nparse_obsolete_option (int argc, char * const *argv, uintmax_t *n_units)\n{\n  char const *p;\n  char const *n_string;\n  char const *n_string_end;\n  int default_count = DEFAULT_N_LINES;\n  bool t_from_start;\n  bool t_count_lines = true;\n  bool t_forever = false;\n\n   \n  if (! (argc == 2\n         || (argc == 3 && ! (argv[2][0] == '-' && argv[2][1]))\n         || (3 <= argc && argc <= 4 && STREQ (argv[2], \"--\"))))\n    return false;\n\n  int posix_ver = posix2_version ();\n  bool obsolete_usage = posix_ver < 200112;\n  bool traditional_usage = obsolete_usage || 200809 <= posix_ver;\n  p = argv[1];\n\n  switch (*p++)\n    {\n    default:\n      return false;\n\n    case '+':\n       \n      if (!traditional_usage)\n        return false;\n\n      t_from_start = true;\n      break;\n\n    case '-':\n       \n      if (!obsolete_usage && !p[p[0] == 'c'])\n        return false;\n\n      t_from_start = false;\n      break;\n    }\n\n  n_string = p;\n  while (ISDIGIT (*p))\n    p++;\n  n_string_end = p;\n\n  switch (*p)\n    {\n    case 'b': default_count *= 512; FALLTHROUGH;\n    case 'c': t_count_lines = false; FALLTHROUGH;\n    case 'l': p++; break;\n    }\n\n  if (*p == 'f')\n    {\n      t_forever = true;\n      ++p;\n    }\n\n  if (*p)\n    return false;\n\n  if (n_string == n_string_end)\n    *n_units = default_count;\n  else if ((xstrtoumax (n_string, nullptr, 10, n_units, \"b\")\n            & ~LONGINT_INVALID_SUFFIX_CHAR)\n           != LONGINT_OK)\n    error (EXIT_FAILURE, errno, \"%s: %s\", _(\"invalid number\"),\n           quote (argv[1]));\n\n   \n  from_start = t_from_start;\n  count_lines = t_count_lines;\n  forever = t_forever;\n\n  return true;\n}\n\nstatic void\nparse_options (int argc, char **argv,\n               uintmax_t *n_units, enum header_mode *header_mode,\n               double *sleep_interval)\n{\n  int c;\n\n  while ((c = getopt_long (argc, argv, \"c:n:fFqs:vz0123456789\",\n                           long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'F':\n          forever = true;\n          follow_mode = Follow_name;\n          reopen_inaccessible_files = true;\n          break;\n\n        case 'c':\n        case 'n':\n          count_lines = (c == 'n');\n          if (*optarg == '+')\n            from_start = true;\n          else if (*optarg == '-')\n            ++optarg;\n\n          *n_units = xdectoumax (optarg, 0, UINTMAX_MAX, \"bkKmMGTPEZYRQ0\",\n                                 count_lines\n                                 ? _(\"invalid number of lines\")\n                                 : _(\"invalid number of bytes\"), 0);\n          break;\n\n        case 'f':\n        case LONG_FOLLOW_OPTION:\n          forever = true;\n          if (optarg == nullptr)\n            follow_mode = DEFAULT_FOLLOW_MODE;\n          else\n            follow_mode = XARGMATCH (\"--follow\", optarg,\n                                     follow_mode_string, follow_mode_map);\n          break;\n\n        case RETRY_OPTION:\n          reopen_inaccessible_files = true;\n          break;\n\n        case MAX_UNCHANGED_STATS_OPTION:\n           \n          max_n_unchanged_stats_between_opens =\n            xdectoumax (optarg, 0, UINTMAX_MAX, \"\",\n              _(\"invalid maximum number of unchanged stats between opens\"), 0);\n          break;\n\n        case DISABLE_INOTIFY_OPTION:\n          disable_inotify = true;\n          break;\n\n        case PID_OPTION:\n          pid = xdectoumax (optarg, 0, PID_T_MAX, \"\", _(\"invalid PID\"), 0);\n          break;\n\n        case PRESUME_INPUT_PIPE_OPTION:\n          presume_input_pipe = true;\n          break;\n\n        case 'q':\n          *header_mode = never;\n          break;\n\n        case 's':\n          {\n            double s;\n            if (! (xstrtod (optarg, nullptr, &s, cl_strtod) && 0 <= s))\n              error (EXIT_FAILURE, 0,\n                     _(\"invalid number of seconds: %s\"), quote (optarg));\n            *sleep_interval = s;\n          }\n          break;\n\n        case 'v':\n          *header_mode = always;\n          break;\n\n        case 'z':\n          line_end = '\\0';\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n          error (EXIT_FAILURE, 0, _(\"option used in invalid context -- %c\"), c);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (reopen_inaccessible_files)\n    {\n      if (!forever)\n        {\n          reopen_inaccessible_files = false;\n          error (0, 0, _(\"warning: --retry ignored; --retry is useful\"\n                         \" only when following\"));\n        }\n      else if (follow_mode == Follow_descriptor)\n        error (0, 0, _(\"warning: --retry only effective for the initial open\"));\n    }\n\n  if (pid && !forever)\n    error (0, 0,\n           _(\"warning: PID ignored; --pid=PID is useful only when following\"));\n  else if (pid && kill (pid, 0) != 0 && errno == ENOSYS)\n    {\n      error (0, 0, _(\"warning: --pid=PID is not supported on this system\"));\n      pid = 0;\n    }\n}\n\n \nstatic size_t\nignore_fifo_and_pipe (struct File_spec *f, size_t n_files)\n{\n   \n  size_t n_viable = 0;\n\n  for (size_t i = 0; i < n_files; i++)\n    {\n      bool is_a_fifo_or_pipe =\n        (STREQ (f[i].name, \"-\")\n         && !f[i].ignore\n         && 0 <= f[i].fd\n         && (S_ISFIFO (f[i].mode)\n             || (HAVE_FIFO_PIPES != 1 && isapipe (f[i].fd))));\n      if (is_a_fifo_or_pipe)\n        {\n          f[i].fd = -1;\n          f[i].ignore = true;\n        }\n      else\n        ++n_viable;\n    }\n\n  return n_viable;\n}\n\nint\nmain (int argc, char **argv)\n{\n  enum header_mode header_mode = multiple_files;\n  bool ok = true;\n   \n  uintmax_t n_units = DEFAULT_N_LINES;\n  size_t n_files;\n  char **file;\n  struct File_spec *F;\n  size_t i;\n  bool obsolete_option;\n\n   \n  double sleep_interval = 1.0;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  have_read_stdin = false;\n\n  count_lines = true;\n  forever = from_start = print_headers = false;\n  line_end = '\\n';\n  obsolete_option = parse_obsolete_option (argc, argv, &n_units);\n  argc -= obsolete_option;\n  argv += obsolete_option;\n  parse_options (argc, argv, &n_units, &header_mode, &sleep_interval);\n\n   \n  if (from_start)\n    {\n      if (n_units)\n        --n_units;\n    }\n\n  if (optind < argc)\n    {\n      n_files = argc - optind;\n      file = argv + optind;\n    }\n  else\n    {\n      static char *dummy_stdin = (char *) \"-\";\n      n_files = 1;\n      file = &dummy_stdin;\n    }\n\n  {\n    bool found_hyphen = false;\n\n    for (i = 0; i < n_files; i++)\n      if (STREQ (file[i], \"-\"))\n        found_hyphen = true;\n\n     \n    if (found_hyphen && follow_mode == Follow_name)\n      error (EXIT_FAILURE, 0, _(\"cannot follow %s by name\"), quoteaf (\"-\"));\n\n     \n    if (forever && found_hyphen)\n      {\n        struct stat in_stat;\n        bool blocking_stdin;\n        blocking_stdin = (pid == 0 && follow_mode == Follow_descriptor\n                          && n_files == 1 && ! fstat (STDIN_FILENO, &in_stat)\n                          && ! S_ISREG (in_stat.st_mode));\n\n        if (! blocking_stdin && isatty (STDIN_FILENO))\n          error (0, 0, _(\"warning: following standard input\"\n                         \" indefinitely is ineffective\"));\n      }\n  }\n\n   \n  if (! n_units && ! forever && ! from_start)\n    return EXIT_SUCCESS;\n\n  F = xnmalloc (n_files, sizeof *F);\n  for (i = 0; i < n_files; i++)\n    F[i].name = file[i];\n\n  if (header_mode == always\n      || (header_mode == multiple_files && n_files > 1))\n    print_headers = true;\n\n  xset_binary_mode (STDOUT_FILENO, O_BINARY);\n\n  for (i = 0; i < n_files; i++)\n    ok &= tail_file (&F[i], n_units);\n\n  if (forever && ignore_fifo_and_pipe (F, n_files))\n    {\n       \n      struct stat out_stat;\n      if (fstat (STDOUT_FILENO, &out_stat) < 0)\n        error (EXIT_FAILURE, errno, _(\"standard output\"));\n      monitor_output = (S_ISFIFO (out_stat.st_mode)\n                        || (HAVE_FIFO_PIPES != 1 && isapipe (STDOUT_FILENO)));\n\n#if HAVE_INOTIFY\n       \n      if (!disable_inotify && (tailable_stdin (F, n_files)\n                               || any_remote_file (F, n_files)\n                               || ! any_non_remote_file (F, n_files)\n                               || any_symlinks (F, n_files)\n                               || any_non_regular_fifo (F, n_files)\n                               || (!ok && follow_mode == Follow_descriptor)))\n        disable_inotify = true;\n\n      if (!disable_inotify)\n        {\n          int wd = inotify_init ();\n          if (0 <= wd)\n            {\n               \n              if (fflush (stdout) != 0)\n                write_error ();\n\n              Hash_table *ht;\n              tail_forever_inotify (wd, F, n_files, sleep_interval, &ht);\n              hash_free (ht);\n              close (wd);\n              errno = 0;\n            }\n          error (0, errno, _(\"inotify cannot be used, reverting to polling\"));\n        }\n#endif\n      disable_inotify = true;\n      tail_forever (F, n_files, sleep_interval);\n    }\n\n  if (have_read_stdin && close (STDIN_FILENO) < 0)\n    error (EXIT_FAILURE, errno, \"-\");\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}