{
  "module_name": "df.c",
  "hash_id": "c117931bd1c088930ddab690f345983fc02335cc9e9167213e498644768a940c",
  "original_prompt": "Ingested from coreutils-9.4/src/df.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n#include <c-ctype.h>\n#include <wchar.h>\n#include <wctype.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"canonicalize.h\"\n#include \"fsusage.h\"\n#include \"human.h\"\n#include \"mbsalign.h\"\n#include \"mbswidth.h\"\n#include \"mountlist.h\"\n#include \"quote.h\"\n#include \"find-mount-point.h\"\n#include \"hash.h\"\n#include \"xstrtol-error.h\"\n\n \n#define PROGRAM_NAME \"df\"\n\n#define AUTHORS \\\n  proper_name_lite (\"Torbjorn Granlund\", \"Torbj\\303\\266rn Granlund\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Paul Eggert\")\n\nstruct devlist\n{\n  dev_t dev_num;\n  struct mount_entry *me;\n  struct devlist *next;\n  struct devlist *seen_last;  \n};\n\n \nstatic Hash_table *devlist_table;\n\n \nstatic bool show_all_fs;\n\n \nstatic bool show_local_fs;\n\n \nstatic bool show_listed_fs;\n\n \nstatic int human_output_opts;\n\n \nstatic uintmax_t output_block_size;\n\n \nstatic bool file_systems_processed;\n\n \nstatic bool require_sync;\n\n \nstatic int exit_status;\n\n \n\nstruct fs_type_list\n{\n  char *fs_name;\n  struct fs_type_list *fs_next;\n};\n\n \n\nstatic struct fs_type_list *fs_select_list;\n\n \n\nstatic struct fs_type_list *fs_exclude_list;\n\n \nstatic struct mount_entry *mount_list;\n\n \nstatic bool print_type;\n\n \nstatic bool print_grand_total;\n\n \nstatic struct fs_usage grand_fsu;\n\n \nstatic enum\n{\n  DEFAULT_MODE,\n  INODES_MODE,\n  HUMAN_MODE,\n  POSIX_MODE,\n  OUTPUT_MODE\n} header_mode = DEFAULT_MODE;\n\n \ntypedef enum\n{\n  SOURCE_FIELD,  \n  FSTYPE_FIELD,  \n  SIZE_FIELD,    \n  USED_FIELD,    \n  AVAIL_FIELD,   \n  PCENT_FIELD,   \n  ITOTAL_FIELD,  \n  IUSED_FIELD,   \n  IAVAIL_FIELD,  \n  IPCENT_FIELD,  \n  TARGET_FIELD,  \n  FILE_FIELD,    \n  INVALID_FIELD  \n} display_field_t;\n\n \ntypedef enum\n{\n  BLOCK_FLD,  \n  INODE_FLD,  \n  OTHER_FLD   \n} field_type_t;\n\n \nstruct field_data_t\n{\n  display_field_t field;\n  char const *arg;\n  field_type_t field_type;\n  char const *caption; \n  size_t width;        \n  mbs_align_t align;   \n  bool used;\n};\n\n \nstatic struct field_data_t field_data[] = {\n  [SOURCE_FIELD] = { SOURCE_FIELD,\n    \"source\", OTHER_FLD, N_(\"Filesystem\"), 14, MBS_ALIGN_LEFT,  false },\n\n  [FSTYPE_FIELD] = { FSTYPE_FIELD,\n    \"fstype\", OTHER_FLD, N_(\"Type\"),        4, MBS_ALIGN_LEFT,  false },\n\n  [SIZE_FIELD] = { SIZE_FIELD,\n    \"size\",   BLOCK_FLD, N_(\"blocks\"),      5, MBS_ALIGN_RIGHT, false },\n\n  [USED_FIELD] = { USED_FIELD,\n    \"used\",   BLOCK_FLD, N_(\"Used\"),        5, MBS_ALIGN_RIGHT, false },\n\n  [AVAIL_FIELD] = { AVAIL_FIELD,\n    \"avail\",  BLOCK_FLD, N_(\"Available\"),   5, MBS_ALIGN_RIGHT, false },\n\n  [PCENT_FIELD] = { PCENT_FIELD,\n    \"pcent\",  BLOCK_FLD, N_(\"Use%\"),        4, MBS_ALIGN_RIGHT, false },\n\n  [ITOTAL_FIELD] = { ITOTAL_FIELD,\n    \"itotal\", INODE_FLD, N_(\"Inodes\"),      5, MBS_ALIGN_RIGHT, false },\n\n  [IUSED_FIELD] = { IUSED_FIELD,\n    \"iused\",  INODE_FLD, N_(\"IUsed\"),       5, MBS_ALIGN_RIGHT, false },\n\n  [IAVAIL_FIELD] = { IAVAIL_FIELD,\n    \"iavail\", INODE_FLD, N_(\"IFree\"),       5, MBS_ALIGN_RIGHT, false },\n\n  [IPCENT_FIELD] = { IPCENT_FIELD,\n    \"ipcent\", INODE_FLD, N_(\"IUse%\"),       4, MBS_ALIGN_RIGHT, false },\n\n  [TARGET_FIELD] = { TARGET_FIELD,\n    \"target\", OTHER_FLD, N_(\"Mounted on\"),  0, MBS_ALIGN_LEFT,  false },\n\n  [FILE_FIELD] = { FILE_FIELD,\n    \"file\",   OTHER_FLD, N_(\"File\"),        0, MBS_ALIGN_LEFT,  false }\n};\n\nstatic char const *all_args_string =\n  \"source,fstype,itotal,iused,iavail,ipcent,size,\"\n  \"used,avail,pcent,file,target\";\n\n \nstatic struct field_data_t **columns;\n\n \nstatic size_t ncolumns;\n\n \nstruct field_values_t\n{\n  uintmax_t input_units;\n  uintmax_t output_units;\n  uintmax_t total;\n  uintmax_t available;\n  bool negate_available;\n  uintmax_t available_to_root;\n  uintmax_t used;\n  bool negate_used;\n};\n\n \nstatic char ***table;\n\n \nstatic size_t nrows;\n\n \nenum\n{\n  NO_SYNC_OPTION = CHAR_MAX + 1,\n  SYNC_OPTION,\n  TOTAL_OPTION,\n  OUTPUT_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"all\", no_argument, nullptr, 'a'},\n  {\"block-size\", required_argument, nullptr, 'B'},\n  {\"inodes\", no_argument, nullptr, 'i'},\n  {\"human-readable\", no_argument, nullptr, 'h'},\n  {\"si\", no_argument, nullptr, 'H'},\n  {\"local\", no_argument, nullptr, 'l'},\n  {\"output\", optional_argument, nullptr, OUTPUT_OPTION},\n  {\"portability\", no_argument, nullptr, 'P'},\n  {\"print-type\", no_argument, nullptr, 'T'},\n  {\"sync\", no_argument, nullptr, SYNC_OPTION},\n  {\"no-sync\", no_argument, nullptr, NO_SYNC_OPTION},\n  {\"total\", no_argument, nullptr, TOTAL_OPTION},\n  {\"type\", required_argument, nullptr, 't'},\n  {\"exclude-type\", required_argument, nullptr, 'x'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nstatic int\nautomount_stat_err (char const *file, struct stat *st)\n{\n  int fd = open (file, O_RDONLY | O_NOCTTY | O_NONBLOCK);\n  if (fd < 0)\n    {\n      if (errno == ENOENT || errno == ENOTDIR)\n        return errno;\n      return stat (file, st) == 0 ? 0 : errno;\n    }\n  else\n    {\n      int err = fstat (fd, st) == 0 ? 0 : errno;\n      close (fd);\n      return err;\n    }\n}\n\n \n\nstatic void\nreplace_control_chars (char *cell)\n{\n  char *p = cell;\n  while (*p)\n    {\n      if (c_iscntrl (to_uchar (*p)))\n        *p = '?';\n      p++;\n    }\n}\n\n \n\nstatic void\nreplace_invalid_chars (char *cell)\n{\n  char *srcend = cell + strlen (cell);\n  char *dst = cell;\n  mbstate_t mbstate = { 0, };\n  size_t n;\n\n  for (char *src = cell; src != srcend; src += n)\n    {\n      wchar_t wc;\n      size_t srcbytes = srcend - src;\n      n = mbrtowc (&wc, src, srcbytes, &mbstate);\n      bool ok = n <= srcbytes;\n\n      if (ok)\n        ok = !iswcntrl (wc);\n      else\n        n = 1;\n\n      if (ok)\n        {\n          memmove (dst, src, n);\n          dst += n;\n        }\n      else\n        {\n          *dst++ = '?';\n          memset (&mbstate, 0, sizeof mbstate);\n        }\n    }\n\n  *dst = '\\0';\n}\n\nstatic void\nreplace_problematic_chars (char *cell)\n{\n  static int tty_out = -1;\n  if (tty_out < 0)\n    tty_out = isatty (STDOUT_FILENO);\n\n  (tty_out ? replace_invalid_chars : replace_control_chars) (cell) ;\n}\n\n\n \n\nstatic void\nalloc_table_row (void)\n{\n  nrows++;\n  table = xnrealloc (table, nrows, sizeof (char **));\n  table[nrows - 1] = xnmalloc (ncolumns, sizeof (char *));\n}\n\n \n\nstatic void\nprint_table (void)\n{\n  size_t row;\n\n  for (row = 0; row < nrows; row++)\n    {\n      size_t col;\n      for (col = 0; col < ncolumns; col++)\n        {\n          char *cell = table[row][col];\n\n           \n          if (col != 0)\n            putchar (' ');\n\n          int flags = 0;\n          if (col == ncolumns - 1)  \n            flags = MBA_NO_RIGHT_PAD;\n\n          size_t width = columns[col]->width;\n          cell = ambsalign (cell, &width, columns[col]->align, flags);\n           \n          fputs (cell ? cell : table[row][col], stdout);\n          free (cell);\n        }\n      putchar ('\\n');\n    }\n}\n\n \n\nstatic void\nalloc_field (int f, char const *c)\n{\n  ncolumns++;\n  columns = xnrealloc (columns, ncolumns, sizeof (struct field_data_t *));\n  columns[ncolumns - 1] = &field_data[f];\n  if (c != nullptr)\n    columns[ncolumns - 1]->caption = c;\n\n  affirm (!field_data[f].used);\n\n   \n  field_data[f].used = true;\n}\n\n\n \nstatic void\ndecode_output_arg (char const *arg)\n{\n  char *arg_writable = xstrdup (arg);\n  char *s = arg_writable;\n  do\n    {\n       \n      char *comma = strchr (s, ',');\n\n       \n      if (comma)\n        *comma++ = 0;\n\n       \n      display_field_t field = INVALID_FIELD;\n      for (idx_t i = 0; i < ARRAY_CARDINALITY (field_data); i++)\n        {\n          if (STREQ (field_data[i].arg, s))\n            {\n              field = i;\n              break;\n            }\n        }\n      if (field == INVALID_FIELD)\n        {\n          error (0, 0, _(\"option --output: field %s unknown\"), quote (s));\n          usage (EXIT_FAILURE);\n        }\n\n      if (field_data[field].used)\n        {\n           \n          error (0, 0, _(\"option --output: field %s used more than once\"),\n                 quote (field_data[field].arg));\n          usage (EXIT_FAILURE);\n        }\n\n      switch (field)\n        {\n        case SOURCE_FIELD:\n        case FSTYPE_FIELD:\n        case USED_FIELD:\n        case PCENT_FIELD:\n        case ITOTAL_FIELD:\n        case IUSED_FIELD:\n        case IAVAIL_FIELD:\n        case IPCENT_FIELD:\n        case TARGET_FIELD:\n        case FILE_FIELD:\n          alloc_field (field, nullptr);\n          break;\n\n        case SIZE_FIELD:\n          alloc_field (field, N_(\"Size\"));\n          break;\n\n        case AVAIL_FIELD:\n          alloc_field (field, N_(\"Avail\"));\n          break;\n\n        default:\n          affirm (!\"invalid field\");\n        }\n      s = comma;\n    }\n  while (s);\n\n  free (arg_writable);\n}\n\n \nstatic void\nget_field_list (void)\n{\n  switch (header_mode)\n    {\n    case DEFAULT_MODE:\n      alloc_field (SOURCE_FIELD, nullptr);\n      if (print_type)\n        alloc_field (FSTYPE_FIELD, nullptr);\n      alloc_field (SIZE_FIELD,   nullptr);\n      alloc_field (USED_FIELD,   nullptr);\n      alloc_field (AVAIL_FIELD,  nullptr);\n      alloc_field (PCENT_FIELD,  nullptr);\n      alloc_field (TARGET_FIELD, nullptr);\n      break;\n\n    case HUMAN_MODE:\n      alloc_field (SOURCE_FIELD, nullptr);\n      if (print_type)\n        alloc_field (FSTYPE_FIELD, nullptr);\n\n      alloc_field (SIZE_FIELD,   N_(\"Size\"));\n      alloc_field (USED_FIELD,   nullptr);\n      alloc_field (AVAIL_FIELD,  N_(\"Avail\"));\n      alloc_field (PCENT_FIELD,  nullptr);\n      alloc_field (TARGET_FIELD, nullptr);\n      break;\n\n    case INODES_MODE:\n      alloc_field (SOURCE_FIELD, nullptr);\n      if (print_type)\n        alloc_field (FSTYPE_FIELD, nullptr);\n      alloc_field (ITOTAL_FIELD,  nullptr);\n      alloc_field (IUSED_FIELD,   nullptr);\n      alloc_field (IAVAIL_FIELD,  nullptr);\n      alloc_field (IPCENT_FIELD,  nullptr);\n      alloc_field (TARGET_FIELD,  nullptr);\n      break;\n\n    case POSIX_MODE:\n      alloc_field (SOURCE_FIELD, nullptr);\n      if (print_type)\n        alloc_field (FSTYPE_FIELD, nullptr);\n      alloc_field (SIZE_FIELD,   nullptr);\n      alloc_field (USED_FIELD,   nullptr);\n      alloc_field (AVAIL_FIELD,  nullptr);\n      alloc_field (PCENT_FIELD,  N_(\"Capacity\"));\n      alloc_field (TARGET_FIELD, nullptr);\n      break;\n\n    case OUTPUT_MODE:\n      if (!ncolumns)\n        {\n           \n          decode_output_arg (all_args_string);\n        }\n      break;\n\n    default:\n      unreachable ();\n    }\n}\n\n \n\nstatic void\nget_header (void)\n{\n  size_t col;\n\n  alloc_table_row ();\n\n  for (col = 0; col < ncolumns; col++)\n    {\n      char *cell = nullptr;\n      char const *header = _(columns[col]->caption);\n\n      if (columns[col]->field == SIZE_FIELD\n          && (header_mode == DEFAULT_MODE\n              || (header_mode == OUTPUT_MODE\n                  && !(human_output_opts & human_autoscale))))\n        {\n          char buf[LONGEST_HUMAN_READABLE + 1];\n\n          int opts = (human_suppress_point_zero\n                      | human_autoscale | human_SI\n                      | (human_output_opts\n                         & (human_group_digits | human_base_1024 | human_B)));\n\n           \n\n          uintmax_t q1000 = output_block_size;\n          uintmax_t q1024 = output_block_size;\n          bool divisible_by_1000;\n          bool divisible_by_1024;\n\n          do\n            {\n              divisible_by_1000 = q1000 % 1000 == 0;  q1000 /= 1000;\n              divisible_by_1024 = q1024 % 1024 == 0;  q1024 /= 1024;\n            }\n          while (divisible_by_1000 & divisible_by_1024);\n\n          if (divisible_by_1000 < divisible_by_1024)\n            opts |= human_base_1024;\n          if (divisible_by_1024 < divisible_by_1000)\n            opts &= ~human_base_1024;\n          if (! (opts & human_base_1024))\n            opts |= human_B;\n\n          char *num = human_readable (output_block_size, buf, opts, 1, 1);\n\n           \n          header = _(\"blocks\");\n\n           \n          if (asprintf (&cell, _(\"%s-%s\"), num, header) == -1)\n            cell = nullptr;\n        }\n      else if (header_mode == POSIX_MODE && columns[col]->field == SIZE_FIELD)\n        {\n          char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n          char *num = umaxtostr (output_block_size, buf);\n\n           \n          if (asprintf (&cell, _(\"%s-%s\"), num, header) == -1)\n            cell = nullptr;\n        }\n      else\n        cell = strdup (header);\n\n      if (!cell)\n        xalloc_die ();\n\n      replace_problematic_chars (cell);\n\n      table[nrows - 1][col] = cell;\n\n      size_t cell_width = mbswidth (cell, 0);\n      columns[col]->width = MAX (columns[col]->width, cell_width);\n    }\n}\n\n \n\nATTRIBUTE_PURE\nstatic bool\nselected_fstype (char const *fstype)\n{\n  const struct fs_type_list *fsp;\n\n  if (fs_select_list == nullptr || fstype == nullptr)\n    return true;\n  for (fsp = fs_select_list; fsp; fsp = fsp->fs_next)\n    if (STREQ (fstype, fsp->fs_name))\n      return true;\n  return false;\n}\n\n \n\nATTRIBUTE_PURE\nstatic bool\nexcluded_fstype (char const *fstype)\n{\n  const struct fs_type_list *fsp;\n\n  if (fs_exclude_list == nullptr || fstype == nullptr)\n    return false;\n  for (fsp = fs_exclude_list; fsp; fsp = fsp->fs_next)\n    if (STREQ (fstype, fsp->fs_name))\n      return true;\n  return false;\n}\n\nstatic size_t\ndevlist_hash (void const *x, size_t table_size)\n{\n  struct devlist const *p = x;\n  return (uintmax_t) p->dev_num % table_size;\n}\n\nstatic bool\ndevlist_compare (void const *x, void const *y)\n{\n  struct devlist const *a = x;\n  struct devlist const *b = y;\n  return a->dev_num == b->dev_num;\n}\n\nstatic struct devlist *\ndevlist_for_dev (dev_t dev)\n{\n  if (devlist_table == nullptr)\n    return nullptr;\n  struct devlist dev_entry;\n  dev_entry.dev_num = dev;\n\n  struct devlist *found = hash_lookup (devlist_table, &dev_entry);\n  if (found == nullptr)\n    return nullptr;\n\n   \n  return found->seen_last;\n}\n\n \n\nstatic void\nfilter_mount_list (bool devices_only)\n{\n  struct mount_entry *me;\n\n   \n  struct devlist *device_list = nullptr;\n  int mount_list_size = 0;\n\n  for (me = mount_list; me; me = me->me_next)\n    mount_list_size++;\n\n  devlist_table = hash_initialize (mount_list_size, nullptr,\n                                   devlist_hash, devlist_compare, nullptr);\n  if (devlist_table == nullptr)\n    xalloc_die ();\n\n   \n  for (me = mount_list; me;)\n    {\n      struct stat buf;\n      struct mount_entry *discard_me = nullptr;\n\n       \n      if ((me->me_remote && show_local_fs)\n          || (me->me_dummy && !show_all_fs && !show_listed_fs)\n          || (!selected_fstype (me->me_type) || excluded_fstype (me->me_type))\n          || -1 == stat (me->me_mountdir, &buf))\n        {\n           \n          buf.st_dev = me->me_dev;\n        }\n      else\n        {\n           \n          struct devlist *seen_dev = devlist_for_dev (buf.st_dev);\n\n          if (seen_dev)\n            {\n              bool target_nearer_root = strlen (seen_dev->me->me_mountdir)\n                                        > strlen (me->me_mountdir);\n               \n              bool source_below_root = seen_dev->me->me_mntroot != nullptr\n                                       && me->me_mntroot != nullptr\n                                       && (strlen (seen_dev->me->me_mntroot)\n                                           < strlen (me->me_mntroot));\n              if (! print_grand_total\n                  && me->me_remote && seen_dev->me->me_remote\n                  && ! STREQ (seen_dev->me->me_devname, me->me_devname))\n                {\n                   \n                }\n              else if ((strchr (me->me_devname, '/')\n                        \n                        && ! strchr (seen_dev->me->me_devname, '/'))\n                        \n                       || (target_nearer_root && ! source_below_root)\n                        \n                       || (! STREQ (seen_dev->me->me_devname, me->me_devname)\n                            \n                           && STREQ (me->me_mountdir,\n                                     seen_dev->me->me_mountdir)))\n                {\n                   \n                  discard_me = seen_dev->me;\n                  seen_dev->me = me;\n                }\n              else\n                {\n                   \n                  discard_me = me;\n                }\n\n            }\n        }\n\n      if (discard_me)\n        {\n          me = me->me_next;\n          if (! devices_only)\n            free_mount_entry (discard_me);\n        }\n      else\n        {\n           \n          struct devlist *devlist = xmalloc (sizeof *devlist);\n          devlist->me = me;\n          devlist->dev_num = buf.st_dev;\n          devlist->next = device_list;\n          device_list = devlist;\n\n          struct devlist *hash_entry = hash_insert (devlist_table, devlist);\n          if (hash_entry == nullptr)\n            xalloc_die ();\n           \n          hash_entry->seen_last = devlist;\n\n          me = me->me_next;\n        }\n    }\n\n   \n  if (! devices_only) {\n    mount_list = nullptr;\n    while (device_list)\n      {\n         \n        me = device_list->me;\n        me->me_next = mount_list;\n        mount_list = me;\n        struct devlist *next = device_list->next;\n        free (device_list);\n        device_list = next;\n      }\n\n      hash_free (devlist_table);\n      devlist_table = nullptr;\n  }\n}\n\n\n \n\nATTRIBUTE_PURE\nstatic struct mount_entry const *\nme_for_dev (dev_t dev)\n{\n  struct devlist *dl = devlist_for_dev (dev);\n  if (dl)\n        return dl->me;\n\n  return nullptr;\n}\n\n \nstatic bool\nknown_value (uintmax_t n)\n{\n  return n < UINTMAX_MAX - 1;\n}\n\n \n\nstatic char const *\ndf_readable (bool negative, uintmax_t n, char *buf,\n             uintmax_t input_units, uintmax_t output_units)\n{\n  if (! known_value (n) && !negative)\n    return \"-\";\n  else\n    {\n      char *p = human_readable (negative ? -n : n, buf + negative,\n                                human_output_opts, input_units, output_units);\n      if (negative)\n        *--p = '-';\n      return p;\n    }\n}\n\n \nstatic void\nadd_uint_with_neg_flag (uintmax_t *dest, bool *dest_neg,\n                        uintmax_t src, bool src_neg)\n{\n  if (*dest_neg == src_neg)\n    {\n      *dest += src;\n      return;\n    }\n\n  if (*dest_neg)\n    *dest = -*dest;\n\n  if (src_neg)\n    src = -src;\n\n  if (src < *dest)\n    *dest -= src;\n  else\n    {\n      *dest = src - *dest;\n      *dest_neg = src_neg;\n    }\n\n  if (*dest_neg)\n    *dest = -*dest;\n}\n\n \nATTRIBUTE_PURE\nstatic bool\nhas_uuid_suffix (char const *s)\n{\n  size_t len = strlen (s);\n  return (36 < len\n          && strspn (s + len - 36, \"-0123456789abcdefABCDEF\") == 36);\n}\n\n \nstatic void\nget_field_values (struct field_values_t *bv,\n                  struct field_values_t *iv,\n                  const struct fs_usage *fsu)\n{\n   \n  iv->input_units = iv->output_units = 1;\n  iv->total = fsu->fsu_files;\n  iv->available = iv->available_to_root = fsu->fsu_ffree;\n  iv->negate_available = false;\n\n  iv->used = UINTMAX_MAX;\n  iv->negate_used = false;\n  if (known_value (iv->total) && known_value (iv->available_to_root))\n    {\n      iv->used = iv->total - iv->available_to_root;\n      iv->negate_used = (iv->total < iv->available_to_root);\n    }\n\n   \n  bv->input_units = fsu->fsu_blocksize;\n  bv->output_units = output_block_size;\n  bv->total = fsu->fsu_blocks;\n  bv->available = fsu->fsu_bavail;\n  bv->available_to_root = fsu->fsu_bfree;\n  bv->negate_available = (fsu->fsu_bavail_top_bit_set\n                         && known_value (fsu->fsu_bavail));\n\n  bv->used = UINTMAX_MAX;\n  bv->negate_used = false;\n  if (known_value (bv->total) && known_value (bv->available_to_root))\n    {\n      bv->used = bv->total - bv->available_to_root;\n      bv->negate_used = (bv->total < bv->available_to_root);\n    }\n}\n\n \nstatic void\nadd_to_grand_total (struct field_values_t *bv, struct field_values_t *iv)\n{\n  if (known_value (iv->total))\n    grand_fsu.fsu_files += iv->total;\n  if (known_value (iv->available))\n    grand_fsu.fsu_ffree += iv->available;\n\n  if (known_value (bv->total))\n    grand_fsu.fsu_blocks += bv->input_units * bv->total;\n  if (known_value (bv->available_to_root))\n    grand_fsu.fsu_bfree += bv->input_units * bv->available_to_root;\n  if (known_value (bv->available))\n    add_uint_with_neg_flag (&grand_fsu.fsu_bavail,\n                            &grand_fsu.fsu_bavail_top_bit_set,\n                            bv->input_units * bv->available,\n                            bv->negate_available);\n}\n\n \n\nstatic void\nget_dev (char const *device, char const *mount_point, char const *file,\n         char const *stat_file, char const *fstype,\n         bool me_dummy, bool me_remote,\n         const struct fs_usage *force_fsu,\n         bool process_all)\n{\n  if (me_remote && show_local_fs)\n    return;\n\n  if (me_dummy && !show_all_fs && !show_listed_fs)\n    return;\n\n  if (!selected_fstype (fstype) || excluded_fstype (fstype))\n    return;\n\n   \n  if (!force_fsu && mount_point && ! IS_ABSOLUTE_FILE_NAME (mount_point))\n    return;\n\n   \n  if (!stat_file)\n    stat_file = mount_point ? mount_point : device;\n\n  struct fs_usage fsu;\n  if (force_fsu)\n    fsu = *force_fsu;\n  else if (get_fs_usage (stat_file, device, &fsu))\n    {\n       \n      if (process_all && (errno == EACCES || errno == ENOENT))\n        {\n          if (! show_all_fs)\n            return;\n\n          fstype = \"-\";\n          fsu.fsu_bavail_top_bit_set = false;\n          fsu.fsu_blocksize = fsu.fsu_blocks = fsu.fsu_bfree =\n          fsu.fsu_bavail = fsu.fsu_files = fsu.fsu_ffree = UINTMAX_MAX;\n        }\n      else\n        {\n          error (0, errno, \"%s\", quotef (stat_file));\n          exit_status = EXIT_FAILURE;\n          return;\n        }\n    }\n  else if (process_all && show_all_fs)\n    {\n       \n      struct stat sb;\n      if (stat (stat_file, &sb) == 0)\n        {\n          struct mount_entry const * dev_me = me_for_dev (sb.st_dev);\n          if (dev_me && ! STREQ (dev_me->me_devname, device)\n              && (! dev_me->me_remote || ! me_remote))\n            {\n              fstype = \"-\";\n              fsu.fsu_bavail_top_bit_set = false;\n              fsu.fsu_blocksize = fsu.fsu_blocks = fsu.fsu_bfree =\n              fsu.fsu_bavail = fsu.fsu_files = fsu.fsu_ffree = UINTMAX_MAX;\n            }\n        }\n    }\n\n  if (fsu.fsu_blocks == 0 && !show_all_fs && !show_listed_fs)\n    return;\n\n  if (! force_fsu)\n    file_systems_processed = true;\n\n  alloc_table_row ();\n\n  if (! device)\n    device = \"-\";\t\t \n\n  if (! file)\n    file = \"-\";\t\t\t \n\n  char *dev_name = xstrdup (device);\n  char *resolved_dev;\n\n   \n  if (process_all\n      && has_uuid_suffix (dev_name)\n      && (resolved_dev = canonicalize_filename_mode (dev_name, CAN_EXISTING)))\n    {\n      free (dev_name);\n      dev_name = resolved_dev;\n    }\n\n  if (! fstype)\n    fstype = \"-\";\t\t \n\n  struct field_values_t block_values;\n  struct field_values_t inode_values;\n  get_field_values (&block_values, &inode_values, &fsu);\n\n   \n  if (print_grand_total && ! force_fsu)\n    add_to_grand_total (&block_values, &inode_values);\n\n  size_t col;\n  for (col = 0; col < ncolumns; col++)\n    {\n      char buf[LONGEST_HUMAN_READABLE + 2];\n      char *cell;\n\n      struct field_values_t *v;\n      switch (columns[col]->field_type)\n        {\n        case BLOCK_FLD:\n          v = &block_values;\n          break;\n        case INODE_FLD:\n          v = &inode_values;\n          break;\n        case OTHER_FLD:\n          v = nullptr;\n          break;\n        default:\n          affirm (!\"bad field_type\");\n        }\n\n      switch (columns[col]->field)\n        {\n        case SOURCE_FIELD:\n          cell = xstrdup (dev_name);\n          break;\n\n        case FSTYPE_FIELD:\n          cell = xstrdup (fstype);\n          break;\n\n        case SIZE_FIELD:\n        case ITOTAL_FIELD:\n          cell = xstrdup (df_readable (false, v->total, buf,\n                                       v->input_units, v->output_units));\n          break;\n\n        case USED_FIELD:\n        case IUSED_FIELD:\n          cell = xstrdup (df_readable (v->negate_used, v->used, buf,\n                                       v->input_units, v->output_units));\n          break;\n\n        case AVAIL_FIELD:\n        case IAVAIL_FIELD:\n          cell = xstrdup (df_readable (v->negate_available, v->available, buf,\n                                       v->input_units, v->output_units));\n          break;\n\n        case PCENT_FIELD:\n        case IPCENT_FIELD:\n          {\n            double pct = -1;\n            if (! known_value (v->used) || ! known_value (v->available))\n              ;\n            else if (!v->negate_used\n                     && v->used <= TYPE_MAXIMUM (uintmax_t) / 100\n                     && v->used + v->available != 0\n                     && (v->used + v->available < v->used)\n                     == v->negate_available)\n              {\n                uintmax_t u100 = v->used * 100;\n                uintmax_t nonroot_total = v->used + v->available;\n                pct = u100 / nonroot_total + (u100 % nonroot_total != 0);\n              }\n            else\n              {\n                 \n                double u = v->negate_used ? - (double) - v->used : v->used;\n                double a = v->negate_available\n                           ? - (double) - v->available : v->available;\n                double nonroot_total = u + a;\n                if (nonroot_total)\n                  {\n                    long int lipct = pct = u * 100 / nonroot_total;\n                    double ipct = lipct;\n\n                     \n                    if (ipct - 1 < pct && pct <= ipct + 1)\n                      pct = ipct + (ipct < pct);\n                  }\n              }\n\n            if (0 <= pct)\n              {\n                if (asprintf (&cell, \"%.0f%%\", pct) == -1)\n                  cell = nullptr;\n              }\n            else\n              cell = strdup (\"-\");\n\n            if (!cell)\n              xalloc_die ();\n\n            break;\n          }\n\n        case FILE_FIELD:\n          cell = xstrdup (file);\n          break;\n\n        case TARGET_FIELD:\n#ifdef HIDE_AUTOMOUNT_PREFIX\n           \n          if (STRNCMP_LIT (mount_point, \"/auto/\") == 0)\n            mount_point += 5;\n          else if (STRNCMP_LIT (mount_point, \"/tmp_mnt/\") == 0)\n            mount_point += 8;\n#endif\n          cell = xstrdup (mount_point);\n          break;\n\n        default:\n          affirm (!\"unhandled field\");\n        }\n\n      affirm (cell);\n\n      replace_problematic_chars (cell);\n      size_t cell_width = mbswidth (cell, 0);\n      columns[col]->width = MAX (columns[col]->width, cell_width);\n      table[nrows - 1][col] = cell;\n    }\n  free (dev_name);\n}\n\n \nstatic char *\nlast_device_for_mount (char const *mount)\n{\n  struct mount_entry const *me;\n  struct mount_entry const *le = nullptr;\n\n  for (me = mount_list; me; me = me->me_next)\n    {\n      if (STREQ (me->me_mountdir, mount))\n        le = me;\n    }\n\n  if (le)\n    {\n      char *devname = le->me_devname;\n      char *canon_dev = canonicalize_file_name (devname);\n      if (canon_dev && IS_ABSOLUTE_FILE_NAME (canon_dev))\n        return canon_dev;\n      free (canon_dev);\n      return xstrdup (le->me_devname);\n    }\n  else\n    return nullptr;\n}\n\n \nstatic bool\nget_device (char const *device)\n{\n  struct mount_entry const *me;\n  struct mount_entry const *best_match = nullptr;\n  bool best_match_accessible = false;\n  bool eclipsed_device = false;\n  char const *file = device;\n\n  char *resolved = canonicalize_file_name (device);\n  if (resolved && IS_ABSOLUTE_FILE_NAME (resolved))\n    device = resolved;\n\n  size_t best_match_len = SIZE_MAX;\n  for (me = mount_list; me; me = me->me_next)\n    {\n       \n      char *devname = me->me_devname;\n      char *canon_dev = canonicalize_file_name (me->me_devname);\n      if (canon_dev && IS_ABSOLUTE_FILE_NAME (canon_dev))\n        devname = canon_dev;\n\n      if (STREQ (device, devname))\n        {\n          char *last_device = last_device_for_mount (me->me_mountdir);\n          eclipsed_device = last_device && ! STREQ (last_device, devname);\n          size_t len = strlen (me->me_mountdir);\n\n          if (! eclipsed_device\n              && (! best_match_accessible || len < best_match_len))\n            {\n              struct stat device_stats;\n              bool this_match_accessible = false;\n\n              if (stat (me->me_mountdir, &device_stats) == 0)\n                best_match_accessible = this_match_accessible = true;\n\n              if (this_match_accessible\n                  || (! best_match_accessible && len < best_match_len))\n                {\n                  best_match = me;\n                  if (len == 1)  \n                    {\n                      free (last_device);\n                      free (canon_dev);\n                      break;\n                    }\n                  else\n                    best_match_len = len;\n                }\n            }\n\n          free (last_device);\n        }\n\n      free (canon_dev);\n    }\n\n  free (resolved);\n\n  if (best_match)\n    {\n      get_dev (best_match->me_devname, best_match->me_mountdir, file, nullptr,\n               best_match->me_type, best_match->me_dummy,\n               best_match->me_remote, nullptr, false);\n      return true;\n    }\n  else if (eclipsed_device)\n    {\n      error (0, 0, _(\"cannot access %s: over-mounted by another device\"),\n             quoteaf (file));\n      exit_status = EXIT_FAILURE;\n      return true;\n    }\n\n  return false;\n}\n\n \nstatic void\nget_point (char const *point, const struct stat *statp)\n{\n  struct stat device_stats;\n  struct mount_entry *me;\n  struct mount_entry const *best_match = nullptr;\n\n   \n  char *resolved = canonicalize_file_name (point);\n  if (resolved && resolved[0] == '/')\n    {\n      size_t resolved_len = strlen (resolved);\n      size_t best_match_len = 0;\n\n      for (me = mount_list; me; me = me->me_next)\n        {\n          if (!STREQ (me->me_type, \"lofs\")\n              && (!best_match || best_match->me_dummy || !me->me_dummy))\n            {\n              size_t len = strlen (me->me_mountdir);\n              if (best_match_len <= len && len <= resolved_len\n                  && (len == 1  \n                      || ((len == resolved_len || resolved[len] == '/')\n                          && STREQ_LEN (me->me_mountdir, resolved, len))))\n                {\n                  best_match = me;\n                  best_match_len = len;\n                }\n            }\n        }\n    }\n  free (resolved);\n  if (best_match\n      && (stat (best_match->me_mountdir, &device_stats) != 0\n          || device_stats.st_dev != statp->st_dev))\n    best_match = nullptr;\n\n  if (! best_match)\n    for (me = mount_list; me; me = me->me_next)\n      {\n        if (me->me_dev == (dev_t) -1)\n          {\n            if (stat (me->me_mountdir, &device_stats) == 0)\n              me->me_dev = device_stats.st_dev;\n            else\n              {\n                 \n                if (errno == EIO)\n                  {\n                    error (0, errno, \"%s\", quotef (me->me_mountdir));\n                    exit_status = EXIT_FAILURE;\n                  }\n\n                 \n                me->me_dev = (dev_t) -2;\n              }\n          }\n\n        if (statp->st_dev == me->me_dev\n            && !STREQ (me->me_type, \"lofs\")\n            && (!best_match || best_match->me_dummy || !me->me_dummy))\n          {\n             \n            if (stat (me->me_mountdir, &device_stats) != 0\n                || device_stats.st_dev != me->me_dev)\n              me->me_dev = (dev_t) -2;\n            else\n              best_match = me;\n          }\n      }\n\n  if (best_match)\n    get_dev (best_match->me_devname, best_match->me_mountdir, point, point,\n             best_match->me_type, best_match->me_dummy, best_match->me_remote,\n             nullptr, false);\n  else\n    {\n       \n\n       \n      char *mp = find_mount_point (point, statp);\n      if (mp)\n        {\n          get_dev (nullptr, mp, point, nullptr, nullptr,\n                   false, false, nullptr, false);\n          free (mp);\n        }\n    }\n}\n\n \n\nstatic void\nget_entry (char const *name, struct stat const *statp)\n{\n  if ((S_ISBLK (statp->st_mode) || S_ISCHR (statp->st_mode))\n      && get_device (name))\n    return;\n\n  get_point (name, statp);\n}\n\n \n\nstatic void\nget_all_entries (void)\n{\n  struct mount_entry *me;\n\n  filter_mount_list (show_all_fs);\n\n  for (me = mount_list; me; me = me->me_next)\n    get_dev (me->me_devname, me->me_mountdir, nullptr, nullptr, me->me_type,\n             me->me_dummy, me->me_remote, nullptr, true);\n}\n\n \n\nstatic void\nadd_fs_type (char const *fstype)\n{\n  struct fs_type_list *fsp;\n\n  fsp = xmalloc (sizeof *fsp);\n  fsp->fs_name = (char *) fstype;\n  fsp->fs_next = fs_select_list;\n  fs_select_list = fsp;\n}\n\n \n\nstatic void\nadd_excluded_fs_type (char const *fstype)\n{\n  struct fs_type_list *fsp;\n\n  fsp = xmalloc (sizeof *fsp);\n  fsp->fs_name = (char *) fstype;\n  fsp->fs_next = fs_exclude_list;\n  fs_exclude_list = fsp;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [FILE]...\\n\"), program_name);\n      fputs (_(\"\\\nShow information about the file system on which each FILE resides,\\n\\\nor all file systems by default.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      /* TRANSLATORS: The thousands and decimal separators are best\n         adjusted to an appropriate default for your locale.  */\n      fputs (_(\"\\\n  -a, --all             include pseudo, duplicate, inaccessible file systems\\n\\\n  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\\n\\\n                           '-BM' prints sizes in units of 1,048,576 bytes;\\n\\\n                           see SIZE format below\\n\\\n  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\\n\\\n  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -i, --inodes          list inode information instead of block usage\\n\\\n  -k                    like --block-size=1K\\n\\\n  -l, --local           limit listing to local file systems\\n\\\n      --no-sync         do not invoke sync before getting usage info (default)\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\\n\\\n                               or print all fields if FIELD_LIST is omitted.\\n\\\n  -P, --portability     use the POSIX output format\\n\\\n      --sync            invoke sync before getting usage info\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --total           elide all entries insignificant to available space,\\n\\\n                          and produce a grand total\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t, --type=TYPE       limit listing to file systems of type TYPE\\n\\\n  -T, --print-type      print file system type\\n\\\n  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\\n\\\n  -v                    (ignored)\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_blocksize_note (\"DF\");\n      emit_size_note ();\n      fputs (_(\"\\n\\\nFIELD_LIST is a comma-separated list of columns to be included.  Valid\\n\\\nfield names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\\n\\\n'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  struct stat *stats = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  fs_select_list = nullptr;\n  fs_exclude_list = nullptr;\n  show_all_fs = false;\n  show_listed_fs = false;\n  human_output_opts = -1;\n  print_type = false;\n  file_systems_processed = false;\n  exit_status = EXIT_SUCCESS;\n  print_grand_total = false;\n  grand_fsu.fsu_blocksize = 1;\n\n  /* If true, use the POSIX output format.  */\n  bool posix_format = false;\n\n  char const *msg_mut_excl = _(\"options %s and %s are mutually exclusive\");\n\n  while (true)\n    {\n      int oi = -1;\n      int c = getopt_long (argc, argv, \"aB:iF:hHklmPTt:vx:\", long_options,\n                           &oi);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 'a':\n          show_all_fs = true;\n          break;\n        case 'B':\n          {\n            enum strtol_error e = human_options (optarg, &human_output_opts,\n                                                 &output_block_size);\n            if (e != LONGINT_OK)\n              xstrtol_fatal (e, oi, c, long_options, optarg);\n          }\n          break;\n        case 'i':\n          if (header_mode == OUTPUT_MODE)\n            {\n              error (0, 0, msg_mut_excl, \"-i\", \"--output\");\n              usage (EXIT_FAILURE);\n            }\n          header_mode = INODES_MODE;\n          break;\n        case 'h':\n          human_output_opts = human_autoscale | human_SI | human_base_1024;\n          output_block_size = 1;\n          break;\n        case 'H':\n          human_output_opts = human_autoscale | human_SI;\n          output_block_size = 1;\n          break;\n        case 'k':\n          human_output_opts = 0;\n          output_block_size = 1024;\n          break;\n        case 'l':\n          show_local_fs = true;\n          break;\n        case 'm': /* obsolescent, exists for BSD compatibility */\n          human_output_opts = 0;\n          output_block_size = 1024 * 1024;\n          break;\n        case 'T':\n          if (header_mode == OUTPUT_MODE)\n            {\n              error (0, 0, msg_mut_excl, \"-T\", \"--output\");\n              usage (EXIT_FAILURE);\n            }\n          print_type = true;\n          break;\n        case 'P':\n          if (header_mode == OUTPUT_MODE)\n            {\n              error (0, 0, msg_mut_excl, \"-P\", \"--output\");\n              usage (EXIT_FAILURE);\n            }\n          posix_format = true;\n          break;\n        case SYNC_OPTION:\n          require_sync = true;\n          break;\n        case NO_SYNC_OPTION:\n          require_sync = false;\n          break;\n\n        case 'F':\n          /* Accept -F as a synonym for -t for compatibility with Solaris.  */\n        case 't':\n          add_fs_type (optarg);\n          break;\n\n        case 'v':\t\t/* For SysV compatibility.  */\n          /* ignore */\n          break;\n        case 'x':\n          add_excluded_fs_type (optarg);\n          break;\n\n        case OUTPUT_OPTION:\n          if (header_mode == INODES_MODE)\n            {\n              error (0, 0, msg_mut_excl, \"-i\", \"--output\");\n              usage (EXIT_FAILURE);\n            }\n          if (posix_format && header_mode == DEFAULT_MODE)\n            {\n              error (0, 0, msg_mut_excl, \"-P\", \"--output\");\n              usage (EXIT_FAILURE);\n            }\n          if (print_type)\n            {\n              error (0, 0, msg_mut_excl, \"-T\", \"--output\");\n              usage (EXIT_FAILURE);\n            }\n          header_mode = OUTPUT_MODE;\n          if (optarg)\n            decode_output_arg (optarg);\n          break;\n\n        case TOTAL_OPTION:\n          print_grand_total = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (human_output_opts == -1)\n    {\n      if (posix_format)\n        {\n          human_output_opts = 0;\n          output_block_size = (getenv (\"POSIXLY_CORRECT\") ? 512 : 1024);\n        }\n      else\n        human_options (getenv (\"DF_BLOCK_SIZE\"),\n                       &human_output_opts, &output_block_size);\n    }\n\n  if (header_mode == INODES_MODE || header_mode == OUTPUT_MODE)\n    ;\n  else if (human_output_opts & human_autoscale)\n    header_mode = HUMAN_MODE;\n  else if (posix_format)\n    header_mode = POSIX_MODE;\n\n  /* Fail if the same file system type was both selected and excluded.  */\n  {\n    bool match = false;\n    struct fs_type_list *fs_incl;\n    for (fs_incl = fs_select_list; fs_incl; fs_incl = fs_incl->fs_next)\n      {\n        struct fs_type_list *fs_excl;\n        for (fs_excl = fs_exclude_list; fs_excl; fs_excl = fs_excl->fs_next)\n          {\n            if (STREQ (fs_incl->fs_name, fs_excl->fs_name))\n              {\n                error (0, 0,\n                       _(\"file system type %s both selected and excluded\"),\n                       quote (fs_incl->fs_name));\n                match = true;\n                break;\n              }\n          }\n      }\n    if (match)\n      return EXIT_FAILURE;\n  }\n\n  if (optind < argc)\n    {\n      /* stat each of the given entries to make sure any corresponding\n         partition is automounted.  This must be done before reading the\n         file system table.  */\n      stats = xnmalloc (argc - optind, sizeof *stats);\n      for (int i = optind; i < argc; ++i)\n        {\n          int err = automount_stat_err (argv[i], &stats[i - optind]);\n          if (err != 0)\n            {\n              error (0, err, \"%s\", quotef (argv[i]));\n              exit_status = EXIT_FAILURE;\n              argv[i] = nullptr;\n            }\n        }\n    }\n\n  mount_list =\n    read_file_system_list ((fs_select_list != nullptr\n                            || fs_exclude_list != nullptr\n                            || print_type\n                            || field_data[FSTYPE_FIELD].used\n                            || show_local_fs));\n\n  if (mount_list == nullptr)\n    {\n      /* Couldn't read the table of mounted file systems.\n         Fail if df was invoked with no file name arguments,\n         or when either of -a, -l, -t or -x is used with file name\n         arguments.  Otherwise, merely give a warning and proceed.  */\n      int status = 0;\n      if ( ! (optind < argc)\n           || (show_all_fs\n               || show_local_fs\n               || fs_select_list != nullptr\n               || fs_exclude_list != nullptr))\n        {\n          status = EXIT_FAILURE;\n        }\n      char const *warning = (status == 0 ? _(\"Warning: \") : \"\");\n      error (status, errno, \"%s%s\", warning,\n             _(\"cannot read table of mounted file systems\"));\n    }\n\n  if (require_sync)\n    sync ();\n\n  get_field_list ();\n  get_header ();\n\n  if (stats)\n    {\n      /* Display explicitly requested empty file systems.  */\n      show_listed_fs = true;\n\n      for (int i = optind; i < argc; ++i)\n        if (argv[i])\n          get_entry (argv[i], &stats[i - optind]);\n    }\n  else\n    get_all_entries ();\n\n  if (file_systems_processed)\n    {\n      if (print_grand_total)\n        get_dev (\"total\",\n                 (field_data[SOURCE_FIELD].used ? \"-\" : \"total\"),\n                 nullptr, nullptr, nullptr, false, false, &grand_fsu, false);\n\n      print_table ();\n    }\n  else\n    {\n      /* Print the \"no FS processed\" diagnostic only if there was no preceding\n         diagnostic, e.g., if all have been excluded.  */\n      if (exit_status == EXIT_SUCCESS)\n        error (EXIT_FAILURE, 0, _(\"no file systems processed\"));\n    }\n\n  main_exit (exit_status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}