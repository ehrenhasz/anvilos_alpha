{
  "module_name": "cksum_pclmul.c",
  "hash_id": "04fb5abd6b4d84446972fa6c462d1b05286226a16d4e6e5aca1d64c4dfa5c924",
  "original_prompt": "Ingested from coreutils-9.4/src/cksum_pclmul.c",
  "human_readable_source": " \n#define BUFLEN (1 << 16)\n\nextern uint_fast32_t const crctab[8][256];\n\nextern bool\ncksum_pclmul (FILE *fp, uint_fast32_t *crc_out, uintmax_t *length_out);\n\n \n\nbool\ncksum_pclmul (FILE *fp, uint_fast32_t *crc_out, uintmax_t *length_out)\n{\n  __m128i buf[BUFLEN / sizeof (__m128i)];\n  uint_fast32_t crc = 0;\n  uintmax_t length = 0;\n  size_t bytes_read;\n  __m128i single_mult_constant;\n  __m128i four_mult_constant;\n  __m128i shuffle_constant;\n\n  if (!fp || !crc_out || !length_out)\n    return false;\n\n   \n  single_mult_constant = _mm_set_epi64x (0xC5B9CD4C, 0xE8A45605);\n  four_mult_constant = _mm_set_epi64x (0x8833794C, 0xE6228B11);\n\n   \n  shuffle_constant = _mm_set_epi8 (0, 1, 2, 3, 4, 5, 6, 7, 8,\n                                   9, 10, 11, 12, 13, 14, 15);\n\n  while ((bytes_read = fread (buf, 1, BUFLEN, fp)) > 0)\n    {\n      __m128i *datap;\n      __m128i data;\n      __m128i data2;\n      __m128i data3;\n      __m128i data4;\n      __m128i data5;\n      __m128i data6;\n      __m128i data7;\n      __m128i data8;\n      __m128i fold_data;\n      __m128i xor_crc;\n\n      if (length + bytes_read < length)\n        {\n          errno = EOVERFLOW;\n          return false;\n        }\n      length += bytes_read;\n\n      datap = (__m128i *)buf;\n\n       \n      if (bytes_read >= 16 * 8)\n        {\n          data = _mm_loadu_si128 (datap);\n          data = _mm_shuffle_epi8 (data, shuffle_constant);\n           \n          xor_crc = _mm_set_epi32 (crc, 0, 0, 0);\n          crc = 0;\n          data = _mm_xor_si128 (data, xor_crc);\n          data3 = _mm_loadu_si128 (datap + 1);\n          data3 = _mm_shuffle_epi8 (data3, shuffle_constant);\n          data5 = _mm_loadu_si128 (datap + 2);\n          data5 = _mm_shuffle_epi8 (data5, shuffle_constant);\n          data7 = _mm_loadu_si128 (datap + 3);\n          data7 = _mm_shuffle_epi8 (data7, shuffle_constant);\n\n\n          while (bytes_read >= 16 * 8)\n            {\n              datap += 4;\n\n               \n              data2 = _mm_clmulepi64_si128 (data, four_mult_constant, 0x00);\n              data = _mm_clmulepi64_si128 (data, four_mult_constant, 0x11);\n              data4 = _mm_clmulepi64_si128 (data3, four_mult_constant, 0x00);\n              data3 = _mm_clmulepi64_si128 (data3, four_mult_constant, 0x11);\n              data6 = _mm_clmulepi64_si128 (data5, four_mult_constant, 0x00);\n              data5 = _mm_clmulepi64_si128 (data5, four_mult_constant, 0x11);\n              data8 = _mm_clmulepi64_si128 (data7, four_mult_constant, 0x00);\n              data7 = _mm_clmulepi64_si128 (data7, four_mult_constant, 0x11);\n\n               \n              data = _mm_xor_si128 (data, data2);\n              data2 = _mm_loadu_si128 (datap);\n              data2 = _mm_shuffle_epi8 (data2, shuffle_constant);\n              data = _mm_xor_si128 (data, data2);\n\n              data3 = _mm_xor_si128 (data3, data4);\n              data4 = _mm_loadu_si128 (datap + 1);\n              data4 = _mm_shuffle_epi8 (data4, shuffle_constant);\n              data3 = _mm_xor_si128 (data3, data4);\n\n              data5 = _mm_xor_si128 (data5, data6);\n              data6 = _mm_loadu_si128 (datap + 2);\n              data6 = _mm_shuffle_epi8 (data6, shuffle_constant);\n              data5 = _mm_xor_si128 (data5, data6);\n\n              data7 = _mm_xor_si128 (data7, data8);\n              data8 = _mm_loadu_si128 (datap + 3);\n              data8 = _mm_shuffle_epi8 (data8, shuffle_constant);\n              data7 = _mm_xor_si128 (data7, data8);\n\n              bytes_read -= (16 * 4);\n            }\n           \n          data = _mm_shuffle_epi8 (data, shuffle_constant);\n          _mm_storeu_si128 (datap, data);\n          data3 = _mm_shuffle_epi8 (data3, shuffle_constant);\n          _mm_storeu_si128 (datap + 1, data3);\n          data5 = _mm_shuffle_epi8 (data5, shuffle_constant);\n          _mm_storeu_si128 (datap + 2, data5);\n          data7 = _mm_shuffle_epi8 (data7, shuffle_constant);\n          _mm_storeu_si128 (datap + 3, data7);\n        }\n\n       \n      if (bytes_read >= 32)\n        {\n          data = _mm_loadu_si128 (datap);\n          data = _mm_shuffle_epi8 (data, shuffle_constant);\n          xor_crc = _mm_set_epi32 (crc, 0, 0, 0);\n          crc = 0;\n          data = _mm_xor_si128 (data, xor_crc);\n          while (bytes_read >= 32)\n            {\n              datap++;\n\n              data2 = _mm_clmulepi64_si128 (data, single_mult_constant, 0x00);\n              data = _mm_clmulepi64_si128 (data, single_mult_constant, 0x11);\n              fold_data = _mm_loadu_si128 (datap);\n              fold_data = _mm_shuffle_epi8 (fold_data, shuffle_constant);\n              data = _mm_xor_si128 (data, data2);\n              data = _mm_xor_si128 (data, fold_data);\n              bytes_read -= 16;\n            }\n          data = _mm_shuffle_epi8 (data, shuffle_constant);\n          _mm_storeu_si128 (datap, data);\n        }\n\n       \n      unsigned char *cp = (unsigned char *)datap;\n      while (bytes_read--)\n        crc = (crc << 8) ^ crctab[0][((crc >> 24) ^ *cp++) & 0xFF];\n      if (feof (fp))\n        break;\n    }\n\n  *crc_out = crc;\n  *length_out = length;\n\n  return !ferror (fp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}