{
  "module_name": "force-link.c",
  "hash_id": "08f99757efbef9bfc28d00e1e0a878ae5a458a1fc55b4979f48f5f90887b7a22",
  "original_prompt": "Ingested from coreutils-9.4/src/force-link.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n#include \"system.h\"\n\n#include \"force-link.h\"\n\n#include <tempname.h>\n\n \n\nstatic char const simple_pattern[] = \"CuXXXXXX\";\nenum { x_suffix_len = sizeof \"XXXXXX\" - 1 };\n\n \n\nenum { smallsize = 256 };\n\n \n\nstatic char *\nsamedir_template (char const *dstname, char buf[smallsize])\n{\n  ptrdiff_t dstdirlen = last_component (dstname) - dstname;\n  size_t dsttmpsize = dstdirlen + sizeof simple_pattern;\n  char *dsttmp;\n  if (dsttmpsize <= smallsize)\n    dsttmp = buf;\n  else\n    {\n      dsttmp = malloc (dsttmpsize);\n      if (!dsttmp)\n        return dsttmp;\n    }\n  strcpy (mempcpy (dsttmp, dstname, dstdirlen), simple_pattern);\n  return dsttmp;\n}\n\n\n \n\nstruct link_arg\n{\n  int srcdir;\n  char const *srcname;\n  int dstdir;\n  int flags;\n};\n\nstatic int\ntry_link (char *dest, void *arg)\n{\n  struct link_arg *a = arg;\n  return linkat (a->srcdir, a->srcname, a->dstdir, dest, a->flags);\n}\n\n \nextern int\nforce_linkat (int srcdir, char const *srcname,\n              int dstdir, char const *dstname, int flags, bool force,\n              int linkat_errno)\n{\n  if (linkat_errno < 0)\n    linkat_errno = (linkat (srcdir, srcname, dstdir, dstname, flags) == 0\n                    ? 0 : errno);\n  if (!force || linkat_errno != EEXIST)\n    return linkat_errno;\n\n  char buf[smallsize];\n  char *dsttmp = samedir_template (dstname, buf);\n  if (! dsttmp)\n    return errno;\n  struct link_arg arg = { srcdir, srcname, dstdir, flags };\n  int err;\n\n  if (try_tempname_len (dsttmp, 0, &arg, try_link, x_suffix_len) != 0)\n    err = errno;\n  else\n    {\n      err = renameat (dstdir, dsttmp, dstdir, dstname) == 0 ? -1 : errno;\n       \n      unlinkat (dstdir, dsttmp, 0);\n    }\n\n  if (dsttmp != buf)\n    free (dsttmp);\n  return err;\n}\n\n\n \n\nstruct symlink_arg\n{\n  char const *srcname;\n  int dstdir;\n};\n\nstatic int\ntry_symlink (char *dest, void *arg)\n{\n  struct symlink_arg *a = arg;\n  return symlinkat (a->srcname, a->dstdir, dest);\n}\n\n \nextern int\nforce_symlinkat (char const *srcname, int dstdir, char const *dstname,\n                 bool force, int symlinkat_errno)\n{\n  if (symlinkat_errno < 0)\n    symlinkat_errno = symlinkat (srcname, dstdir, dstname) == 0 ? 0 : errno;\n  if (!force || symlinkat_errno != EEXIST)\n    return symlinkat_errno;\n\n  char buf[smallsize];\n  char *dsttmp = samedir_template (dstname, buf);\n  if (!dsttmp)\n    return errno;\n  struct symlink_arg arg = { srcname, dstdir };\n  int err;\n\n  if (try_tempname_len (dsttmp, 0, &arg, try_symlink, x_suffix_len) != 0)\n    err = errno;\n  else if (renameat (dstdir, dsttmp, dstdir, dstname) != 0)\n    {\n      err = errno;\n      unlinkat (dstdir, dsttmp, 0);\n    }\n  else\n    {\n       \n      err = -1;\n    }\n\n  if (dsttmp != buf)\n    free (dsttmp);\n  return err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}