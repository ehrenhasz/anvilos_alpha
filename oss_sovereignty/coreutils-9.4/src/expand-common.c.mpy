{
  "module_name": "expand-common.c",
  "hash_id": "169fb0754034bfdd604068f633083b1082c6e3f5fa303cd2b272edce209af3b4",
  "original_prompt": "Ingested from coreutils-9.4/src/expand-common.c",
  "human_readable_source": " \nbool convert_entire_line = false;\n\n \nstatic uintmax_t tab_size = 0;\n\n \nstatic uintmax_t extend_size = 0;\n\n \nstatic uintmax_t increment_size = 0;\n\n \nsize_t max_column_width;\n\n \nstatic uintmax_t *tab_list = nullptr;\n\n \nstatic size_t n_tabs_allocated = 0;\n\n \nstatic size_t first_free_tab = 0;\n\n \nstatic char **file_list = nullptr;\n\n \nstatic char *stdin_argv[] =\n{\n  (char *) \"-\", nullptr\n};\n\n \nstatic bool have_read_stdin = false;\n\n \nint exit_status = EXIT_SUCCESS;\n\n\n\n \nextern void\nadd_tab_stop (uintmax_t tabval)\n{\n  uintmax_t prev_column = first_free_tab ? tab_list[first_free_tab - 1] : 0;\n  uintmax_t column_width = prev_column <= tabval ? tabval - prev_column : 0;\n\n  if (first_free_tab == n_tabs_allocated)\n    tab_list = X2NREALLOC (tab_list, &n_tabs_allocated);\n  tab_list[first_free_tab++] = tabval;\n\n  if (max_column_width < column_width)\n    {\n      if (SIZE_MAX < column_width)\n        error (EXIT_FAILURE, 0, _(\"tabs are too far apart\"));\n      max_column_width = column_width;\n    }\n}\n\nstatic bool\nset_extend_size (uintmax_t tabval)\n{\n  bool ok = true;\n\n  if (extend_size)\n    {\n      error (0, 0,\n             _(\"'/' specifier only allowed\"\n               \" with the last value\"));\n      ok = false;\n    }\n  extend_size = tabval;\n\n  return ok;\n}\n\nstatic bool\nset_increment_size (uintmax_t tabval)\n{\n  bool ok = true;\n\n  if (increment_size)\n    {\n      error (0,0,\n             _(\"'+' specifier only allowed\"\n               \" with the last value\"));\n      ok = false;\n    }\n  increment_size = tabval;\n\n  return ok;\n}\n\n \nextern void\nparse_tab_stops (char const *stops)\n{\n  bool have_tabval = false;\n  uintmax_t tabval = 0;\n  bool extend_tabval = false;\n  bool increment_tabval = false;\n  char const *num_start = nullptr;\n  bool ok = true;\n\n  for (; *stops; stops++)\n    {\n      if (*stops == ',' || isblank (to_uchar (*stops)))\n        {\n          if (have_tabval)\n            {\n              if (extend_tabval)\n                {\n                  if (! set_extend_size (tabval))\n                    {\n                      ok = false;\n                      break;\n                    }\n                }\n              else if (increment_tabval)\n                {\n                  if (! set_increment_size (tabval))\n                    {\n                      ok = false;\n                      break;\n                    }\n                }\n              else\n                add_tab_stop (tabval);\n            }\n          have_tabval = false;\n        }\n      else if (*stops == '/')\n        {\n          if (have_tabval)\n            {\n              error (0, 0, _(\"'/' specifier not at start of number: %s\"),\n                     quote (stops));\n              ok = false;\n            }\n          extend_tabval = true;\n          increment_tabval = false;\n        }\n      else if (*stops == '+')\n        {\n          if (have_tabval)\n            {\n              error (0, 0, _(\"'+' specifier not at start of number: %s\"),\n                     quote (stops));\n              ok = false;\n            }\n          increment_tabval = true;\n          extend_tabval = false;\n        }\n      else if (ISDIGIT (*stops))\n        {\n          if (!have_tabval)\n            {\n              tabval = 0;\n              have_tabval = true;\n              num_start = stops;\n            }\n\n           \n          if (!DECIMAL_DIGIT_ACCUMULATE (tabval, *stops - '0', uintmax_t))\n            {\n              size_t len = strspn (num_start, \"0123456789\");\n              char *bad_num = ximemdup0 (num_start, len);\n              error (0, 0, _(\"tab stop is too large %s\"), quote (bad_num));\n              free (bad_num);\n              ok = false;\n              stops = num_start + len - 1;\n            }\n        }\n      else\n        {\n          error (0, 0, _(\"tab size contains invalid character(s): %s\"),\n                 quote (stops));\n          ok = false;\n          break;\n        }\n    }\n\n  if (ok && have_tabval)\n    {\n      if (extend_tabval)\n        ok &= set_extend_size (tabval);\n      else if (increment_tabval)\n        ok &= set_increment_size (tabval);\n      else\n        add_tab_stop (tabval);\n    }\n\n  if (! ok)\n    exit (EXIT_FAILURE);\n}\n\n \n\nstatic void\nvalidate_tab_stops (uintmax_t const *tabs, size_t entries)\n{\n  uintmax_t prev_tab = 0;\n\n  for (size_t i = 0; i < entries; i++)\n    {\n      if (tabs[i] == 0)\n        error (EXIT_FAILURE, 0, _(\"tab size cannot be 0\"));\n      if (tabs[i] <= prev_tab)\n        error (EXIT_FAILURE, 0, _(\"tab sizes must be ascending\"));\n      prev_tab = tabs[i];\n    }\n\n  if (increment_size && extend_size)\n    error (EXIT_FAILURE, 0, _(\"'/' specifier is mutually exclusive with '+'\"));\n}\n\n \nextern void\nfinalize_tab_stops (void)\n{\n  validate_tab_stops (tab_list, first_free_tab);\n\n  if (first_free_tab == 0)\n    tab_size = max_column_width = extend_size\n                                  ? extend_size : increment_size\n                                                  ? increment_size : 8;\n  else if (first_free_tab == 1 && ! extend_size && ! increment_size)\n    tab_size = tab_list[0];\n  else\n    tab_size = 0;\n}\n\n\nextern uintmax_t\nget_next_tab_column (const uintmax_t column, size_t *tab_index,\n                     bool *last_tab)\n{\n  *last_tab = false;\n\n   \n  if (tab_size)\n    return column + (tab_size - column % tab_size);\n\n   \n  for ( ; *tab_index < first_free_tab ; (*tab_index)++ )\n    {\n        uintmax_t tab = tab_list[*tab_index];\n        if (column < tab)\n            return tab;\n    }\n\n   \n  if (extend_size)\n    return column + (extend_size - column % extend_size);\n\n   \n  if (increment_size)\n    {\n      uintmax_t end_tab = tab_list[first_free_tab - 1];\n\n      return column + (increment_size - ((column - end_tab) % increment_size));\n    }\n\n  *last_tab = true;\n  return 0;\n}\n\n\n\n\n \nextern void\nset_file_list (char **list)\n{\n  have_read_stdin = false;\n\n  if (!list)\n    file_list = stdin_argv;\n  else\n    file_list = list;\n}\n\n \n\nextern FILE *\nnext_file (FILE *fp)\n{\n  static char *prev_file;\n  char *file;\n\n  if (fp)\n    {\n      int err = errno;\n      if (!ferror (fp))\n        err = 0;\n      if (STREQ (prev_file, \"-\"))\n        clearerr (fp);\t\t \n      else if (fclose (fp) != 0)\n        err = errno;\n      if (err)\n        {\n          error (0, err, \"%s\", quotef (prev_file));\n          exit_status = EXIT_FAILURE;\n        }\n    }\n\n  while ((file = *file_list++) != nullptr)\n    {\n      if (STREQ (file, \"-\"))\n        {\n          have_read_stdin = true;\n          fp = stdin;\n        }\n      else\n        fp = fopen (file, \"r\");\n      if (fp)\n        {\n          prev_file = file;\n          fadvise (fp, FADVISE_SEQUENTIAL);\n          return fp;\n        }\n      error (0, errno, \"%s\", quotef (file));\n      exit_status = EXIT_FAILURE;\n    }\n  return nullptr;\n}\n\n \nextern void\ncleanup_file_list_stdin (void)\n{\n    if (have_read_stdin && fclose (stdin) != 0)\n      error (EXIT_FAILURE, errno, \"-\");\n}\n\n\nextern void\nemit_tab_list_info (void)\n{\n   \n  fputs (_(\"\\\n  -t, --tabs=LIST  use comma separated list of tab positions.\\n\\\n\"), stdout);\n  fputs (_(\"\\\n                     The last specified position can be prefixed with '/'\\n\\\n                     to specify a tab size to use after the last\\n\\\n                     explicitly specified tab stop.  Also a prefix of '+'\\n\\\n                     can be used to align remaining tab stops relative to\\n\\\n                     the last specified tab stop instead of the first column\\n\\\n\"), stdout);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}