{
  "module_name": "date.c",
  "hash_id": "22009929d068feb1ddb14cc04283befed74f2ed9050ebeea10c9bb9d1343e134",
  "original_prompt": "Ingested from coreutils-9.4/src/date.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#if HAVE_LANGINFO_CODESET\n# include <langinfo.h>\n#endif\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"parse-datetime.h\"\n#include \"posixtm.h\"\n#include \"quote.h\"\n#include \"stat-time.h\"\n#include \"fprintftime.h\"\n\n \n#define PROGRAM_NAME \"date\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic bool show_date (char const *, struct timespec, timezone_t);\n\nenum Time_spec\n{\n   \n  TIME_SPEC_DATE,\n   \n  TIME_SPEC_SECONDS,\n   \n  TIME_SPEC_NS,\n\n   \n\n   \n  TIME_SPEC_HOURS,\n   \n  TIME_SPEC_MINUTES\n};\n\nstatic char const *const time_spec_string[] =\n{\n   \n  \"hours\", \"minutes\",\n  \"date\", \"seconds\", \"ns\", nullptr\n};\nstatic enum Time_spec const time_spec[] =\n{\n  TIME_SPEC_HOURS, TIME_SPEC_MINUTES,\n  TIME_SPEC_DATE, TIME_SPEC_SECONDS, TIME_SPEC_NS\n};\nARGMATCH_VERIFY (time_spec_string, time_spec);\n\n \nstatic char const rfc_email_format[] = \"%a, %d %b %Y %H:%M:%S %z\";\n\n \nenum\n{\n  DEBUG_DATE_PARSING_OPTION = CHAR_MAX + 1,\n  RESOLUTION_OPTION,\n  RFC_3339_OPTION\n};\n\nstatic char const short_options[] = \"d:f:I::r:Rs:u\";\n\nstatic struct option const long_options[] =\n{\n  {\"date\", required_argument, nullptr, 'd'},\n  {\"debug\", no_argument, nullptr, DEBUG_DATE_PARSING_OPTION},\n  {\"file\", required_argument, nullptr, 'f'},\n  {\"iso-8601\", optional_argument, nullptr, 'I'},\n  {\"reference\", required_argument, nullptr, 'r'},\n  {\"resolution\", no_argument, nullptr, RESOLUTION_OPTION},\n  {\"rfc-email\", no_argument, nullptr, 'R'},\n  {\"rfc-822\", no_argument, nullptr, 'R'},\n  {\"rfc-2822\", no_argument, nullptr, 'R'},\n  {\"rfc-3339\", required_argument, nullptr, RFC_3339_OPTION},\n  {\"set\", required_argument, nullptr, 's'},\n  {\"uct\", no_argument, nullptr, 'u'},\n  {\"utc\", no_argument, nullptr, 'u'},\n  {\"universal\", no_argument, nullptr, 'u'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic unsigned int parse_datetime_flags;\n\n#if LOCALTIME_CACHE\n# define TZSET tzset ()\n#else\n# define TZSET  \n#endif\n\n#ifdef _DATE_FMT\n# define DATE_FMT_LANGINFO() nl_langinfo (_DATE_FMT)\n#else\n# define DATE_FMT_LANGINFO() \"\"\n#endif\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [+FORMAT]\\n\\\n  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nDisplay date and time in the given FORMAT.\\n\\\nWith -s, or with [MMDDhhmm[[CC]YY][.ss]], set the date and time.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -d, --date=STRING          display time described by STRING, not 'now'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --debug                annotate the parsed date,\\n\\\n                              and warn about questionable usage to stderr\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\\n\\\n                               FMT='date' for date only (the default),\\n\\\n                               'hours', 'minutes', 'seconds', or 'ns'\\n\\\n                               for date and time to the indicated precision.\\n\\\n                               Example: 2006-08-14T02:34:56-06:00\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  --resolution               output the available resolution of timestamps\\n\\\n                               Example: 0.000000001\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -R, --rfc-email            output date and time in RFC 5322 format.\\n\\\n                               Example: Mon, 14 Aug 2006 02:34:56 -0600\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --rfc-3339=FMT         output date/time in RFC 3339 format.\\n\\\n                               FMT='date', 'seconds', or 'ns'\\n\\\n                               for date and time to the indicated precision.\\n\\\n                               Example: 2006-08-14 02:34:56-06:00\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -r, --reference=FILE       display the last modification time of FILE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -s, --set=STRING           set time described by STRING\\n\\\n  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nAll options that specify the date to display are mutually exclusive.\\n\\\nI.e.: --date, --file, --reference, --resolution.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nFORMAT controls the output.  Interpreted sequences are:\\n\\\n\\n\\\n  %%   a literal %\\n\\\n  %a   locale's abbreviated weekday name (e.g., Sun)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %A   locale's full weekday name (e.g., Sunday)\\n\\\n  %b   locale's abbreviated month name (e.g., Jan)\\n\\\n  %B   locale's full month name (e.g., January)\\n\\\n  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %C   century; like %Y, except omit last two digits (e.g., 20)\\n\\\n  %d   day of month (e.g., 01)\\n\\\n  %D   date; same as %m/%d/%y\\n\\\n  %e   day of month, space padded; same as %_d\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %F   full date; like %+4Y-%m-%d\\n\\\n  %g   last two digits of year of ISO week number (see %G)\\n\\\n  %G   year of ISO week number (see %V); normally useful only with %V\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %h   same as %b\\n\\\n  %H   hour (00..23)\\n\\\n  %I   hour (01..12)\\n\\\n  %j   day of year (001..366)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %k   hour, space padded ( 0..23); same as %_H\\n\\\n  %l   hour, space padded ( 1..12); same as %_I\\n\\\n  %m   month (01..12)\\n\\\n  %M   minute (00..59)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %n   a newline\\n\\\n  %N   nanoseconds (000000000..999999999)\\n\\\n  %p   locale's equivalent of either AM or PM; blank if not known\\n\\\n  %P   like %p, but lower case\\n\\\n  %q   quarter of year (1..4)\\n\\\n  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\\n\\\n  %R   24-hour hour and minute; same as %H:%M\\n\\\n  %s   seconds since the Epoch (1970-01-01 00:00 UTC)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %S   second (00..60)\\n\\\n  %t   a tab\\n\\\n  %T   time; same as %H:%M:%S\\n\\\n  %u   day of week (1..7); 1 is Monday\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %U   week number of year, with Sunday as first day of week (00..53)\\n\\\n  %V   ISO week number, with Monday as first day of week (01..53)\\n\\\n  %w   day of week (0..6); 0 is Sunday\\n\\\n  %W   week number of year, with Monday as first day of week (00..53)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %x   locale's date representation (e.g., 12/31/99)\\n\\\n  %X   locale's time representation (e.g., 23:13:48)\\n\\\n  %y   last two digits of year (00..99)\\n\\\n  %Y   year\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %z   +hhmm numeric time zone (e.g., -0400)\\n\\\n  %:z  +hh:mm numeric time zone (e.g., -04:00)\\n\\\n  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\\n\\\n  %:::z  numeric time zone with : to necessary precision (e.g., -04, +05:30)\\n\\\n  %Z   alphabetic time zone abbreviation (e.g., EDT)\\n\\\n\\n\\\nBy default, date pads numeric fields with zeroes.\\n\\\n\"), stdout);\n      fputs (_(\"\\\nThe following optional flags may follow '%':\\n\\\n\\n\\\n  -  (hyphen) do not pad the field\\n\\\n  _  (underscore) pad with spaces\\n\\\n  0  (zero) pad with zeros\\n\\\n  +  pad with zeros, and put '+' before future years with >4 digits\\n\\\n  ^  use upper case if possible\\n\\\n  #  use opposite case if possible\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nAfter any flags comes an optional field width, as a decimal number;\\n\\\nthen an optional modifier, which is either\\n\\\nE to use the locale's alternate representations if available, or\\n\\\nO to use the locale's alternate numeric symbols if available.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nExamples:\\n\\\nConvert seconds since the Epoch (1970-01-01 UTC) to a date\\n\\\n  $ date --date='@2147483647'\\n\\\n\\n\\\nShow the time on the west coast of the US (use tzselect(1) to find TZ)\\n\\\n  $ TZ='America/Los_Angeles' date\\n\\\n\\n\\\nShow the local time for 9AM next Friday on the west coast of the US\\n\\\n  $ date --date='TZ=\\\"America/Los_Angeles\\\" 09:00 next Fri'\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Yield the number of decimal digits needed to output a time with the\n   nanosecond resolution RES, without losing information.  */\n\nstatic int\nres_width (long int res)\n{\n  int i = 9;\n  for (long long int r = 1; (r *= 10) <= res; )\n    i--;\n  return i;\n}\n\n/* Return a newly allocated copy of FORMAT with each \"%-N\" adjusted to\n   be \"%9N\", \"%6N\", or whatever other resolution is appropriate for\n   the current platform.  If no \"%-N\" appears, return nullptr.  */\n\nstatic char *\nadjust_resolution (char const *format)\n{\n  char *copy = nullptr;\n\n  for (char const *f = format; *f; f++)\n    if (f[0] == '%')\n      {\n        if (f[1] == '-' && f[2] == 'N')\n          {\n            if (!copy)\n              copy = xstrdup (format);\n            copy[f + 1 - format] = '0' + res_width (gettime_res ());\n            f += 2;\n          }\n        else\n          f += f[1] == '%';\n      }\n\n  return copy;\n}\n\n/* Parse each line in INPUT_FILENAME as with --date and display each\n   resulting time and date.  If the file cannot be opened, tell why\n   then exit.  Issue a diagnostic for any lines that cannot be parsed.\n   Return true if successful.  */\n\nstatic bool\nbatch_convert (char const *input_filename, char const *format,\n               timezone_t tz, char const *tzstring)\n{\n  bool ok;\n  FILE *in_stream;\n  char *line;\n  size_t buflen;\n  struct timespec when;\n\n  if (STREQ (input_filename, \"-\"))\n    {\n      input_filename = _(\"standard input\");\n      in_stream = stdin;\n    }\n  else\n    {\n      in_stream = fopen (input_filename, \"r\");\n      if (in_stream == nullptr)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (input_filename));\n    }\n\n  line = nullptr;\n  buflen = 0;\n  ok = true;\n  while (true)\n    {\n      ssize_t line_length = getline (&line, &buflen, in_stream);\n      if (line_length < 0)\n        {\n          if (ferror (in_stream))\n            error (EXIT_FAILURE, errno, _(\"%s: read error\"),\n                   quotef (input_filename));\n          break;\n        }\n\n      if (! parse_datetime2 (&when, line, nullptr,\n                             parse_datetime_flags, tz, tzstring))\n        {\n          if (line[line_length - 1] == '\\n')\n            line[line_length - 1] = '\\0';\n          error (0, 0, _(\"invalid date %s\"), quote (line));\n          ok = false;\n        }\n      else\n        {\n          ok &= show_date (format, when, tz);\n        }\n    }\n\n  if (fclose (in_stream) == EOF)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (input_filename));\n\n  free (line);\n\n  return ok;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  char const *datestr = nullptr;\n  char const *set_datestr = nullptr;\n  struct timespec when;\n  bool set_date = false;\n  char const *format = nullptr;\n  bool get_resolution = false;\n  char *batch_file = nullptr;\n  char *reference = nullptr;\n  struct stat refstats;\n  bool ok;\n  bool discarded_datestr = false;\n  bool discarded_set_datestr = false;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, short_options, long_options, nullptr))\n         != -1)\n    {\n      char const *new_format = nullptr;\n\n      switch (optc)\n        {\n        case 'd':\n          if (datestr)\n            discarded_datestr = true;\n          datestr = optarg;\n          break;\n        case DEBUG_DATE_PARSING_OPTION:\n          parse_datetime_flags |= PARSE_DATETIME_DEBUG;\n          break;\n        case 'f':\n          batch_file = optarg;\n          break;\n        case RESOLUTION_OPTION:\n          get_resolution = true;\n          break;\n        case RFC_3339_OPTION:\n          {\n            static char const rfc_3339_format[][32] =\n              {\n                \"%Y-%m-%d\",\n                \"%Y-%m-%d %H:%M:%S%:z\",\n                \"%Y-%m-%d %H:%M:%S.%N%:z\"\n              };\n            enum Time_spec i =\n              XARGMATCH (\"--rfc-3339\", optarg,\n                         time_spec_string + 2, time_spec + 2);\n            new_format = rfc_3339_format[i];\n            break;\n          }\n        case 'I':\n          {\n            static char const iso_8601_format[][32] =\n              {\n                \"%Y-%m-%d\",\n                \"%Y-%m-%dT%H:%M:%S%:z\",\n                \"%Y-%m-%dT%H:%M:%S,%N%:z\",\n                \"%Y-%m-%dT%H%:z\",\n                \"%Y-%m-%dT%H:%M%:z\"\n              };\n            enum Time_spec i =\n              (optarg\n               ? XARGMATCH (\"--iso-8601\", optarg, time_spec_string, time_spec)\n               : TIME_SPEC_DATE);\n            new_format = iso_8601_format[i];\n            break;\n          }\n        case 'r':\n          reference = optarg;\n          break;\n        case 'R':\n          new_format = rfc_email_format;\n          break;\n        case 's':\n          if (set_datestr)\n            discarded_set_datestr = true;\n          set_datestr = optarg;\n          set_date = true;\n          break;\n        case 'u':\n          /* POSIX says that 'date -u' is equivalent to setting the TZ\n             environment variable, so this option should do nothing other\n             than setting TZ.  */\n          if (putenv (bad_cast (\"TZ=UTC0\")) != 0)\n            xalloc_die ();\n          TZSET;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n\n      if (new_format)\n        {\n          if (format)\n            error (EXIT_FAILURE, 0, _(\"multiple output formats specified\"));\n          format = new_format;\n        }\n    }\n\n  int option_specified_date = (!!datestr + !!batch_file + !!reference\n                               + get_resolution);\n\n  if (option_specified_date > 1)\n    {\n      error (0, 0,\n        _(\"the options to specify dates for printing are mutually exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (set_date && option_specified_date)\n    {\n      error (0, 0,\n          _(\"the options to print and set the time may not be used together\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (discarded_datestr && (parse_datetime_flags & PARSE_DATETIME_DEBUG))\n    error (0, 0, _(\"only using last of multiple -d options\"));\n\n  if (discarded_set_datestr && (parse_datetime_flags & PARSE_DATETIME_DEBUG))\n    error (0, 0, _(\"only using last of multiple -s options\"));\n\n  if (optind < argc)\n    {\n      if (optind + 1 < argc)\n        {\n          error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 1]));\n          usage (EXIT_FAILURE);\n        }\n\n      if (argv[optind][0] == '+')\n        {\n          if (format)\n            error (EXIT_FAILURE, 0, _(\"multiple output formats specified\"));\n          format = argv[optind++] + 1;\n        }\n      else if (set_date || option_specified_date)\n        {\n          error (0, 0,\n                 _(\"the argument %s lacks a leading '+';\\n\"\n                   \"when using an option to specify date(s), any non-option\\n\"\n                   \"argument must be a format string beginning with '+'\"),\n                 quote (argv[optind]));\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (!format)\n    {\n      if (get_resolution)\n        format = \"%s.%N\";\n      else\n        {\n          format = DATE_FMT_LANGINFO ();\n\n          /* Do not wrap the following literal format string with _(...).\n             For example, suppose LC_ALL is unset, LC_TIME=POSIX,\n             and LANG=\"ko_KR\".  In that case, POSIX says that LC_TIME\n             determines the format and contents of date and time strings\n             written by date, which means \"date\" must generate output\n             using the POSIX locale; but adding _() would cause \"date\"\n             to use a Korean translation of the format.  */\n          if (! *format)\n            format = \"%a %b %e %H:%M:%S %Z %Y\";\n        }\n    }\n\n  char *format_copy = adjust_resolution (format);\n  char const *format_res = format_copy ? format_copy : format;\n  char const *tzstring = getenv (\"TZ\");\n  timezone_t tz = tzalloc (tzstring);\n\n  if (batch_file != nullptr)\n    ok = batch_convert (batch_file, format_res, tz, tzstring);\n  else\n    {\n      bool valid_date = true;\n      ok = true;\n\n      if (!option_specified_date && !set_date)\n        {\n          if (optind < argc)\n            {\n              /* Prepare to set system clock to the specified date/time\n                 given in the POSIX-format.  */\n              set_date = true;\n              datestr = argv[optind];\n              valid_date = posixtime (&when.tv_sec,\n                                      datestr,\n                                      (PDS_TRAILING_YEAR\n                                       | PDS_CENTURY | PDS_SECONDS));\n              when.tv_nsec = 0; /* FIXME: posixtime should set this.  */\n            }\n          else\n            {\n              /* Prepare to print the current date/time.  */\n              gettime (&when);\n            }\n        }\n      else\n        {\n          /* (option_specified_date || set_date) */\n          if (reference != nullptr)\n            {\n              if (stat (reference, &refstats) != 0)\n                error (EXIT_FAILURE, errno, \"%s\", quotef (reference));\n              when = get_stat_mtime (&refstats);\n            }\n          else if (get_resolution)\n            {\n              long int res = gettime_res ();\n              when.tv_sec = res / TIMESPEC_HZ;\n              when.tv_nsec = res % TIMESPEC_HZ;\n            }\n          else\n            {\n              if (set_datestr)\n                datestr = set_datestr;\n              valid_date = parse_datetime2 (&when, datestr, nullptr,\n                                            parse_datetime_flags,\n                                            tz, tzstring);\n            }\n        }\n\n      if (! valid_date)\n        error (EXIT_FAILURE, 0, _(\"invalid date %s\"), quote (datestr));\n\n      if (set_date)\n        {\n          /* Set the system clock to the specified date, then regardless of\n             the success of that operation, format and print that date.  */\n          if (settime (&when) != 0)\n            {\n              error (0, errno, _(\"cannot set date\"));\n              ok = false;\n            }\n        }\n\n      ok &= show_date (format_res, when, tz);\n    }\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n\n/* Display the date and/or time in WHEN according to the format specified\n   in FORMAT, followed by a newline.  Return true if successful.  */\n\nstatic bool\nshow_date (char const *format, struct timespec when, timezone_t tz)\n{\n  struct tm tm;\n\n  if (parse_datetime_flags & PARSE_DATETIME_DEBUG)\n    error (0, 0, _(\"output format: %s\"), quote (format));\n\n  if (localtime_rz (tz, &when.tv_sec, &tm))\n    {\n      if (format == rfc_email_format)\n        setlocale (LC_TIME, \"C\");\n      fprintftime (stdout, format, &tm, tz, when.tv_nsec);\n      if (format == rfc_email_format)\n        setlocale (LC_TIME, \"\");\n      fputc ('\\n', stdout);\n      return true;\n    }\n  else\n    {\n      char buf[INT_BUFSIZE_BOUND (intmax_t)];\n      error (0, 0, _(\"time %s is out of range\"),\n             quote (timetostr (when.tv_sec, buf)));\n      return false;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}