{
  "module_name": "tsort.c",
  "hash_id": "648f539926a05a6cb36f6a23225f851947f910311bd22b9afd94249ed716f3e8",
  "original_prompt": "Ingested from coreutils-9.4/src/tsort.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"long-options.h\"\n#include \"fadvise.h\"\n#include \"readtokens.h\"\n#include \"stdio--.h\"\n#include \"quote.h\"\n\n \n#define PROGRAM_NAME \"tsort\"\n\n#define AUTHORS proper_name (\"Mark Kettenis\")\n\n \n#define DELIM \" \\t\\n\"\n\n \nstruct successor\n{\n  struct item *suc;\n  struct successor *next;\n};\n\n \nstruct item\n{\n  char const *str;\n  struct item *left, *right;\n  signed char balance;  \n  bool printed;\n  size_t count;\n  struct item *qlink;\n  struct successor *top;\n};\n\n \nstatic struct item *head = nullptr;\n\n \nstatic struct item *zeros = nullptr;\n\n \nstatic struct item *loop = nullptr;\n\n \nstatic size_t n_strings = 0;\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION] [FILE]\\n\\\nWrite totally ordered list consistent with the partial ordering in FILE.\\n\\\n\"), program_name);\n\n      emit_stdin_note ();\n\n      fputs (_(\"\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\n/* Create a new item/node for STR.  */\nstatic struct item *\nnew_item (char const *str)\n{\n  /* T1. Initialize (COUNT[k] <- 0 and TOP[k] <- ^).  */\n  struct item *k = xzalloc (sizeof *k);\n  if (str)\n    k->str = xstrdup (str);\n  return k;\n}\n\n/* Search binary tree rooted at *ROOT for STR.  Allocate a new tree if\n   *ROOT is null.  Insert a node/item for STR if not found.  Return\n   the node/item found/created for STR.\n\n   This is done according to Algorithm A (Balanced tree search and\n   insertion) in Donald E. Knuth, The Art of Computer Programming,\n   Volume 3/Searching and Sorting, pages 455--457.  */\n\nstatic struct item *\nsearch_item (struct item *root, char const *str)\n{\n  struct item *p, *q, *r, *s, *t;\n  int a;\n\n  /* Make sure the tree is not empty, since that is what the algorithm\n     below expects.  */\n  if (root->right == nullptr)\n    return (root->right = new_item (str));\n\n  /* A1. Initialize.  */\n  t = root;\n  s = p = root->right;\n\n  while (true)\n    {\n      /* A2. Compare.  */\n      a = strcmp (str, p->str);\n      if (a == 0)\n        return p;\n\n      /* A3 & A4.  Move left & right.  */\n      if (a < 0)\n        q = p->left;\n      else\n        q = p->right;\n\n      if (q == nullptr)\n        {\n          /* A5. Insert.  */\n          q = new_item (str);\n\n          /* A3 & A4.  (continued).  */\n          if (a < 0)\n            p->left = q;\n          else\n            p->right = q;\n\n          /* A6. Adjust balance factors.  */\n          a = strcmp (str, s->str);\n          if (a < 0)\n            {\n              r = p = s->left;\n              a = -1;\n            }\n          else\n            {\n              affirm (0 < a);\n              r = p = s->right;\n              a = 1;\n            }\n\n          while (p != q)\n            {\n              int cmp = strcmp (str, p->str);\n              if (cmp < 0)\n                {\n                  p->balance = -1;\n                  p = p->left;\n                }\n              else\n                {\n                  affirm (0 < cmp);\n                  p->balance = 1;\n                  p = p->right;\n                }\n            }\n\n          /* A7. Balancing act.  */\n          if (s->balance == 0 || s->balance == -a)\n            {\n              s->balance += a;\n              return q;\n            }\n\n          if (r->balance == a)\n            {\n              /* A8. Single Rotation.  */\n              p = r;\n              if (a < 0)\n                {\n                  s->left = r->right;\n                  r->right = s;\n                }\n              else\n                {\n                  s->right = r->left;\n                  r->left = s;\n                }\n              s->balance = r->balance = 0;\n            }\n          else\n            {\n              /* A9. Double rotation.  */\n              if (a < 0)\n                {\n                  p = r->right;\n                  r->right = p->left;\n                  p->left = r;\n                  s->left = p->right;\n                  p->right = s;\n                }\n              else\n                {\n                  p = r->left;\n                  r->left = p->right;\n                  p->right = r;\n                  s->right = p->left;\n                  p->left = s;\n                }\n\n              s->balance = 0;\n              r->balance = 0;\n              if (p->balance == a)\n                s->balance = -a;\n              else if (p->balance == -a)\n                r->balance = a;\n              p->balance = 0;\n            }\n\n          /* A10. Finishing touch.  */\n          if (s == t->right)\n            t->right = p;\n          else\n            t->left = p;\n\n          return q;\n        }\n\n      /* A3 & A4.  (continued).  */\n      if (q->balance)\n        {\n          t = p;\n          s = q;\n        }\n\n      p = q;\n    }\n\n  /* NOTREACHED */\n}\n\n/* Record the fact that J precedes K.  */\n\nstatic void\nrecord_relation (struct item *j, struct item *k)\n{\n  struct successor *p;\n\n  if (!STREQ (j->str, k->str))\n    {\n      k->count++;\n      p = xmalloc (sizeof *p);\n      p->suc = k;\n      p->next = j->top;\n      j->top = p;\n    }\n}\n\nstatic bool\ncount_items (MAYBE_UNUSED struct item *unused)\n{\n  n_strings++;\n  return false;\n}\n\nstatic bool\nscan_zeros (struct item *k)\n{\n  /* Ignore strings that have already been printed.  */\n  if (k->count == 0 && !k->printed)\n    {\n      if (head == nullptr)\n        head = k;\n      else\n        zeros->qlink = k;\n\n      zeros = k;\n    }\n\n  return false;\n}\n\n/* Try to detect the loop.  If we have detected that K is part of a\n   loop, print the loop on standard error, remove a relation to break\n   the loop, and return true.\n\n   The loop detection strategy is as follows: Realize that what we're\n   dealing with is essentially a directed graph.  If we find an item\n   that is part of a graph that contains a cycle we traverse the graph\n   in backwards direction.  In general there is no unique way to do\n   this, but that is no problem.  If we encounter an item that we have\n   encountered before, we know that we've found a cycle.  All we have\n   to do now is retrace our steps, printing out the items until we\n   encounter that item again.  (This is not necessarily the item that\n   we started from originally.)  Since the order in which the items\n   are stored in the tree is not related to the specified partial\n   ordering, we may need to walk the tree several times before the\n   loop has completely been constructed.  If the loop was found, the\n   global variable LOOP will be null.  */\n\nstatic bool\ndetect_loop (struct item *k)\n{\n  if (k->count > 0)\n    {\n      /* K does not have to be part of a cycle.  It is however part of\n         a graph that contains a cycle.  */\n\n      if (loop == nullptr)\n        /* Start traversing the graph at K.  */\n        loop = k;\n      else\n        {\n          struct successor **p = &k->top;\n\n          while (*p)\n            {\n              if ((*p)->suc == loop)\n                {\n                  if (k->qlink)\n                    {\n                      /* We have found a loop.  Retrace our steps.  */\n                      while (loop)\n                        {\n                          struct item *tmp = loop->qlink;\n\n                          error (0, 0, \"%s\", (loop->str));\n\n                          /* Until we encounter K again.  */\n                          if (loop == k)\n                            {\n                              /* Remove relation.  */\n                              struct successor *s = *p;\n                              s->suc->count--;\n                              *p = s->next;\n                              IF_LINT (free (s));\n                              break;\n                            }\n\n                          /* Tidy things up since we might have to\n                             detect another loop.  */\n                          loop->qlink = nullptr;\n                          loop = tmp;\n                        }\n\n                      while (loop)\n                        {\n                          struct item *tmp = loop->qlink;\n\n                          loop->qlink = nullptr;\n                          loop = tmp;\n                        }\n\n                      /* Since we have found the loop, stop walking\n                         the tree.  */\n                      return true;\n                    }\n                  else\n                    {\n                      k->qlink = loop;\n                      loop = k;\n                      break;\n                    }\n                }\n\n              p = &(*p)->next;\n            }\n        }\n    }\n\n  return false;\n}\n\n/* Recurse (sub)tree rooted at ROOT, calling ACTION for each node.\n   Stop when ACTION returns true.  */\n\nstatic bool\nrecurse_tree (struct item *root, bool (*action) (struct item *))\n{\n  if (root->left == nullptr && root->right == nullptr)\n    return (*action) (root);\n  else\n    {\n      if (root->left != nullptr)\n        if (recurse_tree (root->left, action))\n          return true;\n      if ((*action) (root))\n        return true;\n      if (root->right != nullptr)\n        if (recurse_tree (root->right, action))\n          return true;\n    }\n\n  return false;\n}\n\n/* Walk the tree specified by the head ROOT, calling ACTION for\n   each node.  */\n\nstatic void\nwalk_tree (struct item *root, bool (*action) (struct item *))\n{\n  if (root->right)\n    recurse_tree (root->right, action);\n}\n\n/* Do a topological sort on FILE.  Exit with appropriate exit status.  */\n\nstatic _Noreturn void\ntsort (char const *file)\n{\n  bool ok = true;\n  struct item *j = nullptr;\n  struct item *k = nullptr;\n  token_buffer tokenbuffer;\n  bool is_stdin = STREQ (file, \"-\");\n\n  /* Initialize the head of the tree holding the strings we're sorting.  */\n  struct item *root = new_item (nullptr);\n\n  if (!is_stdin && ! freopen (file, \"r\", stdin))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (file));\n\n  fadvise (stdin, FADVISE_SEQUENTIAL);\n\n  init_tokenbuffer (&tokenbuffer);\n\n  while (true)\n    {\n      /* T2. Next Relation.  */\n      size_t len = readtoken (stdin, DELIM, sizeof (DELIM) - 1, &tokenbuffer);\n      if (len == (size_t) -1)\n        {\n          if (ferror (stdin))\n            error (EXIT_FAILURE, errno, _(\"%s: read error\"), quotef (file));\n          break;\n        }\n\n      affirm (len != 0);\n\n      k = search_item (root, tokenbuffer.buffer);\n      if (j)\n        {\n          /* T3. Record the relation.  */\n          record_relation (j, k);\n          k = nullptr;\n        }\n\n      j = k;\n    }\n\n  if (k != nullptr)\n    error (EXIT_FAILURE, 0, _(\"%s: input contains an odd number of tokens\"),\n           quotef (file));\n\n  /* T1. Initialize (N <- n).  */\n  walk_tree (root, count_items);\n\n  while (n_strings > 0)\n    {\n      /* T4. Scan for zeros.  */\n      walk_tree (root, scan_zeros);\n\n      while (head)\n        {\n          struct successor *p = head->top;\n\n          /* T5. Output front of queue.  */\n          puts (head->str);\n          head->printed = true;\n          n_strings--;\n\n          /* T6. Erase relations.  */\n          while (p)\n            {\n              p->suc->count--;\n              if (p->suc->count == 0)\n                {\n                  zeros->qlink = p->suc;\n                  zeros = p->suc;\n                }\n\n              p = p->next;\n            }\n\n          /* T7. Remove from queue.  */\n          head = head->qlink;\n        }\n\n      /* T8.  End of process.  */\n      if (n_strings > 0)\n        {\n          /* The input contains a loop.  */\n          error (0, 0, _(\"%s: input contains a loop:\"), quotef (file));\n          ok = false;\n\n          /* Print the loop and remove a relation to break it.  */\n          do\n            walk_tree (root, detect_loop);\n          while (loop);\n        }\n    }\n\n  if (fclose (stdin) != 0)\n    error (EXIT_FAILURE, errno, \"%s\",\n           is_stdin ? _(\"standard input\") : quotef (file));\n\n  exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n\nint\nmain (int argc, char **argv)\n{\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n                                   Version, true, usage, AUTHORS,\n                                   (char const *) nullptr);\n\n  if (1 < argc - optind)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  tsort (optind == argc ? \"-\" : argv[optind]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}