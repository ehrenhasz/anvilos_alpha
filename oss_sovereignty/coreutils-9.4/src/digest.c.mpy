{
  "module_name": "digest.c",
  "hash_id": "75e4e059fb470528e7cfadb26d50fd06ab8ad3e98010203e467fa6a3f354ecde",
  "original_prompt": "Ingested from coreutils-9.4/src/digest.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"quote.h\"\n#include \"xdectoint.h\"\n#include \"xstrtol.h\"\n\n#if HASH_ALGO_SUM || HASH_ALGO_CKSUM\n# include \"sum.h\"\n#endif\n#if HASH_ALGO_CKSUM\n# include \"cksum.h\"\n# include \"base64.h\"\n#endif\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n# include \"blake2/b2sum.h\"\n#endif\n#if HASH_ALGO_MD5 || HASH_ALGO_CKSUM\n# include \"md5.h\"\n#endif\n#if HASH_ALGO_SHA1 || HASH_ALGO_CKSUM\n# include \"sha1.h\"\n#endif\n#if HASH_ALGO_SHA256 || HASH_ALGO_SHA224 || HASH_ALGO_CKSUM\n# include \"sha256.h\"\n#endif\n#if HASH_ALGO_SHA512 || HASH_ALGO_SHA384 || HASH_ALGO_CKSUM\n# include \"sha512.h\"\n#endif\n#if HASH_ALGO_CKSUM\n# include \"sm3.h\"\n#endif\n#include \"fadvise.h\"\n#include \"stdio--.h\"\n#include \"xbinary-io.h\"\n\n \n#if HASH_ALGO_SUM\n# define PROGRAM_NAME \"sum\"\n# define DIGEST_TYPE_STRING \"BSD\"\n# define DIGEST_STREAM sumfns[sum_algorithm]\n# define DIGEST_OUT sum_output_fns[sum_algorithm]\n# define DIGEST_BITS 16\n# define DIGEST_ALIGN 4\n#elif HASH_ALGO_CKSUM\n# define MAX_DIGEST_BITS 512\n# define MAX_DIGEST_ALIGN 8\n# define PROGRAM_NAME \"cksum\"\n# define DIGEST_TYPE_STRING algorithm_tags[cksum_algorithm]\n# define DIGEST_STREAM cksumfns[cksum_algorithm]\n# define DIGEST_OUT cksum_output_fns[cksum_algorithm]\n# define DIGEST_BITS MAX_DIGEST_BITS\n# define DIGEST_ALIGN MAX_DIGEST_ALIGN\n#elif HASH_ALGO_MD5\n# define PROGRAM_NAME \"md5sum\"\n# define DIGEST_TYPE_STRING \"MD5\"\n# define DIGEST_STREAM md5_stream\n# define DIGEST_BITS 128\n# define DIGEST_REFERENCE \"RFC 1321\"\n# define DIGEST_ALIGN 4\n#elif HASH_ALGO_BLAKE2\n# define PROGRAM_NAME \"b2sum\"\n# define DIGEST_TYPE_STRING \"BLAKE2b\"\n# define DIGEST_STREAM blake2b_stream\n# define DIGEST_BITS 512\n# define DIGEST_REFERENCE \"RFC 7693\"\n# define DIGEST_ALIGN 8\n#elif HASH_ALGO_SHA1\n# define PROGRAM_NAME \"sha1sum\"\n# define DIGEST_TYPE_STRING \"SHA1\"\n# define DIGEST_STREAM sha1_stream\n# define DIGEST_BITS 160\n# define DIGEST_REFERENCE \"FIPS-180-1\"\n# define DIGEST_ALIGN 4\n#elif HASH_ALGO_SHA256\n# define PROGRAM_NAME \"sha256sum\"\n# define DIGEST_TYPE_STRING \"SHA256\"\n# define DIGEST_STREAM sha256_stream\n# define DIGEST_BITS 256\n# define DIGEST_REFERENCE \"FIPS-180-2\"\n# define DIGEST_ALIGN 4\n#elif HASH_ALGO_SHA224\n# define PROGRAM_NAME \"sha224sum\"\n# define DIGEST_TYPE_STRING \"SHA224\"\n# define DIGEST_STREAM sha224_stream\n# define DIGEST_BITS 224\n# define DIGEST_REFERENCE \"RFC 3874\"\n# define DIGEST_ALIGN 4\n#elif HASH_ALGO_SHA512\n# define PROGRAM_NAME \"sha512sum\"\n# define DIGEST_TYPE_STRING \"SHA512\"\n# define DIGEST_STREAM sha512_stream\n# define DIGEST_BITS 512\n# define DIGEST_REFERENCE \"FIPS-180-2\"\n# define DIGEST_ALIGN 8\n#elif HASH_ALGO_SHA384\n# define PROGRAM_NAME \"sha384sum\"\n# define DIGEST_TYPE_STRING \"SHA384\"\n# define DIGEST_STREAM sha384_stream\n# define DIGEST_BITS 384\n# define DIGEST_REFERENCE \"FIPS-180-2\"\n# define DIGEST_ALIGN 8\n#else\n# error \"Can't decide which hash algorithm to compile.\"\n#endif\n#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n# define DIGEST_OUT output_file\n#endif\n\n#if HASH_ALGO_SUM\n# define AUTHORS \\\n  proper_name (\"Kayvan Aghaiepour\"), \\\n  proper_name (\"David MacKenzie\")\n#elif HASH_ALGO_CKSUM\n# define AUTHORS \\\n  proper_name_lite (\"Padraig Brady\", \"P\\303\\241draig Brady\"), \\\n  proper_name (\"Q. Frank Xia\")\n#elif HASH_ALGO_BLAKE2\n# define AUTHORS \\\n  proper_name_lite (\"Padraig Brady\", \"P\\303\\241draig Brady\"), \\\n  proper_name (\"Samuel Neves\")\n#else\n# define AUTHORS \\\n  proper_name (\"Ulrich Drepper\"), \\\n  proper_name (\"Scott Miller\"), \\\n  proper_name (\"David Madore\")\n#endif\n#if !HASH_ALGO_BLAKE2 && !HASH_ALGO_CKSUM\n# define DIGEST_HEX_BYTES (DIGEST_BITS / 4)\n#endif\n#define DIGEST_BIN_BYTES (DIGEST_BITS / 8)\n\n \n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n# define MIN_DIGEST_LINE_LENGTH 3  \n#else\n# define MIN_DIGEST_LINE_LENGTH \\\n   (DIGEST_HEX_BYTES   \\\n    + 1   \\\n    + 1   )\n#endif\n\n#if !HASH_ALGO_SUM\nstatic void\noutput_file (char const *file, int binary_file, void const *digest,\n             bool raw, bool tagged, unsigned char delim, bool args,\n             uintmax_t length);\n#endif\n\n \nstatic bool have_read_stdin;\n\n \nstatic size_t min_digest_line_length;\n\n \nstatic size_t digest_hex_bytes;\n\n \nstatic bool status_only = false;\n\n \nstatic bool warn = false;\n\n \nstatic bool ignore_missing = false;\n\n \nstatic bool quiet = false;\n\n \nstatic bool strict = false;\n\n \nstatic int bsd_reversed = -1;\n\n \nstatic unsigned char digest_delim = '\\n';\n\n#if HASH_ALGO_CKSUM\n \nstatic bool base64_digest = false;\n#endif\n\n \nstatic bool raw_digest = false;\n\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n# define BLAKE2B_MAX_LEN BLAKE2B_OUTBYTES\nstatic uintmax_t digest_length;\n#endif  \n\ntypedef void (*digest_output_fn)(char const *, int, void const *, bool,\n                                 bool, unsigned char, bool, uintmax_t);\n#if HASH_ALGO_SUM\nenum Algorithm\n{\n  bsd,\n  sysv,\n};\n\nstatic enum Algorithm sum_algorithm;\nstatic sumfn sumfns[]=\n{\n  bsd_sum_stream,\n  sysv_sum_stream,\n};\nstatic digest_output_fn sum_output_fns[]=\n{\n  output_bsd,\n  output_sysv,\n};\n#endif\n\n#if HASH_ALGO_CKSUM\nstatic int\nmd5_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return md5_stream (stream, resstream);\n}\nstatic int\nsha1_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return sha1_stream (stream, resstream);\n}\nstatic int\nsha224_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return sha224_stream (stream, resstream);\n}\nstatic int\nsha256_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return sha256_stream (stream, resstream);\n}\nstatic int\nsha384_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return sha384_stream (stream, resstream);\n}\nstatic int\nsha512_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return sha512_stream (stream, resstream);\n}\nstatic int\nblake2b_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return blake2b_stream (stream, resstream, *length);\n}\nstatic int\nsm3_sum_stream (FILE *stream, void *resstream, uintmax_t *length)\n{\n  return sm3_stream (stream, resstream);\n}\n\nenum Algorithm\n{\n  bsd,\n  sysv,\n  crc,\n  md5,\n  sha1,\n  sha224,\n  sha256,\n  sha384,\n  sha512,\n  blake2b,\n  sm3,\n};\n\nstatic char const *const algorithm_args[] =\n{\n  \"bsd\", \"sysv\", \"crc\", \"md5\", \"sha1\", \"sha224\",\n  \"sha256\", \"sha384\", \"sha512\", \"blake2b\", \"sm3\", nullptr\n};\nstatic enum Algorithm const algorithm_types[] =\n{\n  bsd, sysv, crc, md5, sha1, sha224,\n  sha256, sha384, sha512, blake2b, sm3,\n};\nARGMATCH_VERIFY (algorithm_args, algorithm_types);\n\nstatic char const *const algorithm_tags[] =\n{\n  \"BSD\", \"SYSV\", \"CRC\", \"MD5\", \"SHA1\", \"SHA224\",\n  \"SHA256\", \"SHA384\", \"SHA512\", \"BLAKE2b\", \"SM3\", nullptr\n};\nstatic int const algorithm_bits[] =\n{\n  16, 16, 32, 128, 160, 224,\n  256, 384, 512, 512, 256, 0\n};\n\nstatic_assert (ARRAY_CARDINALITY (algorithm_bits)\n               == ARRAY_CARDINALITY (algorithm_args));\n\nstatic bool algorithm_specified = false;\nstatic enum Algorithm cksum_algorithm = crc;\nstatic sumfn cksumfns[]=\n{\n  bsd_sum_stream,\n  sysv_sum_stream,\n  crc_sum_stream,\n  md5_sum_stream,\n  sha1_sum_stream,\n  sha224_sum_stream,\n  sha256_sum_stream,\n  sha384_sum_stream,\n  sha512_sum_stream,\n  blake2b_sum_stream,\n  sm3_sum_stream,\n};\nstatic digest_output_fn cksum_output_fns[]=\n{\n  output_bsd,\n  output_sysv,\n  output_crc,\n  output_file,\n  output_file,\n  output_file,\n  output_file,\n  output_file,\n  output_file,\n  output_file,\n  output_file,\n};\nbool cksum_debug;\n#endif\n\n \n\nenum\n{\n  IGNORE_MISSING_OPTION = CHAR_MAX + 1,\n  STATUS_OPTION,\n  QUIET_OPTION,\n  STRICT_OPTION,\n  TAG_OPTION,\n  UNTAG_OPTION,\n  DEBUG_PROGRAM_OPTION,\n  RAW_OPTION,\n  BASE64_OPTION,\n};\n\nstatic struct option const long_options[] =\n{\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n  { \"length\", required_argument, nullptr, 'l'},\n#endif\n\n#if !HASH_ALGO_SUM\n  { \"check\", no_argument, nullptr, 'c' },\n  { \"ignore-missing\", no_argument, nullptr, IGNORE_MISSING_OPTION},\n  { \"quiet\", no_argument, nullptr, QUIET_OPTION },\n  { \"status\", no_argument, nullptr, STATUS_OPTION },\n  { \"warn\", no_argument, nullptr, 'w' },\n  { \"strict\", no_argument, nullptr, STRICT_OPTION },\n  { \"tag\", no_argument, nullptr, TAG_OPTION },\n  { \"zero\", no_argument, nullptr, 'z' },\n\n# if HASH_ALGO_CKSUM\n  { \"algorithm\", required_argument, nullptr, 'a'},\n  { \"base64\", no_argument, nullptr, BASE64_OPTION },\n  { \"debug\", no_argument, nullptr, DEBUG_PROGRAM_OPTION},\n  { \"raw\", no_argument, nullptr, RAW_OPTION},\n  { \"untagged\", no_argument, nullptr, UNTAG_OPTION },\n# endif\n  { \"binary\", no_argument, nullptr, 'b' },\n  { \"text\", no_argument, nullptr, 't' },\n\n#else\n  {\"sysv\", no_argument, nullptr, 's'},\n#endif\n\n  { GETOPT_HELP_OPTION_DECL },\n  { GETOPT_VERSION_OPTION_DECL },\n  { nullptr, 0, nullptr, 0 }\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"), program_name);\n#if HASH_ALGO_CKSUM\n      fputs (_(\"\\\nPrint or verify checksums.\\n\\\nBy default use the 32 bit CRC algorithm.\\n\\\n\"), stdout);\n#else\n      printf (_(\"\\\nPrint or check %s (%d-bit) checksums.\\n\\\n\"),\n              DIGEST_TYPE_STRING,\n              DIGEST_BITS);\n#endif\n\n      emit_stdin_note ();\n#if HASH_ALGO_SUM\n      fputs (_(\"\\\n\\n\\\n  -r              use BSD sum algorithm (the default), use 1K blocks\\n\\\n  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\\n\\\n\"), stdout);\n#endif\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n        emit_mandatory_arg_note ();\n#endif\n#if HASH_ALGO_CKSUM\n        fputs (_(\"\\\n  -a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\\\n\\n\\\n\"), stdout);\n        fputs (_(\"\\\n      --base64          emit base64-encoded digests, not hexadecimal\\\n\\n\\\n\"), stdout);\n#endif\n#if !HASH_ALGO_SUM\n# if !HASH_ALGO_CKSUM\n      if (O_BINARY)\n        fputs (_(\"\\\n  -b, --binary          read in binary mode (default unless reading tty stdin)\\\n\\n\\\n\"), stdout);\n      else\n        fputs (_(\"\\\n  -b, --binary          read in binary mode\\n\\\n\"), stdout);\n# endif\n        fputs (_(\"\\\n  -c, --check           read checksums from the FILEs and check them\\n\\\n\"), stdout);\n# if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n        fputs (_(\"\\\n  -l, --length=BITS     digest length in bits; must not exceed the max for\\n\\\n                          the blake2 algorithm and must be a multiple of 8\\n\\\n\"), stdout);\n# endif\n# if HASH_ALGO_CKSUM\n        fputs (_(\"\\\n      --raw             emit a raw binary digest, not hexadecimal\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --tag             create a BSD-style checksum (the default)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --untagged        create a reversed style checksum, without digest type\\n\\\n\"), stdout);\n# else\n      fputs (_(\"\\\n      --tag             create a BSD-style checksum\\n\\\n\"), stdout);\n# endif\n# if !HASH_ALGO_CKSUM\n      if (O_BINARY)\n        fputs (_(\"\\\n  -t, --text            read in text mode (default if reading tty stdin)\\n\\\n\"), stdout);\n      else\n        fputs (_(\"\\\n  -t, --text            read in text mode (default)\\n\\\n\"), stdout);\n# endif\n      fputs (_(\"\\\n  -z, --zero            end each output line with NUL, not newline,\\n\\\n                          and disable file name escaping\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nThe following five options are useful only when verifying checksums:\\n\\\n      --ignore-missing  don't fail or report status for missing files\\n\\\n      --quiet           don't print OK for each successfully verified file\\n\\\n      --status          don't output anything, status code shows success\\n\\\n      --strict          exit non-zero for improperly formatted checksum lines\\n\\\n  -w, --warn            warn about improperly formatted checksum lines\\n\\\n\\n\\\n\"), stdout);\n#endif\n#if HASH_ALGO_CKSUM\n      fputs (_(\"\\\n      --debug           indicate which implementation used\\n\\\n\"), stdout);\n#endif\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n#if HASH_ALGO_CKSUM\n      fputs (_(\"\\\n\\n\\\nDIGEST determines the digest algorithm and default output format:\\n\\\n  sysv      (equivalent to sum -s)\\n\\\n  bsd       (equivalent to sum -r)\\n\\\n  crc       (equivalent to cksum)\\n\\\n  md5       (equivalent to md5sum)\\n\\\n  sha1      (equivalent to sha1sum)\\n\\\n  sha224    (equivalent to sha224sum)\\n\\\n  sha256    (equivalent to sha256sum)\\n\\\n  sha384    (equivalent to sha384sum)\\n\\\n  sha512    (equivalent to sha512sum)\\n\\\n  blake2b   (equivalent to b2sum)\\n\\\n  sm3       (only available through cksum)\\n\\\n\\n\"), stdout);\n#endif\n#if !HASH_ALGO_SUM && !HASH_ALGO_CKSUM\n      printf (_(\"\\\n\\n\\\nThe sums are computed as described in %s.\\n\"), DIGEST_REFERENCE);\n      fputs (_(\"\\\nWhen checking, the input should be a former output of this program.\\n\\\nThe default mode is to print a line with: checksum, a space,\\n\\\na character indicating input mode ('*' for binary, ' ' for text\\n\\\nor where binary is insignificant), and name for each FILE.\\n\\\n\\n\\\nNote: There is no difference between binary mode and text mode on GNU systems.\\\n\\n\"), stdout);\n#endif\n#if HASH_ALGO_CKSUM\n      fputs (_(\"\\\nWhen checking, the input should be a former output of this program,\\n\\\nor equivalent standalone program.\\\n\\n\"), stdout);\n#endif\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\n/* Given a string S, return TRUE if it contains problematic characters\n   that need escaping.  Note we escape '\\' itself to provide some forward\n   compat to introduce escaping of other characters.  */\n\nATTRIBUTE_PURE\nstatic bool\nproblematic_chars (char const *s)\n{\n  size_t length = strcspn (s, \"\\\\\\n\\r\");\n  return s[length] != '\\0';\n}\n\n#define ISWHITE(c) ((c) == ' ' || (c) == '\\t')\n\n/* Given a file name, S of length S_LEN, that is not NUL-terminated,\n   modify it in place, performing the equivalent of this sed substitution:\n   's/\\\\n/\\n/g;s/\\\\r/\\r/g;s/\\\\\\\\/\\\\/g' i.e., replacing each \"\\\\n\" string\n   with a newline, each \"\\\\r\" string with a carriage return,\n   and each \"\\\\\\\\\" with a single backslash, NUL-terminate it and return S.\n   If S is not a valid escaped file name, i.e., if it ends with an odd number\n   of backslashes or if it contains a backslash followed by anything other\n   than \"n\" or another backslash, return nullptr.  */\n\nstatic char *\nfilename_unescape (char *s, size_t s_len)\n{\n  char *dst = s;\n\n  for (size_t i = 0; i < s_len; i++)\n    {\n      switch (s[i])\n        {\n        case '\\\\':\n          if (i == s_len - 1)\n            {\n              /* File name ends with an unescaped backslash: invalid.  */\n              return nullptr;\n            }\n          ++i;\n          switch (s[i])\n            {\n            case 'n':\n              *dst++ = '\\n';\n              break;\n            case 'r':\n              *dst++ = '\\r';\n              break;\n            case '\\\\':\n              *dst++ = '\\\\';\n              break;\n            default:\n              /* Only '\\', 'n' or 'r' may follow a backslash.  */\n              return nullptr;\n            }\n          break;\n\n        case '\\0':\n          /* The file name may not contain a NUL.  */\n          return nullptr;\n\n        default:\n          *dst++ = s[i];\n          break;\n        }\n    }\n  if (dst < s + s_len)\n    *dst = '\\0';\n\n  return s;\n}\n\n/* Return true if S is a LEN-byte NUL-terminated string of hex or base64\n   digits and has the expected length.  Otherwise, return false.  */\nATTRIBUTE_PURE\nstatic bool\nvalid_digits (unsigned char const *s, size_t len)\n{\n#if HASH_ALGO_CKSUM\n  if (len == BASE64_LENGTH (digest_length / 8))\n    {\n      size_t i;\n      for (i = 0; i < len - digest_length % 3; i++)\n        {\n          if (!isbase64 (*s))\n            return false;\n          ++s;\n        }\n      for ( ; i < len; i++)\n        {\n          if (*s != '=')\n            return false;\n          ++s;\n        }\n    }\n  else\n#endif\n  if (len == digest_hex_bytes)\n    {\n      for (idx_t i = 0; i < digest_hex_bytes; i++)\n        {\n          if (!isxdigit (*s))\n            return false;\n          ++s;\n        }\n    }\n  else\n    return false;\n\n  return *s == '\\0';\n}\n\n/* Split the checksum string S (of length S_LEN) from a BSD 'md5' or\n   'sha1' command into two parts: a hexadecimal digest, and the file\n   name.  S is modified.  Set *D_LEN to the length of the digest string.\n   Return true if successful.  */\n\nstatic bool\nbsd_split_3 (char *s, size_t s_len,\n             unsigned char **digest, size_t *d_len,\n             char **file_name, bool escaped_filename)\n{\n  if (s_len == 0)\n    return false;\n\n  /* Find end of filename.  */\n  size_t i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  *file_name = s;\n\n  if (escaped_filename && filename_unescape (s, i) == nullptr)\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *digest = (unsigned char *) &s[i];\n\n  *d_len = s_len - i;\n  return valid_digits (*digest, *d_len);\n}\n\n#if HASH_ALGO_CKSUM\n/* Return the corresponding Algorithm for the string S,\n   or -1 for no match.  */\n\nstatic ptrdiff_t\nalgorithm_from_tag (char *s)\n{\n  /* Limit check size to this length for perf reasons.  */\n  static size_t max_tag_len;\n  if (! max_tag_len)\n    {\n      char const * const * tag = algorithm_tags;\n      while (*tag)\n        {\n          size_t tag_len = strlen (*tag++);\n          max_tag_len = MAX (tag_len, max_tag_len);\n        }\n    }\n\n  size_t i = 0;\n\n  /* Find end of tag */\n  while (i <= max_tag_len && s[i] && ! ISWHITE (s[i])\n         && s[i] != '-' && s[i] != '(')\n    ++i;\n\n  if (i > max_tag_len)\n    return -1;\n\n  /* Terminate tag, and lookup.  */\n  char sep = s[i];\n  s[i] = '\\0';\n  ptrdiff_t algo = argmatch_exact (s, algorithm_tags);\n  s[i] = sep;\n\n  return algo;\n}\n#endif\n\n/* Split the string S (of length S_LEN) into three parts:\n   a hexadecimal digest, binary flag, and the file name.\n   S is modified.  Set *D_LEN to the length of the digest string.\n   Return true if successful.  */\n\nstatic bool\nsplit_3 (char *s, size_t s_len,\n         unsigned char **digest, size_t *d_len, int *binary, char **file_name)\n{\n  bool escaped_filename = false;\n  size_t algo_name_len;\n\n  size_t i = 0;\n  while (ISWHITE (s[i]))\n    ++i;\n\n  if (s[i] == '\\\\')\n    {\n      ++i;\n      escaped_filename = true;\n    }\n\n  /* Check for BSD-style checksum line. */\n\n#if HASH_ALGO_CKSUM\n  if (! algorithm_specified)\n    {\n      ptrdiff_t algo_tag = algorithm_from_tag (s + i);\n      if (algo_tag >= 0)\n        {\n          if (algo_tag <= crc)\n            return false;  /* We don't support checking these older formats.  */\n          cksum_algorithm = algo_tag;\n        }\n      else\n        return false;  /* We only support tagged format without -a.  */\n    }\n#endif\n\n  algo_name_len = strlen (DIGEST_TYPE_STRING);\n  if (STREQ_LEN (s + i, DIGEST_TYPE_STRING, algo_name_len))\n    {\n      i += algo_name_len;\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n      /* Terminate and match algorithm name.  */\n      char const *algo_name = &s[i - algo_name_len];\n      bool length_specified = s[i] == '-';\n      bool openssl_format = s[i] == '('; /* and no length_specified */\n      s[i++] = '\\0';\n      if (!STREQ (algo_name, DIGEST_TYPE_STRING))\n        return false;\n      if (openssl_format)\n        s[--i] = '(';\n\n# if HASH_ALGO_BLAKE2\n      digest_length = BLAKE2B_MAX_LEN * 8;\n# else\n      digest_length = algorithm_bits[cksum_algorithm];\n# endif\n      if (length_specified)\n        {\n          uintmax_t length;\n          char *siend;\n          if (! (xstrtoumax (s + i, &siend, 0, &length, nullptr) == LONGINT_OK\n                 && 0 < length && length <= digest_length\n                 && length % 8 == 0))\n            return false;\n\n          i = siend - s;\n          digest_length = length;\n        }\n      digest_hex_bytes = digest_length / 4;\n#endif\n      if (s[i] == ' ')\n        ++i;\n      if (s[i] == '(')\n        {\n          ++i;\n          *binary = 0;\n          return bsd_split_3 (s + i, s_len - i,\n                              digest, d_len, file_name, escaped_filename);\n        }\n      return false;\n    }\n\n  /* Ignore this line if it is too short.\n     Each line must have at least 'min_digest_line_length - 1' (or one more, if\n     the first is a backslash) more characters to contain correct message digest\n     information.  */\n  if (s_len - i < min_digest_line_length + (s[i] == '\\\\'))\n    return false;\n\n  *digest = (unsigned char *) &s[i];\n\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n  /* Auto determine length.  */\n# if HASH_ALGO_CKSUM\n  if (cksum_algorithm == blake2b) {\n# endif\n  unsigned char const *hp = *digest;\n  digest_hex_bytes = 0;\n  while (isxdigit (*hp++))\n    digest_hex_bytes++;\n  if (digest_hex_bytes < 2 || digest_hex_bytes % 2\n      || BLAKE2B_MAX_LEN * 2 < digest_hex_bytes)\n    return false;\n  digest_length = digest_hex_bytes * 4;\n# if HASH_ALGO_CKSUM\n  }\n# endif\n#endif\n\n  /* This field must be the hexadecimal or base64 representation\n     of the message digest.  */\n  while (s[i] && !ISWHITE (s[i]))\n    i++;\n\n  /* The digest must be followed by at least one whitespace character.  */\n  if (i == s_len)\n    return false;\n\n  *d_len = &s[i] - (char *) *digest;\n  s[i++] = '\\0';\n\n  if (! valid_digits (*digest, *d_len))\n    return false;\n\n  /* If \"bsd reversed\" format detected.  */\n  if ((s_len - i == 1) || (s[i] != ' ' && s[i] != '*'))\n    {\n      /* Don't allow mixing bsd and standard formats,\n         to minimize security issues with attackers\n         renaming files with leading spaces.\n         This assumes that with bsd format checksums\n         that the first file name does not have\n         a leading ' ' or '*'.  */\n      if (bsd_reversed == 0)\n        return false;\n      bsd_reversed = 1;\n    }\n  else if (bsd_reversed != 1)\n    {\n      bsd_reversed = 0;\n      *binary = (s[i++] == '*');\n    }\n\n  /* All characters between the type indicator and end of line are\n     significant -- that includes leading and trailing white space.  */\n  *file_name = &s[i];\n\n  if (escaped_filename)\n    return filename_unescape (&s[i], s_len - i) != nullptr;\n\n  return true;\n}\n\n/* If ESCAPE is true, then translate each:\n   NEWLINE byte to the string, \"\\\\n\",\n   CARRIAGE RETURN byte to the string, \"\\\\r\",\n   and each backslash to \"\\\\\\\\\".  */\nstatic void\nprint_filename (char const *file, bool escape)\n{\n  if (! escape)\n    {\n      fputs (file, stdout);\n      return;\n    }\n\n  while (*file)\n    {\n      switch (*file)\n        {\n        case '\\n':\n          fputs (\"\\\\n\", stdout);\n          break;\n\n        case '\\r':\n          fputs (\"\\\\r\", stdout);\n          break;\n\n        case '\\\\':\n          fputs (\"\\\\\\\\\", stdout);\n          break;\n\n        default:\n          putchar (*file);\n          break;\n        }\n      file++;\n    }\n}\n\n/* An interface to the function, DIGEST_STREAM.\n   Operate on FILENAME (it may be \"-\").\n\n   *BINARY indicates whether the file is binary.  BINARY < 0 means it\n   depends on whether binary mode makes any difference and the file is\n   a terminal; in that case, clear *BINARY if the file was treated as\n   text because it was a terminal.\n\n   Put the checksum in *BIN_RESULT, which must be properly aligned.\n   Put true in *MISSING if the file can't be opened due to ENOENT.\n   Return true if successful.  */\n\nstatic bool\ndigest_file (char const *filename, int *binary, unsigned char *bin_result,\n             bool *missing, MAYBE_UNUSED uintmax_t *length)\n{\n  FILE *fp;\n  int err;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  *missing = false;\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fp = stdin;\n      if (O_BINARY && *binary)\n        {\n          if (*binary < 0)\n            *binary = ! isatty (STDIN_FILENO);\n          if (*binary)\n            xset_binary_mode (STDIN_FILENO, O_BINARY);\n        }\n    }\n  else\n    {\n      fp = fopen (filename, (O_BINARY && *binary ? \"rb\" : \"r\"));\n      if (fp == nullptr)\n        {\n          if (ignore_missing && errno == ENOENT)\n            {\n              *missing = true;\n              return true;\n            }\n          error (0, errno, \"%s\", quotef (filename));\n          return false;\n        }\n    }\n\n  fadvise (fp, FADVISE_SEQUENTIAL);\n\n#if HASH_ALGO_CKSUM\n  if (cksum_algorithm == blake2b)\n    *length = digest_length / 8;\n  err = DIGEST_STREAM (fp, bin_result, length);\n#elif HASH_ALGO_SUM\n  err = DIGEST_STREAM (fp, bin_result, length);\n#elif HASH_ALGO_BLAKE2\n  err = DIGEST_STREAM (fp, bin_result, digest_length / 8);\n#else\n  err = DIGEST_STREAM (fp, bin_result);\n#endif\n  err = err ? errno : 0;\n  if (is_stdin)\n    clearerr (fp);\n  else if (fclose (fp) != 0 && !err)\n    err = errno;\n\n  if (err)\n    {\n      error (0, err, \"%s\", quotef (filename));\n      return false;\n    }\n\n  return true;\n}\n\n#if !HASH_ALGO_SUM\nstatic void\noutput_file (char const *file, int binary_file, void const *digest,\n             bool raw, bool tagged, unsigned char delim, MAYBE_UNUSED bool args,\n             MAYBE_UNUSED uintmax_t length)\n{\n# if HASH_ALGO_CKSUM\n  if (raw)\n    {\n      fwrite (digest, 1, digest_length / 8, stdout);\n      return;\n    }\n# endif\n\n  unsigned char const *bin_buffer = digest;\n\n  /* Output a leading backslash if the file name contains problematic chars.  */\n  bool needs_escape = delim == '\\n' && problematic_chars (file);\n\n  if (needs_escape)\n    putchar ('\\\\');\n\n  if (tagged)\n    {\n      fputs (DIGEST_TYPE_STRING, stdout);\n# if HASH_ALGO_BLAKE2\n      if (digest_length < BLAKE2B_MAX_LEN * 8)\n        printf (\"-%\"PRIuMAX, digest_length);\n# elif HASH_ALGO_CKSUM\n      if (cksum_algorithm == blake2b)\n        {\n          if (digest_length < BLAKE2B_MAX_LEN * 8)\n            printf (\"-%\"PRIuMAX, digest_length);\n        }\n# endif\n      fputs (\" (\", stdout);\n      print_filename (file, needs_escape);\n      fputs (\") = \", stdout);\n    }\n\n# if HASH_ALGO_CKSUM\n  if (base64_digest)\n    {\n      char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n      base64_encode ((char const *) bin_buffer, digest_length / 8,\n                     b64, sizeof b64);\n      fputs (b64, stdout);\n    }\n  else\n# endif\n    {\n      for (size_t i = 0; i < (digest_hex_bytes / 2); ++i)\n        printf (\"%02x\", bin_buffer[i]);\n    }\n\n  if (!tagged)\n    {\n      putchar (' ');\n      putchar (binary_file ? '*' : ' ');\n      print_filename (file, needs_escape);\n    }\n\n  putchar (delim);\n}\n#endif\n\n#if HASH_ALGO_CKSUM\n/* Return true if B64_DIGEST is the same as the base64 digest of the\n   DIGEST_LENGTH/8 bytes at BIN_BUFFER.  */\nstatic bool\nb64_equal (unsigned char const *b64_digest, unsigned char const *bin_buffer)\n{\n  size_t b64_n_bytes = BASE64_LENGTH (digest_length / 8);\n  char b64[BASE64_LENGTH (DIGEST_BIN_BYTES) + 1];\n  base64_encode ((char const *) bin_buffer, digest_length / 8, b64, sizeof b64);\n  return memcmp (b64_digest, b64, b64_n_bytes + 1) == 0;\n}\n#endif\n\n/* Return true if HEX_DIGEST is the same as the hex-encoded digest of the\n   DIGEST_LENGTH/8 bytes at BIN_BUFFER.  */\nstatic bool\nhex_equal (unsigned char const *hex_digest, unsigned char const *bin_buffer)\n{\n  static const char bin2hex[] = { '0', '1', '2', '3',\n                                  '4', '5', '6', '7',\n                                  '8', '9', 'a', 'b',\n                                  'c', 'd', 'e', 'f' };\n  size_t digest_bin_bytes = digest_hex_bytes / 2;\n\n  /* Compare generated binary number with text representation\n     in check file.  Ignore case of hex digits.  */\n  size_t cnt;\n  for (cnt = 0; cnt < digest_bin_bytes; ++cnt)\n    {\n      if (tolower (hex_digest[2 * cnt])\n          != bin2hex[bin_buffer[cnt] >> 4]\n          || (tolower (hex_digest[2 * cnt + 1])\n              != (bin2hex[bin_buffer[cnt] & 0xf])))\n        break;\n    }\n  return cnt == digest_bin_bytes;\n}\n\nstatic bool\ndigest_check (char const *checkfile_name)\n{\n  FILE *checkfile_stream;\n  uintmax_t n_misformatted_lines = 0;\n  uintmax_t n_mismatched_checksums = 0;\n  uintmax_t n_open_or_read_failures = 0;\n  bool properly_formatted_lines = false;\n  bool matched_checksums = false;\n  unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n  /* Make sure bin_buffer is properly aligned. */\n  unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n  uintmax_t line_number;\n  char *line;\n  size_t line_chars_allocated;\n  bool is_stdin = STREQ (checkfile_name, \"-\");\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      checkfile_name = _(\"standard input\");\n      checkfile_stream = stdin;\n    }\n  else\n    {\n      checkfile_stream = fopen (checkfile_name, \"r\");\n      if (checkfile_stream == nullptr)\n        {\n          error (0, errno, \"%s\", quotef (checkfile_name));\n          return false;\n        }\n    }\n\n  line_number = 0;\n  line = nullptr;\n  line_chars_allocated = 0;\n  do\n    {\n      char *filename;\n      int binary;\n      unsigned char *digest;\n      ssize_t line_length;\n\n      ++line_number;\n      if (line_number == 0)\n        error (EXIT_FAILURE, 0, _(\"%s: too many checksum lines\"),\n               quotef (checkfile_name));\n\n      line_length = getline (&line, &line_chars_allocated, checkfile_stream);\n      if (line_length <= 0)\n        break;\n\n      /* Ignore comment lines, which begin with a '#' character.  */\n      if (line[0] == '#')\n        continue;\n\n      /* Remove any trailing newline.  */\n      line_length -= line[line_length - 1] == '\\n';\n      /* Remove any trailing carriage return.  */\n      line_length -= line[line_length - (0 < line_length)] == '\\r';\n\n      /* Ignore empty lines.  */\n      if (line_length == 0)\n        continue;\n\n      line[line_length] = '\\0';\n\n      size_t d_len;\n      if (! (split_3 (line, line_length, &digest, &d_len, &binary, &filename)\n             && ! (is_stdin && STREQ (filename, \"-\"))))\n        {\n          ++n_misformatted_lines;\n\n          if (warn)\n            {\n              error (0, 0,\n                     _(\"%s: %\" PRIuMAX\n                       \": improperly formatted %s checksum line\"),\n                     quotef (checkfile_name), line_number,\n                     DIGEST_TYPE_STRING);\n            }\n        }\n      else\n        {\n          bool ok;\n          bool missing;\n          bool needs_escape = ! status_only && problematic_chars (filename);\n\n          properly_formatted_lines = true;\n\n          uintmax_t length;\n          ok = digest_file (filename, &binary, bin_buffer, &missing, &length);\n\n          if (!ok)\n            {\n              ++n_open_or_read_failures;\n              if (!status_only)\n                {\n                  if (needs_escape)\n                    putchar ('\\\\');\n                  print_filename (filename, needs_escape);\n                  printf (\": %s\\n\", _(\"FAILED open or read\"));\n                }\n            }\n          else if (ignore_missing && missing)\n            {\n              /* Ignore missing files with --ignore-missing.  */\n              ;\n            }\n          else\n            {\n              bool match = false;\n#if HASH_ALGO_CKSUM\n              if (d_len < digest_hex_bytes)\n                match = b64_equal (digest, bin_buffer);\n              else\n#endif\n                if (d_len == digest_hex_bytes)\n                  match = hex_equal (digest, bin_buffer);\n\n              if (match)\n                matched_checksums = true;\n              else\n                ++n_mismatched_checksums;\n\n              if (!status_only)\n                {\n                  if (! match || ! quiet)\n                    {\n                      if (needs_escape)\n                        putchar ('\\\\');\n                      print_filename (filename, needs_escape);\n                    }\n\n                  if (! match)\n                    printf (\": %s\\n\", _(\"FAILED\"));\n                  else if (!quiet)\n                    printf (\": %s\\n\", _(\"OK\"));\n                }\n            }\n        }\n    }\n  while (!feof (checkfile_stream) && !ferror (checkfile_stream));\n\n  free (line);\n\n  int err = ferror (checkfile_stream) ? 0 : -1;\n  if (is_stdin)\n    clearerr (checkfile_stream);\n  else if (fclose (checkfile_stream) != 0 && err < 0)\n    err = errno;\n\n  if (0 <= err)\n    {\n      error (0, err, err ? \"%s\" : _(\"%s: read error\"),\n             quotef (checkfile_name));\n      return false;\n    }\n\n  if (! properly_formatted_lines)\n    {\n      /* Warn if no tests are found.  */\n      error (0, 0, _(\"%s: no properly formatted checksum lines found\"),\n             quotef (checkfile_name));\n    }\n  else\n    {\n      if (!status_only)\n        {\n          if (n_misformatted_lines != 0)\n            error (0, 0,\n                   (ngettext\n                    (\"WARNING: %\" PRIuMAX \" line is improperly formatted\",\n                     \"WARNING: %\" PRIuMAX \" lines are improperly formatted\",\n                     select_plural (n_misformatted_lines))),\n                   n_misformatted_lines);\n\n          if (n_open_or_read_failures != 0)\n            error (0, 0,\n                   (ngettext\n                    (\"WARNING: %\" PRIuMAX \" listed file could not be read\",\n                     \"WARNING: %\" PRIuMAX \" listed files could not be read\",\n                     select_plural (n_open_or_read_failures))),\n                   n_open_or_read_failures);\n\n          if (n_mismatched_checksums != 0)\n            error (0, 0,\n                   (ngettext\n                    (\"WARNING: %\" PRIuMAX \" computed checksum did NOT match\",\n                     \"WARNING: %\" PRIuMAX \" computed checksums did NOT match\",\n                     select_plural (n_mismatched_checksums))),\n                   n_mismatched_checksums);\n\n          if (ignore_missing && ! matched_checksums)\n            error (0, 0, _(\"%s: no file was verified\"),\n                   quotef (checkfile_name));\n        }\n    }\n\n  return (properly_formatted_lines\n          && matched_checksums\n          && n_mismatched_checksums == 0\n          && n_open_or_read_failures == 0\n          && (!strict || n_misformatted_lines == 0));\n}\n\nint\nmain (int argc, char **argv)\n{\n  unsigned char bin_buffer_unaligned[DIGEST_BIN_BYTES + DIGEST_ALIGN];\n  /* Make sure bin_buffer is properly aligned. */\n  unsigned char *bin_buffer = ptr_align (bin_buffer_unaligned, DIGEST_ALIGN);\n  bool do_check = false;\n  int opt;\n  bool ok = true;\n  int binary = -1;\n#if HASH_ALGO_CKSUM\n  bool prefix_tag = true;\n#else\n  bool prefix_tag = false;\n#endif\n\n  /* Setting values of global variables.  */\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  /* Line buffer stdout to ensure lines are written atomically and immediately\n     so that processes running in parallel do not intersperse their output.  */\n  setvbuf (stdout, nullptr, _IOLBF, 0);\n\n#if HASH_ALGO_SUM\n  char const *short_opts = \"rs\";\n#elif HASH_ALGO_CKSUM\n  char const *short_opts = \"a:l:bctwz\";\n  char const *digest_length_str = \"\";\n#elif HASH_ALGO_BLAKE2\n  char const *short_opts = \"l:bctwz\";\n  char const *digest_length_str = \"\";\n#else\n  char const *short_opts = \"bctwz\";\n#endif\n\n  while ((opt = getopt_long (argc, argv, short_opts, long_options, nullptr))\n         != -1)\n    switch (opt)\n      {\n#if HASH_ALGO_CKSUM\n      case 'a':\n        cksum_algorithm = XARGMATCH_EXACT (\"--algorithm\", optarg,\n                                           algorithm_args, algorithm_types);\n        algorithm_specified = true;\n        break;\n\n      case DEBUG_PROGRAM_OPTION:\n        cksum_debug = true;\n        break;\n#endif\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n      case 'l':\n        digest_length = xdectoumax (optarg, 0, UINTMAX_MAX, \"\",\n                                _(\"invalid length\"), 0);\n        digest_length_str = optarg;\n        if (digest_length % 8 != 0)\n          {\n            error (0, 0, _(\"invalid length: %s\"), quote (digest_length_str));\n            error (EXIT_FAILURE, 0, _(\"length is not a multiple of 8\"));\n          }\n        break;\n#endif\n#if !HASH_ALGO_SUM\n      case 'c':\n        do_check = true;\n        break;\n      case STATUS_OPTION:\n        status_only = true;\n        warn = false;\n        quiet = false;\n        break;\n      case 'b':\n        binary = 1;\n        break;\n      case 't':\n        binary = 0;\n        break;\n      case 'w':\n        status_only = false;\n        warn = true;\n        quiet = false;\n        break;\n      case IGNORE_MISSING_OPTION:\n        ignore_missing = true;\n        break;\n      case QUIET_OPTION:\n        status_only = false;\n        warn = false;\n        quiet = true;\n        break;\n      case STRICT_OPTION:\n        strict = true;\n        break;\n# if HASH_ALGO_CKSUM\n      case BASE64_OPTION:\n        base64_digest = true;\n        break;\n      case RAW_OPTION:\n        raw_digest = true;\n        break;\n      case UNTAG_OPTION:\n        prefix_tag = false;\n        break;\n# endif\n      case TAG_OPTION:\n        prefix_tag = true;\n        binary = 1;\n        break;\n      case 'z':\n        digest_delim = '\\0';\n        break;\n#endif\n#if HASH_ALGO_SUM\n      case 'r':\t\t/* For SysV compatibility. */\n        sum_algorithm = bsd;\n        break;\n\n      case 's':\n        sum_algorithm = sysv;\n        break;\n#endif\n      case_GETOPT_HELP_CHAR;\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n      default:\n        usage (EXIT_FAILURE);\n      }\n\n  min_digest_line_length = MIN_DIGEST_LINE_LENGTH;\n#if HASH_ALGO_BLAKE2 || HASH_ALGO_CKSUM\n# if HASH_ALGO_CKSUM\n  if (digest_length && cksum_algorithm != blake2b)\n    error (EXIT_FAILURE, 0,\n           _(\"--length is only supported with --algorithm=blake2b\"));\n# endif\n  if (digest_length > BLAKE2B_MAX_LEN * 8)\n    {\n      error (0, 0, _(\"invalid length: %s\"), quote (digest_length_str));\n      error (EXIT_FAILURE, 0,\n             _(\"maximum digest length for %s is %d bits\"),\n             quote (DIGEST_TYPE_STRING),\n             BLAKE2B_MAX_LEN * 8);\n    }\n  if (digest_length == 0)\n    {\n# if HASH_ALGO_BLAKE2\n      digest_length = BLAKE2B_MAX_LEN * 8;\n# else\n      digest_length = algorithm_bits[cksum_algorithm];\n# endif\n    }\n  digest_hex_bytes = digest_length / 4;\n#else\n  digest_hex_bytes = DIGEST_HEX_BYTES;\n#endif\n\n#if HASH_ALGO_CKSUM\n  switch (cksum_algorithm)\n    {\n    case bsd:\n    case sysv:\n    case crc:\n        if (do_check && algorithm_specified)\n          error (EXIT_FAILURE, 0,\n                 _(\"--check is not supported with --algorithm={bsd,sysv,crc}\"));\n        break;\n    default:\n        break;\n    }\n\n  if (base64_digest && raw_digest)\n   {\n     error (0, 0, _(\"--base64 and --raw are mutually exclusive\"));\n     usage (EXIT_FAILURE);\n   }\n#endif\n\n  if (prefix_tag && !binary)\n   {\n     /* This could be supported in a backwards compatible way\n        by prefixing the output line with a space in text mode.\n        However that's invasive enough that it was agreed to\n        not support this mode with --tag, as --text use cases\n        are adequately supported by the default output format.  */\n#if !HASH_ALGO_CKSUM\n     error (0, 0, _(\"--tag does not support --text mode\"));\n#else\n     error (0, 0, _(\"--text mode is only supported with --untagged\"));\n#endif\n     usage (EXIT_FAILURE);\n   }\n\n  if (digest_delim != '\\n' && do_check)\n    {\n      error (0, 0, _(\"the --zero option is not supported when \"\n                     \"verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n#if !HASH_ALGO_CKSUM\n  if (prefix_tag && do_check)\n    {\n      error (0, 0, _(\"the --tag option is meaningless when \"\n                     \"verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n#endif\n\n  if (0 <= binary && do_check)\n    {\n      error (0, 0, _(\"the --binary and --text options are meaningless when \"\n                     \"verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (ignore_missing && !do_check)\n    {\n      error (0, 0,\n             _(\"the --ignore-missing option is meaningful only when \"\n               \"verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (status_only && !do_check)\n    {\n      error (0, 0,\n       _(\"the --status option is meaningful only when verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (warn && !do_check)\n    {\n      error (0, 0,\n       _(\"the --warn option is meaningful only when verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (quiet && !do_check)\n    {\n      error (0, 0,\n       _(\"the --quiet option is meaningful only when verifying checksums\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (strict & !do_check)\n   {\n     error (0, 0,\n        _(\"the --strict option is meaningful only when verifying checksums\"));\n     usage (EXIT_FAILURE);\n   }\n\n  if (!O_BINARY && binary < 0)\n    binary = 0;\n\n  char **operand_lim = argv + argc;\n  if (optind == argc)\n    *operand_lim++ = bad_cast (\"-\");\n  else if (1 < argc - optind && raw_digest)\n    error (EXIT_FAILURE, 0,\n           _(\"the --raw option is not supported with multiple files\"));\n\n  for (char **operandp = argv + optind; operandp < operand_lim; operandp++)\n    {\n      char *file = *operandp;\n      if (do_check)\n        ok &= digest_check (file);\n      else\n        {\n          int binary_file = binary;\n          bool missing;\n          uintmax_t length;\n\n          if (! digest_file (file, &binary_file, bin_buffer, &missing, &length))\n            ok = false;\n          else\n            {\n              DIGEST_OUT (file, binary_file, bin_buffer, raw_digest, prefix_tag,\n                          digest_delim, optind != argc, length);\n            }\n        }\n    }\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    error (EXIT_FAILURE, errno, _(\"standard input\"));\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}