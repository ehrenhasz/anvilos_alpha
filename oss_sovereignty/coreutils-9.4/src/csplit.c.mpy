{
  "module_name": "csplit.c",
  "hash_id": "9034f1bcd37691a6f4d787e6a07d5590aac612634fcb18357b8a014ce38ded75",
  "original_prompt": "Ingested from coreutils-9.4/src/csplit.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <getopt.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <stdckdint.h>\n\n#include \"system.h\"\n\n#include <regex.h>\n\n#include \"fd-reopen.h\"\n#include \"quote.h\"\n#include \"safe-read.h\"\n#include \"stdio--.h\"\n#include \"xdectoint.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"csplit\"\n\n#define AUTHORS \\\n  proper_name (\"Stuart Kemp\"), \\\n  proper_name (\"David MacKenzie\")\n\n \n#define DEFAULT_PREFIX\t\"xx\"\n\n \nstruct control\n{\n  intmax_t offset;\t\t \n  intmax_t lines_required;\t \n  intmax_t repeat;\t\t \n  int argnum;\t\t\t \n  bool repeat_forever;\t\t \n  bool ignore;\t\t\t \n  bool regexpr;\t\t\t \n  struct re_pattern_buffer re_compiled;\t \n};\n\n \n#define START_SIZE\t8191\n\n \n#define CTRL_SIZE\t80\n\n#ifdef DEBUG\n \n# define START_SIZE\t200\n# define CTRL_SIZE\t1\n#endif\n\n \nstruct cstring\n{\n  idx_t len;\n  char *str;\n};\n\n \nstruct line\n{\n  idx_t used;\t\t\t \n  idx_t insert_index;\t\t \n  idx_t retrieve_index;\t \n  struct cstring starts[CTRL_SIZE];  \n  struct line *next;\t\t \n};\n\n \nstruct buffer_record\n{\n  idx_t bytes_alloc;\t\t \n  idx_t bytes_used;\t\t \n  intmax_t start_line;\t\t \n  intmax_t first_available;\t \n  idx_t num_lines;\t\t \n  char *buffer;\t\t\t \n  struct line *line_start;\t \n  struct line *curr_line;\t \n  struct buffer_record *next;\n};\n\nstatic void close_output_file (void);\nstatic void create_output_file (void);\nstatic void delete_all_files (bool);\nstatic void save_line_to_file (const struct cstring *line);\n\n \nstatic struct buffer_record *head = nullptr;\n\n \nstatic char *hold_area = nullptr;\n\n \nstatic idx_t hold_count = 0;\n\n \nstatic intmax_t last_line_number = 0;\n\n \nstatic intmax_t current_line = 0;\n\n \nstatic bool have_read_eof = false;\n\n \nstatic char *volatile filename_space = nullptr;\n\n \nstatic char const *volatile prefix = nullptr;\n\n \nstatic char *volatile suffix = nullptr;\n\n \nstatic int volatile digits = 2;\n\n \nstatic int volatile files_created = 0;\n\n \nstatic intmax_t bytes_written;\n\n \nstatic FILE *output_stream = nullptr;\n\n \nstatic char *output_filename = nullptr;\n\n \nstatic char **global_argv;\n\n \nstatic bool suppress_count;\n\n \nstatic bool volatile remove_files;\n\n \nstatic bool elide_empty_files;\n\n \nstatic bool suppress_matched;\n\n \nstatic struct control *controls;\n\n \nstatic idx_t control_used;\n\n \nstatic sigset_t caught_signals;\n\n \nenum\n{\n  SUPPRESS_MATCHED_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const longopts[] =\n{\n  {\"digits\", required_argument, nullptr, 'n'},\n  {\"quiet\", no_argument, nullptr, 'q'},\n  {\"silent\", no_argument, nullptr, 's'},\n  {\"keep-files\", no_argument, nullptr, 'k'},\n  {\"elide-empty-files\", no_argument, nullptr, 'z'},\n  {\"prefix\", required_argument, nullptr, 'f'},\n  {\"suffix-format\", required_argument, nullptr, 'b'},\n  {\"suppress-matched\", no_argument, nullptr, SUPPRESS_MATCHED_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nstatic void\ncleanup (void)\n{\n  sigset_t oldset;\n\n  close_output_file ();\n\n  sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n  delete_all_files (false);\n  sigprocmask (SIG_SETMASK, &oldset, nullptr);\n}\n\nstatic _Noreturn void\ncleanup_fatal (void)\n{\n  cleanup ();\n  exit (EXIT_FAILURE);\n}\n\nextern void\nxalloc_die (void)\n{\n  error (0, 0, \"%s\", _(\"memory exhausted\"));\n  cleanup_fatal ();\n}\n\nstatic void\ninterrupt_handler (int sig)\n{\n  delete_all_files (true);\n  signal (sig, SIG_DFL);\n   \n  raise (sig);\n}\n\n \n\nstatic void\nsave_to_hold_area (char *start, idx_t num)\n{\n  free (hold_area);\n  hold_area = start;\n  hold_count = num;\n}\n\n \n\nstatic idx_t\nread_input (char *dest, idx_t max_n_bytes)\n{\n  idx_t bytes_read;\n\n  if (max_n_bytes == 0)\n    return 0;\n\n  bytes_read = safe_read (STDIN_FILENO, dest, max_n_bytes);\n\n  if (bytes_read == 0)\n    have_read_eof = true;\n\n  if (bytes_read == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"read error\"));\n      cleanup_fatal ();\n    }\n\n  return bytes_read;\n}\n\n \n\nstatic void\nclear_line_control (struct line *p)\n{\n  p->used = 0;\n  p->insert_index = 0;\n  p->retrieve_index = 0;\n}\n\n \n\nstatic struct line *\nnew_line_control (void)\n{\n  struct line *p = xmalloc (sizeof *p);\n\n  p->next = nullptr;\n  clear_line_control (p);\n\n  return p;\n}\n\n \n\nstatic void\nkeep_new_line (struct buffer_record *b, char *line_start, idx_t line_len)\n{\n  struct line *l;\n\n   \n  if (b->line_start == nullptr)\n    b->line_start = b->curr_line = new_line_control ();\n\n   \n  if (b->curr_line->used == CTRL_SIZE)\n    {\n      b->curr_line->next = new_line_control ();\n      b->curr_line = b->curr_line->next;\n    }\n\n  l = b->curr_line;\n\n   \n  l->starts[l->insert_index].str = line_start;\n  l->starts[l->insert_index].len = line_len;\n  l->used++;\n  l->insert_index++;\n}\n\n \n\nstatic idx_t\nrecord_line_starts (struct buffer_record *b)\n{\n  char *line_start;\t\t \n  idx_t lines;\t\t\t \n  idx_t line_length;\t\t \n\n  if (b->bytes_used == 0)\n    return 0;\n\n  lines = 0;\n  line_start = b->buffer;\n  char *buffer_end = line_start + b->bytes_used;\n  *buffer_end = '\\n';\n\n  while (true)\n    {\n      char *line_end = rawmemchr (line_start, '\\n');\n      if (line_end == buffer_end)\n        break;\n      line_length = line_end - line_start + 1;\n      keep_new_line (b, line_start, line_length);\n      line_start = line_end + 1;\n      lines++;\n    }\n\n   \n  idx_t bytes_left = buffer_end - line_start;\n  if (bytes_left)\n    {\n      if (have_read_eof)\n        {\n          keep_new_line (b, line_start, bytes_left);\n          lines++;\n        }\n      else\n        save_to_hold_area (ximemdup (line_start, bytes_left), bytes_left);\n    }\n\n  b->num_lines = lines;\n  b->first_available = b->start_line = last_line_number + 1;\n  last_line_number += lines;\n\n  return lines;\n}\n\n \n\nstatic ATTRIBUTE_DEALLOC (free_buffer, 1)\nstruct buffer_record *\nget_new_buffer (idx_t min_size)\n{\n  struct buffer_record *new_buffer = xmalloc (sizeof *new_buffer);\n  new_buffer->bytes_alloc = 0;\n  new_buffer->buffer = xpalloc (nullptr, &new_buffer->bytes_alloc, min_size,\n                                -1, 1);\n  new_buffer->bytes_used = 0;\n  new_buffer->start_line = new_buffer->first_available = last_line_number + 1;\n  new_buffer->num_lines = 0;\n  new_buffer->line_start = new_buffer->curr_line = nullptr;\n  new_buffer->next = nullptr;\n\n  return new_buffer;\n}\n\n \n\nstatic void\nsave_buffer (struct buffer_record *buf)\n{\n  struct buffer_record *p;\n\n  buf->next = nullptr;\n  buf->curr_line = buf->line_start;\n\n  if (head == nullptr)\n    head = buf;\n  else\n    {\n      for (p = head; p->next; p = p->next)\n          ;\n      p->next = buf;\n    }\n}\n\n \n\nstatic bool\nload_buffer (void)\n{\n  if (have_read_eof)\n    return false;\n\n   \n  idx_t bytes_wanted = MAX (START_SIZE, hold_count + 1);\n\n  while (true)\n    {\n      struct buffer_record *b = get_new_buffer (bytes_wanted);\n      idx_t bytes_alloc = b->bytes_alloc;\n      idx_t bytes_avail = bytes_alloc;\n      char *p = b->buffer;\n\n       \n      if (hold_count)\n        {\n          p = mempcpy (p, hold_area, hold_count);\n          b->bytes_used += hold_count;\n          bytes_avail -= hold_count;\n          hold_count = 0;\n        }\n\n      b->bytes_used += read_input (p, bytes_avail - 1);\n\n      if (record_line_starts (b) != 0)\n        {\n          save_buffer (b);\n          return true;\n        }\n\n      free_buffer (b);\n      if (have_read_eof)\n        return false;\n      if (ckd_add (&bytes_wanted, bytes_alloc, bytes_alloc >> 1))\n        xalloc_die ();\n    }\n}\n\n \n\nstatic intmax_t\nget_first_line_in_buffer (void)\n{\n  if (head == nullptr && !load_buffer ())\n    error (EXIT_FAILURE, errno, _(\"input disappeared\"));\n\n  return head->first_available;\n}\n\n \n\nstatic struct cstring *\nremove_line (void)\n{\n   \n  static struct buffer_record *prev_buf = nullptr;\n\n  struct cstring *line;\t\t \n  struct line *l;\t\t \n\n  if (prev_buf)\n    {\n      free_buffer (prev_buf);\n      prev_buf = nullptr;\n    }\n\n  if (head == nullptr && !load_buffer ())\n    return nullptr;\n\n  if (current_line < head->first_available)\n    current_line = head->first_available;\n\n  ++(head->first_available);\n\n  l = head->curr_line;\n\n  line = &l->starts[l->retrieve_index];\n\n   \n  if (++l->retrieve_index == l->used)\n    {\n       \n      head->curr_line = l->next;\n      if (head->curr_line == nullptr || head->curr_line->used == 0)\n        {\n           \n          prev_buf = head;\n          head = head->next;\n        }\n    }\n\n  return line;\n}\n\n \n\nstatic struct cstring *\nfind_line (intmax_t linenum)\n{\n  struct buffer_record *b;\n\n  if (head == nullptr && !load_buffer ())\n    return nullptr;\n\n  if (linenum < head->start_line)\n    return nullptr;\n\n  for (b = head;;)\n    {\n      if (linenum < b->start_line + b->num_lines)\n        {\n           \n          struct line *l;\n          idx_t offset;\t \n\n          l = b->line_start;\n          offset = linenum - b->start_line;\n           \n          while (offset >= CTRL_SIZE)\n            {\n              l = l->next;\n              offset -= CTRL_SIZE;\n            }\n          return &l->starts[offset];\n        }\n      if (b->next == nullptr && !load_buffer ())\n        return nullptr;\n      b = b->next;\t\t \n    }\n}\n\n \n\nstatic bool\nno_more_lines (void)\n{\n  return find_line (current_line + 1) == nullptr;\n}\n\n \n\nstatic void\nset_input_file (char const *name)\n{\n  if (! STREQ (name, \"-\") && fd_reopen (STDIN_FILENO, name, O_RDONLY, 0) < 0)\n    error (EXIT_FAILURE, errno, _(\"cannot open %s for reading\"),\n           quoteaf (name));\n}\n\n \n\nstatic void\nwrite_to_file (intmax_t last_line, bool ignore, int argnum)\n{\n  struct cstring *line;\n  intmax_t first_line;\t\t \n  intmax_t lines;\t\t \n  intmax_t i;\n\n  first_line = get_first_line_in_buffer ();\n\n  if (first_line > last_line)\n    {\n      error (0, 0, _(\"%s: line number out of range\"),\n             quote (global_argv[argnum]));\n      cleanup_fatal ();\n    }\n\n  lines = last_line - first_line;\n\n  for (i = 0; i < lines; i++)\n    {\n      line = remove_line ();\n      if (line == nullptr)\n        {\n          error (0, 0, _(\"%s: line number out of range\"),\n                 quote (global_argv[argnum]));\n          cleanup_fatal ();\n        }\n      if (!ignore)\n        save_line_to_file (line);\n    }\n}\n\n \n\nstatic void\ndump_rest_of_file (void)\n{\n  struct cstring *line;\n\n  while ((line = remove_line ()) != nullptr)\n    save_line_to_file (line);\n}\n\n \n\nstatic void\nhandle_line_error (const struct control *p, intmax_t repetition)\n{\n  char buf[INT_BUFSIZE_BOUND (intmax_t)];\n\n  fprintf (stderr, _(\"%s: %s: line number out of range\"),\n           program_name, quote (imaxtostr (p->lines_required, buf)));\n  if (repetition)\n    fprintf (stderr, _(\" on repetition %s\\n\"), imaxtostr (repetition, buf));\n  else\n    fprintf (stderr, \"\\n\");\n\n  cleanup_fatal ();\n}\n\n \n\nstatic void\nprocess_line_count (const struct control *p, intmax_t repetition)\n{\n  intmax_t linenum;\n  intmax_t last_line_to_save = p->lines_required * (repetition + 1);\n\n  create_output_file ();\n\n   \n  if (no_more_lines () && suppress_matched)\n    handle_line_error (p, repetition);\n\n  linenum = get_first_line_in_buffer ();\n  while (linenum++ < last_line_to_save)\n    {\n      struct cstring *line = remove_line ();\n      if (line == nullptr)\n        handle_line_error (p, repetition);\n      save_line_to_file (line);\n    }\n\n  close_output_file ();\n\n  if (suppress_matched)\n    remove_line ();\n\n   \n  if (no_more_lines () && !suppress_matched)\n    handle_line_error (p, repetition);\n}\n\nstatic void\nregexp_error (struct control *p, intmax_t repetition, bool ignore)\n{\n  fprintf (stderr, _(\"%s: %s: match not found\"),\n           program_name, quote (global_argv[p->argnum]));\n\n  if (repetition)\n    {\n      char buf[INT_BUFSIZE_BOUND (intmax_t)];\n      fprintf (stderr, _(\" on repetition %s\\n\"), imaxtostr (repetition, buf));\n    }\n  else\n    fprintf (stderr, \"\\n\");\n\n  if (!ignore)\n    {\n      dump_rest_of_file ();\n      close_output_file ();\n    }\n  cleanup_fatal ();\n}\n\n \n\nstatic void\nprocess_regexp (struct control *p, intmax_t repetition)\n{\n  struct cstring *line;\t\t \n  idx_t line_len;\t\t \n  intmax_t break_line;\t\t \n  bool ignore = p->ignore;\t \n  regoff_t ret;\n\n  if (!ignore)\n    create_output_file ();\n\n   \n\n  if (p->offset >= 0)\n    {\n      while (true)\n        {\n          line = find_line (++current_line);\n          if (line == nullptr)\n            {\n              if (p->repeat_forever)\n                {\n                  if (!ignore)\n                    {\n                      dump_rest_of_file ();\n                      close_output_file ();\n                    }\n                  exit (EXIT_SUCCESS);\n                }\n              else\n                regexp_error (p, repetition, ignore);\n            }\n          line_len = line->len;\n          if (line->str[line_len - 1] == '\\n')\n            line_len--;\n          ret = re_search (&p->re_compiled, line->str, line_len,\n                           0, line_len, nullptr);\n          if (ret == -2)\n            {\n              error (0, 0, _(\"error in regular expression search\"));\n              cleanup_fatal ();\n            }\n          if (ret == -1)\n            {\n              line = remove_line ();\n              if (!ignore)\n                save_line_to_file (line);\n            }\n          else\n            break;\n        }\n    }\n  else\n    {\n       \n      while (true)\n        {\n          line = find_line (++current_line);\n          if (line == nullptr)\n            {\n              if (p->repeat_forever)\n                {\n                  if (!ignore)\n                    {\n                      dump_rest_of_file ();\n                      close_output_file ();\n                    }\n                  exit (EXIT_SUCCESS);\n                }\n              else\n                regexp_error (p, repetition, ignore);\n            }\n          line_len = line->len;\n          if (line->str[line_len - 1] == '\\n')\n            line_len--;\n          ret = re_search (&p->re_compiled, line->str, line_len,\n                           0, line_len, nullptr);\n          if (ret == -2)\n            {\n              error (0, 0, _(\"error in regular expression search\"));\n              cleanup_fatal ();\n            }\n          if (ret != -1)\n            break;\n        }\n    }\n\n   \n  break_line = current_line + p->offset;\n\n  write_to_file (break_line, ignore, p->argnum);\n\n  if (!ignore)\n    close_output_file ();\n\n  if (p->offset > 0)\n    current_line = break_line;\n\n  if (suppress_matched)\n    remove_line ();\n}\n\n \n\nstatic void\nsplit_file (void)\n{\n  for (idx_t i = 0; i < control_used; i++)\n    {\n      intmax_t j;\n      if (controls[i].regexpr)\n        {\n          for (j = 0; (controls[i].repeat_forever\n                       || j <= controls[i].repeat); j++)\n            process_regexp (&controls[i], j);\n        }\n      else\n        {\n          for (j = 0; (controls[i].repeat_forever\n                       || j <= controls[i].repeat); j++)\n            process_line_count (&controls[i], j);\n        }\n    }\n\n  create_output_file ();\n  dump_rest_of_file ();\n  close_output_file ();\n}\n\n \n\nstatic char *\nmake_filename (int num)\n{\n  strcpy (filename_space, prefix);\n  if (suffix)\n    sprintf (filename_space + strlen (prefix), suffix, num);\n  else\n    sprintf (filename_space + strlen (prefix), \"%0*d\", digits, num);\n  return filename_space;\n}\n\n \n\nstatic void\ncreate_output_file (void)\n{\n  int nfiles = files_created;\n  bool fopen_ok;\n  int fopen_errno;\n\n  output_filename = make_filename (nfiles);\n\n  if (nfiles == INT_MAX)\n    {\n      fopen_ok = false;\n      fopen_errno = EOVERFLOW;\n    }\n  else\n    {\n       \n      sigset_t oldset;\n      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n      output_stream = fopen (output_filename, \"w\");\n      fopen_ok = (output_stream != nullptr);\n      fopen_errno = errno;\n      files_created = nfiles + fopen_ok;\n      sigprocmask (SIG_SETMASK, &oldset, nullptr);\n    }\n\n  if (! fopen_ok)\n    {\n      error (0, fopen_errno, \"%s\", quotef (output_filename));\n      cleanup_fatal ();\n    }\n  bytes_written = 0;\n}\n\n \n\nstatic void\ndelete_all_files (bool in_signal_handler)\n{\n  if (! remove_files)\n    return;\n\n  for (int i = files_created; 0 <= --i; )\n    {\n      char const *name = make_filename (i);\n      if (unlink (name) != 0 && errno != ENOENT && !in_signal_handler)\n        error (0, errno, \"%s\", quotef (name));\n    }\n\n  files_created = 0;\n}\n\n \n\nstatic void\nclose_output_file (void)\n{\n  if (output_stream)\n    {\n      if (ferror (output_stream))\n        {\n          error (0, 0, _(\"write error for %s\"), quoteaf (output_filename));\n          output_stream = nullptr;\n          cleanup_fatal ();\n        }\n      if (fclose (output_stream) != 0)\n        {\n          error (0, errno, \"%s\", quotef (output_filename));\n          output_stream = nullptr;\n          cleanup_fatal ();\n        }\n      if (bytes_written == 0 && elide_empty_files)\n        {\n          sigset_t oldset;\n          bool unlink_ok;\n          int unlink_errno;\n\n           \n          sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n          unlink_ok = (unlink (output_filename) == 0);\n          unlink_errno = errno;\n          files_created--;\n          sigprocmask (SIG_SETMASK, &oldset, nullptr);\n\n          if (! unlink_ok && unlink_errno != ENOENT)\n            error (0, unlink_errno, \"%s\", quotef (output_filename));\n        }\n      else\n        {\n          if (!suppress_count)\n            {\n              char buf[INT_BUFSIZE_BOUND (intmax_t)];\n              fprintf (stdout, \"%s\\n\", imaxtostr (bytes_written, buf));\n            }\n        }\n      output_stream = nullptr;\n    }\n}\n\n \n\nstatic void\nsave_line_to_file (const struct cstring *line)\n{\n  idx_t l = fwrite (line->str, sizeof (char), line->len, output_stream);\n  if (l != line->len)\n    {\n      error (0, errno, _(\"write error for %s\"), quoteaf (output_filename));\n      output_stream = nullptr;\n      cleanup_fatal ();\n    }\n  bytes_written += line->len;\n}\n\n \n\nstatic struct control *\nnew_control_record (void)\n{\n  static idx_t control_allocated = 0;  \n  struct control *p;\n\n  if (control_used == control_allocated)\n    controls = xpalloc (controls, &control_allocated, 1, -1, sizeof *controls);\n  p = &controls[control_used++];\n  p->regexpr = false;\n  p->repeat = 0;\n  p->repeat_forever = false;\n  p->lines_required = 0;\n  p->offset = 0;\n  return p;\n}\n\n \n\nstatic void\ncheck_for_offset (struct control *p, char const *str, char const *num)\n{\n  if (xstrtoimax (num, nullptr, 10, &p->offset, \"\") != LONGINT_OK)\n    error (EXIT_FAILURE, 0, _(\"%s: integer expected after delimiter\"),\n           quote (str));\n}\n\n \n\nstatic void\nparse_repeat_count (int argnum, struct control *p, char *str)\n{\n  char *end;\n\n  end = str + strlen (str) - 1;\n  if (*end != '}')\n    error (EXIT_FAILURE, 0, _(\"%s: '}' is required in repeat count\"),\n           quote (str));\n  *end = '\\0';\n\n  if (str + 1 == end - 1 && *(str + 1) == '*')\n    p->repeat_forever = true;\n  else\n    {\n      uintmax_t val;\n      if (xstrtoumax (str + 1, nullptr, 10, &val, \"\") != LONGINT_OK\n          || INTMAX_MAX < val)\n        {\n          error (EXIT_FAILURE, 0,\n                 _(\"%s}: integer required between '{' and '}'\"),\n                 quote (global_argv[argnum]));\n        }\n      p->repeat = val;\n    }\n\n  *end = '}';\n}\n\n \n\nstatic struct control *\nextract_regexp (int argnum, bool ignore, char const *str)\n{\n  idx_t len;\t\t\t \n  char delim = *str;\n  char const *closing_delim;\n  struct control *p;\n  char const *err;\n\n  closing_delim = strrchr (str + 1, delim);\n  if (closing_delim == nullptr)\n    error (EXIT_FAILURE, 0,\n           _(\"%s: closing delimiter '%c' missing\"), str, delim);\n\n  len = closing_delim - str - 1;\n  p = new_control_record ();\n  p->argnum = argnum;\n  p->ignore = ignore;\n\n  p->regexpr = true;\n  p->re_compiled.buffer = nullptr;\n  p->re_compiled.allocated = 0;\n  p->re_compiled.fastmap = xmalloc (UCHAR_MAX + 1);\n  p->re_compiled.translate = nullptr;\n  re_syntax_options =\n    RE_SYNTAX_POSIX_BASIC & ~RE_CONTEXT_INVALID_DUP & ~RE_NO_EMPTY_RANGES;\n  err = re_compile_pattern (str + 1, len, &p->re_compiled);\n  if (err)\n    {\n      error (0, 0, _(\"%s: invalid regular expression: %s\"), quote (str), err);\n      cleanup_fatal ();\n    }\n\n  if (closing_delim[1])\n    check_for_offset (p, str, closing_delim + 1);\n\n  return p;\n}\n\n \n\nstatic void\nparse_patterns (int argc, int start, char **argv)\n{\n  struct control *p;\t\t \n  static intmax_t last_val = 0;\n\n  for (int i = start; i < argc; i++)\n    {\n      if (*argv[i] == '/' || *argv[i] == '%')\n        {\n          p = extract_regexp (i, *argv[i] == '%', argv[i]);\n        }\n      else\n        {\n          p = new_control_record ();\n          p->argnum = i;\n\n          uintmax_t val;\n          if (xstrtoumax (argv[i], nullptr, 10, &val, \"\") != LONGINT_OK\n              || INTMAX_MAX < val)\n            error (EXIT_FAILURE, 0, _(\"%s: invalid pattern\"), quote (argv[i]));\n          if (val == 0)\n            error (EXIT_FAILURE, 0,\n                   _(\"%s: line number must be greater than zero\"), argv[i]);\n          if (val < last_val)\n            {\n              char buf[INT_BUFSIZE_BOUND (intmax_t)];\n              error (EXIT_FAILURE, 0,\n                     _(\"line number %s is smaller than preceding line number,\"\n                       \" %s\"),\n                     quote (argv[i]), imaxtostr (last_val, buf));\n            }\n\n          if (val == last_val)\n            error (0, 0,\n           _(\"warning: line number %s is the same as preceding line number\"),\n                   quote (argv[i]));\n\n          last_val = val;\n\n          p->lines_required = val;\n        }\n\n      if (i + 1 < argc && *argv[i + 1] == '{')\n        {\n           \n          i++;\n          parse_repeat_count (i, p, argv[i]);\n        }\n    }\n}\n\n\n\n \nenum { FLAG_THOUSANDS = 1, FLAG_ALTERNATIVE = 2 };\n\n \nstatic idx_t\nget_format_flags (char const *format, int *flags_ptr)\n{\n  int flags = 0;\n\n  for (idx_t count = 0; ; count++)\n    {\n      switch (format[count])\n        {\n        case '-':\n        case '0':\n          break;\n\n        case '\\'':\n          flags |= FLAG_THOUSANDS;\n          break;\n\n        case '#':\n          flags |= FLAG_ALTERNATIVE;\n          break;\n\n        default:\n          *flags_ptr = flags;\n          return count;\n        }\n    }\n}\n\n \nstatic void\ncheck_format_conv_type (char *format, int flags)\n{\n  unsigned char ch = *format;\n  int compatible_flags = FLAG_THOUSANDS;\n\n  switch (ch)\n    {\n    case 'd':\n    case 'i':\n      break;\n\n    case 'u':\n      *format = 'd';\n      break;\n\n    case 'o':\n    case 'x':\n    case 'X':\n      compatible_flags = FLAG_ALTERNATIVE;\n      break;\n\n    case 0:\n      error (EXIT_FAILURE, 0, _(\"missing conversion specifier in suffix\"));\n\n    default:\n      if (isprint (ch))\n        error (EXIT_FAILURE, 0,\n               _(\"invalid conversion specifier in suffix: %c\"), ch);\n      else\n        error (EXIT_FAILURE, 0,\n               _(\"invalid conversion specifier in suffix: \\\\%.3o\"), ch);\n    }\n\n  if (flags & ~ compatible_flags)\n    error (EXIT_FAILURE, 0,\n           _(\"invalid flags in conversion specification: %%%c%c\"),\n           (flags & ~ compatible_flags & FLAG_ALTERNATIVE ? '#' : '\\''), ch);\n}\n\n \nstatic idx_t\nmax_out (char *format)\n{\n  bool percent = false;\n\n  for (char *f = format; *f; f++)\n    if (*f == '%' && *++f != '%')\n      {\n        if (percent)\n          error (EXIT_FAILURE, 0,\n                 _(\"too many %% conversion specifications in suffix\"));\n        percent = true;\n        int flags;\n        f += get_format_flags (f, &flags);\n        while (ISDIGIT (*f))\n          f++;\n        if (*f == '.')\n          while (ISDIGIT (*++f))\n            continue;\n        check_format_conv_type (f, flags);\n      }\n\n  if (! percent)\n    error (EXIT_FAILURE, 0,\n           _(\"missing %% conversion specification in suffix\"));\n\n  int maxlen = snprintf (nullptr, 0, format, INT_MAX);\n  if (maxlen < 0)\n    xalloc_die ();\n  return maxlen;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  global_argv = argv;\n  controls = nullptr;\n  control_used = 0;\n  suppress_count = false;\n  remove_files = true;\n  suppress_matched = false;\n  prefix = DEFAULT_PREFIX;\n\n  while ((optc = getopt_long (argc, argv, \"f:b:kn:sqz\", longopts, nullptr))\n         != -1)\n    switch (optc)\n      {\n      case 'f':\n        prefix = optarg;\n        break;\n\n      case 'b':\n        suffix = optarg;\n        break;\n\n      case 'k':\n        remove_files = false;\n        break;\n\n      case 'n':\n        digits = xdectoimax (optarg, 0, MIN (INT_MAX, IDX_MAX), \"\",\n                             _(\"invalid number\"), 0);\n        break;\n\n      case 's':\n      case 'q':\n        suppress_count = true;\n        break;\n\n      case 'z':\n        elide_empty_files = true;\n        break;\n\n      case SUPPRESS_MATCHED_OPTION:\n        suppress_matched = true;\n        break;\n\n      case_GETOPT_HELP_CHAR;\n\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n      default:\n        usage (EXIT_FAILURE);\n      }\n\n  if (argc - optind < 2)\n    {\n      if (argc <= optind)\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  idx_t prefix_len = strlen (prefix);\n  idx_t max_digit_string_len\n    = (suffix\n       ? max_out (suffix)\n       : MAX (INT_STRLEN_BOUND (int), digits));\n  idx_t filename_size;\n  if (ckd_add (&filename_size, prefix_len, max_digit_string_len + 1))\n    xalloc_die ();\n  filename_space = ximalloc (filename_size);\n\n  set_input_file (argv[optind++]);\n\n  parse_patterns (argc, optind, argv);\n\n  {\n    int i;\n    static int const sig[] =\n      {\n         \n        SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n#ifdef SIGPOLL\n        SIGPOLL,\n#endif\n#ifdef SIGPROF\n        SIGPROF,\n#endif\n#ifdef SIGVTALRM\n        SIGVTALRM,\n#endif\n#ifdef SIGXCPU\n        SIGXCPU,\n#endif\n#ifdef SIGXFSZ\n        SIGXFSZ,\n#endif\n      };\n    enum { nsigs = ARRAY_CARDINALITY (sig) };\n\n    struct sigaction act;\n\n    sigemptyset (&caught_signals);\n    for (i = 0; i < nsigs; i++)\n      {\n        sigaction (sig[i], nullptr, &act);\n        if (act.sa_handler != SIG_IGN)\n          sigaddset (&caught_signals, sig[i]);\n      }\n\n    act.sa_handler = interrupt_handler;\n    act.sa_mask = caught_signals;\n    act.sa_flags = 0;\n\n    for (i = 0; i < nsigs; i++)\n      if (sigismember (&caught_signals, sig[i]))\n        sigaction (sig[i], &act, nullptr);\n  }\n\n  split_file ();\n\n  if (close (STDIN_FILENO) != 0)\n    {\n      error (0, errno, _(\"read error\"));\n      cleanup_fatal ();\n    }\n\n  return EXIT_SUCCESS;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... FILE PATTERN...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nOutput pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\\n\\\nand output byte counts of each piece to standard output.\\n\\\n\"), stdout);\n       fputs (_(\"\\\n\\n\\\nRead standard input if FILE is -\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\\n\\\n  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\\n\\\n  -k, --keep-files           do not remove output files on errors\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --suppress-matched     suppress the lines matching PATTERN\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -n, --digits=DIGITS        use specified number of digits instead of 2\\n\\\n  -s, --quiet, --silent      do not print counts of output file sizes\\n\\\n  -z, --elide-empty-files    suppress empty output files\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nEach PATTERN may be:\\n\\\n  INTEGER            copy up to but not including specified line number\\n\\\n  /REGEXP/[OFFSET]   copy up to but not including a matching line\\n\\\n  %REGEXP%[OFFSET]   skip to, but not including a matching line\\n\\\n  {INTEGER}          repeat the previous pattern specified number of times\\n\\\n  {*}                repeat the previous pattern as many times as possible\\n\\\n\\n\\\nA line OFFSET is an integer optionally preceded by '+' or '-'\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}