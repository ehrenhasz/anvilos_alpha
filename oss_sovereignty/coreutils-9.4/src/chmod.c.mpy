{
  "module_name": "chmod.c",
  "hash_id": "d83ca94a940ba39ecfa04b18a142362b5266bf85fbaf15eadab84c9f46b37410",
  "original_prompt": "Ingested from coreutils-9.4/src/chmod.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"dev-ino.h\"\n#include \"filemode.h\"\n#include \"ignore-value.h\"\n#include \"modechange.h\"\n#include \"quote.h\"\n#include \"root-dev-ino.h\"\n#include \"xfts.h\"\n\n \n#define PROGRAM_NAME \"chmod\"\n\n#define AUTHORS \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\nstruct change_status\n{\n  enum\n    {\n      CH_NO_STAT,\n      CH_FAILED,\n      CH_NOT_APPLIED,\n      CH_NO_CHANGE_REQUESTED,\n      CH_SUCCEEDED\n    }\n    status;\n  mode_t old_mode;\n  mode_t new_mode;\n};\n\nenum Verbosity\n{\n   \n  V_high,\n\n   \n  V_changes_only,\n\n   \n  V_off\n};\n\n \nstatic struct mode_change *change;\n\n \nstatic mode_t umask_value;\n\n \nstatic bool recurse;\n\n \nstatic bool force_silent;\n\n \nstatic bool diagnose_surprises;\n\n \nstatic enum Verbosity verbosity = V_off;\n\n \nstatic struct dev_ino *root_dev_ino;\n\n \nenum\n{\n  NO_PRESERVE_ROOT = CHAR_MAX + 1,\n  PRESERVE_ROOT,\n  REFERENCE_FILE_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"changes\", no_argument, nullptr, 'c'},\n  {\"recursive\", no_argument, nullptr, 'R'},\n  {\"no-preserve-root\", no_argument, nullptr, NO_PRESERVE_ROOT},\n  {\"preserve-root\", no_argument, nullptr, PRESERVE_ROOT},\n  {\"quiet\", no_argument, nullptr, 'f'},\n  {\"reference\", required_argument, nullptr, REFERENCE_FILE_OPTION},\n  {\"silent\", no_argument, nullptr, 'f'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nstatic bool\nmode_changed (int dir_fd, char const *file, char const *file_full_name,\n              mode_t old_mode, mode_t new_mode)\n{\n  if (new_mode & (S_ISUID | S_ISGID | S_ISVTX))\n    {\n       \n\n      struct stat new_stats;\n\n      if (fstatat (dir_fd, file, &new_stats, 0) != 0)\n        {\n          if (! force_silent)\n            error (0, errno, _(\"getting new attributes of %s\"),\n                   quoteaf (file_full_name));\n          return false;\n        }\n\n      new_mode = new_stats.st_mode;\n    }\n\n  return ((old_mode ^ new_mode) & CHMOD_MODE_BITS) != 0;\n}\n\n \n\nstatic void\ndescribe_change (char const *file, struct change_status const *ch)\n{\n  char perms[12];\t\t \n  char old_perms[12];\n  char const *fmt;\n  char const *quoted_file = quoteaf (file);\n\n  switch (ch->status)\n    {\n    case CH_NOT_APPLIED:\n      printf (_(\"neither symbolic link %s nor referent has been changed\\n\"),\n              quoted_file);\n      return;\n\n    case CH_NO_STAT:\n      printf (_(\"%s could not be accessed\\n\"), quoted_file);\n      return;\n\n    default:\n      break;\n  }\n\n  unsigned long int\n    old_m = ch->old_mode & CHMOD_MODE_BITS,\n    m = ch->new_mode & CHMOD_MODE_BITS;\n\n  strmode (ch->new_mode, perms);\n  perms[10] = '\\0';\t\t \n\n  strmode (ch->old_mode, old_perms);\n  old_perms[10] = '\\0';\t\t \n\n  switch (ch->status)\n    {\n    case CH_SUCCEEDED:\n      fmt = _(\"mode of %s changed from %04lo (%s) to %04lo (%s)\\n\");\n      break;\n    case CH_FAILED:\n      fmt = _(\"failed to change mode of %s from %04lo (%s) to %04lo (%s)\\n\");\n      break;\n    case CH_NO_CHANGE_REQUESTED:\n      fmt = _(\"mode of %s retained as %04lo (%s)\\n\");\n      printf (fmt, quoted_file, m, &perms[1]);\n      return;\n    default:\n      affirm (false);\n    }\n  printf (fmt, quoted_file, old_m, &old_perms[1], m, &perms[1]);\n}\n\n \n\nstatic bool\nprocess_file (FTS *fts, FTSENT *ent)\n{\n  char const *file_full_name = ent->fts_path;\n  char const *file = ent->fts_accpath;\n  const struct stat *file_stats = ent->fts_statp;\n  struct change_status ch = { 0, };\n  ch.status = CH_NO_STAT;\n\n  switch (ent->fts_info)\n    {\n    case FTS_DP:\n      return true;\n\n    case FTS_NS:\n       \n      if (ent->fts_level == 0 && ent->fts_number == 0)\n        {\n          ent->fts_number = 1;\n          fts_set (fts, ent, FTS_AGAIN);\n          return true;\n        }\n      if (! force_silent)\n        error (0, ent->fts_errno, _(\"cannot access %s\"),\n               quoteaf (file_full_name));\n      break;\n\n    case FTS_ERR:\n      if (! force_silent)\n        error (0, ent->fts_errno, \"%s\", quotef (file_full_name));\n      break;\n\n    case FTS_DNR:\n      if (! force_silent)\n        error (0, ent->fts_errno, _(\"cannot read directory %s\"),\n               quoteaf (file_full_name));\n      break;\n\n    case FTS_SLNONE:\n      if (! force_silent)\n        error (0, 0, _(\"cannot operate on dangling symlink %s\"),\n               quoteaf (file_full_name));\n      break;\n\n    case FTS_DC:\t\t \n      if (cycle_warning_required (fts, ent))\n        {\n          emit_cycle_warning (file_full_name);\n          return false;\n        }\n      FALLTHROUGH;\n    default:\n      ch.status = CH_NOT_APPLIED;\n      break;\n    }\n\n  if (ch.status == CH_NOT_APPLIED\n      && ROOT_DEV_INO_CHECK (root_dev_ino, file_stats))\n    {\n      ROOT_DEV_INO_WARN (file_full_name);\n       \n      fts_set (fts, ent, FTS_SKIP);\n       \n      ignore_value (fts_read (fts));\n      return false;\n    }\n\n  if (ch.status == CH_NOT_APPLIED && ! S_ISLNK (file_stats->st_mode))\n    {\n      ch.old_mode = file_stats->st_mode;\n      ch.new_mode = mode_adjust (ch.old_mode, S_ISDIR (ch.old_mode) != 0,\n                                 umask_value, change, nullptr);\n      if (chmodat (fts->fts_cwd_fd, file, ch.new_mode) == 0)\n        ch.status = CH_SUCCEEDED;\n      else\n        {\n          if (! force_silent)\n            error (0, errno, _(\"changing permissions of %s\"),\n                   quoteaf (file_full_name));\n          ch.status = CH_FAILED;\n        }\n    }\n\n  if (verbosity != V_off)\n    {\n      if (ch.status == CH_SUCCEEDED\n          && !mode_changed (fts->fts_cwd_fd, file, file_full_name,\n                            ch.old_mode, ch.new_mode))\n        ch.status = CH_NO_CHANGE_REQUESTED;\n\n      if (ch.status == CH_SUCCEEDED || verbosity == V_high)\n        describe_change (file_full_name, &ch);\n    }\n\n  if (CH_NO_CHANGE_REQUESTED <= ch.status && diagnose_surprises)\n    {\n      mode_t naively_expected_mode =\n        mode_adjust (ch.old_mode, S_ISDIR (ch.old_mode) != 0,\n                     0, change, nullptr);\n      if (ch.new_mode & ~naively_expected_mode)\n        {\n          char new_perms[12];\n          char naively_expected_perms[12];\n          strmode (ch.new_mode, new_perms);\n          strmode (naively_expected_mode, naively_expected_perms);\n          new_perms[10] = naively_expected_perms[10] = '\\0';\n          error (0, 0,\n                 _(\"%s: new permissions are %s, not %s\"),\n                 quotef (file_full_name),\n                 new_perms + 1, naively_expected_perms + 1);\n          ch.status = CH_FAILED;\n        }\n    }\n\n  if ( ! recurse)\n    fts_set (fts, ent, FTS_SKIP);\n\n  return CH_NOT_APPLIED <= ch.status;\n}\n\n \n\nstatic bool\nprocess_files (char **files, int bit_flags)\n{\n  bool ok = true;\n\n  FTS *fts = xfts_open (files, bit_flags, nullptr);\n\n  while (true)\n    {\n      FTSENT *ent;\n\n      ent = fts_read (fts);\n      if (ent == nullptr)\n        {\n          if (errno != 0)\n            {\n               \n              if (! force_silent)\n                error (0, errno, _(\"fts_read failed\"));\n              ok = false;\n            }\n          break;\n        }\n\n      ok &= process_file (fts, ent);\n    }\n\n  if (fts_close (fts) != 0)\n    {\n      error (0, errno, _(\"fts_close failed\"));\n      ok = false;\n    }\n\n  return ok;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... MODE[,MODE]... FILE...\\n\\\n  or:  %s [OPTION]... OCTAL-MODE FILE...\\n\\\n  or:  %s [OPTION]... --reference=RFILE FILE...\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\\nChange the mode of each FILE to MODE.\\n\\\nWith --reference, change the mode of each FILE to that of RFILE.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -c, --changes          like verbose but report only when a change is made\\n\\\n  -f, --silent, --quiet  suppress most error messages\\n\\\n  -v, --verbose          output a diagnostic for every file processed\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --no-preserve-root  do not treat '/' specially (the default)\\n\\\n      --preserve-root    fail to operate recursively on '/'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --reference=RFILE  use RFILE's mode instead of specifying MODE values.\\n\\\n                         RFILE is always dereferenced if a symbolic link.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -R, --recursive        change files and directories recursively\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nEach MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Parse the ASCII mode given on the command line into a linked list\n   of 'struct mode_change' and apply that to each file argument. */\n\nint\nmain (int argc, char **argv)\n{\n  char *mode = nullptr;\n  idx_t mode_len = 0;\n  idx_t mode_alloc = 0;\n  bool ok;\n  bool preserve_root = false;\n  char const *reference_file = nullptr;\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  recurse = force_silent = diagnose_surprises = false;\n\n  while ((c = getopt_long (argc, argv,\n                           (\"Rcfvr::w::x::X::s::t::u::g::o::a::,::+::=::\"\n                            \"0::1::2::3::4::5::6::7::\"),\n                           long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'r':\n        case 'w':\n        case 'x':\n        case 'X':\n        case 's':\n        case 't':\n        case 'u':\n        case 'g':\n        case 'o':\n        case 'a':\n        case ',':\n        case '+':\n        case '=':\n        case '0': case '1': case '2': case '3':\n        case '4': case '5': case '6': case '7':\n          /* Support non-portable uses like \"chmod -w\", but diagnose\n             surprises due to umask confusion.  Even though \"--\", \"--r\",\n             etc., are valid modes, there is no \"case '-'\" here since\n             getopt_long reserves leading \"--\" for long options.  */\n          {\n            /* Allocate a mode string (e.g., \"-rwx\") by concatenating\n               the argument containing this option.  If a previous mode\n               string was given, concatenate the previous string, a\n               comma, and the new string (e.g., \"-s,-rwx\").  */\n\n            char const *arg = argv[optind - 1];\n            idx_t arg_len = strlen (arg);\n            idx_t mode_comma_len = mode_len + !!mode_len;\n            idx_t new_mode_len = mode_comma_len + arg_len;\n            assume (0 <= new_mode_len);  /* Pacify GCC bug #109613.  */\n            if (mode_alloc <= new_mode_len)\n              mode = xpalloc (mode, &mode_alloc,\n                              new_mode_len + 1 - mode_alloc, -1, 1);\n            mode[mode_len] = ',';\n            memcpy (mode + mode_comma_len, arg, arg_len + 1);\n            mode_len = new_mode_len;\n\n            diagnose_surprises = true;\n          }\n          break;\n        case NO_PRESERVE_ROOT:\n          preserve_root = false;\n          break;\n        case PRESERVE_ROOT:\n          preserve_root = true;\n          break;\n        case REFERENCE_FILE_OPTION:\n          reference_file = optarg;\n          break;\n        case 'R':\n          recurse = true;\n          break;\n        case 'c':\n          verbosity = V_changes_only;\n          break;\n        case 'f':\n          force_silent = true;\n          break;\n        case 'v':\n          verbosity = V_high;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (reference_file)\n    {\n      if (mode)\n        {\n          error (0, 0, _(\"cannot combine mode and --reference options\"));\n          usage (EXIT_FAILURE);\n        }\n    }\n  else\n    {\n      if (!mode)\n        mode = argv[optind++];\n    }\n\n  if (optind >= argc)\n    {\n      if (!mode || mode != argv[optind - 1])\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (reference_file)\n    {\n      change = mode_create_from_ref (reference_file);\n      if (!change)\n        error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n               quoteaf (reference_file));\n    }\n  else\n    {\n      change = mode_compile (mode);\n      if (!change)\n        {\n          error (0, 0, _(\"invalid mode: %s\"), quote (mode));\n          usage (EXIT_FAILURE);\n        }\n      umask_value = umask (0);\n    }\n\n  if (recurse && preserve_root)\n    {\n      static struct dev_ino dev_ino_buf;\n      root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n      if (root_dev_ino == nullptr)\n        error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n               quoteaf (\"/\"));\n    }\n  else\n    {\n      root_dev_ino = nullptr;\n    }\n\n  ok = process_files (argv + optind,\n                      FTS_COMFOLLOW | FTS_PHYSICAL | FTS_DEFER_STAT);\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}