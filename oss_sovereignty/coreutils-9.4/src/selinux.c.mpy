{
  "module_name": "selinux.c",
  "hash_id": "a54fc927d4ae95e149dff026743f91e92cd553d36bbe06a7d496ad33a7ba6405",
  "original_prompt": "Ingested from coreutils-9.4/src/selinux.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <selinux/label.h>\n#include <selinux/context.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"canonicalize.h\"\n#include \"xfts.h\"\n#include \"selinux.h\"\n\n#if HAVE_SELINUX_LABEL_H\n\n# if ! HAVE_MODE_TO_SECURITY_CLASS\n \nstatic security_class_t\nmode_to_security_class (mode_t m)\n{\n\n  if (S_ISREG (m))\n    return string_to_security_class (\"file\");\n  if (S_ISDIR (m))\n    return string_to_security_class (\"dir\");\n  if (S_ISCHR (m))\n    return string_to_security_class (\"chr_file\");\n  if (S_ISBLK (m))\n    return string_to_security_class (\"blk_file\");\n  if (S_ISFIFO (m))\n    return string_to_security_class (\"fifo_file\");\n  if (S_ISLNK (m))\n    return string_to_security_class (\"lnk_file\");\n  if (S_ISSOCK (m))\n    return string_to_security_class (\"sock_file\");\n\n  errno = EINVAL;\n  return 0;\n}\n# endif\n\n \n\nstatic int\ncomputecon (char const *path, mode_t mode, char **con)\n{\n  char *scon = nullptr;\n  char *tcon = nullptr;\n  security_class_t tclass;\n  int rc = -1;\n\n  char *dir = dir_name (path);\n  if (!dir)\n    goto quit;\n  if (getcon (&scon) < 0)\n    goto quit;\n  if (getfilecon (dir, &tcon) < 0)\n    goto quit;\n  tclass = mode_to_security_class (mode);\n  if (!tclass)\n    goto quit;\n  rc = security_compute_create (scon, tcon, tclass, con);\n\n quit:;\n  int err = errno;\n  free (dir);\n  freecon (scon);\n  freecon (tcon);\n  errno = err;\n  return rc;\n}\n\n \nint\ndefaultcon (struct selabel_handle *selabel_handle,\n            char const *path, mode_t mode)\n{\n  int rc = -1;\n  char *scon = nullptr;\n  char *tcon = nullptr;\n  context_t scontext = 0, tcontext = 0;\n  char const *contype;\n  char const *constr;\n  char *newpath = nullptr;\n\n  if (! IS_ABSOLUTE_FILE_NAME (path))\n    {\n       \n      newpath = canonicalize_filename_mode (path, CAN_MISSING);\n      if (! newpath)\n        goto quit;\n      path = newpath;\n    }\n\n  if (selabel_lookup (selabel_handle, &scon, path, mode) < 0)\n    {\n       \n      if (errno == ENOENT)\n        errno = ENODATA;\n      goto quit;\n    }\n  if (computecon (path, mode, &tcon) < 0)\n    goto quit;\n  if (!(scontext = context_new (scon)))\n    goto quit;\n  if (!(tcontext = context_new (tcon)))\n    goto quit;\n\n  if (!(contype = context_type_get (scontext)))\n    goto quit;\n  if (context_type_set (tcontext, contype))\n    goto quit;\n  if (!(constr = context_str (tcontext)))\n    goto quit;\n\n  rc = setfscreatecon (constr);\n\n quit:;\n  int err = errno;\n  context_free (scontext);\n  context_free (tcontext);\n  freecon (scon);\n  freecon (tcon);\n  free (newpath);\n  errno = err;\n  return rc;\n}\n\n \nstatic int\nrestorecon_private (struct selabel_handle *selabel_handle, char const *path)\n{\n  int rc = -1;\n  struct stat sb;\n  char *scon = nullptr;\n  char *tcon = nullptr;\n  context_t scontext = 0, tcontext = 0;\n  char const *contype;\n  char const *constr;\n  int fd;\n\n  if (!selabel_handle)\n    {\n      if (getfscreatecon (&tcon) < 0)\n        return rc;\n      if (!tcon)\n        {\n          errno = ENODATA;\n          return rc;\n        }\n      rc = lsetfilecon (path, tcon);\n      int err = errno;\n      freecon (tcon);\n      errno = err;\n      return rc;\n    }\n\n  fd = open (path, O_RDONLY | O_NOFOLLOW);\n  if (fd == -1 && (errno != ELOOP))\n    goto quit;\n\n  if (fd != -1)\n    {\n      if (fstat (fd, &sb) < 0)\n        goto quit;\n    }\n  else\n    {\n      if (lstat (path, &sb) < 0)\n        goto quit;\n    }\n\n  if (selabel_lookup (selabel_handle, &scon, path, sb.st_mode) < 0)\n    {\n       \n      if (errno == ENOENT)\n        errno = ENODATA;\n      goto quit;\n    }\n  if (!(scontext = context_new (scon)))\n    goto quit;\n\n  if (fd != -1)\n    {\n      if (fgetfilecon (fd, &tcon) < 0)\n        goto quit;\n    }\n  else\n    {\n      if (lgetfilecon (path, &tcon) < 0)\n        goto quit;\n    }\n\n  if (!(tcontext = context_new (tcon)))\n    goto quit;\n\n  if (!(contype = context_type_get (scontext)))\n    goto quit;\n  if (context_type_set (tcontext, contype))\n    goto quit;\n  if (!(constr = context_str (tcontext)))\n    goto quit;\n\n  if (fd != -1)\n    rc = fsetfilecon (fd, constr);\n  else\n    rc = lsetfilecon (path, constr);\n\n quit:;\n  int err = errno;\n  if (fd != -1)\n    close (fd);\n  context_free (scontext);\n  context_free (tcontext);\n  freecon (scon);\n  freecon (tcon);\n  errno = err;\n  return rc;\n}\n\n \nbool\nrestorecon (struct selabel_handle *selabel_handle,\n            char const *path, bool recurse)\n{\n  char *newpath = nullptr;\n\n  if (! IS_ABSOLUTE_FILE_NAME (path))\n    {\n       \n      newpath = canonicalize_filename_mode (path, CAN_MISSING);\n      if (! newpath)\n        return false;\n      path = newpath;\n    }\n\n  if (! recurse)\n    {\n      bool ok = restorecon_private (selabel_handle, path) != -1;\n      int err = errno;\n      free (newpath);\n      errno = err;\n      return ok;\n    }\n\n  char const *ftspath[2] = { path, nullptr };\n  FTS *fts = xfts_open ((char *const *) ftspath, FTS_PHYSICAL, nullptr);\n\n  int err = 0;\n  for (FTSENT *ent; (ent = fts_read (fts)); )\n    if (restorecon_private (selabel_handle, fts->fts_path) < 0)\n      err = errno;\n\n  if (errno != 0)\n    err = errno;\n\n  if (fts_close (fts) != 0)\n    err = errno;\n\n  free (newpath);\n  return !err;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}