{
  "module_name": "ls.c",
  "hash_id": "647cc2b6f4f7ed619dcb4d285a742812708ea7af9c420c0a6782e3894822e1e2",
  "original_prompt": "Ingested from coreutils-9.4/src/ls.c",
  "human_readable_source": " \n\n \n\n \n\n#include <config.h>\n#include <sys/types.h>\n\n#include <termios.h>\n#if HAVE_STROPTS_H\n# include <stropts.h>\n#endif\n#include <sys/ioctl.h>\n\n#ifdef WINSIZE_IN_PTEM\n# include <sys/stream.h>\n# include <sys/ptem.h>\n#endif\n\n#include <stdio.h>\n#include <setjmp.h>\n#include <pwd.h>\n#include <getopt.h>\n#include <signal.h>\n#include <selinux/selinux.h>\n#include <wchar.h>\n\n#if HAVE_LANGINFO_CODESET\n# include <langinfo.h>\n#endif\n\n \n#ifndef SA_NOCLDSTOP\n# define SA_NOCLDSTOP 0\n# define sigprocmask(How, Set, Oset)  \n# define sigset_t int\n# if ! HAVE_SIGINTERRUPT\n#  define siginterrupt(sig, flag)  \n# endif\n#endif\n\n \n#ifndef SA_RESTART\n# define SA_RESTART 0\n#endif\n\n#include \"system.h\"\n#include <fnmatch.h>\n\n#include \"acl.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"c-strcase.h\"\n#include \"dev-ino.h\"\n#include \"filenamecat.h\"\n#include \"hard-locale.h\"\n#include \"hash.h\"\n#include \"human.h\"\n#include \"filemode.h\"\n#include \"filevercmp.h\"\n#include \"idcache.h\"\n#include \"ls.h\"\n#include \"mbswidth.h\"\n#include \"mpsort.h\"\n#include \"obstack.h\"\n#include \"quote.h\"\n#include \"smack.h\"\n#include \"stat-size.h\"\n#include \"stat-time.h\"\n#include \"strftime.h\"\n#include \"xdectoint.h\"\n#include \"xstrtol.h\"\n#include \"xstrtol-error.h\"\n#include \"areadlink.h\"\n#include \"mbsalign.h\"\n#include \"dircolors.h\"\n#include \"xgethostname.h\"\n#include \"c-ctype.h\"\n#include \"canonicalize.h\"\n#include \"statx.h\"\n\n \n\n#ifndef READDIR_LIES_ABOUT_MOUNTPOINT_D_INO\n# define READDIR_LIES_ABOUT_MOUNTPOINT_D_INO 1\n#endif\n\n#if READDIR_LIES_ABOUT_MOUNTPOINT_D_INO\n# define RELIABLE_D_INO(dp) NOT_AN_INODE_NUMBER\n#else\n# define RELIABLE_D_INO(dp) D_INO (dp)\n#endif\n\n#if ! HAVE_STRUCT_STAT_ST_AUTHOR\n# define st_author st_uid\n#endif\n\nenum filetype\n  {\n    unknown,\n    fifo,\n    chardev,\n    directory,\n    blockdev,\n    normal,\n    symbolic_link,\n    sock,\n    whiteout,\n    arg_directory\n  };\n\n \nstatic char const filetype_letter[] = \"?pcdb-lswd\";\n\n \nstatic_assert (sizeof filetype_letter - 1 == arg_directory + 1);\n\n#define FILETYPE_INDICATORS\t\t\t\t\\\n  {\t\t\t\t\t\t\t\\\n    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,\t\\\n    C_LINK, C_SOCK, C_FILE, C_DIR\t\t\t\\\n  }\n\nenum acl_type\n  {\n    ACL_T_NONE,\n    ACL_T_LSM_CONTEXT_ONLY,\n    ACL_T_YES\n  };\n\nstruct fileinfo\n  {\n     \n    char *name;\n\n     \n    char *linkname;\n\n     \n    char *absolute_name;\n\n    struct stat stat;\n\n    enum filetype filetype;\n\n     \n    mode_t linkmode;\n\n     \n    char *scontext;\n\n    bool stat_ok;\n\n     \n    bool linkok;\n\n     \n    enum acl_type acl_type;\n\n     \n    bool has_capability;\n\n     \n    int quoted;\n\n     \n    size_t width;\n  };\n\n#define LEN_STR_PAIR(s) sizeof (s) - 1, s\n\n \n\nstruct bin_str\n  {\n    size_t len;\t\t\t \n    char const *string;\t\t \n  };\n\n#if ! HAVE_TCGETPGRP\n# define tcgetpgrp(Fd) 0\n#endif\n\nstatic size_t quote_name (char const *name,\n                          struct quoting_options const *options,\n                          int needs_general_quoting,\n                          const struct bin_str *color,\n                          bool allow_pad, struct obstack *stack,\n                          char const *absolute_name);\nstatic size_t quote_name_buf (char **inbuf, size_t bufsize, char *name,\n                              struct quoting_options const *options,\n                              int needs_general_quoting, size_t *width,\n                              bool *pad);\nstatic int decode_switches (int argc, char **argv);\nstatic bool file_ignored (char const *name);\nstatic uintmax_t gobble_file (char const *name, enum filetype type,\n                              ino_t inode, bool command_line_arg,\n                              char const *dirname);\nstatic const struct bin_str * get_color_indicator (const struct fileinfo *f,\n                                                   bool symlink_target);\nstatic bool print_color_indicator (const struct bin_str *ind);\nstatic void put_indicator (const struct bin_str *ind);\nstatic void add_ignore_pattern (char const *pattern);\nstatic void attach (char *dest, char const *dirname, char const *name);\nstatic void clear_files (void);\nstatic void extract_dirs_from_files (char const *dirname,\n                                     bool command_line_arg);\nstatic void get_link_name (char const *filename, struct fileinfo *f,\n                           bool command_line_arg);\nstatic void indent (size_t from, size_t to);\nstatic size_t calculate_columns (bool by_columns);\nstatic void print_current_files (void);\nstatic void print_dir (char const *name, char const *realname,\n                       bool command_line_arg);\nstatic size_t print_file_name_and_frills (const struct fileinfo *f,\n                                          size_t start_col);\nstatic void print_horizontal (void);\nstatic int format_user_width (uid_t u);\nstatic int format_group_width (gid_t g);\nstatic void print_long_format (const struct fileinfo *f);\nstatic void print_many_per_line (void);\nstatic size_t print_name_with_quoting (const struct fileinfo *f,\n                                       bool symlink_target,\n                                       struct obstack *stack,\n                                       size_t start_col);\nstatic void prep_non_filename_text (void);\nstatic bool print_type_indicator (bool stat_ok, mode_t mode,\n                                  enum filetype type);\nstatic void print_with_separator (char sep);\nstatic void queue_directory (char const *name, char const *realname,\n                             bool command_line_arg);\nstatic void sort_files (void);\nstatic void parse_ls_color (void);\n\nstatic int getenv_quoting_style (void);\n\nstatic size_t quote_name_width (char const *name,\n                                struct quoting_options const *options,\n                                int needs_general_quoting);\n\n \nenum { INITIAL_TABLE_SIZE = 30 };\n\n \nstatic Hash_table *active_dir_set;\n\n#define LOOP_DETECT (!!active_dir_set)\n\n \n\n \nstatic struct fileinfo *cwd_file;\n\n \nstatic size_t cwd_n_alloc;\n\n \nstatic size_t cwd_n_used;\n\n \nstatic bool cwd_some_quoted;\n\n \nstatic bool align_variable_outer_quotes;\n\n \nstatic void **sorted_file;\nstatic size_t sorted_file_alloc;\n\n \n\nstatic bool color_symlink_as_referent;\n\nstatic char const *hostname;\n\n \nstatic mode_t\nfile_or_link_mode (struct fileinfo const *file)\n{\n  return (color_symlink_as_referent && file->linkok\n          ? file->linkmode : file->stat.st_mode);\n}\n\n\n \n\nstruct pending\n  {\n    char *name;\n     \n    char *realname;\n    bool command_line_arg;\n    struct pending *next;\n  };\n\nstatic struct pending *pending_dirs;\n\n \n\nstatic struct timespec current_time;\n\nstatic bool print_scontext;\nstatic char UNKNOWN_SECURITY_CONTEXT[] = \"?\";\n\n \n\nstatic bool any_has_acl;\n\n \n\nstatic int inode_number_width;\nstatic int block_size_width;\nstatic int nlink_width;\nstatic int scontext_width;\nstatic int owner_width;\nstatic int group_width;\nstatic int author_width;\nstatic int major_device_number_width;\nstatic int minor_device_number_width;\nstatic int file_size_width;\n\n \n\n \n\nenum format\n  {\n    long_format,\t\t \n    one_per_line,\t\t \n    many_per_line,\t\t \n    horizontal,\t\t\t \n    with_commas\t\t\t \n  };\n\nstatic enum format format;\n\n \nenum time_style\n  {\n    full_iso_time_style,\t \n    long_iso_time_style,\t \n    iso_time_style,\t\t \n    locale_time_style\t\t \n  };\n\nstatic char const *const time_style_args[] =\n{\n  \"full-iso\", \"long-iso\", \"iso\", \"locale\", nullptr\n};\nstatic enum time_style const time_style_types[] =\n{\n  full_iso_time_style, long_iso_time_style, iso_time_style,\n  locale_time_style\n};\nARGMATCH_VERIFY (time_style_args, time_style_types);\n\n \n\nenum time_type\n  {\n    time_mtime = 0,\t\t \n    time_ctime,\t\t\t \n    time_atime,\t\t\t \n    time_btime,                  \n    time_numtypes\t\t \n  };\n\nstatic enum time_type time_type;\n\n \n\nenum sort_type\n  {\n    sort_name = 0,\t\t \n    sort_extension,\t\t \n    sort_width,\n    sort_size,\t\t\t \n    sort_version,\t\t \n    sort_time,\t\t\t \n    sort_none,\t\t\t \n    sort_numtypes\t\t \n  };\n\nstatic enum sort_type sort_type;\n\n \n\nstatic bool sort_reverse;\n\n \n\nstatic bool print_owner = true;\n\n \n\nstatic bool print_author;\n\n \n\nstatic bool print_group = true;\n\n \n\nstatic bool numeric_ids;\n\n \n\nstatic bool print_block_size;\n\n \nstatic int human_output_opts;\n\n \nstatic uintmax_t output_block_size;\n\n \nstatic int file_human_output_opts;\nstatic uintmax_t file_output_block_size = 1;\n\n \nstatic bool dired;\n\n \n\nenum indicator_style\n  {\n    none = 0,\t \n    slash,\t \n    file_type,\t \n    classify\t \n  };\n\nstatic enum indicator_style indicator_style;\n\n \nstatic char const *const indicator_style_args[] =\n{\n  \"none\", \"slash\", \"file-type\", \"classify\", nullptr\n};\nstatic enum indicator_style const indicator_style_types[] =\n{\n  none, slash, file_type, classify\n};\nARGMATCH_VERIFY (indicator_style_args, indicator_style_types);\n\n \n\nstatic bool print_with_color;\n\nstatic bool print_hyperlink;\n\n \n\nstatic bool used_color = false;\n\nenum when_type\n  {\n    when_never,\t\t \n    when_always,\t \n    when_if_tty\t\t \n  };\n\nenum Dereference_symlink\n  {\n    DEREF_UNDEFINED = 0,\t\t \n    DEREF_NEVER,\n    DEREF_COMMAND_LINE_ARGUMENTS,\t \n    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,\t \n    DEREF_ALWAYS\t\t\t \n  };\n\nenum indicator_no\n  {\n    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,\n    C_FIFO, C_SOCK,\n    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,\n    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,\n    C_CLR_TO_EOL\n  };\n\nstatic char const *const indicator_name[]=\n  {\n    \"lc\", \"rc\", \"ec\", \"rs\", \"no\", \"fi\", \"di\", \"ln\", \"pi\", \"so\",\n    \"bd\", \"cd\", \"mi\", \"or\", \"ex\", \"do\", \"su\", \"sg\", \"st\",\n    \"ow\", \"tw\", \"ca\", \"mh\", \"cl\", nullptr\n  };\n\nstruct color_ext_type\n  {\n    struct bin_str ext;\t\t \n    struct bin_str seq;\t\t \n    bool   exact_match;\t\t \n    struct color_ext_type *next;\t \n  };\n\nstatic struct bin_str color_indicator[] =\n  {\n    { LEN_STR_PAIR (\"\\033[\") },\t\t \n    { LEN_STR_PAIR (\"m\") },\t\t \n    { 0, nullptr },\t\t\t \n    { LEN_STR_PAIR (\"0\") },\t\t \n    { 0, nullptr },\t\t\t \n    { 0, nullptr },\t\t\t \n    { LEN_STR_PAIR (\"01;34\") },\t\t \n    { LEN_STR_PAIR (\"01;36\") },\t\t \n    { LEN_STR_PAIR (\"33\") },\t\t \n    { LEN_STR_PAIR (\"01;35\") },\t\t \n    { LEN_STR_PAIR (\"01;33\") },\t\t \n    { LEN_STR_PAIR (\"01;33\") },\t\t \n    { 0, nullptr },\t\t\t \n    { 0, nullptr },\t\t\t \n    { LEN_STR_PAIR (\"01;32\") },\t\t \n    { LEN_STR_PAIR (\"01;35\") },\t\t \n    { LEN_STR_PAIR (\"37;41\") },\t\t \n    { LEN_STR_PAIR (\"30;43\") },\t\t \n    { LEN_STR_PAIR (\"37;44\") },\t\t \n    { LEN_STR_PAIR (\"34;42\") },\t\t \n    { LEN_STR_PAIR (\"30;42\") },\t\t \n    { 0, nullptr },\t\t\t \n    { 0, nullptr },\t\t\t \n    { LEN_STR_PAIR (\"\\033[K\") },\t \n  };\n\n \nstatic struct color_ext_type *color_ext_list = nullptr;\n\n \nstatic char *color_buf;\n\n \n\nstatic bool check_symlink_mode;\n\n \n\nstatic bool print_inode;\n\n \n\nstatic enum Dereference_symlink dereference;\n\n \n\nstatic bool recursive;\n\n \n\nstatic bool immediate_dirs;\n\n \n\nstatic bool directories_first;\n\n \n\nstatic enum\n{\n   \n  IGNORE_DEFAULT = 0,\n\n   \n  IGNORE_DOT_AND_DOTDOT,\n\n   \n  IGNORE_MINIMAL\n} ignore_mode;\n\n \n\nstruct ignore_pattern\n  {\n    char const *pattern;\n    struct ignore_pattern *next;\n  };\n\nstatic struct ignore_pattern *ignore_patterns;\n\n \nstatic struct ignore_pattern *hide_patterns;\n\n \nstatic bool qmark_funny_chars;\n\n \n\nstatic struct quoting_options *filename_quoting_options;\nstatic struct quoting_options *dirname_quoting_options;\n\n \nstatic size_t tabsize;\n\n \n\nstatic bool print_dir_name;\n\n \n\nstatic size_t line_length;\n\n \n\nstatic timezone_t localtz;\n\n \n\nstatic bool format_needs_stat;\n\n \n\nstatic bool format_needs_type;\n\n \n\nenum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };\n\n \n\nstatic char const *long_time_format[2] =\n  {\n     \n     \n    N_(\"%b %e  %Y\"),\n     \n     \n    N_(\"%b %e %H:%M\")\n  };\n\n \n\nstatic sigset_t caught_signals;\n\n \n\nstatic sig_atomic_t volatile interrupt_signal;\n\n \n\nstatic sig_atomic_t volatile stop_signal_count;\n\n \n\nstatic int exit_status;\n\n \nenum\n  {\n     \n    LS_MINOR_PROBLEM = 1,\n\n     \n    LS_FAILURE = 2\n  };\n\n \nenum\n{\n  AUTHOR_OPTION = CHAR_MAX + 1,\n  BLOCK_SIZE_OPTION,\n  COLOR_OPTION,\n  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,\n  FILE_TYPE_INDICATOR_OPTION,\n  FORMAT_OPTION,\n  FULL_TIME_OPTION,\n  GROUP_DIRECTORIES_FIRST_OPTION,\n  HIDE_OPTION,\n  HYPERLINK_OPTION,\n  INDICATOR_STYLE_OPTION,\n  QUOTING_STYLE_OPTION,\n  SHOW_CONTROL_CHARS_OPTION,\n  SI_OPTION,\n  SORT_OPTION,\n  TIME_OPTION,\n  TIME_STYLE_OPTION,\n  ZERO_OPTION,\n};\n\nstatic struct option const long_options[] =\n{\n  {\"all\", no_argument, nullptr, 'a'},\n  {\"escape\", no_argument, nullptr, 'b'},\n  {\"directory\", no_argument, nullptr, 'd'},\n  {\"dired\", no_argument, nullptr, 'D'},\n  {\"full-time\", no_argument, nullptr, FULL_TIME_OPTION},\n  {\"group-directories-first\", no_argument, nullptr,\n   GROUP_DIRECTORIES_FIRST_OPTION},\n  {\"human-readable\", no_argument, nullptr, 'h'},\n  {\"inode\", no_argument, nullptr, 'i'},\n  {\"kibibytes\", no_argument, nullptr, 'k'},\n  {\"numeric-uid-gid\", no_argument, nullptr, 'n'},\n  {\"no-group\", no_argument, nullptr, 'G'},\n  {\"hide-control-chars\", no_argument, nullptr, 'q'},\n  {\"reverse\", no_argument, nullptr, 'r'},\n  {\"size\", no_argument, nullptr, 's'},\n  {\"width\", required_argument, nullptr, 'w'},\n  {\"almost-all\", no_argument, nullptr, 'A'},\n  {\"ignore-backups\", no_argument, nullptr, 'B'},\n  {\"classify\", optional_argument, nullptr, 'F'},\n  {\"file-type\", no_argument, nullptr, FILE_TYPE_INDICATOR_OPTION},\n  {\"si\", no_argument, nullptr, SI_OPTION},\n  {\"dereference-command-line\", no_argument, nullptr, 'H'},\n  {\"dereference-command-line-symlink-to-dir\", no_argument, nullptr,\n   DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION},\n  {\"hide\", required_argument, nullptr, HIDE_OPTION},\n  {\"ignore\", required_argument, nullptr, 'I'},\n  {\"indicator-style\", required_argument, nullptr, INDICATOR_STYLE_OPTION},\n  {\"dereference\", no_argument, nullptr, 'L'},\n  {\"literal\", no_argument, nullptr, 'N'},\n  {\"quote-name\", no_argument, nullptr, 'Q'},\n  {\"quoting-style\", required_argument, nullptr, QUOTING_STYLE_OPTION},\n  {\"recursive\", no_argument, nullptr, 'R'},\n  {\"format\", required_argument, nullptr, FORMAT_OPTION},\n  {\"show-control-chars\", no_argument, nullptr, SHOW_CONTROL_CHARS_OPTION},\n  {\"sort\", required_argument, nullptr, SORT_OPTION},\n  {\"tabsize\", required_argument, nullptr, 'T'},\n  {\"time\", required_argument, nullptr, TIME_OPTION},\n  {\"time-style\", required_argument, nullptr, TIME_STYLE_OPTION},\n  {\"zero\", no_argument, nullptr, ZERO_OPTION},\n  {\"color\", optional_argument, nullptr, COLOR_OPTION},\n  {\"hyperlink\", optional_argument, nullptr, HYPERLINK_OPTION},\n  {\"block-size\", required_argument, nullptr, BLOCK_SIZE_OPTION},\n  {\"context\", no_argument, 0, 'Z'},\n  {\"author\", no_argument, nullptr, AUTHOR_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nstatic char const *const format_args[] =\n{\n  \"verbose\", \"long\", \"commas\", \"horizontal\", \"across\",\n  \"vertical\", \"single-column\", nullptr\n};\nstatic enum format const format_types[] =\n{\n  long_format, long_format, with_commas, horizontal, horizontal,\n  many_per_line, one_per_line\n};\nARGMATCH_VERIFY (format_args, format_types);\n\nstatic char const *const sort_args[] =\n{\n  \"none\", \"time\", \"size\", \"extension\", \"version\", \"width\", nullptr\n};\nstatic enum sort_type const sort_types[] =\n{\n  sort_none, sort_time, sort_size, sort_extension, sort_version, sort_width\n};\nARGMATCH_VERIFY (sort_args, sort_types);\n\nstatic char const *const time_args[] =\n{\n  \"atime\", \"access\", \"use\",\n  \"ctime\", \"status\",\n  \"mtime\", \"modification\",\n  \"birth\", \"creation\",\n  nullptr\n};\nstatic enum time_type const time_types[] =\n{\n  time_atime, time_atime, time_atime,\n  time_ctime, time_ctime,\n  time_mtime, time_mtime,\n  time_btime, time_btime,\n};\nARGMATCH_VERIFY (time_args, time_types);\n\nstatic char const *const when_args[] =\n{\n   \n  \"always\", \"yes\", \"force\",\n  \"never\", \"no\", \"none\",\n  \"auto\", \"tty\", \"if-tty\", nullptr\n};\nstatic enum when_type const when_types[] =\n{\n  when_always, when_always, when_always,\n  when_never, when_never, when_never,\n  when_if_tty, when_if_tty, when_if_tty\n};\nARGMATCH_VERIFY (when_args, when_types);\n\n \nstruct column_info\n{\n  bool valid_len;\n  size_t line_len;\n  size_t *col_arr;\n};\n\n \nstatic struct column_info *column_info;\n\n \nstatic size_t max_idx;\n\n \nenum { MIN_COLUMN_WIDTH = 3 };\n\n\n \nstatic off_t dired_pos;\n\nstatic void\ndired_outbyte (char c)\n{\n  dired_pos++;\n  putchar (c);\n}\n\n \nstatic void\ndired_outbuf (char const *s, size_t s_len)\n{\n  dired_pos += s_len;\n  fwrite (s, sizeof *s, s_len, stdout);\n}\n\n \nstatic void\ndired_outstring (char const *s)\n{\n  dired_outbuf (s, strlen (s));\n}\n\nstatic void\ndired_indent (void)\n{\n  if (dired)\n    dired_outstring (\"  \");\n}\n\n \nstatic struct obstack dired_obstack;\n\n \nstatic struct obstack subdired_obstack;\n\n \nstatic void\npush_current_dired_pos (struct obstack *obs)\n{\n  if (dired)\n    obstack_grow (obs, &dired_pos, sizeof dired_pos);\n}\n\n \nstatic struct obstack dev_ino_obstack;\n\n \nstatic void\ndev_ino_push (dev_t dev, ino_t ino)\n{\n  void *vdi;\n  struct dev_ino *di;\n  int dev_ino_size = sizeof *di;\n  obstack_blank (&dev_ino_obstack, dev_ino_size);\n  vdi = obstack_next_free (&dev_ino_obstack);\n  di = vdi;\n  di--;\n  di->st_dev = dev;\n  di->st_ino = ino;\n}\n\n \nstatic struct dev_ino\ndev_ino_pop (void)\n{\n  void *vdi;\n  struct dev_ino *di;\n  int dev_ino_size = sizeof *di;\n  affirm (dev_ino_size <= obstack_object_size (&dev_ino_obstack));\n  obstack_blank_fast (&dev_ino_obstack, -dev_ino_size);\n  vdi = obstack_next_free (&dev_ino_obstack);\n  di = vdi;\n  return *di;\n}\n\nstatic void\nassert_matching_dev_ino (char const *name, struct dev_ino di)\n{\n  MAYBE_UNUSED struct stat sb;\n  assure (0 <= stat (name, &sb));\n  assure (sb.st_dev == di.st_dev);\n  assure (sb.st_ino == di.st_ino);\n}\n\nstatic char eolbyte = '\\n';\n\n \n\nstatic void\ndired_dump_obstack (char const *prefix, struct obstack *os)\n{\n  size_t n_pos;\n\n  n_pos = obstack_object_size (os) / sizeof (dired_pos);\n  if (n_pos > 0)\n    {\n      off_t *pos = obstack_finish (os);\n      fputs (prefix, stdout);\n      for (size_t i = 0; i < n_pos; i++)\n        {\n          intmax_t p = pos[i];\n          printf (\" %\"PRIdMAX, p);\n        }\n      putchar ('\\n');\n    }\n}\n\n \nstatic struct timespec\nget_stat_btime (struct stat const *st)\n{\n  struct timespec btimespec;\n\n#if HAVE_STATX && defined STATX_INO\n  btimespec = get_stat_mtime (st);\n#else\n  btimespec = get_stat_birthtime (st);\n#endif\n\n  return btimespec;\n}\n\n#if HAVE_STATX && defined STATX_INO\nATTRIBUTE_PURE\nstatic unsigned int\ntime_type_to_statx (void)\n{\n  switch (time_type)\n    {\n    case time_ctime:\n      return STATX_CTIME;\n    case time_mtime:\n      return STATX_MTIME;\n    case time_atime:\n      return STATX_ATIME;\n    case time_btime:\n      return STATX_BTIME;\n    default:\n      unreachable ();\n    }\n    return 0;\n}\n\nATTRIBUTE_PURE\nstatic unsigned int\ncalc_req_mask (void)\n{\n  unsigned int mask = STATX_MODE;\n\n  if (print_inode)\n    mask |= STATX_INO;\n\n  if (print_block_size)\n    mask |= STATX_BLOCKS;\n\n  if (format == long_format) {\n    mask |= STATX_NLINK | STATX_SIZE | time_type_to_statx ();\n    if (print_owner || print_author)\n      mask |= STATX_UID;\n    if (print_group)\n      mask |= STATX_GID;\n  }\n\n  switch (sort_type)\n    {\n    case sort_none:\n    case sort_name:\n    case sort_version:\n    case sort_extension:\n    case sort_width:\n      break;\n    case sort_time:\n      mask |= time_type_to_statx ();\n      break;\n    case sort_size:\n      mask |= STATX_SIZE;\n      break;\n    default:\n      unreachable ();\n    }\n\n  return mask;\n}\n\nstatic int\ndo_statx (int fd, char const *name, struct stat *st, int flags,\n          unsigned int mask)\n{\n  struct statx stx;\n  bool want_btime = mask & STATX_BTIME;\n  int ret = statx (fd, name, flags | AT_NO_AUTOMOUNT, mask, &stx);\n  if (ret >= 0)\n    {\n      statx_to_stat (&stx, st);\n       \n      if (want_btime)\n        {\n          if (stx.stx_mask & STATX_BTIME)\n            st->st_mtim = statx_timestamp_to_timespec (stx.stx_btime);\n          else\n            st->st_mtim.tv_sec = st->st_mtim.tv_nsec = -1;\n        }\n    }\n\n  return ret;\n}\n\nstatic int\ndo_stat (char const *name, struct stat *st)\n{\n  return do_statx (AT_FDCWD, name, st, 0, calc_req_mask ());\n}\n\nstatic int\ndo_lstat (char const *name, struct stat *st)\n{\n  return do_statx (AT_FDCWD, name, st, AT_SYMLINK_NOFOLLOW, calc_req_mask ());\n}\n\nstatic int\nstat_for_mode (char const *name, struct stat *st)\n{\n  return do_statx (AT_FDCWD, name, st, 0, STATX_MODE);\n}\n\n \nstatic int\nstat_for_ino (char const *name, struct stat *st)\n{\n  return do_statx (AT_FDCWD, name, st, 0, STATX_INO);\n}\n\nstatic int\nfstat_for_ino (int fd, struct stat *st)\n{\n  return do_statx (fd, \"\", st, AT_EMPTY_PATH, STATX_INO);\n}\n#else\nstatic int\ndo_stat (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}\n\nstatic int\ndo_lstat (char const *name, struct stat *st)\n{\n  return lstat (name, st);\n}\n\nstatic int\nstat_for_mode (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}\n\nstatic int\nstat_for_ino (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}\n\nstatic int\nfstat_for_ino (int fd, struct stat *st)\n{\n  return fstat (fd, st);\n}\n#endif\n\n \n\nATTRIBUTE_PURE\nstatic char const *\nfirst_percent_b (char const *fmt)\n{\n  for (; *fmt; fmt++)\n    if (fmt[0] == '%')\n      switch (fmt[1])\n        {\n        case 'b': return fmt;\n        case '%': fmt++; break;\n        }\n  return nullptr;\n}\n\nstatic char RFC3986[256];\nstatic void\nfile_escape_init (void)\n{\n  for (int i = 0; i < 256; i++)\n    RFC3986[i] |= c_isalnum (i) || i == '~' || i == '-' || i == '.' || i == '_';\n}\n\n \n\n \nenum { MAX_MON_WIDTH = 12 };\n \nenum { ABFORMAT_SIZE = 128 };\nstatic char abformat[2][12][ABFORMAT_SIZE];\n \nstatic bool use_abformat;\n\n \n\nstatic bool\nabmon_init (char abmon[12][ABFORMAT_SIZE])\n{\n#ifndef HAVE_NL_LANGINFO\n  return false;\n#else\n  size_t required_mon_width = MAX_MON_WIDTH;\n  size_t curr_max_width;\n  do\n    {\n      curr_max_width = required_mon_width;\n      required_mon_width = 0;\n      for (int i = 0; i < 12; i++)\n        {\n          size_t width = curr_max_width;\n          char const *abbr = nl_langinfo (ABMON_1 + i);\n          if (strchr (abbr, '%'))\n            return false;\n          mbs_align_t alignment = isdigit (to_uchar (*abbr))\n                                  ? MBS_ALIGN_RIGHT : MBS_ALIGN_LEFT;\n          size_t req = mbsalign (abbr, abmon[i], ABFORMAT_SIZE,\n                                 &width, alignment, 0);\n          if (! (req < ABFORMAT_SIZE))\n            return false;\n          required_mon_width = MAX (required_mon_width, width);\n        }\n    }\n  while (curr_max_width > required_mon_width);\n\n  return true;\n#endif\n}\n\n \n\nstatic void\nabformat_init (void)\n{\n  char const *pb[2];\n  for (int recent = 0; recent < 2; recent++)\n    pb[recent] = first_percent_b (long_time_format[recent]);\n  if (! (pb[0] || pb[1]))\n    return;\n\n  char abmon[12][ABFORMAT_SIZE];\n  if (! abmon_init (abmon))\n    return;\n\n  for (int recent = 0; recent < 2; recent++)\n    {\n      char const *fmt = long_time_format[recent];\n      for (int i = 0; i < 12; i++)\n        {\n          char *nfmt = abformat[recent][i];\n          int nbytes;\n\n          if (! pb[recent])\n            nbytes = snprintf (nfmt, ABFORMAT_SIZE, \"%s\", fmt);\n          else\n            {\n              if (! (pb[recent] - fmt <= MIN (ABFORMAT_SIZE, INT_MAX)))\n                return;\n              int prefix_len = pb[recent] - fmt;\n              nbytes = snprintf (nfmt, ABFORMAT_SIZE, \"%.*s%s%s\",\n                                 prefix_len, fmt, abmon[i], pb[recent] + 2);\n            }\n\n          if (! (0 <= nbytes && nbytes < ABFORMAT_SIZE))\n            return;\n        }\n    }\n\n  use_abformat = true;\n}\n\nstatic size_t\ndev_ino_hash (void const *x, size_t table_size)\n{\n  struct dev_ino const *p = x;\n  return (uintmax_t) p->st_ino % table_size;\n}\n\nstatic bool\ndev_ino_compare (void const *x, void const *y)\n{\n  struct dev_ino const *a = x;\n  struct dev_ino const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n\nstatic void\ndev_ino_free (void *x)\n{\n  free (x);\n}\n\n \n\nstatic bool\nvisit_dir (dev_t dev, ino_t ino)\n{\n  struct dev_ino *ent;\n  struct dev_ino *ent_from_table;\n  bool found_match;\n\n  ent = xmalloc (sizeof *ent);\n  ent->st_ino = ino;\n  ent->st_dev = dev;\n\n   \n  ent_from_table = hash_insert (active_dir_set, ent);\n\n  if (ent_from_table == nullptr)\n    {\n       \n      xalloc_die ();\n    }\n\n  found_match = (ent_from_table != ent);\n\n  if (found_match)\n    {\n       \n      free (ent);\n    }\n\n  return found_match;\n}\n\nstatic void\nfree_pending_ent (struct pending *p)\n{\n  free (p->name);\n  free (p->realname);\n  free (p);\n}\n\nstatic bool\nis_colored (enum indicator_no type)\n{\n  size_t len = color_indicator[type].len;\n  char const *s = color_indicator[type].string;\n  return ! (len == 0\n            || (len == 1 && STRNCMP_LIT (s, \"0\") == 0)\n            || (len == 2 && STRNCMP_LIT (s, \"00\") == 0));\n}\n\nstatic void\nrestore_default_color (void)\n{\n  put_indicator (&color_indicator[C_LEFT]);\n  put_indicator (&color_indicator[C_RIGHT]);\n}\n\nstatic void\nset_normal_color (void)\n{\n  if (print_with_color && is_colored (C_NORM))\n    {\n      put_indicator (&color_indicator[C_LEFT]);\n      put_indicator (&color_indicator[C_NORM]);\n      put_indicator (&color_indicator[C_RIGHT]);\n    }\n}\n\n \n\nstatic void\nsighandler (int sig)\n{\n  if (! SA_NOCLDSTOP)\n    signal (sig, SIG_IGN);\n  if (! interrupt_signal)\n    interrupt_signal = sig;\n}\n\n \n\nstatic void\nstophandler (int sig)\n{\n  if (! SA_NOCLDSTOP)\n    signal (sig, stophandler);\n  if (! interrupt_signal)\n    stop_signal_count++;\n}\n\n \n\nstatic void\nprocess_signals (void)\n{\n  while (interrupt_signal || stop_signal_count)\n    {\n      int sig;\n      int stops;\n      sigset_t oldset;\n\n      if (used_color)\n        restore_default_color ();\n      fflush (stdout);\n\n      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n\n       \n      sig = interrupt_signal;\n      stops = stop_signal_count;\n\n       \n      if (stops)\n        {\n          stop_signal_count = stops - 1;\n          sig = SIGSTOP;\n        }\n      else\n        signal (sig, SIG_DFL);\n\n       \n      raise (sig);\n      sigprocmask (SIG_SETMASK, &oldset, nullptr);\n\n       \n    }\n}\n\n \n\nstatic void\nsignal_setup (bool init)\n{\n   \n  static int const sig[] =\n    {\n       \n      SIGTSTP,\n\n       \n      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n#ifdef SIGPOLL\n      SIGPOLL,\n#endif\n#ifdef SIGPROF\n      SIGPROF,\n#endif\n#ifdef SIGVTALRM\n      SIGVTALRM,\n#endif\n#ifdef SIGXCPU\n      SIGXCPU,\n#endif\n#ifdef SIGXFSZ\n      SIGXFSZ,\n#endif\n    };\n  enum { nsigs = ARRAY_CARDINALITY (sig) };\n\n#if ! SA_NOCLDSTOP\n  static bool caught_sig[nsigs];\n#endif\n\n  int j;\n\n  if (init)\n    {\n#if SA_NOCLDSTOP\n      struct sigaction act;\n\n      sigemptyset (&caught_signals);\n      for (j = 0; j < nsigs; j++)\n        {\n          sigaction (sig[j], nullptr, &act);\n          if (act.sa_handler != SIG_IGN)\n            sigaddset (&caught_signals, sig[j]);\n        }\n\n      act.sa_mask = caught_signals;\n      act.sa_flags = SA_RESTART;\n\n      for (j = 0; j < nsigs; j++)\n        if (sigismember (&caught_signals, sig[j]))\n          {\n            act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;\n            sigaction (sig[j], &act, nullptr);\n          }\n#else\n      for (j = 0; j < nsigs; j++)\n        {\n          caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);\n          if (caught_sig[j])\n            {\n              signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);\n              siginterrupt (sig[j], 0);\n            }\n        }\n#endif\n    }\n  else  \n    {\n#if SA_NOCLDSTOP\n      for (j = 0; j < nsigs; j++)\n        if (sigismember (&caught_signals, sig[j]))\n          signal (sig[j], SIG_DFL);\n#else\n      for (j = 0; j < nsigs; j++)\n        if (caught_sig[j])\n          signal (sig[j], SIG_DFL);\n#endif\n    }\n}\n\nstatic void\nsignal_init (void)\n{\n  signal_setup (true);\n}\n\nstatic void\nsignal_restore (void)\n{\n  signal_setup (false);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int i;\n  struct pending *thispend;\n  int n_files;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (LS_FAILURE);\n  atexit (close_stdout);\n\n  static_assert (ARRAY_CARDINALITY (color_indicator) + 1\n                 == ARRAY_CARDINALITY (indicator_name));\n\n  exit_status = EXIT_SUCCESS;\n  print_dir_name = true;\n  pending_dirs = nullptr;\n\n  current_time.tv_sec = TYPE_MINIMUM (time_t);\n  current_time.tv_nsec = -1;\n\n  i = decode_switches (argc, argv);\n\n  if (print_with_color)\n    parse_ls_color ();\n\n   \n\n  if (print_with_color)\n    {\n       \n      tabsize = 0;\n    }\n\n  if (directories_first)\n    check_symlink_mode = true;\n  else if (print_with_color)\n    {\n       \n      if (is_colored (C_ORPHAN)\n          || (is_colored (C_EXEC) && color_symlink_as_referent)\n          || (is_colored (C_MISSING) && format == long_format))\n        check_symlink_mode = true;\n    }\n\n  if (dereference == DEREF_UNDEFINED)\n    dereference = ((immediate_dirs\n                    || indicator_style == classify\n                    || format == long_format)\n                   ? DEREF_NEVER\n                   : DEREF_COMMAND_LINE_SYMLINK_TO_DIR);\n\n   \n  if (recursive)\n    {\n      active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, nullptr,\n                                        dev_ino_hash,\n                                        dev_ino_compare,\n                                        dev_ino_free);\n      if (active_dir_set == nullptr)\n        xalloc_die ();\n\n      obstack_init (&dev_ino_obstack);\n    }\n\n  localtz = tzalloc (getenv (\"TZ\"));\n\n  format_needs_stat = sort_type == sort_time || sort_type == sort_size\n    || format == long_format\n    || print_scontext\n    || print_block_size;\n  format_needs_type = (! format_needs_stat\n                       && (recursive\n                           || print_with_color\n                           || indicator_style != none\n                           || directories_first));\n\n  if (dired)\n    {\n      obstack_init (&dired_obstack);\n      obstack_init (&subdired_obstack);\n    }\n\n  if (print_hyperlink)\n    {\n      file_escape_init ();\n\n      hostname = xgethostname ();\n       \n      if (! hostname)\n        hostname = \"\";\n    }\n\n  cwd_n_alloc = 100;\n  cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);\n  cwd_n_used = 0;\n\n  clear_files ();\n\n  n_files = argc - i;\n\n  if (n_files <= 0)\n    {\n      if (immediate_dirs)\n        gobble_file (\".\", directory, NOT_AN_INODE_NUMBER, true, \"\");\n      else\n        queue_directory (\".\", nullptr, true);\n    }\n  else\n    do\n      gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, \"\");\n    while (i < argc);\n\n  if (cwd_n_used)\n    {\n      sort_files ();\n      if (!immediate_dirs)\n        extract_dirs_from_files (nullptr, true);\n       \n    }\n\n   \n  if (cwd_n_used)\n    {\n      print_current_files ();\n      if (pending_dirs)\n        dired_outbyte ('\\n');\n    }\n  else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)\n    print_dir_name = false;\n\n  while (pending_dirs)\n    {\n      thispend = pending_dirs;\n      pending_dirs = pending_dirs->next;\n\n      if (LOOP_DETECT)\n        {\n          if (thispend->name == nullptr)\n            {\n               \n              struct dev_ino di = dev_ino_pop ();\n              struct dev_ino *found = hash_remove (active_dir_set, &di);\n              if (false)\n                assert_matching_dev_ino (thispend->realname, di);\n              affirm (found);\n              dev_ino_free (found);\n              free_pending_ent (thispend);\n              continue;\n            }\n        }\n\n      print_dir (thispend->name, thispend->realname,\n                 thispend->command_line_arg);\n\n      free_pending_ent (thispend);\n      print_dir_name = true;\n    }\n\n  if (print_with_color && used_color)\n    {\n      int j;\n\n       \n      if (!(color_indicator[C_LEFT].len == 2\n            && memcmp (color_indicator[C_LEFT].string, \"\\033[\", 2) == 0\n            && color_indicator[C_RIGHT].len == 1\n            && color_indicator[C_RIGHT].string[0] == 'm'))\n        restore_default_color ();\n\n      fflush (stdout);\n\n      signal_restore ();\n\n       \n      for (j = stop_signal_count; j; j--)\n        raise (SIGSTOP);\n      j = interrupt_signal;\n      if (j)\n        raise (j);\n    }\n\n  if (dired)\n    {\n       \n      dired_dump_obstack (\"//DIRED//\", &dired_obstack);\n      dired_dump_obstack (\"//SUBDIRED//\", &subdired_obstack);\n      printf (\"//DIRED-OPTIONS// --quoting-style=%s\\n\",\n              quoting_style_args[get_quoting_style (filename_quoting_options)]);\n    }\n\n  if (LOOP_DETECT)\n    {\n      assure (hash_get_n_entries (active_dir_set) == 0);\n      hash_free (active_dir_set);\n    }\n\n  return exit_status;\n}\n\n \n\nstatic ptrdiff_t\ndecode_line_length (char const *spec)\n{\n  uintmax_t val;\n\n   \n  switch (xstrtoumax (spec, nullptr, 0, &val, \"\"))\n    {\n    case LONGINT_OK:\n      return val <= MIN (PTRDIFF_MAX, SIZE_MAX) ? val : 0;\n\n    case LONGINT_OVERFLOW:\n      return 0;\n\n    default:\n      return -1;\n    }\n}\n\n \n\nstatic bool\nstdout_isatty (void)\n{\n  static signed char out_tty = -1;\n  if (out_tty < 0)\n    out_tty = isatty (STDOUT_FILENO);\n  assume (out_tty == 0 || out_tty == 1);\n  return out_tty;\n}\n\n \n\nstatic int\ndecode_switches (int argc, char **argv)\n{\n  char *time_style_option = nullptr;\n\n   \n  bool kibibytes_specified = false;\n  int format_opt = -1;\n  int hide_control_chars_opt = -1;\n  int quoting_style_opt = -1;\n  int sort_opt = -1;\n  ptrdiff_t tabsize_opt = -1;\n  ptrdiff_t width_opt = -1;\n\n  while (true)\n    {\n      int oi = -1;\n      int c = getopt_long (argc, argv,\n                           \"abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1\",\n                           long_options, &oi);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 'a':\n          ignore_mode = IGNORE_MINIMAL;\n          break;\n\n        case 'b':\n          quoting_style_opt = escape_quoting_style;\n          break;\n\n        case 'c':\n          time_type = time_ctime;\n          break;\n\n        case 'd':\n          immediate_dirs = true;\n          break;\n\n        case 'f':\n           \n          ignore_mode = IGNORE_MINIMAL;\n          sort_opt = sort_none;\n          if (format_opt == long_format)\n            format_opt = -1;\n          print_with_color = false;\n          print_hyperlink = false;\n          print_block_size = false;\n          break;\n\n        case FILE_TYPE_INDICATOR_OPTION:  \n          indicator_style = file_type;\n          break;\n\n        case 'g':\n          format_opt = long_format;\n          print_owner = false;\n          break;\n\n        case 'h':\n          file_human_output_opts = human_output_opts =\n            human_autoscale | human_SI | human_base_1024;\n          file_output_block_size = output_block_size = 1;\n          break;\n\n        case 'i':\n          print_inode = true;\n          break;\n\n        case 'k':\n          kibibytes_specified = true;\n          break;\n\n        case 'l':\n          format_opt = long_format;\n          break;\n\n        case 'm':\n          format_opt = with_commas;\n          break;\n\n        case 'n':\n          numeric_ids = true;\n          format_opt = long_format;\n          break;\n\n        case 'o':   \n          format_opt = long_format;\n          print_group = false;\n          break;\n\n        case 'p':\n          indicator_style = slash;\n          break;\n\n        case 'q':\n          hide_control_chars_opt = true;\n          break;\n\n        case 'r':\n          sort_reverse = true;\n          break;\n\n        case 's':\n          print_block_size = true;\n          break;\n\n        case 't':\n          sort_opt = sort_time;\n          break;\n\n        case 'u':\n          time_type = time_atime;\n          break;\n\n        case 'v':\n          sort_opt = sort_version;\n          break;\n\n        case 'w':\n          width_opt = decode_line_length (optarg);\n          if (width_opt < 0)\n            error (LS_FAILURE, 0, \"%s: %s\", _(\"invalid line width\"),\n                   quote (optarg));\n          break;\n\n        case 'x':\n          format_opt = horizontal;\n          break;\n\n        case 'A':\n          ignore_mode = IGNORE_DOT_AND_DOTDOT;\n          break;\n\n        case 'B':\n          add_ignore_pattern (\"*~\");\n          add_ignore_pattern (\".*~\");\n          break;\n\n        case 'C':\n          format_opt = many_per_line;\n          break;\n\n        case 'D':\n          dired = true;\n          break;\n\n        case 'F':\n          {\n            int i;\n            if (optarg)\n              i = XARGMATCH (\"--classify\", optarg, when_args, when_types);\n            else\n               \n              i = when_always;\n\n            if (i == when_always || (i == when_if_tty && stdout_isatty ()))\n              indicator_style = classify;\n            break;\n          }\n\n        case 'G':\t\t \n          print_group = false;\n          break;\n\n        case 'H':\n          dereference = DEREF_COMMAND_LINE_ARGUMENTS;\n          break;\n\n        case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:\n          dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;\n          break;\n\n        case 'I':\n          add_ignore_pattern (optarg);\n          break;\n\n        case 'L':\n          dereference = DEREF_ALWAYS;\n          break;\n\n        case 'N':\n          quoting_style_opt = literal_quoting_style;\n          break;\n\n        case 'Q':\n          quoting_style_opt = c_quoting_style;\n          break;\n\n        case 'R':\n          recursive = true;\n          break;\n\n        case 'S':\n          sort_opt = sort_size;\n          break;\n\n        case 'T':\n          tabsize_opt = xnumtoumax (optarg, 0, 0, MIN (PTRDIFF_MAX, SIZE_MAX),\n                                    \"\", _(\"invalid tab size\"), LS_FAILURE);\n          break;\n\n        case 'U':\n          sort_opt = sort_none;\n          break;\n\n        case 'X':\n          sort_opt = sort_extension;\n          break;\n\n        case '1':\n           \n          if (format_opt != long_format)\n            format_opt = one_per_line;\n          break;\n\n        case AUTHOR_OPTION:\n          print_author = true;\n          break;\n\n        case HIDE_OPTION:\n          {\n            struct ignore_pattern *hide = xmalloc (sizeof *hide);\n            hide->pattern = optarg;\n            hide->next = hide_patterns;\n            hide_patterns = hide;\n          }\n          break;\n\n        case SORT_OPTION:\n          sort_opt = XARGMATCH (\"--sort\", optarg, sort_args, sort_types);\n          break;\n\n        case GROUP_DIRECTORIES_FIRST_OPTION:\n          directories_first = true;\n          break;\n\n        case TIME_OPTION:\n          time_type = XARGMATCH (\"--time\", optarg, time_args, time_types);\n          break;\n\n        case FORMAT_OPTION:\n          format_opt = XARGMATCH (\"--format\", optarg, format_args,\n                                  format_types);\n          break;\n\n        case FULL_TIME_OPTION:\n          format_opt = long_format;\n          time_style_option = bad_cast (\"full-iso\");\n          break;\n\n        case COLOR_OPTION:\n          {\n            int i;\n            if (optarg)\n              i = XARGMATCH (\"--color\", optarg, when_args, when_types);\n            else\n               \n              i = when_always;\n\n            print_with_color = (i == when_always\n                                || (i == when_if_tty && stdout_isatty ()));\n            break;\n          }\n\n        case HYPERLINK_OPTION:\n          {\n            int i;\n            if (optarg)\n              i = XARGMATCH (\"--hyperlink\", optarg, when_args, when_types);\n            else\n               \n              i = when_always;\n\n            print_hyperlink = (i == when_always\n                               || (i == when_if_tty && stdout_isatty ()));\n            break;\n          }\n\n        case INDICATOR_STYLE_OPTION:\n          indicator_style = XARGMATCH (\"--indicator-style\", optarg,\n                                       indicator_style_args,\n                                       indicator_style_types);\n          break;\n\n        case QUOTING_STYLE_OPTION:\n          quoting_style_opt = XARGMATCH (\"--quoting-style\", optarg,\n                                         quoting_style_args,\n                                         quoting_style_vals);\n          break;\n\n        case TIME_STYLE_OPTION:\n          time_style_option = optarg;\n          break;\n\n        case SHOW_CONTROL_CHARS_OPTION:\n          hide_control_chars_opt = false;\n          break;\n\n        case BLOCK_SIZE_OPTION:\n          {\n            enum strtol_error e = human_options (optarg, &human_output_opts,\n                                                 &output_block_size);\n            if (e != LONGINT_OK)\n              xstrtol_fatal (e, oi, 0, long_options, optarg);\n            file_human_output_opts = human_output_opts;\n            file_output_block_size = output_block_size;\n          }\n          break;\n\n        case SI_OPTION:\n          file_human_output_opts = human_output_opts =\n            human_autoscale | human_SI;\n          file_output_block_size = output_block_size = 1;\n          break;\n\n        case 'Z':\n          print_scontext = true;\n          break;\n\n        case ZERO_OPTION:\n          eolbyte = 0;\n          hide_control_chars_opt = false;\n          if (format_opt != long_format)\n            format_opt = one_per_line;\n          print_with_color = false;\n          quoting_style_opt = literal_quoting_style;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (LS_FAILURE);\n        }\n    }\n\n  if (! output_block_size)\n    {\n      char const *ls_block_size = getenv (\"LS_BLOCK_SIZE\");\n      human_options (ls_block_size,\n                     &human_output_opts, &output_block_size);\n      if (ls_block_size || getenv (\"BLOCK_SIZE\"))\n        {\n          file_human_output_opts = human_output_opts;\n          file_output_block_size = output_block_size;\n        }\n      if (kibibytes_specified)\n        {\n          human_output_opts = 0;\n          output_block_size = 1024;\n        }\n    }\n\n  format = (0 <= format_opt ? format_opt\n            : ls_mode == LS_LS ? (stdout_isatty ()\n                                  ? many_per_line : one_per_line)\n            : ls_mode == LS_MULTI_COL ? many_per_line\n            :   long_format);\n\n   \n  ptrdiff_t linelen = width_opt;\n  if (format == many_per_line || format == horizontal || format == with_commas\n      || print_with_color)\n    {\n#ifdef TIOCGWINSZ\n      if (linelen < 0)\n        {\n           \n# if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wtype-limits\"\n# endif\n          struct winsize ws;\n          if (stdout_isatty ()\n              && 0 <= ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws)\n              && 0 < ws.ws_col)\n            linelen = ws.ws_col <= MIN (PTRDIFF_MAX, SIZE_MAX) ? ws.ws_col : 0;\n# if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)\n#  pragma GCC diagnostic pop\n# endif\n        }\n#endif\n      if (linelen < 0)\n        {\n          char const *p = getenv (\"COLUMNS\");\n          if (p && *p)\n            {\n              linelen = decode_line_length (p);\n              if (linelen < 0)\n                error (0, 0,\n                       _(\"ignoring invalid width\"\n                         \" in environment variable COLUMNS: %s\"),\n                       quote (p));\n            }\n        }\n    }\n\n  line_length = linelen < 0 ? 80 : linelen;\n\n   \n  max_idx = line_length / MIN_COLUMN_WIDTH;\n   \n  max_idx += line_length % MIN_COLUMN_WIDTH != 0;\n\n  if (format == many_per_line || format == horizontal || format == with_commas)\n    {\n      if (0 <= tabsize_opt)\n        tabsize = tabsize_opt;\n      else\n        {\n          tabsize = 8;\n          char const *p = getenv (\"TABSIZE\");\n          if (p)\n            {\n              uintmax_t tmp;\n              if (xstrtoumax (p, nullptr, 0, &tmp, \"\") == LONGINT_OK\n                  && tmp <= SIZE_MAX)\n                tabsize = tmp;\n              else\n                error (0, 0,\n                       _(\"ignoring invalid tab size\"\n                         \" in environment variable TABSIZE: %s\"),\n                       quote (p));\n            }\n        }\n    }\n\n  qmark_funny_chars = (hide_control_chars_opt < 0\n                       ? ls_mode == LS_LS && stdout_isatty ()\n                       : hide_control_chars_opt);\n\n  int qs = quoting_style_opt;\n  if (qs < 0)\n    qs = getenv_quoting_style ();\n  if (qs < 0)\n    qs = (ls_mode == LS_LS\n          ? (stdout_isatty () ? shell_escape_quoting_style : -1)\n          : escape_quoting_style);\n  if (0 <= qs)\n    set_quoting_style (nullptr, qs);\n  qs = get_quoting_style (nullptr);\n  align_variable_outer_quotes\n    = ((format == long_format\n        || ((format == many_per_line || format == horizontal) && line_length))\n       && (qs == shell_quoting_style\n           || qs == shell_escape_quoting_style\n           || qs == c_maybe_quoting_style));\n  filename_quoting_options = clone_quoting_options (nullptr);\n  if (qs == escape_quoting_style)\n    set_char_quoting (filename_quoting_options, ' ', 1);\n  if (file_type <= indicator_style)\n    {\n      char const *p;\n      for (p = &\"*=>@|\"[indicator_style - file_type]; *p; p++)\n        set_char_quoting (filename_quoting_options, *p, 1);\n    }\n\n  dirname_quoting_options = clone_quoting_options (nullptr);\n  set_char_quoting (dirname_quoting_options, ':', 1);\n\n   \n  dired &= (format == long_format) & !print_hyperlink;\n\n  if (eolbyte < dired)\n    error (LS_FAILURE, 0, _(\"--dired and --zero are incompatible\"));\n\n   \n\n  sort_type = (0 <= sort_opt ? sort_opt\n               : (format != long_format\n                  && (time_type == time_ctime || time_type == time_atime\n                      || time_type == time_btime))\n               ? sort_time : sort_name);\n\n  if (format == long_format)\n    {\n      char *style = time_style_option;\n      static char const posix_prefix[] = \"posix-\";\n\n      if (! style)\n        if (! (style = getenv (\"TIME_STYLE\")))\n          style = bad_cast (\"locale\");\n\n      while (STREQ_LEN (style, posix_prefix, sizeof posix_prefix - 1))\n        {\n          if (! hard_locale (LC_TIME))\n            return optind;\n          style += sizeof posix_prefix - 1;\n        }\n\n      if (*style == '+')\n        {\n          char *p0 = style + 1;\n          char *p1 = strchr (p0, '\\n');\n          if (! p1)\n            p1 = p0;\n          else\n            {\n              if (strchr (p1 + 1, '\\n'))\n                error (LS_FAILURE, 0, _(\"invalid time style format %s\"),\n                       quote (p0));\n              *p1++ = '\\0';\n            }\n          long_time_format[0] = p0;\n          long_time_format[1] = p1;\n        }\n      else\n        {\n          ptrdiff_t res = argmatch (style, time_style_args,\n                                    (char const *) time_style_types,\n                                    sizeof (*time_style_types));\n          if (res < 0)\n            {\n               \n              argmatch_invalid (\"time style\", style, res);\n\n               \n              fputs (_(\"Valid arguments are:\\n\"), stderr);\n              char const *const *p = time_style_args;\n              while (*p)\n                fprintf (stderr, \"  - [posix-]%s\\n\", *p++);\n              fputs (_(\"  - +FORMAT (e.g., +%H:%M) for a 'date'-style\"\n                       \" format\\n\"), stderr);\n              usage (LS_FAILURE);\n            }\n          switch (res)\n            {\n            case full_iso_time_style:\n              long_time_format[0] = long_time_format[1] =\n                \"%Y-%m-%d %H:%M:%S.%N %z\";\n              break;\n\n            case long_iso_time_style:\n              long_time_format[0] = long_time_format[1] = \"%Y-%m-%d %H:%M\";\n              break;\n\n            case iso_time_style:\n              long_time_format[0] = \"%Y-%m-%d \";\n              long_time_format[1] = \"%m-%d %H:%M\";\n              break;\n\n            case locale_time_style:\n              if (hard_locale (LC_TIME))\n                {\n                  for (int i = 0; i < 2; i++)\n                    long_time_format[i] =\n                      dcgettext (nullptr, long_time_format[i], LC_TIME);\n                }\n            }\n        }\n\n      abformat_init ();\n    }\n\n  return optind;\n}\n\n \n\nstatic bool\nget_funky_string (char **dest, char const **src, bool equals_end,\n                  size_t *output_count)\n{\n  char num;\t\t\t \n  size_t count;\t\t\t \n  enum {\n    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR\n  } state;\n  char const *p;\n  char *q;\n\n  p = *src;\t\t\t \n  q = *dest;\t\t\t \n\n  count = 0;\t\t\t \n  num = 0;\n\n  state = ST_GND;\t\t \n  while (state < ST_END)\n    {\n      switch (state)\n        {\n        case ST_GND:\t\t \n          switch (*p)\n            {\n            case ':':\n            case '\\0':\n              state = ST_END;\t \n              break;\n            case '\\\\':\n              state = ST_BACKSLASH;  \n              ++p;\n              break;\n            case '^':\n              state = ST_CARET;  \n              ++p;\n              break;\n            case '=':\n              if (equals_end)\n                {\n                  state = ST_END;  \n                  break;\n                }\n              FALLTHROUGH;\n            default:\n              *(q++) = *(p++);\n              ++count;\n              break;\n            }\n          break;\n\n        case ST_BACKSLASH:\t \n          switch (*p)\n            {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n              state = ST_OCTAL;\t \n              num = *p - '0';\n              break;\n            case 'x':\n            case 'X':\n              state = ST_HEX;\t \n              num = 0;\n              break;\n            case 'a':\t\t \n              num = '\\a';\n              break;\n            case 'b':\t\t \n              num = '\\b';\n              break;\n            case 'e':\t\t \n              num = 27;\n              break;\n            case 'f':\t\t \n              num = '\\f';\n              break;\n            case 'n':\t\t \n              num = '\\n';\n              break;\n            case 'r':\t\t \n              num = '\\r';\n              break;\n            case 't':\t\t \n              num = '\\t';\n              break;\n            case 'v':\t\t \n              num = '\\v';\n              break;\n            case '?':\t\t \n              num = 127;\n              break;\n            case '_':\t\t \n              num = ' ';\n              break;\n            case '\\0':\t\t \n              state = ST_ERROR;\t \n              break;\n            default:\t\t \n              num = *p;\n              break;\n            }\n          if (state == ST_BACKSLASH)\n            {\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n            }\n          ++p;\n          break;\n\n        case ST_OCTAL:\t\t \n          if (*p < '0' || *p > '7')\n            {\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n            }\n          else\n            num = (num << 3) + (*(p++) - '0');\n          break;\n\n        case ST_HEX:\t\t \n          switch (*p)\n            {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n              num = (num << 4) + (*(p++) - '0');\n              break;\n            case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n            case 'f':\n              num = (num << 4) + (*(p++) - 'a') + 10;\n              break;\n            case 'A':\n            case 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n            case 'F':\n              num = (num << 4) + (*(p++) - 'A') + 10;\n              break;\n            default:\n              *(q++) = num;\n              ++count;\n              state = ST_GND;\n              break;\n            }\n          break;\n\n        case ST_CARET:\t\t \n          state = ST_GND;\t \n          if (*p >= '@' && *p <= '~')\n            {\n              *(q++) = *(p++) & 037;\n              ++count;\n            }\n          else if (*p == '?')\n            {\n              *(q++) = 127;\n              ++count;\n            }\n          else\n            state = ST_ERROR;\n          break;\n\n        default:\n          unreachable ();\n        }\n    }\n\n  *dest = q;\n  *src = p;\n  *output_count = count;\n\n  return state != ST_ERROR;\n}\n\nenum parse_state\n  {\n    PS_START = 1,\n    PS_2,\n    PS_3,\n    PS_4,\n    PS_DONE,\n    PS_FAIL\n  };\n\n\n \n\nstatic bool\nknown_term_type (void)\n{\n  char const *term = getenv (\"TERM\");\n  if (! term || ! *term)\n    return false;\n\n  char const *line = G_line;\n  while (line - G_line < sizeof (G_line))\n    {\n      if (STRNCMP_LIT (line, \"TERM \") == 0)\n        {\n          if (fnmatch (line + 5, term, 0) == 0)\n            return true;\n        }\n      line += strlen (line) + 1;\n    }\n\n  return false;\n}\n\nstatic void\nparse_ls_color (void)\n{\n  char const *p;\t\t \n  char *buf;\t\t\t \n  int ind_no;\t\t\t \n  char label[3];\t\t \n  struct color_ext_type *ext;\t \n\n  if ((p = getenv (\"LS_COLORS\")) == nullptr || *p == '\\0')\n    {\n       \n      char const *colorterm = getenv (\"COLORTERM\");\n      if (! (colorterm && *colorterm) && ! known_term_type ())\n        print_with_color = false;\n      return;\n    }\n\n  ext = nullptr;\n  strcpy (label, \"??\");\n\n   \n  buf = color_buf = xstrdup (p);\n\n  enum parse_state state = PS_START;\n  while (true)\n    {\n      switch (state)\n        {\n        case PS_START:\t\t \n          switch (*p)\n            {\n            case ':':\n              ++p;\n              break;\n\n            case '*':\n               \n\n              ext = xmalloc (sizeof *ext);\n              ext->next = color_ext_list;\n              color_ext_list = ext;\n              ext->exact_match = false;\n\n              ++p;\n              ext->ext.string = buf;\n\n              state = (get_funky_string (&buf, &p, true, &ext->ext.len)\n                       ? PS_4 : PS_FAIL);\n              break;\n\n            case '\\0':\n              state = PS_DONE;\t \n              goto done;\n\n            default:\t \n              label[0] = *(p++);\n              state = PS_2;\n              break;\n            }\n          break;\n\n        case PS_2:\t\t \n          if (*p)\n            {\n              label[1] = *(p++);\n              state = PS_3;\n            }\n          else\n            state = PS_FAIL;\t \n          break;\n\n        case PS_3:\t\t \n          state = PS_FAIL;\t \n          if (*(p++) == '=') \n            {\n              for (ind_no = 0; indicator_name[ind_no] != nullptr; ++ind_no)\n                {\n                  if (STREQ (label, indicator_name[ind_no]))\n                    {\n                      color_indicator[ind_no].string = buf;\n                      state = (get_funky_string (&buf, &p, false,\n                                                 &color_indicator[ind_no].len)\n                               ? PS_START : PS_FAIL);\n                      break;\n                    }\n                }\n              if (state == PS_FAIL)\n                error (0, 0, _(\"unrecognized prefix: %s\"), quote (label));\n            }\n          break;\n\n        case PS_4:\t\t \n          if (*(p++) == '=')\n            {\n              ext->seq.string = buf;\n              state = (get_funky_string (&buf, &p, false, &ext->seq.len)\n                       ? PS_START : PS_FAIL);\n            }\n          else\n            state = PS_FAIL;\n          break;\n\n        case PS_FAIL:\n          goto done;\n\n        default:\n          affirm (false);\n        }\n    }\n done:\n\n  if (state == PS_FAIL)\n    {\n      struct color_ext_type *e;\n      struct color_ext_type *e2;\n\n      error (0, 0,\n             _(\"unparsable value for LS_COLORS environment variable\"));\n      free (color_buf);\n      for (e = color_ext_list; e != nullptr;  )\n        {\n          e2 = e;\n          e = e->next;\n          free (e2);\n        }\n      print_with_color = false;\n    }\n  else\n    {\n       \n      struct color_ext_type *e1;\n\n      for (e1 = color_ext_list; e1 != nullptr; e1 = e1->next)\n        {\n          struct color_ext_type *e2;\n          bool case_ignored = false;\n\n          for (e2 = e1->next; e2 != nullptr; e2 = e2->next)\n            {\n              if (e2->ext.len < SIZE_MAX && e1->ext.len == e2->ext.len)\n                {\n                  if (memcmp (e1->ext.string, e2->ext.string, e1->ext.len) == 0)\n                    e2->ext.len = SIZE_MAX;  \n                  else if (c_strncasecmp (e1->ext.string, e2->ext.string,\n                                          e1->ext.len) == 0)\n                    {\n                      if (case_ignored)\n                        {\n                          e2->ext.len = SIZE_MAX;  \n                        }\n                      else if (e1->seq.len == e2->seq.len\n                               && memcmp (e1->seq.string, e2->seq.string,\n                                          e1->seq.len) == 0)\n                        {\n                          e2->ext.len = SIZE_MAX;  \n                          case_ignored = true;     \n                        }\n                      else\n                        {\n                          e1->exact_match = true;\n                          e2->exact_match = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n  if (color_indicator[C_LINK].len == 6\n      && !STRNCMP_LIT (color_indicator[C_LINK].string, \"target\"))\n    color_symlink_as_referent = true;\n}\n\n \n\nstatic int\ngetenv_quoting_style (void)\n{\n  char const *q_style = getenv (\"QUOTING_STYLE\");\n  if (!q_style)\n    return -1;\n  int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);\n  if (i < 0)\n    {\n      error (0, 0,\n             _(\"ignoring invalid value\"\n               \" of environment variable QUOTING_STYLE: %s\"),\n             quote (q_style));\n      return -1;\n    }\n  return quoting_style_vals[i];\n}\n\n \n\nstatic void\nset_exit_status (bool serious)\n{\n  if (serious)\n    exit_status = LS_FAILURE;\n  else if (exit_status == EXIT_SUCCESS)\n    exit_status = LS_MINOR_PROBLEM;\n}\n\n \n\nstatic void\nfile_failure (bool serious, char const *message, char const *file)\n{\n  error (0, errno, message, quoteaf (file));\n  set_exit_status (serious);\n}\n\n \n\nstatic void\nqueue_directory (char const *name, char const *realname, bool command_line_arg)\n{\n  struct pending *new = xmalloc (sizeof *new);\n  new->realname = realname ? xstrdup (realname) : nullptr;\n  new->name = name ? xstrdup (name) : nullptr;\n  new->command_line_arg = command_line_arg;\n  new->next = pending_dirs;\n  pending_dirs = new;\n}\n\n \n\nstatic void\nprint_dir (char const *name, char const *realname, bool command_line_arg)\n{\n  DIR *dirp;\n  struct dirent *next;\n  uintmax_t total_blocks = 0;\n  static bool first = true;\n\n  errno = 0;\n  dirp = opendir (name);\n  if (!dirp)\n    {\n      file_failure (command_line_arg, _(\"cannot open directory %s\"), name);\n      return;\n    }\n\n  if (LOOP_DETECT)\n    {\n      struct stat dir_stat;\n      int fd = dirfd (dirp);\n\n       \n      if ((0 <= fd\n           ? fstat_for_ino (fd, &dir_stat)\n           : stat_for_ino (name, &dir_stat)) < 0)\n        {\n          file_failure (command_line_arg,\n                        _(\"cannot determine device and inode of %s\"), name);\n          closedir (dirp);\n          return;\n        }\n\n       \n      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))\n        {\n          error (0, 0, _(\"%s: not listing already-listed directory\"),\n                 quotef (name));\n          closedir (dirp);\n          set_exit_status (true);\n          return;\n        }\n\n      dev_ino_push (dir_stat.st_dev, dir_stat.st_ino);\n    }\n\n  clear_files ();\n\n  if (recursive || print_dir_name)\n    {\n      if (!first)\n        dired_outbyte ('\\n');\n      first = false;\n      dired_indent ();\n\n      char *absolute_name = nullptr;\n      if (print_hyperlink)\n        {\n          absolute_name = canonicalize_filename_mode (name, CAN_MISSING);\n          if (! absolute_name)\n            file_failure (command_line_arg,\n                          _(\"error canonicalizing %s\"), name);\n        }\n      quote_name (realname ? realname : name, dirname_quoting_options, -1,\n                  nullptr, true, &subdired_obstack, absolute_name);\n\n      free (absolute_name);\n\n      dired_outstring (\":\\n\");\n    }\n\n   \n\n  while (true)\n    {\n       \n      errno = 0;\n      next = readdir (dirp);\n      if (next)\n        {\n          if (! file_ignored (next->d_name))\n            {\n              enum filetype type = unknown;\n\n#if HAVE_STRUCT_DIRENT_D_TYPE\n              switch (next->d_type)\n                {\n                case DT_BLK:  type = blockdev;\t\tbreak;\n                case DT_CHR:  type = chardev;\t\tbreak;\n                case DT_DIR:  type = directory;\t\tbreak;\n                case DT_FIFO: type = fifo;\t\tbreak;\n                case DT_LNK:  type = symbolic_link;\tbreak;\n                case DT_REG:  type = normal;\t\tbreak;\n                case DT_SOCK: type = sock;\t\tbreak;\n# ifdef DT_WHT\n                case DT_WHT:  type = whiteout;\t\tbreak;\n# endif\n                }\n#endif\n              total_blocks += gobble_file (next->d_name, type,\n                                           RELIABLE_D_INO (next),\n                                           false, name);\n\n               \n              if (format == one_per_line && sort_type == sort_none\n                      && !print_block_size && !recursive)\n                {\n                   \n                  sort_files ();\n                  print_current_files ();\n                  clear_files ();\n                }\n            }\n        }\n      else if (errno != 0)\n        {\n          file_failure (command_line_arg, _(\"reading directory %s\"), name);\n          if (errno != EOVERFLOW)\n            break;\n        }\n      else\n        break;\n\n       \n      process_signals ();\n    }\n\n  if (closedir (dirp) != 0)\n    {\n      file_failure (command_line_arg, _(\"closing directory %s\"), name);\n       \n    }\n\n   \n  sort_files ();\n\n   \n\n  if (recursive)\n    extract_dirs_from_files (name, false);\n\n  if (format == long_format || print_block_size)\n    {\n      char buf[LONGEST_HUMAN_READABLE + 3];\n      char *p = human_readable (total_blocks, buf + 1, human_output_opts,\n                                ST_NBLOCKSIZE, output_block_size);\n      char *pend = p + strlen (p);\n      *--p = ' ';\n      *pend++ = eolbyte;\n      dired_indent ();\n      dired_outstring (_(\"total\"));\n      dired_outbuf (p, pend - p);\n    }\n\n  if (cwd_n_used)\n    print_current_files ();\n}\n\n \n\nstatic void\nadd_ignore_pattern (char const *pattern)\n{\n  struct ignore_pattern *ignore;\n\n  ignore = xmalloc (sizeof *ignore);\n  ignore->pattern = pattern;\n   \n  ignore->next = ignore_patterns;\n  ignore_patterns = ignore;\n}\n\n \n\nstatic bool\npatterns_match (struct ignore_pattern const *patterns, char const *file)\n{\n  struct ignore_pattern const *p;\n  for (p = patterns; p; p = p->next)\n    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)\n      return true;\n  return false;\n}\n\n \n\nstatic bool\nfile_ignored (char const *name)\n{\n  return ((ignore_mode != IGNORE_MINIMAL\n           && name[0] == '.'\n           && (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))\n          || (ignore_mode == IGNORE_DEFAULT\n              && patterns_match (hide_patterns, name))\n          || patterns_match (ignore_patterns, name));\n}\n\n \n\nstatic uintmax_t\nunsigned_file_size (off_t size)\n{\n  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);\n}\n\n#ifdef HAVE_CAP\n \nstatic bool\nhas_capability (char const *name)\n{\n  char *result;\n  bool has_cap;\n\n  cap_t cap_d = cap_get_file (name);\n  if (cap_d == nullptr)\n    return false;\n\n  result = cap_to_text (cap_d, nullptr);\n  cap_free (cap_d);\n  if (!result)\n    return false;\n\n   \n  has_cap = !!*result;\n\n  cap_free (result);\n  return has_cap;\n}\n#else\nstatic bool\nhas_capability (MAYBE_UNUSED char const *name)\n{\n  errno = ENOTSUP;\n  return false;\n}\n#endif\n\n \n\nstatic void\nfree_ent (struct fileinfo *f)\n{\n  free (f->name);\n  free (f->linkname);\n  free (f->absolute_name);\n  if (f->scontext != UNKNOWN_SECURITY_CONTEXT)\n    {\n      if (is_smack_enabled ())\n        free (f->scontext);\n      else\n        freecon (f->scontext);\n    }\n}\n\n \nstatic void\nclear_files (void)\n{\n  for (size_t i = 0; i < cwd_n_used; i++)\n    {\n      struct fileinfo *f = sorted_file[i];\n      free_ent (f);\n    }\n\n  cwd_n_used = 0;\n  cwd_some_quoted = false;\n  any_has_acl = false;\n  inode_number_width = 0;\n  block_size_width = 0;\n  nlink_width = 0;\n  owner_width = 0;\n  group_width = 0;\n  author_width = 0;\n  scontext_width = 0;\n  major_device_number_width = 0;\n  minor_device_number_width = 0;\n  file_size_width = 0;\n}\n\n \nstatic bool\nerrno_unsupported (int err)\n{\n  return (err == EINVAL || err == ENOSYS || is_ENOTSUP (err));\n}\n\n \nstatic int\ngetfilecon_cache (char const *file, struct fileinfo *f, bool deref)\n{\n   \n  static dev_t unsupported_device;\n\n  if (f->stat.st_dev == unsupported_device)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n  int r = 0;\n#ifdef HAVE_SMACK\n  if (is_smack_enabled ())\n    r = smack_new_label_from_path (file, \"security.SMACK64\", deref,\n                                   &f->scontext);\n  else\n#endif\n    r = (deref\n         ? getfilecon (file, &f->scontext)\n         : lgetfilecon (file, &f->scontext));\n  if (r < 0 && errno_unsupported (errno))\n    unsupported_device = f->stat.st_dev;\n  return r;\n}\n\n \nstatic int\nfile_has_acl_cache (char const *file, struct fileinfo *f)\n{\n   \n  static dev_t unsupported_device;\n\n  if (f->stat.st_dev == unsupported_device)\n    {\n      errno = ENOTSUP;\n      return 0;\n    }\n\n   \n  errno = 0;\n  int n = file_has_acl (file, &f->stat);\n  if (n <= 0 && errno_unsupported (errno))\n    unsupported_device = f->stat.st_dev;\n  return n;\n}\n\n \nstatic bool\nhas_capability_cache (char const *file, struct fileinfo *f)\n{\n   \n  static dev_t unsupported_device;\n\n  if (f->stat.st_dev == unsupported_device)\n    {\n      errno = ENOTSUP;\n      return 0;\n    }\n\n  bool b = has_capability (file);\n  if ( !b && errno_unsupported (errno))\n    unsupported_device = f->stat.st_dev;\n  return b;\n}\n\nstatic bool\nneeds_quoting (char const *name)\n{\n  char test[2];\n  size_t len = quotearg_buffer (test, sizeof test , name, -1,\n                                filename_quoting_options);\n  return *name != *test || strlen (name) != len;\n}\n\n \nstatic uintmax_t\ngobble_file (char const *name, enum filetype type, ino_t inode,\n             bool command_line_arg, char const *dirname)\n{\n  uintmax_t blocks = 0;\n  struct fileinfo *f;\n\n   \n  affirm (! command_line_arg || inode == NOT_AN_INODE_NUMBER);\n\n  if (cwd_n_used == cwd_n_alloc)\n    {\n      cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);\n      cwd_n_alloc *= 2;\n    }\n\n  f = &cwd_file[cwd_n_used];\n  memset (f, '\\0', sizeof *f);\n  f->stat.st_ino = inode;\n  f->filetype = type;\n\n  f->quoted = -1;\n  if ((! cwd_some_quoted) && align_variable_outer_quotes)\n    {\n       \n      f->quoted = needs_quoting (name);\n      if (f->quoted)\n        cwd_some_quoted = 1;\n    }\n\n  if (command_line_arg\n      || print_hyperlink\n      || format_needs_stat\n       \n      || (type == directory && print_with_color\n          && (is_colored (C_OTHER_WRITABLE)\n              || is_colored (C_STICKY)\n              || is_colored (C_STICKY_OTHER_WRITABLE)))\n       \n      || ((print_inode || format_needs_type)\n          && (type == symbolic_link || type == unknown)\n          && (dereference == DEREF_ALWAYS\n              || color_symlink_as_referent || check_symlink_mode))\n       \n      || (print_inode && inode == NOT_AN_INODE_NUMBER)\n      || (format_needs_type\n          && (type == unknown || command_line_arg\n               \n              || (type == normal && (indicator_style == classify\n                                      \n                                     || (print_with_color\n                                         && (is_colored (C_EXEC)\n                                             || is_colored (C_SETUID)\n                                             || is_colored (C_SETGID)\n                                             || is_colored (C_CAP)))\n                                     )))))\n\n    {\n       \n      char *full_name;\n      bool do_deref;\n      int err;\n\n      if (name[0] == '/' || dirname[0] == 0)\n        full_name = (char *) name;\n      else\n        {\n          full_name = alloca (strlen (name) + strlen (dirname) + 2);\n          attach (full_name, dirname, name);\n        }\n\n      if (print_hyperlink)\n        {\n          f->absolute_name = canonicalize_filename_mode (full_name,\n                                                         CAN_MISSING);\n          if (! f->absolute_name)\n            file_failure (command_line_arg,\n                          _(\"error canonicalizing %s\"), full_name);\n        }\n\n      switch (dereference)\n        {\n        case DEREF_ALWAYS:\n          err = do_stat (full_name, &f->stat);\n          do_deref = true;\n          break;\n\n        case DEREF_COMMAND_LINE_ARGUMENTS:\n        case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:\n          if (command_line_arg)\n            {\n              bool need_lstat;\n              err = do_stat (full_name, &f->stat);\n              do_deref = true;\n\n              if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)\n                break;\n\n              need_lstat = (err < 0\n                            ? (errno == ENOENT || errno == ELOOP)\n                            : ! S_ISDIR (f->stat.st_mode));\n              if (!need_lstat)\n                break;\n\n               \n            }\n          FALLTHROUGH;\n\n        default:  \n          err = do_lstat (full_name, &f->stat);\n          do_deref = false;\n          break;\n        }\n\n      if (err != 0)\n        {\n           \n          file_failure (command_line_arg,\n                        _(\"cannot access %s\"), full_name);\n\n          f->scontext = UNKNOWN_SECURITY_CONTEXT;\n\n          if (command_line_arg)\n            return 0;\n\n          f->name = xstrdup (name);\n          cwd_n_used++;\n\n          return 0;\n        }\n\n      f->stat_ok = true;\n\n       \n      if ((type == normal || S_ISREG (f->stat.st_mode))\n          && print_with_color && is_colored (C_CAP))\n        f->has_capability = has_capability_cache (full_name, f);\n\n      if (format == long_format || print_scontext)\n        {\n          bool have_scontext = false;\n          bool have_acl = false;\n          int attr_len = getfilecon_cache (full_name, f, do_deref);\n          err = (attr_len < 0);\n\n          if (err == 0)\n            {\n              if (is_smack_enabled ())\n                have_scontext = ! STREQ (\"_\", f->scontext);\n              else\n                have_scontext = ! STREQ (\"unlabeled\", f->scontext);\n            }\n          else\n            {\n              f->scontext = UNKNOWN_SECURITY_CONTEXT;\n\n               \n              if (is_ENOTSUP (errno) || errno == ENODATA)\n                err = 0;\n            }\n\n          if (err == 0 && format == long_format)\n            {\n              int n = file_has_acl_cache (full_name, f);\n              err = (n < 0);\n              have_acl = (0 < n);\n            }\n\n          f->acl_type = (!have_scontext && !have_acl\n                         ? ACL_T_NONE\n                         : (have_scontext && !have_acl\n                            ? ACL_T_LSM_CONTEXT_ONLY\n                            : ACL_T_YES));\n          any_has_acl |= f->acl_type != ACL_T_NONE;\n\n          if (err)\n            error (0, errno, \"%s\", quotef (full_name));\n        }\n\n      if (S_ISLNK (f->stat.st_mode)\n          && (format == long_format || check_symlink_mode))\n        {\n          struct stat linkstats;\n\n          get_link_name (full_name, f, command_line_arg);\n\n           \n          if (f->linkname && f->quoted == 0 && needs_quoting (f->linkname))\n            f->quoted = -1;\n\n           \n          if (f->linkname\n              && (file_type <= indicator_style || check_symlink_mode)\n              && stat_for_mode (full_name, &linkstats) == 0)\n            {\n              f->linkok = true;\n              f->linkmode = linkstats.st_mode;\n            }\n        }\n\n      if (S_ISLNK (f->stat.st_mode))\n        f->filetype = symbolic_link;\n      else if (S_ISDIR (f->stat.st_mode))\n        {\n          if (command_line_arg && !immediate_dirs)\n            f->filetype = arg_directory;\n          else\n            f->filetype = directory;\n        }\n      else\n        f->filetype = normal;\n\n      blocks = ST_NBLOCKS (f->stat);\n      if (format == long_format || print_block_size)\n        {\n          char buf[LONGEST_HUMAN_READABLE + 1];\n          int len = mbswidth (human_readable (blocks, buf, human_output_opts,\n                                              ST_NBLOCKSIZE, output_block_size),\n                              0);\n          if (block_size_width < len)\n            block_size_width = len;\n        }\n\n      if (format == long_format)\n        {\n          if (print_owner)\n            {\n              int len = format_user_width (f->stat.st_uid);\n              if (owner_width < len)\n                owner_width = len;\n            }\n\n          if (print_group)\n            {\n              int len = format_group_width (f->stat.st_gid);\n              if (group_width < len)\n                group_width = len;\n            }\n\n          if (print_author)\n            {\n              int len = format_user_width (f->stat.st_author);\n              if (author_width < len)\n                author_width = len;\n            }\n        }\n\n      if (print_scontext)\n        {\n          int len = strlen (f->scontext);\n          if (scontext_width < len)\n            scontext_width = len;\n        }\n\n      if (format == long_format)\n        {\n          char b[INT_BUFSIZE_BOUND (uintmax_t)];\n          int b_len = strlen (umaxtostr (f->stat.st_nlink, b));\n          if (nlink_width < b_len)\n            nlink_width = b_len;\n\n          if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))\n            {\n              char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n              int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));\n              if (major_device_number_width < len)\n                major_device_number_width = len;\n              len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));\n              if (minor_device_number_width < len)\n                minor_device_number_width = len;\n              len = major_device_number_width + 2 + minor_device_number_width;\n              if (file_size_width < len)\n                file_size_width = len;\n            }\n          else\n            {\n              char buf[LONGEST_HUMAN_READABLE + 1];\n              uintmax_t size = unsigned_file_size (f->stat.st_size);\n              int len = mbswidth (human_readable (size, buf,\n                                                  file_human_output_opts,\n                                                  1, file_output_block_size),\n                                  0);\n              if (file_size_width < len)\n                file_size_width = len;\n            }\n        }\n    }\n\n  if (print_inode)\n    {\n      char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n      int len = strlen (umaxtostr (f->stat.st_ino, buf));\n      if (inode_number_width < len)\n        inode_number_width = len;\n    }\n\n  f->name = xstrdup (name);\n  cwd_n_used++;\n\n  return blocks;\n}\n\n \nstatic bool\nis_directory (const struct fileinfo *f)\n{\n  return f->filetype == directory || f->filetype == arg_directory;\n}\n\n \nstatic bool\nis_linked_directory (const struct fileinfo *f)\n{\n  return f->filetype == directory || f->filetype == arg_directory\n         || S_ISDIR (f->linkmode);\n}\n\n \n\nstatic void\nget_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)\n{\n  f->linkname = areadlink_with_size (filename, f->stat.st_size);\n  if (f->linkname == nullptr)\n    file_failure (command_line_arg, _(\"cannot read symbolic link %s\"),\n                  filename);\n}\n\n \n\nstatic bool\nbasename_is_dot_or_dotdot (char const *name)\n{\n  char const *base = last_component (name);\n  return dot_or_dotdot (base);\n}\n\n \n\nstatic void\nextract_dirs_from_files (char const *dirname, bool command_line_arg)\n{\n  size_t i;\n  size_t j;\n  bool ignore_dot_and_dot_dot = (dirname != nullptr);\n\n  if (dirname && LOOP_DETECT)\n    {\n       \n      queue_directory (nullptr, dirname, false);\n    }\n\n   \n  for (i = cwd_n_used; i-- != 0; )\n    {\n      struct fileinfo *f = sorted_file[i];\n\n      if (is_directory (f)\n          && (! ignore_dot_and_dot_dot\n              || ! basename_is_dot_or_dotdot (f->name)))\n        {\n          if (!dirname || f->name[0] == '/')\n            queue_directory (f->name, f->linkname, command_line_arg);\n          else\n            {\n              char *name = file_name_concat (dirname, f->name, nullptr);\n              queue_directory (name, f->linkname, command_line_arg);\n              free (name);\n            }\n          if (f->filetype == arg_directory)\n            free_ent (f);\n        }\n    }\n\n   \n\n  for (i = 0, j = 0; i < cwd_n_used; i++)\n    {\n      struct fileinfo *f = sorted_file[i];\n      sorted_file[j] = f;\n      j += (f->filetype != arg_directory);\n    }\n  cwd_n_used = j;\n}\n\n \n\nstatic jmp_buf failed_strcoll;\n\nstatic int\nxstrcoll (char const *a, char const *b)\n{\n  int diff;\n  errno = 0;\n  diff = strcoll (a, b);\n  if (errno)\n    {\n      error (0, errno, _(\"cannot compare file names %s and %s\"),\n             quote_n (0, a), quote_n (1, b));\n      set_exit_status (false);\n      longjmp (failed_strcoll, 1);\n    }\n  return diff;\n}\n\n \n\ntypedef void const *V;\ntypedef int (*qsortFunc)(V a, V b);\n\n \nstatic int\ndirfirst_check (struct fileinfo const *a, struct fileinfo const *b,\n                int (*cmp) (V, V))\n{\n  int diff = is_linked_directory (b) - is_linked_directory (a);\n  return diff ? diff : cmp (a, b);\n}\n\n \n#define DEFINE_SORT_FUNCTIONS(key_name, key_cmp_func)\t\t\t\\\n   \t\t\t\t\t\\\n  static int xstrcoll_##key_name (V a, V b)\t\t\t\t\\\n  { return key_cmp_func (a, b, xstrcoll); }\t\t\t\t\\\n  ATTRIBUTE_PURE static int strcmp_##key_name (V a, V b)\t\t\\\n  { return key_cmp_func (a, b, strcmp); }\t\t\t\t\\\n                                                                        \\\n   \t\t\t\t\t\\\n  static int rev_xstrcoll_##key_name (V a, V b)\t\t\t\t\\\n  { return key_cmp_func (b, a, xstrcoll); }\t\t\t\t\\\n  ATTRIBUTE_PURE static int rev_strcmp_##key_name (V a, V b)\t\\\n  { return key_cmp_func (b, a, strcmp); }\t\t\t\t\\\n                                                                        \\\n   \t\t\t\t\t\\\n  static int xstrcoll_df_##key_name (V a, V b)\t\t\t\t\\\n  { return dirfirst_check (a, b, xstrcoll_##key_name); }\t\t\\\n  ATTRIBUTE_PURE static int strcmp_df_##key_name (V a, V b)\t\t\\\n  { return dirfirst_check (a, b, strcmp_##key_name); }\t\t\t\\\n                                                                        \\\n   \t\t\t\t\t\\\n  static int rev_xstrcoll_df_##key_name (V a, V b)\t\t\t\\\n  { return dirfirst_check (a, b, rev_xstrcoll_##key_name); }\t\t\\\n  ATTRIBUTE_PURE static int rev_strcmp_df_##key_name (V a, V b)\t\\\n  { return dirfirst_check (a, b, rev_strcmp_##key_name); }\n\nstatic int\ncmp_ctime (struct fileinfo const *a, struct fileinfo const *b,\n           int (*cmp) (char const *, char const *))\n{\n  int diff = timespec_cmp (get_stat_ctime (&b->stat),\n                           get_stat_ctime (&a->stat));\n  return diff ? diff : cmp (a->name, b->name);\n}\n\nstatic int\ncmp_mtime (struct fileinfo const *a, struct fileinfo const *b,\n           int (*cmp) (char const *, char const *))\n{\n  int diff = timespec_cmp (get_stat_mtime (&b->stat),\n                           get_stat_mtime (&a->stat));\n  return diff ? diff : cmp (a->name, b->name);\n}\n\nstatic int\ncmp_atime (struct fileinfo const *a, struct fileinfo const *b,\n           int (*cmp) (char const *, char const *))\n{\n  int diff = timespec_cmp (get_stat_atime (&b->stat),\n                           get_stat_atime (&a->stat));\n  return diff ? diff : cmp (a->name, b->name);\n}\n\nstatic int\ncmp_btime (struct fileinfo const *a, struct fileinfo const *b,\n           int (*cmp) (char const *, char const *))\n{\n  int diff = timespec_cmp (get_stat_btime (&b->stat),\n                           get_stat_btime (&a->stat));\n  return diff ? diff : cmp (a->name, b->name);\n}\n\nstatic int\noff_cmp (off_t a, off_t b)\n{\n  return (a > b) - (a < b);\n}\n\nstatic int\ncmp_size (struct fileinfo const *a, struct fileinfo const *b,\n          int (*cmp) (char const *, char const *))\n{\n  int diff = off_cmp (b->stat.st_size, a->stat.st_size);\n  return diff ? diff : cmp (a->name, b->name);\n}\n\nstatic int\ncmp_name (struct fileinfo const *a, struct fileinfo const *b,\n          int (*cmp) (char const *, char const *))\n{\n  return cmp (a->name, b->name);\n}\n\n \n\nstatic int\ncmp_extension (struct fileinfo const *a, struct fileinfo const *b,\n               int (*cmp) (char const *, char const *))\n{\n  char const *base1 = strrchr (a->name, '.');\n  char const *base2 = strrchr (b->name, '.');\n  int diff = cmp (base1 ? base1 : \"\", base2 ? base2 : \"\");\n  return diff ? diff : cmp (a->name, b->name);\n}\n\n \n\nstatic size_t\nfileinfo_name_width (struct fileinfo const *f)\n{\n  return f->width\n         ? f->width\n         : quote_name_width (f->name, filename_quoting_options, f->quoted);\n}\n\nstatic int\ncmp_width (struct fileinfo const *a, struct fileinfo const *b,\n          int (*cmp) (char const *, char const *))\n{\n  int diff = fileinfo_name_width (a) - fileinfo_name_width (b);\n  return diff ? diff : cmp (a->name, b->name);\n}\n\nDEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)\nDEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)\nDEFINE_SORT_FUNCTIONS (atime, cmp_atime)\nDEFINE_SORT_FUNCTIONS (btime, cmp_btime)\nDEFINE_SORT_FUNCTIONS (size, cmp_size)\nDEFINE_SORT_FUNCTIONS (name, cmp_name)\nDEFINE_SORT_FUNCTIONS (extension, cmp_extension)\nDEFINE_SORT_FUNCTIONS (width, cmp_width)\n\n \nstatic int\ncmp_version (struct fileinfo const *a, struct fileinfo const *b)\n{\n  int diff = filevercmp (a->name, b->name);\n  return diff ? diff : strcmp (a->name, b->name);\n}\n\nstatic int\nxstrcoll_version (V a, V b)\n{\n  return cmp_version (a, b);\n}\nstatic int\nrev_xstrcoll_version (V a, V b)\n{\n  return cmp_version (b, a);\n}\nstatic int\nxstrcoll_df_version (V a, V b)\n{\n  return dirfirst_check (a, b, xstrcoll_version);\n}\nstatic int\nrev_xstrcoll_df_version (V a, V b)\n{\n  return dirfirst_check (a, b, rev_xstrcoll_version);\n}\n\n\n \n\n#define LIST_SORTFUNCTION_VARIANTS(key_name)                        \\\n  {                                                                 \\\n    {                                                               \\\n      { xstrcoll_##key_name, xstrcoll_df_##key_name },              \\\n      { rev_xstrcoll_##key_name, rev_xstrcoll_df_##key_name },      \\\n    },                                                              \\\n    {                                                               \\\n      { strcmp_##key_name, strcmp_df_##key_name },                  \\\n      { rev_strcmp_##key_name, rev_strcmp_df_##key_name },          \\\n    }                                                               \\\n  }\n\nstatic qsortFunc const sort_functions[][2][2][2] =\n  {\n    LIST_SORTFUNCTION_VARIANTS (name),\n    LIST_SORTFUNCTION_VARIANTS (extension),\n    LIST_SORTFUNCTION_VARIANTS (width),\n    LIST_SORTFUNCTION_VARIANTS (size),\n\n    {\n      {\n        { xstrcoll_version, xstrcoll_df_version },\n        { rev_xstrcoll_version, rev_xstrcoll_df_version },\n      },\n\n       \n      {\n        { nullptr, nullptr },\n        { nullptr, nullptr },\n      }\n    },\n\n     \n    LIST_SORTFUNCTION_VARIANTS (mtime),\n    LIST_SORTFUNCTION_VARIANTS (ctime),\n    LIST_SORTFUNCTION_VARIANTS (atime),\n    LIST_SORTFUNCTION_VARIANTS (btime)\n  };\n\n \nstatic_assert (ARRAY_CARDINALITY (sort_functions)\n               == sort_numtypes - 2 + time_numtypes);\n\n \n\nstatic void\ninitialize_ordering_vector (void)\n{\n  for (size_t i = 0; i < cwd_n_used; i++)\n    sorted_file[i] = &cwd_file[i];\n}\n\n \n\nstatic void\nupdate_current_files_info (void)\n{\n   \n  if (sort_type == sort_width\n      || (line_length && (format == many_per_line || format == horizontal)))\n    {\n      size_t i;\n      for (i = 0; i < cwd_n_used; i++)\n        {\n          struct fileinfo *f = sorted_file[i];\n          f->width = fileinfo_name_width (f);\n        }\n    }\n}\n\n \n\nstatic void\nsort_files (void)\n{\n  bool use_strcmp;\n\n  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)\n    {\n      free (sorted_file);\n      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);\n      sorted_file_alloc = 3 * cwd_n_used;\n    }\n\n  initialize_ordering_vector ();\n\n  update_current_files_info ();\n\n  if (sort_type == sort_none)\n    return;\n\n   \n\n  if (! setjmp (failed_strcoll))\n    use_strcmp = false;       \n  else\n    {\n      use_strcmp = true;\n      affirm (sort_type != sort_version);\n      initialize_ordering_vector ();\n    }\n\n   \n  mpsort ((void const **) sorted_file, cwd_n_used,\n          sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]\n                        [use_strcmp][sort_reverse]\n                        [directories_first]);\n}\n\n \n\nstatic void\nprint_current_files (void)\n{\n  size_t i;\n\n  switch (format)\n    {\n    case one_per_line:\n      for (i = 0; i < cwd_n_used; i++)\n        {\n          print_file_name_and_frills (sorted_file[i], 0);\n          putchar (eolbyte);\n        }\n      break;\n\n    case many_per_line:\n      if (! line_length)\n        print_with_separator (' ');\n      else\n        print_many_per_line ();\n      break;\n\n    case horizontal:\n      if (! line_length)\n        print_with_separator (' ');\n      else\n        print_horizontal ();\n      break;\n\n    case with_commas:\n      print_with_separator (',');\n      break;\n\n    case long_format:\n      for (i = 0; i < cwd_n_used; i++)\n        {\n          set_normal_color ();\n          print_long_format (sorted_file[i]);\n          dired_outbyte (eolbyte);\n        }\n      break;\n    }\n}\n\n \n\nstatic size_t\nalign_nstrftime (char *buf, size_t size, bool recent, struct tm const *tm,\n                 timezone_t tz, int ns)\n{\n  char const *nfmt = (use_abformat\n                      ? abformat[recent][tm->tm_mon]\n                      : long_time_format[recent]);\n  return nstrftime (buf, size, nfmt, tm, tz, ns);\n}\n\n \n\nstatic int\nlong_time_expected_width (void)\n{\n  static int width = -1;\n\n  if (width < 0)\n    {\n      time_t epoch = 0;\n      struct tm tm;\n      char buf[TIME_STAMP_LEN_MAXIMUM + 1];\n\n       \n      if (localtime_rz (localtz, &epoch, &tm))\n        {\n          size_t len = align_nstrftime (buf, sizeof buf, false,\n                                        &tm, localtz, 0);\n          if (len != 0)\n            width = mbsnwidth (buf, len, 0);\n        }\n\n      if (width < 0)\n        width = 0;\n    }\n\n  return width;\n}\n\n \n\nstatic void\nformat_user_or_group (char const *name, uintmax_t id, int width)\n{\n  if (name)\n    {\n      int width_gap = width - mbswidth (name, 0);\n      int pad = MAX (0, width_gap);\n      dired_outstring (name);\n\n      do\n        dired_outbyte (' ');\n      while (pad--);\n    }\n  else\n    dired_pos += printf (\"%*\"PRIuMAX\" \", width, id);\n}\n\n \n\nstatic void\nformat_user (uid_t u, int width, bool stat_ok)\n{\n  format_user_or_group (! stat_ok ? \"?\" :\n                        (numeric_ids ? nullptr : getuser (u)), u, width);\n}\n\n \n\nstatic void\nformat_group (gid_t g, int width, bool stat_ok)\n{\n  format_user_or_group (! stat_ok ? \"?\" :\n                        (numeric_ids ? nullptr : getgroup (g)), g, width);\n}\n\n \n\nstatic int\nformat_user_or_group_width (char const *name, uintmax_t id)\n{\n  if (name)\n    {\n      int len = mbswidth (name, 0);\n      return MAX (0, len);\n    }\n  else\n    return snprintf (nullptr, 0, \"%\"PRIuMAX, id);\n}\n\n \n\nstatic int\nformat_user_width (uid_t u)\n{\n  return format_user_or_group_width (numeric_ids ? nullptr : getuser (u), u);\n}\n\n \n\nstatic int\nformat_group_width (gid_t g)\n{\n  return format_user_or_group_width (numeric_ids ? nullptr : getgroup (g), g);\n}\n\n \nstatic char *\nformat_inode (char buf[INT_BUFSIZE_BOUND (uintmax_t)],\n              const struct fileinfo *f)\n{\n  return (f->stat_ok && f->stat.st_ino != NOT_AN_INODE_NUMBER\n          ? umaxtostr (f->stat.st_ino, buf)\n          : (char *) \"?\");\n}\n\n \nstatic void\nprint_long_format (const struct fileinfo *f)\n{\n  char modebuf[12];\n  char buf\n    [LONGEST_HUMAN_READABLE + 1\t\t \n     + LONGEST_HUMAN_READABLE + 1\t \n     + sizeof (modebuf) - 1 + 1\t\t \n     + INT_BUFSIZE_BOUND (uintmax_t)\t \n     + LONGEST_HUMAN_READABLE + 2\t \n     + LONGEST_HUMAN_READABLE + 1\t \n     + TIME_STAMP_LEN_MAXIMUM + 1\t \n     ];\n  size_t s;\n  char *p;\n  struct timespec when_timespec;\n  struct tm when_local;\n  bool btime_ok = true;\n\n   \n  if (f->stat_ok)\n    filemodestring (&f->stat, modebuf);\n  else\n    {\n      modebuf[0] = filetype_letter[f->filetype];\n      memset (modebuf + 1, '?', 10);\n      modebuf[11] = '\\0';\n    }\n  if (! any_has_acl)\n    modebuf[10] = '\\0';\n  else if (f->acl_type == ACL_T_LSM_CONTEXT_ONLY)\n    modebuf[10] = '.';\n  else if (f->acl_type == ACL_T_YES)\n    modebuf[10] = '+';\n\n  switch (time_type)\n    {\n    case time_ctime:\n      when_timespec = get_stat_ctime (&f->stat);\n      break;\n    case time_mtime:\n      when_timespec = get_stat_mtime (&f->stat);\n      break;\n    case time_atime:\n      when_timespec = get_stat_atime (&f->stat);\n      break;\n    case time_btime:\n      when_timespec = get_stat_btime (&f->stat);\n      if (when_timespec.tv_sec == -1 && when_timespec.tv_nsec == -1)\n        btime_ok = false;\n      break;\n    default:\n      unreachable ();\n    }\n\n  p = buf;\n\n  if (print_inode)\n    {\n      char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n      p += sprintf (p, \"%*s \", inode_number_width, format_inode (hbuf, f));\n    }\n\n  if (print_block_size)\n    {\n      char hbuf[LONGEST_HUMAN_READABLE + 1];\n      char const *blocks =\n        (! f->stat_ok\n         ? \"?\"\n         : human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,\n                           ST_NBLOCKSIZE, output_block_size));\n      int pad;\n      for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)\n        *p++ = ' ';\n      while ((*p++ = *blocks++))\n        continue;\n      p[-1] = ' ';\n    }\n\n   \n  {\n    char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n    p += sprintf (p, \"%s %*s \", modebuf, nlink_width,\n                  ! f->stat_ok ? \"?\" : umaxtostr (f->stat.st_nlink, hbuf));\n  }\n\n  dired_indent ();\n\n  if (print_owner || print_group || print_author || print_scontext)\n    {\n      dired_outbuf (buf, p - buf);\n\n      if (print_owner)\n        format_user (f->stat.st_uid, owner_width, f->stat_ok);\n\n      if (print_group)\n        format_group (f->stat.st_gid, group_width, f->stat_ok);\n\n      if (print_author)\n        format_user (f->stat.st_author, author_width, f->stat_ok);\n\n      if (print_scontext)\n        format_user_or_group (f->scontext, 0, scontext_width);\n\n      p = buf;\n    }\n\n  if (f->stat_ok\n      && (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))\n    {\n      char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n      char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];\n      int blanks_width = (file_size_width\n                          - (major_device_number_width + 2\n                             + minor_device_number_width));\n      p += sprintf (p, \"%*s, %*s \",\n                    major_device_number_width + MAX (0, blanks_width),\n                    umaxtostr (major (f->stat.st_rdev), majorbuf),\n                    minor_device_number_width,\n                    umaxtostr (minor (f->stat.st_rdev), minorbuf));\n    }\n  else\n    {\n      char hbuf[LONGEST_HUMAN_READABLE + 1];\n      char const *size =\n        (! f->stat_ok\n         ? \"?\"\n         : human_readable (unsigned_file_size (f->stat.st_size),\n                           hbuf, file_human_output_opts, 1,\n                           file_output_block_size));\n      int pad;\n      for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)\n        *p++ = ' ';\n      while ((*p++ = *size++))\n        continue;\n      p[-1] = ' ';\n    }\n\n  s = 0;\n  *p = '\\1';\n\n  if (f->stat_ok && btime_ok\n      && localtime_rz (localtz, &when_timespec.tv_sec, &when_local))\n    {\n      struct timespec six_months_ago;\n      bool recent;\n\n       \n      if (timespec_cmp (current_time, when_timespec) < 0)\n        gettime (&current_time);\n\n       \n      six_months_ago.tv_sec = current_time.tv_sec - 31556952 / 2;\n      six_months_ago.tv_nsec = current_time.tv_nsec;\n\n      recent = (timespec_cmp (six_months_ago, when_timespec) < 0\n                && timespec_cmp (when_timespec, current_time) < 0);\n\n       \n      s = align_nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, recent,\n                           &when_local, localtz, when_timespec.tv_nsec);\n    }\n\n  if (s || !*p)\n    {\n      p += s;\n      *p++ = ' ';\n    }\n  else\n    {\n       \n      char hbuf[INT_BUFSIZE_BOUND (intmax_t)];\n      p += sprintf (p, \"%*s \", long_time_expected_width (),\n                    (! f->stat_ok || ! btime_ok\n                     ? \"?\"\n                     : timetostr (when_timespec.tv_sec, hbuf)));\n       \n    }\n\n  dired_outbuf (buf, p - buf);\n  size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);\n\n  if (f->filetype == symbolic_link)\n    {\n      if (f->linkname)\n        {\n          dired_outstring (\" -> \");\n          print_name_with_quoting (f, true, nullptr, (p - buf) + w + 4);\n          if (indicator_style != none)\n            print_type_indicator (true, f->linkmode, unknown);\n        }\n    }\n  else if (indicator_style != none)\n    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);\n}\n\n \n\nstatic size_t\nquote_name_buf (char **inbuf, size_t bufsize, char *name,\n                struct quoting_options const *options,\n                int needs_general_quoting, size_t *width, bool *pad)\n{\n  char *buf = *inbuf;\n  size_t displayed_width IF_LINT ( = 0);\n  size_t len = 0;\n  bool quoted;\n\n  enum quoting_style qs = get_quoting_style (options);\n  bool needs_further_quoting = qmark_funny_chars\n                               && (qs == shell_quoting_style\n                                   || qs == shell_always_quoting_style\n                                   || qs == literal_quoting_style);\n\n  if (needs_general_quoting != 0)\n    {\n      len = quotearg_buffer (buf, bufsize, name, -1, options);\n      if (bufsize <= len)\n        {\n          buf = xmalloc (len + 1);\n          quotearg_buffer (buf, len + 1, name, -1, options);\n        }\n\n      quoted = (*name != *buf) || strlen (name) != len;\n    }\n  else if (needs_further_quoting)\n    {\n      len = strlen (name);\n      if (bufsize <= len)\n        buf = xmalloc (len + 1);\n      memcpy (buf, name, len + 1);\n\n      quoted = false;\n    }\n  else\n    {\n      len = strlen (name);\n      buf = name;\n      quoted = false;\n    }\n\n  if (needs_further_quoting)\n    {\n      if (MB_CUR_MAX > 1)\n        {\n          char const *p = buf;\n          char const *plimit = buf + len;\n          char *q = buf;\n          displayed_width = 0;\n\n          while (p < plimit)\n            switch (*p)\n              {\n                case ' ': case '!': case '\"': case '#': case '%':\n                case '&': case '\\'': case '(': case ')': case '*':\n                case '+': case ',': case '-': case '.': case '/':\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case ':': case ';': case '<': case '=': case '>':\n                case '?':\n                case 'A': case 'B': case 'C': case 'D': case 'E':\n                case 'F': case 'G': case 'H': case 'I': case 'J':\n                case 'K': case 'L': case 'M': case 'N': case 'O':\n                case 'P': case 'Q': case 'R': case 'S': case 'T':\n                case 'U': case 'V': case 'W': case 'X': case 'Y':\n                case 'Z':\n                case '[': case '\\\\': case ']': case '^': case '_':\n                case 'a': case 'b': case 'c': case 'd': case 'e':\n                case 'f': case 'g': case 'h': case 'i': case 'j':\n                case 'k': case 'l': case 'm': case 'n': case 'o':\n                case 'p': case 'q': case 'r': case 's': case 't':\n                case 'u': case 'v': case 'w': case 'x': case 'y':\n                case 'z': case '{': case '|': case '}': case '~':\n                   \n                  *q++ = *p++;\n                  displayed_width += 1;\n                  break;\n                default:\n                   \n                  {\n                    mbstate_t mbstate = { 0, };\n                    do\n                      {\n                        wchar_t wc;\n                        size_t bytes;\n                        int w;\n\n                        bytes = mbrtowc (&wc, p, plimit - p, &mbstate);\n\n                        if (bytes == (size_t) -1)\n                          {\n                             \n                            p++;\n                            *q++ = '?';\n                            displayed_width += 1;\n                            break;\n                          }\n\n                        if (bytes == (size_t) -2)\n                          {\n                             \n                            p = plimit;\n                            *q++ = '?';\n                            displayed_width += 1;\n                            break;\n                          }\n\n                        if (bytes == 0)\n                           \n                          bytes = 1;\n\n                        w = wcwidth (wc);\n                        if (w >= 0)\n                          {\n                             \n                            for (; bytes > 0; --bytes)\n                              *q++ = *p++;\n                            displayed_width += w;\n                          }\n                        else\n                          {\n                             \n                            p += bytes;\n                            *q++ = '?';\n                            displayed_width += 1;\n                          }\n                      }\n                    while (! mbsinit (&mbstate));\n                  }\n                  break;\n              }\n\n           \n          len = q - buf;\n        }\n      else\n        {\n          char *p = buf;\n          char const *plimit = buf + len;\n\n          while (p < plimit)\n            {\n              if (! isprint (to_uchar (*p)))\n                *p = '?';\n              p++;\n            }\n          displayed_width = len;\n        }\n    }\n  else if (width != nullptr)\n    {\n      if (MB_CUR_MAX > 1)\n        displayed_width = mbsnwidth (buf, len, 0);\n      else\n        {\n          char const *p = buf;\n          char const *plimit = buf + len;\n\n          displayed_width = 0;\n          while (p < plimit)\n            {\n              if (isprint (to_uchar (*p)))\n                displayed_width++;\n              p++;\n            }\n        }\n    }\n\n   \n  *pad = (align_variable_outer_quotes && cwd_some_quoted && ! quoted);\n\n  if (width != nullptr)\n    *width = displayed_width;\n\n  *inbuf = buf;\n\n  return len;\n}\n\nstatic size_t\nquote_name_width (char const *name, struct quoting_options const *options,\n                  int needs_general_quoting)\n{\n  char smallbuf[BUFSIZ];\n  char *buf = smallbuf;\n  size_t width;\n  bool pad;\n\n  quote_name_buf (&buf, sizeof smallbuf, (char *) name, options,\n                  needs_general_quoting, &width, &pad);\n\n  if (buf != smallbuf && buf != name)\n    free (buf);\n\n  width += pad;\n\n  return width;\n}\n\n \nstatic char *\nfile_escape (char const *str, bool path)\n{\n  char *esc = xnmalloc (3, strlen (str) + 1);\n  char *p = esc;\n  while (*str)\n    {\n      if (path && ISSLASH (*str))\n        {\n          *p++ = '/';\n          str++;\n        }\n      else if (RFC3986[to_uchar (*str)])\n        *p++ = *str++;\n      else\n        p += sprintf (p, \"%%%02x\", to_uchar (*str++));\n    }\n  *p = '\\0';\n  return esc;\n}\n\nstatic size_t\nquote_name (char const *name, struct quoting_options const *options,\n            int needs_general_quoting, const struct bin_str *color,\n            bool allow_pad, struct obstack *stack, char const *absolute_name)\n{\n  char smallbuf[BUFSIZ];\n  char *buf = smallbuf;\n  size_t len;\n  bool pad;\n\n  len = quote_name_buf (&buf, sizeof smallbuf, (char *) name, options,\n                        needs_general_quoting, nullptr, &pad);\n\n  if (pad && allow_pad)\n    dired_outbyte (' ');\n\n  if (color)\n    print_color_indicator (color);\n\n   \n  bool skip_quotes = false;\n\n  if (absolute_name)\n    {\n      if (align_variable_outer_quotes && cwd_some_quoted && ! pad)\n        {\n          skip_quotes = true;\n          putchar (*buf);\n        }\n      char *h = file_escape (hostname,   false);\n      char *n = file_escape (absolute_name,   true);\n       \n      printf (\"\\033]8;;file:\n      free (h);\n      free (n);\n    }\n\n  if (stack)\n    push_current_dired_pos (stack);\n\n  fwrite (buf + skip_quotes, 1, len - (skip_quotes * 2), stdout);\n\n  dired_pos += len;\n\n  if (stack)\n    push_current_dired_pos (stack);\n\n  if (absolute_name)\n    {\n      fputs (\"\\033]8;;\\a\", stdout);\n      if (skip_quotes)\n        putchar (*(buf + len - 1));\n    }\n\n  if (buf != smallbuf && buf != name)\n    free (buf);\n\n  return len + pad;\n}\n\nstatic size_t\nprint_name_with_quoting (const struct fileinfo *f,\n                         bool symlink_target,\n                         struct obstack *stack,\n                         size_t start_col)\n{\n  char const *name = symlink_target ? f->linkname : f->name;\n\n  const struct bin_str *color\n    = print_with_color ? get_color_indicator (f, symlink_target) : nullptr;\n\n  bool used_color_this_time = (print_with_color\n                               && (color || is_colored (C_NORM)));\n\n  size_t len = quote_name (name, filename_quoting_options, f->quoted,\n                           color, !symlink_target, stack, f->absolute_name);\n\n  process_signals ();\n  if (used_color_this_time)\n    {\n      prep_non_filename_text ();\n\n      /* We use the byte length rather than display width here as\n         an optimization to avoid accurately calculating the width,\n         because we only output the clear to EOL sequence if the name\n         _might_ wrap to the next line.  This may output a sequence\n         unnecessarily in multi-byte locales for example,\n         but in that case it's inconsequential to the output.  */\n      if (line_length\n          && (start_col / line_length != (start_col + len - 1) / line_length))\n        put_indicator (&color_indicator[C_CLR_TO_EOL]);\n    }\n\n  return len;\n}\n\nstatic void\nprep_non_filename_text (void)\n{\n  if (color_indicator[C_END].string != nullptr)\n    put_indicator (&color_indicator[C_END]);\n  else\n    {\n      put_indicator (&color_indicator[C_LEFT]);\n      put_indicator (&color_indicator[C_RESET]);\n      put_indicator (&color_indicator[C_RIGHT]);\n    }\n}\n\n/* Print the file name of 'f' with appropriate quoting.\n   Also print file size, inode number, and filetype indicator character,\n   as requested by switches.  */\n\nstatic size_t\nprint_file_name_and_frills (const struct fileinfo *f, size_t start_col)\n{\n  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];\n\n  set_normal_color ();\n\n  if (print_inode)\n    printf (\"%*s \", format == with_commas ? 0 : inode_number_width,\n            format_inode (buf, f));\n\n  if (print_block_size)\n    printf (\"%*s \", format == with_commas ? 0 : block_size_width,\n            ! f->stat_ok ? \"?\"\n            : human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,\n                              ST_NBLOCKSIZE, output_block_size));\n\n  if (print_scontext)\n    printf (\"%*s \", format == with_commas ? 0 : scontext_width, f->scontext);\n\n  size_t width = print_name_with_quoting (f, false, nullptr, start_col);\n\n  if (indicator_style != none)\n    width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);\n\n  return width;\n}\n\n/* Given these arguments describing a file, return the single-byte\n   type indicator, or 0.  */\nstatic char\nget_type_indicator (bool stat_ok, mode_t mode, enum filetype type)\n{\n  char c;\n\n  if (stat_ok ? S_ISREG (mode) : type == normal)\n    {\n      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))\n        c = '*';\n      else\n        c = 0;\n    }\n  else\n    {\n      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)\n        c = '/';\n      else if (indicator_style == slash)\n        c = 0;\n      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)\n        c = '@';\n      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)\n        c = '|';\n      else if (stat_ok ? S_ISSOCK (mode) : type == sock)\n        c = '=';\n      else if (stat_ok && S_ISDOOR (mode))\n        c = '>';\n      else\n        c = 0;\n    }\n  return c;\n}\n\nstatic bool\nprint_type_indicator (bool stat_ok, mode_t mode, enum filetype type)\n{\n  char c = get_type_indicator (stat_ok, mode, type);\n  if (c)\n    dired_outbyte (c);\n  return !!c;\n}\n\n/* Returns if color sequence was printed.  */\nstatic bool\nprint_color_indicator (const struct bin_str *ind)\n{\n  if (ind)\n    {\n      /* Need to reset so not dealing with attribute combinations */\n      if (is_colored (C_NORM))\n        restore_default_color ();\n      put_indicator (&color_indicator[C_LEFT]);\n      put_indicator (ind);\n      put_indicator (&color_indicator[C_RIGHT]);\n    }\n\n  return ind != nullptr;\n}\n\n/* Returns color indicator or nullptr if none.  */\nATTRIBUTE_PURE\nstatic const struct bin_str*\nget_color_indicator (const struct fileinfo *f, bool symlink_target)\n{\n  enum indicator_no type;\n  struct color_ext_type *ext;\t/* Color extension */\n  size_t len;\t\t\t/* Length of name */\n\n  char const *name;\n  mode_t mode;\n  int linkok;\n  if (symlink_target)\n    {\n      name = f->linkname;\n      mode = f->linkmode;\n      linkok = f->linkok ? 0 : -1;\n    }\n  else\n    {\n      name = f->name;\n      mode = file_or_link_mode (f);\n      linkok = f->linkok;\n    }\n\n  /* Is this a nonexistent file?  If so, linkok == -1.  */\n\n  if (linkok == -1 && is_colored (C_MISSING))\n    type = C_MISSING;\n  else if (!f->stat_ok)\n    {\n      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n      type = filetype_indicator[f->filetype];\n    }\n  else\n    {\n      if (S_ISREG (mode))\n        {\n          type = C_FILE;\n\n          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n            type = C_SETUID;\n          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n            type = C_SETGID;\n          else if (is_colored (C_CAP) && f->has_capability)\n            type = C_CAP;\n          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n            type = C_EXEC;\n          else if ((1 < f->stat.st_nlink) && is_colored (C_MULTIHARDLINK))\n            type = C_MULTIHARDLINK;\n        }\n      else if (S_ISDIR (mode))\n        {\n          type = C_DIR;\n\n          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n              && is_colored (C_STICKY_OTHER_WRITABLE))\n            type = C_STICKY_OTHER_WRITABLE;\n          else if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n            type = C_OTHER_WRITABLE;\n          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n            type = C_STICKY;\n        }\n      else if (S_ISLNK (mode))\n        type = C_LINK;\n      else if (S_ISFIFO (mode))\n        type = C_FIFO;\n      else if (S_ISSOCK (mode))\n        type = C_SOCK;\n      else if (S_ISBLK (mode))\n        type = C_BLK;\n      else if (S_ISCHR (mode))\n        type = C_CHR;\n      else if (S_ISDOOR (mode))\n        type = C_DOOR;\n      else\n        {\n          /* Classify a file of some other type as C_ORPHAN.  */\n          type = C_ORPHAN;\n        }\n    }\n\n  /* Check the file's suffix only if still classified as C_FILE.  */\n  ext = nullptr;\n  if (type == C_FILE)\n    {\n      /* Test if NAME has a recognized suffix.  */\n\n      len = strlen (name);\n      name += len;\t\t/* Pointer to final \\0.  */\n      for (ext = color_ext_list; ext != nullptr; ext = ext->next)\n        {\n          if (ext->ext.len <= len)\n            {\n              if (ext->exact_match)\n                {\n                  if (STREQ_LEN (name - ext->ext.len, ext->ext.string,\n                                 ext->ext.len))\n                    break;\n                }\n              else\n                {\n                  if (c_strncasecmp (name - ext->ext.len, ext->ext.string,\n                                     ext->ext.len) == 0)\n                    break;\n                }\n            }\n        }\n    }\n\n  /* Adjust the color for orphaned symlinks.  */\n  if (type == C_LINK && !linkok)\n    {\n      if (color_symlink_as_referent || is_colored (C_ORPHAN))\n        type = C_ORPHAN;\n    }\n\n  const struct bin_str *const s\n    = ext ? &(ext->seq) : &color_indicator[type];\n\n  return s->string ? s : nullptr;\n}\n\n/* Output a color indicator (which may contain nulls).  */\nstatic void\nput_indicator (const struct bin_str *ind)\n{\n  if (! used_color)\n    {\n      used_color = true;\n\n      /* If the standard output is a controlling terminal, watch out\n         for signals, so that the colors can be restored to the\n         default state if \"ls\" is suspended or interrupted.  */\n\n      if (0 <= tcgetpgrp (STDOUT_FILENO))\n        signal_init ();\n\n      prep_non_filename_text ();\n    }\n\n  fwrite (ind->string, ind->len, 1, stdout);\n}\n\nstatic size_t\nlength_of_file_name_and_frills (const struct fileinfo *f)\n{\n  size_t len = 0;\n  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];\n\n  if (print_inode)\n    len += 1 + (format == with_commas\n                ? strlen (umaxtostr (f->stat.st_ino, buf))\n                : inode_number_width);\n\n  if (print_block_size)\n    len += 1 + (format == with_commas\n                ? strlen (! f->stat_ok ? \"?\"\n                          : human_readable (ST_NBLOCKS (f->stat), buf,\n                                            human_output_opts, ST_NBLOCKSIZE,\n                                            output_block_size))\n                : block_size_width);\n\n  if (print_scontext)\n    len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);\n\n  len += fileinfo_name_width (f);\n\n  if (indicator_style != none)\n    {\n      char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);\n      len += (c != 0);\n    }\n\n  return len;\n}\n\nstatic void\nprint_many_per_line (void)\n{\n  size_t row;\t\t\t/* Current row.  */\n  size_t cols = calculate_columns (true);\n  struct column_info const *line_fmt = &column_info[cols - 1];\n\n  /* Calculate the number of rows that will be in each column except possibly\n     for a short column on the right.  */\n  size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);\n\n  for (row = 0; row < rows; row++)\n    {\n      size_t col = 0;\n      size_t filesno = row;\n      size_t pos = 0;\n\n      /* Print the next row.  */\n      while (true)\n        {\n          struct fileinfo const *f = sorted_file[filesno];\n          size_t name_length = length_of_file_name_and_frills (f);\n          size_t max_name_length = line_fmt->col_arr[col++];\n          print_file_name_and_frills (f, pos);\n\n          filesno += rows;\n          if (filesno >= cwd_n_used)\n            break;\n\n          indent (pos + name_length, pos + max_name_length);\n          pos += max_name_length;\n        }\n      putchar (eolbyte);\n    }\n}\n\nstatic void\nprint_horizontal (void)\n{\n  size_t filesno;\n  size_t pos = 0;\n  size_t cols = calculate_columns (false);\n  struct column_info const *line_fmt = &column_info[cols - 1];\n  struct fileinfo const *f = sorted_file[0];\n  size_t name_length = length_of_file_name_and_frills (f);\n  size_t max_name_length = line_fmt->col_arr[0];\n\n  /* Print first entry.  */\n  print_file_name_and_frills (f, 0);\n\n  /* Now the rest.  */\n  for (filesno = 1; filesno < cwd_n_used; ++filesno)\n    {\n      size_t col = filesno % cols;\n\n      if (col == 0)\n        {\n          putchar (eolbyte);\n          pos = 0;\n        }\n      else\n        {\n          indent (pos + name_length, pos + max_name_length);\n          pos += max_name_length;\n        }\n\n      f = sorted_file[filesno];\n      print_file_name_and_frills (f, pos);\n\n      name_length = length_of_file_name_and_frills (f);\n      max_name_length = line_fmt->col_arr[col];\n    }\n  putchar (eolbyte);\n}\n\n/* Output name + SEP + ' '.  */\n\nstatic void\nprint_with_separator (char sep)\n{\n  size_t filesno;\n  size_t pos = 0;\n\n  for (filesno = 0; filesno < cwd_n_used; filesno++)\n    {\n      struct fileinfo const *f = sorted_file[filesno];\n      size_t len = line_length ? length_of_file_name_and_frills (f) : 0;\n\n      if (filesno != 0)\n        {\n          char separator;\n\n          if (! line_length\n              || ((pos + len + 2 < line_length)\n                  && (pos <= SIZE_MAX - len - 2)))\n            {\n              pos += 2;\n              separator = ' ';\n            }\n          else\n            {\n              pos = 0;\n              separator = eolbyte;\n            }\n\n          putchar (sep);\n          putchar (separator);\n        }\n\n      print_file_name_and_frills (f, pos);\n      pos += len;\n    }\n  putchar (eolbyte);\n}\n\n/* Assuming cursor is at position FROM, indent up to position TO.\n   Use a TAB character instead of two or more spaces whenever possible.  */\n\nstatic void\nindent (size_t from, size_t to)\n{\n  while (from < to)\n    {\n      if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)\n        {\n          putchar ('\\t');\n          from += tabsize - from % tabsize;\n        }\n      else\n        {\n          putchar (' ');\n          from++;\n        }\n    }\n}\n\n/* Put DIRNAME/NAME into DEST, handling '.' and '/' properly.  */\n/* FIXME: maybe remove this function someday.  See about using a\n   non-malloc'ing version of file_name_concat.  */\n\nstatic void\nattach (char *dest, char const *dirname, char const *name)\n{\n  char const *dirnamep = dirname;\n\n  /* Copy dirname if it is not \".\".  */\n  if (dirname[0] != '.' || dirname[1] != 0)\n    {\n      while (*dirnamep)\n        *dest++ = *dirnamep++;\n      /* Add '/' if 'dirname' doesn't already end with it.  */\n      if (dirnamep > dirname && dirnamep[-1] != '/')\n        *dest++ = '/';\n    }\n  while (*name)\n    *dest++ = *name++;\n  *dest = 0;\n}\n\n/* Allocate enough column info suitable for the current number of\n   files and display columns, and initialize the info to represent the\n   narrowest possible columns.  */\n\nstatic void\ninit_column_info (size_t max_cols)\n{\n  size_t i;\n\n  /* Currently allocated columns in column_info.  */\n  static size_t column_info_alloc;\n\n  if (column_info_alloc < max_cols)\n    {\n      size_t new_column_info_alloc;\n      size_t *p;\n\n      if (!max_idx || max_cols < max_idx / 2)\n        {\n          /* The number of columns is far less than the display width\n             allows.  Grow the allocation, but only so that it's\n             double the current requirements.  If the display is\n             extremely wide, this avoids allocating a lot of memory\n             that is never needed.  */\n          column_info = xnrealloc (column_info, max_cols,\n                                   2 * sizeof *column_info);\n          new_column_info_alloc = 2 * max_cols;\n        }\n      else\n        {\n          column_info = xnrealloc (column_info, max_idx, sizeof *column_info);\n          new_column_info_alloc = max_idx;\n        }\n\n      /* Allocate the new size_t objects by computing the triangle\n         formula n * (n + 1) / 2, except that we don't need to\n         allocate the part of the triangle that we've already\n         allocated.  Check for address arithmetic overflow.  */\n      {\n        size_t column_info_growth = new_column_info_alloc - column_info_alloc;\n        size_t s = column_info_alloc + 1 + new_column_info_alloc;\n        size_t t = s * column_info_growth;\n        if (s < new_column_info_alloc || t / column_info_growth != s)\n          xalloc_die ();\n        p = xnmalloc (t / 2, sizeof *p);\n      }\n\n      /* Grow the triangle by parceling out the cells just allocated.  */\n      for (i = column_info_alloc; i < new_column_info_alloc; i++)\n        {\n          column_info[i].col_arr = p;\n          p += i + 1;\n        }\n\n      column_info_alloc = new_column_info_alloc;\n    }\n\n  for (i = 0; i < max_cols; ++i)\n    {\n      size_t j;\n\n      column_info[i].valid_len = true;\n      column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;\n      for (j = 0; j <= i; ++j)\n        column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;\n    }\n}\n\n/* Calculate the number of columns needed to represent the current set\n   of files in the current display width.  */\n\nstatic size_t\ncalculate_columns (bool by_columns)\n{\n  size_t filesno;\t\t/* Index into cwd_file.  */\n  size_t cols;\t\t\t/* Number of files across.  */\n\n  /* Normally the maximum number of columns is determined by the\n     screen width.  But if few files are available this might limit it\n     as well.  */\n  size_t max_cols = 0 < max_idx && max_idx < cwd_n_used ? max_idx : cwd_n_used;\n\n  init_column_info (max_cols);\n\n  /* Compute the maximum number of possible columns.  */\n  for (filesno = 0; filesno < cwd_n_used; ++filesno)\n    {\n      struct fileinfo const *f = sorted_file[filesno];\n      size_t name_length = length_of_file_name_and_frills (f);\n\n      for (size_t i = 0; i < max_cols; ++i)\n        {\n          if (column_info[i].valid_len)\n            {\n              size_t idx = (by_columns\n                            ? filesno / ((cwd_n_used + i) / (i + 1))\n                            : filesno % (i + 1));\n              size_t real_length = name_length + (idx == i ? 0 : 2);\n\n              if (column_info[i].col_arr[idx] < real_length)\n                {\n                  column_info[i].line_len += (real_length\n                                              - column_info[i].col_arr[idx]);\n                  column_info[i].col_arr[idx] = real_length;\n                  column_info[i].valid_len = (column_info[i].line_len\n                                              < line_length);\n                }\n            }\n        }\n    }\n\n  /* Find maximum allowed columns.  */\n  for (cols = max_cols; 1 < cols; --cols)\n    {\n      if (column_info[cols - 1].valid_len)\n        break;\n    }\n\n  return cols;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [FILE]...\\n\"), program_name);\n      fputs (_(\"\\\nList information about the FILEs (the current directory by default).\\n\\\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -a, --all                  do not ignore entries starting with .\\n\\\n  -A, --almost-all           do not list implied . and ..\\n\\\n      --author               with -l, print the author of each file\\n\\\n  -b, --escape               print C-style escapes for nongraphic characters\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\\n\\\n                             e.g., '--block-size=M'; see SIZE format below\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -B, --ignore-backups       do not list implied entries ending with ~\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -c                         with -lt: sort by, and show, ctime (time of last\\n\\\n                             change of file status information);\\n\\\n                             with -l: show ctime and sort by name;\\n\\\n                             otherwise: sort by ctime, newest first\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -C                         list entries by columns\\n\\\n      --color[=WHEN]         color the output WHEN; more info below\\n\\\n  -d, --directory            list directories themselves, not their contents\\n\\\n  -D, --dired                generate output designed for Emacs' dired mode\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f                         list all entries in directory order\\n\\\n  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\\n\\\n      --file-type            likewise, except do not append '*'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --format=WORD          across -x, commas -m, horizontal -x, long -l,\\n\\\n                             single-column -1, verbose -l, vertical -C\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --full-time            like -l --time-style=full-iso\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -g                         like -l, but do not list owner\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --group-directories-first\\n\\\n                             group directories before files;\\n\\\n                             can be augmented with a --sort option, but any\\n\\\n                             use of --sort=none (-U) disables grouping\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -G, --no-group             in a long listing, don't print group names\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\\n\\\n      --si                   likewise, but use powers of 1000 not 1024\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -H, --dereference-command-line\\n\\\n                             follow symbolic links listed on the command line\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --dereference-command-line-symlink-to-dir\\n\\\n                             follow each command line symbolic link\\n\\\n                             that points to a directory\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --hide=PATTERN         do not list implied entries matching shell PATTERN\\\n\\n\\\n                             (overridden by -a or -A)\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --hyperlink[=WHEN]     hyperlink file names WHEN\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --indicator-style=WORD\\n\\\n                             append indicator with style WORD to entry names:\\n\\\n                             none (default), slash (-p),\\n\\\n                             file-type (--file-type), classify (-F)\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -i, --inode                print the index number of each file\\n\\\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -k, --kibibytes            default to 1024-byte blocks for file system usage;\\\n\\n\\\n                             used only with -s and per directory totals\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -l                         use a long listing format\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -L, --dereference          when showing file information for a symbolic\\n\\\n                             link, show information for the file the link\\n\\\n                             references rather than for the link itself\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -m                         fill width with a comma separated list of entries\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\\n\\\n  -N, --literal              print entry names without quoting\\n\\\n  -o                         like -l, but do not list group information\\n\\\n  -p, --indicator-style=slash\\n\\\n                             append / indicator to directories\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -q, --hide-control-chars   print ? instead of nongraphic characters\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --show-control-chars   show nongraphic characters as-is (the default,\\n\\\n                             unless program is 'ls' and output is a terminal)\\\n\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -Q, --quote-name           enclose entry names in double quotes\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --quoting-style=WORD   use quoting style WORD for entry names:\\n\\\n                             literal, locale, shell, shell-always,\\n\\\n                             shell-escape, shell-escape-always, c, escape\\n\\\n                             (overrides QUOTING_STYLE environment variable)\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -r, --reverse              reverse order while sorting\\n\\\n  -R, --recursive            list subdirectories recursively\\n\\\n  -s, --size                 print the allocated size of each file, in blocks\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -S                         sort by file size, largest first\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --sort=WORD            sort by WORD instead of name: none (-U), size (-S)\\\n,\\n\\\n                             time (-t), version (-v), extension (-X), width\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --time=WORD            select which timestamp used to display or sort;\\n\\\n                               access time (-u): atime, access, use;\\n\\\n                               metadata change time (-c): ctime, status;\\n\\\n                               modified time (default): mtime, modification;\\n\\\n                               birth time: birth, creation;\\n\\\n                             with -l, WORD determines which time to show;\\n\\\n                             with --sort=time, sort by WORD (newest first)\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --time-style=TIME_STYLE\\n\\\n                             time/date format with -l; see TIME_STYLE below\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t                         sort by time, newest first; see --time\\n\\\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -u                         with -lt: sort by, and show, access time;\\n\\\n                             with -l: show access time and sort by name;\\n\\\n                             otherwise: sort by access time, newest first\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -U                         do not sort; list entries in directory order\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v                         natural sort of (version) numbers within text\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -w, --width=COLS           set output width to COLS.  0 means no limit\\n\\\n  -x                         list entries by lines instead of by columns\\n\\\n  -X                         sort alphabetically by entry extension\\n\\\n  -Z, --context              print any security context of each file\\n\\\n      --zero                 end each output line with NUL, not newline\\n\\\n  -1                         list one file per line\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_size_note ();\n      fputs (_(\"\\\n\\n\\\nThe TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\\n\\\nFORMAT is interpreted like in date(1).  If FORMAT is FORMAT1<newline>FORMAT2,\\n\\\nthen FORMAT1 applies to non-recent files and FORMAT2 to recent files.\\n\\\nTIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX locale.\\n\\\nAlso the TIME_STYLE environment variable sets the default style to use.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nThe WHEN argument defaults to 'always' and can also be 'auto' or 'never'.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nUsing color to distinguish file types is disabled both by default and\\n\\\nwith --color=never.  With --color=auto, ls emits color codes only when\\n\\\nstandard output is connected to a terminal.  The LS_COLORS environment\\n\\\nvariable can change the settings.  Use the dircolors(1) command to set it.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nExit status:\\n\\\n 0  if OK,\\n\\\n 1  if minor problems (e.g., cannot access subdirectory),\\n\\\n 2  if serious trouble (e.g., cannot access command-line argument).\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}