{
  "module_name": "set-fields.c",
  "hash_id": "972c1ed9748481955b34fc720ff9348b412cf45610895e5ed2e7522330b1f65e",
  "original_prompt": "Ingested from coreutils-9.4/src/set-fields.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"system.h\"\n#include \"quote.h\"\n#include \"set-fields.h\"\n\n \nstruct field_range_pair *frp;\n\n \nsize_t n_frp;\n\n \nstatic size_t n_frp_allocated;\n\n#define FATAL_ERROR(Message)                                            \\\n  do                                                                    \\\n    {                                                                   \\\n      error (0, 0, (Message));                                          \\\n      usage (EXIT_FAILURE);                                             \\\n    }                                                                   \\\n  while (0)\n\n \nstatic void\nadd_range_pair (uintmax_t lo, uintmax_t hi)\n{\n  if (n_frp == n_frp_allocated)\n    frp = X2NREALLOC (frp, &n_frp_allocated);\n  frp[n_frp].lo = lo;\n  frp[n_frp].hi = hi;\n  ++n_frp;\n}\n\n\n \nstatic int\ncompare_ranges (const void *a, const void *b)\n{\n  struct field_range_pair const *ap = a, *bp = b;\n  return (ap->lo > bp->lo) - (ap->lo < bp->lo);\n}\n\n \n\nstatic void\ncomplement_rp (void)\n{\n  struct field_range_pair *c = frp;\n  size_t n = n_frp;\n\n  frp = nullptr;\n  n_frp = 0;\n  n_frp_allocated = 0;\n\n  if (c[0].lo > 1)\n    add_range_pair (1, c[0].lo - 1);\n\n  for (size_t i = 1; i < n; ++i)\n    {\n      if (c[i - 1].hi + 1 == c[i].lo)\n        continue;\n\n      add_range_pair (c[i - 1].hi + 1, c[i].lo - 1);\n    }\n\n  if (c[n - 1].hi < UINTMAX_MAX)\n    add_range_pair (c[n - 1].hi + 1, UINTMAX_MAX);\n\n  free (c);\n}\n\n \nvoid\nset_fields (char const *fieldstr, unsigned int options)\n{\n  uintmax_t initial = 1;\t \n  uintmax_t value = 0;\t\t \n  bool lhs_specified = false;\n  bool rhs_specified = false;\n  bool dash_found = false;\t \n\n  bool in_digits = false;\n\n   \n\n   \n  if ((options & SETFLD_ALLOW_DASH) && STREQ (fieldstr,\"-\"))\n    {\n      value = 1;\n      lhs_specified = true;\n      dash_found = true;\n      fieldstr++;\n    }\n\n  while (true)\n    {\n      if (*fieldstr == '-')\n        {\n          in_digits = false;\n           \n          if (dash_found)\n            FATAL_ERROR ((options & SETFLD_ERRMSG_USE_POS)\n                         ? _(\"invalid byte or character range\")\n                         : _(\"invalid field range\"));\n\n          dash_found = true;\n          fieldstr++;\n\n          if (lhs_specified && !value)\n            FATAL_ERROR ((options & SETFLD_ERRMSG_USE_POS)\n                         ? _(\"byte/character positions are numbered from 1\")\n                         : _(\"fields are numbered from 1\"));\n\n          initial = (lhs_specified ? value : 1);\n          value = 0;\n        }\n      else if (*fieldstr == ','\n               || isblank (to_uchar (*fieldstr)) || *fieldstr == '\\0')\n        {\n          in_digits = false;\n           \n          if (dash_found)\n            {\n              dash_found = false;\n\n              if (!lhs_specified && !rhs_specified)\n                {\n                   \n                  if (options & SETFLD_ALLOW_DASH)\n                    initial = 1;\n                  else\n                    FATAL_ERROR (_(\"invalid range with no endpoint: -\"));\n                }\n\n               \n              if (!rhs_specified)\n                {\n                   \n                  add_range_pair (initial, UINTMAX_MAX);\n                }\n              else\n                {\n                   \n                  if (value < initial)\n                    FATAL_ERROR (_(\"invalid decreasing range\"));\n\n                  add_range_pair (initial, value);\n                }\n              value = 0;\n            }\n          else\n            {\n               \n              if (value == 0)\n                FATAL_ERROR ((options & SETFLD_ERRMSG_USE_POS)\n                             ? _(\"byte/character positions are numbered from 1\")\n                             : _(\"fields are numbered from 1\"));\n\n              add_range_pair (value, value);\n              value = 0;\n            }\n\n          if (*fieldstr == '\\0')\n            break;\n\n          fieldstr++;\n          lhs_specified = false;\n          rhs_specified = false;\n        }\n      else if (ISDIGIT (*fieldstr))\n        {\n           \n          static char const *num_start;\n          if (!in_digits || !num_start)\n            num_start = fieldstr;\n          in_digits = true;\n\n          if (dash_found)\n            rhs_specified = 1;\n          else\n            lhs_specified = 1;\n\n           \n          if (!DECIMAL_DIGIT_ACCUMULATE (value, *fieldstr - '0', uintmax_t)\n              || value == UINTMAX_MAX)\n            {\n               \n               \n              size_t len = strspn (num_start, \"0123456789\");\n              char *bad_num = ximemdup0 (num_start, len);\n              error (0, 0, (options & SETFLD_ERRMSG_USE_POS)\n                           ?_(\"byte/character offset %s is too large\")\n                           :_(\"field number %s is too large\"),\n                           quote (bad_num));\n              free (bad_num);\n              usage (EXIT_FAILURE);\n            }\n\n          fieldstr++;\n        }\n      else\n        {\n          error (0, 0, (options & SETFLD_ERRMSG_USE_POS)\n                       ?_(\"invalid byte/character position %s\")\n                       :_(\"invalid field value %s\"),\n                       quote (fieldstr));\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (!n_frp)\n    FATAL_ERROR ((options&SETFLD_ERRMSG_USE_POS)\n                 ? _(\"missing list of byte/character positions\")\n                 : _(\"missing list of fields\"));\n\n  qsort (frp, n_frp, sizeof (frp[0]), compare_ranges);\n\n   \n  for (size_t i = 0; i < n_frp; ++i)\n    {\n      for (size_t j = i + 1; j < n_frp; ++j)\n        {\n          if (frp[j].lo <= frp[i].hi)\n            {\n              frp[i].hi = MAX (frp[j].hi, frp[i].hi);\n              memmove (frp + j, frp + j + 1, (n_frp - j - 1) * sizeof *frp);\n              n_frp--;\n              j--;\n            }\n          else\n            break;\n        }\n    }\n\n  if (options & SETFLD_COMPLEMENT)\n    complement_rp ();\n\n   \n  ++n_frp;\n  frp = xrealloc (frp, n_frp * sizeof (struct field_range_pair));\n  frp[n_frp - 1].lo = frp[n_frp - 1].hi = UINTMAX_MAX;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}