{
  "module_name": "cat.c",
  "hash_id": "a847f838ef995fab3cf4840723b7accd10f0175c86841f15f9d8c465b877b0cc",
  "original_prompt": "Ingested from coreutils-9.4/src/cat.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdckdint.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#if HAVE_STROPTS_H\n# include <stropts.h>\n#endif\n#include <sys/ioctl.h>\n\n#include \"system.h\"\n#include \"alignalloc.h\"\n#include \"ioblksize.h\"\n#include \"fadvise.h\"\n#include \"full-write.h\"\n#include \"safe-read.h\"\n#include \"xbinary-io.h\"\n\n \n#define PROGRAM_NAME \"cat\"\n\n#define AUTHORS \\\n  proper_name_lite (\"Torbjorn Granlund\", \"Torbj\\303\\266rn Granlund\"), \\\n  proper_name (\"Richard M. Stallman\")\n\n \nstatic char const *infile;\n\n \nstatic int input_desc;\n\n \n#define LINE_COUNTER_BUF_LEN 20\nstatic char line_buf[LINE_COUNTER_BUF_LEN] =\n  {\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0',\n    '\\t', '\\0'\n  };\n\n \nstatic char *line_num_print = line_buf + LINE_COUNTER_BUF_LEN - 8;\n\n \nstatic char *line_num_start = line_buf + LINE_COUNTER_BUF_LEN - 3;\n\n \nstatic char *line_num_end = line_buf + LINE_COUNTER_BUF_LEN - 3;\n\n \nstatic int newlines2 = 0;\n\n \nstatic bool pending_cr = false;\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nConcatenate FILE(s) to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n\n      fputs (_(\"\\\n\\n\\\n  -A, --show-all           equivalent to -vET\\n\\\n  -b, --number-nonblank    number nonempty output lines, overrides -n\\n\\\n  -e                       equivalent to -vE\\n\\\n  -E, --show-ends          display $ at end of each line\\n\\\n  -n, --number             number all output lines\\n\\\n  -s, --squeeze-blank      suppress repeated empty output lines\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t                       equivalent to -vT\\n\\\n  -T, --show-tabs          display TAB characters as ^I\\n\\\n  -u                       (ignored)\\n\\\n  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      printf (_(\"\\\n\\n\\\nExamples:\\n\\\n  %s f - g  Output f's contents, then standard input, then g's contents.\\n\\\n  %s        Copy standard input to standard output.\\n\\\n\"),\n              program_name, program_name);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Compute the next line number.  */\n\nstatic void\nnext_line_num (void)\n{\n  char *endp = line_num_end;\n  do\n    {\n      if ((*endp)++ < '9')\n        return;\n      *endp-- = '0';\n    }\n  while (endp >= line_num_start);\n\n  if (line_num_start > line_buf)\n    *--line_num_start = '1';\n  else\n    *line_buf = '>';\n  if (line_num_start < line_num_print)\n    line_num_print--;\n}\n\n/* Plain cat.  Copy the file behind 'input_desc' to STDOUT_FILENO.\n   BUF (of size BUFSIZE) is the I/O buffer, used by reads and writes.\n   Return true if successful.  */\n\nstatic bool\nsimple_cat (char *buf, idx_t bufsize)\n{\n  /* Loop until the end of the file.  */\n\n  while (true)\n    {\n      /* Read a block of input.  */\n\n      size_t n_read = safe_read (input_desc, buf, bufsize);\n      if (n_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, \"%s\", quotef (infile));\n          return false;\n        }\n\n      /* End of this file?  */\n\n      if (n_read == 0)\n        return true;\n\n      /* Write this block out.  */\n\n      if (full_write (STDOUT_FILENO, buf, n_read) != n_read)\n        write_error ();\n    }\n}\n\n/* Write any pending output to STDOUT_FILENO.\n   Pending is defined to be the *BPOUT - OUTBUF bytes starting at OUTBUF.\n   Then set *BPOUT to OUTPUT if it's not already that value.  */\n\nstatic inline void\nwrite_pending (char *outbuf, char **bpout)\n{\n  idx_t n_write = *bpout - outbuf;\n  if (0 < n_write)\n    {\n      if (full_write (STDOUT_FILENO, outbuf, n_write) != n_write)\n        write_error ();\n      *bpout = outbuf;\n    }\n}\n\n/* Copy the file behind 'input_desc' to STDOUT_FILENO.\n   Use INBUF and read INSIZE with each call,\n   and OUTBUF and write OUTSIZE with each call.\n   (The buffers are a bit larger than the I/O sizes.)\n   The remaining boolean args say what 'cat' options to use.\n\n   Return true if successful.\n   Called if any option more than -u was specified.\n\n   A newline character is always put at the end of the buffer, to make\n   an explicit test for buffer end unnecessary.  */\n\nstatic bool\ncat (char *inbuf, idx_t insize, char *outbuf, idx_t outsize,\n     bool show_nonprinting, bool show_tabs, bool number, bool number_nonblank,\n     bool show_ends, bool squeeze_blank)\n{\n  /* Last character read from the input buffer.  */\n  unsigned char ch;\n\n  /* Determines how many consecutive newlines there have been in the\n     input.  0 newlines makes NEWLINES -1, 1 newline makes NEWLINES 1,\n     etc.  Initially 0 to indicate that we are at the beginning of a\n     new line.  The \"state\" of the procedure is determined by\n     NEWLINES.  */\n  int newlines = newlines2;\n\n#ifdef FIONREAD\n  /* If nonzero, use the FIONREAD ioctl, as an optimization.\n     (On Ultrix, it is not supported on NFS file systems.)  */\n  bool use_fionread = true;\n#endif\n\n  /* The inbuf pointers are initialized so that BPIN > EOB, and thereby input\n     is read immediately.  */\n\n  /* Pointer to the first non-valid byte in the input buffer, i.e., the\n     current end of the buffer.  */\n  char *eob = inbuf;\n\n  /* Pointer to the next character in the input buffer.  */\n  char *bpin = eob + 1;\n\n  /* Pointer to the position where the next character shall be written.  */\n  char *bpout = outbuf;\n\n  while (true)\n    {\n      do\n        {\n          /* Write if there are at least OUTSIZE bytes in OUTBUF.  */\n\n          if (outbuf + outsize <= bpout)\n            {\n              char *wp = outbuf;\n              idx_t remaining_bytes;\n              do\n                {\n                  if (full_write (STDOUT_FILENO, wp, outsize) != outsize)\n                    write_error ();\n                  wp += outsize;\n                  remaining_bytes = bpout - wp;\n                }\n              while (outsize <= remaining_bytes);\n\n              /* Move the remaining bytes to the beginning of the\n                 buffer.  */\n\n              memmove (outbuf, wp, remaining_bytes);\n              bpout = outbuf + remaining_bytes;\n            }\n\n          /* Is INBUF empty?  */\n\n          if (bpin > eob)\n            {\n              bool input_pending = false;\n#ifdef FIONREAD\n              int n_to_read = 0;\n\n              /* Is there any input to read immediately?\n                 If not, we are about to wait,\n                 so write all buffered output before waiting.  */\n\n              if (use_fionread\n                  && ioctl (input_desc, FIONREAD, &n_to_read) < 0)\n                {\n                  /* Ultrix returns EOPNOTSUPP on NFS;\n                     HP-UX returns ENOTTY on pipes.\n                     SunOS returns EINVAL and\n                     More/BSD returns ENODEV on special files\n                     like /dev/null.\n                     Irix-5 returns ENOSYS on pipes.  */\n                  if (errno == EOPNOTSUPP || errno == ENOTTY\n                      || errno == EINVAL || errno == ENODEV\n                      || errno == ENOSYS)\n                    use_fionread = false;\n                  else\n                    {\n                      error (0, errno, _(\"cannot do ioctl on %s\"),\n                             quoteaf (infile));\n                      newlines2 = newlines;\n                      return false;\n                    }\n                }\n              if (n_to_read != 0)\n                input_pending = true;\n#endif\n\n              if (!input_pending)\n                write_pending (outbuf, &bpout);\n\n              /* Read more input into INBUF.  */\n\n              size_t n_read = safe_read (input_desc, inbuf, insize);\n              if (n_read == SAFE_READ_ERROR)\n                {\n                  error (0, errno, \"%s\", quotef (infile));\n                  write_pending (outbuf, &bpout);\n                  newlines2 = newlines;\n                  return false;\n                }\n              if (n_read == 0)\n                {\n                  write_pending (outbuf, &bpout);\n                  newlines2 = newlines;\n                  return true;\n                }\n\n              /* Update the pointers and insert a sentinel at the buffer\n                 end.  */\n\n              bpin = inbuf;\n              eob = bpin + n_read;\n              *eob = '\\n';\n            }\n          else\n            {\n              /* It was a real (not a sentinel) newline.  */\n\n              /* Was the last line empty?\n                 (i.e., have two or more consecutive newlines been read?)  */\n\n              if (++newlines > 0)\n                {\n                  if (newlines >= 2)\n                    {\n                      /* Limit this to 2 here.  Otherwise, with lots of\n                         consecutive newlines, the counter could wrap\n                         around at INT_MAX.  */\n                      newlines = 2;\n\n                      /* Are multiple adjacent empty lines to be substituted\n                         by single ditto (-s), and this was the second empty\n                         line?  */\n                      if (squeeze_blank)\n                        {\n                          ch = *bpin++;\n                          continue;\n                        }\n                    }\n\n                  /* Are line numbers to be written at empty lines (-n)?  */\n\n                  if (number && !number_nonblank)\n                    {\n                      next_line_num ();\n                      bpout = stpcpy (bpout, line_num_print);\n                    }\n                }\n\n              /* Output a currency symbol if requested (-e).  */\n              if (show_ends)\n                {\n                  if (pending_cr)\n                    {\n                      *bpout++ = '^';\n                      *bpout++ = 'M';\n                      pending_cr = false;\n                    }\n                  *bpout++ = '$';\n                }\n\n              /* Output the newline.  */\n\n              *bpout++ = '\\n';\n            }\n          ch = *bpin++;\n        }\n      while (ch == '\\n');\n\n      /* Here CH cannot contain a newline character.  */\n\n      if (pending_cr)\n        {\n          *bpout++ = '\\r';\n          pending_cr = false;\n        }\n\n      /* Are we at the beginning of a line, and line numbers are requested?  */\n\n      if (newlines >= 0 && number)\n        {\n          next_line_num ();\n          bpout = stpcpy (bpout, line_num_print);\n        }\n\n      /* The loops below continue until a newline character is found,\n         which means that the buffer is empty or that a proper newline\n         has been found.  */\n\n      /* If quoting, i.e., at least one of -v, -e, or -t specified,\n         scan for chars that need conversion.  */\n      if (show_nonprinting)\n        {\n          while (true)\n            {\n              if (ch >= 32)\n                {\n                  if (ch < 127)\n                    *bpout++ = ch;\n                  else if (ch == 127)\n                    {\n                      *bpout++ = '^';\n                      *bpout++ = '?';\n                    }\n                  else\n                    {\n                      *bpout++ = 'M';\n                      *bpout++ = '-';\n                      if (ch >= 128 + 32)\n                        {\n                          if (ch < 128 + 127)\n                            *bpout++ = ch - 128;\n                          else\n                            {\n                              *bpout++ = '^';\n                              *bpout++ = '?';\n                            }\n                        }\n                      else\n                        {\n                          *bpout++ = '^';\n                          *bpout++ = ch - 128 + 64;\n                        }\n                    }\n                }\n              else if (ch == '\\t' && !show_tabs)\n                *bpout++ = '\\t';\n              else if (ch == '\\n')\n                {\n                  newlines = -1;\n                  break;\n                }\n              else\n                {\n                  *bpout++ = '^';\n                  *bpout++ = ch + 64;\n                }\n\n              ch = *bpin++;\n            }\n        }\n      else\n        {\n          /* Not quoting, neither of -v, -e, or -t specified.  */\n          while (true)\n            {\n              if (ch == '\\t' && show_tabs)\n                {\n                  *bpout++ = '^';\n                  *bpout++ = ch + 64;\n                }\n              else if (ch != '\\n')\n                {\n                  if (ch == '\\r' && *bpin == '\\n' && show_ends)\n                    {\n                      if (bpin == eob)\n                        pending_cr = true;\n                      else\n                        {\n                          *bpout++ = '^';\n                          *bpout++ = 'M';\n                        }\n                    }\n                  else\n                    *bpout++ = ch;\n                }\n              else\n                {\n                  newlines = -1;\n                  break;\n                }\n\n              ch = *bpin++;\n            }\n        }\n    }\n}\n\n/* Copy data from input to output using copy_file_range if possible.\n   Return 1 if successful, 0 if ordinary read+write should be tried,\n   -1 if a serious problem has been diagnosed.  */\n\nstatic int\ncopy_cat (void)\n{\n  /* Copy at most COPY_MAX bytes at a time; this is min\n     (SSIZE_MAX, SIZE_MAX) truncated to a value that is\n     surely aligned well.  */\n  ssize_t copy_max = MIN (SSIZE_MAX, SIZE_MAX) >> 30 << 30;\n\n  /* copy_file_range does not support some cases, and it\n     incorrectly returns 0 when reading from the proc file\n     system on the Linux kernel through at least 5.6.19 (2020),\n     so fall back on read+write if the copy_file_range is\n     unsupported or the input file seems empty.  */\n\n  for (bool some_copied = false; ; some_copied = true)\n    switch (copy_file_range (input_desc, nullptr, STDOUT_FILENO, nullptr,\n                             copy_max, 0))\n      {\n      case 0:\n        return some_copied;\n\n      case -1:\n        if (errno == ENOSYS || is_ENOTSUP (errno) || errno == EINVAL\n            || errno == EBADF || errno == EXDEV || errno == ETXTBSY\n            || errno == EPERM)\n          return 0;\n        error (0, errno, \"%s\", quotef (infile));\n        return -1;\n      }\n}\n\n\nint\nmain (int argc, char **argv)\n{\n  /* Nonzero if we have ever read standard input.  */\n  bool have_read_stdin = false;\n\n  struct stat stat_buf;\n\n  /* Variables that are set according to the specified options.  */\n  bool number = false;\n  bool number_nonblank = false;\n  bool squeeze_blank = false;\n  bool show_ends = false;\n  bool show_nonprinting = false;\n  bool show_tabs = false;\n  int file_open_mode = O_RDONLY;\n\n  static struct option const long_options[] =\n  {\n    {\"number-nonblank\", no_argument, nullptr, 'b'},\n    {\"number\", no_argument, nullptr, 'n'},\n    {\"squeeze-blank\", no_argument, nullptr, 's'},\n    {\"show-nonprinting\", no_argument, nullptr, 'v'},\n    {\"show-ends\", no_argument, nullptr, 'E'},\n    {\"show-tabs\", no_argument, nullptr, 'T'},\n    {\"show-all\", no_argument, nullptr, 'A'},\n    {GETOPT_HELP_OPTION_DECL},\n    {GETOPT_VERSION_OPTION_DECL},\n    {nullptr, 0, nullptr, 0}\n  };\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* Arrange to close stdout if we exit via the\n     case_GETOPT_HELP_CHAR or case_GETOPT_VERSION_CHAR code.\n     Normally STDOUT_FILENO is used rather than stdout, so\n     close_stdout does nothing.  */\n  atexit (close_stdout);\n\n  /* Parse command line options.  */\n\n  int c;\n  while ((c = getopt_long (argc, argv, \"benstuvAET\", long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'b':\n          number = true;\n          number_nonblank = true;\n          break;\n\n        case 'e':\n          show_ends = true;\n          show_nonprinting = true;\n          break;\n\n        case 'n':\n          number = true;\n          break;\n\n        case 's':\n          squeeze_blank = true;\n          break;\n\n        case 't':\n          show_tabs = true;\n          show_nonprinting = true;\n          break;\n\n        case 'u':\n          /* We provide the -u feature unconditionally.  */\n          break;\n\n        case 'v':\n          show_nonprinting = true;\n          break;\n\n        case 'A':\n          show_nonprinting = true;\n          show_ends = true;\n          show_tabs = true;\n          break;\n\n        case 'E':\n          show_ends = true;\n          break;\n\n        case 'T':\n          show_tabs = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  /* Get device, i-node number, and optimal blocksize of output.  */\n\n  if (fstat (STDOUT_FILENO, &stat_buf) < 0)\n    error (EXIT_FAILURE, errno, _(\"standard output\"));\n\n  /* Optimal size of i/o operations of output.  */\n  idx_t outsize = io_blksize (stat_buf);\n\n  /* Device and I-node number of the output.  */\n  dev_t out_dev = stat_buf.st_dev;\n  ino_t out_ino = stat_buf.st_ino;\n\n  /* True if the output is a regular file.  */\n  bool out_isreg = S_ISREG (stat_buf.st_mode) != 0;\n\n  if (! (number || show_ends || squeeze_blank))\n    {\n      file_open_mode |= O_BINARY;\n      xset_binary_mode (STDOUT_FILENO, O_BINARY);\n    }\n\n  /* Main loop.  */\n\n  infile = \"-\";\n  int argind = optind;\n  bool ok = true;\n  idx_t page_size = getpagesize ();\n\n  do\n    {\n      if (argind < argc)\n        infile = argv[argind];\n\n      bool reading_stdin = STREQ (infile, \"-\");\n      if (reading_stdin)\n        {\n          have_read_stdin = true;\n          input_desc = STDIN_FILENO;\n          if (file_open_mode & O_BINARY)\n            xset_binary_mode (STDIN_FILENO, O_BINARY);\n        }\n      else\n        {\n          input_desc = open (infile, file_open_mode);\n          if (input_desc < 0)\n            {\n              error (0, errno, \"%s\", quotef (infile));\n              ok = false;\n              continue;\n            }\n        }\n\n      if (fstat (input_desc, &stat_buf) < 0)\n        {\n          error (0, errno, \"%s\", quotef (infile));\n          ok = false;\n          goto contin;\n        }\n\n      /* Optimal size of i/o operations of input.  */\n      idx_t insize = io_blksize (stat_buf);\n\n      fdadvise (input_desc, 0, 0, FADVISE_SEQUENTIAL);\n\n      /* Don't copy a nonempty regular file to itself, as that would\n         merely exhaust the output device.  It's better to catch this\n         error earlier rather than later.  */\n\n      if (out_isreg\n          && stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino\n          && lseek (input_desc, 0, SEEK_CUR) < stat_buf.st_size)\n        {\n          error (0, 0, _(\"%s: input file is output file\"), quotef (infile));\n          ok = false;\n          goto contin;\n        }\n\n      /* Pointer to the input buffer.  */\n      char *inbuf;\n\n      /* Select which version of 'cat' to use.  If any format-oriented\n         options were given use 'cat'; if not, use 'copy_cat' if it\n         works, 'simple_cat' otherwise.  */\n\n      if (! (number || show_ends || show_nonprinting\n             || show_tabs || squeeze_blank))\n        {\n          int copy_cat_status =\n            out_isreg && S_ISREG (stat_buf.st_mode) ? copy_cat () : 0;\n          if (copy_cat_status != 0)\n            {\n              inbuf = nullptr;\n              ok &= 0 < copy_cat_status;\n            }\n          else\n            {\n              insize = MAX (insize, outsize);\n              inbuf = xalignalloc (page_size, insize);\n              ok &= simple_cat (inbuf, insize);\n            }\n        }\n      else\n        {\n          /* Allocate, with an extra byte for a newline sentinel.  */\n          inbuf = xalignalloc (page_size, insize + 1);\n\n          /* Why are\n             (OUTSIZE - 1 + INSIZE * 4 + LINE_COUNTER_BUF_LEN)\n             bytes allocated for the output buffer?\n\n             A test whether output needs to be written is done when the input\n             buffer empties or when a newline appears in the input.  After\n             output is written, at most (OUTSIZE - 1) bytes will remain in the\n             buffer.  Now INSIZE bytes of input is read.  Each input character\n             may grow by a factor of 4 (by the prepending of M-^).  If all\n             characters do, and no newlines appear in this block of input, we\n             will have at most (OUTSIZE - 1 + INSIZE * 4) bytes in the buffer.\n             If the last character in the preceding block of input was a\n             newline, a line number may be written (according to the given\n             options) as the first thing in the output buffer. (Done after the\n             new input is read, but before processing of the input begins.)\n             A line number requires seldom more than LINE_COUNTER_BUF_LEN\n             positions.\n\n             Align the output buffer to a page size boundary, for efficiency\n             on some paging implementations.  */\n\n          idx_t bufsize;\n          if (ckd_mul (&bufsize, insize, 4)\n              || ckd_add (&bufsize, bufsize, outsize)\n              || ckd_add (&bufsize, bufsize, LINE_COUNTER_BUF_LEN - 1))\n            xalloc_die ();\n          char *outbuf = xalignalloc (page_size, bufsize);\n\n          ok &= cat (inbuf, insize, outbuf, outsize, show_nonprinting,\n                     show_tabs, number, number_nonblank, show_ends,\n                     squeeze_blank);\n\n          alignfree (outbuf);\n        }\n\n      alignfree (inbuf);\n\n    contin:\n      if (!reading_stdin && close (input_desc) < 0)\n        {\n          error (0, errno, \"%s\", quotef (infile));\n          ok = false;\n        }\n    }\n  while (++argind < argc);\n\n  if (pending_cr)\n    {\n      if (full_write (STDOUT_FILENO, \"\\r\", 1) != 1)\n        write_error ();\n    }\n\n  if (have_read_stdin && close (STDIN_FILENO) < 0)\n    error (EXIT_FAILURE, errno, _(\"closing standard input\"));\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}