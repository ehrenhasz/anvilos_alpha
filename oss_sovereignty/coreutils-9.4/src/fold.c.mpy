{
  "module_name": "fold.c",
  "hash_id": "e368c556ea2adde25a2a0832e202bab76c11cda54ba2a2ed49e4490fa0f4e0ba",
  "original_prompt": "Ingested from coreutils-9.4/src/fold.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"fadvise.h\"\n#include \"xdectoint.h\"\n\n#define TAB_WIDTH 8\n\n \n#define PROGRAM_NAME \"fold\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\n \nstatic bool break_spaces;\n\n \nstatic bool count_bytes;\n\n \nstatic bool have_read_stdin;\n\nstatic char const shortopts[] = \"bsw:0::1::2::3::4::5::6::7::8::9::\";\n\nstatic struct option const longopts[] =\n{\n  {\"bytes\", no_argument, nullptr, 'b'},\n  {\"spaces\", no_argument, nullptr, 's'},\n  {\"width\", required_argument, nullptr, 'w'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nWrap input lines in each FILE, writing to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -b, --bytes         count bytes rather than columns\\n\\\n  -s, --spaces        break at spaces\\n\\\n  -w, --width=WIDTH   use WIDTH columns instead of 80\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Assuming the current column is COLUMN, return the column that\n   printing C will move the cursor to.\n   The first column is 0. */\n\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n        {\n          if (column > 0)\n            column--;\n        }\n      else if (c == '\\r')\n        column = 0;\n      else if (c == '\\t')\n        column += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n        column++;\n    }\n  else\n    column++;\n  return column;\n}\n\n/* Fold file FILENAME, or standard input if FILENAME is \"-\",\n   to stdout, with maximum line length WIDTH.\n   Return true if successful.  */\n\nstatic bool\nfold_file (char const *filename, size_t width)\n{\n  FILE *istream;\n  int c;\n  size_t column = 0;\t\t/* Screen column where next char will go. */\n  size_t offset_out = 0;\t/* Index in 'line_out' for next char. */\n  static char *line_out = nullptr;\n  static size_t allocated_out = 0;\n  int saved_errno;\n\n  if (STREQ (filename, \"-\"))\n    {\n      istream = stdin;\n      have_read_stdin = true;\n    }\n  else\n    istream = fopen (filename, \"r\");\n\n  if (istream == nullptr)\n    {\n      error (0, errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  fadvise (istream, FADVISE_SEQUENTIAL);\n\n  while ((c = getc (istream)) != EOF)\n    {\n      if (offset_out + 1 >= allocated_out)\n        line_out = X2REALLOC (line_out, &allocated_out);\n\n      if (c == '\\n')\n        {\n          line_out[offset_out++] = c;\n          fwrite (line_out, sizeof (char), offset_out, stdout);\n          column = offset_out = 0;\n          continue;\n        }\n\n    rescan:\n      column = adjust_column (column, c);\n\n      if (column > width)\n        {\n          /* This character would make the line too long.\n             Print the line plus a newline, and make this character\n             start the next line. */\n          if (break_spaces)\n            {\n              bool found_blank = false;\n              size_t logical_end = offset_out;\n\n              /* Look for the last blank. */\n              while (logical_end)\n                {\n                  --logical_end;\n                  if (isblank (to_uchar (line_out[logical_end])))\n                    {\n                      found_blank = true;\n                      break;\n                    }\n                }\n\n              if (found_blank)\n                {\n                  size_t i;\n\n                  /* Found a blank.  Don't output the part after it. */\n                  logical_end++;\n                  fwrite (line_out, sizeof (char), (size_t) logical_end,\n                          stdout);\n                  putchar ('\\n');\n                  /* Move the remainder to the beginning of the next line.\n                     The areas being copied here might overlap. */\n                  memmove (line_out, line_out + logical_end,\n                           offset_out - logical_end);\n                  offset_out -= logical_end;\n                  for (column = i = 0; i < offset_out; i++)\n                    column = adjust_column (column, line_out[i]);\n                  goto rescan;\n                }\n            }\n\n          if (offset_out == 0)\n            {\n              line_out[offset_out++] = c;\n              continue;\n            }\n\n          line_out[offset_out++] = '\\n';\n          fwrite (line_out, sizeof (char), (size_t) offset_out, stdout);\n          column = offset_out = 0;\n          goto rescan;\n        }\n\n      line_out[offset_out++] = c;\n    }\n\n  saved_errno = errno;\n  if (!ferror (istream))\n    saved_errno = 0;\n\n  if (offset_out)\n    fwrite (line_out, sizeof (char), (size_t) offset_out, stdout);\n\n  if (STREQ (filename, \"-\"))\n    clearerr (istream);\n  else if (fclose (istream) != 0 && !saved_errno)\n    saved_errno = errno;\n\n  if (saved_errno)\n    {\n      error (0, saved_errno, \"%s\", quotef (filename));\n      return false;\n    }\n\n  return true;\n}\n\nint\nmain (int argc, char **argv)\n{\n  size_t width = 80;\n  int i;\n  int optc;\n  bool ok;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  break_spaces = count_bytes = have_read_stdin = false;\n\n  while ((optc = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)\n    {\n      char optargbuf[2];\n\n      switch (optc)\n        {\n        case 'b':\t\t/* Count bytes rather than columns. */\n          count_bytes = true;\n          break;\n\n        case 's':\t\t/* Break at word boundaries. */\n          break_spaces = true;\n          break;\n\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n          if (optarg)\n            optarg--;\n          else\n            {\n              optargbuf[0] = optc;\n              optargbuf[1] = '\\0';\n              optarg = optargbuf;\n            }\n          FALLTHROUGH;\n        case 'w':\t\t/* Line width. */\n          width = xdectoumax (optarg, 1, SIZE_MAX - TAB_WIDTH - 1, \"\",\n                              _(\"invalid number of columns\"), 0);\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (argc == optind)\n    ok = fold_file (\"-\", width);\n  else\n    {\n      ok = true;\n      for (i = optind; i < argc; i++)\n        ok &= fold_file (argv[i], width);\n    }\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    error (EXIT_FAILURE, errno, \"-\");\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}