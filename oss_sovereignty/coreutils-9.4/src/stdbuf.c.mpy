{
  "module_name": "stdbuf.c",
  "hash_id": "239aad69c32cb7b72a9cfd6c9563d4cee3e827008c528417b774ded02e14233f",
  "original_prompt": "Ingested from coreutils-9.4/src/stdbuf.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"filenamecat.h\"\n#include \"quote.h\"\n#include \"xreadlink.h\"\n#include \"xstrtol.h\"\n#include \"c-ctype.h\"\n\n \n#define PROGRAM_NAME \"stdbuf\"\n#define LIB_NAME \"libstdbuf.so\"  \n\n#define AUTHORS proper_name_lite (\"Padraig Brady\", \"P\\303\\241draig Brady\")\n\nstatic char *program_path;\n\nstatic struct\n{\n  size_t size;\n  int optc;\n  char *optarg;\n} stdbuf[3];\n\nstatic struct option const longopts[] =\n{\n  {\"input\", required_argument, nullptr, 'i'},\n  {\"output\", required_argument, nullptr, 'o'},\n  {\"error\", required_argument, nullptr, 'e'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic int\nparse_size (char const *str, size_t *size)\n{\n  uintmax_t tmp_size;\n  enum strtol_error e = xstrtoumax (str, nullptr, 10,\n                                    &tmp_size, \"EGkKMPQRTYZ0\");\n  if (e == LONGINT_OK && SIZE_MAX < tmp_size)\n    e = LONGINT_OVERFLOW;\n\n  if (e == LONGINT_OK)\n    {\n      errno = 0;\n      *size = tmp_size;\n      return 0;\n    }\n\n  errno = (e == LONGINT_OVERFLOW ? EOVERFLOW : errno);\n  return -1;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s OPTION... COMMAND\\n\"), program_name);\n      fputs (_(\"\\\nRun COMMAND, with modified buffering operations for its standard streams.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -i, --input=MODE   adjust standard input stream buffering\\n\\\n  -o, --output=MODE  adjust standard output stream buffering\\n\\\n  -e, --error=MODE   adjust standard error stream buffering\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\n\\\nIf MODE is 'L' the corresponding stream will be line buffered.\\n\\\nThis option is invalid with standard input.\\n\"), stdout);\n      fputs (_(\"\\n\\\nIf MODE is '0' the corresponding stream will be unbuffered.\\n\\\n\"), stdout);\n      fputs (_(\"\\n\\\nOtherwise MODE is a number which may be followed by one of the following:\\n\\\nKB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G,T,P,E,Z,Y,R,Q.\\n\\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\\nIn this case the corresponding stream will be fully buffered with the buffer\\n\\\nsize set to MODE bytes.\\n\\\n\"), stdout);\n      fputs (_(\"\\n\\\nNOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\\n\\\nfor example) then that will override corresponding changes by 'stdbuf'.\\n\\\nAlso some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\\n\\\nand are thus unaffected by 'stdbuf' settings.\\n\\\n\"), stdout);\n      emit_exec_status (PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* argv[0] can be anything really, but generally it contains\n   the path to the executable or just a name if it was executed\n   using $PATH. In the latter case to get the path we can:\n   search getenv(\"PATH\"), readlink(\"/prof/self/exe\"), getenv(\"_\"),\n   dladdr(), pstat_getpathname(), etc.  */\n\nstatic void\nset_program_path (char const *arg)\n{\n  if (strchr (arg, '/'))        /* Use absolute or relative paths directly.  */\n    {\n      program_path = dir_name (arg);\n    }\n  else\n    {\n      char *path = xreadlink (\"/proc/self/exe\");\n      if (path)\n        program_path = dir_name (path);\n      else if ((path = getenv (\"PATH\")))\n        {\n          char *dir;\n          path = xstrdup (path);\n          for (dir = strtok (path, \":\"); dir != nullptr;\n               dir = strtok (nullptr, \":\"))\n            {\n              char *candidate = file_name_concat (dir, arg, nullptr);\n              if (access (candidate, X_OK) == 0)\n                {\n                  program_path = dir_name (candidate);\n                  free (candidate);\n                  break;\n                }\n              free (candidate);\n            }\n        }\n      free (path);\n    }\n}\n\nstatic int\noptc_to_fileno (int c)\n{\n  int ret = -1;\n\n  switch (c)\n    {\n    case 'e':\n      ret = STDERR_FILENO;\n      break;\n    case 'i':\n      ret = STDIN_FILENO;\n      break;\n    case 'o':\n      ret = STDOUT_FILENO;\n      break;\n    }\n\n  return ret;\n}\n\nstatic void\nset_LD_PRELOAD (void)\n{\n  int ret;\n#ifdef __APPLE__\n  char const *preload_env = \"DYLD_INSERT_LIBRARIES\";\n#else\n  char const *preload_env = \"LD_PRELOAD\";\n#endif\n  char *old_libs = getenv (preload_env);\n  char *LD_PRELOAD;\n\n  /* Note this would auto add the appropriate search path for \"libstdbuf.so\":\n     gcc stdbuf.c -Wl,-rpath,'$ORIGIN' -Wl,-rpath,$PKGLIBEXECDIR\n     However we want the lookup done for the exec'd command not stdbuf.\n\n     Since we don't link against libstdbuf.so add it to PKGLIBEXECDIR\n     rather than to LIBDIR.\n\n     Note we could add \"\" as the penultimate item in the following list\n     to enable searching for libstdbuf.so in the default system lib paths.\n     However that would not indicate an error if libstdbuf.so was not found.\n     Also while this could support auto selecting the right arch in a multilib\n     environment, what we really want is to auto select based on the arch of the\n     command being run, rather than that of stdbuf itself.  This is currently\n     not supported due to the unusual need for controlling the stdio buffering\n     of programs that are a different architecture to the default on the\n     system (and that of stdbuf itself).  */\n  char const *const search_path[] = {\n    program_path,\n    PKGLIBEXECDIR,\n    nullptr\n  };\n\n  char const *const *path = search_path;\n  char *libstdbuf;\n\n  while (true)\n    {\n      struct stat sb;\n\n      if (!**path)              /* system default  */\n        {\n          libstdbuf = xstrdup (LIB_NAME);\n          break;\n        }\n      ret = asprintf (&libstdbuf, \"%s/%s\", *path, LIB_NAME);\n      if (ret < 0)\n        xalloc_die ();\n      if (stat (libstdbuf, &sb) == 0)   /* file_exists  */\n        break;\n      free (libstdbuf);\n\n      ++path;\n      if ( ! *path)\n        error (EXIT_CANCELED, 0, _(\"failed to find %s\"), quote (LIB_NAME));\n    }\n\n  /* FIXME: Do we need to support libstdbuf.dll, c:, '\\' separators etc?  */\n\n  if (old_libs)\n    ret = asprintf (&LD_PRELOAD, \"%s=%s:%s\", preload_env, old_libs, libstdbuf);\n  else\n    ret = asprintf (&LD_PRELOAD, \"%s=%s\", preload_env, libstdbuf);\n\n  if (ret < 0)\n    xalloc_die ();\n\n  free (libstdbuf);\n\n  ret = putenv (LD_PRELOAD);\n#ifdef __APPLE__\n  if (ret == 0)\n    ret = setenv (\"DYLD_FORCE_FLAT_NAMESPACE\", \"y\", 1);\n#endif\n\n  if (ret != 0)\n    error (EXIT_CANCELED, errno,\n           _(\"failed to update the environment with %s\"),\n           quote (LD_PRELOAD));\n}\n\n/* Populate environ with _STDBUF_I=$MODE _STDBUF_O=$MODE _STDBUF_E=$MODE.\n   Return TRUE if any environment variables set.   */\n\nstatic bool\nset_libstdbuf_options (void)\n{\n  bool env_set = false;\n\n  for (size_t i = 0; i < ARRAY_CARDINALITY (stdbuf); i++)\n    {\n      if (stdbuf[i].optarg)\n        {\n          char *var;\n          int ret;\n\n          if (*stdbuf[i].optarg == 'L')\n            ret = asprintf (&var, \"%s%c=L\", \"_STDBUF_\",\n                            toupper (stdbuf[i].optc));\n          else\n            ret = asprintf (&var, \"%s%c=%\" PRIuMAX, \"_STDBUF_\",\n                            toupper (stdbuf[i].optc),\n                            (uintmax_t) stdbuf[i].size);\n          if (ret < 0)\n            xalloc_die ();\n\n          if (putenv (var) != 0)\n            error (EXIT_CANCELED, errno,\n                   _(\"failed to update the environment with %s\"),\n                   quote (var));\n\n          env_set = true;\n        }\n    }\n\n  return env_set;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXIT_CANCELED);\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"+i:o:e:\", longopts, nullptr)) != -1)\n    {\n      int opt_fileno;\n\n      switch (c)\n        {\n        /* Old McDonald had a farm ei...  */\n        case 'e':\n        case 'i':\n        case 'o':\n          opt_fileno = optc_to_fileno (c);\n          affirm (0 <= opt_fileno && opt_fileno < ARRAY_CARDINALITY (stdbuf));\n          stdbuf[opt_fileno].optc = c;\n          while (c_isspace (*optarg))\n            optarg++;\n          stdbuf[opt_fileno].optarg = optarg;\n          if (c == 'i' && *optarg == 'L')\n            {\n              /* -oL will be by far the most common use of this utility,\n                 but one could easily think -iL might have the same affect,\n                 so disallow it as it could be confusing.  */\n              error (0, 0, _(\"line buffering stdin is meaningless\"));\n              usage (EXIT_CANCELED);\n            }\n\n          if (!STREQ (optarg, \"L\")\n              && parse_size (optarg, &stdbuf[opt_fileno].size) == -1)\n            error (EXIT_CANCELED, errno, _(\"invalid mode %s\"), quote (optarg));\n\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_CANCELED);\n        }\n    }\n\n  argv += optind;\n  argc -= optind;\n\n  /* must specify at least 1 command.  */\n  if (argc < 1)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_CANCELED);\n    }\n\n  if (! set_libstdbuf_options ())\n    {\n      error (0, 0, _(\"you must specify a buffering mode option\"));\n      usage (EXIT_CANCELED);\n    }\n\n  /* Try to preload libstdbuf first from the same path as\n     stdbuf is running from.  */\n  set_program_path (program_name);\n  if (!program_path)\n    program_path = xstrdup (PKGLIBDIR);  /* Need to init to non-null.  */\n  set_LD_PRELOAD ();\n  free (program_path);\n\n  execvp (*argv, argv);\n\n  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n  error (0, errno, _(\"failed to run command %s\"), quote (argv[0]));\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}