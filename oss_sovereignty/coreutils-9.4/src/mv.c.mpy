{
  "module_name": "mv.c",
  "hash_id": "d47dba706d68daa1186a4a48ada3035c0b282ca821533c2cfe71da2468c7f855",
  "original_prompt": "Ingested from coreutils-9.4/src/mv.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <selinux/label.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"backupfile.h\"\n#include \"copy.h\"\n#include \"cp-hash.h\"\n#include \"filenamecat.h\"\n#include \"remove.h\"\n#include \"renameatu.h\"\n#include \"root-dev-ino.h\"\n#include \"targetdir.h\"\n#include \"priv-set.h\"\n\n \n#define PROGRAM_NAME \"mv\"\n\n#define AUTHORS \\\n  proper_name (\"Mike Parker\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\n \nenum\n{\n  DEBUG_OPTION = CHAR_MAX + 1,\n  NO_COPY_OPTION,\n  STRIP_TRAILING_SLASHES_OPTION\n};\n\nstatic char const *const update_type_string[] =\n{\n  \"all\", \"none\", \"older\", nullptr\n};\nstatic enum Update_type const update_type[] =\n{\n  UPDATE_ALL, UPDATE_NONE, UPDATE_OLDER,\n};\nARGMATCH_VERIFY (update_type_string, update_type);\n\nstatic struct option const long_options[] =\n{\n  {\"backup\", optional_argument, nullptr, 'b'},\n  {\"context\", no_argument, nullptr, 'Z'},\n  {\"debug\", no_argument, nullptr, DEBUG_OPTION},\n  {\"force\", no_argument, nullptr, 'f'},\n  {\"interactive\", no_argument, nullptr, 'i'},\n  {\"no-clobber\", no_argument, nullptr, 'n'},\n  {\"no-copy\", no_argument, nullptr, NO_COPY_OPTION},\n  {\"no-target-directory\", no_argument, nullptr, 'T'},\n  {\"strip-trailing-slashes\", no_argument, nullptr,\n   STRIP_TRAILING_SLASHES_OPTION},\n  {\"suffix\", required_argument, nullptr, 'S'},\n  {\"target-directory\", required_argument, nullptr, 't'},\n  {\"update\", optional_argument, nullptr, 'u'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nstatic void\nrm_option_init (struct rm_options *x)\n{\n  x->ignore_missing_files = false;\n  x->remove_empty_directories = true;\n  x->recursive = true;\n  x->one_file_system = false;\n\n   \n  x->interactive = RMI_NEVER;\n  x->stdin_tty = false;\n\n  x->verbose = false;\n\n   \n  x->require_restore_cwd = true;\n\n  {\n    static struct dev_ino dev_ino_buf;\n    x->root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n    if (x->root_dev_ino == nullptr)\n      error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n             quoteaf (\"/\"));\n  }\n\n  x->preserve_all_root = false;\n}\n\nstatic void\ncp_option_init (struct cp_options *x)\n{\n  bool selinux_enabled = (0 < is_selinux_enabled ());\n\n  cp_options_default (x);\n  x->copy_as_regular = false;   \n  x->reflink_mode = REFLINK_AUTO;\n  x->dereference = DEREF_NEVER;\n  x->unlink_dest_before_opening = false;\n  x->unlink_dest_after_failed_open = false;\n  x->hard_link = false;\n  x->interactive = I_UNSPECIFIED;\n  x->move_mode = true;\n  x->install_mode = false;\n  x->one_file_system = false;\n  x->preserve_ownership = true;\n  x->preserve_links = true;\n  x->preserve_mode = true;\n  x->preserve_timestamps = true;\n  x->explicit_no_preserve_mode= false;\n  x->preserve_security_context = selinux_enabled;\n  x->set_security_context = nullptr;\n  x->reduce_diagnostics = false;\n  x->data_copy_required = true;\n  x->require_preserve = false;   \n  x->require_preserve_context = false;\n  x->preserve_xattr = true;\n  x->require_preserve_xattr = false;\n  x->recursive = true;\n  x->sparse_mode = SPARSE_AUTO;   \n  x->symbolic_link = false;\n  x->set_mode = false;\n  x->mode = 0;\n  x->stdin_tty = isatty (STDIN_FILENO);\n\n  x->open_dangling_dest_symlink = false;\n  x->update = false;\n  x->verbose = false;\n  x->dest_info = nullptr;\n  x->src_info = nullptr;\n}\n\n \n\nstatic bool\ndo_move (char const *source, char const *dest,\n         int dest_dirfd, char const *dest_relname, const struct cp_options *x)\n{\n  bool copy_into_self;\n  bool rename_succeeded;\n  bool ok = copy (source, dest, dest_dirfd, dest_relname, 0, x,\n                  &copy_into_self, &rename_succeeded);\n\n  if (ok)\n    {\n      char const *dir_to_remove;\n      if (copy_into_self)\n        {\n           \n\n          dir_to_remove = nullptr;\n          ok = false;\n        }\n      else if (rename_succeeded)\n        {\n           \n          dir_to_remove = nullptr;\n        }\n      else\n        {\n           \n\n          dir_to_remove = source;\n        }\n\n      if (dir_to_remove != nullptr)\n        {\n          struct rm_options rm_options;\n          enum RM_status status;\n          char const *dir[2];\n\n          rm_option_init (&rm_options);\n          rm_options.verbose = x->verbose;\n          dir[0] = dir_to_remove;\n          dir[1] = nullptr;\n\n          status = rm ((void *) dir, &rm_options);\n          affirm (VALID_STATUS (status));\n          if (status == RM_ERROR)\n            ok = false;\n        }\n    }\n\n  return ok;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [-T] SOURCE DEST\\n\\\n  or:  %s [OPTION]... SOURCE... DIRECTORY\\n\\\n  or:  %s [OPTION]... -t DIRECTORY SOURCE...\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\\nRename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n      --backup[=CONTROL]       make a backup of each existing destination file\\\n\\n\\\n  -b                           like --backup but does not accept an argument\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --debug                  explain how a file is copied.  Implies -v\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f, --force                  do not prompt before overwriting\\n\\\n  -i, --interactive            prompt before overwrite\\n\\\n  -n, --no-clobber             do not overwrite an existing file\\n\\\nIf you specify more than one of -i, -f, -n, only the final one takes effect.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --no-copy                do not copy if renaming fails\\n\\\n      --strip-trailing-slashes  remove any trailing slashes from each SOURCE\\n\\\n                                 argument\\n\\\n  -S, --suffix=SUFFIX          override the usual backup suffix\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY\\n\\\n  -T, --no-target-directory    treat DEST as a normal file\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  --update[=UPDATE]            control which existing files are updated;\\n\\\n                                 UPDATE={all,none,older(default)}.  See below\\n\\\n  -u                           equivalent to --update[=older]\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --verbose                explain what is being done\\n\\\n  -Z, --context                set SELinux security context of destination\\n\\\n                                 file to default type\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_update_parameters_note ();\n      emit_backup_suffix_note ();\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n  bool ok;\n  bool make_backups = false;\n  char const *backup_suffix = nullptr;\n  char *version_control_string = nullptr;\n  struct cp_options x;\n  bool remove_trailing_slashes = false;\n  char const *target_directory = nullptr;\n  bool no_target_directory = false;\n  int n_files;\n  char **file;\n  bool selinux_enabled = (0 < is_selinux_enabled ());\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdin);\n\n  cp_option_init (&x);\n\n  /* Try to disable the ability to unlink a directory.  */\n  priv_set_remove_linkdir ();\n\n  while ((c = getopt_long (argc, argv, \"bfint:uvS:TZ\", long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'b':\n          make_backups = true;\n          if (optarg)\n            version_control_string = optarg;\n          break;\n        case 'f':\n          x.interactive = I_ALWAYS_YES;\n          break;\n        case 'i':\n          x.interactive = I_ASK_USER;\n          break;\n        case 'n':\n          x.interactive = I_ALWAYS_NO;\n          break;\n        case DEBUG_OPTION:\n          x.debug = x.verbose = true;\n          break;\n        case NO_COPY_OPTION:\n          x.no_copy = true;\n          break;\n        case STRIP_TRAILING_SLASHES_OPTION:\n          remove_trailing_slashes = true;\n          break;\n        case 't':\n          if (target_directory)\n            error (EXIT_FAILURE, 0, _(\"multiple target directories specified\"));\n          target_directory = optarg;\n          break;\n        case 'T':\n          no_target_directory = true;\n          break;\n        case 'u':\n          if (optarg == nullptr)\n            x.update = true;\n          else if (x.interactive != I_ALWAYS_NO)  /* -n takes precedence.  */\n            {\n              enum Update_type update_opt;\n              update_opt = XARGMATCH (\"--update\", optarg,\n                                      update_type_string, update_type);\n              if (update_opt == UPDATE_ALL)\n                {\n                  /* Default mv operation.  */\n                  x.update = false;\n                  x.interactive = I_UNSPECIFIED;\n                }\n              else if (update_opt == UPDATE_NONE)\n                {\n                  x.update = false;\n                  x.interactive = I_ALWAYS_SKIP;\n                }\n              else if (update_opt == UPDATE_OLDER)\n                {\n                  x.update = true;\n                  x.interactive = I_UNSPECIFIED;\n                }\n            }\n          break;\n        case 'v':\n          x.verbose = true;\n          break;\n        case 'S':\n          make_backups = true;\n          backup_suffix = optarg;\n          break;\n        case 'Z':\n          /* As a performance enhancement, don't even bother trying\n             to \"restorecon\" when not on an selinux-enabled kernel.  */\n          if (selinux_enabled)\n            {\n              x.preserve_security_context = false;\n              x.set_security_context = selabel_open (SELABEL_CTX_FILE,\n                                                     nullptr, 0);\n              if (! x.set_security_context)\n                error (0, errno, _(\"warning: ignoring --context\"));\n            }\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  n_files = argc - optind;\n  file = argv + optind;\n\n  if (n_files <= !target_directory)\n    {\n      if (n_files <= 0)\n        error (0, 0, _(\"missing file operand\"));\n      else\n        error (0, 0, _(\"missing destination file operand after %s\"),\n               quoteaf (file[0]));\n      usage (EXIT_FAILURE);\n    }\n\n  struct stat sb;\n  sb.st_mode = 0;\n  int target_dirfd = AT_FDCWD;\n  if (no_target_directory)\n    {\n      if (target_directory)\n        error (EXIT_FAILURE, 0,\n               _(\"cannot combine --target-directory (-t) \"\n                 \"and --no-target-directory (-T)\"));\n      if (2 < n_files)\n        {\n          error (0, 0, _(\"extra operand %s\"), quoteaf (file[2]));\n          usage (EXIT_FAILURE);\n        }\n    }\n  else if (target_directory)\n    {\n      target_dirfd = target_directory_operand (target_directory, &sb);\n      if (! target_dirfd_valid (target_dirfd))\n        error (EXIT_FAILURE, errno, _(\"target directory %s\"),\n               quoteaf (target_directory));\n    }\n  else\n    {\n      char const *lastfile = file[n_files - 1];\n      if (n_files == 2)\n        x.rename_errno = (renameatu (AT_FDCWD, file[0], AT_FDCWD, lastfile,\n                                     RENAME_NOREPLACE)\n                          ? errno : 0);\n      if (x.rename_errno != 0)\n        {\n          int fd = target_directory_operand (lastfile, &sb);\n          if (target_dirfd_valid (fd))\n            {\n              x.rename_errno = -1;\n              target_dirfd = fd;\n              target_directory = lastfile;\n              n_files--;\n            }\n          else\n            {\n              /* The last operand LASTFILE cannot be opened as a directory.\n                 If there are more than two operands, report an error.\n\n                 Also, report an error if LASTFILE is known to be a directory\n                 even though it could not be opened, which can happen if\n                 opening failed with EACCES on a platform lacking O_PATH.\n                 In this case use stat to test whether LASTFILE is a\n                 directory, in case opening a non-directory with (O_SEARCH\n                 | O_DIRECTORY) failed with EACCES not ENOTDIR.  */\n              int err = errno;\n              if (2 < n_files\n                  || (O_PATHSEARCH == O_SEARCH && err == EACCES\n                      && (sb.st_mode != 0 || stat (lastfile, &sb) == 0)\n                      && S_ISDIR (sb.st_mode)))\n                error (EXIT_FAILURE, err, _(\"target %s\"), quoteaf (lastfile));\n            }\n        }\n    }\n\n  /* Handle the ambiguity in the semantics of mv induced by the\n     varying semantics of the rename function.  POSIX-compatible\n     systems (e.g., GNU/Linux) have a rename function that honors a\n     trailing slash in the source, while others (Solaris 9, FreeBSD\n     7.2) have a rename function that ignores it.  */\n  if (remove_trailing_slashes)\n    for (int i = 0; i < n_files; i++)\n      strip_trailing_slashes (file[i]);\n\n  if (x.interactive == I_ALWAYS_NO)\n    x.update = false;\n\n  if (make_backups && x.interactive == I_ALWAYS_NO)\n    {\n      error (0, 0,\n             _(\"options --backup and --no-clobber are mutually exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  x.backup_type = (make_backups\n                   ? xget_version (_(\"backup type\"),\n                                   version_control_string)\n                   : no_backups);\n  set_simple_backup_suffix (backup_suffix);\n\n  hash_init ();\n\n  if (target_directory)\n    {\n       \n      if (2 <= n_files)\n        dest_info_init (&x);\n\n      ok = true;\n      for (int i = 0; i < n_files; ++i)\n        {\n          x.last_file = i + 1 == n_files;\n          char const *source = file[i];\n          char const *source_basename = last_component (source);\n          char *dest_relname;\n          char *dest = file_name_concat (target_directory, source_basename,\n                                         &dest_relname);\n          strip_trailing_slashes (dest_relname);\n          ok &= do_move (source, dest, target_dirfd, dest_relname, &x);\n          free (dest);\n        }\n    }\n  else\n    {\n      x.last_file = true;\n      ok = do_move (file[0], file[1], AT_FDCWD, file[1], &x);\n    }\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}