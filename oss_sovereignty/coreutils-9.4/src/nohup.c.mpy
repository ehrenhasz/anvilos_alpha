{
  "module_name": "nohup.c",
  "hash_id": "063574ef464fb347bda8e82539bfcccd23b25241e667d0270e4043d8153fc129",
  "original_prompt": "Ingested from coreutils-9.4/src/nohup.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <signal.h>\n\n#include \"system.h\"\n\n#include \"filenamecat.h\"\n#include \"fd-reopen.h\"\n#include \"long-options.h\"\n#include \"unistd--.h\"\n\n#define PROGRAM_NAME \"nohup\"\n\n#define AUTHORS proper_name (\"Jim Meyering\")\n\n \nenum\n  {\n     \n    POSIX_NOHUP_FAILURE = 127\n  };\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s COMMAND [ARG]...\\n\\\n  or:  %s OPTION\\n\\\n\"),\n              program_name, program_name);\n\n      fputs (_(\"\\\nRun COMMAND, ignoring hangup signals.\\n\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      printf (_(\"\\n\\\nIf standard input is a terminal, redirect it from an unreadable file.\\n\\\nIf standard output is a terminal, append output to 'nohup.out' if possible,\\n\\\n'$HOME/nohup.out' otherwise.\\n\\\nIf standard error is a terminal, redirect it to standard output.\\n\\\nTo save output to FILE, use '%s COMMAND > FILE'.\\n\"),\n              program_name);\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_exec_status (PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* GCC 13 gets confused by the dup2 calls.  */\n#if 13 <= __GNUC__\n# pragma GCC diagnostic ignored \"-Wanalyzer-fd-leak\"\n#endif\n\nint\nmain (int argc, char **argv)\n{\n  int out_fd = STDOUT_FILENO;\n  int saved_stderr_fd = STDERR_FILENO;\n  bool ignoring_input;\n  bool redirecting_stdout;\n  bool stdout_is_closed;\n  bool redirecting_stderr;\n  int exit_internal_failure;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* POSIX 2008 requires that internal failure give status 127; unlike\n     for env, exec, nice, time, and xargs where it requires internal\n     failure give something in the range 1-125.  For consistency with\n     other tools, fail with EXIT_CANCELED unless POSIXLY_CORRECT.  */\n  exit_internal_failure = (getenv (\"POSIXLY_CORRECT\")\n                           ? POSIX_NOHUP_FAILURE : EXIT_CANCELED);\n  initialize_exit_failure (exit_internal_failure);\n  atexit (close_stdout);\n\n  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n                                   Version, false, usage, AUTHORS,\n                                   (char const *) nullptr);\n\n  if (argc <= optind)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (exit_internal_failure);\n    }\n\n  ignoring_input = isatty (STDIN_FILENO);\n  redirecting_stdout = isatty (STDOUT_FILENO);\n  stdout_is_closed = (!redirecting_stdout && errno == EBADF);\n  redirecting_stderr = isatty (STDERR_FILENO);\n\n  /* If standard input is a tty, replace it with /dev/null if possible.\n     Note that it is deliberately opened for *writing*,\n     to ensure any read evokes an error.  */\n  if (ignoring_input)\n    {\n      if (fd_reopen (STDIN_FILENO, \"/dev/null\", O_WRONLY, 0) < 0)\n        error (exit_internal_failure, errno,\n               _(\"failed to render standard input unusable\"));\n      if (!redirecting_stdout && !redirecting_stderr)\n        error (0, 0, _(\"ignoring input\"));\n    }\n\n  /* If standard output is a tty, redirect it (appending) to a file.\n     First try nohup.out, then $HOME/nohup.out.  If standard error is\n     a tty and standard output is closed, open nohup.out or\n     $HOME/nohup.out without redirecting anything.  */\n  if (redirecting_stdout || (redirecting_stderr && stdout_is_closed))\n    {\n      char *in_home = nullptr;\n      char const *file = \"nohup.out\";\n      int flags = O_CREAT | O_WRONLY | O_APPEND;\n      mode_t mode = S_IRUSR | S_IWUSR;\n      mode_t umask_value = umask (~mode);\n      out_fd = (redirecting_stdout\n                ? fd_reopen (STDOUT_FILENO, file, flags, mode)\n                : open (file, flags, mode));\n\n      if (out_fd < 0)\n        {\n          int saved_errno = errno;\n          char const *home = getenv (\"HOME\");\n          if (home)\n            {\n              in_home = file_name_concat (home, file, nullptr);\n              out_fd = (redirecting_stdout\n                        ? fd_reopen (STDOUT_FILENO, in_home, flags, mode)\n                        : open (in_home, flags, mode));\n            }\n          if (out_fd < 0)\n            {\n              int saved_errno2 = errno;\n              error (0, saved_errno, _(\"failed to open %s\"), quoteaf (file));\n              if (in_home)\n                error (0, saved_errno2, _(\"failed to open %s\"),\n                       quoteaf (in_home));\n              return exit_internal_failure;\n            }\n          file = in_home;\n        }\n\n      umask (umask_value);\n      error (0, 0,\n             _(ignoring_input\n               ? N_(\"ignoring input and appending output to %s\")\n               : N_(\"appending output to %s\")),\n             quoteaf (file));\n      free (in_home);\n    }\n\n  /* If standard error is a tty, redirect it.  */\n  if (redirecting_stderr)\n    {\n      /* Save a copy of stderr before redirecting, so we can use the original\n         if execve fails.  It's no big deal if this dup fails.  It might\n         not change anything, and at worst, it'll lead to suppression of\n         the post-failed-execve diagnostic.  */\n      saved_stderr_fd = fcntl (STDERR_FILENO, F_DUPFD_CLOEXEC,\n                               STDERR_FILENO + 1);\n\n      if (!redirecting_stdout)\n        error (0, 0,\n               _(ignoring_input\n                 ? N_(\"ignoring input and redirecting stderr to stdout\")\n                 : N_(\"redirecting stderr to stdout\")));\n\n      if (dup2 (out_fd, STDERR_FILENO) < 0)\n        error (exit_internal_failure, errno,\n               _(\"failed to redirect standard error\"));\n\n      if (stdout_is_closed)\n        close (out_fd);\n    }\n\n  /* error() flushes stderr, but does not check for write failure.\n     Normally, we would catch this via our atexit() hook of\n     close_stdout, but execvp() gets in the way.  If stderr\n     encountered a write failure, there is no need to try calling\n     error() again, particularly since we may have just changed the\n     underlying fd out from under stderr.  */\n  if (ferror (stderr))\n    return exit_internal_failure;\n\n  signal (SIGHUP, SIG_IGN);\n\n  char **cmd = argv + optind;\n  execvp (*cmd, cmd);\n  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n  int saved_errno = errno;\n\n  /* The execve failed.  Output a diagnostic to stderr only if:\n     - stderr was initially redirected to a non-tty, or\n     - stderr was initially directed to a tty, and we\n     can dup2 it to point back to that same tty.\n     In other words, output the diagnostic if possible, but only if\n     it will go to the original stderr.  */\n  if (dup2 (saved_stderr_fd, STDERR_FILENO) == STDERR_FILENO)\n    error (0, saved_errno, _(\"failed to run command %s\"), quoteaf (*cmd));\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}