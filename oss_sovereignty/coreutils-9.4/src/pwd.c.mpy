{
  "module_name": "pwd.c",
  "hash_id": "9c646ee5019b04e5396f5d64f06ffd8d09ecb9f8e0d0d6b8a97b077b22877bb7",
  "original_prompt": "Ingested from coreutils-9.4/src/pwd.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"pwd\"\n\n#define AUTHORS proper_name (\"Jim Meyering\")\n\nstruct file_name\n{\n  char *buf;\n  size_t n_alloc;\n  char *start;\n};\n\nstatic struct option const longopts[] =\n{\n  {\"logical\", no_argument, nullptr, 'L'},\n  {\"physical\", no_argument, nullptr, 'P'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]...\\n\"), program_name);\n      fputs (_(\"\\\nPrint the full filename of the current working directory.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -L, --logical   use PWD from environment, even if it contains symlinks\\n\\\n  -P, --physical  avoid all symlinks\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\n\\\nIf no option is specified, -P is assumed.\\n\\\n\"), stdout);\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic void\nfile_name_free (struct file_name *p)\n{\n  free (p->buf);\n  free (p);\n}\n\nstatic struct file_name *\nfile_name_init (void)\n{\n  struct file_name *p = xmalloc (sizeof *p);\n\n  /* Start with a buffer larger than PATH_MAX, but beware of systems\n     on which PATH_MAX is very large -- e.g., INT_MAX.  */\n  p->n_alloc = MIN (2 * PATH_MAX, 32 * 1024);\n\n  p->buf = xmalloc (p->n_alloc);\n  p->start = p->buf + (p->n_alloc - 1);\n  p->start[0] = '\\0';\n  return p;\n}\n\n/* Prepend the name S of length S_LEN, to the growing file_name, P.  */\nstatic void\nfile_name_prepend (struct file_name *p, char const *s, size_t s_len)\n{\n  size_t n_free = p->start - p->buf;\n  if (n_free < 1 + s_len)\n    {\n      size_t half = p->n_alloc + 1 + s_len;\n      /* Use xnmalloc+free rather than xnrealloc, since with the latter\n         we'd end up copying the data twice: once via realloc, then again\n         to align it with the end of the new buffer.  With xnmalloc, we\n         copy it only once.  */\n      char *q = xnmalloc (2, half);\n      size_t n_used = p->n_alloc - n_free;\n      p->start = q + 2 * half - n_used;\n      memcpy (p->start, p->buf + n_free, n_used);\n      free (p->buf);\n      p->buf = q;\n      p->n_alloc = 2 * half;\n    }\n\n  p->start -= 1 + s_len;\n  p->start[0] = '/';\n  memcpy (p->start + 1, s, s_len);\n}\n\n/* Return a string (malloc'd) consisting of N '/'-separated \"..\" components.  */\nstatic char *\nnth_parent (size_t n)\n{\n  char *buf = xnmalloc (3, n);\n  char *p = buf;\n\n  for (size_t i = 0; i < n; i++)\n    {\n      memcpy (p, \"../\", 3);\n      p += 3;\n    }\n  p[-1] = '\\0';\n  return buf;\n}\n\n/* Determine the basename of the current directory, where DOT_SB is the\n   result of lstat'ing \".\" and prepend that to the file name in *FILE_NAME.\n   Find the directory entry in '..' that matches the dev/i-node of DOT_SB.\n   Upon success, update *DOT_SB with stat information of '..', chdir to '..',\n   and prepend \"/basename\" to FILE_NAME.\n   Otherwise, exit with a diagnostic.\n   PARENT_HEIGHT is the number of levels '..' is above the starting directory.\n   The first time this function is called (from the initial directory),\n   PARENT_HEIGHT is 1.  This is solely for diagnostics.\n   Exit nonzero upon error.  */\n\nstatic void\nfind_dir_entry (struct stat *dot_sb, struct file_name *file_name,\n                size_t parent_height)\n{\n  DIR *dirp;\n  int fd;\n  struct stat parent_sb;\n  bool use_lstat;\n  bool found;\n\n  dirp = opendir (\"..\");\n  if (dirp == nullptr)\n    error (EXIT_FAILURE, errno, _(\"cannot open directory %s\"),\n           quote (nth_parent (parent_height)));\n\n  fd = dirfd (dirp);\n  if ((0 <= fd ? fchdir (fd) : chdir (\"..\")) < 0)\n    error (EXIT_FAILURE, errno, _(\"failed to chdir to %s\"),\n           quote (nth_parent (parent_height)));\n\n  if ((0 <= fd ? fstat (fd, &parent_sb) : stat (\".\", &parent_sb)) < 0)\n    error (EXIT_FAILURE, errno, _(\"failed to stat %s\"),\n           quote (nth_parent (parent_height)));\n\n  /* If parent and child directory are on different devices, then we\n     can't rely on d_ino for useful i-node numbers; use lstat instead.  */\n  use_lstat = (parent_sb.st_dev != dot_sb->st_dev);\n\n  found = false;\n  while (true)\n    {\n      struct dirent const *dp;\n      struct stat ent_sb;\n      ino_t ino;\n\n      errno = 0;\n      if ((dp = readdir_ignoring_dot_and_dotdot (dirp)) == nullptr)\n        {\n          if (errno)\n            {\n              /* Save/restore errno across closedir call.  */\n              int e = errno;\n              closedir (dirp);\n              errno = e;\n\n              /* Arrange to give a diagnostic after exiting this loop.  */\n              dirp = nullptr;\n            }\n          break;\n        }\n\n      ino = D_INO (dp);\n\n      if (ino == NOT_AN_INODE_NUMBER || use_lstat)\n        {\n          if (lstat (dp->d_name, &ent_sb) < 0)\n            {\n              /* Skip any entry we can't stat.  */\n              continue;\n            }\n          ino = ent_sb.st_ino;\n        }\n\n      if (ino != dot_sb->st_ino)\n        continue;\n\n      /* If we're not crossing a device boundary, then a simple i-node\n         match is enough.  */\n      if ( ! use_lstat || ent_sb.st_dev == dot_sb->st_dev)\n        {\n          file_name_prepend (file_name, dp->d_name, _D_EXACT_NAMLEN (dp));\n          found = true;\n          break;\n        }\n    }\n\n  if (dirp == nullptr || closedir (dirp) != 0)\n    {\n      /* Note that this diagnostic serves for both readdir\n         and closedir failures.  */\n      error (EXIT_FAILURE, errno, _(\"reading directory %s\"),\n             quote (nth_parent (parent_height)));\n    }\n\n  if ( ! found)\n    error (EXIT_FAILURE, 0,\n           _(\"couldn't find directory entry in %s with matching i-node\"),\n           quote (nth_parent (parent_height)));\n\n  *dot_sb = parent_sb;\n}\n\n/* Construct the full, absolute name of the current working\n   directory and store it in *FILE_NAME.\n   The getcwd function performs nearly the same task, but is typically\n   unable to handle names longer than PATH_MAX.  This function has\n   no such limitation.  However, this function *can* fail due to\n   permission problems or a lack of memory, while GNU/Linux's getcwd\n   function works regardless of restricted permissions on parent\n   directories.  Upon failure, give a diagnostic and exit nonzero.\n\n   Note: although this function is similar to getcwd, it has a fundamental\n   difference in that it gives a diagnostic and exits upon failure.\n   I would have liked a function that did not exit, and that could be\n   used as a getcwd replacement.  Unfortunately, considering all of\n   the information the caller would require in order to produce good\n   diagnostics, it doesn't seem worth the added complexity.\n   In any case, any getcwd replacement must *not* exceed the PATH_MAX\n   limitation.  Otherwise, functions like 'chdir' would fail with\n   ENAMETOOLONG.\n\n   FIXME-maybe: if find_dir_entry fails due to permissions, try getcwd,\n   in case the unreadable directory is close enough to the root that\n   getcwd works from there.  */\n\nstatic void\nrobust_getcwd (struct file_name *file_name)\n{\n  size_t height = 1;\n  struct dev_ino dev_ino_buf;\n  struct dev_ino *root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n  struct stat dot_sb;\n\n  if (root_dev_ino == nullptr)\n    error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n           quoteaf (\"/\"));\n\n  if (stat (\".\", &dot_sb) < 0)\n    error (EXIT_FAILURE, errno, _(\"failed to stat %s\"), quoteaf (\".\"));\n\n  while (true)\n    {\n      /* If we've reached the root, we're done.  */\n      if (SAME_INODE (dot_sb, *root_dev_ino))\n        break;\n\n      find_dir_entry (&dot_sb, file_name, height++);\n    }\n\n  /* See if a leading slash is needed; file_name_prepend adds one.  */\n  if (file_name->start[0] == '\\0')\n    file_name_prepend (file_name, \"\", 0);\n}\n\n\n/* Return PWD from the environment if it is acceptable for 'pwd -L'\n   output, otherwise nullptr.  */\nstatic char *\nlogical_getcwd (void)\n{\n  struct stat st1;\n  struct stat st2;\n  char *wd = getenv (\"PWD\");\n  char *p;\n\n  /* Textual validation first.  */\n  if (!wd || wd[0] != '/')\n    return nullptr;\n  p = wd;\n  while ((p = strstr (p, \"/.\")))\n    {\n      if (!p[2] || p[2] == '/'\n          || (p[2] == '.' && (!p[3] || p[3] == '/')))\n        return nullptr;\n      p++;\n    }\n\n  /* System call validation.  */\n  if (stat (wd, &st1) == 0 && stat (\".\", &st2) == 0 && SAME_INODE (st1, st2))\n    return wd;\n  return nullptr;\n}\n\n\nint\nmain (int argc, char **argv)\n{\n  char *wd;\n  /* POSIX requires a default of -L, but most scripts expect -P.\n     Currently shells default to -L, while stand-alone\n     pwd implementations default to -P.  */\n  bool logical = (getenv (\"POSIXLY_CORRECT\") != nullptr);\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while (true)\n    {\n      int c = getopt_long (argc, argv, \"LP\", longopts, nullptr);\n      if (c == -1)\n        break;\n      switch (c)\n        {\n        case 'L':\n          logical = true;\n          break;\n        case 'P':\n          logical = false;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind < argc)\n    error (0, 0, _(\"ignoring non-option arguments\"));\n\n  if (logical)\n    {\n      wd = logical_getcwd ();\n      if (wd)\n        {\n          puts (wd);\n          return EXIT_SUCCESS;\n        }\n    }\n\n  wd = xgetcwd ();\n  if (wd != nullptr)\n    {\n      puts (wd);\n      free (wd);\n    }\n  else\n    {\n      struct file_name *file_name = file_name_init ();\n      robust_getcwd (file_name);\n      puts (file_name->start);\n      file_name_free (file_name);\n    }\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}