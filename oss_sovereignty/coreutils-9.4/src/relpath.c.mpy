{
  "module_name": "relpath.c",
  "hash_id": "dbee3de6e74aae71dc4bdac9f24478df1aa58cb7221bff6f116756d63686fec1",
  "original_prompt": "Ingested from coreutils-9.4/src/relpath.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"system.h\"\n#include \"relpath.h\"\n\n\n \nATTRIBUTE_PURE\nstatic int\npath_common_prefix (char const *path1, char const *path2)\n{\n  int i = 0;\n  int ret = 0;\n\n   \n  if ((path1[1] == '/') != (path2[1] == '/'))\n    return 0;\n\n  while (*path1 && *path2)\n    {\n      if (*path1 != *path2)\n        break;\n      if (*path1 == '/')\n        ret = i + 1;\n      path1++;\n      path2++;\n      i++;\n    }\n\n  if ((!*path1 && !*path2)\n      || (!*path1 && *path2 == '/')\n      || (!*path2 && *path1 == '/'))\n    ret = i;\n\n  return ret;\n}\n\n \nstatic bool\nbuffer_or_output (char const *str, char **pbuf, size_t *plen)\n{\n  if (*pbuf)\n    {\n      size_t slen = strlen (str);\n      if (slen >= *plen)\n        return true;\n      memcpy (*pbuf, str, slen + 1);\n      *pbuf += slen;\n      *plen -= slen;\n    }\n  else\n    {\n      fputs (str, stdout);\n    }\n\n  return false;\n}\n\n \nbool\nrelpath (char const *can_fname, char const *can_reldir, char *buf, size_t len)\n{\n  bool buf_err = false;\n\n   \n  int common_index = path_common_prefix (can_reldir, can_fname);\n  if (!common_index)\n    return false;\n\n  char const *relto_suffix = can_reldir + common_index;\n  char const *fname_suffix = can_fname + common_index;\n\n   \n  if (*relto_suffix == '/')\n    relto_suffix++;\n  if (*fname_suffix == '/')\n    fname_suffix++;\n\n   \n  if (*relto_suffix)\n    {\n      buf_err |= buffer_or_output (\"..\", &buf, &len);\n      for (; *relto_suffix; ++relto_suffix)\n        {\n          if (*relto_suffix == '/')\n            buf_err |= buffer_or_output (\"/..\", &buf, &len);\n        }\n\n      if (*fname_suffix)\n        {\n          buf_err |= buffer_or_output (\"/\", &buf, &len);\n          buf_err |= buffer_or_output (fname_suffix, &buf, &len);\n        }\n    }\n  else\n    {\n        buf_err |= buffer_or_output (*fname_suffix ? fname_suffix : \".\",\n                                     &buf, &len);\n    }\n\n  if (buf_err)\n    error (0, ENAMETOOLONG, \"%s\", _(\"generating relative path\"));\n\n  return !buf_err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}