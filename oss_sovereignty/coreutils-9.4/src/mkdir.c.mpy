{
  "module_name": "mkdir.c",
  "hash_id": "79ddfe496b10c60690a48597132e434afaecf453123092c5e8be5a06c26ad525",
  "original_prompt": "Ingested from coreutils-9.4/src/mkdir.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <selinux/label.h>\n\n#include \"system.h\"\n#include \"mkdir-p.h\"\n#include \"modechange.h\"\n#include \"prog-fprintf.h\"\n#include \"quote.h\"\n#include \"savewd.h\"\n#include \"selinux.h\"\n#include \"smack.h\"\n\n \n#define PROGRAM_NAME \"mkdir\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic struct option const longopts[] =\n{\n  {GETOPT_SELINUX_CONTEXT_OPTION_DECL},\n  {\"mode\", required_argument, nullptr, 'm'},\n  {\"parents\", no_argument, nullptr, 'p'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... DIRECTORY...\\n\"), program_name);\n      fputs (_(\"\\\nCreate the DIRECTORY(ies), if they do not already exist.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\\n\\\n  -p, --parents     no error if existing, make parent directories as needed,\\n\\\n                    with their file modes unaffected by any -m option.\\n\\\n  -v, --verbose     print a message for each created directory\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -Z                   set SELinux security context of each created directory\\n\\\n                         to the default type\\n\\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n\\\n                         or SMACK security context to CTX\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Options passed to subsidiary functions.  */\nstruct mkdir_options\n{\n  /* Function to make an ancestor, or nullptr if ancestors should not be\n     made.  */\n  int (*make_ancestor_function) (char const *, char const *, void *);\n\n  /* Umask value for when making an ancestor.  */\n  mode_t umask_ancestor;\n\n  /* Umask value for when making the directory itself.  */\n  mode_t umask_self;\n\n  /* Mode for directory itself.  */\n  mode_t mode;\n\n  /* File mode bits affected by MODE.  */\n  mode_t mode_bits;\n\n  /* Set the SELinux File Context.  */\n  struct selabel_handle *set_security_context;\n\n  /* If not null, format to use when reporting newly made directories.  */\n  char const *created_directory_format;\n};\n\n/* Report that directory DIR was made, if OPTIONS requests this.  */\nstatic void\nannounce_mkdir (char const *dir, void *options)\n{\n  struct mkdir_options const *o = options;\n  if (o->created_directory_format)\n    prog_fprintf (stdout, o->created_directory_format, quoteaf (dir));\n}\n\n/* Make ancestor directory DIR, whose last component is COMPONENT,\n   with options OPTIONS.  Assume the working directory is COMPONENT's\n   parent.  Return 0 if successful and the resulting directory is\n   readable, 1 if successful but the resulting directory is not\n   readable, -1 (setting errno) otherwise.  */\nstatic int\nmake_ancestor (char const *dir, char const *component, void *options)\n{\n  struct mkdir_options const *o = options;\n\n  if (o->set_security_context\n      && defaultcon (o->set_security_context, component, S_IFDIR) < 0\n      && ! ignorable_ctx_err (errno))\n    error (0, errno, _(\"failed to set default creation context for %s\"),\n           quoteaf (dir));\n\n  if (o->umask_ancestor != o->umask_self)\n    umask (o->umask_ancestor);\n  int r = mkdir (component, S_IRWXUGO);\n  if (o->umask_ancestor != o->umask_self)\n    {\n      int mkdir_errno = errno;\n      umask (o->umask_self);\n      errno = mkdir_errno;\n    }\n  if (r == 0)\n    {\n      r = (o->umask_ancestor & S_IRUSR) != 0;\n      announce_mkdir (dir, options);\n    }\n  return r;\n}\n\n/* Process a command-line file name.  */\nstatic int\nprocess_dir (char *dir, struct savewd *wd, void *options)\n{\n  struct mkdir_options const *o = options;\n\n  /* If possible set context before DIR created.  */\n  if (o->set_security_context)\n    {\n      if (! o->make_ancestor_function\n          && defaultcon (o->set_security_context, dir, S_IFDIR) < 0\n          && ! ignorable_ctx_err (errno))\n        error (0, errno, _(\"failed to set default creation context for %s\"),\n               quoteaf (dir));\n    }\n\n  int ret = (make_dir_parents (dir, wd, o->make_ancestor_function, options,\n                               o->mode, announce_mkdir,\n                               o->mode_bits, (uid_t) -1, (gid_t) -1, true)\n             ? EXIT_SUCCESS\n             : EXIT_FAILURE);\n\n  /* FIXME: Due to the current structure of make_dir_parents()\n     we don't have the facility to call defaultcon() before the\n     final component of DIR is created.  So for now, create the\n     final component with the context from previous component\n     and here we set the context for the final component. */\n  if (ret == EXIT_SUCCESS && o->set_security_context\n      && o->make_ancestor_function)\n    {\n      if (! restorecon (o->set_security_context, last_component (dir), false)\n          && ! ignorable_ctx_err (errno))\n        error (0, errno, _(\"failed to restore context for %s\"),\n               quoteaf (dir));\n    }\n\n  return ret;\n}\n\nint\nmain (int argc, char **argv)\n{\n  char const *specified_mode = nullptr;\n  int optc;\n  char const *scontext = nullptr;\n  struct mkdir_options options;\n\n  options.make_ancestor_function = nullptr;\n  options.mode = S_IRWXUGO;\n  options.mode_bits = 0;\n  options.created_directory_format = nullptr;\n  options.set_security_context = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"pm:vZ\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'p':\n          options.make_ancestor_function = make_ancestor;\n          break;\n        case 'm':\n          specified_mode = optarg;\n          break;\n        case 'v': /* --verbose  */\n          options.created_directory_format = _(\"created directory %s\");\n          break;\n        case 'Z':\n          if (is_smack_enabled ())\n            {\n              /* We don't yet support -Z to restore context with SMACK.  */\n              scontext = optarg;\n            }\n          else if (is_selinux_enabled () > 0)\n            {\n              if (optarg)\n                scontext = optarg;\n              else\n                {\n                  options.set_security_context = selabel_open (SELABEL_CTX_FILE,\n                                                               nullptr, 0);\n                  if (! options.set_security_context)\n                    error (0, errno, _(\"warning: ignoring --context\"));\n                }\n            }\n          else if (optarg)\n            {\n              error (0, 0,\n                     _(\"warning: ignoring --context; \"\n                       \"it requires an SELinux/SMACK-enabled kernel\"));\n            }\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind == argc)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  /* FIXME: This assumes mkdir() is done in the same process.\n     If that's not always the case we would need to call this\n     like we do when options.set_security_context.  */\n  if (scontext)\n    {\n      int ret = 0;\n      if (is_smack_enabled ())\n        ret = smack_set_label_for_self (scontext);\n      else\n        ret = setfscreatecon (scontext);\n\n      if (ret < 0)\n        error (EXIT_FAILURE, errno,\n               _(\"failed to set default file creation context to %s\"),\n               quote (scontext));\n    }\n\n\n  if (options.make_ancestor_function || specified_mode)\n    {\n      mode_t umask_value = umask (0);\n      options.umask_ancestor = umask_value & ~(S_IWUSR | S_IXUSR);\n\n      if (specified_mode)\n        {\n          struct mode_change *change = mode_compile (specified_mode);\n          if (!change)\n            error (EXIT_FAILURE, 0, _(\"invalid mode %s\"),\n                   quote (specified_mode));\n          options.mode = mode_adjust (S_IRWXUGO, true, umask_value, change,\n                                      &options.mode_bits);\n          options.umask_self = umask_value & ~options.mode;\n          free (change);\n        }\n      else\n        {\n          options.mode = S_IRWXUGO;\n          options.umask_self = umask_value;\n        }\n\n      umask (options.umask_self);\n    }\n\n  return savewd_process_files (argc - optind, argv + optind,\n                               process_dir, &options);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}