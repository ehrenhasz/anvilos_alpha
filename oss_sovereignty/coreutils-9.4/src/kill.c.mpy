{
  "module_name": "kill.c",
  "hash_id": "85dab587083c0a5ffd6630b09af00ca8901841a59cd43bfeb404616c5317bd80",
  "original_prompt": "Ingested from coreutils-9.4/src/kill.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdckdint.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <signal.h>\n\n#include \"system.h\"\n#include \"sig2str.h\"\n#include \"operand2sig.h\"\n#include \"quote.h\"\n\n \n#define PROGRAM_NAME \"kill\"\n\n#define AUTHORS proper_name (\"Paul Eggert\")\n\n#if ! (HAVE_DECL_STRSIGNAL || defined strsignal)\n# if ! (HAVE_DECL_SYS_SIGLIST || defined sys_siglist)\n#  if HAVE_DECL__SYS_SIGLIST || defined _sys_siglist\n#   define sys_siglist _sys_siglist\n#  elif HAVE_DECL___SYS_SIGLIST || defined __sys_siglist\n#   define sys_siglist __sys_siglist\n#  endif\n# endif\n# if HAVE_DECL_SYS_SIGLIST || defined sys_siglist\n#  define strsignal(signum) (0 <= (signum) && (signum) <= SIGNUM_BOUND \\\n                             ? sys_siglist[signum] \\\n                             : 0)\n# endif\n# ifndef strsignal\n#  define strsignal(signum) 0\n# endif\n#endif\n\nstatic char const short_options[] =\n  \"0::1::2::3::4::5::6::7::8::9::\"\n  \"A::B::C::D::E::F::G::H::I::J::K::M::\"\n  \"N::O::P::Q::R::S::T::U::V::W::X::Y::Z::\"\n  \"Lln:s:t\";\n\nstatic struct option const long_options[] =\n{\n  {\"list\", no_argument, nullptr, 'l'},\n  {\"signal\", required_argument, nullptr, 's'},\n  {\"table\", no_argument, nullptr, 't'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [-s SIGNAL | -SIGNAL] PID...\\n\\\n  or:  %s -l [SIGNAL]...\\n\\\n  or:  %s -t [SIGNAL]...\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\\nSend signals to processes, or list signals.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -s, --signal=SIGNAL, -SIGNAL\\n\\\n                   specify the name or number of the signal to be sent\\n\\\n  -l, --list       list signal names, or convert signal names to/from numbers\\n\\\n  -t, --table      print a table of signal information\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\n\\\nSIGNAL may be a signal name like 'HUP', or a signal number like '1',\\n\\\nor the exit status of a process terminated by a signal.\\n\\\nPID is an integer; if negative it identifies a process group.\\n\\\n\"), stdout);\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Print a row of 'kill -t' output.  NUM_WIDTH is the maximum signal\n   number width, and SIGNUM is the signal number to print.  The\n   maximum name width is NAME_WIDTH, and SIGNAME is the name to print.  */\n\nstatic void\nprint_table_row (int num_width, int signum,\n                 int name_width, char const *signame)\n{\n  char const *description = strsignal (signum);\n  printf (\"%*d %-*s %s\\n\", num_width, signum, name_width, signame,\n          description ? description : \"?\");\n}\n\n/* Print a list of signal names.  If TABLE, print a table.\n   Print the names specified by ARGV if nonzero; otherwise,\n   print all known names.  Return a suitable exit status.  */\n\nstatic int\nlist_signals (bool table, char *const *argv)\n{\n  int signum;\n  int status = EXIT_SUCCESS;\n  char signame[SIG2STR_MAX];\n\n  if (table)\n    {\n      int name_width = 0;\n\n      /* Compute the maximum width of a signal number.  */\n      int num_width = 1;\n      for (signum = 1; signum <= SIGNUM_BOUND / 10; signum *= 10)\n        num_width++;\n\n      /* Compute the maximum width of a signal name.  */\n      for (signum = 1; signum <= SIGNUM_BOUND; signum++)\n        if (sig2str (signum, signame) == 0)\n          {\n            idx_t len = strlen (signame);\n            if (name_width < len)\n              name_width = len;\n          }\n\n      if (argv)\n        for (; *argv; argv++)\n          {\n            signum = operand2sig (*argv, signame);\n            if (signum < 0)\n              status = EXIT_FAILURE;\n            else\n              print_table_row (num_width, signum, name_width, signame);\n          }\n      else\n        for (signum = 1; signum <= SIGNUM_BOUND; signum++)\n          if (sig2str (signum, signame) == 0)\n            print_table_row (num_width, signum, name_width, signame);\n    }\n  else\n    {\n      if (argv)\n        for (; *argv; argv++)\n          {\n            signum = operand2sig (*argv, signame);\n            if (signum < 0)\n              status = EXIT_FAILURE;\n            else\n              {\n                if (ISDIGIT (**argv))\n                  puts (signame);\n                else\n                  printf (\"%d\\n\", signum);\n              }\n          }\n      else\n        for (signum = 1; signum <= SIGNUM_BOUND; signum++)\n          if (sig2str (signum, signame) == 0)\n            puts (signame);\n    }\n\n  return status;\n}\n\n/* Send signal SIGNUM to all the processes or process groups specified\n   by ARGV.  Return a suitable exit status.  */\n\nstatic int\nsend_signals (int signum, char *const *argv)\n{\n  int status = EXIT_SUCCESS;\n  char const *arg = *argv;\n\n  do\n    {\n      char *endp;\n      intmax_t n = (errno = 0, strtoimax (arg, &endp, 10));\n      pid_t pid;\n\n      if (errno == ERANGE || ckd_add (&pid, n, 0)\n          || arg == endp || *endp)\n        {\n          error (0, 0, _(\"%s: invalid process id\"), quote (arg));\n          status = EXIT_FAILURE;\n        }\n      else if (kill (pid, signum) != 0)\n        {\n          error (0, errno, \"%s\", quote (arg));\n          status = EXIT_FAILURE;\n        }\n    }\n  while ((arg = *++argv));\n\n  return status;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  bool list = false;\n  bool table = false;\n  int signum = -1;\n  char signame[SIG2STR_MAX];\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, short_options, long_options, nullptr))\n         != -1)\n    switch (optc)\n      {\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        if (optind != 2)\n          {\n            /* This option is actually a process-id.  */\n            optind--;\n            goto no_more_options;\n          }\n        FALLTHROUGH;\n      case 'A': case 'B': case 'C': case 'D': case 'E':\n      case 'F': case 'G': case 'H': case 'I': case 'J':\n      case 'K': /*case 'L':*/ case 'M': case 'N': case 'O':\n      case 'P': case 'Q': case 'R': case 'S': case 'T':\n      case 'U': case 'V': case 'W': case 'X': case 'Y':\n      case 'Z':\n        if (! optarg)\n          optarg = argv[optind - 1] + strlen (argv[optind - 1]);\n        if (optarg != argv[optind - 1] + 2)\n          {\n            error (0, 0, _(\"invalid option -- %c\"), optc);\n            usage (EXIT_FAILURE);\n          }\n        optarg--;\n        FALLTHROUGH;\n      case 'n': /* -n is not documented, but is for Bash compatibility.  */\n      case 's':\n        if (0 <= signum)\n          {\n            error (0, 0, _(\"%s: multiple signals specified\"), quote (optarg));\n            usage (EXIT_FAILURE);\n          }\n        signum = operand2sig (optarg, signame);\n        if (signum < 0)\n          usage (EXIT_FAILURE);\n        break;\n\n      case 'L': /* -L is not documented, but is for procps compatibility.  */\n      case 't':\n        table = true;\n        FALLTHROUGH;\n      case 'l':\n        if (list)\n          {\n            error (0, 0, _(\"multiple -l or -t options specified\"));\n            usage (EXIT_FAILURE);\n          }\n        list = true;\n        break;\n\n      case_GETOPT_HELP_CHAR;\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n      default:\n        usage (EXIT_FAILURE);\n      }\n no_more_options:\n\n  if (signum < 0)\n    signum = SIGTERM;\n  else if (list)\n    {\n      error (0, 0, _(\"cannot combine signal with -l or -t\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if ( ! list && argc <= optind)\n    {\n      error (0, 0, _(\"no process ID specified\"));\n      usage (EXIT_FAILURE);\n    }\n\n  return (list\n          ? list_signals (table, optind < argc ? argv + optind : nullptr)\n          : send_signals (signum, argv + optind));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}