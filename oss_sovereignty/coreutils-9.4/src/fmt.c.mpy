{
  "module_name": "fmt.c",
  "hash_id": "cd220b612bcd7c9fdf5894d33166d0a43df87099796e1544dd74be92a29ca532",
  "original_prompt": "Ingested from coreutils-9.4/src/fmt.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n\n \n#define word unused_word_type\n\n#include \"c-ctype.h\"\n#include \"system.h\"\n#include \"fadvise.h\"\n#include \"xdectoint.h\"\n\n \n#define PROGRAM_NAME \"fmt\"\n\n#define AUTHORS proper_name (\"Ross Paterson\")\n\n \n\n \n#define WIDTH\t75\n\n \n#define LEEWAY\t7\n\n \n#define DEF_INDENT 3\n\n \n\n \n\ntypedef long int COST;\n\n#define MAXCOST\tTYPE_MAXIMUM (COST)\n\n#define SQR(n)\t\t((n) * (n))\n#define EQUIV(n)\tSQR ((COST) (n))\n\n \n#define SHORT_COST(n)\tEQUIV ((n) * 10)\n\n \n#define RAGGED_COST(n)\t(SHORT_COST (n) / 2)\n\n \n#define LINE_COST\tEQUIV (70)\n\n \n#define WIDOW_COST(n)\t(EQUIV (200) / ((n) + 2))\n\n \n#define ORPHAN_COST(n)\t(EQUIV (150) / ((n) + 2))\n\n \n#define SENTENCE_BONUS\tEQUIV (50)\n\n \n#define NOBREAK_COST\tEQUIV (600)\n\n \n#define PAREN_BONUS\tEQUIV (40)\n\n \n#define PUNCT_BONUS\tEQUIV(40)\n\n \n#define LINE_CREDIT\tEQUIV(3)\n\n \n\n#define MAXWORDS\t1000\n#define MAXCHARS\t5000\n\n \n\n#define isopen(c)\t(strchr (\"(['`\\\"\", c) != nullptr)\n#define isclose(c)\t(strchr (\")]'\\\"\", c) != nullptr)\n#define isperiod(c)\t(strchr (\".?!\", c) != nullptr)\n\n \n#define TABWIDTH\t8\n\n \n\ntypedef struct Word WORD;\n\nstruct Word\n  {\n\n     \n\n    char const *text;\t\t \n    int length;\t\t\t \n    int space;\t\t\t \n    unsigned int paren:1;\t \n    unsigned int period:1;\t \n    unsigned int punct:1;\t \n    unsigned int final:1;\t \n\n     \n\n    int line_length;\t\t \n    COST best_cost;\t\t \n    WORD *next_break;\t\t \n  };\n\n \n\nstatic void set_prefix (char *p);\nstatic bool fmt (FILE *f, char const *);\nstatic bool get_paragraph (FILE *f);\nstatic int get_line (FILE *f, int c);\nstatic int get_prefix (FILE *f);\nstatic int get_space (FILE *f, int c);\nstatic int copy_rest (FILE *f, int c);\nstatic bool same_para (int c);\nstatic void flush_paragraph (void);\nstatic void fmt_paragraph (void);\nstatic void check_punctuation (WORD *w);\nstatic COST base_cost (WORD *this);\nstatic COST line_cost (WORD *next, int len);\nstatic void put_paragraph (WORD *finish);\nstatic void put_line (WORD *w, int indent);\nstatic void put_word (WORD *w);\nstatic void put_space (int space);\n\n \n\n \nstatic bool crown;\n\n \nstatic bool tagged;\n\n \nstatic bool split;\n\n \nstatic bool uniform;\n\n \nstatic char const *prefix;\n\n \nstatic int max_width;\n\n \n\n \nstatic int prefix_full_length;\n\n \nstatic int prefix_lead_space;\n\n \nstatic int prefix_length;\n\n \nstatic int goal_width;\n\n \n\n \nstatic int in_column;\n\n \nstatic int out_column;\n\n \nstatic char parabuf[MAXCHARS];\n\n \nstatic char *wptr;\n\n \nstatic WORD word[MAXWORDS];\n\n \nstatic WORD *word_limit;\n\n \nstatic bool tabs;\n\n \nstatic int prefix_indent;\n\n \nstatic int first_indent;\n\n \nstatic int other_indent;\n\n \n\n \nstatic int next_char;\n\n \nstatic int next_prefix_indent;\n\n \nstatic int last_line_length;\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [-WIDTH] [OPTION]... [FILE]...\\n\"), program_name);\n      fputs (_(\"\\\nReformat each paragraph in the FILE(s), writing to standard output.\\n\\\nThe option -WIDTH is an abbreviated form of --width=DIGITS.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -c, --crown-margin        preserve indentation of first two lines\\n\\\n  -p, --prefix=STRING       reformat only lines beginning with STRING,\\n\\\n                              reattaching the prefix to reformatted lines\\n\\\n  -s, --split-only          split long lines, but do not refill\\n\\\n\"),\n             stdout);\n      /* Tell xgettext that the \"% o\" below is not a printf-style\n         format string:  xgettext:no-c-format */\n      fputs (_(\"\\\n  -t, --tagged-paragraph    indentation of first line different from second\\n\\\n  -u, --uniform-spacing     one space between words, two after sentences\\n\\\n  -w, --width=WIDTH         maximum line width (default of 75 columns)\\n\\\n  -g, --goal=WIDTH          goal width (default of 93% of width)\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Decode options and launch execution.  */\n\nstatic struct option const long_options[] =\n{\n  {\"crown-margin\", no_argument, nullptr, 'c'},\n  {\"prefix\", required_argument, nullptr, 'p'},\n  {\"split-only\", no_argument, nullptr, 's'},\n  {\"tagged-paragraph\", no_argument, nullptr, 't'},\n  {\"uniform-spacing\", no_argument, nullptr, 'u'},\n  {\"width\", required_argument, nullptr, 'w'},\n  {\"goal\", required_argument, nullptr, 'g'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0},\n};\n\nint\nmain (int argc, char **argv)\n{\n  int optchar;\n  bool ok = true;\n  char const *max_width_option = nullptr;\n  char const *goal_width_option = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  crown = tagged = split = uniform = false;\n  max_width = WIDTH;\n  prefix = \"\";\n  prefix_length = prefix_lead_space = prefix_full_length = 0;\n\n  if (argc > 1 && argv[1][0] == '-' && ISDIGIT (argv[1][1]))\n    {\n      /* Old option syntax; a dash followed by one or more digits.  */\n      max_width_option = argv[1] + 1;\n\n      /* Make the option we just parsed invisible to getopt.  */\n      argv[1] = argv[0];\n      argv++;\n      argc--;\n    }\n\n  while ((optchar = getopt_long (argc, argv, \"0123456789cstuw:p:g:\",\n                                 long_options, nullptr))\n         != -1)\n    switch (optchar)\n      {\n      default:\n        if (ISDIGIT (optchar))\n          error (0, 0, _(\"invalid option -- %c; -WIDTH is recognized\\\n only when it is the first\\noption; use -w N instead\"),\n                 optchar);\n        usage (EXIT_FAILURE);\n\n      case 'c':\n        crown = true;\n        break;\n\n      case 's':\n        split = true;\n        break;\n\n      case 't':\n        tagged = true;\n        break;\n\n      case 'u':\n        uniform = true;\n        break;\n\n      case 'w':\n        max_width_option = optarg;\n        break;\n\n      case 'g':\n        goal_width_option = optarg;\n        break;\n\n      case 'p':\n        set_prefix (optarg);\n        break;\n\n      case_GETOPT_HELP_CHAR;\n\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n      }\n\n  if (max_width_option)\n    {\n      /* Limit max_width to MAXCHARS / 2; otherwise, the resulting\n         output can be quite ugly.  */\n      max_width = xdectoumax (max_width_option, 0, MAXCHARS / 2, \"\",\n                              _(\"invalid width\"), 0);\n    }\n\n  if (goal_width_option)\n    {\n      /* Limit goal_width to max_width.  */\n      goal_width = xdectoumax (goal_width_option, 0, max_width, \"\",\n                               _(\"invalid width\"), 0);\n      if (max_width_option == nullptr)\n        max_width = goal_width + 10;\n    }\n  else\n    {\n      goal_width = max_width * (2 * (100 - LEEWAY) + 1) / 200;\n    }\n\n  bool have_read_stdin = false;\n\n  if (optind == argc)\n    {\n      have_read_stdin = true;\n      ok = fmt (stdin, \"-\");\n    }\n  else\n    {\n      for (; optind < argc; optind++)\n        {\n          char *file = argv[optind];\n          if (STREQ (file, \"-\"))\n            {\n              ok &= fmt (stdin, file);\n              have_read_stdin = true;\n            }\n          else\n            {\n              FILE *in_stream;\n              in_stream = fopen (file, \"r\");\n              if (in_stream != nullptr)\n                ok &= fmt (in_stream, file);\n              else\n                {\n                  error (0, errno, _(\"cannot open %s for reading\"),\n                         quoteaf (file));\n                  ok = false;\n                }\n            }\n        }\n    }\n\n  if (have_read_stdin && fclose (stdin) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", _(\"closing standard input\"));\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n/* Trim space from the front and back of the string P, yielding the prefix,\n   and record the lengths of the prefix and the space trimmed.  */\n\nstatic void\nset_prefix (char *p)\n{\n  char *s;\n\n  prefix_lead_space = 0;\n  while (*p == ' ')\n    {\n      prefix_lead_space++;\n      p++;\n    }\n  prefix = p;\n  prefix_full_length = strlen (p);\n  s = p + prefix_full_length;\n  while (s > p && s[-1] == ' ')\n    s--;\n  *s = '\\0';\n  prefix_length = s - p;\n}\n\n/* Read F and send formatted output to stdout.\n   Close F when done, unless F is stdin.  Diagnose input errors, using FILE.\n   If !F, assume F resulted from an fopen failure and diagnose that.\n   Return true if successful.  */\n\nstatic bool\nfmt (FILE *f, char const *file)\n{\n  fadvise (f, FADVISE_SEQUENTIAL);\n  tabs = false;\n  other_indent = 0;\n  next_char = get_prefix (f);\n  while (get_paragraph (f))\n    {\n      fmt_paragraph ();\n      put_paragraph (word_limit);\n    }\n\n  int err = ferror (f) ? 0 : -1;\n  if (f == stdin)\n    clearerr (f);\n  else if (fclose (f) != 0 && err < 0)\n    err = errno;\n  if (0 <= err)\n    error (0, err, err ? \"%s\" : _(\"read error\"), quotef (file));\n  return err < 0;\n}\n\n/* Set the global variable 'other_indent' according to SAME_PARAGRAPH\n   and other global variables.  */\n\nstatic void\nset_other_indent (bool same_paragraph)\n{\n  if (split)\n    other_indent = first_indent;\n  else if (crown)\n    {\n      other_indent = (same_paragraph ? in_column : first_indent);\n    }\n  else if (tagged)\n    {\n      if (same_paragraph && in_column != first_indent)\n        {\n          other_indent = in_column;\n        }\n\n      /* Only one line: use the secondary indent from last time if it\n         splits, or 0 if there have been no multi-line paragraphs in the\n         input so far.  But if these rules make the two indents the same,\n         pick a new secondary indent.  */\n\n      else if (other_indent == first_indent)\n        other_indent = first_indent == 0 ? DEF_INDENT : 0;\n    }\n  else\n    {\n      other_indent = first_indent;\n    }\n}\n\n/* Read a paragraph from input file F.  A paragraph consists of a\n   maximal number of non-blank (excluding any prefix) lines subject to:\n   * In split mode, a paragraph is a single non-blank line.\n   * In crown mode, the second and subsequent lines must have the\n   same indentation, but possibly different from the indent of the\n   first line.\n   * Tagged mode is similar, but the first and second lines must have\n   different indentations.\n   * Otherwise, all lines of a paragraph must have the same indent.\n   If a prefix is in effect, it must be present at the same indent for\n   each line in the paragraph.\n\n   Return false if end-of-file was encountered before the start of a\n   paragraph, else true.  */\n\nstatic bool\nget_paragraph (FILE *f)\n{\n  int c;\n\n  last_line_length = 0;\n  c = next_char;\n\n  /* Scan (and copy) blank lines, and lines not introduced by the prefix.  */\n\n  while (c == '\\n' || c == EOF\n         || next_prefix_indent < prefix_lead_space\n         || in_column < next_prefix_indent + prefix_full_length)\n    {\n      c = copy_rest (f, c);\n      if (c == EOF)\n        {\n          next_char = EOF;\n          return false;\n        }\n      putchar ('\\n');\n      c = get_prefix (f);\n    }\n\n  /* Got a suitable first line for a paragraph.  */\n\n  prefix_indent = next_prefix_indent;\n  first_indent = in_column;\n  wptr = parabuf;\n  word_limit = word;\n  c = get_line (f, c);\n  set_other_indent (same_para (c));\n\n  /* Read rest of paragraph (unless split is specified).  */\n\n  if (split)\n    {\n      /* empty */\n    }\n  else if (crown)\n    {\n      if (same_para (c))\n        {\n          do\n            {\t\t\t/* for each line till the end of the para */\n              c = get_line (f, c);\n            }\n          while (same_para (c) && in_column == other_indent);\n        }\n    }\n  else if (tagged)\n    {\n      if (same_para (c) && in_column != first_indent)\n        {\n          do\n            {\t\t\t/* for each line till the end of the para */\n              c = get_line (f, c);\n            }\n          while (same_para (c) && in_column == other_indent);\n        }\n    }\n  else\n    {\n      while (same_para (c) && in_column == other_indent)\n        c = get_line (f, c);\n    }\n\n  (word_limit - 1)->period = (word_limit - 1)->final = true;\n  next_char = c;\n  return true;\n}\n\n/* Copy to the output a line that failed to match the prefix, or that\n   was blank after the prefix.  In the former case, C is the character\n   that failed to match the prefix.  In the latter, C is \\n or EOF.\n   Return the character (\\n or EOF) ending the line.  */\n\nstatic int\ncopy_rest (FILE *f, int c)\n{\n  char const *s;\n\n  out_column = 0;\n  if (in_column > next_prefix_indent || (c != '\\n' && c != EOF))\n    {\n      put_space (next_prefix_indent);\n      for (s = prefix; out_column != in_column && *s; out_column++)\n        putchar (*s++);\n      if (c != EOF && c != '\\n')\n        put_space (in_column - out_column);\n      if (c == EOF && in_column >= next_prefix_indent + prefix_length)\n        putchar ('\\n');\n    }\n  while (c != '\\n' && c != EOF)\n    {\n      putchar (c);\n      c = getc (f);\n    }\n  return c;\n}\n\n/* Return true if a line whose first non-blank character after the\n   prefix (if any) is C could belong to the current paragraph,\n   otherwise false.  */\n\nstatic bool\nsame_para (int c)\n{\n  return (next_prefix_indent == prefix_indent\n          && in_column >= next_prefix_indent + prefix_full_length\n          && c != '\\n' && c != EOF);\n}\n\n/* Read a line from input file F, given first non-blank character C\n   after the prefix, and the following indent, and break it into words.\n   A word is a maximal non-empty string of non-white characters.  A word\n   ending in [.?!][])\"']* and followed by end-of-line or at least two\n   spaces ends a sentence, as in emacs.\n\n   Return the first non-blank character of the next line.  */\n\nstatic int\nget_line (FILE *f, int c)\n{\n  int start;\n  char *end_of_parabuf;\n  WORD *end_of_word;\n\n  end_of_parabuf = &parabuf[MAXCHARS];\n  end_of_word = &word[MAXWORDS - 2];\n\n  do\n    {\t\t\t\t/* for each word in a line */\n\n      /* Scan word.  */\n\n      word_limit->text = wptr;\n      do\n        {\n          if (wptr == end_of_parabuf)\n            {\n              set_other_indent (true);\n              flush_paragraph ();\n            }\n          *wptr++ = c;\n          c = getc (f);\n        }\n      while (c != EOF && !c_isspace (c));\n      in_column += word_limit->length = wptr - word_limit->text;\n      check_punctuation (word_limit);\n\n      /* Scan inter-word space.  */\n\n      start = in_column;\n      c = get_space (f, c);\n      word_limit->space = in_column - start;\n      word_limit->final = (c == EOF\n                           || (word_limit->period\n                               && (c == '\\n' || word_limit->space > 1)));\n      if (c == '\\n' || c == EOF || uniform)\n        word_limit->space = word_limit->final ? 2 : 1;\n      if (word_limit == end_of_word)\n        {\n          set_other_indent (true);\n          flush_paragraph ();\n        }\n      word_limit++;\n    }\n  while (c != '\\n' && c != EOF);\n  return get_prefix (f);\n}\n\n/* Read a prefix from input file F.  Return either first non-matching\n   character, or first non-blank character after the prefix.  */\n\nstatic int\nget_prefix (FILE *f)\n{\n  int c;\n\n  in_column = 0;\n  c = get_space (f, getc (f));\n  if (prefix_length == 0)\n    next_prefix_indent = prefix_lead_space < in_column ?\n      prefix_lead_space : in_column;\n  else\n    {\n      char const *p;\n      next_prefix_indent = in_column;\n      for (p = prefix; *p != '\\0'; p++)\n        {\n          unsigned char pc = *p;\n          if (c != pc)\n            return c;\n          in_column++;\n          c = getc (f);\n        }\n      c = get_space (f, c);\n    }\n  return c;\n}\n\n/* Read blank characters from input file F, starting with C, and keeping\n   in_column up-to-date.  Return first non-blank character.  */\n\nstatic int\nget_space (FILE *f, int c)\n{\n  while (true)\n    {\n      if (c == ' ')\n        in_column++;\n      else if (c == '\\t')\n        {\n          tabs = true;\n          in_column = (in_column / TABWIDTH + 1) * TABWIDTH;\n        }\n      else\n        return c;\n      c = getc (f);\n    }\n}\n\n/* Set extra fields in word W describing any attached punctuation.  */\n\nstatic void\ncheck_punctuation (WORD *w)\n{\n  char const *start = w->text;\n  char const *finish = start + (w->length - 1);\n  unsigned char fin = *finish;\n\n  w->paren = isopen (*start);\n  w->punct = !! ispunct (fin);\n  while (start < finish && isclose (*finish))\n    finish--;\n  w->period = isperiod (*finish);\n}\n\n/* Flush part of the paragraph to make room.  This function is called on\n   hitting the limit on the number of words or characters.  */\n\nstatic void\nflush_paragraph (void)\n{\n  WORD *split_point;\n  WORD *w;\n  int shift;\n  COST best_break;\n\n  /* In the special case where it's all one word, just flush it.  */\n\n  if (word_limit == word)\n    {\n      fwrite (parabuf, sizeof *parabuf, wptr - parabuf, stdout);\n      wptr = parabuf;\n      return;\n    }\n\n   \n\n  fmt_paragraph ();\n\n   \n\n  split_point = word_limit;\n  best_break = MAXCOST;\n  for (w = word->next_break; w != word_limit; w = w->next_break)\n    {\n      if (w->best_cost - w->next_break->best_cost < best_break)\n        {\n          split_point = w;\n          best_break = w->best_cost - w->next_break->best_cost;\n        }\n      if (best_break <= MAXCOST - LINE_CREDIT)\n        best_break += LINE_CREDIT;\n    }\n  put_paragraph (split_point);\n\n   \n\n  memmove (parabuf, split_point->text, wptr - split_point->text);\n  shift = split_point->text - parabuf;\n  wptr -= shift;\n\n   \n\n  for (w = split_point; w <= word_limit; w++)\n    w->text -= shift;\n\n   \n\n  memmove (word, split_point, (word_limit - split_point + 1) * sizeof *word);\n  word_limit -= split_point - word;\n}\n\n \n\nstatic void\nfmt_paragraph (void)\n{\n  WORD *start, *w;\n  int len;\n  COST wcost, best;\n  int saved_length;\n\n  word_limit->best_cost = 0;\n  saved_length = word_limit->length;\n  word_limit->length = max_width;\t \n\n  for (start = word_limit - 1; start >= word; start--)\n    {\n      best = MAXCOST;\n      len = start == word ? first_indent : other_indent;\n\n       \n\n      w = start;\n      len += w->length;\n      do\n        {\n          w++;\n\n           \n\n          wcost = line_cost (w, len) + w->best_cost;\n          if (start == word && last_line_length > 0)\n            wcost += RAGGED_COST (len - last_line_length);\n          if (wcost < best)\n            {\n              best = wcost;\n              start->next_break = w;\n              start->line_length = len;\n            }\n\n           \n          if (w == word_limit)\n            break;\n\n          len += (w - 1)->space + w->length;\t \n        }\n      while (len < max_width);\n      start->best_cost = best + base_cost (start);\n    }\n\n  word_limit->length = saved_length;\n}\n\n \n\nstatic COST\nbase_cost (WORD *this)\n{\n  COST cost;\n\n  cost = LINE_COST;\n\n  if (this > word)\n    {\n      if ((this - 1)->period)\n        {\n          if ((this - 1)->final)\n            cost -= SENTENCE_BONUS;\n          else\n            cost += NOBREAK_COST;\n        }\n      else if ((this - 1)->punct)\n        cost -= PUNCT_BONUS;\n      else if (this > word + 1 && (this - 2)->final)\n        cost += WIDOW_COST ((this - 1)->length);\n    }\n\n  if (this->paren)\n    cost -= PAREN_BONUS;\n  else if (this->final)\n    cost += ORPHAN_COST (this->length);\n\n  return cost;\n}\n\n \n\nstatic COST\nline_cost (WORD *next, int len)\n{\n  int n;\n  COST cost;\n\n  if (next == word_limit)\n    return 0;\n  n = goal_width - len;\n  cost = SHORT_COST (n);\n  if (next->next_break != word_limit)\n    {\n      n = len - next->line_length;\n      cost += RAGGED_COST (n);\n    }\n  return cost;\n}\n\n \n\nstatic void\nput_paragraph (WORD *finish)\n{\n  WORD *w;\n\n  put_line (word, first_indent);\n  for (w = word->next_break; w != finish; w = w->next_break)\n    put_line (w, other_indent);\n}\n\n \n\nstatic void\nput_line (WORD *w, int indent)\n{\n  WORD *endline;\n\n  out_column = 0;\n  put_space (prefix_indent);\n  fputs (prefix, stdout);\n  out_column += prefix_length;\n  put_space (indent - out_column);\n\n  endline = w->next_break - 1;\n  for (; w != endline; w++)\n    {\n      put_word (w);\n      put_space (w->space);\n    }\n  put_word (w);\n  last_line_length = out_column;\n  putchar ('\\n');\n}\n\n \n\nstatic void\nput_word (WORD *w)\n{\n  char const *s;\n  int n;\n\n  s = w->text;\n  for (n = w->length; n != 0; n--)\n    putchar (*s++);\n  out_column += w->length;\n}\n\n \n\nstatic void\nput_space (int space)\n{\n  int space_target, tab_target;\n\n  space_target = out_column + space;\n  if (tabs)\n    {\n      tab_target = space_target / TABWIDTH * TABWIDTH;\n      if (out_column + 1 < tab_target)\n        while (out_column < tab_target)\n          {\n            putchar ('\\t');\n            out_column = (out_column / TABWIDTH + 1) * TABWIDTH;\n          }\n    }\n  while (out_column < space_target)\n    {\n      putchar (' ');\n      out_column++;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}