{
  "module_name": "stty.c",
  "hash_id": "54ad26ca52aeb0f4e0c7c359d6b23821a122fb73fc163878111a0e4d8d77a0ed",
  "original_prompt": "Ingested from coreutils-9.4/src/stty.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#ifdef TERMIOS_NEEDS_XOPEN_SOURCE\n# define _XOPEN_SOURCE\n#endif\n\n#include <stdio.h>\n#include <sys/types.h>\n\n#include <termios.h>\n#if HAVE_STROPTS_H\n# include <stropts.h>\n#endif\n#include <sys/ioctl.h>\n\n#ifdef WINSIZE_IN_PTEM\n# include <sys/stream.h>\n# include <sys/ptem.h>\n#endif\n#ifdef GWINSZ_IN_SYS_PTY\n# include <sys/tty.h>\n# include <sys/pty.h>\n#endif\n#include <getopt.h>\n#include <stdarg.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"fd-reopen.h\"\n#include \"quote.h\"\n#include \"xdectoint.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"stty\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\n#ifndef _POSIX_VDISABLE\n# define _POSIX_VDISABLE 0\n#endif\n\n#define Control(c) ((c) & 0x1f)\n \n#ifndef CINTR\n# define CINTR Control ('c')\n#endif\n#ifndef CQUIT\n# define CQUIT 28\n#endif\n#ifndef CERASE\n# define CERASE 127\n#endif\n#ifndef CKILL\n# define CKILL Control ('u')\n#endif\n#ifndef CEOF\n# define CEOF Control ('d')\n#endif\n#ifndef CEOL\n# define CEOL _POSIX_VDISABLE\n#endif\n#ifndef CSTART\n# define CSTART Control ('q')\n#endif\n#ifndef CSTOP\n# define CSTOP Control ('s')\n#endif\n#ifndef CSUSP\n# define CSUSP Control ('z')\n#endif\n#if defined VEOL2 && !defined CEOL2\n# define CEOL2 _POSIX_VDISABLE\n#endif\n \n#if defined VSWTC && !defined VSWTCH\n# define VSWTCH VSWTC\n#endif\n \n#if defined VSUSP && !defined VSWTCH\n# define VSWTCH VSUSP\n# if defined CSUSP && !defined CSWTCH\n#  define CSWTCH CSUSP\n# endif\n#endif\n#if defined VSWTCH && !defined CSWTCH\n# define CSWTCH _POSIX_VDISABLE\n#endif\n\n \n#if defined __sun\n# undef CSWTCH\n# define CSWTCH _POSIX_VDISABLE\n#endif\n\n#if defined VWERSE && !defined VWERASE\t \n# define VWERASE VWERSE\n#endif\n#if defined VDSUSP && !defined CDSUSP\n# define CDSUSP Control ('y')\n#endif\n#if !defined VREPRINT && defined VRPRNT  \n# define VREPRINT VRPRNT\n#endif\n#if defined VREPRINT && !defined CRPRNT\n# define CRPRNT Control ('r')\n#endif\n#if defined CREPRINT && !defined CRPRNT\n# define CRPRNT Control ('r')\n#endif\n#if defined VWERASE && !defined CWERASE\n# define CWERASE Control ('w')\n#endif\n#if defined VLNEXT && !defined CLNEXT\n# define CLNEXT Control ('v')\n#endif\n#if defined VDISCARD && !defined VFLUSHO\n# define VFLUSHO VDISCARD\n#endif\n#if defined VFLUSH && !defined VFLUSHO\t \n# define VFLUSHO VFLUSH\n#endif\n#if defined CTLECH && !defined ECHOCTL\t \n# define ECHOCTL CTLECH\n#endif\n#if defined TCTLECH && !defined ECHOCTL\t \n# define ECHOCTL TCTLECH\n#endif\n#if defined CRTKIL && !defined ECHOKE\t \n# define ECHOKE CRTKIL\n#endif\n#if defined VFLUSHO && !defined CFLUSHO\n# define CFLUSHO Control ('o')\n#endif\n#if defined VSTATUS && !defined CSTATUS\n# define CSTATUS Control ('t')\n#endif\n\n \nenum speed_setting\n  {\n    input_speed, output_speed, both_speeds\n  };\n\n \nenum output_type\n  {\n    changed, all, recoverable\t \n  };\n\n \nenum mode_type\n  {\n    control, input, output, local, combination\n  };\n\n \n#define SANE_SET 1\t\t \n#define SANE_UNSET 2\t\t \n#define REV 4\t\t\t \n#define OMIT 8\t\t\t \n#define NO_SETATTR 16\t\t \n\n \nstruct mode_info\n  {\n    char const *name;\t\t \n    enum mode_type type;\t \n    char flags;\t\t\t \n    unsigned long bits;\t\t \n    unsigned long mask;\t\t \n  };\n\nstatic struct mode_info const mode_info[] =\n{\n  {\"parenb\", control, REV, PARENB, 0},\n  {\"parodd\", control, REV, PARODD, 0},\n#ifdef CMSPAR\n  {\"cmspar\", control, REV, CMSPAR, 0},\n#endif\n  {\"cs5\", control, 0, CS5, CSIZE},\n  {\"cs6\", control, 0, CS6, CSIZE},\n  {\"cs7\", control, 0, CS7, CSIZE},\n  {\"cs8\", control, 0, CS8, CSIZE},\n  {\"hupcl\", control, REV, HUPCL, 0},\n  {\"hup\", control, REV | OMIT, HUPCL, 0},\n  {\"cstopb\", control, REV, CSTOPB, 0},\n  {\"cread\", control, SANE_SET | REV, CREAD, 0},\n  {\"clocal\", control, REV, CLOCAL, 0},\n#ifdef CRTSCTS\n  {\"crtscts\", control, REV, CRTSCTS, 0},\n#endif\n#ifdef CDTRDSR\n  {\"cdtrdsr\", control, REV, CDTRDSR, 0},\n#endif\n\n  {\"ignbrk\", input, SANE_UNSET | REV, IGNBRK, 0},\n  {\"brkint\", input, SANE_SET | REV, BRKINT, 0},\n  {\"ignpar\", input, REV, IGNPAR, 0},\n  {\"parmrk\", input, REV, PARMRK, 0},\n  {\"inpck\", input, REV, INPCK, 0},\n  {\"istrip\", input, REV, ISTRIP, 0},\n  {\"inlcr\", input, SANE_UNSET | REV, INLCR, 0},\n  {\"igncr\", input, SANE_UNSET | REV, IGNCR, 0},\n  {\"icrnl\", input, SANE_SET | REV, ICRNL, 0},\n  {\"ixon\", input, REV, IXON, 0},\n  {\"ixoff\", input, SANE_UNSET | REV, IXOFF, 0},\n  {\"tandem\", input, REV | OMIT, IXOFF, 0},\n#ifdef IUCLC\n  {\"iuclc\", input, SANE_UNSET | REV, IUCLC, 0},\n#endif\n#ifdef IXANY\n  {\"ixany\", input, SANE_UNSET | REV, IXANY, 0},\n#endif\n#ifdef IMAXBEL\n  {\"imaxbel\", input, SANE_SET | REV, IMAXBEL, 0},\n#endif\n#ifdef IUTF8\n  {\"iutf8\", input, SANE_UNSET | REV, IUTF8, 0},\n#endif\n\n  {\"opost\", output, SANE_SET | REV, OPOST, 0},\n#ifdef OLCUC\n  {\"olcuc\", output, SANE_UNSET | REV, OLCUC, 0},\n#endif\n#ifdef OCRNL\n  {\"ocrnl\", output, SANE_UNSET | REV, OCRNL, 0},\n#endif\n#ifdef ONLCR\n  {\"onlcr\", output, SANE_SET | REV, ONLCR, 0},\n#endif\n#ifdef ONOCR\n  {\"onocr\", output, SANE_UNSET | REV, ONOCR, 0},\n#endif\n#ifdef ONLRET\n  {\"onlret\", output, SANE_UNSET | REV, ONLRET, 0},\n#endif\n#ifdef OFILL\n  {\"ofill\", output, SANE_UNSET | REV, OFILL, 0},\n#endif\n#ifdef OFDEL\n  {\"ofdel\", output, SANE_UNSET | REV, OFDEL, 0},\n#endif\n#ifdef NLDLY\n  {\"nl1\", output, SANE_UNSET, NL1, NLDLY},\n  {\"nl0\", output, SANE_SET, NL0, NLDLY},\n#endif\n#ifdef CRDLY\n  {\"cr3\", output, SANE_UNSET, CR3, CRDLY},\n  {\"cr2\", output, SANE_UNSET, CR2, CRDLY},\n  {\"cr1\", output, SANE_UNSET, CR1, CRDLY},\n  {\"cr0\", output, SANE_SET, CR0, CRDLY},\n#endif\n#ifdef TABDLY\n# ifdef TAB3\n  {\"tab3\", output, SANE_UNSET, TAB3, TABDLY},\n# endif\n# ifdef TAB2\n  {\"tab2\", output, SANE_UNSET, TAB2, TABDLY},\n# endif\n# ifdef TAB1\n  {\"tab1\", output, SANE_UNSET, TAB1, TABDLY},\n# endif\n# ifdef TAB0\n  {\"tab0\", output, SANE_SET, TAB0, TABDLY},\n# endif\n#else\n# ifdef OXTABS\n  {\"tab3\", output, SANE_UNSET, OXTABS, 0},\n# endif\n#endif\n#ifdef BSDLY\n  {\"bs1\", output, SANE_UNSET, BS1, BSDLY},\n  {\"bs0\", output, SANE_SET, BS0, BSDLY},\n#endif\n#ifdef VTDLY\n  {\"vt1\", output, SANE_UNSET, VT1, VTDLY},\n  {\"vt0\", output, SANE_SET, VT0, VTDLY},\n#endif\n#ifdef FFDLY\n  {\"ff1\", output, SANE_UNSET, FF1, FFDLY},\n  {\"ff0\", output, SANE_SET, FF0, FFDLY},\n#endif\n\n  {\"isig\", local, SANE_SET | REV, ISIG, 0},\n  {\"icanon\", local, SANE_SET | REV, ICANON, 0},\n#ifdef IEXTEN\n  {\"iexten\", local, SANE_SET | REV, IEXTEN, 0},\n#endif\n  {\"echo\", local, SANE_SET | REV, ECHO, 0},\n  {\"echoe\", local, SANE_SET | REV, ECHOE, 0},\n  {\"crterase\", local, REV | OMIT, ECHOE, 0},\n  {\"echok\", local, SANE_SET | REV, ECHOK, 0},\n  {\"echonl\", local, SANE_UNSET | REV, ECHONL, 0},\n  {\"noflsh\", local, SANE_UNSET | REV, NOFLSH, 0},\n#ifdef XCASE\n  {\"xcase\", local, SANE_UNSET | REV, XCASE, 0},\n#endif\n#ifdef TOSTOP\n  {\"tostop\", local, SANE_UNSET | REV, TOSTOP, 0},\n#endif\n#ifdef ECHOPRT\n  {\"echoprt\", local, SANE_UNSET | REV, ECHOPRT, 0},\n  {\"prterase\", local, REV | OMIT, ECHOPRT, 0},\n#endif\n#ifdef ECHOCTL\n  {\"echoctl\", local, SANE_SET | REV, ECHOCTL, 0},\n  {\"ctlecho\", local, REV | OMIT, ECHOCTL, 0},\n#endif\n#ifdef ECHOKE\n  {\"echoke\", local, SANE_SET | REV, ECHOKE, 0},\n  {\"crtkill\", local, REV | OMIT, ECHOKE, 0},\n#endif\n#ifdef FLUSHO\n  {\"flusho\", local, SANE_UNSET | REV, FLUSHO, 0},\n#endif\n#if defined TIOCEXT\n  {\"extproc\", local, SANE_UNSET | REV | NO_SETATTR, EXTPROC, 0},\n#elif defined EXTPROC\n  {\"extproc\", local, SANE_UNSET | REV, EXTPROC, 0},\n#endif\n\n  {\"evenp\", combination, REV | OMIT, 0, 0},\n  {\"parity\", combination, REV | OMIT, 0, 0},\n  {\"oddp\", combination, REV | OMIT, 0, 0},\n  {\"nl\", combination, REV | OMIT, 0, 0},\n  {\"ek\", combination, OMIT, 0, 0},\n  {\"sane\", combination, OMIT, 0, 0},\n  {\"cooked\", combination, REV | OMIT, 0, 0},\n  {\"raw\", combination, REV | OMIT, 0, 0},\n  {\"pass8\", combination, REV | OMIT, 0, 0},\n  {\"litout\", combination, REV | OMIT, 0, 0},\n  {\"cbreak\", combination, REV | OMIT, 0, 0},\n#ifdef IXANY\n  {\"decctlq\", combination, REV | OMIT, 0, 0},\n#endif\n#if defined TABDLY || defined OXTABS\n  {\"tabs\", combination, REV | OMIT, 0, 0},\n#endif\n#if defined XCASE && defined IUCLC && defined OLCUC\n  {\"lcase\", combination, REV | OMIT, 0, 0},\n  {\"LCASE\", combination, REV | OMIT, 0, 0},\n#endif\n  {\"crt\", combination, OMIT, 0, 0},\n  {\"dec\", combination, OMIT, 0, 0},\n\n  {nullptr, control, 0, 0, 0}\n};\n\n \nstruct control_info\n  {\n    char const *name;\t\t \n    cc_t saneval;\t\t \n    size_t offset;\t\t \n  };\n\n \n\nstatic struct control_info const control_info[] =\n{\n  {\"intr\", CINTR, VINTR},\n  {\"quit\", CQUIT, VQUIT},\n  {\"erase\", CERASE, VERASE},\n  {\"kill\", CKILL, VKILL},\n  {\"eof\", CEOF, VEOF},\n  {\"eol\", CEOL, VEOL},\n#ifdef VEOL2\n  {\"eol2\", CEOL2, VEOL2},\n#endif\n#ifdef VSWTCH\n  {\"swtch\", CSWTCH, VSWTCH},\n#endif\n  {\"start\", CSTART, VSTART},\n  {\"stop\", CSTOP, VSTOP},\n  {\"susp\", CSUSP, VSUSP},\n#ifdef VDSUSP\n  {\"dsusp\", CDSUSP, VDSUSP},\n#endif\n#ifdef VREPRINT\n  {\"rprnt\", CRPRNT, VREPRINT},\n#else\n# ifdef CREPRINT  \n  {\"rprnt\", CRPRNT, CREPRINT},\n# endif\n#endif\n#ifdef VWERASE\n  {\"werase\", CWERASE, VWERASE},\n#endif\n#ifdef VLNEXT\n  {\"lnext\", CLNEXT, VLNEXT},\n#endif\n#ifdef VFLUSHO\n  {\"flush\", CFLUSHO, VFLUSHO},    \n  {\"discard\", CFLUSHO, VFLUSHO},\n#endif\n#ifdef VSTATUS\n  {\"status\", CSTATUS, VSTATUS},\n#endif\n\n   \n  {\"min\", 1, VMIN},\n  {\"time\", 0, VTIME},\n  {nullptr, 0, 0}\n};\n\nstatic char const *visible (cc_t ch);\nstatic unsigned long int baud_to_value (speed_t speed);\nstatic bool recover_mode (char const *arg, struct termios *mode);\nstatic int screen_columns (void);\nstatic bool set_mode (struct mode_info const *info, bool reversed,\n                      struct termios *mode);\nstatic bool eq_mode (struct termios *mode1, struct termios *mode2);\nstatic unsigned long int integer_arg (char const *s, unsigned long int max);\nstatic speed_t string_to_baud (char const *arg);\nstatic tcflag_t *mode_type_flag (enum mode_type type, struct termios *mode);\nstatic void display_all (struct termios *mode, char const *device_name);\nstatic void display_changed (struct termios *mode);\nstatic void display_recoverable (struct termios *mode);\nstatic void display_settings (enum output_type output_type,\n                              struct termios *mode,\n                              char const *device_name);\nstatic void check_speed (struct termios *mode);\nstatic void display_speed (struct termios *mode, bool fancy);\nstatic void display_window_size (bool fancy, char const *device_name);\nstatic void sane_mode (struct termios *mode);\nstatic void set_control_char (struct control_info const *info,\n                              char const *arg,\n                              struct termios *mode);\nstatic void set_speed (enum speed_setting type, char const *arg,\n                       struct termios *mode);\nstatic void set_window_size (int rows, int cols, char const *device_name);\n\n \nstatic int max_col;\n\n \nstatic int current_col;\n\n \nstatic int tcsetattr_options = TCSADRAIN;\n\n \nstatic bool dev_debug;\n\n \nstatic speed_t last_ibaud = (speed_t) -1;\nstatic speed_t last_obaud = (speed_t) -1;\n\n \nenum\n{\n  DEV_DEBUG_OPTION = CHAR_MAX + 1,\n};\n\nstatic struct option const longopts[] =\n{\n  {\"all\", no_argument, nullptr, 'a'},\n  {\"save\", no_argument, nullptr, 'g'},\n  {\"file\", required_argument, nullptr, 'F'},\n  {\"-debug\", no_argument, nullptr, DEV_DEBUG_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nATTRIBUTE_FORMAT ((printf, 1, 2))\nstatic void\nwrapf (char const *message,...)\n{\n  va_list args;\n  char *buf;\n  int buflen;\n\n  va_start (args, message);\n  buflen = vasprintf (&buf, message, args);\n  va_end (args);\n\n  if (buflen < 0)\n    xalloc_die ();\n\n  if (0 < current_col)\n    {\n      if (max_col - current_col <= buflen)\n        {\n          putchar ('\\n');\n          current_col = 0;\n        }\n      else\n        {\n          putchar (' ');\n          current_col++;\n        }\n    }\n\n  fputs (buf, stdout);\n  free (buf);\n  current_col += buflen;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\\n\\\n  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\\n\\\n  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\\nPrint or change terminal characteristics.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -a, --all          print all current settings in human-readable form\\n\\\n  -g, --save         print all current settings in a stty-readable form\\n\\\n  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nOptional - before SETTING indicates negation.  An * marks non-POSIX\\n\\\nsettings.  The underlying system defines which settings are available.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nSpecial characters:\\n\"), stdout);\n#ifdef VFLUSHO\n      fputs (_(\"\\\n * discard CHAR  CHAR will toggle discarding of output\\n\\\n\"), stdout);\n#endif\n#ifdef VDSUSP\n      fputs (_(\"\\\n * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   eof CHAR      CHAR will send an end of file (terminate the input)\\n\\\n   eol CHAR      CHAR will end the line\\n\\\n\"), stdout);\n#ifdef VEOL2\n      fputs (_(\"\\\n * eol2 CHAR     alternate CHAR for ending the line\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   erase CHAR    CHAR will erase the last character typed\\n\\\n   intr CHAR     CHAR will send an interrupt signal\\n\\\n   kill CHAR     CHAR will erase the current line\\n\\\n\"), stdout);\n#ifdef VLNEXT\n      fputs (_(\"\\\n * lnext CHAR    CHAR will enter the next character quoted\\n\\\n\"), stdout);\n#endif\n#ifdef VSTATUS\n      fputs (_(\"\\\n * status CHAR   CHAR will send an info signal\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   quit CHAR     CHAR will send a quit signal\\n\\\n\"), stdout);\n#if defined CREPRINT || defined VREPRINT\n      fputs (_(\"\\\n * rprnt CHAR    CHAR will redraw the current line\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   start CHAR    CHAR will restart the output after stopping it\\n\\\n   stop CHAR     CHAR will stop the output\\n\\\n   susp CHAR     CHAR will send a terminal stop signal\\n\\\n\"), stdout);\n#ifdef VSWTCH\n      fputs (_(\"\\\n * swtch CHAR    CHAR will switch to a different shell layer\\n\\\n\"), stdout);\n#endif\n#ifdef VWERASE\n      fputs (_(\"\\\n * werase CHAR   CHAR will erase the last word typed\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n\\n\\\nSpecial settings:\\n\\\n   N             set the input and output speeds to N bauds\\n\\\n\"), stdout);\n#ifdef TIOCGWINSZ\n      fputs (_(\"\\\n * cols N        tell the kernel that the terminal has N columns\\n\\\n * columns N     same as cols N\\n\\\n\"), stdout);\n#endif\n      printf (_(\"\\\n * [-]drain      wait for transmission before applying settings (%s by default)\\\n\\n\"), tcsetattr_options == TCSADRAIN ? _(\"on\") : _(\"off\"));\n      fputs (_(\"\\\n   ispeed N      set the input speed to N\\n\\\n\"), stdout);\n#ifdef HAVE_C_LINE\n      fputs (_(\"\\\n * line N        use line discipline N\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   min N         with -icanon, set N characters minimum for a completed read\\n\\\n   ospeed N      set the output speed to N\\n\\\n\"), stdout);\n#ifdef TIOCGWINSZ\n      fputs (_(\"\\\n * rows N        tell the kernel that the terminal has N rows\\n\\\n * size          print the number of rows and columns according to the kernel\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   speed         print the terminal speed\\n\\\n   time N        with -icanon, set read timeout of N tenths of a second\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nControl settings:\\n\\\n   [-]clocal     disable modem control signals\\n\\\n   [-]cread      allow input to be received\\n\\\n\"), stdout);\n#ifdef CRTSCTS\n      fputs (_(\"\\\n * [-]crtscts    enable RTS/CTS handshaking\\n\\\n\"), stdout);\n#endif\n#ifdef CDTRDSR\n      fputs (_(\"\\\n * [-]cdtrdsr    enable DTR/DSR handshaking\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   csN           set character size to N bits, N in [5..8]\\n\\\n\"), stdout);\n      fputs (_(\"\\\n   [-]cstopb     use two stop bits per character (one with '-')\\n\\\n   [-]hup        send a hangup signal when the last process closes the tty\\n\\\n   [-]hupcl      same as [-]hup\\n\\\n   [-]parenb     generate parity bit in output and expect parity bit in input\\n\\\n   [-]parodd     set odd parity (or even parity with '-')\\n\\\n\"), stdout);\n#ifdef CMSPAR\n      fputs (_(\"\\\n * [-]cmspar     use \\\"stick\\\" (mark/space) parity\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n\\n\\\nInput settings:\\n\\\n   [-]brkint     breaks cause an interrupt signal\\n\\\n   [-]icrnl      translate carriage return to newline\\n\\\n   [-]ignbrk     ignore break characters\\n\\\n   [-]igncr      ignore carriage return\\n\\\n   [-]ignpar     ignore characters with parity errors\\n\\\n\"), stdout);\n#ifdef IMAXBEL\n      fputs (_(\"\\\n * [-]imaxbel    beep and do not flush a full input buffer on a character\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   [-]inlcr      translate newline to carriage return\\n\\\n   [-]inpck      enable input parity checking\\n\\\n   [-]istrip     clear high (8th) bit of input characters\\n\\\n\"), stdout);\n#ifdef IUTF8\n      fputs (_(\"\\\n * [-]iutf8      assume input characters are UTF-8 encoded\\n\\\n\"), stdout);\n#endif\n#ifdef IUCLC\n      fputs (_(\"\\\n * [-]iuclc      translate uppercase characters to lowercase\\n\\\n\"), stdout);\n#endif\n#ifdef IXANY\n      fputs (_(\"\\\n * [-]ixany      let any character restart output, not only start character\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   [-]ixoff      enable sending of start/stop characters\\n\\\n   [-]ixon       enable XON/XOFF flow control\\n\\\n   [-]parmrk     mark parity errors (with a 255-0-character sequence)\\n\\\n   [-]tandem     same as [-]ixoff\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nOutput settings:\\n\\\n\"), stdout);\n#ifdef BSDLY\n      fputs (_(\"\\\n * bsN           backspace delay style, N in [0..1]\\n\\\n\"), stdout);\n#endif\n#ifdef CRDLY\n      fputs (_(\"\\\n * crN           carriage return delay style, N in [0..3]\\n\\\n\"), stdout);\n#endif\n#ifdef FFDLY\n      fputs (_(\"\\\n * ffN           form feed delay style, N in [0..1]\\n\\\n\"), stdout);\n#endif\n#ifdef NLDLY\n      fputs (_(\"\\\n * nlN           newline delay style, N in [0..1]\\n\\\n\"), stdout);\n#endif\n#ifdef OCRNL\n      fputs (_(\"\\\n * [-]ocrnl      translate carriage return to newline\\n\\\n\"), stdout);\n#endif\n#ifdef OFDEL\n      fputs (_(\"\\\n * [-]ofdel      use delete characters for fill instead of NUL characters\\n\\\n\"), stdout);\n#endif\n#ifdef OFILL\n      fputs (_(\"\\\n * [-]ofill      use fill (padding) characters instead of timing for delays\\n\\\n\"), stdout);\n#endif\n#ifdef OLCUC\n      fputs (_(\"\\\n * [-]olcuc      translate lowercase characters to uppercase\\n\\\n\"), stdout);\n#endif\n#ifdef ONLCR\n      fputs (_(\"\\\n * [-]onlcr      translate newline to carriage return-newline\\n\\\n\"), stdout);\n#endif\n#ifdef ONLRET\n      fputs (_(\"\\\n * [-]onlret     newline performs a carriage return\\n\\\n\"), stdout);\n#endif\n#ifdef ONOCR\n      fputs (_(\"\\\n * [-]onocr      do not print carriage returns in the first column\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   [-]opost      postprocess output\\n\\\n\"), stdout);\n#if defined TABDLY || defined OXTABS\n      fputs (_(\"\\\n * tabN          horizontal tab delay style, N in [0..3]\\n\\\n * tabs          same as tab0\\n\\\n * -tabs         same as tab3\\n\\\n\"), stdout);\n#endif\n#ifdef VTDLY\n      fputs (_(\"\\\n * vtN           vertical tab delay style, N in [0..1]\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n\\n\\\nLocal settings:\\n\\\n   [-]crterase   echo erase characters as backspace-space-backspace\\n\\\n\"), stdout);\n#ifdef ECHOKE\n      fputs (_(\"\\\n * crtkill       kill all line by obeying the echoprt and echoe settings\\n\\\n * -crtkill      kill all line by obeying the echoctl and echok settings\\n\\\n\"), stdout);\n#endif\n#ifdef ECHOCTL\n      fputs (_(\"\\\n * [-]ctlecho    echo control characters in hat notation ('^c')\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   [-]echo       echo input characters\\n\\\n\"), stdout);\n#ifdef ECHOCTL\n      fputs (_(\"\\\n * [-]echoctl    same as [-]ctlecho\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   [-]echoe      same as [-]crterase\\n\\\n   [-]echok      echo a newline after a kill character\\n\\\n\"), stdout);\n#ifdef ECHOKE\n      fputs (_(\"\\\n * [-]echoke     same as [-]crtkill\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   [-]echonl     echo newline even if not echoing other characters\\n\\\n\"), stdout);\n#ifdef ECHOPRT\n      fputs (_(\"\\\n * [-]echoprt    echo erased characters backward, between '\\\\' and '/'\\n\\\n\"), stdout);\n#endif\n#if defined EXTPROC || defined TIOCEXT\n      fputs (_(\"\\\n * [-]extproc    enable \\\"LINEMODE\\\"; useful with high latency links\\n\\\n\"), stdout);\n#endif\n#if defined FLUSHO\n      fputs (_(\"\\\n * [-]flusho     discard output\\n\\\n\"), stdout);\n#endif\n      printf (_(\"\\\n   [-]icanon     enable special characters: %s\\n\\\n   [-]iexten     enable non-POSIX special characters\\n\\\n\"), \"erase, kill\"\n#ifdef VWERASE\n    \", werase\"\n#endif\n#if defined CREPRINT || defined VREPRINT\n    \", rprnt\"\n#endif\n);\n      fputs (_(\"\\\n   [-]isig       enable interrupt, quit, and suspend special characters\\n\\\n   [-]noflsh     disable flushing after interrupt and quit special characters\\n\\\n\"), stdout);\n#ifdef ECHOPRT\n      fputs (_(\"\\\n * [-]prterase   same as [-]echoprt\\n\\\n\"), stdout);\n#endif\n#ifdef TOSTOP\n      fputs (_(\"\\\n * [-]tostop     stop background jobs that try to write to the terminal\\n\\\n\"), stdout);\n#endif\n#ifdef XCASE\n      fputs (_(\"\\\n * [-]xcase      with icanon, escape with '\\\\' for uppercase characters\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n\\n\\\nCombination settings:\\n\\\n\"), stdout);\n#if defined XCASE && defined IUCLC && defined OLCUC\n      fputs (_(\"\\\n * [-]LCASE      same as [-]lcase\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   cbreak        same as -icanon\\n\\\n   -cbreak       same as icanon\\n\\\n\"), stdout);\n      fputs (_(\"\\\n   cooked        same as brkint ignpar istrip icrnl ixon opost isig\\n\\\n                 icanon, eof and eol characters to their default values\\n\\\n   -cooked       same as raw\\n\\\n\"), stdout);\n      printf (_(\"\\\n   crt           same as %s\\n\\\n\"), \"echoe\"\n#ifdef ECHOCTL\n    \" echoctl\"\n#endif\n#ifdef ECHOKE\n    \" echoke\"\n#endif\n);\n      printf (_(\"\\\n   dec           same as %s intr ^c erase 0177\\n\\\n                 kill ^u\\n\\\n\"), \"echoe\"\n#ifdef ECHOCTL\n    \" echoctl\"\n#endif\n#ifdef ECHOKE\n    \" echoke\"\n#endif\n#ifdef IXANY\n    \" -ixany\"\n#endif\n);\n#ifdef IXANY\n      fputs (_(\"\\\n * [-]decctlq    same as [-]ixany\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   ek            erase and kill characters to their default values\\n\\\n   evenp         same as parenb -parodd cs7\\n\\\n   -evenp        same as -parenb cs8\\n\\\n\"), stdout);\n#if defined XCASE && defined IUCLC && defined OLCUC\n      fputs (_(\"\\\n * [-]lcase      same as xcase iuclc olcuc\\n\\\n\"), stdout);\n#endif\n      fputs (_(\"\\\n   litout        same as -parenb -istrip -opost cs8\\n\\\n   -litout       same as parenb istrip opost cs7\\n\\\n\"), stdout);\n      printf (_(\"\\\n   nl            same as %s\\n\\\n   -nl           same as %s\\n\\\n\"), \"-icrnl\"\n#ifdef ONLCR\n   \" -onlcr\"\n#endif\n  , \"icrnl -inlcr -igncr\"\n#ifdef ONLCR\n   \" onlcr\"\n#endif\n#ifdef OCRNL\n   \" -ocrnl\"\n#endif\n#ifdef ONLRET\n   \" -onlret\"\n#endif\n);\n      fputs (_(\"\\\n   oddp          same as parenb parodd cs7\\n\\\n   -oddp         same as -parenb cs8\\n\\\n   [-]parity     same as [-]evenp\\n\\\n   pass8         same as -parenb -istrip cs8\\n\\\n   -pass8        same as parenb istrip cs7\\n\\\n\"), stdout);\n      printf (_(\"\\\n   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\\n\\\n                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\\n\\\n                 -isig%s min 1 time 0\\n\\\n   -raw          same as cooked\\n\\\n\"),\n#ifdef IUCLC\n   \" -iuclc\"\n#endif\n#ifdef IXANY\n   \" -ixany\"\n#endif\n#ifdef IMAXBEL\n   \" -imaxbel\"\n#endif\n#ifdef XCASE\n   \" -xcase\"\n#endif\n);\n      printf (_(\"\\\n   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\\n\\\n                 icanon iexten echo echoe echok -echonl -noflsh\\n\\\n                 %s\\n\\\n                 %s\\n\\\n                 %s,\\n\\\n                 all special characters to their default values\\n\\\n\"),\n   \"-ixoff\"\n#ifdef IUTF8\n   \" -iutf8\"\n#endif\n#ifdef IUCLC\n   \" -iuclc\"\n#endif\n#ifdef IXANY\n   \" -ixany\"\n#endif\n#ifdef IMAXBEL\n   \" imaxbel\"\n#endif\n#ifdef XCASE\n   \" -xcase\"\n#endif\n#ifdef OLCUC\n   \" -olcuc\"\n#endif\n#ifdef OCRNL\n   \" -ocrnl\"\n#endif\n\n , \"opost\"\n#ifdef OFILL\n   \" -ofill\"\n#endif\n#ifdef ONLCR\n   \" onlcr\"\n#endif\n#ifdef ONOCR\n   \" -onocr\"\n#endif\n#ifdef ONLRET\n   \" -onlret\"\n#endif\n#ifdef NLDLY\n   \" nl0\"\n#endif\n#ifdef CRDLY\n   \" cr0\"\n#endif\n#ifdef TAB0\n   \" tab0\"\n#endif\n#ifdef BSDLY\n   \" bs0\"\n#endif\n#ifdef VTDLY\n   \" vt0\"\n#endif\n#ifdef FFDLY\n   \" ff0\"\n#endif\n\n , \"isig\"\n#ifdef TOSTOP\n   \" -tostop\"\n#endif\n#ifdef OFDEL\n   \" -ofdel\"\n#endif\n#ifdef ECHOPRT\n   \" -echoprt\"\n#endif\n#ifdef ECHOCTL\n   \" echoctl\"\n#endif\n#ifdef ECHOKE\n   \" echoke\"\n#endif\n#ifdef EXTPROC\n   \" -extproc\"\n#endif\n#ifdef FLUSHO\n   \" -flusho\"\n#endif\n);\n      fputs (_(\"\\\n\\n\\\nHandle the tty line connected to standard input.  Without arguments,\\n\\\nprints baud rate, line discipline, and deviations from stty sane.  In\\n\\\nsettings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\\n\\\n127; special values ^- or undef used to disable special characters.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n\n \n\nstatic void\napply_settings (bool checking, char const *device_name,\n                char * const *settings, int n_settings,\n                struct termios *mode, bool *require_set_attr)\n{\n#define check_argument(arg)\t\t\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (k == n_settings - 1 || ! settings[k + 1])\t\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          error (0, 0, _(\"missing argument to %s\"), quote (arg));\t\\\n          usage (EXIT_FAILURE);\t\t\t\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n  for (int k = 1; k < n_settings; k++)\n    {\n      char const *arg = settings[k];\n      bool match_found = false;\n      bool not_set_attr = false;\n      bool reversed = false;\n      int i;\n\n      if (! arg)\n        continue;\n\n      if (arg[0] == '-')\n        {\n          ++arg;\n          reversed = true;\n        }\n      if (STREQ (arg, \"drain\"))\n        {\n          tcsetattr_options = reversed ? TCSANOW : TCSADRAIN;\n          continue;\n        }\n      for (i = 0; mode_info[i].name != nullptr; ++i)\n        {\n          if (STREQ (arg, mode_info[i].name))\n            {\n              if ((mode_info[i].flags & NO_SETATTR) == 0)\n                {\n                  match_found = set_mode (&mode_info[i], reversed, mode);\n                  *require_set_attr = true;\n                }\n              else\n                match_found = not_set_attr = true;\n              break;\n            }\n        }\n      if (!match_found && reversed)\n        {\n          error (0, 0, _(\"invalid argument %s\"), quote (arg - 1));\n          usage (EXIT_FAILURE);\n        }\n      if (!match_found)\n        {\n          for (i = 0; control_info[i].name != nullptr; ++i)\n            {\n              if (STREQ (arg, control_info[i].name))\n                {\n                  check_argument (arg);\n                  match_found = true;\n                  ++k;\n                  set_control_char (&control_info[i], settings[k], mode);\n                  *require_set_attr = true;\n                  break;\n                }\n            }\n        }\n      if (!match_found || not_set_attr)\n        {\n          if (STREQ (arg, \"ispeed\"))\n            {\n              check_argument (arg);\n              ++k;\n              if (string_to_baud (settings[k]) == (speed_t) -1)\n                {\n                  error (0, 0, _(\"invalid ispeed %s\"), quote (settings[k]));\n                  usage (EXIT_FAILURE);\n                }\n              set_speed (input_speed, settings[k], mode);\n              if (checking)\n                continue;\n              *require_set_attr = true;\n            }\n          else if (STREQ (arg, \"ospeed\"))\n            {\n              check_argument (arg);\n              ++k;\n              if (string_to_baud (settings[k]) == (speed_t) -1)\n                {\n                  error (0, 0, _(\"invalid ospeed %s\"), quote (settings[k]));\n                  usage (EXIT_FAILURE);\n                }\n              set_speed (output_speed, settings[k], mode);\n              if (checking)\n                continue;\n              *require_set_attr = true;\n            }\n#ifdef TIOCEXT\n           \n          else if (STREQ (arg, \"extproc\"))\n            {\n              int val = ! reversed;\n\n              if (checking)\n                continue;\n\n              if (ioctl (STDIN_FILENO, TIOCEXT, &val) != 0)\n                error (EXIT_FAILURE, errno, _(\"%s: error setting %s\"),\n                       quotef_n (0, device_name), quote_n (1, arg));\n            }\n#endif\n#ifdef TIOCGWINSZ\n          else if (STREQ (arg, \"rows\"))\n            {\n              check_argument (arg);\n              ++k;\n              if (checking)\n                continue;\n              set_window_size (integer_arg (settings[k], INT_MAX), -1,\n                               device_name);\n            }\n          else if (STREQ (arg, \"cols\")\n                   || STREQ (arg, \"columns\"))\n            {\n              check_argument (arg);\n              ++k;\n              if (checking)\n                continue;\n              set_window_size (-1, integer_arg (settings[k], INT_MAX),\n                               device_name);\n            }\n          else if (STREQ (arg, \"size\"))\n            {\n              if (checking)\n                continue;\n              max_col = screen_columns ();\n              current_col = 0;\n              display_window_size (false, device_name);\n            }\n#endif\n#ifdef HAVE_C_LINE\n          else if (STREQ (arg, \"line\"))\n            {\n              unsigned long int value;\n              check_argument (arg);\n              ++k;\n              mode->c_line = value = integer_arg (settings[k], ULONG_MAX);\n              if (mode->c_line != value)\n                error (0, 0, _(\"invalid line discipline %s\"),\n                       quote (settings[k]));\n              *require_set_attr = true;\n            }\n#endif\n          else if (STREQ (arg, \"speed\"))\n            {\n              if (checking)\n                continue;\n              max_col = screen_columns ();\n              display_speed (mode, false);\n            }\n          else if (string_to_baud (arg) != (speed_t) -1)\n            {\n              set_speed (both_speeds, arg, mode);\n              if (checking)\n                continue;\n              *require_set_attr = true;\n            }\n          else\n            {\n              if (! recover_mode (arg, mode))\n                {\n                  error (0, 0, _(\"invalid argument %s\"), quote (arg));\n                  usage (EXIT_FAILURE);\n                }\n              *require_set_attr = true;\n            }\n        }\n    }\n\n  if (checking)\n    check_speed (mode);\n}\n\nint\nmain (int argc, char **argv)\n{\n   \n  static struct termios mode;\n\n  enum output_type output_type;\n  int optc;\n  int argi = 0;\n  int opti = 1;\n  bool require_set_attr;\n  bool verbose_output;\n  bool recoverable_output;\n  bool noargs = true;\n  char *file_name = nullptr;\n  char const *device_name;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  output_type = changed;\n  verbose_output = false;\n  recoverable_output = false;\n\n   \n  opterr = 0;\n\n   \n\n  while ((optc = getopt_long (argc - argi, argv + argi, \"-agF:\",\n                              longopts, nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'a':\n          verbose_output = true;\n          output_type = all;\n          break;\n\n        case 'g':\n          recoverable_output = true;\n          output_type = recoverable;\n          break;\n\n        case 'F':\n          if (file_name)\n            error (EXIT_FAILURE, 0, _(\"only one device may be specified\"));\n          file_name = optarg;\n          break;\n\n        case DEV_DEBUG_OPTION:\n          dev_debug = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n           \n          if (! STREQ (argv[argi + opti], \"-drain\")\n              && ! STREQ (argv[argi + opti], \"drain\"))\n            noargs = false;\n\n           \n          argi += opti;\n\n           \n          opti = 1;\n          optind = 0;\n\n          break;\n        }\n\n       \n      while (opti < optind)\n        argv[argi + opti++] = nullptr;\n    }\n\n   \n  if (verbose_output && recoverable_output)\n    error (EXIT_FAILURE, 0,\n           _(\"the options for verbose and stty-readable output styles are\\n\"\n             \"mutually exclusive\"));\n\n   \n  if (!noargs && (verbose_output || recoverable_output))\n    error (EXIT_FAILURE, 0,\n           _(\"when specifying an output style, modes may not be set\"));\n\n  device_name = file_name ? file_name : _(\"standard input\");\n\n  if (!noargs && !verbose_output && !recoverable_output)\n    {\n      static struct termios check_mode;\n      apply_settings (  true, device_name, argv, argc,\n                      &check_mode, &require_set_attr);\n    }\n\n  if (file_name)\n    {\n      int fdflags;\n      if (fd_reopen (STDIN_FILENO, device_name, O_RDONLY | O_NONBLOCK, 0) < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n      if ((fdflags = fcntl (STDIN_FILENO, F_GETFL)) == -1\n          || fcntl (STDIN_FILENO, F_SETFL, fdflags & ~O_NONBLOCK) < 0)\n        error (EXIT_FAILURE, errno, _(\"%s: couldn't reset non-blocking mode\"),\n               quotef (device_name));\n    }\n\n  if (tcgetattr (STDIN_FILENO, &mode))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n\n  if (verbose_output || recoverable_output || noargs)\n    {\n      max_col = screen_columns ();\n      current_col = 0;\n      display_settings (output_type, &mode, device_name);\n      return EXIT_SUCCESS;\n    }\n\n  require_set_attr = false;\n  apply_settings (  false, device_name, argv, argc,\n                  &mode, &require_set_attr);\n\n  if (require_set_attr)\n    {\n       \n      static struct termios new_mode;\n\n      if (tcsetattr (STDIN_FILENO, tcsetattr_options, &mode))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n\n       \n\n      if (tcgetattr (STDIN_FILENO, &new_mode))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n\n      if (! eq_mode (&mode, &new_mode))\n        {\n          if (dev_debug)\n            {\n              error (0, 0, _(\"indx: mode: actual mode\"));\n              for (unsigned int i = 0; i < sizeof (new_mode); i++)\n                {\n                  unsigned int newc = *(((unsigned char *) &new_mode) + i);\n                  unsigned int oldc = *(((unsigned char *) &mode) + i);\n                  error (0, 0, \"0x%02x, 0x%02x: 0x%02x%s\", i, oldc, newc,\n                          newc == oldc ? \"\" : \" *\");\n                }\n            }\n\n          error (EXIT_FAILURE, 0,\n                 _(\"%s: unable to perform all requested operations\"),\n                 quotef (device_name));\n        }\n    }\n\n  return EXIT_SUCCESS;\n}\n\n \n\nstatic bool\neq_mode (struct termios *mode1, struct termios *mode2)\n{\n  return mode1->c_iflag == mode2->c_iflag\n      && mode1->c_oflag == mode2->c_oflag\n      && mode1->c_cflag == mode2->c_cflag\n      && mode1->c_lflag == mode2->c_lflag\n#ifdef HAVE_C_LINE\n      && mode1->c_line == mode2->c_line\n#endif\n      && memcmp (mode1->c_cc, mode2->c_cc, sizeof (mode1->c_cc)) == 0\n      && cfgetispeed (mode1) == cfgetispeed (mode2)\n      && cfgetospeed (mode1) == cfgetospeed (mode2);\n}\n\n \n\nstatic bool\nset_mode (struct mode_info const *info, bool reversed, struct termios *mode)\n{\n  tcflag_t *bitsp;\n\n  if (reversed && (info->flags & REV) == 0)\n    return false;\n\n  bitsp = mode_type_flag (info->type, mode);\n\n  if (bitsp == nullptr)\n    {\n       \n      if (STREQ (info->name, \"evenp\") || STREQ (info->name, \"parity\"))\n        {\n          if (reversed)\n            mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n          else\n            mode->c_cflag = (mode->c_cflag & ~PARODD & ~CSIZE) | PARENB | CS7;\n        }\n      else if (STREQ (info->name, \"oddp\"))\n        {\n          if (reversed)\n            mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n          else\n            mode->c_cflag = (mode->c_cflag & ~CSIZE) | CS7 | PARODD | PARENB;\n        }\n      else if (STREQ (info->name, \"nl\"))\n        {\n          if (reversed)\n            {\n              mode->c_iflag = (mode->c_iflag | ICRNL) & ~INLCR & ~IGNCR;\n              mode->c_oflag = (mode->c_oflag\n#ifdef ONLCR\n                               | ONLCR\n#endif\n                )\n#ifdef OCRNL\n                & ~OCRNL\n#endif\n#ifdef ONLRET\n                & ~ONLRET\n#endif\n                ;\n            }\n          else\n            {\n              mode->c_iflag = mode->c_iflag & ~ICRNL;\n#ifdef ONLCR\n              mode->c_oflag = mode->c_oflag & ~ONLCR;\n#endif\n            }\n        }\n      else if (STREQ (info->name, \"ek\"))\n        {\n          mode->c_cc[VERASE] = CERASE;\n          mode->c_cc[VKILL] = CKILL;\n        }\n      else if (STREQ (info->name, \"sane\"))\n        sane_mode (mode);\n      else if (STREQ (info->name, \"cbreak\"))\n        {\n          if (reversed)\n            mode->c_lflag |= ICANON;\n          else\n            mode->c_lflag &= ~ICANON;\n        }\n      else if (STREQ (info->name, \"pass8\"))\n        {\n          if (reversed)\n            {\n              mode->c_cflag = (mode->c_cflag & ~CSIZE) | CS7 | PARENB;\n              mode->c_iflag |= ISTRIP;\n            }\n          else\n            {\n              mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n              mode->c_iflag &= ~ISTRIP;\n            }\n        }\n      else if (STREQ (info->name, \"litout\"))\n        {\n          if (reversed)\n            {\n              mode->c_cflag = (mode->c_cflag & ~CSIZE) | CS7 | PARENB;\n              mode->c_iflag |= ISTRIP;\n              mode->c_oflag |= OPOST;\n            }\n          else\n            {\n              mode->c_cflag = (mode->c_cflag & ~PARENB & ~CSIZE) | CS8;\n              mode->c_iflag &= ~ISTRIP;\n              mode->c_oflag &= ~OPOST;\n            }\n        }\n      else if (STREQ (info->name, \"raw\") || STREQ (info->name, \"cooked\"))\n        {\n          if ((info->name[0] == 'r' && reversed)\n              || (info->name[0] == 'c' && !reversed))\n            {\n               \n              mode->c_iflag |= BRKINT | IGNPAR | ISTRIP | ICRNL | IXON;\n              mode->c_oflag |= OPOST;\n              mode->c_lflag |= ISIG | ICANON;\n#if VMIN == VEOF\n              mode->c_cc[VEOF] = CEOF;\n#endif\n#if VTIME == VEOL\n              mode->c_cc[VEOL] = CEOL;\n#endif\n            }\n          else\n            {\n               \n              mode->c_iflag = 0;\n              mode->c_oflag &= ~OPOST;\n              mode->c_lflag &= ~(ISIG | ICANON\n#ifdef XCASE\n                                 | XCASE\n#endif\n                );\n              mode->c_cc[VMIN] = 1;\n              mode->c_cc[VTIME] = 0;\n            }\n        }\n#ifdef IXANY\n      else if (STREQ (info->name, \"decctlq\"))\n        {\n          if (reversed)\n            mode->c_iflag |= IXANY;\n          else\n            mode->c_iflag &= ~IXANY;\n        }\n#endif\n#ifdef TABDLY\n      else if (STREQ (info->name, \"tabs\"))\n        {\n          if (reversed)\n            mode->c_oflag = (mode->c_oflag & ~TABDLY) | TAB3;\n          else\n            mode->c_oflag = (mode->c_oflag & ~TABDLY) | TAB0;\n        }\n#else\n# ifdef OXTABS\n      else if (STREQ (info->name, \"tabs\"))\n        {\n          if (reversed)\n            mode->c_oflag = mode->c_oflag | OXTABS;\n          else\n            mode->c_oflag = mode->c_oflag & ~OXTABS;\n        }\n# endif\n#endif\n#if defined XCASE && defined IUCLC && defined OLCUC\n      else if (STREQ (info->name, \"lcase\")\n               || STREQ (info->name, \"LCASE\"))\n        {\n          if (reversed)\n            {\n              mode->c_lflag &= ~XCASE;\n              mode->c_iflag &= ~IUCLC;\n              mode->c_oflag &= ~OLCUC;\n            }\n          else\n            {\n              mode->c_lflag |= XCASE;\n              mode->c_iflag |= IUCLC;\n              mode->c_oflag |= OLCUC;\n            }\n        }\n#endif\n      else if (STREQ (info->name, \"crt\"))\n        mode->c_lflag |= ECHOE\n#ifdef ECHOCTL\n          | ECHOCTL\n#endif\n#ifdef ECHOKE\n          | ECHOKE\n#endif\n          ;\n      else if (STREQ (info->name, \"dec\"))\n        {\n          mode->c_cc[VINTR] = 3;\t \n          mode->c_cc[VERASE] = 127;\t \n          mode->c_cc[VKILL] = 21;\t \n          mode->c_lflag |= ECHOE\n#ifdef ECHOCTL\n            | ECHOCTL\n#endif\n#ifdef ECHOKE\n            | ECHOKE\n#endif\n            ;\n#ifdef IXANY\n          mode->c_iflag &= ~IXANY;\n#endif\n        }\n    }\n  else if (reversed)\n    *bitsp = *bitsp & ~info->mask & ~info->bits;\n  else\n    *bitsp = (*bitsp & ~info->mask) | info->bits;\n\n  return true;\n}\n\nstatic void\nset_control_char (struct control_info const *info, char const *arg,\n                  struct termios *mode)\n{\n  unsigned long int value;\n\n  if (STREQ (info->name, \"min\") || STREQ (info->name, \"time\"))\n    value = integer_arg (arg, TYPE_MAXIMUM (cc_t));\n  else if (arg[0] == '\\0' || arg[1] == '\\0')\n    value = to_uchar (arg[0]);\n  else if (STREQ (arg, \"^-\") || STREQ (arg, \"undef\"))\n    value = _POSIX_VDISABLE;\n  else if (arg[0] == '^' && arg[1] != '\\0')\t \n    {\n      if (arg[1] == '?')\n        value = 127;\n      else\n        value = to_uchar (arg[1]) & ~0140;  \n    }\n  else\n    value = integer_arg (arg, TYPE_MAXIMUM (cc_t));\n  mode->c_cc[info->offset] = value;\n}\n\nstatic void\nset_speed (enum speed_setting type, char const *arg, struct termios *mode)\n{\n   \n\n  speed_t baud = string_to_baud (arg);\n  affirm (baud != (speed_t) -1);\n\n  if (type == input_speed || type == both_speeds)\n    {\n      last_ibaud = baud;\n      if (cfsetispeed (mode, baud))\n        error (EXIT_FAILURE, 0, _(\"unsupported ispeed %s\"), quoteaf (arg));\n    }\n  if (type == output_speed || type == both_speeds)\n    {\n      last_obaud = baud;\n      if (cfsetospeed (mode, baud))\n        error (EXIT_FAILURE, 0, _(\"unsupported ospeed %s\"), quoteaf (arg));\n    }\n}\n\n#ifdef TIOCGWINSZ\n\nstatic int\nget_win_size (int fd, struct winsize *win)\n{\n  int err = ioctl (fd, TIOCGWINSZ, (char *) win);\n  return err;\n}\n\nstatic void\nset_window_size (int rows, int cols, char const *device_name)\n{\n  struct winsize win;\n\n  if (get_win_size (STDIN_FILENO, &win))\n    {\n      if (errno != EINVAL)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n      memset (&win, 0, sizeof (win));\n    }\n\n  if (rows >= 0)\n    win.ws_row = rows;\n  if (cols >= 0)\n    win.ws_col = cols;\n\n# ifdef TIOCSSIZE\n   \n\n  if (win.ws_row == 0 || win.ws_col == 0)\n    {\n      struct ttysize ttysz;\n\n      ttysz.ts_lines = win.ws_row;\n      ttysz.ts_cols = win.ws_col;\n\n      win.ws_row = 1;\n      win.ws_col = 1;\n\n      if (ioctl (STDIN_FILENO, TIOCSWINSZ, (char *) &win))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n\n      if (ioctl (STDIN_FILENO, TIOCSSIZE, (char *) &ttysz))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n      return;\n    }\n# endif\n\n  if (ioctl (STDIN_FILENO, TIOCSWINSZ, (char *) &win))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n}\n\nstatic void\ndisplay_window_size (bool fancy, char const *device_name)\n{\n  struct winsize win;\n\n  if (get_win_size (STDIN_FILENO, &win))\n    {\n      if (errno != EINVAL)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (device_name));\n      if (!fancy)\n        error (EXIT_FAILURE, 0,\n               _(\"%s: no size information for this device\"),\n               quotef (device_name));\n    }\n  else\n    {\n      wrapf (fancy ? \"rows %d; columns %d;\" : \"%d %d\\n\",\n             win.ws_row, win.ws_col);\n      if (!fancy)\n        current_col = 0;\n    }\n}\n#endif\n\nstatic int\nscreen_columns (void)\n{\n#ifdef TIOCGWINSZ\n  struct winsize win;\n\n   \n  if (get_win_size (STDOUT_FILENO, &win) == 0 && 0 < win.ws_col)\n    return win.ws_col;\n#endif\n  {\n     \n    char *col_string = getenv (\"COLUMNS\");\n    long int n_columns;\n    if (!(col_string != nullptr\n          && xstrtol (col_string, nullptr, 0, &n_columns, \"\") == LONGINT_OK\n          && 0 < n_columns\n          && n_columns <= INT_MAX))\n      n_columns = 80;\n    return n_columns;\n  }\n}\n\nATTRIBUTE_PURE\nstatic tcflag_t *\nmode_type_flag (enum mode_type type, struct termios *mode)\n{\n  switch (type)\n    {\n    case control:\n      return &mode->c_cflag;\n\n    case input:\n      return &mode->c_iflag;\n\n    case output:\n      return &mode->c_oflag;\n\n    case local:\n      return &mode->c_lflag;\n\n    case combination:\n      return nullptr;\n\n    default:\n      unreachable ();\n    }\n}\n\nstatic void\ndisplay_settings (enum output_type output_type, struct termios *mode,\n                  char const *device_name)\n{\n  switch (output_type)\n    {\n    case changed:\n      display_changed (mode);\n      break;\n\n    case all:\n      display_all (mode, device_name);\n      break;\n\n    case recoverable:\n      display_recoverable (mode);\n      break;\n    }\n}\n\nstatic void\ndisplay_changed (struct termios *mode)\n{\n  int i;\n  bool empty_line;\n  tcflag_t *bitsp;\n  unsigned long mask;\n  enum mode_type prev_type = control;\n\n  display_speed (mode, true);\n#ifdef HAVE_C_LINE\n  wrapf (\"line = %d;\", mode->c_line);\n#endif\n  putchar ('\\n');\n  current_col = 0;\n\n  empty_line = true;\n  for (i = 0; !STREQ (control_info[i].name, \"min\"); ++i)\n    {\n      if (mode->c_cc[control_info[i].offset] == control_info[i].saneval)\n        continue;\n\n#ifdef VFLUSHO\n       \n      if (STREQ (control_info[i].name, \"flush\"))\n        continue;\n#endif\n       \n#if VSWTCH == VSUSP\n      if (STREQ (control_info[i].name, \"swtch\"))\n        continue;\n#endif\n       \n#if VEOF == VMIN\n      if ((mode->c_lflag & ICANON) == 0\n          && (STREQ (control_info[i].name, \"eof\")\n              || STREQ (control_info[i].name, \"eol\")))\n        continue;\n#endif\n\n      empty_line = false;\n      wrapf (\"%s = %s;\", control_info[i].name,\n             visible (mode->c_cc[control_info[i].offset]));\n    }\n  if ((mode->c_lflag & ICANON) == 0)\n    {\n      wrapf (\"min = %lu; time = %lu;\\n\",\n             (unsigned long int) mode->c_cc[VMIN],\n             (unsigned long int) mode->c_cc[VTIME]);\n    }\n  else if (!empty_line)\n    putchar ('\\n');\n  current_col = 0;\n\n  empty_line = true;\n  for (i = 0; mode_info[i].name != nullptr; ++i)\n    {\n      if (mode_info[i].flags & OMIT)\n        continue;\n      if (mode_info[i].type != prev_type)\n        {\n          if (!empty_line)\n            {\n              putchar ('\\n');\n              current_col = 0;\n              empty_line = true;\n            }\n          prev_type = mode_info[i].type;\n        }\n\n      bitsp = mode_type_flag (mode_info[i].type, mode);\n      mask = mode_info[i].mask ? mode_info[i].mask : mode_info[i].bits;\n      if ((*bitsp & mask) == mode_info[i].bits)\n        {\n          if (mode_info[i].flags & SANE_UNSET)\n            {\n              wrapf (\"%s\", mode_info[i].name);\n              empty_line = false;\n            }\n        }\n      else if ((mode_info[i].flags & (SANE_SET | REV)) == (SANE_SET | REV))\n        {\n          wrapf (\"-%s\", mode_info[i].name);\n          empty_line = false;\n        }\n    }\n  if (!empty_line)\n    putchar ('\\n');\n  current_col = 0;\n}\n\nstatic void\ndisplay_all (struct termios *mode, char const *device_name)\n{\n  int i;\n  tcflag_t *bitsp;\n  unsigned long mask;\n  enum mode_type prev_type = control;\n\n  display_speed (mode, true);\n#ifdef TIOCGWINSZ\n  display_window_size (true, device_name);\n#endif\n#ifdef HAVE_C_LINE\n  wrapf (\"line = %d;\", mode->c_line);\n#endif\n  putchar ('\\n');\n  current_col = 0;\n\n  for (i = 0; ! STREQ (control_info[i].name, \"min\"); ++i)\n    {\n#ifdef VFLUSHO\n       \n      if (STREQ (control_info[i].name, \"flush\"))\n        continue;\n#endif\n       \n#if VSWTCH == VSUSP\n      if (STREQ (control_info[i].name, \"swtch\"))\n        continue;\n#endif\n       \n#if VEOF == VMIN\n      if ((mode->c_lflag & ICANON) == 0\n          && (STREQ (control_info[i].name, \"eof\")\n              || STREQ (control_info[i].name, \"eol\")))\n        continue;\n#endif\n      wrapf (\"%s = %s;\", control_info[i].name,\n             visible (mode->c_cc[control_info[i].offset]));\n    }\n#if VEOF == VMIN\n  if ((mode->c_lflag & ICANON) == 0)\n#endif\n    wrapf (\"min = %lu; time = %lu;\",\n           (unsigned long int) mode->c_cc[VMIN],\n           (unsigned long int) mode->c_cc[VTIME]);\n  if (current_col != 0)\n    putchar ('\\n');\n  current_col = 0;\n\n  for (i = 0; mode_info[i].name != nullptr; ++i)\n    {\n      if (mode_info[i].flags & OMIT)\n        continue;\n      if (mode_info[i].type != prev_type)\n        {\n          putchar ('\\n');\n          current_col = 0;\n          prev_type = mode_info[i].type;\n        }\n\n      bitsp = mode_type_flag (mode_info[i].type, mode);\n      mask = mode_info[i].mask ? mode_info[i].mask : mode_info[i].bits;\n      if ((*bitsp & mask) == mode_info[i].bits)\n        wrapf (\"%s\", mode_info[i].name);\n      else if (mode_info[i].flags & REV)\n        wrapf (\"-%s\", mode_info[i].name);\n    }\n  putchar ('\\n');\n  current_col = 0;\n}\n\n \n\nstatic void\ncheck_speed (struct termios *mode)\n{\n  if (last_ibaud != -1 && last_obaud != -1)\n    {\n      if (cfgetispeed (mode) != last_ibaud\n          || cfgetospeed (mode) != last_obaud)\n        error (EXIT_FAILURE, 0,\n               _(\"asymmetric input (%lu), output (%lu) speeds not supported\"),\n               baud_to_value (last_ibaud), baud_to_value (last_obaud));\n    }\n}\n\nstatic void\ndisplay_speed (struct termios *mode, bool fancy)\n{\n  if (cfgetispeed (mode) == 0 || cfgetispeed (mode) == cfgetospeed (mode))\n    wrapf (fancy ? \"speed %lu baud;\" : \"%lu\\n\",\n           baud_to_value (cfgetospeed (mode)));\n  else\n    wrapf (fancy ? \"ispeed %lu baud; ospeed %lu baud;\" : \"%lu %lu\\n\",\n           baud_to_value (cfgetispeed (mode)),\n           baud_to_value (cfgetospeed (mode)));\n  if (!fancy)\n    current_col = 0;\n}\n\nstatic void\ndisplay_recoverable (struct termios *mode)\n{\n  printf (\"%lx:%lx:%lx:%lx\",\n          (unsigned long int) mode->c_iflag,\n          (unsigned long int) mode->c_oflag,\n          (unsigned long int) mode->c_cflag,\n          (unsigned long int) mode->c_lflag);\n  for (size_t i = 0; i < NCCS; ++i)\n    printf (\":%lx\", (unsigned long int) mode->c_cc[i]);\n  putchar ('\\n');\n}\n\n \nstatic int\nstrtoul_tcflag_t (char const *s, int base, char **p, tcflag_t *result,\n                  char delim)\n{\n  unsigned long ul;\n  errno = 0;\n  ul = strtoul (s, p, base);\n  if (errno || **p != delim || *p == s || (tcflag_t) ul != ul)\n    return -1;\n  *result = ul;\n  return 0;\n}\n\n \nstatic int\nstrtoul_cc_t (char const *s, int base, char **p, cc_t *result, char delim)\n{\n  unsigned long ul;\n  errno = 0;\n  ul = strtoul (s, p, base);\n  if (errno || **p != delim || *p == s || (cc_t) ul != ul)\n    return -1;\n  *result = ul;\n  return 0;\n}\n\n \nstatic bool\nrecover_mode (char const *arg, struct termios *mode)\n{\n  tcflag_t flag[4];\n  char const *s = arg;\n  size_t i;\n  for (i = 0; i < 4; i++)\n    {\n      char *p;\n      if (strtoul_tcflag_t (s, 16, &p, flag + i, ':') != 0)\n        return false;\n      s = p + 1;\n    }\n  mode->c_iflag = flag[0];\n  mode->c_oflag = flag[1];\n  mode->c_cflag = flag[2];\n  mode->c_lflag = flag[3];\n\n  for (i = 0; i < NCCS; ++i)\n    {\n      char *p;\n      char delim = i < NCCS - 1 ? ':' : '\\0';\n      if (strtoul_cc_t (s, 16, &p, mode->c_cc + i, delim) != 0)\n        return false;\n      s = p + 1;\n    }\n\n  return true;\n}\n\nstruct speed_map\n{\n  char const *string;\t\t \n  speed_t speed;\t\t \n  unsigned long int value;\t \n};\n\nstatic struct speed_map const speeds[] =\n{\n  {\"0\", B0, 0},\n  {\"50\", B50, 50},\n  {\"75\", B75, 75},\n  {\"110\", B110, 110},\n  {\"134\", B134, 134},\n  {\"134.5\", B134, 134},\n  {\"150\", B150, 150},\n  {\"200\", B200, 200},\n  {\"300\", B300, 300},\n  {\"600\", B600, 600},\n  {\"1200\", B1200, 1200},\n  {\"1800\", B1800, 1800},\n  {\"2400\", B2400, 2400},\n  {\"4800\", B4800, 4800},\n  {\"9600\", B9600, 9600},\n  {\"19200\", B19200, 19200},\n  {\"38400\", B38400, 38400},\n  {\"exta\", B19200, 19200},\n  {\"extb\", B38400, 38400},\n#ifdef B57600\n  {\"57600\", B57600, 57600},\n#endif\n#ifdef B115200\n  {\"115200\", B115200, 115200},\n#endif\n#ifdef B230400\n  {\"230400\", B230400, 230400},\n#endif\n#ifdef B460800\n  {\"460800\", B460800, 460800},\n#endif\n#ifdef B500000\n  {\"500000\", B500000, 500000},\n#endif\n#ifdef B576000\n  {\"576000\", B576000, 576000},\n#endif\n#ifdef B921600\n  {\"921600\", B921600, 921600},\n#endif\n#ifdef B1000000\n  {\"1000000\", B1000000, 1000000},\n#endif\n#ifdef B1152000\n  {\"1152000\", B1152000, 1152000},\n#endif\n#ifdef B1500000\n  {\"1500000\", B1500000, 1500000},\n#endif\n#ifdef B2000000\n  {\"2000000\", B2000000, 2000000},\n#endif\n#ifdef B2500000\n  {\"2500000\", B2500000, 2500000},\n#endif\n#ifdef B3000000\n  {\"3000000\", B3000000, 3000000},\n#endif\n#ifdef B3500000\n  {\"3500000\", B3500000, 3500000},\n#endif\n#ifdef B4000000\n  {\"4000000\", B4000000, 4000000},\n#endif\n  {nullptr, 0, 0}\n};\n\nATTRIBUTE_PURE\nstatic speed_t\nstring_to_baud (char const *arg)\n{\n  for (int i = 0; speeds[i].string != nullptr; ++i)\n    if (STREQ (arg, speeds[i].string))\n      return speeds[i].speed;\n  return (speed_t) -1;\n}\n\nATTRIBUTE_PURE\nstatic unsigned long int\nbaud_to_value (speed_t speed)\n{\n  for (int i = 0; speeds[i].string != nullptr; ++i)\n    if (speed == speeds[i].speed)\n      return speeds[i].value;\n  return 0;\n}\n\nstatic void\nsane_mode (struct termios *mode)\n{\n  int i;\n  tcflag_t *bitsp;\n\n  for (i = 0; control_info[i].name; ++i)\n    {\n#if VMIN == VEOF\n      if (STREQ (control_info[i].name, \"min\"))\n        break;\n#endif\n      mode->c_cc[control_info[i].offset] = control_info[i].saneval;\n    }\n\n  for (i = 0; mode_info[i].name != nullptr; ++i)\n    {\n      if (mode_info[i].flags & NO_SETATTR)\n        continue;\n\n      if (mode_info[i].flags & SANE_SET)\n        {\n          bitsp = mode_type_flag (mode_info[i].type, mode);\n          assume (bitsp);  \n          *bitsp = (*bitsp & ~mode_info[i].mask) | mode_info[i].bits;\n        }\n      else if (mode_info[i].flags & SANE_UNSET)\n        {\n          bitsp = mode_type_flag (mode_info[i].type, mode);\n          assume (bitsp);  \n          *bitsp = *bitsp & ~mode_info[i].mask & ~mode_info[i].bits;\n        }\n    }\n}\n\n \n \n\nstatic char const *\nvisible (cc_t ch)\n{\n  static char buf[10];\n  char *bpout = buf;\n\n  if (ch == _POSIX_VDISABLE)\n    return \"<undef>\";\n\n  if (ch >= 32)\n    {\n      if (ch < 127)\n        *bpout++ = ch;\n      else if (ch == 127)\n        {\n          *bpout++ = '^';\n          *bpout++ = '?';\n        }\n      else\n        {\n          *bpout++ = 'M';\n          *bpout++ = '-';\n          if (ch >= 128 + 32)\n            {\n              if (ch < 128 + 127)\n                *bpout++ = ch - 128;\n              else\n                {\n                  *bpout++ = '^';\n                  *bpout++ = '?';\n                }\n            }\n          else\n            {\n              *bpout++ = '^';\n              *bpout++ = ch - 128 + 64;\n            }\n        }\n    }\n  else\n    {\n      *bpout++ = '^';\n      *bpout++ = ch + 64;\n    }\n  *bpout = '\\0';\n  return (char const *) buf;\n}\n\n \n\nstatic unsigned long int\ninteger_arg (char const *s, unsigned long int maxval)\n{\n  return xnumtoumax (s, 0, 0, maxval, \"bB\", _(\"invalid integer argument\"), 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}