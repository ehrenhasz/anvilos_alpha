{
  "module_name": "numfmt.c",
  "hash_id": "23b4502258f3898f0d68f208ba41cd6afda69d12fa0046d47d252972d1d90ee7",
  "original_prompt": "Ingested from coreutils-9.4/src/numfmt.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"numfmt\"\n\n#define AUTHORS proper_name (\"Assaf Gordon\")\n\n \nenum { EXIT_CONVERSION_WARNINGS = 2 };\n\nenum\n{\n  FROM_OPTION = CHAR_MAX + 1,\n  FROM_UNIT_OPTION,\n  TO_OPTION,\n  TO_UNIT_OPTION,\n  ROUND_OPTION,\n  SUFFIX_OPTION,\n  GROUPING_OPTION,\n  PADDING_OPTION,\n  FIELD_OPTION,\n  DEBUG_OPTION,\n  DEV_DEBUG_OPTION,\n  HEADER_OPTION,\n  FORMAT_OPTION,\n  INVALID_OPTION\n};\n\nenum scale_type\n{\n  scale_none,                    \n  scale_auto,                    \n  scale_SI,\n  scale_IEC,\n  scale_IEC_I                    \n};\n\nstatic char const *const scale_from_args[] =\n{\n  \"none\", \"auto\", \"si\", \"iec\", \"iec-i\", nullptr\n};\n\nstatic enum scale_type const scale_from_types[] =\n{\n  scale_none, scale_auto, scale_SI, scale_IEC, scale_IEC_I\n};\n\nstatic char const *const scale_to_args[] =\n{\n  \"none\", \"si\", \"iec\", \"iec-i\", nullptr\n};\n\nstatic enum scale_type const scale_to_types[] =\n{\n  scale_none, scale_SI, scale_IEC, scale_IEC_I\n};\n\n\nenum round_type\n{\n  round_ceiling,\n  round_floor,\n  round_from_zero,\n  round_to_zero,\n  round_nearest,\n};\n\nstatic char const *const round_args[] =\n{\n  \"up\", \"down\", \"from-zero\", \"towards-zero\", \"nearest\", nullptr\n};\n\nstatic enum round_type const round_types[] =\n{\n  round_ceiling, round_floor, round_from_zero, round_to_zero, round_nearest\n};\n\n\nenum inval_type\n{\n  inval_abort,\n  inval_fail,\n  inval_warn,\n  inval_ignore\n};\n\nstatic char const *const inval_args[] =\n{\n  \"abort\", \"fail\", \"warn\", \"ignore\", nullptr\n};\n\nstatic enum inval_type const inval_types[] =\n{\n  inval_abort, inval_fail, inval_warn, inval_ignore\n};\n\nstatic struct option const longopts[] =\n{\n  {\"from\", required_argument, nullptr, FROM_OPTION},\n  {\"from-unit\", required_argument, nullptr, FROM_UNIT_OPTION},\n  {\"to\", required_argument, nullptr, TO_OPTION},\n  {\"to-unit\", required_argument, nullptr, TO_UNIT_OPTION},\n  {\"round\", required_argument, nullptr, ROUND_OPTION},\n  {\"padding\", required_argument, nullptr, PADDING_OPTION},\n  {\"suffix\", required_argument, nullptr, SUFFIX_OPTION},\n  {\"grouping\", no_argument, nullptr, GROUPING_OPTION},\n  {\"delimiter\", required_argument, nullptr, 'd'},\n  {\"field\", required_argument, nullptr, FIELD_OPTION},\n  {\"debug\", no_argument, nullptr, DEBUG_OPTION},\n  {\"-debug\", no_argument, nullptr, DEV_DEBUG_OPTION},\n  {\"header\", optional_argument, nullptr, HEADER_OPTION},\n  {\"format\", required_argument, nullptr, FORMAT_OPTION},\n  {\"invalid\", required_argument, nullptr, INVALID_OPTION},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nenum { DELIMITER_DEFAULT = CHAR_MAX + 1 };\n\n \nenum { MAX_UNSCALED_DIGITS = LDBL_DIG };\n\n \nenum { MAX_ACCEPTABLE_DIGITS = 33 };\n\nstatic enum scale_type scale_from = scale_none;\nstatic enum scale_type scale_to = scale_none;\nstatic enum round_type round_style = round_from_zero;\nstatic enum inval_type inval_style = inval_abort;\nstatic char const *suffix = nullptr;\nstatic uintmax_t from_unit_size = 1;\nstatic uintmax_t to_unit_size = 1;\nstatic int grouping = 0;\nstatic char *padding_buffer = nullptr;\nstatic size_t padding_buffer_size = 0;\nstatic long int padding_width = 0;\nstatic long int zero_padding_width = 0;\nstatic long int user_precision = -1;\nstatic char const *format_str = nullptr;\nstatic char *format_str_prefix = nullptr;\nstatic char *format_str_suffix = nullptr;\n\n \nstatic int conv_exit_code = EXIT_CONVERSION_WARNINGS;\n\n\n \nstatic int auto_padding = 0;\nstatic mbs_align_t padding_alignment = MBS_ALIGN_RIGHT;\n\n \nstatic int delimiter = DELIMITER_DEFAULT;\n\n \nstatic unsigned char line_delim = '\\n';\n\n \nstatic uintmax_t header = 0;\n\n \nstatic bool debug;\n\n \nstatic char const *decimal_point;\nstatic int decimal_point_length;\n\n \nstatic bool dev_debug = false;\n\n\nstatic inline int\ndefault_scale_base (enum scale_type scale)\n{\n  switch (scale)\n    {\n    case scale_IEC:\n    case scale_IEC_I:\n      return 1024;\n\n    case scale_none:\n    case scale_auto:\n    case scale_SI:\n    default:\n      return 1000;\n    }\n}\n\nstatic char const zero_and_valid_suffixes[] = \"0KMGTPEZYRQ\";\nstatic char const *valid_suffixes = 1 + zero_and_valid_suffixes;\n\nstatic inline bool\nvalid_suffix (const char suf)\n{\n  return strchr (valid_suffixes, suf) != nullptr;\n}\n\nstatic inline int\nsuffix_power (const char suf)\n{\n  switch (suf)\n    {\n    case 'K':                   \n      return 1;\n\n    case 'M':                   \n      return 2;\n\n    case 'G':                   \n      return 3;\n\n    case 'T':                   \n      return 4;\n\n    case 'P':                   \n      return 5;\n\n    case 'E':                   \n      return 6;\n\n    case 'Z':                   \n      return 7;\n\n    case 'Y':                   \n      return 8;\n\n    case 'R':                   \n      return 9;\n\n    case 'Q':                   \n      return 10;\n\n    default:                    \n      return 0;\n    }\n}\n\nstatic inline char const *\nsuffix_power_char (int power)\n{\n  switch (power)\n    {\n    case 0:\n      return \"\";\n\n    case 1:\n      return \"K\";\n\n    case 2:\n      return \"M\";\n\n    case 3:\n      return \"G\";\n\n    case 4:\n      return \"T\";\n\n    case 5:\n      return \"P\";\n\n    case 6:\n      return \"E\";\n\n    case 7:\n      return \"Z\";\n\n    case 8:\n      return \"Y\";\n\n    case 9:\n      return \"R\";\n\n    case 10:\n      return \"Q\";\n\n    default:\n      return \"(error)\";\n    }\n}\n\n \nstatic long double\npowerld (long double base, int x)\n{\n  long double result = base;\n  if (x == 0)\n    return 1;                    \n\n   \n  while (--x)\n    result *= base;\n  return result;\n}\n\n \nstatic inline long double\nabsld (long double val)\n{\n  return val < 0 ? -val : val;\n}\n\n \nstatic long double\nexpld (long double val, int base, int   *x)\n{\n  int power = 0;\n\n  if (val >= -LDBL_MAX && val <= LDBL_MAX)\n    {\n      while (absld (val) >= base)\n        {\n          ++power;\n          val /= base;\n        }\n    }\n  if (x)\n    *x = power;\n  return val;\n}\n\n \nstatic inline intmax_t\nsimple_round_ceiling (long double val)\n{\n  intmax_t intval = val;\n  if (intval < val)\n    intval++;\n  return intval;\n}\n\n \nstatic inline intmax_t\nsimple_round_floor (long double val)\n{\n  return -simple_round_ceiling (-val);\n}\n\n \nstatic inline intmax_t\nsimple_round_from_zero (long double val)\n{\n  return val < 0 ? simple_round_floor (val) : simple_round_ceiling (val);\n}\n\n \nstatic inline intmax_t\nsimple_round_to_zero (long double val)\n{\n  return val;\n}\n\n \nstatic inline intmax_t\nsimple_round_nearest (long double val)\n{\n  return val < 0 ? val - 0.5 : val + 0.5;\n}\n\nATTRIBUTE_CONST\nstatic inline long double\nsimple_round (long double val, enum round_type t)\n{\n  intmax_t rval;\n  intmax_t intmax_mul = val / INTMAX_MAX;\n  val -= (long double) INTMAX_MAX * intmax_mul;\n\n  switch (t)\n    {\n    case round_ceiling:\n      rval = simple_round_ceiling (val);\n      break;\n\n    case round_floor:\n      rval = simple_round_floor (val);\n      break;\n\n    case round_from_zero:\n      rval = simple_round_from_zero (val);\n      break;\n\n    case round_to_zero:\n      rval = simple_round_to_zero (val);\n      break;\n\n    case round_nearest:\n      rval = simple_round_nearest (val);\n      break;\n\n    default:\n       \n      return 0;\n    }\n\n  return (long double) INTMAX_MAX * intmax_mul + rval;\n}\n\nenum simple_strtod_error\n{\n  SSE_OK = 0,\n  SSE_OK_PRECISION_LOSS,\n  SSE_OVERFLOW,\n  SSE_INVALID_NUMBER,\n\n   \n  SSE_VALID_BUT_FORBIDDEN_SUFFIX,\n  SSE_INVALID_SUFFIX,\n  SSE_MISSING_I_SUFFIX\n};\n\n \nstatic enum simple_strtod_error\nsimple_strtod_int (char const *input_str,\n                   char **endptr, long double *value, bool *negative)\n{\n  enum simple_strtod_error e = SSE_OK;\n\n  long double val = 0;\n  int digits = 0;\n  bool found_digit = false;\n\n  if (*input_str == '-')\n    {\n      input_str++;\n      *negative = true;\n    }\n  else\n    *negative = false;\n\n  *endptr = (char *) input_str;\n  while (c_isdigit (**endptr))\n    {\n      int digit = (**endptr) - '0';\n\n      found_digit = true;\n\n      if (val || digit)\n        digits++;\n\n      if (digits > MAX_UNSCALED_DIGITS)\n        e = SSE_OK_PRECISION_LOSS;\n\n      if (digits > MAX_ACCEPTABLE_DIGITS)\n        return SSE_OVERFLOW;\n\n      val *= 10;\n      val += digit;\n\n      ++(*endptr);\n    }\n  if (! found_digit\n      && ! STREQ_LEN (*endptr, decimal_point, decimal_point_length))\n    return SSE_INVALID_NUMBER;\n  if (*negative)\n    val = -val;\n\n  if (value)\n    *value = val;\n\n  return e;\n}\n\n \nstatic enum simple_strtod_error\nsimple_strtod_float (char const *input_str,\n                     char **endptr,\n                     long double *value,\n                     size_t *precision)\n{\n  bool negative;\n  enum simple_strtod_error e = SSE_OK;\n\n  if (precision)\n    *precision = 0;\n\n   \n  e = simple_strtod_int (input_str, endptr, value, &negative);\n  if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)\n    return e;\n\n   \n  if (STREQ_LEN (*endptr, decimal_point, decimal_point_length))\n    {\n      char *ptr2;\n      long double val_frac = 0;\n      bool neg_frac;\n\n      (*endptr) += decimal_point_length;\n      enum simple_strtod_error e2 =\n        simple_strtod_int (*endptr, &ptr2, &val_frac, &neg_frac);\n      if (e2 != SSE_OK && e2 != SSE_OK_PRECISION_LOSS)\n        return e2;\n      if (e2 == SSE_OK_PRECISION_LOSS)\n        e = e2;                        \n      if (neg_frac)\n        return SSE_INVALID_NUMBER;\n\n       \n      size_t exponent = ptr2 - *endptr;\n\n      val_frac = ((long double) val_frac) / powerld (10, exponent);\n\n       \n      if (value)\n        {\n          if (negative)\n            *value -= val_frac;\n          else\n            *value += val_frac;\n        }\n\n      if (precision)\n        *precision = exponent;\n\n      *endptr = ptr2;\n    }\n  return e;\n}\n\n \nstatic enum simple_strtod_error\nsimple_strtod_human (char const *input_str,\n                     char **endptr, long double *value, size_t *precision,\n                     enum scale_type allowed_scaling)\n{\n  int power = 0;\n   \n  int scale_base = default_scale_base (allowed_scaling);\n\n  devmsg (\"simple_strtod_human:\\n  input string: %s\\n\"\n          \"  locale decimal-point: %s\\n\"\n          \"  MAX_UNSCALED_DIGITS: %d\\n\",\n          quote_n (0, input_str),\n          quote_n (1, decimal_point),\n          MAX_UNSCALED_DIGITS);\n\n  enum simple_strtod_error e =\n    simple_strtod_float (input_str, endptr, value, precision);\n  if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)\n    return e;\n\n  devmsg (\"  parsed numeric value: %Lf\\n\"\n          \"  input precision = %d\\n\", *value, (int)*precision);\n\n  if (**endptr != '\\0')\n    {\n       \n\n       \n      while (isblank (to_uchar (**endptr)))\n        (*endptr)++;\n\n      if (!valid_suffix (**endptr))\n        return SSE_INVALID_SUFFIX;\n\n      if (allowed_scaling == scale_none)\n        return SSE_VALID_BUT_FORBIDDEN_SUFFIX;\n\n      power = suffix_power (**endptr);\n      (*endptr)++;                      \n\n      if (allowed_scaling == scale_auto && **endptr == 'i')\n        {\n           \n          scale_base = 1024;\n          (*endptr)++;               \n          devmsg (\"  Auto-scaling, found 'i', switching to base %d\\n\",\n                  scale_base);\n        }\n\n      *precision = 0;   \n    }\n\n  if (allowed_scaling == scale_IEC_I)\n    {\n      if (**endptr == 'i')\n        (*endptr)++;\n      else\n        return SSE_MISSING_I_SUFFIX;\n    }\n\n  long double multiplier = powerld (scale_base, power);\n\n  devmsg (\"  suffix power=%d^%d = %Lf\\n\", scale_base, power, multiplier);\n\n   \n  (*value) = (*value) * multiplier;\n\n  devmsg (\"  returning value: %Lf (%LG)\\n\", *value, *value);\n\n  return e;\n}\n\n\nstatic void\nsimple_strtod_fatal (enum simple_strtod_error err, char const *input_str)\n{\n  char const *msgid = nullptr;\n\n  switch (err)\n    {\n    case SSE_OK_PRECISION_LOSS:\n    case SSE_OK:\n       \n      unreachable ();\n\n    case SSE_OVERFLOW:\n      msgid = N_(\"value too large to be converted: %s\");\n      break;\n\n    case SSE_INVALID_NUMBER:\n      msgid = N_(\"invalid number: %s\");\n      break;\n\n    case SSE_VALID_BUT_FORBIDDEN_SUFFIX:\n      msgid = N_(\"rejecting suffix in input: %s (consider using --from)\");\n      break;\n\n    case SSE_INVALID_SUFFIX:\n      msgid = N_(\"invalid suffix in input: %s\");\n      break;\n\n    case SSE_MISSING_I_SUFFIX:\n      msgid = N_(\"missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)\");\n      break;\n\n    }\n\n  if (inval_style != inval_ignore)\n    error (conv_exit_code, 0, gettext (msgid), quote (input_str));\n}\n\n \nstatic void\ndouble_to_human (long double val, int precision,\n                 char *buf, size_t buf_size,\n                 enum scale_type scale, int group, enum round_type round)\n{\n  int num_size;\n  char fmt[64];\n  static_assert ((INT_BUFSIZE_BOUND (zero_padding_width)\n                  + INT_BUFSIZE_BOUND (precision)\n                  + 10  )\n                 < sizeof fmt);\n\n  char *pfmt = fmt;\n  *pfmt++ = '%';\n\n  if (group)\n    *pfmt++ = '\\'';\n\n  if (zero_padding_width)\n    pfmt += snprintf (pfmt, sizeof (fmt) - 2, \"0%ld\", zero_padding_width);\n\n  devmsg (\"double_to_human:\\n\");\n\n  if (scale == scale_none)\n    {\n      val *= powerld (10, precision);\n      val = simple_round (val, round);\n      val /= powerld (10, precision);\n\n      devmsg ((group) ?\n              \"  no scaling, returning (grouped) value: %'.*Lf\\n\" :\n              \"  no scaling, returning value: %.*Lf\\n\", precision, val);\n\n      stpcpy (pfmt, \".*Lf\");\n\n      num_size = snprintf (buf, buf_size, fmt, precision, val);\n      if (num_size < 0 || num_size >= (int) buf_size)\n        error (EXIT_FAILURE, 0,\n               _(\"failed to prepare value '%Lf' for printing\"), val);\n      return;\n    }\n\n   \n  double scale_base = default_scale_base (scale);\n\n   \n  int power = 0;\n  val = expld (val, scale_base, &power);\n  devmsg (\"  scaled value to %Lf * %0.f ^ %d\\n\", val, scale_base, power);\n\n   \n  int power_adjust = 0;\n  if (user_precision != -1)\n    power_adjust = MIN (power * 3, user_precision);\n  else if (absld (val) < 10)\n    {\n       \n      power_adjust = 1;\n    }\n\n  val *= powerld (10, power_adjust);\n  val = simple_round (val, round);\n  val /= powerld (10, power_adjust);\n\n   \n  if (absld (val) >= scale_base)\n    {\n      val /= scale_base;\n      power++;\n    }\n\n   \n  int show_decimal_point = (val != 0) && (absld (val) < 10) && (power > 0);\n   \n\n  devmsg (\"  after rounding, value=%Lf * %0.f ^ %d\\n\", val, scale_base, power);\n\n  stpcpy (pfmt, \".*Lf%s\");\n\n  int prec = user_precision == -1 ? show_decimal_point : user_precision;\n\n   \n  num_size = snprintf (buf, buf_size - 1, fmt, prec, val,\n                       suffix_power_char (power));\n  if (num_size < 0 || num_size >= (int) buf_size - 1)\n    error (EXIT_FAILURE, 0,\n           _(\"failed to prepare value '%Lf' for printing\"), val);\n\n  if (scale == scale_IEC_I && power > 0)\n    strncat (buf, \"i\", buf_size - num_size - 1);\n\n  devmsg (\"  returning value: %s\\n\", quote (buf));\n\n  return;\n}\n\n \nstatic uintmax_t\nunit_to_umax (char const *n_string)\n{\n  strtol_error s_err;\n  char const *c_string = n_string;\n  char *t_string = nullptr;\n  size_t n_len = strlen (n_string);\n  char *end = nullptr;\n  uintmax_t n;\n  char const *suffixes = valid_suffixes;\n\n   \n  if (n_len && ! c_isdigit (n_string[n_len - 1]))\n    {\n      t_string = xmalloc (n_len + 2);\n      end = t_string + n_len - 1;\n      memcpy (t_string, n_string, n_len);\n\n      if (*end == 'i' && 2 <= n_len && ! c_isdigit (*(end - 1)))\n        *end = '\\0';\n      else\n        {\n          *++end = 'B';\n          *++end = '\\0';\n          suffixes = zero_and_valid_suffixes;\n        }\n\n      c_string = t_string;\n    }\n\n  s_err = xstrtoumax (c_string, &end, 10, &n, suffixes);\n\n  if (s_err != LONGINT_OK || *end || n == 0)\n    {\n      free (t_string);\n      error (EXIT_FAILURE, 0, _(\"invalid unit size: %s\"), quote (n_string));\n    }\n\n  free (t_string);\n\n  return n;\n}\n\n\nstatic void\nsetup_padding_buffer (size_t min_size)\n{\n  if (padding_buffer_size > min_size)\n    return;\n\n  padding_buffer_size = min_size + 1;\n  padding_buffer = xrealloc (padding_buffer, padding_buffer_size);\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [NUMBER]...\\n\\\n\"), program_name);\n      fputs (_(\"\\\nReformat NUMBER(s), or the numbers from standard input if none are specified.\\n\\\n\"), stdout);\n      emit_mandatory_arg_note ();\n      fputs (_(\"\\\n      --debug          print warnings about invalid input\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -d, --delimiter=X    use X instead of whitespace for field delimiter\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --field=FIELDS   replace the numbers in these input fields (default=1);\\n\\\n                         see FIELDS below\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --format=FORMAT  use printf style floating-point FORMAT;\\n\\\n                         see FORMAT below for details\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --from=UNIT      auto-scale input numbers to UNITs; default is 'none';\\n\\\n                         see UNIT below\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --from-unit=N    specify the input unit size (instead of the default 1)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --grouping       use locale-defined grouping of digits, e.g. 1,000,000\\n\\\n                         (which means it has no effect in the C/POSIX locale)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --header[=N]     print (without converting) the first N header lines;\\n\\\n                         N defaults to 1 if not specified\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --invalid=MODE   failure mode for invalid numbers: MODE can be:\\n\\\n                         abort (default), fail, warn, ignore\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --padding=N      pad the output to N characters; positive N will\\n\\\n                         right-align; negative N will left-align;\\n\\\n                         padding is ignored if the output is wider than N;\\n\\\n                         the default is to automatically pad if a whitespace\\n\\\n                         is found\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\\n\\\n                         up, down, from-zero (default), towards-zero, nearest\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\\n\\\n                         SUFFIX in input numbers\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --to-unit=N      the output unit size (instead of the default 1)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated    line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n\n      fputs (_(\"\\\n\\n\\\nUNIT options:\\n\"), stdout);\n      fputs (_(\"\\\n  none       no auto-scaling is done; suffixes will trigger an error\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  auto       accept optional single/two letter suffix:\\n\\\n               1K = 1000,\\n\\\n               1Ki = 1024,\\n\\\n               1M = 1000000,\\n\\\n               1Mi = 1048576,\\n\"), stdout);\n      fputs (_(\"\\\n  si         accept optional single letter suffix:\\n\\\n               1K = 1000,\\n\\\n               1M = 1000000,\\n\\\n               ...\\n\"), stdout);\n      fputs (_(\"\\\n  iec        accept optional single letter suffix:\\n\\\n               1K = 1024,\\n\\\n               1M = 1048576,\\n\\\n               ...\\n\"), stdout);\n      fputs (_(\"\\\n  iec-i      accept optional two-letter suffix:\\n\\\n               1Ki = 1024,\\n\\\n               1Mi = 1048576,\\n\\\n               ...\\n\"), stdout);\n\n      fputs (_(\"\\n\\\nFIELDS supports cut(1) style field ranges:\\n\\\n  N    N'th field, counted from 1\\n\\\n  N-   from N'th field, to end of line\\n\\\n  N-M  from N'th to M'th field (inclusive)\\n\\\n  -M   from first to M'th field (inclusive)\\n\\\n  -    all fields\\n\\\nMultiple fields/ranges can be separated with commas\\n\\\n\"), stdout);\n\n      fputs (_(\"\\n\\\nFORMAT must be suitable for printing one floating-point argument '%f'.\\n\\\nOptional quote (%'f) will enable --grouping (if supported by current locale).\\n\\\nOptional width value (%10f) will pad output. Optional zero (%010f) width\\n\\\nwill zero pad the number. Optional negative values (%-10f) will left align.\\n\\\nOptional precision (%.1f) will override the input determined precision.\\n\\\n\"), stdout);\n\n      printf (_(\"\\n\\\nExit status is 0 if all input numbers were successfully converted.\\n\\\nBy default, %s will stop at the first conversion error with exit status 2.\\n\\\nWith --invalid='fail' a warning is printed for each conversion error\\n\\\nand the exit status is 2.  With --invalid='warn' each conversion error is\\n\\\ndiagnosed, but the exit status is 0.  With --invalid='ignore' conversion\\n\\\nerrors are not diagnosed and the exit status is 0.\\n\\\n\"), program_name);\n\n      printf (_(\"\\n\\\nExamples:\\n\\\n  $ %s --to=si 1000\\n\\\n            -> \\\"1.0K\\\"\\n\\\n  $ %s --to=iec 2048\\n\\\n           -> \\\"2.0K\\\"\\n\\\n  $ %s --to=iec-i 4096\\n\\\n           -> \\\"4.0Ki\\\"\\n\\\n  $ echo 1K | %s --from=si\\n\\\n           -> \\\"1000\\\"\\n\\\n  $ echo 1K | %s --from=iec\\n\\\n           -> \\\"1024\\\"\\n\\\n  $ df -B1 | %s --header --field 2-4 --to=si\\n\\\n  $ ls -l  | %s --header --field 5 --to=iec\\n\\\n  $ ls -lh | %s --header --field 5 --from=iec --padding=10\\n\\\n  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\\n\"),\n              program_name, program_name, program_name,\n              program_name, program_name, program_name,\n              program_name, program_name, program_name);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Given 'fmt' (a printf(3) compatible format string), extracts the following:\n    1. padding (e.g. %20f)\n    2. alignment (e.g. %-20f)\n    3. grouping (e.g. %'f)\n\n   Only a limited subset of printf(3) syntax is supported.\n\n   TODO:\n     support %e %g etc. rather than just %f\n\n   NOTES:\n   1. This function sets the global variables:\n       padding_width, padding_alignment, grouping,\n       format_str_prefix, format_str_suffix\n   2. The function aborts on any errors.  */\nstatic void\nparse_format_string (char const *fmt)\n{\n  size_t i;\n  size_t prefix_len = 0;\n  size_t suffix_pos;\n  long int pad = 0;\n  char *endptr = nullptr;\n  bool zero_padding = false;\n\n  for (i = 0; !(fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)\n    {\n      if (!fmt[i])\n        error (EXIT_FAILURE, 0,\n               _(\"format %s has no %% directive\"), quote (fmt));\n      prefix_len++;\n    }\n\n  i++;\n  while (true)\n    {\n      size_t skip = strspn (fmt + i, \" \");\n      i += skip;\n      if (fmt[i] == '\\'')\n        {\n          grouping = 1;\n          i++;\n        }\n      else if (fmt[i] == '0')\n        {\n          zero_padding = true;\n          i++;\n        }\n      else if (! skip)\n        break;\n    }\n\n  errno = 0;\n  pad = strtol (fmt + i, &endptr, 10);\n  if (errno == ERANGE || pad < -LONG_MAX)\n    error (EXIT_FAILURE, 0,\n           _(\"invalid format %s (width overflow)\"), quote (fmt));\n\n  if (endptr != (fmt + i) && pad != 0)\n    {\n      if (debug && padding_width && !(zero_padding && pad > 0))\n        error (0, 0, _(\"--format padding overriding --padding\"));\n\n      if (pad < 0)\n        {\n          padding_alignment = MBS_ALIGN_LEFT;\n          padding_width = -pad;\n        }\n      else\n        {\n          if (zero_padding)\n            zero_padding_width = pad;\n          else\n            padding_width = pad;\n        }\n\n    }\n  i = endptr - fmt;\n\n  if (fmt[i] == '\\0')\n    error (EXIT_FAILURE, 0, _(\"format %s ends in %%\"), quote (fmt));\n\n  if (fmt[i] == '.')\n    {\n      i++;\n      errno = 0;\n      user_precision = strtol (fmt + i, &endptr, 10);\n      if (errno == ERANGE || user_precision < 0 || SIZE_MAX < user_precision\n          || isblank (fmt[i]) || fmt[i] == '+')\n        {\n          /* Note we disallow negative user_precision to be\n             consistent with printf(1).  POSIX states that\n             negative precision is only supported (and ignored)\n             when used with '.*f'.  glibc at least will malform\n             output when passed a direct negative precision.  */\n          error (EXIT_FAILURE, 0,\n                 _(\"invalid precision in format %s\"), quote (fmt));\n        }\n      i = endptr - fmt;\n    }\n\n  if (fmt[i] != 'f')\n    error (EXIT_FAILURE, 0, _(\"invalid format %s,\"\n                              \" directive must be %%[0]['][-][N][.][N]f\"),\n         quote (fmt));\n  i++;\n  suffix_pos = i;\n\n  for (; fmt[i] != '\\0'; i += (fmt[i] == '%') + 1)\n    if (fmt[i] == '%' && fmt[i + 1] != '%')\n      error (EXIT_FAILURE, 0, _(\"format %s has too many %% directives\"),\n             quote (fmt));\n\n  if (prefix_len)\n    format_str_prefix = ximemdup0 (fmt, prefix_len);\n  if (fmt[suffix_pos] != '\\0')\n    format_str_suffix = xstrdup (fmt + suffix_pos);\n\n  devmsg (\"format String:\\n  input: %s\\n  grouping: %s\\n\"\n                   \"  padding width: %ld\\n  alignment: %s\\n\"\n                   \"  prefix: %s\\n  suffix: %s\\n\",\n          quote_n (0, fmt), (grouping) ? \"yes\" : \"no\",\n          padding_width,\n          (padding_alignment == MBS_ALIGN_LEFT) ? \"Left\" : \"Right\",\n          quote_n (1, format_str_prefix ? format_str_prefix : \"\"),\n          quote_n (2, format_str_suffix ? format_str_suffix : \"\"));\n}\n\n/* Parse a numeric value (with optional suffix) from a string.\n   Returns a long double value, with input precision.\n\n   If there's an error converting the string to value - exits with\n   an error.\n\n   If there are any trailing characters after the number\n   (besides a valid suffix) - exits with an error.  */\nstatic enum simple_strtod_error\nparse_human_number (char const *str, long double   *value,\n                    size_t *precision)\n{\n  char *ptr = nullptr;\n\n  enum simple_strtod_error e =\n    simple_strtod_human (str, &ptr, value, precision, scale_from);\n  if (e != SSE_OK && e != SSE_OK_PRECISION_LOSS)\n    {\n      simple_strtod_fatal (e, str);\n      return e;\n    }\n\n  if (ptr && *ptr != '\\0')\n    {\n      if (inval_style != inval_ignore)\n        error (conv_exit_code, 0, _(\"invalid suffix in input %s: %s\"),\n               quote_n (0, str), quote_n (1, ptr));\n      e = SSE_INVALID_SUFFIX;\n    }\n  return e;\n}\n\n\n \nstatic int\nprepare_padded_number (const long double val, size_t precision)\n{\n   \n  char buf[128];\n\n  size_t precision_used = user_precision == -1 ? precision : user_precision;\n\n   \n  int x;\n  expld (val, 10, &x);\n\n  if (scale_to == scale_none\n      && x + precision_used > MAX_UNSCALED_DIGITS)\n    {\n      if (inval_style != inval_ignore)\n        {\n          if (precision_used)\n            error (conv_exit_code, 0,\n                   _(\"value/precision too large to be printed: '%Lg/%\"PRIuMAX\"'\"\n                     \" (consider using --to)\"), val, (uintmax_t)precision_used);\n          else\n            error (conv_exit_code, 0,\n                   _(\"value too large to be printed: '%Lg'\"\n                     \" (consider using --to)\"), val);\n        }\n      return 0;\n    }\n\n  if (x > MAX_ACCEPTABLE_DIGITS - 1)\n    {\n      if (inval_style != inval_ignore)\n        error (conv_exit_code, 0, _(\"value too large to be printed: '%Lg'\"\n                                    \" (cannot handle values > 999Q)\"), val);\n      return 0;\n    }\n\n  double_to_human (val, precision_used, buf, sizeof (buf),\n                   scale_to, grouping, round_style);\n  if (suffix)\n    strncat (buf, suffix, sizeof (buf) - strlen (buf) -1);\n\n  devmsg (\"formatting output:\\n  value: %Lf\\n  humanized: %s\\n\",\n          val, quote (buf));\n\n  if (padding_width && strlen (buf) < padding_width)\n    {\n      size_t w = padding_width;\n      mbsalign (buf, padding_buffer, padding_buffer_size, &w,\n                padding_alignment, MBA_UNIBYTE_ONLY);\n\n      devmsg (\"  After padding: %s\\n\", quote (padding_buffer));\n    }\n  else\n    {\n      setup_padding_buffer (strlen (buf) + 1);\n      strcpy (padding_buffer, buf);\n    }\n\n  return 1;\n}\n\nstatic void\nprint_padded_number (void)\n{\n  if (format_str_prefix)\n    fputs (format_str_prefix, stdout);\n\n  fputs (padding_buffer, stdout);\n\n  if (format_str_suffix)\n    fputs (format_str_suffix, stdout);\n}\n\n \nstatic int\nprocess_suffixed_number (char *text, long double *result,\n                         size_t *precision, long int field)\n{\n  if (suffix && strlen (text) > strlen (suffix))\n    {\n      char *possible_suffix = text + strlen (text) - strlen (suffix);\n\n      if (STREQ (suffix, possible_suffix))\n        {\n           \n          *possible_suffix = '\\0';\n          devmsg (\"trimming suffix %s\\n\", quote (suffix));\n        }\n      else\n        devmsg (\"no valid suffix found\\n\");\n    }\n\n   \n  char *p = text;\n  while (*p && isblank (to_uchar (*p)))\n    ++p;\n\n   \n  if (auto_padding)\n    {\n      if (text < p || field > 1)\n        {\n          padding_width = strlen (text);\n          setup_padding_buffer (padding_width);\n        }\n      else\n        {\n          padding_width = 0;\n        }\n     devmsg (\"setting Auto-Padding to %ld characters\\n\", padding_width);\n    }\n\n  long double val = 0;\n  enum simple_strtod_error e = parse_human_number (p, &val, precision);\n  if (e == SSE_OK_PRECISION_LOSS && debug)\n    error (0, 0, _(\"large input value %s: possible precision loss\"),\n           quote (p));\n\n  if (from_unit_size != 1 || to_unit_size != 1)\n    val = (val * from_unit_size) / to_unit_size;\n\n  *result = val;\n\n  return (e == SSE_OK || e == SSE_OK_PRECISION_LOSS);\n}\n\n \nstatic char*\nnext_field (char **line)\n{\n  char *field_start = *line;\n  char *field_end   = field_start;\n\n  if (delimiter != DELIMITER_DEFAULT)\n    {\n      if (*field_start != delimiter)\n        {\n          while (*field_end && *field_end != delimiter)\n            ++field_end;\n        }\n       \n    }\n  else\n    {\n       \n      while (*field_end && field_sep (*field_end))\n        ++field_end;\n\n      while (*field_end && ! field_sep (*field_end))\n        ++field_end;\n    }\n\n  *line = field_end;\n  return field_start;\n}\n\nATTRIBUTE_PURE\nstatic bool\ninclude_field (uintmax_t field)\n{\n  struct field_range_pair *p = frp;\n  if (!p)\n    return field == 1;\n\n  while (p->lo != UINTMAX_MAX)\n    {\n      if (p->lo <= field && p->hi >= field)\n        return true;\n      ++p;\n    }\n  return false;\n}\n\n \nstatic bool\nprocess_field (char *text, uintmax_t field)\n{\n  long double val = 0;\n  size_t precision = 0;\n  bool valid_number = true;\n\n  if (include_field (field))\n    {\n      valid_number =\n        process_suffixed_number (text, &val, &precision, field);\n\n      if (valid_number)\n        valid_number = prepare_padded_number (val, precision);\n\n      if (valid_number)\n        print_padded_number ();\n      else\n        fputs (text, stdout);\n    }\n  else\n    fputs (text, stdout);\n\n  return valid_number;\n}\n\n \nstatic int\nprocess_line (char *line, bool newline)\n{\n  char *next;\n  uintmax_t field = 0;\n  bool valid_number = true;\n\n  while (true) {\n    ++field;\n    next = next_field (&line);\n\n    if (*line != '\\0')\n      {\n         \n        *line = '\\0';\n\n        if (! process_field (next, field))\n          valid_number = false;\n\n        fputc ((delimiter == DELIMITER_DEFAULT) ?\n               ' ' : delimiter, stdout);\n        ++line;\n      }\n    else\n      {\n         \n        if (! process_field (next, field))\n          valid_number = false;\n\n        break;\n      }\n  }\n\n  if (newline)\n    putchar (line_delim);\n\n  return valid_number;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int valid_numbers = 1;\n  bool locale_ok;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  locale_ok = !!setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n#if HAVE_FPSETPREC\n   \n  fpsetprec (FP_PE);\n#endif\n\n  decimal_point = nl_langinfo (RADIXCHAR);\n  if (decimal_point == nullptr || strlen (decimal_point) == 0)\n    decimal_point = \".\";\n  decimal_point_length = strlen (decimal_point);\n\n  atexit (close_stdout);\n\n  while (true)\n    {\n      int c = getopt_long (argc, argv, \"d:z\", longopts, nullptr);\n\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case FROM_OPTION:\n          scale_from = XARGMATCH (\"--from\", optarg,\n                                  scale_from_args, scale_from_types);\n          break;\n\n        case FROM_UNIT_OPTION:\n          from_unit_size = unit_to_umax (optarg);\n          break;\n\n        case TO_OPTION:\n          scale_to =\n            XARGMATCH (\"--to\", optarg, scale_to_args, scale_to_types);\n          break;\n\n        case TO_UNIT_OPTION:\n          to_unit_size = unit_to_umax (optarg);\n          break;\n\n        case ROUND_OPTION:\n          round_style = XARGMATCH (\"--round\", optarg, round_args, round_types);\n          break;\n\n        case GROUPING_OPTION:\n          grouping = 1;\n          break;\n\n        case PADDING_OPTION:\n          if (xstrtol (optarg, nullptr, 10, &padding_width, \"\") != LONGINT_OK\n              || padding_width == 0 || padding_width < -LONG_MAX)\n            error (EXIT_FAILURE, 0, _(\"invalid padding value %s\"),\n                   quote (optarg));\n          if (padding_width < 0)\n            {\n              padding_alignment = MBS_ALIGN_LEFT;\n              padding_width = -padding_width;\n            }\n           \n          break;\n\n        case FIELD_OPTION:\n          if (n_frp)\n            error (EXIT_FAILURE, 0, _(\"multiple field specifications\"));\n          set_fields (optarg, SETFLD_ALLOW_DASH);\n          break;\n\n        case 'd':\n           \n          if (optarg[0] != '\\0' && optarg[1] != '\\0')\n            error (EXIT_FAILURE, 0,\n                   _(\"the delimiter must be a single character\"));\n          delimiter = optarg[0];\n          break;\n\n        case 'z':\n          line_delim = '\\0';\n          break;\n\n        case SUFFIX_OPTION:\n          suffix = optarg;\n          break;\n\n        case DEBUG_OPTION:\n          debug = true;\n          break;\n\n        case DEV_DEBUG_OPTION:\n          dev_debug = true;\n          debug = true;\n          break;\n\n        case HEADER_OPTION:\n          if (optarg)\n            {\n              if (xstrtoumax (optarg, nullptr, 10, &header, \"\") != LONGINT_OK\n                  || header == 0)\n                error (EXIT_FAILURE, 0, _(\"invalid header value %s\"),\n                       quote (optarg));\n            }\n          else\n            {\n              header = 1;\n            }\n          break;\n\n        case FORMAT_OPTION:\n          format_str = optarg;\n          break;\n\n        case INVALID_OPTION:\n          inval_style = XARGMATCH (\"--invalid\", optarg,\n                                   inval_args, inval_types);\n          break;\n\n          case_GETOPT_HELP_CHAR;\n          case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (format_str != nullptr && grouping)\n    error (EXIT_FAILURE, 0, _(\"--grouping cannot be combined with --format\"));\n\n  if (debug && ! locale_ok)\n    error (0, 0, _(\"failed to set locale\"));\n\n   \n  if (debug && scale_from == scale_none && scale_to == scale_none\n      && !grouping && (padding_width == 0) && (format_str == nullptr))\n    error (0, 0, _(\"no conversion option specified\"));\n\n  if (format_str)\n    parse_format_string (format_str);\n\n  if (grouping)\n    {\n      if (scale_to != scale_none)\n        error (EXIT_FAILURE, 0, _(\"grouping cannot be combined with --to\"));\n      if (debug && (strlen (nl_langinfo (THOUSEP)) == 0))\n        error (0, 0, _(\"grouping has no effect in this locale\"));\n    }\n\n\n  setup_padding_buffer (padding_width);\n  auto_padding = (padding_width == 0 && delimiter == DELIMITER_DEFAULT);\n\n  if (inval_style != inval_abort)\n    conv_exit_code = 0;\n\n  if (argc > optind)\n    {\n      if (debug && header)\n        error (0, 0, _(\"--header ignored with command-line input\"));\n\n      for (; optind < argc; optind++)\n        valid_numbers &= process_line (argv[optind], true);\n    }\n  else\n    {\n      char *line = nullptr;\n      size_t line_allocated = 0;\n      ssize_t len;\n\n      while (header-- && getdelim (&line, &line_allocated,\n                                   line_delim, stdin) > 0)\n        fputs (line, stdout);\n\n      while ((len = getdelim (&line, &line_allocated,\n                              line_delim, stdin)) > 0)\n        {\n          bool newline = line[len - 1] == line_delim;\n          if (newline)\n            line[len - 1] = '\\0';\n          valid_numbers &= process_line (line, newline);\n        }\n\n      if (ferror (stdin))\n        error (EXIT_FAILURE, errno, _(\"error reading input\"));\n    }\n\n  if (debug && !valid_numbers)\n    error (0, 0, _(\"failed to convert some of the input numbers\"));\n\n  int exit_status = EXIT_SUCCESS;\n  if (!valid_numbers\n      && inval_style != inval_warn && inval_style != inval_ignore)\n    exit_status = EXIT_CONVERSION_WARNINGS;\n\n  main_exit (exit_status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}