{
  "module_name": "expand.c",
  "hash_id": "9b3b0f691cb4849b54aaba7a89c021b110303016bfe249607e3b3a6937d6c0dd",
  "original_prompt": "Ingested from coreutils-9.4/src/expand.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"expand-common.h\"\n\n \n#define PROGRAM_NAME \"expand\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic char const shortopts[] = \"it:0::1::2::3::4::5::6::7::8::9::\";\n\nstatic struct option const longopts[] =\n{\n  {\"tabs\", required_argument, nullptr, 't'},\n  {\"initial\", no_argument, nullptr, 'i'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nConvert tabs in each FILE to spaces, writing to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -i, --initial    do not convert tabs after non blanks\\n\\\n  -t, --tabs=N     have tabs N characters apart, not 8\\n\\\n\"), stdout);\n      emit_tab_list_info ();\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n\n/* Change tabs to spaces, writing to stdout.\n   Read each file in 'file_list', in order.  */\n\nstatic void\nexpand (void)\n{\n  /* Input stream.  */\n  FILE *fp = next_file (nullptr);\n\n  if (!fp)\n    return;\n\n  while (true)\n    {\n      /* Input character, or EOF.  */\n      int c;\n\n      /* If true, perform translations.  */\n      bool convert = true;\n\n\n      /* The following variables have valid values only when CONVERT\n         is true:  */\n\n      /* Column of next input character.  */\n      uintmax_t column = 0;\n\n      /* Index in TAB_LIST of next tab stop to examine.  */\n      size_t tab_index = 0;\n\n\n      /* Convert a line of text.  */\n\n      do\n        {\n          while ((c = getc (fp)) < 0 && (fp = next_file (fp)))\n            continue;\n\n          if (convert)\n            {\n              if (c == '\\t')\n                {\n                  /* Column the next input tab stop is on.  */\n                  uintmax_t next_tab_column;\n                  bool last_tab;\n\n                  next_tab_column = get_next_tab_column (column, &tab_index,\n                                                         &last_tab);\n\n                  if (last_tab)\n                    next_tab_column = column + 1;\n\n                  if (next_tab_column < column)\n                    error (EXIT_FAILURE, 0, _(\"input line is too long\"));\n\n                  while (++column < next_tab_column)\n                    if (putchar (' ') < 0)\n                      write_error ();\n\n                  c = ' ';\n                }\n              else if (c == '\\b')\n                {\n                  /* Go back one column, and force recalculation of the\n                     next tab stop.  */\n                  column -= !!column;\n                  tab_index -= !!tab_index;\n                }\n              else\n                {\n                  column++;\n                  if (!column)\n                    error (EXIT_FAILURE, 0, _(\"input line is too long\"));\n                }\n\n              convert &= convert_entire_line || !! isblank (c);\n            }\n\n          if (c < 0)\n            return;\n\n          if (putchar (c) < 0)\n            write_error ();\n        }\n      while (c != '\\n');\n    }\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n  convert_entire_line = true;\n\n  while ((c = getopt_long (argc, argv, shortopts, longopts, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'i':\n          convert_entire_line = false;\n          break;\n\n        case 't':\n          parse_tab_stops (optarg);\n          break;\n\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n          if (optarg)\n            parse_tab_stops (optarg - 1);\n          else\n            {\n              char tab_stop[2];\n              tab_stop[0] = c;\n              tab_stop[1] = '\\0';\n              parse_tab_stops (tab_stop);\n            }\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  finalize_tab_stops ();\n\n  set_file_list (optind < argc ? &argv[optind] : nullptr);\n\n  expand ();\n\n  cleanup_file_list_stdin ();\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}