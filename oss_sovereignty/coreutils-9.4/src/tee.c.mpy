{
  "module_name": "tee.c",
  "hash_id": "68c24f1179d41f2156b521351899cc4300f9739ddbebac6b5aaa18185b7fba40",
  "original_prompt": "Ingested from coreutils-9.4/src/tee.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <getopt.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"fadvise.h\"\n#include \"iopoll.h\"\n#include \"stdio--.h\"\n#include \"xbinary-io.h\"\n#include \"iopoll.h\"\n\n \n#define PROGRAM_NAME \"tee\"\n\n#define AUTHORS \\\n  proper_name (\"Mike Parker\"), \\\n  proper_name (\"Richard M. Stallman\"), \\\n  proper_name (\"David MacKenzie\")\n\nstatic bool tee_files (int nfiles, char **files, bool);\n\n \nstatic bool append;\n\n \nstatic bool ignore_interrupts;\n\nenum output_error\n  {\n    output_error_sigpipe,       \n    output_error_warn,          \n    output_error_warn_nopipe,   \n    output_error_exit,          \n    output_error_exit_nopipe    \n  };\n\nstatic enum output_error output_error;\n\nstatic struct option const long_options[] =\n{\n  {\"append\", no_argument, nullptr, 'a'},\n  {\"ignore-interrupts\", no_argument, nullptr, 'i'},\n  {\"output-error\", optional_argument, nullptr, 'p'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nstatic char const *const output_error_args[] =\n{\n  \"warn\", \"warn-nopipe\", \"exit\", \"exit-nopipe\", nullptr\n};\nstatic enum output_error const output_error_types[] =\n{\n  output_error_warn, output_error_warn_nopipe,\n  output_error_exit, output_error_exit_nopipe\n};\nARGMATCH_VERIFY (output_error_args, output_error_types);\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [FILE]...\\n\"), program_name);\n      fputs (_(\"\\\nCopy standard input to each FILE, and also to standard output.\\n\\\n\\n\\\n  -a, --append              append to the given FILEs, do not overwrite\\n\\\n  -i, --ignore-interrupts   ignore interrupt signals\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -p                        operate in a more appropriate MODE with pipes.\\n\\\n      --output-error[=MODE]   set behavior on write error.  See MODE below\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nMODE determines behavior with write errors on the outputs:\\n\\\n  warn           diagnose errors writing to any output\\n\\\n  warn-nopipe    diagnose errors writing to any output not a pipe\\n\\\n  exit           exit on error writing to any output\\n\\\n  exit-nopipe    exit on error writing to any output not a pipe\\n\\\nThe default MODE for the -p option is 'warn-nopipe'.\\n\\\nWith \\\"nopipe\\\" MODEs, exit immediately if all outputs become broken pipes.\\n\\\nThe default operation when --output-error is not specified, is to\\n\\\nexit immediately on error writing to a pipe, and diagnose errors\\n\\\nwriting to non pipe outputs.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  append = false;\n  ignore_interrupts = false;\n\n  int optc;\n  while ((optc = getopt_long (argc, argv, \"aip\", long_options, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'a':\n          append = true;\n          break;\n\n        case 'i':\n          ignore_interrupts = true;\n          break;\n\n        case 'p':\n          if (optarg)\n            output_error = XARGMATCH (\"--output-error\", optarg,\n                                      output_error_args, output_error_types);\n          else\n            output_error = output_error_warn_nopipe;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (ignore_interrupts)\n    signal (SIGINT, SIG_IGN);\n\n  if (output_error != output_error_sigpipe)\n    signal (SIGPIPE, SIG_IGN);\n\n  /* Whether to detect and close a broken pipe output.\n     There is no need if the input is always ready for reading.  */\n  bool pipe_check = ((output_error == output_error_warn_nopipe\n                      || output_error == output_error_exit_nopipe)\n                     && iopoll_input_ok (STDIN_FILENO));\n\n  /* Do *not* warn if tee is given no file arguments.\n     POSIX requires that it work when given no arguments.  */\n\n  bool ok = tee_files (argc - optind, &argv[optind], pipe_check);\n  if (close (STDIN_FILENO) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", _(\"standard input\"));\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n\n/* Return the index of the first non-null descriptor after idx,\n   or -1 if all are null.  */\n\nstatic int\nget_next_out (FILE **descriptors, int nfiles, int idx)\n{\n  for (idx++; idx <= nfiles; idx++)\n    if (descriptors[idx])\n      return idx;\n  return -1;  /* no outputs remaining */\n}\n\n/* Remove descriptors[i] due to write failure or broken pipe.\n   Return true if this indicates a reportable error.  */\n\nstatic bool\nfail_output (FILE **descriptors, char **files, int i)\n{\n  int w_errno = errno;\n  bool fail = errno != EPIPE\n              || output_error == output_error_exit\n              || output_error == output_error_warn;\n  if (descriptors[i] == stdout)\n    clearerr (stdout); /* Avoid redundant close_stdout diagnostic.  */\n  if (fail)\n    {\n      error (output_error == output_error_exit\n             || output_error == output_error_exit_nopipe,\n             w_errno, \"%s\", quotef (files[i]));\n    }\n  descriptors[i] = nullptr;\n  return fail;\n}\n\n\n/* Copy the standard input into each of the NFILES files in FILES\n   and into the standard output.  As a side effect, modify FILES[-1].\n   Return true if successful.  */\n\nstatic bool\ntee_files (int nfiles, char **files, bool pipe_check)\n{\n  size_t n_outputs = 0;\n  FILE **descriptors;\n  bool *out_pollable IF_LINT ( = nullptr);\n  char buffer[BUFSIZ];\n  ssize_t bytes_read = 0;\n  int i;\n  int first_out = 0;  /* idx of first non-null output in descriptors */\n  bool ok = true;\n  char const *mode_string =\n    (O_BINARY\n     ? (append ? \"ab\" : \"wb\")\n     : (append ? \"a\" : \"w\"));\n\n  xset_binary_mode (STDIN_FILENO, O_BINARY);\n  xset_binary_mode (STDOUT_FILENO, O_BINARY);\n  fadvise (stdin, FADVISE_SEQUENTIAL);\n\n  /* Set up FILES[0 .. NFILES] and DESCRIPTORS[0 .. NFILES].\n     In both arrays, entry 0 corresponds to standard output.  */\n\n  descriptors = xnmalloc (nfiles + 1, sizeof *descriptors);\n  if (pipe_check)\n    out_pollable = xnmalloc (nfiles + 1, sizeof *out_pollable);\n  files--;\n  descriptors[0] = stdout;\n  if (pipe_check)\n    out_pollable[0] = iopoll_output_ok (fileno (descriptors[0]));\n  files[0] = bad_cast (_(\"standard output\"));\n  setvbuf (stdout, nullptr, _IONBF, 0);\n  n_outputs++;\n\n  for (i = 1; i <= nfiles; i++)\n    {\n      /* Do not treat \"-\" specially - as mandated by POSIX.  */\n       descriptors[i] = fopen (files[i], mode_string);\n      if (descriptors[i] == nullptr)\n        {\n          if (pipe_check)\n            out_pollable[i] = false;\n          error (output_error == output_error_exit\n                 || output_error == output_error_exit_nopipe,\n                 errno, \"%s\", quotef (files[i]));\n          ok = false;\n        }\n      else\n        {\n          if (pipe_check)\n            out_pollable[i] = iopoll_output_ok (fileno (descriptors[i]));\n          setvbuf (descriptors[i], nullptr, _IONBF, 0);\n          n_outputs++;\n        }\n    }\n\n  while (n_outputs)\n    {\n      if (pipe_check && out_pollable[first_out])\n        {\n          /* Monitor for input, or errors on first valid output.  */\n          int err = iopoll (STDIN_FILENO, fileno (descriptors[first_out]),\n                            true);\n\n          /* Close the output if it became a broken pipe.  */\n          if (err == IOPOLL_BROKEN_OUTPUT)\n            {\n              errno = EPIPE;  /* behave like write produced EPIPE */\n              if (fail_output (descriptors, files, first_out))\n                ok = false;\n              n_outputs--;\n              first_out = get_next_out (descriptors, nfiles, first_out);\n              continue;\n            }\n          else if (err == IOPOLL_ERROR)\n            {\n              error (0, errno, _(\"iopoll error\"));\n              ok = false;\n            }\n        }\n\n      bytes_read = read (STDIN_FILENO, buffer, sizeof buffer);\n      if (bytes_read < 0 && errno == EINTR)\n        continue;\n      if (bytes_read <= 0)\n        break;\n\n      /* Write to all NFILES + 1 descriptors.\n         Standard output is the first one.  */\n      for (i = 0; i <= nfiles; i++)\n        if (descriptors[i]\n            && ! fwrite_wait (buffer, bytes_read, descriptors[i]))\n          {\n            if (fail_output (descriptors, files, i))\n              ok = false;\n            n_outputs--;\n            if (i == first_out)\n              first_out = get_next_out (descriptors, nfiles, first_out);\n          }\n    }\n\n  if (bytes_read == -1)\n    {\n      error (0, errno, _(\"read error\"));\n      ok = false;\n    }\n\n  /* Close the files, but not standard output.  */\n  for (i = 1; i <= nfiles; i++)\n    if (descriptors[i] && ! fclose_wait (descriptors[i]))\n      {\n        error (0, errno, \"%s\", quotef (files[i]));\n        ok = false;\n      }\n\n  free (descriptors);\n  if (pipe_check)\n    free (out_pollable);\n\n  return ok;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}