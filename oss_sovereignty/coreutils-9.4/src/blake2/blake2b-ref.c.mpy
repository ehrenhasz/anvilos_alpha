{
  "module_name": "blake2b-ref.c",
  "hash_id": "ac9fa1e84ee6367d15541bc23da55b2641aa15e2002ad8bab5bb101b4aa7a8d7",
  "original_prompt": "Ingested from coreutils-9.4/src/blake2/blake2b-ref.c",
  "human_readable_source": " \n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"blake2.h\"\n#include \"blake2-impl.h\"\n\nstatic const uint64_t blake2b_IV[8] =\n{\n  0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,\n  0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,\n  0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,\n  0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL\n};\n\nstatic const uint8_t blake2b_sigma[12][16] =\n{\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 } ,\n  { 11,  8, 12,  0,  5,  2, 15, 13, 10, 14,  3,  6,  7,  1,  9,  4 } ,\n  {  7,  9,  3,  1, 13, 12, 11, 14,  2,  6,  5, 10,  4,  0, 15,  8 } ,\n  {  9,  0,  5,  7,  2,  4, 10, 15, 14,  1, 11, 12,  6,  8,  3, 13 } ,\n  {  2, 12,  6, 10,  0, 11,  8,  3,  4, 13,  7,  5, 15, 14,  1,  9 } ,\n  { 12,  5,  1, 15, 14, 13,  4, 10,  0,  7,  6,  3,  9,  2,  8, 11 } ,\n  { 13, 11,  7, 14, 12,  1,  3,  9,  5,  0, 15,  4,  8,  6,  2, 10 } ,\n  {  6, 15, 14,  9, 11,  3,  0,  8, 12,  2, 13,  7,  1,  4, 10,  5 } ,\n  { 10,  2,  8,  4,  7,  6,  1,  5, 15, 11,  9, 14,  3, 12, 13 , 0 } ,\n  {  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 } ,\n  { 14, 10,  4,  8,  9, 15, 13,  6,  1, 12,  0,  2, 11,  7,  5,  3 }\n};\n\n\nstatic void blake2b_set_lastnode( blake2b_state *S )\n{\n  S->f[1] = (uint64_t)-1;\n}\n\n \nstatic int blake2b_is_lastblock( const blake2b_state *S )\n{\n  return S->f[0] != 0;\n}\n\nstatic void blake2b_set_lastblock( blake2b_state *S )\n{\n  if( S->last_node ) blake2b_set_lastnode( S );\n\n  S->f[0] = (uint64_t)-1;\n}\n\nstatic void blake2b_increment_counter( blake2b_state *S, const uint64_t inc )\n{\n  S->t[0] += inc;\n  S->t[1] += ( S->t[0] < inc );\n}\n\nstatic void blake2b_init0( blake2b_state *S )\n{\n  size_t i;\n  memset( S, 0, sizeof( blake2b_state ) );\n\n  for( i = 0; i < 8; ++i ) S->h[i] = blake2b_IV[i];\n}\n\n \nint blake2b_init_param( blake2b_state *S, const blake2b_param *P )\n{\n  const uint8_t *p = ( const uint8_t * )( P );\n  size_t i;\n\n  blake2b_init0( S );\n\n   \n  for( i = 0; i < 8; ++i )\n    S->h[i] ^= load64( p + sizeof( S->h[i] ) * i );\n\n  S->outlen = P->digest_length;\n  return 0;\n}\n\n\n\nint blake2b_init( blake2b_state *S, size_t outlen )\n{\n  blake2b_param P[1];\n\n  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n\n  P->digest_length = (uint8_t)outlen;\n  P->key_length    = 0;\n  P->fanout        = 1;\n  P->depth         = 1;\n  store32( &P->leaf_length, 0 );\n  store32( &P->node_offset, 0 );\n  store32( &P->xof_length, 0 );\n  P->node_depth    = 0;\n  P->inner_length  = 0;\n  memset( P->reserved, 0, sizeof( P->reserved ) );\n  memset( P->salt,     0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n  return blake2b_init_param( S, P );\n}\n\n\nint blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen )\n{\n  blake2b_param P[1];\n\n  if ( ( !outlen ) || ( outlen > BLAKE2B_OUTBYTES ) ) return -1;\n\n  if ( !key || !keylen || keylen > BLAKE2B_KEYBYTES ) return -1;\n\n  P->digest_length = (uint8_t)outlen;\n  P->key_length    = (uint8_t)keylen;\n  P->fanout        = 1;\n  P->depth         = 1;\n  store32( &P->leaf_length, 0 );\n  store32( &P->node_offset, 0 );\n  store32( &P->xof_length, 0 );\n  P->node_depth    = 0;\n  P->inner_length  = 0;\n  memset( P->reserved, 0, sizeof( P->reserved ) );\n  memset( P->salt,     0, sizeof( P->salt ) );\n  memset( P->personal, 0, sizeof( P->personal ) );\n\n  if( blake2b_init_param( S, P ) < 0 ) return -1;\n\n  {\n    uint8_t block[BLAKE2B_BLOCKBYTES];\n    memset( block, 0, BLAKE2B_BLOCKBYTES );\n    memcpy( block, key, keylen );\n    blake2b_update( S, block, BLAKE2B_BLOCKBYTES );\n    secure_zero_memory( block, BLAKE2B_BLOCKBYTES );  \n  }\n  return 0;\n}\n\n#define G(r,i,a,b,c,d)                      \\\n  do {                                      \\\n    a = a + b + m[blake2b_sigma[r][2 * i + 0]]; \\\n    d = rotr64(d ^ a, 32);                  \\\n    c = c + d;                              \\\n    b = rotr64(b ^ c, 24);                  \\\n    a = a + b + m[blake2b_sigma[r][2 * i + 1]]; \\\n    d = rotr64(d ^ a, 16);                  \\\n    c = c + d;                              \\\n    b = rotr64(b ^ c, 63);                  \\\n  } while(0)\n\n#define ROUND(r)                    \\\n  do {                              \\\n    G(r,0,v[ 0],v[ 4],v[ 8],v[12]); \\\n    G(r,1,v[ 1],v[ 5],v[ 9],v[13]); \\\n    G(r,2,v[ 2],v[ 6],v[10],v[14]); \\\n    G(r,3,v[ 3],v[ 7],v[11],v[15]); \\\n    G(r,4,v[ 0],v[ 5],v[10],v[15]); \\\n    G(r,5,v[ 1],v[ 6],v[11],v[12]); \\\n    G(r,6,v[ 2],v[ 7],v[ 8],v[13]); \\\n    G(r,7,v[ 3],v[ 4],v[ 9],v[14]); \\\n  } while(0)\n\nstatic void blake2b_compress( blake2b_state *S, const uint8_t block[BLAKE2B_BLOCKBYTES] )\n{\n  uint64_t m[16];\n  uint64_t v[16];\n  size_t i;\n\n  for( i = 0; i < 16; ++i ) {\n    m[i] = load64( block + i * sizeof( m[i] ) );\n  }\n\n  for( i = 0; i < 8; ++i ) {\n    v[i] = S->h[i];\n  }\n\n  v[ 8] = blake2b_IV[0];\n  v[ 9] = blake2b_IV[1];\n  v[10] = blake2b_IV[2];\n  v[11] = blake2b_IV[3];\n  v[12] = blake2b_IV[4] ^ S->t[0];\n  v[13] = blake2b_IV[5] ^ S->t[1];\n  v[14] = blake2b_IV[6] ^ S->f[0];\n  v[15] = blake2b_IV[7] ^ S->f[1];\n\n  ROUND( 0 );\n  ROUND( 1 );\n  ROUND( 2 );\n  ROUND( 3 );\n  ROUND( 4 );\n  ROUND( 5 );\n  ROUND( 6 );\n  ROUND( 7 );\n  ROUND( 8 );\n  ROUND( 9 );\n  ROUND( 10 );\n  ROUND( 11 );\n\n  for( i = 0; i < 8; ++i ) {\n    S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];\n  }\n}\n\n#undef G\n#undef ROUND\n\nint blake2b_update( blake2b_state *S, const void *pin, size_t inlen )\n{\n  const unsigned char * in = (const unsigned char *)pin;\n  if( inlen > 0 )\n  {\n    size_t left = S->buflen;\n    size_t fill = BLAKE2B_BLOCKBYTES - left;\n    if( inlen > fill )\n    {\n      S->buflen = 0;\n      memcpy( S->buf + left, in, fill );  \n      blake2b_increment_counter( S, BLAKE2B_BLOCKBYTES );\n      blake2b_compress( S, S->buf );  \n      in += fill; inlen -= fill;\n      while(inlen > BLAKE2B_BLOCKBYTES) {\n        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n        blake2b_compress( S, in );\n        in += BLAKE2B_BLOCKBYTES;\n        inlen -= BLAKE2B_BLOCKBYTES;\n      }\n    }\n    memcpy( S->buf + S->buflen, in, inlen );\n    S->buflen += inlen;\n  }\n  return 0;\n}\n\nint blake2b_final( blake2b_state *S, void *out, size_t outlen )\n{\n  uint8_t buffer[BLAKE2B_OUTBYTES] = {0};\n  size_t i;\n\n  if( out == NULL || outlen < S->outlen )\n    return -1;\n\n  if( blake2b_is_lastblock( S ) )\n    return -1;\n\n  blake2b_increment_counter( S, S->buflen );\n  blake2b_set_lastblock( S );\n  memset( S->buf + S->buflen, 0, BLAKE2B_BLOCKBYTES - S->buflen );  \n  blake2b_compress( S, S->buf );\n\n  for( i = 0; i < 8; ++i )  \n    store64( buffer + sizeof( S->h[i] ) * i, S->h[i] );\n\n  memcpy( out, buffer, S->outlen );\n  secure_zero_memory(buffer, sizeof(buffer));\n  return 0;\n}\n\n \nint blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen )\n{\n  blake2b_state S[1];\n\n   \n  if ( NULL == in && inlen > 0 ) return -1;\n\n  if ( NULL == out ) return -1;\n\n  if( NULL == key && keylen > 0 ) return -1;\n\n  if( !outlen || outlen > BLAKE2B_OUTBYTES ) return -1;\n\n  if( keylen > BLAKE2B_KEYBYTES ) return -1;\n\n  if( keylen > 0 )\n  {\n    if( blake2b_init_key( S, outlen, key, keylen ) < 0 ) return -1;\n  }\n  else\n  {\n    if( blake2b_init( S, outlen ) < 0 ) return -1;\n  }\n\n  blake2b_update( S, ( const uint8_t * )in, inlen );\n  blake2b_final( S, out, outlen );\n  return 0;\n}\n\nint blake2( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen ) {\n  return blake2b(out, outlen, in, inlen, key, keylen);\n}\n\n#if defined(SUPERCOP)\nint crypto_hash( unsigned char *out, unsigned char *in, unsigned long long inlen )\n{\n  return blake2b( out, BLAKE2B_OUTBYTES, in, inlen, NULL, 0 );\n}\n#endif\n\n#if defined(BLAKE2B_SELFTEST)\n#include <string.h>\n#include \"blake2-kat.h\"\nint main( void )\n{\n  uint8_t key[BLAKE2B_KEYBYTES];\n  uint8_t buf[BLAKE2_KAT_LENGTH];\n  size_t i, step;\n\n  for( i = 0; i < BLAKE2B_KEYBYTES; ++i )\n    key[i] = ( uint8_t )i;\n\n  for( i = 0; i < BLAKE2_KAT_LENGTH; ++i )\n    buf[i] = ( uint8_t )i;\n\n   \n  for( i = 0; i < BLAKE2_KAT_LENGTH; ++i )\n  {\n    uint8_t hash[BLAKE2B_OUTBYTES];\n    blake2b( hash, BLAKE2B_OUTBYTES, buf, i, key, BLAKE2B_KEYBYTES );\n\n    if( 0 != memcmp( hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES ) )\n    {\n      goto fail;\n    }\n  }\n\n   \n  for(step = 1; step < BLAKE2B_BLOCKBYTES; ++step) {\n    for (i = 0; i < BLAKE2_KAT_LENGTH; ++i) {\n      uint8_t hash[BLAKE2B_OUTBYTES];\n      blake2b_state S;\n      uint8_t * p = buf;\n      size_t mlen = i;\n      int err = 0;\n\n      if( (err = blake2b_init_key(&S, BLAKE2B_OUTBYTES, key, BLAKE2B_KEYBYTES)) < 0 ) {\n        goto fail;\n      }\n\n      while (mlen >= step) {\n        if ( (err = blake2b_update(&S, p, step)) < 0 ) {\n          goto fail;\n        }\n        mlen -= step;\n        p += step;\n      }\n      if ( (err = blake2b_update(&S, p, mlen)) < 0) {\n        goto fail;\n      }\n      if ( (err = blake2b_final(&S, hash, BLAKE2B_OUTBYTES)) < 0) {\n        goto fail;\n      }\n\n      if (0 != memcmp(hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES)) {\n        goto fail;\n      }\n    }\n  }\n\n  puts( \"ok\" );\n  return 0;\nfail:\n  puts(\"error\");\n  return -1;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}