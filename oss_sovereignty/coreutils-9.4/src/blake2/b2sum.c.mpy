{
  "module_name": "b2sum.c",
  "hash_id": "5956163e6c288bda6d2e4f282e25c75c685949dffad652517d24a5b9e912599d",
  "original_prompt": "Ingested from coreutils-9.4/src/blake2/b2sum.c",
  "human_readable_source": " \n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include <ctype.h>\n#include <unistd.h>\n#include <getopt.h>\n\n#include \"blake2.h\"\n\n#if 0\n \nint blake2s_stream( FILE *stream, void *resstream, size_t outbytes )\n{\n  int ret = -1;\n  size_t sum, n;\n  blake2s_state S[1];\n  static const size_t buffer_length = 32768;\n  uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n\n  if( !buffer ) return -1;\n\n  blake2s_init( S, outbytes );\n\n  while( 1 )\n  {\n    sum = 0;\n\n    while( 1 )\n    {\n      n = fread( buffer + sum, 1, buffer_length - sum, stream );\n      sum += n;\n\n      if( buffer_length == sum )\n        break;\n\n      if( 0 == n )\n      {\n        if( ferror( stream ) )\n          goto cleanup_buffer;\n\n        goto final_process;\n      }\n\n      if( feof( stream ) )\n        goto final_process;\n    }\n\n    blake2s_update( S, buffer, buffer_length );\n  }\n\nfinal_process:;\n\n  if( sum > 0 ) blake2s_update( S, buffer, sum );\n\n  blake2s_final( S, resstream, outbytes );\n  ret = 0;\ncleanup_buffer:\n  free( buffer );\n  return ret;\n}\n#endif\n\nint blake2b_stream( FILE *stream, void *resstream, size_t outbytes )\n{\n  int ret = -1;\n  size_t sum, n;\n  blake2b_state S[1];\n  static const size_t buffer_length = 32768;\n  uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n\n  if( !buffer ) return -1;\n\n  blake2b_init( S, outbytes );\n\n  while( 1 )\n  {\n    sum = 0;\n\n    while( 1 )\n    {\n      n = fread( buffer + sum, 1, buffer_length - sum, stream );\n      sum += n;\n\n      if( buffer_length == sum )\n        break;\n\n      if( 0 == n )\n      {\n        if( ferror( stream ) )\n          goto cleanup_buffer;\n\n        goto final_process;\n      }\n\n      if( feof( stream ) )\n        goto final_process;\n    }\n\n    blake2b_update( S, buffer, buffer_length );\n  }\n\nfinal_process:;\n\n  if( sum > 0 ) blake2b_update( S, buffer, sum );\n\n  blake2b_final( S, resstream, outbytes );\n  ret = 0;\ncleanup_buffer:\n  free( buffer );\n  return ret;\n}\n\n#if 0\n\nint blake2sp_stream( FILE *stream, void *resstream, size_t outbytes )\n{\n  int ret = -1;\n  size_t sum, n;\n  blake2sp_state S[1];\n  static const size_t buffer_length = 16 * ( 1UL << 20 );\n  uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n\n  if( !buffer ) return -1;\n\n  blake2sp_init( S, outbytes );\n\n  while( 1 )\n  {\n    sum = 0;\n\n    while( 1 )\n    {\n      n = fread( buffer + sum, 1, buffer_length - sum, stream );\n      sum += n;\n\n      if( buffer_length == sum )\n        break;\n\n      if( 0 == n )\n      {\n        if( ferror( stream ) )\n          goto cleanup_buffer;\n\n        goto final_process;\n      }\n\n      if( feof( stream ) )\n        goto final_process;\n    }\n\n    blake2sp_update( S, buffer, buffer_length );\n  }\n\nfinal_process:;\n\n  if( sum > 0 ) blake2sp_update( S, buffer, sum );\n\n  blake2sp_final( S, resstream, outbytes );\n  ret = 0;\ncleanup_buffer:\n  free( buffer );\n  return ret;\n}\n\n\nint blake2bp_stream( FILE *stream, void *resstream, size_t outbytes )\n{\n  int ret = -1;\n  size_t sum, n;\n  blake2bp_state S[1];\n  static const size_t buffer_length = 16 * ( 1UL << 20 );\n  uint8_t *buffer = ( uint8_t * )malloc( buffer_length );\n\n  if( !buffer ) return -1;\n\n  blake2bp_init( S, outbytes );\n\n  while( 1 )\n  {\n    sum = 0;\n\n    while( 1 )\n    {\n      n = fread( buffer + sum, 1, buffer_length - sum, stream );\n      sum += n;\n\n      if( buffer_length == sum )\n        break;\n\n      if( 0 == n )\n      {\n        if( ferror( stream ) )\n          goto cleanup_buffer;\n\n        goto final_process;\n      }\n\n      if( feof( stream ) )\n        goto final_process;\n    }\n\n    blake2bp_update( S, buffer, buffer_length );\n  }\n\nfinal_process:;\n\n  if( sum > 0 ) blake2bp_update( S, buffer, sum );\n\n  blake2bp_final( S, resstream, outbytes );\n  ret = 0;\ncleanup_buffer:\n  free( buffer );\n  return ret;\n}\n\ntypedef int ( *blake2fn )( FILE *, void *, size_t );\n\n\nstatic void usage( char **argv, int errcode )\n{\n  FILE *out = errcode ? stderr : stdout;\n  fprintf( out, \"Usage: %s [OPTION]... [FILE]...\\n\", argv[0] );\n  fprintf( out, \"\\n\" );\n  fprintf( out, \"With no FILE, or when FILE is -, read standard input.\\n\" );\n  fprintf( out, \"\\n\" );\n  fprintf( out, \"  -a <algo>    hash algorithm (blake2b is default): \\n\"\n                \"               [blake2b|blake2s|blake2bp|blake2sp]\\n\" );\n  fprintf( out, \"  -l <length>  digest length in bits, must not exceed the maximum for\\n\"\n                \"               the selected algorithm and must be a multiple of 8\\n\" );\n  fprintf( out, \"  --tag        create a BSD-style checksum\\n\" );\n  fprintf( out, \"  --help       display this help and exit\\n\" );\n  exit( errcode );\n}\n\n\nint main( int argc, char **argv )\n{\n  blake2fn blake2_stream = blake2b_stream;\n  unsigned long maxbytes = BLAKE2B_OUTBYTES;\n  const char *algorithm = \"BLAKE2b\";\n  unsigned long outbytes = 0;\n  unsigned char hash[BLAKE2B_OUTBYTES] = {0};\n  bool bsdstyle = false;\n  int c, i;\n  opterr = 1;\n\n  while( 1 )\n  {\n    int option_index = 0;\n    char *end = nullptr;\n    unsigned long outbits;\n    static struct option long_options[] = {\n      { \"help\",  no_argument, 0,  0  },\n      { \"tag\",   no_argument, 0,  0  },\n      { nullptr, 0, nullptr, 0 }\n    };\n\n    c = getopt_long( argc, argv, \"a:l:\", long_options, &option_index );\n    if( c == -1 ) break;\n    switch( c )\n    {\n    case 'a':\n      if( 0 == strcmp( optarg, \"blake2b\" ) )\n      {\n        blake2_stream = blake2b_stream;\n        maxbytes = BLAKE2B_OUTBYTES;\n        algorithm = \"BLAKE2b\";\n      }\n      else if ( 0 == strcmp( optarg, \"blake2s\" ) )\n      {\n        blake2_stream = blake2s_stream;\n        maxbytes = BLAKE2S_OUTBYTES;\n        algorithm = \"BLAKE2s\";\n      }\n      else if ( 0 == strcmp( optarg, \"blake2bp\" ) )\n      {\n        blake2_stream = blake2bp_stream;\n        maxbytes = BLAKE2B_OUTBYTES;\n        algorithm = \"BLAKE2bp\";\n      }\n      else if ( 0 == strcmp( optarg, \"blake2sp\" ) )\n      {\n        blake2_stream = blake2sp_stream;\n        maxbytes = BLAKE2S_OUTBYTES;\n        algorithm = \"BLAKE2sp\";\n      }\n      else\n      {\n        printf( \"Invalid function name: `%s'\\n\", optarg );\n        usage( argv, 111 );\n      }\n\n      break;\n\n    case 'l':\n      outbits = strtoul(optarg, &end, 10);\n      if( !end || *end != '\\0' || outbits % 8 != 0)\n      {\n        printf( \"Invalid length argument: `%s'\\n\", optarg);\n        usage( argv, 111 );\n      }\n      outbytes = outbits / 8;\n      break;\n\n    case 0:\n      if( 0 == strcmp( \"help\", long_options[option_index].name ) )\n        usage( argv, 0 );\n      else if( 0 == strcmp( \"tag\", long_options[option_index].name ) )\n        bsdstyle = true;\n      break;\n\n    case '?':\n      usage( argv, 1 );\n      break;\n    }\n  }\n\n  if(outbytes > maxbytes)\n  {\n    printf( \"Invalid length argument: %lu\\n\", outbytes * 8 );\n    printf( \"Maximum digest length for %s is %lu\\n\", algorithm, maxbytes * 8 );\n    usage( argv, 111 );\n  }\n  else if( outbytes == 0 )\n    outbytes = maxbytes;\n\n  if( optind == argc )\n    argv[argc++] = (char *) \"-\";\n\n  for( i = optind; i < argc; ++i )\n  {\n    FILE *f = nullptr;\n    if( argv[i][0] == '-' && argv[i][1] == '\\0' )\n      f = stdin;\n    else\n      f = fopen( argv[i], \"rb\" );\n\n    if( !f )\n    {\n      fprintf( stderr, \"Could not open `%s': %s\\n\", argv[i], strerror( errno ) );\n      continue;\n    }\n\n    if( blake2_stream( f, hash, outbytes ) < 0 )\n    {\n      fprintf( stderr, \"Failed to hash `%s'\\n\", argv[i] );\n    }\n    else\n    {\n      size_t j;\n      if( bsdstyle )\n      {\n        if( outbytes < maxbytes )\n          printf( \"%s-%lu (%s) = \", algorithm, outbytes * 8, argv[i] );\n        else\n          printf( \"%s (%s) = \", algorithm, argv[i] );\n      }\n\n      for( j = 0; j < outbytes; ++j )\n        printf( \"%02x\", hash[j] );\n\n      if( bsdstyle )\n        printf( \"\\n\" );\n      else\n        printf( \"  %s\\n\", argv[i] );\n    }\n\n    if( f == stdin )\n      clearerr( f );\n    else if( fclose( f ) != 0 )\n      fprintf( stderr, \"Could not close `%s': %s\\n\", argv[i], strerror( errno ) );\n  }\n\n  return 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}