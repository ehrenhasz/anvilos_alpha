{
  "module_name": "blake2.h",
  "hash_id": "6710fa1df09d918b8bdb11e2b3fb93b64eae7ba11b92fc891ddf44f2b4defa9b",
  "original_prompt": "Ingested from coreutils-9.4/src/blake2/blake2.h",
  "human_readable_source": " \n#ifndef BLAKE2_H\n#define BLAKE2_H\n\n#include <stddef.h>\n#include <stdint.h>\n\n \n#ifdef _MSC_VER\n# define BLAKE2_PACKED(x) __pragma (pack (push, 1)) x __pragma (pack (pop))\n#else\n# define BLAKE2_PACKED(x) x _GL_ATTRIBUTE_PACKED\n#endif\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n  enum blake2s_constant\n  {\n    BLAKE2S_BLOCKBYTES = 64,\n    BLAKE2S_OUTBYTES   = 32,\n    BLAKE2S_KEYBYTES   = 32,\n    BLAKE2S_SALTBYTES  = 8,\n    BLAKE2S_PERSONALBYTES = 8\n  };\n\n  enum blake2b_constant\n  {\n    BLAKE2B_BLOCKBYTES = 128,\n    BLAKE2B_OUTBYTES   = 64,\n    BLAKE2B_KEYBYTES   = 64,\n    BLAKE2B_SALTBYTES  = 16,\n    BLAKE2B_PERSONALBYTES = 16\n  };\n\n  typedef struct blake2s_state__\n  {\n    uint32_t h[8];\n    uint32_t t[2];\n    uint32_t f[2];\n    uint8_t  buf[BLAKE2S_BLOCKBYTES];\n    size_t   buflen;\n    size_t   outlen;\n    uint8_t  last_node;\n  } blake2s_state;\n\n  typedef struct blake2b_state__\n  {\n    uint64_t h[8];\n    uint64_t t[2];\n    uint64_t f[2];\n    uint8_t  buf[BLAKE2B_BLOCKBYTES];\n    size_t   buflen;\n    size_t   outlen;\n    uint8_t  last_node;\n  } blake2b_state;\n\n  typedef struct blake2sp_state__\n  {\n    blake2s_state S[8][1];\n    blake2s_state R[1];\n    uint8_t       buf[8 * BLAKE2S_BLOCKBYTES];\n    size_t        buflen;\n    size_t        outlen;\n  } blake2sp_state;\n\n  typedef struct blake2bp_state__\n  {\n    blake2b_state S[4][1];\n    blake2b_state R[1];\n    uint8_t       buf[4 * BLAKE2B_BLOCKBYTES];\n    size_t        buflen;\n    size_t        outlen;\n  } blake2bp_state;\n\n\n  BLAKE2_PACKED(struct blake2s_param__\n  {\n    uint8_t  digest_length;  \n    uint8_t  key_length;     \n    uint8_t  fanout;         \n    uint8_t  depth;          \n    uint32_t leaf_length;    \n    uint32_t node_offset;   \n    uint16_t xof_length;     \n    uint8_t  node_depth;     \n    uint8_t  inner_length;   \n     \n    uint8_t  salt[BLAKE2S_SALTBYTES];  \n    uint8_t  personal[BLAKE2S_PERSONALBYTES];   \n  });\n\n  typedef struct blake2s_param__ blake2s_param;\n\n  BLAKE2_PACKED(struct blake2b_param__\n  {\n    uint8_t  digest_length;  \n    uint8_t  key_length;     \n    uint8_t  fanout;         \n    uint8_t  depth;          \n    uint32_t leaf_length;    \n    uint32_t node_offset;    \n    uint32_t xof_length;     \n    uint8_t  node_depth;     \n    uint8_t  inner_length;   \n    uint8_t  reserved[14];   \n    uint8_t  salt[BLAKE2B_SALTBYTES];  \n    uint8_t  personal[BLAKE2B_PERSONALBYTES];   \n  });\n\n  typedef struct blake2b_param__ blake2b_param;\n\n  typedef struct blake2xs_state__\n  {\n    blake2s_state S[1];\n    blake2s_param P[1];\n  } blake2xs_state;\n\n  typedef struct blake2xb_state__\n  {\n    blake2b_state S[1];\n    blake2b_param P[1];\n  } blake2xb_state;\n\n   \n  enum {\n    BLAKE2_DUMMY_1 = 1 / (sizeof (blake2s_param) == BLAKE2S_OUTBYTES),\n    BLAKE2_DUMMY_2 = 1 / (sizeof (blake2b_param) == BLAKE2B_OUTBYTES)\n  };\n\n   \n  int blake2s_init( blake2s_state *S, size_t outlen );\n  int blake2s_init_key( blake2s_state *S, size_t outlen, const void *key, size_t keylen );\n  int blake2s_init_param( blake2s_state *S, const blake2s_param *P );\n  int blake2s_update( blake2s_state *S, const void *in, size_t inlen );\n  int blake2s_final( blake2s_state *S, void *out, size_t outlen );\n\n  int blake2b_init( blake2b_state *S, size_t outlen );\n  int blake2b_init_key( blake2b_state *S, size_t outlen, const void *key, size_t keylen );\n  int blake2b_init_param (blake2b_state *S, const blake2b_param *P)\n    _GL_ATTRIBUTE_NONNULL ();\n  int blake2b_update( blake2b_state *S, const void *in, size_t inlen );\n  int blake2b_final( blake2b_state *S, void *out, size_t outlen );\n\n  int blake2sp_init( blake2sp_state *S, size_t outlen );\n  int blake2sp_init_key( blake2sp_state *S, size_t outlen, const void *key, size_t keylen );\n  int blake2sp_update( blake2sp_state *S, const void *in, size_t inlen );\n  int blake2sp_final( blake2sp_state *S, void *out, size_t outlen );\n\n  int blake2bp_init( blake2bp_state *S, size_t outlen );\n  int blake2bp_init_key( blake2bp_state *S, size_t outlen, const void *key, size_t keylen );\n  int blake2bp_update( blake2bp_state *S, const void *in, size_t inlen );\n  int blake2bp_final( blake2bp_state *S, void *out, size_t outlen );\n\n   \n  int blake2xs_init( blake2xs_state *S, const size_t outlen );\n  int blake2xs_init_key( blake2xs_state *S, const size_t outlen, const void *key, size_t keylen );\n  int blake2xs_update( blake2xs_state *S, const void *in, size_t inlen );\n  int blake2xs_final(blake2xs_state *S, void *out, size_t outlen);\n\n  int blake2xb_init( blake2xb_state *S, const size_t outlen );\n  int blake2xb_init_key( blake2xb_state *S, const size_t outlen, const void *key, size_t keylen );\n  int blake2xb_update( blake2xb_state *S, const void *in, size_t inlen );\n  int blake2xb_final(blake2xb_state *S, void *out, size_t outlen);\n\n   \n  int blake2s( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n  int blake2b( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n\n  int blake2sp( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n  int blake2bp( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n\n  int blake2xs( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n  int blake2xb( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n\n   \n  int blake2( void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen );\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}