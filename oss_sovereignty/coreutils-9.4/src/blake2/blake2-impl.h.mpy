{
  "module_name": "blake2-impl.h",
  "hash_id": "14f781a99de9a9bea523d5e1ce478ec4ff5fc660becfe63ac941ec3dac0723a0",
  "original_prompt": "Ingested from coreutils-9.4/src/blake2/blake2-impl.h",
  "human_readable_source": " \n#ifndef BLAKE2_IMPL_H\n#define BLAKE2_IMPL_H\n\n#ifndef WORDS_BIGENDIAN\n# define NATIVE_LITTLE_ENDIAN 1\n#endif\n\n#include <stdint.h>\n#include <string.h>\n\n#if !defined(__cplusplus) && (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L)\n  #if   defined(_MSC_VER)\n    #define BLAKE2_INLINE __inline\n  #elif defined(__GNUC__)\n    #define BLAKE2_INLINE __inline__\n  #else\n    #define BLAKE2_INLINE\n  #endif\n#else\n  #define BLAKE2_INLINE inline\n#endif\n\nstatic BLAKE2_INLINE uint32_t load32( const void *src )\n{\n#if defined(NATIVE_LITTLE_ENDIAN)\n  uint32_t w;\n  memcpy(&w, src, sizeof w);\n  return w;\n#else\n  const uint8_t *p = ( const uint8_t * )src;\n  return (( uint32_t )( p[0] ) <<  0) |\n         (( uint32_t )( p[1] ) <<  8) |\n         (( uint32_t )( p[2] ) << 16) |\n         (( uint32_t )( p[3] ) << 24) ;\n#endif\n}\n\nstatic BLAKE2_INLINE uint64_t load64( const void *src )\n{\n#if defined(NATIVE_LITTLE_ENDIAN)\n  uint64_t w;\n  memcpy(&w, src, sizeof w);\n  return w;\n#else\n  const uint8_t *p = ( const uint8_t * )src;\n  return (( uint64_t )( p[0] ) <<  0) |\n         (( uint64_t )( p[1] ) <<  8) |\n         (( uint64_t )( p[2] ) << 16) |\n         (( uint64_t )( p[3] ) << 24) |\n         (( uint64_t )( p[4] ) << 32) |\n         (( uint64_t )( p[5] ) << 40) |\n         (( uint64_t )( p[6] ) << 48) |\n         (( uint64_t )( p[7] ) << 56) ;\n#endif\n}\n\nstatic BLAKE2_INLINE uint16_t load16( const void *src )\n{\n#if defined(NATIVE_LITTLE_ENDIAN)\n  uint16_t w;\n  memcpy(&w, src, sizeof w);\n  return w;\n#else\n  const uint8_t *p = ( const uint8_t * )src;\n  return ( uint16_t )((( uint32_t )( p[0] ) <<  0) |\n                      (( uint32_t )( p[1] ) <<  8));\n#endif\n}\n\nstatic BLAKE2_INLINE void store16( void *dst, uint16_t w )\n{\n#if defined(NATIVE_LITTLE_ENDIAN)\n  memcpy(dst, &w, sizeof w);\n#else\n  uint8_t *p = ( uint8_t * )dst;\n  *p++ = ( uint8_t )w; w >>= 8;\n  *p++ = ( uint8_t )w;\n#endif\n}\n\nstatic BLAKE2_INLINE void store32( void *dst, uint32_t w )\n{\n#if defined(NATIVE_LITTLE_ENDIAN)\n  memcpy(dst, &w, sizeof w);\n#else\n  uint8_t *p = ( uint8_t * )dst;\n  p[0] = (uint8_t)(w >>  0);\n  p[1] = (uint8_t)(w >>  8);\n  p[2] = (uint8_t)(w >> 16);\n  p[3] = (uint8_t)(w >> 24);\n#endif\n}\n\nstatic BLAKE2_INLINE void store64( void *dst, uint64_t w )\n{\n#if defined(NATIVE_LITTLE_ENDIAN)\n  memcpy(dst, &w, sizeof w);\n#else\n  uint8_t *p = ( uint8_t * )dst;\n  p[0] = (uint8_t)(w >>  0);\n  p[1] = (uint8_t)(w >>  8);\n  p[2] = (uint8_t)(w >> 16);\n  p[3] = (uint8_t)(w >> 24);\n  p[4] = (uint8_t)(w >> 32);\n  p[5] = (uint8_t)(w >> 40);\n  p[6] = (uint8_t)(w >> 48);\n  p[7] = (uint8_t)(w >> 56);\n#endif\n}\n\nstatic BLAKE2_INLINE uint64_t load48( const void *src )\n{\n  const uint8_t *p = ( const uint8_t * )src;\n  return (( uint64_t )( p[0] ) <<  0) |\n         (( uint64_t )( p[1] ) <<  8) |\n         (( uint64_t )( p[2] ) << 16) |\n         (( uint64_t )( p[3] ) << 24) |\n         (( uint64_t )( p[4] ) << 32) |\n         (( uint64_t )( p[5] ) << 40) ;\n}\n\nstatic BLAKE2_INLINE void store48( void *dst, uint64_t w )\n{\n  uint8_t *p = ( uint8_t * )dst;\n  p[0] = (uint8_t)(w >>  0);\n  p[1] = (uint8_t)(w >>  8);\n  p[2] = (uint8_t)(w >> 16);\n  p[3] = (uint8_t)(w >> 24);\n  p[4] = (uint8_t)(w >> 32);\n  p[5] = (uint8_t)(w >> 40);\n}\n\nstatic BLAKE2_INLINE uint32_t rotr32( const uint32_t w, const unsigned c )\n{\n  return ( w >> c ) | ( w << ( 32 - c ) );\n}\n\nstatic BLAKE2_INLINE uint64_t rotr64( const uint64_t w, const unsigned c )\n{\n  return ( w >> c ) | ( w << ( 64 - c ) );\n}\n\n \nstatic BLAKE2_INLINE void secure_zero_memory(void *v, size_t n)\n{\n  static void *(*const volatile memset_v)(void *, int, size_t) = &memset;\n  memset_v(v, 0, n);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}