{
  "module_name": "chroot.c",
  "hash_id": "eb356cc9e2d85e6407d71521df8ebbc390b21d1f0bab3711e4001f35c2e17f58",
  "original_prompt": "Ingested from coreutils-9.4/src/chroot.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include \"system.h\"\n#include \"ignore-value.h\"\n#include \"mgetgroups.h\"\n#include \"quote.h\"\n#include \"root-dev-ino.h\"\n#include \"userspec.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"chroot\"\n\n#define AUTHORS proper_name (\"Roland McGrath\")\n\n#ifndef MAXGID\n# define MAXGID GID_T_MAX\n#endif\n\nstatic inline bool uid_unset (uid_t uid) { return uid == (uid_t) -1; }\nstatic inline bool gid_unset (gid_t gid) { return gid == (gid_t) -1; }\n#define uid_set(x) (!uid_unset (x))\n#define gid_set(x) (!gid_unset (x))\n\nenum\n{\n  GROUPS = UCHAR_MAX + 1,\n  USERSPEC,\n  SKIP_CHDIR\n};\n\nstatic struct option const long_opts[] =\n{\n  {\"groups\", required_argument, nullptr, GROUPS},\n  {\"userspec\", required_argument, nullptr, USERSPEC},\n  {\"skip-chdir\", no_argument, nullptr, SKIP_CHDIR},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n#if ! HAVE_SETGROUPS\n \nstatic int\nsetgroups (size_t size, MAYBE_UNUSED gid_t const *list)\n{\n  if (size == 0)\n    {\n       \n      return 0;\n    }\n  else\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n}\n#endif\n\n \n\nstatic int\nparse_additional_groups (char const *groups, GETGROUPS_T **pgids,\n                         size_t *pn_gids, bool show_errors)\n{\n  GETGROUPS_T *gids = nullptr;\n  size_t n_gids_allocated = 0;\n  size_t n_gids = 0;\n  char *buffer = xstrdup (groups);\n  char const *tmp;\n  int ret = 0;\n\n  for (tmp = strtok (buffer, \",\"); tmp; tmp = strtok (nullptr, \",\"))\n    {\n      struct group *g;\n      uintmax_t value;\n\n      if (xstrtoumax (tmp, nullptr, 10, &value, \"\") == LONGINT_OK\n          && value <= MAXGID)\n        {\n          while (isspace (to_uchar (*tmp)))\n            tmp++;\n          if (*tmp != '+')\n            {\n               \n              g = getgrnam (tmp);\n              if (g != nullptr)\n                value = g->gr_gid;\n            }\n           \n          g = (struct group *) (intptr_t) ! nullptr;\n        }\n      else\n        {\n          g = getgrnam (tmp);\n          if (g != nullptr)\n            value = g->gr_gid;\n        }\n\n      if (g == nullptr)\n        {\n          ret = -1;\n\n          if (show_errors)\n            {\n              error (0, errno, _(\"invalid group %s\"), quote (tmp));\n              continue;\n            }\n\n          break;\n        }\n\n      if (n_gids == n_gids_allocated)\n        gids = X2NREALLOC (gids, &n_gids_allocated);\n      gids[n_gids++] = value;\n    }\n\n  if (ret == 0 && n_gids == 0)\n    {\n      if (show_errors)\n        error (0, 0, _(\"invalid group list %s\"), quote (groups));\n      ret = -1;\n    }\n\n  *pgids = gids;\n\n  if (ret == 0)\n    *pn_gids = n_gids;\n\n  free (buffer);\n  return ret;\n}\n\n \n\nstatic bool\nis_root (char const *dir)\n{\n  char *resolved = canonicalize_file_name (dir);\n  bool is_res_root = resolved && STREQ (\"/\", resolved);\n  free (resolved);\n  return is_res_root;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\\n\\\n  or:  %s OPTION\\n\\\n\"), program_name, program_name);\n\n      fputs (_(\"\\\nRun COMMAND with root directory set to NEWROOT.\\n\\\n\\n\\\n\"), stdout);\n\n      fputs (_(\"\\\n      --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --userspec=USER:GROUP  specify user and group (ID or name) to use\\n\\\n\"), stdout);\n      printf (_(\"\\\n      --skip-chdir           do not change working directory to %s\\n\\\n\"), quoteaf (\"/\"));\n\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nIf no command is given, run '\\\"$SHELL\\\" -i' (default: '/bin/sh -i').\\n\\\n\"), stdout);\n      emit_exec_status (PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n\n  /* Input user and groups spec.  */\n  char *userspec = nullptr;\n  char const *username = nullptr;\n  char const *groups = nullptr;\n  bool skip_chdir = false;\n\n  /* Parsed user and group IDs.  */\n  uid_t uid = -1;\n  gid_t gid = -1;\n  GETGROUPS_T *out_gids = nullptr;\n  size_t n_gids = 0;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXIT_CANCELED);\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"+\", long_opts, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case USERSPEC:\n          {\n            userspec = optarg;\n            /* Treat 'user:' just like 'user'\n               as we lookup the primary group by default\n               (and support doing so for UIDs as well as names.  */\n            size_t userlen = strlen (userspec);\n            if (userlen && userspec[userlen - 1] == ':')\n              userspec[userlen - 1] = '\\0';\n            break;\n          }\n\n        case GROUPS:\n          groups = optarg;\n          break;\n\n        case SKIP_CHDIR:\n          skip_chdir = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_CANCELED);\n        }\n    }\n\n  if (argc <= optind)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_CANCELED);\n    }\n\n  char const *newroot = argv[optind];\n  bool is_oldroot = is_root (newroot);\n\n  if (! is_oldroot && skip_chdir)\n    {\n      error (0, 0, _(\"option --skip-chdir only permitted if NEWROOT is old %s\"),\n             quoteaf (\"/\"));\n      usage (EXIT_CANCELED);\n    }\n\n  if (! is_oldroot)\n    {\n      /* We have to look up users and groups twice.\n        - First, outside the chroot to load potentially necessary passwd/group\n          parsing plugins (e.g. NSS);\n        - Second, inside chroot to redo parsing in case IDs are different.\n          Within chroot lookup is the main justification for having\n          the --user option supported by the chroot command itself.  */\n      if (userspec)\n        ignore_value (parse_user_spec (userspec, &uid, &gid, nullptr, nullptr));\n\n      /* If no gid is supplied or looked up, do so now.\n        Also lookup the username for use with getgroups.  */\n      if (uid_set (uid) && (! groups || gid_unset (gid)))\n        {\n          const struct passwd *pwd;\n          if ((pwd = getpwuid (uid)))\n            {\n              if (gid_unset (gid))\n                gid = pwd->pw_gid;\n              username = pwd->pw_name;\n            }\n        }\n\n      if (groups && *groups)\n        ignore_value (parse_additional_groups (groups, &out_gids, &n_gids,\n                                               false));\n#if HAVE_SETGROUPS\n      else if (! groups && gid_set (gid) && username)\n        {\n          int ngroups = xgetgroups (username, gid, &out_gids);\n          if (0 < ngroups)\n            n_gids = ngroups;\n        }\n#endif\n    }\n\n  if (chroot (newroot) != 0)\n    error (EXIT_CANCELED, errno, _(\"cannot change root directory to %s\"),\n           quoteaf (newroot));\n\n  if (! skip_chdir && chdir (\"/\"))\n    error (EXIT_CANCELED, errno, _(\"cannot chdir to root directory\"));\n\n  if (argc == optind + 1)\n    {\n      /* No command.  Run an interactive shell.  */\n      char *shell = getenv (\"SHELL\");\n      if (shell == nullptr)\n        shell = bad_cast (\"/bin/sh\");\n      argv[0] = shell;\n      argv[1] = bad_cast (\"-i\");\n      argv[2] = nullptr;\n    }\n  else\n    {\n      /* The following arguments give the command.  */\n      argv += optind + 1;\n    }\n\n  /* Attempt to set all three: supplementary groups, group ID, user ID.\n     Diagnose any failures.  If any have failed, exit before execvp.  */\n  if (userspec)\n    {\n      bool warn;\n      char const *err = parse_user_spec_warn (userspec, &uid, &gid,\n                                              nullptr, nullptr, &warn);\n      if (err)\n        error (warn ? 0 : EXIT_CANCELED, 0, \"%s\", (err));\n    }\n\n  /* If no gid is supplied or looked up, do so now.\n     Also lookup the username for use with getgroups.  */\n  if (uid_set (uid) && (! groups || gid_unset (gid)))\n    {\n      const struct passwd *pwd;\n      if ((pwd = getpwuid (uid)))\n        {\n          if (gid_unset (gid))\n            gid = pwd->pw_gid;\n          username = pwd->pw_name;\n        }\n      else if (gid_unset (gid))\n        {\n          error (EXIT_CANCELED, errno,\n                 _(\"no group specified for unknown uid: %d\"), (int) uid);\n        }\n    }\n\n  GETGROUPS_T *gids = out_gids;\n  GETGROUPS_T *in_gids = nullptr;\n  if (groups && *groups)\n    {\n      if (parse_additional_groups (groups, &in_gids, &n_gids, !n_gids) != 0)\n        {\n          if (! n_gids)\n            return EXIT_CANCELED;\n          /* else look-up outside the chroot worked, then go with those.  */\n        }\n      else\n        gids = in_gids;\n    }\n#if HAVE_SETGROUPS\n  else if (! groups && gid_set (gid) && username)\n    {\n      int ngroups = xgetgroups (username, gid, &in_gids);\n      if (ngroups <= 0)\n        {\n          if (! n_gids)\n            error (EXIT_CANCELED, errno,\n                   _(\"failed to get supplemental groups\"));\n          /* else look-up outside the chroot worked, then go with those.  */\n        }\n      else\n        {\n          n_gids = ngroups;\n          gids = in_gids;\n        }\n    }\n#endif\n\n  if ((uid_set (uid) || groups) && setgroups (n_gids, gids) != 0)\n    error (EXIT_CANCELED, errno, _(\"failed to set supplemental groups\"));\n\n  free (in_gids);\n  free (out_gids);\n\n  if (gid_set (gid) && setgid (gid))\n    error (EXIT_CANCELED, errno, _(\"failed to set group-ID\"));\n\n  if (uid_set (uid) && setuid (uid))\n    error (EXIT_CANCELED, errno, _(\"failed to set user-ID\"));\n\n  /* Execute the given command.  */\n  execvp (argv[0], argv);\n\n  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n  error (0, errno, _(\"failed to run command %s\"), quote (argv[0]));\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}