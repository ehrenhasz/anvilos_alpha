{
  "module_name": "chown-core.c",
  "hash_id": "65b7f62021eee0c297692981f542288989c377d28a4632ac2e60b4e50faf63d1",
  "original_prompt": "Ingested from coreutils-9.4/src/chown-core.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"chown-core.h\"\n#include \"ignore-value.h\"\n#include \"root-dev-ino.h\"\n#include \"xfts.h\"\n\n#define FTSENT_IS_DIRECTORY(E)\t\\\n  ((E)->fts_info == FTS_D\t\\\n   || (E)->fts_info == FTS_DC\t\\\n   || (E)->fts_info == FTS_DP\t\\\n   || (E)->fts_info == FTS_DNR)\n\nenum RCH_status\n  {\n     \n    RC_ok = 2,\n\n     \n    RC_excluded,\n\n     \n    RC_inode_changed,\n\n     \n    RC_do_ordinary_chown,\n\n     \n    RC_error\n  };\n\nextern void\nchopt_init (struct Chown_option *chopt)\n{\n  chopt->verbosity = V_off;\n  chopt->root_dev_ino = nullptr;\n  chopt->affect_symlink_referent = true;\n  chopt->recurse = false;\n  chopt->force_silent = false;\n  chopt->user_name = nullptr;\n  chopt->group_name = nullptr;\n}\n\nextern void\nchopt_free (struct Chown_option *chopt)\n{\n  free (chopt->user_name);\n  free (chopt->group_name);\n}\n\n \n\nstatic char *\nuid_to_str (uid_t uid)\n{\n  char buf[INT_BUFSIZE_BOUND (intmax_t)];\n  return xstrdup (TYPE_SIGNED (uid_t) ? imaxtostr (uid, buf)\n                  : umaxtostr (uid, buf));\n}\n\n \n\nstatic char *\ngid_to_str (gid_t gid)\n{\n  char buf[INT_BUFSIZE_BOUND (intmax_t)];\n  return xstrdup (TYPE_SIGNED (gid_t) ? imaxtostr (gid, buf)\n                  : umaxtostr (gid, buf));\n}\n\n \n\nextern char *\ngid_to_name (gid_t gid)\n{\n  struct group *grp = getgrgid (gid);\n  return grp ? xstrdup (grp->gr_name) : gid_to_str (gid);\n}\n\n \n\nextern char *\nuid_to_name (uid_t uid)\n{\n  struct passwd *pwd = getpwuid (uid);\n  return pwd ? xstrdup (pwd->pw_name) : uid_to_str (uid);\n}\n\n \n\nstatic char *\nuser_group_str (char const *user, char const *group)\n{\n  char *spec = nullptr;\n\n  if (user)\n    {\n      if (group)\n        {\n          spec = xmalloc (strlen (user) + 1 + strlen (group) + 1);\n          stpcpy (stpcpy (stpcpy (spec, user), \":\"), group);\n        }\n      else\n        {\n          spec = xstrdup (user);\n        }\n    }\n  else if (group)\n    {\n      spec = xstrdup (group);\n    }\n\n  return spec;\n}\n\n \n\nstatic void\ndescribe_change (char const *file, enum Change_status changed,\n                 char const *old_user, char const *old_group,\n                 char const *user, char const *group)\n{\n  char const *fmt;\n  char *old_spec;\n  char *spec;\n\n  if (changed == CH_NOT_APPLIED)\n    {\n      printf (_(\"neither symbolic link %s nor referent has been changed\\n\"),\n              quoteaf (file));\n      return;\n    }\n\n  spec = user_group_str (user, group);\n  old_spec = user_group_str (user ? old_user : nullptr,\n                             group ? old_group : nullptr);\n\n  switch (changed)\n    {\n    case CH_SUCCEEDED:\n      fmt = (user ? _(\"changed ownership of %s from %s to %s\\n\")\n             : group ? _(\"changed group of %s from %s to %s\\n\")\n             : _(\"no change to ownership of %s\\n\"));\n      break;\n    case CH_FAILED:\n      if (old_spec)\n        {\n          fmt = (user ? _(\"failed to change ownership of %s from %s to %s\\n\")\n                 : group ? _(\"failed to change group of %s from %s to %s\\n\")\n                 : _(\"failed to change ownership of %s\\n\"));\n        }\n      else\n        {\n          fmt = (user ? _(\"failed to change ownership of %s to %s\\n\")\n                 : group ? _(\"failed to change group of %s to %s\\n\")\n                 : _(\"failed to change ownership of %s\\n\"));\n          free (old_spec);\n          old_spec = spec;\n          spec = nullptr;\n        }\n      break;\n    case CH_NO_CHANGE_REQUESTED:\n      fmt = (user ? _(\"ownership of %s retained as %s\\n\")\n             : group ? _(\"group of %s retained as %s\\n\")\n             : _(\"ownership of %s retained\\n\"));\n      break;\n    default:\n      affirm (false);\n    }\n\n  printf (fmt, quoteaf (file), old_spec, spec);\n\n  free (old_spec);\n  free (spec);\n}\n\n \n\nstatic enum RCH_status\nrestricted_chown (int cwd_fd, char const *file,\n                  struct stat const *orig_st,\n                  uid_t uid, gid_t gid,\n                  uid_t required_uid, gid_t required_gid)\n{\n  enum RCH_status status = RC_ok;\n  struct stat st;\n  int open_flags = O_NONBLOCK | O_NOCTTY;\n  int fd;\n\n  if (required_uid == (uid_t) -1 && required_gid == (gid_t) -1)\n    return RC_do_ordinary_chown;\n\n  if (! S_ISREG (orig_st->st_mode))\n    {\n      if (S_ISDIR (orig_st->st_mode))\n        open_flags |= O_DIRECTORY;\n      else\n        return RC_do_ordinary_chown;\n    }\n\n  fd = openat (cwd_fd, file, O_RDONLY | open_flags);\n  if (! (0 <= fd\n         || (errno == EACCES && S_ISREG (orig_st->st_mode)\n             && 0 <= (fd = openat (cwd_fd, file, O_WRONLY | open_flags)))))\n    return (errno == EACCES ? RC_do_ordinary_chown : RC_error);\n\n  if (fstat (fd, &st) != 0)\n    status = RC_error;\n  else if (! SAME_INODE (*orig_st, st))\n    status = RC_inode_changed;\n  else if ((required_uid == (uid_t) -1 || required_uid == st.st_uid)\n           && (required_gid == (gid_t) -1 || required_gid == st.st_gid))\n    {\n      if (fchown (fd, uid, gid) == 0)\n        {\n          status = (close (fd) == 0\n                    ? RC_ok : RC_error);\n          return status;\n        }\n      else\n        {\n          status = RC_error;\n        }\n    }\n\n  int saved_errno = errno;\n  close (fd);\n  errno = saved_errno;\n  return status;\n}\n\n \nstatic bool\nchange_file_owner (FTS *fts, FTSENT *ent,\n                   uid_t uid, gid_t gid,\n                   uid_t required_uid, gid_t required_gid,\n                   struct Chown_option const *chopt)\n{\n  char const *file_full_name = ent->fts_path;\n  char const *file = ent->fts_accpath;\n  struct stat const *file_stats;\n  struct stat stat_buf;\n  bool ok = true;\n  bool do_chown;\n  bool symlink_changed = true;\n\n  switch (ent->fts_info)\n    {\n    case FTS_D:\n      if (chopt->recurse)\n        {\n          if (ROOT_DEV_INO_CHECK (chopt->root_dev_ino, ent->fts_statp))\n            {\n               \n              ROOT_DEV_INO_WARN (file_full_name);\n               \n              fts_set (fts, ent, FTS_SKIP);\n               \n              ignore_value (fts_read (fts));\n              return false;\n            }\n          return true;\n        }\n      break;\n\n    case FTS_DP:\n      if (! chopt->recurse)\n        return true;\n      break;\n\n    case FTS_NS:\n       \n      if (ent->fts_level == 0 && ent->fts_number == 0)\n        {\n          ent->fts_number = 1;\n          fts_set (fts, ent, FTS_AGAIN);\n          return true;\n        }\n      if (! chopt->force_silent)\n        error (0, ent->fts_errno, _(\"cannot access %s\"),\n               quoteaf (file_full_name));\n      ok = false;\n      break;\n\n    case FTS_ERR:\n      if (! chopt->force_silent)\n        error (0, ent->fts_errno, \"%s\", quotef (file_full_name));\n      ok = false;\n      break;\n\n    case FTS_DNR:\n      if (! chopt->force_silent)\n        error (0, ent->fts_errno, _(\"cannot read directory %s\"),\n               quoteaf (file_full_name));\n      ok = false;\n      break;\n\n    case FTS_DC:\t\t \n      if (cycle_warning_required (fts, ent))\n        {\n          emit_cycle_warning (file_full_name);\n          return false;\n        }\n      break;\n\n    default:\n      break;\n    }\n\n  if (!ok)\n    {\n      do_chown = false;\n      file_stats = nullptr;\n    }\n  else if (required_uid == (uid_t) -1 && required_gid == (gid_t) -1\n           && chopt->verbosity == V_off\n           && ! chopt->root_dev_ino\n           && ! chopt->affect_symlink_referent)\n    {\n      do_chown = true;\n      file_stats = ent->fts_statp;\n    }\n  else\n    {\n      file_stats = ent->fts_statp;\n\n       \n      if (chopt->affect_symlink_referent && S_ISLNK (file_stats->st_mode))\n        {\n          if (fstatat (fts->fts_cwd_fd, file, &stat_buf, 0) != 0)\n            {\n              if (! chopt->force_silent)\n                error (0, errno, _(\"cannot dereference %s\"),\n                       quoteaf (file_full_name));\n              ok = false;\n            }\n\n          file_stats = &stat_buf;\n        }\n\n      do_chown = (ok\n                  && (required_uid == (uid_t) -1\n                      || required_uid == file_stats->st_uid)\n                  && (required_gid == (gid_t) -1\n                      || required_gid == file_stats->st_gid));\n    }\n\n   \n  if (ok\n      && FTSENT_IS_DIRECTORY (ent)\n      && ROOT_DEV_INO_CHECK (chopt->root_dev_ino, file_stats))\n    {\n      ROOT_DEV_INO_WARN (file_full_name);\n      return false;\n    }\n\n  if (do_chown)\n    {\n      if ( ! chopt->affect_symlink_referent)\n        {\n          ok = (lchownat (fts->fts_cwd_fd, file, uid, gid) == 0);\n\n           \n          if (!ok && errno == EOPNOTSUPP)\n            {\n              ok = true;\n              symlink_changed = false;\n            }\n        }\n      else\n        {\n           \n\n          enum RCH_status err\n            = restricted_chown (fts->fts_cwd_fd, file, file_stats, uid, gid,\n                                required_uid, required_gid);\n          switch (err)\n            {\n            case RC_ok:\n              break;\n\n            case RC_do_ordinary_chown:\n              ok = (chownat (fts->fts_cwd_fd, file, uid, gid) == 0);\n              break;\n\n            case RC_error:\n              ok = false;\n              break;\n\n            case RC_inode_changed:\n               \n            case RC_excluded:\n              do_chown = false;\n              ok = false;\n              break;\n\n            default:\n              unreachable ();\n            }\n        }\n\n       \n\n      if (do_chown && !ok && ! chopt->force_silent)\n        error (0, errno, (uid != (uid_t) -1\n                          ? _(\"changing ownership of %s\")\n                          : _(\"changing group of %s\")),\n               quoteaf (file_full_name));\n    }\n\n  if (chopt->verbosity != V_off)\n    {\n      bool changed =\n        ((do_chown && ok && symlink_changed)\n         && ! ((uid == (uid_t) -1 || uid == file_stats->st_uid)\n               && (gid == (gid_t) -1 || gid == file_stats->st_gid)));\n\n      if (changed || chopt->verbosity == V_high)\n        {\n          enum Change_status ch_status =\n            (!ok ? CH_FAILED\n             : !symlink_changed ? CH_NOT_APPLIED\n             : !changed ? CH_NO_CHANGE_REQUESTED\n             : CH_SUCCEEDED);\n          char *old_usr = (file_stats\n                           ? uid_to_name (file_stats->st_uid) : nullptr);\n          char *old_grp = (file_stats\n                           ? gid_to_name (file_stats->st_gid) : nullptr);\n          char *new_usr = chopt->user_name\n                          ? chopt->user_name : uid != -1\n                                               ? uid_to_str (uid) : nullptr;\n          char *new_grp = chopt->group_name\n                          ? chopt->group_name : gid != -1\n                                               ? gid_to_str (gid) : nullptr;\n          describe_change (file_full_name, ch_status,\n                           old_usr, old_grp,\n                           new_usr, new_grp);\n          free (old_usr);\n          free (old_grp);\n          if (new_usr != chopt->user_name)\n            free (new_usr);\n          if (new_grp != chopt->group_name)\n            free (new_grp);\n        }\n    }\n\n  if ( ! chopt->recurse)\n    fts_set (fts, ent, FTS_SKIP);\n\n  return ok;\n}\n\n \nextern bool\nchown_files (char **files, int bit_flags,\n             uid_t uid, gid_t gid,\n             uid_t required_uid, gid_t required_gid,\n             struct Chown_option const *chopt)\n{\n  bool ok = true;\n\n   \n  int stat_flags = ((required_uid != (uid_t) -1 || required_gid != (gid_t) -1\n                     || chopt->affect_symlink_referent\n                     || chopt->verbosity != V_off)\n                    ? 0\n                    : FTS_NOSTAT);\n\n  FTS *fts = xfts_open (files, bit_flags | stat_flags, nullptr);\n\n  while (true)\n    {\n      FTSENT *ent;\n\n      ent = fts_read (fts);\n      if (ent == nullptr)\n        {\n          if (errno != 0)\n            {\n               \n              if (! chopt->force_silent)\n                error (0, errno, _(\"fts_read failed\"));\n              ok = false;\n            }\n          break;\n        }\n\n      ok &= change_file_owner (fts, ent, uid, gid,\n                               required_uid, required_gid, chopt);\n    }\n\n  if (fts_close (fts) != 0)\n    {\n      error (0, errno, _(\"fts_close failed\"));\n      ok = false;\n    }\n\n  return ok;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}