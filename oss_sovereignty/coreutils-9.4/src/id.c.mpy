{
  "module_name": "id.c",
  "hash_id": "9b52c59ac4cfa7ad95df046ecc8b4d6c7839c7766584d04415d2498f157d96c6",
  "original_prompt": "Ingested from coreutils-9.4/src/id.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include <getopt.h>\n#include <selinux/selinux.h>\n\n#include \"system.h\"\n#include \"mgetgroups.h\"\n#include \"quote.h\"\n#include \"group-list.h\"\n#include \"smack.h\"\n#include \"userspec.h\"\n\n \n#define PROGRAM_NAME \"id\"\n\n#define AUTHORS \\\n  proper_name (\"Arnold Robbins\"), \\\n  proper_name (\"David MacKenzie\")\n\n \nstatic bool just_context = 0;\n \nstatic bool opt_zero = false;\n \nstatic bool just_group_list = false;\n \nstatic bool just_group = false;\n \nstatic bool use_real = false;\n \nstatic bool just_user = false;\n \nstatic bool ok = true;\n \nstatic bool multiple_users = false;\n \nstatic bool use_name = false;\n\n \nstatic uid_t ruid, euid;\nstatic gid_t rgid, egid;\n\n \nstatic char *context = nullptr;\n\nstatic void print_user (uid_t uid);\nstatic void print_full_info (char const *username);\nstatic void print_stuff (char const *pw_name);\n\nstatic struct option const longopts[] =\n{\n  {\"context\", no_argument, nullptr, 'Z'},\n  {\"group\", no_argument, nullptr, 'g'},\n  {\"groups\", no_argument, nullptr, 'G'},\n  {\"name\", no_argument, nullptr, 'n'},\n  {\"real\", no_argument, nullptr, 'r'},\n  {\"user\", no_argument, nullptr, 'u'},\n  {\"zero\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [USER]...\\n\"), program_name);\n      fputs (_(\"\\\nPrint user and group information for each specified USER,\\n\\\nor (when USER omitted) for the current process.\\n\\\n\\n\"),\n             stdout);\n      fputs (_(\"\\\n  -a             ignore, for compatibility with other versions\\n\\\n  -Z, --context  print only the security context of the process\\n\\\n  -g, --group    print only the effective group ID\\n\\\n  -G, --groups   print all group IDs\\n\\\n  -n, --name     print a name instead of a number, for -ugG\\n\\\n  -r, --real     print the real ID instead of the effective ID, with -ugG\\n\\\n  -u, --user     print only the effective user ID\\n\\\n  -z, --zero     delimit entries with NUL characters, not whitespace;\\n\\\n                   not permitted in default format\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nWithout any OPTION, print some useful set of identified information.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  int selinux_enabled = (is_selinux_enabled () > 0);\n  bool smack_enabled = is_smack_enabled ();\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"agnruzGZ\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'a':\n          /* Ignore -a, for compatibility with SVR4.  */\n          break;\n\n        case 'Z':\n          /* politely decline if we're not on a SELinux/SMACK-enabled kernel. */\n#ifdef HAVE_SMACK\n          if (!selinux_enabled && !smack_enabled)\n            error (EXIT_FAILURE, 0,\n                   _(\"--context (-Z) works only on \"\n                     \"an SELinux/SMACK-enabled kernel\"));\n#else\n          if (!selinux_enabled)\n            error (EXIT_FAILURE, 0,\n                   _(\"--context (-Z) works only on an SELinux-enabled kernel\"));\n#endif\n          just_context = true;\n          break;\n\n        case 'g':\n          just_group = true;\n          break;\n        case 'n':\n          use_name = true;\n          break;\n        case 'r':\n          use_real = true;\n          break;\n        case 'u':\n          just_user = true;\n          break;\n        case 'z':\n          opt_zero = true;\n          break;\n        case 'G':\n          just_group_list = true;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  size_t n_ids = argc - optind;\n\n  if (n_ids && just_context)\n    error (EXIT_FAILURE, 0,\n           _(\"cannot print security context when user specified\"));\n\n  if (just_user + just_group + just_group_list + just_context > 1)\n    error (EXIT_FAILURE, 0, _(\"cannot print \\\"only\\\" of more than one choice\"));\n\n  bool default_format = ! (just_user\n                           || just_group\n                           || just_group_list\n                           || just_context);\n\n  if (default_format && (use_real || use_name))\n    error (EXIT_FAILURE, 0,\n           _(\"cannot print only names or real IDs in default format\"));\n\n  if (default_format && opt_zero)\n    error (EXIT_FAILURE, 0,\n           _(\"option --zero not permitted in default format\"));\n\n   \n  if (n_ids == 0\n      && (just_context\n          || (default_format && ! getenv (\"POSIXLY_CORRECT\"))))\n    {\n       \n      if ((selinux_enabled && getcon (&context) && just_context)\n          || (smack_enabled\n              && smack_new_label_from_self (&context) < 0\n              && just_context))\n        error (EXIT_FAILURE, 0, _(\"can't get process context\"));\n    }\n\n  if (n_ids >= 1)\n    {\n      multiple_users = n_ids > 1 ? true : false;\n       \n      n_ids += optind;\n       \n      for (; optind < n_ids; optind++)\n        {\n          char *pw_name = nullptr;\n          struct passwd *pwd = nullptr;\n          char const *spec = argv[optind];\n           \n          if (*spec)\n            {\n              if (! parse_user_spec (spec, &euid, nullptr, &pw_name, nullptr))\n                pwd = pw_name ? getpwnam (pw_name) : getpwuid (euid);\n            }\n          if (pwd == nullptr)\n            {\n              error (0, errno, _(\"%s: no such user\"), quote (spec));\n              ok &= false;\n            }\n          else\n            {\n              if (!pw_name)\n                pw_name = xstrdup (pwd->pw_name);\n              ruid = euid = pwd->pw_uid;\n              rgid = egid = pwd->pw_gid;\n              print_stuff (pw_name);\n            }\n          free (pw_name);\n        }\n    }\n  else\n    {\n       \n      uid_t NO_UID = -1;\n      gid_t NO_GID = -1;\n\n      if (just_user ? !use_real\n          : !just_group && !just_group_list && !just_context)\n        {\n          errno = 0;\n          euid = geteuid ();\n          if (euid == NO_UID && errno)\n            error (EXIT_FAILURE, errno, _(\"cannot get effective UID\"));\n        }\n\n      if (just_user ? use_real\n          : !just_group && (just_group_list || !just_context))\n        {\n          errno = 0;\n          ruid = getuid ();\n          if (ruid == NO_UID && errno)\n            error (EXIT_FAILURE, errno, _(\"cannot get real UID\"));\n        }\n\n      if (!just_user && (just_group || just_group_list || !just_context))\n        {\n          errno = 0;\n          egid = getegid ();\n          if (egid == NO_GID && errno)\n            error (EXIT_FAILURE, errno, _(\"cannot get effective GID\"));\n\n          errno = 0;\n          rgid = getgid ();\n          if (rgid == NO_GID && errno)\n            error (EXIT_FAILURE, errno, _(\"cannot get real GID\"));\n        }\n        print_stuff (nullptr);\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n \nstatic char *\ngidtostr_ptr (gid_t const *gid)\n{\n  static char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n  return umaxtostr (*gid, buf);\n}\n#define gidtostr(g) gidtostr_ptr (&(g))\n\n \nstatic char *\nuidtostr_ptr (uid_t const *uid)\n{\n  static char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n  return umaxtostr (*uid, buf);\n}\n#define uidtostr(u) uidtostr_ptr (&(u))\n\n \n\nstatic void\nprint_user (uid_t uid)\n{\n  struct passwd *pwd = nullptr;\n\n  if (use_name)\n    {\n      pwd = getpwuid (uid);\n      if (pwd == nullptr)\n        {\n          error (0, 0, _(\"cannot find name for user ID %s\"),\n                 uidtostr (uid));\n          ok &= false;\n        }\n    }\n\n  char *s = pwd ? pwd->pw_name : uidtostr (uid);\n  fputs (s, stdout);\n}\n\n \n\nstatic void\nprint_full_info (char const *username)\n{\n  struct passwd *pwd;\n  struct group *grp;\n\n  printf (_(\"uid=%s\"), uidtostr (ruid));\n  pwd = getpwuid (ruid);\n  if (pwd)\n    printf (\"(%s)\", pwd->pw_name);\n\n  printf (_(\" gid=%s\"), gidtostr (rgid));\n  grp = getgrgid (rgid);\n  if (grp)\n    printf (\"(%s)\", grp->gr_name);\n\n  if (euid != ruid)\n    {\n      printf (_(\" euid=%s\"), uidtostr (euid));\n      pwd = getpwuid (euid);\n      if (pwd)\n        printf (\"(%s)\", pwd->pw_name);\n    }\n\n  if (egid != rgid)\n    {\n      printf (_(\" egid=%s\"), gidtostr (egid));\n      grp = getgrgid (egid);\n      if (grp)\n        printf (\"(%s)\", grp->gr_name);\n    }\n\n  {\n    gid_t *groups;\n\n    gid_t primary_group;\n    if (username)\n      primary_group = pwd ? pwd->pw_gid : -1;\n    else\n      primary_group = egid;\n\n    int n_groups = xgetgroups (username, primary_group, &groups);\n    if (n_groups < 0)\n      {\n        if (username)\n          error (0, errno, _(\"failed to get groups for user %s\"),\n                 quote (username));\n        else\n          error (0, errno, _(\"failed to get groups for the current process\"));\n        ok &= false;\n        return;\n      }\n\n    if (n_groups > 0)\n      fputs (_(\" groups=\"), stdout);\n    for (int i = 0; i < n_groups; i++)\n      {\n        if (i > 0)\n          putchar (',');\n        fputs (gidtostr (groups[i]), stdout);\n        grp = getgrgid (groups[i]);\n        if (grp)\n          printf (\"(%s)\", grp->gr_name);\n      }\n    free (groups);\n  }\n\n   \n  if (context)\n    printf (_(\" context=%s\"), context);\n}\n\n \n\nstatic void\nprint_stuff (char const *pw_name)\n{\n  if (just_user)\n      print_user (use_real ? ruid : euid);\n\n   \n  else if (just_group)\n    ok &= print_group (use_real ? rgid : egid, use_name);\n  else if (just_group_list)\n    ok &= print_group_list (pw_name, ruid, rgid, egid,\n                            use_name, opt_zero ? '\\0' : ' ');\n  else if (just_context)\n    fputs (context, stdout);\n  else\n    print_full_info (pw_name);\n\n   \n  if (opt_zero && just_group_list && multiple_users)\n    {\n      putchar ('\\0');\n      putchar ('\\0');\n    }\n  else\n    {\n      putchar (opt_zero ? '\\0' : '\\n');\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}