{
  "module_name": "chcon.c",
  "hash_id": "9e5ff9a8c20e7a94a60ddc3c4ca66f94c4963ace7c325ea3709f0a77bc3e7110",
  "original_prompt": "Ingested from coreutils-9.4/src/chcon.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"chcon\"\n\n#define AUTHORS \\\n  proper_name (\"Russell Coker\"), \\\n  proper_name (\"Jim Meyering\")\n\n \nstatic bool affect_symlink_referent;\n\n \nstatic bool recurse;\n\n \nstatic bool verbose;\n\n \nstatic struct dev_ino *root_dev_ino;\n\n \nstatic char const *specified_context;\n\n \nstatic char const *specified_user;\nstatic char const *specified_role;\nstatic char const *specified_range;\nstatic char const *specified_type;\n\n \nenum\n{\n  DEREFERENCE_OPTION = CHAR_MAX + 1,\n  NO_PRESERVE_ROOT,\n  PRESERVE_ROOT,\n  REFERENCE_FILE_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"recursive\", no_argument, nullptr, 'R'},\n  {\"dereference\", no_argument, nullptr, DEREFERENCE_OPTION},\n  {\"no-dereference\", no_argument, nullptr, 'h'},\n  {\"no-preserve-root\", no_argument, nullptr, NO_PRESERVE_ROOT},\n  {\"preserve-root\", no_argument, nullptr, PRESERVE_ROOT},\n  {\"reference\", required_argument, nullptr, REFERENCE_FILE_OPTION},\n  {\"user\", required_argument, nullptr, 'u'},\n  {\"role\", required_argument, nullptr, 'r'},\n  {\"type\", required_argument, nullptr, 't'},\n  {\"range\", required_argument, nullptr, 'l'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic int\ncompute_context_from_mask (char const *context, context_t *ret)\n{\n  bool ok = true;\n  context_t new_context = context_new (context);\n  if (!new_context)\n    {\n      error (0, errno, _(\"failed to create security context: %s\"),\n             quote (context));\n      return 1;\n    }\n\n#define SET_COMPONENT(C, comp)\t\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (specified_ ## comp\t\t\t\t\t\t\\\n           && context_ ## comp ## _set ((C), specified_ ## comp))\t\\\n         {\t\t\t\t\t\t\t\t\\\n            error (0, errno,\t\t\t\t\t\t\\\n                   _(\"failed to set %s security context component to %s\"), \\\n                   #comp, quote (specified_ ## comp));\t\t\t\\\n           ok = false;\t\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n\n  SET_COMPONENT (new_context, user);\n  SET_COMPONENT (new_context, range);\n  SET_COMPONENT (new_context, role);\n  SET_COMPONENT (new_context, type);\n\n  if (!ok)\n    {\n      int saved_errno = errno;\n      context_free (new_context);\n      errno = saved_errno;\n      return 1;\n    }\n\n  *ret = new_context;\n  return 0;\n}\n\n \n\nstatic int\nchange_file_context (int fd, char const *file)\n{\n  char *file_context = nullptr;\n  context_t context IF_LINT (= 0);\n  char const * context_string;\n  int errors = 0;\n\n  if (specified_context == nullptr)\n    {\n      int status = (affect_symlink_referent\n                    ? getfileconat (fd, file, &file_context)\n                    : lgetfileconat (fd, file, &file_context));\n\n      if (status < 0 && errno != ENODATA)\n        {\n          error (0, errno, _(\"failed to get security context of %s\"),\n                 quoteaf (file));\n          return 1;\n        }\n\n       \n      if (file_context == nullptr)\n        {\n          error (0, 0, _(\"can't apply partial context to unlabeled file %s\"),\n                 quoteaf (file));\n          return 1;\n        }\n\n      if (compute_context_from_mask (file_context, &context))\n        return 1;\n\n      context_string = context_str (context);\n    }\n  else\n    {\n      context_string = specified_context;\n    }\n\n  if (file_context == nullptr || ! STREQ (context_string, file_context))\n    {\n      int fail = (affect_symlink_referent\n                  ?  setfileconat (fd, file, context_string)\n                  : lsetfileconat (fd, file, context_string));\n\n      if (fail)\n        {\n          errors = 1;\n          error (0, errno, _(\"failed to change context of %s to %s\"),\n                 quoteaf_n (0, file), quote_n (1, context_string));\n        }\n    }\n\n  if (specified_context == nullptr)\n    {\n      context_free (context);\n      freecon (file_context);\n    }\n\n  return errors;\n}\n\n \n\nstatic bool\nprocess_file (FTS *fts, FTSENT *ent)\n{\n  char const *file_full_name = ent->fts_path;\n  char const *file = ent->fts_accpath;\n  const struct stat *file_stats = ent->fts_statp;\n  bool ok = true;\n\n  switch (ent->fts_info)\n    {\n    case FTS_D:\n      if (recurse)\n        {\n          if (ROOT_DEV_INO_CHECK (root_dev_ino, ent->fts_statp))\n            {\n               \n              ROOT_DEV_INO_WARN (file_full_name);\n               \n              fts_set (fts, ent, FTS_SKIP);\n               \n              ignore_value (fts_read (fts));\n              return false;\n            }\n          return true;\n        }\n      break;\n\n    case FTS_DP:\n      if (! recurse)\n        return true;\n      break;\n\n    case FTS_NS:\n       \n      if (ent->fts_level == 0 && ent->fts_number == 0)\n        {\n          ent->fts_number = 1;\n          fts_set (fts, ent, FTS_AGAIN);\n          return true;\n        }\n      error (0, ent->fts_errno, _(\"cannot access %s\"),\n             quoteaf (file_full_name));\n      ok = false;\n      break;\n\n    case FTS_ERR:\n      error (0, ent->fts_errno, \"%s\", quotef (file_full_name));\n      ok = false;\n      break;\n\n    case FTS_DNR:\n      error (0, ent->fts_errno, _(\"cannot read directory %s\"),\n             quoteaf (file_full_name));\n      ok = false;\n      break;\n\n    case FTS_DC:\t\t \n      if (cycle_warning_required (fts, ent))\n        {\n          emit_cycle_warning (file_full_name);\n          return false;\n        }\n      break;\n\n    default:\n      break;\n    }\n\n  if (ent->fts_info == FTS_DP\n      && ok && ROOT_DEV_INO_CHECK (root_dev_ino, file_stats))\n    {\n      ROOT_DEV_INO_WARN (file_full_name);\n      ok = false;\n    }\n\n  if (ok)\n    {\n      if (verbose)\n        printf (_(\"changing security context of %s\\n\"),\n                quoteaf (file_full_name));\n\n      if (change_file_context (fts->fts_cwd_fd, file) != 0)\n        ok = false;\n    }\n\n  if ( ! recurse)\n    fts_set (fts, ent, FTS_SKIP);\n\n  return ok;\n}\n\n \n\nstatic bool\nprocess_files (char **files, int bit_flags)\n{\n  bool ok = true;\n\n  FTS *fts = xfts_open (files, bit_flags, nullptr);\n\n  while (true)\n    {\n      FTSENT *ent;\n\n      ent = fts_read (fts);\n      if (ent == nullptr)\n        {\n          if (errno != 0)\n            {\n               \n              error (0, errno, _(\"fts_read failed\"));\n              ok = false;\n            }\n          break;\n        }\n\n      ok &= process_file (fts, ent);\n    }\n\n  if (fts_close (fts) != 0)\n    {\n      error (0, errno, _(\"fts_close failed\"));\n      ok = false;\n    }\n\n  return ok;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... CONTEXT FILE...\\n\\\n  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\\n\\\n  or:  %s [OPTION]... --reference=RFILE FILE...\\n\\\n\"),\n        program_name, program_name, program_name);\n      fputs (_(\"\\\nChange the SELinux security context of each FILE to CONTEXT.\\n\\\nWith --reference, change the security context of each FILE to that of RFILE.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n      --dereference      affect the referent of each symbolic link (this is\\n\\\n                         the default), rather than the symbolic link itself\\n\\\n  -h, --no-dereference   affect symbolic links instead of any referenced file\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -u, --user=USER        set user USER in the target security context\\n\\\n  -r, --role=ROLE        set role ROLE in the target security context\\n\\\n  -t, --type=TYPE        set type TYPE in the target security context\\n\\\n  -l, --range=RANGE      set range RANGE in the target security context\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --no-preserve-root  do not treat '/' specially (the default)\\n\\\n      --preserve-root    fail to operate recursively on '/'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --reference=RFILE  use RFILE's security context rather than specifying\\n\\\n                         a CONTEXT value\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -R, --recursive        operate on files and directories recursively\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --verbose          output a diagnostic for every file processed\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nThe following options modify how a hierarchy is traversed when the -R\\n\\\noption is also specified.  If more than one is specified, only the final\\n\\\none takes effect.\\n\\\n\\n\\\n  -H                     if a command line argument is a symbolic link\\n\\\n                         to a directory, traverse it\\n\\\n  -L                     traverse every symbolic link to a directory\\n\\\n                         encountered\\n\\\n  -P                     do not traverse any symbolic links (default)\\n\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  /* Bit flags that control how fts works.  */\n  int bit_flags = FTS_PHYSICAL;\n\n  /* 1 if --dereference, 0 if --no-dereference, -1 if neither has been\n     specified.  */\n  int dereference = -1;\n\n  bool ok;\n  bool preserve_root = false;\n  bool component_specified = false;\n  char *reference_file = nullptr;\n  int optc;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"HLPRhvu:r:t:l:\",\n                              long_options, nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'H': /* Traverse command-line symlinks-to-directories.  */\n          bit_flags = FTS_COMFOLLOW | FTS_PHYSICAL;\n          break;\n\n        case 'L': /* Traverse all symlinks-to-directories.  */\n          bit_flags = FTS_LOGICAL;\n          break;\n\n        case 'P': /* Traverse no symlinks-to-directories.  */\n          bit_flags = FTS_PHYSICAL;\n          break;\n\n        case 'h': /* --no-dereference: affect symlinks */\n          dereference = 0;\n          break;\n\n        case DEREFERENCE_OPTION: /* --dereference: affect the referent\n                                    of each symlink */\n          dereference = 1;\n          break;\n\n        case NO_PRESERVE_ROOT:\n          preserve_root = false;\n          break;\n\n        case PRESERVE_ROOT:\n          preserve_root = true;\n          break;\n\n        case REFERENCE_FILE_OPTION:\n          reference_file = optarg;\n          break;\n\n        case 'R':\n          recurse = true;\n          break;\n\n        case 'f':\n          /* ignore */\n          break;\n\n        case 'v':\n          verbose = true;\n          break;\n\n        case 'u':\n          specified_user = optarg;\n          component_specified = true;\n          break;\n\n        case 'r':\n          specified_role = optarg;\n          component_specified = true;\n          break;\n\n        case 't':\n          specified_type = optarg;\n          component_specified = true;\n          break;\n\n        case 'l':\n          specified_range = optarg;\n          component_specified = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (recurse)\n    {\n      if (bit_flags == FTS_PHYSICAL)\n        {\n          if (dereference == 1)\n            error (EXIT_FAILURE, 0,\n                   _(\"-R --dereference requires either -H or -L\"));\n          affect_symlink_referent = false;\n        }\n      else\n        {\n          if (dereference == 0)\n            error (EXIT_FAILURE, 0, _(\"-R -h requires -P\"));\n          affect_symlink_referent = true;\n        }\n    }\n  else\n    {\n      bit_flags = FTS_PHYSICAL;\n      affect_symlink_referent = (dereference != 0);\n    }\n\n  if (argc - optind < (reference_file || component_specified ? 1 : 2))\n    {\n      if (argc <= optind)\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (reference_file)\n    {\n      char *ref_context = nullptr;\n\n      if (getfilecon (reference_file, &ref_context) < 0)\n        error (EXIT_FAILURE, errno, _(\"failed to get security context of %s\"),\n               quoteaf (reference_file));\n\n      specified_context = ref_context;\n    }\n  else if (component_specified)\n    {\n      /* FIXME: it's already null, so this is a no-op. */\n      specified_context = nullptr;\n    }\n  else\n    {\n      specified_context = argv[optind++];\n      if (0 < is_selinux_enabled ()\n          && security_check_context (specified_context) < 0)\n        error (EXIT_FAILURE, errno, _(\"invalid context: %s\"),\n               quote (specified_context));\n    }\n\n  if (reference_file && component_specified)\n    {\n      error (0, 0, _(\"conflicting security context specifiers given\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (recurse && preserve_root)\n    {\n      static struct dev_ino dev_ino_buf;\n      root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n      if (root_dev_ino == nullptr)\n        error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n               quoteaf (\"/\"));\n    }\n  else\n    {\n      root_dev_ino = nullptr;\n    }\n\n  ok = process_files (argv + optind, bit_flags | FTS_NOSTAT);\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}