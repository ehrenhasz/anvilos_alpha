{
  "module_name": "rmdir.c",
  "hash_id": "e7de7ee0cf669e2bbaf0e6d64b41c4c5d31136c6fd92410fbe2bfc29d2b07fe1",
  "original_prompt": "Ingested from coreutils-9.4/src/rmdir.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"prog-fprintf.h\"\n\n \n#define PROGRAM_NAME \"rmdir\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\n \nstatic bool remove_empty_parents;\n\n \nstatic bool ignore_fail_on_non_empty;\n\n \nstatic bool verbose;\n\n \nenum\n{\n  IGNORE_FAIL_ON_NON_EMPTY_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const longopts[] =\n{\n   \n  {\"ignore-fail-on-non-empty\", no_argument, nullptr,\n   IGNORE_FAIL_ON_NON_EMPTY_OPTION},\n\n  {\"path\", no_argument, nullptr, 'p'},   \n  {\"parents\", no_argument, nullptr, 'p'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic bool\nerrno_rmdir_non_empty (int error_number)\n{\n  return error_number == ENOTEMPTY || error_number == EEXIST;\n}\n\n \nstatic bool\nerrno_may_be_non_empty (int error_number)\n{\n  switch (error_number)\n    {\n    case EACCES:\n    case EPERM:\n    case EROFS:\n    case EBUSY:\n      return true;\n    default:\n      return false;\n    }\n}\n\n \nstatic bool\nignorable_failure (int error_number, char const *dir)\n{\n  return (ignore_fail_on_non_empty\n          && (errno_rmdir_non_empty (error_number)\n              || (errno_may_be_non_empty (error_number)\n                  && directory_status (AT_FDCWD, dir) == DS_NONEMPTY)));\n}\n\n \n\nstatic bool\nremove_parents (char *dir)\n{\n  char *slash;\n  bool ok = true;\n\n  strip_trailing_slashes (dir);\n  while (true)\n    {\n      slash = strrchr (dir, '/');\n      if (slash == nullptr)\n        break;\n       \n      while (slash > dir && *slash == '/')\n        --slash;\n      slash[1] = 0;\n\n       \n      if (verbose)\n        prog_fprintf (stdout, _(\"removing directory, %s\"), quoteaf (dir));\n\n      ok = (rmdir (dir) == 0);\n      int rmdir_errno = errno;\n\n      if (! ok)\n        {\n           \n          if (ignorable_failure (rmdir_errno, dir))\n            {\n              ok = true;\n            }\n          else\n            {\n              char const *error_msg;\n              if (rmdir_errno != ENOTDIR)\n                {\n                   \n                  error_msg = N_(\"failed to remove directory %s\");\n                }\n              else\n                {\n                   \n                  error_msg = N_(\"failed to remove %s\");\n                }\n              error (0, rmdir_errno, _(error_msg), quoteaf (dir));\n            }\n          break;\n        }\n    }\n  return ok;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... DIRECTORY...\\n\"), program_name);\n      fputs (_(\"\\\nRemove the DIRECTORY(ies), if they are empty.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --ignore-fail-on-non-empty\\n\\\n                    ignore each failure to remove a non-empty directory\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -p, --parents     remove DIRECTORY and its ancestors;\\n\\\n                    e.g., 'rmdir -p a/b' is similar to 'rmdir a/b a'\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --verbose     output a diagnostic for every directory processed\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool ok = true;\n  int optc;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  remove_empty_parents = false;\n\n  while ((optc = getopt_long (argc, argv, \"pv\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'p':\n          remove_empty_parents = true;\n          break;\n        case IGNORE_FAIL_ON_NON_EMPTY_OPTION:\n          ignore_fail_on_non_empty = true;\n          break;\n        case 'v':\n          verbose = true;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind == argc)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  for (; optind < argc; ++optind)\n    {\n      char *dir = argv[optind];\n\n      /* Give a diagnostic for each attempted removal if --verbose.  */\n      if (verbose)\n        prog_fprintf (stdout, _(\"removing directory, %s\"), quoteaf (dir));\n\n      if (rmdir (dir) != 0)\n        {\n          int rmdir_errno = errno;\n          if (ignorable_failure (rmdir_errno, dir))\n            continue;\n\n          /* Distinguish the case for a symlink with trailing slash.\n             On Linux, rmdir(2) confusingly does not follow the symlink,\n             thus giving the errno ENOTDIR, while on other systems the symlink\n             is followed.  We don't provide consistent behavior here,\n             but at least we provide a more accurate error message.  */\n          bool custom_error = false;\n          if (rmdir_errno == ENOTDIR)\n            {\n              char const *last_unix_slash = strrchr (dir, '/');\n              if (last_unix_slash && (*(last_unix_slash + 1) == '\\0'))\n                {\n                  struct stat st;\n                  int ret = stat (dir, &st);\n                  /* Some other issue following, or is actually a directory. */\n                  if ((ret != 0 && errno != ENOTDIR)\n                      || (ret == 0 && S_ISDIR (st.st_mode)))\n                    {\n                      /* Ensure the last component was a symlink.  */\n                      char *dir_arg = xstrdup (dir);\n                      strip_trailing_slashes (dir);\n                      ret = lstat (dir, &st);\n                      if (ret == 0 && S_ISLNK (st.st_mode))\n                        {\n                          error (0, 0,\n                                 _(\"failed to remove %s:\"\n                                   \" Symbolic link not followed\"),\n                                 quoteaf (dir_arg));\n                          custom_error = true;\n                        }\n                      free (dir_arg);\n                    }\n                }\n            }\n\n          if (! custom_error)\n            error (0, rmdir_errno, _(\"failed to remove %s\"), quoteaf (dir));\n\n          ok = false;\n        }\n      else if (remove_empty_parents)\n        {\n          ok &= remove_parents (dir);\n        }\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}