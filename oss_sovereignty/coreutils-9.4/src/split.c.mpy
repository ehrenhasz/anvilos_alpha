{
  "module_name": "split.c",
  "hash_id": "4cd3842b21f1a9dcdc3e7c78076d1495fea64b2e0b90cad5736175cd80c18b55",
  "original_prompt": "Ingested from coreutils-9.4/src/split.c",
  "human_readable_source": " \n#include <config.h>\n\n#include <stdckdint.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include \"system.h\"\n#include \"alignalloc.h\"\n#include \"assure.h\"\n#include \"fadvise.h\"\n#include \"fd-reopen.h\"\n#include \"fcntl--.h\"\n#include \"full-write.h\"\n#include \"ioblksize.h\"\n#include \"quote.h\"\n#include \"sig2str.h\"\n#include \"sys-limits.h\"\n#include \"temp-stream.h\"\n#include \"xbinary-io.h\"\n#include \"xdectoint.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"split\"\n\n#define AUTHORS \\\n  proper_name_lite (\"Torbjorn Granlund\", \"Torbj\\303\\266rn Granlund\"), \\\n  proper_name (\"Richard M. Stallman\")\n\n \nstatic char const *filter_command;\n\n \nstatic pid_t filter_pid;\n\n \nstatic int *open_pipes;\nstatic idx_t open_pipes_alloc;\nstatic int n_open_pipes;\n\n \nstatic bool default_SIGPIPE;\n\n \nstatic char const *outbase;\n\n \nstatic char *outfile;\n\n \nstatic char *outfile_mid;\n\n \nstatic bool suffix_auto = true;\n\n \nstatic idx_t suffix_length;\n\n \nstatic char const *suffix_alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n \nstatic char const *numeric_suffix_start;\n\n \nstatic char const *additional_suffix;\n\n \nstatic char *infile;\n\n \nstatic struct stat in_stat_buf;\n\n \nstatic int output_desc = -1;\n\n \nstatic bool verbose;\n\n \nstatic bool elide_empty_files;\n\n \nstatic bool unbuffered;\n\n \nstatic int eolchar = -1;\n\n \nenum Split_type\n{\n  type_undef, type_bytes, type_byteslines, type_lines, type_digits,\n  type_chunk_bytes, type_chunk_lines, type_rr\n};\n\n \nenum\n{\n  VERBOSE_OPTION = CHAR_MAX + 1,\n  FILTER_OPTION,\n  IO_BLKSIZE_OPTION,\n  ADDITIONAL_SUFFIX_OPTION\n};\n\nstatic struct option const longopts[] =\n{\n  {\"bytes\", required_argument, nullptr, 'b'},\n  {\"lines\", required_argument, nullptr, 'l'},\n  {\"line-bytes\", required_argument, nullptr, 'C'},\n  {\"number\", required_argument, nullptr, 'n'},\n  {\"elide-empty-files\", no_argument, nullptr, 'e'},\n  {\"unbuffered\", no_argument, nullptr, 'u'},\n  {\"suffix-length\", required_argument, nullptr, 'a'},\n  {\"additional-suffix\", required_argument, nullptr,\n   ADDITIONAL_SUFFIX_OPTION},\n  {\"numeric-suffixes\", optional_argument, nullptr, 'd'},\n  {\"hex-suffixes\", optional_argument, nullptr, 'x'},\n  {\"filter\", required_argument, nullptr, FILTER_OPTION},\n  {\"verbose\", no_argument, nullptr, VERBOSE_OPTION},\n  {\"separator\", required_argument, nullptr, 't'},\n  {\"-io-blksize\", required_argument, nullptr,\n   IO_BLKSIZE_OPTION},  \n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic inline bool\nignorable (int err)\n{\n  return filter_command && err == EPIPE;\n}\n\nstatic void\nset_suffix_length (intmax_t n_units, enum Split_type split_type)\n{\n#define DEFAULT_SUFFIX_LENGTH 2\n\n  int suffix_length_needed = 0;\n\n   \n  if (numeric_suffix_start)\n    suffix_auto = false;\n\n   \n  if (split_type == type_chunk_bytes || split_type == type_chunk_lines\n      || split_type == type_rr)\n    {\n      intmax_t n_units_end = n_units - 1;\n      if (numeric_suffix_start)\n        {\n          intmax_t n_start;\n          strtol_error e = xstrtoimax (numeric_suffix_start, nullptr, 10,\n                                       &n_start, \"\");\n          if (e == LONGINT_OK && n_start < n_units)\n            {\n               \n              if (ckd_add (&n_units_end, n_units_end, n_start))\n                n_units_end = INTMAX_MAX;\n            }\n\n        }\n      idx_t alphabet_len = strlen (suffix_alphabet);\n      do\n        suffix_length_needed++;\n      while (n_units_end /= alphabet_len);\n\n      suffix_auto = false;\n    }\n\n  if (suffix_length)             \n    {\n      if (suffix_length < suffix_length_needed)\n        error (EXIT_FAILURE, 0,\n               _(\"the suffix length needs to be at least %d\"),\n               suffix_length_needed);\n      suffix_auto = false;\n      return;\n    }\n  else\n    suffix_length = MAX (DEFAULT_SUFFIX_LENGTH, suffix_length_needed);\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE [PREFIX]]\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nOutput pieces of FILE to PREFIXaa, PREFIXab, ...;\\n\\\ndefault size is 1000 lines, and default PREFIX is 'x'.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fprintf (stdout, _(\"\\\n  -a, --suffix-length=N   generate suffixes of length N (default %d)\\n\\\n      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\\n\\\n  -b, --bytes=SIZE        put SIZE bytes per output file\\n\\\n  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\\n\\\n  -d                      use numeric suffixes starting at 0, not alphabetic\\n\\\n      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value\\\n\\n\\\n  -x                      use hex suffixes starting at 0, not alphabetic\\n\\\n      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\\n\\\n  -e, --elide-empty-files  do not generate empty output files with '-n'\\n\\\n      --filter=COMMAND    write to shell COMMAND; file name is $FILE\\n\\\n  -l, --lines=NUMBER      put NUMBER lines/records per output file\\n\\\n  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below\\n\\\n  -t, --separator=SEP     use SEP instead of newline as the record separator;\\n\\\n                            '\\\\0' (zero) specifies the NUL character\\n\\\n  -u, --unbuffered        immediately copy input to output with '-n r/...'\\n\\\n\"), DEFAULT_SUFFIX_LENGTH);\n      fputs (_(\"\\\n      --verbose           print a diagnostic just before each\\n\\\n                            output file is opened\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_size_note ();\n      fputs (_(\"\\n\\\nCHUNKS may be:\\n\\\n  N       split into N files based on size of input\\n\\\n  K/N     output Kth of N to stdout\\n\\\n  l/N     split into N files without splitting lines/records\\n\\\n  l/K/N   output Kth of N to stdout without splitting lines/records\\n\\\n  r/N     like 'l' but use round robin distribution\\n\\\n  r/K/N   likewise but only output Kth of N to stdout\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Copy the data in FD to a temporary file, then make that file FD.\n   Use BUF, of size BUFSIZE, to copy.  Return the number of\n   bytes copied, or -1 (setting errno) on error.  */\nstatic off_t\ncopy_to_tmpfile (int fd, char *buf, idx_t bufsize)\n{\n  FILE *tmp;\n  if (!temp_stream (&tmp, nullptr))\n    return -1;\n  off_t copied = 0;\n  off_t r;\n\n  while (0 < (r = read (fd, buf, bufsize)))\n    {\n      if (fwrite (buf, 1, r, tmp) != r)\n        return -1;\n      if (ckd_add (&copied, copied, r))\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n    }\n\n  if (r < 0)\n    return r;\n  r = dup2 (fileno (tmp), fd);\n  if (r < 0)\n    return r;\n  if (fclose (tmp) < 0)\n    return -1;\n  return copied;\n}\n\n/* Return the number of bytes that can be read from FD with status ST.\n   Store up to the first BUFSIZE bytes of the file's data into BUF,\n   and advance the file position by the number of bytes read.  On\n   input error, set errno and return -1.  */\n\nstatic off_t\ninput_file_size (int fd, struct stat const *st, char *buf, idx_t bufsize)\n{\n  off_t size = 0;\n  do\n    {\n      ssize_t n_read = read (fd, buf + size, bufsize - size);\n      if (n_read <= 0)\n        return n_read < 0 ? n_read : size;\n      size += n_read;\n    }\n  while (size < bufsize);\n\n  off_t cur, end;\n  if ((usable_st_size (st) && st->st_size < size)\n      || (cur = lseek (fd, 0, SEEK_CUR)) < 0\n      || cur < size /* E.g., /dev/zero on GNU/Linux.  */\n      || (end = lseek (fd, 0, SEEK_END)) < 0)\n    {\n      char *tmpbuf = xmalloc (bufsize);\n      end = copy_to_tmpfile (fd, tmpbuf, bufsize);\n      free (tmpbuf);\n      if (end < 0)\n        return end;\n      cur = 0;\n    }\n\n  if (end == OFF_T_MAX /* E.g., /dev/zero on GNU/Hurd.  */\n      || (cur < end && ckd_add (&size, size, end - cur)))\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  if (cur < end)\n    {\n      off_t r = lseek (fd, cur, SEEK_SET);\n      if (r < 0)\n        return r;\n    }\n\n  return size;\n}\n\n/* Compute the next sequential output file name and store it into the\n   string 'outfile'.  */\n\nstatic void\nnext_file_name (void)\n{\n  /* Index in suffix_alphabet of each character in the suffix.  */\n  static idx_t *sufindex;\n  static idx_t outbase_length;\n  static idx_t outfile_length;\n  static idx_t addsuf_length;\n\n  if (! outfile)\n    {\n      bool overflow, widen;\n\nnew_name:\n      widen = !! outfile_length;\n\n      if (! widen)\n        {\n          /* Allocate and initialize the first file name.  */\n\n          outbase_length = strlen (outbase);\n          addsuf_length = additional_suffix ? strlen (additional_suffix) : 0;\n          overflow = ckd_add (&outfile_length, outbase_length + addsuf_length,\n                              suffix_length);\n        }\n      else\n        {\n          /* Reallocate and initialize a new wider file name.\n             We do this by subsuming the unchanging part of\n             the generated suffix into the prefix (base), and\n             reinitializing the now one longer suffix.  */\n\n          overflow = ckd_add (&outfile_length, outfile_length, 2);\n          suffix_length++;\n        }\n\n      idx_t outfile_size;\n      overflow |= ckd_add (&outfile_size, outfile_length, 1);\n      if (overflow)\n        xalloc_die ();\n      outfile = xirealloc (outfile, outfile_size);\n\n      if (! widen)\n        memcpy (outfile, outbase, outbase_length);\n      else\n        {\n          /* Append the last alphabet character to the file name prefix.  */\n          outfile[outbase_length] = suffix_alphabet[sufindex[0]];\n          outbase_length++;\n        }\n\n      outfile_mid = outfile + outbase_length;\n      memset (outfile_mid, suffix_alphabet[0], suffix_length);\n      if (additional_suffix)\n        memcpy (outfile_mid + suffix_length, additional_suffix, addsuf_length);\n      outfile[outfile_length] = 0;\n\n      free (sufindex);\n      sufindex = xicalloc (suffix_length, sizeof *sufindex);\n\n      if (numeric_suffix_start)\n        {\n          affirm (! widen);\n\n          /* Update the output file name.  */\n          idx_t i = strlen (numeric_suffix_start);\n          memcpy (outfile_mid + suffix_length - i, numeric_suffix_start, i);\n\n          /* Update the suffix index.  */\n          idx_t *sufindex_end = sufindex + suffix_length;\n          while (i-- != 0)\n            *--sufindex_end = numeric_suffix_start[i] - '0';\n        }\n\n#if ! _POSIX_NO_TRUNC && HAVE_PATHCONF && defined _PC_NAME_MAX\n      /* POSIX requires that if the output file name is too long for\n         its directory, 'split' must fail without creating any files.\n         This must be checked for explicitly on operating systems that\n         silently truncate file names.  */\n      {\n        char *dir = dir_name (outfile);\n        long name_max = pathconf (dir, _PC_NAME_MAX);\n        if (0 <= name_max && name_max < base_len (last_component (outfile)))\n          error (EXIT_FAILURE, ENAMETOOLONG, \"%s\", quotef (outfile));\n        free (dir);\n      }\n#endif\n    }\n  else\n    {\n      /* Increment the suffix in place, if possible.  */\n\n      idx_t i = suffix_length;\n      while (i-- != 0)\n        {\n          sufindex[i]++;\n          if (suffix_auto && i == 0 && ! suffix_alphabet[sufindex[0] + 1])\n            goto new_name;\n          outfile_mid[i] = suffix_alphabet[sufindex[i]];\n          if (outfile_mid[i])\n            return;\n          sufindex[i] = 0;\n          outfile_mid[i] = suffix_alphabet[sufindex[i]];\n        }\n      error (EXIT_FAILURE, 0, _(\"output file suffixes exhausted\"));\n    }\n}\n\n/* Create or truncate a file.  */\n\nstatic int\ncreate (char const *name)\n{\n  if (!filter_command)\n    {\n      if (verbose)\n        fprintf (stdout, _(\"creating file %s\\n\"), quoteaf (name));\n\n      int oflags = O_WRONLY | O_CREAT | O_BINARY;\n      int fd = open (name, oflags | O_EXCL, MODE_RW_UGO);\n      if (0 <= fd || errno != EEXIST)\n        return fd;\n      fd = open (name, oflags, MODE_RW_UGO);\n      if (fd < 0)\n        return fd;\n      struct stat out_stat_buf;\n      if (fstat (fd, &out_stat_buf) != 0)\n        error (EXIT_FAILURE, errno, _(\"failed to stat %s\"), quoteaf (name));\n      if (SAME_INODE (in_stat_buf, out_stat_buf))\n        error (EXIT_FAILURE, 0, _(\"%s would overwrite input; aborting\"),\n               quoteaf (name));\n      bool regularish\n        = S_ISREG (out_stat_buf.st_mode) || S_TYPEISSHM (&out_stat_buf);\n      if (! (regularish && out_stat_buf.st_size == 0)\n          && ftruncate (fd, 0) < 0 && regularish)\n        error (EXIT_FAILURE, errno, _(\"%s: error truncating\"), quotef (name));\n\n      return fd;\n    }\n  else\n    {\n      int fd_pair[2];\n      pid_t child_pid;\n      char const *shell_prog = getenv (\"SHELL\");\n      if (shell_prog == nullptr)\n        shell_prog = \"/bin/sh\";\n      if (setenv (\"FILE\", name, 1) != 0)\n        error (EXIT_FAILURE, errno,\n               _(\"failed to set FILE environment variable\"));\n      if (verbose)\n        fprintf (stdout, _(\"executing with FILE=%s\\n\"), quotef (name));\n      if (pipe (fd_pair) != 0)\n        error (EXIT_FAILURE, errno, _(\"failed to create pipe\"));\n      child_pid = fork ();\n      if (child_pid == 0)\n        {\n          /* This is the child process.  If an error occurs here, the\n             parent will eventually learn about it after doing a wait,\n             at which time it will emit its own error message.  */\n          int j;\n          /* We have to close any pipes that were opened during an\n             earlier call, otherwise this process will be holding a\n             write-pipe that will prevent the earlier process from\n             reading an EOF on the corresponding read-pipe.  */\n          for (j = 0; j < n_open_pipes; ++j)\n            if (close (open_pipes[j]) != 0)\n              error (EXIT_FAILURE, errno, _(\"closing prior pipe\"));\n          if (close (fd_pair[1]))\n            error (EXIT_FAILURE, errno, _(\"closing output pipe\"));\n          if (fd_pair[0] != STDIN_FILENO)\n            {\n              if (dup2 (fd_pair[0], STDIN_FILENO) != STDIN_FILENO)\n                error (EXIT_FAILURE, errno, _(\"moving input pipe\"));\n              if (close (fd_pair[0]) != 0)\n                error (EXIT_FAILURE, errno, _(\"closing input pipe\"));\n            }\n          if (default_SIGPIPE)\n            signal (SIGPIPE, SIG_DFL);\n          execl (shell_prog, last_component (shell_prog), \"-c\",\n                 filter_command, (char *) nullptr);\n          error (EXIT_FAILURE, errno, _(\"failed to run command: \\\"%s -c %s\\\"\"),\n                 shell_prog, filter_command);\n        }\n      if (child_pid < 0)\n        error (EXIT_FAILURE, errno, _(\"fork system call failed\"));\n      if (close (fd_pair[0]) != 0)\n        error (EXIT_FAILURE, errno, _(\"failed to close input pipe\"));\n      filter_pid = child_pid;\n      if (n_open_pipes == open_pipes_alloc)\n        open_pipes = xpalloc (open_pipes, &open_pipes_alloc, 1,\n                              MIN (INT_MAX, IDX_MAX), sizeof *open_pipes);\n      open_pipes[n_open_pipes++] = fd_pair[1];\n      return fd_pair[1];\n    }\n}\n\n \nstatic void\ncloseout (FILE *fp, int fd, pid_t pid, char const *name)\n{\n  if (fp != nullptr && fclose (fp) != 0 && ! ignorable (errno))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (name));\n  if (fd >= 0)\n    {\n      if (fp == nullptr && close (fd) < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (name));\n      int j;\n      for (j = 0; j < n_open_pipes; ++j)\n        {\n          if (open_pipes[j] == fd)\n            {\n              open_pipes[j] = open_pipes[--n_open_pipes];\n              break;\n            }\n        }\n    }\n  if (pid > 0)\n    {\n      int wstatus;\n      if (waitpid (pid, &wstatus, 0) < 0)\n        error (EXIT_FAILURE, errno, _(\"waiting for child process\"));\n      else if (WIFSIGNALED (wstatus))\n        {\n          int sig = WTERMSIG (wstatus);\n          if (sig != SIGPIPE)\n            {\n              char signame[MAX (SIG2STR_MAX, INT_BUFSIZE_BOUND (int))];\n              if (sig2str (sig, signame) != 0)\n                sprintf (signame, \"%d\", sig);\n              error (sig + 128, 0,\n                     _(\"with FILE=%s, signal %s from command: %s\"),\n                     quotef (name), signame, filter_command);\n            }\n        }\n      else if (WIFEXITED (wstatus))\n        {\n          int ex = WEXITSTATUS (wstatus);\n          if (ex != 0)\n            error (ex, 0, _(\"with FILE=%s, exit %d from command: %s\"),\n                   quotef (name), ex, filter_command);\n        }\n      else\n        {\n           \n          error (EXIT_FAILURE, 0,\n                 _(\"unknown status from command (0x%X)\"), wstatus + 0u);\n        }\n    }\n}\n\n \n\nstatic bool\ncwrite (bool new_file_flag, char const *bp, idx_t bytes)\n{\n  if (new_file_flag)\n    {\n      if (!bp && bytes == 0 && elide_empty_files)\n        return true;\n      closeout (nullptr, output_desc, filter_pid, outfile);\n      next_file_name ();\n      output_desc = create (outfile);\n      if (output_desc < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (outfile));\n    }\n\n  if (full_write (output_desc, bp, bytes) == bytes)\n    return true;\n  else\n    {\n      if (! ignorable (errno))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (outfile));\n      return false;\n    }\n}\n\n \n\nstatic void\nbytes_split (intmax_t n_bytes, intmax_t rem_bytes,\n             char *buf, idx_t bufsize, ssize_t initial_read,\n             intmax_t max_files)\n{\n  bool new_file_flag = true;\n  bool filter_ok = true;\n  intmax_t opened = 0;\n  intmax_t to_write = n_bytes + (0 < rem_bytes);\n  bool eof = ! to_write;\n\n  while (! eof)\n    {\n      ssize_t n_read;\n      if (0 <= initial_read)\n        {\n          n_read = initial_read;\n          initial_read = -1;\n          eof = n_read < bufsize;\n        }\n      else\n        {\n          if (! filter_ok\n              && 0 <= lseek (STDIN_FILENO, to_write, SEEK_CUR))\n            {\n              to_write = n_bytes + (opened + 1 < rem_bytes);\n              new_file_flag = true;\n            }\n\n          n_read = read (STDIN_FILENO, buf, bufsize);\n          if (n_read < 0)\n            error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n          eof = n_read == 0;\n        }\n      char *bp_out = buf;\n      while (0 < to_write && to_write <= n_read)\n        {\n          if (filter_ok || new_file_flag)\n            filter_ok = cwrite (new_file_flag, bp_out, to_write);\n          opened += new_file_flag;\n          new_file_flag = !max_files || (opened < max_files);\n          if (! filter_ok && ! new_file_flag)\n            {\n               \n              n_read = 0;\n              eof = true;\n              break;\n            }\n          bp_out += to_write;\n          n_read -= to_write;\n          to_write = n_bytes + (opened < rem_bytes);\n        }\n      if (0 < n_read)\n        {\n          if (filter_ok || new_file_flag)\n            filter_ok = cwrite (new_file_flag, bp_out, n_read);\n          opened += new_file_flag;\n          new_file_flag = false;\n          if (! filter_ok && opened == max_files)\n            {\n               \n              break;\n            }\n          to_write -= n_read;\n        }\n    }\n\n   \n  while (opened++ < max_files)\n    cwrite (true, nullptr, 0);\n}\n\n \n\nstatic void\nlines_split (intmax_t n_lines, char *buf, idx_t bufsize)\n{\n  ssize_t n_read;\n  char *bp, *bp_out, *eob;\n  bool new_file_flag = true;\n  intmax_t n = 0;\n\n  do\n    {\n      n_read = read (STDIN_FILENO, buf, bufsize);\n      if (n_read < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n      bp = bp_out = buf;\n      eob = bp + n_read;\n      *eob = eolchar;\n      while (true)\n        {\n          bp = rawmemchr (bp, eolchar);\n          if (bp == eob)\n            {\n              if (eob != bp_out)  \n                {\n                  idx_t len = eob - bp_out;\n                  cwrite (new_file_flag, bp_out, len);\n                  new_file_flag = false;\n                }\n              break;\n            }\n\n          ++bp;\n          if (++n >= n_lines)\n            {\n              cwrite (new_file_flag, bp_out, bp - bp_out);\n              bp_out = bp;\n              new_file_flag = true;\n              n = 0;\n            }\n        }\n    }\n  while (n_read);\n}\n\n \n\nstatic void\nline_bytes_split (intmax_t n_bytes, char *buf, idx_t bufsize)\n{\n  ssize_t n_read;\n  intmax_t n_out = 0;       \n  idx_t n_hold = 0;\n  char *hold = nullptr;         \n  idx_t hold_size = 0;\n  bool split_line = false;   \n\n  do\n    {\n      n_read = read (STDIN_FILENO, buf, bufsize);\n      if (n_read < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n      idx_t n_left = n_read;\n      char *sob = buf;\n      while (n_left)\n        {\n          idx_t split_rest = 0;\n          char *eoc = nullptr;\n          char *eol;\n\n           \n          if (n_bytes - n_out - n_hold <= n_left)\n            {\n               \n              split_rest = n_bytes - n_out - n_hold;\n              eoc = sob + split_rest - 1;\n              eol = memrchr (sob, eolchar, split_rest);\n            }\n          else\n            eol = memrchr (sob, eolchar, n_left);\n\n           \n          if (n_hold && !(!eol && n_out))\n            {\n              cwrite (n_out == 0, hold, n_hold);\n              n_out += n_hold;\n              if (n_hold > bufsize)\n                hold = xirealloc (hold, bufsize);\n              n_hold = 0;\n              hold_size = bufsize;\n            }\n\n           \n          if (eol)\n            {\n              split_line = true;\n              idx_t n_write = eol - sob + 1;\n              cwrite (n_out == 0, sob, n_write);\n              n_out += n_write;\n              n_left -= n_write;\n              sob += n_write;\n              if (eoc)\n                split_rest -= n_write;\n            }\n\n           \n          if (n_left && !split_line)\n            {\n              idx_t n_write = eoc ? split_rest : n_left;\n              cwrite (n_out == 0, sob, n_write);\n              n_out += n_write;\n              n_left -= n_write;\n              sob += n_write;\n              if (eoc)\n                split_rest -= n_write;\n            }\n\n           \n          if ((eoc && split_rest) || (!eoc && n_left))\n            {\n              idx_t n_buf = eoc ? split_rest : n_left;\n              if (hold_size - n_hold < n_buf)\n                hold = xpalloc (hold, &hold_size, n_buf - (hold_size - n_hold),\n                                -1, sizeof *hold);\n              memcpy (hold + n_hold, sob, n_buf);\n              n_hold += n_buf;\n              n_left -= n_buf;\n              sob += n_buf;\n            }\n\n           \n          if (eoc)\n            {\n              n_out = 0;\n              split_line = false;\n            }\n        }\n    }\n  while (n_read);\n\n   \n  if (n_hold)\n    cwrite (n_out == 0, hold, n_hold);\n\n  free (hold);\n}\n\n \n\nstatic void\nlines_chunk_split (intmax_t k, intmax_t n, char *buf, idx_t bufsize,\n                   ssize_t initial_read, off_t file_size)\n{\n  affirm (n && k <= n);\n\n  intmax_t rem_bytes = file_size % n;\n  off_t chunk_size = file_size / n;\n  intmax_t chunk_no = 1;\n  off_t chunk_end = chunk_size + (0 < rem_bytes);\n  off_t n_written = 0;\n  bool new_file_flag = true;\n  bool chunk_truncated = false;\n\n  if (k > 1 && 0 < file_size)\n    {\n       \n      off_t start = (k - 1) * chunk_size + MIN (k - 1, rem_bytes) - 1;\n      if (start < initial_read)\n        {\n          memmove (buf, buf + start, initial_read - start);\n          initial_read -= start;\n        }\n      else\n        {\n          if (initial_read < start\n              && lseek (STDIN_FILENO, start - initial_read, SEEK_CUR) < 0)\n            error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n          initial_read = -1;\n        }\n      n_written = start;\n      chunk_no = k - 1;\n      chunk_end = start + 1;\n    }\n\n  while (n_written < file_size)\n    {\n      char *bp = buf, *eob;\n      ssize_t n_read;\n      if (0 <= initial_read)\n        {\n          n_read = initial_read;\n          initial_read = -1;\n        }\n      else\n        {\n          n_read = read (STDIN_FILENO, buf,\n                         MIN (bufsize, file_size - n_written));\n          if (n_read < 0)\n            error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n        }\n      if (n_read == 0)\n        break;  \n      chunk_truncated = false;\n      eob = buf + n_read;\n\n      while (bp != eob)\n        {\n          idx_t to_write;\n          bool next = false;\n\n           \n          off_t skip = MIN (n_read, MAX (0, chunk_end - 1 - n_written));\n          char *bp_out = memchr (bp + skip, eolchar, n_read - skip);\n          if (bp_out)\n            {\n              bp_out++;\n              next = true;\n            }\n          else\n            bp_out = eob;\n          to_write = bp_out - bp;\n\n          if (k == chunk_no)\n            {\n               \n              if (full_write (STDOUT_FILENO, bp, to_write) != to_write)\n                write_error ();\n            }\n          else if (! k)\n            cwrite (new_file_flag, bp, to_write);\n          n_written += to_write;\n          bp += to_write;\n          n_read -= to_write;\n          new_file_flag = next;\n\n           \n          while (next || chunk_end <= n_written)\n            {\n              if (!next && bp == eob)\n                {\n                   \n                  chunk_truncated = true;\n                  break;\n                }\n              if (k == chunk_no)\n                return;\n              chunk_end += chunk_size + (chunk_no < rem_bytes);\n              chunk_no++;\n              if (chunk_end <= n_written)\n                {\n                  if (! k)\n                    cwrite (true, nullptr, 0);\n                }\n              else\n                next = false;\n            }\n        }\n    }\n\n  if (chunk_truncated)\n    chunk_no++;\n\n   \n  if (!k)\n    while (chunk_no++ <= n)\n      cwrite (true, nullptr, 0);\n}\n\n \n\nstatic void\nbytes_chunk_extract (intmax_t k, intmax_t n, char *buf, idx_t bufsize,\n                     ssize_t initial_read, off_t file_size)\n{\n  off_t start;\n  off_t end;\n\n  assert (0 < k && k <= n);\n\n  start = (k - 1) * (file_size / n) + MIN (k - 1, file_size % n);\n  end = k == n ? file_size : k * (file_size / n) + MIN (k, file_size % n);\n\n  if (start < initial_read)\n    {\n      memmove (buf, buf + start, initial_read - start);\n      initial_read -= start;\n    }\n  else\n    {\n      if (initial_read < start\n          && lseek (STDIN_FILENO, start - initial_read, SEEK_CUR) < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n      initial_read = -1;\n    }\n\n  while (start < end)\n    {\n      ssize_t n_read;\n      if (0 <= initial_read)\n        {\n          n_read = initial_read;\n          initial_read = -1;\n        }\n      else\n        {\n          n_read = read (STDIN_FILENO, buf, bufsize);\n          if (n_read < 0)\n            error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n        }\n      if (n_read == 0)\n        break;  \n      n_read = MIN (n_read, end - start);\n      if (full_write (STDOUT_FILENO, buf, n_read) != n_read\n          && ! ignorable (errno))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (\"-\"));\n      start += n_read;\n    }\n}\n\ntypedef struct of_info\n{\n  char *of_name;\n  int ofd;\n  FILE *ofile;\n  pid_t opid;\n} of_t;\n\nenum\n{\n  OFD_NEW = -1,\n  OFD_APPEND = -2\n};\n\n \n\nstatic bool\nofile_open (of_t *files, idx_t i_check, idx_t nfiles)\n{\n  bool file_limit = false;\n\n  if (files[i_check].ofd <= OFD_NEW)\n    {\n      int fd;\n      idx_t i_reopen = i_check ? i_check - 1 : nfiles - 1;\n\n       \n      while (true)\n        {\n          if (files[i_check].ofd == OFD_NEW)\n            fd = create (files[i_check].of_name);\n          else  \n            {\n               \n              fd = open (files[i_check].of_name,\n                         O_WRONLY | O_BINARY | O_APPEND | O_NONBLOCK);\n            }\n\n          if (0 <= fd)\n            break;\n\n          if (!(errno == EMFILE || errno == ENFILE))\n            error (EXIT_FAILURE, errno, \"%s\", quotef (files[i_check].of_name));\n\n          file_limit = true;\n\n           \n          while (files[i_reopen].ofd < 0)\n            {\n              i_reopen = i_reopen ? i_reopen - 1 : nfiles - 1;\n               \n              if (i_reopen == i_check)\n                error (EXIT_FAILURE, errno, \"%s\",\n                       quotef (files[i_check].of_name));\n            }\n\n          if (fclose (files[i_reopen].ofile) != 0)\n            error (EXIT_FAILURE, errno, \"%s\", quotef (files[i_reopen].of_name));\n          files[i_reopen].ofile = nullptr;\n          files[i_reopen].ofd = OFD_APPEND;\n        }\n\n      files[i_check].ofd = fd;\n      FILE *ofile = fdopen (fd, \"a\");\n      if (!ofile)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (files[i_check].of_name));\n      files[i_check].ofile = ofile;\n      files[i_check].opid = filter_pid;\n      filter_pid = 0;\n    }\n\n  return file_limit;\n}\n\n \n\nstatic void\nlines_rr (intmax_t k, intmax_t n, char *buf, idx_t bufsize, of_t **filesp)\n{\n  bool wrapped = false;\n  bool wrote = false;\n  bool file_limit;\n  idx_t i_file;\n  of_t *files IF_LINT (= nullptr);\n  intmax_t line_no;\n\n  if (k)\n    line_no = 1;\n  else\n    {\n      if (IDX_MAX < n)\n        xalloc_die ();\n      files = *filesp = xinmalloc (n, sizeof *files);\n\n       \n      for (i_file = 0; i_file < n; i_file++)\n        {\n          next_file_name ();\n          files[i_file].of_name = xstrdup (outfile);\n          files[i_file].ofd = OFD_NEW;\n          files[i_file].ofile = nullptr;\n          files[i_file].opid = 0;\n        }\n      i_file = 0;\n      file_limit = false;\n    }\n\n  while (true)\n    {\n      char *bp = buf, *eob;\n      ssize_t n_read = read (STDIN_FILENO, buf, bufsize);\n      if (n_read < 0)\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n      else if (n_read == 0)\n        break;  \n      eob = buf + n_read;\n\n      while (bp != eob)\n        {\n          idx_t to_write;\n          bool next = false;\n\n           \n          char *bp_out = memchr (bp, eolchar, eob - bp);\n          if (bp_out)\n            {\n              bp_out++;\n              next = true;\n            }\n          else\n            bp_out = eob;\n          to_write = bp_out - bp;\n\n          if (k)\n            {\n              if (line_no == k && unbuffered)\n                {\n                  if (full_write (STDOUT_FILENO, bp, to_write) != to_write)\n                    write_error ();\n                }\n              else if (line_no == k && fwrite (bp, to_write, 1, stdout) != 1)\n                {\n                  write_error ();\n                }\n              if (next)\n                line_no = (line_no == n) ? 1 : line_no + 1;\n            }\n          else\n            {\n               \n              file_limit |= ofile_open (files, i_file, n);\n              if (unbuffered)\n                {\n                   \n                  if (full_write (files[i_file].ofd, bp, to_write) != to_write\n                      && ! ignorable (errno))\n                    error (EXIT_FAILURE, errno, \"%s\",\n                           quotef (files[i_file].of_name));\n                }\n              else if (fwrite (bp, to_write, 1, files[i_file].ofile) != 1\n                       && ! ignorable (errno))\n                error (EXIT_FAILURE, errno, \"%s\",\n                       quotef (files[i_file].of_name));\n\n              if (! ignorable (errno))\n                wrote = true;\n\n              if (file_limit)\n                {\n                  if (fclose (files[i_file].ofile) != 0)\n                    error (EXIT_FAILURE, errno, \"%s\",\n                           quotef (files[i_file].of_name));\n                  files[i_file].ofile = nullptr;\n                  files[i_file].ofd = OFD_APPEND;\n                }\n              if (next && ++i_file == n)\n                {\n                  wrapped = true;\n                   \n                  if (! wrote)\n                    goto no_filters;\n                  wrote = false;\n                  i_file = 0;\n                }\n            }\n\n          bp = bp_out;\n        }\n    }\n\nno_filters:\n   \n  if (!k)\n    {\n      idx_t ceiling = wrapped ? n : i_file;\n      for (i_file = 0; i_file < n; i_file++)\n        {\n          if (i_file >= ceiling && !elide_empty_files)\n            file_limit |= ofile_open (files, i_file, n);\n          if (files[i_file].ofd >= 0)\n            closeout (files[i_file].ofile, files[i_file].ofd,\n                      files[i_file].opid, files[i_file].of_name);\n          files[i_file].ofd = OFD_APPEND;\n        }\n    }\n}\n\n#define FAIL_ONLY_ONE_WAY()\t\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n      error (0, 0, _(\"cannot split in more than one way\"));\t\\\n      usage (EXIT_FAILURE);\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  while (0)\n\n \n\nstatic _Noreturn void\nstrtoint_die (char const *msgid, char const *arg)\n{\n  error (EXIT_FAILURE, errno == EINVAL ? 0 : errno, \"%s: %s\",\n         gettext (msgid), quote (arg));\n}\n\n \n#define OVERFLOW_OK LONGINT_OVERFLOW\n\n \n\nstatic intmax_t\nparse_n_units (char const *arg, char const *multipliers, char const *msgid)\n{\n  intmax_t n;\n  if (OVERFLOW_OK < xstrtoimax (arg, nullptr, 10, &n, multipliers) || n < 1)\n    strtoint_die (msgid, arg);\n  return n;\n}\n\n \n\nstatic void\nparse_chunk (intmax_t *k_units, intmax_t *n_units, char const *arg)\n{\n  char *argend;\n  strtol_error e = xstrtoimax (arg, &argend, 10, n_units, \"\");\n  if (e == LONGINT_INVALID_SUFFIX_CHAR && *argend == '/')\n    {\n      *k_units = *n_units;\n      *n_units = parse_n_units (argend + 1, \"\",\n                                N_(\"invalid number of chunks\"));\n      if (! (0 < *k_units && *k_units <= *n_units))\n        error (EXIT_FAILURE, 0, \"%s: %s\", _(\"invalid chunk number\"),\n               quote_mem (arg, argend - arg));\n    }\n  else if (! (e <= OVERFLOW_OK && 0 < *n_units))\n    strtoint_die (N_(\"invalid number of chunks\"), arg);\n}\n\n\nint\nmain (int argc, char **argv)\n{\n  enum Split_type split_type = type_undef;\n  idx_t in_blk_size = 0;\t \n  idx_t page_size = getpagesize ();\n  intmax_t k_units = 0;\n  intmax_t n_units = 0;\n\n  static char const multipliers[] = \"bEGKkMmPQRTYZ0\";\n  int c;\n  int digits_optind = 0;\n  off_t file_size = OFF_T_MAX;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n   \n\n  infile = bad_cast (\"-\");\n  outbase = bad_cast (\"x\");\n\n  while (true)\n    {\n       \n      int this_optind = optind ? optind : 1;\n\n      c = getopt_long (argc, argv, \"0123456789C:a:b:del:n:t:ux\",\n                       longopts, nullptr);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 'a':\n          suffix_length = xdectoimax (optarg, 0, IDX_MAX,\n                                      \"\", _(\"invalid suffix length\"), 0);\n          break;\n\n        case ADDITIONAL_SUFFIX_OPTION:\n          {\n            int suffix_len = strlen (optarg);\n            if (last_component (optarg) != optarg\n                || (suffix_len && ISSLASH (optarg[suffix_len - 1])))\n              {\n                error (0, 0,\n                       _(\"invalid suffix %s, contains directory separator\"),\n                       quote (optarg));\n                usage (EXIT_FAILURE);\n              }\n          }\n          additional_suffix = optarg;\n          break;\n\n        case 'b':\n          if (split_type != type_undef)\n            FAIL_ONLY_ONE_WAY ();\n          split_type = type_bytes;\n          n_units = parse_n_units (optarg, multipliers,\n                                   N_(\"invalid number of bytes\"));\n          break;\n\n        case 'l':\n          if (split_type != type_undef)\n            FAIL_ONLY_ONE_WAY ();\n          split_type = type_lines;\n          n_units = parse_n_units (optarg, \"\", N_(\"invalid number of lines\"));\n          break;\n\n        case 'C':\n          if (split_type != type_undef)\n            FAIL_ONLY_ONE_WAY ();\n          split_type = type_byteslines;\n          n_units = parse_n_units (optarg, multipliers,\n                                   N_(\"invalid number of lines\"));\n          break;\n\n        case 'n':\n          if (split_type != type_undef)\n            FAIL_ONLY_ONE_WAY ();\n           \n          while (isspace (to_uchar (*optarg)))\n            optarg++;\n          if (STRNCMP_LIT (optarg, \"r/\") == 0)\n            {\n              split_type = type_rr;\n              optarg += 2;\n            }\n          else if (STRNCMP_LIT (optarg, \"l/\") == 0)\n            {\n              split_type = type_chunk_lines;\n              optarg += 2;\n            }\n          else\n            split_type = type_chunk_bytes;\n          parse_chunk (&k_units, &n_units, optarg);\n          break;\n\n        case 'u':\n          unbuffered = true;\n          break;\n\n        case 't':\n          {\n            char neweol = optarg[0];\n            if (! neweol)\n              error (EXIT_FAILURE, 0, _(\"empty record separator\"));\n            if (optarg[1])\n              {\n                if (STREQ (optarg, \"\\\\0\"))\n                  neweol = '\\0';\n                else\n                  {\n                     \n                    error (EXIT_FAILURE, 0, _(\"multi-character separator %s\"),\n                           quote (optarg));\n                  }\n              }\n             \n            if (0 <= eolchar && neweol != eolchar)\n              {\n                error (EXIT_FAILURE, 0,\n                       _(\"multiple separator characters specified\"));\n              }\n\n            eolchar = neweol;\n          }\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (split_type == type_undef)\n            {\n              split_type = type_digits;\n              n_units = 0;\n            }\n          if (split_type != type_undef && split_type != type_digits)\n            FAIL_ONLY_ONE_WAY ();\n          if (digits_optind != 0 && digits_optind != this_optind)\n            n_units = 0;\t \n          digits_optind = this_optind;\n          if (ckd_mul (&n_units, n_units, 10)\n              || ckd_add (&n_units, n_units, c - '0'))\n            n_units = INTMAX_MAX;\n          break;\n\n        case 'd':\n        case 'x':\n          if (c == 'd')\n            suffix_alphabet = \"0123456789\";\n          else\n            suffix_alphabet = \"0123456789abcdef\";\n          if (optarg)\n            {\n              if (strlen (optarg) != strspn (optarg, suffix_alphabet))\n                {\n                  error (0, 0,\n                         (c == 'd') ?\n                           _(\"%s: invalid start value for numerical suffix\") :\n                           _(\"%s: invalid start value for hexadecimal suffix\"),\n                         quote (optarg));\n                  usage (EXIT_FAILURE);\n                }\n              else\n                {\n                   \n                  while (*optarg == '0' && *(optarg + 1) != '\\0')\n                    optarg++;\n                  numeric_suffix_start = optarg;\n                }\n            }\n          break;\n\n        case 'e':\n          elide_empty_files = true;\n          break;\n\n        case FILTER_OPTION:\n          filter_command = optarg;\n          break;\n\n        case IO_BLKSIZE_OPTION:\n          in_blk_size = xdectoumax (optarg, 1,\n                                    MIN (SYS_BUFSIZE_MAX,\n                                         MIN (IDX_MAX, SIZE_MAX) - 1),\n                                    multipliers, _(\"invalid IO block size\"), 0);\n          break;\n\n        case VERBOSE_OPTION:\n          verbose = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (k_units != 0 && filter_command)\n    {\n      error (0, 0, _(\"--filter does not process a chunk extracted to stdout\"));\n      usage (EXIT_FAILURE);\n    }\n\n   \n  if (split_type == type_undef)\n    {\n      split_type = type_lines;\n      n_units = 1000;\n    }\n\n  if (n_units == 0)\n    {\n      error (0, 0, _(\"invalid number of lines: %s\"), quote (\"0\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (eolchar < 0)\n    eolchar = '\\n';\n\n  set_suffix_length (n_units, split_type);\n\n   \n\n  if (optind < argc)\n    infile = argv[optind++];\n\n  if (optind < argc)\n    outbase = argv[optind++];\n\n  if (optind < argc)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind]));\n      usage (EXIT_FAILURE);\n    }\n\n   \n  if (numeric_suffix_start && strlen (numeric_suffix_start) > suffix_length)\n    {\n      error (0, 0, _(\"numerical suffix start value is too large \"\n                     \"for the suffix length\"));\n      usage (EXIT_FAILURE);\n    }\n\n   \n  if (! STREQ (infile, \"-\")\n      && fd_reopen (STDIN_FILENO, infile, O_RDONLY, 0) < 0)\n    error (EXIT_FAILURE, errno, _(\"cannot open %s for reading\"),\n           quoteaf (infile));\n\n   \n  xset_binary_mode (STDIN_FILENO, O_BINARY);\n\n   \n  fdadvise (STDIN_FILENO, 0, 0, FADVISE_SEQUENTIAL);\n\n   \n\n  if (fstat (STDIN_FILENO, &in_stat_buf) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n\n  if (in_blk_size == 0)\n    {\n      in_blk_size = io_blksize (in_stat_buf);\n      if (SYS_BUFSIZE_MAX < in_blk_size)\n        in_blk_size = SYS_BUFSIZE_MAX;\n    }\n\n  char *buf = xalignalloc (page_size, in_blk_size + 1);\n  ssize_t initial_read = -1;\n\n  if (split_type == type_chunk_bytes || split_type == type_chunk_lines)\n    {\n      file_size = input_file_size (STDIN_FILENO, &in_stat_buf,\n                                   buf, in_blk_size);\n      if (file_size < 0)\n        error (EXIT_FAILURE, errno, _(\"%s: cannot determine file size\"),\n               quotef (infile));\n      initial_read = MIN (file_size, in_blk_size);\n    }\n\n   \n  if (filter_command)\n    default_SIGPIPE = signal (SIGPIPE, SIG_IGN) == SIG_DFL;\n\n  switch (split_type)\n    {\n    case type_digits:\n    case type_lines:\n      lines_split (n_units, buf, in_blk_size);\n      break;\n\n    case type_bytes:\n      bytes_split (n_units, 0, buf, in_blk_size, -1, 0);\n      break;\n\n    case type_byteslines:\n      line_bytes_split (n_units, buf, in_blk_size);\n      break;\n\n    case type_chunk_bytes:\n      if (k_units == 0)\n        bytes_split (file_size / n_units, file_size % n_units,\n                     buf, in_blk_size, initial_read, n_units);\n      else\n        bytes_chunk_extract (k_units, n_units, buf, in_blk_size, initial_read,\n                             file_size);\n      break;\n\n    case type_chunk_lines:\n      lines_chunk_split (k_units, n_units, buf, in_blk_size, initial_read,\n                         file_size);\n      break;\n\n    case type_rr:\n       \n      {\n        of_t *files;\n        lines_rr (k_units, n_units, buf, in_blk_size, &files);\n      }\n      break;\n\n    default:\n      affirm (false);\n    }\n\n  if (close (STDIN_FILENO) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (infile));\n  closeout (nullptr, output_desc, filter_pid, outfile);\n\n  main_exit (EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}