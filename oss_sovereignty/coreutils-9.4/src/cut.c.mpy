{
  "module_name": "cut.c",
  "hash_id": "74a18c54f7d83733fce4b0886ead4a0f840c27018705e475381c9fbb8accdeaa",
  "original_prompt": "Ingested from coreutils-9.4/src/cut.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n\n#include \"assure.h\"\n#include \"fadvise.h\"\n#include \"getndelim2.h\"\n\n#include \"set-fields.h\"\n\n \n#define PROGRAM_NAME \"cut\"\n\n#define AUTHORS \\\n  proper_name (\"David M. Ihnat\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\n#define FATAL_ERROR(Message)\t\t\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      error (0, 0, (Message));\t\t\t\t\t\t\\\n      usage (EXIT_FAILURE);\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n\n \nstatic struct field_range_pair *current_rp;\n\n \nstatic char *field_1_buffer;\n\n \nstatic size_t field_1_bufsize;\n\n \nstatic bool suppress_non_delimited;\n\n \nstatic bool complement;\n\n \nstatic unsigned char delim;\n\n \nstatic unsigned char line_delim = '\\n';\n\n \nstatic size_t output_delimiter_length;\n\n \nstatic char *output_delimiter_string;\n\n \nstatic char output_delimiter_default[1];\n\n \nstatic bool have_read_stdin;\n\n \nenum\n{\n  OUTPUT_DELIMITER_OPTION = CHAR_MAX + 1,\n  COMPLEMENT_OPTION\n};\n\nstatic struct option const longopts[] =\n{\n  {\"bytes\", required_argument, nullptr, 'b'},\n  {\"characters\", required_argument, nullptr, 'c'},\n  {\"fields\", required_argument, nullptr, 'f'},\n  {\"delimiter\", required_argument, nullptr, 'd'},\n  {\"only-delimited\", no_argument, nullptr, 's'},\n  {\"output-delimiter\", required_argument, nullptr, OUTPUT_DELIMITER_OPTION},\n  {\"complement\", no_argument, nullptr, COMPLEMENT_OPTION},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s OPTION... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nPrint selected parts of lines from each FILE to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -b, --bytes=LIST        select only these bytes\\n\\\n  -c, --characters=LIST   select only these characters\\n\\\n  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f, --fields=LIST       select only these fields;  also print any line\\n\\\n                            that contains no delimiter character, unless\\n\\\n                            the -s option is specified\\n\\\n  -n                      (ignored)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --complement        complement the set of selected bytes, characters\\n\\\n                            or fields\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -s, --only-delimited    do not print lines not containing delimiters\\n\\\n      --output-delimiter=STRING  use STRING as the output delimiter\\n\\\n                            the default is to use the input delimiter\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated   line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nUse one, and only one of -b, -c or -f.  Each LIST is made up of one\\n\\\nrange, or many ranges separated by commas.  Selected input is written\\n\\\nin the same order that it is read, and is written exactly once.\\n\\\n\"), stdout);\n      fputs (_(\"\\\nEach range is one of:\\n\\\n\\n\\\n  N     N'th byte, character or field, counted from 1\\n\\\n  N-    from N'th byte, character or field, to end of line\\n\\\n  N-M   from N'th to M'th (included) byte, character or field\\n\\\n  -M    from first to M'th (included) byte, character or field\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n\n/* Increment *ITEM_IDX (i.e., a field or byte index),\n   and if required CURRENT_RP.  */\n\nstatic inline void\nnext_item (uintmax_t *item_idx)\n{\n  (*item_idx)++;\n  if ((*item_idx) > current_rp->hi)\n    current_rp++;\n}\n\n/* Return nonzero if the K'th field or byte is printable.  */\n\nstatic inline bool\nprint_kth (uintmax_t k)\n{\n  return current_rp->lo <= k;\n}\n\n/* Return nonzero if K'th byte is the beginning of a range.  */\n\nstatic inline bool\nis_range_start_index (uintmax_t k)\n{\n  return k == current_rp->lo;\n}\n\n/* Read from stream STREAM, printing to standard output any selected bytes.  */\n\nstatic void\ncut_bytes (FILE *stream)\n{\n  uintmax_t byte_idx;\t/* Number of bytes in the line so far.  */\n  /* Whether to begin printing delimiters between ranges for the current line.\n     Set after we've begun printing data corresponding to the first range.  */\n  bool print_delimiter;\n\n  byte_idx = 0;\n  print_delimiter = false;\n  current_rp = frp;\n  while (true)\n    {\n      int c;\t\t/* Each character from the file.  */\n\n      c = getc (stream);\n\n      if (c == line_delim)\n        {\n          if (putchar (c) < 0)\n            write_error ();\n          byte_idx = 0;\n          print_delimiter = false;\n          current_rp = frp;\n        }\n      else if (c == EOF)\n        {\n          if (byte_idx > 0)\n          {\n            if (putchar (line_delim) < 0)\n              write_error ();\n          }\n          break;\n        }\n      else\n        {\n          next_item (&byte_idx);\n          if (print_kth (byte_idx))\n            {\n              if (output_delimiter_string != output_delimiter_default)\n                {\n                  if (print_delimiter && is_range_start_index (byte_idx))\n                    {\n                      if (fwrite (output_delimiter_string, sizeof (char),\n                                  output_delimiter_length, stdout)\n                          != output_delimiter_length)\n                        write_error ();\n                    }\n                  print_delimiter = true;\n                }\n\n              if (putchar (c) < 0)\n                write_error ();\n            }\n        }\n    }\n}\n\n/* Read from stream STREAM, printing to standard output any selected fields.  */\n\nstatic void\ncut_fields (FILE *stream)\n{\n  int c;\t/* Each character from the file.  */\n  uintmax_t field_idx = 1;\n  bool found_any_selected_field = false;\n  bool buffer_first_field;\n\n  current_rp = frp;\n\n  c = getc (stream);\n  if (c == EOF)\n    return;\n\n  ungetc (c, stream);\n  c = 0;\n\n  /* To support the semantics of the -s flag, we may have to buffer\n     all of the first field to determine whether it is 'delimited.'\n     But that is unnecessary if all non-delimited lines must be printed\n     and the first field has been selected, or if non-delimited lines\n     must be suppressed and the first field has *not* been selected.\n     That is because a non-delimited line has exactly one field.  */\n  buffer_first_field = (suppress_non_delimited ^ !print_kth (1));\n\n  while (true)\n    {\n      if (field_idx == 1 && buffer_first_field)\n        {\n          ssize_t len;\n          size_t n_bytes;\n\n          len = getndelim2 (&field_1_buffer, &field_1_bufsize, 0,\n                            GETNLINE_NO_LIMIT, delim, line_delim, stream);\n          if (len < 0)\n            {\n              free (field_1_buffer);\n              field_1_buffer = nullptr;\n              if (ferror (stream) || feof (stream))\n                break;\n              xalloc_die ();\n            }\n\n          n_bytes = len;\n          affirm (n_bytes != 0);\n\n          c = 0;\n\n          /* If the first field extends to the end of line (it is not\n             delimited) and we are printing all non-delimited lines,\n             print this one.  */\n          if (to_uchar (field_1_buffer[n_bytes - 1]) != delim)\n            {\n              if (suppress_non_delimited)\n                {\n                  /* Empty.  */\n                }\n              else\n                {\n                  if (fwrite (field_1_buffer, sizeof (char), n_bytes, stdout)\n                      != n_bytes)\n                    write_error ();\n                  /* Make sure the output line is newline terminated.  */\n                  if (field_1_buffer[n_bytes - 1] != line_delim)\n                    {\n                      if (putchar (line_delim) < 0)\n                        write_error ();\n                    }\n                  c = line_delim;\n                }\n              continue;\n            }\n\n          if (print_kth (1))\n            {\n              /* Print the field, but not the trailing delimiter.  */\n              if (fwrite (field_1_buffer, sizeof (char), n_bytes - 1, stdout)\n                  != n_bytes - 1)\n                write_error ();\n\n              /* With -d$'\\n' don't treat the last '\\n' as a delimiter.  */\n              if (delim == line_delim)\n                {\n                  int last_c = getc (stream);\n                  if (last_c != EOF)\n                    {\n                      ungetc (last_c, stream);\n                      found_any_selected_field = true;\n                    }\n                }\n              else\n                {\n                  found_any_selected_field = true;\n                }\n            }\n          next_item (&field_idx);\n        }\n\n      int prev_c = c;\n\n      if (print_kth (field_idx))\n        {\n          if (found_any_selected_field)\n            {\n              if (fwrite (output_delimiter_string, sizeof (char),\n                          output_delimiter_length, stdout)\n                  != output_delimiter_length)\n                write_error ();\n            }\n          found_any_selected_field = true;\n\n          while ((c = getc (stream)) != delim && c != line_delim && c != EOF)\n            {\n              if (putchar (c) < 0)\n                write_error ();\n              prev_c = c;\n            }\n        }\n      else\n        {\n          while ((c = getc (stream)) != delim && c != line_delim && c != EOF)\n            prev_c = c;\n        }\n\n      /* With -d$'\\n' don't treat the last '\\n' as a delimiter.  */\n      if (delim == line_delim && c == delim)\n        {\n          int last_c = getc (stream);\n          if (last_c != EOF)\n            ungetc (last_c, stream);\n          else\n            c = last_c;\n        }\n\n      if (c == delim)\n        next_item (&field_idx);\n      else if (c == line_delim || c == EOF)\n        {\n          if (found_any_selected_field\n              || !(suppress_non_delimited && field_idx == 1))\n            {\n              /* Make sure the output line is newline terminated.  */\n              if (c == line_delim || prev_c != line_delim\n                  || delim == line_delim)\n                {\n                  if (putchar (line_delim) < 0)\n                    write_error ();\n                }\n            }\n          if (c == EOF)\n            break;\n\n          /* Start processing the next input line.  */\n          field_idx = 1;\n          current_rp = frp;\n          found_any_selected_field = false;\n        }\n    }\n}\n\n/* Process file FILE to standard output, using CUT_STREAM.\n   Return true if successful.  */\n\nstatic bool\ncut_file (char const *file, void (*cut_stream) (FILE *))\n{\n  FILE *stream;\n\n  if (STREQ (file, \"-\"))\n    {\n      have_read_stdin = true;\n      stream = stdin;\n      assume (stream);  /* Pacify GCC bug#109613.  */\n    }\n  else\n    {\n      stream = fopen (file, \"r\");\n      if (stream == nullptr)\n        {\n          error (0, errno, \"%s\", quotef (file));\n          return false;\n        }\n    }\n\n  fadvise (stream, FADVISE_SEQUENTIAL);\n\n  cut_stream (stream);\n\n  int err = errno;\n  if (!ferror (stream))\n    err = 0;\n  if (STREQ (file, \"-\"))\n    clearerr (stream);\t\t/* Also clear EOF.  */\n  else if (fclose (stream) == EOF)\n    err = errno;\n  if (err)\n    {\n      error (0, err, \"%s\", quotef (file));\n      return false;\n    }\n  return true;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  bool ok;\n  bool delim_specified = false;\n  bool byte_mode = false;\n  char *spec_list_string = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  /* By default, all non-delimited lines are printed.  */\n  suppress_non_delimited = false;\n\n  delim = '\\0';\n  have_read_stdin = false;\n\n  while ((optc = getopt_long (argc, argv, \"b:c:d:f:nsz\", longopts, nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'b':\n        case 'c':\n          /* Build the byte list.  */\n          byte_mode = true;\n          FALLTHROUGH;\n        case 'f':\n          /* Build the field list.  */\n          if (spec_list_string)\n            FATAL_ERROR (_(\"only one list may be specified\"));\n          spec_list_string = optarg;\n          break;\n\n        case 'd':\n          /* New delimiter.  */\n          /* Interpret -d '' to mean 'use the NUL byte as the delimiter.'  */\n          if (optarg[0] != '\\0' && optarg[1] != '\\0')\n            FATAL_ERROR (_(\"the delimiter must be a single character\"));\n          delim = optarg[0];\n          delim_specified = true;\n          break;\n\n        case OUTPUT_DELIMITER_OPTION:\n          /* Interpret --output-delimiter='' to mean\n             'use the NUL byte as the delimiter.'  */\n          output_delimiter_length = (optarg[0] == '\\0'\n                                     ? 1 : strlen (optarg));\n          output_delimiter_string = optarg;\n          break;\n\n        case 'n':\n          break;\n\n        case 's':\n          suppress_non_delimited = true;\n          break;\n\n        case 'z':\n          line_delim = '\\0';\n          break;\n\n        case COMPLEMENT_OPTION:\n          complement = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (!spec_list_string)\n    FATAL_ERROR (_(\"you must specify a list of bytes, characters, or fields\"));\n\n  if (byte_mode)\n    {\n      if (delim_specified)\n        FATAL_ERROR (_(\"an input delimiter may be specified only\\\n when operating on fields\"));\n\n      if (suppress_non_delimited)\n        FATAL_ERROR (_(\"suppressing non-delimited lines makes sense\\n\\\n\\tonly when operating on fields\"));\n    }\n\n  set_fields (spec_list_string,\n              ((byte_mode ? SETFLD_ERRMSG_USE_POS : 0)\n               | (complement ? SETFLD_COMPLEMENT : 0)));\n\n  if (!delim_specified)\n    delim = '\\t';\n\n  if (output_delimiter_string == nullptr)\n    {\n      output_delimiter_default[0] = delim;\n      output_delimiter_string = output_delimiter_default;\n      output_delimiter_length = 1;\n    }\n\n  void (*cut_stream) (FILE *) = byte_mode ? cut_bytes : cut_fields;\n  if (optind == argc)\n    ok = cut_file (\"-\", cut_stream);\n  else\n    for (ok = true; optind < argc; optind++)\n      ok &= cut_file (argv[optind], cut_stream);\n\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    {\n      error (0, errno, \"-\");\n      ok = false;\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}