{
  "module_name": "yes.c",
  "hash_id": "67bf3e5171f47d48e126ec68d50174e7598970b8d7f94d883ee46c19bede2e9a",
  "original_prompt": "Ingested from coreutils-9.4/src/yes.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n\n#include \"full-write.h\"\n#include \"long-options.h\"\n\n \n#define PROGRAM_NAME \"yes\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [STRING]...\\n\\\n  or:  %s OPTION\\n\\\n\"),\n              program_name, program_name);\n\n      fputs (_(\"\\\nRepeatedly output a line with all specified STRING(s), or 'y'.\\n\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n                                   Version, true, usage, AUTHORS,\n                                   (char const *) nullptr);\n\n  char **operands = argv + optind;\n  char **operand_lim = argv + argc;\n  if (optind == argc)\n    *operand_lim++ = bad_cast (\"y\");\n\n  /* Buffer data locally once, rather than having the\n     large overhead of stdio buffering each item.  */\n  size_t bufalloc = 0;\n  bool reuse_operand_strings = true;\n  char **operandp = operands;\n  do\n    {\n      size_t operand_len = strlen (*operandp);\n      bufalloc += operand_len + 1;\n      if (operandp + 1 < operand_lim\n          && *operandp + operand_len + 1 != operandp[1])\n        reuse_operand_strings = false;\n    }\n  while (++operandp < operand_lim);\n\n  /* Improve performance by using a buffer size greater than BUFSIZ / 2.  */\n  if (bufalloc <= BUFSIZ / 2)\n    {\n      bufalloc = BUFSIZ;\n      reuse_operand_strings = false;\n    }\n\n  /* Fill the buffer with one copy of the output.  If possible, reuse\n     the operands strings; this wins when the buffer would be large.  */\n  char *buf = reuse_operand_strings ? *operands : xmalloc (bufalloc);\n  size_t bufused = 0;\n  operandp = operands;\n  do\n    {\n      size_t operand_len = strlen (*operandp);\n      if (! reuse_operand_strings)\n        memcpy (buf + bufused, *operandp, operand_len);\n      bufused += operand_len;\n      buf[bufused++] = ' ';\n    }\n  while (++operandp < operand_lim);\n  buf[bufused - 1] = '\\n';\n\n  /* If a larger buffer was allocated, fill it by repeating the buffer\n     contents.  */\n  size_t copysize = bufused;\n  for (size_t copies = bufalloc / copysize; --copies; )\n    {\n      memcpy (buf + bufused, buf, copysize);\n      bufused += copysize;\n    }\n\n  /* Repeatedly output the buffer until there is a write error; then fail.  */\n  while (full_write (STDOUT_FILENO, buf, bufused) == bufused)\n    continue;\n  error (0, errno, _(\"standard output\"));\n  main_exit (EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}