{
  "module_name": "comm.c",
  "hash_id": "3835d6b0e43d59251fa364ce3232b84e0fcc5258ca165848c76ab836426dd0ef",
  "original_prompt": "Ingested from coreutils-9.4/src/comm.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"linebuffer.h\"\n#include \"fadvise.h\"\n#include \"hard-locale.h\"\n#include \"quote.h\"\n#include \"stdio--.h\"\n#include \"memcmp2.h\"\n#include \"xmemcoll.h\"\n\n \n#define PROGRAM_NAME \"comm\"\n\n#define AUTHORS \\\n  proper_name (\"Richard M. Stallman\"), \\\n  proper_name (\"David MacKenzie\")\n\n \n#undef min\n#define min(x, y) ((x) < (y) ? (x) : (y))\n\n \nstatic bool hard_LC_COLLATE;\n\n \nstatic bool only_file_1;\n\n \nstatic bool only_file_2;\n\n \nstatic bool both;\n\n \nstatic bool seen_unpairable;\n\n \nstatic bool issued_disorder_warning[2];\n\n \nstatic unsigned char delim = '\\n';\n\n \nstatic bool total_option;\n\n \nstatic enum\n  {\n    CHECK_ORDER_DEFAULT,\n    CHECK_ORDER_ENABLED,\n    CHECK_ORDER_DISABLED\n  } check_input_order;\n\n \nstatic char const *col_sep = \"\\t\";\nstatic size_t col_sep_len = 0;\n\n \nenum\n{\n  CHECK_ORDER_OPTION = CHAR_MAX + 1,\n  NOCHECK_ORDER_OPTION,\n  OUTPUT_DELIMITER_OPTION,\n  TOTAL_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"check-order\", no_argument, nullptr, CHECK_ORDER_OPTION},\n  {\"nocheck-order\", no_argument, nullptr, NOCHECK_ORDER_OPTION},\n  {\"output-delimiter\", required_argument, nullptr, OUTPUT_DELIMITER_OPTION},\n  {\"total\", no_argument, nullptr, TOTAL_OPTION},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... FILE1 FILE2\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nCompare sorted files FILE1 and FILE2 line by line.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nWhen FILE1 or FILE2 (not both) is -, read standard input.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nWith no options, produce three-column output.  Column one contains\\n\\\nlines unique to FILE1, column two contains lines unique to FILE2,\\n\\\nand column three contains lines common to both files.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n  -1                      suppress column 1 (lines unique to FILE1)\\n\\\n  -2                      suppress column 2 (lines unique to FILE2)\\n\\\n  -3                      suppress column 3 (lines that appear in both files)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n      --check-order       check that the input is correctly sorted, even\\n\\\n                            if all input lines are pairable\\n\\\n      --nocheck-order     do not check that the input is correctly sorted\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --output-delimiter=STR  separate columns with STR\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --total             output a summary\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated   line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nNote, comparisons honor the rules specified by 'LC_COLLATE'.\\n\\\n\"), stdout);\n      printf (_(\"\\\n\\n\\\nExamples:\\n\\\n  %s -12 file1 file2  Print only lines present in both file1 and file2.\\n\\\n  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\\n\\\n\"),\n              program_name, program_name);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Output the line in linebuffer LINE to stdout\n   provided the switches say it should be output.\n   CLASS is 1 for a line found only in file 1,\n   2 for a line only in file 2, 3 for a line in both. */\n\nstatic void\nwriteline (struct linebuffer const *line, int class)\n{\n  switch (class)\n    {\n    case 1:\n      if (!only_file_1)\n        return;\n      break;\n\n    case 2:\n      if (!only_file_2)\n        return;\n      if (only_file_1)\n        fwrite (col_sep, 1, col_sep_len, stdout);\n      break;\n\n    case 3:\n      if (!both)\n        return;\n      if (only_file_1)\n        fwrite (col_sep, 1, col_sep_len, stdout);\n      if (only_file_2)\n        fwrite (col_sep, 1, col_sep_len, stdout);\n      break;\n    }\n\n  fwrite (line->buffer, sizeof (char), line->length, stdout);\n\n  if (ferror (stdout))\n    write_error ();\n}\n\n/* Check that successive input lines PREV and CURRENT from input file\n   WHATFILE are presented in order.\n\n   If the user specified --nocheck-order, the check is not made.\n   If the user specified --check-order, the problem is fatal.\n   Otherwise (the default), the message is simply a warning.\n\n   A message is printed at most once per input file.\n\n   This function was copied (nearly) verbatim from 'src/join.c'. */\n\nstatic void\ncheck_order (struct linebuffer const *prev,\n             struct linebuffer const *current,\n             int whatfile)\n{\n\n  if (check_input_order != CHECK_ORDER_DISABLED\n      && ((check_input_order == CHECK_ORDER_ENABLED) || seen_unpairable))\n    {\n      if (!issued_disorder_warning[whatfile - 1])\n        {\n          int order;\n\n          if (hard_LC_COLLATE)\n            order = xmemcoll (prev->buffer, prev->length - 1,\n                              current->buffer, current->length - 1);\n          else\n            order = memcmp2 (prev->buffer, prev->length - 1,\n                             current->buffer, current->length - 1);\n\n          if (0 < order)\n            {\n              error ((check_input_order == CHECK_ORDER_ENABLED\n                      ? EXIT_FAILURE : 0),\n                     0, _(\"file %d is not in sorted order\"), whatfile);\n\n              /* If we get to here, the message was just a warning, but we\n                 want only to issue it once. */\n              issued_disorder_warning[whatfile - 1] = true;\n            }\n        }\n    }\n}\n\n/* Compare INFILES[0] and INFILES[1].\n   If either is \"-\", use the standard input for that file.\n   Assume that each input file is sorted;\n   merge them and output the result.\n   Exit the program when done.  */\n\nstatic _Noreturn void\ncompare_files (char **infiles)\n{\n  /* For each file, we have four linebuffers in lba. */\n  struct linebuffer lba[2][4];\n\n  /* thisline[i] points to the linebuffer holding the next available line\n     in file i, or is null if there are no lines left in that file.  */\n  struct linebuffer *thisline[2];\n\n  /* all_line[i][alt[i][0]] also points to the linebuffer holding the\n     current line in file i. We keep two buffers of history around so we\n     can look two lines back when we get to the end of a file. */\n  struct linebuffer *all_line[2][4];\n\n  /* This is used to rotate through the buffers for each input file. */\n  int alt[2][3];\n\n  /* streams[i] holds the input stream for file i.  */\n  FILE *streams[2];\n\n  /* Counters for the summary.  */\n  uintmax_t total[] = {0, 0, 0};\n\n  int i, j;\n\n  /* Initialize the storage. */\n  for (i = 0; i < 2; i++)\n    {\n      for (j = 0; j < 4; j++)\n        {\n          initbuffer (&lba[i][j]);\n          all_line[i][j] = &lba[i][j];\n        }\n      alt[i][0] = 0;\n      alt[i][1] = 0;\n      alt[i][2] = 0;\n      streams[i] = (STREQ (infiles[i], \"-\") ? stdin : fopen (infiles[i], \"r\"));\n      if (!streams[i])\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infiles[i]));\n\n      fadvise (streams[i], FADVISE_SEQUENTIAL);\n\n      thisline[i] = readlinebuffer_delim (all_line[i][alt[i][0]], streams[i],\n                                          delim);\n      if (ferror (streams[i]))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (infiles[i]));\n    }\n\n  while (thisline[0] || thisline[1])\n    {\n      int order;\n      bool fill_up[2] = { false, false };\n\n      /* Compare the next available lines of the two files.  */\n\n      if (!thisline[0])\n        order = 1;\n      else if (!thisline[1])\n        order = -1;\n      else\n        {\n          if (hard_LC_COLLATE)\n            order = xmemcoll (thisline[0]->buffer, thisline[0]->length - 1,\n                              thisline[1]->buffer, thisline[1]->length - 1);\n          else\n            {\n              size_t len = min (thisline[0]->length, thisline[1]->length) - 1;\n              order = memcmp (thisline[0]->buffer, thisline[1]->buffer, len);\n              if (order == 0)\n                order = ((thisline[0]->length > thisline[1]->length)\n                         - (thisline[0]->length < thisline[1]->length));\n            }\n        }\n\n      /* Output the line that is lesser. */\n      if (order == 0)\n        {\n          /* Line is seen in both files.  */\n          total[2]++;\n          writeline (thisline[1], 3);\n        }\n      else\n        {\n          seen_unpairable = true;\n          if (order <= 0)\n            {\n              /* Line is seen in file 1 only.  */\n              total[0]++;\n              writeline (thisline[0], 1);\n            }\n          else\n            {\n              /* Line is seen in file 2 only.  */\n              total[1]++;\n              writeline (thisline[1], 2);\n            }\n        }\n\n      /* Step the file the line came from.\n         If the files match, step both files.  */\n      if (0 <= order)\n        fill_up[1] = true;\n      if (order <= 0)\n        fill_up[0] = true;\n\n      for (i = 0; i < 2; i++)\n        if (fill_up[i])\n          {\n            /* Rotate the buffers for this file. */\n            alt[i][2] = alt[i][1];\n            alt[i][1] = alt[i][0];\n            alt[i][0] = (alt[i][0] + 1) & 0x03;\n\n            thisline[i] = readlinebuffer_delim (all_line[i][alt[i][0]],\n                                                streams[i], delim);\n\n            if (thisline[i])\n              check_order (all_line[i][alt[i][1]], thisline[i], i + 1);\n\n            /* If this is the end of the file we may need to re-check\n               the order of the previous two lines, since we might have\n               discovered an unpairable match since we checked before. */\n            else if (all_line[i][alt[i][2]]->buffer)\n              check_order (all_line[i][alt[i][2]],\n                           all_line[i][alt[i][1]], i + 1);\n\n            if (ferror (streams[i]))\n              error (EXIT_FAILURE, errno, \"%s\", quotef (infiles[i]));\n\n            fill_up[i] = false;\n          }\n    }\n\n  for (i = 0; i < 2; i++)\n    if (fclose (streams[i]) != 0)\n      error (EXIT_FAILURE, errno, \"%s\", quotef (infiles[i]));\n\n  if (total_option)\n    {\n      /* Print the summary, minding the column and line delimiters.  */\n      char buf1[INT_BUFSIZE_BOUND (uintmax_t)];\n      char buf2[INT_BUFSIZE_BOUND (uintmax_t)];\n      char buf3[INT_BUFSIZE_BOUND (uintmax_t)];\n      if (col_sep_len == 1)\n        { /* Separate to handle NUL char.  */\n          printf (\"%s%c%s%c%s%c%s%c\",\n                  umaxtostr (total[0], buf1), *col_sep,\n                  umaxtostr (total[1], buf2), *col_sep,\n                  umaxtostr (total[2], buf3), *col_sep,\n                  _(\"total\"), delim);\n        }\n      else\n        {\n          printf (\"%s%s%s%s%s%s%s%c\",\n                  umaxtostr (total[0], buf1), col_sep,\n                  umaxtostr (total[1], buf2), col_sep,\n                  umaxtostr (total[2], buf3), col_sep,\n                  _(\"total\"), delim);\n        }\n    }\n\n  if (issued_disorder_warning[0] || issued_disorder_warning[1])\n    error (EXIT_FAILURE, 0, _(\"input is not in sorted order\"));\n\n  /* Exit here to pacify gcc -fsanitizer=leak.  */\n  exit (EXIT_SUCCESS);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  hard_LC_COLLATE = hard_locale (LC_COLLATE);\n\n  atexit (close_stdout);\n\n  only_file_1 = true;\n  only_file_2 = true;\n  both = true;\n\n  seen_unpairable = false;\n  issued_disorder_warning[0] = issued_disorder_warning[1] = false;\n  check_input_order = CHECK_ORDER_DEFAULT;\n  total_option = false;\n\n  while ((c = getopt_long (argc, argv, \"123z\", long_options, nullptr)) != -1)\n    switch (c)\n      {\n      case '1':\n        only_file_1 = false;\n        break;\n\n      case '2':\n        only_file_2 = false;\n        break;\n\n      case '3':\n        both = false;\n        break;\n\n      case 'z':\n        delim = '\\0';\n        break;\n\n      case NOCHECK_ORDER_OPTION:\n        check_input_order = CHECK_ORDER_DISABLED;\n        break;\n\n      case CHECK_ORDER_OPTION:\n        check_input_order = CHECK_ORDER_ENABLED;\n        break;\n\n      case OUTPUT_DELIMITER_OPTION:\n        if (col_sep_len && !STREQ (col_sep, optarg))\n          error (EXIT_FAILURE, 0, _(\"multiple output delimiters specified\"));\n        col_sep = optarg;\n        col_sep_len = *optarg ? strlen (optarg) : 1;\n        break;\n\n      case TOTAL_OPTION:\n        total_option = true;\n        break;\n\n      case_GETOPT_HELP_CHAR;\n\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n      default:\n        usage (EXIT_FAILURE);\n      }\n\n  if (! col_sep_len)\n    col_sep_len = 1;\n\n  if (argc - optind < 2)\n    {\n      if (argc <= optind)\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (2 < argc - optind)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 2]));\n      usage (EXIT_FAILURE);\n    }\n\n  compare_files (argv + optind);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}