{
  "module_name": "shuf.c",
  "hash_id": "d9b7a2bbf8c1d1b3a9049a05d7b17f532bc7caefcb1a221561ee3eb27ef4a131",
  "original_prompt": "Ingested from coreutils-9.4/src/shuf.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <sys/types.h>\n#include \"system.h\"\n\n#include \"fadvise.h\"\n#include \"getopt.h\"\n#include \"linebuffer.h\"\n#include \"quote.h\"\n#include \"randint.h\"\n#include \"randperm.h\"\n#include \"read-file.h\"\n#include \"stdio--.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"shuf\"\n\n#define AUTHORS proper_name (\"Paul Eggert\")\n\n \nenum { RESERVOIR_LINES_INCREMENT = 1024 };\n\n \nenum { RESERVOIR_MIN_INPUT = 8192 * 1024 };\n\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]\\n\\\n  or:  %s -e [OPTION]... [ARG]...\\n\\\n  or:  %s -i LO-HI [OPTION]...\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\\nWrite a random permutation of the input lines to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -e, --echo                treat each ARG as an input line\\n\\\n  -i, --input-range=LO-HI   treat each number LO through HI as an input line\\n\\\n  -n, --head-count=COUNT    output at most COUNT lines\\n\\\n  -o, --output=FILE         write result to FILE instead of standard output\\n\\\n      --random-source=FILE  get random bytes from FILE\\n\\\n  -r, --repeat              output lines can be repeated\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -z, --zero-terminated     line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\n/* For long options that have no equivalent short option, use a\n   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */\nenum\n{\n  RANDOM_SOURCE_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const long_opts[] =\n{\n  {\"echo\", no_argument, nullptr, 'e'},\n  {\"input-range\", required_argument, nullptr, 'i'},\n  {\"head-count\", required_argument, nullptr, 'n'},\n  {\"output\", required_argument, nullptr, 'o'},\n  {\"random-source\", required_argument, nullptr, RANDOM_SOURCE_OPTION},\n  {\"repeat\", no_argument, nullptr, 'r'},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {0, 0, 0, 0},\n};\n\nstatic void\ninput_from_argv (char **operand, int n_operands, char eolbyte)\n{\n  char *p;\n  size_t size = n_operands;\n  int i;\n\n  for (i = 0; i < n_operands; i++)\n    size += strlen (operand[i]);\n  p = xmalloc (size);\n\n  for (i = 0; i < n_operands; i++)\n    {\n      char *p1 = stpcpy (p, operand[i]);\n      operand[i] = p;\n      p = p1;\n      *p++ = eolbyte;\n    }\n\n  operand[n_operands] = p;\n}\n\n/* Return the start of the next line after LINE, which is guaranteed\n   to end in EOLBYTE.  */\n\nstatic char *\nnext_line (char *line, char eolbyte)\n{\n  char *p = rawmemchr (line, eolbyte);\n  return p + 1;\n}\n\n/* Return the size of the input if possible or OFF_T_MAX if not.  */\n\nstatic off_t\ninput_size (void)\n{\n  off_t file_size;\n\n  struct stat stat_buf;\n  if (fstat (STDIN_FILENO, &stat_buf) != 0)\n    return OFF_T_MAX;\n  if (usable_st_size (&stat_buf))\n    file_size = stat_buf.st_size;\n  else\n    return OFF_T_MAX;\n\n  off_t input_offset = lseek (STDIN_FILENO, 0, SEEK_CUR);\n  if (input_offset < 0)\n    return OFF_T_MAX;\n\n  file_size -= input_offset;\n\n  return file_size;\n}\n\n/* Read all lines and store up to K permuted lines in *OUT_RSRV.\n   Return the number of lines read, up to a maximum of K.  */\n\nstatic size_t\nread_input_reservoir_sampling (FILE *in, char eolbyte, size_t k,\n                               struct randint_source *s,\n                               struct linebuffer **out_rsrv)\n{\n  randint n_lines = 0;\n  size_t n_alloc_lines = MIN (k, RESERVOIR_LINES_INCREMENT);\n  struct linebuffer *line = nullptr;\n  struct linebuffer *rsrv;\n\n  rsrv = xcalloc (n_alloc_lines, sizeof (struct linebuffer));\n\n  /* Fill the first K lines, directly into the reservoir.  */\n  while (n_lines < k\n         && (line =\n             readlinebuffer_delim (&rsrv[n_lines], in, eolbyte)) != nullptr)\n    {\n      n_lines++;\n\n      /* Enlarge reservoir.  */\n      if (n_lines >= n_alloc_lines)\n        {\n          n_alloc_lines += RESERVOIR_LINES_INCREMENT;\n          rsrv = xnrealloc (rsrv, n_alloc_lines, sizeof (struct linebuffer));\n          memset (&rsrv[n_lines], 0,\n                  RESERVOIR_LINES_INCREMENT * sizeof (struct linebuffer));\n        }\n    }\n\n  /* last line wasn't null - so there may be more lines to read.  */\n  if (line != nullptr)\n    {\n      struct linebuffer dummy;\n      initbuffer (&dummy);  /* space for lines not put in reservoir.  */\n\n      /* Choose the fate of the next line, with decreasing probability (as\n         n_lines increases in size).\n\n         If the line will be used, store it directly in the reservoir.\n         Otherwise, store it in dummy space.\n\n         With 'struct linebuffer', storing into existing buffer will reduce\n         re-allocations (will only re-allocate if the new line is longer than\n         the currently allocated space).  */\n      do\n        {\n          randint j = randint_choose (s, n_lines + 1);  /* 0 .. n_lines.  */\n          line = (j < k) ? (&rsrv[j]) : (&dummy);\n        }\n      while (readlinebuffer_delim (line, in, eolbyte) != nullptr && n_lines++);\n\n      if (! n_lines)\n        error (EXIT_FAILURE, EOVERFLOW, _(\"too many input lines\"));\n\n      freebuffer (&dummy);\n    }\n\n  /* no more input lines, or an input error.  */\n  if (ferror (in))\n    error (EXIT_FAILURE, errno, _(\"read error\"));\n\n  *out_rsrv = rsrv;\n  return MIN (k, n_lines);\n}\n\nstatic int\nwrite_permuted_output_reservoir (size_t n_lines, struct linebuffer *lines,\n                                 size_t const *permutation)\n{\n  for (size_t i = 0; i < n_lines; i++)\n    {\n      const struct linebuffer *p = &lines[permutation[i]];\n      if (fwrite (p->buffer, sizeof (char), p->length, stdout) != p->length)\n        return -1;\n    }\n\n  return 0;\n}\n\n/* Read data from file IN.  Input lines are delimited by EOLBYTE;\n   silently append a trailing EOLBYTE if the file ends in some other\n   byte.  Store a pointer to the resulting array of lines into *PLINE.\n   Return the number of lines read.  Report an error and exit on\n   failure.  */\n\nstatic size_t\nread_input (FILE *in, char eolbyte, char ***pline)\n{\n  char *p;\n  char *buf = nullptr;\n  size_t used;\n  char *lim;\n  char **line;\n  size_t n_lines;\n\n  /* TODO: We should limit the amount of data read here,\n     to less than RESERVOIR_MIN_INPUT.  I.e., adjust fread_file() to support\n     taking a byte limit.  We'd then need to ensure we handle a line spanning\n     this boundary.  With that in place we could set use_reservoir_sampling\n     when used==RESERVOIR_MIN_INPUT, and have read_input_reservoir_sampling()\n     call a wrapper function to populate a linebuffer from the internal pline\n     or if none left, stdin.  Doing that would give better performance by\n     avoiding the reservoir CPU overhead when reading < RESERVOIR_MIN_INPUT\n     from a pipe, and allow us to dispense with the input_size() function.  */\n  if (!(buf = fread_file (in, 0, &used)))\n    error (EXIT_FAILURE, errno, _(\"read error\"));\n\n  if (used && buf[used - 1] != eolbyte)\n    buf[used++] = eolbyte;\n\n  lim = buf + used;\n\n  n_lines = 0;\n  for (p = buf; p < lim; p = next_line (p, eolbyte))\n    n_lines++;\n\n  *pline = line = xnmalloc (n_lines + 1, sizeof *line);\n\n  line[0] = p = buf;\n  for (size_t i = 1; i <= n_lines; i++)\n    line[i] = p = next_line (p, eolbyte);\n\n  return n_lines;\n}\n\n/* Output N_LINES lines to stdout from LINE array,\n   chosen by the indices in PERMUTATION.\n   PERMUTATION and LINE must have at least N_LINES elements.\n   Strings in LINE must include the line-terminator character.  */\nstatic int\nwrite_permuted_lines (size_t n_lines, char *const *line,\n                      size_t const *permutation)\n{\n  for (size_t i = 0; i < n_lines; i++)\n    {\n      char *const *p = line + permutation[i];\n      size_t len = p[1] - p[0];\n      if (fwrite (p[0], sizeof *p[0], len, stdout) != len)\n        return -1;\n    }\n\n  return 0;\n}\n\n/* Output N_LINES of numbers to stdout, from PERMUTATION array.\n   PERMUTATION must have at least N_LINES elements.  */\nstatic int\nwrite_permuted_numbers (size_t n_lines, size_t lo_input,\n                        size_t const *permutation, char eolbyte)\n{\n  for (size_t i = 0; i < n_lines; i++)\n    {\n      unsigned long int n = lo_input + permutation[i];\n      if (printf (\"%lu%c\", n, eolbyte) < 0)\n        return -1;\n    }\n\n  return 0;\n}\n\n/* Output COUNT numbers to stdout, chosen randomly from range\n   LO_INPUT through HI_INPUT.  */\nstatic int\nwrite_random_numbers (struct randint_source *s, size_t count,\n                      size_t lo_input, size_t hi_input, char eolbyte)\n{\n  const randint range = hi_input - lo_input + 1;\n\n  for (size_t i = 0; i < count; i++)\n    {\n      unsigned long int j = lo_input + randint_choose (s, range);\n      if (printf (\"%lu%c\", j, eolbyte) < 0)\n        return -1;\n    }\n\n  return 0;\n}\n\n/* Output COUNT lines to stdout from LINES array.\n   LINES must have at least N_LINES elements in it.\n   Strings in LINES_ must include the line-terminator character.  */\nstatic int\nwrite_random_lines (struct randint_source *s, size_t count,\n                    char *const *lines, size_t n_lines)\n{\n  for (size_t i = 0; i < count; i++)\n    {\n      const randint j = randint_choose (s, n_lines);\n      char *const *p = lines + j;\n      size_t len = p[1] - p[0];\n      if (fwrite (p[0], sizeof *p[0], len, stdout) != len)\n        return -1;\n    }\n\n  return 0;\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool echo = false;\n  bool input_range = false;\n  size_t lo_input = SIZE_MAX;\n  size_t hi_input = 0;\n  size_t head_lines = SIZE_MAX;\n  char const *outfile = nullptr;\n  char *random_source = nullptr;\n  char eolbyte = '\\n';\n  char **input_lines = nullptr;\n  bool use_reservoir_sampling = false;\n  bool repeat = false;\n\n  int optc;\n  int n_operands;\n  char **operand;\n  size_t n_lines;\n  char **line = nullptr;\n  struct linebuffer *reservoir = nullptr;\n  struct randint_source *randint_source;\n  size_t *permutation = nullptr;\n  int i;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"ei:n:o:rz\", long_opts, nullptr))\n         != -1)\n    switch (optc)\n      {\n      case 'e':\n        echo = true;\n        break;\n\n      case 'i':\n        {\n          if (input_range)\n            error (EXIT_FAILURE, 0, _(\"multiple -i options specified\"));\n          input_range = true;\n\n          uintmax_t u;\n          char *lo_end;\n          strtol_error err = xstrtoumax (optarg, &lo_end, 10, &u, nullptr);\n          if (err == LONGINT_OK)\n            {\n              lo_input = u;\n              if (lo_input != u)\n                err = LONGINT_OVERFLOW;\n              else if (*lo_end != '-')\n                err = LONGINT_INVALID;\n              else\n                {\n                  err = xstrtoumax (lo_end + 1, nullptr, 10, &u, \"\");\n                  if (err == LONGINT_OK)\n                    {\n                      hi_input = u;\n                      if (hi_input != u)\n                        err = LONGINT_OVERFLOW;\n                    }\n                }\n            }\n\n          n_lines = hi_input - lo_input + 1;\n\n          if (err != LONGINT_OK || (lo_input <= hi_input) == (n_lines == 0))\n            error (EXIT_FAILURE, err == LONGINT_OVERFLOW ? EOVERFLOW : 0,\n                   \"%s: %s\", _(\"invalid input range\"), quote (optarg));\n        }\n        break;\n\n      case 'n':\n        {\n          uintmax_t argval;\n          strtol_error e = xstrtoumax (optarg, nullptr, 10, &argval, \"\");\n\n          if (e == LONGINT_OK)\n            head_lines = MIN (head_lines, argval);\n          else if (e != LONGINT_OVERFLOW)\n            error (EXIT_FAILURE, 0, _(\"invalid line count: %s\"),\n                   quote (optarg));\n        }\n        break;\n\n      case 'o':\n        if (outfile && !STREQ (outfile, optarg))\n          error (EXIT_FAILURE, 0, _(\"multiple output files specified\"));\n        outfile = optarg;\n        break;\n\n      case RANDOM_SOURCE_OPTION:\n        if (random_source && !STREQ (random_source, optarg))\n          error (EXIT_FAILURE, 0, _(\"multiple random sources specified\"));\n        random_source = optarg;\n        break;\n\n      case 'r':\n        repeat = true;\n        break;\n\n      case 'z':\n        eolbyte = '\\0';\n        break;\n\n      case_GETOPT_HELP_CHAR;\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n      default:\n        usage (EXIT_FAILURE);\n      }\n\n  n_operands = argc - optind;\n  operand = argv + optind;\n\n  /* Check invalid usage.  */\n  if (echo && input_range)\n    {\n      error (0, 0, _(\"cannot combine -e and -i options\"));\n      usage (EXIT_FAILURE);\n    }\n  if (input_range ? 0 < n_operands : !echo && 1 < n_operands)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (operand[!input_range]));\n      usage (EXIT_FAILURE);\n    }\n\n  /* Prepare input.  */\n  if (head_lines == 0)\n    {\n      n_lines = 0;\n      line = nullptr;\n    }\n  else if (echo)\n    {\n      input_from_argv (operand, n_operands, eolbyte);\n      n_lines = n_operands;\n      line = operand;\n    }\n  else if (input_range)\n    {\n      n_lines = hi_input - lo_input + 1;\n      line = nullptr;\n    }\n  else\n    {\n      /* If an input file is specified, re-open it as stdin.  */\n      if (n_operands == 1\n          && ! (STREQ (operand[0], \"-\")\n                || freopen (operand[0], \"r\", stdin)))\n        error (EXIT_FAILURE, errno, \"%s\", quotef (operand[0]));\n\n      fadvise (stdin, FADVISE_SEQUENTIAL);\n\n      if (repeat || head_lines == SIZE_MAX\n          || input_size () <= RESERVOIR_MIN_INPUT)\n        {\n          n_lines = read_input (stdin, eolbyte, &input_lines);\n          line = input_lines;\n        }\n      else\n        {\n          use_reservoir_sampling = true;\n          n_lines = SIZE_MAX;   /* unknown number of input lines, for now.  */\n        }\n    }\n\n  /* The adjusted head line count; can be less than HEAD_LINES if the\n     input is small and if not repeating.  */\n  size_t ahead_lines = repeat || head_lines < n_lines ? head_lines : n_lines;\n\n  randint_source = randint_all_new (random_source,\n                                    (use_reservoir_sampling || repeat\n                                     ? SIZE_MAX\n                                     : randperm_bound (ahead_lines, n_lines)));\n  if (! randint_source)\n    error (EXIT_FAILURE, errno, \"%s\",\n           quotef (random_source ? random_source : \"getrandom\"));\n\n  if (use_reservoir_sampling)\n    {\n      /* Instead of reading the entire file into 'line',\n         use reservoir-sampling to store just AHEAD_LINES random lines.  */\n      n_lines = read_input_reservoir_sampling (stdin, eolbyte, ahead_lines,\n                                               randint_source, &reservoir);\n      ahead_lines = n_lines;\n    }\n\n  /* Close stdin now, rather than earlier, so that randint_all_new\n     doesn't have to worry about opening something other than\n     stdin.  */\n  if (! (head_lines == 0 || echo || input_range || fclose (stdin) == 0))\n    error (EXIT_FAILURE, errno, _(\"read error\"));\n\n  if (!repeat)\n    permutation = randperm_new (randint_source, ahead_lines, n_lines);\n\n  if (outfile && ! freopen (outfile, \"w\", stdout))\n    error (EXIT_FAILURE, errno, \"%s\", quotef (outfile));\n\n  /* Generate output according to requested method */\n  if (repeat)\n    {\n      if (head_lines == 0)\n        i = 0;\n      else\n        {\n          if (n_lines == 0)\n            error (EXIT_FAILURE, 0, _(\"no lines to repeat\"));\n          if (input_range)\n            i = write_random_numbers (randint_source, ahead_lines,\n                                      lo_input, hi_input, eolbyte);\n          else\n            i = write_random_lines (randint_source, ahead_lines, line, n_lines);\n        }\n    }\n  else\n    {\n      if (use_reservoir_sampling)\n        i = write_permuted_output_reservoir (n_lines, reservoir, permutation);\n      else if (input_range)\n        i = write_permuted_numbers (ahead_lines, lo_input,\n                                    permutation, eolbyte);\n      else\n        i = write_permuted_lines (ahead_lines, line, permutation);\n    }\n\n  if (i != 0)\n    write_error ();\n\n  main_exit (EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}