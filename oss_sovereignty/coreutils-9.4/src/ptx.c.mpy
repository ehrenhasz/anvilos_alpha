{
  "module_name": "ptx.c",
  "hash_id": "7945dcb8d1ee3385f8aa6de81e723d4090c8d6266dd0dd5952fcde1e34696825",
  "original_prompt": "Ingested from coreutils-9.4/src/ptx.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include <regex.h>\n#include \"argmatch.h\"\n#include \"fadvise.h\"\n#include \"quote.h\"\n#include \"read-file.h\"\n#include \"stdio--.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"ptx\"\n\n \n#define AUTHORS proper_name_lite (\"F. Pinard\", \"Fran\\xc3\\xa7ois Pinard\")\n\n \n#define CHAR_SET_SIZE 256\n\n#define ISODIGIT(C) ((C) >= '0' && (C) <= '7')\n#define HEXTOBIN(C) ((C) >= 'a' && (C) <= 'f' ? (C)-'a'+10 \\\n                     : (C) >= 'A' && (C) <= 'F' ? (C)-'A'+10 : (C)-'0')\n#define OCTTOBIN(C) ((C) - '0')\n\n \n\n#if WITH_DMALLOC\n# define MALLOC_FUNC_CHECK 1\n# include <dmalloc.h>\n#endif\n\n \n\n \n\n \n\nenum Format\n{\n  UNKNOWN_FORMAT,\t\t \n  DUMB_FORMAT,\t\t\t \n  ROFF_FORMAT,\t\t\t \n  TEX_FORMAT\t\t\t \n};\n\nstatic bool gnu_extensions = true;\t \nstatic bool auto_reference = false;\t \nstatic bool input_reference = false;\t \nstatic bool right_reference = false;\t \nstatic ptrdiff_t line_width = 72;\t \nstatic ptrdiff_t gap_size = 3;\t \nstatic char const *truncation_string = \"/\";\n                                 \nstatic char const *macro_name = \"xx\";\t \nstatic enum Format output_format = UNKNOWN_FORMAT;\n                                 \n\nstatic bool ignore_case = false;\t \nstatic char const *break_file = nullptr;  \nstatic char const *only_file = nullptr;\t \nstatic char const *ignore_file = nullptr;  \n\n \nstruct regex_data\n{\n   \n  char const *string;\n\n   \n  struct re_pattern_buffer pattern;\n  char fastmap[UCHAR_MAX + 1];\n};\n\nstatic struct regex_data context_regex;\t \nstatic struct regex_data word_regex;\t \n\n \n\ntypedef struct\n  {\n    char *start;\t\t \n    char *end;\t\t\t \n  }\nBLOCK;\n\ntypedef struct\n  {\n    char *start;\t\t \n    ptrdiff_t size;\t\t \n  }\nWORD;\n\ntypedef struct\n  {\n    WORD *start;\t\t \n    size_t alloc;\t\t \n    ptrdiff_t length;\t\t \n  }\nWORD_TABLE;\n\n \n\n \nstatic unsigned char folded_chars[CHAR_SET_SIZE];\n\n \nstatic struct re_registers context_regs;\n\n \nstatic struct re_registers word_regs;\n\n \nstatic char word_fastmap[CHAR_SET_SIZE];\n\n \nstatic ptrdiff_t maximum_word_length;\n\n \nstatic ptrdiff_t reference_max_width;\n\n \n\nstatic WORD_TABLE ignore_table;\t \nstatic WORD_TABLE only_table;\t\t \n\n \n\nstatic int number_input_files;\t \nstatic intmax_t total_line_count;\t \nstatic char const **input_file_name;\t \nstatic intmax_t *file_line_count;\t \n\nstatic BLOCK *text_buffers;\t \n\n \n\n#define SKIP_NON_WHITE(cursor, limit) \\\n  while (cursor < limit && ! isspace (to_uchar (*cursor)))\t\t\\\n    cursor++\n\n#define SKIP_WHITE(cursor, limit) \\\n  while (cursor < limit && isspace (to_uchar (*cursor)))\t\t\\\n    cursor++\n\n#define SKIP_WHITE_BACKWARDS(cursor, start) \\\n  while (cursor > start && isspace (to_uchar (cursor[-1])))\t\t\\\n    cursor--\n\n#define SKIP_SOMETHING(cursor, limit) \\\n  if (word_regex.string)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      regoff_t count;\t\t\t\t\t\t\t\\\n      count = re_match (&word_regex.pattern, cursor, limit - cursor,\t\\\n                        0, nullptr);\t\t\t\t\t\\\n      if (count == -2)\t\t\t\t\t\t\t\\\n        matcher_error ();\t\t\t\t\t\t\\\n      cursor += count == -1 ? 1 : count;\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else if (word_fastmap[to_uchar (*cursor)])\t\t\t\t\\\n    while (cursor < limit && word_fastmap[to_uchar (*cursor)])\t\t\\\n      cursor++;\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    cursor++\n\n \n\ntypedef struct\n  {\n    WORD key;\t\t\t \n    ptrdiff_t left;\t\t \n    ptrdiff_t right;\t\t \n    intmax_t reference;\t\t \n    int file_index;\t\t \n  }\nOCCURS;\n\n \n\nstatic OCCURS *occurs_table[1];\t \nstatic size_t occurs_alloc[1];\t \nstatic ptrdiff_t number_of_occurs[1];  \n\n\n \n\n \nstatic char edited_flag[CHAR_SET_SIZE];\n\n \nstatic ptrdiff_t half_line_width;\n\n \nstatic ptrdiff_t before_max_width;\n\n \nstatic ptrdiff_t keyafter_max_width;\n\n \nstatic ptrdiff_t truncation_string_length;\n\n \n\nstatic BLOCK tail;\t\t \nstatic bool tail_truncation;\t \n\nstatic BLOCK before;\t\t \nstatic bool before_truncation;\t \n\nstatic BLOCK keyafter;\t\t \nstatic bool keyafter_truncation;  \n\nstatic BLOCK head;\t\t \nstatic bool head_truncation;\t \n\nstatic BLOCK reference;\t\t \n\n \n\n \n\nstatic void\nmatcher_error (void)\n{\n  error (EXIT_FAILURE, errno, _(\"error in regular expression matcher\"));\n}\n\n \n\nstatic void\nunescape_string (char *string)\n{\n  char *cursor;\t\t\t \n  int value;\t\t\t \n  int length;\t\t\t \n\n  cursor = string;\n\n  while (*string)\n    {\n      if (*string == '\\\\')\n        {\n          string++;\n          switch (*string)\n            {\n            case 'x':\t\t \n              value = 0;\n              for (length = 0, string++;\n                   length < 3 && isxdigit (to_uchar (*string));\n                   length++, string++)\n                value = value * 16 + HEXTOBIN (*string);\n              if (length == 0)\n                {\n                  *cursor++ = '\\\\';\n                  *cursor++ = 'x';\n                }\n              else\n                *cursor++ = value;\n              break;\n\n            case '0':\t\t \n              value = 0;\n              for (length = 0, string++;\n                   length < 3 && ISODIGIT (*string);\n                   length++, string++)\n                value = value * 8 + OCTTOBIN (*string);\n              *cursor++ = value;\n              break;\n\n            case 'a':\t\t \n#if __STDC__\n              *cursor++ = '\\a';\n#else\n              *cursor++ = 7;\n#endif\n              string++;\n              break;\n\n            case 'b':\t\t \n              *cursor++ = '\\b';\n              string++;\n              break;\n\n            case 'c':\t\t \n              while (*string)\n                string++;\n              break;\n\n            case 'f':\t\t \n              *cursor++ = '\\f';\n              string++;\n              break;\n\n            case 'n':\t\t \n              *cursor++ = '\\n';\n              string++;\n              break;\n\n            case 'r':\t\t \n              *cursor++ = '\\r';\n              string++;\n              break;\n\n            case 't':\t\t \n              *cursor++ = '\\t';\n              string++;\n              break;\n\n            case 'v':\t\t \n#if __STDC__\n              *cursor++ = '\\v';\n#else\n              *cursor++ = 11;\n#endif\n              string++;\n              break;\n\n            case '\\0':\t\t \n               \n              break;\n\n            default:\n              *cursor++ = '\\\\';\n              *cursor++ = *string++;\n              break;\n            }\n        }\n      else\n        *cursor++ = *string++;\n    }\n\n  *cursor = '\\0';\n}\n\n \n\nstatic void\ncompile_regex (struct regex_data *regex)\n{\n  struct re_pattern_buffer *pattern = &regex->pattern;\n  char const *string = regex->string;\n  char const *message;\n\n  pattern->buffer = nullptr;\n  pattern->allocated = 0;\n  pattern->fastmap = regex->fastmap;\n  pattern->translate = ignore_case ? folded_chars : nullptr;\n\n  message = re_compile_pattern (string, strlen (string), pattern);\n  if (message)\n    error (EXIT_FAILURE, 0, _(\"%s (for regexp %s)\"), message, quote (string));\n\n   \n\n  re_compile_fastmap (pattern);\n}\n\n \n\nstatic void\ninitialize_regex (void)\n{\n  int character;\t\t \n\n   \n\n  if (ignore_case)\n    for (character = 0; character < CHAR_SET_SIZE; character++)\n      folded_chars[character] = toupper (character);\n\n   \n\n  if (context_regex.string)\n    {\n      if (!*context_regex.string)\n        context_regex.string = nullptr;\n    }\n  else if (gnu_extensions && !input_reference)\n    context_regex.string = \"[.?!][]\\\"')}]*\\\\($\\\\|\\t\\\\|  \\\\)[ \\t\\n]*\";\n  else\n    context_regex.string = \"\\n\";\n\n  if (context_regex.string)\n    compile_regex (&context_regex);\n\n   \n\n  if (word_regex.string)\n    compile_regex (&word_regex);\n  else if (!break_file)\n    {\n      if (gnu_extensions)\n        {\n\n           \n\n          for (character = 0; character < CHAR_SET_SIZE; character++)\n            word_fastmap[character] = !! isalpha (character);\n        }\n      else\n        {\n\n           \n\n          memset (word_fastmap, 1, CHAR_SET_SIZE);\n          word_fastmap[' '] = 0;\n          word_fastmap['\\t'] = 0;\n          word_fastmap['\\n'] = 0;\n        }\n    }\n}\n\n \n\nstatic void\nswallow_file_in_memory (char const *file_name, BLOCK *block)\n{\n  size_t used_length;\t\t \n\n   \n  bool using_stdin = !file_name || !*file_name || STREQ (file_name, \"-\");\n  if (using_stdin)\n    block->start = fread_file (stdin, 0, &used_length);\n  else\n    block->start = read_file (file_name, 0, &used_length);\n\n  if (!block->start)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (using_stdin ? \"-\" : file_name));\n\n  if (using_stdin)\n    clearerr (stdin);\n\n  block->end = block->start + used_length;\n}\n\n \n\n \n\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  ptrdiff_t length;\t\t \n  ptrdiff_t counter;\t\t \n  int value;\t\t\t \n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n        {\n          value = (folded_chars [to_uchar (first->start[counter])]\n                   - folded_chars [to_uchar (second->start[counter])]);\n          if (value != 0)\n            return value;\n        }\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n        {\n          value = (to_uchar (first->start[counter])\n                   - to_uchar (second->start[counter]));\n          if (value != 0)\n            return value;\n        }\n    }\n\n  return (first->size > second->size) - (first->size < second->size);\n#undef first\n#undef second\n}\n\n \n\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return (value ? value\n          : ((first->key.start > second->key.start)\n             - (first->key.start < second->key.start)));\n#undef first\n#undef second\n}\n\n \n\nATTRIBUTE_PURE\nstatic bool\nsearch_table (WORD *word, WORD_TABLE *table)\n{\n  ptrdiff_t lowest;\t\t \n  ptrdiff_t highest;\t\t \n  ptrdiff_t middle;\t\t \n  int value;\t\t\t \n\n  lowest = 0;\n  highest = table->length - 1;\n  while (lowest <= highest)\n    {\n      middle = (lowest + highest) / 2;\n      value = compare_words (word, table->start + middle);\n      if (value < 0)\n        highest = middle - 1;\n      else if (value > 0)\n        lowest = middle + 1;\n      else\n        return true;\n    }\n  return false;\n}\n\n \n\nstatic void\nsort_found_occurs (void)\n{\n\n   \n  if (number_of_occurs[0])\n    qsort (occurs_table[0], number_of_occurs[0], sizeof **occurs_table,\n           compare_occurs);\n}\n\n \n\n \n\nstatic void\ndigest_break_file (char const *file_name)\n{\n  BLOCK file_contents;\t\t \n  char *cursor;\t\t\t \n\n  swallow_file_in_memory (file_name, &file_contents);\n\n   \n\n  memset (word_fastmap, 1, CHAR_SET_SIZE);\n  for (cursor = file_contents.start; cursor < file_contents.end; cursor++)\n    word_fastmap[to_uchar (*cursor)] = 0;\n\n  if (!gnu_extensions)\n    {\n\n       \n\n      word_fastmap[' '] = 0;\n      word_fastmap['\\t'] = 0;\n      word_fastmap['\\n'] = 0;\n    }\n\n   \n\n  free (file_contents.start);\n}\n\n \n\nstatic void\ndigest_word_file (char const *file_name, WORD_TABLE *table)\n{\n  BLOCK file_contents;\t\t \n  char *cursor;\t\t\t \n  char *word_start;\t\t \n\n  swallow_file_in_memory (file_name, &file_contents);\n\n  table->start = nullptr;\n  table->alloc = 0;\n  table->length = 0;\n\n   \n\n  cursor = file_contents.start;\n  while (cursor < file_contents.end)\n    {\n\n       \n\n      word_start = cursor;\n      while (cursor < file_contents.end && *cursor != '\\n')\n        cursor++;\n\n       \n\n      if (cursor > word_start)\n        {\n          if (table->length == table->alloc)\n            table->start = x2nrealloc (table->start, &table->alloc,\n                                       sizeof *table->start);\n          table->start[table->length].start = word_start;\n          table->start[table->length].size = cursor - word_start;\n          table->length++;\n        }\n\n       \n\n      if (cursor < file_contents.end)\n        cursor++;\n    }\n\n   \n\n  qsort (table->start, table->length, sizeof table->start[0], compare_words);\n}\n\n \n\n \n\nstatic void\nfind_occurs_in_text (int file_index)\n{\n  char *cursor;\t\t\t \n  char *scan;\t\t\t \n  char *line_start;\t\t \n  char *line_scan;\t\t \n  ptrdiff_t reference_length;\t \n  WORD possible_key;\t\t \n  OCCURS *occurs_cursor;\t \n\n  char *context_start;\t\t \n  char *context_end;\t\t \n  char *word_start;\t\t \n  char *word_end;\t\t \n  char *next_context_start;\t \n\n  const BLOCK *text_buffer = &text_buffers[file_index];\n\n   \n\n  reference_length = 0;\n\n   \n\n  line_start = text_buffer->start;\n  line_scan = line_start;\n  if (input_reference)\n    {\n      SKIP_NON_WHITE (line_scan, text_buffer->end);\n      reference_length = line_scan - line_start;\n      SKIP_WHITE (line_scan, text_buffer->end);\n    }\n\n   \n\n  for (cursor = text_buffer->start;\n       cursor < text_buffer->end;\n       cursor = next_context_start)\n    {\n\n       \n\n      context_start = cursor;\n\n       \n\n      next_context_start = text_buffer->end;\n      if (context_regex.string)\n        switch (re_search (&context_regex.pattern, cursor,\n                           text_buffer->end - cursor,\n                           0, text_buffer->end - cursor, &context_regs))\n          {\n          case -2:\n            matcher_error ();\n\n          case -1:\n            break;\n\n          case 0:\n            error (EXIT_FAILURE, 0,\n                   _(\"error: regular expression has a match of length zero:\"\n                     \" %s\"),\n                   quote (context_regex.string));\n\n          default:\n            next_context_start = cursor + context_regs.end[0];\n            break;\n          }\n\n       \n\n      context_end = next_context_start;\n      SKIP_WHITE_BACKWARDS (context_end, context_start);\n\n       \n\n      while (true)\n        {\n          if (word_regex.string)\n\n             \n\n            {\n              regoff_t r = re_search (&word_regex.pattern, cursor,\n                                      context_end - cursor,\n                                      0, context_end - cursor, &word_regs);\n              if (r == -2)\n                matcher_error ();\n              if (r == -1)\n                break;\n              word_start = cursor + word_regs.start[0];\n              word_end = cursor + word_regs.end[0];\n            }\n          else\n\n             \n\n            {\n              scan = cursor;\n              while (scan < context_end\n                     && !word_fastmap[to_uchar (*scan)])\n                scan++;\n\n              if (scan == context_end)\n                break;\n\n              word_start = scan;\n\n              while (scan < context_end\n                     && word_fastmap[to_uchar (*scan)])\n                scan++;\n\n              word_end = scan;\n            }\n\n           \n\n          cursor = word_start;\n\n           \n\n          if (word_end == word_start)\n            {\n              cursor++;\n              continue;\n            }\n\n           \n\n          possible_key.start = cursor;\n          possible_key.size = word_end - word_start;\n          cursor += possible_key.size;\n\n          if (possible_key.size > maximum_word_length)\n            maximum_word_length = possible_key.size;\n\n           \n\n          if (input_reference)\n            {\n              while (line_scan < possible_key.start)\n                if (*line_scan == '\\n')\n                  {\n                    total_line_count++;\n                    line_scan++;\n                    line_start = line_scan;\n                    SKIP_NON_WHITE (line_scan, text_buffer->end);\n                    reference_length = line_scan - line_start;\n                  }\n                else\n                  line_scan++;\n              if (line_scan > possible_key.start)\n                continue;\n            }\n\n           \n\n          if (ignore_file && search_table (&possible_key, &ignore_table))\n            continue;\n          if (only_file && !search_table (&possible_key, &only_table))\n            continue;\n\n           \n\n          if (number_of_occurs[0] == occurs_alloc[0])\n            occurs_table[0] = x2nrealloc (occurs_table[0],\n                                          &occurs_alloc[0],\n                                          sizeof *occurs_table[0]);\n          occurs_cursor = occurs_table[0] + number_of_occurs[0];\n\n           \n\n          if (auto_reference)\n            {\n\n               \n\n              while (line_scan < possible_key.start)\n                if (*line_scan == '\\n')\n                  {\n                    total_line_count++;\n                    line_scan++;\n                    line_start = line_scan;\n                    SKIP_NON_WHITE (line_scan, text_buffer->end);\n                  }\n                else\n                  line_scan++;\n\n              occurs_cursor->reference = total_line_count;\n            }\n          else if (input_reference)\n            {\n\n               \n\n              occurs_cursor->reference = line_start - possible_key.start;\n              if (reference_length > reference_max_width)\n                reference_max_width = reference_length;\n            }\n\n           \n\n          if (input_reference && line_start == context_start)\n            {\n              SKIP_NON_WHITE (context_start, context_end);\n              SKIP_WHITE (context_start, context_end);\n            }\n\n           \n\n          occurs_cursor->key = possible_key;\n          occurs_cursor->left = context_start - possible_key.start;\n          occurs_cursor->right = context_end - possible_key.start;\n          occurs_cursor->file_index = file_index;\n\n          number_of_occurs[0]++;\n        }\n    }\n}\n\n \n\n \n\nstatic void\nprint_spaces (ptrdiff_t number)\n{\n  for (ptrdiff_t counter = number; counter > 0; counter--)\n    putchar (' ');\n}\n\n \n\nstatic void\nprint_field (BLOCK field)\n{\n  char *cursor;\t\t\t \n\n   \n\n  for (cursor = field.start; cursor < field.end; cursor++)\n    {\n      unsigned char character = *cursor;\n      if (edited_flag[character])\n        {\n           \n\n          switch (character)\n            {\n            case '\"':\n               \n              putchar ('\"');\n              putchar ('\"');\n              break;\n\n            case '$':\n            case '%':\n            case '&':\n            case '#':\n            case '_':\n               \n              putchar ('\\\\');\n              putchar (character);\n              break;\n\n            case '{':\n            case '}':\n               \n              printf (\"$\\\\%c$\", character);\n              break;\n\n            case '\\\\':\n               \n              fputs (\"\\\\backslash{}\", stdout);\n              break;\n\n            default:\n               \n              putchar (' ');\n            }\n        }\n      else\n        putchar (*cursor);\n    }\n}\n\n \n\n \n\nstatic void\nfix_output_parameters (void)\n{\n  size_t file_index;\t\t \n  intmax_t line_ordinal;\t \n  ptrdiff_t reference_width;\t \n  int character;\t\t \n  char const *cursor;\t\t \n\n   \n\n  if (auto_reference)\n    {\n      reference_max_width = 0;\n      for (file_index = 0; file_index < number_input_files; file_index++)\n        {\n          line_ordinal = file_line_count[file_index] + 1;\n          if (file_index > 0)\n            line_ordinal -= file_line_count[file_index - 1];\n          char ordinal_string[INT_BUFSIZE_BOUND (intmax_t)];\n          reference_width = sprintf (ordinal_string, \"%\"PRIdMAX, line_ordinal);\n          if (input_file_name[file_index])\n            reference_width += strlen (input_file_name[file_index]);\n          if (reference_width > reference_max_width)\n            reference_max_width = reference_width;\n        }\n      reference_max_width++;\n      reference.start = xmalloc (reference_max_width + 1);\n    }\n\n   \n\n  if ((auto_reference || input_reference) && !right_reference)\n    line_width -= reference_max_width + gap_size;\n  if (line_width < 0)\n    line_width = 0;\n\n   \n\n  half_line_width = line_width / 2;\n  before_max_width = half_line_width - gap_size;\n  keyafter_max_width = half_line_width;\n\n   \n\n  if (truncation_string && *truncation_string)\n    truncation_string_length = strlen (truncation_string);\n  else\n    truncation_string = nullptr;\n\n  if (gnu_extensions)\n    {\n\n       \n\n      before_max_width -= 2 * truncation_string_length;\n      if (before_max_width < 0)\n        before_max_width = 0;\n      keyafter_max_width -= 2 * truncation_string_length;\n    }\n  else\n    {\n\n       \n\n      keyafter_max_width -= 2 * truncation_string_length + 1;\n    }\n\n   \n\n  for (character = 0; character < CHAR_SET_SIZE; character++)\n    edited_flag[character] = !! isspace (character);\n  edited_flag['\\f'] = 1;\n\n   \n\n  switch (output_format)\n    {\n    case UNKNOWN_FORMAT:\n       \n\n    case DUMB_FORMAT:\n      break;\n\n    case ROFF_FORMAT:\n\n       \n\n      edited_flag['\"'] = 1;\n      break;\n\n    case TEX_FORMAT:\n\n       \n\n      for (cursor = \"$%&#_{}\\\\\"; *cursor; cursor++)\n        edited_flag[to_uchar (*cursor)] = 1;\n\n      break;\n    }\n}\n\n \n\nstatic void\ndefine_all_fields (OCCURS *occurs)\n{\n  ptrdiff_t tail_max_width;\t \n  ptrdiff_t head_max_width;\t \n  char *cursor;\t\t\t \n  char *left_context_start;\t \n  char *right_context_end;\t \n  char *left_field_start;\t \n  char const *file_name;\t \n  intmax_t line_ordinal;\t \n  char const *buffer_start;\t \n  char const *buffer_end;\t \n\n   \n\n  keyafter.start = occurs->key.start;\n  keyafter.end = keyafter.start + occurs->key.size;\n  left_context_start = keyafter.start + occurs->left;\n  right_context_end = keyafter.start + occurs->right;\n\n  buffer_start = text_buffers[occurs->file_index].start;\n  buffer_end = text_buffers[occurs->file_index].end;\n\n  cursor = keyafter.end;\n  while (cursor < right_context_end\n         && cursor <= keyafter.start + keyafter_max_width)\n    {\n      keyafter.end = cursor;\n      SKIP_SOMETHING (cursor, right_context_end);\n    }\n  if (cursor <= keyafter.start + keyafter_max_width)\n    keyafter.end = cursor;\n\n  keyafter_truncation = truncation_string && keyafter.end < right_context_end;\n\n  SKIP_WHITE_BACKWARDS (keyafter.end, keyafter.start);\n\n   \n\n  if (-occurs->left > half_line_width + maximum_word_length)\n    {\n      left_field_start\n        = keyafter.start - (half_line_width + maximum_word_length);\n      SKIP_SOMETHING (left_field_start, keyafter.start);\n    }\n  else\n    left_field_start = keyafter.start + occurs->left;\n\n   \n\n  before.start = left_field_start;\n  before.end = keyafter.start;\n  SKIP_WHITE_BACKWARDS (before.end, before.start);\n\n  while (before.start + before_max_width < before.end)\n    SKIP_SOMETHING (before.start, before.end);\n\n  if (truncation_string)\n    {\n      cursor = before.start;\n      SKIP_WHITE_BACKWARDS (cursor, buffer_start);\n      before_truncation = cursor > left_context_start;\n    }\n  else\n    before_truncation = false;\n\n  SKIP_WHITE (before.start, buffer_end);\n\n   \n\n  tail_max_width\n    = before_max_width - (before.end - before.start) - gap_size;\n\n  if (tail_max_width > 0)\n    {\n      tail.start = keyafter.end;\n      SKIP_WHITE (tail.start, buffer_end);\n\n      tail.end = tail.start;\n      cursor = tail.end;\n      while (cursor < right_context_end\n             && cursor < tail.start + tail_max_width)\n        {\n          tail.end = cursor;\n          SKIP_SOMETHING (cursor, right_context_end);\n        }\n\n      if (cursor < tail.start + tail_max_width)\n        tail.end = cursor;\n\n      if (tail.end > tail.start)\n        {\n          keyafter_truncation = false;\n          tail_truncation = truncation_string && tail.end < right_context_end;\n        }\n      else\n        tail_truncation = false;\n\n      SKIP_WHITE_BACKWARDS (tail.end, tail.start);\n    }\n  else\n    {\n\n       \n\n      tail.start = nullptr;\n      tail.end = nullptr;\n      tail_truncation = false;\n    }\n\n   \n\n  head_max_width\n    = keyafter_max_width - (keyafter.end - keyafter.start) - gap_size;\n\n  if (head_max_width > 0)\n    {\n      head.end = before.start;\n      SKIP_WHITE_BACKWARDS (head.end, buffer_start);\n\n      head.start = left_field_start;\n      while (head.start + head_max_width < head.end)\n        SKIP_SOMETHING (head.start, head.end);\n\n      if (head.end > head.start)\n        {\n          before_truncation = false;\n          head_truncation = (truncation_string\n                             && head.start > left_context_start);\n        }\n      else\n        head_truncation = false;\n\n      SKIP_WHITE (head.start, head.end);\n    }\n  else\n    {\n\n       \n\n      head.start = nullptr;\n      head.end = nullptr;\n      head_truncation = false;\n    }\n\n  if (auto_reference)\n    {\n\n       \n\n      file_name = input_file_name[occurs->file_index];\n      if (!file_name)\n        file_name = \"\";\n\n      line_ordinal = occurs->reference + 1;\n      if (occurs->file_index > 0)\n        line_ordinal -= file_line_count[occurs->file_index - 1];\n\n      char *file_end = stpcpy (reference.start, file_name);\n      reference.end = file_end + sprintf (file_end, \":%\"PRIdMAX, line_ordinal);\n    }\n  else if (input_reference)\n    {\n\n       \n\n      reference.start = keyafter.start + occurs->reference;\n      reference.end = reference.start;\n      SKIP_NON_WHITE (reference.end, right_context_end);\n    }\n}\n\n \n\n \n\nstatic void\noutput_one_roff_line (void)\n{\n   \n\n  printf (\".%s \\\"\", macro_name);\n  print_field (tail);\n  if (tail_truncation)\n    fputs (truncation_string, stdout);\n  putchar ('\"');\n\n   \n\n  fputs (\" \\\"\", stdout);\n  if (before_truncation)\n    fputs (truncation_string, stdout);\n  print_field (before);\n  putchar ('\"');\n\n   \n\n  fputs (\" \\\"\", stdout);\n  print_field (keyafter);\n  if (keyafter_truncation)\n    fputs (truncation_string, stdout);\n  putchar ('\"');\n\n   \n\n  fputs (\" \\\"\", stdout);\n  if (head_truncation)\n    fputs (truncation_string, stdout);\n  print_field (head);\n  putchar ('\"');\n\n   \n\n  if (auto_reference || input_reference)\n    {\n      fputs (\" \\\"\", stdout);\n      print_field (reference);\n      putchar ('\"');\n    }\n\n  putchar ('\\n');\n}\n\n \n\nstatic void\noutput_one_tex_line (void)\n{\n  BLOCK key;\t\t\t \n  BLOCK after;\t\t\t \n  char *cursor;\t\t\t \n\n  printf (\"\\\\%s \", macro_name);\n  putchar ('{');\n  print_field (tail);\n  fputs (\"}{\", stdout);\n  print_field (before);\n  fputs (\"}{\", stdout);\n  key.start = keyafter.start;\n  after.end = keyafter.end;\n  cursor = keyafter.start;\n  SKIP_SOMETHING (cursor, keyafter.end);\n  key.end = cursor;\n  after.start = cursor;\n  print_field (key);\n  fputs (\"}{\", stdout);\n  print_field (after);\n  fputs (\"}{\", stdout);\n  print_field (head);\n  putchar ('}');\n  if (auto_reference || input_reference)\n    {\n      putchar ('{');\n      print_field (reference);\n      putchar ('}');\n    }\n  putchar ('\\n');\n}\n\n \n\nstatic void\noutput_one_dumb_line (void)\n{\n  if (!right_reference)\n    {\n      if (auto_reference)\n        {\n\n           \n\n          print_field (reference);\n          putchar (':');\n          print_spaces (reference_max_width\n                        + gap_size\n                        - (reference.end - reference.start)\n                        - 1);\n        }\n      else\n        {\n\n           \n\n          print_field (reference);\n          print_spaces (reference_max_width\n                        + gap_size\n                        - (reference.end - reference.start));\n        }\n    }\n\n  if (tail.start < tail.end)\n    {\n       \n\n      print_field (tail);\n      if (tail_truncation)\n        fputs (truncation_string, stdout);\n\n      print_spaces (half_line_width - gap_size\n                    - (before.end - before.start)\n                    - (before_truncation ? truncation_string_length : 0)\n                    - (tail.end - tail.start)\n                    - (tail_truncation ? truncation_string_length : 0));\n    }\n  else\n    print_spaces (half_line_width - gap_size\n                  - (before.end - before.start)\n                  - (before_truncation ? truncation_string_length : 0));\n\n   \n\n  if (before_truncation)\n    fputs (truncation_string, stdout);\n  print_field (before);\n\n  print_spaces (gap_size);\n\n   \n\n  print_field (keyafter);\n  if (keyafter_truncation)\n    fputs (truncation_string, stdout);\n\n  if (head.start < head.end)\n    {\n       \n\n      print_spaces (half_line_width\n                    - (keyafter.end - keyafter.start)\n                    - (keyafter_truncation ? truncation_string_length : 0)\n                    - (head.end - head.start)\n                    - (head_truncation ? truncation_string_length : 0));\n      if (head_truncation)\n        fputs (truncation_string, stdout);\n      print_field (head);\n    }\n  else\n\n    if ((auto_reference || input_reference) && right_reference)\n      print_spaces (half_line_width\n                    - (keyafter.end - keyafter.start)\n                    - (keyafter_truncation ? truncation_string_length : 0));\n\n  if ((auto_reference || input_reference) && right_reference)\n    {\n       \n\n      print_spaces (gap_size);\n      print_field (reference);\n    }\n\n  putchar ('\\n');\n}\n\n \n\nstatic void\ngenerate_all_output (void)\n{\n  ptrdiff_t occurs_index;\t \n  OCCURS *occurs_cursor;\t \n\n   \n\n  tail.start = nullptr;\n  tail.end = nullptr;\n  tail_truncation = false;\n\n  head.start = nullptr;\n  head.end = nullptr;\n  head_truncation = false;\n\n   \n\n  occurs_cursor = occurs_table[0];\n\n  for (occurs_index = 0; occurs_index < number_of_occurs[0]; occurs_index++)\n    {\n       \n\n      define_all_fields (occurs_cursor);\n\n       \n\n      switch (output_format)\n        {\n        case UNKNOWN_FORMAT:\n           \n\n        case DUMB_FORMAT:\n          output_one_dumb_line ();\n          break;\n\n        case ROFF_FORMAT:\n          output_one_roff_line ();\n          break;\n\n        case TEX_FORMAT:\n          output_one_tex_line ();\n          break;\n        }\n\n       \n\n      occurs_cursor++;\n    }\n}\n\n \n\n \n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [INPUT]...   (without -G)\\n\\\n  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nOutput a permuted index, including context, of the words in the input files.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -A, --auto-reference           output automatically generated references\\n\\\n  -G, --traditional              behave more like System V 'ptx'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\\n\\\n                                 The default is '/'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -M, --macro-name=STRING        macro name to use instead of 'xx'\\n\\\n  -O, --format=roff              generate output as roff directives\\n\\\n  -R, --right-side-refs          put references at right, not counted in -w\\n\\\n  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\\n\\\n  -T, --format=tex               generate output as TeX directives\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\\n\\\n  -b, --break-file=FILE          word break characters in this FILE\\n\\\n  -f, --ignore-case              fold lower case to upper case for sorting\\n\\\n  -g, --gap-size=NUMBER          gap size in columns between output fields\\n\\\n  -i, --ignore-file=FILE         read ignore word list from FILE\\n\\\n  -o, --only-file=FILE           read only word list from this FILE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -r, --references               first field of each line is a reference\\n\\\n  -t, --typeset-mode               - not implemented -\\n\\\n  -w, --width=NUMBER             output width in columns, reference excluded\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/*----------------------------------------------------------------------.\n| Main program.  Decode ARGC arguments passed through the ARGV array of |\n| strings, then launch execution.\t\t\t\t        |\n`----------------------------------------------------------------------*/\n\n/* Long options equivalences.  */\nstatic struct option const long_options[] =\n{\n  {\"auto-reference\", no_argument, nullptr, 'A'},\n  {\"break-file\", required_argument, nullptr, 'b'},\n  {\"flag-truncation\", required_argument, nullptr, 'F'},\n  {\"ignore-case\", no_argument, nullptr, 'f'},\n  {\"gap-size\", required_argument, nullptr, 'g'},\n  {\"ignore-file\", required_argument, nullptr, 'i'},\n  {\"macro-name\", required_argument, nullptr, 'M'},\n  {\"only-file\", required_argument, nullptr, 'o'},\n  {\"references\", no_argument, nullptr, 'r'},\n  {\"right-side-refs\", no_argument, nullptr, 'R'},\n  {\"format\", required_argument, nullptr, 10},\n  {\"sentence-regexp\", required_argument, nullptr, 'S'},\n  {\"traditional\", no_argument, nullptr, 'G'},\n  {\"typeset-mode\", no_argument, nullptr, 't'},\n  {\"width\", required_argument, nullptr, 'w'},\n  {\"word-regexp\", required_argument, nullptr, 'W'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0},\n};\n\nstatic char const *const format_args[] =\n{\n  \"roff\", \"tex\", nullptr\n};\n\nstatic enum Format const format_vals[] =\n{\n  ROFF_FORMAT, TEX_FORMAT\n};\n\nint\nmain (int argc, char **argv)\n{\n  int optchar;\t\t\t/* argument character */\n  int file_index;\t\t/* index in text input file arrays */\n\n  /* Decode program options.  */\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n#if HAVE_SETCHRCLASS\n  setchrclass (nullptr);\n#endif\n\n  while (optchar = getopt_long (argc, argv, \"AF:GM:ORS:TW:b:i:fg:o:trw:\",\n                                long_options, nullptr),\n         optchar != EOF)\n    {\n      switch (optchar)\n        {\n        default:\n          usage (EXIT_FAILURE);\n\n        case 'G':\n          gnu_extensions = false;\n          break;\n\n        case 'b':\n          break_file = optarg;\n          break;\n\n        case 'f':\n          ignore_case = true;\n          break;\n\n        case 'g':\n          {\n            intmax_t tmp;\n            if (! (xstrtoimax (optarg, nullptr, 0, &tmp, \"\") == LONGINT_OK\n                   && 0 < tmp && tmp <= PTRDIFF_MAX))\n              error (EXIT_FAILURE, 0, _(\"invalid gap width: %s\"),\n                     quote (optarg));\n            gap_size = tmp;\n            break;\n          }\n\n        case 'i':\n          ignore_file = optarg;\n          break;\n\n        case 'o':\n          only_file = optarg;\n          break;\n\n        case 'r':\n          input_reference = true;\n          break;\n\n        case 't':\n          /* Yet to understand...  */\n          break;\n\n        case 'w':\n          {\n            intmax_t tmp;\n            if (! (xstrtoimax (optarg, nullptr, 0, &tmp, \"\") == LONGINT_OK\n                   && 0 < tmp && tmp <= PTRDIFF_MAX))\n              error (EXIT_FAILURE, 0, _(\"invalid line width: %s\"),\n                     quote (optarg));\n            line_width = tmp;\n            break;\n          }\n\n        case 'A':\n          auto_reference = true;\n          break;\n\n        case 'F':\n          truncation_string = optarg;\n          unescape_string (optarg);\n          break;\n\n        case 'M':\n          macro_name = optarg;\n          break;\n\n        case 'O':\n          output_format = ROFF_FORMAT;\n          break;\n\n        case 'R':\n          right_reference = true;\n          break;\n\n        case 'S':\n          context_regex.string = optarg;\n          unescape_string (optarg);\n          break;\n\n        case 'T':\n          output_format = TEX_FORMAT;\n          break;\n\n        case 'W':\n          word_regex.string = optarg;\n          unescape_string (optarg);\n          if (!*word_regex.string)\n            word_regex.string = nullptr;\n          break;\n\n        case 10:\n          output_format = XARGMATCH (\"--format\", optarg,\n                                     format_args, format_vals);\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        }\n    }\n\n  /* Process remaining arguments.  If GNU extensions are enabled, process\n     all arguments as input parameters.  If disabled, accept at most two\n     arguments, the second of which is an output parameter.  */\n\n  if (optind == argc)\n    {\n\n      /* No more argument simply means: read standard input.  */\n\n      input_file_name = xmalloc (sizeof *input_file_name);\n      file_line_count = xmalloc (sizeof *file_line_count);\n      text_buffers =    xmalloc (sizeof *text_buffers);\n      number_input_files = 1;\n      input_file_name[0] = nullptr;\n    }\n  else if (gnu_extensions)\n    {\n      number_input_files = argc - optind;\n      input_file_name = xnmalloc (number_input_files, sizeof *input_file_name);\n      file_line_count = xnmalloc (number_input_files, sizeof *file_line_count);\n      text_buffers    = xnmalloc (number_input_files, sizeof *text_buffers);\n\n      for (file_index = 0; file_index < number_input_files; file_index++)\n        {\n          if (!*argv[optind] || STREQ (argv[optind], \"-\"))\n            input_file_name[file_index] = nullptr;\n          else\n            input_file_name[file_index] = argv[optind];\n          optind++;\n        }\n    }\n  else\n    {\n\n      /* There is one necessary input file.  */\n\n      number_input_files = 1;\n      input_file_name = xmalloc (sizeof *input_file_name);\n      file_line_count = xmalloc (sizeof *file_line_count);\n      text_buffers    = xmalloc (sizeof *text_buffers);\n      if (!*argv[optind] || STREQ (argv[optind], \"-\"))\n        input_file_name[0] = nullptr;\n      else\n        input_file_name[0] = argv[optind];\n      optind++;\n\n      /* Redirect standard output, only if requested.  */\n\n      if (optind < argc)\n        {\n          if (! freopen (argv[optind], \"w\", stdout))\n            error (EXIT_FAILURE, errno, \"%s\", quotef (argv[optind]));\n          optind++;\n        }\n\n      /* Diagnose any other argument as an error.  */\n\n      if (optind < argc)\n        {\n          error (0, 0, _(\"extra operand %s\"), quote (argv[optind]));\n          usage (EXIT_FAILURE);\n        }\n    }\n\n   \n\n  if (output_format == UNKNOWN_FORMAT)\n    output_format = gnu_extensions ? DUMB_FORMAT : ROFF_FORMAT;\n\n   \n\n  initialize_regex ();\n\n   \n\n  if (break_file)\n    digest_break_file (break_file);\n\n   \n\n  if (ignore_file)\n    {\n      digest_word_file (ignore_file, &ignore_table);\n      if (ignore_table.length == 0)\n        ignore_file = nullptr;\n    }\n\n  if (only_file)\n    {\n      digest_word_file (only_file, &only_table);\n      if (only_table.length == 0)\n        only_file = nullptr;\n    }\n\n   \n\n  number_of_occurs[0] = 0;\n  total_line_count = 0;\n  maximum_word_length = 0;\n  reference_max_width = 0;\n\n  for (file_index = 0; file_index < number_input_files; file_index++)\n    {\n      BLOCK *text_buffer = text_buffers + file_index;\n\n       \n\n      swallow_file_in_memory (input_file_name[file_index], text_buffer);\n      find_occurs_in_text (file_index);\n\n       \n\n      total_line_count++;\n      file_line_count[file_index] = total_line_count;\n    }\n\n   \n\n  sort_found_occurs ();\n  fix_output_parameters ();\n  generate_all_output ();\n\n   \n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}