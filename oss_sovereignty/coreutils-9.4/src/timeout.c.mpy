{
  "module_name": "timeout.c",
  "hash_id": "1c39d6ced71a6c763804279a3e0c84e3a969f8edd8ca4a74d791975dd430c12a",
  "original_prompt": "Ingested from coreutils-9.4/src/timeout.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <signal.h>\n#if HAVE_PRCTL\n# include <sys/prctl.h>\n#endif\n#include <sys/wait.h>\n\n#include \"system.h\"\n#include \"cl-strtod.h\"\n#include \"xstrtod.h\"\n#include \"sig2str.h\"\n#include \"operand2sig.h\"\n#include \"quote.h\"\n\n#if HAVE_SETRLIMIT\n \n# include <sys/resource.h>\n#endif\n\n \n#ifndef SA_RESTART\n# define SA_RESTART 0\n#endif\n\n#define PROGRAM_NAME \"timeout\"\n\n#define AUTHORS proper_name_lite (\"Padraig Brady\", \"P\\303\\241draig Brady\")\n\nstatic int timed_out;\nstatic int term_signal = SIGTERM;   \nstatic pid_t monitored_pid;\nstatic double kill_after;\nstatic bool foreground;       \nstatic bool preserve_status;  \nstatic bool verbose;          \nstatic char const *command;\n\n \nenum\n{\n      FOREGROUND_OPTION = CHAR_MAX + 1,\n      PRESERVE_STATUS_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"kill-after\", required_argument, nullptr, 'k'},\n  {\"signal\", required_argument, nullptr, 's'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {\"foreground\", no_argument, nullptr, FOREGROUND_OPTION},\n  {\"preserve-status\", no_argument, nullptr, PRESERVE_STATUS_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic void\nsettimeout (double duration, bool warn)\n{\n\n#if HAVE_TIMER_SETTIME\n   \n\n  struct timespec ts = dtotimespec (duration);\n  struct itimerspec its = { {0, 0}, ts };\n  timer_t timerid;\n  if (timer_create (CLOCK_REALTIME, nullptr, &timerid) == 0)\n    {\n      if (timer_settime (timerid, 0, &its, nullptr) == 0)\n        return;\n      else\n        {\n          if (warn)\n            error (0, errno, _(\"warning: timer_settime\"));\n          timer_delete (timerid);\n        }\n    }\n  else if (warn && errno != ENOSYS)\n    error (0, errno, _(\"warning: timer_create\"));\n\n#elif HAVE_SETITIMER\n   \n\n  struct timeval tv;\n  struct timespec ts = dtotimespec (duration);\n  tv.tv_sec = ts.tv_sec;\n  tv.tv_usec = (ts.tv_nsec + 999) / 1000;\n  if (tv.tv_usec == 1000 * 1000)\n    {\n      if (tv.tv_sec != TYPE_MAXIMUM (time_t))\n        {\n          tv.tv_sec++;\n          tv.tv_usec = 0;\n        }\n      else\n        tv.tv_usec--;\n    }\n  struct itimerval it = { {0, 0}, tv };\n  if (setitimer (ITIMER_REAL, &it, nullptr) == 0)\n    return;\n  else\n    {\n      if (warn && errno != ENOSYS)\n        error (0, errno, _(\"warning: setitimer\"));\n    }\n#endif\n\n   \n\n  unsigned int timeint;\n  if (UINT_MAX <= duration)\n    timeint = UINT_MAX;\n  else\n    {\n      unsigned int duration_floor = duration;\n      timeint = duration_floor + (duration_floor < duration);\n    }\n  alarm (timeint);\n}\n\n \n\nstatic int\nsend_sig (pid_t where, int sig)\n{\n   \n  if (where == 0)\n    signal (sig, SIG_IGN);\n  return kill (where, sig);\n}\n\n \nstatic void\nchld (int sig)\n{\n}\n\n\nstatic void\ncleanup (int sig)\n{\n  if (sig == SIGALRM)\n    {\n      timed_out = 1;\n      sig = term_signal;\n    }\n  if (monitored_pid)\n    {\n      if (kill_after)\n        {\n          int saved_errno = errno;  \n           \n          term_signal = SIGKILL;\n          settimeout (kill_after, false);\n          kill_after = 0;  \n          errno = saved_errno;\n        }\n\n       \n      if (verbose)\n        {\n          char signame[MAX (SIG2STR_MAX, INT_BUFSIZE_BOUND (int))];\n          if (sig2str (sig, signame) != 0)\n            snprintf (signame, sizeof signame, \"%d\", sig);\n          error (0, 0, _(\"sending signal %s to command %s\"),\n                 signame, quote (command));\n        }\n      send_sig (monitored_pid, sig);\n\n       \n      if (!foreground)\n        {\n          send_sig (0, sig);\n          if (sig != SIGKILL && sig != SIGCONT)\n            {\n              send_sig (monitored_pid, SIGCONT);\n              send_sig (0, SIGCONT);\n            }\n        }\n    }\n  else  \n    _exit (128 + sig);\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION] DURATION COMMAND [ARG]...\\n\\\n  or:  %s [OPTION]\\n\"), program_name, program_name);\n\n      fputs (_(\"\\\nStart COMMAND, and kill it if still running after DURATION.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n      --preserve-status\\n\\\n                 exit with the same status as COMMAND, even when the\\n\\\n                   command times out\\n\\\n      --foreground\\n\\\n                 when not running timeout directly from a shell prompt,\\n\\\n                   allow COMMAND to read from the TTY and get TTY signals;\\n\\\n                   in this mode, children of COMMAND will not be timed out\\n\\\n  -k, --kill-after=DURATION\\n\\\n                 also send a KILL signal if COMMAND is still running\\n\\\n                   this long after the initial signal was sent\\n\\\n  -s, --signal=SIGNAL\\n\\\n                 specify the signal to be sent on timeout;\\n\\\n                   SIGNAL may be a name like 'HUP' or a number;\\n\\\n                   see 'kill -l' for a list of signals\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --verbose  diagnose to stderr any signal sent upon timeout\\n\"), stdout);\n\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n\n      fputs (_(\"\\n\\\nDURATION is a floating point number with an optional suffix:\\n\\\n's' for seconds (the default), 'm' for minutes, 'h' for hours or \\\n'd' for days.\\nA duration of 0 disables the associated timeout.\\n\"), stdout);\n\n      fputs (_(\"\\n\\\nUpon timeout, send the TERM signal to COMMAND, if no other SIGNAL specified.\\n\\\nThe TERM signal kills any process that does not block or catch that signal.\\n\\\nIt may be necessary to use the KILL signal, since this signal can't be caught.\\\n\\n\"), stdout);\n\n      fputs (_(\"\\n\\\nExit status:\\n\\\n  124  if COMMAND times out, and --preserve-status is not specified\\n\\\n  125  if the timeout command itself fails\\n\\\n  126  if COMMAND is found but cannot be invoked\\n\\\n  127  if COMMAND cannot be found\\n\\\n  137  if COMMAND (or timeout itself) is sent the KILL (9) signal (128+9)\\n\\\n  -    the exit status of COMMAND otherwise\\n\\\n\"), stdout);\n\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Given a floating point value *X, and a suffix character, SUFFIX_CHAR,\n   scale *X by the multiplier implied by SUFFIX_CHAR.  SUFFIX_CHAR may\n   be the NUL byte or 's' to denote seconds, 'm' for minutes, 'h' for\n   hours, or 'd' for days.  If SUFFIX_CHAR is invalid, don't modify *X\n   and return false.  Otherwise return true.  */\n\nstatic bool\napply_time_suffix (double *x, char suffix_char)\n{\n  int multiplier;\n\n  switch (suffix_char)\n    {\n    case 0:\n    case 's':\n      multiplier = 1;\n      break;\n    case 'm':\n      multiplier = 60;\n      break;\n    case 'h':\n      multiplier = 60 * 60;\n      break;\n    case 'd':\n      multiplier = 60 * 60 * 24;\n      break;\n    default:\n      return false;\n    }\n\n  *x *= multiplier;\n\n  return true;\n}\n\nstatic double\nparse_duration (char const *str)\n{\n  double duration;\n  char const *ep;\n\n  if (! (xstrtod (str, &ep, &duration, cl_strtod) || errno == ERANGE)\n      /* Nonnegative interval.  */\n      || ! (0 <= duration)\n      /* No extra chars after the number and an optional s,m,h,d char.  */\n      || (*ep && *(ep + 1))\n      /* Check any suffix char and update timeout based on the suffix.  */\n      || !apply_time_suffix (&duration, *ep))\n    {\n      error (0, 0, _(\"invalid time interval %s\"), quote (str));\n      usage (EXIT_CANCELED);\n    }\n\n  return duration;\n}\n\nstatic void\nunblock_signal (int sig)\n{\n  sigset_t unblock_set;\n  sigemptyset (&unblock_set);\n  sigaddset (&unblock_set, sig);\n  if (sigprocmask (SIG_UNBLOCK, &unblock_set, nullptr) != 0)\n    error (0, errno, _(\"warning: sigprocmask\"));\n}\n\nstatic void\ninstall_sigchld (void)\n{\n  struct sigaction sa;\n  sigemptyset (&sa.sa_mask);  /* Allow concurrent calls to handler */\n  sa.sa_handler = chld;\n  sa.sa_flags = SA_RESTART;   /* Restart syscalls if possible, as that's\n                                 more likely to work cleanly.  */\n\n  sigaction (SIGCHLD, &sa, nullptr);\n\n  /* We inherit the signal mask from our parent process,\n     so ensure SIGCHLD is not blocked. */\n  unblock_signal (SIGCHLD);\n}\n\nstatic void\ninstall_cleanup (int sigterm)\n{\n  struct sigaction sa;\n  sigemptyset (&sa.sa_mask);  /* Allow concurrent calls to handler */\n  sa.sa_handler = cleanup;\n  sa.sa_flags = SA_RESTART;   /* Restart syscalls if possible, as that's\n                                 more likely to work cleanly.  */\n\n  sigaction (SIGALRM, &sa, nullptr); /* our timeout.  */\n  sigaction (SIGINT, &sa, nullptr);  /* Ctrl-C at terminal for example.  */\n  sigaction (SIGQUIT, &sa, nullptr); /* Ctrl-\\ at terminal for example.  */\n  sigaction (SIGHUP, &sa, nullptr);  /* terminal closed for example.  */\n  sigaction (SIGTERM, &sa, nullptr); /* if killed, stop monitored proc.  */\n  sigaction (sigterm, &sa, nullptr); /* user specified termination signal.  */\n}\n\n/* Block all signals which were registered with cleanup() as the signal\n   handler, so we never kill processes after waitpid() returns.\n   Also block SIGCHLD to ensure it doesn't fire between\n   waitpid() polling and sigsuspend() waiting for a signal.\n   Return original mask in OLD_SET.  */\nstatic void\nblock_cleanup_and_chld (int sigterm, sigset_t *old_set)\n{\n  sigset_t block_set;\n  sigemptyset (&block_set);\n\n  sigaddset (&block_set, SIGALRM);\n  sigaddset (&block_set, SIGINT);\n  sigaddset (&block_set, SIGQUIT);\n  sigaddset (&block_set, SIGHUP);\n  sigaddset (&block_set, SIGTERM);\n  sigaddset (&block_set, sigterm);\n\n  sigaddset (&block_set, SIGCHLD);\n\n  if (sigprocmask (SIG_BLOCK, &block_set, old_set) != 0)\n    error (0, errno, _(\"warning: sigprocmask\"));\n}\n\n/* Try to disable core dumps for this process.\n   Return TRUE if successful, FALSE otherwise.  */\nstatic bool\ndisable_core_dumps (void)\n{\n#if HAVE_PRCTL && defined PR_SET_DUMPABLE\n  if (prctl (PR_SET_DUMPABLE, 0) == 0)\n    return true;\n\n#elif HAVE_SETRLIMIT && defined RLIMIT_CORE\n  /* Note this doesn't disable processing by a filter in\n     /proc/sys/kernel/core_pattern on Linux.  */\n  if (setrlimit (RLIMIT_CORE, &(struct rlimit) {0,0}) == 0)\n    return true;\n\n#else\n  return false;\n#endif\n\n  error (0, errno, _(\"warning: disabling core dumps failed\"));\n  return false;\n}\n\nint\nmain (int argc, char **argv)\n{\n  double timeout;\n  char signame[SIG2STR_MAX];\n  int c;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXIT_CANCELED);\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"+k:s:v\", long_options, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'k':\n          kill_after = parse_duration (optarg);\n          break;\n\n        case 's':\n          term_signal = operand2sig (optarg, signame);\n          if (term_signal == -1)\n            usage (EXIT_CANCELED);\n          break;\n\n        case 'v':\n          verbose = true;\n          break;\n\n        case FOREGROUND_OPTION:\n          foreground = true;\n          break;\n\n        case PRESERVE_STATUS_OPTION:\n          preserve_status = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_CANCELED);\n          break;\n        }\n    }\n\n  if (argc - optind < 2)\n    usage (EXIT_CANCELED);\n\n  timeout = parse_duration (argv[optind++]);\n\n  argv += optind;\n  command = argv[0];\n\n  /* Ensure we're in our own group so all subprocesses can be killed.\n     Note we don't just put the child in a separate group as\n     then we would need to worry about foreground and background groups\n     and propagating signals between them.  */\n  if (!foreground)\n    setpgid (0, 0);\n\n  /* Setup handlers before fork() so that we\n     handle any signals caused by child, without races.  */\n  install_cleanup (term_signal);\n  signal (SIGTTIN, SIG_IGN);   /* Don't stop if background child needs tty.  */\n  signal (SIGTTOU, SIG_IGN);   /* Don't stop if background child needs tty.  */\n  install_sigchld ();          /* Interrupt sigsuspend() when child exits.   */\n\n  monitored_pid = fork ();\n  if (monitored_pid == -1)\n    {\n      error (0, errno, _(\"fork system call failed\"));\n      return EXIT_CANCELED;\n    }\n  else if (monitored_pid == 0)\n    {                           /* child */\n      /* exec doesn't reset SIG_IGN -> SIG_DFL.  */\n      signal (SIGTTIN, SIG_DFL);\n      signal (SIGTTOU, SIG_DFL);\n\n      execvp (argv[0], argv);\n\n      /* exit like sh, env, nohup, ...  */\n      int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n      error (0, errno, _(\"failed to run command %s\"), quote (command));\n      return exit_status;\n    }\n  else\n    {\n      pid_t wait_result;\n      int status;\n\n      /* We configure timers so that SIGALRM is sent on expiry.\n         Therefore ensure we don't inherit a mask blocking SIGALRM.  */\n      unblock_signal (SIGALRM);\n\n      settimeout (timeout, true);\n\n      /* Ensure we don't cleanup() after waitpid() reaps the child,\n         to avoid sending signals to a possibly different process.  */\n      sigset_t cleanup_set;\n      block_cleanup_and_chld (term_signal, &cleanup_set);\n\n      while ((wait_result = waitpid (monitored_pid, &status, WNOHANG)) == 0)\n        sigsuspend (&cleanup_set);  /* Wait with cleanup signals unblocked.  */\n\n      if (wait_result < 0)\n        {\n          /* shouldn't happen.  */\n          error (0, errno, _(\"error waiting for command\"));\n          status = EXIT_CANCELED;\n        }\n      else\n        {\n          if (WIFEXITED (status))\n            status = WEXITSTATUS (status);\n          else if (WIFSIGNALED (status))\n            {\n              int sig = WTERMSIG (status);\n              if (WCOREDUMP (status))\n                error (0, 0, _(\"the monitored command dumped core\"));\n              if (!timed_out && disable_core_dumps ())\n                {\n                  /* exit with the signal flag set.  */\n                  signal (sig, SIG_DFL);\n                  unblock_signal (sig);\n                  raise (sig);\n                }\n              /* Allow users to distinguish if command was forcibly killed.\n                 Needed with --foreground where we don't send SIGKILL to\n                 the timeout process itself.  */\n              if (timed_out && sig == SIGKILL)\n                preserve_status = true;\n              status = sig + 128; /* what sh returns for signaled processes.  */\n            }\n          else\n            {\n              /* shouldn't happen.  */\n              error (0, 0, _(\"unknown status from command (%d)\"), status);\n              status = EXIT_FAILURE;\n            }\n        }\n\n      if (timed_out && !preserve_status)\n        status = EXIT_TIMEDOUT;\n      return status;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}