{
  "module_name": "iopoll.c",
  "hash_id": "852f9d8eb08ca17debbbfc77e5d159e53d7aef7cc27d4dca92715ad11774601a",
  "original_prompt": "Ingested from coreutils-9.4/src/iopoll.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n\n#if defined _AIX || defined __sun || defined __APPLE__ || \\\n    defined __linux__ || defined __ANDROID__\n# define IOPOLL_USES_POLL 1\n   \n# if defined HAVE_POLL\n#  error \"gnulib's poll() replacement is currently incompatible\"\n# endif\n#endif\n\n#if IOPOLL_USES_POLL\n# include <poll.h>\n#else\n# include <sys/select.h>\n#endif\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"iopoll.h\"\n#include \"isapipe.h\"\n\n\n \n\nstatic int\niopoll_internal (int fdin, int fdout, bool block, bool broken_output)\n{\n  affirm (fdin != -1 || fdout != -1);\n\n#if IOPOLL_USES_POLL\n  struct pollfd pfds[2] = {   \n    { .fd = fdin,  .events = POLLIN | POLLRDBAND, .revents = 0 },\n    { .fd = fdout, .events = POLLRDBAND, .revents = 0 },\n  };\n  int check_out_events = POLLERR | POLLHUP | POLLNVAL;\n  int ret = 0;\n\n  if (! broken_output)\n    {\n      pfds[0].events = pfds[1].events = POLLOUT;\n      check_out_events = POLLOUT;\n    }\n\n  while (0 <= ret || errno == EINTR)\n    {\n      ret = poll (pfds, 2, block ? -1 : 0);\n\n      if (ret < 0)\n        continue;\n      if (ret == 0 && ! block)\n        return 0;\n      affirm (0 < ret);\n      if (pfds[0].revents)  \n        return 0;           \n      if (pfds[1].revents & check_out_events)\n        return broken_output ? IOPOLL_BROKEN_OUTPUT : 0;\n    }\n\n#else   \n\n  int nfds = (fdin > fdout ? fdin : fdout) + 1;\n  int ret = 0;\n\n  if (FD_SETSIZE < nfds)\n    {\n      errno = EINVAL;\n      ret = -1;\n    }\n\n   \n  while (0 <= ret || errno == EINTR)\n    {\n      fd_set fds;\n      FD_ZERO (&fds);\n      if (0 <= fdin)\n        FD_SET (fdin, &fds);\n      if (0 <= fdout)\n        FD_SET (fdout, &fds);\n\n      struct timeval delay = { .tv_sec = 0, .tv_usec = 0 };\n      ret = select (nfds,\n                    broken_output ? &fds : nullptr,\n                    broken_output ? nullptr : &fds,\n                    nullptr, block ? nullptr : &delay);\n\n      if (ret < 0)\n        continue;\n      if (ret == 0 && ! block)\n        return 0;\n      affirm (0 < ret);\n      if (0 <= fdin && FD_ISSET (fdin, &fds))     \n        return 0;           \n      if (0 <= fdout && FD_ISSET (fdout, &fds))   \n        return broken_output ? IOPOLL_BROKEN_OUTPUT : 0;\n    }\n\n#endif\n  return IOPOLL_ERROR;\n}\n\nextern int\niopoll (int fdin, int fdout, bool block)\n{\n  return iopoll_internal (fdin, fdout, block, true);\n}\n\n\n\n \n\nextern bool\niopoll_input_ok (int fdin)\n{\n  struct stat st;\n  bool always_ready = fstat (fdin, &st) == 0\n                      && (S_ISREG (st.st_mode)\n                          || S_ISBLK (st.st_mode));\n  return ! always_ready;\n}\n\n \n\nextern bool\niopoll_output_ok (int fdout)\n{\n  return isapipe (fdout) > 0;\n}\n\n#ifdef EWOULDBLOCK\n# define IS_EAGAIN(errcode) ((errcode) == EAGAIN || (errcode) == EWOULDBLOCK)\n#else\n# define IS_EAGAIN(errcode) ((errcode) == EAGAIN)\n#endif\n\n \n\nstatic bool\nfwait_for_nonblocking_write (FILE *f)\n{\n  if (! IS_EAGAIN (errno))\n     \n    return false;\n\n  int fd = fileno (f);\n  if (fd == -1)\n    goto fail;\n\n   \n  if (iopoll_internal (-1, fd, true, false) != 0)\n    goto fail;\n\n   \n  clearerr (f);\n  return true;\n\nfail:\n  errno = EAGAIN;\n  return false;\n}\n\n\n \n\nextern bool\nfclose_wait (FILE *f)\n{\n  for (;;)\n    {\n      if (fflush (f) == 0)\n        break;\n\n      if (! fwait_for_nonblocking_write (f))\n        break;\n    }\n\n  return fclose (f) == 0;\n}\n\n\n \n\nextern bool\nfwrite_wait (char const *buf, ssize_t size, FILE *f)\n{\n  for (;;)\n    {\n      const size_t written = fwrite (buf, 1, size, f);\n      size -= written;\n      affirm (size >= 0);\n      if (size <= 0)   \n        return true;\n\n      if (! fwait_for_nonblocking_write (f))\n        return false;\n\n      buf += written;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}