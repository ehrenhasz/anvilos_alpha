{
  "module_name": "sleep.c",
  "hash_id": "dc8aa9aa5c5f7b2bf9037ddd390cc3c3b4e4bc504e271e519b1fcb64577e6ce2",
  "original_prompt": "Ingested from coreutils-9.4/src/sleep.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"sleep\"\n\n#define AUTHORS \\\n  proper_name (\"Jim Meyering\"), \\\n  proper_name (\"Paul Eggert\")\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s NUMBER[SUFFIX]...\\n\\\n  or:  %s OPTION\\n\\\nPause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\\n\\\n'm' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\\n\\\ninteger.  Given two or more arguments, pause for the amount of time\\n\\\nspecified by the sum of their values.\\n\\\n\\n\\\n\"),\n              program_name, program_name);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Given a floating point value *X, and a suffix character, SUFFIX_CHAR,\n   scale *X by the multiplier implied by SUFFIX_CHAR.  SUFFIX_CHAR may\n   be the NUL byte or 's' to denote seconds, 'm' for minutes, 'h' for\n   hours, or 'd' for days.  If SUFFIX_CHAR is invalid, don't modify *X\n   and return false.  Otherwise return true.  */\n\nstatic bool\napply_suffix (double *x, char suffix_char)\n{\n  int multiplier;\n\n  switch (suffix_char)\n    {\n    case 0:\n    case 's':\n      multiplier = 1;\n      break;\n    case 'm':\n      multiplier = 60;\n      break;\n    case 'h':\n      multiplier = 60 * 60;\n      break;\n    case 'd':\n      multiplier = 60 * 60 * 24;\n      break;\n    default:\n      return false;\n    }\n\n  *x *= multiplier;\n\n  return true;\n}\n\nint\nmain (int argc, char **argv)\n{\n  double seconds = 0.0;\n  bool ok = true;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE_NAME,\n                                   Version, true, usage, AUTHORS,\n                                   (char const *) nullptr);\n\n  if (argc == 1)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  for (int i = optind; i < argc; i++)\n    {\n      double s;\n      char const *p;\n      if (! (xstrtod (argv[i], &p, &s, cl_strtod) || errno == ERANGE)\n          /* Nonnegative interval.  */\n          || ! (0 <= s)\n          /* No extra chars after the number and an optional s,m,h,d char.  */\n          || (*p && *(p + 1))\n          /* Check any suffix char and update S based on the suffix.  */\n          || ! apply_suffix (&s, *p))\n        {\n          error (0, 0, _(\"invalid time interval %s\"), quote (argv[i]));\n          ok = false;\n        }\n\n      seconds += s;\n    }\n\n  if (!ok)\n    usage (EXIT_FAILURE);\n\n  if (xnanosleep (seconds))\n    error (EXIT_FAILURE, errno, _(\"cannot read realtime clock\"));\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}