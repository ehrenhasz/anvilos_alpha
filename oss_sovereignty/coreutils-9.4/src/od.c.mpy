{
  "module_name": "od.c",
  "hash_id": "73e640aabc0f653b989190ae8a2164f58f4ca4d558dee186983fd4a7b2fa9066",
  "original_prompt": "Ingested from coreutils-9.4/src/od.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdckdint.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"ftoastr.h\"\n#include \"quote.h\"\n#include \"stat-size.h\"\n#include \"xbinary-io.h\"\n#include \"xprintf.h\"\n#include \"xstrtol.h\"\n#include \"xstrtol-error.h\"\n\n \n#define PROGRAM_NAME \"od\"\n\n#define AUTHORS proper_name (\"Jim Meyering\")\n\n \n#define DEFAULT_BYTES_PER_BLOCK 16\n\n#if HAVE_UNSIGNED_LONG_LONG_INT\ntypedef unsigned long long int unsigned_long_long_int;\n#else\n \ntypedef unsigned long int unsigned_long_long_int;\n#endif\n\nenum size_spec\n  {\n    NO_SIZE,\n    CHAR,\n    SHORT,\n    INT,\n    LONG,\n    LONG_LONG,\n     \n    FLOAT_SINGLE,\n    FLOAT_DOUBLE,\n    FLOAT_LONG_DOUBLE,\n    N_SIZE_SPECS\n  };\n\nenum output_format\n  {\n    SIGNED_DECIMAL,\n    UNSIGNED_DECIMAL,\n    OCTAL,\n    HEXADECIMAL,\n    FLOATING_POINT,\n    NAMED_CHARACTER,\n    CHARACTER\n  };\n\n#define MAX_INTEGRAL_TYPE_SIZE sizeof (unsigned_long_long_int)\n\n \nenum\n  {\n    FMT_BYTES_ALLOCATED =\n           (sizeof \"%*.99\" + 1\n            + MAX (sizeof \"ld\",\n                   MAX (sizeof PRIdMAX,\n                        MAX (sizeof PRIoMAX,\n                             MAX (sizeof PRIuMAX,\n                                  sizeof PRIxMAX)))))\n  };\n\n \nstatic_assert (MAX_INTEGRAL_TYPE_SIZE * CHAR_BIT / 3 <= 99);\n\n \nstruct tspec\n  {\n    enum output_format fmt;\n    enum size_spec size;  \n     \n    void (*print_function) (size_t fields, size_t blank, void const *data,\n                            char const *fmt, int width, int pad);\n    char fmt_string[FMT_BYTES_ALLOCATED];  \n    bool hexl_mode_trailer;\n    int field_width;  \n    int pad_width;  \n  };\n\n \n\nstatic char const bytes_to_oct_digits[] =\n{0, 3, 6, 8, 11, 14, 16, 19, 22, 25, 27, 30, 32, 35, 38, 41, 43};\n\nstatic char const bytes_to_signed_dec_digits[] =\n{1, 4, 6, 8, 11, 13, 16, 18, 20, 23, 25, 28, 30, 33, 35, 37, 40};\n\nstatic char const bytes_to_unsigned_dec_digits[] =\n{0, 3, 5, 8, 10, 13, 15, 17, 20, 22, 25, 27, 29, 32, 34, 37, 39};\n\nstatic char const bytes_to_hex_digits[] =\n{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32};\n\n \nstatic_assert (MAX_INTEGRAL_TYPE_SIZE\n               < ARRAY_CARDINALITY (bytes_to_hex_digits));\n\n \nstatic_assert (sizeof bytes_to_oct_digits == sizeof bytes_to_signed_dec_digits);\nstatic_assert (sizeof bytes_to_oct_digits\n               == sizeof bytes_to_unsigned_dec_digits);\nstatic_assert (sizeof bytes_to_oct_digits == sizeof bytes_to_hex_digits);\n\n \nstatic const int width_bytes[] =\n{\n  -1,\n  sizeof (char),\n  sizeof (short int),\n  sizeof (int),\n  sizeof (long int),\n  sizeof (unsigned_long_long_int),\n  sizeof (float),\n  sizeof (double),\n  sizeof (long double)\n};\n\n \nstatic_assert (ARRAY_CARDINALITY (width_bytes) == N_SIZE_SPECS);\n\n \nstatic char const charname[33][4] =\n{\n  \"nul\", \"soh\", \"stx\", \"etx\", \"eot\", \"enq\", \"ack\", \"bel\",\n  \"bs\", \"ht\", \"nl\", \"vt\", \"ff\", \"cr\", \"so\", \"si\",\n  \"dle\", \"dc1\", \"dc2\", \"dc3\", \"dc4\", \"nak\", \"syn\", \"etb\",\n  \"can\", \"em\", \"sub\", \"esc\", \"fs\", \"gs\", \"rs\", \"us\",\n  \"sp\"\n};\n\n \nstatic int address_base;\n\n \n#define MAX_ADDRESS_LENGTH \\\n  ((sizeof (uintmax_t) * CHAR_BIT + CHAR_BIT - 1) / 3)\n\n \nstatic int address_pad_len;\n\n \nstatic size_t string_min;\n\n \nstatic bool flag_dump_strings;\n\n \nstatic bool traditional;\n\n \nstatic bool flag_pseudo_start;\n\n \nstatic uintmax_t pseudo_offset;\n\n \nstatic void (*format_address) (uintmax_t, char);\n\n \nstatic uintmax_t n_bytes_to_skip = 0;\n\n \nstatic bool limit_bytes_to_format = false;\n\n \nstatic uintmax_t max_bytes_to_format;\n\n \nstatic uintmax_t end_offset;\n\n \nstatic bool abbreviate_duplicate_blocks = true;\n\n \nstatic struct tspec *spec;\n\n \nstatic size_t n_specs;\n\n \nstatic size_t n_specs_allocated;\n\n \nstatic size_t bytes_per_block;\n\n \nstatic char const *input_filename;\n\n \nstatic char const *const *file_list;\n\n \nstatic char const *const default_file_list[] = {\"-\", nullptr};\n\n \nstatic FILE *in_stream;\n\n \nstatic bool have_read_stdin;\n\n \nstatic enum size_spec integral_type_size[MAX_INTEGRAL_TYPE_SIZE + 1];\n\n#define MAX_FP_TYPE_SIZE sizeof (long double)\nstatic enum size_spec fp_type_size[MAX_FP_TYPE_SIZE + 1];\n\n#ifndef WORDS_BIGENDIAN\n# define WORDS_BIGENDIAN 0\n#endif\n\n \nstatic bool input_swap;\n\nstatic char const short_options[] = \"A:aBbcDdeFfHhIij:LlN:OoS:st:vw::Xx\";\n\n \nenum\n{\n  TRADITIONAL_OPTION = CHAR_MAX + 1,\n  ENDIAN_OPTION,\n};\n\nenum endian_type\n{\n  endian_little,\n  endian_big\n};\n\nstatic char const *const endian_args[] =\n{\n  \"little\", \"big\", nullptr\n};\n\nstatic enum endian_type const endian_types[] =\n{\n  endian_little, endian_big\n};\n\nstatic struct option const long_options[] =\n{\n  {\"skip-bytes\", required_argument, nullptr, 'j'},\n  {\"address-radix\", required_argument, nullptr, 'A'},\n  {\"read-bytes\", required_argument, nullptr, 'N'},\n  {\"format\", required_argument, nullptr, 't'},\n  {\"output-duplicates\", no_argument, nullptr, 'v'},\n  {\"strings\", optional_argument, nullptr, 'S'},\n  {\"traditional\", no_argument, nullptr, TRADITIONAL_OPTION},\n  {\"width\", optional_argument, nullptr, 'w'},\n  {\"endian\", required_argument, nullptr, ENDIAN_OPTION },\n\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\\n\\\n  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.][b]]\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\n\\\nWrite an unambiguous representation, octal bytes by default,\\n\\\nof FILE to standard output.  With more than one FILE argument,\\n\\\nconcatenate them in the listed order to form the input.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n\n      fputs (_(\"\\\n\\n\\\nIf first and second call formats both apply, the second format is assumed\\n\\\nif the last operand begins with + or (if there are 2 operands) a digit.\\n\\\nAn OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\\n\\\nat first byte printed, incremented when dump is progressing.\\n\\\nFor OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\\n\\\nsuffixes may be . for octal and b for multiply by 512.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\\n\\\n                                of [doxn], for Decimal, Octal, Hex or None\\n\\\n      --endian={big|little}   swap input bytes according the specified order\\n\\\n  -j, --skip-bytes=BYTES      skip BYTES input bytes first\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\\n\\\n  -S BYTES, --strings[=BYTES]  show only NUL terminated strings\\n\\\n                                of at least BYTES (3) printable characters\\n\\\n  -t, --format=TYPE           select output format or formats\\n\\\n  -v, --output-duplicates     do not use * to mark line suppression\\n\\\n  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\\n\\\n                                32 is implied when BYTES is not specified\\n\\\n      --traditional           accept arguments in third form above\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\n\\n\\\nTraditional format specifications may be intermixed; they accumulate:\\n\\\n  -a   same as -t a,  select named characters, ignoring high-order bit\\n\\\n  -b   same as -t o1, select octal bytes\\n\\\n  -c   same as -t c,  select printable characters or backslash escapes\\n\\\n  -d   same as -t u2, select unsigned decimal 2-byte units\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f   same as -t fF, select floats\\n\\\n  -i   same as -t dI, select decimal ints\\n\\\n  -l   same as -t dL, select decimal longs\\n\\\n  -o   same as -t o2, select octal 2-byte units\\n\\\n  -s   same as -t d2, select decimal 2-byte units\\n\\\n  -x   same as -t x2, select hexadecimal 2-byte units\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n\\n\\\nTYPE is made up of one or more of these specifications:\\n\\\n  a          named character, ignoring high-order bit\\n\\\n  c          printable character or backslash escape\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  d[SIZE]    signed decimal, SIZE bytes per integer\\n\\\n  f[SIZE]    floating point, SIZE bytes per float\\n\\\n  o[SIZE]    octal, SIZE bytes per integer\\n\\\n  u[SIZE]    unsigned decimal, SIZE bytes per integer\\n\\\n  x[SIZE]    hexadecimal, SIZE bytes per integer\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nSIZE is a number.  For TYPE in [doux], SIZE may also be C for\\n\\\nsizeof(char), S for sizeof(short), I for sizeof(int) or L for\\n\\\nsizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\\n\\\nfor sizeof(double) or L for sizeof(long double).\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nAdding a z suffix to any type displays printable characters at the end of\\n\\\neach output line.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\n\\n\\\nBYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\\n\\\n  b    512\\n\\\n  KB   1000\\n\\\n  K    1024\\n\\\n  MB   1000*1000\\n\\\n  M    1024*1024\\n\\\nand so on for G, T, P, E, Z, Y, R, Q.\\n\\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n \n\n#define PRINT_FIELDS(N, T, FMT_STRING_DECL, ACTION)                     \\\nstatic void                                                             \\\nN (size_t fields, size_t blank, void const *block,                      \\\n   FMT_STRING_DECL, int width, int pad)                                 \\\n{                                                                       \\\n  T const *p = block;                                                   \\\n  uintmax_t i;                                                          \\\n  int pad_remaining = pad;                                              \\\n  for (i = fields; blank < i; i--)                                      \\\n    {                                                                   \\\n      int next_pad = pad * (i - 1) / fields;                            \\\n      int adjusted_width = pad_remaining - next_pad + width;            \\\n      T x;                                                              \\\n      if (input_swap && sizeof (T) > 1)                                 \\\n        {                                                               \\\n          size_t j;                                                     \\\n          union {                                                       \\\n            T x;                                                        \\\n            char b[sizeof (T)];                                         \\\n          } u;                                                          \\\n          for (j = 0; j < sizeof (T); j++)                              \\\n            u.b[j] = ((char const *) p)[sizeof (T) - 1 - j];            \\\n          x = u.x;                                                      \\\n        }                                                               \\\n      else                                                              \\\n        x = *p;                                                         \\\n      p++;                                                              \\\n      ACTION;                                                           \\\n      pad_remaining = next_pad;                                         \\\n    }                                                                   \\\n}\n\n#define PRINT_TYPE(N, T)                                                \\\n  PRINT_FIELDS (N, T, char const *fmt_string,                           \\\n                xprintf (fmt_string, adjusted_width, x))\n\n#define PRINT_FLOATTYPE(N, T, FTOASTR, BUFSIZE)                         \\\n  PRINT_FIELDS (N, T, MAYBE_UNUSED char const *fmt_string,              \\\n                char buf[BUFSIZE];                                      \\\n                FTOASTR (buf, sizeof buf, 0, 0, x);                     \\\n                xprintf (\"%*s\", adjusted_width, buf))\n\nPRINT_TYPE (print_s_char, signed char)\nPRINT_TYPE (print_char, unsigned char)\nPRINT_TYPE (print_s_short, short int)\nPRINT_TYPE (print_short, unsigned short int)\nPRINT_TYPE (print_int, unsigned int)\nPRINT_TYPE (print_long, unsigned long int)\nPRINT_TYPE (print_long_long, unsigned_long_long_int)\n\nPRINT_FLOATTYPE (print_float, float, ftoastr, FLT_BUFSIZE_BOUND)\nPRINT_FLOATTYPE (print_double, double, dtoastr, DBL_BUFSIZE_BOUND)\nPRINT_FLOATTYPE (print_long_double, long double, ldtoastr, LDBL_BUFSIZE_BOUND)\n\n#undef PRINT_TYPE\n#undef PRINT_FLOATTYPE\n\nstatic void\ndump_hexl_mode_trailer (size_t n_bytes, char const *block)\n{\n  fputs (\"  >\", stdout);\n  for (size_t i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *block++;\n      unsigned char c2 = (isprint (c) ? c : '.');\n      putchar (c2);\n    }\n  putchar ('<');\n}\n\nstatic void\nprint_named_ascii (size_t fields, size_t blank, void const *block,\n                   MAYBE_UNUSED char const *unused_fmt_string,\n                   int width, int pad)\n{\n  unsigned char const *p = block;\n  uintmax_t i;\n  int pad_remaining = pad;\n  for (i = fields; blank < i; i--)\n    {\n      int next_pad = pad * (i - 1) / fields;\n      int masked_c = *p++ & 0x7f;\n      char const *s;\n      char buf[2];\n\n      if (masked_c == 127)\n        s = \"del\";\n      else if (masked_c <= 040)\n        s = charname[masked_c];\n      else\n        {\n          buf[0] = masked_c;\n          buf[1] = 0;\n          s = buf;\n        }\n\n      xprintf (\"%*s\", pad_remaining - next_pad + width, s);\n      pad_remaining = next_pad;\n    }\n}\n\nstatic void\nprint_ascii (size_t fields, size_t blank, void const *block,\n             MAYBE_UNUSED char const *unused_fmt_string, int width,\n             int pad)\n{\n  unsigned char const *p = block;\n  uintmax_t i;\n  int pad_remaining = pad;\n  for (i = fields; blank < i; i--)\n    {\n      int next_pad = pad * (i - 1) / fields;\n      unsigned char c = *p++;\n      char const *s;\n      char buf[4];\n\n      switch (c)\n        {\n        case '\\0':\n          s = \"\\\\0\";\n          break;\n\n        case '\\a':\n          s = \"\\\\a\";\n          break;\n\n        case '\\b':\n          s = \"\\\\b\";\n          break;\n\n        case '\\f':\n          s = \"\\\\f\";\n          break;\n\n        case '\\n':\n          s = \"\\\\n\";\n          break;\n\n        case '\\r':\n          s = \"\\\\r\";\n          break;\n\n        case '\\t':\n          s = \"\\\\t\";\n          break;\n\n        case '\\v':\n          s = \"\\\\v\";\n          break;\n\n        default:\n          sprintf (buf, (isprint (c) ? \"%c\" : \"%03o\"), c);\n          s = buf;\n        }\n\n      xprintf (\"%*s\", pad_remaining - next_pad + width, s);\n      pad_remaining = next_pad;\n    }\n}\n\n \n\nstatic bool\nsimple_strtoi (char const *s, char const **p, int *val)\n{\n  int sum;\n\n  for (sum = 0; ISDIGIT (*s); s++)\n    if (ckd_mul (&sum, sum, 10) || ckd_add (&sum, sum, *s - '0'))\n      return false;\n  *p = s;\n  *val = sum;\n  return true;\n}\n\n \n\nstatic bool ATTRIBUTE_NONNULL ()\ndecode_one_format (char const *s_orig, char const *s, char const **next,\n                   struct tspec *tspec)\n{\n  enum size_spec size_spec;\n  int size;\n  enum output_format fmt;\n  void (*print_function) (size_t, size_t, void const *, char const *,\n                          int, int);\n  char const *p;\n  char c;\n  int field_width;\n\n  switch (*s)\n    {\n    case 'd':\n    case 'o':\n    case 'u':\n    case 'x':\n      c = *s;\n      ++s;\n      switch (*s)\n        {\n        case 'C':\n          ++s;\n          size = sizeof (char);\n          break;\n\n        case 'S':\n          ++s;\n          size = sizeof (short int);\n          break;\n\n        case 'I':\n          ++s;\n          size = sizeof (int);\n          break;\n\n        case 'L':\n          ++s;\n          size = sizeof (long int);\n          break;\n\n        default:\n          if (! simple_strtoi (s, &p, &size))\n            {\n               \n              error (0, 0, _(\"invalid type string %s\"), quote (s_orig));\n              return false;\n            }\n          if (p == s)\n            size = sizeof (int);\n          else\n            {\n              if (MAX_INTEGRAL_TYPE_SIZE < size\n                  || integral_type_size[size] == NO_SIZE)\n                {\n                  error (0, 0, _(\"invalid type string %s;\\nthis system\"\n                                 \" doesn't provide a %d-byte integral type\"),\n                         quote (s_orig), size);\n                  return false;\n                }\n              s = p;\n            }\n          break;\n        }\n\n#define ISPEC_TO_FORMAT(Spec, Min_format, Long_format, Max_format)\t\\\n  ((Spec) == LONG_LONG ? (Max_format)\t\t\t\t\t\\\n   : ((Spec) == LONG ? (Long_format)\t\t\t\t\t\\\n      : (Min_format)))\t\t\t\t\t\t\t\\\n\n      size_spec = integral_type_size[size];\n\n      switch (c)\n        {\n        case 'd':\n          fmt = SIGNED_DECIMAL;\n          field_width = bytes_to_signed_dec_digits[size];\n          sprintf (tspec->fmt_string, \"%%*%s\",\n                   ISPEC_TO_FORMAT (size_spec, \"d\", \"ld\", PRIdMAX));\n          break;\n\n        case 'o':\n          fmt = OCTAL;\n          sprintf (tspec->fmt_string, \"%%*.%d%s\",\n                   (field_width = bytes_to_oct_digits[size]),\n                   ISPEC_TO_FORMAT (size_spec, \"o\", \"lo\", PRIoMAX));\n          break;\n\n        case 'u':\n          fmt = UNSIGNED_DECIMAL;\n          field_width = bytes_to_unsigned_dec_digits[size];\n          sprintf (tspec->fmt_string, \"%%*%s\",\n                   ISPEC_TO_FORMAT (size_spec, \"u\", \"lu\", PRIuMAX));\n          break;\n\n        case 'x':\n          fmt = HEXADECIMAL;\n          sprintf (tspec->fmt_string, \"%%*.%d%s\",\n                   (field_width = bytes_to_hex_digits[size]),\n                   ISPEC_TO_FORMAT (size_spec, \"x\", \"lx\", PRIxMAX));\n          break;\n\n        default:\n          unreachable ();\n        }\n\n      switch (size_spec)\n        {\n        case CHAR:\n          print_function = (fmt == SIGNED_DECIMAL\n                            ? print_s_char\n                            : print_char);\n          break;\n\n        case SHORT:\n          print_function = (fmt == SIGNED_DECIMAL\n                            ? print_s_short\n                            : print_short);\n          break;\n\n        case INT:\n          print_function = print_int;\n          break;\n\n        case LONG:\n          print_function = print_long;\n          break;\n\n        case LONG_LONG:\n          print_function = print_long_long;\n          break;\n\n        default:\n          affirm (false);\n        }\n      break;\n\n    case 'f':\n      fmt = FLOATING_POINT;\n      ++s;\n      switch (*s)\n        {\n        case 'F':\n          ++s;\n          size = sizeof (float);\n          break;\n\n        case 'D':\n          ++s;\n          size = sizeof (double);\n          break;\n\n        case 'L':\n          ++s;\n          size = sizeof (long double);\n          break;\n\n        default:\n          if (! simple_strtoi (s, &p, &size))\n            {\n               \n              error (0, 0, _(\"invalid type string %s\"), quote (s_orig));\n              return false;\n            }\n          if (p == s)\n            size = sizeof (double);\n          else\n            {\n              if (size > MAX_FP_TYPE_SIZE\n                  || fp_type_size[size] == NO_SIZE)\n                {\n                  error (0, 0,\n                         _(\"invalid type string %s;\\n\"\n                           \"this system doesn't provide a %d-byte\"\n                           \" floating point type\"),\n                         quote (s_orig), size);\n                  return false;\n                }\n              s = p;\n            }\n          break;\n        }\n      size_spec = fp_type_size[size];\n\n      {\n        struct lconv const *locale = localeconv ();\n        size_t decimal_point_len =\n          (locale->decimal_point[0] ? strlen (locale->decimal_point) : 1);\n\n        switch (size_spec)\n          {\n          case FLOAT_SINGLE:\n            print_function = print_float;\n            field_width = FLT_STRLEN_BOUND_L (decimal_point_len);\n            break;\n\n          case FLOAT_DOUBLE:\n            print_function = print_double;\n            field_width = DBL_STRLEN_BOUND_L (decimal_point_len);\n            break;\n\n          case FLOAT_LONG_DOUBLE:\n            print_function = print_long_double;\n            field_width = LDBL_STRLEN_BOUND_L (decimal_point_len);\n            break;\n\n          default:\n            affirm (false);\n          }\n\n        break;\n      }\n\n    case 'a':\n      ++s;\n      fmt = NAMED_CHARACTER;\n      size_spec = CHAR;\n      print_function = print_named_ascii;\n      field_width = 3;\n      break;\n\n    case 'c':\n      ++s;\n      fmt = CHARACTER;\n      size_spec = CHAR;\n      print_function = print_ascii;\n      field_width = 3;\n      break;\n\n    default:\n      error (0, 0, _(\"invalid character '%c' in type string %s\"),\n             *s, quote (s_orig));\n      return false;\n    }\n\n  tspec->size = size_spec;\n  tspec->fmt = fmt;\n  tspec->print_function = print_function;\n\n  tspec->field_width = field_width;\n  tspec->hexl_mode_trailer = (*s == 'z');\n  if (tspec->hexl_mode_trailer)\n    s++;\n\n  *next = s;\n  return true;\n}\n\n \n\nstatic bool\nopen_next_file (void)\n{\n  bool ok = true;\n\n  do\n    {\n      input_filename = *file_list;\n      if (input_filename == nullptr)\n        return ok;\n      ++file_list;\n\n      if (STREQ (input_filename, \"-\"))\n        {\n          input_filename = _(\"standard input\");\n          in_stream = stdin;\n          have_read_stdin = true;\n          xset_binary_mode (STDIN_FILENO, O_BINARY);\n        }\n      else\n        {\n          in_stream = fopen (input_filename, (O_BINARY ? \"rb\" : \"r\"));\n          if (in_stream == nullptr)\n            {\n              error (0, errno, \"%s\", quotef (input_filename));\n              ok = false;\n            }\n        }\n    }\n  while (in_stream == nullptr);\n\n  if (limit_bytes_to_format && !flag_dump_strings)\n    setvbuf (in_stream, nullptr, _IONBF, 0);\n\n  return ok;\n}\n\n \n\nstatic bool\ncheck_and_close (int in_errno)\n{\n  bool ok = true;\n\n  if (in_stream != nullptr)\n    {\n      if (!ferror (in_stream))\n        in_errno = 0;\n      if (STREQ (file_list[-1], \"-\"))\n        clearerr (in_stream);\n      else if (fclose (in_stream) != 0 && !in_errno)\n        in_errno = errno;\n      if (in_errno)\n        {\n          error (0, in_errno, \"%s\", quotef (input_filename));\n          ok = false;\n        }\n\n      in_stream = nullptr;\n    }\n\n  if (ferror (stdout))\n    {\n      error (0, 0, _(\"write error\"));\n      ok = false;\n    }\n\n  return ok;\n}\n\n \n\nstatic bool ATTRIBUTE_NONNULL ()\ndecode_format_string (char const *s)\n{\n  char const *s_orig = s;\n\n  while (*s != '\\0')\n    {\n      char const *next;\n\n      if (n_specs_allocated <= n_specs)\n        spec = X2NREALLOC (spec, &n_specs_allocated);\n\n      if (! decode_one_format (s_orig, s, &next, &spec[n_specs]))\n        return false;\n\n      affirm (s != next);\n      s = next;\n      ++n_specs;\n    }\n\n  return true;\n}\n\n \n\nstatic bool\nskip (uintmax_t n_skip)\n{\n  bool ok = true;\n  int in_errno = 0;\n\n  if (n_skip == 0)\n    return true;\n\n  while (in_stream != nullptr)\t \n    {\n      struct stat file_stats;\n\n       \n\n      if (fstat (fileno (in_stream), &file_stats) == 0)\n        {\n          bool usable_size = usable_st_size (&file_stats);\n\n           \n          if (usable_size && ST_BLKSIZE (file_stats) < file_stats.st_size)\n            {\n              if ((uintmax_t) file_stats.st_size < n_skip)\n                n_skip -= file_stats.st_size;\n              else\n                {\n                  if (fseeko (in_stream, n_skip, SEEK_CUR) != 0)\n                    {\n                      in_errno = errno;\n                      ok = false;\n                    }\n                  n_skip = 0;\n                }\n            }\n\n          else if (!usable_size && fseeko (in_stream, n_skip, SEEK_CUR) == 0)\n            n_skip = 0;\n\n           \n\n          else\n            {\n              char buf[BUFSIZ];\n              size_t n_bytes_read, n_bytes_to_read = BUFSIZ;\n\n              while (0 < n_skip)\n                {\n                  if (n_skip < n_bytes_to_read)\n                    n_bytes_to_read = n_skip;\n                  n_bytes_read = fread (buf, 1, n_bytes_to_read, in_stream);\n                  n_skip -= n_bytes_read;\n                  if (n_bytes_read != n_bytes_to_read)\n                    {\n                      if (ferror (in_stream))\n                        {\n                          in_errno = errno;\n                          ok = false;\n                          n_skip = 0;\n                          break;\n                        }\n                      if (feof (in_stream))\n                        break;\n                    }\n                }\n            }\n\n          if (n_skip == 0)\n            break;\n        }\n\n      else    \n        {\n          error (0, errno, \"%s\", quotef (input_filename));\n          ok = false;\n        }\n\n      ok &= check_and_close (in_errno);\n\n      ok &= open_next_file ();\n    }\n\n  if (n_skip != 0)\n    error (EXIT_FAILURE, 0, _(\"cannot skip past end of combined input\"));\n\n  return ok;\n}\n\nstatic void\nformat_address_none (MAYBE_UNUSED uintmax_t address,\n                     MAYBE_UNUSED char c)\n{\n}\n\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n   \n  switch (address_base)\n    {\n    case 8:\n      do\n        *--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n        *--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n        *--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n\nstatic void\nformat_address_paren (uintmax_t address, char c)\n{\n  putchar ('(');\n  format_address_std (address, ')');\n  if (c)\n    putchar (c);\n}\n\nstatic void\nformat_address_label (uintmax_t address, char c)\n{\n  format_address_std (address, ' ');\n  format_address_paren (address + pseudo_offset, c);\n}\n\n \n\nstatic void\nwrite_block (uintmax_t current_offset, size_t n_bytes,\n             char const *prev_block, char const *curr_block)\n{\n  static bool first = true;\n  static bool prev_pair_equal = false;\n\n#define EQUAL_BLOCKS(b1, b2) (memcmp (b1, b2, bytes_per_block) == 0)\n\n  if (abbreviate_duplicate_blocks\n      && !first && n_bytes == bytes_per_block\n      && EQUAL_BLOCKS (prev_block, curr_block))\n    {\n      if (prev_pair_equal)\n        {\n           \n        }\n      else\n        {\n          printf (\"*\\n\");\n          prev_pair_equal = true;\n        }\n    }\n  else\n    {\n      prev_pair_equal = false;\n      for (size_t i = 0; i < n_specs; i++)\n        {\n          int datum_width = width_bytes[spec[i].size];\n          int fields_per_block = bytes_per_block / datum_width;\n          int blank_fields = (bytes_per_block - n_bytes) / datum_width;\n          if (i == 0)\n            format_address (current_offset, '\\0');\n          else\n            printf (\"%*s\", address_pad_len, \"\");\n          (*spec[i].print_function) (fields_per_block, blank_fields,\n                                     curr_block, spec[i].fmt_string,\n                                     spec[i].field_width, spec[i].pad_width);\n          if (spec[i].hexl_mode_trailer)\n            {\n               \n              int field_width = spec[i].field_width;\n              int pad_width = (spec[i].pad_width * blank_fields\n                               / fields_per_block);\n              printf (\"%*s\", blank_fields * field_width + pad_width, \"\");\n              dump_hexl_mode_trailer (n_bytes, curr_block);\n            }\n          putchar ('\\n');\n        }\n    }\n  first = false;\n}\n\n \n\nstatic bool\nread_char (int *c)\n{\n  bool ok = true;\n\n  *c = EOF;\n\n  while (in_stream != nullptr)\t \n    {\n      *c = fgetc (in_stream);\n\n      if (*c != EOF)\n        break;\n\n      ok &= check_and_close (errno);\n\n      ok &= open_next_file ();\n    }\n\n  return ok;\n}\n\n \n\nstatic bool\nread_block (size_t n, char *block, size_t *n_bytes_in_buffer)\n{\n  bool ok = true;\n\n  affirm (0 < n && n <= bytes_per_block);\n\n  *n_bytes_in_buffer = 0;\n\n  while (in_stream != nullptr)\t \n    {\n      size_t n_needed;\n      size_t n_read;\n\n      n_needed = n - *n_bytes_in_buffer;\n      n_read = fread (block + *n_bytes_in_buffer, 1, n_needed, in_stream);\n\n      *n_bytes_in_buffer += n_read;\n\n      if (n_read == n_needed)\n        break;\n\n      ok &= check_and_close (errno);\n\n      ok &= open_next_file ();\n    }\n\n  return ok;\n}\n\n \n\nATTRIBUTE_PURE\nstatic int\nget_lcm (void)\n{\n  int l_c_m = 1;\n\n  for (size_t i = 0; i < n_specs; i++)\n    l_c_m = lcm (l_c_m, width_bytes[spec[i].size]);\n  return l_c_m;\n}\n\n \n\nstatic bool\nparse_old_offset (char const *s, uintmax_t *offset)\n{\n  int radix;\n\n  if (*s == '\\0')\n    return false;\n\n   \n  if (s[0] == '+')\n    ++s;\n\n   \n  if (strchr (s, '.') != nullptr)\n    radix = 10;\n  else\n    {\n      if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))\n        radix = 16;\n      else\n        radix = 8;\n    }\n\n  return xstrtoumax (s, nullptr, radix, offset, \"Bb\") == LONGINT_OK;\n}\n\n \n\nstatic bool\ndump (void)\n{\n  char *block[2];\n  uintmax_t current_offset;\n  bool idx = false;\n  bool ok = true;\n  size_t n_bytes_read;\n\n  block[0] = xnmalloc (2, bytes_per_block);\n  block[1] = block[0] + bytes_per_block;\n\n  current_offset = n_bytes_to_skip;\n\n  if (limit_bytes_to_format)\n    {\n      while (ok)\n        {\n          size_t n_needed;\n          if (current_offset >= end_offset)\n            {\n              n_bytes_read = 0;\n              break;\n            }\n          n_needed = MIN (end_offset - current_offset,\n                          (uintmax_t) bytes_per_block);\n          ok &= read_block (n_needed, block[idx], &n_bytes_read);\n          if (n_bytes_read < bytes_per_block)\n            break;\n          affirm (n_bytes_read == bytes_per_block);\n          write_block (current_offset, n_bytes_read,\n                       block[!idx], block[idx]);\n          if (ferror (stdout))\n            ok = false;\n          current_offset += n_bytes_read;\n          idx = !idx;\n        }\n    }\n  else\n    {\n      while (ok)\n        {\n          ok &= read_block (bytes_per_block, block[idx], &n_bytes_read);\n          if (n_bytes_read < bytes_per_block)\n            break;\n          affirm (n_bytes_read == bytes_per_block);\n          write_block (current_offset, n_bytes_read,\n                       block[!idx], block[idx]);\n          if (ferror (stdout))\n            ok = false;\n          current_offset += n_bytes_read;\n          idx = !idx;\n        }\n    }\n\n  if (n_bytes_read > 0)\n    {\n      int l_c_m;\n      size_t bytes_to_write;\n\n      l_c_m = get_lcm ();\n\n       \n      bytes_to_write = l_c_m * ((n_bytes_read + l_c_m - 1) / l_c_m);\n\n      memset (block[idx] + n_bytes_read, 0, bytes_to_write - n_bytes_read);\n      write_block (current_offset, n_bytes_read, block[!idx], block[idx]);\n      current_offset += n_bytes_read;\n    }\n\n  format_address (current_offset, '\\n');\n\n  if (limit_bytes_to_format && current_offset >= end_offset)\n    ok &= check_and_close (0);\n\n  free (block[0]);\n\n  return ok;\n}\n\n \n\nstatic bool\ndump_strings (void)\n{\n  size_t bufsize = MAX (100, string_min);\n  char *buf = xmalloc (bufsize);\n  uintmax_t address = n_bytes_to_skip;\n  bool ok = true;\n\n  while (true)\n    {\n      size_t i;\n      int c;\n\n       \n    tryline:\n\n      if (limit_bytes_to_format\n          && (end_offset < string_min || end_offset - string_min <= address))\n        break;\n\n      for (i = 0; i < string_min; i++)\n        {\n          ok &= read_char (&c);\n          address++;\n          if (c < 0)\n            {\n              free (buf);\n              return ok;\n            }\n          if (! isprint (c))\n             \n            goto tryline;\n          buf[i] = c;\n        }\n\n       \n      while (!limit_bytes_to_format || address < end_offset)\n        {\n          if (i == bufsize)\n            {\n              buf = X2REALLOC (buf, &bufsize);\n            }\n          ok &= read_char (&c);\n          address++;\n          if (c < 0)\n            {\n              free (buf);\n              return ok;\n            }\n          if (c == '\\0')\n            break;\t\t \n          if (! isprint (c))\n            goto tryline;\t \n          buf[i++] = c;\t\t \n        }\n\n       \n      buf[i] = 0;\n      format_address (address - i - 1, ' ');\n\n      for (i = 0; (c = buf[i]); i++)\n        {\n          switch (c)\n            {\n            case '\\a':\n              fputs (\"\\\\a\", stdout);\n              break;\n\n            case '\\b':\n              fputs (\"\\\\b\", stdout);\n              break;\n\n            case '\\f':\n              fputs (\"\\\\f\", stdout);\n              break;\n\n            case '\\n':\n              fputs (\"\\\\n\", stdout);\n              break;\n\n            case '\\r':\n              fputs (\"\\\\r\", stdout);\n              break;\n\n            case '\\t':\n              fputs (\"\\\\t\", stdout);\n              break;\n\n            case '\\v':\n              fputs (\"\\\\v\", stdout);\n              break;\n\n            default:\n              putc (c, stdout);\n            }\n        }\n      putchar ('\\n');\n    }\n\n   \n\n  free (buf);\n\n  ok &= check_and_close (0);\n  return ok;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int n_files;\n  size_t i;\n  int l_c_m;\n  idx_t desired_width IF_LINT ( = 0);\n  bool modern = false;\n  bool width_specified = false;\n  bool ok = true;\n  size_t width_per_block = 0;\n  static char const multipliers[] = \"bEGKkMmPQRTYZ0\";\n\n   \n  uintmax_t pseudo_start IF_LINT ( = 0);\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  for (i = 0; i <= MAX_INTEGRAL_TYPE_SIZE; i++)\n    integral_type_size[i] = NO_SIZE;\n\n  integral_type_size[sizeof (char)] = CHAR;\n  integral_type_size[sizeof (short int)] = SHORT;\n  integral_type_size[sizeof (int)] = INT;\n  integral_type_size[sizeof (long int)] = LONG;\n#if HAVE_UNSIGNED_LONG_LONG_INT\n   \n  integral_type_size[sizeof (unsigned_long_long_int)] = LONG_LONG;\n#endif\n\n  for (i = 0; i <= MAX_FP_TYPE_SIZE; i++)\n    fp_type_size[i] = NO_SIZE;\n\n  fp_type_size[sizeof (float)] = FLOAT_SINGLE;\n   \n  fp_type_size[sizeof (long double)] = FLOAT_LONG_DOUBLE;\n  fp_type_size[sizeof (double)] = FLOAT_DOUBLE;\n\n  n_specs = 0;\n  n_specs_allocated = 0;\n  spec = nullptr;\n\n  format_address = format_address_std;\n  address_base = 8;\n  address_pad_len = 7;\n  flag_dump_strings = false;\n\n  while (true)\n    {\n      uintmax_t tmp;\n      enum strtol_error s_err;\n      int oi = -1;\n      int c = getopt_long (argc, argv, short_options, long_options, &oi);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 'A':\n          modern = true;\n          switch (optarg[0])\n            {\n            case 'd':\n              format_address = format_address_std;\n              address_base = 10;\n              address_pad_len = 7;\n              break;\n            case 'o':\n              format_address = format_address_std;\n              address_base = 8;\n              address_pad_len = 7;\n              break;\n            case 'x':\n              format_address = format_address_std;\n              address_base = 16;\n              address_pad_len = 6;\n              break;\n            case 'n':\n              format_address = format_address_none;\n              address_pad_len = 0;\n              break;\n            default:\n              error (EXIT_FAILURE, 0,\n                     _(\"invalid output address radix '%c';\"\n                       \" it must be one character from [doxn]\"),\n                     optarg[0]);\n              break;\n            }\n          break;\n\n        case 'j':\n          modern = true;\n          s_err = xstrtoumax (optarg, nullptr, 0,\n                              &n_bytes_to_skip, multipliers);\n          if (s_err != LONGINT_OK)\n            xstrtol_fatal (s_err, oi, c, long_options, optarg);\n          break;\n\n        case 'N':\n          modern = true;\n          limit_bytes_to_format = true;\n\n          s_err = xstrtoumax (optarg, nullptr, 0, &max_bytes_to_format,\n                              multipliers);\n          if (s_err != LONGINT_OK)\n            xstrtol_fatal (s_err, oi, c, long_options, optarg);\n          break;\n\n        case 'S':\n          modern = true;\n          if (optarg == nullptr)\n            string_min = 3;\n          else\n            {\n              s_err = xstrtoumax (optarg, nullptr, 0, &tmp, multipliers);\n              if (s_err != LONGINT_OK)\n                xstrtol_fatal (s_err, oi, c, long_options, optarg);\n\n               \n              if (SIZE_MAX < tmp)\n                error (EXIT_FAILURE, 0, _(\"%s is too large\"), quote (optarg));\n\n              string_min = tmp;\n            }\n          flag_dump_strings = true;\n          break;\n\n        case 't':\n          modern = true;\n          ok &= decode_format_string (optarg);\n          break;\n\n        case 'v':\n          modern = true;\n          abbreviate_duplicate_blocks = false;\n          break;\n\n        case TRADITIONAL_OPTION:\n          traditional = true;\n          break;\n\n        case ENDIAN_OPTION:\n          switch (XARGMATCH (\"--endian\", optarg, endian_args, endian_types))\n            {\n              case endian_big:\n                  input_swap = ! WORDS_BIGENDIAN;\n                  break;\n              case endian_little:\n                  input_swap = WORDS_BIGENDIAN;\n                  break;\n            }\n          break;\n\n           \n\n#define CASE_OLD_ARG(old_char,new_string)\t\t\\\n        case old_char:\t\t\t\t\t\\\n          ok &= decode_format_string (new_string);\t\\\n          break\n\n          CASE_OLD_ARG ('a', \"a\");\n          CASE_OLD_ARG ('b', \"o1\");\n          CASE_OLD_ARG ('c', \"c\");\n          CASE_OLD_ARG ('D', \"u4\");  \n          CASE_OLD_ARG ('d', \"u2\");\n        case 'F':  \n          CASE_OLD_ARG ('e', \"fD\");  \n          CASE_OLD_ARG ('f', \"fF\");\n        case 'X':  \n          CASE_OLD_ARG ('H', \"x4\");  \n          CASE_OLD_ARG ('i', \"dI\");\n        case 'I': case 'L':  \n          CASE_OLD_ARG ('l', \"dL\");\n          CASE_OLD_ARG ('O', \"o4\");  \n        case 'B':  \n          CASE_OLD_ARG ('o', \"o2\");\n          CASE_OLD_ARG ('s', \"d2\");\n        case 'h':  \n          CASE_OLD_ARG ('x', \"x2\");\n\n#undef CASE_OLD_ARG\n\n        case 'w':\n          modern = true;\n          width_specified = true;\n          if (optarg == nullptr)\n            {\n              desired_width = 32;\n            }\n          else\n            {\n              intmax_t w_tmp;\n              s_err = xstrtoimax (optarg, nullptr, 10, &w_tmp, \"\");\n              if (s_err != LONGINT_OK || w_tmp <= 0)\n                xstrtol_fatal (s_err, oi, c, long_options, optarg);\n              if (ckd_add (&desired_width, w_tmp, 0))\n                error (EXIT_FAILURE, 0, _(\"%s is too large\"), quote (optarg));\n            }\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n          break;\n        }\n    }\n\n  if (!ok)\n    return EXIT_FAILURE;\n\n  if (flag_dump_strings && n_specs > 0)\n    error (EXIT_FAILURE, 0,\n           _(\"no type may be specified when dumping strings\"));\n\n  n_files = argc - optind;\n\n   \n\n  if (!modern || traditional)\n    {\n      uintmax_t o1;\n      uintmax_t o2;\n\n      switch (n_files)\n        {\n        case 1:\n          if ((traditional || argv[optind][0] == '+')\n              && parse_old_offset (argv[optind], &o1))\n            {\n              n_bytes_to_skip = o1;\n              --n_files;\n              ++argv;\n            }\n          break;\n\n        case 2:\n          if ((traditional || argv[optind + 1][0] == '+'\n               || ISDIGIT (argv[optind + 1][0]))\n              && parse_old_offset (argv[optind + 1], &o2))\n            {\n              if (traditional && parse_old_offset (argv[optind], &o1))\n                {\n                  n_bytes_to_skip = o1;\n                  flag_pseudo_start = true;\n                  pseudo_start = o2;\n                  argv += 2;\n                  n_files -= 2;\n                }\n              else\n                {\n                  n_bytes_to_skip = o2;\n                  --n_files;\n                  argv[optind + 1] = argv[optind];\n                  ++argv;\n                }\n            }\n          break;\n\n        case 3:\n          if (traditional\n              && parse_old_offset (argv[optind + 1], &o1)\n              && parse_old_offset (argv[optind + 2], &o2))\n            {\n              n_bytes_to_skip = o1;\n              flag_pseudo_start = true;\n              pseudo_start = o2;\n              argv[optind + 2] = argv[optind];\n              argv += 2;\n              n_files -= 2;\n            }\n          break;\n        }\n\n      if (traditional && 1 < n_files)\n        {\n          error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 1]));\n          error (0, 0, \"%s\",\n                 _(\"compatibility mode supports at most one file\"));\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (flag_pseudo_start)\n    {\n      if (format_address == format_address_none)\n        {\n          address_base = 8;\n          address_pad_len = 7;\n          format_address = format_address_paren;\n        }\n      else\n        format_address = format_address_label;\n    }\n\n  if (limit_bytes_to_format)\n    {\n      end_offset = n_bytes_to_skip + max_bytes_to_format;\n      if (end_offset < n_bytes_to_skip)\n        error (EXIT_FAILURE, 0, _(\"skip-bytes + read-bytes is too large\"));\n    }\n\n  if (n_specs == 0)\n    decode_format_string (\"oS\");\n\n  if (n_files > 0)\n    {\n       \n\n      file_list = (char const *const *) &argv[optind];\n    }\n  else\n    {\n       \n\n      file_list = default_file_list;\n    }\n\n   \n  ok = open_next_file ();\n  if (in_stream == nullptr)\n    goto cleanup;\n\n   \n  ok &= skip (n_bytes_to_skip);\n  if (in_stream == nullptr)\n    goto cleanup;\n\n  pseudo_offset = (flag_pseudo_start ? pseudo_start - n_bytes_to_skip : 0);\n\n   \n  l_c_m = get_lcm ();\n\n  if (width_specified)\n    {\n      if (desired_width != 0 && desired_width % l_c_m == 0)\n        bytes_per_block = desired_width;\n      else\n        {\n          error (0, 0, _(\"warning: invalid width %td; using %d instead\"),\n                 desired_width, l_c_m);\n          bytes_per_block = l_c_m;\n        }\n    }\n  else\n    {\n      if (l_c_m < DEFAULT_BYTES_PER_BLOCK)\n        bytes_per_block = l_c_m * (DEFAULT_BYTES_PER_BLOCK / l_c_m);\n      else\n        bytes_per_block = l_c_m;\n    }\n\n   \n  for (i = 0; i < n_specs; i++)\n    {\n      int fields_per_block = bytes_per_block / width_bytes[spec[i].size];\n      int block_width = (spec[i].field_width + 1) * fields_per_block;\n      if (width_per_block < block_width)\n        width_per_block = block_width;\n    }\n  for (i = 0; i < n_specs; i++)\n    {\n      int fields_per_block = bytes_per_block / width_bytes[spec[i].size];\n      int block_width = spec[i].field_width * fields_per_block;\n      spec[i].pad_width = width_per_block - block_width;\n    }\n\n#ifdef DEBUG\n  printf (\"lcm=%d, width_per_block=%\"PRIuMAX\"\\n\", l_c_m,\n          (uintmax_t) width_per_block);\n  for (i = 0; i < n_specs; i++)\n    {\n      int fields_per_block = bytes_per_block / width_bytes[spec[i].size];\n      affirm (bytes_per_block % width_bytes[spec[i].size] == 0);\n      affirm (1 <= spec[i].pad_width / fields_per_block);\n      printf (\"%d: fmt=\\\"%s\\\" in_width=%d out_width=%d pad=%d\\n\",\n              i, spec[i].fmt_string, width_bytes[spec[i].size],\n              spec[i].field_width, spec[i].pad_width);\n    }\n#endif\n\n  ok &= (flag_dump_strings ? dump_strings () : dump ());\n\ncleanup:\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    error (EXIT_FAILURE, errno, _(\"standard input\"));\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}