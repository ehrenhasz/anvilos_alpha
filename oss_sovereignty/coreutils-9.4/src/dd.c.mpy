{
  "module_name": "dd.c",
  "hash_id": "2eadfaa720518b8d8a46f598e3fc3086fb639f6f04eef3d42227ba529fc10deb",
  "original_prompt": "Ingested from coreutils-9.4/src/dd.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <sys/types.h>\n#include <signal.h>\n#include <stdckdint.h>\n\n#include \"system.h\"\n#include \"alignalloc.h\"\n#include \"close-stream.h\"\n#include \"fd-reopen.h\"\n#include \"gethrxtime.h\"\n#include \"human.h\"\n#include \"ioblksize.h\"\n#include \"long-options.h\"\n#include \"quote.h\"\n#include \"verror.h\"\n#include \"xstrtol.h\"\n#include \"xtime.h\"\n\n \n#define PROGRAM_NAME \"dd\"\n\n#define AUTHORS \\\n  proper_name (\"Paul Rubin\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Stuart Kemp\")\n\n \n#ifndef SA_NOCLDSTOP\n# define SA_NOCLDSTOP 0\n# define sigprocmask(How, Set, Oset)  \n# define sigset_t int\n# if ! HAVE_SIGINTERRUPT\n#  define siginterrupt(sig, flag)  \n# endif\n#endif\n\n \n#ifndef SA_RESETHAND\n# define SA_RESETHAND 0\n#endif\n\n#ifndef SIGINFO\n# define SIGINFO SIGUSR1\n#endif\n\n \n#ifndef O_CIO\n# define O_CIO 0\n#endif\n\n \n#undef O_NOCACHE\n\n#if ! HAVE_FDATASYNC\n# define fdatasync(fd) (errno = ENOSYS, -1)\n#endif\n\n#define output_char(c)\t\t\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      obuf[oc++] = (c);\t\t\t\t\\\n      if (oc >= output_blocksize)\t\t\\\n        write_output ();\t\t\t\\\n    }\t\t\t\t\t\t\\\n  while (0)\n\n \n#define DEFAULT_BLOCKSIZE 512\n\n \nenum\n  {\n    C_ASCII = 01,\n\n    C_EBCDIC = 02,\n    C_IBM = 04,\n    C_BLOCK = 010,\n    C_UNBLOCK = 020,\n    C_LCASE = 040,\n    C_UCASE = 0100,\n    C_SWAB = 0200,\n    C_NOERROR = 0400,\n    C_NOTRUNC = 01000,\n    C_SYNC = 02000,\n\n     \n    C_TWOBUFS = 04000,\n\n    C_NOCREAT = 010000,\n    C_EXCL = 020000,\n    C_FDATASYNC = 040000,\n    C_FSYNC = 0100000,\n\n    C_SPARSE = 0200000\n  };\n\n \nenum\n  {\n    STATUS_NONE = 1,\n    STATUS_NOXFER = 2,\n    STATUS_DEFAULT = 3,\n    STATUS_PROGRESS = 4\n  };\n\n \nstatic char const *input_file = nullptr;\n\n \nstatic char const *output_file = nullptr;\n\n \nstatic idx_t page_size;\n\n \nstatic idx_t input_blocksize = 0;\n\n \nstatic idx_t output_blocksize = 0;\n\n \nstatic idx_t conversion_blocksize = 0;\n\n \nstatic intmax_t skip_records = 0;\n\n \nstatic idx_t skip_bytes = 0;\n\n \nstatic intmax_t seek_records = 0;\n\n \nstatic intmax_t seek_bytes = 0;\n\n \nstatic bool final_op_was_seek;\n\n \nstatic intmax_t max_records = INTMAX_MAX;\n\n \nstatic idx_t max_bytes = 0;\n\n \nstatic int conversions_mask = 0;\n\n \nstatic int input_flags = 0;\nstatic int output_flags = 0;\n\n \nstatic int status_level = STATUS_DEFAULT;\n\n \nstatic bool translation_needed = false;\n\n \nstatic intmax_t w_partial = 0;\n\n \nstatic intmax_t w_full = 0;\n\n \nstatic intmax_t r_partial = 0;\n\n \nstatic intmax_t r_full = 0;\n\n \nstatic intmax_t w_bytes = 0;\n\n \nstatic intmax_t reported_w_bytes = -1;\n\n \nstatic xtime_t start_time;\n\n \nstatic xtime_t next_time;\n\n \nstatic int progress_len;\n\n \nstatic bool input_seekable;\n\n \nstatic int input_seek_errno;\n\n \nstatic off_t input_offset;\n\n \nstatic bool warn_partial_read;\n\n \nstatic intmax_t r_truncate = 0;\n\n \nstatic char newline_character = '\\n';\nstatic char space_character = ' ';\n\n \nstatic char *ibuf;\nstatic char *obuf;\n\n \nstatic idx_t oc = 0;\n\n \nstatic idx_t col = 0;\n\n \nstatic sigset_t caught_signals;\n\n \nstatic sig_atomic_t volatile interrupt_signal;\n\n \nstatic sig_atomic_t volatile info_signal_count;\n\n \nstatic bool i_nocache, o_nocache;\n\n \nstatic bool i_nocache_eof, o_nocache_eof;\n\n \nstatic ssize_t (*iread_fnc) (int fd, char *buf, idx_t size);\n\n \n#define LONGEST_SYMBOL \"count_bytes\"\n\n \nstruct symbol_value\n{\n  char symbol[sizeof LONGEST_SYMBOL];\n  int value;\n};\n\n \nstatic struct symbol_value const conversions[] =\n{\n  {\"ascii\", C_ASCII | C_UNBLOCK | C_TWOBUFS},\t \n  {\"ebcdic\", C_EBCDIC | C_BLOCK | C_TWOBUFS},\t \n  {\"ibm\", C_IBM | C_BLOCK | C_TWOBUFS},\t \n  {\"block\", C_BLOCK | C_TWOBUFS},\t \n  {\"unblock\", C_UNBLOCK | C_TWOBUFS},\t \n  {\"lcase\", C_LCASE | C_TWOBUFS},\t \n  {\"ucase\", C_UCASE | C_TWOBUFS},\t \n  {\"sparse\", C_SPARSE},\t\t \n  {\"swab\", C_SWAB | C_TWOBUFS},\t \n  {\"noerror\", C_NOERROR},\t \n  {\"nocreat\", C_NOCREAT},\t \n  {\"excl\", C_EXCL},\t\t \n  {\"notrunc\", C_NOTRUNC},\t \n  {\"sync\", C_SYNC},\t\t \n  {\"fdatasync\", C_FDATASYNC},\t \n  {\"fsync\", C_FSYNC},\t\t \n  {\"\", 0}\n};\n\n#define FFS_MASK(x) ((x) ^ ((x) & ((x) - 1)))\nenum\n  {\n     \n    v = ~(0\n          | O_APPEND\n          | O_BINARY\n          | O_CIO\n          | O_DIRECT\n          | O_DIRECTORY\n          | O_DSYNC\n          | O_NOATIME\n          | O_NOCTTY\n          | O_NOFOLLOW\n          | O_NOLINKS\n          | O_NONBLOCK\n          | O_SYNC\n          | O_TEXT\n          ),\n\n     \n    O_FULLBLOCK = FFS_MASK (v),\n    v2 = v ^ O_FULLBLOCK,\n\n    O_NOCACHE = FFS_MASK (v2),\n    v3 = v2 ^ O_NOCACHE,\n\n    O_COUNT_BYTES = FFS_MASK (v3),\n    v4 = v3 ^ O_COUNT_BYTES,\n\n    O_SKIP_BYTES = FFS_MASK (v4),\n    v5 = v4 ^ O_SKIP_BYTES,\n\n    O_SEEK_BYTES = FFS_MASK (v5)\n  };\n\n \nstatic_assert (O_FULLBLOCK != 0);\nstatic_assert (O_NOCACHE != 0);\nstatic_assert (O_COUNT_BYTES != 0);\nstatic_assert (O_SKIP_BYTES != 0);\nstatic_assert (O_SEEK_BYTES != 0);\n\n#define MULTIPLE_BITS_SET(i) (((i) & ((i) - 1)) != 0)\n\n \nstatic_assert ( ! MULTIPLE_BITS_SET (O_FULLBLOCK));\nstatic_assert ( ! MULTIPLE_BITS_SET (O_NOCACHE));\nstatic_assert ( ! MULTIPLE_BITS_SET (O_COUNT_BYTES));\nstatic_assert ( ! MULTIPLE_BITS_SET (O_SKIP_BYTES));\nstatic_assert ( ! MULTIPLE_BITS_SET (O_SEEK_BYTES));\n\n \nstatic struct symbol_value const flags[] =\n{\n  {\"append\",\t  O_APPEND},\n  {\"binary\",\t  O_BINARY},\n  {\"cio\",\t  O_CIO},\n  {\"direct\",\t  O_DIRECT},\n  {\"directory\",   O_DIRECTORY},\n  {\"dsync\",\t  O_DSYNC},\n  {\"noatime\",\t  O_NOATIME},\n  {\"nocache\",\t  O_NOCACHE},    \n  {\"noctty\",\t  O_NOCTTY},\n  {\"nofollow\",\t  HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0},\n  {\"nolinks\",\t  O_NOLINKS},\n  {\"nonblock\",\t  O_NONBLOCK},\n  {\"sync\",\t  O_SYNC},\n  {\"text\",\t  O_TEXT},\n  {\"fullblock\",   O_FULLBLOCK},  \n  {\"count_bytes\", O_COUNT_BYTES},\n  {\"skip_bytes\",  O_SKIP_BYTES},\n  {\"seek_bytes\",  O_SEEK_BYTES},\n  {\"\",\t\t0}\n};\n\n \nstatic struct symbol_value const statuses[] =\n{\n  {\"none\",\tSTATUS_NONE},\n  {\"noxfer\",\tSTATUS_NOXFER},\n  {\"progress\",\tSTATUS_PROGRESS},\n  {\"\",\t\t0}\n};\n\n \nstatic unsigned char trans_table[256];\n\n \n\nstatic char const ascii_to_ebcdic[] =\n{\n  '\\000', '\\001', '\\002', '\\003', '\\067', '\\055', '\\056', '\\057',\n  '\\026', '\\005', '\\045', '\\013', '\\014', '\\015', '\\016', '\\017',\n  '\\020', '\\021', '\\022', '\\023', '\\074', '\\075', '\\062', '\\046',\n  '\\030', '\\031', '\\077', '\\047', '\\034', '\\035', '\\036', '\\037',\n  '\\100', '\\132', '\\177', '\\173', '\\133', '\\154', '\\120', '\\175',\n  '\\115', '\\135', '\\134', '\\116', '\\153', '\\140', '\\113', '\\141',\n  '\\360', '\\361', '\\362', '\\363', '\\364', '\\365', '\\366', '\\367',\n  '\\370', '\\371', '\\172', '\\136', '\\114', '\\176', '\\156', '\\157',\n  '\\174', '\\301', '\\302', '\\303', '\\304', '\\305', '\\306', '\\307',\n  '\\310', '\\311', '\\321', '\\322', '\\323', '\\324', '\\325', '\\326',\n  '\\327', '\\330', '\\331', '\\342', '\\343', '\\344', '\\345', '\\346',\n  '\\347', '\\350', '\\351', '\\255', '\\340', '\\275', '\\232', '\\155',\n  '\\171', '\\201', '\\202', '\\203', '\\204', '\\205', '\\206', '\\207',\n  '\\210', '\\211', '\\221', '\\222', '\\223', '\\224', '\\225', '\\226',\n  '\\227', '\\230', '\\231', '\\242', '\\243', '\\244', '\\245', '\\246',\n  '\\247', '\\250', '\\251', '\\300', '\\117', '\\320', '\\137', '\\007',\n  '\\040', '\\041', '\\042', '\\043', '\\044', '\\025', '\\006', '\\027',\n  '\\050', '\\051', '\\052', '\\053', '\\054', '\\011', '\\012', '\\033',\n  '\\060', '\\061', '\\032', '\\063', '\\064', '\\065', '\\066', '\\010',\n  '\\070', '\\071', '\\072', '\\073', '\\004', '\\024', '\\076', '\\341',\n  '\\101', '\\102', '\\103', '\\104', '\\105', '\\106', '\\107', '\\110',\n  '\\111', '\\121', '\\122', '\\123', '\\124', '\\125', '\\126', '\\127',\n  '\\130', '\\131', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n  '\\150', '\\151', '\\160', '\\161', '\\162', '\\163', '\\164', '\\165',\n  '\\166', '\\167', '\\170', '\\200', '\\212', '\\213', '\\214', '\\215',\n  '\\216', '\\217', '\\220', '\\152', '\\233', '\\234', '\\235', '\\236',\n  '\\237', '\\240', '\\252', '\\253', '\\254', '\\112', '\\256', '\\257',\n  '\\260', '\\261', '\\262', '\\263', '\\264', '\\265', '\\266', '\\267',\n  '\\270', '\\271', '\\272', '\\273', '\\274', '\\241', '\\276', '\\277',\n  '\\312', '\\313', '\\314', '\\315', '\\316', '\\317', '\\332', '\\333',\n  '\\334', '\\335', '\\336', '\\337', '\\352', '\\353', '\\354', '\\355',\n  '\\356', '\\357', '\\372', '\\373', '\\374', '\\375', '\\376', '\\377'\n};\n\nstatic char const ascii_to_ibm[] =\n{\n  '\\000', '\\001', '\\002', '\\003', '\\067', '\\055', '\\056', '\\057',\n  '\\026', '\\005', '\\045', '\\013', '\\014', '\\015', '\\016', '\\017',\n  '\\020', '\\021', '\\022', '\\023', '\\074', '\\075', '\\062', '\\046',\n  '\\030', '\\031', '\\077', '\\047', '\\034', '\\035', '\\036', '\\037',\n  '\\100', '\\132', '\\177', '\\173', '\\133', '\\154', '\\120', '\\175',\n  '\\115', '\\135', '\\134', '\\116', '\\153', '\\140', '\\113', '\\141',\n  '\\360', '\\361', '\\362', '\\363', '\\364', '\\365', '\\366', '\\367',\n  '\\370', '\\371', '\\172', '\\136', '\\114', '\\176', '\\156', '\\157',\n  '\\174', '\\301', '\\302', '\\303', '\\304', '\\305', '\\306', '\\307',\n  '\\310', '\\311', '\\321', '\\322', '\\323', '\\324', '\\325', '\\326',\n  '\\327', '\\330', '\\331', '\\342', '\\343', '\\344', '\\345', '\\346',\n  '\\347', '\\350', '\\351', '\\255', '\\340', '\\275', '\\137', '\\155',\n  '\\171', '\\201', '\\202', '\\203', '\\204', '\\205', '\\206', '\\207',\n  '\\210', '\\211', '\\221', '\\222', '\\223', '\\224', '\\225', '\\226',\n  '\\227', '\\230', '\\231', '\\242', '\\243', '\\244', '\\245', '\\246',\n  '\\247', '\\250', '\\251', '\\300', '\\117', '\\320', '\\241', '\\007',\n  '\\040', '\\041', '\\042', '\\043', '\\044', '\\025', '\\006', '\\027',\n  '\\050', '\\051', '\\052', '\\053', '\\054', '\\011', '\\012', '\\033',\n  '\\060', '\\061', '\\032', '\\063', '\\064', '\\065', '\\066', '\\010',\n  '\\070', '\\071', '\\072', '\\073', '\\004', '\\024', '\\076', '\\341',\n  '\\101', '\\102', '\\103', '\\104', '\\105', '\\106', '\\107', '\\110',\n  '\\111', '\\121', '\\122', '\\123', '\\124', '\\125', '\\126', '\\127',\n  '\\130', '\\131', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n  '\\150', '\\151', '\\160', '\\161', '\\162', '\\163', '\\164', '\\165',\n  '\\166', '\\167', '\\170', '\\200', '\\212', '\\213', '\\214', '\\215',\n  '\\216', '\\217', '\\220', '\\232', '\\233', '\\234', '\\235', '\\236',\n  '\\237', '\\240', '\\252', '\\253', '\\254', '\\255', '\\256', '\\257',\n  '\\260', '\\261', '\\262', '\\263', '\\264', '\\265', '\\266', '\\267',\n  '\\270', '\\271', '\\272', '\\273', '\\274', '\\275', '\\276', '\\277',\n  '\\312', '\\313', '\\314', '\\315', '\\316', '\\317', '\\332', '\\333',\n  '\\334', '\\335', '\\336', '\\337', '\\352', '\\353', '\\354', '\\355',\n  '\\356', '\\357', '\\372', '\\373', '\\374', '\\375', '\\376', '\\377'\n};\n\nstatic char const ebcdic_to_ascii[] =\n{\n  '\\000', '\\001', '\\002', '\\003', '\\234', '\\011', '\\206', '\\177',\n  '\\227', '\\215', '\\216', '\\013', '\\014', '\\015', '\\016', '\\017',\n  '\\020', '\\021', '\\022', '\\023', '\\235', '\\205', '\\010', '\\207',\n  '\\030', '\\031', '\\222', '\\217', '\\034', '\\035', '\\036', '\\037',\n  '\\200', '\\201', '\\202', '\\203', '\\204', '\\012', '\\027', '\\033',\n  '\\210', '\\211', '\\212', '\\213', '\\214', '\\005', '\\006', '\\007',\n  '\\220', '\\221', '\\026', '\\223', '\\224', '\\225', '\\226', '\\004',\n  '\\230', '\\231', '\\232', '\\233', '\\024', '\\025', '\\236', '\\032',\n  '\\040', '\\240', '\\241', '\\242', '\\243', '\\244', '\\245', '\\246',\n  '\\247', '\\250', '\\325', '\\056', '\\074', '\\050', '\\053', '\\174',\n  '\\046', '\\251', '\\252', '\\253', '\\254', '\\255', '\\256', '\\257',\n  '\\260', '\\261', '\\041', '\\044', '\\052', '\\051', '\\073', '\\176',\n  '\\055', '\\057', '\\262', '\\263', '\\264', '\\265', '\\266', '\\267',\n  '\\270', '\\271', '\\313', '\\054', '\\045', '\\137', '\\076', '\\077',\n  '\\272', '\\273', '\\274', '\\275', '\\276', '\\277', '\\300', '\\301',\n  '\\302', '\\140', '\\072', '\\043', '\\100', '\\047', '\\075', '\\042',\n  '\\303', '\\141', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n  '\\150', '\\151', '\\304', '\\305', '\\306', '\\307', '\\310', '\\311',\n  '\\312', '\\152', '\\153', '\\154', '\\155', '\\156', '\\157', '\\160',\n  '\\161', '\\162', '\\136', '\\314', '\\315', '\\316', '\\317', '\\320',\n  '\\321', '\\345', '\\163', '\\164', '\\165', '\\166', '\\167', '\\170',\n  '\\171', '\\172', '\\322', '\\323', '\\324', '\\133', '\\326', '\\327',\n  '\\330', '\\331', '\\332', '\\333', '\\334', '\\335', '\\336', '\\337',\n  '\\340', '\\341', '\\342', '\\343', '\\344', '\\135', '\\346', '\\347',\n  '\\173', '\\101', '\\102', '\\103', '\\104', '\\105', '\\106', '\\107',\n  '\\110', '\\111', '\\350', '\\351', '\\352', '\\353', '\\354', '\\355',\n  '\\175', '\\112', '\\113', '\\114', '\\115', '\\116', '\\117', '\\120',\n  '\\121', '\\122', '\\356', '\\357', '\\360', '\\361', '\\362', '\\363',\n  '\\134', '\\237', '\\123', '\\124', '\\125', '\\126', '\\127', '\\130',\n  '\\131', '\\132', '\\364', '\\365', '\\366', '\\367', '\\370', '\\371',\n  '\\060', '\\061', '\\062', '\\063', '\\064', '\\065', '\\066', '\\067',\n  '\\070', '\\071', '\\372', '\\373', '\\374', '\\375', '\\376', '\\377'\n};\n\n \nstatic bool close_stdout_required = true;\n\n \nstatic void\nmaybe_close_stdout (void)\n{\n  if (close_stdout_required)\n    close_stdout ();\n  else if (close_stream (stderr) != 0)\n    _exit (EXIT_FAILURE);\n}\n\n \n\nATTRIBUTE_FORMAT ((__printf__, 2, 3))\nstatic void\ndiagnose (int errnum, char const *fmt, ...)\n{\n  if (0 < progress_len)\n    {\n      fputc ('\\n', stderr);\n      progress_len = 0;\n    }\n\n  va_list ap;\n  va_start (ap, fmt);\n  verror (0, errnum, fmt, ap);\n  va_end (ap);\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPERAND]...\\n\\\n  or:  %s OPTION\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nCopy a file, converting and formatting according to the operands.\\n\\\n\\n\\\n  bs=BYTES        read and write up to BYTES bytes at a time (default: 512);\\n\\\n                  overrides ibs and obs\\n\\\n  cbs=BYTES       convert BYTES bytes at a time\\n\\\n  conv=CONVS      convert the file as per the comma separated symbol list\\n\\\n  count=N         copy only N input blocks\\n\\\n  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  if=FILE         read from FILE instead of stdin\\n\\\n  iflag=FLAGS     read as per the comma separated symbol list\\n\\\n  obs=BYTES       write BYTES bytes at a time (default: 512)\\n\\\n  of=FILE         write to FILE instead of stdout\\n\\\n  oflag=FLAGS     write as per the comma separated symbol list\\n\\\n  seek=N          (or oseek=N) skip N obs-sized output blocks\\n\\\n  skip=N          (or iseek=N) skip N ibs-sized input blocks\\n\\\n  status=LEVEL    The LEVEL of information to print to stderr;\\n\\\n                  'none' suppresses everything but error messages,\\n\\\n                  'noxfer' suppresses the final transfer statistics,\\n\\\n                  'progress' shows periodic transfer statistics\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nN and BYTES may be followed by the following multiplicative suffixes:\\n\\\nc=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\\n\\\nGB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\n\\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\\nIf N ends in 'B', it counts bytes not blocks.\\n\\\n\\n\\\nEach CONV symbol may be:\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  ascii     from EBCDIC to ASCII\\n\\\n  ebcdic    from ASCII to EBCDIC\\n\\\n  ibm       from ASCII to alternate EBCDIC\\n\\\n  block     pad newline-terminated records with spaces to cbs-size\\n\\\n  unblock   replace trailing spaces in cbs-size records with newline\\n\\\n  lcase     change upper case to lower case\\n\\\n  ucase     change lower case to upper case\\n\\\n  sparse    try to seek rather than write all-NUL output blocks\\n\\\n  swab      swap every pair of input bytes\\n\\\n  sync      pad every input block with NULs to ibs-size; when used\\n\\\n            with block or unblock, pad with spaces rather than NULs\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  excl      fail if the output file already exists\\n\\\n  nocreat   do not create the output file\\n\\\n  notrunc   do not truncate the output file\\n\\\n  noerror   continue after read errors\\n\\\n  fdatasync  physically write output file data before finishing\\n\\\n  fsync     likewise, but also write metadata\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nEach FLAG symbol may be:\\n\\\n\\n\\\n  append    append mode (makes sense only for output; conv=notrunc suggested)\\n\\\n\"), stdout);\n      if (O_CIO)\n        fputs (_(\"  cio       use concurrent I/O for data\\n\"), stdout);\n      if (O_DIRECT)\n        fputs (_(\"  direct    use direct I/O for data\\n\"), stdout);\n      if (O_DIRECTORY)\n        fputs (_(\"  directory  fail unless a directory\\n\"), stdout);\n      if (O_DSYNC)\n        fputs (_(\"  dsync     use synchronized I/O for data\\n\"), stdout);\n      if (O_SYNC)\n        fputs (_(\"  sync      likewise, but also for metadata\\n\"), stdout);\n      fputs (_(\"  fullblock  accumulate full blocks of input (iflag only)\\n\"),\n             stdout);\n      if (O_NONBLOCK)\n        fputs (_(\"  nonblock  use non-blocking I/O\\n\"), stdout);\n      if (O_NOATIME)\n        fputs (_(\"  noatime   do not update access time\\n\"), stdout);\n#if HAVE_POSIX_FADVISE\n      if (O_NOCACHE)\n        fputs (_(\"  nocache   Request to drop cache.  See also oflag=sync\\n\"),\n               stdout);\n#endif\n      if (O_NOCTTY)\n        fputs (_(\"  noctty    do not assign controlling terminal from file\\n\"),\n               stdout);\n      if (HAVE_WORKING_O_NOFOLLOW)\n        fputs (_(\"  nofollow  do not follow symlinks\\n\"), stdout);\n      if (O_NOLINKS)\n        fputs (_(\"  nolinks   fail if multiply-linked\\n\"), stdout);\n      if (O_BINARY)\n        fputs (_(\"  binary    use binary I/O for data\\n\"), stdout);\n      if (O_TEXT)\n        fputs (_(\"  text      use text I/O for data\\n\"), stdout);\n\n      {\n        printf (_(\"\\\n\\n\\\nSending a %s signal to a running 'dd' process makes it\\n\\\nprint I/O statistics to standard error and then resume copying.\\n\\\n\\n\\\nOptions are:\\n\\\n\\n\\\n\"), SIGINFO == SIGUSR1 ? \"USR1\" : \"INFO\");\n      }\n\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Common options to use when displaying sizes and rates.  */\n\nenum { human_opts = (human_autoscale | human_round_to_nearest\n                     | human_space_before_unit | human_SI | human_B) };\n\n/* Ensure input buffer IBUF is allocated.  */\n\nstatic void\nalloc_ibuf (void)\n{\n  if (ibuf)\n    return;\n\n  bool extra_byte_for_swab = !!(conversions_mask & C_SWAB);\n  ibuf = alignalloc (page_size, input_blocksize + extra_byte_for_swab);\n  if (!ibuf)\n    {\n      char hbuf[LONGEST_HUMAN_READABLE + 1];\n      error (EXIT_FAILURE, 0,\n             _(\"memory exhausted by input buffer of size %td bytes (%s)\"),\n             input_blocksize,\n             human_readable (input_blocksize, hbuf,\n                             human_opts | human_base_1024, 1, 1));\n    }\n}\n\n/* Ensure output buffer OBUF is allocated/initialized.  */\n\nstatic void\nalloc_obuf (void)\n{\n  if (obuf)\n    return;\n\n  if (conversions_mask & C_TWOBUFS)\n    {\n      obuf = alignalloc (page_size, output_blocksize);\n      if (!obuf)\n        {\n          char hbuf[LONGEST_HUMAN_READABLE + 1];\n          error (EXIT_FAILURE, 0,\n                 _(\"memory exhausted by output buffer of size %td\"\n                   \" bytes (%s)\"),\n                 output_blocksize,\n                 human_readable (output_blocksize, hbuf,\n                                 human_opts | human_base_1024, 1, 1));\n        }\n    }\n  else\n    {\n      alloc_ibuf ();\n      obuf = ibuf;\n    }\n}\n\nstatic void\ntranslate_charset (char const *new_trans)\n{\n  for (int i = 0; i < 256; i++)\n    trans_table[i] = new_trans[trans_table[i]];\n  translation_needed = true;\n}\n\n/* Return true if I has more than one bit set.  I must be nonnegative.  */\n\nstatic inline bool\nmultiple_bits_set (int i)\n{\n  return MULTIPLE_BITS_SET (i);\n}\n\nstatic bool\nabbreviation_lacks_prefix (char const *message)\n{\n  return message[strlen (message) - 2] == ' ';\n}\n\n/* Print transfer statistics.  */\n\nstatic void\nprint_xfer_stats (xtime_t progress_time)\n{\n  xtime_t now = progress_time ? progress_time : gethrxtime ();\n  static char const slash_s[] = \"/s\";\n  char hbuf[3][LONGEST_HUMAN_READABLE + sizeof slash_s];\n  double delta_s;\n  char const *bytes_per_second;\n  char const *si = human_readable (w_bytes, hbuf[0], human_opts, 1, 1);\n  char const *iec = human_readable (w_bytes, hbuf[1],\n                                    human_opts | human_base_1024, 1, 1);\n\n  /* Use integer arithmetic to compute the transfer rate,\n     since that makes it easy to use SI abbreviations.  */\n  char *bpsbuf = hbuf[2];\n  int bpsbufsize = sizeof hbuf[2];\n  if (start_time < now)\n    {\n      double XTIME_PRECISIONe0 = XTIME_PRECISION;\n      xtime_t delta_xtime = now - start_time;\n      delta_s = delta_xtime / XTIME_PRECISIONe0;\n      bytes_per_second = human_readable (w_bytes, bpsbuf, human_opts,\n                                         XTIME_PRECISION, delta_xtime);\n      strcat (bytes_per_second - bpsbuf + bpsbuf, slash_s);\n    }\n  else\n    {\n      delta_s = 0;\n      snprintf (bpsbuf, bpsbufsize, \"%s B/s\", _(\"Infinity\"));\n      bytes_per_second = bpsbuf;\n    }\n\n  if (progress_time)\n    fputc ('\\r', stderr);\n\n  /* Use full seconds when printing progress, since the progress\n     report is output once per second and there is little point\n     displaying any subsecond jitter.  Use default precision with %g\n     otherwise, as this provides more-useful output then.  With long\n     transfers %g can generate a number with an exponent; that is OK.  */\n  char delta_s_buf[24];\n  snprintf (delta_s_buf, sizeof delta_s_buf,\n            progress_time ? \"%.0f s\" : \"%g s\", delta_s);\n\n  int stats_len\n    = (abbreviation_lacks_prefix (si)\n       ? fprintf (stderr,\n                  ngettext (\"%\"PRIdMAX\" byte copied, %s, %s\",\n                            \"%\"PRIdMAX\" bytes copied, %s, %s\",\n                            select_plural (w_bytes)),\n                  w_bytes, delta_s_buf, bytes_per_second)\n       : abbreviation_lacks_prefix (iec)\n       ? fprintf (stderr,\n                  _(\"%\"PRIdMAX\" bytes (%s) copied, %s, %s\"),\n                  w_bytes, si, delta_s_buf, bytes_per_second)\n       : fprintf (stderr,\n                  _(\"%\"PRIdMAX\" bytes (%s, %s) copied, %s, %s\"),\n                  w_bytes, si, iec, delta_s_buf, bytes_per_second));\n\n  if (progress_time)\n    {\n      /* Erase any trailing junk on the output line by outputting\n         spaces.  In theory this could glitch the display because the\n         formatted translation of a line describing a larger file\n         could consume fewer screen columns than the strlen difference\n         from the previously formatted translation.  In practice this\n         does not seem to be a problem.  */\n      if (0 <= stats_len && stats_len < progress_len)\n        fprintf (stderr, \"%*s\", progress_len - stats_len, \"\");\n      progress_len = stats_len;\n    }\n  else\n    fputc ('\\n', stderr);\n\n  reported_w_bytes = w_bytes;\n}\n\nstatic void\nprint_stats (void)\n{\n  if (status_level == STATUS_NONE)\n    return;\n\n  if (0 < progress_len)\n    {\n      fputc ('\\n', stderr);\n      progress_len = 0;\n    }\n\n  fprintf (stderr,\n           _(\"%\"PRIdMAX\"+%\"PRIdMAX\" records in\\n\"\n             \"%\"PRIdMAX\"+%\"PRIdMAX\" records out\\n\"),\n           r_full, r_partial, w_full, w_partial);\n\n  if (r_truncate != 0)\n    fprintf (stderr,\n             ngettext (\"%\"PRIdMAX\" truncated record\\n\",\n                       \"%\"PRIdMAX\" truncated records\\n\",\n                       select_plural (r_truncate)),\n             r_truncate);\n\n  if (status_level == STATUS_NOXFER)\n    return;\n\n  print_xfer_stats (0);\n}\n\n/* An ordinary signal was received; arrange for the program to exit.  */\n\nstatic void\ninterrupt_handler (int sig)\n{\n  if (! SA_RESETHAND)\n    signal (sig, SIG_DFL);\n  interrupt_signal = sig;\n}\n\n/* An info signal was received; arrange for the program to print status.  */\n\nstatic void\nsiginfo_handler (int sig)\n{\n  if (! SA_NOCLDSTOP)\n    signal (sig, siginfo_handler);\n  info_signal_count++;\n}\n\n/* Install the signal handlers.  */\n\nstatic void\ninstall_signal_handlers (void)\n{\n  bool catch_siginfo = ! (SIGINFO == SIGUSR1 && getenv (\"POSIXLY_CORRECT\"));\n\n#if SA_NOCLDSTOP\n\n  struct sigaction act;\n  sigemptyset (&caught_signals);\n  if (catch_siginfo)\n    sigaddset (&caught_signals, SIGINFO);\n  sigaction (SIGINT, nullptr, &act);\n  if (act.sa_handler != SIG_IGN)\n    sigaddset (&caught_signals, SIGINT);\n  act.sa_mask = caught_signals;\n\n  if (sigismember (&caught_signals, SIGINFO))\n    {\n      act.sa_handler = siginfo_handler;\n      /* Note we don't use SA_RESTART here and instead\n         handle EINTR explicitly in iftruncate etc.\n         to avoid blocking on uncommitted read/write calls.  */\n      act.sa_flags = 0;\n      sigaction (SIGINFO, &act, nullptr);\n    }\n\n  if (sigismember (&caught_signals, SIGINT))\n    {\n      act.sa_handler = interrupt_handler;\n      act.sa_flags = SA_NODEFER | SA_RESETHAND;\n      sigaction (SIGINT, &act, nullptr);\n    }\n\n#else\n\n  if (catch_siginfo)\n    {\n      signal (SIGINFO, siginfo_handler);\n      siginterrupt (SIGINFO, 1);\n    }\n  if (signal (SIGINT, SIG_IGN) != SIG_IGN)\n    {\n      signal (SIGINT, interrupt_handler);\n      siginterrupt (SIGINT, 1);\n    }\n#endif\n}\n\n/* Close FD.  Return 0 if successful, -1 (setting errno) otherwise.\n   If close fails with errno == EINTR, POSIX says the file descriptor\n   is in an unspecified state, so keep trying to close FD but do not\n   consider EBADF to be an error.  Do not process signals.  This all\n   differs somewhat from functions like ifdatasync and ifsync.  */\nstatic int\niclose (int fd)\n{\n  if (close (fd) != 0)\n    do\n      if (errno != EINTR)\n        return -1;\n    while (close (fd) != 0 && errno != EBADF);\n\n  return 0;\n}\n\nstatic int synchronize_output (void);\n\nstatic void\ncleanup (void)\n{\n  if (!interrupt_signal)\n    {\n      int sync_status = synchronize_output ();\n      if (sync_status)\n        exit (sync_status);\n    }\n\n  if (iclose (STDIN_FILENO) != 0)\n    error (EXIT_FAILURE, errno, _(\"closing input file %s\"),\n           quoteaf (input_file));\n\n  /* Don't remove this call to close, even though close_stdout\n     closes standard output.  This close is necessary when cleanup\n     is called as a consequence of signal handling.  */\n  if (iclose (STDOUT_FILENO) != 0)\n    error (EXIT_FAILURE, errno,\n           _(\"closing output file %s\"), quoteaf (output_file));\n}\n\n/* Process any pending signals.  If signals are caught, this function\n   should be called periodically.  Ideally there should never be an\n   unbounded amount of time when signals are not being processed.  */\n\nstatic void\nprocess_signals (void)\n{\n  while (interrupt_signal || info_signal_count)\n    {\n      int interrupt;\n      int infos;\n      sigset_t oldset;\n\n      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);\n\n      /* Reload interrupt_signal and info_signal_count, in case a new\n         signal was handled before sigprocmask took effect.  */\n      interrupt = interrupt_signal;\n      infos = info_signal_count;\n\n      if (infos)\n        info_signal_count = infos - 1;\n\n      sigprocmask (SIG_SETMASK, &oldset, nullptr);\n\n      if (interrupt)\n        cleanup ();\n      print_stats ();\n      if (interrupt)\n        raise (interrupt);\n    }\n}\n\nstatic void\nfinish_up (void)\n{\n  /* Process signals first, so that cleanup is called at most once.  */\n  process_signals ();\n  cleanup ();\n  print_stats ();\n}\n\nstatic void\nquit (int code)\n{\n  finish_up ();\n  exit (code);\n}\n\n/* Return LEN rounded down to a multiple of IO_BUFSIZE\n   (to minimize calls to the expensive posix_fadvise (,POSIX_FADV_DONTNEED),\n   while storing the remainder internally per FD.\n   Pass LEN == 0 to get the current remainder.  */\n\nstatic off_t\ncache_round (int fd, off_t len)\n{\n  static off_t i_pending, o_pending;\n  off_t *pending = (fd == STDIN_FILENO ? &i_pending : &o_pending);\n\n  if (len)\n    {\n      intmax_t c_pending;\n      if (ckd_add (&c_pending, *pending, len))\n        c_pending = INTMAX_MAX;\n      *pending = c_pending % IO_BUFSIZE;\n      if (c_pending > *pending)\n        len = c_pending - *pending;\n      else\n        len = 0;\n    }\n  else\n    len = *pending;\n\n  return len;\n}\n\n/* Discard the cache from the current offset of either\n   STDIN_FILENO or STDOUT_FILENO.\n   Return true on success.  */\n\nstatic bool\ninvalidate_cache (int fd, off_t len)\n{\n  int adv_ret = -1;\n  off_t offset;\n  bool nocache_eof = (fd == STDIN_FILENO ? i_nocache_eof : o_nocache_eof);\n\n  /* Minimize syscalls.  */\n  off_t clen = cache_round (fd, len);\n  if (len && !clen)\n    return true; /* Don't advise this time.  */\n  else if (! len && ! clen && ! nocache_eof)\n    return true;\n  off_t pending = len ? cache_round (fd, 0) : 0;\n\n  if (fd == STDIN_FILENO)\n    {\n      if (input_seekable)\n        offset = input_offset;\n      else\n        {\n          offset = -1;\n          errno = ESPIPE;\n        }\n    }\n  else\n    {\n      static off_t output_offset = -2;\n\n      if (output_offset != -1)\n        {\n          if (output_offset < 0)\n            output_offset = lseek (fd, 0, SEEK_CUR);\n          else if (len)\n            output_offset += clen + pending;\n        }\n\n      offset = output_offset;\n    }\n\n  if (0 <= offset)\n   {\n     if (! len && clen && nocache_eof)\n       {\n         pending = clen;\n         clen = 0;\n       }\n\n     /* Note we're being careful here to only invalidate what\n        we've read, so as not to dump any read ahead cache.\n        Note also the kernel is conservative and only invalidates\n        full pages in the specified range.  */\n#if HAVE_POSIX_FADVISE\n     offset = offset - clen - pending;\n     /* ensure full page specified when invalidating to eof.  */\n     if (clen == 0)\n       offset -= offset % page_size;\n     adv_ret = posix_fadvise (fd, offset, clen, POSIX_FADV_DONTNEED);\n#else\n     errno = ENOTSUP;\n#endif\n   }\n\n  return adv_ret != -1 ? true : false;\n}\n\n/* Read from FD into the buffer BUF of size SIZE, processing any\n   signals that arrive before bytes are read.  Return the number of\n   bytes read if successful, -1 (setting errno) on failure.  */\n\nstatic ssize_t\niread (int fd, char *buf, idx_t size)\n{\n  ssize_t nread;\n  static ssize_t prev_nread;\n\n  do\n    {\n      process_signals ();\n      nread = read (fd, buf, size);\n      /* Ignore final read error with iflag=direct as that\n         returns EINVAL due to the non aligned file offset.  */\n      if (nread == -1 && errno == EINVAL\n          && 0 < prev_nread && prev_nread < size\n          && (input_flags & O_DIRECT))\n        {\n          errno = 0;\n          nread = 0;\n        }\n    }\n  while (nread < 0 && errno == EINTR);\n\n  /* Short read may be due to received signal.  */\n  if (0 < nread && nread < size)\n    process_signals ();\n\n  if (0 < nread && warn_partial_read)\n    {\n      if (0 < prev_nread && prev_nread < size)\n        {\n          idx_t prev = prev_nread;\n          if (status_level != STATUS_NONE)\n            diagnose (0, ngettext ((\"warning: partial read (%td byte); \"\n                                    \"suggest iflag=fullblock\"),\n                                   (\"warning: partial read (%td bytes); \"\n                                    \"suggest iflag=fullblock\"),\n                                   select_plural (prev)),\n                      prev);\n          warn_partial_read = false;\n        }\n    }\n\n  prev_nread = nread;\n  return nread;\n}\n\n/* Wrapper around iread function to accumulate full blocks.  */\nstatic ssize_t\niread_fullblock (int fd, char *buf, idx_t size)\n{\n  ssize_t nread = 0;\n\n  while (0 < size)\n    {\n      ssize_t ncurr = iread (fd, buf, size);\n      if (ncurr < 0)\n        return ncurr;\n      if (ncurr == 0)\n        break;\n      nread += ncurr;\n      buf   += ncurr;\n      size  -= ncurr;\n    }\n\n  return nread;\n}\n\n/* Write to FD the buffer BUF of size SIZE, processing any signals\n   that arrive.  Return the number of bytes written, setting errno if\n   this is less than SIZE.  Keep trying if there are partial\n   writes.  */\n\nstatic idx_t\niwrite (int fd, char const *buf, idx_t size)\n{\n  idx_t total_written = 0;\n\n  if ((output_flags & O_DIRECT) && size < output_blocksize)\n    {\n      int old_flags = fcntl (STDOUT_FILENO, F_GETFL);\n      if (fcntl (STDOUT_FILENO, F_SETFL, old_flags & ~O_DIRECT) != 0\n          && status_level != STATUS_NONE)\n        diagnose (errno, _(\"failed to turn off O_DIRECT: %s\"),\n                  quotef (output_file));\n\n      /* Since we have just turned off O_DIRECT for the final write,\n         we try to preserve some of its semantics.  */\n\n      /* Call invalidate_cache to setup the appropriate offsets\n         for subsequent calls.  */\n      o_nocache_eof = true;\n      invalidate_cache (STDOUT_FILENO, 0);\n\n      /* Attempt to ensure that that final block is committed\n         to stable storage as quickly as possible.  */\n      conversions_mask |= C_FSYNC;\n\n      /* After the subsequent fsync we'll call invalidate_cache\n         to attempt to clear all data from the page cache.  */\n    }\n\n  while (total_written < size)\n    {\n      ssize_t nwritten = 0;\n      process_signals ();\n\n      /* Perform a seek for a NUL block if sparse output is enabled.  */\n      final_op_was_seek = false;\n      if ((conversions_mask & C_SPARSE) && is_nul (buf, size))\n        {\n          if (lseek (fd, size, SEEK_CUR) < 0)\n            {\n              conversions_mask &= ~C_SPARSE;\n              /* Don't warn about the advisory sparse request.  */\n            }\n          else\n            {\n              final_op_was_seek = true;\n              nwritten = size;\n            }\n        }\n\n      if (!nwritten)\n        nwritten = write (fd, buf + total_written, size - total_written);\n\n      if (nwritten < 0)\n        {\n          if (errno != EINTR)\n            break;\n        }\n      else if (nwritten == 0)\n        {\n          /* Some buggy drivers return 0 when one tries to write beyond\n             a device's end.  (Example: Linux kernel 1.2.13 on /dev/fd0.)\n             Set errno to ENOSPC so they get a sensible diagnostic.  */\n          errno = ENOSPC;\n          break;\n        }\n      else\n        total_written += nwritten;\n    }\n\n  if (o_nocache && total_written)\n    invalidate_cache (fd, total_written);\n\n  return total_written;\n}\n\n/* Write, then empty, the output buffer 'obuf'. */\n\nstatic void\nwrite_output (void)\n{\n  idx_t nwritten = iwrite (STDOUT_FILENO, obuf, output_blocksize);\n  w_bytes += nwritten;\n  if (nwritten != output_blocksize)\n    {\n      diagnose (errno, _(\"writing to %s\"), quoteaf (output_file));\n      if (nwritten != 0)\n        w_partial++;\n      quit (EXIT_FAILURE);\n    }\n  else\n    w_full++;\n  oc = 0;\n}\n\n/* Restart on EINTR from fdatasync.  */\n\nstatic int\nifdatasync (int fd)\n{\n  int ret;\n\n  do\n    {\n      process_signals ();\n      ret = fdatasync (fd);\n    }\n  while (ret < 0 && errno == EINTR);\n\n  return ret;\n}\n\n/* Restart on EINTR from fd_reopen.  */\n\nstatic int\nifd_reopen (int desired_fd, char const *file, int flag, mode_t mode)\n{\n  int ret;\n\n  do\n    {\n      process_signals ();\n      ret = fd_reopen (desired_fd, file, flag, mode);\n    }\n  while (ret < 0 && errno == EINTR);\n\n  return ret;\n}\n\n/* Restart on EINTR from fstat.  */\n\nstatic int\nifstat (int fd, struct stat *st)\n{\n  int ret;\n\n  do\n    {\n      process_signals ();\n      ret = fstat (fd, st);\n    }\n  while (ret < 0 && errno == EINTR);\n\n  return ret;\n}\n\n/* Restart on EINTR from fsync.  */\n\nstatic int\nifsync (int fd)\n{\n  int ret;\n\n  do\n    {\n      process_signals ();\n      ret = fsync (fd);\n    }\n  while (ret < 0 && errno == EINTR);\n\n  return ret;\n}\n\n/* Restart on EINTR from ftruncate.  */\n\nstatic int\niftruncate (int fd, off_t length)\n{\n  int ret;\n\n  do\n    {\n      process_signals ();\n      ret = ftruncate (fd, length);\n    }\n  while (ret < 0 && errno == EINTR);\n\n  return ret;\n}\n\n/* Return true if STR is of the form \"PATTERN\" or \"PATTERNDELIM...\".  */\n\nATTRIBUTE_PURE\nstatic bool\noperand_matches (char const *str, char const *pattern, char delim)\n{\n  while (*pattern)\n    if (*str++ != *pattern++)\n      return false;\n  return !*str || *str == delim;\n}\n\n/* Interpret one \"conv=...\" or similar operand STR according to the\n   symbols in TABLE, returning the flags specified.  If the operand\n   cannot be parsed, use ERROR_MSGID to generate a diagnostic.  */\n\nstatic int\nparse_symbols (char const *str, struct symbol_value const *table,\n               bool exclusive, char const *error_msgid)\n{\n  int value = 0;\n\n  while (true)\n    {\n      char const *strcomma = strchr (str, ',');\n      struct symbol_value const *entry;\n\n      for (entry = table;\n           ! (operand_matches (str, entry->symbol, ',') && entry->value);\n           entry++)\n        {\n          if (! entry->symbol[0])\n            {\n              idx_t slen = strcomma ? strcomma - str : strlen (str);\n              diagnose (0, \"%s: %s\", _(error_msgid),\n                        quotearg_n_style_mem (0, locale_quoting_style,\n                                              str, slen));\n              usage (EXIT_FAILURE);\n            }\n        }\n\n      if (exclusive)\n        value = entry->value;\n      else\n        value |= entry->value;\n      if (!strcomma)\n        break;\n      str = strcomma + 1;\n    }\n\n  return value;\n}\n\n/* Return the value of STR, interpreted as a non-negative decimal integer,\n   optionally multiplied by various values.\n   Set *INVALID to an appropriate error value and return INTMAX_MAX if\n   it is an overflow, an indeterminate value if some other error occurred.  */\n\nstatic intmax_t\nparse_integer (char const *str, strtol_error *invalid)\n{\n  /* Call xstrtoumax, not xstrtoimax, since we don't want to\n     allow strings like \" -0\".  Initialize N to an indeterminate value;\n     calling code should not rely on this function returning 0\n     when *INVALID represents a non-overflow error.  */\n  int indeterminate = 0;\n  uintmax_t n = indeterminate;\n  char *suffix;\n  static char const suffixes[] = \"bcEGkKMPQRTwYZ0\";\n  strtol_error e = xstrtoumax (str, &suffix, 10, &n, suffixes);\n  intmax_t result;\n\n  if ((e & ~LONGINT_OVERFLOW) == LONGINT_INVALID_SUFFIX_CHAR\n      && *suffix == 'B' && str < suffix && suffix[-1] != 'B')\n    {\n      suffix++;\n      if (!*suffix)\n        e &= ~LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  if ((e & ~LONGINT_OVERFLOW) == LONGINT_INVALID_SUFFIX_CHAR\n      && *suffix == 'x')\n    {\n      strtol_error f = LONGINT_OK;\n      intmax_t o = parse_integer (suffix + 1, &f);\n      if ((f & ~LONGINT_OVERFLOW) != LONGINT_OK)\n        {\n          e = f;\n          result = indeterminate;\n        }\n      else if (ckd_mul (&result, n, o)\n               || (result != 0 && ((e | f) & LONGINT_OVERFLOW)))\n        {\n          e = LONGINT_OVERFLOW;\n          result = INTMAX_MAX;\n        }\n      else\n        {\n          if (result == 0 && STRPREFIX (str, \"0x\"))\n            diagnose (0, _(\"warning: %s is a zero multiplier; \"\n                           \"use %s if that is intended\"),\n                      quote_n (0, \"0x\"), quote_n (1, \"00x\"));\n          e = LONGINT_OK;\n        }\n    }\n  else if (n <= INTMAX_MAX)\n    result = n;\n  else\n    {\n      e = LONGINT_OVERFLOW;\n      result = INTMAX_MAX;\n    }\n\n  *invalid = e;\n  return result;\n}\n\n/* OPERAND is of the form \"X=...\".  Return true if X is NAME.  */\n\nATTRIBUTE_PURE\nstatic bool\noperand_is (char const *operand, char const *name)\n{\n  return operand_matches (operand, name, '=');\n}\n\nstatic void\nscanargs (int argc, char *const *argv)\n{\n  idx_t blocksize = 0;\n  intmax_t count = INTMAX_MAX;\n  intmax_t skip = 0;\n  intmax_t seek = 0;\n  bool count_B = false, skip_B = false, seek_B = false;\n\n  for (int i = optind; i < argc; i++)\n    {\n      char const *name = argv[i];\n      char const *val = strchr (name, '=');\n\n      if (val == nullptr)\n        {\n          diagnose (0, _(\"unrecognized operand %s\"), quoteaf (name));\n          usage (EXIT_FAILURE);\n        }\n      val++;\n\n      if (operand_is (name, \"if\"))\n        input_file = val;\n      else if (operand_is (name, \"of\"))\n        output_file = val;\n      else if (operand_is (name, \"conv\"))\n        conversions_mask |= parse_symbols (val, conversions, false,\n                                           N_(\"invalid conversion\"));\n      else if (operand_is (name, \"iflag\"))\n        input_flags |= parse_symbols (val, flags, false,\n                                      N_(\"invalid input flag\"));\n      else if (operand_is (name, \"oflag\"))\n        output_flags |= parse_symbols (val, flags, false,\n                                       N_(\"invalid output flag\"));\n      else if (operand_is (name, \"status\"))\n        status_level = parse_symbols (val, statuses, true,\n                                      N_(\"invalid status level\"));\n      else\n        {\n          strtol_error invalid = LONGINT_OK;\n          intmax_t n = parse_integer (val, &invalid);\n          bool has_B = !!strchr (val, 'B');\n          intmax_t n_min = 0;\n          intmax_t n_max = INTMAX_MAX;\n          idx_t *converted_idx = nullptr;\n\n          /* Maximum blocksize.  Keep it smaller than IDX_MAX, so that\n             it fits into blocksize vars even if 1 is added for conv=swab.\n             Do not exceed SSIZE_MAX, for the benefit of system calls\n             like \"read\".  And do not exceed OFF_T_MAX, for the\n             benefit of the large-offset seek code.  */\n          idx_t max_blocksize = MIN (IDX_MAX - 1, MIN (SSIZE_MAX, OFF_T_MAX));\n\n          if (operand_is (name, \"ibs\"))\n            {\n              n_min = 1;\n              n_max = max_blocksize;\n              converted_idx = &input_blocksize;\n            }\n          else if (operand_is (name, \"obs\"))\n            {\n              n_min = 1;\n              n_max = max_blocksize;\n              converted_idx = &output_blocksize;\n            }\n          else if (operand_is (name, \"bs\"))\n            {\n              n_min = 1;\n              n_max = max_blocksize;\n              converted_idx = &blocksize;\n            }\n          else if (operand_is (name, \"cbs\"))\n            {\n              n_min = 1;\n              n_max = MIN (SIZE_MAX, IDX_MAX);\n              converted_idx = &conversion_blocksize;\n            }\n          else if (operand_is (name, \"skip\") || operand_is (name, \"iseek\"))\n            {\n              skip = n;\n              skip_B = has_B;\n            }\n          else if (operand_is (name + (*name == 'o'), \"seek\"))\n            {\n              seek = n;\n              seek_B = has_B;\n            }\n          else if (operand_is (name, \"count\"))\n            {\n              count = n;\n              count_B = has_B;\n            }\n          else\n            {\n              diagnose (0, _(\"unrecognized operand %s\"), quoteaf (name));\n              usage (EXIT_FAILURE);\n            }\n\n          if (n < n_min)\n            invalid = LONGINT_INVALID;\n          else if (n_max < n)\n            invalid = LONGINT_OVERFLOW;\n\n          if (invalid != LONGINT_OK)\n            error (EXIT_FAILURE, invalid == LONGINT_OVERFLOW ? EOVERFLOW : 0,\n                   \"%s: %s\", _(\"invalid number\"), quoteaf (val));\n          else if (converted_idx)\n            *converted_idx = n;\n        }\n    }\n\n  if (blocksize)\n    input_blocksize = output_blocksize = blocksize;\n  else\n    {\n      /* POSIX says dd aggregates partial reads into\n         output_blocksize if bs= is not specified.  */\n      conversions_mask |= C_TWOBUFS;\n    }\n\n  if (input_blocksize == 0)\n    input_blocksize = DEFAULT_BLOCKSIZE;\n  if (output_blocksize == 0)\n    output_blocksize = DEFAULT_BLOCKSIZE;\n  if (conversion_blocksize == 0)\n    conversions_mask &= ~(C_BLOCK | C_UNBLOCK);\n\n  if (input_flags & (O_DSYNC | O_SYNC))\n    input_flags |= O_RSYNC;\n\n  if (output_flags & O_FULLBLOCK)\n    {\n      diagnose (0, \"%s: %s\", _(\"invalid output flag\"), quote (\"fullblock\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (skip_B)\n    input_flags |= O_SKIP_BYTES;\n  if (input_flags & O_SKIP_BYTES && skip != 0)\n    {\n      skip_records = skip / input_blocksize;\n      skip_bytes = skip % input_blocksize;\n    }\n  else if (skip != 0)\n    skip_records = skip;\n\n  if (count_B)\n    input_flags |= O_COUNT_BYTES;\n  if (input_flags & O_COUNT_BYTES && count != INTMAX_MAX)\n    {\n      max_records = count / input_blocksize;\n      max_bytes = count % input_blocksize;\n    }\n  else if (count != INTMAX_MAX)\n    max_records = count;\n\n  if (seek_B)\n    output_flags |= O_SEEK_BYTES;\n  if (output_flags & O_SEEK_BYTES && seek != 0)\n    {\n      seek_records = seek / output_blocksize;\n      seek_bytes = seek % output_blocksize;\n    }\n  else if (seek != 0)\n    seek_records = seek;\n\n  /* Warn about partial reads if bs=SIZE is given and iflag=fullblock\n     is not, and if counting or skipping bytes or using direct I/O.\n     This helps to avoid confusion with miscounts, and to avoid issues\n     with direct I/O on GNU/Linux.  */\n  warn_partial_read =\n    (! (conversions_mask & C_TWOBUFS) && ! (input_flags & O_FULLBLOCK)\n     && (skip_records\n         || (0 < max_records && max_records < INTMAX_MAX)\n         || (input_flags | output_flags) & O_DIRECT));\n\n  iread_fnc = ((input_flags & O_FULLBLOCK)\n               ? iread_fullblock\n               : iread);\n  input_flags &= ~O_FULLBLOCK;\n\n  if (multiple_bits_set (conversions_mask & (C_ASCII | C_EBCDIC | C_IBM)))\n    error (EXIT_FAILURE, 0, _(\"cannot combine any two of {ascii,ebcdic,ibm}\"));\n  if (multiple_bits_set (conversions_mask & (C_BLOCK | C_UNBLOCK)))\n    error (EXIT_FAILURE, 0, _(\"cannot combine block and unblock\"));\n  if (multiple_bits_set (conversions_mask & (C_LCASE | C_UCASE)))\n    error (EXIT_FAILURE, 0, _(\"cannot combine lcase and ucase\"));\n  if (multiple_bits_set (conversions_mask & (C_EXCL | C_NOCREAT)))\n    error (EXIT_FAILURE, 0, _(\"cannot combine excl and nocreat\"));\n  if (multiple_bits_set (input_flags & (O_DIRECT | O_NOCACHE))\n      || multiple_bits_set (output_flags & (O_DIRECT | O_NOCACHE)))\n    error (EXIT_FAILURE, 0, _(\"cannot combine direct and nocache\"));\n\n  if (input_flags & O_NOCACHE)\n    {\n      i_nocache = true;\n      i_nocache_eof = (max_records == 0 && max_bytes == 0);\n      input_flags &= ~O_NOCACHE;\n    }\n  if (output_flags & O_NOCACHE)\n    {\n      o_nocache = true;\n      o_nocache_eof = (max_records == 0 && max_bytes == 0);\n      output_flags &= ~O_NOCACHE;\n    }\n}\n\n/* Fix up translation table. */\n\nstatic void\napply_translations (void)\n{\n  int i;\n\n  if (conversions_mask & C_ASCII)\n    translate_charset (ebcdic_to_ascii);\n\n  if (conversions_mask & C_UCASE)\n    {\n      for (i = 0; i < 256; i++)\n        trans_table[i] = toupper (trans_table[i]);\n      translation_needed = true;\n    }\n  else if (conversions_mask & C_LCASE)\n    {\n      for (i = 0; i < 256; i++)\n        trans_table[i] = tolower (trans_table[i]);\n      translation_needed = true;\n    }\n\n  if (conversions_mask & C_EBCDIC)\n    {\n      translate_charset (ascii_to_ebcdic);\n      newline_character = ascii_to_ebcdic['\\n'];\n      space_character = ascii_to_ebcdic[' '];\n    }\n  else if (conversions_mask & C_IBM)\n    {\n      translate_charset (ascii_to_ibm);\n      newline_character = ascii_to_ibm['\\n'];\n      space_character = ascii_to_ibm[' '];\n    }\n}\n\n/* Apply the character-set translations specified by the user\n   to the NREAD bytes in BUF.  */\n\nstatic void\ntranslate_buffer (char *buf, idx_t nread)\n{\n  idx_t i;\n  char *cp;\n  for (i = nread, cp = buf; i; i--, cp++)\n    *cp = trans_table[to_uchar (*cp)];\n}\n\n/* Swap *NREAD bytes in BUF, which should have room for an extra byte\n   after the end because the swapping is not in-place.  If *SAVED_BYTE\n   is nonnegative, also swap that initial byte from the previous call.\n   Save the last byte into into *SAVED_BYTE if needed to make the\n   resulting *NREAD even, and set *SAVED_BYTE to -1 otherwise.\n   Return the buffer's adjusted start, either BUF or BUF + 1.  */\n\nstatic char *\nswab_buffer (char *buf, idx_t *nread, int *saved_byte)\n{\n  if (*nread == 0)\n    return buf;\n\n  /* Update *SAVED_BYTE, and set PREV_SAVED to its old value.  */\n  int prev_saved = *saved_byte;\n  if ((prev_saved < 0) == (*nread & 1))\n    {\n      unsigned char c = buf[--*nread];\n      *saved_byte = c;\n    }\n  else\n    *saved_byte = -1;\n\n  /* Do the byte-swapping by moving every other byte two\n     positions toward the end, working from the end of the buffer\n     toward the beginning.  This way we move only half the data.  */\n  for (idx_t i = *nread; 1 < i; i -= 2)\n    buf[i] = buf[i - 2];\n\n  if (prev_saved < 0)\n    return buf + 1;\n\n  buf[1] = prev_saved;\n  ++*nread;\n  return buf;\n}\n\n/* Add OFFSET to the input offset, setting the overflow flag if\n   necessary.  */\n\nstatic void\nadvance_input_offset (intmax_t offset)\n{\n  if (0 <= input_offset && ckd_add (&input_offset, input_offset, offset))\n    input_offset = -1;\n}\n\n/* Throw away RECORDS blocks of BLOCKSIZE bytes plus BYTES bytes on\n   file descriptor FDESC, which is open with read permission for FILE.\n   Store up to BLOCKSIZE bytes of the data at a time in IBUF or OBUF, if\n   necessary. RECORDS or BYTES must be nonzero. If FDESC is\n   STDIN_FILENO, advance the input offset. Return the number of\n   records remaining, i.e., that were not skipped because EOF was\n   reached.  If FDESC is STDOUT_FILENO, on return, BYTES is the\n   remaining bytes in addition to the remaining records.  */\n\nstatic intmax_t\nskip (int fdesc, char const *file, intmax_t records, idx_t blocksize,\n      idx_t *bytes)\n{\n  /* Try lseek and if an error indicates it was an inappropriate operation --\n     or if the file offset is not representable as an off_t --\n     fall back on using read.  */\n\n  errno = 0;\n  off_t offset;\n  if (! ckd_mul (&offset, records, blocksize)\n      && ! ckd_add (&offset, offset, *bytes)\n      && 0 <= lseek (fdesc, offset, SEEK_CUR))\n    {\n      if (fdesc == STDIN_FILENO)\n        {\n           struct stat st;\n           if (ifstat (STDIN_FILENO, &st) != 0)\n             error (EXIT_FAILURE, errno, _(\"cannot fstat %s\"), quoteaf (file));\n           if (usable_st_size (&st) && 0 <= input_offset\n               && st.st_size - input_offset < offset)\n             {\n               /* When skipping past EOF, return the number of _full_ blocks\n                * that are not skipped, and set offset to EOF, so the caller\n                * can determine the requested skip was not satisfied.  */\n               records = ( offset - st.st_size ) / blocksize;\n               offset = st.st_size - input_offset;\n             }\n           else\n             records = 0;\n           advance_input_offset (offset);\n        }\n      else\n        {\n          records = 0;\n          *bytes = 0;\n        }\n      return records;\n    }\n  else\n    {\n      int lseek_errno = errno;\n\n      /* The seek request may have failed above if it was too big\n         (> device size, > max file size, etc.)\n         Or it may not have been done at all (> OFF_T_MAX).\n         Therefore try to seek to the end of the file,\n         to avoid redundant reading.  */\n      if (lseek (fdesc, 0, SEEK_END) >= 0)\n        {\n          /* File is seekable, and we're at the end of it, and\n             size <= OFF_T_MAX. So there's no point using read to advance.  */\n\n          if (!lseek_errno)\n            {\n              /* The original seek was not attempted as offset > OFF_T_MAX.\n                 We should error for write as can't get to the desired\n                 location, even if OFF_T_MAX < max file size.\n                 For read we're not going to read any data anyway,\n                 so we should error for consistency.\n                 It would be nice to not error for /dev/{zero,null}\n                 for any offset, but that's not a significant issue.  */\n              lseek_errno = EOVERFLOW;\n            }\n\n          diagnose (lseek_errno,\n                    gettext (fdesc == STDIN_FILENO\n                             ? N_(\"%s: cannot skip\")\n                             : N_(\"%s: cannot seek\")),\n                    quotef (file));\n          /* If the file has a specific size and we've asked\n             to skip/seek beyond the max allowable, then quit.  */\n          quit (EXIT_FAILURE);\n        }\n      /* else file_size && offset > OFF_T_MAX or file ! seekable */\n\n      char *buf;\n      if (fdesc == STDIN_FILENO)\n        {\n          alloc_ibuf ();\n          buf = ibuf;\n        }\n      else\n        {\n          alloc_obuf ();\n          buf = obuf;\n        }\n\n      do\n        {\n          ssize_t nread = iread_fnc (fdesc, buf, records ? blocksize : *bytes);\n          if (nread < 0)\n            {\n              if (fdesc == STDIN_FILENO)\n                {\n                  diagnose (errno, _(\"error reading %s\"), quoteaf (file));\n                  if (conversions_mask & C_NOERROR)\n                    print_stats ();\n                }\n              else\n                diagnose (lseek_errno, _(\"%s: cannot seek\"), quotef (file));\n              quit (EXIT_FAILURE);\n            }\n          else if (nread == 0)\n            break;\n          else if (fdesc == STDIN_FILENO)\n            advance_input_offset (nread);\n\n          if (records != 0)\n            records--;\n          else\n            *bytes = 0;\n        }\n      while (records || *bytes);\n\n      return records;\n    }\n}\n\n/* Advance the input by NBYTES if possible, after a read error.\n   The input file offset may or may not have advanced after the failed\n   read; adjust it to point just after the bad record regardless.\n   Return true if successful, or if the input is already known to not\n   be seekable.  */\n\nstatic bool\nadvance_input_after_read_error (idx_t nbytes)\n{\n  if (! input_seekable)\n    {\n      if (input_seek_errno == ESPIPE)\n        return true;\n      errno = input_seek_errno;\n    }\n  else\n    {\n      off_t offset;\n      advance_input_offset (nbytes);\n      if (input_offset < 0)\n        {\n          diagnose (0, _(\"offset overflow while reading file %s\"),\n                    quoteaf (input_file));\n          return false;\n        }\n      offset = lseek (STDIN_FILENO, 0, SEEK_CUR);\n      if (0 <= offset)\n        {\n          off_t diff;\n          if (offset == input_offset)\n            return true;\n          diff = input_offset - offset;\n          if (! (0 <= diff && diff <= nbytes) && status_level != STATUS_NONE)\n            diagnose (0, _(\"warning: invalid file offset after failed read\"));\n          if (0 <= lseek (STDIN_FILENO, diff, SEEK_CUR))\n            return true;\n          if (errno == 0)\n            diagnose (0, _(\"cannot work around kernel bug after all\"));\n        }\n    }\n\n  diagnose (errno, _(\"%s: cannot seek\"), quotef (input_file));\n  return false;\n}\n\n/* Copy NREAD bytes of BUF, with no conversions.  */\n\nstatic void\ncopy_simple (char const *buf, idx_t nread)\n{\n  char const *start = buf;\t/* First uncopied char in BUF.  */\n\n  do\n    {\n      idx_t nfree = MIN (nread, output_blocksize - oc);\n\n      memcpy (obuf + oc, start, nfree);\n\n      nread -= nfree;\t\t/* Update the number of bytes left to copy. */\n      start += nfree;\n      oc += nfree;\n      if (oc >= output_blocksize)\n        write_output ();\n    }\n  while (nread != 0);\n}\n\n/* Copy NREAD bytes of BUF, doing conv=block\n   (pad newline-terminated records to 'conversion_blocksize',\n   replacing the newline with trailing spaces).  */\n\nstatic void\ncopy_with_block (char const *buf, idx_t nread)\n{\n  for (idx_t i = nread; i; i--, buf++)\n    {\n      if (*buf == newline_character)\n        {\n          if (col < conversion_blocksize)\n            {\n              idx_t j;\n              for (j = col; j < conversion_blocksize; j++)\n                output_char (space_character);\n            }\n          col = 0;\n        }\n      else\n        {\n          if (col == conversion_blocksize)\n            r_truncate++;\n          else if (col < conversion_blocksize)\n            output_char (*buf);\n          col++;\n        }\n    }\n}\n\n/* Copy NREAD bytes of BUF, doing conv=unblock\n   (replace trailing spaces in 'conversion_blocksize'-sized records\n   with a newline).  */\n\nstatic void\ncopy_with_unblock (char const *buf, idx_t nread)\n{\n  static idx_t pending_spaces = 0;\n\n  for (idx_t i = 0; i < nread; i++)\n    {\n      char c = buf[i];\n\n      if (col++ >= conversion_blocksize)\n        {\n          col = pending_spaces = 0; /* Wipe out any pending spaces.  */\n          i--;\t\t\t/* Push the char back; get it later. */\n          output_char (newline_character);\n        }\n      else if (c == space_character)\n        pending_spaces++;\n      else\n        {\n          /* 'c' is the character after a run of spaces that were not\n             at the end of the conversion buffer.  Output them.  */\n          while (pending_spaces)\n            {\n              output_char (space_character);\n              --pending_spaces;\n            }\n          output_char (c);\n        }\n    }\n}\n\n/* Set the file descriptor flags for FD that correspond to the nonzero bits\n   in ADD_FLAGS.  The file's name is NAME.  */\n\nstatic void\nset_fd_flags (int fd, int add_flags, char const *name)\n{\n  /* Ignore file creation flags that are no-ops on file descriptors.  */\n  add_flags &= ~ (O_NOCTTY | O_NOFOLLOW);\n\n  if (add_flags)\n    {\n      int old_flags = fcntl (fd, F_GETFL);\n      int new_flags = old_flags | add_flags;\n      bool ok = true;\n      if (old_flags < 0)\n        ok = false;\n      else if (old_flags != new_flags)\n        {\n          if (new_flags & (O_DIRECTORY | O_NOLINKS))\n            {\n              /* NEW_FLAGS contains at least one file creation flag that\n                 requires some checking of the open file descriptor.  */\n              struct stat st;\n              if (ifstat (fd, &st) != 0)\n                ok = false;\n              else if ((new_flags & O_DIRECTORY) && ! S_ISDIR (st.st_mode))\n                {\n                  errno = ENOTDIR;\n                  ok = false;\n                }\n              else if ((new_flags & O_NOLINKS) && 1 < st.st_nlink)\n                {\n                  errno = EMLINK;\n                  ok = false;\n                }\n              new_flags &= ~ (O_DIRECTORY | O_NOLINKS);\n            }\n\n          if (ok && old_flags != new_flags\n              && fcntl (fd, F_SETFL, new_flags) == -1)\n            ok = false;\n        }\n\n      if (!ok)\n        error (EXIT_FAILURE, errno, _(\"setting flags for %s\"), quoteaf (name));\n    }\n}\n\n/* The main loop.  */\n\nstatic int\ndd_copy (void)\n{\n  char *bufstart;\t\t/* Input buffer. */\n  ssize_t nread;\t\t/* Bytes read in the current block.  */\n\n  /* If nonzero, then the previously read block was partial and\n     PARTREAD was its size.  */\n  idx_t partread = 0;\n\n  int exit_status = EXIT_SUCCESS;\n  idx_t n_bytes_read;\n\n  if (skip_records != 0 || skip_bytes != 0)\n    {\n      intmax_t us_bytes;\n      bool us_bytes_overflow =\n        (ckd_mul (&us_bytes, skip_records, input_blocksize)\n         || ckd_add (&us_bytes, skip_bytes, us_bytes));\n      off_t input_offset0 = input_offset;\n      intmax_t us_blocks = skip (STDIN_FILENO, input_file,\n                                 skip_records, input_blocksize, &skip_bytes);\n\n      /* POSIX doesn't say what to do when dd detects it has been\n         asked to skip past EOF, so I assume it's non-fatal.\n         There are 3 reasons why there might be unskipped blocks/bytes:\n             1. file is too small\n             2. pipe has not enough data\n             3. partial reads  */\n      if ((us_blocks\n           || (0 <= input_offset\n               && (us_bytes_overflow\n                   || us_bytes != input_offset - input_offset0)))\n          && status_level != STATUS_NONE)\n        {\n          diagnose (0, _(\"%s: cannot skip to specified offset\"),\n                    quotef (input_file));\n        }\n    }\n\n  if (seek_records != 0 || seek_bytes != 0)\n    {\n      idx_t bytes = seek_bytes;\n      intmax_t write_records = skip (STDOUT_FILENO, output_file,\n                                      seek_records, output_blocksize, &bytes);\n\n      if (write_records != 0 || bytes != 0)\n        {\n          memset (obuf, 0, write_records ? output_blocksize : bytes);\n\n          do\n            {\n              idx_t size = write_records ? output_blocksize : bytes;\n              if (iwrite (STDOUT_FILENO, obuf, size) != size)\n                {\n                  diagnose (errno, _(\"writing to %s\"), quoteaf (output_file));\n                  quit (EXIT_FAILURE);\n                }\n\n              if (write_records != 0)\n                write_records--;\n              else\n                bytes = 0;\n            }\n          while (write_records || bytes);\n        }\n    }\n\n  if (max_records == 0 && max_bytes == 0)\n    return exit_status;\n\n  alloc_ibuf ();\n  alloc_obuf ();\n  int saved_byte = -1;\n\n  while (true)\n    {\n      if (status_level == STATUS_PROGRESS)\n        {\n          xtime_t progress_time = gethrxtime ();\n          if (next_time <= progress_time)\n            {\n              print_xfer_stats (progress_time);\n              next_time += XTIME_PRECISION;\n            }\n        }\n\n      if (r_partial + r_full >= max_records + !!max_bytes)\n        break;\n\n      /* Zero the buffer before reading, so that if we get a read error,\n         whatever data we are able to read is followed by zeros.\n         This minimizes data loss. */\n      if ((conversions_mask & C_SYNC) && (conversions_mask & C_NOERROR))\n        memset (ibuf,\n                (conversions_mask & (C_BLOCK | C_UNBLOCK)) ? ' ' : '\\0',\n                input_blocksize);\n\n      if (r_partial + r_full >= max_records)\n        nread = iread_fnc (STDIN_FILENO, ibuf, max_bytes);\n      else\n        nread = iread_fnc (STDIN_FILENO, ibuf, input_blocksize);\n\n      if (nread > 0)\n        {\n          advance_input_offset (nread);\n          if (i_nocache)\n            invalidate_cache (STDIN_FILENO, nread);\n        }\n      else if (nread == 0)\n        {\n          i_nocache_eof |= i_nocache;\n          o_nocache_eof |= o_nocache && ! (conversions_mask & C_NOTRUNC);\n          break;\t\t\t/* EOF.  */\n        }\n      else\n        {\n          if (!(conversions_mask & C_NOERROR) || status_level != STATUS_NONE)\n            diagnose (errno, _(\"error reading %s\"), quoteaf (input_file));\n\n          if (conversions_mask & C_NOERROR)\n            {\n              print_stats ();\n              idx_t bad_portion = input_blocksize - partread;\n\n              /* We already know this data is not cached,\n                 but call this so that correct offsets are maintained.  */\n              invalidate_cache (STDIN_FILENO, bad_portion);\n\n              /* Seek past the bad block if possible. */\n              if (!advance_input_after_read_error (bad_portion))\n                {\n                  exit_status = EXIT_FAILURE;\n\n                  /* Suppress duplicate diagnostics.  */\n                  input_seekable = false;\n                  input_seek_errno = ESPIPE;\n                }\n              if ((conversions_mask & C_SYNC) && !partread)\n                /* Replace the missing input with null bytes and\n                   proceed normally.  */\n                nread = 0;\n              else\n                continue;\n            }\n          else\n            {\n              /* Write any partial block. */\n              exit_status = EXIT_FAILURE;\n              break;\n            }\n        }\n\n      n_bytes_read = nread;\n\n      if (n_bytes_read < input_blocksize)\n        {\n          r_partial++;\n          partread = n_bytes_read;\n          if (conversions_mask & C_SYNC)\n            {\n              if (!(conversions_mask & C_NOERROR))\n                /* If C_NOERROR, we zeroed the block before reading. */\n                memset (ibuf + n_bytes_read,\n                        (conversions_mask & (C_BLOCK | C_UNBLOCK)) ? ' ' : '\\0',\n                        input_blocksize - n_bytes_read);\n              n_bytes_read = input_blocksize;\n            }\n        }\n      else\n        {\n          r_full++;\n          partread = 0;\n        }\n\n      if (ibuf == obuf)\t\t/* If not C_TWOBUFS. */\n        {\n          idx_t nwritten = iwrite (STDOUT_FILENO, obuf, n_bytes_read);\n          w_bytes += nwritten;\n          if (nwritten != n_bytes_read)\n            {\n              diagnose (errno, _(\"error writing %s\"), quoteaf (output_file));\n              return EXIT_FAILURE;\n            }\n          else if (n_bytes_read == input_blocksize)\n            w_full++;\n          else\n            w_partial++;\n          continue;\n        }\n\n      /* Do any translations on the whole buffer at once.  */\n\n      if (translation_needed)\n        translate_buffer (ibuf, n_bytes_read);\n\n      if (conversions_mask & C_SWAB)\n        bufstart = swab_buffer (ibuf, &n_bytes_read, &saved_byte);\n      else\n        bufstart = ibuf;\n\n      if (conversions_mask & C_BLOCK)\n        copy_with_block (bufstart, n_bytes_read);\n      else if (conversions_mask & C_UNBLOCK)\n        copy_with_unblock (bufstart, n_bytes_read);\n      else\n        copy_simple (bufstart, n_bytes_read);\n    }\n\n  /* If we have a char left as a result of conv=swab, output it.  */\n  if (0 <= saved_byte)\n    {\n      char saved_char = saved_byte;\n      if (conversions_mask & C_BLOCK)\n        copy_with_block (&saved_char, 1);\n      else if (conversions_mask & C_UNBLOCK)\n        copy_with_unblock (&saved_char, 1);\n      else\n        output_char (saved_char);\n    }\n\n  if ((conversions_mask & C_BLOCK) && col > 0)\n    {\n      /* If the final input line didn't end with a '\\n', pad\n         the output block to 'conversion_blocksize' chars.  */\n      for (idx_t i = col; i < conversion_blocksize; i++)\n        output_char (space_character);\n    }\n\n  if (col && (conversions_mask & C_UNBLOCK))\n    {\n      /* If there was any output, add a final '\\n'.  */\n      output_char (newline_character);\n    }\n\n  /* Write out the last block. */\n  if (oc != 0)\n    {\n      idx_t nwritten = iwrite (STDOUT_FILENO, obuf, oc);\n      w_bytes += nwritten;\n      if (nwritten != 0)\n        w_partial++;\n      if (nwritten != oc)\n        {\n          diagnose (errno, _(\"error writing %s\"), quoteaf (output_file));\n          return EXIT_FAILURE;\n        }\n    }\n\n  /* If the last write was converted to a seek, then for a regular file\n     or shared memory object, ftruncate to extend the size.  */\n  if (final_op_was_seek)\n    {\n      struct stat stdout_stat;\n      if (ifstat (STDOUT_FILENO, &stdout_stat) != 0)\n        {\n          diagnose (errno, _(\"cannot fstat %s\"), quoteaf (output_file));\n          return EXIT_FAILURE;\n        }\n      if (S_ISREG (stdout_stat.st_mode) || S_TYPEISSHM (&stdout_stat))\n        {\n          off_t output_offset = lseek (STDOUT_FILENO, 0, SEEK_CUR);\n          if (0 <= output_offset && stdout_stat.st_size < output_offset)\n            {\n              if (iftruncate (STDOUT_FILENO, output_offset) != 0)\n                {\n                  diagnose (errno, _(\"failed to truncate to %\" PRIdMAX \" bytes\"\n                                     \" in output file %s\"),\n                            (intmax_t) output_offset, quoteaf (output_file));\n                  return EXIT_FAILURE;\n                }\n            }\n        }\n    }\n\n  /* fdatasync/fsync can take a long time, so issue a final progress\n     indication now if progress has been made since the previous indication.  */\n  if (conversions_mask & (C_FDATASYNC | C_FSYNC)\n      && status_level == STATUS_PROGRESS\n      && 0 <= reported_w_bytes && reported_w_bytes < w_bytes)\n    print_xfer_stats (0);\n\n  return exit_status;\n}\n\n/* Synchronize output according to conversions_mask.\n   Do this even if w_bytes is zero, as fsync and fdatasync\n   flush out write requests from other processes too.\n   Clear bits in conversions_mask so that synchronization is done only once.\n   Return zero if successful, an exit status otherwise.  */\n\nstatic int\nsynchronize_output (void)\n{\n  int exit_status = 0;\n  int mask = conversions_mask;\n  conversions_mask &= ~ (C_FDATASYNC | C_FSYNC);\n\n  if ((mask & C_FDATASYNC) && ifdatasync (STDOUT_FILENO) != 0)\n    {\n      if (errno != ENOSYS && errno != EINVAL)\n        {\n          diagnose (errno, _(\"fdatasync failed for %s\"), quoteaf (output_file));\n          exit_status = EXIT_FAILURE;\n        }\n      mask |= C_FSYNC;\n    }\n\n  if ((mask & C_FSYNC) && ifsync (STDOUT_FILENO) != 0)\n    {\n      diagnose (errno, _(\"fsync failed for %s\"), quoteaf (output_file));\n      return EXIT_FAILURE;\n    }\n\n  return exit_status;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int i;\n  int exit_status;\n  off_t offset;\n\n  install_signal_handlers ();\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* Arrange to close stdout if parse_long_options exits.  */\n  atexit (maybe_close_stdout);\n\n  page_size = getpagesize ();\n\n  parse_gnu_standard_options_only (argc, argv, PROGRAM_NAME, PACKAGE, Version,\n                                   true, usage, AUTHORS,\n                                   (char const *) nullptr);\n  close_stdout_required = false;\n\n  /* Initialize translation table to identity translation. */\n  for (i = 0; i < 256; i++)\n    trans_table[i] = i;\n\n  /* Decode arguments. */\n  scanargs (argc, argv);\n\n  apply_translations ();\n\n  if (input_file == nullptr)\n    {\n      input_file = _(\"standard input\");\n      set_fd_flags (STDIN_FILENO, input_flags, input_file);\n    }\n  else\n    {\n      if (ifd_reopen (STDIN_FILENO, input_file, O_RDONLY | input_flags, 0) < 0)\n        error (EXIT_FAILURE, errno, _(\"failed to open %s\"),\n               quoteaf (input_file));\n    }\n\n  offset = lseek (STDIN_FILENO, 0, SEEK_CUR);\n  input_seekable = (0 <= offset);\n  input_offset = MAX (0, offset);\n  input_seek_errno = errno;\n\n  if (output_file == nullptr)\n    {\n      output_file = _(\"standard output\");\n      set_fd_flags (STDOUT_FILENO, output_flags, output_file);\n    }\n  else\n    {\n      mode_t perms = MODE_RW_UGO;\n      int opts\n        = (output_flags\n           | (conversions_mask & C_NOCREAT ? 0 : O_CREAT)\n           | (conversions_mask & C_EXCL ? O_EXCL : 0)\n           | (seek_records || (conversions_mask & C_NOTRUNC) ? 0 : O_TRUNC));\n\n      off_t size;\n      if ((ckd_mul (&size, seek_records, output_blocksize)\n           || ckd_add (&size, seek_bytes, size))\n          && !(conversions_mask & C_NOTRUNC))\n        error (EXIT_FAILURE, 0,\n               _(\"offset too large: \"\n                 \"cannot truncate to a length of seek=%\"PRIdMAX\"\"\n                 \" (%td-byte) blocks\"),\n               seek_records, output_blocksize);\n\n      /* Open the output file with *read* access only if we might\n         need to read to satisfy a 'seek=' request.  If we can't read\n         the file, go ahead with write-only access; it might work.  */\n      if ((! seek_records\n           || ifd_reopen (STDOUT_FILENO, output_file, O_RDWR | opts, perms) < 0)\n          && (ifd_reopen (STDOUT_FILENO, output_file, O_WRONLY | opts, perms)\n              < 0))\n        error (EXIT_FAILURE, errno, _(\"failed to open %s\"),\n               quoteaf (output_file));\n\n      if (seek_records != 0 && !(conversions_mask & C_NOTRUNC))\n        {\n          if (iftruncate (STDOUT_FILENO, size) != 0)\n            {\n              /* Complain only when ftruncate fails on a regular file, a\n                 directory, or a shared memory object, as POSIX 1003.1-2004\n                 specifies ftruncate's behavior only for these file types.\n                 For example, do not complain when Linux kernel 2.4 ftruncate\n                 fails on /dev/fd0.  */\n              int ftruncate_errno = errno;\n              struct stat stdout_stat;\n              if (ifstat (STDOUT_FILENO, &stdout_stat) != 0)\n                {\n                  diagnose (errno, _(\"cannot fstat %s\"), quoteaf (output_file));\n                  exit_status = EXIT_FAILURE;\n                }\n              else if (S_ISREG (stdout_stat.st_mode)\n                       || S_ISDIR (stdout_stat.st_mode)\n                       || S_TYPEISSHM (&stdout_stat))\n                {\n                  intmax_t isize = size;\n                  diagnose (ftruncate_errno,\n                            _(\"failed to truncate to %\"PRIdMAX\" bytes\"\n                              \" in output file %s\"),\n                            isize, quoteaf (output_file));\n                  exit_status = EXIT_FAILURE;\n                }\n            }\n        }\n    }\n\n  start_time = gethrxtime ();\n  next_time = start_time + XTIME_PRECISION;\n\n  exit_status = dd_copy ();\n\n  int sync_status = synchronize_output ();\n  if (sync_status)\n    exit_status = sync_status;\n\n  if (max_records == 0 && max_bytes == 0)\n    {\n      /* Special case to invalidate cache to end of file.  */\n      if (i_nocache && !invalidate_cache (STDIN_FILENO, 0))\n        {\n          diagnose (errno, _(\"failed to discard cache for: %s\"),\n                    quotef (input_file));\n          exit_status = EXIT_FAILURE;\n        }\n      if (o_nocache && !invalidate_cache (STDOUT_FILENO, 0))\n        {\n          diagnose (errno, _(\"failed to discard cache for: %s\"),\n                    quotef (output_file));\n          exit_status = EXIT_FAILURE;\n        }\n    }\n  else\n    {\n       \n      if (i_nocache || i_nocache_eof)\n        invalidate_cache (STDIN_FILENO, 0);\n      if (o_nocache || o_nocache_eof)\n        invalidate_cache (STDOUT_FILENO, 0);\n    }\n\n  finish_up ();\n  main_exit (exit_status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}