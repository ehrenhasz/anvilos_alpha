{
  "module_name": "mkfifo.c",
  "hash_id": "c74680388840997cdbf15e7d13f1c8b5d43eef906c5490108880f35b06370dc1",
  "original_prompt": "Ingested from coreutils-9.4/src/mkfifo.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <selinux/label.h>\n\n#include \"system.h\"\n#include \"modechange.h\"\n#include \"quote.h\"\n#include \"selinux.h\"\n#include \"smack.h\"\n\n \n#define PROGRAM_NAME \"mkfifo\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic struct option const longopts[] =\n{\n  {GETOPT_SELINUX_CONTEXT_OPTION_DECL},\n  {\"mode\", required_argument, nullptr, 'm'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... NAME...\\n\"), program_name);\n      fputs (_(\"\\\nCreate named pipes (FIFOs) with the given NAMEs.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -Z                   set the SELinux security context to default type\\n\\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n\\\n                         or SMACK security context to CTX\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  mode_t newmode;\n  char const *specified_mode = nullptr;\n  int exit_status = EXIT_SUCCESS;\n  int optc;\n  char const *scontext = nullptr;\n  struct selabel_handle *set_security_context = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"m:Z\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'm':\n          specified_mode = optarg;\n          break;\n        case 'Z':\n          if (is_smack_enabled ())\n            {\n              /* We don't yet support -Z to restore context with SMACK.  */\n              scontext = optarg;\n            }\n          else if (is_selinux_enabled () > 0)\n            {\n              if (optarg)\n                scontext = optarg;\n              else\n                {\n                  set_security_context = selabel_open (SELABEL_CTX_FILE,\n                                                       nullptr, 0);\n                  if (! set_security_context)\n                    error (0, errno, _(\"warning: ignoring --context\"));\n                }\n            }\n          else if (optarg)\n            {\n              error (0, 0,\n                     _(\"warning: ignoring --context; \"\n                       \"it requires an SELinux/SMACK-enabled kernel\"));\n            }\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (optind == argc)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (scontext)\n    {\n      int ret = 0;\n      if (is_smack_enabled ())\n        ret = smack_set_label_for_self (scontext);\n      else\n        ret = setfscreatecon (scontext);\n\n      if (ret < 0)\n        error (EXIT_FAILURE, errno,\n               _(\"failed to set default file creation context to %s\"),\n               quote (scontext));\n    }\n\n  newmode = MODE_RW_UGO;\n  if (specified_mode)\n    {\n      mode_t umask_value;\n      struct mode_change *change = mode_compile (specified_mode);\n      if (!change)\n        error (EXIT_FAILURE, 0, _(\"invalid mode\"));\n      umask_value = umask (0);\n      umask (umask_value);\n      newmode = mode_adjust (newmode, false, umask_value, change, nullptr);\n      free (change);\n      if (newmode & ~S_IRWXUGO)\n        error (EXIT_FAILURE, 0,\n               _(\"mode must specify only file permission bits\"));\n    }\n\n  for (; optind < argc; ++optind)\n    {\n      if (set_security_context)\n        defaultcon (set_security_context, argv[optind], S_IFIFO);\n      if (mkfifo (argv[optind], newmode) != 0)\n        {\n          error (0, errno, _(\"cannot create fifo %s\"), quoteaf (argv[optind]));\n          exit_status = EXIT_FAILURE;\n        }\n      else if (specified_mode && lchmod (argv[optind], newmode) != 0)\n        {\n          error (0, errno, _(\"cannot set permissions of %s\"),\n                 quoteaf (argv[optind]));\n          exit_status = EXIT_FAILURE;\n        }\n    }\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}