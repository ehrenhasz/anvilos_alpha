{
  "module_name": "ln.c",
  "hash_id": "5a69cf99038362c3dac5f48b419fe26189bee19388d7c27d8d7709945b769cf6",
  "original_prompt": "Ingested from coreutils-9.4/src/ln.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n\n#include \"system.h\"\n#include \"backupfile.h\"\n#include \"fcntl-safer.h\"\n#include \"filenamecat.h\"\n#include \"file-set.h\"\n#include \"force-link.h\"\n#include \"hash.h\"\n#include \"hash-triple.h\"\n#include \"priv-set.h\"\n#include \"relpath.h\"\n#include \"same.h\"\n#include \"unlinkdir.h\"\n#include \"yesno.h\"\n#include \"canonicalize.h\"\n\n \n#define PROGRAM_NAME \"ln\"\n\n#define AUTHORS \\\n  proper_name (\"Mike Parker\"), \\\n  proper_name (\"David MacKenzie\")\n\n \nstatic enum backup_type backup_type;\n\n \nstatic bool symbolic_link;\n\n \nstatic bool relative;\n\n \nstatic bool logical = !!LINK_FOLLOWS_SYMLINKS;\n\n \nstatic bool interactive;\n\n \nstatic bool remove_existing_files;\n\n \nstatic bool verbose;\n\n \nstatic bool hard_dir_link;\n\n \nstatic bool beware_hard_dir_link;\n\n \nstatic bool dereference_dest_dir_symlinks = true;\n\n \nstatic Hash_table *dest_set;\n\n \nenum { DEST_INFO_INITIAL_CAPACITY = 61 };\n\nstatic struct option const long_options[] =\n{\n  {\"backup\", optional_argument, nullptr, 'b'},\n  {\"directory\", no_argument, nullptr, 'F'},\n  {\"no-dereference\", no_argument, nullptr, 'n'},\n  {\"no-target-directory\", no_argument, nullptr, 'T'},\n  {\"force\", no_argument, nullptr, 'f'},\n  {\"interactive\", no_argument, nullptr, 'i'},\n  {\"suffix\", required_argument, nullptr, 'S'},\n  {\"target-directory\", required_argument, nullptr, 't'},\n  {\"logical\", no_argument, nullptr, 'L'},\n  {\"physical\", no_argument, nullptr, 'P'},\n  {\"relative\", no_argument, nullptr, 'r'},\n  {\"symbolic\", no_argument, nullptr, 's'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nstatic int\nerrnoize (int status)\n{\n  return status < 0 ? errno : 0;\n}\n\n \n\nstatic char *\nconvert_abs_rel (char const *from, char const *target)\n{\n   \n  char *targetdir = dir_name (target);\n\n  char *realdest = canonicalize_filename_mode (targetdir, CAN_MISSING);\n  char *realfrom = canonicalize_filename_mode (from, CAN_MISSING);\n\n  char *relative_from = nullptr;\n  if (realdest && realfrom)\n    {\n       \n      relative_from = xmalloc (PATH_MAX);\n\n      if (!relpath (realfrom, realdest, relative_from, PATH_MAX))\n        {\n          free (relative_from);\n          relative_from = nullptr;\n        }\n    }\n\n  free (targetdir);\n  free (realdest);\n  free (realfrom);\n\n  return relative_from ? relative_from : xstrdup (from);\n}\n\n \n\nstatic int\natomic_link (char const *source, int destdir_fd, char const *dest_base)\n{\n  return (symbolic_link\n          ? (relative ? -1\n             : errnoize (symlinkat (source, destdir_fd, dest_base)))\n          : beware_hard_dir_link ? -1\n          : errnoize (linkat (AT_FDCWD, source, destdir_fd, dest_base,\n                              logical ? AT_SYMLINK_FOLLOW : 0)));\n}\n\n \n\nstatic bool\ndo_link (char const *source, int destdir_fd, char const *dest_base,\n         char const *dest, int link_errno)\n{\n  struct stat source_stats;\n  int source_status = 1;\n  char *backup_base = nullptr;\n  char *rel_source = nullptr;\n  int nofollow_flag = logical ? 0 : AT_SYMLINK_NOFOLLOW;\n  if (link_errno < 0)\n    link_errno = atomic_link (source, destdir_fd, dest_base);\n\n   \n  if ((link_errno || dest_set) && !symbolic_link)\n    {\n      source_status = fstatat (AT_FDCWD, source, &source_stats, nofollow_flag);\n      if (source_status != 0)\n        {\n          error (0, errno, _(\"failed to access %s\"), quoteaf (source));\n          return false;\n        }\n    }\n\n  if (link_errno)\n    {\n      if (!symbolic_link && !hard_dir_link && S_ISDIR (source_stats.st_mode))\n        {\n          error (0, 0, _(\"%s: hard link not allowed for directory\"),\n                 quotef (source));\n          return false;\n        }\n\n      if (relative)\n        source = rel_source = convert_abs_rel (source, dest);\n\n      bool force = (remove_existing_files || interactive\n                    || backup_type != no_backups);\n      if (force)\n        {\n          struct stat dest_stats;\n          if (fstatat (destdir_fd, dest_base, &dest_stats, AT_SYMLINK_NOFOLLOW)\n              != 0)\n            {\n              if (errno != ENOENT)\n                {\n                  error (0, errno, _(\"failed to access %s\"), quoteaf (dest));\n                  goto fail;\n                }\n              force = false;\n            }\n          else if (S_ISDIR (dest_stats.st_mode))\n            {\n              error (0, 0, _(\"%s: cannot overwrite directory\"), quotef (dest));\n              goto fail;\n            }\n          else if (seen_file (dest_set, dest, &dest_stats))\n            {\n               \n              error (0, 0,\n                     _(\"will not overwrite just-created %s with %s\"),\n                     quoteaf_n (0, dest), quoteaf_n (1, source));\n              goto fail;\n            }\n          else\n            {\n               \n              if (backup_type != no_backups\n                  ? !symbolic_link\n                  : remove_existing_files)\n                {\n                   \n                  if (source_status != 0)\n                    source_status = stat (source, &source_stats);\n                  if (source_status == 0\n                      && SAME_INODE (source_stats, dest_stats)\n                      && (source_stats.st_nlink == 1\n                          || same_nameat (AT_FDCWD, source,\n                                          destdir_fd, dest_base)))\n                    {\n                      error (0, 0, _(\"%s and %s are the same file\"),\n                             quoteaf_n (0, source), quoteaf_n (1, dest));\n                      goto fail;\n                    }\n                }\n\n              if (link_errno < 0 || link_errno == EEXIST)\n                {\n                  if (interactive)\n                    {\n                      fprintf (stderr, _(\"%s: replace %s? \"),\n                               program_name, quoteaf (dest));\n                      if (!yesno ())\n                        {\n                          free (rel_source);\n                          return false;\n                        }\n                    }\n\n                  if (backup_type != no_backups)\n                    {\n                      backup_base = find_backup_file_name (destdir_fd,\n                                                           dest_base,\n                                                           backup_type);\n                      if (renameat (destdir_fd, dest_base,\n                                    destdir_fd, backup_base)\n                          != 0)\n                        {\n                          int rename_errno = errno;\n                          free (backup_base);\n                          backup_base = nullptr;\n                          if (rename_errno != ENOENT)\n                            {\n                              error (0, rename_errno, _(\"cannot backup %s\"),\n                                     quoteaf (dest));\n                              goto fail;\n                            }\n                          force = false;\n                        }\n                    }\n                }\n            }\n        }\n\n       \n      link_errno\n        = (symbolic_link\n           ? force_symlinkat (source, destdir_fd, dest_base,\n                              force, link_errno)\n           : force_linkat (AT_FDCWD, source, destdir_fd, dest_base,\n                           logical ? AT_SYMLINK_FOLLOW : 0,\n                           force, link_errno));\n       \n    }\n\n  if (link_errno <= 0)\n    {\n       \n      if (! symbolic_link)\n        record_file (dest_set, dest, &source_stats);\n\n      if (verbose)\n        {\n          char const *quoted_backup = \"\";\n          char const *backup_sep = \"\";\n          if (backup_base)\n            {\n              char *backup = backup_base;\n              void *alloc = nullptr;\n              ptrdiff_t destdirlen = dest_base - dest;\n              if (0 < destdirlen)\n                {\n                  alloc = xmalloc (destdirlen + strlen (backup_base) + 1);\n                  backup = memcpy (alloc, dest, destdirlen);\n                  strcpy (backup + destdirlen, backup_base);\n                }\n              quoted_backup = quoteaf_n (2, backup);\n              backup_sep = \" ~ \";\n              free (alloc);\n            }\n          printf (\"%s%s%s %c> %s\\n\", quoted_backup, backup_sep,\n                  quoteaf_n (0, dest), symbolic_link ? '-' : '=',\n                  quoteaf_n (1, source));\n        }\n    }\n  else\n    {\n      error (0, link_errno,\n             (symbolic_link\n              ? (link_errno != ENAMETOOLONG && *source\n                 ? _(\"failed to create symbolic link %s\")\n                 : _(\"failed to create symbolic link %s -> %s\"))\n              : (link_errno == EMLINK\n                 ? _(\"failed to create hard link to %.0s%s\")\n                 : (link_errno == EDQUOT || link_errno == EEXIST\n                    || link_errno == ENOSPC || link_errno == EROFS)\n                 ? _(\"failed to create hard link %s\")\n                 : _(\"failed to create hard link %s => %s\"))),\n             quoteaf_n (0, dest), quoteaf_n (1, source));\n\n      if (backup_base)\n        {\n          if (renameat (destdir_fd, backup_base, destdir_fd, dest_base) != 0)\n            error (0, errno, _(\"cannot un-backup %s\"), quoteaf (dest));\n        }\n    }\n\n  free (backup_base);\n  free (rel_source);\n  return link_errno <= 0;\n\nfail:\n  free (rel_source);\n  return false;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [-T] TARGET LINK_NAME\\n\\\n  or:  %s [OPTION]... TARGET\\n\\\n  or:  %s [OPTION]... TARGET... DIRECTORY\\n\\\n  or:  %s [OPTION]... -t DIRECTORY TARGET...\\n\\\n\"),\n              program_name, program_name, program_name, program_name);\n      fputs (_(\"\\\nIn the 1st form, create a link to TARGET with the name LINK_NAME.\\n\\\nIn the 2nd form, create a link to TARGET in the current directory.\\n\\\nIn the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\\n\\\nCreate hard links by default, symbolic links with --symbolic.\\n\\\nBy default, each destination (name of new link) should not already exist.\\n\\\nWhen creating hard links, each TARGET must exist.  Symbolic links\\n\\\ncan hold arbitrary text; if later resolved, a relative link is\\n\\\ninterpreted in relation to its parent directory.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n      --backup[=CONTROL]      make a backup of each existing destination file\\n\\\n  -b                          like --backup but does not accept an argument\\n\\\n  -d, -F, --directory         allow the superuser to attempt to hard link\\n\\\n                                directories (note: will probably fail due to\\n\\\n                                system restrictions, even for the superuser)\\n\\\n  -f, --force                 remove existing destination files\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -i, --interactive           prompt whether to remove destinations\\n\\\n  -L, --logical               dereference TARGETs that are symbolic links\\n\\\n  -n, --no-dereference        treat LINK_NAME as a normal file if\\n\\\n                                it is a symbolic link to a directory\\n\\\n  -P, --physical              make hard links directly to symbolic links\\n\\\n  -r, --relative              with -s, create links relative to link location\\n\\\n  -s, --symbolic              make symbolic links instead of hard links\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -S, --suffix=SUFFIX         override the usual backup suffix\\n\\\n  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to create\\n\\\n                                the links\\n\\\n  -T, --no-target-directory   treat LINK_NAME as a normal file always\\n\\\n  -v, --verbose               print name of each linked file\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_backup_suffix_note ();\n      printf (_(\"\\\n\\n\\\nUsing -s ignores -L and -P.  Otherwise, the last option specified controls\\n\\\nbehavior when a TARGET is a symbolic link, defaulting to %s.\\n\\\n\"), LINK_FOLLOWS_SYMLINKS ? \"-L\" : \"-P\");\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n  bool ok;\n  bool make_backups = false;\n  char const *backup_suffix = nullptr;\n  char *version_control_string = nullptr;\n  char const *target_directory = nullptr;\n  int destdir_fd;\n  bool no_target_directory = false;\n  int n_files;\n  char **file;\n  int link_errno = -1;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdin);\n\n  symbolic_link = remove_existing_files = interactive = verbose\n    = hard_dir_link = false;\n\n  while ((c = getopt_long (argc, argv, \"bdfinrst:vFLPS:T\",\n                           long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'b':\n          make_backups = true;\n          if (optarg)\n            version_control_string = optarg;\n          break;\n        case 'd':\n        case 'F':\n          hard_dir_link = true;\n          break;\n        case 'f':\n          remove_existing_files = true;\n          interactive = false;\n          break;\n        case 'i':\n          remove_existing_files = false;\n          interactive = true;\n          break;\n        case 'L':\n          logical = true;\n          break;\n        case 'n':\n          dereference_dest_dir_symlinks = false;\n          break;\n        case 'P':\n          logical = false;\n          break;\n        case 'r':\n          relative = true;\n          break;\n        case 's':\n          symbolic_link = true;\n          break;\n        case 't':\n          if (target_directory)\n            error (EXIT_FAILURE, 0, _(\"multiple target directories specified\"));\n          else\n            {\n              struct stat st;\n              if (stat (optarg, &st) != 0)\n                error (EXIT_FAILURE, errno, _(\"failed to access %s\"),\n                       quoteaf (optarg));\n              if (! S_ISDIR (st.st_mode))\n                error (EXIT_FAILURE, 0, _(\"target %s is not a directory\"),\n                       quoteaf (optarg));\n            }\n          target_directory = optarg;\n          break;\n        case 'T':\n          no_target_directory = true;\n          break;\n        case 'v':\n          verbose = true;\n          break;\n        case 'S':\n          make_backups = true;\n          backup_suffix = optarg;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n          break;\n        }\n    }\n\n  n_files = argc - optind;\n  file = argv + optind;\n\n  if (n_files <= 0)\n    {\n      error (0, 0, _(\"missing file operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (relative && !symbolic_link)\n    error (EXIT_FAILURE, 0, _(\"cannot do --relative without --symbolic\"));\n\n  if (!hard_dir_link)\n    {\n      priv_set_remove_linkdir ();\n      beware_hard_dir_link = !cannot_unlink_dir ();\n    }\n\n  if (no_target_directory)\n    {\n      if (target_directory)\n        error (EXIT_FAILURE, 0,\n               _(\"cannot combine --target-directory \"\n                 \"and --no-target-directory\"));\n      if (n_files != 2)\n        {\n          if (n_files < 2)\n            error (0, 0,\n                   _(\"missing destination file operand after %s\"),\n                   quoteaf (file[0]));\n          else\n            error (0, 0, _(\"extra operand %s\"), quoteaf (file[2]));\n          usage (EXIT_FAILURE);\n        }\n    }\n  else if (n_files < 2 && !target_directory)\n    {\n      target_directory = \".\";\n      destdir_fd = AT_FDCWD;\n    }\n  else\n    {\n      if (n_files == 2 && !target_directory)\n        link_errno = atomic_link (file[0], AT_FDCWD, file[1]);\n      if (link_errno < 0 || link_errno == EEXIST || link_errno == ENOTDIR\n          || link_errno == EINVAL)\n        {\n          char const *d\n            = target_directory ? target_directory : file[n_files - 1];\n          int flags = (O_PATHSEARCH | O_DIRECTORY\n                       | (dereference_dest_dir_symlinks ? 0 : O_NOFOLLOW));\n          destdir_fd = openat_safer (AT_FDCWD, d, flags);\n          int err = errno;\n          if (!O_DIRECTORY && 0 <= destdir_fd)\n            {\n              struct stat st;\n              err = (fstat (destdir_fd, &st) != 0 ? errno\n                     : S_ISDIR (st.st_mode) ? 0 : ENOTDIR);\n              if (err != 0)\n                {\n                  close (destdir_fd);\n                  destdir_fd = -1;\n                }\n            }\n          if (0 <= destdir_fd)\n            {\n              n_files -= !target_directory;\n              target_directory = d;\n            }\n          else if (! (n_files == 2 && !target_directory))\n            error (EXIT_FAILURE, err, _(\"target %s\"), quoteaf (d));\n        }\n    }\n\n  backup_type = (make_backups\n                 ? xget_version (_(\"backup type\"), version_control_string)\n                 : no_backups);\n  set_simple_backup_suffix (backup_suffix);\n\n\n  if (target_directory)\n    {\n       \n      if (2 <= n_files\n          && remove_existing_files\n           \n          && ! symbolic_link\n           \n          && backup_type != numbered_backups)\n        {\n          dest_set = hash_initialize (DEST_INFO_INITIAL_CAPACITY,\n                                      nullptr,\n                                      triple_hash,\n                                      triple_compare,\n                                      triple_free);\n          if (dest_set == nullptr)\n            xalloc_die ();\n        }\n\n      ok = true;\n      for (int i = 0; i < n_files; ++i)\n        {\n          char *dest_base;\n          char *dest = file_name_concat (target_directory,\n                                         last_component (file[i]),\n                                         &dest_base);\n          strip_trailing_slashes (dest_base);\n          ok &= do_link (file[i], destdir_fd, dest_base, dest, -1);\n          free (dest);\n        }\n    }\n  else\n    ok = do_link (file[0], AT_FDCWD, file[1], file[1], link_errno);\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}