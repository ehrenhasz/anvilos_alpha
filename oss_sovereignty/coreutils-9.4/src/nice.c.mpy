{
  "module_name": "nice.c",
  "hash_id": "e4355bb8a2580e13e059df22283adc2d2fda7f33df2eeb2fc6c1fb5c44b621d6",
  "original_prompt": "Ingested from coreutils-9.4/src/nice.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n\n#if ! HAVE_NICE\n \n# include <sys/resource.h>\n#endif\n\n#include \"quote.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"nice\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\n#if HAVE_NICE\n# define GET_NICENESS() nice (0)\n#else\n# define GET_NICENESS() getpriority (PRIO_PROCESS, 0)\n#endif\n\n#ifndef NZERO\n# define NZERO 20\n#endif\n\n \n#if NZERO == 0\n# undef  NZERO\n# define NZERO 20\n#endif\n\nstatic struct option const longopts[] =\n{\n  {\"adjustment\", required_argument, nullptr, 'n'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION] [COMMAND [ARG]...]\\n\"), program_name);\n      printf (_(\"\\\nRun COMMAND with an adjusted niceness, which affects process scheduling.\\n\\\nWith no COMMAND, print the current niceness.  Niceness values range from\\n\\\n%d (most favorable to the process) to %d (least favorable to the process).\\n\\\n\"),\n              - NZERO, NZERO - 1);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -n, --adjustment=N   add integer N to the niceness (default 10)\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_exec_status (PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic bool\nperm_related_errno (int err)\n{\n  return err == EACCES || err == EPERM;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int current_niceness;\n  int adjustment = 10;\n  char const *adjustment_given = nullptr;\n  bool ok;\n  int i;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXIT_CANCELED);\n  atexit (close_stdout);\n\n  for (i = 1; i < argc; /* empty */)\n    {\n      char const *s = argv[i];\n\n      if (s[0] == '-' && ISDIGIT (s[1 + (s[1] == '-' || s[1] == '+')]))\n        {\n          adjustment_given = s + 1;\n          ++i;\n        }\n      else\n        {\n          int c;\n          int fake_argc = argc - (i - 1);\n          char **fake_argv = argv + (i - 1);\n\n          /* Ensure that any getopt diagnostics use the right name.  */\n          fake_argv[0] = argv[0];\n\n          /* Initialize getopt_long's internal state.  */\n          optind = 0;\n\n          c = getopt_long (fake_argc, fake_argv, \"+n:\", longopts, nullptr);\n          i += optind - 1;\n\n          switch (c)\n            {\n            case 'n':\n              adjustment_given = optarg;\n              break;\n\n            case -1:\n              break;\n\n            case_GETOPT_HELP_CHAR;\n\n            case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n            default:\n              usage (EXIT_CANCELED);\n              break;\n            }\n\n          if (c == -1)\n            break;\n        }\n    }\n\n  if (adjustment_given)\n    {\n      /* If the requested adjustment is outside the valid range,\n         silently bring it to just within range; this mimics what\n         \"setpriority\" and \"nice\" do.  */\n      enum { MIN_ADJUSTMENT = 1 - 2 * NZERO, MAX_ADJUSTMENT = 2 * NZERO - 1 };\n      long int tmp;\n      if (LONGINT_OVERFLOW < xstrtol (adjustment_given, nullptr, 10, &tmp, \"\"))\n        error (EXIT_CANCELED, 0, _(\"invalid adjustment %s\"),\n               quote (adjustment_given));\n      adjustment = MAX (MIN_ADJUSTMENT, MIN (tmp, MAX_ADJUSTMENT));\n    }\n\n  if (i == argc)\n    {\n      if (adjustment_given)\n        {\n          error (0, 0, _(\"a command must be given with an adjustment\"));\n          usage (EXIT_CANCELED);\n        }\n      /* No command given; print the niceness.  */\n      errno = 0;\n      current_niceness = GET_NICENESS ();\n      if (current_niceness == -1 && errno != 0)\n        error (EXIT_CANCELED, errno, _(\"cannot get niceness\"));\n      printf (\"%d\\n\", current_niceness);\n      return EXIT_SUCCESS;\n    }\n\n  errno = 0;\n#if HAVE_NICE\n  ok = (nice (adjustment) != -1 || errno == 0);\n#else\n  current_niceness = GET_NICENESS ();\n  if (current_niceness == -1 && errno != 0)\n    error (EXIT_CANCELED, errno, _(\"cannot get niceness\"));\n  ok = (setpriority (PRIO_PROCESS, 0, current_niceness + adjustment) == 0);\n#endif\n  if (!ok)\n    {\n      error (perm_related_errno (errno) ? 0\n             : EXIT_CANCELED, errno, _(\"cannot set niceness\"));\n      /* error() flushes stderr, but does not check for write failure.\n         Normally, we would catch this via our atexit() hook of\n         close_stdout, but execvp() gets in the way.  If stderr\n         encountered a write failure, there is no need to try calling\n         error() again.  */\n      if (ferror (stderr))\n        return EXIT_CANCELED;\n    }\n\n  execvp (argv[i], &argv[i]);\n\n  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n  error (0, errno, \"%s\", quote (argv[i]));\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}