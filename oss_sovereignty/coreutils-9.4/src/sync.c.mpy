{
  "module_name": "sync.c",
  "hash_id": "8971778730552a57d8957c738e6e201346a7c682f0718d2ab26803e4d68c95bb",
  "original_prompt": "Ingested from coreutils-9.4/src/sync.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n\n \n#define PROGRAM_NAME \"sync\"\n\n#define AUTHORS                                 \\\n  proper_name (\"Jim Meyering\"),                 \\\n  proper_name (\"Giuseppe Scrivano\")\n\n#ifndef HAVE_SYNCFS\n# define HAVE_SYNCFS 0\n#endif\n\nenum sync_mode\n{\n  MODE_FILE,\n  MODE_DATA,\n  MODE_FILE_SYSTEM,\n  MODE_SYNC\n};\n\nstatic struct option const long_options[] =\n{\n  {\"data\", no_argument, nullptr, 'd'},\n  {\"file-system\", no_argument, nullptr, 'f'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION] [FILE]...\\n\"), program_name);\n      fputs (_(\"\\\nSynchronize cached writes to persistent storage\\n\\\n\\n\\\nIf one or more files are specified, sync only them,\\n\\\nor their containing file systems.\\n\\\n\\n\\\n\"), stdout);\n\n      fputs (_(\"\\\n  -d, --data             sync only file data, no unneeded metadata\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f, --file-system      sync the file systems that contain the files\\n\\\n\"), stdout);\n\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Sync the specified FILE, or file systems associated with FILE.\n   Return 1 on success.  */\n\nstatic bool\nsync_arg (enum sync_mode mode, char const *file)\n{\n  bool ret = true;\n  int open_flags = O_RDONLY | O_NONBLOCK;\n  int fd;\n\n#if defined _AIX || defined __CYGWIN__\n  /* AIX 7.1, CYGWIN 2.9.0, fsync requires write access to file.  */\n  if (mode == MODE_FILE)\n    open_flags = O_WRONLY | O_NONBLOCK;\n#endif\n\n  /* Note O_PATH might be supported with syncfs(),\n     though as of Linux 3.18 is not.  */\n  fd = open (file, open_flags);\n  if (fd < 0)\n    {\n      /* Use the O_RDONLY errno, which is significant\n         with directories for example.  */\n      int rd_errno = errno;\n      if (open_flags != (O_WRONLY | O_NONBLOCK))\n        fd = open (file, O_WRONLY | O_NONBLOCK);\n      if (fd < 0)\n        {\n          error (0, rd_errno, _(\"error opening %s\"), quoteaf (file));\n          return false;\n        }\n    }\n\n  /* We used O_NONBLOCK above to not hang with fifos,\n     so reset that here.  */\n  int fdflags = fcntl (fd, F_GETFL);\n  if (fdflags == -1\n      || fcntl (fd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)\n    {\n      error (0, errno, _(\"couldn't reset non-blocking mode %s\"),\n             quoteaf (file));\n      ret = false;\n    }\n\n  if (ret == true)\n    {\n      int sync_status = -1;\n\n      switch (mode)\n        {\n        case MODE_DATA:\n          sync_status = fdatasync (fd);\n          break;\n\n        case MODE_FILE:\n          sync_status = fsync (fd);\n          break;\n\n#if HAVE_SYNCFS\n        case MODE_FILE_SYSTEM:\n          sync_status = syncfs (fd);\n          break;\n#endif\n\n        default:\n          unreachable ();\n        }\n\n      if (sync_status < 0)\n        {\n          error (0, errno, _(\"error syncing %s\"), quoteaf (file));\n          ret = false;\n        }\n    }\n\n  if (close (fd) < 0)\n    {\n      error (0, errno, _(\"failed to close %s\"), quoteaf (file));\n      ret = false;\n    }\n\n  return ret;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n  bool args_specified;\n  bool arg_data = false, arg_file_system = false;\n  enum sync_mode mode;\n  bool ok = true;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"df\", long_options, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case 'd':\n          arg_data = true;\n          break;\n\n        case 'f':\n          arg_file_system = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  args_specified = optind < argc;\n\n  if (arg_data && arg_file_system)\n    error (EXIT_FAILURE, 0,\n           _(\"cannot specify both --data and --file-system\"));\n\n  if (!args_specified && arg_data)\n    error (EXIT_FAILURE, 0, _(\"--data needs at least one argument\"));\n\n  if (! args_specified || (arg_file_system && ! HAVE_SYNCFS))\n    mode = MODE_SYNC;\n  else if (arg_file_system)\n    mode = MODE_FILE_SYSTEM;\n  else if (! arg_data)\n    mode = MODE_FILE;\n  else\n    mode = MODE_DATA;\n\n  if (mode == MODE_SYNC)\n    sync ();\n  else\n    {\n      for (; optind < argc; optind++)\n        ok &= sync_arg (mode, argv[optind]);\n    }\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}