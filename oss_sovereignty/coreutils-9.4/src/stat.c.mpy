{
  "module_name": "stat.c",
  "hash_id": "f10ce74bab201e17e34dcbf503aa61d2f7c7f1122486f56cfc37de9ebe04a441",
  "original_prompt": "Ingested from coreutils-9.4/src/stat.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#if ((STAT_STATVFS || STAT_STATVFS64)                                       \\\n     && (HAVE_STRUCT_STATVFS_F_BASETYPE || HAVE_STRUCT_STATVFS_F_FSTYPENAME \\\n         || (! HAVE_STRUCT_STATFS_F_FSTYPENAME && HAVE_STRUCT_STATVFS_F_TYPE)))\n# define USE_STATVFS 1\n#else\n# define USE_STATVFS 0\n#endif\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#if USE_STATVFS\n# include <sys/statvfs.h>\n#elif HAVE_SYS_VFS_H\n# include <sys/vfs.h>\n#elif HAVE_SYS_MOUNT_H && HAVE_SYS_PARAM_H\n \n \n# include <sys/param.h>\n# include <sys/mount.h>\n# if HAVE_NFS_NFS_CLNT_H && HAVE_NFS_VFS_H\n \n#  include <netinet/in.h>\n#  include <nfs/nfs_clnt.h>\n#  include <nfs/vfs.h>\n# endif\n#elif HAVE_OS_H  \n# include <fs_info.h>\n#endif\n#include <selinux/selinux.h>\n\n#include \"system.h\"\n\n#include \"areadlink.h\"\n#include \"argmatch.h\"\n#include \"file-type.h\"\n#include \"filemode.h\"\n#include \"fs.h\"\n#include \"getopt.h\"\n#include \"mountlist.h\"\n#include \"quote.h\"\n#include \"stat-size.h\"\n#include \"stat-time.h\"\n#include \"strftime.h\"\n#include \"find-mount-point.h\"\n#include \"xvasprintf.h\"\n#include \"statx.h\"\n\n#if HAVE_STATX && defined STATX_INO\n# define USE_STATX 1\n#else\n# define USE_STATX 0\n#endif\n\n#if USE_STATVFS\n# define STRUCT_STATXFS_F_FSID_IS_INTEGER STRUCT_STATVFS_F_FSID_IS_INTEGER\n# define HAVE_STRUCT_STATXFS_F_TYPE HAVE_STRUCT_STATVFS_F_TYPE\n# if HAVE_STRUCT_STATVFS_F_NAMEMAX\n#  define SB_F_NAMEMAX(S) ((S)->f_namemax)\n# endif\n# if ! STAT_STATVFS && STAT_STATVFS64\n#  define STRUCT_STATVFS struct statvfs64\n#  define STATFS statvfs64\n# else\n#  define STRUCT_STATVFS struct statvfs\n#  define STATFS statvfs\n# endif\n# define STATFS_FRSIZE(S) ((S)->f_frsize)\n#else\n# define HAVE_STRUCT_STATXFS_F_TYPE HAVE_STRUCT_STATFS_F_TYPE\n# if HAVE_STRUCT_STATFS_F_NAMELEN\n#  define SB_F_NAMEMAX(S) ((S)->f_namelen)\n# elif HAVE_STRUCT_STATFS_F_NAMEMAX\n#  define SB_F_NAMEMAX(S) ((S)->f_namemax)\n# endif\n# define STATFS statfs\n# if HAVE_OS_H  \n \nNODISCARD\nstatic int\nstatfs (char const *filename, struct fs_info *buf)\n{\n  dev_t device = dev_for_path (filename);\n  if (device < 0)\n    {\n      errno = (device == B_ENTRY_NOT_FOUND ? ENOENT\n               : device == B_BAD_VALUE ? EINVAL\n               : device == B_NAME_TOO_LONG ? ENAMETOOLONG\n               : device == B_NO_MEMORY ? ENOMEM\n               : device == B_FILE_ERROR ? EIO\n               : 0);\n      return -1;\n    }\n   \n  return fs_stat_dev (device, buf);\n}\n#  define f_fsid dev\n#  define f_blocks total_blocks\n#  define f_bfree free_blocks\n#  define f_bavail free_blocks\n#  define f_bsize io_size\n#  define f_files total_nodes\n#  define f_ffree free_nodes\n#  define STRUCT_STATVFS struct fs_info\n#  define STRUCT_STATXFS_F_FSID_IS_INTEGER true\n#  define STATFS_FRSIZE(S) ((S)->block_size)\n# else\n#  define STRUCT_STATVFS struct statfs\n#  define STRUCT_STATXFS_F_FSID_IS_INTEGER STRUCT_STATFS_F_FSID_IS_INTEGER\n#  if HAVE_STRUCT_STATFS_F_FRSIZE\n#   define STATFS_FRSIZE(S) ((S)->f_frsize)\n#  else\n#   define STATFS_FRSIZE(S) 0\n#  endif\n# endif\n#endif\n\n#ifdef SB_F_NAMEMAX\n# define OUT_NAMEMAX out_uint\n#else\n \n# define SB_F_NAMEMAX(S) \"?\"\n# define OUT_NAMEMAX out_string\n#endif\n\n#if HAVE_STRUCT_STATVFS_F_BASETYPE\n# define STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME f_basetype\n#else\n# if HAVE_STRUCT_STATVFS_F_FSTYPENAME || HAVE_STRUCT_STATFS_F_FSTYPENAME\n#  define STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME f_fstypename\n# elif HAVE_OS_H  \n#  define STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME fsh_name\n# endif\n#endif\n\n#if HAVE_GETATTRAT\n# include <attr.h>\n# include <sys/nvpair.h>\n#endif\n\n \n#define isodigit(c) ('0' <= (c) && (c) <= '7')\n#define octtobin(c) ((c) - '0')\n#define hextobin(c) ((c) >= 'a' && (c) <= 'f' ? (c) - 'a' + 10 : \\\n                     (c) >= 'A' && (c) <= 'F' ? (c) - 'A' + 10 : (c) - '0')\n\nstatic char const digits[] = \"0123456789\";\n\n \nstatic char const printf_flags[] = \"'-+ #0I\";\n\n \nstatic char const fmt_terse_fs[] = \"%n %i %l %t %s %S %b %f %a %c %d\\n\";\nstatic char const fmt_terse_regular[] = \"%n %s %b %f %u %g %D %i %h %t %T\"\n                                        \" %X %Y %Z %W %o\\n\";\nstatic char const fmt_terse_selinux[] = \"%n %s %b %f %u %g %D %i %h %t %T\"\n                                        \" %X %Y %Z %W %o %C\\n\";\n\n#define PROGRAM_NAME \"stat\"\n\n#define AUTHORS proper_name (\"Michael Meskes\")\n\nenum\n{\n  PRINTF_OPTION = CHAR_MAX + 1\n};\n\nenum cached_mode\n{\n  cached_default,\n  cached_never,\n  cached_always\n};\n\nstatic char const *const cached_args[] =\n{\n  \"default\", \"never\", \"always\", nullptr\n};\n\nstatic enum cached_mode const cached_modes[] =\n{\n  cached_default, cached_never, cached_always\n};\n\nstatic struct option const long_options[] =\n{\n  {\"dereference\", no_argument, nullptr, 'L'},\n  {\"file-system\", no_argument, nullptr, 'f'},\n  {\"format\", required_argument, nullptr, 'c'},\n  {\"printf\", required_argument, nullptr, PRINTF_OPTION},\n  {\"terse\", no_argument, nullptr, 't'},\n  {\"cached\", required_argument, nullptr, 0},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic bool follow_links;\n\n \nstatic bool interpret_backslash_escapes;\n\n \nstatic char const *trailing_delim = \"\";\n\n \nstatic char const *decimal_point;\nstatic size_t decimal_point_len;\n\nstatic bool\nprint_stat (char *pformat, size_t prefix_len, char mod, char m,\n            int fd, char const *filename, void const *data);\n\n \nNODISCARD\nstatic char const *\nhuman_fstype (STRUCT_STATVFS const *statfsbuf)\n{\n#ifdef STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME\n  return statfsbuf->STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME;\n#else\n  switch (statfsbuf->f_type)\n    {\n# if defined __linux__ || defined __ANDROID__\n\n       \n\n       \n\n       \n\n    case S_MAGIC_AAFS:  \n      return \"aafs\";\n    case S_MAGIC_ACFS:  \n      return \"acfs\";\n    case S_MAGIC_ADFS:  \n      return \"adfs\";\n    case S_MAGIC_AFFS:  \n      return \"affs\";\n    case S_MAGIC_AFS:  \n      return \"afs\";\n    case S_MAGIC_ANON_INODE_FS:  \n      return \"anon-inode FS\";\n    case S_MAGIC_AUFS:  \n       \n      return \"aufs\";\n    case S_MAGIC_AUTOFS:  \n      return \"autofs\";\n    case S_MAGIC_BALLOON_KVM:  \n      return \"balloon-kvm-fs\";\n    case S_MAGIC_BEFS:  \n      return \"befs\";\n    case S_MAGIC_BDEVFS:  \n      return \"bdevfs\";\n    case S_MAGIC_BFS:  \n      return \"bfs\";\n    case S_MAGIC_BINDERFS:  \n      return \"binderfs\";\n    case S_MAGIC_BPF_FS:  \n      return \"bpf_fs\";\n    case S_MAGIC_BINFMTFS:  \n      return \"binfmt_misc\";\n    case S_MAGIC_BTRFS:  \n      return \"btrfs\";\n    case S_MAGIC_BTRFS_TEST:  \n      return \"btrfs_test\";\n    case S_MAGIC_CEPH:  \n      return \"ceph\";\n    case S_MAGIC_CGROUP:  \n      return \"cgroupfs\";\n    case S_MAGIC_CGROUP2:  \n      return \"cgroup2fs\";\n    case S_MAGIC_CIFS:  \n      return \"cifs\";\n    case S_MAGIC_CODA:  \n      return \"coda\";\n    case S_MAGIC_COH:  \n      return \"coh\";\n    case S_MAGIC_CONFIGFS:  \n      return \"configfs\";\n    case S_MAGIC_CRAMFS:  \n      return \"cramfs\";\n    case S_MAGIC_CRAMFS_WEND:  \n      return \"cramfs-wend\";\n    case S_MAGIC_DAXFS:  \n      return \"daxfs\";\n    case S_MAGIC_DEBUGFS:  \n      return \"debugfs\";\n    case S_MAGIC_DEVFS:  \n      return \"devfs\";\n    case S_MAGIC_DEVMEM:  \n      return \"devmem\";\n    case S_MAGIC_DEVPTS:  \n      return \"devpts\";\n    case S_MAGIC_DMA_BUF:  \n      return \"dma-buf-fs\";\n    case S_MAGIC_ECRYPTFS:  \n      return \"ecryptfs\";\n    case S_MAGIC_EFIVARFS:  \n      return \"efivarfs\";\n    case S_MAGIC_EFS:  \n      return \"efs\";\n    case S_MAGIC_EROFS_V1:  \n      return \"erofs\";\n    case S_MAGIC_EXFAT:  \n      return \"exfat\";\n    case S_MAGIC_EXFS:  \n      return \"exfs\";\n    case S_MAGIC_EXOFS:  \n      return \"exofs\";\n    case S_MAGIC_EXT:  \n      return \"ext\";\n    case S_MAGIC_EXT2:  \n      return \"ext2/ext3\";\n    case S_MAGIC_EXT2_OLD:  \n      return \"ext2\";\n    case S_MAGIC_F2FS:  \n      return \"f2fs\";\n    case S_MAGIC_FAT:  \n      return \"fat\";\n    case S_MAGIC_FHGFS:  \n      return \"fhgfs\";\n    case S_MAGIC_FUSEBLK:  \n      return \"fuseblk\";\n    case S_MAGIC_FUSECTL:  \n      return \"fusectl\";\n    case S_MAGIC_FUTEXFS:  \n      return \"futexfs\";\n    case S_MAGIC_GFS:  \n      return \"gfs/gfs2\";\n    case S_MAGIC_GPFS:  \n      return \"gpfs\";\n    case S_MAGIC_HFS:  \n      return \"hfs\";\n    case S_MAGIC_HFS_PLUS:  \n      return \"hfs+\";\n    case S_MAGIC_HFS_X:  \n      return \"hfsx\";\n    case S_MAGIC_HOSTFS:  \n      return \"hostfs\";\n    case S_MAGIC_HPFS:  \n      return \"hpfs\";\n    case S_MAGIC_HUGETLBFS:  \n      return \"hugetlbfs\";\n    case S_MAGIC_MTD_INODE_FS:  \n      return \"inodefs\";\n    case S_MAGIC_IBRIX:  \n      return \"ibrix\";\n    case S_MAGIC_INOTIFYFS:  \n      return \"inotifyfs\";\n    case S_MAGIC_ISOFS:  \n      return \"isofs\";\n    case S_MAGIC_ISOFS_R_WIN:  \n      return \"isofs\";\n    case S_MAGIC_ISOFS_WIN:  \n      return \"isofs\";\n    case S_MAGIC_JFFS:  \n      return \"jffs\";\n    case S_MAGIC_JFFS2:  \n      return \"jffs2\";\n    case S_MAGIC_JFS:  \n      return \"jfs\";\n    case S_MAGIC_KAFS:  \n      return \"k-afs\";\n    case S_MAGIC_LOGFS:  \n      return \"logfs\";\n    case S_MAGIC_LUSTRE:  \n      return \"lustre\";\n    case S_MAGIC_M1FS:  \n      return \"m1fs\";\n    case S_MAGIC_MINIX:  \n      return \"minix\";\n    case S_MAGIC_MINIX_30:  \n      return \"minix (30 char.)\";\n    case S_MAGIC_MINIX_V2:  \n      return \"minix v2\";\n    case S_MAGIC_MINIX_V2_30:  \n      return \"minix v2 (30 char.)\";\n    case S_MAGIC_MINIX_V3:  \n      return \"minix3\";\n    case S_MAGIC_MQUEUE:  \n      return \"mqueue\";\n    case S_MAGIC_MSDOS:  \n      return \"msdos\";\n    case S_MAGIC_NCP:  \n      return \"novell\";\n    case S_MAGIC_NFS:  \n      return \"nfs\";\n    case S_MAGIC_NFSD:  \n      return \"nfsd\";\n    case S_MAGIC_NILFS:  \n      return \"nilfs\";\n    case S_MAGIC_NSFS:  \n      return \"nsfs\";\n    case S_MAGIC_NTFS:  \n      return \"ntfs\";\n    case S_MAGIC_OPENPROM:  \n      return \"openprom\";\n    case S_MAGIC_OCFS2:  \n      return \"ocfs2\";\n    case S_MAGIC_OVERLAYFS:  \n       \n      return \"overlayfs\";\n    case S_MAGIC_PANFS:  \n      return \"panfs\";\n    case S_MAGIC_PIPEFS:  \n       \n      return \"pipefs\";\n    case S_MAGIC_PPC_CMM:  \n      return \"ppc-cmm-fs\";\n    case S_MAGIC_PRL_FS:  \n      return \"prl_fs\";\n    case S_MAGIC_PROC:  \n      return \"proc\";\n    case S_MAGIC_PSTOREFS:  \n      return \"pstorefs\";\n    case S_MAGIC_QNX4:  \n      return \"qnx4\";\n    case S_MAGIC_QNX6:  \n      return \"qnx6\";\n    case S_MAGIC_RAMFS:  \n      return \"ramfs\";\n    case S_MAGIC_RDTGROUP:  \n      return \"rdt\";\n    case S_MAGIC_REISERFS:  \n      return \"reiserfs\";\n    case S_MAGIC_ROMFS:  \n      return \"romfs\";\n    case S_MAGIC_RPC_PIPEFS:  \n      return \"rpc_pipefs\";\n    case S_MAGIC_SDCARDFS:  \n      return \"sdcardfs\";\n    case S_MAGIC_SECRETMEM:  \n      return \"secretmem\";\n    case S_MAGIC_SECURITYFS:  \n      return \"securityfs\";\n    case S_MAGIC_SELINUX:  \n      return \"selinux\";\n    case S_MAGIC_SMACK:  \n      return \"smackfs\";\n    case S_MAGIC_SMB:  \n      return \"smb\";\n    case S_MAGIC_SMB2:  \n      return \"smb2\";\n    case S_MAGIC_SNFS:  \n      return \"snfs\";\n    case S_MAGIC_SOCKFS:  \n      return \"sockfs\";\n    case S_MAGIC_SQUASHFS:  \n      return \"squashfs\";\n    case S_MAGIC_SYSFS:  \n      return \"sysfs\";\n    case S_MAGIC_SYSV2:  \n      return \"sysv2\";\n    case S_MAGIC_SYSV4:  \n      return \"sysv4\";\n    case S_MAGIC_TMPFS:  \n      return \"tmpfs\";\n    case S_MAGIC_TRACEFS:  \n      return \"tracefs\";\n    case S_MAGIC_UBIFS:  \n      return \"ubifs\";\n    case S_MAGIC_UDF:  \n      return \"udf\";\n    case S_MAGIC_UFS:  \n      return \"ufs\";\n    case S_MAGIC_UFS_BYTESWAPPED:  \n      return \"ufs\";\n    case S_MAGIC_USBDEVFS:  \n      return \"usbdevfs\";\n    case S_MAGIC_V9FS:  \n      return \"v9fs\";\n    case S_MAGIC_VBOXSF:  \n      return \"vboxsf\";\n    case S_MAGIC_VMHGFS:  \n      return \"vmhgfs\";\n    case S_MAGIC_VXFS:  \n       \n      return \"vxfs\";\n    case S_MAGIC_VZFS:  \n      return \"vzfs\";\n    case S_MAGIC_WSLFS:  \n      return \"wslfs\";\n    case S_MAGIC_XENFS:  \n      return \"xenfs\";\n    case S_MAGIC_XENIX:  \n      return \"xenix\";\n    case S_MAGIC_XFS:  \n      return \"xfs\";\n    case S_MAGIC_XIAFS:  \n      return \"xia\";\n    case S_MAGIC_Z3FOLD:  \n      return \"z3fold\";\n    case S_MAGIC_ZFS:  \n      return \"zfs\";\n    case S_MAGIC_ZONEFS:  \n      return \"zonefs\";\n    case S_MAGIC_ZSMALLOC:  \n      return \"zsmallocfs\";\n\n\n# elif __GNU__\n    case FSTYPE_UFS:\n      return \"ufs\";\n    case FSTYPE_NFS:\n      return \"nfs\";\n    case FSTYPE_GFS:\n      return \"gfs\";\n    case FSTYPE_LFS:\n      return \"lfs\";\n    case FSTYPE_SYSV:\n      return \"sysv\";\n    case FSTYPE_FTP:\n      return \"ftp\";\n    case FSTYPE_TAR:\n      return \"tar\";\n    case FSTYPE_AR:\n      return \"ar\";\n    case FSTYPE_CPIO:\n      return \"cpio\";\n    case FSTYPE_MSLOSS:\n      return \"msloss\";\n    case FSTYPE_CPM:\n      return \"cpm\";\n    case FSTYPE_HFS:\n      return \"hfs\";\n    case FSTYPE_DTFS:\n      return \"dtfs\";\n    case FSTYPE_GRFS:\n      return \"grfs\";\n    case FSTYPE_TERM:\n      return \"term\";\n    case FSTYPE_DEV:\n      return \"dev\";\n    case FSTYPE_PROC:\n      return \"proc\";\n    case FSTYPE_IFSOCK:\n      return \"ifsock\";\n    case FSTYPE_AFS:\n      return \"afs\";\n    case FSTYPE_DFS:\n      return \"dfs\";\n    case FSTYPE_PROC9:\n      return \"proc9\";\n    case FSTYPE_SOCKET:\n      return \"socket\";\n    case FSTYPE_MISC:\n      return \"misc\";\n    case FSTYPE_EXT2FS:\n      return \"ext2/ext3\";\n    case FSTYPE_HTTP:\n      return \"http\";\n    case FSTYPE_MEMFS:\n      return \"memfs\";\n    case FSTYPE_ISO9660:\n      return \"iso9660\";\n# endif\n    default:\n      {\n        unsigned long int type = statfsbuf->f_type;\n        static char buf[sizeof \"UNKNOWN (0x%lx)\" - 3\n                        + (sizeof type * CHAR_BIT + 3) / 4];\n        sprintf (buf, \"UNKNOWN (0x%lx)\", type);\n        return buf;\n      }\n    }\n#endif\n}\n\nNODISCARD\nstatic char *\nhuman_access (struct stat const *statbuf)\n{\n  static char modebuf[12];\n  filemodestring (statbuf, modebuf);\n  modebuf[10] = 0;\n  return modebuf;\n}\n\nNODISCARD\nstatic char *\nhuman_time (struct timespec t)\n{\n   \n  static char str[INT_BUFSIZE_BOUND (intmax_t)\n                  + INT_STRLEN_BOUND (int)  \n                  + 1  \n                  + sizeof \"-MM-DD HH:MM:SS.NNNNNNNNN +\"];\n  static timezone_t tz;\n  if (!tz)\n    tz = tzalloc (getenv (\"TZ\"));\n  struct tm tm;\n  int ns = t.tv_nsec;\n  if (localtime_rz (tz, &t.tv_sec, &tm))\n    nstrftime (str, sizeof str, \"%Y-%m-%d %H:%M:%S.%N %z\", &tm, tz, ns);\n  else\n    {\n      char secbuf[INT_BUFSIZE_BOUND (intmax_t)];\n      sprintf (str, \"%s.%09d\", timetostr (t.tv_sec, secbuf), ns);\n    }\n  return str;\n}\n\n \nstatic void\nmake_format (char *pformat, size_t prefix_len, char const *allowed_flags,\n             char const *suffix)\n{\n  char *dst = pformat + 1;\n  char const *src;\n  char const *srclim = pformat + prefix_len;\n  for (src = dst; src < srclim && strchr (printf_flags, *src); src++)\n    if (strchr (allowed_flags, *src))\n      *dst++ = *src;\n  while (src < srclim)\n    *dst++ = *src++;\n  strcpy (dst, suffix);\n}\n\nstatic void\nout_string (char *pformat, size_t prefix_len, char const *arg)\n{\n  make_format (pformat, prefix_len, \"-\", \"s\");\n  printf (pformat, arg);\n}\nstatic int\nout_int (char *pformat, size_t prefix_len, intmax_t arg)\n{\n  make_format (pformat, prefix_len, \"'-+ 0\", PRIdMAX);\n  return printf (pformat, arg);\n}\nstatic int\nout_uint (char *pformat, size_t prefix_len, uintmax_t arg)\n{\n  make_format (pformat, prefix_len, \"'-0\", PRIuMAX);\n  return printf (pformat, arg);\n}\nstatic void\nout_uint_o (char *pformat, size_t prefix_len, uintmax_t arg)\n{\n  make_format (pformat, prefix_len, \"-#0\", PRIoMAX);\n  printf (pformat, arg);\n}\nstatic void\nout_uint_x (char *pformat, size_t prefix_len, uintmax_t arg)\n{\n  make_format (pformat, prefix_len, \"-#0\", PRIxMAX);\n  printf (pformat, arg);\n}\nstatic int\nout_minus_zero (char *pformat, size_t prefix_len)\n{\n  make_format (pformat, prefix_len, \"'-+ 0\", \".0f\");\n  return printf (pformat, -0.25);\n}\n\n \nstatic void\nout_epoch_sec (char *pformat, size_t prefix_len,\n               struct timespec arg)\n{\n  char *dot = memchr (pformat, '.', prefix_len);\n  size_t sec_prefix_len = prefix_len;\n  int width = 0;\n  int precision = 0;\n  bool frac_left_adjust = false;\n\n  if (dot)\n    {\n      sec_prefix_len = dot - pformat;\n      pformat[prefix_len] = '\\0';\n\n      if (ISDIGIT (dot[1]))\n        {\n          long int lprec = strtol (dot + 1, nullptr, 10);\n          precision = (lprec <= INT_MAX ? lprec : INT_MAX);\n        }\n      else\n        {\n          precision = 9;\n        }\n\n      if (precision && ISDIGIT (dot[-1]))\n        {\n           \n          char *p = dot;\n          *dot = '\\0';\n\n          do\n            --p;\n          while (ISDIGIT (p[-1]));\n\n          long int lwidth = strtol (p, nullptr, 10);\n          width = (lwidth <= INT_MAX ? lwidth : INT_MAX);\n          if (1 < width)\n            {\n              p += (*p == '0');\n              sec_prefix_len = p - pformat;\n              int w_d = (decimal_point_len < width\n                         ? width - decimal_point_len\n                         : 0);\n              if (1 < w_d)\n                {\n                  int w = w_d - precision;\n                  if (1 < w)\n                    {\n                      char *dst = pformat;\n                      for (char const *src = dst; src < p; src++)\n                        {\n                          if (*src == '-')\n                            frac_left_adjust = true;\n                          else\n                            *dst++ = *src;\n                        }\n                      sec_prefix_len =\n                        (dst - pformat\n                         + (frac_left_adjust ? 0 : sprintf (dst, \"%d\", w)));\n                    }\n                }\n            }\n        }\n    }\n\n  int divisor = 1;\n  for (int i = precision; i < 9; i++)\n    divisor *= 10;\n  int frac_sec = arg.tv_nsec / divisor;\n  int int_len;\n\n  if (TYPE_SIGNED (time_t))\n    {\n      bool minus_zero = false;\n      if (arg.tv_sec < 0 && arg.tv_nsec != 0)\n        {\n          int frac_sec_modulus = 1000000000 / divisor;\n          frac_sec = (frac_sec_modulus - frac_sec\n                      - (arg.tv_nsec % divisor != 0));\n          arg.tv_sec += (frac_sec != 0);\n          minus_zero = (arg.tv_sec == 0);\n        }\n      int_len = (minus_zero\n                 ? out_minus_zero (pformat, sec_prefix_len)\n                 : out_int (pformat, sec_prefix_len, arg.tv_sec));\n    }\n  else\n    int_len = out_uint (pformat, sec_prefix_len, arg.tv_sec);\n\n  if (precision)\n    {\n      int prec = (precision < 9 ? precision : 9);\n      int trailing_prec = precision - prec;\n      int ilen = (int_len < 0 ? 0 : int_len);\n      int trailing_width = (ilen < width && decimal_point_len < width - ilen\n                            ? width - ilen - decimal_point_len - prec\n                            : 0);\n      printf (\"%s%.*d%-*.*d\", decimal_point, prec, frac_sec,\n              trailing_width, trailing_prec, 0);\n    }\n}\n\n \nNODISCARD\nstatic bool\nout_file_context (char *pformat, size_t prefix_len, char const *filename)\n{\n  char *scontext;\n  bool fail = false;\n\n  if ((follow_links\n       ? getfilecon (filename, &scontext)\n       : lgetfilecon (filename, &scontext)) < 0)\n    {\n      error (0, errno, _(\"failed to get security context of %s\"),\n             quoteaf (filename));\n      scontext = nullptr;\n      fail = true;\n    }\n  strcpy (pformat + prefix_len, \"s\");\n  printf (pformat, (scontext ? scontext : \"?\"));\n  if (scontext)\n    freecon (scontext);\n  return fail;\n}\n\n \nNODISCARD\nstatic bool\nprint_statfs (char *pformat, size_t prefix_len, MAYBE_UNUSED char mod, char m,\n              int fd, char const *filename,\n              void const *data)\n{\n  STRUCT_STATVFS const *statfsbuf = data;\n  bool fail = false;\n\n  switch (m)\n    {\n    case 'n':\n      out_string (pformat, prefix_len, filename);\n      break;\n\n    case 'i':\n      {\n#if STRUCT_STATXFS_F_FSID_IS_INTEGER\n        uintmax_t fsid = statfsbuf->f_fsid;\n#else\n        typedef unsigned int fsid_word;\n        static_assert (alignof (STRUCT_STATVFS) % alignof (fsid_word) == 0);\n        static_assert (offsetof (STRUCT_STATVFS, f_fsid) % alignof (fsid_word)\n                       == 0);\n        static_assert (sizeof statfsbuf->f_fsid % alignof (fsid_word) == 0);\n        fsid_word const *p = (fsid_word *) &statfsbuf->f_fsid;\n\n         \n        uintmax_t fsid = 0;\n        int words = sizeof statfsbuf->f_fsid / sizeof *p;\n        for (int i = 0; i < words && i * sizeof *p < sizeof fsid; i++)\n          {\n            uintmax_t u = p[words - 1 - i];\n            fsid |= u << (i * CHAR_BIT * sizeof *p);\n          }\n#endif\n        out_uint_x (pformat, prefix_len, fsid);\n      }\n      break;\n\n    case 'l':\n      OUT_NAMEMAX (pformat, prefix_len, SB_F_NAMEMAX (statfsbuf));\n      break;\n    case 't':\n#if HAVE_STRUCT_STATXFS_F_TYPE\n      out_uint_x (pformat, prefix_len, statfsbuf->f_type);\n#else\n      fputc ('?', stdout);\n#endif\n      break;\n    case 'T':\n      out_string (pformat, prefix_len, human_fstype (statfsbuf));\n      break;\n    case 'b':\n      out_int (pformat, prefix_len, statfsbuf->f_blocks);\n      break;\n    case 'f':\n      out_int (pformat, prefix_len, statfsbuf->f_bfree);\n      break;\n    case 'a':\n      out_int (pformat, prefix_len, statfsbuf->f_bavail);\n      break;\n    case 's':\n      out_uint (pformat, prefix_len, statfsbuf->f_bsize);\n      break;\n    case 'S':\n      {\n        uintmax_t frsize = STATFS_FRSIZE (statfsbuf);\n        if (! frsize)\n          frsize = statfsbuf->f_bsize;\n        out_uint (pformat, prefix_len, frsize);\n      }\n      break;\n    case 'c':\n      out_uint (pformat, prefix_len, statfsbuf->f_files);\n      break;\n    case 'd':\n      out_int (pformat, prefix_len, statfsbuf->f_ffree);\n      break;\n    default:\n      fputc ('?', stdout);\n      break;\n    }\n  return fail;\n}\n\n \nNODISCARD\nstatic char const *\nfind_bind_mount (char const * name)\n{\n  char const * bind_mount = nullptr;\n\n  static struct mount_entry *mount_list;\n  static bool tried_mount_list = false;\n  if (!tried_mount_list)  \n    {\n      if (!(mount_list = read_file_system_list (false)))\n        error (0, errno, \"%s\", _(\"cannot read table of mounted file systems\"));\n      tried_mount_list = true;\n    }\n\n  struct stat name_stats;\n  if (stat (name, &name_stats) != 0)\n    return nullptr;\n\n  struct mount_entry *me;\n  for (me = mount_list; me; me = me->me_next)\n    {\n      if (me->me_dummy && me->me_devname[0] == '/'\n          && STREQ (me->me_mountdir, name))\n        {\n          struct stat dev_stats;\n\n          if (stat (me->me_devname, &dev_stats) == 0\n              && SAME_INODE (name_stats, dev_stats))\n            {\n              bind_mount = me->me_devname;\n              break;\n            }\n        }\n    }\n\n  return bind_mount;\n}\n\n \nNODISCARD\nstatic bool\nout_mount_point (char const *filename, char *pformat, size_t prefix_len,\n                 const struct stat *statp)\n{\n\n  char const *np = \"?\", *bp = nullptr;\n  char *mp = nullptr;\n  bool fail = true;\n\n   \n  if (follow_links || !S_ISLNK (statp->st_mode))\n    {\n      char *resolved = canonicalize_file_name (filename);\n      if (!resolved)\n        {\n          error (0, errno, _(\"failed to canonicalize %s\"), quoteaf (filename));\n          goto print_mount_point;\n        }\n      bp = find_bind_mount (resolved);\n      free (resolved);\n      if (bp)\n        {\n          fail = false;\n          goto print_mount_point;\n        }\n    }\n\n   \n  if ((mp = find_mount_point (filename, statp)))\n    {\n       \n      bp = find_bind_mount (mp);\n      fail = false;\n    }\n\nprint_mount_point:\n\n  out_string (pformat, prefix_len, bp ? bp : mp ? mp : np);\n  free (mp);\n  return fail;\n}\n\n \nstatic inline struct timespec\nneg_to_zero (struct timespec ts)\n{\n  if (0 <= ts.tv_nsec)\n    return ts;\n  struct timespec z = {0, 0};\n  return z;\n}\n\n \n\nstatic void\ngetenv_quoting_style (void)\n{\n  char const *q_style = getenv (\"QUOTING_STYLE\");\n  if (q_style)\n    {\n      int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);\n      if (0 <= i)\n        set_quoting_style (nullptr, quoting_style_vals[i]);\n      else\n        {\n          set_quoting_style (nullptr, shell_escape_always_quoting_style);\n          error (0, 0, _(\"ignoring invalid value of environment \"\n                         \"variable QUOTING_STYLE: %s\"), quote (q_style));\n        }\n    }\n  else\n    set_quoting_style (nullptr, shell_escape_always_quoting_style);\n}\n\n \n#define quoteN(x) quotearg_style (get_quoting_style (nullptr), x)\n\n \n\nstatic void\nprint_esc_char (char c)\n{\n  switch (c)\n    {\n    case 'a':\t\t\t \n      c ='\\a';\n      break;\n    case 'b':\t\t\t \n      c ='\\b';\n      break;\n    case 'e':\t\t\t \n      c ='\\x1B';\n      break;\n    case 'f':\t\t\t \n      c ='\\f';\n      break;\n    case 'n':\t\t\t \n      c ='\\n';\n      break;\n    case 'r':\t\t\t \n      c ='\\r';\n      break;\n    case 't':\t\t\t \n      c ='\\t';\n      break;\n    case 'v':\t\t\t \n      c ='\\v';\n      break;\n    case '\"':\n    case '\\\\':\n      break;\n    default:\n      error (0, 0, _(\"warning: unrecognized escape '\\\\%c'\"), c);\n      break;\n    }\n  putchar (c);\n}\n\nATTRIBUTE_PURE\nstatic size_t\nformat_code_offset (char const *directive)\n{\n  size_t len = strspn (directive + 1, printf_flags);\n  char const *fmt_char = directive + len + 1;\n  fmt_char += strspn (fmt_char, digits);\n  if (*fmt_char == '.')\n    fmt_char += 1 + strspn (fmt_char + 1, digits);\n  return fmt_char - directive;\n}\n\n \nNODISCARD\nstatic bool\nprint_it (char const *format, int fd, char const *filename,\n          bool (*print_func) (char *, size_t, char, char,\n                              int, char const *, void const *),\n          void const *data)\n{\n  bool fail = false;\n\n   \n  enum\n    {\n      MAX_ADDITIONAL_BYTES =\n        (MAX (sizeof PRIdMAX,\n              MAX (sizeof PRIoMAX, MAX (sizeof PRIuMAX, sizeof PRIxMAX)))\n         - 1)\n    };\n  size_t n_alloc = strlen (format) + MAX_ADDITIONAL_BYTES + 1;\n  char *dest = xmalloc (n_alloc);\n  char const *b;\n  for (b = format; *b; b++)\n    {\n      switch (*b)\n        {\n        case '%':\n          {\n            size_t len = format_code_offset (b);\n            char fmt_char = *(b + len);\n            char mod_char = 0;\n            memcpy (dest, b, len);\n            b += len;\n\n            switch (fmt_char)\n              {\n              case '\\0':\n                --b;\n                FALLTHROUGH;\n              case '%':\n                if (1 < len)\n                  {\n                    dest[len] = fmt_char;\n                    dest[len + 1] = '\\0';\n                    error (EXIT_FAILURE, 0, _(\"%s: invalid directive\"),\n                           quote (dest));\n                  }\n                putchar ('%');\n                break;\n              case 'H':\n              case 'L':\n                mod_char = fmt_char;\n                fmt_char = *(b + 1);\n                if (print_func == print_stat\n                    && (fmt_char == 'd' || fmt_char == 'r'))\n                  {\n                    b++;\n                  }\n                else\n                  {\n                    fmt_char = mod_char;\n                    mod_char = 0;\n                  }\n                FALLTHROUGH;\n              default:\n                fail |= print_func (dest, len, mod_char, fmt_char,\n                                    fd, filename, data);\n                break;\n              }\n            break;\n          }\n\n        case '\\\\':\n          if ( ! interpret_backslash_escapes)\n            {\n              putchar ('\\\\');\n              break;\n            }\n          ++b;\n          if (isodigit (*b))\n            {\n              int esc_value = octtobin (*b);\n              int esc_length = 1;\t \n              for (++b; esc_length < 3 && isodigit (*b);\n                   ++esc_length, ++b)\n                {\n                  esc_value = esc_value * 8 + octtobin (*b);\n                }\n              putchar (esc_value);\n              --b;\n            }\n          else if (*b == 'x' && isxdigit (to_uchar (b[1])))\n            {\n              int esc_value = hextobin (b[1]);\t \n               \n              ++b;\n              if (isxdigit (to_uchar (b[1])))\n                {\n                  ++b;\n                  esc_value = esc_value * 16 + hextobin (*b);\n                }\n              putchar (esc_value);\n            }\n          else if (*b == '\\0')\n            {\n              error (0, 0, _(\"warning: backslash at end of format\"));\n              putchar ('\\\\');\n               \n              --b;\n            }\n          else\n            {\n              print_esc_char (*b);\n            }\n          break;\n\n        default:\n          putchar (*b);\n          break;\n        }\n    }\n  free (dest);\n\n  fputs (trailing_delim, stdout);\n\n  return fail;\n}\n\n \nNODISCARD\nstatic bool\ndo_statfs (char const *filename, char const *format)\n{\n  STRUCT_STATVFS statfsbuf;\n\n  if (STREQ (filename, \"-\"))\n    {\n      error (0, 0, _(\"using %s to denote standard input does not work\"\n                     \" in file system mode\"), quoteaf (filename));\n      return false;\n    }\n\n  if (STATFS (filename, &statfsbuf) != 0)\n    {\n      error (0, errno, _(\"cannot read file system information for %s\"),\n             quoteaf (filename));\n      return false;\n    }\n\n  bool fail = print_it (format, -1, filename, print_statfs, &statfsbuf);\n  return ! fail;\n}\n\nstruct print_args {\n  struct stat *st;\n  struct timespec btime;\n};\n\n \nstatic bool dont_sync;\n\n \nstatic bool force_sync;\n\n#if USE_STATX\nstatic unsigned int\nfmt_to_mask (char fmt)\n{\n  switch (fmt)\n    {\n    case 'N':\n      return STATX_MODE;\n    case 'd':\n    case 'D':\n      return STATX_MODE;\n    case 'i':\n      return STATX_INO;\n    case 'a':\n    case 'A':\n      return STATX_MODE;\n    case 'f':\n      return STATX_MODE|STATX_TYPE;\n    case 'F':\n      return STATX_TYPE;\n    case 'h':\n      return STATX_NLINK;\n    case 'u':\n    case 'U':\n      return STATX_UID;\n    case 'g':\n    case 'G':\n      return STATX_GID;\n    case 'm':\n      return STATX_MODE|STATX_INO;\n    case 's':\n      return STATX_SIZE;\n    case 't':\n    case 'T':\n      return STATX_MODE;\n    case 'b':\n      return STATX_BLOCKS;\n    case 'w':\n    case 'W':\n      return STATX_BTIME;\n    case 'x':\n    case 'X':\n      return STATX_ATIME;\n    case 'y':\n    case 'Y':\n      return STATX_MTIME;\n    case 'z':\n    case 'Z':\n      return STATX_CTIME;\n    }\n  return 0;\n}\n\nATTRIBUTE_PURE\nstatic unsigned int\nformat_to_mask (char const *format)\n{\n  unsigned int mask = 0;\n  char const *b;\n\n  for (b = format; *b; b++)\n    {\n      if (*b != '%')\n        continue;\n\n      b += format_code_offset (b);\n      if (*b == '\\0')\n        break;\n      mask |= fmt_to_mask (*b);\n    }\n  return mask;\n}\n\n \nNODISCARD\nstatic bool\ndo_stat (char const *filename, char const *format, char const *format2)\n{\n  int fd = STREQ (filename, \"-\") ? 0 : AT_FDCWD;\n  int flags = 0;\n  struct stat st;\n  struct statx stx = { 0, };\n  char const *pathname = filename;\n  struct print_args pa;\n  pa.st = &st;\n  pa.btime = (struct timespec) {-1, -1};\n\n  if (AT_FDCWD != fd)\n    {\n      pathname = \"\";\n      flags = AT_EMPTY_PATH;\n    }\n  else if (!follow_links)\n    {\n      flags = AT_SYMLINK_NOFOLLOW;\n    }\n\n  if (dont_sync)\n    flags |= AT_STATX_DONT_SYNC;\n  else if (force_sync)\n    flags |= AT_STATX_FORCE_SYNC;\n\n  if (! force_sync)\n    flags |= AT_NO_AUTOMOUNT;\n\n  fd = statx (fd, pathname, flags, format_to_mask (format), &stx);\n  if (fd < 0)\n    {\n      if (flags & AT_EMPTY_PATH)\n        error (0, errno, _(\"cannot stat standard input\"));\n      else\n        error (0, errno, _(\"cannot statx %s\"), quoteaf (filename));\n      return false;\n    }\n\n  if (S_ISBLK (stx.stx_mode) || S_ISCHR (stx.stx_mode))\n    format = format2;\n\n  statx_to_stat (&stx, &st);\n  if (stx.stx_mask & STATX_BTIME)\n    pa.btime = statx_timestamp_to_timespec (stx.stx_btime);\n\n  bool fail = print_it (format, fd, filename, print_stat, &pa);\n  return ! fail;\n}\n\n#else  \n\nstatic struct timespec\nget_birthtime (int fd, char const *filename, struct stat const *st)\n{\n  struct timespec ts = get_stat_birthtime (st);\n\n# if HAVE_GETATTRAT\n  if (ts.tv_nsec < 0)\n    {\n      nvlist_t *response;\n      if ((fd < 0\n           ? getattrat (AT_FDCWD, XATTR_VIEW_READWRITE, filename, &response)\n           : fgetattr (fd, XATTR_VIEW_READWRITE, &response))\n          == 0)\n        {\n          uint64_t *val;\n          uint_t n;\n          if (nvlist_lookup_uint64_array (response, A_CRTIME, &val, &n) == 0\n              && 2 <= n\n              && val[0] <= TYPE_MAXIMUM (time_t)\n              && val[1] < 1000000000 * 2  )\n            {\n              ts.tv_sec = val[0];\n              ts.tv_nsec = val[1];\n            }\n          nvlist_free (response);\n        }\n    }\n# endif\n\n  return ts;\n}\n\n\n \nNODISCARD\nstatic bool\ndo_stat (char const *filename, char const *format,\n         char const *format2)\n{\n  int fd = STREQ (filename, \"-\") ? 0 : -1;\n  struct stat statbuf;\n  struct print_args pa;\n  pa.st = &statbuf;\n  pa.btime = (struct timespec) {-1, -1};\n\n  if (0 <= fd)\n    {\n      if (fstat (fd, &statbuf) != 0)\n        {\n          error (0, errno, _(\"cannot stat standard input\"));\n          return false;\n        }\n    }\n   \n  else if ((follow_links\n            ? stat (filename, &statbuf)\n            : lstat (filename, &statbuf)) != 0)\n    {\n      error (0, errno, _(\"cannot stat %s\"), quoteaf (filename));\n      return false;\n    }\n\n  if (S_ISBLK (statbuf.st_mode) || S_ISCHR (statbuf.st_mode))\n    format = format2;\n\n  bool fail = print_it (format, fd, filename, print_stat, &pa);\n  return ! fail;\n}\n#endif  \n\n \n\nstatic uintmax_t\nunsigned_file_size (off_t size)\n{\n  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);\n}\n\n \nstatic bool\nprint_stat (char *pformat, size_t prefix_len, char mod, char m,\n            int fd, char const *filename, void const *data)\n{\n  struct print_args *parg = (struct print_args *) data;\n  struct stat *statbuf = parg->st;\n  struct timespec btime = parg->btime;\n  struct passwd *pw_ent;\n  struct group *gw_ent;\n  bool fail = false;\n\n  switch (m)\n    {\n    case 'n':\n      out_string (pformat, prefix_len, filename);\n      break;\n    case 'N':\n      out_string (pformat, prefix_len, quoteN (filename));\n      if (S_ISLNK (statbuf->st_mode))\n        {\n          char *linkname = areadlink_with_size (filename, statbuf->st_size);\n          if (linkname == nullptr)\n            {\n              error (0, errno, _(\"cannot read symbolic link %s\"),\n                     quoteaf (filename));\n              return true;\n            }\n          printf (\" -> \");\n          out_string (pformat, prefix_len, quoteN (linkname));\n          free (linkname);\n        }\n      break;\n    case 'd':\n      if (mod == 'H')\n        out_uint (pformat, prefix_len, major (statbuf->st_dev));\n      else if (mod == 'L')\n        out_uint (pformat, prefix_len, minor (statbuf->st_dev));\n      else\n        out_uint (pformat, prefix_len, statbuf->st_dev);\n      break;\n    case 'D':\n      out_uint_x (pformat, prefix_len, statbuf->st_dev);\n      break;\n    case 'i':\n      out_uint (pformat, prefix_len, statbuf->st_ino);\n      break;\n    case 'a':\n      out_uint_o (pformat, prefix_len, statbuf->st_mode & CHMOD_MODE_BITS);\n      break;\n    case 'A':\n      out_string (pformat, prefix_len, human_access (statbuf));\n      break;\n    case 'f':\n      out_uint_x (pformat, prefix_len, statbuf->st_mode);\n      break;\n    case 'F':\n      out_string (pformat, prefix_len, file_type (statbuf));\n      break;\n    case 'h':\n      out_uint (pformat, prefix_len, statbuf->st_nlink);\n      break;\n    case 'u':\n      out_uint (pformat, prefix_len, statbuf->st_uid);\n      break;\n    case 'U':\n      pw_ent = getpwuid (statbuf->st_uid);\n      out_string (pformat, prefix_len,\n                  pw_ent ? pw_ent->pw_name : \"UNKNOWN\");\n      break;\n    case 'g':\n      out_uint (pformat, prefix_len, statbuf->st_gid);\n      break;\n    case 'G':\n      gw_ent = getgrgid (statbuf->st_gid);\n      out_string (pformat, prefix_len,\n                  gw_ent ? gw_ent->gr_name : \"UNKNOWN\");\n      break;\n    case 'm':\n      fail |= out_mount_point (filename, pformat, prefix_len, statbuf);\n      break;\n    case 's':\n      out_uint (pformat, prefix_len, unsigned_file_size (statbuf->st_size));\n      break;\n    case 'r':\n      if (mod == 'H')\n        out_uint (pformat, prefix_len, major (statbuf->st_rdev));\n      else if (mod == 'L')\n        out_uint (pformat, prefix_len, minor (statbuf->st_rdev));\n      else\n        out_uint (pformat, prefix_len, statbuf->st_rdev);\n      break;\n    case 'R':\n      out_uint_x (pformat, prefix_len, statbuf->st_rdev);\n      break;\n    case 't':\n      out_uint_x (pformat, prefix_len, major (statbuf->st_rdev));\n      break;\n    case 'T':\n      out_uint_x (pformat, prefix_len, minor (statbuf->st_rdev));\n      break;\n    case 'B':\n      out_uint (pformat, prefix_len, ST_NBLOCKSIZE);\n      break;\n    case 'b':\n      out_uint (pformat, prefix_len, ST_NBLOCKS (*statbuf));\n      break;\n    case 'o':\n      out_uint (pformat, prefix_len, ST_BLKSIZE (*statbuf));\n      break;\n    case 'w':\n      {\n#if ! USE_STATX\n        btime = get_birthtime (fd, filename, statbuf);\n#endif\n        if (btime.tv_nsec < 0)\n          out_string (pformat, prefix_len, \"-\");\n        else\n          out_string (pformat, prefix_len, human_time (btime));\n      }\n      break;\n    case 'W':\n      {\n#if ! USE_STATX\n        btime = get_birthtime (fd, filename, statbuf);\n#endif\n        out_epoch_sec (pformat, prefix_len, neg_to_zero (btime));\n      }\n      break;\n    case 'x':\n      out_string (pformat, prefix_len, human_time (get_stat_atime (statbuf)));\n      break;\n    case 'X':\n      out_epoch_sec (pformat, prefix_len, get_stat_atime (statbuf));\n      break;\n    case 'y':\n      out_string (pformat, prefix_len, human_time (get_stat_mtime (statbuf)));\n      break;\n    case 'Y':\n      out_epoch_sec (pformat, prefix_len, get_stat_mtime (statbuf));\n      break;\n    case 'z':\n      out_string (pformat, prefix_len, human_time (get_stat_ctime (statbuf)));\n      break;\n    case 'Z':\n      out_epoch_sec (pformat, prefix_len, get_stat_ctime (statbuf));\n      break;\n    case 'C':\n      fail |= out_file_context (pformat, prefix_len, filename);\n      break;\n    default:\n      fputc ('?', stdout);\n      break;\n    }\n  return fail;\n}\n\n \nstatic char *\ndefault_format (bool fs, bool terse, bool device)\n{\n  char *format;\n  if (fs)\n    {\n      if (terse)\n        format = xstrdup (fmt_terse_fs);\n      else\n        {\n           \n          format = xstrdup (_(\"  File: \\\"%n\\\"\\n\"\n                              \"    ID: %-8i Namelen: %-7l Type: %T\\n\"\n                              \"Block size: %-10s Fundamental block size: %S\\n\"\n                              \"Blocks: Total: %-10b Free: %-10f Available: %a\\n\"\n                              \"Inodes: Total: %-10c Free: %d\\n\"));\n        }\n    }\n  else  \n    {\n      if (terse)\n        {\n          if (0 < is_selinux_enabled ())\n            format = xstrdup (fmt_terse_selinux);\n          else\n            format = xstrdup (fmt_terse_regular);\n        }\n      else\n        {\n          char *temp;\n           \n          format = xstrdup (_(\"\\\n  File: %N\\n\\\n  Size: %-10s\\tBlocks: %-10b IO Block: %-6o %F\\n\\\n\"));\n\n          temp = format;\n          if (device)\n            {\n              /* TRANSLATORS: This string uses format specifiers from\n                 'stat --help' without --file-system, and NOT from printf.  */\n              format = xasprintf (\"%s%s\", format, _(\"\\\n\" \"Device: %Hd,%Ld\\tInode: %-10i  Links: %-5h Device type: %Hr,%Lr\\n\\\n\"));\n            }\n          else\n            {\n              /* TRANSLATORS: This string uses format specifiers from\n                 'stat --help' without --file-system, and NOT from printf.  */\n              format = xasprintf (\"%s%s\", format, _(\"\\\n\" \"Device: %Hd,%Ld\\tInode: %-10i  Links: %h\\n\\\n\"));\n            }\n          free (temp);\n\n          temp = format;\n          /* TRANSLATORS: This string uses format specifiers from\n             'stat --help' without --file-system, and NOT from printf.  */\n          format = xasprintf (\"%s%s\", format, _(\"\\\n\" \"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\\n\\\n\"));\n          free (temp);\n\n          if (0 < is_selinux_enabled ())\n            {\n              temp = format;\n              /* TRANSLATORS: This string uses format specifiers from\n                 'stat --help' without --file-system, and NOT from printf.  */\n              format = xasprintf (\"%s%s\", format, _(\"Context: %C\\n\"));\n              free (temp);\n            }\n\n          temp = format;\n          /* TRANSLATORS: This string uses format specifiers from\n             'stat --help' without --file-system, and NOT from printf.  */\n          format = xasprintf (\"%s%s\", format,\n                              _(\"Access: %x\\n\"\n                                \"Modify: %y\\n\"\n                                \"Change: %z\\n\"\n                                \" Birth: %w\\n\"));\n          free (temp);\n        }\n    }\n  return format;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... FILE...\\n\"), program_name);\n      fputs (_(\"\\\nDisplay file or file system status.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -L, --dereference     follow links\\n\\\n  -f, --file-system     display file system status instead of file status\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --cached=MODE     specify how to use cached attributes;\\n\\\n                          useful on remote file systems. See MODE below\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -c  --format=FORMAT   use the specified FORMAT instead of the default;\\n\\\n                          output a newline after each use of FORMAT\\n\\\n      --printf=FORMAT   like --format, but interpret backslash escapes,\\n\\\n                          and do not output a mandatory trailing newline;\\n\\\n                          if you want a newline, include \\\\n in FORMAT\\n\\\n  -t, --terse           print the information in terse form\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n\n      fputs (_(\"\\n\\\nThe MODE argument of --cached can be: always, never, or default.\\n\\\n'always' will use cached attributes if available, while\\n\\\n'never' will try to synchronize with the latest attributes, and\\n\\\n'default' will leave it up to the underlying file system.\\n\\\n\"), stdout);\n\n      fputs (_(\"\\n\\\nThe valid format sequences for files (without --file-system):\\n\\\n\\n\\\n  %a   permission bits in octal (note '#' and '0' printf flags)\\n\\\n  %A   permission bits and file type in human readable form\\n\\\n  %b   number of blocks allocated (see %B)\\n\\\n  %B   the size in bytes of each block reported by %b\\n\\\n  %C   SELinux security context string\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %d   device number in decimal (st_dev)\\n\\\n  %D   device number in hex (st_dev)\\n\\\n  %Hd  major device number in decimal\\n\\\n  %Ld  minor device number in decimal\\n\\\n  %f   raw mode in hex\\n\\\n  %F   file type\\n\\\n  %g   group ID of owner\\n\\\n  %G   group name of owner\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %h   number of hard links\\n\\\n  %i   inode number\\n\\\n  %m   mount point\\n\\\n  %n   file name\\n\\\n  %N   quoted file name with dereference if symbolic link\\n\\\n  %o   optimal I/O transfer size hint\\n\\\n  %s   total size, in bytes\\n\\\n  %r   device type in decimal (st_rdev)\\n\\\n  %R   device type in hex (st_rdev)\\n\\\n  %Hr  major device type in decimal, for character/block device special files\\n\\\n  %Lr  minor device type in decimal, for character/block device special files\\n\\\n  %t   major device type in hex, for character/block device special files\\n\\\n  %T   minor device type in hex, for character/block device special files\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %u   user ID of owner\\n\\\n  %U   user name of owner\\n\\\n  %w   time of file birth, human-readable; - if unknown\\n\\\n  %W   time of file birth, seconds since Epoch; 0 if unknown\\n\\\n  %x   time of last access, human-readable\\n\\\n  %X   time of last access, seconds since Epoch\\n\\\n  %y   time of last data modification, human-readable\\n\\\n  %Y   time of last data modification, seconds since Epoch\\n\\\n  %z   time of last status change, human-readable\\n\\\n  %Z   time of last status change, seconds since Epoch\\n\\\n\\n\\\n\"), stdout);\n\n      fputs (_(\"\\\nValid format sequences for file systems:\\n\\\n\\n\\\n  %a   free blocks available to non-superuser\\n\\\n  %b   total data blocks in file system\\n\\\n  %c   total file nodes in file system\\n\\\n  %d   free file nodes in file system\\n\\\n  %f   free blocks in file system\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %i   file system ID in hex\\n\\\n  %l   maximum length of filenames\\n\\\n  %n   file name\\n\\\n  %s   block size (for faster transfers)\\n\\\n  %S   fundamental block size (for block counts)\\n\\\n  %t   file system type in hex\\n\\\n  %T   file system type in human readable form\\n\\\n\"), stdout);\n\n      printf (_(\"\\n\\\n--terse is equivalent to the following FORMAT:\\n\\\n    %s\\\n\"),\n#if HAVE_SELINUX_SELINUX_H\n              fmt_terse_selinux\n#else\n              fmt_terse_regular\n#endif\n              );\n\n        printf (_(\"\\\n--terse --file-system is equivalent to the following FORMAT:\\n\\\n    %s\\\n\"), fmt_terse_fs);\n\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int c;\n  bool fs = false;\n  bool terse = false;\n  char *format = nullptr;\n  char *format2;\n  bool ok = true;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  struct lconv const *locale = localeconv ();\n  decimal_point = (locale->decimal_point[0] ? locale->decimal_point : \".\");\n  decimal_point_len = strlen (decimal_point);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \"c:fLt\", long_options, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case PRINTF_OPTION:\n          format = optarg;\n          interpret_backslash_escapes = true;\n          trailing_delim = \"\";\n          break;\n\n        case 'c':\n          format = optarg;\n          interpret_backslash_escapes = false;\n          trailing_delim = \"\\n\";\n          break;\n\n        case 'L':\n          follow_links = true;\n          break;\n\n        case 'f':\n          fs = true;\n          break;\n\n        case 't':\n          terse = true;\n          break;\n\n        case 0:\n          switch (XARGMATCH (\"--cached\", optarg, cached_args, cached_modes))\n            {\n              case cached_never:\n                force_sync = true;\n                dont_sync = false;\n                break;\n              case cached_always:\n                force_sync = false;\n                dont_sync = true;\n                break;\n              case cached_default:\n                force_sync = false;\n                dont_sync = false;\n            }\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (argc == optind)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (format)\n    {\n      if (strstr (format, \"%N\"))\n        getenv_quoting_style ();\n      format2 = format;\n    }\n  else\n    {\n      format = default_format (fs, terse,   false);\n      format2 = default_format (fs, terse,   true);\n    }\n\n  for (int i = optind; i < argc; i++)\n    ok &= (fs\n           ? do_statfs (argv[i], format)\n           : do_stat (argv[i], format, format2));\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}