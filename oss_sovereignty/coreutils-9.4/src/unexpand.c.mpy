{
  "module_name": "unexpand.c",
  "hash_id": "f57e8bc568218faa2dc4cfc9c1b0d6a66ee20855d761c911dc2c1c5d034606c4",
  "original_prompt": "Ingested from coreutils-9.4/src/unexpand.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"expand-common.h\"\n\n \n#define PROGRAM_NAME \"unexpand\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\n\n\n \nenum\n{\n  CONVERT_FIRST_ONLY_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const longopts[] =\n{\n  {\"tabs\", required_argument, nullptr, 't'},\n  {\"all\", no_argument, nullptr, 'a'},\n  {\"first-only\", no_argument, nullptr, CONVERT_FIRST_ONLY_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nConvert blanks in each FILE to tabs, writing to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -a, --all        convert all blanks, instead of just initial blanks\\n\\\n      --first-only  convert only leading sequences of blanks (overrides -a)\\n\\\n  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\\n\\\n\"), stdout);\n      emit_tab_list_info ();\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Change blanks to tabs, writing to stdout.\n   Read each file in 'file_list', in order.  */\n\nstatic void\nunexpand (void)\n{\n  /* Input stream.  */\n  FILE *fp = next_file (nullptr);\n\n  /* The array of pending blanks.  In non-POSIX locales, blanks can\n     include characters other than spaces, so the blanks must be\n     stored, not merely counted.  */\n  char *pending_blank;\n\n  if (!fp)\n    return;\n\n  /* The worst case is a non-blank character, then one blank, then a\n     tab stop, then MAX_COLUMN_WIDTH - 1 blanks, then a non-blank; so\n     allocate MAX_COLUMN_WIDTH bytes to store the blanks.  */\n  pending_blank = xmalloc (max_column_width);\n\n  while (true)\n    {\n      /* Input character, or EOF.  */\n      int c;\n\n      /* If true, perform translations.  */\n      bool convert = true;\n\n\n      /* The following variables have valid values only when CONVERT\n         is true:  */\n\n      /* Column of next input character.  */\n      uintmax_t column = 0;\n\n      /* Column the next input tab stop is on.  */\n      uintmax_t next_tab_column = 0;\n\n      /* Index in TAB_LIST of next tab stop to examine.  */\n      size_t tab_index = 0;\n\n      /* If true, the first pending blank came just before a tab stop.  */\n      bool one_blank_before_tab_stop = false;\n\n      /* If true, the previous input character was a blank.  This is\n         initially true, since initial strings of blanks are treated\n         as if the line was preceded by a blank.  */\n      bool prev_blank = true;\n\n      /* Number of pending columns of blanks.  */\n      size_t pending = 0;\n\n\n      /* Convert a line of text.  */\n\n      do\n        {\n          while ((c = getc (fp)) < 0 && (fp = next_file (fp)))\n            continue;\n\n          if (convert)\n            {\n              bool blank = !! isblank (c);\n\n              if (blank)\n                {\n                  bool last_tab;\n\n                  next_tab_column = get_next_tab_column (column, &tab_index,\n                                                         &last_tab);\n\n                  if (last_tab)\n                    convert = false;\n\n                  if (convert)\n                    {\n                      if (next_tab_column < column)\n                        error (EXIT_FAILURE, 0, _(\"input line is too long\"));\n\n                      if (c == '\\t')\n                        {\n                          column = next_tab_column;\n\n                          if (pending)\n                            pending_blank[0] = '\\t';\n                        }\n                      else\n                        {\n                          column++;\n\n                          if (! (prev_blank && column == next_tab_column))\n                            {\n                              /* It is not yet known whether the pending blanks\n                                 will be replaced by tabs.  */\n                              if (column == next_tab_column)\n                                one_blank_before_tab_stop = true;\n                              pending_blank[pending++] = c;\n                              prev_blank = true;\n                              continue;\n                            }\n\n                          /* Replace the pending blanks by a tab or two.  */\n                          pending_blank[0] = c = '\\t';\n                        }\n\n                      /* Discard pending blanks, unless it was a single\n                         blank just before the previous tab stop.  */\n                      pending = one_blank_before_tab_stop;\n                    }\n                }\n              else if (c == '\\b')\n                {\n                  /* Go back one column, and force recalculation of the\n                     next tab stop.  */\n                  column -= !!column;\n                  next_tab_column = column;\n                  tab_index -= !!tab_index;\n                }\n              else\n                {\n                  column++;\n                  if (!column)\n                    error (EXIT_FAILURE, 0, _(\"input line is too long\"));\n                }\n\n              if (pending)\n                {\n                  if (pending > 1 && one_blank_before_tab_stop)\n                    pending_blank[0] = '\\t';\n                  if (fwrite (pending_blank, 1, pending, stdout) != pending)\n                    write_error ();\n                  pending = 0;\n                  one_blank_before_tab_stop = false;\n                }\n\n              prev_blank = blank;\n              convert &= convert_entire_line || blank;\n            }\n\n          if (c < 0)\n            {\n              free (pending_blank);\n              return;\n            }\n\n          if (putchar (c) < 0)\n            write_error ();\n        }\n      while (c != '\\n');\n    }\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool have_tabval = false;\n  uintmax_t tabval IF_LINT ( = 0);\n  int c;\n\n  /* If true, cancel the effect of any -a (explicit or implicit in -t),\n     so that only leading blanks will be considered.  */\n  bool convert_first_only = false;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((c = getopt_long (argc, argv, \",0123456789at:\", longopts, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case '?':\n          usage (EXIT_FAILURE);\n        case 'a':\n          convert_entire_line = true;\n          break;\n        case 't':\n          convert_entire_line = true;\n          parse_tab_stops (optarg);\n          break;\n        case CONVERT_FIRST_ONLY_OPTION:\n          convert_first_only = true;\n          break;\n        case ',':\n          if (have_tabval)\n            add_tab_stop (tabval);\n          have_tabval = false;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          if (!have_tabval)\n            {\n              tabval = 0;\n              have_tabval = true;\n            }\n          if (!DECIMAL_DIGIT_ACCUMULATE (tabval, c - '0', uintmax_t))\n            error (EXIT_FAILURE, 0, _(\"tab stop value is too large\"));\n          break;\n        }\n    }\n\n  if (convert_first_only)\n    convert_entire_line = false;\n\n  if (have_tabval)\n    add_tab_stop (tabval);\n\n  finalize_tab_stops ();\n\n  set_file_list ((optind < argc) ? &argv[optind] : nullptr);\n\n  unexpand ();\n\n  cleanup_file_list_stdin ();\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}