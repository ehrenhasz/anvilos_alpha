{
  "module_name": "chown.c",
  "hash_id": "360365b79993d17e4a486a0349cffdf8fa376b449d130c8e9ab681f7dc0a2985",
  "original_prompt": "Ingested from coreutils-9.4/src/chown.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n\n#include \"system.h\"\n#include \"chown-core.h\"\n#include \"fts_.h\"\n#include \"quote.h\"\n#include \"root-dev-ino.h\"\n#include \"userspec.h\"\n\n \n#define PROGRAM_NAME \"chown\"\n\n#define AUTHORS \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\n \nstatic char *reference_file;\n\n \nenum\n{\n  DEREFERENCE_OPTION = CHAR_MAX + 1,\n  FROM_OPTION,\n  NO_PRESERVE_ROOT,\n  PRESERVE_ROOT,\n  REFERENCE_FILE_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"recursive\", no_argument, nullptr, 'R'},\n  {\"changes\", no_argument, nullptr, 'c'},\n  {\"dereference\", no_argument, nullptr, DEREFERENCE_OPTION},\n  {\"from\", required_argument, nullptr, FROM_OPTION},\n  {\"no-dereference\", no_argument, nullptr, 'h'},\n  {\"no-preserve-root\", no_argument, nullptr, NO_PRESERVE_ROOT},\n  {\"preserve-root\", no_argument, nullptr, PRESERVE_ROOT},\n  {\"quiet\", no_argument, nullptr, 'f'},\n  {\"silent\", no_argument, nullptr, 'f'},\n  {\"reference\", required_argument, nullptr, REFERENCE_FILE_OPTION},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\\n\\\n  or:  %s [OPTION]... --reference=RFILE FILE...\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nChange the owner and/or group of each FILE to OWNER and/or GROUP.\\n\\\nWith --reference, change the owner and group of each FILE to those of RFILE.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -c, --changes          like verbose but report only when a change is made\\n\\\n  -f, --silent, --quiet  suppress most error messages\\n\\\n  -v, --verbose          output a diagnostic for every file processed\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --dereference      affect the referent of each symbolic link (this is\\n\\\n                         the default), rather than the symbolic link itself\\n\\\n  -h, --no-dereference   affect symbolic links instead of any referenced file\\n\\\n\"), stdout);\n      fputs (_(\"\\\n                         (useful only on systems that can change the\\n\\\n                         ownership of a symlink)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --from=CURRENT_OWNER:CURRENT_GROUP\\n\\\n                         change the owner and/or group of each file only if\\n\\\n                         its current owner and/or group match those specified\\n\\\n                         here.  Either may be omitted, in which case a match\\n\\\n                         is not required for the omitted attribute\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --no-preserve-root  do not treat '/' specially (the default)\\n\\\n      --preserve-root    fail to operate recursively on '/'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --reference=RFILE  use RFILE's owner and group rather than specifying\\n\\\n                         OWNER:GROUP values.  RFILE is always dereferenced.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -R, --recursive        operate on files and directories recursively\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nThe following options modify how a hierarchy is traversed when the -R\\n\\\noption is also specified.  If more than one is specified, only the final\\n\\\none takes effect.\\n\\\n\\n\\\n  -H                     if a command line argument is a symbolic link\\n\\\n                         to a directory, traverse it\\n\\\n  -L                     traverse every symbolic link to a directory\\n\\\n                         encountered\\n\\\n  -P                     do not traverse any symbolic links (default)\\n\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nOwner is unchanged if missing.  Group is unchanged if missing, but changed\\n\\\nto login group if implied by a ':' following a symbolic OWNER.\\n\\\nOWNER and GROUP may be numeric as well as symbolic.\\n\\\n\"), stdout);\n      printf (_(\"\\\n\\n\\\nExamples:\\n\\\n  %s root /u        Change the owner of /u to \\\"root\\\".\\n\\\n  %s root:staff /u  Likewise, but also change its group to \\\"staff\\\".\\n\\\n  %s -hR root /u    Change the owner of /u and subfiles to \\\"root\\\".\\n\\\n\"),\n              program_name, program_name, program_name);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool preserve_root = false;\n\n  uid_t uid = -1;\t/* Specified uid; -1 if not to be changed. */\n  gid_t gid = -1;\t/* Specified gid; -1 if not to be changed. */\n\n  /* Change the owner (group) of a file only if it has this uid (gid).\n     -1 means there's no restriction.  */\n  uid_t required_uid = -1;\n  gid_t required_gid = -1;\n\n  /* Bit flags that control how fts works.  */\n  int bit_flags = FTS_PHYSICAL;\n\n  /* 1 if --dereference, 0 if --no-dereference, -1 if neither has been\n     specified.  */\n  int dereference = -1;\n\n  struct Chown_option chopt;\n  bool ok;\n  int optc;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  chopt_init (&chopt);\n\n  while ((optc = getopt_long (argc, argv, \"HLPRcfhv\", long_options, nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'H': /* Traverse command-line symlinks-to-directories.  */\n          bit_flags = FTS_COMFOLLOW | FTS_PHYSICAL;\n          break;\n\n        case 'L': /* Traverse all symlinks-to-directories.  */\n          bit_flags = FTS_LOGICAL;\n          break;\n\n        case 'P': /* Traverse no symlinks-to-directories.  */\n          bit_flags = FTS_PHYSICAL;\n          break;\n\n        case 'h': /* --no-dereference: affect symlinks */\n          dereference = 0;\n          break;\n\n        case DEREFERENCE_OPTION: /* --dereference: affect the referent\n                                    of each symlink */\n          dereference = 1;\n          break;\n\n        case NO_PRESERVE_ROOT:\n          preserve_root = false;\n          break;\n\n        case PRESERVE_ROOT:\n          preserve_root = true;\n          break;\n\n        case REFERENCE_FILE_OPTION:\n          reference_file = optarg;\n          break;\n\n        case FROM_OPTION:\n          {\n            bool warn;\n            char const *e = parse_user_spec_warn (optarg,\n                                                  &required_uid, &required_gid,\n                                                  nullptr, nullptr, &warn);\n            if (e)\n              error (warn ? 0 : EXIT_FAILURE, 0, \"%s: %s\", e, quote (optarg));\n            break;\n          }\n\n        case 'R':\n          chopt.recurse = true;\n          break;\n\n        case 'c':\n          chopt.verbosity = V_changes_only;\n          break;\n\n        case 'f':\n          chopt.force_silent = true;\n          break;\n\n        case 'v':\n          chopt.verbosity = V_high;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (chopt.recurse)\n    {\n      if (bit_flags == FTS_PHYSICAL)\n        {\n          if (dereference == 1)\n            error (EXIT_FAILURE, 0,\n                   _(\"-R --dereference requires either -H or -L\"));\n          dereference = 0;\n        }\n    }\n  else\n    {\n      bit_flags = FTS_PHYSICAL;\n    }\n  chopt.affect_symlink_referent = (dereference != 0);\n\n  if (argc - optind < (reference_file ? 1 : 2))\n    {\n      if (argc <= optind)\n        error (0, 0, _(\"missing operand\"));\n      else\n        error (0, 0, _(\"missing operand after %s\"), quote (argv[argc - 1]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (reference_file)\n    {\n      struct stat ref_stats;\n      if (stat (reference_file, &ref_stats))\n        error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n               quoteaf (reference_file));\n\n      uid = ref_stats.st_uid;\n      gid = ref_stats.st_gid;\n      chopt.user_name = uid_to_name (ref_stats.st_uid);\n      chopt.group_name = gid_to_name (ref_stats.st_gid);\n    }\n  else\n    {\n      bool warn;\n      char const *e = parse_user_spec_warn (argv[optind], &uid, &gid,\n                                            &chopt.user_name,\n                                            &chopt.group_name, &warn);\n      if (e)\n        error (warn ? 0 : EXIT_FAILURE, 0, \"%s: %s\", e, quote (argv[optind]));\n\n      /* If a group is specified but no user, set the user name to the\n         empty string so that diagnostics say \"ownership :GROUP\"\n         rather than \"group GROUP\".  */\n      if (!chopt.user_name && chopt.group_name)\n        chopt.user_name = xstrdup (\"\");\n\n      optind++;\n    }\n\n  if (chopt.recurse && preserve_root)\n    {\n      static struct dev_ino dev_ino_buf;\n      chopt.root_dev_ino = get_root_dev_ino (&dev_ino_buf);\n      if (chopt.root_dev_ino == nullptr)\n        error (EXIT_FAILURE, errno, _(\"failed to get attributes of %s\"),\n               quoteaf (\"/\"));\n    }\n\n  bit_flags |= FTS_DEFER_STAT;\n  ok = chown_files (argv + optind, bit_flags,\n                    uid, gid,\n                    required_uid, required_gid, &chopt);\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}