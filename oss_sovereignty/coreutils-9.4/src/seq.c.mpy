{
  "module_name": "seq.c",
  "hash_id": "f17185790182d349abac34d0c8a075eee114f9bd173eb6017a57dca487eccaff",
  "original_prompt": "Ingested from coreutils-9.4/src/seq.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <sys/types.h>\n\n#include \"system.h\"\n#include \"cl-strtod.h\"\n#include \"quote.h\"\n#include \"xstrtod.h\"\n\n \n#ifndef isfinite\n# define isfinite(x) ((x) * 0 == 0)\n#endif\n#ifndef isnan\n# define isnan(x) ((x) != (x))\n#endif\n\n \n#define SEQ_FAST_STEP_LIMIT 200   \n#define SEQ_FAST_STEP_LIMIT_DIGITS 3\n\n \n#define PROGRAM_NAME \"seq\"\n\n#define AUTHORS proper_name (\"Ulrich Drepper\")\n\n \nstatic bool locale_ok;\n\n \nstatic bool equal_width;\n\n \nstatic char const *separator;\n\n \nstatic char const terminator[] = \"\\n\";\n\nstatic struct option const long_options[] =\n{\n  { \"equal-width\", no_argument, nullptr, 'w'},\n  { \"format\", required_argument, nullptr, 'f'},\n  { \"separator\", required_argument, nullptr, 's'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  { nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... LAST\\n\\\n  or:  %s [OPTION]... FIRST LAST\\n\\\n  or:  %s [OPTION]... FIRST INCREMENT LAST\\n\\\n\"), program_name, program_name, program_name);\n      fputs (_(\"\\\nPrint numbers from FIRST to LAST, in steps of INCREMENT.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -f, --format=FORMAT      use printf style floating-point FORMAT\\n\\\n  -s, --separator=STRING   use STRING to separate numbers (default: \\\\n)\\n\\\n  -w, --equal-width        equalize width by padding with leading zeroes\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nIf FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\\n\\\nomitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\\n\\\nThe sequence of numbers ends when the sum of the current number and\\n\\\nINCREMENT would become greater than LAST.\\n\\\nFIRST, INCREMENT, and LAST are interpreted as floating point values.\\n\\\nINCREMENT is usually positive if FIRST is smaller than LAST, and\\n\\\nINCREMENT is usually negative if FIRST is greater than LAST.\\n\\\nINCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\\n\\\n\"), stdout);\n      fputs (_(\"\\\nFORMAT must be suitable for printing one argument of type 'double';\\n\\\nit defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\\n\\\ndecimal numbers with maximum precision PREC, and to %g otherwise.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* A command-line operand.  */\nstruct operand\n{\n  /* Its value, converted to 'long double'.  */\n  long double value;\n\n  /* Its print width, if it were printed out in a form similar to its\n     input form.  An input like \"-.1\" is treated like \"-0.1\", and an\n     input like \"1.\" is treated like \"1\", but otherwise widths are\n     left alone.  */\n  size_t width;\n\n  /* Number of digits after the decimal point, or INT_MAX if the\n     number can't easily be expressed as a fixed-point number.  */\n  int precision;\n};\ntypedef struct operand operand;\n\n/* Description of what a number-generating format will generate.  */\nstruct layout\n{\n  /* Number of bytes before and after the number.  */\n  size_t prefix_len;\n  size_t suffix_len;\n};\n\n/* Read a long double value from the command line.\n   Return if the string is correct else signal error.  */\n\nstatic operand\nscan_arg (char const *arg)\n{\n  operand ret;\n\n  if (! xstrtold (arg, nullptr, &ret.value, cl_strtold))\n    {\n      error (0, 0, _(\"invalid floating point argument: %s\"), quote (arg));\n      usage (EXIT_FAILURE);\n    }\n\n  if (isnan (ret.value))\n    {\n      error (0, 0, _(\"invalid %s argument: %s\"), quote_n (0, \"not-a-number\"),\n             quote_n (1, arg));\n      usage (EXIT_FAILURE);\n    }\n\n  /* We don't output spaces or '+' so don't include in width */\n  while (isspace (to_uchar (*arg)) || *arg == '+')\n    arg++;\n\n  /* Default to auto width and precision.  */\n  ret.width = 0;\n  ret.precision = INT_MAX;\n\n  /* Use no precision (and possibly fast generation) for integers.  */\n  char const *decimal_point = strchr (arg, '.');\n  if (! decimal_point && ! strchr (arg, 'p') /* not a hex float */)\n    ret.precision = 0;\n\n  /* auto set width and precision for decimal inputs.  */\n  if (! arg[strcspn (arg, \"xX\")] && isfinite (ret.value))\n    {\n      size_t fraction_len = 0;\n      ret.width = strlen (arg);\n\n      if (decimal_point)\n        {\n          fraction_len = strcspn (decimal_point + 1, \"eE\");\n          if (fraction_len <= INT_MAX)\n            ret.precision = fraction_len;\n          ret.width += (fraction_len == 0                      /* #.  -> #   */\n                        ? -1\n                        : (decimal_point == arg                /* .#  -> 0.# */\n                           || ! ISDIGIT (decimal_point[-1]))); /* -.# -> 0.# */\n        }\n      char const *e = strchr (arg, 'e');\n      if (! e)\n        e = strchr (arg, 'E');\n      if (e)\n        {\n          long exponent = MAX (strtol (e + 1, nullptr, 10), -LONG_MAX);\n          ret.precision += exponent < 0 ? -exponent\n                                        : - MIN (ret.precision, exponent);\n          /* Don't account for e.... in the width since this is not output.  */\n          ret.width -= strlen (arg) - (e - arg);\n          /* Adjust the width as per the exponent.  */\n          if (exponent < 0)\n            {\n              if (decimal_point)\n                {\n                  if (e == decimal_point + 1) /* undo #. -> # above  */\n                    ret.width++;\n                }\n              else\n                ret.width++;\n              exponent = -exponent;\n            }\n          else\n            {\n              if (decimal_point && ret.precision == 0 && fraction_len)\n                ret.width--; /* discount space for '.'  */\n              exponent -= MIN (fraction_len, exponent);\n            }\n          ret.width += exponent;\n        }\n    }\n\n  return ret;\n}\n\n/* If FORMAT is a valid printf format for a double argument, return\n   its long double equivalent, allocated from dynamic storage, and\n   store into *LAYOUT a description of the output layout; otherwise,\n   report an error and exit.  */\n\nstatic char const *\nlong_double_format (char const *fmt, struct layout *layout)\n{\n  size_t i;\n  size_t prefix_len = 0;\n  size_t suffix_len = 0;\n  size_t length_modifier_offset;\n  bool has_L;\n\n  for (i = 0; ! (fmt[i] == '%' && fmt[i + 1] != '%'); i += (fmt[i] == '%') + 1)\n    {\n      if (!fmt[i])\n        error (EXIT_FAILURE, 0,\n               _(\"format %s has no %% directive\"), quote (fmt));\n      prefix_len++;\n    }\n\n  i++;\n  i += strspn (fmt + i, \"-+#0 '\");\n  i += strspn (fmt + i, \"0123456789\");\n  if (fmt[i] == '.')\n    {\n      i++;\n      i += strspn (fmt + i, \"0123456789\");\n    }\n\n  length_modifier_offset = i;\n  has_L = (fmt[i] == 'L');\n  i += has_L;\n  if (fmt[i] == '\\0')\n    error (EXIT_FAILURE, 0, _(\"format %s ends in %%\"), quote (fmt));\n  if (! strchr (\"efgaEFGA\", fmt[i]))\n    error (EXIT_FAILURE, 0,\n           _(\"format %s has unknown %%%c directive\"), quote (fmt), fmt[i]);\n\n  for (i++; ; i += (fmt[i] == '%') + 1)\n    if (fmt[i] == '%' && fmt[i + 1] != '%')\n      error (EXIT_FAILURE, 0, _(\"format %s has too many %% directives\"),\n             quote (fmt));\n    else if (fmt[i])\n      suffix_len++;\n    else\n      {\n        size_t format_size = i + 1;\n        char *ldfmt = xmalloc (format_size + 1);\n        memcpy (ldfmt, fmt, length_modifier_offset);\n        ldfmt[length_modifier_offset] = 'L';\n        strcpy (ldfmt + length_modifier_offset + 1,\n                fmt + length_modifier_offset + has_L);\n        layout->prefix_len = prefix_len;\n        layout->suffix_len = suffix_len;\n        return ldfmt;\n      }\n}\n\n/* Actually print the sequence of numbers in the specified range, with the\n   given or default stepping and format.  */\n\nstatic void\nprint_numbers (char const *fmt, struct layout layout,\n               long double first, long double step, long double last)\n{\n  bool out_of_range = (step < 0 ? first < last : last < first);\n\n  if (! out_of_range)\n    {\n      long double x = first;\n      long double i;\n\n      for (i = 1; ; i++)\n        {\n          long double x0 = x;\n          if (printf (fmt, x) < 0)\n            write_error ();\n          if (out_of_range)\n            break;\n          x = first + i * step;\n          out_of_range = (step < 0 ? x < last : last < x);\n\n          if (out_of_range)\n            {\n              /* If the number just past LAST prints as a value equal\n                 to LAST, and prints differently from the previous\n                 number, then print the number.  This avoids problems\n                 with rounding.  For example, with the x86 it causes\n                 \"seq 0 0.000001 0.000003\" to print 0.000003 instead\n                 of stopping at 0.000002.  */\n\n              bool print_extra_number = false;\n              long double x_val;\n              char *x_str;\n              int x_strlen;\n              if (locale_ok)\n                setlocale (LC_NUMERIC, \"C\");\n              x_strlen = asprintf (&x_str, fmt, x);\n              if (locale_ok)\n                setlocale (LC_NUMERIC, \"\");\n              if (x_strlen < 0)\n                xalloc_die ();\n              x_str[x_strlen - layout.suffix_len] = '\\0';\n\n              if (xstrtold (x_str + layout.prefix_len, nullptr,\n                            &x_val, cl_strtold)\n                  && x_val == last)\n                {\n                  char *x0_str = nullptr;\n                  int x0_strlen = asprintf (&x0_str, fmt, x0);\n                  if (x0_strlen < 0)\n                    xalloc_die ();\n                  x0_str[x0_strlen - layout.suffix_len] = '\\0';\n                  print_extra_number = !STREQ (x0_str, x_str);\n                  free (x0_str);\n                }\n\n              free (x_str);\n              if (! print_extra_number)\n                break;\n            }\n\n          if (fputs (separator, stdout) == EOF)\n            write_error ();\n        }\n\n      if (fputs (terminator, stdout) == EOF)\n        write_error ();\n    }\n}\n\n/* Return the default format given FIRST, STEP, and LAST.  */\nstatic char const *\nget_default_format (operand first, operand step, operand last)\n{\n  static char format_buf[sizeof \"%0.Lf\" + 2 * INT_STRLEN_BOUND (int)];\n\n  int prec = MAX (first.precision, step.precision);\n\n  if (prec != INT_MAX && last.precision != INT_MAX)\n    {\n      if (equal_width)\n        {\n          /* increase first_width by any increased precision in step */\n          size_t first_width = first.width + (prec - first.precision);\n          /* adjust last_width to use precision from first/step */\n          size_t last_width = last.width + (prec - last.precision);\n          if (last.precision && prec == 0)\n            last_width--;  /* don't include space for '.' */\n          if (last.precision == 0 && prec)\n            last_width++;   \n          if (first.precision == 0 && prec)\n            first_width++;   \n          size_t width = MAX (first_width, last_width);\n          if (width <= INT_MAX)\n            {\n              int w = width;\n              sprintf (format_buf, \"%%0%d.%dLf\", w, prec);\n              return format_buf;\n            }\n        }\n      else\n        {\n          sprintf (format_buf, \"%%.%dLf\", prec);\n          return format_buf;\n        }\n    }\n\n  return \"%Lg\";\n}\n\n \nstatic void\nincr (char **s0, size_t *s_len)\n{\n  char *s = *s0;\n  char *endp = s + *s_len - 1;\n\n  do\n    {\n      if ((*endp)++ < '9')\n        return;\n      *endp-- = '0';\n    }\n  while (endp >= s);\n  *--(*s0) = '1';\n  ++*s_len;\n}\n\n \nstatic int\ncmp (char const *a, size_t a_len, char const *b, size_t b_len)\n{\n  if (a_len < b_len)\n    return -1;\n  if (b_len < a_len)\n    return 1;\n  return (memcmp (a, b, a_len));\n}\n\n \nATTRIBUTE_PURE\nstatic char const *\ntrim_leading_zeros (char const *s)\n{\n  char const *p = s;\n  while (*s == '0')\n    ++s;\n\n   \n  if (!*s && s != p)\n    --s;\n  return s;\n}\n\n \nstatic void\nseq_fast (char const *a, char const *b, uintmax_t step)\n{\n  bool inf = STREQ (b, \"inf\");\n\n   \n  a = trim_leading_zeros (a);\n  b = trim_leading_zeros (b);\n\n  size_t p_len = strlen (a);\n  size_t q_len = inf ? 0 : strlen (b);\n\n   \n#define INITIAL_ALLOC_DIGITS 31\n  size_t inc_size = MAX (MAX (p_len + 1, q_len), INITIAL_ALLOC_DIGITS);\n   \n  static_assert (SEQ_FAST_STEP_LIMIT_DIGITS < INITIAL_ALLOC_DIGITS - 1);\n\n   \n  char *p0 = xmalloc (inc_size + 1);\n  char *p = memcpy (p0 + inc_size - p_len, a, p_len + 1);\n  char *q;\n  char *q0;\n  if (! inf)\n    {\n      q0 = xmalloc (inc_size + 1);\n      q = memcpy (q0 + inc_size - q_len, b, q_len + 1);\n    }\n  else\n    q = q0 = nullptr;\n\n  bool ok = inf || cmp (p, p_len, q, q_len) <= 0;\n  if (ok)\n    {\n       \n      size_t buf_size = MAX (BUFSIZ, (inc_size + 1) * 2);\n      char *buf = xmalloc (buf_size);\n      char const *buf_end = buf + buf_size;\n\n      char *bufp = buf;\n\n       \n      bufp = mempcpy (bufp, p, p_len);\n\n       \n      while (true)\n        {\n          for (uintmax_t n_incr = step; n_incr; n_incr--)\n            incr (&p, &p_len);\n\n          if (! inf && 0 < cmp (p, p_len, q, q_len))\n            break;\n\n          *bufp++ = *separator;\n\n           \n          if (p_len == inc_size)\n            {\n              inc_size *= 2;\n              p0 = xrealloc (p0, inc_size + 1);\n              p = memmove (p0 + p_len, p0, p_len + 1);\n\n              if (buf_size < (inc_size + 1) * 2)\n                {\n                  size_t buf_offset = bufp - buf;\n                  buf_size = (inc_size + 1) * 2;\n                  buf = xrealloc (buf, buf_size);\n                  buf_end = buf + buf_size;\n                  bufp = buf + buf_offset;\n                }\n            }\n\n          bufp = mempcpy (bufp, p, p_len);\n           \n          if (buf_end - (p_len + 1) < bufp)\n            {\n              if (fwrite (buf, bufp - buf, 1, stdout) != 1)\n                write_error ();\n              bufp = buf;\n            }\n        }\n\n       \n      *bufp++ = *terminator;\n      if (fwrite (buf, bufp - buf, 1, stdout) != 1)\n        write_error ();\n    }\n\n  if (ok)\n    exit (EXIT_SUCCESS);\n\n  free (p0);\n  free (q0);\n}\n\n \nATTRIBUTE_PURE\nstatic bool\nall_digits_p (char const *s)\n{\n  size_t n = strlen (s);\n  return ISDIGIT (s[0]) && n == strspn (s, \"0123456789\");\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  operand first = { 1, 1, 0 };\n  operand step = { 1, 1, 0 };\n  operand last;\n  struct layout layout = { 0, 0 };\n\n   \n  char const *format_str = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  locale_ok = !!setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  equal_width = false;\n  separator = \"\\n\";\n\n   \n  while (optind < argc)\n    {\n      if (argv[optind][0] == '-'\n          && ((optc = argv[optind][1]) == '.' || ISDIGIT (optc)))\n        {\n           \n          break;\n        }\n\n      optc = getopt_long (argc, argv, \"+f:s:w\", long_options, nullptr);\n      if (optc == -1)\n        break;\n\n      switch (optc)\n        {\n        case 'f':\n          format_str = optarg;\n          break;\n\n        case 's':\n          separator = optarg;\n          break;\n\n        case 'w':\n          equal_width = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  int n_args = argc - optind;\n  if (n_args < 1)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (3 < n_args)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 3]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (format_str)\n    format_str = long_double_format (format_str, &layout);\n\n  if (format_str != nullptr && equal_width)\n    {\n      error (0, 0, _(\"format string may not be specified\"\n                     \" when printing equal width strings\"));\n      usage (EXIT_FAILURE);\n    }\n\n   \n  bool fast_step_ok = false;\n  if (n_args != 3\n      || (all_digits_p (argv[optind + 1])\n          && xstrtold (argv[optind + 1], nullptr, &step.value, cl_strtold)\n          && 0 < step.value && step.value <= SEQ_FAST_STEP_LIMIT))\n    fast_step_ok = true;\n\n  if (all_digits_p (argv[optind])\n      && (n_args == 1 || all_digits_p (argv[optind + 1]))\n      && (n_args < 3 || (fast_step_ok\n                         && all_digits_p (argv[optind + 2])))\n      && !equal_width && !format_str && strlen (separator) == 1)\n    {\n      char const *s1 = n_args == 1 ? \"1\" : argv[optind];\n      char const *s2 = argv[optind + (n_args - 1)];\n      seq_fast (s1, s2, step.value);\n\n       \n    }\n\n  last = scan_arg (argv[optind++]);\n\n  if (optind < argc)\n    {\n      first = last;\n      last = scan_arg (argv[optind++]);\n\n      if (optind < argc)\n        {\n          step = last;\n          if (step.value == 0)\n            {\n              error (0, 0, _(\"invalid Zero increment value: %s\"),\n                     quote (argv[optind - 1]));\n              usage (EXIT_FAILURE);\n            }\n\n          last = scan_arg (argv[optind++]);\n        }\n    }\n\n   \n  if (first.precision == 0 && step.precision == 0 && last.precision == 0\n      && isfinite (first.value) && 0 <= first.value && 0 <= last.value\n      && 0 < step.value && step.value <= SEQ_FAST_STEP_LIMIT\n      && !equal_width && !format_str && strlen (separator) == 1)\n    {\n      char *s1;\n      char *s2;\n      if (asprintf (&s1, \"%0.Lf\", first.value) < 0)\n        xalloc_die ();\n      if (! isfinite (last.value))\n        s2 = xstrdup (\"inf\");  \n      else if (asprintf (&s2, \"%0.Lf\", last.value) < 0)\n        xalloc_die ();\n\n      if (*s1 != '-' && *s2 != '-')\n        seq_fast (s1, s2, step.value);\n\n      free (s1);\n      free (s2);\n       \n    }\n\n  if (format_str == nullptr)\n    format_str = get_default_format (first, step, last);\n\n  print_numbers (format_str, layout, first.value, step.value, last.value);\n\n  main_exit (EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}