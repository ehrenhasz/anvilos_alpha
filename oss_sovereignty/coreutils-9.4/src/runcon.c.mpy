{
  "module_name": "runcon.c",
  "hash_id": "2113923fd316dcc45f499c452cdec71b85e6be295132f6ba67adfcbe33adb796",
  "original_prompt": "Ingested from coreutils-9.4/src/runcon.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <selinux/selinux.h>\n#include <selinux/context.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"quote.h\"\n\n \n#define PROGRAM_NAME \"runcon\"\n\n#define AUTHORS proper_name (\"Russell Coker\")\n\nstatic struct option const long_options[] =\n{\n  {\"role\", required_argument, nullptr, 'r'},\n  {\"type\", required_argument, nullptr, 't'},\n  {\"user\", required_argument, nullptr, 'u'},\n  {\"range\", required_argument, nullptr, 'l'},\n  {\"compute\", no_argument, nullptr, 'c'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s CONTEXT COMMAND [args]\\n\\\n  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\\n\\\n\"), program_name, program_name);\n      fputs (_(\"\\\nRun a program in a different SELinux security context.\\n\\\nWith neither CONTEXT nor COMMAND, print the current security context.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  CONTEXT            Complete security context\\n\\\n  -c, --compute      compute process transition context before modifying\\n\\\n  -t, --type=TYPE    type (for same role as parent)\\n\\\n  -u, --user=USER    user identity\\n\\\n  -r, --role=ROLE    role\\n\\\n  -l, --range=RANGE  levelrange\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_exec_status (PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  char *role = nullptr;\n  char *range = nullptr;\n  char *user = nullptr;\n  char *type = nullptr;\n  char *context = nullptr;\n  char *cur_context = nullptr;\n  char *file_context = nullptr;\n  char *new_context = nullptr;\n  bool compute_trans = false;\n\n  context_t con;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (EXIT_CANCELED);\n  atexit (close_stdout);\n\n  while (true)\n    {\n      int option_index = 0;\n      int c = getopt_long (argc, argv, \"+r:t:u:l:c\", long_options,\n                           &option_index);\n      if (c == -1)\n        break;\n      switch (c)\n        {\n        case 'r':\n          if (role)\n            error (EXIT_CANCELED, 0, _(\"multiple roles\"));\n          role = optarg;\n          break;\n        case 't':\n          if (type)\n            error (EXIT_CANCELED, 0, _(\"multiple types\"));\n          type = optarg;\n          break;\n        case 'u':\n          if (user)\n            error (EXIT_CANCELED, 0, _(\"multiple users\"));\n          user = optarg;\n          break;\n        case 'l':\n          if (range)\n            error (EXIT_CANCELED, 0, _(\"multiple levelranges\"));\n          range = optarg;\n          break;\n        case 'c':\n          compute_trans = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_CANCELED);\n          break;\n        }\n    }\n\n  if (argc - optind == 0)\n    {\n      if (getcon (&cur_context) < 0)\n        error (EXIT_CANCELED, errno, _(\"failed to get current context\"));\n      fputs (cur_context, stdout);\n      fputc ('\\n', stdout);\n      return EXIT_SUCCESS;\n    }\n\n  if (!(user || role || type || range || compute_trans))\n    {\n      if (optind >= argc)\n        {\n          error (0, 0, _(\"you must specify -c, -t, -u, -l, -r, or context\"));\n          usage (EXIT_CANCELED);\n        }\n      context = argv[optind++];\n    }\n\n  if (optind >= argc)\n    {\n      error (0, 0, _(\"no command specified\"));\n      usage (EXIT_CANCELED);\n    }\n\n  if (is_selinux_enabled () != 1)\n    error (EXIT_CANCELED, 0, _(\"%s may be used only on a SELinux kernel\"),\n           program_name);\n\n  if (context)\n    {\n      con = context_new (context);\n      if (!con)\n        error (EXIT_CANCELED, errno, _(\"failed to create security context: %s\"),\n               quote (context));\n    }\n  else\n    {\n      if (getcon (&cur_context) < 0)\n        error (EXIT_CANCELED, errno, _(\"failed to get current context\"));\n\n      /* We will generate context based on process transition */\n      if (compute_trans)\n        {\n          /* Get context of file to be executed */\n          if (getfilecon (argv[optind], &file_context) == -1)\n            error (EXIT_CANCELED, errno,\n                   _(\"failed to get security context of %s\"),\n                   quoteaf (argv[optind]));\n          /* compute result of process transition */\n          if (security_compute_create (cur_context, file_context,\n                                       string_to_security_class (\"process\"),\n                                       &new_context) != 0)\n            error (EXIT_CANCELED, errno, _(\"failed to compute a new context\"));\n          /* free contexts */\n          freecon (file_context);\n          freecon (cur_context);\n\n          /* set cur_context equal to new_context */\n          cur_context = new_context;\n        }\n\n      con = context_new (cur_context);\n      if (!con)\n        error (EXIT_CANCELED, errno, _(\"failed to create security context: %s\"),\n               quote (cur_context));\n      if (user && context_user_set (con, user))\n        error (EXIT_CANCELED, errno, _(\"failed to set new user: %s\"),\n               quote (user));\n      if (type && context_type_set (con, type))\n        error (EXIT_CANCELED, errno, _(\"failed to set new type: %s\"),\n               quote (type));\n      if (range && context_range_set (con, range))\n        error (EXIT_CANCELED, errno, _(\"failed to set new range: %s\"),\n               quote (range));\n      if (role && context_role_set (con, role))\n        error (EXIT_CANCELED, errno, _(\"failed to set new role: %s\"),\n               quote (role));\n    }\n\n  if (security_check_context (context_str (con)) < 0)\n    error (EXIT_CANCELED, errno, _(\"invalid context: %s\"),\n           quote (context_str (con)));\n\n  if (setexeccon (context_str (con)) != 0)\n    error (EXIT_CANCELED, errno, _(\"unable to set security context %s\"),\n           quote (context_str (con)));\n  if (cur_context != nullptr)\n    freecon (cur_context);\n\n  (compute_trans ? execv : execvp) (argv[optind], argv + optind);\n\n  int exit_status = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n  error (0, errno, \"%s\", quote (argv[optind]));\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}