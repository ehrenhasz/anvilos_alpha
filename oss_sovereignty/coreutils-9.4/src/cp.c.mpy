{
  "module_name": "cp.c",
  "hash_id": "db366588d5d978c51f0564bc5e1be8c05298f00e458a723a0ce77406cdf839c0",
  "original_prompt": "Ingested from coreutils-9.4/src/cp.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <getopt.h>\n#include <selinux/label.h>\n\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"backupfile.h\"\n#include \"copy.h\"\n#include \"cp-hash.h\"\n#include \"filenamecat.h\"\n#include \"ignore-value.h\"\n#include \"quote.h\"\n#include \"stat-time.h\"\n#include \"targetdir.h\"\n#include \"utimens.h\"\n#include \"acl.h\"\n\n \n#define PROGRAM_NAME \"cp\"\n\n#define AUTHORS \\\n  proper_name_lite (\"Torbjorn Granlund\", \"Torbj\\303\\266rn Granlund\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Jim Meyering\")\n\n \nstruct dir_attr\n{\n  struct stat st;\n  bool restore_mode;\n  size_t slash_offset;\n  struct dir_attr *next;\n};\n\n \nenum\n{\n  ATTRIBUTES_ONLY_OPTION = CHAR_MAX + 1,\n  COPY_CONTENTS_OPTION,\n  DEBUG_OPTION,\n  NO_PRESERVE_ATTRIBUTES_OPTION,\n  PARENTS_OPTION,\n  PRESERVE_ATTRIBUTES_OPTION,\n  REFLINK_OPTION,\n  SPARSE_OPTION,\n  STRIP_TRAILING_SLASHES_OPTION,\n  UNLINK_DEST_BEFORE_OPENING\n};\n\n \nstatic bool selinux_enabled;\n\n \nstatic bool parents_option = false;\n\n \nstatic bool remove_trailing_slashes;\n\nstatic char const *const sparse_type_string[] =\n{\n  \"never\", \"auto\", \"always\", nullptr\n};\nstatic enum Sparse_type const sparse_type[] =\n{\n  SPARSE_NEVER, SPARSE_AUTO, SPARSE_ALWAYS\n};\nARGMATCH_VERIFY (sparse_type_string, sparse_type);\n\nstatic char const *const reflink_type_string[] =\n{\n  \"auto\", \"always\", \"never\", nullptr\n};\nstatic enum Reflink_type const reflink_type[] =\n{\n  REFLINK_AUTO, REFLINK_ALWAYS, REFLINK_NEVER\n};\nARGMATCH_VERIFY (reflink_type_string, reflink_type);\n\nstatic char const *const update_type_string[] =\n{\n  \"all\", \"none\", \"older\", nullptr\n};\nstatic enum Update_type const update_type[] =\n{\n  UPDATE_ALL, UPDATE_NONE, UPDATE_OLDER,\n};\nARGMATCH_VERIFY (update_type_string, update_type);\n\nstatic struct option const long_opts[] =\n{\n  {\"archive\", no_argument, nullptr, 'a'},\n  {\"attributes-only\", no_argument, nullptr, ATTRIBUTES_ONLY_OPTION},\n  {\"backup\", optional_argument, nullptr, 'b'},\n  {\"copy-contents\", no_argument, nullptr, COPY_CONTENTS_OPTION},\n  {\"debug\", no_argument, nullptr, DEBUG_OPTION},\n  {\"dereference\", no_argument, nullptr, 'L'},\n  {\"force\", no_argument, nullptr, 'f'},\n  {\"interactive\", no_argument, nullptr, 'i'},\n  {\"link\", no_argument, nullptr, 'l'},\n  {\"no-clobber\", no_argument, nullptr, 'n'},\n  {\"no-dereference\", no_argument, nullptr, 'P'},\n  {\"no-preserve\", required_argument, nullptr, NO_PRESERVE_ATTRIBUTES_OPTION},\n  {\"no-target-directory\", no_argument, nullptr, 'T'},\n  {\"one-file-system\", no_argument, nullptr, 'x'},\n  {\"parents\", no_argument, nullptr, PARENTS_OPTION},\n  {\"path\", no_argument, nullptr, PARENTS_OPTION},    \n  {\"preserve\", optional_argument, nullptr, PRESERVE_ATTRIBUTES_OPTION},\n  {\"recursive\", no_argument, nullptr, 'R'},\n  {\"remove-destination\", no_argument, nullptr, UNLINK_DEST_BEFORE_OPENING},\n  {\"sparse\", required_argument, nullptr, SPARSE_OPTION},\n  {\"reflink\", optional_argument, nullptr, REFLINK_OPTION},\n  {\"strip-trailing-slashes\", no_argument, nullptr,\n   STRIP_TRAILING_SLASHES_OPTION},\n  {\"suffix\", required_argument, nullptr, 'S'},\n  {\"symbolic-link\", no_argument, nullptr, 's'},\n  {\"target-directory\", required_argument, nullptr, 't'},\n  {\"update\", optional_argument, nullptr, 'u'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_SELINUX_CONTEXT_OPTION_DECL},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [-T] SOURCE DEST\\n\\\n  or:  %s [OPTION]... SOURCE... DIRECTORY\\n\\\n  or:  %s [OPTION]... -t DIRECTORY SOURCE...\\n\\\n\"),\n              program_name, program_name, program_name);\n      fputs (_(\"\\\nCopy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -a, --archive                same as -dR --preserve=all\\n\\\n      --attributes-only        don't copy the file data, just the attributes\\n\\\n      --backup[=CONTROL]       make a backup of each existing destination file\\\n\\n\\\n  -b                           like --backup but does not accept an argument\\n\\\n      --copy-contents          copy contents of special files when recursive\\n\\\n  -d                           same as --no-dereference --preserve=links\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --debug                  explain how a file is copied.  Implies -v\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f, --force                  if an existing destination file cannot be\\n\\\n                                 opened, remove it and try again (this option\\n\\\n                                 is ignored when the -n option is also used)\\n\\\n  -i, --interactive            prompt before overwrite (overrides a previous -n\\\n\\n\\\n                                  option)\\n\\\n  -H                           follow command-line symbolic links in SOURCE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -l, --link                   hard link files instead of copying\\n\\\n  -L, --dereference            always follow symbolic links in SOURCE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -n, --no-clobber             do not overwrite an existing file (overrides a\\n\\\n                                 -u or previous -i option). See also --update\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -P, --no-dereference         never follow symbolic links in SOURCE\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -p                           same as --preserve=mode,ownership,timestamps\\n\\\n      --preserve[=ATTR_LIST]   preserve the specified attributes\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --no-preserve=ATTR_LIST  don't preserve the specified attributes\\n\\\n      --parents                use full source file name under DIRECTORY\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -R, -r, --recursive          copy directories recursively\\n\\\n      --reflink[=WHEN]         control clone/CoW copies. See below\\n\\\n      --remove-destination     remove each existing destination file before\\n\\\n                                 attempting to open it (contrast with --force)\\\n\\n\"), stdout);\n      fputs (_(\"\\\n      --sparse=WHEN            control creation of sparse files. See below\\n\\\n      --strip-trailing-slashes  remove any trailing slashes from each SOURCE\\n\\\n                                 argument\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -s, --symbolic-link          make symbolic links instead of copying\\n\\\n  -S, --suffix=SUFFIX          override the usual backup suffix\\n\\\n  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY\\n\\\n  -T, --no-target-directory    treat DEST as a normal file\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  --update[=UPDATE]            control which existing files are updated;\\n\\\n                                 UPDATE={all,none,older(default)}.  See below\\n\\\n  -u                           equivalent to --update[=older]\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --verbose                explain what is being done\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -x, --one-file-system        stay on this file system\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -Z                           set SELinux security context of destination\\n\\\n                                 file to default type\\n\\\n      --context[=CTX]          like -Z, or if CTX is specified then set the\\n\\\n                                 SELinux or SMACK security context to CTX\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nATTR_LIST is a comma-separated list of attributes. Attributes are 'mode' for\\n\\\npermissions (including any ACL and xattr permissions), 'ownership' for user\\n\\\nand group, 'timestamps' for file timestamps, 'links' for hard links, 'context'\\\n\\nfor security context, 'xattr' for extended attributes, and 'all' for all\\n\\\nattributes.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n\\n\\\nBy default, sparse SOURCE files are detected by a crude heuristic and the\\n\\\ncorresponding DEST file is made sparse as well.  That is the behavior\\n\\\nselected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\\n\\\nfile whenever the SOURCE file contains a long enough sequence of zero bytes.\\n\\\nUse --sparse=never to inhibit creation of sparse files.\\n\\\n\"), stdout);\n      emit_update_parameters_note ();\n      fputs (_(\"\\\n\\n\\\nWhen --reflink[=always] is specified, perform a lightweight copy, where the\\n\\\ndata blocks are copied only when modified.  If this is not possible the copy\\n\\\nfails, or if --reflink=auto is specified, fall back to a standard copy.\\n\\\nUse --reflink=never to ensure a standard copy is performed.\\n\\\n\"), stdout);\n      emit_backup_suffix_note ();\n      fputs (_(\"\\\n\\n\\\nAs a special case, cp makes a backup of SOURCE when the force and backup\\n\\\noptions are given and SOURCE and DEST are the same name for an existing,\\n\\\nregular file.\\n\\\n\"), stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Ensure that parents of CONST_DST_NAME have correct protections, for\n   the --parents option.  This is done after all copying has been\n   completed, to allow permissions that don't include user write/execute.\n\n   DST_SRC_NAME is the suffix of CONST_DST_NAME that is the source file name,\n   DST_DIRFD+DST_RELNAME is equivalent to CONST_DST_NAME, and\n   DST_RELNAME equals DST_SRC_NAME after skipping any leading '/'s.\n\n   ATTR_LIST is a null-terminated linked list of structures that\n   indicates the end of the filename of each intermediate directory\n   in CONST_DST_NAME that may need to have its attributes changed.\n   The command 'cp --parents --preserve a/b/c d/e_dir' changes the\n   attributes of the directories d/e_dir/a and d/e_dir/a/b to match\n   the corresponding source directories regardless of whether they\n   existed before the 'cp' command was given.\n\n   Return true if the parent of CONST_DST_NAME and any intermediate\n   directories specified by ATTR_LIST have the proper permissions\n   when done.  */\n\nstatic bool\nre_protect (char const *const_dst_name, char const *dst_src_name,\n            int dst_dirfd, char const *dst_relname,\n            struct dir_attr *attr_list, const struct cp_options *x)\n{\n  struct dir_attr *p;\n  char *dst_name;\t\t/* A copy of CONST_DST_NAME we can change. */\n\n  ASSIGN_STRDUPA (dst_name, const_dst_name);\n\n  /* The suffix of DST_NAME that is a copy of the source file name,\n     possibly truncated to name a parent directory.  */\n  char const *src_name = dst_name + (dst_src_name - const_dst_name);\n\n  /* Likewise, but with any leading '/'s skipped.  */\n  char const *relname = dst_name + (dst_relname - const_dst_name);\n\n  for (p = attr_list; p; p = p->next)\n    {\n      dst_name[p->slash_offset] = '\\0';\n\n      /* Adjust the times (and if possible, ownership) for the copy.\n         chown turns off set[ug]id bits for non-root,\n         so do the chmod last.  */\n\n      if (x->preserve_timestamps)\n        {\n          struct timespec timespec[2];\n\n          timespec[0] = get_stat_atime (&p->st);\n          timespec[1] = get_stat_mtime (&p->st);\n\n          if (utimensat (dst_dirfd, relname, timespec, 0))\n            {\n              error (0, errno, _(\"failed to preserve times for %s\"),\n                     quoteaf (dst_name));\n              return false;\n            }\n        }\n\n      if (x->preserve_ownership)\n        {\n          if (lchownat (dst_dirfd, relname, p->st.st_uid, p->st.st_gid)\n              != 0)\n            {\n              if (! chown_failure_ok (x))\n                {\n                  error (0, errno, _(\"failed to preserve ownership for %s\"),\n                         quoteaf (dst_name));\n                  return false;\n                }\n              /* Failing to preserve ownership is OK. Still, try to preserve\n                 the group, but ignore the possible error. */\n              ignore_value (lchownat (dst_dirfd, relname, -1, p->st.st_gid));\n            }\n        }\n\n      if (x->preserve_mode)\n        {\n          if (copy_acl (src_name, -1, dst_name, -1, p->st.st_mode) != 0)\n            return false;\n        }\n      else if (p->restore_mode)\n        {\n          if (lchmodat (dst_dirfd, relname, p->st.st_mode) != 0)\n            {\n              error (0, errno, _(\"failed to preserve permissions for %s\"),\n                     quoteaf (dst_name));\n              return false;\n            }\n        }\n\n      dst_name[p->slash_offset] = '/';\n    }\n  return true;\n}\n\n/* Ensure that the parent directory of CONST_DIR exists, for\n   the --parents option.\n\n   SRC_OFFSET is the index in CONST_DIR (which is a destination\n   directory) of the beginning of the source directory name.\n   Create any leading directories that don't already exist.\n   DST_DIRFD is a file descriptor for the target directory.\n   If VERBOSE_FMT_STRING is nonzero, use it as a printf format\n   string for printing a message after successfully making a directory.\n   The format should take two string arguments: the names of the\n   source and destination directories.\n   Creates a linked list of attributes of intermediate directories,\n   *ATTR_LIST, for re_protect to use after calling copy.\n   Sets *NEW_DST if this function creates parent of CONST_DIR.\n\n   Return true if parent of CONST_DIR exists as a directory with the proper\n   permissions when done.  */\n\n/* FIXME: Synch this function with the one in ../lib/mkdir-p.c.  */\n\nstatic bool\nmake_dir_parents_private (char const *const_dir, size_t src_offset,\n                          int dst_dirfd,\n                          char const *verbose_fmt_string,\n                          struct dir_attr **attr_list, bool *new_dst,\n                          const struct cp_options *x)\n{\n  struct stat stats;\n  char *dir;\t\t/* A copy of CONST_DIR we can change.  */\n  char *src;\t\t/* Source name in DIR.  */\n  char *dst_dir;\t/* Leading directory of DIR.  */\n  idx_t dirlen = dir_len (const_dir);\n\n  *attr_list = nullptr;\n\n  /* Succeed immediately if the parent of CONST_DIR must already exist,\n     as the target directory has already been checked.  */\n  if (dirlen <= src_offset)\n    return true;\n\n  ASSIGN_STRDUPA (dir, const_dir);\n\n  src = dir + src_offset;\n\n  dst_dir = alloca (dirlen + 1);\n  memcpy (dst_dir, dir, dirlen);\n  dst_dir[dirlen] = '\\0';\n  char const *dst_reldir = dst_dir + src_offset;\n  while (*dst_reldir == '/')\n    dst_reldir++;\n\n  /* XXX: If all dirs are present at the destination,\n     no permissions or security contexts will be updated.  */\n  if (fstatat (dst_dirfd, dst_reldir, &stats, 0) != 0)\n    {\n      /* A parent of CONST_DIR does not exist.\n         Make all missing intermediate directories. */\n      char *slash;\n\n      slash = src;\n      while (*slash == '/')\n        slash++;\n      dst_reldir = slash;\n\n      while ((slash = strchr (slash, '/')))\n        {\n          struct dir_attr *new;\n          bool missing_dir;\n\n          *slash = '\\0';\n          missing_dir = fstatat (dst_dirfd, dst_reldir, &stats, 0) != 0;\n\n          if (missing_dir || x->preserve_ownership || x->preserve_mode\n              || x->preserve_timestamps)\n            {\n              /* Add this directory to the list of directories whose\n                 modes might need fixing later. */\n              struct stat src_st;\n              int src_errno = (stat (src, &src_st) != 0\n                               ? errno\n                               : S_ISDIR (src_st.st_mode)\n                               ? 0\n                               : ENOTDIR);\n              if (src_errno)\n                {\n                  error (0, src_errno, _(\"failed to get attributes of %s\"),\n                         quoteaf (src));\n                  return false;\n                }\n\n              new = xmalloc (sizeof *new);\n              new->st = src_st;\n              new->slash_offset = slash - dir;\n              new->restore_mode = false;\n              new->next = *attr_list;\n              *attr_list = new;\n            }\n\n          /* If required set the default context for created dirs.  */\n          if (! set_process_security_ctx (src, dir,\n                                          missing_dir ? new->st.st_mode : 0,\n                                          missing_dir, x))\n            return false;\n\n          if (missing_dir)\n            {\n              mode_t src_mode;\n              mode_t omitted_permissions;\n              mode_t mkdir_mode;\n\n              /* This component does not exist.  We must set\n                 *new_dst and new->st.st_mode inside this loop because,\n                 for example, in the command 'cp --parents ../a/../b/c e_dir',\n                 make_dir_parents_private creates only e_dir/../a if\n                 ./b already exists. */\n              *new_dst = true;\n              src_mode = new->st.st_mode;\n\n              /* If the ownership or special mode bits might change,\n                 omit some permissions at first, so unauthorized users\n                 cannot nip in before the file is ready.  */\n              omitted_permissions = (src_mode\n                                     & (x->preserve_ownership\n                                        ? S_IRWXG | S_IRWXO\n                                        : x->preserve_mode\n                                        ? S_IWGRP | S_IWOTH\n                                        : 0));\n\n              /* POSIX says mkdir's behavior is implementation-defined when\n                 (src_mode & ~S_IRWXUGO) != 0.  However, common practice is\n                 to ask mkdir to copy all the CHMOD_MODE_BITS, letting mkdir\n                 decide what to do with S_ISUID | S_ISGID | S_ISVTX.  */\n              mkdir_mode = x->explicit_no_preserve_mode ? S_IRWXUGO : src_mode;\n              mkdir_mode &= CHMOD_MODE_BITS & ~omitted_permissions;\n              if (mkdirat (dst_dirfd, dst_reldir, mkdir_mode) != 0)\n                {\n                  error (0, errno, _(\"cannot make directory %s\"),\n                         quoteaf (dir));\n                  return false;\n                }\n              else\n                {\n                  if (verbose_fmt_string != nullptr)\n                    printf (verbose_fmt_string, src, dir);\n                }\n\n              /* We need search and write permissions to the new directory\n                 for writing the directory's contents. Check if these\n                 permissions are there.  */\n\n              if (fstatat (dst_dirfd, dst_reldir, &stats, AT_SYMLINK_NOFOLLOW))\n                {\n                  error (0, errno, _(\"failed to get attributes of %s\"),\n                         quoteaf (dir));\n                  return false;\n                }\n\n\n              if (! x->preserve_mode)\n                {\n                  if (omitted_permissions & ~stats.st_mode)\n                    omitted_permissions &= ~ cached_umask ();\n                  if (omitted_permissions & ~stats.st_mode\n                      || (stats.st_mode & S_IRWXU) != S_IRWXU)\n                    {\n                      new->st.st_mode = stats.st_mode | omitted_permissions;\n                      new->restore_mode = true;\n                    }\n                }\n\n              mode_t accessible = stats.st_mode | S_IRWXU;\n              if (stats.st_mode != accessible)\n                {\n                  /* Make the new directory searchable and writable.\n                     The original permissions will be restored later.  */\n\n                  if (lchmodat (dst_dirfd, dst_reldir, accessible) != 0)\n                    {\n                      error (0, errno, _(\"setting permissions for %s\"),\n                             quoteaf (dir));\n                      return false;\n                    }\n                }\n            }\n          else if (!S_ISDIR (stats.st_mode))\n            {\n              error (0, 0, _(\"%s exists but is not a directory\"),\n                     quoteaf (dir));\n              return false;\n            }\n          else\n            *new_dst = false;\n\n          /* For existing dirs, set the security context as per that already\n             set for the process global context.  */\n          if (! *new_dst\n              && (x->set_security_context || x->preserve_security_context))\n            {\n              if (! set_file_security_ctx (dir, false, x)\n                  && x->require_preserve_context)\n                return false;\n            }\n\n          *slash++ = '/';\n\n          /* Avoid unnecessary calls to 'stat' when given\n             file names containing multiple adjacent slashes.  */\n          while (*slash == '/')\n            slash++;\n        }\n    }\n\n  /* We get here if the parent of DIR already exists.  */\n\n  else if (!S_ISDIR (stats.st_mode))\n    {\n      error (0, 0, _(\"%s exists but is not a directory\"), quoteaf (dst_dir));\n      return false;\n    }\n  else\n    {\n      *new_dst = false;\n    }\n  return true;\n}\n\n/* Scan the arguments, and copy each by calling copy.\n   Return true if successful.  */\n\nstatic bool\ndo_copy (int n_files, char **file, char const *target_directory,\n         bool no_target_directory, struct cp_options *x)\n{\n  struct stat sb;\n  bool new_dst = false;\n  bool ok = true;\n\n  if (n_files <= !target_directory)\n    {\n      if (n_files <= 0)\n        error (0, 0, _(\"missing file operand\"));\n      else\n        error (0, 0, _(\"missing destination file operand after %s\"),\n               quoteaf (file[0]));\n      usage (EXIT_FAILURE);\n    }\n\n  sb.st_mode = 0;\n  int target_dirfd = AT_FDCWD;\n  if (no_target_directory)\n    {\n      if (target_directory)\n        error (EXIT_FAILURE, 0,\n               _(\"cannot combine --target-directory (-t) \"\n                 \"and --no-target-directory (-T)\"));\n      if (2 < n_files)\n        {\n          error (0, 0, _(\"extra operand %s\"), quoteaf (file[2]));\n          usage (EXIT_FAILURE);\n        }\n    }\n  else if (target_directory)\n    {\n      target_dirfd = target_directory_operand (target_directory, &sb);\n      if (! target_dirfd_valid (target_dirfd))\n        error (EXIT_FAILURE, errno, _(\"target directory %s\"),\n               quoteaf (target_directory));\n    }\n  else\n    {\n      char const *lastfile = file[n_files - 1];\n      int fd = target_directory_operand (lastfile, &sb);\n      if (target_dirfd_valid (fd))\n        {\n          target_dirfd = fd;\n          target_directory = lastfile;\n          n_files--;\n        }\n      else\n        {\n          int err = errno;\n          if (err == ENOENT)\n            new_dst = true;\n\n          /* The last operand LASTFILE cannot be opened as a directory.\n             If there are more than two operands, report an error.\n\n             Also, report an error if LASTFILE is known to be a directory\n             even though it could not be opened, which can happen if\n             opening failed with EACCES on a platform lacking O_PATH.\n             In this case use stat to test whether LASTFILE is a\n             directory, in case opening a non-directory with (O_SEARCH\n             | O_DIRECTORY) failed with EACCES not ENOTDIR.  */\n          if (2 < n_files\n              || (O_PATHSEARCH == O_SEARCH && err == EACCES\n                  && (sb.st_mode || stat (lastfile, &sb) == 0)\n                  && S_ISDIR (sb.st_mode)))\n            error (EXIT_FAILURE, err, _(\"target %s\"), quoteaf (lastfile));\n        }\n    }\n\n  if (target_directory)\n    {\n      /* cp file1...filen edir\n         Copy the files 'file1' through 'filen'\n         to the existing directory 'edir'. */\n\n      /* Initialize these hash tables only if we'll need them.\n         The problems they're used to detect can arise only if\n         there are two or more files to copy.  */\n      if (2 <= n_files)\n        {\n          dest_info_init (x);\n          src_info_init (x);\n        }\n\n      for (int i = 0; i < n_files; i++)\n        {\n          char *dst_name;\n          bool parent_exists = true;  /* True if dir_name (dst_name) exists. */\n          struct dir_attr *attr_list;\n          char *arg_in_concat;\n          char *arg = file[i];\n\n          /* Trailing slashes are meaningful (i.e., maybe worth preserving)\n             only in the source file names.  */\n          if (remove_trailing_slashes)\n            strip_trailing_slashes (arg);\n\n          if (parents_option)\n            {\n              char *arg_no_trailing_slash;\n\n              /* Use 'arg' without trailing slashes in constructing destination\n                 file names.  Otherwise, we can end up trying to create a\n                 directory using a name with trailing slash, which fails on\n                 NetBSD 1.[34] systems.  */\n              ASSIGN_STRDUPA (arg_no_trailing_slash, arg);\n              strip_trailing_slashes (arg_no_trailing_slash);\n\n              /* Append all of 'arg' (minus any trailing slash) to 'dest'.  */\n              dst_name = file_name_concat (target_directory,\n                                           arg_no_trailing_slash,\n                                           &arg_in_concat);\n\n              /* For --parents, we have to make sure that the directory\n                 dir_name (dst_name) exists.  We may have to create a few\n                 leading directories. */\n              parent_exists =\n                (make_dir_parents_private\n                 (dst_name, arg_in_concat - dst_name, target_dirfd,\n                  (x->verbose ? \"%s -> %s\\n\" : nullptr),\n                  &attr_list, &new_dst, x));\n            }\n          else\n            {\n              char *arg_base;\n              /* Append the last component of 'arg' to 'target_directory'.  */\n              ASSIGN_STRDUPA (arg_base, last_component (arg));\n              strip_trailing_slashes (arg_base);\n              /* For 'cp -R source/.. dest', don't copy into 'dest/..'. */\n              arg_base += STREQ (arg_base, \"..\");\n              dst_name = file_name_concat (target_directory, arg_base,\n                                           &arg_in_concat);\n            }\n\n          if (!parent_exists)\n            {\n              /* make_dir_parents_private failed, so don't even\n                 attempt the copy.  */\n              ok = false;\n            }\n          else\n            {\n              char const *dst_relname = arg_in_concat;\n              while (*dst_relname == '/')\n                dst_relname++;\n\n              bool copy_into_self;\n              ok &= copy (arg, dst_name, target_dirfd, dst_relname,\n                          new_dst, x, &copy_into_self, nullptr);\n\n              if (parents_option)\n                ok &= re_protect (dst_name, arg_in_concat, target_dirfd,\n                                  dst_relname, attr_list, x);\n            }\n\n          if (parents_option)\n            {\n              while (attr_list)\n                {\n                  struct dir_attr *p = attr_list;\n                  attr_list = attr_list->next;\n                  free (p);\n                }\n            }\n\n          free (dst_name);\n        }\n    }\n  else /* !target_directory */\n    {\n      char const *source = file[0];\n      char const *dest = file[1];\n      bool unused;\n\n      if (parents_option)\n        {\n          error (0, 0,\n                 _(\"with --parents, the destination must be a directory\"));\n          usage (EXIT_FAILURE);\n        }\n\n      /* When the force and backup options have been specified and\n         the source and destination are the same name for an existing\n         regular file, convert the user's command, e.g.,\n         'cp --force --backup foo foo' to 'cp --force foo fooSUFFIX'\n         where SUFFIX is determined by any version control options used.  */\n\n      if (x->unlink_dest_after_failed_open\n          && x->backup_type != no_backups\n          && STREQ (source, dest)\n          && !new_dst\n          && (sb.st_mode != 0 || stat (dest, &sb) == 0) && S_ISREG (sb.st_mode))\n        {\n          static struct cp_options x_tmp;\n\n          dest = find_backup_file_name (AT_FDCWD, dest, x->backup_type);\n          /* Set x->backup_type to 'no_backups' so that the normal backup\n             mechanism is not used when performing the actual copy.\n             backup_type must be set to 'no_backups' only *after* the above\n             call to find_backup_file_name -- that function uses\n             backup_type to determine the suffix it applies.  */\n          x_tmp = *x;\n          x_tmp.backup_type = no_backups;\n          x = &x_tmp;\n        }\n\n      ok = copy (source, dest, AT_FDCWD, dest, -new_dst, x, &unused, nullptr);\n    }\n\n  return ok;\n}\n\nstatic void\ncp_option_init (struct cp_options *x)\n{\n  cp_options_default (x);\n  x->copy_as_regular = true;\n  x->dereference = DEREF_UNDEFINED;\n  x->unlink_dest_before_opening = false;\n  x->unlink_dest_after_failed_open = false;\n  x->hard_link = false;\n  x->interactive = I_UNSPECIFIED;\n  x->move_mode = false;\n  x->install_mode = false;\n  x->one_file_system = false;\n  x->reflink_mode = REFLINK_AUTO;\n\n  x->preserve_ownership = false;\n  x->preserve_links = false;\n  x->preserve_mode = false;\n  x->preserve_timestamps = false;\n  x->explicit_no_preserve_mode = false;\n  x->preserve_security_context = false; /* -a or --preserve=context.  */\n  x->require_preserve_context = false;  /* --preserve=context.  */\n  x->set_security_context = nullptr;       /* -Z, set sys default context. */\n  x->preserve_xattr = false;\n  x->reduce_diagnostics = false;\n  x->require_preserve_xattr = false;\n\n  x->data_copy_required = true;\n  x->require_preserve = false;\n  x->recursive = false;\n  x->sparse_mode = SPARSE_AUTO;\n  x->symbolic_link = false;\n  x->set_mode = false;\n  x->mode = 0;\n\n  /* Not used.  */\n  x->stdin_tty = false;\n\n  x->update = false;\n  x->verbose = false;\n\n  /* By default, refuse to open a dangling destination symlink, because\n     in general one cannot do that safely, give the current semantics of\n     open's O_EXCL flag, (which POSIX doesn't even allow cp to use, btw).\n     But POSIX requires it.  */\n  x->open_dangling_dest_symlink = getenv (\"POSIXLY_CORRECT\") != nullptr;\n\n  x->dest_info = nullptr;\n  x->src_info = nullptr;\n}\n\n/* Given a string, ARG, containing a comma-separated list of arguments\n   to the --preserve option, set the appropriate fields of X to ON_OFF.  */\nstatic void\ndecode_preserve_arg (char const *arg, struct cp_options *x, bool on_off)\n{\n  enum File_attribute\n    {\n      PRESERVE_MODE,\n      PRESERVE_TIMESTAMPS,\n      PRESERVE_OWNERSHIP,\n      PRESERVE_LINK,\n      PRESERVE_CONTEXT,\n      PRESERVE_XATTR,\n      PRESERVE_ALL\n    };\n  static enum File_attribute const preserve_vals[] =\n    {\n      PRESERVE_MODE, PRESERVE_TIMESTAMPS,\n      PRESERVE_OWNERSHIP, PRESERVE_LINK, PRESERVE_CONTEXT, PRESERVE_XATTR,\n      PRESERVE_ALL\n    };\n  /* Valid arguments to the '--preserve' option. */\n  static char const *const preserve_args[] =\n    {\n      \"mode\", \"timestamps\",\n      \"ownership\", \"links\", \"context\", \"xattr\", \"all\", nullptr\n    };\n  ARGMATCH_VERIFY (preserve_args, preserve_vals);\n\n  char *arg_writable = xstrdup (arg);\n  char *s = arg_writable;\n  do\n    {\n      /* find next comma */\n      char *comma = strchr (s, ',');\n      enum File_attribute val;\n\n      /* If we found a comma, put a NUL in its place and advance.  */\n      if (comma)\n        *comma++ = 0;\n\n      /* process S.  */\n      val = XARGMATCH (on_off ? \"--preserve\" : \"--no-preserve\",\n                       s, preserve_args, preserve_vals);\n      switch (val)\n        {\n        case PRESERVE_MODE:\n          x->preserve_mode = on_off;\n          x->explicit_no_preserve_mode = !on_off;\n          break;\n\n        case PRESERVE_TIMESTAMPS:\n          x->preserve_timestamps = on_off;\n          break;\n\n        case PRESERVE_OWNERSHIP:\n          x->preserve_ownership = on_off;\n          break;\n\n        case PRESERVE_LINK:\n          x->preserve_links = on_off;\n          break;\n\n        case PRESERVE_CONTEXT:\n          x->require_preserve_context = on_off;\n          x->preserve_security_context = on_off;\n          break;\n\n        case PRESERVE_XATTR:\n          x->preserve_xattr = on_off;\n          x->require_preserve_xattr = on_off;\n          break;\n\n        case PRESERVE_ALL:\n          x->preserve_mode = on_off;\n          x->preserve_timestamps = on_off;\n          x->preserve_ownership = on_off;\n          x->preserve_links = on_off;\n          x->explicit_no_preserve_mode = !on_off;\n          if (selinux_enabled)\n            x->preserve_security_context = on_off;\n          x->preserve_xattr = on_off;\n          break;\n\n        default:\n          affirm (false);\n        }\n      s = comma;\n    }\n  while (s);\n\n  free (arg_writable);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int c;\n  bool ok;\n  bool make_backups = false;\n  char const *backup_suffix = nullptr;\n  char *version_control_string = nullptr;\n  struct cp_options x;\n  bool copy_contents = false;\n  char *target_directory = nullptr;\n  bool no_target_directory = false;\n  char const *scontext = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdin);\n\n  selinux_enabled = (0 < is_selinux_enabled ());\n  cp_option_init (&x);\n\n  while ((c = getopt_long (argc, argv, \"abdfHilLnprst:uvxPRS:TZ\",\n                           long_opts, nullptr))\n         != -1)\n    {\n      switch (c)\n        {\n        case SPARSE_OPTION:\n          x.sparse_mode = XARGMATCH (\"--sparse\", optarg,\n                                     sparse_type_string, sparse_type);\n          break;\n\n        case REFLINK_OPTION:\n          if (optarg == nullptr)\n            x.reflink_mode = REFLINK_ALWAYS;\n          else\n            x.reflink_mode = XARGMATCH (\"--reflink\", optarg,\n                                       reflink_type_string, reflink_type);\n          break;\n\n        case 'a':\n          /* Like -dR --preserve=all with reduced failure diagnostics.  */\n          x.dereference = DEREF_NEVER;\n          x.preserve_links = true;\n          x.preserve_ownership = true;\n          x.preserve_mode = true;\n          x.preserve_timestamps = true;\n          x.require_preserve = true;\n          if (selinux_enabled)\n             x.preserve_security_context = true;\n          x.preserve_xattr = true;\n          x.reduce_diagnostics = true;\n          x.recursive = true;\n          break;\n\n        case 'b':\n          make_backups = true;\n          if (optarg)\n            version_control_string = optarg;\n          break;\n\n        case ATTRIBUTES_ONLY_OPTION:\n          x.data_copy_required = false;\n          break;\n\n        case DEBUG_OPTION:\n          x.debug = x.verbose = true;\n          break;\n\n        case COPY_CONTENTS_OPTION:\n          copy_contents = true;\n          break;\n\n        case 'd':\n          x.preserve_links = true;\n          x.dereference = DEREF_NEVER;\n          break;\n\n        case 'f':\n          x.unlink_dest_after_failed_open = true;\n          break;\n\n        case 'H':\n          x.dereference = DEREF_COMMAND_LINE_ARGUMENTS;\n          break;\n\n        case 'i':\n          x.interactive = I_ASK_USER;\n          break;\n\n        case 'l':\n          x.hard_link = true;\n          break;\n\n        case 'L':\n          x.dereference = DEREF_ALWAYS;\n          break;\n\n        case 'n':\n          x.interactive = I_ALWAYS_NO;\n          break;\n\n        case 'P':\n          x.dereference = DEREF_NEVER;\n          break;\n\n        case NO_PRESERVE_ATTRIBUTES_OPTION:\n          decode_preserve_arg (optarg, &x, false);\n          break;\n\n        case PRESERVE_ATTRIBUTES_OPTION:\n          if (optarg == nullptr)\n            {\n              /* Fall through to the case for 'p' below.  */\n            }\n          else\n            {\n              decode_preserve_arg (optarg, &x, true);\n              x.require_preserve = true;\n              break;\n            }\n          FALLTHROUGH;\n\n        case 'p':\n          x.preserve_ownership = true;\n          x.preserve_mode = true;\n          x.preserve_timestamps = true;\n          x.require_preserve = true;\n          break;\n\n        case PARENTS_OPTION:\n          parents_option = true;\n          break;\n\n        case 'r':\n        case 'R':\n          x.recursive = true;\n          break;\n\n        case UNLINK_DEST_BEFORE_OPENING:\n          x.unlink_dest_before_opening = true;\n          break;\n\n        case STRIP_TRAILING_SLASHES_OPTION:\n          remove_trailing_slashes = true;\n          break;\n\n        case 's':\n          x.symbolic_link = true;\n          break;\n\n        case 't':\n          if (target_directory)\n            error (EXIT_FAILURE, 0,\n                   _(\"multiple target directories specified\"));\n          target_directory = optarg;\n          break;\n\n        case 'T':\n          no_target_directory = true;\n          break;\n\n        case 'u':\n          if (optarg == nullptr)\n            x.update = true;\n          else if (x.interactive != I_ALWAYS_NO)  /* -n takes precedence.  */\n            {\n              enum Update_type update_opt;\n              update_opt = XARGMATCH (\"--update\", optarg,\n                                      update_type_string, update_type);\n              if (update_opt == UPDATE_ALL)\n                {\n                  /* Default cp operation.  */\n                  x.update = false;\n                  x.interactive = I_UNSPECIFIED;\n                }\n              else if (update_opt == UPDATE_NONE)\n                {\n                  x.update = false;\n                  x.interactive = I_ALWAYS_SKIP;\n                }\n              else if (update_opt == UPDATE_OLDER)\n                {\n                  x.update = true;\n                  x.interactive = I_UNSPECIFIED;\n                }\n            }\n          break;\n\n        case 'v':\n          x.verbose = true;\n          break;\n\n        case 'x':\n          x.one_file_system = true;\n          break;\n\n        case 'Z':\n          /* politely decline if we're not on a selinux-enabled kernel.  */\n          if (selinux_enabled)\n            {\n              if (optarg)\n                scontext = optarg;\n              else\n                {\n                  x.set_security_context = selabel_open (SELABEL_CTX_FILE,\n                                                         nullptr, 0);\n                  if (! x.set_security_context)\n                    error (0, errno, _(\"warning: ignoring --context\"));\n                }\n            }\n          else if (optarg)\n            {\n              error (0, 0,\n                     _(\"warning: ignoring --context; \"\n                       \"it requires an SELinux-enabled kernel\"));\n            }\n          break;\n\n        case 'S':\n          make_backups = true;\n          backup_suffix = optarg;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  /* With --sparse=never, disable reflinking so we create a non sparse copy.\n     This will also have the effect of disabling copy offload as that may\n     propagate holes.  For e.g. FreeBSD documents that copy_file_range()\n     will try to propagate holes.  */\n  if (x.reflink_mode == REFLINK_AUTO && x.sparse_mode == SPARSE_NEVER)\n    x.reflink_mode = REFLINK_NEVER;\n\n  if (x.hard_link && x.symbolic_link)\n    {\n      error (0, 0, _(\"cannot make both hard and symbolic links\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (x.interactive == I_ALWAYS_NO)\n    x.update = false;\n\n  if (make_backups && x.interactive == I_ALWAYS_NO)\n    {\n      error (0, 0,\n             _(\"options --backup and --no-clobber are mutually exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (x.reflink_mode == REFLINK_ALWAYS && x.sparse_mode != SPARSE_AUTO)\n    {\n      error (0, 0, _(\"--reflink can be used only with --sparse=auto\"));\n      usage (EXIT_FAILURE);\n    }\n\n  x.backup_type = (make_backups\n                   ? xget_version (_(\"backup type\"),\n                                   version_control_string)\n                   : no_backups);\n  set_simple_backup_suffix (backup_suffix);\n\n  if (x.dereference == DEREF_UNDEFINED)\n    {\n      if (x.recursive && ! x.hard_link)\n        /* This is compatible with FreeBSD.  */\n        x.dereference = DEREF_NEVER;\n      else\n        x.dereference = DEREF_ALWAYS;\n    }\n\n  if (x.recursive)\n    x.copy_as_regular = copy_contents;\n\n  /* Ensure -Z overrides -a.  */\n  if ((x.set_security_context || scontext)\n      && ! x.require_preserve_context)\n    x.preserve_security_context = false;\n\n  if (x.preserve_security_context && (x.set_security_context || scontext))\n    error (EXIT_FAILURE, 0,\n           _(\"cannot set target context and preserve it\"));\n\n  if (x.require_preserve_context && ! selinux_enabled)\n    error (EXIT_FAILURE, 0,\n           _(\"cannot preserve security context \"\n             \"without an SELinux-enabled kernel\"));\n\n  /* FIXME: This handles new files.  But what about existing files?\n     I.e., if updating a tree, new files would have the specified context,\n     but shouldn't existing files be updated for consistency like this?\n       if (scontext && !restorecon (nullptr, dst_path, 0))\n          error (...);\n   */\n  if (scontext && setfscreatecon (scontext) < 0)\n    error (EXIT_FAILURE, errno,\n           _(\"failed to set default file creation context to %s\"),\n           quote (scontext));\n\n#if !USE_XATTR\n  if (x.require_preserve_xattr)\n    error (EXIT_FAILURE, 0, _(\"cannot preserve extended attributes, cp is \"\n                              \"built without xattr support\"));\n#endif\n\n   \n\n  hash_init ();\n\n  ok = do_copy (argc - optind, argv + optind,\n                target_directory, no_target_directory, &x);\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}