{
  "module_name": "extract-magic",
  "hash_id": "c41ecc68a602652d05e945bfcccf23a802572bf26081074300195aa29baa3cd3",
  "original_prompt": "Ingested from coreutils-9.4/src/extract-magic",
  "human_readable_source": "#!/usr/bin/perl -w\n# Derive #define directives from specially formatted 'case ...:' statements.\n\n# Copyright (C) 2003-2023 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nuse strict;\n\nuse Getopt::Long;\n\n(my $VERSION = '$Revision: 1.5 $ ') =~ tr/[0-9].//cd;\n(my $ME = $0) =~ s|.*/||;\n\nEND\n{\n  # Nobody ever checks the status of print()s.  That's okay, because\n  # if any do fail, we're guaranteed to get an indicator when we close()\n  # the filehandle.\n  #\n  # Close stdout now, and if there were no errors, return happy status.\n  # If stdout has already been closed by the script, though, do nothing.\n  defined fileno STDOUT\n    or return;\n  close STDOUT\n    and return;\n\n  # Errors closing stdout.  Indicate that, and hope stderr is OK.\n  warn \"$ME: closing standard output: $!\\n\";\n\n  # Don't be so arrogant as to assume that we're the first END handler\n  # defined, and thus the last one invoked.  There may be others yet\n  # to come.  $? will be passed on to them, and to the final _exit().\n  #\n  # If it isn't already an error, make it one (and if it _is_ an error,\n  # preserve the value: it might be important).\n  $? ||= 1;\n}\n\nsub usage ($)\n{\n  my ($exit_code) = @_;\n  my $STREAM = ($exit_code == 0 ? *STDOUT : *STDERR);\n  if ($exit_code != 0)\n    {\n      print $STREAM \"Try '$ME --help' for more information.\\n\";\n    }\n  else\n    {\n      print $STREAM <<EOF;\nUsage: $ME [OPTIONS] FILE\n\nFIXME: describe\n\nOPTIONS:\n\n  There are two modes of operation, the default, which is to emit\n  #define directives derived from specially formatted 'case' statements,\n  and that with --local, which is to emit a static inline function\n  mapping S_MAGIC_* values to 1, 0, -1, corresponding to known-local,\n  known-remote/distributed/network and unknown, respectively.\n\n   --local    emit an is_local_fs_type function\n   --help     display this help and exit\n   --version  output version information and exit\n\nEOF\n    }\n  exit $exit_code;\n}\n\n{\n  # The default is to print S_MAGIC_* definitions.\n  my $emit_magic = 1;\n\n  GetOptions\n    (\n     local => sub { $emit_magic = 0 },\n     help => sub { usage 0 },\n     version => sub { print \"$ME version $VERSION\\n\"; exit },\n    ) or usage 1;\n\n  my $fail = 0;\n\n  @ARGV < 1\n    and (warn \"$ME: missing FILE arguments\\n\"), $fail = 1;\n  1 < @ARGV\n    and (warn \"$ME: too many arguments\\n\"), $fail = 1;\n  $fail\n    and usage 1;\n\n  my $file = $ARGV[0];\n\n  open FH, $file\n    or die \"$ME: can't open '$file' for reading: $!\\n\";\n\n  # For each line like this:\n  #   case S_MAGIC_ROMFS: /* 0x7275 */\n  # emit one like this:\n  #   # define S_MAGIC_ROMFS 0x7275\n  # Fail if there is a 'case S_MAGIC_.*' line without\n  # a properly formed comment.\n\n  my $map_comment = <<EOF;\n/* Map each S_MAGIC_* value to 1, 0 or -1.\n   1 if it is known to be a remote file system type,\n   0 if it is known to be a local file system type, or -1 otherwise.  */\nEOF\n  my $magic_comment = <<EOF;\n/* Define the magic numbers as given by statfs(2).\n   Please send additions to bug-coreutils\\@gnu.org and meskes\\@debian.org.\n   This file is generated automatically from $file. */\nEOF\n  print $emit_magic ? $magic_comment : $map_comment;\n\n  $emit_magic\n    and print \"\\n#if defined __linux__ || defined __ANDROID__\\n\";\n  $emit_magic\n    or print \"static inline int\\n\"\n      . \"is_local_fs_type (unsigned long int magic)\\n\"\n      . \"{\\n  switch (magic)\\n    {\\n\";\n\n  while (defined (my $line = <FH>))\n    {\n      $line =~ /^[ \\t]+case S_MAGIC_/\n        or next;\n      $line =~\n        m!^[ \\t]+case (S_MAGIC_\\w+): /\\* (0x[0-9A-Fa-f]+) (local|remote) \\*/!\n        or (warn \"$ME:$file:$.: malformed case S_MAGIC_... line\"),\n          $fail = 1, next;\n      my $name = $1;\n      my $magic = $2;\n      my $local = $3 eq 'local' ? 1 : 0;\n      print $emit_magic\n        ? \"# define $name $magic\\n\"\n        : \"      case $name: return $local;\\n\";\n    }\n\n  $emit_magic\n    and print <<\\EOF;\n#elif defined __GNU__\n# include <hurd/hurd_types.h>\n#endif\nEOF\n  $emit_magic\n    or printf \"      default: return -1;\\n    }\\n}\\n\";\n\n  close FH;\n\n  exit $fail;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}