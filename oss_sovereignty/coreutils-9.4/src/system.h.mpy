{
  "module_name": "system.h",
  "hash_id": "615e228e59c2df533714fb0b57ee97221a1405ef020bb2e7495f774ae487a7a6",
  "original_prompt": "Ingested from coreutils-9.4/src/system.h",
  "human_readable_source": " \n\n#include <attribute.h>\n\n#include <alloca.h>\n\n#include <sys/stat.h>\n\n \n#define MODE_RW_UGO (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)\n\n#if HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n\n#include <unistd.h>\n\n#include <limits.h>\n\n#include \"pathmax.h\"\n#ifndef PATH_MAX\n# define PATH_MAX 8192\n#endif\n\n#include \"configmake.h\"\n\n#include <sys/time.h>\n#include <time.h>\n\n \n#if MAJOR_IN_MKDEV\n# include <sys/mkdev.h>\n# define HAVE_MAJOR\n#endif\n#if MAJOR_IN_SYSMACROS\n# include <sys/sysmacros.h>\n# define HAVE_MAJOR\n#endif\n#ifdef major\t\t\t \n# define HAVE_MAJOR\n#endif\n\n#ifndef HAVE_MAJOR\n# define major(dev)  (((dev) >> 8) & 0xff)\n# define minor(dev)  ((dev) & 0xff)\n# define makedev(maj, min)  (((maj) << 8) | (min))\n#endif\n#undef HAVE_MAJOR\n\n#if ! defined makedev && defined mkdev\n# define makedev(maj, min)  mkdev (maj, min)\n#endif\n\n#include <stddef.h>\n#include <string.h>\n#include <errno.h>\n\n \n#ifndef ENODATA\n# define ENODATA (-1)\n#endif\n\n#include <stdlib.h>\n#include \"version.h\"\n\n \nenum\n{\n  EXIT_TIMEDOUT = 124,  \n  EXIT_CANCELED = 125,  \n  EXIT_CANNOT_INVOKE = 126,  \n  EXIT_ENOENT = 127  \n};\n\n#include \"exitfail.h\"\n\n \nstatic inline void\ninitialize_exit_failure (int status)\n{\n  if (status != EXIT_FAILURE)\n    exit_failure = status;\n}\n\n#include <fcntl.h>\n#ifdef O_PATH\nenum { O_PATHSEARCH = O_PATH };\n#else\nenum { O_PATHSEARCH = O_SEARCH };\n#endif\n\n#include <dirent.h>\n#ifndef _D_EXACT_NAMLEN\n# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)\n#endif\n\nenum\n{\n  NOT_AN_INODE_NUMBER = 0\n};\n\n#ifdef D_INO_IN_DIRENT\n# define D_INO(dp) (dp)->d_ino\n#else\n \n# define D_INO(dp) NOT_AN_INODE_NUMBER\n#endif\n\n \n#include <inttypes.h>\n\n \n#ifndef initialize_main\n# ifndef __OS2__\n#  define initialize_main(ac, av)\n# else\n#  define initialize_main(ac, av) \\\n     do { _wildcard (ac, av); _response (ac, av); } while (0)\n# endif\n#endif\n\n#include \"stat-macros.h\"\n\n#include \"timespec.h\"\n\n#include <ctype.h>\n\n \n#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)\n\n \nstatic inline unsigned char to_uchar (char ch) { return ch; }\n\n \nstatic inline bool\nfield_sep (unsigned char ch)\n{\n  return isblank (ch) || ch == '\\n';\n}\n\n#include <locale.h>\n\n \n\n#include \"gettext.h\"\n#if ! ENABLE_NLS\n# undef textdomain\n# define textdomain(Domainname)  \n# undef bindtextdomain\n# define bindtextdomain(Domainname, Dirname)  \n#endif\n\n#define _(msgid) gettext (msgid)\n#define N_(msgid) msgid\n\n \nstatic inline unsigned long int\nselect_plural (uintmax_t n)\n{\n   \n  enum { PLURAL_REDUCER = 1000000 };\n  return (n <= ULONG_MAX ? n : n % PLURAL_REDUCER + PLURAL_REDUCER);\n}\n\n#define STREQ(a, b) (strcmp (a, b) == 0)\n#define STREQ_LEN(a, b, n) (strncmp (a, b, n) == 0)  \n#define STRPREFIX(a, b) (strncmp (a, b, strlen (b)) == 0)\n\n \n#define STRNCMP_LIT(s, lit) strncmp (s, \"\" lit \"\", sizeof (lit) - 1)\n\n#if !HAVE_DECL_GETLOGIN\nchar *getlogin (void);\n#endif\n\n#if !HAVE_DECL_TTYNAME\nchar *ttyname (int);\n#endif\n\n#if !HAVE_DECL_GETEUID\nuid_t geteuid (void);\n#endif\n\n#if !HAVE_DECL_GETPWUID\nstruct passwd *getpwuid (uid_t);\n#endif\n\n#if !HAVE_DECL_GETGRGID\nstruct group *getgrgid (gid_t);\n#endif\n\n \n \n#if ! HAVE_SETGROUPS\n# if HAVE_GETGRGID_NOMEMBERS\n#  define getgrgid(gid) getgrgid_nomembers(gid)\n# endif\n# if HAVE_GETGRNAM_NOMEMBERS\n#  define getgrnam(nam) getgrnam_nomembers(nam)\n# endif\n# if HAVE_GETGRENT_NOMEMBERS\n#  define getgrent() getgrent_nomembers()\n# endif\n#endif\n\n#if !HAVE_DECL_GETUID\nuid_t getuid (void);\n#endif\n\n#include \"idx.h\"\n#include \"xalloc.h\"\n#include \"verify.h\"\n\n \n#define X2NREALLOC(P, PN) verify_expr (sizeof *(P) != 1, \\\n                                       x2nrealloc (P, PN, sizeof *(P)))\n\n \n#define X2REALLOC(P, PN) verify_expr (sizeof *(P) == 1, \\\n                                      x2realloc (P, PN))\n\n#include \"unlocked-io.h\"\n#include \"same-inode.h\"\n\n#include \"dirname.h\"\n#include \"openat.h\"\n\nstatic inline bool\ndot_or_dotdot (char const *file_name)\n{\n  if (file_name[0] == '.')\n    {\n      char sep = file_name[(file_name[1] == '.') + 1];\n      return (! sep || ISSLASH (sep));\n    }\n  else\n    return false;\n}\n\n \nstatic inline struct dirent const *\nreaddir_ignoring_dot_and_dotdot (DIR *dirp)\n{\n  while (true)\n    {\n      struct dirent const *dp = readdir (dirp);\n      if (dp == nullptr || ! dot_or_dotdot (dp->d_name))\n        return dp;\n    }\n}\n\n \nenum {\n    DS_UNKNOWN = -2,\n    DS_EMPTY = -1,\n    DS_NONEMPTY = 0,\n};\nstatic inline int\ndirectory_status (int fd_cwd, char const *dir)\n{\n  DIR *dirp;\n  bool no_direntries;\n  int saved_errno;\n  int fd = openat (fd_cwd, dir,\n                   (O_RDONLY | O_DIRECTORY\n                    | O_NOCTTY | O_NOFOLLOW | O_NONBLOCK));\n\n  if (fd < 0)\n    return errno;\n\n  dirp = fdopendir (fd);\n  if (dirp == nullptr)\n    {\n      saved_errno = errno;\n      close (fd);\n      return saved_errno;\n    }\n\n  errno = 0;\n  no_direntries = !readdir_ignoring_dot_and_dotdot (dirp);\n  saved_errno = errno;\n  closedir (dirp);\n  return no_direntries && saved_errno == 0 ? DS_EMPTY : saved_errno;\n}\n\n \n\n \nenum\n{\n  GETOPT_HELP_CHAR = (CHAR_MIN - 2),\n  GETOPT_VERSION_CHAR = (CHAR_MIN - 3)\n};\n\n#define GETOPT_HELP_OPTION_DECL \\\n  \"help\", no_argument, nullptr, GETOPT_HELP_CHAR\n#define GETOPT_VERSION_OPTION_DECL \\\n  \"version\", no_argument, nullptr, GETOPT_VERSION_CHAR\n#define GETOPT_SELINUX_CONTEXT_OPTION_DECL \\\n  \"context\", optional_argument, nullptr, 'Z'\n\n#define case_GETOPT_HELP_CHAR\t\t\t\\\n  case GETOPT_HELP_CHAR:\t\t\t\\\n    usage (EXIT_SUCCESS);\t\t\t\\\n    break;\n\n \n#define USAGE_BUILTIN_WARNING \\\n  _(\"\\n\" \\\n\"NOTE: your shell may have its own version of %s, which usually supersedes\\n\" \\\n\"the version described here.  Please refer to your shell's documentation\\n\" \\\n\"for details about the options it supports.\\n\")\n\n#define HELP_OPTION_DESCRIPTION \\\n  _(\"      --help        display this help and exit\\n\")\n#define VERSION_OPTION_DESCRIPTION \\\n  _(\"      --version     output version information and exit\\n\")\n\n#include \"closein.h\"\n#include \"closeout.h\"\n\n#define emit_bug_reporting_address unused__emit_bug_reporting_address\n#include \"version-etc.h\"\n#undef emit_bug_reporting_address\n\n#include \"propername.h\"\n \n#define proper_name(x) proper_name_lite (x, x)\n\n#include \"progname.h\"\n\n#define case_GETOPT_VERSION_CHAR(Program_name, Authors)\t\t\t\\\n  case GETOPT_VERSION_CHAR:\t\t\t\t\t\t\\\n    version_etc (stdout, Program_name, PACKAGE_NAME, Version, Authors,\t\\\n                 (char *) nullptr);\t\t\t\t\t\\\n    exit (EXIT_SUCCESS);\t\t\t\t\t\t\\\n    break;\n\n#include \"minmax.h\"\n#include \"intprops.h\"\n\n#ifndef SSIZE_MAX\n# define SSIZE_MAX TYPE_MAXIMUM (ssize_t)\n#endif\n\n#ifndef OFF_T_MIN\n# define OFF_T_MIN TYPE_MINIMUM (off_t)\n#endif\n\n#ifndef OFF_T_MAX\n# define OFF_T_MAX TYPE_MAXIMUM (off_t)\n#endif\n\n#ifndef UID_T_MAX\n# define UID_T_MAX TYPE_MAXIMUM (uid_t)\n#endif\n\n#ifndef GID_T_MAX\n# define GID_T_MAX TYPE_MAXIMUM (gid_t)\n#endif\n\n#ifndef PID_T_MAX\n# define PID_T_MAX TYPE_MAXIMUM (pid_t)\n#endif\n\n \n#ifdef lint\n# define IF_LINT(Code) Code\n#else\n# define IF_LINT(Code)  \n#endif\n\n \n#ifdef lint\n# define main_exit(status) exit (status)\n#else\n# define main_exit(status) return status\n#endif\n\n#ifdef __GNUC__\n# define LIKELY(cond)    __builtin_expect ((cond), 1)\n# define UNLIKELY(cond)  __builtin_expect ((cond), 0)\n#else\n# define LIKELY(cond)    (cond)\n# define UNLIKELY(cond)  (cond)\n#endif\n\n\n#if defined strdupa\n# define ASSIGN_STRDUPA(DEST, S)\t\t\\\n  do { DEST = strdupa (S); } while (0)\n#else\n# define ASSIGN_STRDUPA(DEST, S)\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      char const *s_ = (S);\t\t\t\\\n      size_t len_ = strlen (s_) + 1;\t\t\\\n      char *tmp_dest_ = alloca (len_);\t\t\\\n      DEST = memcpy (tmp_dest_, s_, len_);\t\\\n    }\t\t\t\t\t\t\\\n  while (0)\n#endif\n\n#if ! HAVE_SYNC\n# define sync()  \n#endif\n\n \n\nATTRIBUTE_CONST\nstatic inline size_t\ngcd (size_t u, size_t v)\n{\n  do\n    {\n      size_t t = u % v;\n      u = v;\n      v = t;\n    }\n  while (v);\n\n  return u;\n}\n\n \n\nATTRIBUTE_CONST\nstatic inline size_t\nlcm (size_t u, size_t v)\n{\n  return u * (v / gcd (u, v));\n}\n\n \n\nstatic inline void *\nptr_align (void const *ptr, size_t alignment)\n{\n  char const *p0 = ptr;\n  char const *p1 = p0 + alignment - 1;\n  return (void *) (p1 - (size_t) p1 % alignment);\n}\n\n \n\nATTRIBUTE_PURE\nstatic inline bool\nis_nul (void const *buf, size_t length)\n{\n  const unsigned char *p = buf;\n \n#if 0 && (_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n  unsigned long word;\n#else\n  unsigned char word;\n#endif\n\n  if (! length)\n      return true;\n\n   \n  while (UNLIKELY (length & (sizeof word - 1)))\n    {\n      if (*p)\n        return false;\n      p++;\n      length--;\n      if (! length)\n        return true;\n   }\n\n   \n  for (;;)\n    {\n      memcpy (&word, p, sizeof word);\n      if (word)\n        return false;\n      p += sizeof word;\n      length -= sizeof word;\n      if (! length)\n        return true;\n      if (UNLIKELY (length & 15) == 0)\n        break;\n   }\n\n    \n   return memcmp (buf, p, length) == 0;\n}\n\n \n\n#define DECIMAL_DIGIT_ACCUMULATE(Accum, Digit_val, Type)\t\t\\\n  (\t\t\t\t\t\t\t\t\t\\\n   (void) (&(Accum) == (Type *) nullptr),   \t\\\n   verify_expr (! TYPE_SIGNED (Type),        \\\n                (((Type) -1 / 10 < (Accum)                              \\\n                  || (Type) ((Accum) * 10 + (Digit_val)) < (Accum))     \\\n                 ? false                                                \\\n                 : (((Accum) = (Accum) * 10 + (Digit_val)), true)))     \\\n  )\n\nstatic inline void\nemit_stdin_note (void)\n{\n  fputs (_(\"\\n\\\nWith no FILE, or when FILE is -, read standard input.\\n\\\n\"), stdout);\n}\nstatic inline void\nemit_mandatory_arg_note (void)\n{\n  fputs (_(\"\\n\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n\"), stdout);\n}\n\nstatic inline void\nemit_size_note (void)\n{\n  fputs (_(\"\\n\\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\n\\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\n\\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\\\n\"), stdout);\n}\n\nstatic inline void\nemit_blocksize_note (char const *program)\n{\n  printf (_(\"\\n\\\nDisplay values are in units of the first available SIZE from --block-size,\\n\\\nand the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\\n\\\nOtherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\\n\\\n\"), program);\n}\n\nstatic inline void\nemit_update_parameters_note (void)\n{\n  fputs (_(\"\\\n\\n\\\nUPDATE controls which existing files in the destination are replaced.\\n\\\n'all' is the default operation when an --update option is not specified,\\n\\\nand results in all existing files in the destination being replaced.\\n\\\n'none' is similar to the --no-clobber option, in that no files in the\\n\\\ndestination are replaced, but also skipped files do not induce a failure.\\n\\\n'older' is the default operation when --update is specified, and results\\n\\\nin files being replaced if they're older than the corresponding source file.\\n\\\n\"), stdout);\n}\n\nstatic inline void\nemit_backup_suffix_note (void)\n{\n  fputs (_(\"\\\n\\n\\\nThe backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\\n\\\nThe version control method may be selected via the --backup option or through\\n\\\nthe VERSION_CONTROL environment variable.  Here are the values:\\n\\\n\\n\\\n\"), stdout);\n  fputs (_(\"\\\n  none, off       never make backups (even if --backup is given)\\n\\\n  numbered, t     make numbered backups\\n\\\n  existing, nil   numbered if numbered backups exist, simple otherwise\\n\\\n  simple, never   always make simple backups\\n\\\n\"), stdout);\n}\n\nstatic inline void\nemit_exec_status (char const *program)\n{\n      printf (_(\"\\n\\\nExit status:\\n\\\n  125  if the %s command itself fails\\n\\\n  126  if COMMAND is found but cannot be invoked\\n\\\n  127  if COMMAND cannot be found\\n\\\n  -    the exit status of COMMAND otherwise\\n\\\n\"), program);\n}\n\nstatic inline void\nemit_ancillary_info (char const *program)\n{\n  struct infomap { char const *program; char const *node; } const infomap[] = {\n    { \"[\", \"test invocation\" },\n    { \"coreutils\", \"Multi-call invocation\" },\n    { \"sha224sum\", \"sha2 utilities\" },\n    { \"sha256sum\", \"sha2 utilities\" },\n    { \"sha384sum\", \"sha2 utilities\" },\n    { \"sha512sum\", \"sha2 utilities\" },\n    { nullptr, nullptr }\n  };\n\n  char const *node = program;\n  struct infomap const *map_prog = infomap;\n\n  while (map_prog->program && ! STREQ (program, map_prog->program))\n    map_prog++;\n\n  if (map_prog->node)\n    node = map_prog->node;\n\n  printf (_(\"\\n%s online help: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n\n  /* Don't output this redundant message for English locales.\n     Note we still output for 'C' so that it gets included in the man page.  */\n  char const *lc_messages = setlocale (LC_MESSAGES, nullptr);\n  if (lc_messages && STRNCMP_LIT (lc_messages, \"en_\"))\n    {\n      /* TRANSLATORS: Replace LANG_CODE in this URL with your language code\n         <https://translationproject.org/team/LANG_CODE.html> to form one of\n         the URLs at https://translationproject.org/team/.  Otherwise, replace\n         the entire URL with your translation team's email address.  */\n      fputs (_(\"Report any translation bugs to \"\n               \"<https:\n    }\n   \n  char const *url_program = STREQ (program, \"[\") ? \"test\" : program;\n  printf (_(\"Full documentation <%s%s>\\n\"),\n          PACKAGE_URL, url_program);\n  printf (_(\"or available locally via: info '(coreutils) %s%s'\\n\"),\n          node, node == program ? \" invocation\" : \"\");\n}\n\n \n#define emit_try_help() \\\n  do \\\n    { \\\n      fprintf (stderr, _(\"Try '%s --help' for more information.\\n\"), \\\n               program_name); \\\n    } \\\n  while (0)\n\n#include \"inttostr.h\"\n\nstatic inline char *\ntimetostr (time_t t, char *buf)\n{\n  return (TYPE_SIGNED (time_t)\n          ? imaxtostr (t, buf)\n          : umaxtostr (t, buf));\n}\n\nstatic inline char *\nbad_cast (char const *s)\n{\n  return (char *) s;\n}\n\n \nstatic inline bool\nusable_st_size (struct stat const *sb)\n{\n  return (S_ISREG (sb->st_mode) || S_ISLNK (sb->st_mode)\n          || S_TYPEISSHM (sb) || S_TYPEISTMO (sb));\n}\n\n_Noreturn void usage (int status);\n\n#include \"error.h\"\n\n \n#define devmsg(...)\t\t\t\\\n  do\t\t\t\t\t\\\n    {\t\t\t\t\t\\\n      if (dev_debug)\t\t\t\\\n        fprintf (stderr, __VA_ARGS__);\t\\\n    }\t\t\t\t\t\\\n  while (0)\n\n#define emit_cycle_warning(file_name)\t\\\n  do\t\t\t\t\t\\\n    {\t\t\t\t\t\\\n      error (0, 0, _(\"\\\nWARNING: Circular directory structure.\\n\\\nThis almost certainly means that you have a corrupted file system.\\n\\\nNOTIFY YOUR SYSTEM MANAGER.\\n\\\nThe following directory is part of the cycle:\\n  %s\\n\"), \\\n             quotef (file_name));\t\\\n    }\t\t\t\t\t\\\n  while (0)\n\n \n\nstatic inline void\nwrite_error (void)\n{\n  int saved_errno = errno;\n  fflush (stdout);     \n  fpurge (stdout);     \n  clearerr (stdout);   \n  error (EXIT_FAILURE, saved_errno, _(\"write error\"));\n}\n\n \nstatic inline char *\nstzncpy (char *restrict dest, char const *restrict src, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len && *src; i++)\n    *dest++ = *src++;\n  *dest = 0;\n  return dest;\n}\n\n#ifndef ARRAY_CARDINALITY\n# define ARRAY_CARDINALITY(Array) (sizeof (Array) / sizeof *(Array))\n#endif\n\n \nstatic inline bool\nis_ENOTSUP (int err)\n{\n  return err == EOPNOTSUPP || (ENOTSUP != EOPNOTSUPP && err == ENOTSUP);\n}\n\n\n \n#include \"quotearg.h\"\n\n \n#define quotef(arg) \\\n  quotearg_n_style_colon (0, shell_escape_quoting_style, arg)\n#define quotef_n(n, arg) \\\n  quotearg_n_style_colon (n, shell_escape_quoting_style, arg)\n\n \n#define quoteaf(arg) \\\n  quotearg_style (shell_escape_always_quoting_style, arg)\n#define quoteaf_n(n, arg) \\\n  quotearg_n_style (n, shell_escape_always_quoting_style, arg)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}