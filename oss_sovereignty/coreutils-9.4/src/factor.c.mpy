{
  "module_name": "factor.c",
  "hash_id": "5f77630675d214e58c588a728b953e746b967b5097707d839ca653b13cbb7b4f",
  "original_prompt": "Ingested from coreutils-9.4/src/factor.c",
  "human_readable_source": " \n\n \n\n \n#ifndef PROVE_PRIMALITY\n# define PROVE_PRIMALITY 1\n#endif\n\n \n#ifndef USE_SQUFOF\n# define USE_SQUFOF 0\n#endif\n\n \n#ifndef STAT_SQUFOF\n# define STAT_SQUFOF 0\n#endif\n\n\n#include <config.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <gmp.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"full-write.h\"\n#include \"quote.h\"\n#include \"readtokens.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"factor\"\n\n#define AUTHORS \\\n  proper_name (\"Paul Rubin\"),                                           \\\n  proper_name_lite (\"Torbjorn Granlund\", \"Torbj\\303\\266rn Granlund\"),   \\\n  proper_name_lite (\"Niels Moller\", \"Niels M\\303\\266ller\")\n\n \n#define DELIM \"\\n\\t \"\n\n#ifndef USE_LONGLONG_H\n \n# if LONG_MAX == INTMAX_MAX\n#  define USE_LONGLONG_H 1\n# endif\n#endif\n\n#if USE_LONGLONG_H\n\n \n\n \n# if UINTMAX_MAX == UINT32_MAX\n#  define W_TYPE_SIZE 32\n# elif UINTMAX_MAX == UINT64_MAX\n#  define W_TYPE_SIZE 64\n# elif UINTMAX_MAX == UINT128_MAX\n#  define W_TYPE_SIZE 128\n# endif\n\n# define UWtype  uintmax_t\n# define UHWtype unsigned long int\n# undef UDWtype\n# if HAVE_ATTRIBUTE_MODE\ntypedef unsigned int UQItype    __attribute__ ((mode (QI)));\ntypedef          int SItype     __attribute__ ((mode (SI)));\ntypedef unsigned int USItype    __attribute__ ((mode (SI)));\ntypedef          int DItype     __attribute__ ((mode (DI)));\ntypedef unsigned int UDItype    __attribute__ ((mode (DI)));\n# else\ntypedef unsigned char UQItype;\ntypedef          long SItype;\ntypedef unsigned long int USItype;\n#  if HAVE_LONG_LONG_INT\ntypedef long long int DItype;\ntypedef unsigned long long int UDItype;\n#  else  \ntypedef long int DItype;\ntypedef unsigned long int UDItype;\n#  endif\n# endif\n# define LONGLONG_STANDALONE      \n# define ASSERT(x)                \n# define __GMP_DECLSPEC           \n# define __clz_tab factor_clz_tab  \n# ifndef __GMP_GNUC_PREREQ\n#  define __GMP_GNUC_PREREQ(a,b) 1\n# endif\n\n \n# if __GMP_GNUC_PREREQ (1,1) && defined __clz_tab\nASSERT (1)\n__GMP_DECLSPEC\n# endif\n\n# if _ARCH_PPC\n#  define HAVE_HOST_CPU_FAMILY_powerpc 1\n# endif\n# include \"longlong.h\"\n# ifdef COUNT_LEADING_ZEROS_NEED_CLZ_TAB\nconst unsigned char factor_clz_tab[129] =\n{\n  1,2,3,3,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n  9\n};\n# endif\n\n#else  \n\n# define W_TYPE_SIZE (8 * sizeof (uintmax_t))\n# define __ll_B ((uintmax_t) 1 << (W_TYPE_SIZE / 2))\n# define __ll_lowpart(t)  ((uintmax_t) (t) & (__ll_B - 1))\n# define __ll_highpart(t) ((uintmax_t) (t) >> (W_TYPE_SIZE / 2))\n\n#endif\n\n#if !defined __clz_tab && !defined UHWtype\n \n#endif\n\n \n#define MAX_NFACTS 26\n\nenum\n{\n  DEV_DEBUG_OPTION = CHAR_MAX + 1\n};\n\nstatic struct option const long_options[] =\n{\n  {\"exponents\", no_argument, nullptr, 'h'},\n  {\"-debug\", no_argument, nullptr, DEV_DEBUG_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic bool print_exponents;\n\nstruct factors\n{\n  uintmax_t     plarge[2];  \n  uintmax_t     p[MAX_NFACTS];\n  unsigned char e[MAX_NFACTS];\n  unsigned char nfactors;\n};\n\nstruct mp_factors\n{\n  mpz_t             *p;\n  unsigned long int *e;\n  idx_t nfactors;\n};\n\nstatic void factor (uintmax_t, uintmax_t, struct factors *);\n\n#ifndef umul_ppmm\n# define umul_ppmm(w1, w0, u, v)                                        \\\n  do {                                                                  \\\n    uintmax_t __x0, __x1, __x2, __x3;                                   \\\n    unsigned long int __ul, __vl, __uh, __vh;                           \\\n    uintmax_t __u = (u), __v = (v);                                     \\\n                                                                        \\\n    __ul = __ll_lowpart (__u);                                          \\\n    __uh = __ll_highpart (__u);                                         \\\n    __vl = __ll_lowpart (__v);                                          \\\n    __vh = __ll_highpart (__v);                                         \\\n                                                                        \\\n    __x0 = (uintmax_t) __ul * __vl;                                     \\\n    __x1 = (uintmax_t) __ul * __vh;                                     \\\n    __x2 = (uintmax_t) __uh * __vl;                                     \\\n    __x3 = (uintmax_t) __uh * __vh;                                     \\\n                                                                        \\\n    __x1 += __ll_highpart (__x0); \t\t\\\n    __x1 += __x2;\t\t \t\t\\\n    if (__x1 < __x2)\t\t \t\t\t\\\n      __x3 += __ll_B;\t\t \t\\\n                                                                        \\\n    (w1) = __x3 + __ll_highpart (__x1);                                 \\\n    (w0) = (__x1 << W_TYPE_SIZE / 2) + __ll_lowpart (__x0);             \\\n  } while (0)\n#endif\n\n#if !defined udiv_qrnnd || defined UDIV_NEEDS_NORMALIZATION\n \n# undef udiv_qrnnd\n# define udiv_qrnnd(q, r, n1, n0, d)                                    \\\n  do {                                                                  \\\n    uintmax_t __d1, __d0, __q, __r1, __r0;                              \\\n                                                                        \\\n    __d1 = (d); __d0 = 0;                                               \\\n    __r1 = (n1); __r0 = (n0);                                           \\\n    affirm (__r1 < __d1);                                               \\\n    __q = 0;                                                            \\\n    for (int __i = W_TYPE_SIZE; __i > 0; __i--)                         \\\n      {                                                                 \\\n        rsh2 (__d1, __d0, __d1, __d0, 1);                               \\\n        __q <<= 1;                                                      \\\n        if (ge2 (__r1, __r0, __d1, __d0))                               \\\n          {                                                             \\\n            __q++;                                                      \\\n            sub_ddmmss (__r1, __r0, __r1, __r0, __d1, __d0);            \\\n          }                                                             \\\n      }                                                                 \\\n    (r) = __r0;                                                         \\\n    (q) = __q;                                                          \\\n  } while (0)\n#endif\n\n#if !defined add_ssaaaa\n# define add_ssaaaa(sh, sl, ah, al, bh, bl)                             \\\n  do {                                                                  \\\n    uintmax_t _add_x;                                                   \\\n    _add_x = (al) + (bl);                                               \\\n    (sh) = (ah) + (bh) + (_add_x < (al));                               \\\n    (sl) = _add_x;                                                      \\\n  } while (0)\n#endif\n\n#define rsh2(rh, rl, ah, al, cnt)                                       \\\n  do {                                                                  \\\n    (rl) = ((ah) << (W_TYPE_SIZE - (cnt))) | ((al) >> (cnt));           \\\n    (rh) = (ah) >> (cnt);                                               \\\n  } while (0)\n\n#define lsh2(rh, rl, ah, al, cnt)                                       \\\n  do {                                                                  \\\n    (rh) = ((ah) << cnt) | ((al) >> (W_TYPE_SIZE - (cnt)));             \\\n    (rl) = (al) << (cnt);                                               \\\n  } while (0)\n\n#define ge2(ah, al, bh, bl)                                             \\\n  ((ah) > (bh) || ((ah) == (bh) && (al) >= (bl)))\n\n#define gt2(ah, al, bh, bl)                                             \\\n  ((ah) > (bh) || ((ah) == (bh) && (al) > (bl)))\n\n#ifndef sub_ddmmss\n# define sub_ddmmss(rh, rl, ah, al, bh, bl)                             \\\n  do {                                                                  \\\n    uintmax_t _cy;                                                      \\\n    _cy = (al) < (bl);                                                  \\\n    (rl) = (al) - (bl);                                                 \\\n    (rh) = (ah) - (bh) - _cy;                                           \\\n  } while (0)\n#endif\n\n#ifndef count_leading_zeros\n# define count_leading_zeros(count, x) do {                             \\\n    uintmax_t __clz_x = (x);                                            \\\n    int __clz_c;                                                        \\\n    for (__clz_c = 0;                                                   \\\n         (__clz_x & ((uintmax_t) 0xff << (W_TYPE_SIZE - 8))) == 0;      \\\n         __clz_c += 8)                                                  \\\n      __clz_x <<= 8;                                                    \\\n    for (; (intmax_t)__clz_x >= 0; __clz_c++)                           \\\n      __clz_x <<= 1;                                                    \\\n    (count) = __clz_c;                                                  \\\n  } while (0)\n#endif\n\n#ifndef count_trailing_zeros\n# define count_trailing_zeros(count, x) do {                            \\\n    uintmax_t __ctz_x = (x);                                            \\\n    int __ctz_c = 0;                                                    \\\n    while ((__ctz_x & 1) == 0)                                          \\\n      {                                                                 \\\n        __ctz_x >>= 1;                                                  \\\n        __ctz_c++;                                                      \\\n      }                                                                 \\\n    (count) = __ctz_c;                                                  \\\n  } while (0)\n#endif\n\n \n#define submod(r,a,b,n)                                                 \\\n  do {                                                                  \\\n    uintmax_t _t = - (uintmax_t) (a < b);                               \\\n    (r) = ((n) & _t) + (a) - (b);                                       \\\n  } while (0)\n\n#define addmod(r,a,b,n)                                                 \\\n  submod ((r), (a), ((n) - (b)), (n))\n\n \n#define addmod2(r1, r0, a1, a0, b1, b0, n1, n0)                         \\\n  do {                                                                  \\\n    add_ssaaaa ((r1), (r0), (a1), (a0), (b1), (b0));                    \\\n    if (ge2 ((r1), (r0), (n1), (n0)))                                   \\\n      sub_ddmmss ((r1), (r0), (r1), (r0), (n1), (n0));                  \\\n  } while (0)\n#define submod2(r1, r0, a1, a0, b1, b0, n1, n0)                         \\\n  do {                                                                  \\\n    sub_ddmmss ((r1), (r0), (a1), (a0), (b1), (b0));                    \\\n    if ((intmax_t) (r1) < 0)                                            \\\n      add_ssaaaa ((r1), (r0), (r1), (r0), (n1), (n0));                  \\\n  } while (0)\n\n#define HIGHBIT_TO_MASK(x)                                              \\\n  (((intmax_t)-1 >> 1) < 0                                              \\\n   ? (uintmax_t)((intmax_t)(x) >> (W_TYPE_SIZE - 1))                    \\\n   : ((x) & ((uintmax_t) 1 << (W_TYPE_SIZE - 1))                        \\\n      ? UINTMAX_MAX : (uintmax_t) 0))\n\n \nstatic uintmax_t\nmod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)\n{\n  int cntd, cnta;\n\n  affirm (d1 != 0);\n\n  if (a1 == 0)\n    {\n      *r1 = 0;\n      return a0;\n    }\n\n  count_leading_zeros (cntd, d1);\n  count_leading_zeros (cnta, a1);\n  int cnt = cntd - cnta;\n  lsh2 (d1, d0, d1, d0, cnt);\n  for (int i = 0; i < cnt; i++)\n    {\n      if (ge2 (a1, a0, d1, d0))\n        sub_ddmmss (a1, a0, a1, a0, d1, d0);\n      rsh2 (d1, d0, d1, d0, 1);\n    }\n\n  *r1 = a1;\n  return a0;\n}\n\nATTRIBUTE_CONST\nstatic uintmax_t\ngcd_odd (uintmax_t a, uintmax_t b)\n{\n  if ((b & 1) == 0)\n    {\n      uintmax_t t = b;\n      b = a;\n      a = t;\n    }\n  if (a == 0)\n    return b;\n\n   \n  b >>= 1;\n\n  for (;;)\n    {\n      uintmax_t t;\n      uintmax_t bgta;\n\n      while ((a & 1) == 0)\n        a >>= 1;\n      a >>= 1;\n\n      t = a - b;\n      if (t == 0)\n        return (a << 1) + 1;\n\n      bgta = HIGHBIT_TO_MASK (t);\n\n       \n      b += (bgta & t);\n\n       \n      a = (t ^ bgta) - bgta;\n    }\n}\n\nstatic uintmax_t\ngcd2_odd (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0)\n{\n  affirm (b0 & 1);\n\n  if ((a0 | a1) == 0)\n    {\n      *r1 = b1;\n      return b0;\n    }\n\n  while ((a0 & 1) == 0)\n    rsh2 (a1, a0, a1, a0, 1);\n\n  for (;;)\n    {\n      if ((b1 | a1) == 0)\n        {\n          *r1 = 0;\n          return gcd_odd (b0, a0);\n        }\n\n      if (gt2 (a1, a0, b1, b0))\n        {\n          sub_ddmmss (a1, a0, a1, a0, b1, b0);\n          do\n            rsh2 (a1, a0, a1, a0, 1);\n          while ((a0 & 1) == 0);\n        }\n      else if (gt2 (b1, b0, a1, a0))\n        {\n          sub_ddmmss (b1, b0, b1, b0, a1, a0);\n          do\n            rsh2 (b1, b0, b1, b0, 1);\n          while ((b0 & 1) == 0);\n        }\n      else\n        break;\n    }\n\n  *r1 = a1;\n  return a0;\n}\n\nstatic void\nfactor_insert_multiplicity (struct factors *factors,\n                            uintmax_t prime, int m)\n{\n  int nfactors = factors->nfactors;\n  uintmax_t *p = factors->p;\n  unsigned char *e = factors->e;\n\n   \n  int i;\n  for (i = nfactors - 1; i >= 0; i--)\n    {\n      if (p[i] <= prime)\n        break;\n    }\n\n  if (i < 0 || p[i] != prime)\n    {\n      for (int j = nfactors - 1; j > i; j--)\n        {\n          p[j + 1] = p[j];\n          e[j + 1] = e[j];\n        }\n      p[i + 1] = prime;\n      e[i + 1] = m;\n      factors->nfactors = nfactors + 1;\n    }\n  else\n    {\n      e[i] += m;\n    }\n}\n\n#define factor_insert(f, p) factor_insert_multiplicity (f, p, 1)\n\nstatic void\nfactor_insert_large (struct factors *factors,\n                     uintmax_t p1, uintmax_t p0)\n{\n  if (p1 > 0)\n    {\n      affirm (factors->plarge[1] == 0);\n      factors->plarge[0] = p0;\n      factors->plarge[1] = p1;\n    }\n  else\n    factor_insert (factors, p0);\n}\n\n#ifndef mpz_inits\n\n# include <stdarg.h>\n\n# define mpz_inits(...) mpz_va_init (mpz_init, __VA_ARGS__)\n# define mpz_clears(...) mpz_va_init (mpz_clear, __VA_ARGS__)\n\nstatic void\nmpz_va_init (void (*mpz_single_init)(mpz_t), ...)\n{\n  va_list ap;\n\n  va_start (ap, mpz_single_init);\n\n  mpz_t *mpz;\n  while ((mpz = va_arg (ap, mpz_t *)))\n    mpz_single_init (*mpz);\n\n  va_end (ap);\n}\n#endif\n\nstatic void mp_factor (mpz_t, struct mp_factors *);\n\nstatic void\nmp_factor_init (struct mp_factors *factors)\n{\n  factors->p = nullptr;\n  factors->e = nullptr;\n  factors->nfactors = 0;\n}\n\nstatic void\nmp_factor_clear (struct mp_factors *factors)\n{\n  for (idx_t i = 0; i < factors->nfactors; i++)\n    mpz_clear (factors->p[i]);\n\n  free (factors->p);\n  free (factors->e);\n}\n\nstatic void\nmp_factor_insert (struct mp_factors *factors, mpz_t prime)\n{\n  idx_t nfactors = factors->nfactors;\n  mpz_t *p = factors->p;\n  unsigned long int *e = factors->e;\n  ptrdiff_t i;\n\n   \n  for (i = nfactors - 1; i >= 0; i--)\n    {\n      if (mpz_cmp (p[i], prime) <= 0)\n        break;\n    }\n\n  if (i < 0 || mpz_cmp (p[i], prime) != 0)\n    {\n      p = xireallocarray (p, nfactors + 1, sizeof p[0]);\n      e = xireallocarray (e, nfactors + 1, sizeof e[0]);\n\n      mpz_init (p[nfactors]);\n      for (long j = nfactors - 1; j > i; j--)\n        {\n          mpz_set (p[j + 1], p[j]);\n          e[j + 1] = e[j];\n        }\n      mpz_set (p[i + 1], prime);\n      e[i + 1] = 1;\n\n      factors->p = p;\n      factors->e = e;\n      factors->nfactors = nfactors + 1;\n    }\n  else\n    {\n      e[i] += 1;\n    }\n}\n\nstatic void\nmp_factor_insert_ui (struct mp_factors *factors, unsigned long int prime)\n{\n  mpz_t pz;\n\n  mpz_init_set_ui (pz, prime);\n  mp_factor_insert (factors, pz);\n  mpz_clear (pz);\n}\n\n\n \nenum { W = sizeof (uintmax_t) * CHAR_BIT };\n\n \nstatic_assert (UINTMAX_MAX >> (W - 1) == 1);\n\n#define P(a,b,c,d) a,\nstatic const unsigned char primes_diff[] = {\n#include \"primes.h\"\n0,0,0,0,0,0,0                            \n};\n#undef P\n\n#define PRIMES_PTAB_ENTRIES \\\n  (sizeof (primes_diff) / sizeof (primes_diff[0]) - 8 + 1)\n\n#define P(a,b,c,d) b,\nstatic const unsigned char primes_diff8[] = {\n#include \"primes.h\"\n0,0,0,0,0,0,0                            \n};\n#undef P\n\nstruct primes_dtab\n{\n  uintmax_t binv, lim;\n};\n\n#define P(a,b,c,d) {c,d},\nstatic const struct primes_dtab primes_dtab[] = {\n#include \"primes.h\"\n{1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0}  \n};\n#undef P\n\n \nstatic_assert (W <= WIDE_UINT_BITS);\n\n \nstatic bool dev_debug = false;\n\n \nstatic bool flag_prove_primality = PROVE_PRIMALITY;\n\n \n#define MR_REPS 25\n\nstatic void\nfactor_insert_refind (struct factors *factors, uintmax_t p, int i, int off)\n{\n  for (int j = 0; j < off; j++)\n    p += primes_diff[i + j];\n  factor_insert (factors, p);\n}\n\n \n\nstatic uintmax_t\nfactor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,\n                       struct factors *factors)\n{\n  if (t0 % 2 == 0)\n    {\n      int cnt;\n\n      if (t0 == 0)\n        {\n          count_trailing_zeros (cnt, t1);\n          t0 = t1 >> cnt;\n          t1 = 0;\n          cnt += W_TYPE_SIZE;\n        }\n      else\n        {\n          count_trailing_zeros (cnt, t0);\n          rsh2 (t1, t0, t1, t0, cnt);\n        }\n\n      factor_insert_multiplicity (factors, 2, cnt);\n    }\n\n  uintmax_t p = 3;\n  idx_t i;\n  for (i = 0; t1 > 0 && i < PRIMES_PTAB_ENTRIES; i++)\n    {\n      for (;;)\n        {\n          uintmax_t q1, q0, hi;\n          MAYBE_UNUSED uintmax_t lo;\n\n          q0 = t0 * primes_dtab[i].binv;\n          umul_ppmm (hi, lo, q0, p);\n          if (hi > t1)\n            break;\n          hi = t1 - hi;\n          q1 = hi * primes_dtab[i].binv;\n          if (LIKELY (q1 > primes_dtab[i].lim))\n            break;\n          t1 = q1; t0 = q0;\n          factor_insert (factors, p);\n        }\n      p += primes_diff[i + 1];\n    }\n  if (t1p)\n    *t1p = t1;\n\n#define DIVBLOCK(I)                                                     \\\n  do {                                                                  \\\n    for (;;)                                                            \\\n      {                                                                 \\\n        q = t0 * pd[I].binv;                                            \\\n        if (LIKELY (q > pd[I].lim))                                     \\\n          break;                                                        \\\n        t0 = q;                                                         \\\n        factor_insert_refind (factors, p, i + 1, I);                    \\\n      }                                                                 \\\n  } while (0)\n\n  for (; i < PRIMES_PTAB_ENTRIES; i += 8)\n    {\n      uintmax_t q;\n      const struct primes_dtab *pd = &primes_dtab[i];\n      DIVBLOCK (0);\n      DIVBLOCK (1);\n      DIVBLOCK (2);\n      DIVBLOCK (3);\n      DIVBLOCK (4);\n      DIVBLOCK (5);\n      DIVBLOCK (6);\n      DIVBLOCK (7);\n\n      p += primes_diff8[i];\n      if (p * p > t0)\n        break;\n    }\n\n  return t0;\n}\n\nstatic void\nmp_factor_using_division (mpz_t t, struct mp_factors *factors)\n{\n  mpz_t q;\n  mp_bitcnt_t p;\n\n  devmsg (\"[trial division] \");\n\n  mpz_init (q);\n\n  p = mpz_scan1 (t, 0);\n  mpz_fdiv_q_2exp (t, t, p);\n  while (p)\n    {\n      mp_factor_insert_ui (factors, 2);\n      --p;\n    }\n\n  unsigned long int d = 3;\n  for (idx_t i = 1; i <= PRIMES_PTAB_ENTRIES;)\n    {\n      if (! mpz_divisible_ui_p (t, d))\n        {\n          d += primes_diff[i++];\n          if (mpz_cmp_ui (t, d * d) < 0)\n            break;\n        }\n      else\n        {\n          mpz_tdiv_q_ui (t, t, d);\n          mp_factor_insert_ui (factors, d);\n        }\n    }\n\n  mpz_clear (q);\n}\n\n \nstatic const unsigned char  binvert_table[128] =\n{\n  0x01, 0xAB, 0xCD, 0xB7, 0x39, 0xA3, 0xC5, 0xEF,\n  0xF1, 0x1B, 0x3D, 0xA7, 0x29, 0x13, 0x35, 0xDF,\n  0xE1, 0x8B, 0xAD, 0x97, 0x19, 0x83, 0xA5, 0xCF,\n  0xD1, 0xFB, 0x1D, 0x87, 0x09, 0xF3, 0x15, 0xBF,\n  0xC1, 0x6B, 0x8D, 0x77, 0xF9, 0x63, 0x85, 0xAF,\n  0xB1, 0xDB, 0xFD, 0x67, 0xE9, 0xD3, 0xF5, 0x9F,\n  0xA1, 0x4B, 0x6D, 0x57, 0xD9, 0x43, 0x65, 0x8F,\n  0x91, 0xBB, 0xDD, 0x47, 0xC9, 0xB3, 0xD5, 0x7F,\n  0x81, 0x2B, 0x4D, 0x37, 0xB9, 0x23, 0x45, 0x6F,\n  0x71, 0x9B, 0xBD, 0x27, 0xA9, 0x93, 0xB5, 0x5F,\n  0x61, 0x0B, 0x2D, 0x17, 0x99, 0x03, 0x25, 0x4F,\n  0x51, 0x7B, 0x9D, 0x07, 0x89, 0x73, 0x95, 0x3F,\n  0x41, 0xEB, 0x0D, 0xF7, 0x79, 0xE3, 0x05, 0x2F,\n  0x31, 0x5B, 0x7D, 0xE7, 0x69, 0x53, 0x75, 0x1F,\n  0x21, 0xCB, 0xED, 0xD7, 0x59, 0xC3, 0xE5, 0x0F,\n  0x11, 0x3B, 0x5D, 0xC7, 0x49, 0x33, 0x55, 0xFF\n};\n\n \n#define binv(inv,n)                                                     \\\n  do {                                                                  \\\n    uintmax_t  __n = (n);                                               \\\n    uintmax_t  __inv;                                                   \\\n                                                                        \\\n    __inv = binvert_table[(__n / 2) & 0x7F];                     \\\n    if (W_TYPE_SIZE > 8)   __inv = 2 * __inv - __inv * __inv * __n;     \\\n    if (W_TYPE_SIZE > 16)  __inv = 2 * __inv - __inv * __inv * __n;     \\\n    if (W_TYPE_SIZE > 32)  __inv = 2 * __inv - __inv * __inv * __n;     \\\n                                                                        \\\n    if (W_TYPE_SIZE > 64)                                               \\\n      {                                                                 \\\n        int  __invbits = 64;                                            \\\n        do {                                                            \\\n          __inv = 2 * __inv - __inv * __inv * __n;                      \\\n          __invbits *= 2;                                               \\\n        } while (__invbits < W_TYPE_SIZE);                              \\\n      }                                                                 \\\n                                                                        \\\n    (inv) = __inv;                                                      \\\n  } while (0)\n\n \n#define divexact_21(q1, q0, u1, u0, d)                                  \\\n  do {                                                                  \\\n    uintmax_t _di, _q0;                                                 \\\n    binv (_di, (d));                                                    \\\n    _q0 = (u0) * _di;                                                   \\\n    if ((u1) >= (d))                                                    \\\n      {                                                                 \\\n        uintmax_t _p1;                                                  \\\n        MAYBE_UNUSED intmax_t _p0;                                      \\\n        umul_ppmm (_p1, _p0, _q0, d);                                   \\\n        (q1) = ((u1) - _p1) * _di;                                      \\\n        (q0) = _q0;                                                     \\\n      }                                                                 \\\n    else                                                                \\\n      {                                                                 \\\n        (q0) = _q0;                                                     \\\n        (q1) = 0;                                                       \\\n      }                                                                 \\\n  } while (0)\n\n \n#define redcify(r_prim, r, n)                                           \\\n  do {                                                                  \\\n    MAYBE_UNUSED uintmax_t _redcify_q;\t\t\t\t\t\\\n    udiv_qrnnd (_redcify_q, r_prim, r, 0, n);                           \\\n  } while (0)\n\n \n#define redcify2(r1, r0, x, n1, n0)                                     \\\n  do {                                                                  \\\n    uintmax_t _r1, _r0, _i;                                             \\\n    if ((x) < (n1))                                                     \\\n      {                                                                 \\\n        _r1 = (x); _r0 = 0;                                             \\\n        _i = W_TYPE_SIZE;                                               \\\n      }                                                                 \\\n    else                                                                \\\n      {                                                                 \\\n        _r1 = 0; _r0 = (x);                                             \\\n        _i = 2 * W_TYPE_SIZE;                                           \\\n      }                                                                 \\\n    while (_i-- > 0)                                                    \\\n      {                                                                 \\\n        lsh2 (_r1, _r0, _r1, _r0, 1);                                   \\\n        if (ge2 (_r1, _r0, (n1), (n0)))                                 \\\n          sub_ddmmss (_r1, _r0, _r1, _r0, (n1), (n0));                  \\\n      }                                                                 \\\n    (r1) = _r1;                                                         \\\n    (r0) = _r0;                                                         \\\n  } while (0)\n\n \nstatic inline uintmax_t\nmulredc (uintmax_t a, uintmax_t b, uintmax_t m, uintmax_t mi)\n{\n  uintmax_t rh, rl, q, th, xh;\n  MAYBE_UNUSED uintmax_t tl;\n\n  umul_ppmm (rh, rl, a, b);\n  q = rl * mi;\n  umul_ppmm (th, tl, q, m);\n  xh = rh - th;\n  if (rh < th)\n    xh += m;\n\n  return xh;\n}\n\n \nstatic uintmax_t\nmulredc2 (uintmax_t *r1p,\n          uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0,\n          uintmax_t m1, uintmax_t m0, uintmax_t mi)\n{\n  uintmax_t r1, r0, q, p1, t1, t0, s1, s0;\n  MAYBE_UNUSED uintmax_t p0;\n  mi = -mi;\n  affirm ((a1 >> (W_TYPE_SIZE - 1)) == 0);\n  affirm ((b1 >> (W_TYPE_SIZE - 1)) == 0);\n  affirm ((m1 >> (W_TYPE_SIZE - 1)) == 0);\n\n   \n  umul_ppmm (t1, t0, a0, b0);\n  umul_ppmm (r1, r0, a0, b1);\n  q = mi * t0;\n  umul_ppmm (p1, p0, q, m0);\n  umul_ppmm (s1, s0, q, m1);\n  r0 += (t0 != 0);  \n  add_ssaaaa (r1, r0, r1, r0, 0, p1);\n  add_ssaaaa (r1, r0, r1, r0, 0, t1);\n  add_ssaaaa (r1, r0, r1, r0, s1, s0);\n\n   \n  umul_ppmm (t1, t0, a1, b0);\n  umul_ppmm (s1, s0, a1, b1);\n  add_ssaaaa (t1, t0, t1, t0, 0, r0);\n  q = mi * t0;\n  add_ssaaaa (r1, r0, s1, s0, 0, r1);\n  umul_ppmm (p1, p0, q, m0);\n  umul_ppmm (s1, s0, q, m1);\n  r0 += (t0 != 0);  \n  add_ssaaaa (r1, r0, r1, r0, 0, p1);\n  add_ssaaaa (r1, r0, r1, r0, 0, t1);\n  add_ssaaaa (r1, r0, r1, r0, s1, s0);\n\n  if (ge2 (r1, r0, m1, m0))\n    sub_ddmmss (r1, r0, r1, r0, m1, m0);\n\n  *r1p = r1;\n  return r0;\n}\n\nATTRIBUTE_CONST\nstatic uintmax_t\npowm (uintmax_t b, uintmax_t e, uintmax_t n, uintmax_t ni, uintmax_t one)\n{\n  uintmax_t y = one;\n\n  if (e & 1)\n    y = b;\n\n  while (e != 0)\n    {\n      b = mulredc (b, b, n, ni);\n      e >>= 1;\n\n      if (e & 1)\n        y = mulredc (y, b, n, ni);\n    }\n\n  return y;\n}\n\nstatic uintmax_t\npowm2 (uintmax_t *r1m,\n       const uintmax_t *bp, const uintmax_t *ep, const uintmax_t *np,\n       uintmax_t ni, const uintmax_t *one)\n{\n  uintmax_t r1, r0, b1, b0, n1, n0;\n  int i;\n  uintmax_t e;\n\n  b0 = bp[0];\n  b1 = bp[1];\n  n0 = np[0];\n  n1 = np[1];\n\n  r0 = one[0];\n  r1 = one[1];\n\n  for (e = ep[0], i = W_TYPE_SIZE; i > 0; i--, e >>= 1)\n    {\n      if (e & 1)\n        {\n          r0 = mulredc2 (r1m, r1, r0, b1, b0, n1, n0, ni);\n          r1 = *r1m;\n        }\n      b0 = mulredc2 (r1m, b1, b0, b1, b0, n1, n0, ni);\n      b1 = *r1m;\n    }\n  for (e = ep[1]; e > 0; e >>= 1)\n    {\n      if (e & 1)\n        {\n          r0 = mulredc2 (r1m, r1, r0, b1, b0, n1, n0, ni);\n          r1 = *r1m;\n        }\n      b0 = mulredc2 (r1m, b1, b0, b1, b0, n1, n0, ni);\n      b1 = *r1m;\n    }\n  *r1m = r1;\n  return r0;\n}\n\nATTRIBUTE_CONST\nstatic bool\nmillerrabin (uintmax_t n, uintmax_t ni, uintmax_t b, uintmax_t q,\n             int k, uintmax_t one)\n{\n  uintmax_t y = powm (b, q, n, ni, one);\n\n  uintmax_t nm1 = n - one;       \n\n  if (y == one || y == nm1)\n    return true;\n\n  for (int i = 1; i < k; i++)\n    {\n      y = mulredc (y, y, n, ni);\n\n      if (y == nm1)\n        return true;\n      if (y == one)\n        return false;\n    }\n  return false;\n}\n\nATTRIBUTE_PURE static bool\nmillerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,\n              const uintmax_t *qp, int k, const uintmax_t *one)\n{\n  uintmax_t y1, y0, nm1_1, nm1_0, r1m;\n\n  y0 = powm2 (&r1m, bp, qp, np, ni, one);\n  y1 = r1m;\n\n  if (y0 == one[0] && y1 == one[1])\n    return true;\n\n  sub_ddmmss (nm1_1, nm1_0, np[1], np[0], one[1], one[0]);\n\n  if (y0 == nm1_0 && y1 == nm1_1)\n    return true;\n\n  for (int i = 1; i < k; i++)\n    {\n      y0 = mulredc2 (&r1m, y1, y0, y1, y0, np[1], np[0], ni);\n      y1 = r1m;\n\n      if (y0 == nm1_0 && y1 == nm1_1)\n        return true;\n      if (y0 == one[0] && y1 == one[1])\n        return false;\n    }\n  return false;\n}\n\nstatic bool\nmp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,\n                mpz_srcptr q, mp_bitcnt_t k)\n{\n  mpz_powm (y, x, q, n);\n\n  if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)\n    return true;\n\n  for (mp_bitcnt_t i = 1; i < k; i++)\n    {\n      mpz_powm_ui (y, y, 2, n);\n      if (mpz_cmp (y, nm1) == 0)\n        return true;\n      if (mpz_cmp_ui (y, 1) == 0)\n        return false;\n    }\n  return false;\n}\n\n \nstatic bool ATTRIBUTE_PURE\nprime_p (uintmax_t n)\n{\n  mp_bitcnt_t k;\n  bool is_prime;\n  uintmax_t a_prim, one, ni;\n  struct factors factors;\n\n  if (n <= 1)\n    return false;\n\n   \n  if (n < (uintmax_t) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME)\n    return true;\n\n   \n  uintmax_t q = n - 1;\n  for (k = 0; (q & 1) == 0; k++)\n    q >>= 1;\n\n  uintmax_t a = 2;\n  binv (ni, n);                  \n  redcify (one, 1, n);\n  addmod (a_prim, one, one, n);  \n\n   \n  if (!millerrabin (n, ni, a_prim, q, k, one))\n    return false;\n\n  if (flag_prove_primality)\n    {\n       \n      factor (0, n - 1, &factors);\n    }\n\n   \n  for (idx_t r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n    {\n      if (flag_prove_primality)\n        {\n          is_prime = true;\n          for (int i = 0; i < factors.nfactors && is_prime; i++)\n            {\n              is_prime\n                = powm (a_prim, (n - 1) / factors.p[i], n, ni, one) != one;\n            }\n        }\n      else\n        {\n           \n          is_prime = (r == MR_REPS - 1);\n        }\n\n      if (is_prime)\n        return true;\n\n      a += primes_diff[r];       \n\n       \n      {\n        uintmax_t s1, s0;\n        umul_ppmm (s1, s0, one, a);\n        if (LIKELY (s1 == 0))\n          a_prim = s0 % n;\n        else\n          {\n            MAYBE_UNUSED uintmax_t dummy;\n            udiv_qrnnd (dummy, a_prim, s1, s0, n);\n          }\n      }\n\n      if (!millerrabin (n, ni, a_prim, q, k, one))\n        return false;\n    }\n\n  affirm (!\"Lucas prime test failure.  This should not happen\");\n}\n\nstatic bool ATTRIBUTE_PURE\nprime2_p (uintmax_t n1, uintmax_t n0)\n{\n  uintmax_t q[2], nm1[2];\n  uintmax_t a_prim[2];\n  uintmax_t one[2];\n  uintmax_t na[2];\n  uintmax_t ni;\n  int k;\n  struct factors factors;\n\n  if (n1 == 0)\n    return prime_p (n0);\n\n  nm1[1] = n1 - (n0 == 0);\n  nm1[0] = n0 - 1;\n  if (nm1[0] == 0)\n    {\n      count_trailing_zeros (k, nm1[1]);\n\n      q[0] = nm1[1] >> k;\n      q[1] = 0;\n      k += W_TYPE_SIZE;\n    }\n  else\n    {\n      count_trailing_zeros (k, nm1[0]);\n      rsh2 (q[1], q[0], nm1[1], nm1[0], k);\n    }\n\n  uintmax_t a = 2;\n  binv (ni, n0);\n  redcify2 (one[1], one[0], 1, n1, n0);\n  addmod2 (a_prim[1], a_prim[0], one[1], one[0], one[1], one[0], n1, n0);\n\n   \n  na[0] = n0;\n  na[1] = n1;\n\n  if (!millerrabin2 (na, ni, a_prim, q, k, one))\n    return false;\n\n  if (flag_prove_primality)\n    {\n       \n      factor (nm1[1], nm1[0], &factors);\n    }\n\n   \n  for (idx_t r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n    {\n      bool is_prime;\n      uintmax_t e[2], y[2];\n\n      if (flag_prove_primality)\n        {\n          is_prime = true;\n          if (factors.plarge[1])\n            {\n              uintmax_t pi;\n              binv (pi, factors.plarge[0]);\n              e[0] = pi * nm1[0];\n              e[1] = 0;\n              y[0] = powm2 (&y[1], a_prim, e, na, ni, one);\n              is_prime = (y[0] != one[0] || y[1] != one[1]);\n            }\n          for (int i = 0; i < factors.nfactors && is_prime; i++)\n            {\n               \n              if (factors.p[i] == 2)\n                rsh2 (e[1], e[0], nm1[1], nm1[0], 1);\n              else\n                divexact_21 (e[1], e[0], nm1[1], nm1[0], factors.p[i]);\n              y[0] = powm2 (&y[1], a_prim, e, na, ni, one);\n              is_prime = (y[0] != one[0] || y[1] != one[1]);\n            }\n        }\n      else\n        {\n           \n          is_prime = (r == MR_REPS - 1);\n        }\n\n      if (is_prime)\n        return true;\n\n      a += primes_diff[r];       \n      redcify2 (a_prim[1], a_prim[0], a, n1, n0);\n\n      if (!millerrabin2 (na, ni, a_prim, q, k, one))\n        return false;\n    }\n\n  affirm (!\"Lucas prime test failure.  This should not happen\");\n}\n\nstatic bool\nmp_prime_p (mpz_t n)\n{\n  bool is_prime;\n  mpz_t q, a, nm1, tmp;\n  struct mp_factors factors;\n\n  if (mpz_cmp_ui (n, 1) <= 0)\n    return false;\n\n   \n  if (mpz_cmp_ui (n, (long) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME) < 0)\n    return true;\n\n  mpz_inits (q, a, nm1, tmp, nullptr);\n\n   \n  mpz_sub_ui (nm1, n, 1);\n\n   \n  mp_bitcnt_t k = mpz_scan1 (nm1, 0);\n  mpz_tdiv_q_2exp (q, nm1, k);\n\n  mpz_set_ui (a, 2);\n\n   \n  if (!mp_millerrabin (n, nm1, a, tmp, q, k))\n    {\n      is_prime = false;\n      goto ret2;\n    }\n\n  if (flag_prove_primality)\n    {\n       \n      mpz_set (tmp, nm1);\n      mp_factor (tmp, &factors);\n    }\n\n   \n  for (idx_t r = 0; r < PRIMES_PTAB_ENTRIES; r++)\n    {\n      if (flag_prove_primality)\n        {\n          is_prime = true;\n          for (idx_t i = 0; i < factors.nfactors && is_prime; i++)\n            {\n              mpz_divexact (tmp, nm1, factors.p[i]);\n              mpz_powm (tmp, a, tmp, n);\n              is_prime = mpz_cmp_ui (tmp, 1) != 0;\n            }\n        }\n      else\n        {\n           \n          is_prime = (r == MR_REPS - 1);\n        }\n\n      if (is_prime)\n        goto ret1;\n\n      mpz_add_ui (a, a, primes_diff[r]);         \n\n      if (!mp_millerrabin (n, nm1, a, tmp, q, k))\n        {\n          is_prime = false;\n          goto ret1;\n        }\n    }\n\n  affirm (!\"Lucas prime test failure.  This should not happen\");\n\n ret1:\n  if (flag_prove_primality)\n    mp_factor_clear (&factors);\n ret2:\n  mpz_clears (q, a, nm1, tmp, nullptr);\n\n  return is_prime;\n}\n\nstatic void\nfactor_using_pollard_rho (uintmax_t n, unsigned long int a,\n                          struct factors *factors)\n{\n  uintmax_t x, z, y, P, t, ni, g;\n\n  unsigned long int k = 1;\n  unsigned long int l = 1;\n\n  redcify (P, 1, n);\n  addmod (x, P, P, n);           \n  y = z = x;\n\n  while (n != 1)\n    {\n      affirm (a < n);\n\n      binv (ni, n);              \n\n      for (;;)\n        {\n          do\n            {\n              x = mulredc (x, x, n, ni);\n              addmod (x, x, a, n);\n\n              submod (t, z, x, n);\n              P = mulredc (P, t, n, ni);\n\n              if (k % 32 == 1)\n                {\n                  if (gcd_odd (P, n) != 1)\n                    goto factor_found;\n                  y = x;\n                }\n            }\n          while (--k != 0);\n\n          z = x;\n          k = l;\n          l = 2 * l;\n          for (unsigned long int i = 0; i < k; i++)\n            {\n              x = mulredc (x, x, n, ni);\n              addmod (x, x, a, n);\n            }\n          y = x;\n        }\n\n    factor_found:\n      do\n        {\n          y = mulredc (y, y, n, ni);\n          addmod (y, y, a, n);\n\n          submod (t, z, y, n);\n          g = gcd_odd (t, n);\n        }\n      while (g == 1);\n\n      if (n == g)\n        {\n           \n          factor_using_pollard_rho (n, a + 1, factors);\n          return;\n        }\n\n      n = n / g;\n\n      if (!prime_p (g))\n        factor_using_pollard_rho (g, a + 1, factors);\n      else\n        factor_insert (factors, g);\n\n      if (prime_p (n))\n        {\n          factor_insert (factors, n);\n          break;\n        }\n\n      x = x % n;\n      z = z % n;\n      y = y % n;\n    }\n}\n\nstatic void\nfactor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,\n                           struct factors *factors)\n{\n  uintmax_t x1, x0, z1, z0, y1, y0, P1, P0, t1, t0, ni, g1, g0, r1m;\n\n  unsigned long int k = 1;\n  unsigned long int l = 1;\n\n  redcify2 (P1, P0, 1, n1, n0);\n  addmod2 (x1, x0, P1, P0, P1, P0, n1, n0);  \n  y1 = z1 = x1;\n  y0 = z0 = x0;\n\n  while (n1 != 0 || n0 != 1)\n    {\n      binv (ni, n0);\n\n      for (;;)\n        {\n          do\n            {\n              x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);\n              x1 = r1m;\n              addmod2 (x1, x0, x1, x0, 0, (uintmax_t) a, n1, n0);\n\n              submod2 (t1, t0, z1, z0, x1, x0, n1, n0);\n              P0 = mulredc2 (&r1m, P1, P0, t1, t0, n1, n0, ni);\n              P1 = r1m;\n\n              if (k % 32 == 1)\n                {\n                  g0 = gcd2_odd (&g1, P1, P0, n1, n0);\n                  if (g1 != 0 || g0 != 1)\n                    goto factor_found;\n                  y1 = x1; y0 = x0;\n                }\n            }\n          while (--k != 0);\n\n          z1 = x1; z0 = x0;\n          k = l;\n          l = 2 * l;\n          for (unsigned long int i = 0; i < k; i++)\n            {\n              x0 = mulredc2 (&r1m, x1, x0, x1, x0, n1, n0, ni);\n              x1 = r1m;\n              addmod2 (x1, x0, x1, x0, 0, (uintmax_t) a, n1, n0);\n            }\n          y1 = x1; y0 = x0;\n        }\n\n    factor_found:\n      do\n        {\n          y0 = mulredc2 (&r1m, y1, y0, y1, y0, n1, n0, ni);\n          y1 = r1m;\n          addmod2 (y1, y0, y1, y0, 0, (uintmax_t) a, n1, n0);\n\n          submod2 (t1, t0, z1, z0, y1, y0, n1, n0);\n          g0 = gcd2_odd (&g1, t1, t0, n1, n0);\n        }\n      while (g1 == 0 && g0 == 1);\n\n      if (g1 == 0)\n        {\n           \n          divexact_21 (n1, n0, n1, n0, g0);      \n\n          if (!prime_p (g0))\n            factor_using_pollard_rho (g0, a + 1, factors);\n          else\n            factor_insert (factors, g0);\n        }\n      else\n        {\n           \n          uintmax_t ginv;\n\n          if (n1 == g1 && n0 == g0)\n            {\n               \n              factor_using_pollard_rho2 (n1, n0, a + 1, factors);\n              return;\n            }\n\n           \n          binv (ginv, g0);\n          n0 = ginv * n0;\n          n1 = 0;\n\n          if (!prime2_p (g1, g0))\n            factor_using_pollard_rho2 (g1, g0, a + 1, factors);\n          else\n            factor_insert_large (factors, g1, g0);\n        }\n\n      if (n1 == 0)\n        {\n          if (prime_p (n0))\n            {\n              factor_insert (factors, n0);\n              break;\n            }\n\n          factor_using_pollard_rho (n0, a, factors);\n          return;\n        }\n\n      if (prime2_p (n1, n0))\n        {\n          factor_insert_large (factors, n1, n0);\n          break;\n        }\n\n      x0 = mod2 (&x1, x1, x0, n1, n0);\n      z0 = mod2 (&z1, z1, z0, n1, n0);\n      y0 = mod2 (&y1, y1, y0, n1, n0);\n    }\n}\n\nstatic void\nmp_factor_using_pollard_rho (mpz_t n, unsigned long int a,\n                             struct mp_factors *factors)\n{\n  mpz_t x, z, y, P;\n  mpz_t t, t2;\n\n  devmsg (\"[pollard-rho (%lu)] \", a);\n\n  mpz_inits (t, t2, nullptr);\n  mpz_init_set_si (y, 2);\n  mpz_init_set_si (x, 2);\n  mpz_init_set_si (z, 2);\n  mpz_init_set_ui (P, 1);\n\n  unsigned long long int k = 1;\n  unsigned long long int l = 1;\n\n  while (mpz_cmp_ui (n, 1) != 0)\n    {\n      for (;;)\n        {\n          do\n            {\n              mpz_mul (t, x, x);\n              mpz_mod (x, t, n);\n              mpz_add_ui (x, x, a);\n\n              mpz_sub (t, z, x);\n              mpz_mul (t2, P, t);\n              mpz_mod (P, t2, n);\n\n              if (k % 32 == 1)\n                {\n                  mpz_gcd (t, P, n);\n                  if (mpz_cmp_ui (t, 1) != 0)\n                    goto factor_found;\n                  mpz_set (y, x);\n                }\n            }\n          while (--k != 0);\n\n          mpz_set (z, x);\n          k = l;\n          l = 2 * l;\n          for (unsigned long long int i = 0; i < k; i++)\n            {\n              mpz_mul (t, x, x);\n              mpz_mod (x, t, n);\n              mpz_add_ui (x, x, a);\n            }\n          mpz_set (y, x);\n        }\n\n    factor_found:\n      do\n        {\n          mpz_mul (t, y, y);\n          mpz_mod (y, t, n);\n          mpz_add_ui (y, y, a);\n\n          mpz_sub (t, z, y);\n          mpz_gcd (t, t, n);\n        }\n      while (mpz_cmp_ui (t, 1) == 0);\n\n      mpz_divexact (n, n, t);    \n\n      if (!mp_prime_p (t))\n        {\n          devmsg (\"[composite factor--restarting pollard-rho] \");\n          mp_factor_using_pollard_rho (t, a + 1, factors);\n        }\n      else\n        {\n          mp_factor_insert (factors, t);\n        }\n\n      if (mp_prime_p (n))\n        {\n          mp_factor_insert (factors, n);\n          break;\n        }\n\n      mpz_mod (x, x, n);\n      mpz_mod (z, z, n);\n      mpz_mod (y, y, n);\n    }\n\n  mpz_clears (P, t2, t, z, x, y, nullptr);\n}\n\n#if USE_SQUFOF\n \nATTRIBUTE_CONST\nstatic uintmax_t\nisqrt (uintmax_t n)\n{\n  uintmax_t x;\n  int c;\n  if (n == 0)\n    return 0;\n\n  count_leading_zeros (c, n);\n\n   \n  x = (uintmax_t) 1 << ((W_TYPE_SIZE + 1 - c) >> 1);\n\n  for (;;)\n    {\n      uintmax_t y = (x + n / x) / 2;\n      if (y >= x)\n        return x;\n\n      x = y;\n    }\n}\n\nATTRIBUTE_CONST\nstatic uintmax_t\nisqrt2 (uintmax_t nh, uintmax_t nl)\n{\n  int shift;\n  uintmax_t x;\n\n   \n  affirm (nh < ((uintmax_t) 1 << (W_TYPE_SIZE - 2)));\n\n  if (nh == 0)\n    return isqrt (nl);\n\n  count_leading_zeros (shift, nh);\n  shift &= ~1;\n\n   \n  x = isqrt ((nh << shift) + (nl >> (W_TYPE_SIZE - shift))) + 1;\n  x <<= (W_TYPE_SIZE - shift) >> 1;\n\n   \n  for (;;)\n    {\n      MAYBE_UNUSED uintmax_t r;\n      uintmax_t q, y;\n      udiv_qrnnd (q, r, nh, nl, x);\n      y = (x + q) / 2;\n\n      if (y >= x)\n        {\n          uintmax_t hi, lo;\n          umul_ppmm (hi, lo, x + 1, x + 1);\n          affirm (gt2 (hi, lo, nh, nl));\n\n          umul_ppmm (hi, lo, x, x);\n          affirm (ge2 (nh, nl, hi, lo));\n          sub_ddmmss (hi, lo, nh, nl, hi, lo);\n          affirm (hi == 0);\n\n          return x;\n        }\n\n      x = y;\n    }\n}\n\n \n# define MAGIC64 0x0202021202030213ULL\n# define MAGIC63 0x0402483012450293ULL\n# define MAGIC65 0x218a019866014613ULL\n# define MAGIC11 0x23b\n\n \nATTRIBUTE_CONST\nstatic uintmax_t\nis_square (uintmax_t x)\n{\n   \n  if (((MAGIC64 >> (x & 63)) & 1)\n      && ((MAGIC63 >> (x % 63)) & 1)\n       \n      && ((MAGIC65 >> ((x % 65) & 63)) & 1)\n      && ((MAGIC11 >> (x % 11) & 1)))\n    {\n      uintmax_t r = isqrt (x);\n      if (r * r == x)\n        return r;\n    }\n  return 0;\n}\n\n \nstatic short const invtab[0x81] =\n  {\n    0x200,\n    0x1fc, 0x1f8, 0x1f4, 0x1f0, 0x1ec, 0x1e9, 0x1e5, 0x1e1,\n    0x1de, 0x1da, 0x1d7, 0x1d4, 0x1d0, 0x1cd, 0x1ca, 0x1c7,\n    0x1c3, 0x1c0, 0x1bd, 0x1ba, 0x1b7, 0x1b4, 0x1b2, 0x1af,\n    0x1ac, 0x1a9, 0x1a6, 0x1a4, 0x1a1, 0x19e, 0x19c, 0x199,\n    0x197, 0x194, 0x192, 0x18f, 0x18d, 0x18a, 0x188, 0x186,\n    0x183, 0x181, 0x17f, 0x17d, 0x17a, 0x178, 0x176, 0x174,\n    0x172, 0x170, 0x16e, 0x16c, 0x16a, 0x168, 0x166, 0x164,\n    0x162, 0x160, 0x15e, 0x15c, 0x15a, 0x158, 0x157, 0x155,\n    0x153, 0x151, 0x150, 0x14e, 0x14c, 0x14a, 0x149, 0x147,\n    0x146, 0x144, 0x142, 0x141, 0x13f, 0x13e, 0x13c, 0x13b,\n    0x139, 0x138, 0x136, 0x135, 0x133, 0x132, 0x130, 0x12f,\n    0x12e, 0x12c, 0x12b, 0x129, 0x128, 0x127, 0x125, 0x124,\n    0x123, 0x121, 0x120, 0x11f, 0x11e, 0x11c, 0x11b, 0x11a,\n    0x119, 0x118, 0x116, 0x115, 0x114, 0x113, 0x112, 0x111,\n    0x10f, 0x10e, 0x10d, 0x10c, 0x10b, 0x10a, 0x109, 0x108,\n    0x107, 0x106, 0x105, 0x104, 0x103, 0x102, 0x101, 0x100,\n  };\n\n \n# define div_smallq(q, r, u, d)                                          \\\n  do {                                                                  \\\n    if ((u) / 0x40 < (d))                                               \\\n      {                                                                 \\\n        int _cnt;                                                       \\\n        uintmax_t _dinv, _mask, _q, _r;                                 \\\n        count_leading_zeros (_cnt, (d));                                \\\n        _r = (u);                                                       \\\n        if (UNLIKELY (_cnt > (W_TYPE_SIZE - 8)))                        \\\n          {                                                             \\\n            _dinv = invtab[((d) << (_cnt + 8 - W_TYPE_SIZE)) - 0x80];   \\\n            _q = _dinv * _r >> (8 + W_TYPE_SIZE - _cnt);                \\\n          }                                                             \\\n        else                                                            \\\n          {                                                             \\\n            _dinv = invtab[((d) >> (W_TYPE_SIZE - 8 - _cnt)) - 0x7f];   \\\n            _q = _dinv * (_r >> (W_TYPE_SIZE - 3 - _cnt)) >> 11;        \\\n          }                                                             \\\n        _r -= _q * (d);                                                 \\\n                                                                        \\\n        _mask = -(uintmax_t) (_r >= (d));                               \\\n        (r) = _r - (_mask & (d));                                       \\\n        (q) = _q - _mask;                                               \\\n        affirm ((q) * (d) + (r) == u);\t\t\t\t\t\\\n      }                                                                 \\\n    else                                                                \\\n      {                                                                 \\\n        uintmax_t _q = (u) / (d);                                       \\\n        (r) = (u) - _q * (d);                                           \\\n        (q) = _q;                                                       \\\n      }                                                                 \\\n  } while (0)\n\n \n\n \n# define QUEUE_SIZE 50\n#endif\n\n#if STAT_SQUFOF\n# define Q_FREQ_SIZE 50\n \nstatic int q_freq[Q_FREQ_SIZE + 1];\n#endif\n\n#if USE_SQUFOF\n \nstatic bool\nfactor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)\n{\n   \n\n  static short const multipliers_1[] =\n    {  \n      105, 165, 21, 385, 33, 5, 77, 1, 0\n    };\n  static short const multipliers_3[] =\n    {  \n      1155, 15, 231, 35, 3, 55, 7, 11, 0\n    };\n\n  struct { uintmax_t Q; uintmax_t P; } queue[QUEUE_SIZE];\n\n  if (n1 >= ((uintmax_t) 1 << (W_TYPE_SIZE - 2)))\n    return false;\n\n  uintmax_t sqrt_n = isqrt2 (n1, n0);\n\n  if (n0 == sqrt_n * sqrt_n)\n    {\n      uintmax_t p1, p0;\n\n      umul_ppmm (p1, p0, sqrt_n, sqrt_n);\n      affirm (p0 == n0);\n\n      if (n1 == p1)\n        {\n          if (prime_p (sqrt_n))\n            factor_insert_multiplicity (factors, sqrt_n, 2);\n          else\n            {\n              struct factors f;\n\n              f.nfactors = 0;\n              if (!factor_using_squfof (0, sqrt_n, &f))\n                {\n                   \n                  factor_using_pollard_rho (sqrt_n, 1, &f);\n                }\n               \n              for (unsigned int i = 0; i < f.nfactors; i++)\n                factor_insert_multiplicity (factors, f.p[i], 2 * f.e[i]);\n            }\n          return true;\n        }\n    }\n\n   \n  for (short const *m = (n0 % 4 == 1) ? multipliers_3 : multipliers_1;\n       *m; m++)\n    {\n      uintmax_t S, Dh, Dl, Q1, Q, P, L, L1, B;\n      unsigned int i;\n      unsigned int mu = *m;\n      int qpos = 0;\n\n      affirm (mu * n0 % 4 == 3);\n\n       \n      if (n1 == 0)\n        {\n          if ((uintmax_t) mu * mu * mu >= n0 / 64)\n            continue;\n        }\n      else\n        {\n          if (n1 > ((uintmax_t) 1 << (W_TYPE_SIZE - 2)) / mu)\n            continue;\n        }\n      umul_ppmm (Dh, Dl, n0, mu);\n      Dh += n1 * mu;\n\n      affirm (Dl % 4 != 1);\n      affirm (Dh < (uintmax_t) 1 << (W_TYPE_SIZE - 2));\n\n      S = isqrt2 (Dh, Dl);\n\n      Q1 = 1;\n      P = S;\n\n       \n      Q = Dl - P * P;\n       \n      L = isqrt (2 * S);\n      B = 2 * L;\n      L1 = mu * 2 * L;\n\n       \n\n      for (i = 0; i <= B; i++)\n        {\n          uintmax_t q, P1, t, rem;\n\n          div_smallq (q, rem, S + P, Q);\n          P1 = S - rem;  \n\n          affirm (q > 0 && Q > 0);\n\n# if STAT_SQUFOF\n          q_freq[0]++;\n          q_freq[MIN (q, Q_FREQ_SIZE)]++;\n# endif\n\n          if (Q <= L1)\n            {\n              uintmax_t g = Q;\n\n              if ((Q & 1) == 0)\n                g /= 2;\n\n              g /= gcd_odd (g, mu);\n\n              if (g <= L)\n                {\n                  if (qpos >= QUEUE_SIZE)\n                    error (EXIT_FAILURE, 0, _(\"squfof queue overflow\"));\n                  queue[qpos].Q = g;\n                  queue[qpos].P = P % g;\n                  qpos++;\n                }\n            }\n\n           \n          t = Q1 + q * (P - P1);\n          Q1 = Q;\n          Q = t;\n          P = P1;\n\n          if ((i & 1) == 0)\n            {\n              uintmax_t r = is_square (Q);\n              if (r)\n                {\n                  for (int j = 0; j < qpos; j++)\n                    {\n                      if (queue[j].Q == r)\n                        {\n                          if (r == 1)\n                             \n                            goto next_multiplier;\n\n                           \n                          if (P >= queue[j].P)\n                            t = P - queue[j].P;\n                          else\n                            t = queue[j].P - P;\n                          if (t % r == 0)\n                            {\n                               \n                              memmove (queue, queue + j + 1,\n                                       (qpos - j - 1) * sizeof (queue[0]));\n                              qpos -= (j + 1);\n                            }\n                          goto next_i;\n                        }\n                    }\n\n                   \n                  Q1 = r;\n                  affirm (S >= P);  \n                  P += r * ((S - P) / r);\n\n                   \n                   \n                  uintmax_t hi, lo;\n                  umul_ppmm (hi, lo, P, P);\n                  sub_ddmmss (hi, lo, Dh, Dl, hi, lo);\n                  udiv_qrnnd (Q, rem, hi, lo, Q1);\n                  affirm (rem == 0);\n\n                  for (;;)\n                    {\n                       \n                      div_smallq (q, rem, S + P, Q);\n                      P1 = S - rem;      \n\n# if STAT_SQUFOF\n                      q_freq[0]++;\n                      q_freq[MIN (q, Q_FREQ_SIZE)]++;\n# endif\n                      if (P == P1)\n                        break;\n                      t = Q1 + q * (P - P1);\n                      Q1 = Q;\n                      Q = t;\n                      P = P1;\n                    }\n\n                  if ((Q & 1) == 0)\n                    Q /= 2;\n                  Q /= gcd_odd (Q, mu);\n\n                  affirm (Q > 1 && (n1 || Q < n0));\n\n                  if (prime_p (Q))\n                    factor_insert (factors, Q);\n                  else if (!factor_using_squfof (0, Q, factors))\n                    factor_using_pollard_rho (Q, 2, factors);\n\n                  divexact_21 (n1, n0, n1, n0, Q);\n\n                  if (prime2_p (n1, n0))\n                    factor_insert_large (factors, n1, n0);\n                  else\n                    {\n                      if (!factor_using_squfof (n1, n0, factors))\n                        {\n                          if (n1 == 0)\n                            factor_using_pollard_rho (n0, 1, factors);\n                          else\n                            factor_using_pollard_rho2 (n1, n0, 1, factors);\n                        }\n                    }\n\n                  return true;\n                }\n            }\n        next_i:;\n        }\n    next_multiplier:;\n    }\n  return false;\n}\n#endif\n\n \nstatic void\nfactor (uintmax_t t1, uintmax_t t0, struct factors *factors)\n{\n  factors->nfactors = 0;\n  factors->plarge[1] = 0;\n\n  if (t1 == 0 && t0 < 2)\n    return;\n\n  t0 = factor_using_division (&t1, t1, t0, factors);\n\n  if (t1 == 0 && t0 < 2)\n    return;\n\n  if (prime2_p (t1, t0))\n    factor_insert_large (factors, t1, t0);\n  else\n    {\n#if USE_SQUFOF\n      if (factor_using_squfof (t1, t0, factors))\n        return;\n#endif\n\n      if (t1 == 0)\n        factor_using_pollard_rho (t0, 1, factors);\n      else\n        factor_using_pollard_rho2 (t1, t0, 1, factors);\n    }\n}\n\n \nstatic void\nmp_factor (mpz_t t, struct mp_factors *factors)\n{\n  mp_factor_init (factors);\n\n  if (mpz_sgn (t) != 0)\n    {\n      mp_factor_using_division (t, factors);\n\n      if (mpz_cmp_ui (t, 1) != 0)\n        {\n          devmsg (\"[is number prime?] \");\n          if (mp_prime_p (t))\n            mp_factor_insert (factors, t);\n          else\n            mp_factor_using_pollard_rho (t, 1, factors);\n        }\n    }\n}\n\nstatic strtol_error\nstrto2uintmax (uintmax_t *hip, uintmax_t *lop, char const *s)\n{\n  int lo_carry;\n  uintmax_t hi = 0, lo = 0;\n\n  strtol_error err = LONGINT_INVALID;\n\n   \n  char const *p = s;\n  for (;;)\n    {\n      unsigned char c = *p++;\n      if (c == 0)\n        break;\n\n      if (UNLIKELY (!ISDIGIT (c)))\n        {\n          err = LONGINT_INVALID;\n          break;\n        }\n\n      err = LONGINT_OK;            \n    }\n\n  while (err == LONGINT_OK)\n    {\n      unsigned char c = *s++;\n      if (c == 0)\n        break;\n\n      c -= '0';\n\n      if (UNLIKELY (hi > ~(uintmax_t)0 / 10))\n        {\n          err = LONGINT_OVERFLOW;\n          break;\n        }\n      hi = 10 * hi;\n\n      lo_carry = (lo >> (W_TYPE_SIZE - 3)) + (lo >> (W_TYPE_SIZE - 1));\n      lo_carry += 10 * lo < 2 * lo;\n\n      lo = 10 * lo;\n      lo += c;\n\n      lo_carry += lo < c;\n      hi += lo_carry;\n      if (UNLIKELY (hi < lo_carry))\n        {\n          err = LONGINT_OVERFLOW;\n          break;\n        }\n    }\n\n  *hip = hi;\n  *lop = lo;\n\n  return err;\n}\n\n \nstatic struct lbuf_\n{\n  char *buf;\n  char *end;\n} lbuf;\n\n \n#define FACTOR_PIPE_BUF 512\n\nstatic void\nlbuf_alloc (void)\n{\n  if (lbuf.buf)\n    return;\n\n   \n  lbuf.buf = xmalloc (FACTOR_PIPE_BUF * 2);\n  lbuf.end = lbuf.buf;\n}\n\n \nstatic void\nlbuf_flush (void)\n{\n  size_t size = lbuf.end - lbuf.buf;\n  if (full_write (STDOUT_FILENO, lbuf.buf, size) != size)\n    write_error ();\n  lbuf.end = lbuf.buf;\n}\n\n \nstatic void\nlbuf_putc (char c)\n{\n  *lbuf.end++ = c;\n\n  if (c == '\\n')\n    {\n      size_t buffered = lbuf.end - lbuf.buf;\n\n       \n      static int line_buffered = -1;\n      if (line_buffered == -1)\n        line_buffered = isatty (STDIN_FILENO) || isatty (STDOUT_FILENO);\n      if (line_buffered)\n        lbuf_flush ();\n      else if (buffered >= FACTOR_PIPE_BUF)\n        {\n           \n          char const *tend = lbuf.end;\n\n           \n          char *tlend = lbuf.buf + FACTOR_PIPE_BUF;\n          while (*--tlend != '\\n');\n          tlend++;\n\n          lbuf.end = tlend;\n          lbuf_flush ();\n\n           \n          memcpy (lbuf.buf, tlend, tend - tlend);\n          lbuf.end = lbuf.buf + (tend - tlend);\n        }\n    }\n}\n\n \nstatic void\nlbuf_putint (uintmax_t i, size_t min_width)\n{\n  char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n  char const *umaxstr = umaxtostr (i, buf);\n  size_t width = sizeof (buf) - (umaxstr - buf) - 1;\n  size_t z = width;\n\n  for (; z < min_width; z++)\n    *lbuf.end++ = '0';\n\n  memcpy (lbuf.end, umaxstr, width);\n  lbuf.end += width;\n}\n\nstatic void\nprint_uintmaxes (uintmax_t t1, uintmax_t t0)\n{\n  uintmax_t q, r;\n\n  if (t1 == 0)\n    lbuf_putint (t0, 0);\n  else\n    {\n       \n      q = t1 / 1000000000;\n      r = t1 % 1000000000;\n      udiv_qrnnd (t0, r, r, t0, 1000000000);\n      print_uintmaxes (q, t0);\n      lbuf_putint (r, 9);\n    }\n}\n\n \nstatic void\nprint_factors_single (uintmax_t t1, uintmax_t t0)\n{\n  struct factors factors;\n\n  print_uintmaxes (t1, t0);\n  lbuf_putc (':');\n\n  factor (t1, t0, &factors);\n\n  for (int j = 0; j < factors.nfactors; j++)\n    for (int k = 0; k < factors.e[j]; k++)\n      {\n        lbuf_putc (' ');\n        print_uintmaxes (0, factors.p[j]);\n        if (print_exponents && factors.e[j] > 1)\n          {\n            lbuf_putc ('^');\n            lbuf_putint (factors.e[j], 0);\n            break;\n          }\n      }\n\n  if (factors.plarge[1])\n    {\n      lbuf_putc (' ');\n      print_uintmaxes (factors.plarge[1], factors.plarge[0]);\n    }\n\n  lbuf_putc ('\\n');\n}\n\n \nstatic bool\nprint_factors (char const *input)\n{\n   \n  char const *str = input;\n  while (*str == ' ')\n    str++;\n  str += *str == '+';\n\n  uintmax_t t1, t0;\n\n   \n  strtol_error err = strto2uintmax (&t1, &t0, str);\n\n  switch (err)\n    {\n    case LONGINT_OK:\n      if (((t1 << 1) >> 1) == t1)\n        {\n          devmsg (\"[using single-precision arithmetic] \");\n          print_factors_single (t1, t0);\n          return true;\n        }\n      break;\n\n    case LONGINT_OVERFLOW:\n       \n      break;\n\n    default:\n      error (0, 0, _(\"%s is not a valid positive integer\"), quote (input));\n      return false;\n    }\n\n  devmsg (\"[using arbitrary-precision arithmetic] \");\n  mpz_t t;\n  struct mp_factors factors;\n\n  mpz_init_set_str (t, str, 10);\n\n  mpz_out_str (stdout, 10, t);\n  putchar (':');\n  mp_factor (t, &factors);\n\n  for (idx_t j = 0; j < factors.nfactors; j++)\n    for (unsigned long int k = 0; k < factors.e[j]; k++)\n      {\n        putchar (' ');\n        mpz_out_str (stdout, 10, factors.p[j]);\n        if (print_exponents && factors.e[j] > 1)\n          {\n            printf (\"^%lu\", factors.e[j]);\n            break;\n          }\n      }\n\n  mp_factor_clear (&factors);\n  mpz_clear (t);\n  putchar ('\\n');\n  fflush (stdout);\n  return true;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION] [NUMBER]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nPrint the prime factors of each specified integer NUMBER.  If none\\n\\\nare specified on the command line, read them from standard input.\\n\\\n\\n\\\n\"), stdout);\n      fputs (\"\\\n  -h, --exponents   print repeated factors in form p^e unless e is 1\\n\\\n\", stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic bool\ndo_stdin (void)\n{\n  bool ok = true;\n  token_buffer tokenbuffer;\n\n  init_tokenbuffer (&tokenbuffer);\n\n  while (true)\n    {\n      size_t token_length = readtoken (stdin, DELIM, sizeof (DELIM) - 1,\n                                       &tokenbuffer);\n      if (token_length == (size_t) -1)\n        {\n          if (ferror (stdin))\n            error (EXIT_FAILURE, errno, _(\"error reading input\"));\n          break;\n        }\n\n      ok &= print_factors (tokenbuffer.buffer);\n    }\n  free (tokenbuffer.buffer);\n\n  return ok;\n}\n\nint\nmain (int argc, char **argv)\n{\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  lbuf_alloc ();\n  atexit (close_stdout);\n  atexit (lbuf_flush);\n\n  int c;\n  while ((c = getopt_long (argc, argv, \"h\", long_options, nullptr)) != -1)\n    {\n      switch (c)\n        {\n        case 'h':  /* NetBSD used -h for this functionality first.  */\n          print_exponents = true;\n          break;\n\n        case DEV_DEBUG_OPTION:\n          dev_debug = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n#if STAT_SQUFOF\n  memset (q_freq, 0, sizeof (q_freq));\n#endif\n\n  bool ok;\n  if (argc <= optind)\n    ok = do_stdin ();\n  else\n    {\n      ok = true;\n      for (int i = optind; i < argc; i++)\n        if (! print_factors (argv[i]))\n          ok = false;\n    }\n\n#if STAT_SQUFOF\n  if (q_freq[0] > 0)\n    {\n      double acc_f;\n      printf (\"q  freq.  cum. freq.(total: %d)\\n\", q_freq[0]);\n      for (int i = 1, acc_f = 0.0; i <= Q_FREQ_SIZE; i++)\n        {\n          double f = (double) q_freq[i] / q_freq[0];\n          acc_f += f;\n          printf (\"%s%d %.2f%% %.2f%%\\n\", i == Q_FREQ_SIZE ? \">=\" : \"\", i,\n                  100.0 * f, 100.0 * acc_f);\n        }\n    }\n#endif\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}