{
  "module_name": "tac.c",
  "hash_id": "27db399b54ee81ffc9481c046981ea9768f024d28e50aea9f9c9ef0a060ba234",
  "original_prompt": "Ingested from coreutils-9.4/src/tac.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n\n#include <regex.h>\n\n#include \"filenamecat.h\"\n#include \"full-read.h\"\n#include \"safe-read.h\"\n#include \"temp-stream.h\"\n#include \"xbinary-io.h\"\n\n \n#define PROGRAM_NAME \"tac\"\n\n#define AUTHORS \\\n  proper_name (\"Jay Lepreau\"), \\\n  proper_name (\"David MacKenzie\")\n\n\n \n#define INITIAL_READSIZE 8192\n\n \n#define WRITESIZE 8192\n\n \nstatic char const *separator;\n\n \nstatic bool have_read_stdin = false;\n\n \nstatic bool separator_ends_record;\n\n \nstatic size_t sentinel_length;\n\n \nstatic size_t match_length;\n\n \nstatic char *G_buffer;\n\n \nstatic size_t read_size;\n\n \nstatic size_t G_buffer_size;\n\n \nstatic struct re_pattern_buffer compiled_separator;\nstatic char compiled_separator_fastmap[UCHAR_MAX + 1];\nstatic struct re_registers regs;\n\nstatic struct option const longopts[] =\n{\n  {\"before\", no_argument, nullptr, 'b'},\n  {\"regex\", no_argument, nullptr, 'r'},\n  {\"separator\", required_argument, nullptr, 's'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n\"),\n              program_name);\n      fputs (_(\"\\\nWrite each FILE to standard output, last line first.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -b, --before             attach the separator before instead of after\\n\\\n  -r, --regex              interpret the separator as a regular expression\\n\\\n  -s, --separator=STRING   use STRING as the separator instead of newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Print the characters from START to PAST_END - 1.\n   If START is null, just flush the buffer. */\n\nstatic void\noutput (char const *start, char const *past_end)\n{\n  static char buffer[WRITESIZE];\n  static size_t bytes_in_buffer = 0;\n  size_t bytes_to_add = past_end - start;\n  size_t bytes_available = WRITESIZE - bytes_in_buffer;\n\n  if (start == 0)\n    {\n      fwrite (buffer, 1, bytes_in_buffer, stdout);\n      bytes_in_buffer = 0;\n      return;\n    }\n\n  /* Write out as many full buffers as possible. */\n  while (bytes_to_add >= bytes_available)\n    {\n      memcpy (buffer + bytes_in_buffer, start, bytes_available);\n      bytes_to_add -= bytes_available;\n      start += bytes_available;\n      fwrite (buffer, 1, WRITESIZE, stdout);\n      bytes_in_buffer = 0;\n      bytes_available = WRITESIZE;\n    }\n\n  memcpy (buffer + bytes_in_buffer, start, bytes_to_add);\n  bytes_in_buffer += bytes_to_add;\n}\n\n/* Print in reverse the file open on descriptor FD for reading FILE.\n   The file is already positioned at FILE_POS, which should be near its end.\n   Return true if successful.  */\n\nstatic bool\ntac_seekable (int input_fd, char const *file, off_t file_pos)\n{\n  /* Pointer to the location in 'G_buffer' where the search for\n     the next separator will begin. */\n  char *match_start;\n\n  /* Pointer to one past the rightmost character in 'G_buffer' that\n     has not been printed yet. */\n  char *past_end;\n\n  /* Length of the record growing in 'G_buffer'. */\n  size_t saved_record_size;\n\n  /* True if 'output' has not been called yet for any file.\n     Only used when the separator is attached to the preceding record. */\n  bool first_time = true;\n  char first_char = *separator;\t/* Speed optimization, non-regexp. */\n  char const *separator1 = separator + 1; /* Speed optimization, non-regexp. */\n  size_t match_length1 = match_length - 1; /* Speed optimization, non-regexp. */\n\n  /* Arrange for the first read to lop off enough to leave the rest of the\n     file a multiple of 'read_size'.  Since 'read_size' can change, this may\n     not always hold during the program run, but since it usually will, leave\n     it here for i/o efficiency (page/sector boundaries and all that).\n     Note: the efficiency gain has not been verified. */\n  size_t remainder = file_pos % read_size;\n  if (remainder != 0)\n    {\n      file_pos -= remainder;\n      if (lseek (input_fd, file_pos, SEEK_SET) < 0)\n        error (0, errno, _(\"%s: seek failed\"), quotef (file));\n    }\n\n  /* Scan backward, looking for end of file.  This caters to proc-like\n     file systems where the file size is just an estimate.  */\n  while ((saved_record_size = safe_read (input_fd, G_buffer, read_size)) == 0\n         && file_pos != 0)\n    {\n      off_t rsize = read_size;\n      if (lseek (input_fd, -rsize, SEEK_CUR) < 0)\n        error (0, errno, _(\"%s: seek failed\"), quotef (file));\n      file_pos -= read_size;\n    }\n\n  /* Now scan forward, looking for end of file.  */\n  while (saved_record_size == read_size)\n    {\n      size_t nread = safe_read (input_fd, G_buffer, read_size);\n      if (nread == 0)\n        break;\n      saved_record_size = nread;\n      if (saved_record_size == SAFE_READ_ERROR)\n        break;\n      file_pos += nread;\n    }\n\n  if (saved_record_size == SAFE_READ_ERROR)\n    {\n      error (0, errno, _(\"%s: read error\"), quotef (file));\n      return false;\n    }\n\n  match_start = past_end = G_buffer + saved_record_size;\n  /* For non-regexp search, move past impossible positions for a match. */\n  if (sentinel_length)\n    match_start -= match_length1;\n\n  while (true)\n    {\n      /* Search backward from 'match_start' - 1 to 'G_buffer' for a match\n         with 'separator'; for speed, use strncmp if 'separator' contains no\n         metacharacters.\n         If the match succeeds, set 'match_start' to point to the start of\n         the match and 'match_length' to the length of the match.\n         Otherwise, make 'match_start' < 'G_buffer'. */\n      if (sentinel_length == 0)\n        {\n          size_t i = match_start - G_buffer;\n          regoff_t ri = i;\n          regoff_t range = 1 - ri;\n          regoff_t ret;\n\n          if (1 < range)\n            error (EXIT_FAILURE, 0, _(\"record too large\"));\n\n          if (range == 1\n              || ((ret = re_search (&compiled_separator, G_buffer,\n                                    i, i - 1, range, &regs))\n                  == -1))\n            match_start = G_buffer - 1;\n          else if (ret == -2)\n            error (EXIT_FAILURE, 0,\n                   _(\"error in regular expression search\"));\n          else\n            {\n              match_start = G_buffer + regs.start[0];\n              match_length = regs.end[0] - regs.start[0];\n            }\n        }\n      else\n        {\n          /* 'match_length' is constant for non-regexp boundaries. */\n          while (*--match_start != first_char\n                 || (match_length1 && !STREQ_LEN (match_start + 1, separator1,\n                                                  match_length1)))\n            /* Do nothing. */ ;\n        }\n\n      /* Check whether we backed off the front of 'G_buffer' without finding\n         a match for 'separator'. */\n      if (match_start < G_buffer)\n        {\n          if (file_pos == 0)\n            {\n              /* Hit the beginning of the file; print the remaining record. */\n              output (G_buffer, past_end);\n              return true;\n            }\n\n          saved_record_size = past_end - G_buffer;\n          if (saved_record_size > read_size)\n            {\n              /* 'G_buffer_size' is about twice 'read_size', so since\n                 we want to read in another 'read_size' bytes before\n                 the data already in 'G_buffer', we need to increase\n                 'G_buffer_size'. */\n              char *newbuffer;\n              size_t offset = sentinel_length ? sentinel_length : 1;\n              size_t old_G_buffer_size = G_buffer_size;\n\n              read_size *= 2;\n              G_buffer_size = read_size * 2 + sentinel_length + 2;\n              if (G_buffer_size < old_G_buffer_size)\n                xalloc_die ();\n              newbuffer = xrealloc (G_buffer - offset, G_buffer_size);\n              newbuffer += offset;\n              G_buffer = newbuffer;\n            }\n\n          /* Back up to the start of the next bufferfull of the file.  */\n          if (file_pos >= read_size)\n            file_pos -= read_size;\n          else\n            {\n              read_size = file_pos;\n              file_pos = 0;\n            }\n          if (lseek (input_fd, file_pos, SEEK_SET) < 0)\n            error (0, errno, _(\"%s: seek failed\"), quotef (file));\n\n          /* Shift the pending record data right to make room for the new.\n             The source and destination regions probably overlap.  */\n          memmove (G_buffer + read_size, G_buffer, saved_record_size);\n          past_end = G_buffer + read_size + saved_record_size;\n          /* For non-regexp searches, avoid unnecessary scanning. */\n          if (sentinel_length)\n            match_start = G_buffer + read_size;\n          else\n            match_start = past_end;\n\n          if (full_read (input_fd, G_buffer, read_size) != read_size)\n            {\n              error (0, errno, _(\"%s: read error\"), quotef (file));\n              return false;\n            }\n        }\n      else\n        {\n          /* Found a match of 'separator'. */\n          if (separator_ends_record)\n            {\n              char *match_end = match_start + match_length;\n\n              /* If this match of 'separator' isn't at the end of the\n                 file, print the record. */\n              if (!first_time || match_end != past_end)\n                output (match_end, past_end);\n              past_end = match_end;\n              first_time = false;\n            }\n          else\n            {\n              output (match_start, past_end);\n              past_end = match_start;\n            }\n\n          /* For non-regex matching, we can back up.  */\n          if (sentinel_length > 0)\n            match_start -= match_length - 1;\n        }\n    }\n}\n\n/* Copy from file descriptor INPUT_FD (corresponding to the named FILE) to\n   a temporary file, and set *G_TMP and *G_TEMPFILE to the resulting stream\n   and file name.  Return the number of bytes copied, or -1 on error.  */\n\nstatic off_t\ncopy_to_temp (FILE **g_tmp, char **g_tempfile, int input_fd, char const *file)\n{\n  FILE *fp;\n  char *file_name;\n  uintmax_t bytes_copied = 0;\n  if (!temp_stream (&fp, &file_name))\n    return -1;\n\n  while (true)\n    {\n      size_t bytes_read = safe_read (input_fd, G_buffer, read_size);\n      if (bytes_read == 0)\n        break;\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, _(\"%s: read error\"), quotef (file));\n          return -1;\n        }\n\n      if (fwrite (G_buffer, 1, bytes_read, fp) != bytes_read)\n        {\n          error (0, errno, _(\"%s: write error\"), quotef (file_name));\n          return -1;\n        }\n\n      /* Implicitly <= OFF_T_MAX due to preceding fwrite(),\n         but unsigned type used to avoid compiler warnings\n         not aware of this fact.  */\n      bytes_copied += bytes_read;\n    }\n\n  if (fflush (fp) != 0)\n    {\n      error (0, errno, _(\"%s: write error\"), quotef (file_name));\n      return -1;\n    }\n\n  *g_tmp = fp;\n  *g_tempfile = file_name;\n  return bytes_copied;\n}\n\n/* Copy INPUT_FD to a temporary, then tac that file.\n   Return true if successful.  */\n\nstatic bool\ntac_nonseekable (int input_fd, char const *file)\n{\n  FILE *tmp_stream;\n  char *tmp_file;\n  off_t bytes_copied = copy_to_temp (&tmp_stream, &tmp_file, input_fd, file);\n  if (bytes_copied < 0)\n    return false;\n\n  bool ok = tac_seekable (fileno (tmp_stream), tmp_file, bytes_copied);\n  return ok;\n}\n\n/* Print FILE in reverse, copying it to a temporary\n   file first if it is not seekable.\n   Return true if successful.  */\n\nstatic bool\ntac_file (char const *filename)\n{\n  bool ok;\n  off_t file_size;\n  int fd;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fd = STDIN_FILENO;\n      filename = _(\"standard input\");\n      xset_binary_mode (STDIN_FILENO, O_BINARY);\n    }\n  else\n    {\n      fd = open (filename, O_RDONLY | O_BINARY);\n      if (fd < 0)\n        {\n          error (0, errno, _(\"failed to open %s for reading\"),\n                 quoteaf (filename));\n          return false;\n        }\n    }\n\n  file_size = lseek (fd, 0, SEEK_END);\n\n  ok = (file_size < 0 || isatty (fd)\n        ? tac_nonseekable (fd, filename)\n        : tac_seekable (fd, filename, file_size));\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, _(\"%s: read error\"), quotef (filename));\n      ok = false;\n    }\n  return ok;\n}\n\nint\nmain (int argc, char **argv)\n{\n  char const *error_message;\t/* Return value from re_compile_pattern. */\n  int optc;\n  bool ok;\n  size_t half_buffer_size;\n\n  /* Initializer for file_list if no file-arguments\n     were specified on the command line.  */\n  static char const *const default_file_list[] = {\"-\", nullptr};\n  char const *const *file;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  separator = \"\\n\";\n  sentinel_length = 1;\n  separator_ends_record = true;\n\n  while ((optc = getopt_long (argc, argv, \"brs:\", longopts, nullptr)) != -1)\n    {\n      switch (optc)\n        {\n        case 'b':\n          separator_ends_record = false;\n          break;\n        case 'r':\n          sentinel_length = 0;\n          break;\n        case 's':\n          separator = optarg;\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (sentinel_length == 0)\n    {\n      if (*separator == 0)\n        error (EXIT_FAILURE, 0, _(\"separator cannot be empty\"));\n\n      compiled_separator.buffer = nullptr;\n      compiled_separator.allocated = 0;\n      compiled_separator.fastmap = compiled_separator_fastmap;\n      compiled_separator.translate = nullptr;\n      error_message = re_compile_pattern (separator, strlen (separator),\n                                          &compiled_separator);\n      if (error_message)\n        error (EXIT_FAILURE, 0, \"%s\", (error_message));\n    }\n  else\n    match_length = sentinel_length = *separator ? strlen (separator) : 1;\n\n  read_size = INITIAL_READSIZE;\n  while (sentinel_length >= read_size / 2)\n    {\n      if (SIZE_MAX / 2 < read_size)\n        xalloc_die ();\n      read_size *= 2;\n    }\n  half_buffer_size = read_size + sentinel_length + 1;\n  G_buffer_size = 2 * half_buffer_size;\n  if (! (read_size < half_buffer_size && half_buffer_size < G_buffer_size))\n    xalloc_die ();\n  G_buffer = xmalloc (G_buffer_size);\n  if (sentinel_length)\n    {\n      memcpy (G_buffer, separator, sentinel_length + 1);\n      G_buffer += sentinel_length;\n    }\n  else\n    {\n      ++G_buffer;\n    }\n\n  file = (optind < argc\n          ? (char const *const *) &argv[optind]\n          : default_file_list);\n\n  xset_binary_mode (STDOUT_FILENO, O_BINARY);\n\n  {\n    ok = true;\n    for (size_t i = 0; file[i]; ++i)\n      ok &= tac_file (file[i]);\n  }\n\n  /* Flush the output buffer. */\n  output ((char *) nullptr, (char *) nullptr);\n\n  if (have_read_stdin && close (STDIN_FILENO) < 0)\n    {\n      error (0, errno, \"-\");\n      ok = false;\n    }\n\n  main_exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}