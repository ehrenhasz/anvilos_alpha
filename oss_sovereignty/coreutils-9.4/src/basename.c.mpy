{
  "module_name": "basename.c",
  "hash_id": "aee2f4b7dda3ddfd283bb5add318be844444eaf2794723ee17bd206f17ad4802",
  "original_prompt": "Ingested from coreutils-9.4/src/basename.c",
  "human_readable_source": " \n#define PROGRAM_NAME \"basename\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic struct option const longopts[] =\n{\n  {\"multiple\", no_argument, nullptr, 'a'},\n  {\"suffix\", required_argument, nullptr, 's'},\n  {\"zero\", no_argument, nullptr, 'z'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s NAME [SUFFIX]\\n\\\n  or:  %s OPTION... NAME...\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nPrint NAME with any leading directory components removed.\\n\\\nIf specified, also remove a trailing SUFFIX.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -a, --multiple       support multiple arguments and treat each as a NAME\\n\\\n  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\\n\\\n  -z, --zero           end each output line with NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      printf (_(\"\\\n\\n\\\nExamples:\\n\\\n  %s /usr/bin/sort          -> \\\"sort\\\"\\n\\\n  %s include/stdio.h .h     -> \\\"stdio\\\"\\n\\\n  %s -s .h include/stdio.h  -> \\\"stdio\\\"\\n\\\n  %s -a any/str1 any/str2   -> \\\"str1\\\" followed by \\\"str2\\\"\\n\\\n\"),\n              program_name, program_name, program_name, program_name);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Remove SUFFIX from the end of NAME if it is there, unless NAME\n   consists entirely of SUFFIX.  */\n\nstatic void\nremove_suffix (char *name, char const *suffix)\n{\n  char *np;\n  char const *sp;\n\n  np = name + strlen (name);\n  sp = suffix + strlen (suffix);\n\n  while (np > name && sp > suffix)\n    if (*--np != *--sp)\n      return;\n  if (np > name)\n    *np = '\\0';\n}\n\n/* Perform the basename operation on STRING.  If SUFFIX is non-null, remove\n   the trailing SUFFIX.  Finally, output the result string.  */\n\nstatic void\nperform_basename (char const *string, char const *suffix, bool use_nuls)\n{\n  char *name = base_name (string);\n  strip_trailing_slashes (name);\n\n  /* Per POSIX, 'basename // /' must return '//' on platforms with\n     distinct //.  On platforms with drive letters, this generalizes\n     to making 'basename c: :' return 'c:'.  This rule is captured by\n     skipping suffix stripping if base_name returned an absolute path\n     or a drive letter (only possible if name is a file-system\n     root).  */\n  if (suffix && IS_RELATIVE_FILE_NAME (name) && ! FILE_SYSTEM_PREFIX_LEN (name))\n    remove_suffix (name, suffix);\n\n  fputs (name, stdout);\n  putchar (use_nuls ? '\\0' : '\\n');\n  free (name);\n}\n\nint\nmain (int argc, char **argv)\n{\n  bool multiple_names = false;\n  bool use_nuls = false;\n  char const *suffix = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while (true)\n    {\n      int c = getopt_long (argc, argv, \"+as:z\", longopts, nullptr);\n\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 's':\n          suffix = optarg;\n          /* -s implies -a, so...  */\n          FALLTHROUGH;\n\n        case 'a':\n          multiple_names = true;\n          break;\n\n        case 'z':\n          use_nuls = true;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  if (argc < optind + 1)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (!multiple_names && optind + 2 < argc)\n    {\n      error (0, 0, _(\"extra operand %s\"), quote (argv[optind + 2]));\n      usage (EXIT_FAILURE);\n    }\n\n  if (multiple_names)\n    {\n      for (; optind < argc; optind++)\n        perform_basename (argv[optind], suffix, use_nuls);\n    }\n  else\n    perform_basename (argv[optind],\n                      optind + 2 == argc ? argv[optind + 1] : nullptr,\n                      use_nuls);\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}