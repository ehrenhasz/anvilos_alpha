{
  "module_name": "pinky.c",
  "hash_id": "94470ed229654191cbe92a76a00048b5f26c97ae10eb7fd0f5dbe8e2e6ebcb8d",
  "original_prompt": "Ingested from coreutils-9.4/src/pinky.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <stdckdint.h>\n#include <stdio.h>\n\n#include <sys/types.h>\n#include \"system.h\"\n\n#include \"canon-host.h\"\n#include \"hard-locale.h\"\n#include \"readutmp.h\"\n\n \n#define PROGRAM_NAME \"pinky\"\n\n#define AUTHORS \\\n  proper_name (\"Joseph Arceneaux\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Kaveh Ghazi\")\n\n \nstatic bool include_idle = true;\n\n \nstatic bool include_heading = true;\n\n \nstatic bool include_fullname = true;\n\n \nstatic bool include_project = true;\n\n \nstatic bool include_plan = true;\n\n \nstatic bool include_home_and_shell = true;\n\n \nstatic bool do_short_format = true;\n\n \n#if HAVE_STRUCT_XTMP_UT_HOST\nstatic bool include_where = true;\n#endif\n\n \nstatic char const *time_format;\nstatic int time_format_width;\n\nstatic struct option const longopts[] =\n{\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \n\nATTRIBUTE_PURE\nstatic size_t\ncount_ampersands (char const *str)\n{\n  size_t count = 0;\n  do\n    {\n      if (*str == '&')\n        count++;\n    } while (*str++);\n  return count;\n}\n\n \n\nstatic char *\ncreate_fullname (char const *gecos_name, char const *user_name)\n{\n  size_t rsize = strlen (gecos_name) + 1;\n  char *result;\n  char *r;\n  size_t ampersands = count_ampersands (gecos_name);\n\n  if (ampersands != 0)\n    {\n      size_t ulen = strlen (user_name);\n      size_t product;\n      if (ckd_mul (&product, ulen, ampersands - 1)\n          || ckd_add (&rsize, rsize, product))\n        xalloc_die ();\n    }\n\n  r = result = xmalloc (rsize);\n\n  while (*gecos_name)\n    {\n      if (*gecos_name == '&')\n        {\n          char const *uname = user_name;\n          if (islower (to_uchar (*uname)))\n            *r++ = toupper (to_uchar (*uname++));\n          while (*uname)\n            *r++ = *uname++;\n        }\n      else\n        {\n          *r++ = *gecos_name;\n        }\n\n      gecos_name++;\n    }\n  *r = 0;\n\n  return result;\n}\n\n \n\nstatic char const *\nidle_string (time_t when)\n{\n  static time_t now = 0;\n  static char buf[INT_STRLEN_BOUND (intmax_t) + sizeof \"d\"];\n  time_t seconds_idle;\n\n  if (now == 0)\n    time (&now);\n\n  seconds_idle = now - when;\n  if (seconds_idle < 60)\t \n    return \"     \";\n  if (seconds_idle < (24 * 60 * 60))\t \n    {\n      int hours = seconds_idle / (60 * 60);\n      int minutes = (seconds_idle % (60 * 60)) / 60;\n      sprintf (buf, \"%02d:%02d\", hours, minutes);\n    }\n  else\n    {\n      intmax_t days = seconds_idle / (24 * 60 * 60);\n      sprintf (buf, \"%\"PRIdMAX\"d\", days);\n    }\n  return buf;\n}\n\n \nstatic char const *\ntime_string (struct gl_utmp const *utmp_ent)\n{\n  static char buf[INT_STRLEN_BOUND (intmax_t) + sizeof \"-%m-%d %H:%M\"];\n  struct tm *tmp = localtime (&utmp_ent->ut_ts.tv_sec);\n\n  if (tmp)\n    {\n      strftime (buf, sizeof buf, time_format, tmp);\n      return buf;\n    }\n  else\n    return timetostr (utmp_ent->ut_ts.tv_sec, buf);\n}\n\n \n\nstatic void\nprint_entry (struct gl_utmp const *utmp_ent)\n{\n  struct stat stats;\n  time_t last_change;\n  char mesg;\n\n   \n  char *line = utmp_ent->ut_line;\n  char *space = strchr (line, ' ');\n  line = space ? space + 1 : line;\n\n  int dirfd;\n  if (IS_ABSOLUTE_FILE_NAME (line))\n    dirfd = AT_FDCWD;\n  else\n    {\n      static int dev_dirfd;\n      if (!dev_dirfd)\n        {\n          dev_dirfd = open (\"/dev\", O_PATHSEARCH | O_DIRECTORY);\n          if (dev_dirfd < 0)\n            dev_dirfd = AT_FDCWD - 1;\n        }\n      dirfd = dev_dirfd;\n    }\n\n  if (AT_FDCWD <= dirfd && fstatat (dirfd, line, &stats, 0) == 0)\n    {\n      mesg = (stats.st_mode & S_IWGRP) ? ' ' : '*';\n      last_change = stats.st_atime;\n    }\n  else\n    {\n      mesg = '?';\n      last_change = 0;\n    }\n\n  char *ut_user = utmp_ent->ut_user;\n  if (strnlen (ut_user, 8) < 8)\n    printf (\"%-8s\", ut_user);\n  else\n    fputs (ut_user, stdout);\n\n  if (include_fullname)\n    {\n      struct passwd *pw = getpwnam (ut_user);\n      if (pw == nullptr)\n         \n        printf (\" %19s\", _(\"        ???\"));\n      else\n        {\n          char *const comma = strchr (pw->pw_gecos, ',');\n          char *result;\n\n          if (comma)\n            *comma = '\\0';\n\n          result = create_fullname (pw->pw_gecos, pw->pw_name);\n          printf (\" %-19.19s\", result);\n          free (result);\n        }\n    }\n\n  fputc (' ', stdout);\n  fputc (mesg, stdout);\n  if (strnlen (utmp_ent->ut_line, 8) < 8)\n    printf (\"%-8s\", utmp_ent->ut_line);\n  else\n    fputs (utmp_ent->ut_line, stdout);\n\n  if (include_idle)\n    {\n      if (last_change)\n        printf (\" %-6s\", idle_string (last_change));\n      else\n         \n        printf (\" %-6s\", _(\"?????\"));\n    }\n\n  printf (\" %s\", time_string (utmp_ent));\n\n#ifdef HAVE_STRUCT_XTMP_UT_HOST\n  if (include_where && utmp_ent->ut_host[0])\n    {\n      char *host = nullptr;\n      char *display = nullptr;\n      char *ut_host = utmp_ent->ut_host;\n\n       \n      display = strchr (ut_host, ':');\n      if (display)\n        *display++ = '\\0';\n\n      if (*ut_host)\n         \n        host = canon_host (ut_host);\n      if ( ! host)\n        host = ut_host;\n\n      fputc (' ', stdout);\n      fputs (host, stdout);\n      if (display)\n        {\n          fputc (':', stdout);\n          fputs (display, stdout);\n        }\n\n      if (host != ut_host)\n        free (host);\n    }\n#endif\n\n  putchar ('\\n');\n}\n\n \n\nstatic void\nprint_long_entry (const char name[])\n{\n  struct passwd *pw;\n\n  pw = getpwnam (name);\n\n  printf (_(\"Login name: \"));\n  printf (\"%-28s\", name);\n\n  printf (_(\"In real life: \"));\n  if (pw == nullptr)\n    {\n       \n      printf (\" %s\", _(\"???\\n\"));\n      return;\n    }\n  else\n    {\n      char *const comma = strchr (pw->pw_gecos, ',');\n      char *result;\n\n      if (comma)\n        *comma = '\\0';\n\n      result = create_fullname (pw->pw_gecos, pw->pw_name);\n      printf (\" %s\", result);\n      free (result);\n    }\n\n  putchar ('\\n');\n\n  if (include_home_and_shell)\n    {\n      printf (_(\"Directory: \"));\n      printf (\"%-29s\", pw->pw_dir);\n      printf (_(\"Shell: \"));\n      printf (\" %s\", pw->pw_shell);\n      putchar ('\\n');\n    }\n\n  if (include_project)\n    {\n      FILE *stream;\n      char buf[1024];\n      char const *const baseproject = \"/.project\";\n      char *const project =\n        xmalloc (strlen (pw->pw_dir) + strlen (baseproject) + 1);\n      stpcpy (stpcpy (project, pw->pw_dir), baseproject);\n\n      stream = fopen (project, \"r\");\n      if (stream)\n        {\n          size_t bytes;\n\n          printf (_(\"Project: \"));\n\n          while ((bytes = fread (buf, 1, sizeof (buf), stream)) > 0)\n            fwrite (buf, 1, bytes, stdout);\n          fclose (stream);\n        }\n\n      free (project);\n    }\n\n  if (include_plan)\n    {\n      FILE *stream;\n      char buf[1024];\n      char const *const baseplan = \"/.plan\";\n      char *const plan =\n        xmalloc (strlen (pw->pw_dir) + strlen (baseplan) + 1);\n      stpcpy (stpcpy (plan, pw->pw_dir), baseplan);\n\n      stream = fopen (plan, \"r\");\n      if (stream)\n        {\n          size_t bytes;\n\n          printf (_(\"Plan:\\n\"));\n\n          while ((bytes = fread (buf, 1, sizeof (buf), stream)) > 0)\n            fwrite (buf, 1, bytes, stdout);\n          fclose (stream);\n        }\n\n      free (plan);\n    }\n\n  putchar ('\\n');\n}\n\n \n\nstatic void\nprint_heading (void)\n{\n  printf (\"%-8s\", _(\"Login\"));\n  if (include_fullname)\n    printf (\" %-19s\", _(\"Name\"));\n  printf (\" %-9s\", _(\" TTY\"));\n  if (include_idle)\n    printf (\" %-6s\", _(\"Idle\"));\n  printf (\" %-*s\", time_format_width, _(\"When\"));\n#ifdef HAVE_STRUCT_XTMP_UT_HOST\n  if (include_where)\n    printf (\" %s\", _(\"Where\"));\n#endif\n  putchar ('\\n');\n}\n\n \n\nstatic void\nscan_entries (idx_t n, struct gl_utmp const *utmp_buf,\n              const int argc_names, char *const argv_names[])\n{\n  if (hard_locale (LC_TIME))\n    {\n      time_format = \"%Y-%m-%d %H:%M\";\n      time_format_width = 4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2;\n    }\n  else\n    {\n      time_format = \"%b %e %H:%M\";\n      time_format_width = 3 + 1 + 2 + 1 + 2 + 1 + 2;\n    }\n\n  if (include_heading)\n    print_heading ();\n\n  while (n--)\n    {\n      if (IS_USER_PROCESS (utmp_buf))\n        {\n          if (argc_names)\n            {\n              for (int i = 0; i < argc_names; i++)\n                if (STREQ (utmp_buf->ut_user, argv_names[i]))\n                  {\n                    print_entry (utmp_buf);\n                    break;\n                  }\n            }\n          else\n            print_entry (utmp_buf);\n        }\n      utmp_buf++;\n    }\n}\n\n \n\nstatic void\nshort_pinky (char const *filename,\n             const int argc_names, char *const argv_names[])\n{\n  idx_t n_users;\n  struct gl_utmp *utmp_buf;\n  if (read_utmp (filename, &n_users, &utmp_buf, READ_UTMP_USER_PROCESS) != 0)\n    error (EXIT_FAILURE, errno, \"%s\", quotef (filename));\n\n  scan_entries (n_users, utmp_buf, argc_names, argv_names);\n  exit (EXIT_SUCCESS);\n}\n\nstatic void\nlong_pinky (const int argc_names, char *const argv_names[])\n{\n  for (int i = 0; i < argc_names; i++)\n    print_long_entry (argv_names[i]);\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"Usage: %s [OPTION]... [USER]...\\n\"), program_name);\n      fputs (_(\"\\\n\\n\\\n  -l              produce long format output for the specified USERs\\n\\\n  -b              omit the user's home directory and shell in long format\\n\\\n  -h              omit the user's project file in long format\\n\\\n  -p              omit the user's plan file in long format\\n\\\n  -s              do short format output, this is the default\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -f              omit the line of column headings in short format\\n\\\n  -w              omit the user's full name in short format\\n\\\n  -i              omit the user's full name and remote host in short format\\n\\\n  -q              omit the user's full name, remote host and idle time\\n\\\n                  in short format\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      printf (_(\"\\\n\\n\\\nA lightweight 'finger' program;  print user information.\\n\\\nThe utmp file will be %s.\\n\\\n\"), UTMP_FILE);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  int n_users;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  while ((optc = getopt_long (argc, argv, \"sfwiqbhlp\", longopts, nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 's':\n          do_short_format = true;\n          break;\n\n        case 'l':\n          do_short_format = false;\n          break;\n\n        case 'f':\n          include_heading = false;\n          break;\n\n        case 'w':\n          include_fullname = false;\n          break;\n\n        case 'i':\n          include_fullname = false;\n#ifdef HAVE_STRUCT_XTMP_UT_HOST\n          include_where = false;\n#endif\n          break;\n\n        case 'q':\n          include_fullname = false;\n#ifdef HAVE_STRUCT_XTMP_UT_HOST\n          include_where = false;\n#endif\n          include_idle = false;\n          break;\n\n        case 'h':\n          include_project = false;\n          break;\n\n        case 'p':\n          include_plan = false;\n          break;\n\n        case 'b':\n          include_home_and_shell = false;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  n_users = argc - optind;\n\n  if (!do_short_format && n_users == 0)\n    {\n      error (0, 0, _(\"no username specified; at least one must be\\\n specified when using -l\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (do_short_format)\n    short_pinky (UTMP_FILE, n_users, argv + optind);\n  else\n    long_pinky (n_users, argv + optind);\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}