{
  "module_name": "install.c",
  "hash_id": "52214241b7c5d749cb2841acc6707b7d513e99f2a49cec92843035bb772910ae",
  "original_prompt": "Ingested from coreutils-9.4/src/install.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <signal.h>\n#include <pwd.h>\n#include <grp.h>\n#include <selinux/label.h>\n#include <sys/wait.h>\n\n#include \"system.h\"\n#include \"backupfile.h\"\n#include \"cp-hash.h\"\n#include \"copy.h\"\n#include \"filenamecat.h\"\n#include \"full-read.h\"\n#include \"mkancesdirs.h\"\n#include \"mkdir-p.h\"\n#include \"modechange.h\"\n#include \"prog-fprintf.h\"\n#include \"quote.h\"\n#include \"savewd.h\"\n#include \"selinux.h\"\n#include \"stat-time.h\"\n#include \"targetdir.h\"\n#include \"utimens.h\"\n#include \"xstrtol.h\"\n\n \n#define PROGRAM_NAME \"install\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\nstatic int selinux_enabled = 0;\nstatic bool use_default_selinux_context = true;\n\n#if ! HAVE_ENDGRENT\n# define endgrent() ((void) 0)\n#endif\n\n#if ! HAVE_ENDPWENT\n# define endpwent() ((void) 0)\n#endif\n\n \nstatic char *owner_name;\n\n \nstatic uid_t owner_id;\n\n \nstatic char *group_name;\n\n \nstatic gid_t group_id;\n\n#define DEFAULT_MODE (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)\n\n \nstatic mode_t mode = DEFAULT_MODE;\n\n \nstatic mode_t dir_mode = DEFAULT_MODE;\n\n \nstatic mode_t dir_mode_bits = CHMOD_MODE_BITS;\n\n \nstatic bool copy_only_if_needed;\n\n \nstatic bool strip_files;\n\n \nstatic bool dir_arg;\n\n \nstatic char const *strip_program = \"strip\";\n\n \nenum\n{\n  DEBUG_OPTION = CHAR_MAX + 1,\n  PRESERVE_CONTEXT_OPTION,\n  STRIP_PROGRAM_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"backup\", optional_argument, nullptr, 'b'},\n  {\"compare\", no_argument, nullptr, 'C'},\n  {GETOPT_SELINUX_CONTEXT_OPTION_DECL},\n  {\"debug\", no_argument, nullptr, DEBUG_OPTION},\n  {\"directory\", no_argument, nullptr, 'd'},\n  {\"group\", required_argument, nullptr, 'g'},\n  {\"mode\", required_argument, nullptr, 'm'},\n  {\"no-target-directory\", no_argument, nullptr, 'T'},\n  {\"owner\", required_argument, nullptr, 'o'},\n  {\"preserve-timestamps\", no_argument, nullptr, 'p'},\n  {\"preserve-context\", no_argument, nullptr, PRESERVE_CONTEXT_OPTION},\n  {\"strip\", no_argument, nullptr, 's'},\n  {\"strip-program\", required_argument, nullptr, STRIP_PROGRAM_OPTION},\n  {\"suffix\", required_argument, nullptr, 'S'},\n  {\"target-directory\", required_argument, nullptr, 't'},\n  {\"verbose\", no_argument, nullptr, 'v'},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\n \nstatic bool\nhave_same_content (int a_fd, int b_fd)\n{\n  enum { CMP_BLOCK_SIZE = 4096 };\n  static char a_buff[CMP_BLOCK_SIZE];\n  static char b_buff[CMP_BLOCK_SIZE];\n\n  size_t size;\n  while (0 < (size = full_read (a_fd, a_buff, sizeof a_buff))) {\n    if (size != full_read (b_fd, b_buff, sizeof b_buff))\n      return false;\n\n    if (memcmp (a_buff, b_buff, size) != 0)\n      return false;\n  }\n\n  return size == 0;\n}\n\n \nstatic bool\nextra_mode (mode_t input)\n{\n  mode_t mask = S_IRWXUGO | S_IFMT;\n  return !! (input & ~ mask);\n}\n\n \nstatic bool\nneed_copy (char const *src_name, char const *dest_name,\n           int dest_dirfd, char const *dest_relname,\n           const struct cp_options *x)\n{\n  struct stat src_sb, dest_sb;\n  int src_fd, dest_fd;\n  bool content_match;\n\n  if (extra_mode (mode))\n    return true;\n\n   \n  if (lstat (src_name, &src_sb) != 0)\n    return true;\n\n  if (fstatat (dest_dirfd, dest_relname, &dest_sb, AT_SYMLINK_NOFOLLOW) != 0)\n    return true;\n\n  if (!S_ISREG (src_sb.st_mode) || !S_ISREG (dest_sb.st_mode)\n      || extra_mode (src_sb.st_mode) || extra_mode (dest_sb.st_mode))\n    return true;\n\n  if (src_sb.st_size != dest_sb.st_size\n      || (dest_sb.st_mode & CHMOD_MODE_BITS) != mode)\n    return true;\n\n  if (owner_id == (uid_t) -1)\n    {\n      errno = 0;\n      uid_t ruid = getuid ();\n      if ((ruid == (uid_t) -1 && errno) || dest_sb.st_uid != ruid)\n        return true;\n    }\n  else if (dest_sb.st_uid != owner_id)\n    return true;\n\n  if (group_id == (uid_t) -1)\n    {\n      errno = 0;\n      gid_t rgid = getgid ();\n      if ((rgid == (uid_t) -1 && errno) || dest_sb.st_gid != rgid)\n        return true;\n    }\n  else if (dest_sb.st_gid != group_id)\n    return true;\n\n   \n  if (selinux_enabled && x->preserve_security_context)\n    {\n      char *file_scontext = nullptr;\n      char *to_scontext = nullptr;\n      bool scontext_match;\n\n      if (getfilecon (src_name, &file_scontext) == -1)\n        return true;\n\n      if (getfilecon (dest_name, &to_scontext) == -1)\n        {\n          freecon (file_scontext);\n          return true;\n        }\n\n      scontext_match = STREQ (file_scontext, to_scontext);\n\n      freecon (file_scontext);\n      freecon (to_scontext);\n      if (!scontext_match)\n        return true;\n    }\n\n   \n  src_fd = open (src_name, O_RDONLY | O_BINARY);\n  if (src_fd < 0)\n    return true;\n\n  dest_fd = openat (dest_dirfd, dest_relname, O_RDONLY | O_BINARY);\n  if (dest_fd < 0)\n    {\n      close (src_fd);\n      return true;\n    }\n\n  content_match = have_same_content (src_fd, dest_fd);\n\n  close (src_fd);\n  close (dest_fd);\n  return !content_match;\n}\n\nstatic void\ncp_option_init (struct cp_options *x)\n{\n  cp_options_default (x);\n  x->copy_as_regular = true;\n  x->reflink_mode = REFLINK_AUTO;\n  x->dereference = DEREF_ALWAYS;\n  x->unlink_dest_before_opening = true;\n  x->unlink_dest_after_failed_open = false;\n  x->hard_link = false;\n  x->interactive = I_UNSPECIFIED;\n  x->move_mode = false;\n  x->install_mode = true;\n  x->one_file_system = false;\n  x->preserve_ownership = false;\n  x->preserve_links = false;\n  x->preserve_mode = false;\n  x->preserve_timestamps = false;\n  x->explicit_no_preserve_mode = false;\n  x->reduce_diagnostics=false;\n  x->data_copy_required = true;\n  x->require_preserve = false;\n  x->require_preserve_xattr = false;\n  x->recursive = false;\n  x->sparse_mode = SPARSE_AUTO;\n  x->symbolic_link = false;\n  x->backup_type = no_backups;\n\n   \n  x->set_mode = true;\n  x->mode = S_IRUSR | S_IWUSR;\n  x->stdin_tty = false;\n\n  x->open_dangling_dest_symlink = false;\n  x->update = false;\n  x->require_preserve_context = false;   \n  x->preserve_security_context = false;  \n  x->set_security_context = nullptr;  \n  x->preserve_xattr = false;\n  x->verbose = false;\n  x->dest_info = nullptr;\n  x->src_info = nullptr;\n}\n\nstatic struct selabel_handle *\nget_labeling_handle (void)\n{\n  static bool initialized;\n  static struct selabel_handle *hnd;\n  if (!initialized)\n    {\n      initialized = true;\n      hnd = selabel_open (SELABEL_CTX_FILE, nullptr, 0);\n      if (!hnd)\n        error (0, errno, _(\"warning: security labeling handle failed\"));\n    }\n  return hnd;\n}\n\n \nstatic void\nsetdefaultfilecon (char const *file)\n{\n  struct stat st;\n  char *scontext = nullptr;\n\n  if (selinux_enabled != 1)\n    {\n       \n      return;\n    }\n  if (lstat (file, &st) != 0)\n    return;\n\n  struct selabel_handle *hnd = get_labeling_handle ();\n  if (!hnd)\n    return;\n  if (selabel_lookup (hnd, &scontext, file, st.st_mode) != 0)\n    {\n      if (errno != ENOENT && ! ignorable_ctx_err (errno))\n        error (0, errno, _(\"warning: %s: context lookup failed\"),\n               quotef (file));\n      return;\n    }\n\n  if (lsetfilecon (file, scontext) < 0 && errno != ENOTSUP)\n    error (0, errno,\n           _(\"warning: %s: failed to change context to %s\"),\n           quotef_n (0, file), quote_n (1, scontext));\n\n  freecon (scontext);\n}\n\n \nstatic void\nannounce_mkdir (char const *dir, void *options)\n{\n  struct cp_options const *x = options;\n  if (x->verbose)\n    prog_fprintf (stdout, _(\"creating directory %s\"), quoteaf (dir));\n}\n\n \nstatic int\nmake_ancestor (char const *dir, char const *component, void *options)\n{\n  struct cp_options const *x = options;\n  if (x->set_security_context\n      && defaultcon (x->set_security_context, component, S_IFDIR) < 0\n      && ! ignorable_ctx_err (errno))\n    error (0, errno, _(\"failed to set default creation context for %s\"),\n           quoteaf (dir));\n\n  int r = mkdir (component, DEFAULT_MODE);\n  if (r == 0)\n    announce_mkdir (dir, options);\n  return r;\n}\n\n \nstatic int\nprocess_dir (char *dir, struct savewd *wd, void *options)\n{\n  struct cp_options const *x = options;\n\n  int ret = (make_dir_parents (dir, wd, make_ancestor, options,\n                               dir_mode, announce_mkdir,\n                               dir_mode_bits, owner_id, group_id, false)\n          ? EXIT_SUCCESS\n          : EXIT_FAILURE);\n\n   \n  if (ret == EXIT_SUCCESS && x->set_security_context)\n    {\n      if (! restorecon (x->set_security_context, last_component (dir), false)\n          && ! ignorable_ctx_err (errno))\n        error (0, errno, _(\"failed to restore context for %s\"),\n               quoteaf (dir));\n    }\n\n  return ret;\n}\n\n \n\nstatic bool\ncopy_file (char const *from, char const *to,\n           int to_dirfd, char const *to_relname, const struct cp_options *x)\n{\n  bool copy_into_self;\n\n  if (copy_only_if_needed && !need_copy (from, to, to_dirfd, to_relname, x))\n    return true;\n\n   \n\n  return copy (from, to, to_dirfd, to_relname, 0, x, &copy_into_self, nullptr);\n}\n\n \n\nstatic bool\nchange_attributes (char const *name, int dirfd, char const *relname)\n{\n  bool ok = false;\n   \n\n  if (! (owner_id == (uid_t) -1 && group_id == (gid_t) -1)\n      && lchownat (dirfd, relname, owner_id, group_id) != 0)\n    error (0, errno, _(\"cannot change ownership of %s\"), quoteaf (name));\n  else if (chmodat (dirfd, relname, mode) != 0)\n    error (0, errno, _(\"cannot change permissions of %s\"), quoteaf (name));\n  else\n    ok = true;\n\n  if (use_default_selinux_context)\n    setdefaultfilecon (name);\n\n  return ok;\n}\n\n \n\nstatic bool\nchange_timestamps (struct stat const *src_sb, char const *dest,\n                   int dirfd, char const *relname)\n{\n  struct timespec timespec[2];\n  timespec[0] = get_stat_atime (src_sb);\n  timespec[1] = get_stat_mtime (src_sb);\n\n  if (utimensat (dirfd, relname, timespec, 0))\n    {\n      error (0, errno, _(\"cannot set timestamps for %s\"), quoteaf (dest));\n      return false;\n    }\n  return true;\n}\n\n \n\nstatic bool\nstrip (char const *name)\n{\n  int status;\n  bool ok = false;\n  pid_t pid = fork ();\n\n  switch (pid)\n    {\n    case -1:\n      error (0, errno, _(\"fork system call failed\"));\n      break;\n    case 0:\t\t\t \n      {\n        char const *safe_name = name;\n        if (name && *name == '-')\n          safe_name = file_name_concat (\".\", name, nullptr);\n        execlp (strip_program, strip_program, safe_name, nullptr);\n        error (EXIT_FAILURE, errno, _(\"cannot run %s\"),\n               quoteaf (strip_program));\n      }\n    default:\t\t\t \n      if (waitpid (pid, &status, 0) < 0)\n        error (0, errno, _(\"waiting for strip\"));\n      else if (! WIFEXITED (status) || WEXITSTATUS (status))\n        error (0, 0, _(\"strip process terminated abnormally\"));\n      else\n        ok = true;       \n      break;\n    }\n  return ok;\n}\n\n \n\nstatic void\nget_ids (void)\n{\n  struct passwd *pw;\n  struct group *gr;\n\n  if (owner_name)\n    {\n      pw = getpwnam (owner_name);\n      if (pw == nullptr)\n        {\n          uintmax_t tmp;\n          if (xstrtoumax (owner_name, nullptr, 0, &tmp, \"\") != LONGINT_OK\n              || UID_T_MAX < tmp)\n            error (EXIT_FAILURE, 0, _(\"invalid user %s\"),\n                   quoteaf (owner_name));\n          owner_id = tmp;\n        }\n      else\n        owner_id = pw->pw_uid;\n      endpwent ();\n    }\n  else\n    owner_id = (uid_t) -1;\n\n  if (group_name)\n    {\n      gr = getgrnam (group_name);\n      if (gr == nullptr)\n        {\n          uintmax_t tmp;\n          if (xstrtoumax (group_name, nullptr, 0, &tmp, \"\") != LONGINT_OK\n              || GID_T_MAX < tmp)\n            error (EXIT_FAILURE, 0, _(\"invalid group %s\"),\n                   quoteaf (group_name));\n          group_id = tmp;\n        }\n      else\n        group_id = gr->gr_gid;\n      endgrent ();\n    }\n  else\n    group_id = (gid_t) -1;\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [-T] SOURCE DEST\\n\\\n  or:  %s [OPTION]... SOURCE... DIRECTORY\\n\\\n  or:  %s [OPTION]... -t DIRECTORY SOURCE...\\n\\\n  or:  %s [OPTION]... -d DIRECTORY...\\n\\\n\"),\n              program_name, program_name, program_name, program_name);\n      fputs (_(\"\\\n\\n\\\nThis install program copies files (often just compiled) into destination\\n\\\nlocations you choose.  If you want to download and install a ready-to-use\\n\\\npackage on a GNU/Linux system, you should instead be using a package manager\\n\\\nlike yum(1) or apt-get(1).\\n\\\n\\n\\\nIn the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\\n\\\nthe existing DIRECTORY, while setting permission modes and owner/group.\\n\\\nIn the 4th form, create all components of the given DIRECTORY(ies).\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n      --backup[=CONTROL]  make a backup of each existing destination file\\n\\\n  -b                  like --backup but does not accept an argument\\n\\\n  -c                  (ignored)\\n\\\n  -C, --compare       compare content of source and destination files, and\\n\\\n                        if no change to content, ownership, and permissions,\\n\\\n                        do not modify the destination at all\\n\\\n  -d, --directory     treat all arguments as directory names; create all\\n\\\n                        components of the specified directories\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -D                  create all leading components of DEST except the last,\\n\\\n                        or all components of --target-directory,\\n\\\n                        then copy SOURCE to DEST\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --debug         explain how a file is copied.  Implies -v\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -g, --group=GROUP   set group ownership, instead of process' current group\\n\\\n  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-x\\n\\\n  -o, --owner=OWNER   set ownership (super-user only)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -p, --preserve-timestamps   apply access/modification times of SOURCE files\\n\\\n                        to corresponding destination files\\n\\\n  -s, --strip         strip symbol tables\\n\\\n      --strip-program=PROGRAM  program used to strip binaries\\n\\\n  -S, --suffix=SUFFIX  override the usual backup suffix\\n\\\n  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY\\n\\\n  -T, --no-target-directory  treat DEST as a normal file\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -v, --verbose       print the name of each created file or directory\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --preserve-context  preserve SELinux security context\\n\\\n  -Z                      set SELinux security context of destination\\n\\\n                            file and each created directory to default type\\n\\\n      --context[=CTX]     like -Z, or if CTX is specified then set the\\n\\\n                            SELinux or SMACK security context to CTX\\n\\\n\"), stdout);\n\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_backup_suffix_note ();\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Copy file FROM onto file TO aka TO_DIRFD+TO_RELNAME and give TO the\n   appropriate attributes.  X gives the command options.\n   Return true if successful.  */\n\nstatic bool\ninstall_file_in_file (char const *from, char const *to,\n                      int to_dirfd, char const *to_relname,\n                      const struct cp_options *x)\n{\n  struct stat from_sb;\n  if (x->preserve_timestamps && stat (from, &from_sb) != 0)\n    {\n      error (0, errno, _(\"cannot stat %s\"), quoteaf (from));\n      return false;\n    }\n  if (! copy_file (from, to, to_dirfd, to_relname, x))\n    return false;\n  if (strip_files)\n    if (! strip (to))\n      {\n        if (unlinkat (to_dirfd, to_relname, 0) != 0)  /* Cleanup.  */\n          error (EXIT_FAILURE, errno, _(\"cannot unlink %s\"), quoteaf (to));\n        return false;\n      }\n  if (x->preserve_timestamps && (strip_files || ! S_ISREG (from_sb.st_mode))\n      && ! change_timestamps (&from_sb, to, to_dirfd, to_relname))\n    return false;\n  return change_attributes (to, to_dirfd, to_relname);\n}\n\n/* Create any missing parent directories of TO,\n   while maintaining the current Working Directory.\n   Return true if successful.  */\n\nstatic bool\nmkancesdirs_safe_wd (char const *from, char *to, struct cp_options *x,\n                     bool save_always)\n{\n  bool save_working_directory =\n    save_always\n    || ! (IS_ABSOLUTE_FILE_NAME (from) && IS_ABSOLUTE_FILE_NAME (to));\n  int status = EXIT_SUCCESS;\n\n  struct savewd wd;\n  savewd_init (&wd);\n  if (! save_working_directory)\n    savewd_finish (&wd);\n\n  if (mkancesdirs (to, &wd, make_ancestor, x) == -1)\n    {\n      error (0, errno, _(\"cannot create directory %s\"), quoteaf (to));\n      status = EXIT_FAILURE;\n    }\n\n  if (save_working_directory)\n    {\n      int restore_result = savewd_restore (&wd, status);\n      int restore_errno = errno;\n      savewd_finish (&wd);\n      if (EXIT_SUCCESS < restore_result)\n        return false;\n      if (restore_result < 0 && status == EXIT_SUCCESS)\n        {\n          error (0, restore_errno, _(\"cannot create directory %s\"),\n                 quoteaf (to));\n          return false;\n        }\n    }\n  return status == EXIT_SUCCESS;\n}\n\n/* Copy file FROM onto file TO, creating any missing parent directories of TO.\n   Return true if successful.  */\n\nstatic bool\ninstall_file_in_file_parents (char const *from, char *to,\n                              const struct cp_options *x)\n{\n  return (mkancesdirs_safe_wd (from, to, (struct cp_options *)x, false)\n          && install_file_in_file (from, to, AT_FDCWD, to, x));\n}\n\n/* Copy file FROM into directory TO_DIR, keeping its same name,\n   and give the copy the appropriate attributes.\n   Return true if successful.  */\n\nstatic bool\ninstall_file_in_dir (char const *from, char const *to_dir,\n                     const struct cp_options *x, bool mkdir_and_install,\n                     int *target_dirfd)\n{\n  char const *from_base = last_component (from);\n  char *to_relname;\n  char *to = file_name_concat (to_dir, from_base, &to_relname);\n  bool ret = true;\n\n  if (!target_dirfd_valid (*target_dirfd)\n      && (ret = mkdir_and_install)\n      && (ret = mkancesdirs_safe_wd (from, to, (struct cp_options *) x, true)))\n    {\n      int fd = open (to_dir, O_PATHSEARCH | O_DIRECTORY);\n      if (fd < 0)\n        {\n          error (0, errno, _(\"cannot open %s\"), quoteaf (to));\n          ret = false;\n        }\n      else\n        *target_dirfd = fd;\n    }\n\n  if (ret)\n    {\n      int to_dirfd = *target_dirfd;\n      if (!target_dirfd_valid (to_dirfd))\n        {\n          to_dirfd = AT_FDCWD;\n          to_relname = to;\n        }\n      ret = install_file_in_file (from, to, to_dirfd, to_relname, x);\n    }\n\n  free (to);\n  return ret;\n}\n\nint\nmain (int argc, char **argv)\n{\n  int optc;\n  int exit_status = EXIT_SUCCESS;\n  char const *specified_mode = nullptr;\n  bool make_backups = false;\n  char const *backup_suffix = nullptr;\n  char *version_control_string = nullptr;\n  bool mkdir_and_install = false;\n  struct cp_options x;\n  char const *target_directory = nullptr;\n  bool no_target_directory = false;\n  int n_files;\n  char **file;\n  bool strip_program_specified = false;\n  char const *scontext = nullptr;\n  /* set iff kernel has extra selinux system calls */\n  selinux_enabled = (0 < is_selinux_enabled ());\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdin);\n\n  cp_option_init (&x);\n\n  owner_name = nullptr;\n  group_name = nullptr;\n  strip_files = false;\n  dir_arg = false;\n  umask (0);\n\n  while ((optc = getopt_long (argc, argv, \"bcCsDdg:m:o:pt:TvS:Z\", long_options,\n                              nullptr))\n         != -1)\n    {\n      switch (optc)\n        {\n        case 'b':\n          make_backups = true;\n          if (optarg)\n            version_control_string = optarg;\n          break;\n        case 'c':\n          break;\n        case 'C':\n          copy_only_if_needed = true;\n          break;\n        case 's':\n          strip_files = true;\n#ifdef SIGCHLD\n          /* System V fork+wait does not work if SIGCHLD is ignored.  */\n          signal (SIGCHLD, SIG_DFL);\n#endif\n          break;\n        case DEBUG_OPTION:\n          x.debug = x.verbose = true;\n          break;\n        case STRIP_PROGRAM_OPTION:\n          strip_program = xstrdup (optarg);\n          strip_program_specified = true;\n          break;\n        case 'd':\n          dir_arg = true;\n          break;\n        case 'D':\n          mkdir_and_install = true;\n          break;\n        case 'v':\n          x.verbose = true;\n          break;\n        case 'g':\n          group_name = optarg;\n          break;\n        case 'm':\n          specified_mode = optarg;\n          break;\n        case 'o':\n          owner_name = optarg;\n          break;\n        case 'p':\n          x.preserve_timestamps = true;\n          break;\n        case 'S':\n          make_backups = true;\n          backup_suffix = optarg;\n          break;\n        case 't':\n          if (target_directory)\n            error (EXIT_FAILURE, 0,\n                   _(\"multiple target directories specified\"));\n          target_directory = optarg;\n          break;\n        case 'T':\n          no_target_directory = true;\n          break;\n\n        case PRESERVE_CONTEXT_OPTION:\n          if (! selinux_enabled)\n            {\n              error (0, 0, _(\"WARNING: ignoring --preserve-context; \"\n                             \"this kernel is not SELinux-enabled\"));\n              break;\n            }\n          x.preserve_security_context = true;\n          use_default_selinux_context = false;\n          break;\n        case 'Z':\n          if (selinux_enabled)\n            {\n              /* Disable use of the install(1) specific setdefaultfilecon().\n                 Note setdefaultfilecon() is different from the newer and more\n                 generic restorecon() in that the former sets the context of\n                 the dest files to that returned by selabel_lookup directly,\n                 thus discarding MLS level and user identity of the file.\n                 TODO: consider removing setdefaultfilecon() in future.  */\n              use_default_selinux_context = false;\n\n              if (optarg)\n                scontext = optarg;\n              else\n                x.set_security_context = get_labeling_handle ();\n            }\n          else if (optarg)\n            {\n              error (0, 0,\n                     _(\"warning: ignoring --context; \"\n                       \"it requires an SELinux-enabled kernel\"));\n            }\n          break;\n        case_GETOPT_HELP_CHAR;\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n        default:\n          usage (EXIT_FAILURE);\n        }\n    }\n\n  /* Check for invalid combinations of arguments. */\n  if (dir_arg && strip_files)\n    error (EXIT_FAILURE, 0,\n           _(\"the strip option may not be used when installing a directory\"));\n  if (dir_arg && target_directory)\n    error (EXIT_FAILURE, 0,\n           _(\"target directory not allowed when installing a directory\"));\n\n  x.backup_type = (make_backups\n                   ? xget_version (_(\"backup type\"),\n                                   version_control_string)\n                   : no_backups);\n  set_simple_backup_suffix (backup_suffix);\n\n  if (x.preserve_security_context && (x.set_security_context || scontext))\n    error (EXIT_FAILURE, 0,\n           _(\"cannot set target context and preserve it\"));\n\n  if (scontext && setfscreatecon (scontext) < 0)\n    error (EXIT_FAILURE, errno,\n           _(\"failed to set default file creation context to %s\"),\n         quote (scontext));\n\n  n_files = argc - optind;\n  file = argv + optind;\n\n  if (n_files <= ! (dir_arg || target_directory))\n    {\n      if (n_files <= 0)\n        error (0, 0, _(\"missing file operand\"));\n      else\n        error (0, 0, _(\"missing destination file operand after %s\"),\n               quoteaf (file[0]));\n      usage (EXIT_FAILURE);\n    }\n\n  struct stat sb;\n  int target_dirfd = AT_FDCWD;\n  if (no_target_directory)\n    {\n      if (target_directory)\n        error (EXIT_FAILURE, 0,\n               _(\"cannot combine --target-directory (-t) \"\n                 \"and --no-target-directory (-T)\"));\n      if (2 < n_files)\n        {\n          error (0, 0, _(\"extra operand %s\"), quoteaf (file[2]));\n          usage (EXIT_FAILURE);\n        }\n    }\n  else if (target_directory)\n    {\n      target_dirfd = target_directory_operand (target_directory, &sb);\n      if (! (target_dirfd_valid (target_dirfd)\n             || (mkdir_and_install && errno == ENOENT)))\n        error (EXIT_FAILURE, errno, _(\"failed to access %s\"),\n               quoteaf (target_directory));\n    }\n  else if (!dir_arg)\n    {\n      char const *lastfile = file[n_files - 1];\n      int fd = target_directory_operand (lastfile, &sb);\n      if (target_dirfd_valid (fd))\n        {\n          target_dirfd = fd;\n          target_directory = lastfile;\n          n_files--;\n        }\n      else if (2 < n_files)\n        error (EXIT_FAILURE, errno, _(\"target %s\"), quoteaf (lastfile));\n    }\n\n  if (specified_mode)\n    {\n      struct mode_change *change = mode_compile (specified_mode);\n      if (!change)\n        error (EXIT_FAILURE, 0, _(\"invalid mode %s\"), quote (specified_mode));\n      mode = mode_adjust (0, false, 0, change, nullptr);\n      dir_mode = mode_adjust (0, true, 0, change, &dir_mode_bits);\n      free (change);\n    }\n\n  if (strip_program_specified && !strip_files)\n    error (0, 0, _(\"WARNING: ignoring --strip-program option as -s option was \"\n                   \"not specified\"));\n\n  if (copy_only_if_needed && x.preserve_timestamps)\n    {\n      error (0, 0, _(\"options --compare (-C) and --preserve-timestamps are \"\n                     \"mutually exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (copy_only_if_needed && strip_files)\n    {\n      error (0, 0, _(\"options --compare (-C) and --strip are mutually \"\n                     \"exclusive\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (copy_only_if_needed && extra_mode (mode))\n    error (0, 0, _(\"the --compare (-C) option is ignored when you\"\n                   \" specify a mode with non-permission bits\"));\n\n  get_ids ();\n\n  if (dir_arg)\n    exit_status = savewd_process_files (n_files, file, process_dir, &x);\n  else\n    {\n       \n      hash_init ();\n\n      if (!target_directory)\n        {\n          if (! (mkdir_and_install\n                 ? install_file_in_file_parents (file[0], file[1], &x)\n                 : install_file_in_file (file[0], file[1], AT_FDCWD,\n                                         file[1], &x)))\n            exit_status = EXIT_FAILURE;\n        }\n      else\n        {\n          int i;\n          dest_info_init (&x);\n          for (i = 0; i < n_files; i++)\n            if (! install_file_in_dir (file[i], target_directory, &x,\n                                       i == 0 && mkdir_and_install,\n                                       &target_dirfd))\n              exit_status = EXIT_FAILURE;\n        }\n    }\n\n  main_exit (exit_status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}