{
  "module_name": "printf.c",
  "hash_id": "af817cbd46df7e4f305e58cca1670b2c9de7829ea2bfe015cc63015eee8b04e0",
  "original_prompt": "Ingested from coreutils-9.4/src/printf.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <wchar.h>\n\n#include \"system.h\"\n#include \"cl-strtod.h\"\n#include \"quote.h\"\n#include \"unicodeio.h\"\n#include \"xprintf.h\"\n\n \n#define PROGRAM_NAME \"printf\"\n\n#define AUTHORS proper_name (\"David MacKenzie\")\n\n#define isodigit(c) ((c) >= '0' && (c) <= '7')\n#define hextobin(c) ((c) >= 'a' && (c) <= 'f' ? (c) - 'a' + 10 : \\\n                     (c) >= 'A' && (c) <= 'F' ? (c) - 'A' + 10 : (c) - '0')\n#define octtobin(c) ((c) - '0')\n\n \nstatic int exit_status;\n\n \nstatic bool posixly_correct;\n\n \nstatic char const *const cfcc_msg =\n N_(\"warning: %s: character(s) following character constant have been ignored\");\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s FORMAT [ARGUMENT]...\\n\\\n  or:  %s OPTION\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nPrint ARGUMENT(s) according to FORMAT, or execute according to OPTION:\\n\\\n\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nFORMAT controls the output as in C printf.  Interpreted sequences are:\\n\\\n\\n\\\n  \\\\\\\"      double quote\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  \\\\\\\\      backslash\\n\\\n  \\\\a      alert (BEL)\\n\\\n  \\\\b      backspace\\n\\\n  \\\\c      produce no further output\\n\\\n  \\\\e      escape\\n\\\n  \\\\f      form feed\\n\\\n  \\\\n      new line\\n\\\n  \\\\r      carriage return\\n\\\n  \\\\t      horizontal tab\\n\\\n  \\\\v      vertical tab\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  \\\\NNN    byte with octal value NNN (1 to 3 digits)\\n\\\n  \\\\xHH    byte with hexadecimal value HH (1 to 2 digits)\\n\\\n  \\\\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\\n\\\n  \\\\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  %%      a single %\\n\\\n  %b      ARGUMENT as a string with '\\\\' escapes interpreted,\\n\\\n          except that octal escapes are of the form \\\\0 or \\\\0NNN\\n\\\n  %q      ARGUMENT is printed in a format that can be reused as shell input,\\n\\\n          escaping non-printable characters with the proposed POSIX $'' syntax.\\\n\\n\\n\\\nand all C format specifications ending with one of diouxXfeEgGcs, with\\n\\\nARGUMENTs converted to proper type first.  Variable widths are handled.\\n\\\n\"), stdout);\n      printf (USAGE_BUILTIN_WARNING, PROGRAM_NAME);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\nstatic void\nverify_numeric (char const *s, char const *end)\n{\n  if (errno)\n    {\n      error (0, errno, \"%s\", quote (s));\n      exit_status = EXIT_FAILURE;\n    }\n  else if (*end)\n    {\n      if (s == end)\n        error (0, 0, _(\"%s: expected a numeric value\"), quote (s));\n      else\n        error (0, 0, _(\"%s: value not completely converted\"), quote (s));\n      exit_status = EXIT_FAILURE;\n    }\n}\n\n#define STRTOX(TYPE, FUNC_NAME, LIB_FUNC_EXPR)\t\t\t\t \\\nstatic TYPE\t\t\t\t\t\t\t\t \\\nFUNC_NAME (char const *s)\t\t\t\t\t\t \\\n{\t\t\t\t\t\t\t\t\t \\\n  char *end;\t\t\t\t\t\t\t\t \\\n  TYPE val;\t\t\t\t\t\t\t\t \\\n                                                                         \\\n  if ((*s == '\\\"' || *s == '\\'') && *(s + 1))\t\t\t\t \\\n    {\t\t\t\t\t\t\t\t\t \\\n      unsigned char ch = *++s;\t\t\t\t\t\t \\\n      val = ch;\t\t\t\t\t\t\t\t \\\n                                                                         \\\n      if (MB_CUR_MAX > 1 && *(s + 1))\t\t\t\t\t \\\n        {\t\t\t\t\t\t\t\t \\\n          mbstate_t mbstate = { 0, };\t\t\t\t\t \\\n          wchar_t wc;\t\t\t\t\t\t\t \\\n          size_t slen = strlen (s);\t\t\t\t\t \\\n          ssize_t bytes;\t\t\t\t\t\t \\\n          bytes = mbrtowc (&wc, s, slen, &mbstate);\t\t\t \\\n          if (0 < bytes)\t\t\t\t\t\t \\\n            {\t\t\t\t\t\t\t\t \\\n              val = wc;\t\t\t\t\t\t\t \\\n              s += bytes - 1;\t\t\t\t\t\t \\\n            }\t\t\t\t\t\t\t\t \\\n        }\t\t\t\t\t\t\t\t \\\n                                                                         \\\n       \t\t\t\t \\\n      if (*++s != 0 && !posixly_correct)\t\t\t\t \\\n        error (0, 0, _(cfcc_msg), s);\t\t\t\t\t \\\n    }\t\t\t\t\t\t\t\t\t \\\n  else\t\t\t\t\t\t\t\t\t \\\n    {\t\t\t\t\t\t\t\t\t \\\n      errno = 0;\t\t\t\t\t\t\t \\\n      val = (LIB_FUNC_EXPR);\t\t\t\t\t\t \\\n      verify_numeric (s, end);\t\t\t\t\t\t \\\n    }\t\t\t\t\t\t\t\t\t \\\n  return val;\t\t\t\t\t\t\t\t \\\n}\t\t\t\t\t\t\t\t\t \\\n\nSTRTOX (intmax_t,    vstrtoimax, strtoimax (s, &end, 0))\nSTRTOX (uintmax_t,   vstrtoumax, strtoumax (s, &end, 0))\nSTRTOX (long double, vstrtold,   cl_strtold (s, &end))\n\n \n\nstatic void\nprint_esc_char (char c)\n{\n  switch (c)\n    {\n    case 'a':\t\t\t \n      putchar ('\\a');\n      break;\n    case 'b':\t\t\t \n      putchar ('\\b');\n      break;\n    case 'c':\t\t\t \n      exit (EXIT_SUCCESS);\n      break;\n    case 'e':\t\t\t \n      putchar ('\\x1B');\n      break;\n    case 'f':\t\t\t \n      putchar ('\\f');\n      break;\n    case 'n':\t\t\t \n      putchar ('\\n');\n      break;\n    case 'r':\t\t\t \n      putchar ('\\r');\n      break;\n    case 't':\t\t\t \n      putchar ('\\t');\n      break;\n    case 'v':\t\t\t \n      putchar ('\\v');\n      break;\n    default:\n      putchar (c);\n      break;\n    }\n}\n\n \n\nstatic int\nprint_esc (char const *escstart, bool octal_0)\n{\n  char const *p = escstart + 1;\n  int esc_value = 0;\t\t \n  int esc_length;\t\t \n\n  if (*p == 'x')\n    {\n       \n      for (esc_length = 0, ++p;\n           esc_length < 2 && isxdigit (to_uchar (*p));\n           ++esc_length, ++p)\n        esc_value = esc_value * 16 + hextobin (*p);\n      if (esc_length == 0)\n        error (EXIT_FAILURE, 0, _(\"missing hexadecimal number in escape\"));\n      putchar (esc_value);\n    }\n  else if (isodigit (*p))\n    {\n       \n      for (esc_length = 0, p += octal_0 && *p == '0';\n           esc_length < 3 && isodigit (*p);\n           ++esc_length, ++p)\n        esc_value = esc_value * 8 + octtobin (*p);\n      putchar (esc_value);\n    }\n  else if (*p && strchr (\"\\\"\\\\abcefnrtv\", *p))\n    print_esc_char (*p++);\n  else if (*p == 'u' || *p == 'U')\n    {\n      char esc_char = *p;\n      unsigned int uni_value;\n\n      uni_value = 0;\n      for (esc_length = (esc_char == 'u' ? 4 : 8), ++p;\n           esc_length > 0;\n           --esc_length, ++p)\n        {\n          if (! isxdigit (to_uchar (*p)))\n            error (EXIT_FAILURE, 0, _(\"missing hexadecimal number in escape\"));\n          uni_value = uni_value * 16 + hextobin (*p);\n        }\n\n       \n      if (uni_value >= 0xd800 && uni_value <= 0xdfff)\n        error (EXIT_FAILURE, 0, _(\"invalid universal character name \\\\%c%0*x\"),\n               esc_char, (esc_char == 'u' ? 4 : 8), uni_value);\n\n      print_unicode_char (stdout, uni_value, 0);\n    }\n  else\n    {\n      putchar ('\\\\');\n      if (*p)\n        {\n          putchar (*p);\n          p++;\n        }\n    }\n  return p - escstart - 1;\n}\n\n \n\nstatic void\nprint_esc_string (char const *str)\n{\n  for (; *str; str++)\n    if (*str == '\\\\')\n      str += print_esc (str, true);\n    else\n      putchar (*str);\n}\n\n \n\nstatic void\nprint_direc (char const *start, size_t length, char conversion,\n             bool have_field_width, int field_width,\n             bool have_precision, int precision,\n             char const *argument)\n{\n  char *p;\t\t \n\n   \n  {\n    char *q;\n    char const *length_modifier;\n    size_t length_modifier_len;\n\n    switch (conversion)\n      {\n      case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':\n        length_modifier = PRIdMAX;\n        length_modifier_len = sizeof PRIdMAX - 2;\n        break;\n\n      case 'a': case 'e': case 'f': case 'g':\n      case 'A': case 'E': case 'F': case 'G':\n        length_modifier = \"L\";\n        length_modifier_len = 1;\n        break;\n\n      default:\n        length_modifier = start;   \n        length_modifier_len = 0;\n        break;\n      }\n\n    p = xmalloc (length + length_modifier_len + 2);\n    q = mempcpy (p, start, length);\n    q = mempcpy (q, length_modifier, length_modifier_len);\n    *q++ = conversion;\n    *q = '\\0';\n  }\n\n  switch (conversion)\n    {\n    case 'd':\n    case 'i':\n      {\n        intmax_t arg = vstrtoimax (argument);\n        if (!have_field_width)\n          {\n            if (!have_precision)\n              xprintf (p, arg);\n            else\n              xprintf (p, precision, arg);\n          }\n        else\n          {\n            if (!have_precision)\n              xprintf (p, field_width, arg);\n            else\n              xprintf (p, field_width, precision, arg);\n          }\n      }\n      break;\n\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n      {\n        uintmax_t arg = vstrtoumax (argument);\n        if (!have_field_width)\n          {\n            if (!have_precision)\n              xprintf (p, arg);\n            else\n              xprintf (p, precision, arg);\n          }\n        else\n          {\n            if (!have_precision)\n              xprintf (p, field_width, arg);\n            else\n              xprintf (p, field_width, precision, arg);\n          }\n      }\n      break;\n\n    case 'a':\n    case 'A':\n    case 'e':\n    case 'E':\n    case 'f':\n    case 'F':\n    case 'g':\n    case 'G':\n      {\n        long double arg = vstrtold (argument);\n        if (!have_field_width)\n          {\n            if (!have_precision)\n              xprintf (p, arg);\n            else\n              xprintf (p, precision, arg);\n          }\n        else\n          {\n            if (!have_precision)\n              xprintf (p, field_width, arg);\n            else\n              xprintf (p, field_width, precision, arg);\n          }\n      }\n      break;\n\n    case 'c':\n      if (!have_field_width)\n        xprintf (p, *argument);\n      else\n        xprintf (p, field_width, *argument);\n      break;\n\n    case 's':\n      if (!have_field_width)\n        {\n          if (!have_precision)\n            xprintf (p, argument);\n          else\n            xprintf (p, precision, argument);\n        }\n      else\n        {\n          if (!have_precision)\n            xprintf (p, field_width, argument);\n          else\n            xprintf (p, field_width, precision, argument);\n        }\n      break;\n    }\n\n  free (p);\n}\n\n \n\nstatic int\nprint_formatted (char const *format, int argc, char **argv)\n{\n  int save_argc = argc;\t\t \n  char const *f;\t\t \n  char const *direc_start;\t \n  size_t direc_length;\t\t \n  bool have_field_width;\t \n  int field_width = 0;\t\t \n  bool have_precision;\t\t \n  int precision = 0;\t\t \n  char ok[UCHAR_MAX + 1];\t \n\n  for (f = format; *f; ++f)\n    {\n      switch (*f)\n        {\n        case '%':\n          direc_start = f++;\n          direc_length = 1;\n          have_field_width = have_precision = false;\n          if (*f == '%')\n            {\n              putchar ('%');\n              break;\n            }\n          if (*f == 'b')\n            {\n               \n              if (argc > 0)\n                {\n                  print_esc_string (*argv);\n                  ++argv;\n                  --argc;\n                }\n              break;\n            }\n\n          if (*f == 'q')\n            {\n              if (argc > 0)\n                {\n                  fputs (quotearg_style (shell_escape_quoting_style, *argv),\n                         stdout);\n                  ++argv;\n                  --argc;\n                }\n              break;\n            }\n\n          memset (ok, 0, sizeof ok);\n          ok['a'] = ok['A'] = ok['c'] = ok['d'] = ok['e'] = ok['E'] =\n            ok['f'] = ok['F'] = ok['g'] = ok['G'] = ok['i'] = ok['o'] =\n            ok['s'] = ok['u'] = ok['x'] = ok['X'] = 1;\n\n          for (;; f++, direc_length++)\n            switch (*f)\n              {\n#if (__GLIBC__ == 2 && 2 <= __GLIBC_MINOR__) || 3 <= __GLIBC__\n              case 'I':\n#endif\n              case '\\'':\n                ok['a'] = ok['A'] = ok['c'] = ok['e'] = ok['E'] =\n                  ok['o'] = ok['s'] = ok['x'] = ok['X'] = 0;\n                break;\n              case '-': case '+': case ' ':\n                break;\n              case '#':\n                ok['c'] = ok['d'] = ok['i'] = ok['s'] = ok['u'] = 0;\n                break;\n              case '0':\n                ok['c'] = ok['s'] = 0;\n                break;\n              default:\n                goto no_more_flag_characters;\n              }\n        no_more_flag_characters:\n\n          if (*f == '*')\n            {\n              ++f;\n              ++direc_length;\n              if (argc > 0)\n                {\n                  intmax_t width = vstrtoimax (*argv);\n                  if (INT_MIN <= width && width <= INT_MAX)\n                    field_width = width;\n                  else\n                    error (EXIT_FAILURE, 0, _(\"invalid field width: %s\"),\n                           quote (*argv));\n                  ++argv;\n                  --argc;\n                }\n              else\n                field_width = 0;\n              have_field_width = true;\n            }\n          else\n            while (ISDIGIT (*f))\n              {\n                ++f;\n                ++direc_length;\n              }\n          if (*f == '.')\n            {\n              ++f;\n              ++direc_length;\n              ok['c'] = 0;\n              if (*f == '*')\n                {\n                  ++f;\n                  ++direc_length;\n                  if (argc > 0)\n                    {\n                      intmax_t prec = vstrtoimax (*argv);\n                      if (prec < 0)\n                        {\n                           \n                          precision = -1;\n                        }\n                      else if (INT_MAX < prec)\n                        error (EXIT_FAILURE, 0, _(\"invalid precision: %s\"),\n                               quote (*argv));\n                      else\n                        precision = prec;\n                      ++argv;\n                      --argc;\n                    }\n                  else\n                    precision = 0;\n                  have_precision = true;\n                }\n              else\n                while (ISDIGIT (*f))\n                  {\n                    ++f;\n                    ++direc_length;\n                  }\n            }\n\n          while (*f == 'l' || *f == 'L' || *f == 'h'\n                 || *f == 'j' || *f == 't' || *f == 'z')\n            ++f;\n\n          {\n            unsigned char conversion = *f;\n            int speclen = MIN (f + 1 - direc_start, INT_MAX);\n            if (! ok[conversion])\n              error (EXIT_FAILURE, 0,\n                     _(\"%.*s: invalid conversion specification\"),\n                     speclen, direc_start);\n          }\n\n          print_direc (direc_start, direc_length, *f,\n                       have_field_width, field_width,\n                       have_precision, precision,\n                       (argc <= 0 ? \"\" : (argc--, *argv++)));\n          break;\n\n        case '\\\\':\n          f += print_esc (f, false);\n          break;\n\n        default:\n          putchar (*f);\n        }\n    }\n\n  return save_argc - argc;\n}\n\nint\nmain (int argc, char **argv)\n{\n  char *format;\n  int args_used;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  exit_status = EXIT_SUCCESS;\n\n  posixly_correct = (getenv (\"POSIXLY_CORRECT\") != nullptr);\n\n   \n  if (argc == 2)\n    {\n      if (STREQ (argv[1], \"--help\"))\n        usage (EXIT_SUCCESS);\n\n      if (STREQ (argv[1], \"--version\"))\n        {\n          version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version, AUTHORS,\n                       (char *) nullptr);\n          return EXIT_SUCCESS;\n        }\n    }\n\n   \n  if (1 < argc && STREQ (argv[1], \"--\"))\n    {\n      --argc;\n      ++argv;\n    }\n\n  if (argc <= 1)\n    {\n      error (0, 0, _(\"missing operand\"));\n      usage (EXIT_FAILURE);\n    }\n\n  format = argv[1];\n  argc -= 2;\n  argv += 2;\n\n  do\n    {\n      args_used = print_formatted (format, argc, argv);\n      argc -= args_used;\n      argv += args_used;\n    }\n  while (args_used > 0 && argc > 0);\n\n  if (argc > 0)\n    error (0, 0,\n           _(\"warning: ignoring excess arguments, starting with %s\"),\n           quote (argv[0]));\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}