{
  "module_name": "wc.c",
  "hash_id": "2e113dcc6c7019ee99f4dcc2711885c433e42529390a3429dba3140785b0060c",
  "original_prompt": "Ingested from coreutils-9.4/src/wc.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdckdint.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <wchar.h>\n#include <wctype.h>\n\n#include \"system.h\"\n#include \"assure.h\"\n#include \"argmatch.h\"\n#include \"argv-iter.h\"\n#include \"fadvise.h\"\n#include \"mbchar.h\"\n#include \"physmem.h\"\n#include \"readtokens0.h\"\n#include \"safe-read.h\"\n#include \"stat-size.h\"\n#include \"xbinary-io.h\"\n\n#if !defined iswspace && !HAVE_ISWSPACE\n# define iswspace(wc) \\\n    ((wc) == to_uchar (wc) && isspace (to_uchar (wc)))\n#endif\n\n \n#define PROGRAM_NAME \"wc\"\n\n#define AUTHORS \\\n  proper_name (\"Paul Rubin\"), \\\n  proper_name (\"David MacKenzie\")\n\n \n#define BUFFER_SIZE (16 * 1024)\n\n#ifdef USE_AVX2_WC_LINECOUNT\n \nextern bool\nwc_lines_avx2 (char const *file, int fd, uintmax_t *lines_out,\n               uintmax_t *bytes_out);\n#endif\n\nstatic bool debug;\n\n \nstatic uintmax_t total_lines;\nstatic uintmax_t total_words;\nstatic uintmax_t total_chars;\nstatic uintmax_t total_bytes;\nstatic uintmax_t total_lines_overflow;\nstatic uintmax_t total_words_overflow;\nstatic uintmax_t total_chars_overflow;\nstatic uintmax_t total_bytes_overflow;\nstatic uintmax_t max_line_length;\n\n \nstatic bool print_lines, print_words, print_chars, print_bytes;\nstatic bool print_linelength;\n\n \nstatic int number_width;\n\n \nstatic bool have_read_stdin;\n\n \nstatic size_t page_size;\n\n \nstatic bool posixly_correct;\n\n \nstruct fstatus\n{\n   \n  int failed;\n\n   \n  struct stat st;\n};\n\n \nenum\n{\n  DEBUG_PROGRAM_OPTION = CHAR_MAX + 1,\n  FILES0_FROM_OPTION,\n  TOTAL_OPTION,\n};\n\nstatic struct option const longopts[] =\n{\n  {\"bytes\", no_argument, nullptr, 'c'},\n  {\"chars\", no_argument, nullptr, 'm'},\n  {\"lines\", no_argument, nullptr, 'l'},\n  {\"words\", no_argument, nullptr, 'w'},\n  {\"debug\", no_argument, nullptr, DEBUG_PROGRAM_OPTION},\n  {\"files0-from\", required_argument, nullptr, FILES0_FROM_OPTION},\n  {\"max-line-length\", no_argument, nullptr, 'L'},\n  {\"total\", required_argument, nullptr, TOTAL_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nenum total_type\n  {\n    total_auto,          \n    total_always,        \n    total_only,          \n    total_never          \n  };\nstatic char const *const total_args[] =\n{\n  \"auto\", \"always\", \"only\", \"never\", nullptr\n};\nstatic enum total_type const total_types[] =\n{\n  total_auto, total_always, total_only, total_never\n};\nARGMATCH_VERIFY (total_args, total_types);\nstatic enum total_type total_mode = total_auto;\n\n#ifdef USE_AVX2_WC_LINECOUNT\nstatic bool\navx2_supported (void)\n{\n  bool avx_enabled = 0 < __builtin_cpu_supports (\"avx2\");\n\n  if (debug)\n    error (0, 0, (avx_enabled\n                  ? _(\"using avx2 hardware support\")\n                  : _(\"avx2 support not detected\")));\n\n  return avx_enabled;\n}\n#endif\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n  or:  %s [OPTION]... --files0-from=F\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nPrint newline, word, and byte counts for each FILE, and a total line if\\n\\\nmore than one FILE is specified.  A word is a non-zero-length sequence of\\n\\\nprintable characters delimited by white space.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n\n      fputs (_(\"\\\n\\n\\\nThe options below may be used to select which counts are printed, always in\\n\\\nthe following order: newline, word, character, byte, maximum line length.\\n\\\n  -c, --bytes            print the byte counts\\n\\\n  -m, --chars            print the character counts\\n\\\n  -l, --lines            print the newline counts\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --files0-from=F    read input from the files specified by\\n\\\n                           NUL-terminated names in file F;\\n\\\n                           If F is - then read names from standard input\\n\\\n  -L, --max-line-length  print the maximum display width\\n\\\n  -w, --words            print the word counts\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --total=WHEN       when to print a line with total counts;\\n\\\n                           WHEN can be: auto, always, only, never\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Return non zero if a non breaking space.  */\nATTRIBUTE_PURE\nstatic int\niswnbspace (wint_t wc)\n{\n  return ! posixly_correct\n         && (wc == 0x00A0 || wc == 0x2007\n             || wc == 0x202F || wc == 0x2060);\n}\n\nstatic int\nisnbspace (int c)\n{\n  return iswnbspace (btowc (c));\n}\n\n/* FILE is the name of the file (or null for standard input)\n   associated with the specified counters.  */\nstatic void\nwrite_counts (uintmax_t lines,\n              uintmax_t words,\n              uintmax_t chars,\n              uintmax_t bytes,\n              uintmax_t linelength,\n              char const *file)\n{\n  static char const format_sp_int[] = \" %*s\";\n  char const *format_int = format_sp_int + 1;\n  char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n\n  if (print_lines)\n    {\n      printf (format_int, number_width, umaxtostr (lines, buf));\n      format_int = format_sp_int;\n    }\n  if (print_words)\n    {\n      printf (format_int, number_width, umaxtostr (words, buf));\n      format_int = format_sp_int;\n    }\n  if (print_chars)\n    {\n      printf (format_int, number_width, umaxtostr (chars, buf));\n      format_int = format_sp_int;\n    }\n  if (print_bytes)\n    {\n      printf (format_int, number_width, umaxtostr (bytes, buf));\n      format_int = format_sp_int;\n    }\n  if (print_linelength)\n    {\n      printf (format_int, number_width, umaxtostr (linelength, buf));\n    }\n  if (file)\n    printf (\" %s\", strchr (file, '\\n') ? quotef (file) : file);\n  putchar ('\\n');\n}\n\nstatic bool\nwc_lines (char const *file, int fd, uintmax_t *lines_out, uintmax_t *bytes_out)\n{\n  size_t bytes_read;\n  uintmax_t lines, bytes;\n  char buf[BUFFER_SIZE + 1];\n  bool long_lines = false;\n\n  if (!lines_out || !bytes_out)\n    {\n      return false;\n    }\n\n  lines = bytes = 0;\n\n  while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)\n    {\n\n      if (bytes_read == SAFE_READ_ERROR)\n        {\n          error (0, errno, \"%s\", quotef (file));\n          return false;\n        }\n\n      bytes += bytes_read;\n\n      char *p = buf;\n      char *end = buf + bytes_read;\n      uintmax_t plines = lines;\n\n      if (! long_lines)\n        {\n          /* Avoid function call overhead for shorter lines.  */\n          while (p != end)\n            lines += *p++ == '\\n';\n        }\n      else\n        {\n          /* rawmemchr is more efficient with longer lines.  */\n          *end = '\\n';\n          while ((p = rawmemchr (p, '\\n')) < end)\n            {\n              ++p;\n              ++lines;\n            }\n        }\n\n      /* If the average line length in the block is >= 15, then use\n          memchr for the next block, where system specific optimizations\n          may outweigh function call overhead.\n          FIXME: This line length was determined in 2015, on both\n          x86_64 and ppc64, but it's worth re-evaluating in future with\n          newer compilers, CPUs, or memchr() implementations etc.  */\n      if (lines - plines <= bytes_read / 15)\n        long_lines = true;\n      else\n        long_lines = false;\n    }\n\n  *bytes_out = bytes;\n  *lines_out = lines;\n\n  return true;\n}\n\n/* Count words.  FILE_X is the name of the file (or null for standard\n   input) that is open on descriptor FD.  *FSTATUS is its status.\n   CURRENT_POS is the current file offset if known, negative if unknown.\n   Return true if successful.  */\nstatic bool\nwc (int fd, char const *file_x, struct fstatus *fstatus, off_t current_pos)\n{\n  bool ok = true;\n  char buf[BUFFER_SIZE + 1];\n  size_t bytes_read;\n  uintmax_t lines, words, chars, bytes, linelength;\n  bool count_bytes, count_chars, count_complicated;\n  char const *file = file_x ? file_x : _(\"standard input\");\n\n  lines = words = chars = bytes = linelength = 0;\n\n  /* If in the current locale, chars are equivalent to bytes, we prefer\n     counting bytes, because that's easier.  */\n#if MB_LEN_MAX > 1\n  if (MB_CUR_MAX > 1)\n    {\n      count_bytes = print_bytes;\n      count_chars = print_chars;\n    }\n  else\n#endif\n    {\n      count_bytes = print_bytes || print_chars;\n      count_chars = false;\n    }\n  count_complicated = print_words || print_linelength;\n\n  /* Advise the kernel of our access pattern only if we will read().  */\n  if (!count_bytes || count_chars || print_lines || count_complicated)\n    fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);\n\n  /* When counting only bytes, save some line- and word-counting\n     overhead.  If FD is a 'regular' Unix file, using lseek is enough\n     to get its 'size' in bytes.  Otherwise, read blocks of BUFFER_SIZE\n     bytes at a time until EOF.  Note that the 'size' (number of bytes)\n     that wc reports is smaller than stats.st_size when the file is not\n     positioned at its beginning.  That's why the lseek calls below are\n     necessary.  For example the command\n     '(dd ibs=99k skip=1 count=0; ./wc -c) < /etc/group'\n     should make wc report '0' bytes.  */\n\n  if (count_bytes && !count_chars && !print_lines && !count_complicated)\n    {\n      bool skip_read = false;\n\n      if (0 < fstatus->failed)\n        fstatus->failed = fstat (fd, &fstatus->st);\n\n      /* For sized files, seek to one st_blksize before EOF rather than to EOF.\n         This works better for files in proc-like file systems where\n         the size is only approximate.  */\n      if (! fstatus->failed && usable_st_size (&fstatus->st)\n          && 0 <= fstatus->st.st_size)\n        {\n          off_t end_pos = fstatus->st.st_size;\n          if (current_pos < 0)\n            current_pos = lseek (fd, 0, SEEK_CUR);\n\n          if (end_pos % page_size)\n            {\n              /* We only need special handling of /proc and /sys files etc.\n                 when they're a multiple of PAGE_SIZE.  In the common case\n                 for files with st_size not a multiple of PAGE_SIZE,\n                 it's more efficient and accurate to use st_size.\n\n                 Be careful here.  The current position may actually be\n                 beyond the end of the file.  As in the example above.  */\n\n              bytes = end_pos < current_pos ? 0 : end_pos - current_pos;\n              if (bytes && 0 <= lseek (fd, bytes, SEEK_CUR))\n                skip_read = true;\n              else\n                bytes = 0;\n            }\n          else\n            {\n              off_t hi_pos = end_pos - end_pos % (ST_BLKSIZE (fstatus->st) + 1);\n              if (0 <= current_pos && current_pos < hi_pos\n                  && 0 <= lseek (fd, hi_pos, SEEK_CUR))\n                bytes = hi_pos - current_pos;\n            }\n        }\n\n      if (! skip_read)\n        {\n          fdadvise (fd, 0, 0, FADVISE_SEQUENTIAL);\n          while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)\n            {\n              if (bytes_read == SAFE_READ_ERROR)\n                {\n                  error (0, errno, \"%s\", quotef (file));\n                  ok = false;\n                  break;\n                }\n              bytes += bytes_read;\n            }\n        }\n    }\n  else if (!count_chars && !count_complicated)\n    {\n#ifdef USE_AVX2_WC_LINECOUNT\n      static bool (*wc_lines_p) (char const *, int, uintmax_t *, uintmax_t *);\n      if (!wc_lines_p)\n        wc_lines_p = avx2_supported () ? wc_lines_avx2 : wc_lines;\n#else\n      bool (*wc_lines_p) (char const *, int, uintmax_t *, uintmax_t *)\n        = wc_lines;\n#endif\n\n      /* Use a separate loop when counting only lines or lines and bytes --\n         but not chars or words.  */\n      ok = wc_lines_p (file, fd, &lines, &bytes);\n    }\n#if MB_LEN_MAX > 1\n# define SUPPORT_OLD_MBRTOWC 1\n  else if (MB_CUR_MAX > 1)\n    {\n      bool in_word = false;\n      uintmax_t linepos = 0;\n      mbstate_t state = { 0, };\n      bool in_shift = false;\n# if SUPPORT_OLD_MBRTOWC\n      /* Back-up the state before each multibyte character conversion and\n         move the last incomplete character of the buffer to the front\n         of the buffer.  This is needed because we don't know whether\n         the 'mbrtowc' function updates the state when it returns -2, --\n         this is the ISO C 99 and glibc-2.2 behavior - or not - amended\n         ANSI C, glibc-2.1 and Solaris 5.7 behavior.  We don't have an\n         autoconf test for this, yet.  */\n      size_t prev = 0; /* number of bytes carried over from previous round */\n# else\n      const size_t prev = 0;\n# endif\n\n      while ((bytes_read = safe_read (fd, buf + prev, BUFFER_SIZE - prev)) > 0)\n        {\n          char const *p;\n# if SUPPORT_OLD_MBRTOWC\n          mbstate_t backup_state;\n# endif\n          if (bytes_read == SAFE_READ_ERROR)\n            {\n              error (0, errno, \"%s\", quotef (file));\n              ok = false;\n              break;\n            }\n\n          bytes += bytes_read;\n          p = buf;\n          bytes_read += prev;\n          do\n            {\n              wchar_t wide_char;\n              size_t n;\n              bool wide = true;\n\n              if (!in_shift && is_basic (*p))\n                {\n                  /* Handle most ASCII characters quickly, without calling\n                     mbrtowc().  */\n                  n = 1;\n                  wide_char = *p;\n                  wide = false;\n                }\n              else\n                {\n                  in_shift = true;\n# if SUPPORT_OLD_MBRTOWC\n                  backup_state = state;\n# endif\n                  n = mbrtowc (&wide_char, p, bytes_read, &state);\n                  if (n == (size_t) -2)\n                    {\n# if SUPPORT_OLD_MBRTOWC\n                      state = backup_state;\n# endif\n                      break;\n                    }\n                  if (n == (size_t) -1)\n                    {\n                      /* Remember that we read a byte, but don't complain\n                         about the error.  Because of the decoding error,\n                         this is a considered to be byte but not a\n                         character (that is, chars is not incremented).  */\n                      p++;\n                      bytes_read--;\n                      continue;\n                    }\n                  if (mbsinit (&state))\n                    in_shift = false;\n                  if (n == 0)\n                    {\n                      wide_char = 0;\n                      n = 1;\n                    }\n                }\n\n              switch (wide_char)\n                {\n                case '\\n':\n                  lines++;\n                  FALLTHROUGH;\n                case '\\r':\n                case '\\f':\n                  if (linepos > linelength)\n                    linelength = linepos;\n                  linepos = 0;\n                  goto mb_word_separator;\n                case '\\t':\n                  linepos += 8 - (linepos % 8);\n                  goto mb_word_separator;\n                case ' ':\n                  linepos++;\n                  FALLTHROUGH;\n                case '\\v':\n                mb_word_separator:\n                  words += in_word;\n                  in_word = false;\n                  break;\n                default:\n                  if (wide && iswprint (wide_char))\n                    {\n                      /* wcwidth can be expensive on OSX for example,\n                         so avoid if not needed.  */\n                      if (print_linelength)\n                        {\n                          int width = wcwidth (wide_char);\n                          if (width > 0)\n                            linepos += width;\n                        }\n                      if (iswspace (wide_char) || iswnbspace (wide_char))\n                        goto mb_word_separator;\n                      in_word = true;\n                    }\n                  else if (!wide && isprint (to_uchar (*p)))\n                    {\n                      linepos++;\n                      if (isspace (to_uchar (*p)))\n                        goto mb_word_separator;\n                      in_word = true;\n                    }\n                  break;\n                }\n\n              p += n;\n              bytes_read -= n;\n              chars++;\n            }\n          while (bytes_read > 0);\n\n# if SUPPORT_OLD_MBRTOWC\n          if (bytes_read > 0)\n            {\n              if (bytes_read == BUFFER_SIZE)\n                {\n                  /* Encountered a very long redundant shift sequence.  */\n                  p++;\n                  bytes_read--;\n                }\n              memmove (buf, p, bytes_read);\n            }\n          prev = bytes_read;\n# endif\n        }\n      if (linepos > linelength)\n        linelength = linepos;\n      words += in_word;\n    }\n#endif\n  else\n    {\n      bool in_word = false;\n      uintmax_t linepos = 0;\n\n      while ((bytes_read = safe_read (fd, buf, BUFFER_SIZE)) > 0)\n        {\n          char const *p = buf;\n          if (bytes_read == SAFE_READ_ERROR)\n            {\n              error (0, errno, \"%s\", quotef (file));\n              ok = false;\n              break;\n            }\n\n          bytes += bytes_read;\n          do\n            {\n              switch (*p++)\n                {\n                case '\\n':\n                  lines++;\n                  FALLTHROUGH;\n                case '\\r':\n                case '\\f':\n                  if (linepos > linelength)\n                    linelength = linepos;\n                  linepos = 0;\n                  goto word_separator;\n                case '\\t':\n                  linepos += 8 - (linepos % 8);\n                  goto word_separator;\n                case ' ':\n                  linepos++;\n                  FALLTHROUGH;\n                case '\\v':\n                word_separator:\n                  words += in_word;\n                  in_word = false;\n                  break;\n                default:\n                  if (isprint (to_uchar (p[-1])))\n                    {\n                      linepos++;\n                      if (isspace (to_uchar (p[-1]))\n                          || isnbspace (to_uchar (p[-1])))\n                        goto word_separator;\n                      in_word = true;\n                    }\n                  break;\n                }\n            }\n          while (--bytes_read);\n        }\n      if (linepos > linelength)\n        linelength = linepos;\n      words += in_word;\n    }\n\n  if (count_chars < print_chars)\n    chars = bytes;\n\n  if (total_mode != total_only)\n    write_counts (lines, words, chars, bytes, linelength, file_x);\n\n  if (ckd_add (&total_lines, total_lines, lines))\n    total_lines_overflow = true;\n  if (ckd_add (&total_words, total_words, words))\n    total_words_overflow = true;\n  if (ckd_add (&total_chars, total_chars, chars))\n    total_chars_overflow = true;\n  if (ckd_add (&total_bytes, total_bytes, bytes))\n    total_bytes_overflow = true;\n\n  if (linelength > max_line_length)\n    max_line_length = linelength;\n\n  return ok;\n}\n\nstatic bool\nwc_file (char const *file, struct fstatus *fstatus)\n{\n  if (! file || STREQ (file, \"-\"))\n    {\n      have_read_stdin = true;\n      xset_binary_mode (STDIN_FILENO, O_BINARY);\n      return wc (STDIN_FILENO, file, fstatus, -1);\n    }\n  else\n    {\n      int fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n        {\n          error (0, errno, \"%s\", quotef (file));\n          return false;\n        }\n      else\n        {\n          bool ok = wc (fd, file, fstatus, 0);\n          if (close (fd) != 0)\n            {\n              error (0, errno, \"%s\", quotef (file));\n              return false;\n            }\n          return ok;\n        }\n    }\n}\n\n/* Return the file status for the NFILES files addressed by FILE.\n   Optimize the case where only one number is printed, for just one\n   file; in that case we can use a print width of 1, so we don't need\n   to stat the file.  Handle the case of (nfiles == 0) in the same way;\n   that happens when we don't know how long the list of file names will be.  */\n\nstatic struct fstatus *\nget_input_fstatus (size_t nfiles, char *const *file)\n{\n  struct fstatus *fstatus = xnmalloc (nfiles ? nfiles : 1, sizeof *fstatus);\n\n  if (nfiles == 0\n      || (nfiles == 1\n          && ((print_lines + print_words + print_chars\n               + print_bytes + print_linelength)\n              == 1)))\n    fstatus[0].failed = 1;\n  else\n    {\n      for (size_t i = 0; i < nfiles; i++)\n        fstatus[i].failed = (! file[i] || STREQ (file[i], \"-\")\n                             ? fstat (STDIN_FILENO, &fstatus[i].st)\n                             : stat (file[i], &fstatus[i].st));\n    }\n\n  return fstatus;\n}\n\n/* Return a print width suitable for the NFILES files whose status is\n   recorded in FSTATUS.  Optimize the same special case that\n   get_input_fstatus optimizes.  */\n\nATTRIBUTE_PURE\nstatic int\ncompute_number_width (size_t nfiles, struct fstatus const *fstatus)\n{\n  int width = 1;\n\n  if (0 < nfiles && fstatus[0].failed <= 0)\n    {\n      int minimum_width = 1;\n      uintmax_t regular_total = 0;\n\n      for (size_t i = 0; i < nfiles; i++)\n        if (! fstatus[i].failed)\n          {\n            if (S_ISREG (fstatus[i].st.st_mode))\n              regular_total += fstatus[i].st.st_size;\n            else\n              minimum_width = 7;\n          }\n\n      for (; 10 <= regular_total; regular_total /= 10)\n        width++;\n      if (width < minimum_width)\n        width = minimum_width;\n    }\n\n  return width;\n}\n\n\nint\nmain (int argc, char **argv)\n{\n  bool ok;\n  int optc;\n  size_t nfiles;\n  char **files;\n  char *files_from = nullptr;\n  struct fstatus *fstatus;\n  struct Tokens tok;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  page_size = getpagesize ();\n  /* Line buffer stdout to ensure lines are written atomically and immediately\n     so that processes running in parallel do not intersperse their output.  */\n  setvbuf (stdout, nullptr, _IOLBF, 0);\n\n  posixly_correct = (getenv (\"POSIXLY_CORRECT\") != nullptr);\n\n  print_lines = print_words = print_chars = print_bytes = false;\n  print_linelength = false;\n  total_lines = total_words = total_chars = total_bytes = max_line_length = 0;\n\n  while ((optc = getopt_long (argc, argv, \"clLmw\", longopts, nullptr)) != -1)\n    switch (optc)\n      {\n      case 'c':\n        print_bytes = true;\n        break;\n\n      case 'm':\n        print_chars = true;\n        break;\n\n      case 'l':\n        print_lines = true;\n        break;\n\n      case 'w':\n        print_words = true;\n        break;\n\n      case 'L':\n        print_linelength = true;\n        break;\n\n      case DEBUG_PROGRAM_OPTION:\n        debug = true;\n        break;\n\n      case FILES0_FROM_OPTION:\n        files_from = optarg;\n        break;\n\n      case TOTAL_OPTION:\n        total_mode = XARGMATCH (\"--total\", optarg, total_args, total_types);\n        break;\n\n      case_GETOPT_HELP_CHAR;\n\n      case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n      default:\n        usage (EXIT_FAILURE);\n      }\n\n  if (! (print_lines || print_words || print_chars || print_bytes\n         || print_linelength))\n    print_lines = print_words = print_bytes = true;\n\n  bool read_tokens = false;\n  struct argv_iterator *ai;\n  if (files_from)\n    {\n      FILE *stream;\n\n      /* When using --files0-from=F, you may not specify any files\n         on the command-line.  */\n      if (optind < argc)\n        {\n          error (0, 0, _(\"extra operand %s\"), quoteaf (argv[optind]));\n          fprintf (stderr, \"%s\\n\",\n                   _(\"file operands cannot be combined with --files0-from\"));\n          usage (EXIT_FAILURE);\n        }\n\n      if (STREQ (files_from, \"-\"))\n        stream = stdin;\n      else\n        {\n          stream = fopen (files_from, \"r\");\n          if (stream == nullptr)\n            error (EXIT_FAILURE, errno, _(\"cannot open %s for reading\"),\n                   quoteaf (files_from));\n        }\n\n      /* Read the file list into RAM if we can detect its size and that\n         size is reasonable.  Otherwise, we'll read a name at a time.  */\n      struct stat st;\n      if (fstat (fileno (stream), &st) == 0\n          && S_ISREG (st.st_mode)\n          && st.st_size <= MIN (10 * 1024 * 1024, physmem_available () / 2))\n        {\n          read_tokens = true;\n          readtokens0_init (&tok);\n          if (! readtokens0 (stream, &tok) || fclose (stream) != 0)\n            error (EXIT_FAILURE, 0, _(\"cannot read file names from %s\"),\n                   quoteaf (files_from));\n          files = tok.tok;\n          nfiles = tok.n_tok;\n          ai = argv_iter_init_argv (files);\n        }\n      else\n        {\n          files = nullptr;\n          nfiles = 0;\n          ai = argv_iter_init_stream (stream);\n        }\n    }\n  else\n    {\n      static char *stdin_only[] = { nullptr };\n      files = (optind < argc ? argv + optind : stdin_only);\n      nfiles = (optind < argc ? argc - optind : 1);\n      ai = argv_iter_init_argv (files);\n    }\n\n  if (!ai)\n    xalloc_die ();\n\n  fstatus = get_input_fstatus (nfiles, files);\n  if (total_mode == total_only)\n    number_width = 1;  /* No extra padding, since no alignment requirement.  */\n  else\n    number_width = compute_number_width (nfiles, fstatus);\n\n  ok = true;\n  for (int i = 0; /* */; i++)\n    {\n      bool skip_file = false;\n      enum argv_iter_err ai_err;\n      char *file_name = argv_iter (ai, &ai_err);\n      if (!file_name)\n        {\n          switch (ai_err)\n            {\n            case AI_ERR_EOF:\n              goto argv_iter_done;\n            case AI_ERR_READ:\n              error (0, errno, _(\"%s: read error\"),\n                     quotef (files_from));\n              ok = false;\n              goto argv_iter_done;\n            case AI_ERR_MEM:\n              xalloc_die ();\n            default:\n              affirm (!\"unexpected error code from argv_iter\");\n            }\n        }\n      if (files_from && STREQ (files_from, \"-\") && STREQ (file_name, \"-\"))\n        {\n          /* Give a better diagnostic in an unusual case:\n             printf - | wc --files0-from=- */\n          error (0, 0, _(\"when reading file names from stdin, \"\n                         \"no file name of %s allowed\"),\n                 quoteaf (file_name));\n          skip_file = true;\n        }\n\n      if (!file_name[0])\n        {\n          /* Diagnose a zero-length file name.  When it's one\n             among many, knowing the record number may help.\n             FIXME: currently print the record number only with\n             --files0-from=FILE.  Maybe do it for argv, too?  */\n          if (files_from == nullptr)\n            error (0, 0, \"%s\", _(\"invalid zero-length file name\"));\n          else\n            {\n              /* Using the standard 'filename:line-number:' prefix here is\n                 not totally appropriate, since NUL is the separator, not NL,\n                 but it might be better than nothing.  */\n              unsigned long int file_number = argv_iter_n_args (ai);\n              error (0, 0, \"%s:%lu: %s\", quotef (files_from),\n                     file_number, _(\"invalid zero-length file name\"));\n            }\n          skip_file = true;\n        }\n\n      if (skip_file)\n        ok = false;\n      else\n        ok &= wc_file (file_name, &fstatus[nfiles ? i : 0]);\n\n      if (! nfiles)\n        fstatus[0].failed = 1;\n    }\n argv_iter_done:\n\n  /* No arguments on the command line is fine.  That means read from stdin.\n     However, no arguments on the --files0-from input stream is an error\n     means don't read anything.  */\n  if (ok && !files_from && argv_iter_n_args (ai) == 0)\n    ok &= wc_file (nullptr, &fstatus[0]);\n\n  if (read_tokens)\n    readtokens0_free (&tok);\n\n  if (total_mode != total_never\n      && (total_mode != total_auto || 1 < argv_iter_n_args (ai)))\n    {\n      if (total_lines_overflow)\n        {\n          total_lines = UINTMAX_MAX;\n          error (0, EOVERFLOW, _(\"total lines\"));\n          ok = false;\n        }\n      if (total_words_overflow)\n        {\n          total_words = UINTMAX_MAX;\n          error (0, EOVERFLOW, _(\"total words\"));\n          ok = false;\n        }\n      if (total_chars_overflow)\n        {\n          total_chars = UINTMAX_MAX;\n          error (0, EOVERFLOW, _(\"total characters\"));\n          ok = false;\n        }\n      if (total_bytes_overflow)\n        {\n          total_bytes = UINTMAX_MAX;\n          error (0, EOVERFLOW, _(\"total bytes\"));\n          ok = false;\n        }\n\n      write_counts (total_lines, total_words, total_chars, total_bytes,\n                    max_line_length,\n                    total_mode != total_only ? _(\"total\") : nullptr);\n    }\n\n  argv_iter_free (ai);\n\n  free (fstatus);\n\n  if (have_read_stdin && close (STDIN_FILENO) != 0)\n    error (EXIT_FAILURE, errno, \"-\");\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}