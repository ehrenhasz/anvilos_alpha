{
  "module_name": "make-prime-list.c",
  "hash_id": "c35b96b800ca4c3783dbb2ca060691807c8767434aa547edb3aaa45797dfebe8",
  "original_prompt": "Ingested from coreutils-9.4/src/make-prime-list.c",
  "human_readable_source": " \n#undef fclose\n#undef free\n#undef malloc\n#undef strerror\n\n \n#ifndef wide_uint\n# if 4 < __GNUC__ + (6 <= __GNUC_MINOR__) && ULONG_MAX >> 31 >> 31 >> 1 != 0\ntypedef unsigned __int128 wide_uint;\n# else\ntypedef uintmax_t wide_uint;\n# endif\n#endif\n\nstruct prime\n{\n  unsigned p;\n  wide_uint pinv;  \n  wide_uint lim;  \n};\n\nATTRIBUTE_CONST\nstatic wide_uint\nbinvert (wide_uint a)\n{\n  wide_uint x = 0xf5397db1 >> (4 * ((a / 2) & 0x7));\n  for (;;)\n    {\n      wide_uint y = 2 * x - x * x * a;\n      if (y == x)\n        return x;\n      x = y;\n    }\n}\n\nstatic void\nprocess_prime (struct prime *info, unsigned p)\n{\n  wide_uint max = -1;\n  info->p = p;\n  info->pinv = binvert (p);\n  info->lim = max / p;\n}\n\nstatic void\nprint_wide_uint (wide_uint n, int nesting, unsigned wide_uint_bits)\n{\n   \n  int hex_digits_per_literal = 7;\n  int bits_per_literal = hex_digits_per_literal * 4;\n\n  unsigned remainder = n & ((1 << bits_per_literal) - 1);\n\n  if (n != remainder)\n    {\n      int needs_parentheses = n >> bits_per_literal >> bits_per_literal != 0;\n      if (needs_parentheses)\n        printf (\"(\");\n      print_wide_uint (n >> bits_per_literal, nesting + 1, wide_uint_bits);\n      if (needs_parentheses)\n        printf (\")\\n%*s\", nesting + 3, \"\");\n      printf (\" << %d | \", bits_per_literal);\n    }\n  else if (nesting)\n    {\n      printf (\"(uintmax_t) \");\n      hex_digits_per_literal\n        = ((wide_uint_bits - 1) % bits_per_literal) % 4 + 1;\n    }\n\n  printf (\"0x%0*xU\", hex_digits_per_literal, remainder);\n}\n\n \n  unsigned wide_uint_bits = 0;\n  wide_uint mask = -1;\n  for (wide_uint_bits = 0; mask; wide_uint_bits++)\n    mask >>= 1;\n\n  puts (\"/* Generated file -- DO NOT EDIT */\\n\");\n  printf (\"#define WIDE_UINT_BITS %u\\n\", wide_uint_bits);\n\n  for (i = 0, p = 2; i < nprimes; i++)\n    {\n      unsigned int d8 = i + 8 < nprimes ? primes[i + 8].p - primes[i].p : 0xff;\n      if (255 < d8)  \n        abort ();\n      printf (\"P (%u, %u,\\n   (\", primes[i].p - p, d8);\n      print_wide_uint (primes[i].pinv, 0, wide_uint_bits);\n      printf (\"),\\n   UINTMAX_MAX / %u)\\n\", primes[i].p);\n      p = primes[i].p;\n    }\n\n  printf (\"\\n#undef FIRST_OMITTED_PRIME\\n\");\n\n   \n  do\n    {\n      p += 2;\n      for (i = 0, is_prime = 1; is_prime; i++)\n        {\n          if (primes[i].p * primes[i].p > p)\n            break;\n          if (p * primes[i].pinv <= primes[i].lim)\n            {\n              is_prime = 0;\n              break;\n            }\n        }\n    }\n  while (!is_prime);\n\n  printf (\"#define FIRST_OMITTED_PRIME %u\\n\", p);\n}\n\nATTRIBUTE_MALLOC\nstatic void *\nxalloc (size_t s)\n{\n  void *p = malloc (s);\n  if (p)\n    return p;\n\n  fprintf (stderr, \"Virtual memory exhausted.\\n\");\n  exit (EXIT_FAILURE);\n}\n\nint\nmain (int argc, char **argv)\n{\n  int limit;\n\n  char *sieve;\n  size_t size, i;\n\n  struct prime *prime_list;\n  unsigned nprimes;\n\n  if (argc != 2)\n    {\n      fprintf (stderr, \"Usage: %s LIMIT\\n\"\n               \"Produces a list of odd primes <= LIMIT\\n\", argv[0]);\n      return EXIT_FAILURE;\n    }\n  limit = atoi (argv[1]);\n  if (limit < 3)\n    return EXIT_SUCCESS;\n\n   \n  if ( !(limit & 1))\n    limit--;\n\n  size = (limit - 1) / 2;\n   \n  sieve = xalloc (size);\n  memset (sieve, 1, size);\n\n  prime_list = xalloc (size * sizeof (*prime_list));\n  nprimes = 0;\n\n  for (i = 0; i < size;)\n    {\n      unsigned p = 3 + 2 * i;\n      unsigned j;\n\n      process_prime (&prime_list[nprimes++], p);\n\n      for (j = (p * p - 3) / 2; j < size; j += p)\n        sieve[j] = 0;\n\n      while (++i < size && sieve[i] == 0)\n        ;\n    }\n\n  output_primes (prime_list, nprimes);\n\n  free (sieve);\n  free (prime_list);\n\n  if (ferror (stdout) + fclose (stdout))\n    {\n      fprintf (stderr, \"write error: %s\\n\", strerror (errno));\n      return EXIT_FAILURE;\n    }\n\n  return EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}