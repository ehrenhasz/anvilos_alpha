{
  "module_name": "sort.c",
  "hash_id": "de5669a3ea9e919ba7ef24e65e3bfdc3ba5df69dda0425f49bbc176f021aae92",
  "original_prompt": "Ingested from coreutils-9.4/src/sort.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <getopt.h>\n#include <pthread.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"assure.h\"\n#include \"fadvise.h\"\n#include \"filevercmp.h\"\n#include \"flexmember.h\"\n#include \"hard-locale.h\"\n#include \"hash.h\"\n#include \"heap.h\"\n#include \"ignore-value.h\"\n#include \"md5.h\"\n#include \"mbswidth.h\"\n#include \"nproc.h\"\n#include \"physmem.h\"\n#include \"posixver.h\"\n#include \"quote.h\"\n#include \"randread.h\"\n#include \"readtokens0.h\"\n#include \"stdlib--.h\"\n#include \"strnumcmp.h\"\n#include \"xmemcoll.h\"\n#include \"xnanosleep.h\"\n#include \"xstrtol.h\"\n#include \"xstrtol-error.h\"\n\n#ifndef RLIMIT_DATA\nstruct rlimit { size_t rlim_cur; };\n# define getrlimit(Resource, Rlp) (-1)\n#endif\n\n \n#define PROGRAM_NAME \"sort\"\n\n#define AUTHORS \\\n  proper_name (\"Mike Haertel\"), \\\n  proper_name (\"Paul Eggert\")\n\n#if HAVE_LANGINFO_CODESET\n# include <langinfo.h>\n#endif\n\n \n#ifndef SA_NOCLDSTOP\n# define SA_NOCLDSTOP 0\n \n# define sigprocmask(How, Set, Oset) (0)\n# define sigset_t int\n# if ! HAVE_SIGINTERRUPT\n#  define siginterrupt(sig, flag)  \n# endif\n#endif\n\n#if !defined OPEN_MAX && defined NR_OPEN\n# define OPEN_MAX NR_OPEN\n#endif\n#if !defined OPEN_MAX\n# define OPEN_MAX 20\n#endif\n\n#define UCHAR_LIM (UCHAR_MAX + 1)\n\n#ifndef DEFAULT_TMPDIR\n# define DEFAULT_TMPDIR \"/tmp\"\n#endif\n\n \n#define MAX_MERGE(total, level) (((total) >> (2 * ((level) + 1))) + 1)\n\n \nenum { SUBTHREAD_LINES_HEURISTIC = 128 * 1024 };\nstatic_assert (4 <= SUBTHREAD_LINES_HEURISTIC);\n\n \nenum { DEFAULT_MAX_THREADS = 8 };\n\n \nenum\n  {\n     \n    SORT_OUT_OF_ORDER = 1,\n\n     \n    SORT_FAILURE = 2\n  };\n\nenum\n  {\n     \n    MAX_FORK_TRIES_COMPRESS = 4,\n\n     \n    MAX_FORK_TRIES_DECOMPRESS = 9\n  };\n\nenum\n  {\n     \n    MERGE_END = 0,\n\n     \n    MERGE_ROOT = 1\n  };\n\n \nstatic char decimal_point;\n\n \nstatic int thousands_sep;\n \nstatic bool thousands_sep_ignored;\n\n \nstatic bool hard_LC_COLLATE;\n#if HAVE_NL_LANGINFO\nstatic bool hard_LC_TIME;\n#endif\n\n#define NONZERO(x) ((x) != 0)\n\n \nenum blanktype { bl_start, bl_end, bl_both };\n\n \nstatic char eolchar = '\\n';\n\n \nstruct line\n{\n  char *text;\t\t\t \n  size_t length;\t\t \n  char *keybeg;\t\t\t \n  char *keylim;\t\t\t \n};\n\n \nstruct buffer\n{\n  char *buf;\t\t\t \n  size_t used;\t\t\t \n  size_t nlines;\t\t \n  size_t alloc;\t\t\t \n  size_t left;\t\t\t \n  size_t line_bytes;\t\t \n  bool eof;\t\t\t \n};\n\n \nstruct keyfield\n{\n  size_t sword;\t\t\t \n  size_t schar;\t\t\t \n  size_t eword;\t\t\t \n  size_t echar;\t\t\t \n  bool const *ignore;\t\t \n  char const *translate;\t \n  bool skipsblanks;\t\t \n  bool skipeblanks;\t\t \n  bool numeric;\t\t\t \n  bool random;\t\t\t \n  bool general_numeric;\t\t \n  bool human_numeric;\t\t \n  bool month;\t\t\t \n  bool reverse;\t\t\t \n  bool version;\t\t\t \n  bool traditional_used;\t \n  struct keyfield *next;\t \n};\n\nstruct month\n{\n  char const *name;\n  int val;\n};\n\n \nstruct merge_node\n{\n  struct line *lo;               \n  struct line *hi;               \n  struct line *end_lo;           \n  struct line *end_hi;           \n  struct line **dest;            \n  size_t nlo;                    \n  size_t nhi;                    \n  struct merge_node *parent;     \n  struct merge_node *lo_child;   \n  struct merge_node *hi_child;   \n  unsigned int level;            \n  bool queued;                   \n  pthread_mutex_t lock;          \n};\n\n \nstruct merge_node_queue\n{\n  struct heap *priority_queue;   \n  pthread_mutex_t mutex;         \n  pthread_cond_t cond;           \n};\n\n \nstatic struct line saved_line;\n\n \n\n \nstatic bool blanks[UCHAR_LIM];\n\n \nstatic bool nonprinting[UCHAR_LIM];\n\n \nstatic bool nondictionary[UCHAR_LIM];\n\n \nstatic char fold_toupper[UCHAR_LIM];\n\n#define MONTHS_PER_YEAR 12\n\n \nstatic struct month monthtab[] =\n{\n  {\"APR\", 4},\n  {\"AUG\", 8},\n  {\"DEC\", 12},\n  {\"FEB\", 2},\n  {\"JAN\", 1},\n  {\"JUL\", 7},\n  {\"JUN\", 6},\n  {\"MAR\", 3},\n  {\"MAY\", 5},\n  {\"NOV\", 11},\n  {\"OCT\", 10},\n  {\"SEP\", 9}\n};\n\n \n#define NMERGE_DEFAULT 16\n\n \n#define MIN_MERGE_BUFFER_SIZE (2 + sizeof (struct line))\n\n \n#define MIN_SORT_SIZE (nmerge * MIN_MERGE_BUFFER_SIZE)\n\n \nstatic size_t merge_buffer_size = MAX (MIN_MERGE_BUFFER_SIZE, 256 * 1024);\n\n \nstatic size_t sort_size;\n\n \n#define INPUT_FILE_SIZE_GUESS (128 * 1024)\n\n \nstatic char const **temp_dirs;\n\n \nstatic size_t temp_dir_count;\n\n \nstatic size_t temp_dir_alloc;\n\n \nstatic bool reverse;\n\n \nstatic bool stable;\n\n \nenum { NON_CHAR = CHAR_MAX + 1 };\n\n \nenum { TAB_DEFAULT = CHAR_MAX + 1 };\n\n \nstatic int tab = TAB_DEFAULT;\n\n \nstatic bool unique;\n\n \nstatic bool have_read_stdin;\n\n \nstatic struct keyfield *keylist;\n\n \nstatic char const *compress_program;\n\n \nstatic bool debug;\n\n \nstatic unsigned int nmerge = NMERGE_DEFAULT;\n\n \n\nstatic _Noreturn void\nasync_safe_die (int errnum, char const *errstr)\n{\n  ignore_value (write (STDERR_FILENO, errstr, strlen (errstr)));\n\n   \n  if (errnum)\n    {\n      char errbuf[INT_BUFSIZE_BOUND (errnum)];\n      char *p = inttostr (errnum, errbuf);\n      ignore_value (write (STDERR_FILENO, \": errno \", 8));\n      ignore_value (write (STDERR_FILENO, p, strlen (p)));\n    }\n\n  ignore_value (write (STDERR_FILENO, \"\\n\", 1));\n\n  _exit (SORT_FAILURE);\n}\n\n \n\nstatic void\nsort_die (char const *message, char const *file)\n{\n  error (SORT_FAILURE, errno, \"%s: %s\", message,\n         quotef (file ? file : _(\"standard output\")));\n}\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n  or:  %s [OPTION]... --files0-from=F\\n\\\n\"),\n              program_name, program_name);\n      fputs (_(\"\\\nWrite sorted concatenation of all FILE(s) to standard output.\\n\\\n\"), stdout);\n\n      emit_stdin_note ();\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\nOrdering options:\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -b, --ignore-leading-blanks  ignore leading blanks\\n\\\n  -d, --dictionary-order      consider only blanks and alphanumeric characters\\\n\\n\\\n  -f, --ignore-case           fold lower case to upper case characters\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -g, --general-numeric-sort  compare according to general numerical value\\n\\\n  -i, --ignore-nonprinting    consider only printable characters\\n\\\n  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -n, --numeric-sort          compare according to string numerical value\\n\\\n  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\\n\\\n      --random-source=FILE    get random bytes from FILE\\n\\\n  -r, --reverse               reverse the result of comparisons\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --sort=WORD             sort according to WORD:\\n\\\n                                general-numeric -g, human-numeric -h, month -M,\\\n\\n\\\n                                numeric -n, random -R, version -V\\n\\\n  -V, --version-sort          natural sort of (version) numbers within text\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\nOther options:\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --batch-size=NMERGE   merge at most NMERGE inputs at once;\\n\\\n                            for more use temp files\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -c, --check, --check=diagnose-first  check for sorted input; do not sort\\n\\\n  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\\\n\\n\\\n      --compress-program=PROG  compress temporaries with PROG;\\n\\\n                              decompress them with PROG -d\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --debug               annotate the part of the line used to sort,\\n\\\n                              and warn about questionable usage to stderr\\n\\\n      --files0-from=F       read input from the files specified by\\n\\\n                            NUL-terminated names in file F;\\n\\\n                            If F is - then read names from standard input\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\\n\\\n  -m, --merge               merge already sorted files; do not sort\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -o, --output=FILE         write result to FILE instead of standard output\\n\\\n  -s, --stable              stabilize sort by disabling last-resort comparison\\\n\\n\\\n  -S, --buffer-size=SIZE    use SIZE for main memory buffer\\n\\\n\"), stdout);\n      printf (_(\"\\\n  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\\n\\\n  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\\n\\\n                              multiple options specify multiple directories\\n\\\n      --parallel=N          change the number of sorts run concurrently to N\\n\\\n  -u, --unique              with -c, check for strict ordering;\\n\\\n                              without -c, output only the first of an equal run\\\n\\n\\\n\"), DEFAULT_TMPDIR);\n      fputs (_(\"\\\n  -z, --zero-terminated     line delimiter is NUL, not newline\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      fputs (_(\"\\\n\\n\\\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\\n\\\nfield number and C a character position in the field; both are origin 1, and\\n\\\nthe stop position defaults to the line's end.  If neither -t nor -b is in\\n\\\neffect, characters in a field are counted from the beginning of the preceding\\n\\\nwhitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\\\n\\n\\\nwhich override global ordering options for that key.  If no key is given, use\\n\\\nthe entire line as the key.  Use --debug to diagnose incorrect key usage.\\n\\\n\\n\\\nSIZE may be followed by the following multiplicative suffixes:\\n\\\n\"), stdout);\n      fputs (_(\"\\\n% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y, R, Q.\\\n\\n\\n\\\n*** WARNING ***\\n\\\nThe locale specified by the environment affects sort order.\\n\\\nSet LC_ALL=C to get the traditional sort order that uses\\n\\\nnative byte values.\\n\\\n\"), stdout );\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n\n  exit (status);\n}\n\n/* For long options that have no equivalent short option, use a\n   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */\nenum\n{\n  CHECK_OPTION = CHAR_MAX + 1,\n  COMPRESS_PROGRAM_OPTION,\n  DEBUG_PROGRAM_OPTION,\n  FILES0_FROM_OPTION,\n  NMERGE_OPTION,\n  RANDOM_SOURCE_OPTION,\n  SORT_OPTION,\n  PARALLEL_OPTION\n};\n\nstatic char const short_options[] = \"-bcCdfghik:mMno:rRsS:t:T:uVy:z\";\n\nstatic struct option const long_options[] =\n{\n  {\"ignore-leading-blanks\", no_argument, nullptr, 'b'},\n  {\"check\", optional_argument, nullptr, CHECK_OPTION},\n  {\"compress-program\", required_argument, nullptr, COMPRESS_PROGRAM_OPTION},\n  {\"debug\", no_argument, nullptr, DEBUG_PROGRAM_OPTION},\n  {\"dictionary-order\", no_argument, nullptr, 'd'},\n  {\"ignore-case\", no_argument, nullptr, 'f'},\n  {\"files0-from\", required_argument, nullptr, FILES0_FROM_OPTION},\n  {\"general-numeric-sort\", no_argument, nullptr, 'g'},\n  {\"ignore-nonprinting\", no_argument, nullptr, 'i'},\n  {\"key\", required_argument, nullptr, 'k'},\n  {\"merge\", no_argument, nullptr, 'm'},\n  {\"month-sort\", no_argument, nullptr, 'M'},\n  {\"numeric-sort\", no_argument, nullptr, 'n'},\n  {\"human-numeric-sort\", no_argument, nullptr, 'h'},\n  {\"version-sort\", no_argument, nullptr, 'V'},\n  {\"random-sort\", no_argument, nullptr, 'R'},\n  {\"random-source\", required_argument, nullptr, RANDOM_SOURCE_OPTION},\n  {\"sort\", required_argument, nullptr, SORT_OPTION},\n  {\"output\", required_argument, nullptr, 'o'},\n  {\"reverse\", no_argument, nullptr, 'r'},\n  {\"stable\", no_argument, nullptr, 's'},\n  {\"batch-size\", required_argument, nullptr, NMERGE_OPTION},\n  {\"buffer-size\", required_argument, nullptr, 'S'},\n  {\"field-separator\", required_argument, nullptr, 't'},\n  {\"temporary-directory\", required_argument, nullptr, 'T'},\n  {\"unique\", no_argument, nullptr, 'u'},\n  {\"zero-terminated\", no_argument, nullptr, 'z'},\n  {\"parallel\", required_argument, nullptr, PARALLEL_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0},\n};\n\n#define CHECK_TABLE \\\n  _ct_(\"quiet\",          'C') \\\n  _ct_(\"silent\",         'C') \\\n  _ct_(\"diagnose-first\", 'c')\n\nstatic char const *const check_args[] =\n{\n#define _ct_(_s, _c) _s,\n  CHECK_TABLE nullptr\n#undef  _ct_\n};\nstatic char const check_types[] =\n{\n#define _ct_(_s, _c) _c,\n  CHECK_TABLE\n#undef  _ct_\n};\n\n#define SORT_TABLE \\\n  _st_(\"general-numeric\", 'g') \\\n  _st_(\"human-numeric\",   'h') \\\n  _st_(\"month\",           'M') \\\n  _st_(\"numeric\",         'n') \\\n  _st_(\"random\",          'R') \\\n  _st_(\"version\",         'V')\n\nstatic char const *const sort_args[] =\n{\n#define _st_(_s, _c) _s,\n  SORT_TABLE nullptr\n#undef  _st_\n};\nstatic char const sort_types[] =\n{\n#define _st_(_s, _c) _c,\n  SORT_TABLE\n#undef  _st_\n};\n\n \nstatic sigset_t caught_signals;\n\n \nstruct cs_status\n{\n  bool valid;\n  sigset_t sigs;\n};\n\n \nstatic void\ncs_enter (struct cs_status *status)\n{\n  int ret = pthread_sigmask (SIG_BLOCK, &caught_signals, &status->sigs);\n  status->valid = ret == 0;\n}\n\n \nstatic void\ncs_leave (struct cs_status const *status)\n{\n  if (status->valid)\n    {\n       \n      pthread_sigmask (SIG_SETMASK, &status->sigs, nullptr);\n    }\n}\n\n \nenum { UNCOMPRESSED, UNREAPED, REAPED };\n\n \nstruct tempnode\n{\n  struct tempnode *volatile next;\n  pid_t pid;      \n  char state;\n  char name[FLEXIBLE_ARRAY_MEMBER];\n};\nstatic struct tempnode *volatile temphead;\nstatic struct tempnode *volatile *temptail = &temphead;\n\n \nstruct sortfile\n{\n   \n  char const *name;\n\n   \n  struct tempnode *temp;\n};\n\n \nstatic Hash_table *proctab;\n\nenum { INIT_PROCTAB_SIZE = 47 };\n\nstatic size_t\nproctab_hasher (void const *entry, size_t tabsize)\n{\n  struct tempnode const *node = entry;\n  return node->pid % tabsize;\n}\n\nstatic bool\nproctab_comparator (void const *e1, void const *e2)\n{\n  struct tempnode const *n1 = e1;\n  struct tempnode const *n2 = e2;\n  return n1->pid == n2->pid;\n}\n\n \nstatic pid_t nprocs;\n\nstatic bool delete_proc (pid_t);\n\n \n\nstatic pid_t\nreap (pid_t pid)\n{\n  int status;\n  pid_t cpid = waitpid ((pid ? pid : -1), &status, (pid ? 0 : WNOHANG));\n\n  if (cpid < 0)\n    error (SORT_FAILURE, errno, _(\"waiting for %s [-d]\"),\n           quoteaf (compress_program));\n  else if (0 < cpid && (0 < pid || delete_proc (cpid)))\n    {\n      if (! WIFEXITED (status) || WEXITSTATUS (status))\n        error (SORT_FAILURE, 0, _(\"%s [-d] terminated abnormally\"),\n               quoteaf (compress_program));\n      --nprocs;\n    }\n\n  return cpid;\n}\n\n \n\nstatic void\nregister_proc (struct tempnode *temp)\n{\n  if (! proctab)\n    {\n      proctab = hash_initialize (INIT_PROCTAB_SIZE, nullptr,\n                                 proctab_hasher,\n                                 proctab_comparator,\n                                 nullptr);\n      if (! proctab)\n        xalloc_die ();\n    }\n\n  temp->state = UNREAPED;\n\n  if (! hash_insert (proctab, temp))\n    xalloc_die ();\n}\n\n \n\nstatic bool\ndelete_proc (pid_t pid)\n{\n  struct tempnode test;\n\n  test.pid = pid;\n  struct tempnode *node = hash_remove (proctab, &test);\n  if (! node)\n    return false;\n  node->state = REAPED;\n  return true;\n}\n\n \n\nstatic void\nwait_proc (pid_t pid)\n{\n  if (delete_proc (pid))\n    reap (pid);\n}\n\n \n\nstatic void\nreap_exited (void)\n{\n  while (0 < nprocs && reap (0))\n    continue;\n}\n\n \n\nstatic void\nreap_some (void)\n{\n  reap (-1);\n  reap_exited ();\n}\n\n \n\nstatic void\nreap_all (void)\n{\n  while (0 < nprocs)\n    reap (-1);\n}\n\n \n\nstatic void\ncleanup (void)\n{\n  struct tempnode const *node;\n\n  for (node = temphead; node; node = node->next)\n    unlink (node->name);\n  temphead = nullptr;\n}\n\n \n\nstatic void\nexit_cleanup (void)\n{\n  if (temphead)\n    {\n       \n      struct cs_status cs;\n      cs_enter (&cs);\n      cleanup ();\n      cs_leave (&cs);\n    }\n\n  close_stdout ();\n}\n\n \n\nstatic struct tempnode *\ncreate_temp_file (int *pfd, bool survive_fd_exhaustion)\n{\n  static char const slashbase[] = \"/sortXXXXXX\";\n  static size_t temp_dir_index;\n  int fd;\n  int saved_errno;\n  char const *temp_dir = temp_dirs[temp_dir_index];\n  size_t len = strlen (temp_dir);\n  struct tempnode *node =\n    xmalloc (FLEXSIZEOF (struct tempnode, name, len + sizeof slashbase));\n  char *file = node->name;\n  struct cs_status cs;\n\n  memcpy (file, temp_dir, len);\n  memcpy (file + len, slashbase, sizeof slashbase);\n  node->next = nullptr;\n  if (++temp_dir_index == temp_dir_count)\n    temp_dir_index = 0;\n\n   \n  cs_enter (&cs);\n  fd = mkostemp (file, O_CLOEXEC);\n  if (0 <= fd)\n    {\n      *temptail = node;\n      temptail = &node->next;\n    }\n  saved_errno = errno;\n  cs_leave (&cs);\n  errno = saved_errno;\n\n  if (fd < 0)\n    {\n      if (! (survive_fd_exhaustion && errno == EMFILE))\n        error (SORT_FAILURE, errno, _(\"cannot create temporary file in %s\"),\n               quoteaf (temp_dir));\n      free (node);\n      node = nullptr;\n    }\n\n  *pfd = fd;\n  return node;\n}\n\n \n\nstatic struct stat *\nget_outstatus (void)\n{\n  static int outstat_errno;\n  static struct stat outstat;\n  if (outstat_errno == 0)\n    outstat_errno = fstat (STDOUT_FILENO, &outstat) == 0 ? -1 : errno;\n  return outstat_errno < 0 ? &outstat : nullptr;\n}\n\n \n\nstatic FILE *\nstream_open (char const *file, char const *how)\n{\n  FILE *fp;\n\n  if (*how == 'r')\n    {\n      if (STREQ (file, \"-\"))\n        {\n          have_read_stdin = true;\n          fp = stdin;\n        }\n      else\n        {\n          int fd = open (file, O_RDONLY | O_CLOEXEC);\n          fp = fd < 0 ? nullptr : fdopen (fd, how);\n        }\n      fadvise (fp, FADVISE_SEQUENTIAL);\n    }\n  else if (*how == 'w')\n    {\n      if (file && ftruncate (STDOUT_FILENO, 0) != 0)\n        {\n          int ftruncate_errno = errno;\n          struct stat *outst = get_outstatus ();\n          if (!outst || S_ISREG (outst->st_mode) || S_TYPEISSHM (outst))\n            error (SORT_FAILURE, ftruncate_errno, _(\"%s: error truncating\"),\n                   quotef (file));\n        }\n      fp = stdout;\n    }\n  else\n    affirm (!\"unexpected mode passed to stream_open\");\n\n  return fp;\n}\n\n \n\nstatic FILE *\nxfopen (char const *file, char const *how)\n{\n  FILE *fp = stream_open (file, how);\n  if (!fp)\n    sort_die (_(\"open failed\"), file);\n  return fp;\n}\n\n \n\nstatic void\nxfclose (FILE *fp, char const *file)\n{\n  switch (fileno (fp))\n    {\n    case STDIN_FILENO:\n       \n      clearerr (fp);\n      break;\n\n    case STDOUT_FILENO:\n       \n      if (fflush (fp) != 0)\n        sort_die (_(\"fflush failed\"), file);\n      break;\n\n    default:\n      if (fclose (fp) != 0)\n        sort_die (_(\"close failed\"), file);\n      break;\n    }\n}\n\n \n\nstatic void\nmove_fd (int oldfd, int newfd)\n{\n  if (oldfd != newfd)\n    {\n       \n      ignore_value (dup2 (oldfd, newfd));\n      ignore_value (close (oldfd));\n    }\n}\n\n \n\nstatic pid_t\npipe_fork (int pipefds[2], size_t tries)\n{\n#if HAVE_WORKING_FORK\n  struct tempnode *saved_temphead;\n  int saved_errno;\n  double wait_retry = 0.25;\n  pid_t pid;\n  struct cs_status cs;\n\n  if (pipe2 (pipefds, O_CLOEXEC) < 0)\n    return -1;\n\n   \n\n  if (nmerge + 1 < nprocs)\n    reap_some ();\n\n  while (tries--)\n    {\n       \n      cs_enter (&cs);\n      saved_temphead = temphead;\n      temphead = nullptr;\n\n      pid = fork ();\n      saved_errno = errno;\n      if (pid)\n        temphead = saved_temphead;\n\n      cs_leave (&cs);\n      errno = saved_errno;\n\n      if (0 <= pid || errno != EAGAIN)\n        break;\n      else\n        {\n          xnanosleep (wait_retry);\n          wait_retry *= 2;\n          reap_exited ();\n        }\n    }\n\n  if (pid < 0)\n    {\n      saved_errno = errno;\n      close (pipefds[0]);\n      close (pipefds[1]);\n      errno = saved_errno;\n    }\n  else if (pid == 0)\n    {\n      close (STDIN_FILENO);\n      close (STDOUT_FILENO);\n    }\n  else\n    ++nprocs;\n\n  return pid;\n\n#else   \n  return -1;\n#endif\n}\n\n \n\nstatic struct tempnode *\nmaybe_create_temp (FILE **pfp, bool survive_fd_exhaustion)\n{\n  int tempfd;\n  struct tempnode *node = create_temp_file (&tempfd, survive_fd_exhaustion);\n  if (! node)\n    return nullptr;\n\n  node->state = UNCOMPRESSED;\n\n  if (compress_program)\n    {\n      int pipefds[2];\n\n      node->pid = pipe_fork (pipefds, MAX_FORK_TRIES_COMPRESS);\n      if (0 < node->pid)\n        {\n          close (tempfd);\n          close (pipefds[0]);\n          tempfd = pipefds[1];\n\n          register_proc (node);\n        }\n      else if (node->pid == 0)\n        {\n           \n          close (pipefds[1]);\n          move_fd (tempfd, STDOUT_FILENO);\n          move_fd (pipefds[0], STDIN_FILENO);\n\n          execlp (compress_program, compress_program, (char *) nullptr);\n\n          async_safe_die (errno, \"couldn't execute compress program\");\n        }\n    }\n\n  *pfp = fdopen (tempfd, \"w\");\n  if (! *pfp)\n    sort_die (_(\"couldn't create temporary file\"), node->name);\n\n  return node;\n}\n\n \n\nstatic struct tempnode *\ncreate_temp (FILE **pfp)\n{\n  return maybe_create_temp (pfp, false);\n}\n\n \n\nstatic FILE *\nopen_temp (struct tempnode *temp)\n{\n  int tempfd, pipefds[2];\n  FILE *fp = nullptr;\n\n  if (temp->state == UNREAPED)\n    wait_proc (temp->pid);\n\n  tempfd = open (temp->name, O_RDONLY);\n  if (tempfd < 0)\n    return nullptr;\n\n  pid_t child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);\n\n  switch (child)\n    {\n    case -1:\n      if (errno != EMFILE)\n        error (SORT_FAILURE, errno, _(\"couldn't create process for %s -d\"),\n               quoteaf (compress_program));\n      close (tempfd);\n      errno = EMFILE;\n      break;\n\n    case 0:\n       \n      close (pipefds[0]);\n      move_fd (tempfd, STDIN_FILENO);\n      move_fd (pipefds[1], STDOUT_FILENO);\n\n      execlp (compress_program, compress_program, \"-d\", (char *) nullptr);\n\n      async_safe_die (errno, \"couldn't execute compress program (with -d)\");\n\n    default:\n      temp->pid = child;\n      register_proc (temp);\n      close (tempfd);\n      close (pipefds[1]);\n\n      fp = fdopen (pipefds[0], \"r\");\n      if (! fp)\n        {\n          int saved_errno = errno;\n          close (pipefds[0]);\n          errno = saved_errno;\n        }\n      break;\n    }\n\n  return fp;\n}\n\n \nstatic void\nadd_temp_dir (char const *dir)\n{\n  if (temp_dir_count == temp_dir_alloc)\n    temp_dirs = X2NREALLOC (temp_dirs, &temp_dir_alloc);\n\n  temp_dirs[temp_dir_count++] = dir;\n}\n\n \n\nstatic void\nzaptemp (char const *name)\n{\n  struct tempnode *volatile *pnode;\n  struct tempnode *node;\n  struct tempnode *next;\n  int unlink_status;\n  int unlink_errno = 0;\n  struct cs_status cs;\n\n  for (pnode = &temphead; (node = *pnode)->name != name; pnode = &node->next)\n    continue;\n\n  if (node->state == UNREAPED)\n    wait_proc (node->pid);\n\n   \n  next = node->next;\n  cs_enter (&cs);\n  unlink_status = unlink (name);\n  unlink_errno = errno;\n  *pnode = next;\n  cs_leave (&cs);\n\n  if (unlink_status != 0)\n    error (0, unlink_errno, _(\"warning: cannot remove: %s\"), quotef (name));\n  if (! next)\n    temptail = pnode;\n  free (node);\n}\n\n#if HAVE_NL_LANGINFO\n\nstatic int\nstruct_month_cmp (void const *m1, void const *m2)\n{\n  struct month const *month1 = m1;\n  struct month const *month2 = m2;\n  return strcmp (month1->name, month2->name);\n}\n\n#endif\n\n \n\nstatic void\ninittables (void)\n{\n  size_t i;\n\n  for (i = 0; i < UCHAR_LIM; ++i)\n    {\n      blanks[i] = field_sep (i);\n      nonprinting[i] = ! isprint (i);\n      nondictionary[i] = ! isalnum (i) && ! field_sep (i);\n      fold_toupper[i] = toupper (i);\n    }\n\n#if HAVE_NL_LANGINFO\n   \n  if (hard_LC_TIME)\n    {\n      for (i = 0; i < MONTHS_PER_YEAR; i++)\n        {\n          char const *s;\n          size_t s_len;\n          size_t j, k;\n          char *name;\n\n          s = nl_langinfo (ABMON_1 + i);\n          s_len = strlen (s);\n          monthtab[i].name = name = xmalloc (s_len + 1);\n          monthtab[i].val = i + 1;\n\n          for (j = k = 0; j < s_len; j++)\n            if (! isblank (to_uchar (s[j])))\n              name[k++] = fold_toupper[to_uchar (s[j])];\n          name[k] = '\\0';\n        }\n      qsort (monthtab, MONTHS_PER_YEAR, sizeof *monthtab, struct_month_cmp);\n    }\n#endif\n}\n\n \nstatic void\nspecify_nmerge (int oi, char c, char const *s)\n{\n  uintmax_t n;\n  struct rlimit rlimit;\n  enum strtol_error e = xstrtoumax (s, nullptr, 10, &n, \"\");\n\n   \n  unsigned int max_nmerge = ((getrlimit (RLIMIT_NOFILE, &rlimit) == 0\n                              ? rlimit.rlim_cur\n                              : OPEN_MAX)\n                             - 3);\n\n  if (e == LONGINT_OK)\n    {\n      nmerge = n;\n      if (nmerge != n)\n        e = LONGINT_OVERFLOW;\n      else\n        {\n          if (nmerge < 2)\n            {\n              error (0, 0, _(\"invalid --%s argument %s\"),\n                     long_options[oi].name, quote (s));\n              error (SORT_FAILURE, 0,\n                     _(\"minimum --%s argument is %s\"),\n                     long_options[oi].name, quote (\"2\"));\n            }\n          else if (max_nmerge < nmerge)\n            {\n              e = LONGINT_OVERFLOW;\n            }\n          else\n            return;\n        }\n    }\n\n  if (e == LONGINT_OVERFLOW)\n    {\n      char max_nmerge_buf[INT_BUFSIZE_BOUND (max_nmerge)];\n      error (0, 0, _(\"--%s argument %s too large\"),\n             long_options[oi].name, quote (s));\n      error (SORT_FAILURE, 0,\n             _(\"maximum --%s argument with current rlimit is %s\"),\n             long_options[oi].name,\n             uinttostr (max_nmerge, max_nmerge_buf));\n    }\n  else\n    xstrtol_fatal (e, oi, c, long_options, s);\n}\n\n \nstatic void\nspecify_sort_size (int oi, char c, char const *s)\n{\n  uintmax_t n;\n  char *suffix;\n  enum strtol_error e = xstrtoumax (s, &suffix, 10, &n, \"EgGkKmMPQRtTYZ\");\n\n   \n  if (e == LONGINT_OK && ISDIGIT (suffix[-1]))\n    {\n      if (n <= UINTMAX_MAX / 1024)\n        n *= 1024;\n      else\n        e = LONGINT_OVERFLOW;\n    }\n\n   \n  if (e == LONGINT_INVALID_SUFFIX_CHAR && ISDIGIT (suffix[-1]) && ! suffix[1])\n    switch (suffix[0])\n      {\n      case 'b':\n        e = LONGINT_OK;\n        break;\n\n      case '%':\n        {\n          double mem = physmem_total () * n / 100;\n\n           \n          if (mem < UINTMAX_MAX)\n            {\n              n = mem;\n              e = LONGINT_OK;\n            }\n          else\n            e = LONGINT_OVERFLOW;\n        }\n        break;\n      }\n\n  if (e == LONGINT_OK)\n    {\n       \n      if (n < sort_size)\n        return;\n\n      sort_size = n;\n      if (sort_size == n)\n        {\n          sort_size = MAX (sort_size, MIN_SORT_SIZE);\n          return;\n        }\n\n      e = LONGINT_OVERFLOW;\n    }\n\n  xstrtol_fatal (e, oi, c, long_options, s);\n}\n\n \nstatic size_t\nspecify_nthreads (int oi, char c, char const *s)\n{\n  uintmax_t nthreads;\n  enum strtol_error e = xstrtoumax (s, nullptr, 10, &nthreads, \"\");\n  if (e == LONGINT_OVERFLOW)\n    return SIZE_MAX;\n  if (e != LONGINT_OK)\n    xstrtol_fatal (e, oi, c, long_options, s);\n  if (SIZE_MAX < nthreads)\n    nthreads = SIZE_MAX;\n  if (nthreads == 0)\n    error (SORT_FAILURE, 0, _(\"number in parallel must be nonzero\"));\n  return nthreads;\n}\n\n \nstatic size_t\ndefault_sort_size (void)\n{\n   \n  size_t size = SIZE_MAX;\n  struct rlimit rlimit;\n  if (getrlimit (RLIMIT_DATA, &rlimit) == 0 && rlimit.rlim_cur < size)\n    size = rlimit.rlim_cur;\n#ifdef RLIMIT_AS\n  if (getrlimit (RLIMIT_AS, &rlimit) == 0 && rlimit.rlim_cur < size)\n    size = rlimit.rlim_cur;\n#endif\n\n   \n  size /= 2;\n\n#ifdef RLIMIT_RSS\n   \n  if (getrlimit (RLIMIT_RSS, &rlimit) == 0 && rlimit.rlim_cur / 16 * 15 < size)\n    size = rlimit.rlim_cur / 16 * 15;\n#endif\n\n   \n  double avail = physmem_available ();\n  double total = physmem_total ();\n  double mem = MAX (avail, total / 8);\n\n   \n  if (total * 0.75 < size)\n    size = total * 0.75;\n\n   \n  if (mem < size)\n    size = mem;\n  return MAX (size, MIN_SORT_SIZE);\n}\n\n \n\nstatic size_t\nsort_buffer_size (FILE *const *fps, size_t nfps,\n                  char *const *files, size_t nfiles,\n                  size_t line_bytes)\n{\n   \n  static size_t size_bound;\n\n   \n  size_t worst_case_per_input_byte = line_bytes + 1;\n\n   \n  size_t size = worst_case_per_input_byte + 1;\n\n  for (size_t i = 0; i < nfiles; i++)\n    {\n      struct stat st;\n      off_t file_size;\n      size_t worst_case;\n\n      if ((i < nfps ? fstat (fileno (fps[i]), &st)\n           : STREQ (files[i], \"-\") ? fstat (STDIN_FILENO, &st)\n           : stat (files[i], &st))\n          != 0)\n        sort_die (_(\"stat failed\"), files[i]);\n\n      if (S_ISREG (st.st_mode))\n        file_size = st.st_size;\n      else\n        {\n           \n          if (sort_size)\n            return sort_size;\n          file_size = INPUT_FILE_SIZE_GUESS;\n        }\n\n      if (! size_bound)\n        {\n          size_bound = sort_size;\n          if (! size_bound)\n            size_bound = default_sort_size ();\n        }\n\n       \n      worst_case = file_size * worst_case_per_input_byte + 1;\n      if (file_size != worst_case / worst_case_per_input_byte\n          || size_bound - size <= worst_case)\n        return size_bound;\n      size += worst_case;\n    }\n\n  return size;\n}\n\n \n\nstatic void\ninitbuf (struct buffer *buf, size_t line_bytes, size_t alloc)\n{\n   \n  while (true)\n    {\n      alloc += sizeof (struct line) - alloc % sizeof (struct line);\n      buf->buf = malloc (alloc);\n      if (buf->buf)\n        break;\n      alloc /= 2;\n      if (alloc <= line_bytes + 1)\n        xalloc_die ();\n    }\n\n  buf->line_bytes = line_bytes;\n  buf->alloc = alloc;\n  buf->used = buf->left = buf->nlines = 0;\n  buf->eof = false;\n}\n\n \n\nstatic inline struct line *\nbuffer_linelim (struct buffer const *buf)\n{\n  void *linelim = buf->buf + buf->alloc;\n  return linelim;\n}\n\n \n\nstatic char *\nbegfield (struct line const *line, struct keyfield const *key)\n{\n  char *ptr = line->text, *lim = ptr + line->length - 1;\n  size_t sword = key->sword;\n  size_t schar = key->schar;\n\n   \n\n  if (tab != TAB_DEFAULT)\n    while (ptr < lim && sword--)\n      {\n        while (ptr < lim && *ptr != tab)\n          ++ptr;\n        if (ptr < lim)\n          ++ptr;\n      }\n  else\n    while (ptr < lim && sword--)\n      {\n        while (ptr < lim && blanks[to_uchar (*ptr)])\n          ++ptr;\n        while (ptr < lim && !blanks[to_uchar (*ptr)])\n          ++ptr;\n      }\n\n   \n  if (key->skipsblanks)\n    while (ptr < lim && blanks[to_uchar (*ptr)])\n      ++ptr;\n\n   \n  ptr = MIN (lim, ptr + schar);\n\n  return ptr;\n}\n\n \n\nATTRIBUTE_PURE\nstatic char *\nlimfield (struct line const *line, struct keyfield const *key)\n{\n  char *ptr = line->text, *lim = ptr + line->length - 1;\n  size_t eword = key->eword, echar = key->echar;\n\n  if (echar == 0)\n    eword++;  \n\n   \n  if (tab != TAB_DEFAULT)\n    while (ptr < lim && eword--)\n      {\n        while (ptr < lim && *ptr != tab)\n          ++ptr;\n        if (ptr < lim && (eword || echar))\n          ++ptr;\n      }\n  else\n    while (ptr < lim && eword--)\n      {\n        while (ptr < lim && blanks[to_uchar (*ptr)])\n          ++ptr;\n        while (ptr < lim && !blanks[to_uchar (*ptr)])\n          ++ptr;\n      }\n\n#ifdef POSIX_UNSPECIFIED\n   \n\n   \n  if (tab != TAB_DEFAULT)\n    {\n      char *newlim;\n      newlim = memchr (ptr, tab, lim - ptr);\n      if (newlim)\n        lim = newlim;\n    }\n  else\n    {\n      char *newlim;\n      newlim = ptr;\n      while (newlim < lim && blanks[to_uchar (*newlim)])\n        ++newlim;\n      while (newlim < lim && !blanks[to_uchar (*newlim)])\n        ++newlim;\n      lim = newlim;\n    }\n#endif\n\n  if (echar != 0)  \n    {\n       \n      if (key->skipeblanks)\n        while (ptr < lim && blanks[to_uchar (*ptr)])\n          ++ptr;\n\n       \n      ptr = MIN (lim, ptr + echar);\n    }\n\n  return ptr;\n}\n\n \n\nstatic bool\nfillbuf (struct buffer *buf, FILE *fp, char const *file)\n{\n  struct keyfield const *key = keylist;\n  char eol = eolchar;\n  size_t line_bytes = buf->line_bytes;\n  size_t mergesize = merge_buffer_size - MIN_MERGE_BUFFER_SIZE;\n\n  if (buf->eof)\n    return false;\n\n  if (buf->used != buf->left)\n    {\n      memmove (buf->buf, buf->buf + buf->used - buf->left, buf->left);\n      buf->used = buf->left;\n      buf->nlines = 0;\n    }\n\n  while (true)\n    {\n      char *ptr = buf->buf + buf->used;\n      struct line *linelim = buffer_linelim (buf);\n      struct line *line = linelim - buf->nlines;\n      size_t avail = (char *) linelim - buf->nlines * line_bytes - ptr;\n      char *line_start = buf->nlines ? line->text + line->length : buf->buf;\n\n      while (line_bytes + 1 < avail)\n        {\n           \n          size_t readsize = (avail - 1) / (line_bytes + 1);\n          size_t bytes_read = fread (ptr, 1, readsize, fp);\n          char *ptrlim = ptr + bytes_read;\n          char *p;\n          avail -= bytes_read;\n\n          if (bytes_read != readsize)\n            {\n              if (ferror (fp))\n                sort_die (_(\"read failed\"), file);\n              if (feof (fp))\n                {\n                  buf->eof = true;\n                  if (buf->buf == ptrlim)\n                    return false;\n                  if (line_start != ptrlim && ptrlim[-1] != eol)\n                    *ptrlim++ = eol;\n                }\n            }\n\n           \n          while ((p = memchr (ptr, eol, ptrlim - ptr)))\n            {\n               \n              *p = '\\0';\n              ptr = p + 1;\n              line--;\n              line->text = line_start;\n              line->length = ptr - line_start;\n              mergesize = MAX (mergesize, line->length);\n              avail -= line_bytes;\n\n              if (key)\n                {\n                   \n                  line->keylim = (key->eword == SIZE_MAX\n                                  ? p\n                                  : limfield (line, key));\n\n                  if (key->sword != SIZE_MAX)\n                    line->keybeg = begfield (line, key);\n                  else\n                    {\n                      if (key->skipsblanks)\n                        while (blanks[to_uchar (*line_start)])\n                          line_start++;\n                      line->keybeg = line_start;\n                    }\n                }\n\n              line_start = ptr;\n            }\n\n          ptr = ptrlim;\n          if (buf->eof)\n            break;\n        }\n\n      buf->used = ptr - buf->buf;\n      buf->nlines = buffer_linelim (buf) - line;\n      if (buf->nlines != 0)\n        {\n          buf->left = ptr - line_start;\n          merge_buffer_size = mergesize + MIN_MERGE_BUFFER_SIZE;\n          return true;\n        }\n\n      {\n         \n        size_t line_alloc = buf->alloc / sizeof (struct line);\n        buf->buf = x2nrealloc (buf->buf, &line_alloc, sizeof (struct line));\n        buf->alloc = line_alloc * sizeof (struct line);\n      }\n    }\n}\n\n \nstatic char const unit_order[UCHAR_LIM] =\n  {\n#if ! ('K' == 75 && 'M' == 77 && 'G' == 71 && 'T' == 84 && 'P' == 80 \\\n       && 'E' == 69 && 'Z' == 90 && 'Y' == 89 && 'R' == 82 && 'Q' == 81 \\\n       && 'k' == 107)\n     \n    ['K']=1, ['M']=2, ['G']=3, ['T']=4, ['P']=5, ['E']=6, ['Z']=7, ['Y']=8,\n    ['R']=9, ['Q']=10,\n    ['k']=1,\n#else\n     \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3,\n    0, 0, 0, 1, 0, 2, 0, 0, 5, 10, 9, 0, 4, 0, 0, 0, 0, 8, 7, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n#endif\n  };\n\n \nstatic char\ntraverse_raw_number (char const **number)\n{\n  char const *p = *number;\n  char ch;\n  char max_digit = '\\0';\n  bool ends_with_thousands_sep = false;\n\n   \n\n  while (ISDIGIT (ch = *p++))\n    {\n      if (max_digit < ch)\n        max_digit = ch;\n\n       \n      ends_with_thousands_sep = (*p == thousands_sep);\n      if (ends_with_thousands_sep)\n        ++p;\n    }\n\n  if (ends_with_thousands_sep)\n    {\n       \n      *number = p - 2;\n      return max_digit;\n    }\n\n  if (ch == decimal_point)\n    while (ISDIGIT (ch = *p++))\n      if (max_digit < ch)\n        max_digit = ch;\n\n  *number = p - 1;\n  return max_digit;\n}\n\n \n\nATTRIBUTE_PURE\nstatic int\nfind_unit_order (char const *number)\n{\n  bool minus_sign = (*number == '-');\n  char const *p = number + minus_sign;\n  char max_digit = traverse_raw_number (&p);\n  if ('0' < max_digit)\n    {\n      unsigned char ch = *p;\n      int order = unit_order[ch];\n      return (minus_sign ? -order : order);\n    }\n  else\n    return 0;\n}\n\n \n\nATTRIBUTE_PURE\nstatic int\nhuman_numcompare (char const *a, char const *b)\n{\n  while (blanks[to_uchar (*a)])\n    a++;\n  while (blanks[to_uchar (*b)])\n    b++;\n\n  int diff = find_unit_order (a) - find_unit_order (b);\n  return (diff ? diff : strnumcmp (a, b, decimal_point, thousands_sep));\n}\n\n \n\nATTRIBUTE_PURE\nstatic int\nnumcompare (char const *a, char const *b)\n{\n  while (blanks[to_uchar (*a)])\n    a++;\n  while (blanks[to_uchar (*b)])\n    b++;\n\n  return strnumcmp (a, b, decimal_point, thousands_sep);\n}\n\nstatic int\nnan_compare (long double a, long double b)\n{\n  char buf[2][sizeof \"-nan\"\"()\" + CHAR_BIT * sizeof a];\n  snprintf (buf[0], sizeof buf[0], \"%Lf\", a);\n  snprintf (buf[1], sizeof buf[1], \"%Lf\", b);\n  return strcmp (buf[0], buf[1]);\n}\n\nstatic int\ngeneral_numcompare (char const *sa, char const *sb)\n{\n   \n\n  char *ea;\n  char *eb;\n  long double a = strtold (sa, &ea);\n  long double b = strtold (sb, &eb);\n\n   \n  if (sa == ea)\n    return sb == eb ? 0 : -1;\n  if (sb == eb)\n    return 1;\n\n   \n  return (a < b ? -1\n          : a > b ? 1\n          : a == b ? 0\n          : b == b ? -1\n          : a == a ? 1\n          : nan_compare (a, b));\n}\n\n \n\nstatic int\ngetmonth (char const *month, char **ea)\n{\n  size_t lo = 0;\n  size_t hi = MONTHS_PER_YEAR;\n\n  while (blanks[to_uchar (*month)])\n    month++;\n\n  do\n    {\n      size_t ix = (lo + hi) / 2;\n      char const *m = month;\n      char const *n = monthtab[ix].name;\n\n      for (;; m++, n++)\n        {\n          if (!*n)\n            {\n              if (ea)\n                *ea = (char *) m;\n              return monthtab[ix].val;\n            }\n          if (to_uchar (fold_toupper[to_uchar (*m)]) < to_uchar (*n))\n            {\n              hi = ix;\n              break;\n            }\n          else if (to_uchar (fold_toupper[to_uchar (*m)]) > to_uchar (*n))\n            {\n              lo = ix + 1;\n              break;\n            }\n        }\n    }\n  while (lo < hi);\n\n  return 0;\n}\n\n \nstatic struct md5_ctx random_md5_state;\n\n \n\nstatic void\nrandom_md5_state_init (char const *random_source)\n{\n  unsigned char buf[MD5_DIGEST_SIZE];\n  struct randread_source *r = randread_new (random_source, sizeof buf);\n  if (! r)\n    sort_die (_(\"open failed\"), random_source ? random_source : \"getrandom\");\n  randread (r, buf, sizeof buf);\n  if (randread_free (r) != 0)\n    sort_die (_(\"close failed\"), random_source);\n  md5_init_ctx (&random_md5_state);\n  md5_process_bytes (buf, sizeof buf, &random_md5_state);\n}\n\n \n\nstatic size_t\nxstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)\n{\n  errno = 0;\n  size_t translated_size = strxfrm (dest, src, destsize);\n\n  if (errno)\n    {\n      error (0, errno, _(\"string transformation failed\"));\n      error (0, 0, _(\"set LC_ALL='C' to work around the problem\"));\n      error (SORT_FAILURE, 0,\n             _(\"the original string was %s\"),\n             quotearg_n_style (0, locale_quoting_style, src));\n    }\n\n  return translated_size;\n}\n\n \n\nstatic int\ncompare_random (char *restrict texta, size_t lena,\n                char *restrict textb, size_t lenb)\n{\n   \n  int xfrm_diff = 0;\n\n  char stackbuf[4000];\n  char *buf = stackbuf;\n  size_t bufsize = sizeof stackbuf;\n  void *allocated = nullptr;\n  uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];\n  struct md5_ctx s[2];\n  s[0] = s[1] = random_md5_state;\n\n  if (hard_LC_COLLATE)\n    {\n      char const *lima = texta + lena;\n      char const *limb = textb + lenb;\n\n      while (true)\n        {\n           \n\n           \n\n           \n          size_t guess_bufsize = 3 * (lena + lenb) + 2;\n          if (bufsize < guess_bufsize)\n            {\n              bufsize = MAX (guess_bufsize, bufsize * 3 / 2);\n              free (allocated);\n              buf = allocated = malloc (bufsize);\n              if (! buf)\n                {\n                  buf = stackbuf;\n                  bufsize = sizeof stackbuf;\n                }\n            }\n\n          size_t sizea =\n            (texta < lima ? xstrxfrm (buf, texta, bufsize) + 1 : 0);\n          bool a_fits = sizea <= bufsize;\n          size_t sizeb =\n            (textb < limb\n             ? (xstrxfrm ((a_fits ? buf + sizea : nullptr), textb,\n                          (a_fits ? bufsize - sizea : 0))\n                + 1)\n             : 0);\n\n          if (! (a_fits && sizea + sizeb <= bufsize))\n            {\n              bufsize = sizea + sizeb;\n              if (bufsize < SIZE_MAX / 3)\n                bufsize = bufsize * 3 / 2;\n              free (allocated);\n              buf = allocated = xmalloc (bufsize);\n              if (texta < lima)\n                strxfrm (buf, texta, sizea);\n              if (textb < limb)\n                strxfrm (buf + sizea, textb, sizeb);\n            }\n\n           \n          if (texta < lima)\n            texta += strlen (texta) + 1;\n          if (textb < limb)\n            textb += strlen (textb) + 1;\n          if (! (texta < lima || textb < limb))\n            {\n              lena = sizea; texta = buf;\n              lenb = sizeb; textb = buf + sizea;\n              break;\n            }\n\n           \n          md5_process_bytes (buf, sizea, &s[0]);\n          md5_process_bytes (buf + sizea, sizeb, &s[1]);\n\n           \n          if (! xfrm_diff)\n            {\n              xfrm_diff = memcmp (buf, buf + sizea, MIN (sizea, sizeb));\n              if (! xfrm_diff)\n                xfrm_diff = (sizea > sizeb) - (sizea < sizeb);\n            }\n        }\n    }\n\n   \n  md5_process_bytes (texta, lena, &s[0]); md5_finish_ctx (&s[0], dig[0]);\n  md5_process_bytes (textb, lenb, &s[1]); md5_finish_ctx (&s[1], dig[1]);\n  int diff = memcmp (dig[0], dig[1], sizeof dig[0]);\n\n   \n  if (! diff)\n    {\n      if (! xfrm_diff)\n        {\n          xfrm_diff = memcmp (texta, textb, MIN (lena, lenb));\n          if (! xfrm_diff)\n            xfrm_diff = (lena > lenb) - (lena < lenb);\n        }\n\n      diff = xfrm_diff;\n    }\n\n  free (allocated);\n\n  return diff;\n}\n\n \n\nstatic size_t\ndebug_width (char const *text, char const *lim)\n{\n  size_t width = mbsnwidth (text, lim - text, 0);\n  while (text < lim)\n    width += (*text++ == '\\t');\n  return width;\n}\n\n \n\nstatic void\nmark_key (size_t offset, size_t width)\n{\n  while (offset--)\n    putchar (' ');\n\n  if (!width)\n    printf (_(\"^ no match for key\\n\"));\n  else\n    {\n      do\n        putchar ('_');\n      while (--width);\n\n      putchar ('\\n');\n    }\n}\n\n \n\nstatic inline bool\nkey_numeric (struct keyfield const *key)\n{\n  return key->numeric || key->general_numeric || key->human_numeric;\n}\n\n \n\nstatic void\ndebug_key (struct line const *line, struct keyfield const *key)\n{\n  char *text = line->text;\n  char *beg = text;\n  char *lim = text + line->length - 1;\n\n  if (key)\n    {\n      if (key->sword != SIZE_MAX)\n        beg = begfield (line, key);\n      if (key->eword != SIZE_MAX)\n        lim = limfield (line, key);\n\n      if ((key->skipsblanks && key->sword == SIZE_MAX)\n          || key->month || key_numeric (key))\n        {\n          char saved = *lim;\n          *lim = '\\0';\n\n          while (blanks[to_uchar (*beg)])\n            beg++;\n\n          char *tighter_lim = beg;\n\n          if (lim < beg)\n            tighter_lim = lim;\n          else if (key->month)\n            getmonth (beg, &tighter_lim);\n          else if (key->general_numeric)\n            ignore_value (strtold (beg, &tighter_lim));\n          else if (key->numeric || key->human_numeric)\n            {\n              char const *p = beg + (beg < lim && *beg == '-');\n              char max_digit = traverse_raw_number (&p);\n              if ('0' <= max_digit)\n                {\n                  unsigned char ch = *p;\n                  tighter_lim = (char *) p\n                    + (key->human_numeric && unit_order[ch]);\n                }\n            }\n          else\n            tighter_lim = lim;\n\n          *lim = saved;\n          lim = tighter_lim;\n        }\n    }\n\n  size_t offset = debug_width (text, beg);\n  size_t width = debug_width (beg, lim);\n  mark_key (offset, width);\n}\n\n \n\nstatic void\ndebug_line (struct line const *line)\n{\n  struct keyfield const *key = keylist;\n\n  do\n    debug_key (line, key);\n  while (key && ((key = key->next) || ! (unique || stable)));\n}\n\n \n\nstatic bool\ndefault_key_compare (struct keyfield const *key)\n{\n  return ! (key->ignore\n            || key->translate\n            || key->skipsblanks\n            || key->skipeblanks\n            || key_numeric (key)\n            || key->month\n            || key->version\n            || key->random\n             \n           );\n}\n\n \n\nstatic void\nkey_to_opts (struct keyfield const *key, char *opts)\n{\n  if (key->skipsblanks || key->skipeblanks)\n    *opts++ = 'b'; \n  if (key->ignore == nondictionary)\n    *opts++ = 'd';\n  if (key->translate)\n    *opts++ = 'f';\n  if (key->general_numeric)\n    *opts++ = 'g';\n  if (key->human_numeric)\n    *opts++ = 'h';\n  if (key->ignore == nonprinting)\n    *opts++ = 'i';\n  if (key->month)\n    *opts++ = 'M';\n  if (key->numeric)\n    *opts++ = 'n';\n  if (key->random)\n    *opts++ = 'R';\n  if (key->reverse)\n    *opts++ = 'r';\n  if (key->version)\n    *opts++ = 'V';\n  *opts = '\\0';\n}\n\n \n\nstatic void\nkey_warnings (struct keyfield const *gkey, bool gkey_only)\n{\n  struct keyfield const *key;\n  struct keyfield ugkey = *gkey;\n  unsigned long keynum = 1;\n  bool basic_numeric_field = false;\n  bool general_numeric_field = false;\n  bool basic_numeric_field_span = false;\n  bool general_numeric_field_span = false;\n\n  for (key = keylist; key; key = key->next, keynum++)\n    {\n      if (key_numeric (key))\n        {\n          if (key->general_numeric)\n            general_numeric_field = true;\n          else\n            basic_numeric_field = true;\n        }\n\n      if (key->traditional_used)\n        {\n          size_t sword = key->sword;\n          size_t eword = key->eword;\n          char tmp[INT_BUFSIZE_BOUND (uintmax_t)];\n           \n          char obuf[INT_BUFSIZE_BOUND (sword) * 2 + 4];  \n          char nbuf[INT_BUFSIZE_BOUND (sword) * 2 + 5];  \n          char *po = obuf;\n          char *pn = nbuf;\n\n          if (sword == SIZE_MAX)\n            sword++;\n\n          po = stpcpy (stpcpy (po, \"+\"), umaxtostr (sword, tmp));\n          pn = stpcpy (stpcpy (pn, \"-k \"), umaxtostr (sword + 1, tmp));\n          if (key->eword != SIZE_MAX)\n            {\n              stpcpy (stpcpy (po, \" -\"), umaxtostr (eword + 1, tmp));\n              stpcpy (stpcpy (pn, \",\"),\n                      umaxtostr (eword + 1\n                                 + (key->echar == SIZE_MAX), tmp));\n            }\n          error (0, 0, _(\"obsolescent key %s used; consider %s instead\"),\n                 quote_n (0, obuf), quote_n (1, nbuf));\n        }\n\n       \n      bool zero_width = key->sword != SIZE_MAX && key->eword < key->sword;\n      if (zero_width)\n        error (0, 0, _(\"key %lu has zero width and will be ignored\"), keynum);\n\n       \n      bool implicit_skip = key_numeric (key) || key->month;\n      bool line_offset = key->eword == 0 && key->echar != 0;  \n      if (!zero_width && !gkey_only && tab == TAB_DEFAULT && !line_offset\n          && ((!key->skipsblanks && !implicit_skip)\n              || (!key->skipsblanks && key->schar)\n              || (!key->skipeblanks && key->echar)))\n        error (0, 0, _(\"leading blanks are significant in key %lu; \"\n                       \"consider also specifying 'b'\"), keynum);\n\n       \n      if (!gkey_only && key_numeric (key))\n        {\n          size_t sword = key->sword + 1;\n          size_t eword = key->eword + 1;\n          if (!sword)\n            sword++;\n          if (!eword || sword < eword)\n            {\n              error (0, 0, _(\"key %lu is numeric and spans multiple fields\"),\n                     keynum);\n              if (key->general_numeric)\n                general_numeric_field_span = true;\n              else\n                basic_numeric_field_span = true;\n            }\n        }\n\n       \n      if (ugkey.ignore && (ugkey.ignore == key->ignore))\n        ugkey.ignore = nullptr;\n      if (ugkey.translate && (ugkey.translate == key->translate))\n        ugkey.translate = nullptr;\n      ugkey.skipsblanks &= !key->skipsblanks;\n      ugkey.skipeblanks &= !key->skipeblanks;\n      ugkey.month &= !key->month;\n      ugkey.numeric &= !key->numeric;\n      ugkey.general_numeric &= !key->general_numeric;\n      ugkey.human_numeric &= !key->human_numeric;\n      ugkey.random &= !key->random;\n      ugkey.version &= !key->version;\n      ugkey.reverse &= !key->reverse;\n    }\n\n   \n  bool number_locale_warned = false;\n  if (basic_numeric_field_span)\n    {\n      if (tab == TAB_DEFAULT\n          ? thousands_sep != NON_CHAR && (isblank (to_uchar (thousands_sep)))\n          : tab == thousands_sep)\n        {\n          error (0, 0,\n                 _(\"field separator %s is treated as a \"\n                   \"group separator in numbers\"),\n                 quote (((char []) {thousands_sep, 0})));\n          number_locale_warned = true;\n        }\n    }\n  if (basic_numeric_field_span || general_numeric_field_span)\n    {\n      if (tab == TAB_DEFAULT\n          ? thousands_sep != NON_CHAR && (isblank (to_uchar (decimal_point)))\n          : tab == decimal_point)\n        {\n          error (0, 0,\n                 _(\"field separator %s is treated as a \"\n                   \"decimal point in numbers\"),\n                 quote (((char []) {decimal_point, 0})));\n          number_locale_warned = true;\n        }\n      else if (tab == '-')\n        {\n          error (0, 0,\n                 _(\"field separator %s is treated as a \"\n                   \"minus sign in numbers\"),\n                 quote (((char []) {tab, 0})));\n        }\n      else if (general_numeric_field_span && tab == '+')\n        {\n          error (0, 0,\n                 _(\"field separator %s is treated as a \"\n                   \"plus sign in numbers\"),\n                 quote (((char []) {tab, 0})));\n        }\n    }\n\n   \n  if ((basic_numeric_field || general_numeric_field) && ! number_locale_warned)\n    {\n      error (0, 0,\n             _(\"%snumbers use %s as a decimal point in this locale\"),\n             tab == decimal_point ? \"\" : _(\"note \"),\n             quote (((char []) {decimal_point, 0})));\n\n    }\n\n  if (basic_numeric_field && thousands_sep_ignored)\n    {\n      error (0, 0,\n             _(\"the multi-byte number group separator \"\n               \"in this locale is not supported\"));\n    }\n\n   \n  if (!default_key_compare (&ugkey)\n      || (ugkey.reverse && (stable || unique) && keylist))\n    {\n      bool ugkey_reverse = ugkey.reverse;\n      if (!(stable || unique))\n        ugkey.reverse = false;\n       \n      char opts[sizeof short_options];\n      key_to_opts (&ugkey, opts);\n      error (0, 0,\n             ngettext (\"option '-%s' is ignored\",\n                       \"options '-%s' are ignored\",\n                       select_plural (strlen (opts))), opts);\n      ugkey.reverse = ugkey_reverse;\n    }\n  if (ugkey.reverse && !(stable || unique) && keylist)\n    error (0, 0, _(\"option '-r' only applies to last-resort comparison\"));\n}\n\n \n\nstatic int\ndiff_reversed (int diff, bool reversed)\n{\n  return reversed ? (diff < 0) - (diff > 0) : diff;\n}\n\n \n\nstatic int\nkeycompare (struct line const *a, struct line const *b)\n{\n  struct keyfield *key = keylist;\n\n   \n  char *texta = a->keybeg;\n  char *textb = b->keybeg;\n  char *lima = a->keylim;\n  char *limb = b->keylim;\n\n  int diff;\n\n  while (true)\n    {\n      char const *translate = key->translate;\n      bool const *ignore = key->ignore;\n\n       \n      lima = MAX (texta, lima);\n      limb = MAX (textb, limb);\n\n       \n      size_t lena = lima - texta;\n      size_t lenb = limb - textb;\n\n      if (hard_LC_COLLATE || key_numeric (key)\n          || key->month || key->random || key->version)\n        {\n           \n          char *ta = texta;\n          char *tb = textb;\n          size_t tlena = lena;\n          size_t tlenb = lenb;\n          char enda = ta[tlena];\n          char endb = tb[tlenb];\n\n          void *allocated = nullptr;\n          char stackbuf[4000];\n\n          if (ignore || translate)\n            {\n               \n\n              size_t i;\n\n               \n              size_t size = lena + 1 + lenb + 1;\n              if (size <= sizeof stackbuf)\n                ta = stackbuf;\n              else\n                ta = allocated = xmalloc (size);\n              tb = ta + lena + 1;\n\n               \n              for (tlena = i = 0; i < lena; i++)\n                if (! (ignore && ignore[to_uchar (texta[i])]))\n                  ta[tlena++] = (translate\n                                 ? translate[to_uchar (texta[i])]\n                                 : texta[i]);\n\n              for (tlenb = i = 0; i < lenb; i++)\n                if (! (ignore && ignore[to_uchar (textb[i])]))\n                  tb[tlenb++] = (translate\n                                 ? translate[to_uchar (textb[i])]\n                                 : textb[i]);\n            }\n\n          ta[tlena] = '\\0';\n          tb[tlenb] = '\\0';\n\n          if (key->numeric)\n            diff = numcompare (ta, tb);\n          else if (key->general_numeric)\n            diff = general_numcompare (ta, tb);\n          else if (key->human_numeric)\n            diff = human_numcompare (ta, tb);\n          else if (key->month)\n            diff = getmonth (ta, nullptr) - getmonth (tb, nullptr);\n          else if (key->random)\n            diff = compare_random (ta, tlena, tb, tlenb);\n          else if (key->version)\n            diff = filenvercmp (ta, tlena, tb, tlenb);\n          else\n            {\n               \n              if (tlena == 0)\n                diff = - NONZERO (tlenb);\n              else if (tlenb == 0)\n                diff = 1;\n              else\n                diff = xmemcoll0 (ta, tlena + 1, tb, tlenb + 1);\n            }\n\n          ta[tlena] = enda;\n          tb[tlenb] = endb;\n\n          free (allocated);\n        }\n      else if (ignore)\n        {\n#define CMP_WITH_IGNORE(A, B)\t\t\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n          while (true)\t\t\t\t\t\t\t\\\n            {\t\t\t\t\t\t\t\t\\\n              while (texta < lima && ignore[to_uchar (*texta)])\t\t\\\n                ++texta;\t\t\t\t\t\t\\\n              while (textb < limb && ignore[to_uchar (*textb)])\t\t\\\n                ++textb;\t\t\t\t\t\t\\\n              if (! (texta < lima && textb < limb))\t\t\t\\\n                {\t\t\t\t\t\t\t\\\n                  diff = (texta < lima) - (textb < limb);\t\t\\\n                  break;\t\t\t\t\t\t\\\n                }\t\t\t\t\t\t\t\\\n              diff = to_uchar (A) - to_uchar (B);\t\t\t\\\n              if (diff)\t\t\t\t\t\t\t\\\n                break;\t\t\t\t\t\t\t\\\n              ++texta;\t\t\t\t\t\t\t\\\n              ++textb;\t\t\t\t\t\t\t\\\n            }\t\t\t\t\t\t\t\t\\\n                                                                        \\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n\n          if (translate)\n            CMP_WITH_IGNORE (translate[to_uchar (*texta)],\n                             translate[to_uchar (*textb)]);\n          else\n            CMP_WITH_IGNORE (*texta, *textb);\n        }\n      else\n        {\n          size_t lenmin = MIN (lena, lenb);\n          if (lenmin == 0)\n            diff = 0;\n          else if (translate)\n            {\n              size_t i = 0;\n              do\n                {\n                  diff = (to_uchar (translate[to_uchar (texta[i])])\n                          - to_uchar (translate[to_uchar (textb[i])]));\n                  if (diff)\n                    break;\n                  i++;\n                }\n              while (i < lenmin);\n            }\n          else\n            diff = memcmp (texta, textb, lenmin);\n\n          if (! diff)\n            diff = (lena > lenb) - (lena < lenb);\n        }\n\n      if (diff)\n        break;\n\n      key = key->next;\n      if (! key)\n        return 0;\n\n       \n      if (key->eword != SIZE_MAX)\n        lima = limfield (a, key), limb = limfield (b, key);\n      else\n        lima = a->text + a->length - 1, limb = b->text + b->length - 1;\n\n      if (key->sword != SIZE_MAX)\n        texta = begfield (a, key), textb = begfield (b, key);\n      else\n        {\n          texta = a->text, textb = b->text;\n          if (key->skipsblanks)\n            {\n              while (texta < lima && blanks[to_uchar (*texta)])\n                ++texta;\n              while (textb < limb && blanks[to_uchar (*textb)])\n                ++textb;\n            }\n        }\n    }\n\n  return diff_reversed (diff, key->reverse);\n}\n\n \n\nstatic int\ncompare (struct line const *a, struct line const *b)\n{\n  int diff;\n  size_t alen, blen;\n\n   \n  if (keylist)\n    {\n      diff = keycompare (a, b);\n      if (diff || unique || stable)\n        return diff;\n    }\n\n   \n  alen = a->length - 1, blen = b->length - 1;\n\n  if (alen == 0)\n    diff = - NONZERO (blen);\n  else if (blen == 0)\n    diff = 1;\n  else if (hard_LC_COLLATE)\n    {\n       \n      diff = xmemcoll0 (a->text, alen + 1, b->text, blen + 1);\n    }\n  else\n    {\n      diff = memcmp (a->text, b->text, MIN (alen, blen));\n      if (!diff)\n        diff = (alen > blen) - (alen < blen);\n    }\n\n  return diff_reversed (diff, reverse);\n}\n\n \n\nstatic void\nwrite_line (struct line const *line, FILE *fp, char const *output_file)\n{\n  char *buf = line->text;\n  size_t n_bytes = line->length;\n  char *ebuf = buf + n_bytes;\n\n  if (!output_file && debug)\n    {\n       \n      char const *c = buf;\n\n      while (c < ebuf)\n        {\n          char wc = *c++;\n          if (wc == '\\t')\n            wc = '>';\n          else if (c == ebuf)\n            wc = '\\n';\n          if (fputc (wc, fp) == EOF)\n            sort_die (_(\"write failed\"), output_file);\n        }\n\n      debug_line (line);\n    }\n  else\n    {\n      ebuf[-1] = eolchar;\n      if (fwrite (buf, 1, n_bytes, fp) != n_bytes)\n        sort_die (_(\"write failed\"), output_file);\n      ebuf[-1] = '\\0';\n    }\n}\n\n \n\nstatic bool\ncheck (char const *file_name, char checkonly)\n{\n  FILE *fp = xfopen (file_name, \"r\");\n  struct buffer buf;\t\t \n  struct line temp;\t\t \n  size_t alloc = 0;\n  uintmax_t line_number = 0;\n  struct keyfield const *key = keylist;\n  bool nonunique = ! unique;\n  bool ordered = true;\n\n  initbuf (&buf, sizeof (struct line),\n           MAX (merge_buffer_size, sort_size));\n  temp.text = nullptr;\n\n  while (fillbuf (&buf, fp, file_name))\n    {\n      struct line const *line = buffer_linelim (&buf);\n      struct line const *linebase = line - buf.nlines;\n\n       \n      if (alloc && nonunique <= compare (&temp, line - 1))\n        {\n        found_disorder:\n          {\n            if (checkonly == 'c')\n              {\n                struct line const *disorder_line = line - 1;\n                uintmax_t disorder_line_number =\n                  buffer_linelim (&buf) - disorder_line + line_number;\n                char hr_buf[INT_BUFSIZE_BOUND (disorder_line_number)];\n                fprintf (stderr, _(\"%s: %s:%s: disorder: \"),\n                         program_name, file_name,\n                         umaxtostr (disorder_line_number, hr_buf));\n                write_line (disorder_line, stderr, _(\"standard error\"));\n              }\n\n            ordered = false;\n            break;\n          }\n        }\n\n       \n      while (linebase < --line)\n        if (nonunique <= compare (line, line - 1))\n          goto found_disorder;\n\n      line_number += buf.nlines;\n\n       \n      if (alloc < line->length)\n        {\n          do\n            {\n              alloc *= 2;\n              if (! alloc)\n                {\n                  alloc = line->length;\n                  break;\n                }\n            }\n          while (alloc < line->length);\n\n          free (temp.text);\n          temp.text = xmalloc (alloc);\n        }\n      memcpy (temp.text, line->text, line->length);\n      temp.length = line->length;\n      if (key)\n        {\n          temp.keybeg = temp.text + (line->keybeg - line->text);\n          temp.keylim = temp.text + (line->keylim - line->text);\n        }\n    }\n\n  xfclose (fp, file_name);\n  free (buf.buf);\n  free (temp.text);\n  return ordered;\n}\n\n \n\nstatic size_t\nopen_input_files (struct sortfile *files, size_t nfiles, FILE ***pfps)\n{\n  FILE **fps = *pfps = xnmalloc (nfiles, sizeof *fps);\n  int i;\n\n   \n  for (i = 0; i < nfiles; i++)\n    {\n      fps[i] = (files[i].temp && files[i].temp->state != UNCOMPRESSED\n                ? open_temp (files[i].temp)\n                : stream_open (files[i].name, \"r\"));\n      if (!fps[i])\n        break;\n    }\n\n  return i;\n}\n\n \n\nstatic void\nmergefps (struct sortfile *files, size_t ntemps, size_t nfiles,\n          FILE *ofp, char const *output_file, FILE **fps)\n{\n  struct buffer *buffer = xnmalloc (nfiles, sizeof *buffer);\n                                 \n  struct line saved;\t\t \n  struct line const *savedline = nullptr;\n                                 \n  size_t savealloc = 0;\t\t \n  struct line const **cur = xnmalloc (nfiles, sizeof *cur);\n                                 \n  struct line const **base = xnmalloc (nfiles, sizeof *base);\n                                 \n  size_t *ord = xnmalloc (nfiles, sizeof *ord);\n                                 \n  size_t i;\n  size_t j;\n  size_t t;\n  struct keyfield const *key = keylist;\n  saved.text = nullptr;\n\n   \n  for (i = 0; i < nfiles; )\n    {\n      initbuf (&buffer[i], sizeof (struct line),\n               MAX (merge_buffer_size, sort_size / nfiles));\n      if (fillbuf (&buffer[i], fps[i], files[i].name))\n        {\n          struct line const *linelim = buffer_linelim (&buffer[i]);\n          cur[i] = linelim - 1;\n          base[i] = linelim - buffer[i].nlines;\n          i++;\n        }\n      else\n        {\n           \n          xfclose (fps[i], files[i].name);\n          if (i < ntemps)\n            {\n              ntemps--;\n              zaptemp (files[i].name);\n            }\n          free (buffer[i].buf);\n          --nfiles;\n          for (j = i; j < nfiles; ++j)\n            {\n              files[j] = files[j + 1];\n              fps[j] = fps[j + 1];\n            }\n        }\n    }\n\n   \n  for (i = 0; i < nfiles; ++i)\n    ord[i] = i;\n  for (i = 1; i < nfiles; ++i)\n    if (0 < compare (cur[ord[i - 1]], cur[ord[i]]))\n      t = ord[i - 1], ord[i - 1] = ord[i], ord[i] = t, i = 0;\n\n   \n  while (nfiles)\n    {\n      struct line const *smallest = cur[ord[0]];\n\n       \n      if (unique)\n        {\n          if (savedline && compare (savedline, smallest))\n            {\n              savedline = nullptr;\n              write_line (&saved, ofp, output_file);\n            }\n          if (!savedline)\n            {\n              savedline = &saved;\n              if (savealloc < smallest->length)\n                {\n                  do\n                    if (! savealloc)\n                      {\n                        savealloc = smallest->length;\n                        break;\n                      }\n                  while ((savealloc *= 2) < smallest->length);\n\n                  free (saved.text);\n                  saved.text = xmalloc (savealloc);\n                }\n              saved.length = smallest->length;\n              memcpy (saved.text, smallest->text, saved.length);\n              if (key)\n                {\n                  saved.keybeg =\n                    saved.text + (smallest->keybeg - smallest->text);\n                  saved.keylim =\n                    saved.text + (smallest->keylim - smallest->text);\n                }\n            }\n        }\n      else\n        write_line (smallest, ofp, output_file);\n\n       \n      if (base[ord[0]] < smallest)\n        cur[ord[0]] = smallest - 1;\n      else\n        {\n          if (fillbuf (&buffer[ord[0]], fps[ord[0]], files[ord[0]].name))\n            {\n              struct line const *linelim = buffer_linelim (&buffer[ord[0]]);\n              cur[ord[0]] = linelim - 1;\n              base[ord[0]] = linelim - buffer[ord[0]].nlines;\n            }\n          else\n            {\n               \n              for (i = 1; i < nfiles; ++i)\n                if (ord[i] > ord[0])\n                  --ord[i];\n              --nfiles;\n              xfclose (fps[ord[0]], files[ord[0]].name);\n              if (ord[0] < ntemps)\n                {\n                  ntemps--;\n                  zaptemp (files[ord[0]].name);\n                }\n              free (buffer[ord[0]].buf);\n              for (i = ord[0]; i < nfiles; ++i)\n                {\n                  fps[i] = fps[i + 1];\n                  files[i] = files[i + 1];\n                  buffer[i] = buffer[i + 1];\n                  cur[i] = cur[i + 1];\n                  base[i] = base[i + 1];\n                }\n              for (i = 0; i < nfiles; ++i)\n                ord[i] = ord[i + 1];\n              continue;\n            }\n        }\n\n       \n      {\n        size_t lo = 1;\n        size_t hi = nfiles;\n        size_t probe = lo;\n        size_t ord0 = ord[0];\n        size_t count_of_smaller_lines;\n\n        while (lo < hi)\n          {\n            int cmp = compare (cur[ord0], cur[ord[probe]]);\n            if (cmp < 0 || (cmp == 0 && ord0 < ord[probe]))\n              hi = probe;\n            else\n              lo = probe + 1;\n            probe = (lo + hi) / 2;\n          }\n\n        count_of_smaller_lines = lo - 1;\n        for (j = 0; j < count_of_smaller_lines; j++)\n          ord[j] = ord[j + 1];\n        ord[count_of_smaller_lines] = ord0;\n      }\n    }\n\n  if (unique && savedline)\n    {\n      write_line (&saved, ofp, output_file);\n      free (saved.text);\n    }\n\n  xfclose (ofp, output_file);\n  free (fps);\n  free (buffer);\n  free (ord);\n  free (base);\n  free (cur);\n}\n\n \n\nstatic size_t\nmergefiles (struct sortfile *files, size_t ntemps, size_t nfiles,\n            FILE *ofp, char const *output_file)\n{\n  FILE **fps;\n  size_t nopened = open_input_files (files, nfiles, &fps);\n  if (nopened < nfiles && nopened < 2)\n    sort_die (_(\"open failed\"), files[nopened].name);\n  mergefps (files, ntemps, nopened, ofp, output_file, fps);\n  return nopened;\n}\n\n \n\nstatic void\nmergelines (struct line *restrict t, size_t nlines,\n            struct line const *restrict lo)\n{\n  size_t nlo = nlines / 2;\n  size_t nhi = nlines - nlo;\n  struct line *hi = t - nlo;\n\n  while (true)\n    if (compare (lo - 1, hi - 1) <= 0)\n      {\n        *--t = *--lo;\n        if (! --nlo)\n          {\n             \n            return;\n          }\n      }\n    else\n      {\n        *--t = *--hi;\n        if (! --nhi)\n          {\n            do\n              *--t = *--lo;\n            while (--nlo);\n\n            return;\n          }\n      }\n}\n\n \n\nstatic void\nsequential_sort (struct line *restrict lines, size_t nlines,\n                 struct line *restrict temp, bool to_temp)\n{\n  if (nlines == 2)\n    {\n       \n      int swap = (0 < compare (&lines[-1], &lines[-2]));\n      if (to_temp)\n        {\n          temp[-1] = lines[-1 - swap];\n          temp[-2] = lines[-2 + swap];\n        }\n      else if (swap)\n        {\n          temp[-1] = lines[-1];\n          lines[-1] = lines[-2];\n          lines[-2] = temp[-1];\n        }\n    }\n  else\n    {\n      size_t nlo = nlines / 2;\n      size_t nhi = nlines - nlo;\n      struct line *lo = lines;\n      struct line *hi = lines - nlo;\n\n      sequential_sort (hi, nhi, temp - (to_temp ? nlo : 0), to_temp);\n      if (1 < nlo)\n        sequential_sort (lo, nlo, temp, !to_temp);\n      else if (!to_temp)\n        temp[-1] = lo[-1];\n\n      struct line *dest;\n      struct line const *sorted_lo;\n      if (to_temp)\n        {\n          dest = temp;\n          sorted_lo = lines;\n        }\n      else\n        {\n          dest = lines;\n          sorted_lo = temp;\n        }\n      mergelines (dest, nlines, sorted_lo);\n    }\n}\n\nstatic struct merge_node *init_node (struct merge_node *restrict,\n                                     struct merge_node *restrict,\n                                     struct line *, size_t, size_t, bool);\n\n\n \nstatic struct merge_node *\nmerge_tree_init (size_t nthreads, size_t nlines, struct line *dest)\n{\n  struct merge_node *merge_tree = xmalloc (2 * sizeof *merge_tree * nthreads);\n\n  struct merge_node *root = merge_tree;\n  root->lo = root->hi = root->end_lo = root->end_hi = nullptr;\n  root->dest = nullptr;\n  root->nlo = root->nhi = nlines;\n  root->parent = nullptr;\n  root->level = MERGE_END;\n  root->queued = false;\n  pthread_mutex_init (&root->lock, nullptr);\n\n  init_node (root, root + 1, dest, nthreads, nlines, false);\n  return merge_tree;\n}\n\n \nstatic void\nmerge_tree_destroy (size_t nthreads, struct merge_node *merge_tree)\n{\n  size_t n_nodes = nthreads * 2;\n  struct merge_node *node = merge_tree;\n\n  while (n_nodes--)\n    {\n      pthread_mutex_destroy (&node->lock);\n      node++;\n    }\n\n  free (merge_tree);\n}\n\n \n\nstatic struct merge_node *\ninit_node (struct merge_node *restrict parent,\n           struct merge_node *restrict node_pool,\n           struct line *dest, size_t nthreads,\n           size_t total_lines, bool is_lo_child)\n{\n  size_t nlines = (is_lo_child ? parent->nlo : parent->nhi);\n  size_t nlo = nlines / 2;\n  size_t nhi = nlines - nlo;\n  struct line *lo = dest - total_lines;\n  struct line *hi = lo - nlo;\n  struct line **parent_end = (is_lo_child ? &parent->end_lo : &parent->end_hi);\n\n  struct merge_node *node = node_pool++;\n  node->lo = node->end_lo = lo;\n  node->hi = node->end_hi = hi;\n  node->dest = parent_end;\n  node->nlo = nlo;\n  node->nhi = nhi;\n  node->parent = parent;\n  node->level = parent->level + 1;\n  node->queued = false;\n  pthread_mutex_init (&node->lock, nullptr);\n\n  if (nthreads > 1)\n    {\n      size_t lo_threads = nthreads / 2;\n      size_t hi_threads = nthreads - lo_threads;\n      node->lo_child = node_pool;\n      node_pool = init_node (node, node_pool, lo, lo_threads,\n                             total_lines, true);\n      node->hi_child = node_pool;\n      node_pool = init_node (node, node_pool, hi, hi_threads,\n                             total_lines, false);\n    }\n  else\n    {\n      node->lo_child = nullptr;\n      node->hi_child = nullptr;\n    }\n  return node_pool;\n}\n\n\n \n\nstatic int\ncompare_nodes (void const *a, void const *b)\n{\n  struct merge_node const *nodea = a;\n  struct merge_node const *nodeb = b;\n  if (nodea->level == nodeb->level)\n      return (nodea->nlo + nodea->nhi) < (nodeb->nlo + nodeb->nhi);\n  return nodea->level < nodeb->level;\n}\n\n \n\nstatic inline void\nlock_node (struct merge_node *node)\n{\n  pthread_mutex_lock (&node->lock);\n}\n\n \n\nstatic inline void\nunlock_node (struct merge_node *node)\n{\n  pthread_mutex_unlock (&node->lock);\n}\n\n \n\nstatic void\nqueue_destroy (struct merge_node_queue *queue)\n{\n  heap_free (queue->priority_queue);\n  pthread_cond_destroy (&queue->cond);\n  pthread_mutex_destroy (&queue->mutex);\n}\n\n \n\nstatic void\nqueue_init (struct merge_node_queue *queue, size_t nthreads)\n{\n   \n  queue->priority_queue = heap_alloc (compare_nodes, 2 * nthreads);\n  pthread_mutex_init (&queue->mutex, nullptr);\n  pthread_cond_init (&queue->cond, nullptr);\n}\n\n \n\nstatic void\nqueue_insert (struct merge_node_queue *queue, struct merge_node *node)\n{\n  pthread_mutex_lock (&queue->mutex);\n  heap_insert (queue->priority_queue, node);\n  node->queued = true;\n  pthread_cond_signal (&queue->cond);\n  pthread_mutex_unlock (&queue->mutex);\n}\n\n \n\nstatic struct merge_node *\nqueue_pop (struct merge_node_queue *queue)\n{\n  struct merge_node *node;\n  pthread_mutex_lock (&queue->mutex);\n  while (! (node = heap_remove_top (queue->priority_queue)))\n    pthread_cond_wait (&queue->cond, &queue->mutex);\n  pthread_mutex_unlock (&queue->mutex);\n  lock_node (node);\n  node->queued = false;\n  return node;\n}\n\n \n\nstatic void\nwrite_unique (struct line const *line, FILE *tfp, char const *temp_output)\n{\n  if (unique)\n    {\n      if (saved_line.text && ! compare (line, &saved_line))\n        return;\n      saved_line = *line;\n    }\n\n  write_line (line, tfp, temp_output);\n}\n\n \n\nstatic void\nmergelines_node (struct merge_node *restrict node, size_t total_lines,\n                 FILE *tfp, char const *temp_output)\n{\n  struct line *lo_orig = node->lo;\n  struct line *hi_orig = node->hi;\n  size_t to_merge = MAX_MERGE (total_lines, node->level);\n  size_t merged_lo;\n  size_t merged_hi;\n\n  if (node->level > MERGE_ROOT)\n    {\n       \n      struct line *dest = *node->dest;\n      while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)\n        if (compare (node->lo - 1, node->hi - 1) <= 0)\n          *--dest = *--node->lo;\n        else\n          *--dest = *--node->hi;\n\n      merged_lo = lo_orig - node->lo;\n      merged_hi = hi_orig - node->hi;\n\n      if (node->nhi == merged_hi)\n        while (node->lo != node->end_lo && to_merge--)\n          *--dest = *--node->lo;\n      else if (node->nlo == merged_lo)\n        while (node->hi != node->end_hi && to_merge--)\n          *--dest = *--node->hi;\n      *node->dest = dest;\n    }\n  else\n    {\n       \n      while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)\n        {\n          if (compare (node->lo - 1, node->hi - 1) <= 0)\n            write_unique (--node->lo, tfp, temp_output);\n          else\n            write_unique (--node->hi, tfp, temp_output);\n        }\n\n      merged_lo = lo_orig - node->lo;\n      merged_hi = hi_orig - node->hi;\n\n      if (node->nhi == merged_hi)\n        {\n          while (node->lo != node->end_lo && to_merge--)\n            write_unique (--node->lo, tfp, temp_output);\n        }\n      else if (node->nlo == merged_lo)\n        {\n          while (node->hi != node->end_hi && to_merge--)\n            write_unique (--node->hi, tfp, temp_output);\n        }\n    }\n\n   \n  merged_lo = lo_orig - node->lo;\n  merged_hi = hi_orig - node->hi;\n  node->nlo -= merged_lo;\n  node->nhi -= merged_hi;\n}\n\n \n\nstatic void\nqueue_check_insert (struct merge_node_queue *queue, struct merge_node *node)\n{\n  if (! node->queued)\n    {\n      bool lo_avail = (node->lo - node->end_lo) != 0;\n      bool hi_avail = (node->hi - node->end_hi) != 0;\n      if (lo_avail ? hi_avail || ! node->nhi : hi_avail && ! node->nlo)\n        queue_insert (queue, node);\n    }\n}\n\n \n\nstatic void\nqueue_check_insert_parent (struct merge_node_queue *queue,\n                           struct merge_node *node)\n{\n  if (node->level > MERGE_ROOT)\n    {\n      lock_node (node->parent);\n      queue_check_insert (queue, node->parent);\n      unlock_node (node->parent);\n    }\n  else if (node->nlo + node->nhi == 0)\n    {\n       \n      queue_insert (queue, node->parent);\n    }\n}\n\n \n\nstatic void\nmerge_loop (struct merge_node_queue *queue,\n            size_t total_lines, FILE *tfp, char const *temp_output)\n{\n  while (true)\n    {\n      struct merge_node *node = queue_pop (queue);\n\n      if (node->level == MERGE_END)\n        {\n          unlock_node (node);\n           \n          queue_insert (queue, node);\n          break;\n        }\n      mergelines_node (node, total_lines, tfp, temp_output);\n      queue_check_insert (queue, node);\n      queue_check_insert_parent (queue, node);\n\n      unlock_node (node);\n    }\n}\n\n\nstatic void sortlines (struct line *restrict, size_t, size_t,\n                       struct merge_node *, struct merge_node_queue *,\n                       FILE *, char const *);\n\n \n\nstruct thread_args\n{\n   \n  struct line *lines;\n\n   \n  size_t nthreads;\n\n   \n  size_t const total_lines;\n\n   \n  struct merge_node *const node;\n\n   \n  struct merge_node_queue *const queue;\n\n   \n  FILE *tfp;\n  char const *output_temp;\n};\n\n \n\nstatic void *\nsortlines_thread (void *data)\n{\n  struct thread_args const *args = data;\n  sortlines (args->lines, args->nthreads, args->total_lines,\n             args->node, args->queue, args->tfp,\n             args->output_temp);\n  return nullptr;\n}\n\n \n\nstatic void\nsortlines (struct line *restrict lines, size_t nthreads,\n           size_t total_lines, struct merge_node *node,\n           struct merge_node_queue *queue, FILE *tfp, char const *temp_output)\n{\n  size_t nlines = node->nlo + node->nhi;\n\n   \n  size_t lo_threads = nthreads / 2;\n  size_t hi_threads = nthreads - lo_threads;\n  pthread_t thread;\n  struct thread_args args = {lines, lo_threads, total_lines,\n                             node->lo_child, queue, tfp, temp_output};\n\n  if (nthreads > 1 && SUBTHREAD_LINES_HEURISTIC <= nlines\n      && pthread_create (&thread, nullptr, sortlines_thread, &args) == 0)\n    {\n      sortlines (lines - node->nlo, hi_threads, total_lines,\n                 node->hi_child, queue, tfp, temp_output);\n      pthread_join (thread, nullptr);\n    }\n  else\n    {\n       \n      size_t nlo = node->nlo;\n      size_t nhi = node->nhi;\n      struct line *temp = lines - total_lines;\n      if (1 < nhi)\n        sequential_sort (lines - nlo, nhi, temp - nlo / 2, false);\n      if (1 < nlo)\n        sequential_sort (lines, nlo, temp, false);\n\n       \n      node->lo = lines;\n      node->hi = lines - nlo;\n      node->end_lo = lines - nlo;\n      node->end_hi = lines - nlo - nhi;\n\n      queue_insert (queue, node);\n      merge_loop (queue, total_lines, tfp, temp_output);\n    }\n}\n\n \n\nstatic void\navoid_trashing_input (struct sortfile *files, size_t ntemps,\n                      size_t nfiles, char const *outfile)\n{\n  struct tempnode *tempcopy = nullptr;\n\n  for (size_t i = ntemps; i < nfiles; i++)\n    {\n      bool is_stdin = STREQ (files[i].name, \"-\");\n      bool same;\n      struct stat instat;\n\n      if (outfile && STREQ (outfile, files[i].name) && !is_stdin)\n        same = true;\n      else\n        {\n          struct stat *outst = get_outstatus ();\n          if (!outst)\n            break;\n\n          same = (((is_stdin\n                    ? fstat (STDIN_FILENO, &instat)\n                    : stat (files[i].name, &instat))\n                   == 0)\n                  && SAME_INODE (instat, *outst));\n        }\n\n      if (same)\n        {\n          if (! tempcopy)\n            {\n              FILE *tftp;\n              tempcopy = create_temp (&tftp);\n              mergefiles (&files[i], 0, 1, tftp, tempcopy->name);\n            }\n\n          files[i].name = tempcopy->name;\n          files[i].temp = tempcopy;\n        }\n    }\n}\n\n \n\nstatic void\ncheck_inputs (char *const *files, size_t nfiles)\n{\n  for (size_t i = 0; i < nfiles; i++)\n    {\n      if (STREQ (files[i], \"-\"))\n        continue;\n\n      if (euidaccess (files[i], R_OK) != 0)\n        sort_die (_(\"cannot read\"), files[i]);\n    }\n}\n\n \n\nstatic void\ncheck_output (char const *outfile)\n{\n  if (outfile)\n    {\n      int oflags = O_WRONLY | O_BINARY | O_CLOEXEC | O_CREAT;\n      int outfd = open (outfile, oflags, MODE_RW_UGO);\n      if (outfd < 0)\n        sort_die (_(\"open failed\"), outfile);\n      move_fd (outfd, STDOUT_FILENO);\n    }\n}\n\n \n\nstatic void\nmerge (struct sortfile *files, size_t ntemps, size_t nfiles,\n       char const *output_file)\n{\n  while (nmerge < nfiles)\n    {\n       \n      size_t in;\n\n       \n      size_t out;\n\n       \n      size_t remainder;\n\n       \n      size_t cheap_slots;\n\n       \n      for (out = in = 0; nmerge <= nfiles - in; out++)\n        {\n          FILE *tfp;\n          struct tempnode *temp = create_temp (&tfp);\n          size_t num_merged = mergefiles (&files[in], MIN (ntemps, nmerge),\n                                          nmerge, tfp, temp->name);\n          ntemps -= MIN (ntemps, num_merged);\n          files[out].name = temp->name;\n          files[out].temp = temp;\n          in += num_merged;\n        }\n\n      remainder = nfiles - in;\n      cheap_slots = nmerge - out % nmerge;\n\n      if (cheap_slots < remainder)\n        {\n           \n          size_t nshortmerge = remainder - cheap_slots + 1;\n          FILE *tfp;\n          struct tempnode *temp = create_temp (&tfp);\n          size_t num_merged = mergefiles (&files[in], MIN (ntemps, nshortmerge),\n                                          nshortmerge, tfp, temp->name);\n          ntemps -= MIN (ntemps, num_merged);\n          files[out].name = temp->name;\n          files[out++].temp = temp;\n          in += num_merged;\n        }\n\n       \n      memmove (&files[out], &files[in], (nfiles - in) * sizeof *files);\n      ntemps += out;\n      nfiles -= in - out;\n    }\n\n  avoid_trashing_input (files, ntemps, nfiles, output_file);\n\n   \n\n  while (true)\n    {\n       \n      FILE **fps;\n      size_t nopened = open_input_files (files, nfiles, &fps);\n\n      if (nopened == nfiles)\n        {\n          FILE *ofp = stream_open (output_file, \"w\");\n          if (ofp)\n            {\n              mergefps (files, ntemps, nfiles, ofp, output_file, fps);\n              break;\n            }\n          if (errno != EMFILE || nopened <= 2)\n            sort_die (_(\"open failed\"), output_file);\n        }\n      else if (nopened <= 2)\n        sort_die (_(\"open failed\"), files[nopened].name);\n\n       \n      FILE *tfp;\n      struct tempnode *temp;\n      do\n        {\n          nopened--;\n          xfclose (fps[nopened], files[nopened].name);\n          temp = maybe_create_temp (&tfp, ! (nopened <= 2));\n        }\n      while (!temp);\n\n       \n      mergefps (&files[0], MIN (ntemps, nopened), nopened, tfp, temp->name,\n                fps);\n      ntemps -= MIN (ntemps, nopened);\n      files[0].name = temp->name;\n      files[0].temp = temp;\n\n      memmove (&files[1], &files[nopened], (nfiles - nopened) * sizeof *files);\n      ntemps++;\n      nfiles -= nopened - 1;\n    }\n}\n\n \n\nstatic void\nsort (char *const *files, size_t nfiles, char const *output_file,\n      size_t nthreads)\n{\n  struct buffer buf;\n  size_t ntemps = 0;\n  bool output_file_created = false;\n\n  buf.alloc = 0;\n\n  while (nfiles)\n    {\n      char const *temp_output;\n      char const *file = *files;\n      FILE *fp = xfopen (file, \"r\");\n      FILE *tfp;\n\n      size_t bytes_per_line;\n      if (nthreads > 1)\n        {\n           \n          size_t tmp = 1;\n          size_t mult = 1;\n          while (tmp < nthreads)\n            {\n              tmp *= 2;\n              mult++;\n            }\n          bytes_per_line = (mult * sizeof (struct line));\n        }\n      else\n        bytes_per_line = sizeof (struct line) * 3 / 2;\n\n      if (! buf.alloc)\n        initbuf (&buf, bytes_per_line,\n                 sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));\n      buf.eof = false;\n      files++;\n      nfiles--;\n\n      while (fillbuf (&buf, fp, file))\n        {\n          struct line *line;\n\n          if (buf.eof && nfiles\n              && (bytes_per_line + 1\n                  < (buf.alloc - buf.used - bytes_per_line * buf.nlines)))\n            {\n               \n              buf.left = buf.used;\n              break;\n            }\n\n          saved_line.text = nullptr;\n          line = buffer_linelim (&buf);\n          if (buf.eof && !nfiles && !ntemps && !buf.left)\n            {\n              xfclose (fp, file);\n              tfp = xfopen (output_file, \"w\");\n              temp_output = output_file;\n              output_file_created = true;\n            }\n          else\n            {\n              ++ntemps;\n              temp_output = create_temp (&tfp)->name;\n            }\n          if (1 < buf.nlines)\n            {\n              struct merge_node_queue queue;\n              queue_init (&queue, nthreads);\n              struct merge_node *merge_tree =\n                merge_tree_init (nthreads, buf.nlines, line);\n\n              sortlines (line, nthreads, buf.nlines, merge_tree + 1,\n                         &queue, tfp, temp_output);\n\n              merge_tree_destroy (nthreads, merge_tree);\n              queue_destroy (&queue);\n            }\n          else\n            write_unique (line - 1, tfp, temp_output);\n\n          xfclose (tfp, temp_output);\n\n          if (output_file_created)\n            goto finish;\n        }\n      xfclose (fp, file);\n    }\n\n finish:\n  free (buf.buf);\n\n  if (! output_file_created)\n    {\n      struct tempnode *node = temphead;\n      struct sortfile *tempfiles = xnmalloc (ntemps, sizeof *tempfiles);\n      for (size_t i = 0; node; i++)\n        {\n          tempfiles[i].name = node->name;\n          tempfiles[i].temp = node;\n          node = node->next;\n        }\n      merge (tempfiles, ntemps, ntemps, output_file);\n      free (tempfiles);\n    }\n\n  reap_all ();\n}\n\n \n\nstatic void\ninsertkey (struct keyfield *key_arg)\n{\n  struct keyfield **p;\n  struct keyfield *key = xmemdup (key_arg, sizeof *key);\n\n  for (p = &keylist; *p; p = &(*p)->next)\n    continue;\n  *p = key;\n  key->next = nullptr;\n}\n\n \n\nstatic void\nbadfieldspec (char const *spec, char const *msgid)\n{\n  error (SORT_FAILURE, 0, _(\"%s: invalid field specification %s\"),\n         _(msgid), quote (spec));\n}\n\n \n\nstatic void\nincompatible_options (char const *opts)\n{\n  error (SORT_FAILURE, 0, _(\"options '-%s' are incompatible\"), (opts));\n}\n\n \n\nstatic void\ncheck_ordering_compatibility (void)\n{\n  struct keyfield *key;\n\n  for (key = keylist; key; key = key->next)\n    if (1 < (key->numeric + key->general_numeric + key->human_numeric\n             + key->month + (key->version | key->random | !!key->ignore)))\n      {\n         \n        char opts[sizeof short_options];\n         \n        key->skipsblanks = key->skipeblanks = key->reverse = false;\n        key_to_opts (key, opts);\n        incompatible_options (opts);\n      }\n}\n\n \n\nstatic char const *\nparse_field_count (char const *string, size_t *val, char const *msgid)\n{\n  char *suffix;\n  uintmax_t n;\n\n  switch (xstrtoumax (string, &suffix, 10, &n, \"\"))\n    {\n    case LONGINT_OK:\n    case LONGINT_INVALID_SUFFIX_CHAR:\n      *val = n;\n      if (*val == n)\n        break;\n      FALLTHROUGH;\n    case LONGINT_OVERFLOW:\n    case LONGINT_OVERFLOW | LONGINT_INVALID_SUFFIX_CHAR:\n      *val = SIZE_MAX;\n      break;\n\n    case LONGINT_INVALID:\n      if (msgid)\n        error (SORT_FAILURE, 0, _(\"%s: invalid count at start of %s\"),\n               _(msgid), quote (string));\n      return nullptr;\n    }\n\n  return suffix;\n}\n\n \n\nstatic void\nsighandler (int sig)\n{\n  if (! SA_NOCLDSTOP)\n    signal (sig, SIG_IGN);\n\n  cleanup ();\n\n  signal (sig, SIG_DFL);\n  raise (sig);\n}\n\n \n\nstatic char *\nset_ordering (char const *s, struct keyfield *key, enum blanktype blanktype)\n{\n  while (*s)\n    {\n      switch (*s)\n        {\n        case 'b':\n          if (blanktype == bl_start || blanktype == bl_both)\n            key->skipsblanks = true;\n          if (blanktype == bl_end || blanktype == bl_both)\n            key->skipeblanks = true;\n          break;\n        case 'd':\n          key->ignore = nondictionary;\n          break;\n        case 'f':\n          key->translate = fold_toupper;\n          break;\n        case 'g':\n          key->general_numeric = true;\n          break;\n        case 'h':\n          key->human_numeric = true;\n          break;\n        case 'i':\n           \n          if (! key->ignore)\n            key->ignore = nonprinting;\n          break;\n        case 'M':\n          key->month = true;\n          break;\n        case 'n':\n          key->numeric = true;\n          break;\n        case 'R':\n          key->random = true;\n          break;\n        case 'r':\n          key->reverse = true;\n          break;\n        case 'V':\n          key->version = true;\n          break;\n        default:\n          return (char *) s;\n        }\n      ++s;\n    }\n  return (char *) s;\n}\n\n \n\nstatic struct keyfield *\nkey_init (struct keyfield *key)\n{\n  memset (key, 0, sizeof *key);\n  key->eword = SIZE_MAX;\n  return key;\n}\n\nint\nmain (int argc, char **argv)\n{\n  struct keyfield *key;\n  struct keyfield key_buf;\n  struct keyfield gkey;\n  bool gkey_only = false;\n  char const *s;\n  int c = 0;\n  char checkonly = 0;\n  bool mergeonly = false;\n  char *random_source = nullptr;\n  bool need_random = false;\n  size_t nthreads = 0;\n  size_t nfiles = 0;\n  bool posixly_correct = (getenv (\"POSIXLY_CORRECT\") != nullptr);\n  int posix_ver = posix2_version ();\n  bool traditional_usage = ! (200112 <= posix_ver && posix_ver < 200809);\n  char **files;\n  char *files_from = nullptr;\n  struct Tokens tok;\n  char const *outfile = nullptr;\n  bool locale_ok;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  locale_ok = !! setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  initialize_exit_failure (SORT_FAILURE);\n\n  hard_LC_COLLATE = hard_locale (LC_COLLATE);\n#if HAVE_NL_LANGINFO\n  hard_LC_TIME = hard_locale (LC_TIME);\n#endif\n\n   \n  {\n    struct lconv const *locale = localeconv ();\n\n     \n    decimal_point = locale->decimal_point[0];\n    if (! decimal_point || locale->decimal_point[1])\n      decimal_point = '.';\n\n     \n    thousands_sep = locale->thousands_sep[0];\n    if (thousands_sep && locale->thousands_sep[1])\n      thousands_sep_ignored = true;\n    if (! thousands_sep || locale->thousands_sep[1])\n      thousands_sep = NON_CHAR;\n  }\n\n  have_read_stdin = false;\n  inittables ();\n\n  {\n    size_t i;\n    static int const sig[] =\n      {\n         \n        SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,\n#ifdef SIGPOLL\n        SIGPOLL,\n#endif\n#ifdef SIGPROF\n        SIGPROF,\n#endif\n#ifdef SIGVTALRM\n        SIGVTALRM,\n#endif\n#ifdef SIGXCPU\n        SIGXCPU,\n#endif\n#ifdef SIGXFSZ\n        SIGXFSZ,\n#endif\n      };\n    enum { nsigs = ARRAY_CARDINALITY (sig) };\n\n#if SA_NOCLDSTOP\n    struct sigaction act;\n\n    sigemptyset (&caught_signals);\n    for (i = 0; i < nsigs; i++)\n      {\n        sigaction (sig[i], nullptr, &act);\n        if (act.sa_handler != SIG_IGN)\n          sigaddset (&caught_signals, sig[i]);\n      }\n\n    act.sa_handler = sighandler;\n    act.sa_mask = caught_signals;\n    act.sa_flags = 0;\n\n    for (i = 0; i < nsigs; i++)\n      if (sigismember (&caught_signals, sig[i]))\n        sigaction (sig[i], &act, nullptr);\n#else\n    for (i = 0; i < nsigs; i++)\n      if (signal (sig[i], SIG_IGN) != SIG_IGN)\n        {\n          signal (sig[i], sighandler);\n          siginterrupt (sig[i], 1);\n        }\n#endif\n  }\n  signal (SIGCHLD, SIG_DFL);  \n\n   \n  atexit (exit_cleanup);\n\n  key_init (&gkey);\n  gkey.sword = SIZE_MAX;\n\n  files = xnmalloc (argc, sizeof *files);\n\n  while (true)\n    {\n       \n      int oi = -1;\n\n      if (c == -1\n          || (posixly_correct && nfiles != 0\n              && ! (traditional_usage\n                    && ! checkonly\n                    && optind != argc\n                    && argv[optind][0] == '-' && argv[optind][1] == 'o'\n                    && (argv[optind][2] || optind + 1 != argc)))\n          || ((c = getopt_long (argc, argv, short_options,\n                                long_options, &oi))\n              == -1))\n        {\n          if (argc <= optind)\n            break;\n          files[nfiles++] = argv[optind++];\n        }\n      else switch (c)\n        {\n        case 1:\n          key = nullptr;\n          if (optarg[0] == '+')\n            {\n              bool minus_pos_usage = (optind != argc && argv[optind][0] == '-'\n                                      && ISDIGIT (argv[optind][1]));\n              traditional_usage |= minus_pos_usage && !posixly_correct;\n              if (traditional_usage)\n                {\n                   \n                  key = key_init (&key_buf);\n                  s = parse_field_count (optarg + 1, &key->sword, nullptr);\n                  if (s && *s == '.')\n                    s = parse_field_count (s + 1, &key->schar, nullptr);\n                  if (! (key->sword || key->schar))\n                    key->sword = SIZE_MAX;\n                  if (! s || *set_ordering (s, key, bl_start))\n                    key = nullptr;\n                  else\n                    {\n                      if (minus_pos_usage)\n                        {\n                          char const *optarg1 = argv[optind++];\n                          s = parse_field_count (optarg1 + 1, &key->eword,\n                                             N_(\"invalid number after '-'\"));\n                          if (*s == '.')\n                            s = parse_field_count (s + 1, &key->echar,\n                                               N_(\"invalid number after '.'\"));\n                          if (!key->echar && key->eword)\n                            {\n                               \n                              key->eword--;\n                            }\n                          if (*set_ordering (s, key, bl_end))\n                            badfieldspec (optarg1,\n                                      N_(\"stray character in field spec\"));\n                        }\n                      key->traditional_used = true;\n                      insertkey (key);\n                    }\n                }\n            }\n          if (! key)\n            files[nfiles++] = optarg;\n          break;\n\n        case SORT_OPTION:\n          c = XARGMATCH (\"--sort\", optarg, sort_args, sort_types);\n          FALLTHROUGH;\n        case 'b':\n        case 'd':\n        case 'f':\n        case 'g':\n        case 'h':\n        case 'i':\n        case 'M':\n        case 'n':\n        case 'r':\n        case 'R':\n        case 'V':\n          {\n            char str[2];\n            str[0] = c;\n            str[1] = '\\0';\n            set_ordering (str, &gkey, bl_both);\n          }\n          break;\n\n        case CHECK_OPTION:\n          c = (optarg\n               ? XARGMATCH (\"--check\", optarg, check_args, check_types)\n               : 'c');\n          FALLTHROUGH;\n        case 'c':\n        case 'C':\n          if (checkonly && checkonly != c)\n            incompatible_options (\"cC\");\n          checkonly = c;\n          break;\n\n        case COMPRESS_PROGRAM_OPTION:\n          if (compress_program && !STREQ (compress_program, optarg))\n            error (SORT_FAILURE, 0, _(\"multiple compress programs specified\"));\n          compress_program = optarg;\n          break;\n\n        case DEBUG_PROGRAM_OPTION:\n          debug = true;\n          break;\n\n        case FILES0_FROM_OPTION:\n          files_from = optarg;\n          break;\n\n        case 'k':\n          key = key_init (&key_buf);\n\n           \n          s = parse_field_count (optarg, &key->sword,\n                                 N_(\"invalid number at field start\"));\n          if (! key->sword--)\n            {\n               \n              badfieldspec (optarg, N_(\"field number is zero\"));\n            }\n          if (*s == '.')\n            {\n              s = parse_field_count (s + 1, &key->schar,\n                                     N_(\"invalid number after '.'\"));\n              if (! key->schar--)\n                {\n                   \n                  badfieldspec (optarg, N_(\"character offset is zero\"));\n                }\n            }\n          if (! (key->sword || key->schar))\n            key->sword = SIZE_MAX;\n          s = set_ordering (s, key, bl_start);\n          if (*s != ',')\n            {\n              key->eword = SIZE_MAX;\n              key->echar = 0;\n            }\n          else\n            {\n               \n              s = parse_field_count (s + 1, &key->eword,\n                                     N_(\"invalid number after ','\"));\n              if (! key->eword--)\n                {\n                   \n                  badfieldspec (optarg, N_(\"field number is zero\"));\n                }\n              if (*s == '.')\n                {\n                  s = parse_field_count (s + 1, &key->echar,\n                                         N_(\"invalid number after '.'\"));\n                }\n              s = set_ordering (s, key, bl_end);\n            }\n          if (*s)\n            badfieldspec (optarg, N_(\"stray character in field spec\"));\n          insertkey (key);\n          break;\n\n        case 'm':\n          mergeonly = true;\n          break;\n\n        case NMERGE_OPTION:\n          specify_nmerge (oi, c, optarg);\n          break;\n\n        case 'o':\n          if (outfile && !STREQ (outfile, optarg))\n            error (SORT_FAILURE, 0, _(\"multiple output files specified\"));\n          outfile = optarg;\n          break;\n\n        case RANDOM_SOURCE_OPTION:\n          if (random_source && !STREQ (random_source, optarg))\n            error (SORT_FAILURE, 0, _(\"multiple random sources specified\"));\n          random_source = optarg;\n          break;\n\n        case 's':\n          stable = true;\n          break;\n\n        case 'S':\n          specify_sort_size (oi, c, optarg);\n          break;\n\n        case 't':\n          {\n            char newtab = optarg[0];\n            if (! newtab)\n              error (SORT_FAILURE, 0, _(\"empty tab\"));\n            if (optarg[1])\n              {\n                if (STREQ (optarg, \"\\\\0\"))\n                  newtab = '\\0';\n                else\n                  {\n                     \n                    error (SORT_FAILURE, 0, _(\"multi-character tab %s\"),\n                           quote (optarg));\n                  }\n              }\n            if (tab != TAB_DEFAULT && tab != newtab)\n              error (SORT_FAILURE, 0, _(\"incompatible tabs\"));\n            tab = newtab;\n          }\n          break;\n\n        case 'T':\n          add_temp_dir (optarg);\n          break;\n\n        case PARALLEL_OPTION:\n          nthreads = specify_nthreads (oi, c, optarg);\n          break;\n\n        case 'u':\n          unique = true;\n          break;\n\n        case 'y':\n           \n          if (optarg == argv[optind - 1])\n            {\n              char const *p;\n              for (p = optarg; ISDIGIT (*p); p++)\n                continue;\n              optind -= (*p != '\\0');\n            }\n          break;\n\n        case 'z':\n          eolchar = 0;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          usage (SORT_FAILURE);\n        }\n    }\n\n  if (files_from)\n    {\n       \n      if (nfiles)\n        {\n          error (0, 0, _(\"extra operand %s\"), quoteaf (files[0]));\n          fprintf (stderr, \"%s\\n\",\n                   _(\"file operands cannot be combined with --files0-from\"));\n          usage (SORT_FAILURE);\n        }\n\n      FILE *stream = xfopen (files_from, \"r\");\n\n      readtokens0_init (&tok);\n\n      if (! readtokens0 (stream, &tok))\n        error (SORT_FAILURE, 0, _(\"cannot read file names from %s\"),\n               quoteaf (files_from));\n      xfclose (stream, files_from);\n\n      if (tok.n_tok)\n        {\n          free (files);\n          files = tok.tok;\n          nfiles = tok.n_tok;\n          for (size_t i = 0; i < nfiles; i++)\n            {\n              if (STREQ (files[i], \"-\"))\n                error (SORT_FAILURE, 0, _(\"when reading file names from stdin, \"\n                                          \"no file name of %s allowed\"),\n                       quoteaf (files[i]));\n              else if (files[i][0] == '\\0')\n                {\n                   \n                  unsigned long int file_number = i + 1;\n                  error (SORT_FAILURE, 0,\n                         _(\"%s:%lu: invalid zero-length file name\"),\n                         quotef (files_from), file_number);\n                }\n            }\n        }\n      else\n        error (SORT_FAILURE, 0, _(\"no input from %s\"),\n               quoteaf (files_from));\n    }\n\n   \n  for (key = keylist; key; key = key->next)\n    {\n      if (default_key_compare (key) && !key->reverse)\n        {\n          key->ignore = gkey.ignore;\n          key->translate = gkey.translate;\n          key->skipsblanks = gkey.skipsblanks;\n          key->skipeblanks = gkey.skipeblanks;\n          key->month = gkey.month;\n          key->numeric = gkey.numeric;\n          key->general_numeric = gkey.general_numeric;\n          key->human_numeric = gkey.human_numeric;\n          key->version = gkey.version;\n          key->random = gkey.random;\n          key->reverse = gkey.reverse;\n        }\n\n      need_random |= key->random;\n    }\n\n  if (!keylist && !default_key_compare (&gkey))\n    {\n      gkey_only = true;\n      insertkey (&gkey);\n      need_random |= gkey.random;\n    }\n\n  check_ordering_compatibility ();\n\n  if (debug)\n    {\n      if (checkonly || outfile)\n        {\n          static char opts[] = \"X --debug\";\n          opts[0] = (checkonly ? checkonly : 'o');\n          incompatible_options (opts);\n        }\n\n       \n\n       \n      if (locale_ok)\n        locale_ok = !! setlocale (LC_COLLATE, \"\");\n      if (! locale_ok)\n          error (0, 0, \"%s\", _(\"failed to set locale\"));\n      if (hard_LC_COLLATE)\n        error (0, 0, _(\"text ordering performed using %s sorting rules\"),\n               quote (setlocale (LC_COLLATE, nullptr)));\n      else\n        error (0, 0, \"%s\",\n               _(\"text ordering performed using simple byte comparison\"));\n\n      key_warnings (&gkey, gkey_only);\n    }\n\n  reverse = gkey.reverse;\n\n  if (need_random)\n    random_md5_state_init (random_source);\n\n  if (temp_dir_count == 0)\n    {\n      char const *tmp_dir = getenv (\"TMPDIR\");\n      add_temp_dir (tmp_dir ? tmp_dir : DEFAULT_TMPDIR);\n    }\n\n  if (nfiles == 0)\n    {\n      nfiles = 1;\n      free (files);\n      files = xmalloc (sizeof *files);\n      *files = (char *) \"-\";\n    }\n\n   \n  if (0 < sort_size)\n    sort_size = MAX (sort_size, MIN_SORT_SIZE);\n\n  if (checkonly)\n    {\n      if (nfiles > 1)\n        error (SORT_FAILURE, 0, _(\"extra operand %s not allowed with -%c\"),\n               quoteaf (files[1]), checkonly);\n\n      if (outfile)\n        {\n          static char opts[] = {0, 'o', 0};\n          opts[0] = checkonly;\n          incompatible_options (opts);\n        }\n\n       \n      exit (check (files[0], checkonly) ? EXIT_SUCCESS : SORT_OUT_OF_ORDER);\n    }\n\n   \n  check_inputs (files, nfiles);\n\n   \n  check_output (outfile);\n\n  if (mergeonly)\n    {\n      struct sortfile *sortfiles = xcalloc (nfiles, sizeof *sortfiles);\n\n      for (size_t i = 0; i < nfiles; ++i)\n        sortfiles[i].name = files[i];\n\n      merge (sortfiles, 0, nfiles, outfile);\n    }\n  else\n    {\n      if (!nthreads)\n        {\n          unsigned long int np = num_processors (NPROC_CURRENT_OVERRIDABLE);\n          nthreads = MIN (np, DEFAULT_MAX_THREADS);\n        }\n\n       \n      size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));\n      nthreads = MIN (nthreads, nthreads_max);\n\n      sort (files, nfiles, outfile, nthreads);\n    }\n\n  if (have_read_stdin && fclose (stdin) == EOF)\n    sort_die (_(\"close failed\"), \"-\");\n\n  main_exit (EXIT_SUCCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}