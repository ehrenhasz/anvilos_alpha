{
  "module_name": "du.c",
  "hash_id": "54a27484f7e785756e02addbee83bf50e079849db1c8fd87ecb9bdc19dce530d",
  "original_prompt": "Ingested from coreutils-9.4/src/du.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include \"system.h\"\n#include \"argmatch.h\"\n#include \"argv-iter.h\"\n#include \"assure.h\"\n#include \"di-set.h\"\n#include \"exclude.h\"\n#include \"fprintftime.h\"\n#include \"human.h\"\n#include \"mountlist.h\"\n#include \"quote.h\"\n#include \"stat-size.h\"\n#include \"stat-time.h\"\n#include \"stdio--.h\"\n#include \"xfts.h\"\n#include \"xstrtol.h\"\n#include \"xstrtol-error.h\"\n\nextern bool fts_debug;\n\n \n#define PROGRAM_NAME \"du\"\n\n#define AUTHORS \\\n  proper_name_lite (\"Torbjorn Granlund\", \"Torbj\\303\\266rn Granlund\"), \\\n  proper_name (\"David MacKenzie\"), \\\n  proper_name (\"Paul Eggert\"), \\\n  proper_name (\"Jim Meyering\")\n\n#if DU_DEBUG\n# define FTS_CROSS_CHECK(Fts) fts_cross_check (Fts)\n#else\n# define FTS_CROSS_CHECK(Fts)\n#endif\n\n \nstatic struct di_set *di_files;\n\n \nstatic struct di_set *di_mnt;\n\n \nstatic size_t prev_level;\n\n \nstruct duinfo\n{\n   \n  uintmax_t size;\n\n   \n  uintmax_t inodes;\n\n   \n  struct timespec tmax;\n};\n\n \nstatic inline void\nduinfo_init (struct duinfo *a)\n{\n  a->size = 0;\n  a->inodes = 0;\n  a->tmax.tv_sec = TYPE_MINIMUM (time_t);\n  a->tmax.tv_nsec = -1;\n}\n\n \nstatic inline void\nduinfo_set (struct duinfo *a, uintmax_t size, struct timespec tmax)\n{\n  a->size = size;\n  a->inodes = 1;\n  a->tmax = tmax;\n}\n\n \nstatic inline void\nduinfo_add (struct duinfo *a, struct duinfo const *b)\n{\n  uintmax_t sum = a->size + b->size;\n  a->size = a->size <= sum ? sum : UINTMAX_MAX;\n  a->inodes = a->inodes + b->inodes;\n  if (timespec_cmp (a->tmax, b->tmax) < 0)\n    a->tmax = b->tmax;\n}\n\n \nstruct dulevel\n{\n   \n  struct duinfo ent;\n\n   \n  struct duinfo subdir;\n};\n\n \nstatic bool opt_all = false;\n\n \nstatic bool apparent_size = false;\n\n \nstatic bool opt_count_all = false;\n\n \nstatic bool hash_all;\n\n \nstatic bool opt_nul_terminate_output = false;\n\n \nstatic bool print_grand_total = false;\n\n \nstatic bool opt_separate_dirs = false;\n\n \nstatic idx_t max_depth = IDX_MAX;\n\n \nstatic intmax_t opt_threshold = 0;\n\n \nstatic int human_output_opts;\n\n \nstatic bool opt_inodes = false;\n\n \nstatic bool opt_time = false;\n\n \n\nenum time_type\n  {\n    time_mtime,\t\t\t \n    time_ctime,\n    time_atime\n  };\n\nstatic enum time_type time_type = time_mtime;\n\n \nstatic char const *time_style = nullptr;\n\n \nstatic char const *time_format = nullptr;\n\n \nstatic timezone_t localtz;\n\n \nstatic uintmax_t output_block_size;\n\n \nstatic struct exclude *exclude;\n\n \nstatic struct duinfo tot_dui;\n\n#define IS_DIR_TYPE(Type)\t\\\n  ((Type) == FTS_DP\t\t\\\n   || (Type) == FTS_DNR)\n\n \nenum\n{\n  APPARENT_SIZE_OPTION = CHAR_MAX + 1,\n  EXCLUDE_OPTION,\n  FILES0_FROM_OPTION,\n  HUMAN_SI_OPTION,\n  FTS_DEBUG,\n  TIME_OPTION,\n  TIME_STYLE_OPTION,\n  INODES_OPTION\n};\n\nstatic struct option const long_options[] =\n{\n  {\"all\", no_argument, nullptr, 'a'},\n  {\"apparent-size\", no_argument, nullptr, APPARENT_SIZE_OPTION},\n  {\"block-size\", required_argument, nullptr, 'B'},\n  {\"bytes\", no_argument, nullptr, 'b'},\n  {\"count-links\", no_argument, nullptr, 'l'},\n   \n  {\"dereference\", no_argument, nullptr, 'L'},\n  {\"dereference-args\", no_argument, nullptr, 'D'},\n  {\"exclude\", required_argument, nullptr, EXCLUDE_OPTION},\n  {\"exclude-from\", required_argument, nullptr, 'X'},\n  {\"files0-from\", required_argument, nullptr, FILES0_FROM_OPTION},\n  {\"human-readable\", no_argument, nullptr, 'h'},\n  {\"inodes\", no_argument, nullptr, INODES_OPTION},\n  {\"si\", no_argument, nullptr, HUMAN_SI_OPTION},\n  {\"max-depth\", required_argument, nullptr, 'd'},\n  {\"null\", no_argument, nullptr, '0'},\n  {\"no-dereference\", no_argument, nullptr, 'P'},\n  {\"one-file-system\", no_argument, nullptr, 'x'},\n  {\"separate-dirs\", no_argument, nullptr, 'S'},\n  {\"summarize\", no_argument, nullptr, 's'},\n  {\"total\", no_argument, nullptr, 'c'},\n  {\"threshold\", required_argument, nullptr, 't'},\n  {\"time\", optional_argument, nullptr, TIME_OPTION},\n  {\"time-style\", required_argument, nullptr, TIME_STYLE_OPTION},\n  {GETOPT_HELP_OPTION_DECL},\n  {GETOPT_VERSION_OPTION_DECL},\n  {nullptr, 0, nullptr, 0}\n};\n\nstatic char const *const time_args[] =\n{\n  \"atime\", \"access\", \"use\", \"ctime\", \"status\", nullptr\n};\nstatic enum time_type const time_types[] =\n{\n  time_atime, time_atime, time_atime, time_ctime, time_ctime\n};\nARGMATCH_VERIFY (time_args, time_types);\n\n \nenum time_style\n  {\n    full_iso_time_style,        \n    long_iso_time_style,        \n    iso_time_style\t        \n  };\n\nstatic char const *const time_style_args[] =\n{\n  \"full-iso\", \"long-iso\", \"iso\", nullptr\n};\nstatic enum time_style const time_style_types[] =\n{\n  full_iso_time_style, long_iso_time_style, iso_time_style\n};\nARGMATCH_VERIFY (time_style_args, time_style_types);\n\nvoid\nusage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    emit_try_help ();\n  else\n    {\n      printf (_(\"\\\nUsage: %s [OPTION]... [FILE]...\\n\\\n  or:  %s [OPTION]... --files0-from=F\\n\\\n\"), program_name, program_name);\n      fputs (_(\"\\\nSummarize device usage of the set of FILEs, recursively for directories.\\n\\\n\"), stdout);\n\n      emit_mandatory_arg_note ();\n\n      fputs (_(\"\\\n  -0, --null            end each output line with NUL, not newline\\n\\\n  -a, --all             write counts for all files, not just directories\\n\\\n      --apparent-size   print apparent sizes rather than device usage; although\\\n\\n\\\n                          the apparent size is usually smaller, it may be\\n\\\n                          larger due to holes in ('sparse') files, internal\\n\\\n                          fragmentation, indirect blocks, and the like\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\\n\\\n                           '-BM' prints sizes in units of 1,048,576 bytes;\\n\\\n                           see SIZE format below\\n\\\n  -b, --bytes           equivalent to '--apparent-size --block-size=1'\\n\\\n  -c, --total           produce a grand total\\n\\\n  -D, --dereference-args  dereference only symlinks that are listed on the\\n\\\n                          command line\\n\\\n  -d, --max-depth=N     print the total for a directory (or file, with --all)\\n\\\n                          only if it is N or fewer levels below the command\\n\\\n                          line argument;  --max-depth=0 is the same as\\n\\\n                          --summarize\\n\\\n\"), stdout);\n      fputs (_(\"\\\n      --files0-from=F   summarize device usage of the\\n\\\n                          NUL-terminated file names specified in file F;\\n\\\n                          if F is -, then read names from standard input\\n\\\n  -H                    equivalent to --dereference-args (-D)\\n\\\n  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\\\n\\n\\\n      --inodes          list inode usage information instead of block usage\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -k                    like --block-size=1K\\n\\\n  -L, --dereference     dereference all symbolic links\\n\\\n  -l, --count-links     count sizes many times if hard linked\\n\\\n  -m                    like --block-size=1M\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -P, --no-dereference  don't follow any symbolic links (this is the default)\\n\\\n  -S, --separate-dirs   for directories do not include size of subdirectories\\n\\\n      --si              like -h, but use powers of 1000 not 1024\\n\\\n  -s, --summarize       display only a total for each argument\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\\n\\\n                          or entries greater than SIZE if negative\\n\\\n      --time            show time of the last modification of any file in the\\n\\\n                          directory, or any of its subdirectories\\n\\\n      --time=WORD       show time as WORD instead of modification time:\\n\\\n                          atime, access, use, ctime or status\\n\\\n      --time-style=STYLE  show times using STYLE, which can be:\\n\\\n                            full-iso, long-iso, iso, or +FORMAT;\\n\\\n                            FORMAT is interpreted like in 'date'\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\\n\\\n      --exclude=PATTERN    exclude files that match PATTERN\\n\\\n  -x, --one-file-system    skip directories on different file systems\\n\\\n\"), stdout);\n      fputs (HELP_OPTION_DESCRIPTION, stdout);\n      fputs (VERSION_OPTION_DESCRIPTION, stdout);\n      emit_blocksize_note (\"DU\");\n      emit_size_note ();\n      emit_ancillary_info (PROGRAM_NAME);\n    }\n  exit (status);\n}\n\n/* Try to insert the INO/DEV pair into DI_SET.\n   Return true if the pair is successfully inserted,\n   false if the pair was already there.  */\nstatic bool\nhash_ins (struct di_set *di_set, ino_t ino, dev_t dev)\n{\n  int inserted = di_set_insert (di_set, dev, ino);\n  if (inserted < 0)\n    xalloc_die ();\n  return inserted;\n}\n\n/* FIXME: this code is nearly identical to code in date.c  */\n/* Display the date and time in WHEN according to the format specified\n   in FORMAT.  */\n\nstatic void\nshow_date (char const *format, struct timespec when, timezone_t tz)\n{\n  struct tm tm;\n  if (localtime_rz (tz, &when.tv_sec, &tm))\n    fprintftime (stdout, format, &tm, tz, when.tv_nsec);\n  else\n    {\n      char buf[INT_BUFSIZE_BOUND (intmax_t)];\n      char *when_str = timetostr (when.tv_sec, buf);\n      error (0, 0, _(\"time %s is out of range\"), quote (when_str));\n      fputs (when_str, stdout);\n    }\n}\n\n/* Print N_BYTES.  Convert it to a readable value before printing.  */\n\nstatic void\nprint_only_size (uintmax_t n_bytes)\n{\n  char buf[LONGEST_HUMAN_READABLE + 1];\n  fputs ((n_bytes == UINTMAX_MAX\n          ? _(\"Infinity\")\n          : human_readable (n_bytes, buf, human_output_opts,\n                            1, output_block_size)),\n         stdout);\n}\n\n/* Print size (and optionally time) indicated by *PDUI, followed by STRING.  */\n\nstatic void\nprint_size (const struct duinfo *pdui, char const *string)\n{\n  print_only_size (opt_inodes\n                   ? pdui->inodes\n                   : pdui->size);\n\n  if (opt_time)\n    {\n      putchar ('\\t');\n      show_date (time_format, pdui->tmax, localtz);\n    }\n  printf (\"\\t%s%c\", string, opt_nul_terminate_output ? '\\0' : '\\n');\n  fflush (stdout);\n}\n\n/* Fill the di_mnt set with local mount point dev/ino pairs.  */\n\nstatic void\nfill_mount_table (void)\n{\n  struct mount_entry *mnt_ent = read_file_system_list (false);\n  while (mnt_ent)\n    {\n      struct mount_entry *mnt_free;\n      if (!mnt_ent->me_remote && !mnt_ent->me_dummy)\n        {\n          struct stat buf;\n          if (!stat (mnt_ent->me_mountdir, &buf))\n            hash_ins (di_mnt, buf.st_ino, buf.st_dev);\n          else\n            {\n              /* Ignore stat failure.  False positives are too common.\n                 E.g., \"Permission denied\" on /run/user/<name>/gvfs.  */\n            }\n        }\n\n      mnt_free = mnt_ent;\n      mnt_ent = mnt_ent->me_next;\n      free_mount_entry (mnt_free);\n    }\n}\n\n/* This function checks whether any of the directories in the cycle that\n   fts detected is a mount point.  */\n\nstatic bool\nmount_point_in_fts_cycle (FTSENT const *ent)\n{\n  FTSENT const *cycle_ent = ent->fts_cycle;\n\n  if (!di_mnt)\n    {\n      /* Initialize the set of dev,inode pairs.  */\n      di_mnt = di_set_alloc ();\n      if (!di_mnt)\n        xalloc_die ();\n\n      fill_mount_table ();\n    }\n\n  while (ent && ent != cycle_ent)\n    {\n      if (di_set_lookup (di_mnt, ent->fts_statp->st_dev,\n                         ent->fts_statp->st_ino) > 0)\n        {\n          return true;\n        }\n      ent = ent->fts_parent;\n    }\n\n  return false;\n}\n\n/* This function is called once for every file system object that fts\n   encounters.  fts does a depth-first traversal.  This function knows\n   that and accumulates per-directory totals based on changes in\n   the depth of the current entry.  It returns true on success.  */\n\nstatic bool\nprocess_file (FTS *fts, FTSENT *ent)\n{\n  bool ok = true;\n  struct duinfo dui;\n  struct duinfo dui_to_print;\n  size_t level;\n  static size_t n_alloc;\n  /* First element of the structure contains:\n     The sum of the sizes of all entries in the single directory\n     at the corresponding level.  Although this does include the sizes\n     corresponding to each subdirectory, it does not include the size of\n     any file in a subdirectory. Also corresponding last modified date.\n     Second element of the structure contains:\n     The sum of the sizes of all entries in the hierarchy at or below the\n     directory at the specified level.  */\n  static struct dulevel *dulvl;\n\n  char const *file = ent->fts_path;\n  const struct stat *sb = ent->fts_statp;\n  int info = ent->fts_info;\n\n  if (info == FTS_DNR)\n    {\n      /* An error occurred, but the size is known, so count it.  */\n      error (0, ent->fts_errno, _(\"cannot read directory %s\"), quoteaf (file));\n      ok = false;\n    }\n  else if (info != FTS_DP)\n    {\n      bool excluded = excluded_file_name (exclude, file);\n      if (! excluded)\n        {\n          /* Make the stat buffer *SB valid, or fail noisily.  */\n\n          if (info == FTS_NSOK)\n            {\n              fts_set (fts, ent, FTS_AGAIN);\n              MAYBE_UNUSED FTSENT const *e = fts_read (fts);\n              affirm (e == ent);\n              info = ent->fts_info;\n            }\n\n          if (info == FTS_NS || info == FTS_SLNONE)\n            {\n              error (0, ent->fts_errno, _(\"cannot access %s\"), quoteaf (file));\n              return false;\n            }\n\n          /* The --one-file-system (-x) option cannot exclude anything\n             specified on the command-line.  By definition, it can exclude\n             a file or directory only when its device number is different\n             from that of its just-processed parent directory, and du does\n             not process the parent of a command-line argument.  */\n          if (fts->fts_options & FTS_XDEV\n              && FTS_ROOTLEVEL < ent->fts_level\n              && fts->fts_dev != sb->st_dev)\n            excluded = true;\n        }\n\n      if (excluded\n          || (! opt_count_all\n              && (hash_all || (! S_ISDIR (sb->st_mode) && 1 < sb->st_nlink))\n              && ! hash_ins (di_files, sb->st_ino, sb->st_dev)))\n        {\n          /* If ignoring a directory in preorder, skip its children.\n             Ignore the next fts_read output too, as it's a postorder\n             visit to the same directory.  */\n          if (info == FTS_D)\n            {\n              fts_set (fts, ent, FTS_SKIP);\n              MAYBE_UNUSED FTSENT const *e = fts_read (fts);\n              affirm (e == ent);\n            }\n\n          return true;\n        }\n\n      switch (info)\n        {\n        case FTS_D:\n          return true;\n\n        case FTS_ERR:\n          /* An error occurred, but the size is known, so count it.  */\n          error (0, ent->fts_errno, \"%s\", quotef (file));\n          ok = false;\n          break;\n\n        case FTS_DC:\n          /* If not following symlinks and not a (bind) mount point.  */\n          if (cycle_warning_required (fts, ent)\n              && ! mount_point_in_fts_cycle (ent))\n            {\n              emit_cycle_warning (file);\n              return false;\n            }\n          return true;\n        }\n    }\n\n  duinfo_set (&dui,\n              (apparent_size\n               ? (usable_st_size (sb) ? MAX (0, sb->st_size) : 0)\n               : (uintmax_t) ST_NBLOCKS (*sb) * ST_NBLOCKSIZE),\n              (time_type == time_mtime ? get_stat_mtime (sb)\n               : time_type == time_atime ? get_stat_atime (sb)\n               : get_stat_ctime (sb)));\n\n  level = ent->fts_level;\n  dui_to_print = dui;\n\n  if (n_alloc == 0)\n    {\n      n_alloc = level + 10;\n      dulvl = xcalloc (n_alloc, sizeof *dulvl);\n    }\n  else\n    {\n      if (level == prev_level)\n        {\n          /* This is usually the most common case.  Do nothing.  */\n        }\n      else if (level > prev_level)\n        {\n          /* Descending the hierarchy.\n             Clear the accumulators for *all* levels between prev_level\n             and the current one.  The depth may change dramatically,\n             e.g., from 1 to 10.  */\n\n          if (n_alloc <= level)\n            {\n              dulvl = xnrealloc (dulvl, level, 2 * sizeof *dulvl);\n              n_alloc = level * 2;\n            }\n\n          for (size_t i = prev_level + 1; i <= level; i++)\n            {\n              duinfo_init (&dulvl[i].ent);\n              duinfo_init (&dulvl[i].subdir);\n            }\n        }\n      else /* level < prev_level */\n        {\n          /* Ascending the hierarchy.\n             Process a directory only after all entries in that\n             directory have been processed.  When the depth decreases,\n             propagate sums from the children (prev_level) to the parent.\n             Here, the current level is always one smaller than the\n             previous one.  */\n          affirm (level == prev_level - 1);\n          duinfo_add (&dui_to_print, &dulvl[prev_level].ent);\n          if (!opt_separate_dirs)\n            duinfo_add (&dui_to_print, &dulvl[prev_level].subdir);\n          duinfo_add (&dulvl[level].subdir, &dulvl[prev_level].ent);\n          duinfo_add (&dulvl[level].subdir, &dulvl[prev_level].subdir);\n        }\n    }\n\n  prev_level = level;\n\n  /* Let the size of a directory entry contribute to the total for the\n     containing directory, unless --separate-dirs (-S) is specified.  */\n  if (! (opt_separate_dirs && IS_DIR_TYPE (info)))\n    duinfo_add (&dulvl[level].ent, &dui);\n\n  /* Even if this directory is unreadable or we can't chdir into it,\n     do let its size contribute to the total. */\n  duinfo_add (&tot_dui, &dui);\n\n  if ((IS_DIR_TYPE (info) && level <= max_depth)\n      || (opt_all && level <= max_depth)\n      || level == 0)\n    {\n      /* Print or elide this entry according to the --threshold option.  */\n      uintmax_t v = opt_inodes ? dui_to_print.inodes : dui_to_print.size;\n      if (opt_threshold < 0\n          ? v <= -opt_threshold\n          : v >= opt_threshold)\n        print_size (&dui_to_print, file);\n    }\n\n  return ok;\n}\n\n/* Recursively print the sizes of the directories (and, if selected, files)\n   named in FILES, the last entry of which is null.\n   BIT_FLAGS controls how fts works.\n   Return true if successful.  */\n\nstatic bool\ndu_files (char **files, int bit_flags)\n{\n  bool ok = true;\n\n  if (*files)\n    {\n      FTS *fts = xfts_open (files, bit_flags, nullptr);\n\n      while (true)\n        {\n          FTSENT *ent;\n\n          ent = fts_read (fts);\n          if (ent == nullptr)\n            {\n              if (errno != 0)\n                {\n                  error (0, errno, _(\"fts_read failed: %s\"),\n                         quotef (fts->fts_path));\n                  ok = false;\n                }\n\n              /* When exiting this loop early, be careful to reset the\n                 global, prev_level, used in process_file.  Otherwise, its\n                 (level == prev_level - 1) assertion could fail.  */\n              prev_level = 0;\n              break;\n            }\n          FTS_CROSS_CHECK (fts);\n\n          ok &= process_file (fts, ent);\n        }\n\n      if (fts_close (fts) != 0)\n        {\n          error (0, errno, _(\"fts_close failed\"));\n          ok = false;\n        }\n    }\n\n  return ok;\n}\n\nint\nmain (int argc, char **argv)\n{\n  char *cwd_only[2];\n  bool max_depth_specified = false;\n  bool ok = true;\n  char *files_from = nullptr;\n\n  /* Bit flags that control how fts works.  */\n  int bit_flags = FTS_NOSTAT;\n\n  /* Select one of the three FTS_ options that control if/when\n     to follow a symlink.  */\n  int symlink_deref_bits = FTS_PHYSICAL;\n\n  /* If true, display only a total for each argument. */\n  bool opt_summarize_only = false;\n\n  cwd_only[0] = bad_cast (\".\");\n  cwd_only[1] = nullptr;\n\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  atexit (close_stdout);\n\n  exclude = new_exclude ();\n\n  human_options (getenv (\"DU_BLOCK_SIZE\"),\n                 &human_output_opts, &output_block_size);\n\n  while (true)\n    {\n      int oi = -1;\n      int c = getopt_long (argc, argv, \"0abd:chHklmst:xB:DLPSX:\",\n                           long_options, &oi);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n#if DU_DEBUG\n        case FTS_DEBUG:\n          fts_debug = true;\n          break;\n#endif\n\n        case '0':\n          opt_nul_terminate_output = true;\n          break;\n\n        case 'a':\n          opt_all = true;\n          break;\n\n        case APPARENT_SIZE_OPTION:\n          apparent_size = true;\n          break;\n\n        case 'b':\n          apparent_size = true;\n          human_output_opts = 0;\n          output_block_size = 1;\n          break;\n\n        case 'c':\n          print_grand_total = true;\n          break;\n\n        case 'h':\n          human_output_opts = human_autoscale | human_SI | human_base_1024;\n          output_block_size = 1;\n          break;\n\n        case HUMAN_SI_OPTION:\n          human_output_opts = human_autoscale | human_SI;\n          output_block_size = 1;\n          break;\n\n        case 'k':\n          human_output_opts = 0;\n          output_block_size = 1024;\n          break;\n\n        case 'd':\t\t/* --max-depth=N */\n          {\n            intmax_t tmp;\n            if (xstrtoimax (optarg, nullptr, 0, &tmp, \"\") == LONGINT_OK\n                && tmp <= IDX_MAX)\n              {\n                max_depth_specified = true;\n                max_depth = tmp;\n              }\n            else\n              {\n                error (0, 0, _(\"invalid maximum depth %s\"),\n                       quote (optarg));\n                ok = false;\n              }\n          }\n          break;\n\n        case 'm':\n          human_output_opts = 0;\n          output_block_size = 1024 * 1024;\n          break;\n\n        case 'l':\n          opt_count_all = true;\n          break;\n\n        case 's':\n          opt_summarize_only = true;\n          break;\n\n        case 't':\n          {\n            enum strtol_error e;\n            e = xstrtoimax (optarg, nullptr, 0, &opt_threshold,\n                            \"kKmMGTPEZYRQ0\");\n            if (e != LONGINT_OK)\n              xstrtol_fatal (e, oi, c, long_options, optarg);\n            if (opt_threshold == 0 && *optarg == '-')\n              {\n                /* Do not allow -0, as this wouldn't make sense anyway.  */\n                error (EXIT_FAILURE, 0, _(\"invalid --threshold argument '-0'\"));\n              }\n          }\n          break;\n\n        case 'x':\n          bit_flags |= FTS_XDEV;\n          break;\n\n        case 'B':\n          {\n            enum strtol_error e = human_options (optarg, &human_output_opts,\n                                                 &output_block_size);\n            if (e != LONGINT_OK)\n              xstrtol_fatal (e, oi, c, long_options, optarg);\n          }\n          break;\n\n        case 'H':  /* NOTE: before 2008-12, -H was equivalent to --si.  */\n        case 'D':\n          symlink_deref_bits = FTS_COMFOLLOW | FTS_PHYSICAL;\n          break;\n\n        case 'L': /* --dereference */\n          symlink_deref_bits = FTS_LOGICAL;\n          break;\n\n        case 'P': /* --no-dereference */\n          symlink_deref_bits = FTS_PHYSICAL;\n          break;\n\n        case 'S':\n          opt_separate_dirs = true;\n          break;\n\n        case 'X':\n          if (add_exclude_file (add_exclude, exclude, optarg,\n                                EXCLUDE_WILDCARDS, '\\n'))\n            {\n              error (0, errno, \"%s\", quotef (optarg));\n              ok = false;\n            }\n          break;\n\n        case FILES0_FROM_OPTION:\n          files_from = optarg;\n          break;\n\n        case EXCLUDE_OPTION:\n          add_exclude (exclude, optarg, EXCLUDE_WILDCARDS);\n          break;\n\n        case INODES_OPTION:\n          opt_inodes = true;\n          break;\n\n        case TIME_OPTION:\n          opt_time = true;\n          time_type =\n            (optarg\n             ? XARGMATCH (\"--time\", optarg, time_args, time_types)\n             : time_mtime);\n          localtz = tzalloc (getenv (\"TZ\"));\n          break;\n\n        case TIME_STYLE_OPTION:\n          time_style = optarg;\n          break;\n\n        case_GETOPT_HELP_CHAR;\n\n        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);\n\n        default:\n          ok = false;\n        }\n    }\n\n  if (!ok)\n    usage (EXIT_FAILURE);\n\n  if (opt_all && opt_summarize_only)\n    {\n      error (0, 0, _(\"cannot both summarize and show all entries\"));\n      usage (EXIT_FAILURE);\n    }\n\n  if (opt_summarize_only && max_depth_specified && max_depth == 0)\n    {\n      error (0, 0,\n             _(\"warning: summarizing is the same as using --max-depth=0\"));\n    }\n\n  if (opt_summarize_only && max_depth_specified && max_depth != 0)\n    {\n      error (0, 0, _(\"warning: summarizing conflicts with --max-depth=%td\"),\n             max_depth);\n      usage (EXIT_FAILURE);\n    }\n\n  if (opt_summarize_only)\n    max_depth = 0;\n\n  if (opt_inodes)\n    {\n      if (apparent_size)\n        {\n          error (0, 0, _(\"warning: options --apparent-size and -b are \"\n                         \"ineffective with --inodes\"));\n        }\n      output_block_size = 1;\n    }\n\n  /* Process time style if printing last times.  */\n  if (opt_time)\n    {\n      if (! time_style)\n        {\n          time_style = getenv (\"TIME_STYLE\");\n\n          /* Ignore TIMESTYLE=\"locale\", for compatibility with ls.  */\n          if (! time_style || STREQ (time_style, \"locale\"))\n            time_style = \"long-iso\";\n          else if (*time_style == '+')\n            {\n              /* Ignore anything after a newline, for compatibility\n                 with ls.  */\n              char *p = strchr (time_style, '\\n');\n              if (p)\n                *p = '\\0';\n            }\n          else\n            {\n              /* Ignore \"posix-\" prefix, for compatibility with ls.  */\n              static char const posix_prefix[] = \"posix-\";\n              static const size_t prefix_len = sizeof posix_prefix - 1;\n              while (STREQ_LEN (time_style, posix_prefix, prefix_len))\n                time_style += prefix_len;\n            }\n        }\n\n      if (*time_style == '+')\n        time_format = time_style + 1;\n      else\n        {\n          switch (XARGMATCH (\"time style\", time_style,\n                             time_style_args, time_style_types))\n            {\n            case full_iso_time_style:\n              time_format = \"%Y-%m-%d %H:%M:%S.%N %z\";\n              break;\n\n            case long_iso_time_style:\n              time_format = \"%Y-%m-%d %H:%M\";\n              break;\n\n            case iso_time_style:\n              time_format = \"%Y-%m-%d\";\n              break;\n            }\n        }\n    }\n\n  struct argv_iterator *ai;\n  if (files_from)\n    {\n      /* When using --files0-from=F, you may not specify any files\n         on the command-line.  */\n      if (optind < argc)\n        {\n          error (0, 0, _(\"extra operand %s\"), quote (argv[optind]));\n          fprintf (stderr, \"%s\\n\",\n                   _(\"file operands cannot be combined with --files0-from\"));\n          usage (EXIT_FAILURE);\n        }\n\n      if (! (STREQ (files_from, \"-\") || freopen (files_from, \"r\", stdin)))\n        error (EXIT_FAILURE, errno, _(\"cannot open %s for reading\"),\n               quoteaf (files_from));\n\n      ai = argv_iter_init_stream (stdin);\n\n      /* It's not easy here to count the arguments, so assume the\n         worst.  */\n      hash_all = true;\n    }\n  else\n    {\n      char **files = (optind < argc ? argv + optind : cwd_only);\n      ai = argv_iter_init_argv (files);\n\n      /* Hash all dev,ino pairs if there are multiple arguments, or if\n         following non-command-line symlinks, because in either case a\n         file with just one hard link might be seen more than once.  */\n      hash_all = (optind + 1 < argc || symlink_deref_bits == FTS_LOGICAL);\n    }\n\n  if (!ai)\n    xalloc_die ();\n\n  /* Initialize the set of dev,inode pairs.  */\n  di_files = di_set_alloc ();\n  if (!di_files)\n    xalloc_die ();\n\n  /* If not hashing everything, process_file won't find cycles on its\n     own, so ask fts_read to check for them accurately.  */\n  if (opt_count_all || ! hash_all)\n    bit_flags |= FTS_TIGHT_CYCLE_CHECK;\n\n  bit_flags |= symlink_deref_bits;\n  static char *temp_argv[] = { nullptr, nullptr };\n\n  while (true)\n    {\n      bool skip_file = false;\n      enum argv_iter_err ai_err;\n      char *file_name = argv_iter (ai, &ai_err);\n      if (!file_name)\n        {\n          switch (ai_err)\n            {\n            case AI_ERR_EOF:\n              goto argv_iter_done;\n            case AI_ERR_READ:\n              error (0, errno, _(\"%s: read error\"),\n                     quotef (files_from));\n              ok = false;\n              goto argv_iter_done;\n            case AI_ERR_MEM:\n              xalloc_die ();\n            default:\n              affirm (!\"unexpected error code from argv_iter\");\n            }\n        }\n      if (files_from && STREQ (files_from, \"-\") && STREQ (file_name, \"-\"))\n        {\n          /* Give a better diagnostic in an unusual case:\n             printf - | du --files0-from=- */\n          error (0, 0, _(\"when reading file names from stdin, \"\n                         \"no file name of %s allowed\"),\n                 quoteaf (file_name));\n          skip_file = true;\n        }\n\n      /* Report and skip any empty file names before invoking fts.\n         This works around a glitch in fts, which fails immediately\n         (without looking at the other file names) when given an empty\n         file name.  */\n      if (!file_name[0])\n        {\n          /* Diagnose a zero-length file name.  When it's one\n             among many, knowing the record number may help.\n             FIXME: currently print the record number only with\n             --files0-from=FILE.  Maybe do it for argv, too?  */\n          if (files_from == nullptr)\n            error (0, 0, \"%s\", _(\"invalid zero-length file name\"));\n          else\n            {\n              /* Using the standard 'filename:line-number:' prefix here is\n                 not totally appropriate, since NUL is the separator, not NL,\n                 but it might be better than nothing.  */\n              idx_t file_number = argv_iter_n_args (ai);\n              error (0, 0, \"%s:%td: %s\", quotef (files_from),\n                     file_number, _(\"invalid zero-length file name\"));\n            }\n          skip_file = true;\n        }\n\n      if (skip_file)\n        ok = false;\n      else\n        {\n          temp_argv[0] = file_name;\n          ok &= du_files (temp_argv, bit_flags);\n        }\n    }\n argv_iter_done:\n\n  argv_iter_free (ai);\n  di_set_free (di_files);\n  if (di_mnt)\n    di_set_free (di_mnt);\n\n  if (files_from && (ferror (stdin) || fclose (stdin) != 0) && ok)\n    error (EXIT_FAILURE, 0, _(\"error reading %s\"), quoteaf (files_from));\n\n  if (print_grand_total)\n    print_size (&tot_dui, _(\"total\"));\n\n  return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}