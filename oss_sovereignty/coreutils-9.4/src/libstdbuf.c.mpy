{
  "module_name": "libstdbuf.c",
  "hash_id": "d9484eaec7314c55faafe99f4398a81e4eeacc8e75899935135bec81dbd31396",
  "original_prompt": "Ingested from coreutils-9.4/src/libstdbuf.c",
  "human_readable_source": " \n\n#include <config.h>\n#include <stdio.h>\n#include <stdint.h>\n#include \"system.h\"\n\n \n#undef fprintf\n#undef free\n#undef malloc\n#undef strtoumax\n\n \n\nstatic char const *\nfileno_to_name (const int fd)\n{\n  char const *ret = nullptr;\n\n  switch (fd)\n    {\n    case 0:\n      ret = \"stdin\";\n      break;\n    case 1:\n      ret = \"stdout\";\n      break;\n    case 2:\n      ret = \"stderr\";\n      break;\n    default:\n      ret = \"unknown\";\n      break;\n    }\n\n  return ret;\n}\n\nstatic void\napply_mode (FILE *stream, char const *mode)\n{\n  char *buf = nullptr;\n  int setvbuf_mode;\n  uintmax_t size = 0;\n\n  if (*mode == '0')\n    setvbuf_mode = _IONBF;\n  else if (*mode == 'L')\n    setvbuf_mode = _IOLBF;       \n  else\n    {\n      setvbuf_mode = _IOFBF;\n      char *mode_end;\n      size = strtoumax (mode, &mode_end, 10);\n      if (size == 0 || *mode_end)\n        {\n          fprintf (stderr, _(\"invalid buffering mode %s for %s\\n\"),\n                   mode, fileno_to_name (fileno (stream)));\n          return;\n        }\n\n      buf = size <= SIZE_MAX ? malloc (size) : nullptr;\n      if (!buf)\n        {\n           \n          fprintf (stderr,\n                   _(\"failed to allocate a %\" PRIuMAX\n                     \" byte stdio buffer\\n\"),\n                   size);\n          return;\n        }\n       \n    }\n\n  if (setvbuf (stream, buf, setvbuf_mode, size) != 0)\n    {\n      fprintf (stderr, _(\"could not set buffering of %s to mode %s\\n\"),\n               fileno_to_name (fileno (stream)), mode);\n      free (buf);\n    }\n}\n\n \nstatic void __attribute ((constructor))\nstdbuf (void)\n{\n  char *e_mode = getenv (\"_STDBUF_E\");\n  char *i_mode = getenv (\"_STDBUF_I\");\n  char *o_mode = getenv (\"_STDBUF_O\");\n  if (e_mode)  \n    apply_mode (stderr, e_mode);\n  if (i_mode)\n    apply_mode (stdin, i_mode);\n  if (o_mode)\n    apply_mode (stdout, o_mode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}