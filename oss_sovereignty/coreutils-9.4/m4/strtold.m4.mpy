{
  "module_name": "strtold.m4",
  "hash_id": "a934a2185c92898da19bf1f3ae49d6b29689e59d25c9900992578883b383c483",
  "original_prompt": "Ingested from coreutils-9.4/m4/strtold.m4",
  "human_readable_source": "# strtold.m4 serial 9\ndnl Copyright (C) 2002-2003, 2006-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_STRTOLD],\n[\n  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n  AC_REQUIRE([gl_LONG_DOUBLE_VS_DOUBLE])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CHECK_FUNCS_ONCE([strtold])\n  if test $ac_cv_func_strtold != yes; then\n    HAVE_STRTOLD=0\n  else\n    AC_CACHE_CHECK([whether strtold obeys POSIX], [gl_cv_func_strtold_works],\n      [AC_RUN_IFELSE([AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <math.h>\n#include <errno.h>\n/* Compare two numbers with ==.\n   This is a separate function because IRIX 6.5 \"cc -O\" miscompiles an\n   'x == x' test.  */\nstatic int\nnumeric_equal (long double x, long double y)\n{\n  return x == y;\n}\n]], [[\n  int result = 0;\n  {\n    /* Under Solaris 2.4, strtod returns the wrong value for the\n       terminating character under some conditions.  */\n    const char *string = \"NaN\";\n    char *term;\n    strtold (string, &term);\n    if (term != string && *(term - 1) == 0)\n      result |= 1;\n  }\n  {\n    /* Older glibc and Cygwin mis-parse \"-0x\".  */\n    const char *string = \"-0x\";\n    char *term;\n    long double value = strtold (string, &term);\n    long double zero = 0.0L;\n    if (1.0L / value != -1.0L / zero || term != (string + 2))\n      result |= 2;\n  }\n  {\n    /* IRIX 6.5, mingw do not parse hex floats.  */\n    const char *string = \"0XaP+1\";\n    char *term;\n    long double value = strtold (string, &term);\n    if (value != 20.0L || term != (string + 6))\n      result |= 4;\n  }\n  {\n    /* IRIX 6.5 does not parse infinities.  HP-UX 11.31/ia64 parses inf,\n       but mistakenly sets errno.  */\n    const char *string = \"inf\";\n    char *term;\n    long double value;\n    errno = 0;\n    value = strtold (string, &term);\n    if (value != HUGE_VAL || term != (string + 3) || errno)\n      result |= 8;\n  }\n  {\n    /* glibc-2.3.2, IRIX 6.5, mingw, Haiku misparse \"nan()\".  */\n    const char *string = \"nan()\";\n    char *term;\n    long double value = strtold (string, &term);\n    if (numeric_equal (value, value) || term != (string + 5))\n      result |= 16;\n  }\n  {\n    /* Mac OS X 10.5, IRIX 6.5 misparse \"nan(\".  */\n    const char *string = \"nan(\";\n    char *term;\n    long double value = strtold (string, &term);\n    if (numeric_equal (value, value) || term != (string + 3))\n      result |= 32;\n  }\n  {\n    /* In Cygwin 2.9, strtold does not set errno upon underflow.  */\n    const char *string = \"1E-100000\";\n    char *term;\n    long double value;\n    errno = 0;\n    value = strtold (string, &term);\n    if (term != (string + 9) || (value == 0.0L && errno != ERANGE))\n      result |= 64;\n  }\n  return result;\n]])],\n        [gl_cv_func_strtold_works=yes],\n        [if expr $? '>=' 64 >/dev/null; then\n           gl_cv_func_strtold_works=\"no (underflow problem)\"\n         else\n           gl_cv_func_strtold_works=no\n         fi\n        ],\n        [dnl The last known bugs in glibc strtold(), as of this writing,\n         dnl were fixed in version 2.8\n         AC_EGREP_CPP([Lucky user],\n           [\n#include <features.h>\n#ifdef __GNU_LIBRARY__\n #if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8) || (__GLIBC__ > 2)) \\\n     && !defined __UCLIBC__\n  Lucky user\n #endif\n#endif\n           ],\n           [gl_cv_func_strtold_works=\"guessing yes\"],\n           [case \"$host_os\" in\n                                  # Guess yes on musl systems.\n              *-musl* | midipix*) gl_cv_func_strtold_works=\"guessing yes\" ;;\n                                  # Guess 'no (underflow problem)' on Cygwin.\n              cygwin*)            gl_cv_func_strtold_works=\"guessing no (underflow problem)\" ;;\n              *)                  gl_cv_func_strtold_works=\"$gl_cross_guess_normal\" ;;\n            esac\n           ])\n        ])\n      ])\n    case \"$gl_cv_func_strtold_works\" in\n      *yes) ;;\n      *)\n        REPLACE_STRTOLD=1\n        case \"$gl_cv_func_strtold_works\" in\n          *\"no (underflow problem)\")\n            AC_DEFINE([STRTOLD_HAS_UNDERFLOW_BUG], [1],\n              [Define to 1 if strtold does not set errno upon underflow.])\n            ;;\n        esac\n        ;;\n    esac\n  fi\n])\n\n# Prerequisites of lib/strtold.c.\nAC_DEFUN([gl_PREREQ_STRTOLD], [\n  AC_REQUIRE([gl_CHECK_LDEXPL_NO_LIBM])\n  if test $gl_cv_func_ldexpl_no_libm = yes; then\n    AC_DEFINE([HAVE_LDEXPL_IN_LIBC], [1],\n      [Define if the ldexpl function is available in libc.])\n  fi\n  gl_CHECK_FUNCS_ANDROID([nl_langinfo], [[#include <langinfo.h>]])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}