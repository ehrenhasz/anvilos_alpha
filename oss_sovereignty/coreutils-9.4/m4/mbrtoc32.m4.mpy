{
  "module_name": "mbrtoc32.m4",
  "hash_id": "6908437cc42bbd5b9c4498128dbb7316d37fed65ae45d072bfb008ce9f32b128",
  "original_prompt": "Ingested from coreutils-9.4/m4/mbrtoc32.m4",
  "human_readable_source": "# mbrtoc32.m4 serial 18\ndnl Copyright (C) 2014-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_MBRTOC32],\n[\n  AC_REQUIRE([gl_UCHAR_H_DEFAULTS])\n\n  AC_REQUIRE([AC_TYPE_MBSTATE_T])\n  dnl Determine REPLACE_MBSTATE_T, from which GNULIB_defined_mbstate_t is\n  dnl determined.  It describes how our overridden mbrtowc is implemented.\n  dnl We then implement mbrtoc32 accordingly.\n  AC_REQUIRE([gl_MBSTATE_T_BROKEN])\n\n  AC_REQUIRE([gl_TYPE_CHAR32_T])\n  AC_REQUIRE([gl_MBRTOC32_SANITYCHECK])\n\n  AC_REQUIRE([gl_CHECK_FUNC_MBRTOC32])\n  if test $gl_cv_func_mbrtoc32 = no; then\n    HAVE_MBRTOC32=0\n  else\n    if test $GNULIBHEADERS_OVERRIDE_CHAR32_T = 1 || test $REPLACE_MBSTATE_T = 1; then\n      REPLACE_MBRTOC32=1\n    else\n      gl_MBRTOC32_EMPTY_INPUT\n      gl_MBRTOC32_C_LOCALE\n      case \"$gl_cv_func_mbrtoc32_empty_input\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOC32_EMPTY_INPUT_BUG], [1],\n             [Define if the mbrtoc32 function does not return (size_t) -2 for empty input.])\n           REPLACE_MBRTOC32=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtoc32_C_locale_sans_EILSEQ\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOC32_IN_C_LOCALE_MAYBE_EILSEQ], [1],\n             [Define if the mbrtoc32 function may signal encoding errors in the C locale.])\n           REPLACE_MBRTOC32=1\n           ;;\n      esac\n    fi\n    if test $HAVE_WORKING_MBRTOC32 = 0; then\n      REPLACE_MBRTOC32=1\n    fi\n  fi\n])\n\nAC_DEFUN([gl_CHECK_FUNC_MBRTOC32],\n[\n  dnl Cf. gl_CHECK_FUNCS_ANDROID\n  AC_CHECK_DECL([mbrtoc32], , ,\n    [[#ifdef __HAIKU__\n       #include <stdint.h>\n      #endif\n      #include <uchar.h>\n    ]])\n  if test $ac_cv_have_decl_mbrtoc32 = yes; then\n    dnl We can't use AC_CHECK_FUNC here, because mbrtoc32() is defined as a\n    dnl static inline function on Haiku 2020.\n    AC_CACHE_CHECK([for mbrtoc32], [gl_cv_func_mbrtoc32],\n      [AC_LINK_IFELSE(\n         [AC_LANG_PROGRAM(\n            [[#include <stdlib.h>\n              #ifdef __HAIKU__\n               #include <stdint.h>\n              #endif\n              #include <uchar.h>\n            ]],\n            [[char32_t c;\n              return mbrtoc32 (&c, \"\", 1, NULL) == 0;\n            ]])\n         ],\n         [gl_cv_func_mbrtoc32=yes],\n         [gl_cv_func_mbrtoc32=no])\n      ])\n  else\n    gl_cv_func_mbrtoc32=no\n  fi\n])\n\ndnl Test whether mbrtoc32 returns the correct value on empty input.\n\nAC_DEFUN([gl_MBRTOC32_EMPTY_INPUT],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtoc32 works on empty input],\n    [gl_cv_func_mbrtoc32_empty_input],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n           #ifdef __HAIKU__\n            #include <stdint.h>\n           #endif\n           #include <uchar.h>\n           static char32_t wc;\n           static mbstate_t mbs;\n           int\n           main (void)\n           {\n             return mbrtoc32 (&wc, \"\", 0, &mbs) != (size_t) -2;\n           }]])],\n        [gl_cv_func_mbrtoc32_empty_input=yes],\n        [gl_cv_func_mbrtoc32_empty_input=no],\n        [case \"$host_os\" in\n                              # Guess no on glibc systems.\n           *-gnu* | gnu*)     gl_cv_func_mbrtoc32_empty_input=\"guessing no\" ;;\n                              # Guess no on Android.\n           linux*-android*)   gl_cv_func_mbrtoc32_empty_input=\"guessing no\" ;;\n                              # Guess no on native Windows.\n           mingw* | windows*) gl_cv_func_mbrtoc32_empty_input=\"guessing no\" ;;\n           *)                 gl_cv_func_mbrtoc32_empty_input=\"guessing yes\" ;;\n         esac\n        ])\n    ])\n])\n\ndnl <https://pubs.opengroup.org/onlinepubs/9699919799/functions/mbrtowc.html>\ndnl POSIX:2018 says regarding mbrtowc: \"In the POSIX locale an [EILSEQ] error\ndnl cannot occur since all byte values are valid characters.\"  It is reasonable\ndnl to expect mbrtoc32 to behave in the same way.\n\nAC_DEFUN([gl_MBRTOC32_C_LOCALE],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether the C locale is free of encoding errors],\n    [gl_cv_func_mbrtoc32_C_locale_sans_EILSEQ],\n    [AC_RUN_IFELSE(\n       [AC_LANG_PROGRAM(\n          [[#include <limits.h>\n            #include <locale.h>\n            #ifdef __HAIKU__\n             #include <stdint.h>\n            #endif\n            #include <uchar.h>\n          ]], [[\n            int i;\n            char *locale = setlocale (LC_ALL, \"C\");\n            if (! locale)\n              return 2;\n            for (i = CHAR_MIN; i <= CHAR_MAX; i++)\n              {\n                char c = i;\n                char32_t wc;\n                mbstate_t mbs = { 0, };\n                size_t ss = mbrtoc32 (&wc, &c, 1, &mbs);\n                if (1 < ss)\n                  return 3;\n              }\n            return 0;\n          ]])],\n       [gl_cv_func_mbrtoc32_C_locale_sans_EILSEQ=yes],\n       [gl_cv_func_mbrtoc32_C_locale_sans_EILSEQ=no],\n       [case \"$host_os\" in\n                             # Guess yes on native Windows.\n          mingw* | windows*) gl_cv_func_mbrtoc32_C_locale_sans_EILSEQ=\"guessing yes\" ;;\n          *)                 gl_cv_func_mbrtoc32_C_locale_sans_EILSEQ=\"$gl_cross_guess_normal\" ;;\n        esac\n       ])\n    ])\n])\n\ndnl Test whether mbrtoc32 works not worse than mbrtowc.\ndnl Result is HAVE_WORKING_MBRTOC32.\n\nAC_DEFUN([gl_MBRTOC32_SANITYCHECK],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_TYPE_CHAR32_T])\n  AC_REQUIRE([gl_CHECK_FUNC_MBRTOC32])\n  AC_REQUIRE([gt_LOCALE_FR])\n  AC_REQUIRE([gt_LOCALE_ZH_CN])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  if test $GNULIBHEADERS_OVERRIDE_CHAR32_T = 1 || test $gl_cv_func_mbrtoc32 = no; then\n    HAVE_WORKING_MBRTOC32=0\n  else\n    AC_CACHE_CHECK([whether mbrtoc32 works as well as mbrtowc],\n      [gl_cv_func_mbrtoc32_sanitycheck],\n      [\n        dnl Initial guess, used when cross-compiling or when no suitable locale\n        dnl is present.\nchangequote(,)dnl\n        case \"$host_os\" in\n          # Guess no on FreeBSD, Solaris, native Windows.\n          freebsd* | midnightbsd* | solaris* | mingw* | windows*)\n            gl_cv_func_mbrtoc32_sanitycheck=\"guessing no\"\n            ;;\n          # Guess yes otherwise.\n          *)\n            gl_cv_func_mbrtoc32_sanitycheck=\"guessing yes\"\n            ;;\n        esac\nchangequote([,])dnl\n        if test $LOCALE_FR != none || test $LOCALE_ZH_CN != none; then\n          AC_RUN_IFELSE(\n            [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n#ifdef __HAIKU__\n #include <stdint.h>\n#endif\n#include <uchar.h>\nint main ()\n{\n  int result = 0;\n  /* This fails on native Windows:\n     mbrtoc32 returns (size_t)-1.\n     mbrtowc returns 1 (correct).  */\n  if (strcmp (\"$LOCALE_FR\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_FR\") != NULL)\n    {\n      mbstate_t state;\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\374\", 1, &state) == 1)\n        {\n          char32_t c32 = (wchar_t) 0xBADFACE;\n          memset (&state, '\\0', sizeof (mbstate_t));\n          if (mbrtoc32 (&c32, \"\\374\", 1, &state) != 1)\n            result |= 1;\n        }\n    }\n  /* This fails on FreeBSD 13.0 and Solaris 11.4:\n     mbrtoc32 returns (size_t)-2 or (size_t)-1.\n     mbrtowc returns 4 (correct).  */\n  if (strcmp (\"$LOCALE_ZH_CN\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_ZH_CN\") != NULL)\n    {\n      mbstate_t state;\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\224\\071\\375\\067\", 4, &state) == 4)\n        {\n          char32_t c32 = (wchar_t) 0xBADFACE;\n          memset (&state, '\\0', sizeof (mbstate_t));\n          if (mbrtoc32 (&c32, \"\\224\\071\\375\\067\", 4, &state) != 4)\n            result |= 2;\n        }\n    }\n  return result;\n}]])],\n            [gl_cv_func_mbrtoc32_sanitycheck=yes],\n            [gl_cv_func_mbrtoc32_sanitycheck=no],\n            [:])\n        fi\n      ])\n    case \"$gl_cv_func_mbrtoc32_sanitycheck\" in\n      *yes)\n        HAVE_WORKING_MBRTOC32=1\n        AC_DEFINE([HAVE_WORKING_MBRTOC32], [1],\n          [Define if the mbrtoc32 function basically works.])\n        ;;\n      *) HAVE_WORKING_MBRTOC32=0 ;;\n    esac\n  fi\n  AC_SUBST([HAVE_WORKING_MBRTOC32])\n])\n\n# Prerequisites of lib/mbrtoc32.c and lib/lc-charset-dispatch.c.\nAC_DEFUN([gl_PREREQ_MBRTOC32], [\n  :\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}