{
  "module_name": "pthread_sigmask.m4",
  "hash_id": "618146929beb92962b21c47ba98714bd47317e72ab2797605ee6d4c8d864669d",
  "original_prompt": "Ingested from coreutils-9.4/m4/pthread_sigmask.m4",
  "human_readable_source": "# pthread_sigmask.m4 serial 22\ndnl Copyright (C) 2011-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_PTHREAD_SIGMASK],\n[\n  AC_REQUIRE([gl_SIGNAL_H_DEFAULTS])\n\n  AC_CHECK_FUNCS_ONCE([pthread_sigmask])\n\n  dnl On MinGW pthread_sigmask is just a macro which always returns 0.\n  dnl It does not exist as a real function, which is required by POSIX.\n  AC_CACHE_CHECK([whether pthread_sigmask is a macro],\n    [gl_cv_func_pthread_sigmask_macro],\n    [AC_EGREP_CPP([headers_define_pthread_sigmask], [\n#include <pthread.h>\n#include <signal.h>\n#ifdef pthread_sigmask\n headers_define_pthread_sigmask\n#endif],\n       [gl_cv_func_pthread_sigmask_macro=yes],\n       [gl_cv_func_pthread_sigmask_macro=no])\n    ])\n\n  PTHREAD_SIGMASK_LIB=\n\n  if test $gl_cv_func_pthread_sigmask_macro = yes; then\n    dnl pthread_sigmask is a dummy macro.\n    HAVE_PTHREAD_SIGMASK=0\n    dnl Make sure to '#undef pthread_sigmask' before defining it.\n    REPLACE_PTHREAD_SIGMASK=1\n  else\n    dnl Test whether the gnulib module 'threadlib' is in use.\n    dnl Some packages like Emacs use --avoid=threadlib.\n    dnl Write the symbol in such a way that it does not cause 'aclocal' to pick\n    dnl the threadlib.m4 file that is installed in $PREFIX/share/aclocal/.\n    m4_ifdef([gl_][THREADLIB], [\n      AC_REQUIRE([gl_][THREADLIB])\n\n      if test \"$gl_threads_api\" = posix; then\n        if test $ac_cv_func_pthread_sigmask = yes; then\n          dnl pthread_sigmask is available without -lpthread.\n          :\n        else\n          if test -n \"$LIBMULTITHREAD\"; then\n            AC_CACHE_CHECK([for pthread_sigmask in $LIBMULTITHREAD],\n              [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD],\n              [gl_save_LIBS=\"$LIBS\"\n               LIBS=\"$LIBS $LIBMULTITHREAD\"\n               AC_LINK_IFELSE(\n                 [AC_LANG_PROGRAM(\n                    [[#include <pthread.h>\n                      #include <signal.h>\n                    ]],\n                    [[return pthread_sigmask (0, (sigset_t *) 0, (sigset_t *) 0);]])\n                 ],\n                 [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=yes],\n                 [gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD=no])\n               LIBS=\"$gl_save_LIBS\"\n              ])\n            if test $gl_cv_func_pthread_sigmask_in_LIBMULTITHREAD = yes; then\n              dnl pthread_sigmask is available with -pthread or -lpthread.\n              PTHREAD_SIGMASK_LIB=\"$LIBMULTITHREAD\"\n            else\n              dnl pthread_sigmask is not available at all.\n              HAVE_PTHREAD_SIGMASK=0\n            fi\n          else\n            dnl pthread_sigmask is not available at all.\n            HAVE_PTHREAD_SIGMASK=0\n          fi\n        fi\n      else\n        dnl pthread_sigmask may exist but does not interoperate with the chosen\n        dnl multithreading facility.\n        if test $ac_cv_func_pthread_sigmask = yes; then\n          REPLACE_PTHREAD_SIGMASK=1\n        else\n          HAVE_PTHREAD_SIGMASK=0\n        fi\n      fi\n    ], [\n      dnl The module 'threadlib' is not in use, due to --avoid=threadlib being\n      dnl specified.\n      dnl The package either has prepared CPPFLAGS and LIBS for use of\n      dnl POSIX:2008 threads, or wants to build single-threaded programs.\n      if test $ac_cv_func_pthread_sigmask = yes; then\n        dnl pthread_sigmask exists and does not require extra libraries.\n        dnl Assume that it is declared.\n        :\n      else\n        dnl pthread_sigmask either does not exist or needs extra libraries.\n        HAVE_PTHREAD_SIGMASK=0\n        dnl Define the symbol rpl_pthread_sigmask, not pthread_sigmask,\n        dnl so as to not accidentally override the system's pthread_sigmask\n        dnl symbol from libpthread. This is necessary on IRIX 6.5.\n        REPLACE_PTHREAD_SIGMASK=1\n      fi\n    ])\n  fi\n\n  AC_SUBST([PTHREAD_SIGMASK_LIB])\n  dnl For backward compatibility.\n  LIB_PTHREAD_SIGMASK=\"$PTHREAD_SIGMASK_LIB\"\n  AC_SUBST([LIB_PTHREAD_SIGMASK])\n  dnl We don't need a variable LTLIB_PTHREAD_SIGMASK, because when\n  dnl \"$gl_threads_api\" = posix, $LTLIBMULTITHREAD and $LIBMULTITHREAD are the\n  dnl same.\n\n  dnl Now test for some bugs in the system function.\n  if test $HAVE_PTHREAD_SIGMASK = 1; then\n    AC_REQUIRE([AC_PROG_CC])\n    AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n    dnl On FreeBSD 13.0, MidnightBSD 1.1, HP-UX 11.31, Solaris 9, in programs\n    dnl that are not linked with -lpthread, the pthread_sigmask() function\n    dnl always returns 0 and has no effect.\n    if test -z \"$PTHREAD_SIGMASK_LIB\"; then\n      case \" $LIBS \" in\n        *' -pthread '*) ;;\n        *' -lpthread '*) ;;\n        *)\n          AC_CACHE_CHECK([whether pthread_sigmask works without -lpthread],\n            [gl_cv_func_pthread_sigmask_in_libc_works],\n            [\n              AC_RUN_IFELSE(\n                [AC_LANG_SOURCE([[\n                   #include <pthread.h>\n                   #include <signal.h>\n                   #include <stddef.h>\n                   int main ()\n                   {\n                     sigset_t set;\n                     sigemptyset (&set);\n                     return pthread_sigmask (1729, &set, NULL) != 0;\n                   }]])],\n                [gl_cv_func_pthread_sigmask_in_libc_works=no],\n                [gl_cv_func_pthread_sigmask_in_libc_works=yes],\n                [\n                 changequote(,)dnl\n                 case \"$host_os\" in\n                   freebsd* | midnightbsd* | hpux* | solaris | solaris2.[2-9]*)\n                     gl_cv_func_pthread_sigmask_in_libc_works=\"guessing no\";;\n                   *)\n                     gl_cv_func_pthread_sigmask_in_libc_works=\"guessing yes\";;\n                 esac\n                 changequote([,])dnl\n                ])\n            ])\n          case \"$gl_cv_func_pthread_sigmask_in_libc_works\" in\n            *no)\n              REPLACE_PTHREAD_SIGMASK=1\n              AC_DEFINE([PTHREAD_SIGMASK_INEFFECTIVE], [1],\n                [Define to 1 if pthread_sigmask may return 0 and have no effect.])\n              ;;\n          esac;;\n      esac\n    fi\n\n    dnl On Cygwin 1.7.5, the pthread_sigmask() has a wrong return value\n    dnl convention: Upon failure, it returns -1 and sets errno.\n    AC_CACHE_CHECK([whether pthread_sigmask returns error numbers],\n      [gl_cv_func_pthread_sigmask_return_works],\n      [\n        gl_save_LIBS=\"$LIBS\"\n        LIBS=\"$LIBS $PTHREAD_SIGMASK_LIB\"\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <pthread.h>\n#include <signal.h>\n#include <stddef.h>\nint main ()\n{\n  sigset_t set;\n  sigemptyset (&set);\n  if (pthread_sigmask (1729, &set, NULL) == -1)\n    return 1;\n  return 0;\n}]])],\n          [gl_cv_func_pthread_sigmask_return_works=yes],\n          [gl_cv_func_pthread_sigmask_return_works=no],\n          [case \"$host_os\" in\n             cygwin*)\n               gl_cv_func_pthread_sigmask_return_works=\"guessing no\";;\n             *)\n               gl_cv_func_pthread_sigmask_return_works=\"guessing yes\";;\n           esac\n          ])\n        LIBS=\"$gl_save_LIBS\"\n      ])\n    case \"$gl_cv_func_pthread_sigmask_return_works\" in\n      *no)\n        REPLACE_PTHREAD_SIGMASK=1\n        AC_DEFINE([PTHREAD_SIGMASK_FAILS_WITH_ERRNO], [1],\n          [Define to 1 if pthread_sigmask(), when it fails, returns -1 and sets errno.])\n        ;;\n    esac\n\n    dnl On IRIX 6.5, in a single-threaded program, pending signals are not\n    dnl immediately delivered when they are unblocked through pthread_sigmask,\n    dnl only a little while later.\n    AC_CACHE_CHECK([whether pthread_sigmask unblocks signals correctly],\n      [gl_cv_func_pthread_sigmask_unblock_works],\n      [\n        case \"$host_os\" in\n          irix*)\n            gl_cv_func_pthread_sigmask_unblock_works=\"guessing no\";;\n          *)\n            gl_cv_func_pthread_sigmask_unblock_works=\"guessing yes\";;\n        esac\n        m4_ifdef([gl_][THREADLIB],\n          [dnl Link against $LIBMULTITHREAD, not only $PTHREAD_SIGMASK_LIB.\n           dnl Otherwise we get a false positive on those platforms where\n           dnl $gl_cv_func_pthread_sigmask_in_libc_works is \"no\".\n           gl_save_LIBS=$LIBS\n           LIBS=\"$LIBS $LIBMULTITHREAD\"])\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <limits.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n]GL_MDA_DEFINES[\nstatic volatile int sigint_occurred;\nstatic void\nsigint_handler (int sig)\n{\n  sigint_occurred++;\n}\nint main ()\n{\n  sigset_t set;\n  pid_t pid = getpid ();\n  char command[80];\n  if (LONG_MAX < pid)\n    return 6;\n  signal (SIGINT, sigint_handler);\n  sigemptyset (&set);\n  sigaddset (&set, SIGINT);\n  if (!(pthread_sigmask (SIG_BLOCK, &set, NULL) == 0))\n    return 1;\n  sprintf (command, \"sh -c 'sleep 1; kill -INT %ld' &\", (long) pid);\n  if (!(system (command) == 0))\n    return 2;\n  sleep (2);\n  if (!(sigint_occurred == 0))\n    return 3;\n  if (!(pthread_sigmask (SIG_UNBLOCK, &set, NULL) == 0))\n    return 4;\n  if (!(sigint_occurred == 1)) /* This fails on IRIX.  */\n    return 5;\n  return 0;\n}]])],\n          [:],\n          [gl_cv_func_pthread_sigmask_unblock_works=no],\n          [:])\n        m4_ifdef([gl_][THREADLIB], [LIBS=$gl_save_LIBS])\n      ])\n    case \"$gl_cv_func_pthread_sigmask_unblock_works\" in\n      *no)\n        REPLACE_PTHREAD_SIGMASK=1\n        AC_DEFINE([PTHREAD_SIGMASK_UNBLOCK_BUG], [1],\n          [Define to 1 if pthread_sigmask() unblocks signals incorrectly.])\n        ;;\n    esac\n  fi\n])\n\n# Prerequisite of lib/pthread_sigmask.c.\nAC_DEFUN([gl_PREREQ_PTHREAD_SIGMASK],\n[\n  if test $HAVE_PTHREAD_SIGMASK = 1; then\n    AC_DEFINE([HAVE_PTHREAD_SIGMASK], [1],\n      [Define to 1 if the pthread_sigmask function can be used (despite bugs).])\n  fi\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}