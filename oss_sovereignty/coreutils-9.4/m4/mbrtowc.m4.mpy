{
  "module_name": "mbrtowc.m4",
  "hash_id": "d80d84ed9de266fbe24e4cff09863770ae8418cb913154185ccae707b8ff1ab4",
  "original_prompt": "Ingested from coreutils-9.4/m4/mbrtowc.m4",
  "human_readable_source": "# mbrtowc.m4 serial 44  -*- coding: utf-8 -*-\ndnl Copyright (C) 2001-2002, 2004-2005, 2008-2023 Free Software Foundation,\ndnl Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_MBRTOWC],\n[\n  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])\n  AC_REQUIRE([gl_PTHREADLIB])\n  AC_CHECK_HEADERS_ONCE([threads.h])\n\n  AC_REQUIRE([AC_TYPE_MBSTATE_T])\n  gl_MBSTATE_T_BROKEN\n\n  AC_CHECK_FUNCS_ONCE([mbrtowc])\n  if test $ac_cv_func_mbrtowc = no; then\n    HAVE_MBRTOWC=0\n    AC_CHECK_DECLS([mbrtowc],,, [[\n      #include <wchar.h>\n    ]])\n    if test $ac_cv_have_decl_mbrtowc = yes; then\n      dnl On Minix 3.1.8, the system's <wchar.h> declares mbrtowc() although\n      dnl it does not have the function. Avoid a collision with gnulib's\n      dnl replacement.\n      REPLACE_MBRTOWC=1\n    fi\n  else\n    if test $REPLACE_MBSTATE_T = 1; then\n      REPLACE_MBRTOWC=1\n    else\n      gl_MBRTOWC_NULL_ARG1\n      gl_MBRTOWC_NULL_ARG2\n      gl_MBRTOWC_RETVAL\n      gl_MBRTOWC_NUL_RETVAL\n      gl_MBRTOWC_STORES_INCOMPLETE\n      gl_MBRTOWC_EMPTY_INPUT\n      gl_MBRTOWC_C_LOCALE\n      case \"$gl_cv_func_mbrtowc_null_arg1\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOWC_NULL_ARG1_BUG], [1],\n             [Define if the mbrtowc function has the NULL pwc argument bug.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtowc_null_arg2\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOWC_NULL_ARG2_BUG], [1],\n             [Define if the mbrtowc function has the NULL string argument bug.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtowc_retval\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOWC_RETVAL_BUG], [1],\n             [Define if the mbrtowc function returns a wrong return value.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtowc_nul_retval\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOWC_NUL_RETVAL_BUG], [1],\n             [Define if the mbrtowc function does not return 0 for a NUL character.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtowc_stores_incomplete\" in\n        *no) ;;\n        *) AC_DEFINE([MBRTOWC_STORES_INCOMPLETE_BUG], [1],\n             [Define if the mbrtowc function stores a wide character when reporting incomplete input.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtowc_empty_input\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOWC_EMPTY_INPUT_BUG], [1],\n             [Define if the mbrtowc function does not return (size_t) -2\n              for empty input.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n      case \"$gl_cv_func_mbrtowc_C_locale_sans_EILSEQ\" in\n        *yes) ;;\n        *) AC_DEFINE([MBRTOWC_IN_C_LOCALE_MAYBE_EILSEQ], [1],\n             [Define if the mbrtowc function may signal encoding errors in the C locale.])\n           REPLACE_MBRTOWC=1\n           ;;\n      esac\n    fi\n  fi\n  if test $REPLACE_MBSTATE_T = 1; then\n    case \"$host_os\" in\n      mingw* | windows*)\n        MBRTOWC_LIB=\n        ;;\n      *)\n        gl_WEAK_SYMBOLS\n        case \"$gl_cv_have_weak\" in\n          *yes) MBRTOWC_LIB= ;;\n          *)    MBRTOWC_LIB=\"$LIBPTHREAD\" ;;\n        esac\n        ;;\n    esac\n  else\n    MBRTOWC_LIB=\n  fi\n  dnl MBRTOWC_LIB is expected to be '-pthread' or '-lpthread' on AIX\n  dnl with gcc or xlc, and empty otherwise.\n  AC_SUBST([MBRTOWC_LIB])\n  dnl For backward compatibility.\n  LIB_MBRTOWC=\"$MBRTOWC_LIB\"\n  AC_SUBST([LIB_MBRTOWC])\n])\n\ndnl Test whether mbsinit() and mbrtowc() need to be overridden in a way that\ndnl redefines the semantics of the given mbstate_t type.\ndnl Result is REPLACE_MBSTATE_T.\ndnl When this is set to 1, we replace both mbsinit() and mbrtowc(), in order to\ndnl avoid inconsistencies.\n\nAC_DEFUN_ONCE([gl_MBSTATE_T_BROKEN],\n[\n  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n\n  AC_REQUIRE([AC_TYPE_MBSTATE_T])\n  AC_CHECK_FUNCS_ONCE([mbsinit])\n  AC_CHECK_FUNCS_ONCE([mbrtowc])\n  dnl On native Windows, we know exactly how mbsinit() behaves and don't need\n  dnl to override it, even if - like on MSVC - mbsinit() is only defined as\n  dnl an inline function, not as a global function.\n  if case \"$host_os\" in\n       mingw* | windows*) true ;;\n       *) test $ac_cv_func_mbsinit = yes ;;\n     esac \\\n    && test $ac_cv_func_mbrtowc = yes; then\n    gl_MBRTOWC_INCOMPLETE_STATE\n    gl_MBRTOWC_SANITYCHECK\n    REPLACE_MBSTATE_T=0\n    case \"$gl_cv_func_mbrtowc_incomplete_state\" in\n      *yes) ;;\n      *) REPLACE_MBSTATE_T=1 ;;\n    esac\n    case \"$gl_cv_func_mbrtowc_sanitycheck\" in\n      *yes) ;;\n      *) REPLACE_MBSTATE_T=1 ;;\n    esac\n  else\n    REPLACE_MBSTATE_T=1\n  fi\n])\n\ndnl Test whether mbrtowc puts the state into non-initial state when parsing an\ndnl incomplete multibyte character.\ndnl Result is gl_cv_func_mbrtowc_incomplete_state.\n\nAC_DEFUN([gl_MBRTOWC_INCOMPLETE_STATE],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gt_LOCALE_JA])\n  AC_REQUIRE([gt_LOCALE_FR_UTF8])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc handles incomplete characters],\n    [gl_cv_func_mbrtowc_incomplete_state],\n    [\n      dnl Initial guess, used when cross-compiling or when no suitable locale\n      dnl is present.\nchangequote(,)dnl\n      case \"$host_os\" in\n                     # Guess no on AIX and OSF/1.\n        aix* | osf*) gl_cv_func_mbrtowc_incomplete_state=\"guessing no\" ;;\n                     # Guess yes otherwise.\n        *)           gl_cv_func_mbrtowc_incomplete_state=\"guessing yes\" ;;\n      esac\nchangequote([,])dnl\n      if test $LOCALE_JA != none; then\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  if (setlocale (LC_ALL, \"$LOCALE_JA\") != NULL)\n    {\n      const char input[] = \"B\\217\\253\\344\\217\\251\\316er\"; /* \"B\u00fc\u00dfer\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 1, 1, &state) == (size_t)(-2))\n        if (mbsinit (&state))\n          return 2;\n    }\n  return 0;\n}]])],\n          [gl_cv_func_mbrtowc_incomplete_state=yes],\n          [gl_cv_func_mbrtowc_incomplete_state=no],\n          [:])\n      else\n        if test $LOCALE_FR_UTF8 != none; then\n          AC_RUN_IFELSE(\n            [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  if (setlocale (LC_ALL, \"$LOCALE_FR_UTF8\") != NULL)\n    {\n      const char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00fc\u00dfer\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 1, 1, &state) == (size_t)(-2))\n        if (mbsinit (&state))\n          return 2;\n    }\n  return 0;\n}]])],\n          [gl_cv_func_mbrtowc_incomplete_state=yes],\n          [gl_cv_func_mbrtowc_incomplete_state=no],\n          [:])\n        fi\n      fi\n    ])\n])\n\ndnl Test whether mbrtowc works not worse than mbtowc.\ndnl Result is gl_cv_func_mbrtowc_sanitycheck.\n\nAC_DEFUN([gl_MBRTOWC_SANITYCHECK],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gt_LOCALE_ZH_CN])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc works as well as mbtowc],\n    [gl_cv_func_mbrtowc_sanitycheck],\n    [\n      dnl Initial guess, used when cross-compiling or when no suitable locale\n      dnl is present.\nchangequote(,)dnl\n      case \"$host_os\" in\n                    # Guess no on Solaris 8.\n        solaris2.8) gl_cv_func_mbrtowc_sanitycheck=\"guessing no\" ;;\n                    # Guess yes otherwise.\n        *)          gl_cv_func_mbrtowc_sanitycheck=\"guessing yes\" ;;\n      esac\nchangequote([,])dnl\n      if test $LOCALE_ZH_CN != none; then\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  /* This fails on Solaris 8:\n     mbrtowc returns 2, and sets wc to 0x00F0.\n     mbtowc returns 4 (correct) and sets wc to 0x5EDC.  */\n  if (setlocale (LC_ALL, \"$LOCALE_ZH_CN\") != NULL)\n    {\n      char input[] = \"B\\250\\271\\201\\060\\211\\070er\"; /* \"B\u00fc\u00dfer\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 3, 6, &state) != 4\n          && mbtowc (&wc, input + 3, 6) == 4)\n        return 2;\n    }\n  return 0;\n}]])],\n          [gl_cv_func_mbrtowc_sanitycheck=yes],\n          [gl_cv_func_mbrtowc_sanitycheck=no],\n          [:])\n      fi\n    ])\n])\n\ndnl Test whether mbrtowc supports a NULL pwc argument correctly.\ndnl Result is gl_cv_func_mbrtowc_null_arg1.\n\nAC_DEFUN([gl_MBRTOWC_NULL_ARG1],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gt_LOCALE_FR_UTF8])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc handles a NULL pwc argument],\n    [gl_cv_func_mbrtowc_null_arg1],\n    [\n      dnl Initial guess, used when cross-compiling or when no suitable locale\n      dnl is present.\nchangequote(,)dnl\n      case \"$host_os\" in\n                  # Guess no on Solaris.\n        solaris*) gl_cv_func_mbrtowc_null_arg1=\"guessing no\" ;;\n                  # Guess yes otherwise.\n        *)        gl_cv_func_mbrtowc_null_arg1=\"guessing yes\" ;;\n      esac\nchangequote([,])dnl\n      if test $LOCALE_FR_UTF8 != none; then\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  int result = 0;\n\n  if (setlocale (LC_ALL, \"$LOCALE_FR_UTF8\") != NULL)\n    {\n      char input[] = \"\\303\\237er\";\n      mbstate_t state;\n      wchar_t wc;\n      size_t ret;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      wc = (wchar_t) 0xBADFACE;\n      ret = mbrtowc (&wc, input, 5, &state);\n      if (ret != 2)\n        result |= 1;\n      if (!mbsinit (&state))\n        result |= 2;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      ret = mbrtowc (NULL, input, 5, &state);\n      if (ret != 2) /* Solaris 7 fails here: ret is -1.  */\n        result |= 4;\n      if (!mbsinit (&state))\n        result |= 8;\n    }\n  return result;\n}]])],\n          [gl_cv_func_mbrtowc_null_arg1=yes],\n          [gl_cv_func_mbrtowc_null_arg1=no],\n          [:])\n      fi\n    ])\n])\n\ndnl Test whether mbrtowc supports a NULL string argument correctly.\ndnl Result is gl_cv_func_mbrtowc_null_arg2.\n\nAC_DEFUN([gl_MBRTOWC_NULL_ARG2],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gt_LOCALE_FR_UTF8])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc handles a NULL string argument],\n    [gl_cv_func_mbrtowc_null_arg2],\n    [\n      dnl Initial guess, used when cross-compiling or when no suitable locale\n      dnl is present.\nchangequote(,)dnl\n      case \"$host_os\" in\n              # Guess no on OSF/1.\n        osf*) gl_cv_func_mbrtowc_null_arg2=\"guessing no\" ;;\n              # Guess yes otherwise.\n        *)    gl_cv_func_mbrtowc_null_arg2=\"guessing yes\" ;;\n      esac\nchangequote([,])dnl\n      if test $LOCALE_FR_UTF8 != none; then\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  if (setlocale (LC_ALL, \"$LOCALE_FR_UTF8\") != NULL)\n    {\n      mbstate_t state;\n      wchar_t wc;\n      int ret;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      wc = (wchar_t) 0xBADFACE;\n      mbrtowc (&wc, NULL, 5, &state);\n      /* Check that wc was not modified.  */\n      if (wc != (wchar_t) 0xBADFACE)\n        return 2;\n    }\n  return 0;\n}]])],\n          [gl_cv_func_mbrtowc_null_arg2=yes],\n          [gl_cv_func_mbrtowc_null_arg2=no],\n          [:])\n      fi\n    ])\n])\n\ndnl Test whether mbrtowc, when parsing the end of a multibyte character,\ndnl correctly returns the number of bytes that were needed to complete the\ndnl character (not the total number of bytes of the multibyte character).\ndnl Result is gl_cv_func_mbrtowc_retval.\n\nAC_DEFUN([gl_MBRTOWC_RETVAL],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gt_LOCALE_FR_UTF8])\n  AC_REQUIRE([gt_LOCALE_JA])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CACHE_CHECK([whether mbrtowc has a correct return value],\n    [gl_cv_func_mbrtowc_retval],\n    [\n      dnl Initial guess, used when cross-compiling or when no suitable locale\n      dnl is present.\nchangequote(,)dnl\n      case \"$host_os\" in\n          # Guess no on HP-UX, Solaris, native Windows.\n        hpux* | solaris* | mingw* | windows*)\n          gl_cv_func_mbrtowc_retval=\"guessing no\" ;;\n          # Guess yes otherwise.\n        *)\n          gl_cv_func_mbrtowc_retval=\"guessing yes\" ;;\n      esac\nchangequote([,])dnl\n      if test $LOCALE_FR_UTF8 != none || test $LOCALE_JA != none \\\n         || { case \"$host_os\" in mingw* | windows*) true;; *) false;; esac; }; then\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  int result = 0;\n  int found_some_locale = 0;\n  /* This fails on Solaris.  */\n  if (strcmp (\"$LOCALE_FR_UTF8\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_FR_UTF8\") != NULL)\n    {\n      char input[] = \"B\\303\\274\\303\\237er\"; /* \"B\u00fc\u00dfer\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 1, 1, &state) == (size_t)(-2))\n        {\n          input[1] = '\\0';\n          if (mbrtowc (&wc, input + 2, 5, &state) != 1)\n            result |= 1;\n        }\n      found_some_locale = 1;\n    }\n  /* This fails on HP-UX 11.11.  */\n  if (strcmp (\"$LOCALE_JA\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_JA\") != NULL)\n    {\n      char input[] = \"B\\217\\253\\344\\217\\251\\316er\"; /* \"B\u00fc\u00dfer\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 1, 1, &state) == (size_t)(-2))\n        {\n          input[1] = '\\0';\n          if (mbrtowc (&wc, input + 2, 5, &state) != 2)\n            result |= 2;\n        }\n      found_some_locale = 1;\n    }\n  /* This fails on native Windows.  */\n  if (setlocale (LC_ALL, \"Japanese_Japan.932\") != NULL)\n    {\n      char input[] = \"<\\223\\372\\226\\173\\214\\352>\"; /* \"<\u65e5\u672c\u8a9e>\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 3, 1, &state) == (size_t)(-2))\n        {\n          input[3] = '\\0';\n          if (mbrtowc (&wc, input + 4, 4, &state) != 1)\n            result |= 4;\n        }\n      found_some_locale = 1;\n    }\n  if (setlocale (LC_ALL, \"Chinese_Taiwan.950\") != NULL)\n    {\n      char input[] = \"<\\244\\351\\245\\273\\273\\171>\"; /* \"<\u65e5\u672c\u8a9e>\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 3, 1, &state) == (size_t)(-2))\n        {\n          input[3] = '\\0';\n          if (mbrtowc (&wc, input + 4, 4, &state) != 1)\n            result |= 8;\n        }\n      found_some_locale = 1;\n    }\n  if (setlocale (LC_ALL, \"Chinese_China.936\") != NULL)\n    {\n      char input[] = \"<\\310\\325\\261\\276\\325\\132>\"; /* \"<\u65e5\u672c\u8a9e>\" */\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, input + 3, 1, &state) == (size_t)(-2))\n        {\n          input[3] = '\\0';\n          if (mbrtowc (&wc, input + 4, 4, &state) != 1)\n            result |= 16;\n        }\n      found_some_locale = 1;\n    }\n  return (found_some_locale ? result : 77);\n}]])],\n          [gl_cv_func_mbrtowc_retval=yes],\n          [if test $? != 77; then\n             gl_cv_func_mbrtowc_retval=no\n           fi\n          ],\n          [:])\n      fi\n    ])\n])\n\ndnl Test whether mbrtowc, when parsing a NUL character, correctly returns 0.\ndnl Result is gl_cv_func_mbrtowc_nul_retval.\n\nAC_DEFUN([gl_MBRTOWC_NUL_RETVAL],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gt_LOCALE_ZH_CN])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc returns 0 when parsing a NUL character],\n    [gl_cv_func_mbrtowc_nul_retval],\n    [\n      dnl Initial guess, used when cross-compiling or when no suitable locale\n      dnl is present.\nchangequote(,)dnl\n      case \"$host_os\" in\n                       # Guess no on Solaris 8 and 9.\n        solaris2.[89]) gl_cv_func_mbrtowc_nul_retval=\"guessing no\" ;;\n                       # Guess yes otherwise.\n        *)             gl_cv_func_mbrtowc_nul_retval=\"guessing yes\" ;;\n      esac\nchangequote([,])dnl\n      if test $LOCALE_ZH_CN != none; then\n        AC_RUN_IFELSE(\n          [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  /* This fails on Solaris 8 and 9.  */\n  if (setlocale (LC_ALL, \"$LOCALE_ZH_CN\") != NULL)\n    {\n      mbstate_t state;\n      wchar_t wc;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\", 1, &state) != 0)\n        return 2;\n    }\n  return 0;\n}]])],\n          [gl_cv_func_mbrtowc_nul_retval=yes],\n          [gl_cv_func_mbrtowc_nul_retval=no],\n          [:])\n      fi\n    ])\n])\n\ndnl Test whether mbrtowc stores a wide character when reporting incomplete\ndnl input.\n\nAC_DEFUN([gl_MBRTOWC_STORES_INCOMPLETE],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc stores incomplete characters],\n    [gl_cv_func_mbrtowc_stores_incomplete],\n    [\n     dnl Initial guess, used when cross-compiling or when no suitable locale\n     dnl is present.\nchangequote(,)dnl\n     case \"$host_os\" in\n                          # Guess yes on native Windows.\n       mingw* | windows*) gl_cv_func_mbrtowc_stores_incomplete=\"guessing yes\" ;;\n       *)                 gl_cv_func_mbrtowc_stores_incomplete=\"guessing no\" ;;\n     esac\nchangequote([,])dnl\n     case \"$host_os\" in\n       mingw* | windows*)\n         AC_RUN_IFELSE(\n           [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  int result = 0;\n  if (setlocale (LC_ALL, \"French_France.65001\") != NULL)\n    {\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      mbstate_t state;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\303\", 1, &state) == (size_t)(-2)\n          && wc != (wchar_t) 0xBADFACE)\n        result |= 1;\n    }\n  if (setlocale (LC_ALL, \"Japanese_Japan.932\") != NULL)\n    {\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      mbstate_t state;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\226\", 1, &state) == (size_t)(-2)\n          && wc != (wchar_t) 0xBADFACE)\n        result |= 2;\n    }\n  if (setlocale (LC_ALL, \"Chinese_Taiwan.950\") != NULL)\n    {\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      mbstate_t state;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\245\", 1, &state) == (size_t)(-2)\n          && wc != (wchar_t) 0xBADFACE)\n        result |= 4;\n    }\n  if (setlocale (LC_ALL, \"Chinese_China.936\") != NULL)\n    {\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      mbstate_t state;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\261\", 1, &state) == (size_t)(-2)\n          && wc != (wchar_t) 0xBADFACE)\n        result |= 8;\n    }\n  return result;\n}]])],\n           [gl_cv_func_mbrtowc_stores_incomplete=no],\n           [gl_cv_func_mbrtowc_stores_incomplete=yes],\n           [:])\n         ;;\n       *)\n         AC_REQUIRE([gt_LOCALE_FR_UTF8])\n         if test $LOCALE_FR_UTF8 != none; then\n           AC_RUN_IFELSE(\n             [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\nint main ()\n{\n  if (setlocale (LC_ALL, \"$LOCALE_FR_UTF8\") != NULL)\n    {\n      wchar_t wc = (wchar_t) 0xBADFACE;\n      mbstate_t state;\n\n      memset (&state, '\\0', sizeof (mbstate_t));\n      if (mbrtowc (&wc, \"\\303\", 1, &state) == (size_t)(-2)\n          && wc != (wchar_t) 0xBADFACE)\n        return 1;\n    }\n  return 0;\n}]])],\n             [gl_cv_func_mbrtowc_stores_incomplete=no],\n             [gl_cv_func_mbrtowc_stores_incomplete=yes],\n             [:])\n         fi\n         ;;\n     esac\n    ])\n])\n\ndnl Test whether mbrtowc returns the correct value on empty input.\n\nAC_DEFUN([gl_MBRTOWC_EMPTY_INPUT],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether mbrtowc works on empty input],\n    [gl_cv_func_mbrtowc_empty_input],\n    [AC_RUN_IFELSE(\n       [AC_LANG_SOURCE([[\n          #include <wchar.h>\n          static wchar_t wc;\n          static mbstate_t mbs;\n          int\n          main (void)\n          {\n            return mbrtowc (&wc, \"\", 0, &mbs) != (size_t) -2;\n          }]])],\n       [gl_cv_func_mbrtowc_empty_input=yes],\n       [gl_cv_func_mbrtowc_empty_input=no],\n       [case \"$host_os\" in\n                                # Guess no on AIX and glibc systems.\n          aix* | *-gnu* | gnu*) gl_cv_func_mbrtowc_empty_input=\"guessing no\" ;;\n                                # Guess no on Android.\n          linux*-android*)      gl_cv_func_mbrtowc_empty_input=\"guessing no\" ;;\n                                # Guess no on native Windows.\n          mingw* | windows*)    gl_cv_func_mbrtowc_empty_input=\"guessing no\" ;;\n          *)                    gl_cv_func_mbrtowc_empty_input=\"guessing yes\" ;;\n        esac\n       ])\n    ])\n])\n\ndnl Test whether mbrtowc reports encoding errors in the C locale.\ndnl Although POSIX was never intended to allow this, the GNU C Library\ndnl and other implementations do it.  See:\ndnl https://sourceware.org/bugzilla/show_bug.cgi?id=19932\ndnl POSIX has now clarified it:\ndnl <https://pubs.opengroup.org/onlinepubs/9699919799/functions/mbrtowc.html>\ndnl says: \"In the POSIX locale an [EILSEQ] error cannot occur since all byte\ndnl values are valid characters.\"\n\nAC_DEFUN([gl_MBRTOWC_C_LOCALE],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether the C locale is free of encoding errors],\n    [gl_cv_func_mbrtowc_C_locale_sans_EILSEQ],\n    [AC_RUN_IFELSE(\n       [AC_LANG_PROGRAM(\n          [[#include <limits.h>\n            #include <locale.h>\n            #include <wchar.h>\n          ]], [[\n            int i;\n            char *locale = setlocale (LC_ALL, \"C\");\n            if (! locale)\n              return 2;\n            for (i = CHAR_MIN; i <= CHAR_MAX; i++)\n              {\n                char c = i;\n                wchar_t wc;\n                mbstate_t mbs = { 0, };\n                size_t ss = mbrtowc (&wc, &c, 1, &mbs);\n                if (1 < ss)\n                  return 3;\n              }\n            return 0;\n          ]])],\n       [gl_cv_func_mbrtowc_C_locale_sans_EILSEQ=yes],\n       [gl_cv_func_mbrtowc_C_locale_sans_EILSEQ=no],\n       [case \"$host_os\" in\n                             # Guess yes on native Windows.\n          mingw* | windows*) gl_cv_func_mbrtowc_C_locale_sans_EILSEQ=\"guessing yes\" ;;\n          *)                 gl_cv_func_mbrtowc_C_locale_sans_EILSEQ=\"$gl_cross_guess_normal\" ;;\n        esac\n       ])\n    ])\n])\n\n# Prerequisites of lib/mbrtowc.c and lib/lc-charset-dispatch.c.\nAC_DEFUN([gl_PREREQ_MBRTOWC], [\n  AC_REQUIRE([AC_C_INLINE])\n  :\n])\n\n# Prerequisites of lib/mbtowc-lock.c.\nAC_DEFUN([gl_PREREQ_MBTOWC_LOCK],\n[\n  gl_VISIBILITY\n])\n\n\ndnl From Paul Eggert\n\ndnl This is an override of an autoconf macro.\n\nAC_DEFUN([AC_FUNC_MBRTOWC],\n[\n  dnl Same as AC_FUNC_MBRTOWC in autoconf-2.60.\n  AC_CACHE_CHECK([whether mbrtowc and mbstate_t are properly declared],\n    [gl_cv_func_mbrtowc],\n    [AC_LINK_IFELSE(\n       [AC_LANG_PROGRAM(\n            [[#include <wchar.h>]],\n            [[wchar_t wc;\n              char const s[] = \"\";\n              size_t n = 1;\n              mbstate_t state;\n              return ! (sizeof state && (mbrtowc) (&wc, s, n, &state));]])],\n       [gl_cv_func_mbrtowc=yes],\n       [gl_cv_func_mbrtowc=no])])\n  if test $gl_cv_func_mbrtowc = yes; then\n    AC_DEFINE([HAVE_MBRTOWC], [1],\n      [Define to 1 if mbrtowc and mbstate_t are properly declared.])\n  fi\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}