{
  "module_name": "stdint.m4",
  "hash_id": "51be1b3de7921d3199e960ba088694d856c5b9b09fa2edcf73df9ef5d8159f7a",
  "original_prompt": "Ingested from coreutils-9.4/m4/stdint.m4",
  "human_readable_source": "# stdint.m4 serial 63\ndnl Copyright (C) 2001-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Paul Eggert and Bruno Haible.\ndnl Test whether <stdint.h> is supported or must be substituted.\n\nAC_PREREQ([2.61])\n\nAC_DEFUN_ONCE([gl_STDINT_H],\n[\n  AC_PREREQ([2.59])dnl\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n  AC_REQUIRE([gl_LIMITS_H])\n  AC_REQUIRE([gt_TYPE_WINT_T])\n\n  dnl For backward compatibility. Some packages may still be testing these\n  dnl macros.\n  AC_DEFINE([HAVE_LONG_LONG_INT], [1],\n    [Define to 1 if the system has the type 'long long int'.])\n  AC_DEFINE([HAVE_UNSIGNED_LONG_LONG_INT], [1],\n    [Define to 1 if the system has the type 'unsigned long long int'.])\n\n  dnl Check for <wchar.h>, in the same way as gl_WCHAR_H does.\n  AC_CHECK_HEADERS_ONCE([wchar.h])\n  if test $ac_cv_header_wchar_h = yes; then\n    HAVE_WCHAR_H=1\n  else\n    HAVE_WCHAR_H=0\n  fi\n  AC_SUBST([HAVE_WCHAR_H])\n\n  dnl Check for <inttypes.h>.\n  AC_CHECK_HEADERS_ONCE([inttypes.h])\n  if test $ac_cv_header_inttypes_h = yes; then\n    HAVE_INTTYPES_H=1\n  else\n    HAVE_INTTYPES_H=0\n  fi\n  AC_SUBST([HAVE_INTTYPES_H])\n\n  dnl Check for <sys/types.h>.\n  AC_CHECK_HEADERS_ONCE([sys/types.h])\n  if test $ac_cv_header_sys_types_h = yes; then\n    HAVE_SYS_TYPES_H=1\n  else\n    HAVE_SYS_TYPES_H=0\n  fi\n  AC_SUBST([HAVE_SYS_TYPES_H])\n\n  gl_CHECK_NEXT_HEADERS([stdint.h])\n  if test $ac_cv_header_stdint_h = yes; then\n    HAVE_STDINT_H=1\n  else\n    HAVE_STDINT_H=0\n  fi\n  AC_SUBST([HAVE_STDINT_H])\n\n  dnl Now see whether we need a substitute <stdint.h>.\n  if test $ac_cv_header_stdint_h = yes; then\n    AC_CACHE_CHECK([whether stdint.h conforms to C99],\n      [gl_cv_header_working_stdint_h],\n      [gl_cv_header_working_stdint_h=no\n       AC_COMPILE_IFELSE([\n         AC_LANG_PROGRAM([[\n#define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1 /* work if build isn't clean */\n#define __STDC_CONSTANT_MACROS 1\n#define __STDC_LIMIT_MACROS 1\n#include <stdint.h>\n/* Dragonfly defines WCHAR_MIN, WCHAR_MAX only in <wchar.h>.  */\n#if !(defined WCHAR_MIN && defined WCHAR_MAX)\n#error \"WCHAR_MIN, WCHAR_MAX not defined in <stdint.h>\"\n#endif\n]\ngl_STDINT_INCLUDES\n[\n#ifdef INT8_MAX\nint8_t a1 = INT8_MAX;\nint8_t a1min = INT8_MIN;\n#endif\n#ifdef INT16_MAX\nint16_t a2 = INT16_MAX;\nint16_t a2min = INT16_MIN;\n#endif\n#ifdef INT32_MAX\nint32_t a3 = INT32_MAX;\nint32_t a3min = INT32_MIN;\n#endif\n#ifdef INT64_MAX\nint64_t a4 = INT64_MAX;\nint64_t a4min = INT64_MIN;\n#endif\n#ifdef UINT8_MAX\nuint8_t b1 = UINT8_MAX;\n#else\ntypedef int b1[(unsigned char) -1 != 255 ? 1 : -1];\n#endif\n#ifdef UINT16_MAX\nuint16_t b2 = UINT16_MAX;\n#endif\n#ifdef UINT32_MAX\nuint32_t b3 = UINT32_MAX;\n#endif\n#ifdef UINT64_MAX\nuint64_t b4 = UINT64_MAX;\n#endif\nint_least8_t c1 = INT8_C (0x7f);\nint_least8_t c1max = INT_LEAST8_MAX;\nint_least8_t c1min = INT_LEAST8_MIN;\nint_least16_t c2 = INT16_C (0x7fff);\nint_least16_t c2max = INT_LEAST16_MAX;\nint_least16_t c2min = INT_LEAST16_MIN;\nint_least32_t c3 = INT32_C (0x7fffffff);\nint_least32_t c3max = INT_LEAST32_MAX;\nint_least32_t c3min = INT_LEAST32_MIN;\nint_least64_t c4 = INT64_C (0x7fffffffffffffff);\nint_least64_t c4max = INT_LEAST64_MAX;\nint_least64_t c4min = INT_LEAST64_MIN;\nuint_least8_t d1 = UINT8_C (0xff);\nuint_least8_t d1max = UINT_LEAST8_MAX;\nuint_least16_t d2 = UINT16_C (0xffff);\nuint_least16_t d2max = UINT_LEAST16_MAX;\nuint_least32_t d3 = UINT32_C (0xffffffff);\nuint_least32_t d3max = UINT_LEAST32_MAX;\nuint_least64_t d4 = UINT64_C (0xffffffffffffffff);\nuint_least64_t d4max = UINT_LEAST64_MAX;\nint_fast8_t e1 = INT_FAST8_MAX;\nint_fast8_t e1min = INT_FAST8_MIN;\nint_fast16_t e2 = INT_FAST16_MAX;\nint_fast16_t e2min = INT_FAST16_MIN;\nint_fast32_t e3 = INT_FAST32_MAX;\nint_fast32_t e3min = INT_FAST32_MIN;\nint_fast64_t e4 = INT_FAST64_MAX;\nint_fast64_t e4min = INT_FAST64_MIN;\nuint_fast8_t f1 = UINT_FAST8_MAX;\nuint_fast16_t f2 = UINT_FAST16_MAX;\nuint_fast32_t f3 = UINT_FAST32_MAX;\nuint_fast64_t f4 = UINT_FAST64_MAX;\n#ifdef INTPTR_MAX\nintptr_t g = INTPTR_MAX;\nintptr_t gmin = INTPTR_MIN;\n#endif\n#ifdef UINTPTR_MAX\nuintptr_t h = UINTPTR_MAX;\n#endif\nintmax_t i = INTMAX_MAX;\nuintmax_t j = UINTMAX_MAX;\n\n/* Check that SIZE_MAX has the correct type, if possible.  */\n/* ISO C 11 mandates _Generic, but GCC versions < 4.9 lack it.  */\n#if 201112 <= __STDC_VERSION__ \\\n    && (!defined __GNUC__ || 4 < __GNUC__ + (9 <= __GNUC_MINOR__) \\\n        || defined __clang__)\nint k = _Generic (SIZE_MAX, size_t: 0);\n#elif (2 <= __GNUC__ || 4 <= __clang_major__ || defined __IBM__TYPEOF__ \\\n       || (0x5110 <= __SUNPRO_C && !__STDC__))\nextern size_t k;\nextern __typeof__ (SIZE_MAX) k;\n#endif\n\n#include <limits.h> /* for CHAR_BIT */\n#define TYPE_MINIMUM(t) \\\n  ((t) ((t) 0 < (t) -1 ? (t) 0 : ~ TYPE_MAXIMUM (t)))\n#define TYPE_MAXIMUM(t) \\\n  ((t) ((t) 0 < (t) -1 \\\n        ? (t) -1 \\\n        : ((((t) 1 << (sizeof (t) * CHAR_BIT - 2)) - 1) * 2 + 1)))\nstruct s {\n  int check_PTRDIFF:\n      PTRDIFF_MIN == TYPE_MINIMUM (ptrdiff_t)\n      && PTRDIFF_MAX == TYPE_MAXIMUM (ptrdiff_t)\n      ? 1 : -1;\n  /* Detect bug in FreeBSD 6.0/ia64 and FreeBSD 13.0/arm64.  */\n  int check_SIG_ATOMIC:\n      SIG_ATOMIC_MIN == TYPE_MINIMUM (sig_atomic_t)\n      && SIG_ATOMIC_MAX == TYPE_MAXIMUM (sig_atomic_t)\n      ? 1 : -1;\n  int check_SIZE: SIZE_MAX == TYPE_MAXIMUM (size_t) ? 1 : -1;\n  int check_WCHAR:\n      WCHAR_MIN == TYPE_MINIMUM (wchar_t)\n      && WCHAR_MAX == TYPE_MAXIMUM (wchar_t)\n      ? 1 : -1;\n  /* Detect bug in mingw.  */\n  int check_WINT:\n      WINT_MIN == TYPE_MINIMUM (wint_t)\n      && WINT_MAX == TYPE_MAXIMUM (wint_t)\n      ? 1 : -1;\n\n  /* Detect bugs in glibc 2.4 and Solaris 10 stdint.h, among others.  */\n  int check_UINT8_C:\n        (-1 < UINT8_C (0)) == (-1 < (uint_least8_t) 0) ? 1 : -1;\n  int check_UINT16_C:\n        (-1 < UINT16_C (0)) == (-1 < (uint_least16_t) 0) ? 1 : -1;\n\n  /* Detect bugs in OpenBSD 3.9 stdint.h.  */\n#ifdef UINT8_MAX\n  int check_uint8: (uint8_t) -1 == UINT8_MAX ? 1 : -1;\n#endif\n#ifdef UINT16_MAX\n  int check_uint16: (uint16_t) -1 == UINT16_MAX ? 1 : -1;\n#endif\n#ifdef UINT32_MAX\n  int check_uint32: (uint32_t) -1 == UINT32_MAX ? 1 : -1;\n#endif\n#ifdef UINT64_MAX\n  int check_uint64: (uint64_t) -1 == UINT64_MAX ? 1 : -1;\n#endif\n  int check_uint_least8: (uint_least8_t) -1 == UINT_LEAST8_MAX ? 1 : -1;\n  int check_uint_least16: (uint_least16_t) -1 == UINT_LEAST16_MAX ? 1 : -1;\n  int check_uint_least32: (uint_least32_t) -1 == UINT_LEAST32_MAX ? 1 : -1;\n  int check_uint_least64: (uint_least64_t) -1 == UINT_LEAST64_MAX ? 1 : -1;\n  int check_uint_fast8: (uint_fast8_t) -1 == UINT_FAST8_MAX ? 1 : -1;\n  int check_uint_fast16: (uint_fast16_t) -1 == UINT_FAST16_MAX ? 1 : -1;\n  int check_uint_fast32: (uint_fast32_t) -1 == UINT_FAST32_MAX ? 1 : -1;\n  int check_uint_fast64: (uint_fast64_t) -1 == UINT_FAST64_MAX ? 1 : -1;\n  int check_uintptr: (uintptr_t) -1 == UINTPTR_MAX ? 1 : -1;\n  int check_uintmax: (uintmax_t) -1 == UINTMAX_MAX ? 1 : -1;\n  int check_size: (size_t) -1 == SIZE_MAX ? 1 : -1;\n};\n         ]])],\n         [dnl Determine whether the various *_MIN, *_MAX macros are usable\n          dnl in preprocessor expression. We could do it by compiling a test\n          dnl program for each of these macros. It is faster to run a program\n          dnl that inspects the macro expansion.\n          dnl This detects a bug on HP-UX 11.23/ia64.\n          AC_RUN_IFELSE([\n            AC_LANG_PROGRAM([[\n#define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1 /* work if build isn't clean */\n#define __STDC_CONSTANT_MACROS 1\n#define __STDC_LIMIT_MACROS 1\n#include <stdint.h>\n]\ngl_STDINT_INCLUDES\n[\n#include <stdio.h>\n#include <string.h>\n#define MVAL(macro) MVAL1(macro)\n#define MVAL1(expression) #expression\nstatic const char *macro_values[] =\n  {\n#ifdef INT8_MAX\n    MVAL (INT8_MAX),\n#endif\n#ifdef INT16_MAX\n    MVAL (INT16_MAX),\n#endif\n#ifdef INT32_MAX\n    MVAL (INT32_MAX),\n#endif\n#ifdef INT64_MAX\n    MVAL (INT64_MAX),\n#endif\n#ifdef UINT8_MAX\n    MVAL (UINT8_MAX),\n#endif\n#ifdef UINT16_MAX\n    MVAL (UINT16_MAX),\n#endif\n#ifdef UINT32_MAX\n    MVAL (UINT32_MAX),\n#endif\n#ifdef UINT64_MAX\n    MVAL (UINT64_MAX),\n#endif\n    NULL\n  };\n]], [[\n  const char **mv;\n  for (mv = macro_values; *mv != NULL; mv++)\n    {\n      const char *value = *mv;\n      /* Test whether it looks like a cast expression.  */\n      if (strncmp (value, \"((unsigned int)\"/*)*/, 15) == 0\n          || strncmp (value, \"((unsigned short)\"/*)*/, 17) == 0\n          || strncmp (value, \"((unsigned char)\"/*)*/, 16) == 0\n          || strncmp (value, \"((int)\"/*)*/, 6) == 0\n          || strncmp (value, \"((signed short)\"/*)*/, 15) == 0\n          || strncmp (value, \"((signed char)\"/*)*/, 14) == 0)\n        return mv - macro_values + 1;\n    }\n  return 0;\n]])],\n              [gl_cv_header_working_stdint_h=yes],\n              [],\n              [case \"$host_os\" in\n                                    # Guess yes on native Windows.\n                 mingw* | windows*) gl_cv_header_working_stdint_h=\"guessing yes\" ;;\n                                    # In general, assume it works.\n                 *)                 gl_cv_header_working_stdint_h=\"guessing yes\" ;;\n               esac\n              ])\n         ])\n      ])\n  fi\n\n  HAVE_C99_STDINT_H=0\n  HAVE_SYS_BITYPES_H=0\n  HAVE_SYS_INTTYPES_H=0\n  GL_GENERATE_STDINT_H=true\n  case \"$gl_cv_header_working_stdint_h\" in\n    *yes)\n      HAVE_C99_STDINT_H=1\n      dnl Now see whether the system <stdint.h> works without\n      dnl __STDC_CONSTANT_MACROS/__STDC_LIMIT_MACROS defined.\n      dnl If not, there would be problems when stdint.h is included from C++.\n      AC_CACHE_CHECK([whether stdint.h works without ISO C predefines],\n        [gl_cv_header_stdint_without_STDC_macros],\n        [gl_cv_header_stdint_without_STDC_macros=no\n         AC_COMPILE_IFELSE([\n           AC_LANG_PROGRAM([[\n#define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1 /* work if build isn't clean */\n#include <stdint.h>\n]\ngl_STDINT_INCLUDES\n[\nintmax_t im = INTMAX_MAX;\nint32_t i32 = INT32_C (0x7fffffff);\n           ]])],\n           [gl_cv_header_stdint_without_STDC_macros=yes])\n        ])\n\n      if test $gl_cv_header_stdint_without_STDC_macros = no; then\n        AC_DEFINE([__STDC_CONSTANT_MACROS], [1],\n          [Define to 1 if the system <stdint.h> predates C++11.])\n        AC_DEFINE([__STDC_LIMIT_MACROS], [1],\n          [Define to 1 if the system <stdint.h> predates C++11.])\n      fi\n      AC_CACHE_CHECK([whether stdint.h has UINTMAX_WIDTH etc.],\n        [gl_cv_header_stdint_width],\n        [gl_cv_header_stdint_width=no\n         AC_COMPILE_IFELSE(\n           [AC_LANG_PROGRAM([[\n              /* Work if build is not clean.  */\n              #define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1\n              #ifndef __STDC_WANT_IEC_60559_BFP_EXT__\n               #define __STDC_WANT_IEC_60559_BFP_EXT__ 1\n              #endif\n              #include <stdint.h>\n              ]gl_STDINT_INCLUDES[\n              int iw = UINTMAX_WIDTH;\n              ]])],\n           [gl_cv_header_stdint_width=yes])])\n      if test \"$gl_cv_header_stdint_width\" = yes; then\n        GL_GENERATE_STDINT_H=false\n      fi\n      ;;\n    *)\n      dnl Check for <sys/inttypes.h>, and for\n      dnl <sys/bitypes.h> (used in Linux libc4 >= 4.6.7 and libc5).\n      AC_CHECK_HEADERS([sys/inttypes.h sys/bitypes.h])\n      if test $ac_cv_header_sys_inttypes_h = yes; then\n        HAVE_SYS_INTTYPES_H=1\n      fi\n      if test $ac_cv_header_sys_bitypes_h = yes; then\n        HAVE_SYS_BITYPES_H=1\n      fi\n      gl_STDINT_TYPE_PROPERTIES\n      ;;\n  esac\n\n  dnl The substitute stdint.h needs the substitute limit.h's _GL_INTEGER_WIDTH.\n  gl_REPLACE_LIMITS_H\n\n  AC_SUBST([HAVE_C99_STDINT_H])\n  AC_SUBST([HAVE_SYS_BITYPES_H])\n  AC_SUBST([HAVE_SYS_INTTYPES_H])\n])\n\ndnl gl_STDINT_BITSIZEOF(TYPES, INCLUDES)\ndnl Determine the size of each of the given types in bits.\nAC_DEFUN([gl_STDINT_BITSIZEOF],\n[\n  dnl Use a shell loop, to avoid bloating configure, and\n  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into\n  dnl   config.h.in,\n  dnl - extra AC_SUBST calls, so that the right substitutions are made.\n  m4_foreach_w([gltype], [$1],\n    [AH_TEMPLATE([BITSIZEOF_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),\n       [Define to the number of bits in type ']gltype['.])])\n  for gltype in $1 ; do\n    AC_CACHE_CHECK([for bit size of $gltype], [gl_cv_bitsizeof_${gltype}],\n      [AC_COMPUTE_INT([result], [sizeof ($gltype) * CHAR_BIT],\n         [$2\n#include <limits.h>], [result=unknown])\n       eval gl_cv_bitsizeof_${gltype}=\\$result\n      ])\n    eval result=\\$gl_cv_bitsizeof_${gltype}\n    if test $result = unknown; then\n      dnl Use a nonempty default, because some compilers, such as IRIX 5 cc,\n      dnl do a syntax check even on unused #if conditions and give an error\n      dnl on valid C code like this:\n      dnl   #if 0\n      dnl   # if  > 32\n      dnl   # endif\n      dnl   #endif\n      result=0\n    fi\n    GLTYPE=`echo \"$gltype\" | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`\n    AC_DEFINE_UNQUOTED([BITSIZEOF_${GLTYPE}], [$result])\n    eval BITSIZEOF_${GLTYPE}=\\$result\n  done\n  m4_foreach_w([gltype], [$1],\n    [AC_SUBST([BITSIZEOF_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])\n])\n\ndnl gl_CHECK_TYPES_SIGNED(TYPES, INCLUDES)\ndnl Determine the signedness of each of the given types.\ndnl Define HAVE_SIGNED_TYPE if type is signed.\nAC_DEFUN([gl_CHECK_TYPES_SIGNED],\n[\n  dnl Use a shell loop, to avoid bloating configure, and\n  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into\n  dnl   config.h.in,\n  dnl - extra AC_SUBST calls, so that the right substitutions are made.\n  m4_foreach_w([gltype], [$1],\n    [AH_TEMPLATE([HAVE_SIGNED_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),\n       [Define to 1 if ']gltype[' is a signed integer type.])])\n  for gltype in $1 ; do\n    AC_CACHE_CHECK([whether $gltype is signed], [gl_cv_type_${gltype}_signed],\n      [AC_COMPILE_IFELSE(\n         [AC_LANG_PROGRAM([$2[\n            int verify[2 * (($gltype) -1 < ($gltype) 0) - 1];]])],\n         result=yes, result=no)\n       eval gl_cv_type_${gltype}_signed=\\$result\n      ])\n    eval result=\\$gl_cv_type_${gltype}_signed\n    GLTYPE=`echo $gltype | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`\n    if test \"$result\" = yes; then\n      AC_DEFINE_UNQUOTED([HAVE_SIGNED_${GLTYPE}], [1])\n      eval HAVE_SIGNED_${GLTYPE}=1\n    else\n      eval HAVE_SIGNED_${GLTYPE}=0\n    fi\n  done\n  m4_foreach_w([gltype], [$1],\n    [AC_SUBST([HAVE_SIGNED_]m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])\n])\n\ndnl gl_INTEGER_TYPE_SUFFIX(TYPES, INCLUDES)\ndnl Determine the suffix to use for integer constants of the given types.\ndnl Define t_SUFFIX for each such type.\nAC_DEFUN([gl_INTEGER_TYPE_SUFFIX],\n[\n  dnl Use a shell loop, to avoid bloating configure, and\n  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into\n  dnl   config.h.in,\n  dnl - extra AC_SUBST calls, so that the right substitutions are made.\n  m4_foreach_w([gltype], [$1],\n    [AH_TEMPLATE(m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX],\n       [Define to l, ll, u, ul, ull, etc., as suitable for\n        constants of type ']gltype['.])])\n  for gltype in $1 ; do\n    AC_CACHE_CHECK([for $gltype integer literal suffix],\n      [gl_cv_type_${gltype}_suffix],\n      [eval gl_cv_type_${gltype}_suffix=no\n       eval result=\\$gl_cv_type_${gltype}_signed\n       if test \"$result\" = yes; then\n         glsufu=\n       else\n         glsufu=u\n       fi\n       for glsuf in \"$glsufu\" ${glsufu}l ${glsufu}ll ${glsufu}i64; do\n         case $glsuf in\n           '')  gltype1='int';;\n           l)   gltype1='long int';;\n           ll)  gltype1='long long int';;\n           i64) gltype1='__int64';;\n           u)   gltype1='unsigned int';;\n           ul)  gltype1='unsigned long int';;\n           ull) gltype1='unsigned long long int';;\n           ui64)gltype1='unsigned __int64';;\n         esac\n         AC_COMPILE_IFELSE(\n           [AC_LANG_PROGRAM([$2[\n              extern $gltype foo;\n              extern $gltype1 foo;]])],\n           [eval gl_cv_type_${gltype}_suffix=\\$glsuf])\n         eval result=\\$gl_cv_type_${gltype}_suffix\n         test \"$result\" != no && break\n       done])\n    GLTYPE=`echo $gltype | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`\n    eval result=\\$gl_cv_type_${gltype}_suffix\n    test \"$result\" = no && result=\n    eval ${GLTYPE}_SUFFIX=\\$result\n    AC_DEFINE_UNQUOTED([${GLTYPE}_SUFFIX], [$result])\n  done\n  m4_foreach_w([gltype], [$1],\n    [AC_SUBST(m4_translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX])])\n])\n\ndnl gl_STDINT_INCLUDES\nAC_DEFUN([gl_STDINT_INCLUDES],\n[[\n  #include <stddef.h>\n  #include <signal.h>\n  #if HAVE_WCHAR_H\n  # include <wchar.h>\n  #endif\n]])\n\ndnl gl_STDINT_TYPE_PROPERTIES\ndnl Compute HAVE_SIGNED_t, BITSIZEOF_t and t_SUFFIX, for all the types t\ndnl of interest to stdint.in.h.\nAC_DEFUN([gl_STDINT_TYPE_PROPERTIES],\n[\n  AC_REQUIRE([gl_MULTIARCH])\n  if test $APPLE_UNIVERSAL_BUILD = 0; then\n    gl_STDINT_BITSIZEOF([ptrdiff_t size_t],\n      [gl_STDINT_INCLUDES])\n  fi\n  gl_STDINT_BITSIZEOF([sig_atomic_t wchar_t wint_t],\n    [gl_STDINT_INCLUDES])\n  gl_CHECK_TYPES_SIGNED([sig_atomic_t wchar_t wint_t],\n    [gl_STDINT_INCLUDES])\n  gl_cv_type_ptrdiff_t_signed=yes\n  gl_cv_type_size_t_signed=no\n  if test $APPLE_UNIVERSAL_BUILD = 0; then\n    gl_INTEGER_TYPE_SUFFIX([ptrdiff_t size_t],\n      [gl_STDINT_INCLUDES])\n  fi\n  gl_INTEGER_TYPE_SUFFIX([sig_atomic_t wchar_t wint_t],\n    [gl_STDINT_INCLUDES])\n\n  dnl If wint_t is smaller than 'int', it cannot satisfy the ISO C 99\n  dnl requirement that wint_t is \"unchanged by default argument promotions\".\n  dnl In this case gnulib's <wchar.h> and <wctype.h> override wint_t.\n  dnl Set the variable BITSIZEOF_WINT_T accordingly.\n  if test $GNULIBHEADERS_OVERRIDE_WINT_T = 1; then\n    BITSIZEOF_WINT_T=32\n  fi\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}