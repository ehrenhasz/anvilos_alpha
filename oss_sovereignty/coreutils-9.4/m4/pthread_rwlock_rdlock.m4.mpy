{
  "module_name": "pthread_rwlock_rdlock.m4",
  "hash_id": "46ecd33f8a0e23ac27042123f375e0d92e846b227c0c08bcfa76dde9f2f35a43",
  "original_prompt": "Ingested from coreutils-9.4/m4/pthread_rwlock_rdlock.m4",
  "human_readable_source": "# pthread_rwlock_rdlock.m4 serial 6\ndnl Copyright (C) 2017-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\ndnl Inspired by\ndnl https://github.com/linux-test-project/ltp/blob/master/testcases/open_posix_testsuite/conformance/interfaces/pthread_rwlock_rdlock/2-2.c\ndnl by Intel Corporation.\n\ndnl Test whether in a situation where\ndnl   - an rwlock is taken by a reader and has a writer waiting,\ndnl   - an additional reader requests the lock,\ndnl   - the waiting writer and the requesting reader threads have the same\ndnl     priority,\ndnl the requesting reader thread gets blocked, so that at some point the\ndnl waiting writer can acquire the lock.\ndnl Without such a guarantee, when there a N readers and each of the readers\ndnl spends more than 1/Nth of the time with the lock held, there is a high\ndnl probability that the waiting writer will not get the lock in a given finite\ndnl time, a phenomenon called \"writer starvation\".\ndnl Without such a guarantee, applications have a hard time avoiding writer\ndnl starvation.\ndnl\ndnl POSIX:2017 makes this requirement only for implementations that support TPS\ndnl (Thread Priority Scheduling) and only for the scheduling policies SCHED_FIFO\ndnl and SCHED_RR, see\ndnl https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_rdlock.html\ndnl but this test verifies the guarantee regardless of TPS and regardless of\ndnl scheduling policy.\ndnl Glibc does not provide this guarantee (and never will on Linux), see\ndnl https://sourceware.org/bugzilla/show_bug.cgi?id=13701\ndnl https://bugzilla.redhat.com/show_bug.cgi?id=1410052\nAC_DEFUN([gl_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER],\n[\n  AC_REQUIRE([gl_THREADLIB_EARLY])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether pthread_rwlock_rdlock prefers a writer to a reader],\n    [gl_cv_pthread_rwlock_rdlock_prefer_writer],\n    [save_LIBS=\"$LIBS\"\n     LIBS=\"$LIBS $LIBMULTITHREAD\"\n     AC_RUN_IFELSE(\n       [AC_LANG_SOURCE([[\n#include <errno.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define SUCCEED() exit (0)\n#define FAILURE() exit (1)\n#define UNEXPECTED(n) (exit (10 + (n)))\n\n/* The main thread creates the waiting writer and the requesting reader threads\n   in the default way; this guarantees that they have the same priority.\n   We can reuse the main thread as first reader thread.  */\n\nstatic pthread_rwlock_t lock;\nstatic pthread_t reader1;\nstatic pthread_t writer;\nstatic pthread_t reader2;\nstatic pthread_t timer;\n/* Used to pass control from writer to reader2 and from reader2 to timer,\n   as in a relay race.\n   Passing control from one running thread to another running thread\n   is most likely faster than to create the second thread.  */\nstatic pthread_mutex_t baton;\n\nstatic void *\ntimer_func (void *ignored)\n{\n  /* Step 13 (can be before or after step 12):\n     The timer thread takes the baton, then waits a moment to make sure\n     it can tell whether the second reader thread is blocked at step 12.  */\n  if (pthread_mutex_lock (&baton))\n    UNEXPECTED (13);\n  usleep (100000);\n  /* By the time we get here, it's clear that the second reader thread is\n     blocked at step 12.  This is the desired behaviour.  */\n  SUCCEED ();\n}\n\nstatic void *\nreader2_func (void *ignored)\n{\n  int err;\n\n  /* Step 8 (can be before or after step 7):\n     The second reader thread takes the baton, then waits a moment to make sure\n     the writer thread has reached step 7.  */\n  if (pthread_mutex_lock (&baton))\n    UNEXPECTED (8);\n  usleep (100000);\n  /* Step 9: The second reader thread requests the lock.  */\n  err = pthread_rwlock_tryrdlock (&lock);\n  if (err == 0)\n    FAILURE ();\n  else if (err != EBUSY)\n    UNEXPECTED (9);\n  /* Step 10: Launch a timer, to test whether the next call blocks.  */\n  if (pthread_create (&timer, NULL, timer_func, NULL))\n    UNEXPECTED (10);\n  /* Step 11: Release the baton.  */\n  if (pthread_mutex_unlock (&baton))\n    UNEXPECTED (11);\n  /* Step 12: The second reader thread requests the lock.  */\n  err = pthread_rwlock_rdlock (&lock);\n  if (err == 0)\n    FAILURE ();\n  else\n    UNEXPECTED (12);\n}\n\nstatic void *\nwriter_func (void *ignored)\n{\n  /* Step 4: Take the baton, so that the second reader thread does not go ahead\n     too early.  */\n  if (pthread_mutex_lock (&baton))\n    UNEXPECTED (4);\n  /* Step 5: Create the second reader thread.  */\n  if (pthread_create (&reader2, NULL, reader2_func, NULL))\n    UNEXPECTED (5);\n  /* Step 6: Release the baton.  */\n  if (pthread_mutex_unlock (&baton))\n    UNEXPECTED (6);\n  /* Step 7: The writer thread requests the lock.  */\n  if (pthread_rwlock_wrlock (&lock))\n    UNEXPECTED (7);\n  return NULL;\n}\n\nint\nmain ()\n{\n  reader1 = pthread_self ();\n\n  /* Step 1: The main thread initializes the lock and the baton.  */\n  if (pthread_rwlock_init (&lock, NULL))\n    UNEXPECTED (1);\n  if (pthread_mutex_init (&baton, NULL))\n    UNEXPECTED (1);\n  /* Step 2: The main thread acquires the lock as a reader.  */\n  if (pthread_rwlock_rdlock (&lock))\n    UNEXPECTED (2);\n  /* Step 3: Create the writer thread.  */\n  if (pthread_create (&writer, NULL, writer_func, NULL))\n    UNEXPECTED (3);\n  /* Job done.  Go to sleep.  */\n  for (;;)\n    {\n      sleep (1);\n    }\n}\n]])],\n       [gl_cv_pthread_rwlock_rdlock_prefer_writer=yes],\n       [gl_cv_pthread_rwlock_rdlock_prefer_writer=no],\n       [case \"$host_os\" in\n                              # Guess no on glibc systems.\n          *-gnu* | gnu*)      gl_cv_pthread_rwlock_rdlock_prefer_writer=\"guessing no\" ;;\n                              # Guess no on musl systems.\n          *-musl* | midipix*) gl_cv_pthread_rwlock_rdlock_prefer_writer=\"guessing no\" ;;\n                              # Guess no on bionic systems.\n          *-android*)         gl_cv_pthread_rwlock_rdlock_prefer_writer=\"guessing no\" ;;\n                              # Guess yes on native Windows with the mingw-w64 winpthreads library.\n                              # Guess no on native Windows with the gnulib windows-rwlock module.\n          mingw* | windows*)  if test \"$gl_use_threads\" = yes || test \"$gl_use_threads\" = posix; then\n                                gl_cv_pthread_rwlock_rdlock_prefer_writer=\"guessing yes\"\n                              else\n                                gl_cv_pthread_rwlock_rdlock_prefer_writer=\"guessing no\"\n                              fi\n                              ;;\n                              # If we don't know, obey --enable-cross-guesses.\n          *)                  gl_cv_pthread_rwlock_rdlock_prefer_writer=\"$gl_cross_guess_normal\" ;;\n         esac\n       ])\n     LIBS=\"$save_LIBS\"\n    ])\n  case \"$gl_cv_pthread_rwlock_rdlock_prefer_writer\" in\n    *yes)\n      AC_DEFINE([HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER], [1],\n        [Define if the 'pthread_rwlock_rdlock' function prefers a writer to a reader.])\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}