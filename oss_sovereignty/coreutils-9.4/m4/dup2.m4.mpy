{
  "module_name": "dup2.m4",
  "hash_id": "fadc4ad6093d824ad20d3488f41cb187e8bcad375fea168decc77992355e8e20",
  "original_prompt": "Ingested from coreutils-9.4/m4/dup2.m4",
  "human_readable_source": "#serial 28\ndnl Copyright (C) 2002, 2005, 2007, 2009-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_DUP2],\n[\n  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CACHE_CHECK([whether dup2 works], [gl_cv_func_dup2_works],\n    [AC_RUN_IFELSE([\n       AC_LANG_PROGRAM(\n         [[#include <errno.h>\n           #include <fcntl.h>\n           #include <limits.h>\n           #include <sys/resource.h>\n           #include <unistd.h>\n           ]GL_MDA_DEFINES[\n           #ifndef RLIM_SAVED_CUR\n           # define RLIM_SAVED_CUR RLIM_INFINITY\n           #endif\n           #ifndef RLIM_SAVED_MAX\n           # define RLIM_SAVED_MAX RLIM_INFINITY\n           #endif\n         ]],\n         [[int result = 0;\n           int bad_fd = INT_MAX;\n           struct rlimit rlim;\n           if (getrlimit (RLIMIT_NOFILE, &rlim) == 0\n               && 0 <= rlim.rlim_cur && rlim.rlim_cur <= INT_MAX\n               && rlim.rlim_cur != RLIM_INFINITY\n               && rlim.rlim_cur != RLIM_SAVED_MAX\n               && rlim.rlim_cur != RLIM_SAVED_CUR)\n             bad_fd = rlim.rlim_cur;\n           #ifdef FD_CLOEXEC\n             if (fcntl (1, F_SETFD, FD_CLOEXEC) == -1)\n               result |= 1;\n           #endif\n           if (dup2 (1, 1) != 1)\n             result |= 2;\n           #ifdef FD_CLOEXEC\n             if (fcntl (1, F_GETFD) != FD_CLOEXEC)\n               result |= 4;\n           #endif\n           close (0);\n           if (dup2 (0, 0) != -1)\n             result |= 8;\n           /* Many gnulib modules require POSIX conformance of EBADF.  */\n           if (dup2 (2, bad_fd) == -1 && errno != EBADF)\n             result |= 16;\n           /* Flush out some cygwin core dumps.  */\n           if (dup2 (2, -1) != -1 || errno != EBADF)\n             result |= 32;\n           dup2 (2, 255);\n           dup2 (2, 256);\n           /* On OS/2 kLIBC, dup2() does not work on a directory fd.  */\n           {\n             int fd = open (\".\", O_RDONLY);\n             if (fd == -1)\n               result |= 64;\n             else if (dup2 (fd, fd + 1) == -1)\n               result |= 128;\n             close (fd);\n           }\n           return result;]])\n      ],\n      [gl_cv_func_dup2_works=yes], [gl_cv_func_dup2_works=no],\n      [case \"$host_os\" in\n         mingw* | windows*) # on this platform, dup2 always returns 0 for success\n           gl_cv_func_dup2_works=\"guessing no\" ;;\n         cygwin*) # on cygwin 1.5.x, dup2(1,1) returns 0\n           gl_cv_func_dup2_works=\"guessing no\" ;;\n         aix* | freebsd*)\n                 # on AIX 7.1 and FreeBSD 6.1, dup2 (1,toobig) gives EMFILE,\n                 # not EBADF.\n           gl_cv_func_dup2_works=\"guessing no\" ;;\n         haiku*) # on Haiku alpha 2, dup2(1, 1) resets FD_CLOEXEC.\n           gl_cv_func_dup2_works=\"guessing no\" ;;\n         *-android*) # implemented using dup3(), which fails if oldfd == newfd\n           gl_cv_func_dup2_works=\"guessing no\" ;;\n         os2*) # on OS/2 kLIBC, dup2() does not work on a directory fd.\n           gl_cv_func_dup2_works=\"guessing no\" ;;\n         *) gl_cv_func_dup2_works=\"guessing yes\" ;;\n       esac])\n    ])\n  case \"$gl_cv_func_dup2_works\" in\n    *yes) ;;\n    *)\n      REPLACE_DUP2=1\n      AC_CHECK_FUNCS([setdtablesize])\n      ;;\n  esac\n  dnl Replace dup2() for supporting the gnulib-defined fchdir() function,\n  dnl to keep fchdir's bookkeeping up-to-date.\n  m4_ifdef([gl_FUNC_FCHDIR], [\n    gl_TEST_FCHDIR\n    if test $HAVE_FCHDIR = 0; then\n      REPLACE_DUP2=1\n    fi\n  ])\n])\n\n# Prerequisites of lib/dup2.c.\nAC_DEFUN([gl_PREREQ_DUP2], [])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}