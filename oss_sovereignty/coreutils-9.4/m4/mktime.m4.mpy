{
  "module_name": "mktime.m4",
  "hash_id": "884bcb24c401cb6bd4bf7996acf8fa242112422018637c8fcf88a9ff751fdb62",
  "original_prompt": "Ingested from coreutils-9.4/m4/mktime.m4",
  "human_readable_source": "# serial 39\ndnl Copyright (C) 2002-2003, 2005-2007, 2009-2023 Free Software Foundation,\ndnl Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Jim Meyering.\n\nAC_DEFUN([gl_TIME_T_IS_SIGNED],\n[\n  AC_CACHE_CHECK([whether time_t is signed],\n    [gl_cv_time_t_is_signed],\n    [AC_COMPILE_IFELSE(\n       [AC_LANG_PROGRAM([[#include <time.h>\n                          char time_t_signed[(time_t) -1 < 0 ? 1 : -1];]])],\n       [gl_cv_time_t_is_signed=yes],\n       [gl_cv_time_t_is_signed=no])])\n  if test $gl_cv_time_t_is_signed = yes; then\n    AC_DEFINE([TIME_T_IS_SIGNED], [1], [Define to 1 if time_t is signed.])\n  fi\n])\n\ndnl Test whether mktime works. Set gl_cv_func_working_mktime.\nAC_DEFUN([gl_FUNC_MKTIME_WORKS],\n[\n  AC_REQUIRE([gl_TIME_T_IS_SIGNED])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n  dnl We don't use AC_FUNC_MKTIME any more, because it is no longer maintained\n  dnl in Autoconf and because it invokes AC_LIBOBJ.\n  AC_CHECK_HEADERS_ONCE([unistd.h])\n  AC_CHECK_DECLS_ONCE([alarm])\n  AC_REQUIRE([gl_MULTIARCH])\n  AC_CACHE_CHECK([for working mktime], [gl_cv_func_working_mktime],\n    [if test $APPLE_UNIVERSAL_BUILD = 1; then\n       # A universal build on Apple Mac OS X platforms.\n       # The test result would be 'yes' in 32-bit mode and 'no' in 64-bit mode.\n       # But we need a configuration result that is valid in both modes.\n       gl_cv_func_working_mktime=\"guessing no\"\n     else\n       AC_RUN_IFELSE(\n         [AC_LANG_SOURCE(\n[[/* Test program from Paul Eggert and Tony Leneis.  */\n#include <limits.h>\n#include <stdlib.h>\n#include <time.h>\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#if HAVE_DECL_ALARM\n# include <signal.h>\n#endif\n\n]GL_MDA_DEFINES[\n\n#ifndef TIME_T_IS_SIGNED\n# define TIME_T_IS_SIGNED 0\n#endif\n\nstatic time_t time_t_max;\nstatic time_t time_t_min;\n\n/* Values we'll use to set the TZ environment variable.  */\nstatic char *tz_strings[] = {\n  (char *) 0, \"TZ=GMT0\", \"TZ=JST-9\",\n  \"TZ=EST+3EDT+2,M10.1.0/00:00:00,M2.3.0/00:00:00\"\n};\n#define N_STRINGS (sizeof (tz_strings) / sizeof (tz_strings[0]))\n\n/* Return 0 if mktime fails to convert a date in the spring-forward gap.\n   Based on a problem report from Andreas Jaeger.  */\nstatic int\nspring_forward_gap ()\n{\n  /* glibc (up to about 1998-10-07) failed this test. */\n  struct tm tm;\n\n  /* Use the portable POSIX.1 specification \"TZ=PST8PDT,M4.1.0,M10.5.0\"\n     instead of \"TZ=America/Vancouver\" in order to detect the bug even\n     on systems that don't support the Olson extension, or don't have the\n     full zoneinfo tables installed.  */\n  if (putenv (\"TZ=PST8PDT,M4.1.0,M10.5.0\") != 0)\n    return -1;\n\n  tm.tm_year = 98;\n  tm.tm_mon = 3;\n  tm.tm_mday = 5;\n  tm.tm_hour = 2;\n  tm.tm_min = 0;\n  tm.tm_sec = 0;\n  tm.tm_isdst = -1;\n  return mktime (&tm) != (time_t) -1;\n}\n\nstatic int\nmktime_test1 (time_t now)\n{\n  struct tm *lt;\n  return ! (lt = localtime (&now)) || mktime (lt) == now;\n}\n\nstatic int\nmktime_test (time_t now)\n{\n  return (mktime_test1 (now)\n          && mktime_test1 ((time_t) (time_t_max - now))\n          && mktime_test1 ((time_t) (time_t_min + now)));\n}\n\nstatic int\nirix_6_4_bug ()\n{\n  /* Based on code from Ariel Faigon.  */\n  struct tm tm;\n  tm.tm_year = 96;\n  tm.tm_mon = 3;\n  tm.tm_mday = 0;\n  tm.tm_hour = 0;\n  tm.tm_min = 0;\n  tm.tm_sec = 0;\n  tm.tm_isdst = -1;\n  mktime (&tm);\n  return tm.tm_mon == 2 && tm.tm_mday == 31;\n}\n\nstatic int\nbigtime_test (int j)\n{\n  struct tm tm;\n  time_t now;\n  tm.tm_year = tm.tm_mon = tm.tm_mday = tm.tm_hour = tm.tm_min = tm.tm_sec = j;\n  now = mktime (&tm);\n  if (now != (time_t) -1)\n    {\n      struct tm *lt = localtime (&now);\n      if (! (lt\n             && lt->tm_year == tm.tm_year\n             && lt->tm_mon == tm.tm_mon\n             && lt->tm_mday == tm.tm_mday\n             && lt->tm_hour == tm.tm_hour\n             && lt->tm_min == tm.tm_min\n             && lt->tm_sec == tm.tm_sec\n             && lt->tm_yday == tm.tm_yday\n             && lt->tm_wday == tm.tm_wday\n             && ((lt->tm_isdst < 0 ? -1 : 0 < lt->tm_isdst)\n                  == (tm.tm_isdst < 0 ? -1 : 0 < tm.tm_isdst))))\n        return 0;\n    }\n  return 1;\n}\n\nstatic int\nyear_2050_test ()\n{\n  /* The correct answer for 2050-02-01 00:00:00 in Pacific time,\n     ignoring leap seconds.  */\n  unsigned long int answer = 2527315200UL;\n\n  struct tm tm;\n  time_t t;\n  tm.tm_year = 2050 - 1900;\n  tm.tm_mon = 2 - 1;\n  tm.tm_mday = 1;\n  tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n  tm.tm_isdst = -1;\n\n  /* Use the portable POSIX.1 specification \"TZ=PST8PDT,M4.1.0,M10.5.0\"\n     instead of \"TZ=America/Vancouver\" in order to detect the bug even\n     on systems that don't support the Olson extension, or don't have the\n     full zoneinfo tables installed.  */\n  if (putenv (\"TZ=PST8PDT,M4.1.0,M10.5.0\") != 0)\n    return -1;\n\n  t = mktime (&tm);\n\n  /* Check that the result is either a failure, or close enough\n     to the correct answer that we can assume the discrepancy is\n     due to leap seconds.  */\n  return (t == (time_t) -1\n          || (0 < t && answer - 120 <= t && t <= answer + 120));\n}\n\nstatic int\nindiana_test ()\n{\n  if (putenv (\"TZ=America/Indiana/Indianapolis\") != 0)\n    return -1;\n  struct tm tm;\n  tm.tm_year = 1986 - 1900; tm.tm_mon = 4 - 1; tm.tm_mday = 28;\n  tm.tm_hour = 16; tm.tm_min = 24; tm.tm_sec = 50; tm.tm_isdst = 0;\n  time_t std = mktime (&tm);\n  if (! (std == 515107490 || std == 515107503))\n    return 1;\n\n  /* This platform supports TZDB, either without or with leap seconds.\n     Return true if GNU Bug#48085 is absent.  */\n  tm.tm_isdst = 1;\n  time_t dst = mktime (&tm);\n  return std - dst == 60 * 60;\n}\n\nint\nmain ()\n{\n  int result = 0;\n  time_t t, delta;\n  int i, j;\n  int time_t_signed_magnitude = (time_t) ~ (time_t) 0 < (time_t) -1;\n\n#if HAVE_DECL_ALARM\n  /* This test makes some buggy mktime implementations loop.\n     Give up after 60 seconds; a mktime slower than that\n     isn't worth using anyway.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (60);\n#endif\n\n  time_t_max = (! TIME_T_IS_SIGNED\n                ? (time_t) -1\n                : ((((time_t) 1 << (sizeof (time_t) * CHAR_BIT - 2)) - 1)\n                   * 2 + 1));\n  time_t_min = (! TIME_T_IS_SIGNED\n                ? (time_t) 0\n                : time_t_signed_magnitude\n                ? ~ (time_t) 0\n                : ~ time_t_max);\n\n  delta = time_t_max / 997; /* a suitable prime number */\n  for (i = 0; i < N_STRINGS; i++)\n    {\n      if (tz_strings[i])\n        putenv (tz_strings[i]);\n\n      for (t = 0; t <= time_t_max - delta && (result & 1) == 0; t += delta)\n        if (! mktime_test (t))\n          result |= 1;\n      if ((result & 2) == 0\n          && ! (mktime_test ((time_t) 1)\n                && mktime_test ((time_t) (60 * 60))\n                && mktime_test ((time_t) (60 * 60 * 24))))\n        result |= 2;\n\n      for (j = 1; (result & 4) == 0; j <<= 1)\n        {\n          if (! bigtime_test (j))\n            result |= 4;\n          if (INT_MAX / 2 < j)\n            break;\n        }\n      if ((result & 8) == 0 && ! bigtime_test (INT_MAX))\n        result |= 8;\n    }\n  if (! irix_6_4_bug ())\n    result |= 16;\n  if (! spring_forward_gap ())\n    result |= 32;\n  if (! year_2050_test () || ! indiana_test ())\n    result |= 64;\n  return result;\n}]])],\n         [gl_cv_func_working_mktime=yes],\n         [gl_cv_func_working_mktime=no],\n         [case \"$host_os\" in\n                               # Guess no on native Windows.\n            mingw* | windows*) gl_cv_func_working_mktime=\"guessing no\" ;;\n            *)                 gl_cv_func_working_mktime=\"$gl_cross_guess_normal\" ;;\n          esac\n         ])\n     fi\n    ])\n])\n\ndnl Main macro of module 'mktime'.\nAC_DEFUN([gl_FUNC_MKTIME],\n[\n  AC_REQUIRE([gl_TIME_H_DEFAULTS])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_REQUIRE([gl_FUNC_MKTIME_WORKS])\n\n  if test \"$gl_cv_func_working_mktime\" != yes; then\n    REPLACE_MKTIME=1\n    AC_DEFINE([NEED_MKTIME_WORKING], [1],\n      [Define if the compilation of mktime.c should define 'mktime'\n       with the algorithmic workarounds.])\n  fi\n  case \"$host_os\" in\n    mingw* | windows*)\n      REPLACE_MKTIME=1\n      AC_DEFINE([NEED_MKTIME_WINDOWS], [1],\n        [Define if the compilation of mktime.c should define 'mktime'\n         with the native Windows TZ workaround.])\n      ;;\n  esac\n])\n\ndnl Main macro of module 'mktime-internal'.\nAC_DEFUN([gl_FUNC_MKTIME_INTERNAL], [\n  AC_REQUIRE([gl_FUNC_MKTIME_WORKS])\n\n  WANT_MKTIME_INTERNAL=0\n  dnl BeOS has __mktime_internal in libc, but other platforms don't.\n  AC_CHECK_FUNC([__mktime_internal],\n    [AC_DEFINE([mktime_internal], [__mktime_internal],\n       [Define to the real name of the mktime_internal function.])\n    ],\n    [dnl mktime works but it doesn't export __mktime_internal,\n     dnl so we need to substitute our own mktime implementation.\n     WANT_MKTIME_INTERNAL=1\n     AC_DEFINE([NEED_MKTIME_INTERNAL], [1],\n       [Define if the compilation of mktime.c should define 'mktime_internal'.])\n    ])\n])\n\n# Prerequisites of lib/mktime.c.\nAC_DEFUN([gl_PREREQ_MKTIME], [:])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}