{
  "module_name": "exponentl.m4",
  "hash_id": "ce858a336aa2531c680568a3ca7236ad069a4f6fc674fc92cc4acbdc642db9d9",
  "original_prompt": "Ingested from coreutils-9.4/m4/exponentl.m4",
  "human_readable_source": "# exponentl.m4 serial 7\ndnl Copyright (C) 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\nAC_DEFUN_ONCE([gl_LONG_DOUBLE_EXPONENT_LOCATION],\n[\n  AC_REQUIRE([gl_BIGENDIAN])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([where to find the exponent in a 'long double'],\n    [gl_cv_cc_long_double_expbit0],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <float.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#define NWORDS \\\n  ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\ntypedef union { long double value; unsigned int word[NWORDS]; }\n        memory_long_double;\nstatic unsigned int ored_words[NWORDS];\nstatic unsigned int anded_words[NWORDS];\nstatic void add_to_ored_words (long double *x)\n{\n  memory_long_double m;\n  size_t i;\n  /* Clear it first, in case\n     sizeof (long double) < sizeof (memory_long_double).  */\n  memset (&m, 0, sizeof (memory_long_double));\n  m.value = *x;\n  for (i = 0; i < NWORDS; i++)\n    {\n      ored_words[i] |= m.word[i];\n      anded_words[i] &= m.word[i];\n    }\n}\nint main ()\n{\n  static long double samples[5] = { 0.25L, 0.5L, 1.0L, 2.0L, 4.0L };\n  size_t j;\n  FILE *fp = fopen (\"conftest.out\", \"w\");\n  if (fp == NULL)\n    return 1;\n  for (j = 0; j < NWORDS; j++)\n    anded_words[j] = ~ (unsigned int) 0;\n  for (j = 0; j < 5; j++)\n    add_to_ored_words (&samples[j]);\n  /* Remove bits that are common (e.g. if representation of the first mantissa\n     bit is explicit).  */\n  for (j = 0; j < NWORDS; j++)\n    ored_words[j] &= ~anded_words[j];\n  /* Now find the nonzero word.  */\n  for (j = 0; j < NWORDS; j++)\n    if (ored_words[j] != 0)\n      break;\n  if (j < NWORDS)\n    {\n      size_t i;\n      for (i = j + 1; i < NWORDS; i++)\n        if (ored_words[i] != 0)\n          {\n            fprintf (fp, \"unknown\");\n            return (fclose (fp) != 0);\n          }\n      for (i = 0; ; i++)\n        if ((ored_words[j] >> i) & 1)\n          {\n            fprintf (fp, \"word %d bit %d\", (int) j, (int) i);\n            return (fclose (fp) != 0);\n          }\n    }\n  fprintf (fp, \"unknown\");\n  return (fclose (fp) != 0);\n}\n        ]])],\n        [gl_cv_cc_long_double_expbit0=`cat conftest.out`],\n        [gl_cv_cc_long_double_expbit0=\"unknown\"],\n        [\n          dnl When cross-compiling, in general we don't know. It depends on the\n          dnl ABI and compiler version. There are too many cases.\n          gl_cv_cc_long_double_expbit0=\"unknown\"\n          case \"$host_os\" in\n            mingw* | windows*)\n              # On native Windows (little-endian), we know the result\n              # in two cases: mingw, MSVC.\n              AC_EGREP_CPP([Known], [\n#ifdef __MINGW32__\n Known\n#endif\n                ], [gl_cv_cc_long_double_expbit0=\"word 2 bit 0\"])\n              AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                ], [gl_cv_cc_long_double_expbit0=\"word 1 bit 20\"])\n              ;;\n          esac\n        ])\n      rm -f conftest.out\n    ])\n  case \"$gl_cv_cc_long_double_expbit0\" in\n    word*bit*)\n      word=`echo \"$gl_cv_cc_long_double_expbit0\" | sed -e 's/word //' -e 's/ bit.*//'`\n      bit=`echo \"$gl_cv_cc_long_double_expbit0\" | sed -e 's/word.*bit //'`\n      AC_DEFINE_UNQUOTED([LDBL_EXPBIT0_WORD], [$word],\n        [Define as the word index where to find the exponent of 'long double'.])\n      AC_DEFINE_UNQUOTED([LDBL_EXPBIT0_BIT], [$bit],\n        [Define as the bit index in the word where to find bit 0 of the exponent of 'long double'.])\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}