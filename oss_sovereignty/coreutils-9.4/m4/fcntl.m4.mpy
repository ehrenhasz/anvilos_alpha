{
  "module_name": "fcntl.m4",
  "hash_id": "16b954cb75c9147cc56f9da76a3b5e5b58b43ae29a89a3308da2301b426b8ec2",
  "original_prompt": "Ingested from coreutils-9.4/m4/fcntl.m4",
  "human_readable_source": "# fcntl.m4 serial 11\ndnl Copyright (C) 2009-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\n# For now, this module ensures that fcntl()\n# - supports F_DUPFD correctly\n# - supports or emulates F_DUPFD_CLOEXEC\n# - supports F_GETFD\n# Still to be ported to mingw:\n# - F_SETFD\n# - F_GETFL, F_SETFL\n# - F_GETOWN, F_SETOWN\n# - F_GETLK, F_SETLK, F_SETLKW\nAC_DEFUN([gl_FUNC_FCNTL],\n[\n  dnl Persuade glibc to expose F_DUPFD_CLOEXEC.\n  AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])\n  AC_REQUIRE([gl_FCNTL_H_DEFAULTS])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CHECK_FUNCS_ONCE([fcntl])\n  if test $ac_cv_func_fcntl = no; then\n    gl_REPLACE_FCNTL\n  else\n    dnl cygwin 1.5.x F_DUPFD has wrong errno, and allows negative target\n    dnl haiku alpha 2 F_DUPFD has wrong errno\n    AC_CACHE_CHECK([whether fcntl handles F_DUPFD correctly],\n      [gl_cv_func_fcntl_f_dupfd_works],\n      [AC_RUN_IFELSE(\n         [AC_LANG_PROGRAM(\n            [[#include <errno.h>\n              #include <fcntl.h>\n              #include <limits.h>\n              #include <sys/resource.h>\n              #include <unistd.h>\n              ]GL_MDA_DEFINES[\n              #ifndef RLIM_SAVED_CUR\n              # define RLIM_SAVED_CUR RLIM_INFINITY\n              #endif\n              #ifndef RLIM_SAVED_MAX\n              # define RLIM_SAVED_MAX RLIM_INFINITY\n              #endif\n            ]],\n            [[int result = 0;\n              int bad_fd = INT_MAX;\n              struct rlimit rlim;\n              if (getrlimit (RLIMIT_NOFILE, &rlim) == 0\n                  && 0 <= rlim.rlim_cur && rlim.rlim_cur <= INT_MAX\n                  && rlim.rlim_cur != RLIM_INFINITY\n                  && rlim.rlim_cur != RLIM_SAVED_MAX\n                  && rlim.rlim_cur != RLIM_SAVED_CUR)\n                bad_fd = rlim.rlim_cur;\n              if (fcntl (0, F_DUPFD, -1) != -1) result |= 1;\n              if (errno != EINVAL) result |= 2;\n              if (fcntl (0, F_DUPFD, bad_fd) != -1) result |= 4;\n              if (errno != EINVAL) result |= 8;\n              /* On OS/2 kLIBC, F_DUPFD does not work on a directory fd */\n              {\n                int fd;\n                fd = open (\".\", O_RDONLY);\n                if (fd == -1)\n                  result |= 16;\n                else if (fcntl (fd, F_DUPFD, STDERR_FILENO + 1) == -1)\n                  result |= 32;\n\n                close (fd);\n              }\n              return result;]])],\n         [gl_cv_func_fcntl_f_dupfd_works=yes],\n         [gl_cv_func_fcntl_f_dupfd_works=no],\n         [case $host_os in\n            aix* | cygwin* | haiku*)\n               gl_cv_func_fcntl_f_dupfd_works=\"guessing no\" ;;\n            *) gl_cv_func_fcntl_f_dupfd_works=\"guessing yes\" ;;\n          esac])])\n    case $gl_cv_func_fcntl_f_dupfd_works in\n      *yes) ;;\n      *) gl_REPLACE_FCNTL\n        AC_DEFINE([FCNTL_DUPFD_BUGGY], [1], [Define this to 1 if F_DUPFD\n          behavior does not match POSIX]) ;;\n    esac\n\n    dnl Many systems lack F_DUPFD_CLOEXEC.\n    dnl NetBSD 9.0 declares F_DUPFD_CLOEXEC but it works only like F_DUPFD.\n    AC_CACHE_CHECK([whether fcntl understands F_DUPFD_CLOEXEC],\n      [gl_cv_func_fcntl_f_dupfd_cloexec],\n      [AC_RUN_IFELSE(\n         [AC_LANG_SOURCE(\n            [[#include <fcntl.h>\n              #include <unistd.h>\n              int main (int argc, char *argv[])\n              {\n                if (argc == 1)\n                  /* parent process */\n                  {\n                    if (fcntl (1, F_DUPFD_CLOEXEC, 10) < 0)\n                      return 1;\n                    return execl (\"./conftest\", \"./conftest\", \"child\", NULL);\n                  }\n                else\n                  /* child process */\n                  return (fcntl (10, F_GETFL) < 0 ? 0 : 42);\n              }\n            ]])\n         ],\n         [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#ifdef __linux__\n/* The Linux kernel only added F_DUPFD_CLOEXEC in 2.6.24, so we always replace\n   it to support the semantics on older kernels that failed with EINVAL.  */\nchoke me\n#endif\n           ]])],\n           [gl_cv_func_fcntl_f_dupfd_cloexec=yes],\n           [gl_cv_func_fcntl_f_dupfd_cloexec=\"needs runtime check\"])\n         ],\n         [gl_cv_func_fcntl_f_dupfd_cloexec=no],\n         [case \"$host_os\" in\n                     # Guess no on NetBSD.\n            netbsd*) gl_cv_func_fcntl_f_dupfd_cloexec=\"guessing no\" ;;\n            *)       gl_cv_func_fcntl_f_dupfd_cloexec=\"$gl_cross_guess_normal\" ;;\n          esac\n         ])\n      ])\n    case \"$gl_cv_func_fcntl_f_dupfd_cloexec\" in\n      *yes) ;;\n      *)    gl_REPLACE_FCNTL\n            dnl No witness macro needed for this bug.\n            ;;\n    esac\n  fi\n  dnl Replace fcntl() for supporting the gnulib-defined fchdir() function,\n  dnl to keep fchdir's bookkeeping up-to-date.\n  m4_ifdef([gl_FUNC_FCHDIR], [\n    gl_TEST_FCHDIR\n    if test $HAVE_FCHDIR = 0; then\n      gl_REPLACE_FCNTL\n    fi\n  ])\n])\n\nAC_DEFUN([gl_REPLACE_FCNTL],\n[\n  AC_REQUIRE([gl_FCNTL_H_DEFAULTS])\n  AC_CHECK_FUNCS_ONCE([fcntl])\n  if test $ac_cv_func_fcntl = no; then\n    HAVE_FCNTL=0\n  else\n    REPLACE_FCNTL=1\n  fi\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}