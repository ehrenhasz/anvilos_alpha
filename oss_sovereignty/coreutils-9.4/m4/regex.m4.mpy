{
  "module_name": "regex.m4",
  "hash_id": "b725dd9c6120d89f3d1a0591bf693acc55dfcb327d708438f3320f022fc96140",
  "original_prompt": "Ingested from coreutils-9.4/m4/regex.m4",
  "human_readable_source": "# serial 75\n\n# Copyright (C) 1996-2001, 2003-2023 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\ndnl Initially derived from code in GNU grep.\ndnl Mostly written by Jim Meyering.\n\nAC_PREREQ([2.50])\n\nAC_DEFUN([gl_REGEX],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_ARG_WITH([included-regex],\n    [AS_HELP_STRING([[--without-included-regex]],\n                    [don't compile regex; this is the default on systems\n                     with recent-enough versions of the GNU C Library\n                     (use with caution on other systems).])])\n\n  case $with_included_regex in #(\n  yes|no) ac_use_included_regex=$with_included_regex\n        ;;\n  '')\n    # If the system regex support is good enough that it passes the\n    # following run test, then default to *not* using the included regex.c.\n    # If cross compiling, assume the test would fail and use the included\n    # regex.c.\n    AC_CHECK_DECLS_ONCE([alarm])\n    AC_CHECK_HEADERS_ONCE([malloc.h])\n    AC_CACHE_CHECK([for working re_compile_pattern],\n                   [gl_cv_func_re_compile_pattern_working],\n      [AC_RUN_IFELSE(\n        [AC_LANG_PROGRAM(\n          [[#include <regex.h>\n\n            #include <locale.h>\n            #include <limits.h>\n            #include <string.h>\n\n            #if defined M_CHECK_ACTION || HAVE_DECL_ALARM\n            # include <signal.h>\n            # include <unistd.h>\n            #endif\n\n            #if HAVE_MALLOC_H\n            # include <malloc.h>\n            #endif\n\n            #ifdef M_CHECK_ACTION\n            /* Exit with distinguishable exit code.  */\n            static void sigabrt_no_core (int sig) { raise (SIGTERM); }\n            #endif\n          ]],\n          [[int result = 0;\n            static struct re_pattern_buffer regex;\n            unsigned char folded_chars[UCHAR_MAX + 1];\n            int i;\n            const char *s;\n            struct re_registers regs;\n\n            /* Some builds of glibc go into an infinite loop on this\n               test.  Use alarm to force death, and mallopt to avoid\n               malloc recursion in diagnosing the corrupted heap. */\n#if HAVE_DECL_ALARM\n            signal (SIGALRM, SIG_DFL);\n            alarm (2);\n#endif\n#ifdef M_CHECK_ACTION\n            signal (SIGABRT, sigabrt_no_core);\n            mallopt (M_CHECK_ACTION, 2);\n#endif\n\n            if (setlocale (LC_ALL, \"en_US.UTF-8\"))\n              {\n                {\n                  /* https://sourceware.org/ml/libc-hacker/2006-09/msg00008.html\n                     This test needs valgrind to catch the bug on Debian\n                     GNU/Linux 3.1 x86, but it might catch the bug better\n                     on other platforms and it shouldn't hurt to try the\n                     test here.  */\n                  static char const pat[] = \"insert into\";\n                  static char const data[] =\n                    \"\\xFF\\0\\x12\\xA2\\xAA\\xC4\\xB1,K\\x12\\xC4\\xB1*\\xACK\";\n                  re_set_syntax (RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE\n                                 | RE_ICASE);\n                  memset (&regex, 0, sizeof regex);\n                  s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n                  if (s)\n                    result |= 1;\n                  else\n                    {\n                      if (re_search (&regex, data, sizeof data - 1,\n                                     0, sizeof data - 1, &regs)\n                          != -1)\n                        result |= 1;\n                      regfree (&regex);\n                    }\n                }\n\n                {\n                  /* This test is from glibc bug 15078.\n                     The test case is from Andreas Schwab in\n                     <https://sourceware.org/ml/libc-alpha/2013-01/msg00967.html>.\n                     */\n                  static char const pat[] = \"[^x]x\";\n                  static char const data[] =\n                    /* <U1000><U103B><U103D><U1014><U103A><U102F><U1015><U103A> */\n                    \"\\xe1\\x80\\x80\"\n                    \"\\xe1\\x80\\xbb\"\n                    \"\\xe1\\x80\\xbd\"\n                    \"\\xe1\\x80\\x94\"\n                    \"\\xe1\\x80\\xba\"\n                    \"\\xe1\\x80\\xaf\"\n                    \"\\xe1\\x80\\x95\"\n                    \"\\xe1\\x80\\xba\"\n                    \"x\";\n                  re_set_syntax (0);\n                  memset (&regex, 0, sizeof regex);\n                  s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n                  if (s)\n                    result |= 1;\n                  else\n                    {\n                      i = re_search (&regex, data, sizeof data - 1,\n                                     0, sizeof data - 1, 0);\n                      if (i != 0 && i != 21)\n                        result |= 1;\n                      regfree (&regex);\n                    }\n                }\n\n                if (! setlocale (LC_ALL, \"C\"))\n                  return 1;\n              }\n\n            /* This test is from glibc bug 3957, reported by Andrew Mackey.  */\n            re_set_syntax (RE_SYNTAX_EGREP | RE_HAT_LISTS_NOT_NEWLINE);\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"a[^x]b\", 6, &regex);\n            if (s)\n              result |= 2;\n            else\n              {\n                /* This should fail, but succeeds for glibc-2.5.  */\n                if (re_search (&regex, \"a\\nb\", 3, 0, 3, &regs) != -1)\n                  result |= 2;\n                regfree (&regex);\n              }\n\n            /* This regular expression is from Spencer ere test number 75\n               in grep-2.3.  */\n            re_set_syntax (RE_SYNTAX_POSIX_EGREP);\n            memset (&regex, 0, sizeof regex);\n            for (i = 0; i <= UCHAR_MAX; i++)\n              folded_chars[i] = i;\n            regex.translate = folded_chars;\n            s = re_compile_pattern (\"a[[:@:>@:]]b\\n\", 11, &regex);\n            /* This should fail with _Invalid character class name_ error.  */\n            if (!s)\n              {\n                result |= 4;\n                regfree (&regex);\n              }\n\n            /* Ensure that [b-a] is diagnosed as invalid, when\n               using RE_NO_EMPTY_RANGES. */\n            re_set_syntax (RE_SYNTAX_POSIX_EGREP | RE_NO_EMPTY_RANGES);\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"a[b-a]\", 6, &regex);\n            if (s == 0)\n              {\n                result |= 8;\n                regfree (&regex);\n              }\n\n            /* This should succeed, but does not for glibc-2.1.3.  */\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"{1\", 2, &regex);\n            if (s)\n              result |= 8;\n            else\n              regfree (&regex);\n\n            /* The following example is derived from a problem report\n               against gawk from Jorge Stolfi <stolfi@ic.unicamp.br>.  */\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"[an\\371]*n\", 7, &regex);\n            if (s)\n              result |= 8;\n            else\n              {\n                /* This should match, but does not for glibc-2.2.1.  */\n                if (re_match (&regex, \"an\", 2, 0, &regs) != 2)\n                  result |= 8;\n                else\n                  {\n                    free (regs.start);\n                    free (regs.end);\n                  }\n                regfree (&regex);\n              }\n\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"x\", 1, &regex);\n            if (s)\n              result |= 8;\n            else\n              {\n                /* glibc-2.2.93 does not work with a negative RANGE argument.  */\n                if (re_search (&regex, \"wxy\", 3, 2, -2, &regs) != 1)\n                  result |= 8;\n                else\n                  {\n                    free (regs.start);\n                    free (regs.end);\n                  }\n                regfree (&regex);\n              }\n\n            /* The version of regex.c in older versions of gnulib\n               ignored RE_ICASE.  Detect that problem too.  */\n            re_set_syntax (RE_SYNTAX_EMACS | RE_ICASE);\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"x\", 1, &regex);\n            if (s)\n              result |= 16;\n            else\n              {\n                if (re_search (&regex, \"WXY\", 3, 0, 3, &regs) < 0)\n                  result |= 16;\n                else\n                  {\n                    free (regs.start);\n                    free (regs.end);\n                  }\n                regfree (&regex);\n              }\n\n            /* Catch a bug reported by Vin Shelton in\n               https://lists.gnu.org/r/bug-coreutils/2007-06/msg00089.html\n               */\n            re_set_syntax (RE_SYNTAX_POSIX_BASIC\n                           & ~RE_CONTEXT_INVALID_DUP\n                           & ~RE_NO_EMPTY_RANGES);\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"[[:alnum:]_-]\\\\\\\\+\\$\", 16, &regex);\n            if (s)\n              result |= 32;\n            else\n              regfree (&regex);\n\n            /* REG_STARTEND was added to glibc on 2004-01-15.\n               Reject older versions.  */\n            if (! REG_STARTEND)\n              result |= 64;\n\n            /* Matching with the compiled form of this regexp would provoke\n               an assertion failure prior to glibc-2.28:\n                 regexec.c:1375: pop_fail_stack: Assertion 'num >= 0' failed\n               With glibc-2.28, compilation fails and reports the invalid\n               back reference.  */\n            re_set_syntax (RE_SYNTAX_POSIX_EGREP);\n            memset (&regex, 0, sizeof regex);\n            s = re_compile_pattern (\"0|()0|\\\\\\\\1|0\", 10, &regex);\n            if (!s)\n              {\n                memset (&regs, 0, sizeof regs);\n                i = re_search (&regex, \"x\", 1, 0, 1, &regs);\n                if (i != -1)\n                  result |= 64;\n                if (0 <= i)\n                  {\n                    free (regs.start);\n                    free (regs.end);\n                  }\n                regfree (&regex);\n              }\n            else\n              {\n                if (strcmp (s, \"Invalid back reference\"))\n                  result |= 64;\n              }\n\n            /* glibc bug 11053.  */\n            re_set_syntax (RE_SYNTAX_POSIX_BASIC);\n            memset (&regex, 0, sizeof regex);\n            static char const pat_sub2[] = \"\\\\\\\\(a*\\\\\\\\)*a*\\\\\\\\1\";\n            s = re_compile_pattern (pat_sub2, sizeof pat_sub2 - 1, &regex);\n            if (s)\n              result |= 64;\n            else\n              {\n                memset (&regs, 0, sizeof regs);\n                static char const data[] = \"a\";\n                int datalen = sizeof data - 1;\n                i = re_search (&regex, data, datalen, 0, datalen, &regs);\n                if (i != 0)\n                  result |= 64;\n                else if (regs.num_regs < 2)\n                  result |= 64;\n                else if (! (regs.start[0] == 0 && regs.end[0] == 1))\n                  result |= 64;\n                else if (! (regs.start[1] == 0 && regs.end[1] == 0))\n                  result |= 64;\n                regfree (&regex);\n                free (regs.start);\n                free (regs.end);\n              }\n\n#if 0\n            /* It would be nice to reject hosts whose regoff_t values are too\n               narrow (including glibc on hosts with 64-bit ptrdiff_t and\n               32-bit int), but we should wait until glibc implements this\n               feature.  Otherwise, support for equivalence classes and\n               multibyte collation symbols would always be broken except\n               when compiling --without-included-regex.   */\n            if (sizeof (regoff_t) < sizeof (ptrdiff_t)\n                || sizeof (regoff_t) < sizeof (ssize_t))\n              result |= 64;\n#endif\n\n            return result;\n          ]])],\n        [gl_cv_func_re_compile_pattern_working=yes],\n        [gl_cv_func_re_compile_pattern_working=no],\n        [case \"$host_os\" in\n                              # Guess no on native Windows.\n           mingw* | windows*) gl_cv_func_re_compile_pattern_working=\"guessing no\" ;;\n                              # Otherwise obey --enable-cross-guesses.\n           *)                 gl_cv_func_re_compile_pattern_working=\"$gl_cross_guess_normal\" ;;\n         esac\n        ])\n      ])\n    case \"$gl_cv_func_re_compile_pattern_working\" in #(\n      *yes) ac_use_included_regex=no;; #(\n      *no) ac_use_included_regex=yes;;\n    esac\n    ;;\n  *) AC_MSG_ERROR([Invalid value for --with-included-regex: $with_included_regex])\n    ;;\n  esac\n\n  if test $ac_use_included_regex = yes; then\n    AC_DEFINE([_REGEX_INCLUDE_LIMITS_H], [1],\n      [Define if you want <regex.h> to include <limits.h>, so that it\n       consistently overrides <limits.h>'s RE_DUP_MAX.])\n    AC_DEFINE([_REGEX_LARGE_OFFSETS], [1],\n      [Define if you want regoff_t to be at least as wide POSIX requires.])\n    AC_DEFINE([re_syntax_options], [rpl_re_syntax_options],\n      [Define to rpl_re_syntax_options if the replacement should be used.])\n    AC_DEFINE([re_set_syntax], [rpl_re_set_syntax],\n      [Define to rpl_re_set_syntax if the replacement should be used.])\n    AC_DEFINE([re_compile_pattern], [rpl_re_compile_pattern],\n      [Define to rpl_re_compile_pattern if the replacement should be used.])\n    AC_DEFINE([re_compile_fastmap], [rpl_re_compile_fastmap],\n      [Define to rpl_re_compile_fastmap if the replacement should be used.])\n    AC_DEFINE([re_search], [rpl_re_search],\n      [Define to rpl_re_search if the replacement should be used.])\n    AC_DEFINE([re_search_2], [rpl_re_search_2],\n      [Define to rpl_re_search_2 if the replacement should be used.])\n    AC_DEFINE([re_match], [rpl_re_match],\n      [Define to rpl_re_match if the replacement should be used.])\n    AC_DEFINE([re_match_2], [rpl_re_match_2],\n      [Define to rpl_re_match_2 if the replacement should be used.])\n    AC_DEFINE([re_set_registers], [rpl_re_set_registers],\n      [Define to rpl_re_set_registers if the replacement should be used.])\n    AC_DEFINE([re_comp], [rpl_re_comp],\n      [Define to rpl_re_comp if the replacement should be used.])\n    AC_DEFINE([re_exec], [rpl_re_exec],\n      [Define to rpl_re_exec if the replacement should be used.])\n    AC_DEFINE([regcomp], [rpl_regcomp],\n      [Define to rpl_regcomp if the replacement should be used.])\n    AC_DEFINE([regexec], [rpl_regexec],\n      [Define to rpl_regexec if the replacement should be used.])\n    AC_DEFINE([regerror], [rpl_regerror],\n      [Define to rpl_regerror if the replacement should be used.])\n    AC_DEFINE([regfree], [rpl_regfree],\n      [Define to rpl_regfree if the replacement should be used.])\n  fi\n])\n\n# Prerequisites of lib/regex.c and lib/regex_internal.c.\nAC_DEFUN([gl_PREREQ_REGEX],\n[\n  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n  AC_REQUIRE([AC_C_INLINE])\n  AC_REQUIRE([AC_C_RESTRICT])\n  AC_REQUIRE([AC_TYPE_MBSTATE_T])\n  AC_REQUIRE([gl_EEMALLOC])\n  AC_CHECK_HEADERS([libintl.h])\n  AC_CHECK_FUNCS_ONCE([isblank iswctype])\n  AC_CHECK_DECLS([isblank], [], [], [[#include <ctype.h>]])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}