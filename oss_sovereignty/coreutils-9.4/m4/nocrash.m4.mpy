{
  "module_name": "nocrash.m4",
  "hash_id": "a19bc6fbf7f43de95e0bccef3845280dff94e93fea1f896252cf8aa7059fa349",
  "original_prompt": "Ingested from coreutils-9.4/m4/nocrash.m4",
  "human_readable_source": "# nocrash.m4 serial 5\ndnl Copyright (C) 2005, 2009-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl Based on libsigsegv, from Bruno Haible and Paolo Bonzini.\n\nAC_PREREQ([2.13])\n\ndnl Expands to some code for use in .c programs that will cause the configure\ndnl test to exit instead of crashing. This is useful to avoid triggering\ndnl action from a background debugger and to avoid core dumps.\ndnl Usage:   ...\ndnl          ]GL_NOCRASH[\ndnl          ...\ndnl          int main() { nocrash_init(); ... }\nAC_DEFUN([GL_NOCRASH],[[\n#include <stdlib.h>\n#if defined __MACH__ && defined __APPLE__\n/* Avoid a crash on Mac OS X.  */\n#include <mach/mach.h>\n#include <mach/mach_error.h>\n#include <mach/thread_status.h>\n#include <mach/exception.h>\n#include <mach/task.h>\n#include <pthread.h>\n/* The exception port on which our thread listens.  */\nstatic mach_port_t our_exception_port;\n/* The main function of the thread listening for exceptions of type\n   EXC_BAD_ACCESS.  */\nstatic void *\nmach_exception_thread (void *arg)\n{\n  /* Buffer for a message to be received.  */\n  struct {\n    mach_msg_header_t head;\n    mach_msg_body_t msgh_body;\n    char data[1024];\n  } msg;\n  mach_msg_return_t retval;\n  /* Wait for a message on the exception port.  */\n  retval = mach_msg (&msg.head, MACH_RCV_MSG | MACH_RCV_LARGE, 0, sizeof (msg),\n                     our_exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n  if (retval != MACH_MSG_SUCCESS)\n    abort ();\n  exit (1);\n}\nstatic void\nnocrash_init (void)\n{\n  mach_port_t self = mach_task_self ();\n  /* Allocate a port on which the thread shall listen for exceptions.  */\n  if (mach_port_allocate (self, MACH_PORT_RIGHT_RECEIVE, &our_exception_port)\n      == KERN_SUCCESS) {\n    /* See https://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_port_insert_right.html.  */\n    if (mach_port_insert_right (self, our_exception_port, our_exception_port,\n                                MACH_MSG_TYPE_MAKE_SEND)\n        == KERN_SUCCESS) {\n      /* The exceptions we want to catch.  Only EXC_BAD_ACCESS is interesting\n         for us.  */\n      exception_mask_t mask = EXC_MASK_BAD_ACCESS;\n      /* Create the thread listening on the exception port.  */\n      pthread_attr_t attr;\n      pthread_t thread;\n      if (pthread_attr_init (&attr) == 0\n          && pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED) == 0\n          && pthread_create (&thread, &attr, mach_exception_thread, NULL) == 0) {\n        pthread_attr_destroy (&attr);\n        /* Replace the exception port info for these exceptions with our own.\n           Note that we replace the exception port for the entire task, not only\n           for a particular thread.  This has the effect that when our exception\n           port gets the message, the thread specific exception port has already\n           been asked, and we don't need to bother about it.\n           See https://web.mit.edu/darwin/src/modules/xnu/osfmk/man/task_set_exception_ports.html.  */\n        task_set_exception_ports (self, mask, our_exception_port,\n                                  EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);\n      }\n    }\n  }\n}\n#elif defined _WIN32 && ! defined __CYGWIN__\n/* Avoid a crash on native Windows.  */\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <winerror.h>\nstatic LONG WINAPI\nexception_filter (EXCEPTION_POINTERS *ExceptionInfo)\n{\n  switch (ExceptionInfo->ExceptionRecord->ExceptionCode)\n    {\n    case EXCEPTION_ACCESS_VIOLATION:\n    case EXCEPTION_IN_PAGE_ERROR:\n    case EXCEPTION_STACK_OVERFLOW:\n    case EXCEPTION_GUARD_PAGE:\n    case EXCEPTION_PRIV_INSTRUCTION:\n    case EXCEPTION_ILLEGAL_INSTRUCTION:\n    case EXCEPTION_DATATYPE_MISALIGNMENT:\n    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n      exit (1);\n    }\n  return EXCEPTION_CONTINUE_SEARCH;\n}\nstatic void\nnocrash_init (void)\n{\n  SetUnhandledExceptionFilter ((LPTOP_LEVEL_EXCEPTION_FILTER) exception_filter);\n}\n#else\n/* Avoid a crash on POSIX systems.  */\n#include <signal.h>\n#include <unistd.h>\n/* A POSIX signal handler.  */\nstatic void\nexception_handler (int sig)\n{\n  _exit (1);\n}\nstatic void\nnocrash_init (void)\n{\n#ifdef SIGSEGV\n  signal (SIGSEGV, exception_handler);\n#endif\n#ifdef SIGBUS\n  signal (SIGBUS, exception_handler);\n#endif\n}\n#endif\n]])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}