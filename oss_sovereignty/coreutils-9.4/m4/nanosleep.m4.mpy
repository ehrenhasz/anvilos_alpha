{
  "module_name": "nanosleep.m4",
  "hash_id": "ec2054c3bebfb1d9f9887d7e0969f6a075e14e83b1a3eac3eec7f04bc17475dc",
  "original_prompt": "Ingested from coreutils-9.4/m4/nanosleep.m4",
  "human_readable_source": "# serial 45\n\ndnl From Jim Meyering.\ndnl Check for the nanosleep function.\ndnl If not found, use the supplied replacement.\ndnl\n\n# Copyright (C) 1999-2001, 2003-2023 Free Software Foundation, Inc.\n\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_NANOSLEEP],\n[\n AC_REQUIRE([gl_TIME_H_DEFAULTS])\n AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n dnl Persuade glibc and Solaris <time.h> to declare nanosleep.\n AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])\n\n AC_CHECK_DECLS_ONCE([alarm])\n\n nanosleep_save_libs=$LIBS\n\n # Solaris 2.5.1 needs -lposix4 to get the nanosleep function.\n # Solaris 7 prefers the library name -lrt to the obsolescent name -lposix4.\n NANOSLEEP_LIB=\n AC_SUBST([NANOSLEEP_LIB])\n AC_SEARCH_LIBS([nanosleep], [rt posix4],\n                [test \"$ac_cv_search_nanosleep\" = \"none required\" ||\n                 NANOSLEEP_LIB=$ac_cv_search_nanosleep])\n if test \"x$ac_cv_search_nanosleep\" != xno; then\n   dnl The system has a nanosleep function.\n\n   AC_REQUIRE([gl_MULTIARCH])\n   if test $APPLE_UNIVERSAL_BUILD = 1; then\n     # A universal build on Apple Mac OS X platforms.\n     # The test result would be 'no (mishandles large arguments)' in 64-bit\n     # mode but 'yes' in 32-bit mode. But we need a configuration result that\n     # is valid in both modes.\n     gl_cv_func_nanosleep='no (mishandles large arguments)'\n   fi\n\n   AC_CACHE_CHECK([for working nanosleep],\n    [gl_cv_func_nanosleep],\n    [\n     AC_RUN_IFELSE(\n       [AC_LANG_SOURCE([[\n          #include <errno.h>\n          #include <limits.h>\n          #include <signal.h>\n          #include <time.h>\n          #include <unistd.h>\n          #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n          #define TYPE_MAXIMUM(t) \\\n            ((t) (! TYPE_SIGNED (t) \\\n                  ? (t) -1 \\\n                  : ((((t) 1 << (sizeof (t) * CHAR_BIT - 2)) - 1) * 2 + 1)))\n\n          #if HAVE_DECL_ALARM\n          static void\n          check_for_SIGALRM (int sig)\n          {\n            if (sig != SIGALRM)\n              _exit (1);\n          }\n          #endif\n\n          int\n          main ()\n          {\n            static struct timespec ts_sleep;\n            static struct timespec ts_remaining;\n            /* Test for major problems first.  */\n            if (! nanosleep)\n              return 2;\n            ts_sleep.tv_sec = 0;\n            ts_sleep.tv_nsec = 1;\n            #if HAVE_DECL_ALARM\n            {\n              static struct sigaction act;\n              act.sa_handler = check_for_SIGALRM;\n              sigemptyset (&act.sa_mask);\n              sigaction (SIGALRM, &act, NULL);\n              alarm (1);\n              if (nanosleep (&ts_sleep, NULL) != 0)\n                return 3;\n              /* Test for a minor problem: the handling of large arguments.  */\n              ts_sleep.tv_sec = TYPE_MAXIMUM (time_t);\n              ts_sleep.tv_nsec = 999999999;\n              alarm (1);\n              if (nanosleep (&ts_sleep, &ts_remaining) != -1)\n                return 4;\n              if (errno != EINTR)\n                return 5;\n              if (ts_remaining.tv_sec <= TYPE_MAXIMUM (time_t) - 10)\n                return 6;\n            }\n            #else /* A simpler test for native Windows.  */\n            if (nanosleep (&ts_sleep, &ts_remaining) < 0)\n              return 3;\n            /* Test for 32-bit mingw bug: negative nanosecond values do not\n               cause failure.  */\n            ts_sleep.tv_sec = 1;\n            ts_sleep.tv_nsec = -1;\n            if (nanosleep (&ts_sleep, &ts_remaining) != -1)\n              return 7;\n            #endif\n            return 0;\n          }]])],\n       [gl_cv_func_nanosleep=yes],\n       [case $? in\n        4|5|6) gl_cv_func_nanosleep='no (mishandles large arguments)' ;;\n        7)     gl_cv_func_nanosleep='no (mishandles negative tv_nsec)' ;;\n        *)     gl_cv_func_nanosleep=no ;;\n        esac],\n       [case \"$host_os\" in\n            # Guess it halfway works when the kernel is Linux.\n          linux*)\n            gl_cv_func_nanosleep='guessing no (mishandles large arguments)' ;;\n            # Guess no on native Windows.\n          mingw* | windows*)\n            gl_cv_func_nanosleep='guessing no' ;;\n            # If we don't know, obey --enable-cross-guesses.\n          *)\n            gl_cv_func_nanosleep=\"$gl_cross_guess_normal\" ;;\n        esac\n       ])\n    ])\n   case \"$gl_cv_func_nanosleep\" in\n     *yes) ;;\n     *)\n       REPLACE_NANOSLEEP=1\n       case \"$gl_cv_func_nanosleep\" in\n         *\"mishandles large arguments\"*)\n           AC_DEFINE([HAVE_BUG_BIG_NANOSLEEP], [1],\n             [Define to 1 if nanosleep mishandles large arguments.])\n           ;;\n       esac\n       ;;\n   esac\n else\n   HAVE_NANOSLEEP=0\n fi\n LIBS=$nanosleep_save_libs\n\n # For backward compatibility.\n LIB_NANOSLEEP=\"$NANOSLEEP_LIB\"\n AC_SUBST([LIB_NANOSLEEP])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}