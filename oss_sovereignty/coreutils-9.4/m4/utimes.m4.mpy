{
  "module_name": "utimes.m4",
  "hash_id": "c23f8e366fdce68cb4ea208cd8c4f8b2a0a9ec171e67b630505e1807ee4a922c",
  "original_prompt": "Ingested from coreutils-9.4/m4/utimes.m4",
  "human_readable_source": "# Detect some bugs in glibc's implementation of utimes.\n# serial 9\n\ndnl Copyright (C) 2003-2005, 2009-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\n# See if we need to work around bugs in glibc's implementation of\n# utimes from 2003-07-12 to 2003-09-17.\n# First, there was a bug that would make utimes set mtime\n# and atime to zero (1970-01-01) unconditionally.\n# Then, there was code to round rather than truncate.\n# Then, there was an implementation (sparc64, Linux-2.4.28, glibc-2.3.3)\n# that didn't honor the NULL-means-set-to-current-time semantics.\n# Finally, there was also a version of utimes that failed on read-only\n# files, while utime worked fine (linux-2.2.20, glibc-2.2.5).\n#\n# From Jim Meyering, with suggestions from Paul Eggert.\n\nAC_DEFUN([gl_FUNC_UTIMES],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether the utimes function works],\n                 [gl_cv_func_working_utimes],\n    [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <utime.h>\n#include <errno.h>\n]GL_MDA_DEFINES[\n\nstatic int\ninorder (time_t a, time_t b, time_t c)\n{\n  return a <= b && b <= c;\n}\n\nint\nmain ()\n{\n  int result = 0;\n  char const *file = \"conftest.utimes\";\n  /* On OS/2, file timestamps must be on or after 1980 in local time,\n     with an even number of seconds.  */\n  static struct timeval timeval[2] = {{315620000 + 10, 10},\n                                      {315620000 + 1000000, 999998}};\n\n  /* Test whether utimes() essentially works.  */\n  {\n    struct stat sbuf;\n    FILE *f = fopen (file, \"w\");\n    if (f == NULL)\n      result |= 1;\n    else if (fclose (f) != 0)\n      result |= 1;\n    else if (utimes (file, timeval) != 0)\n      result |= 2;\n    else if (lstat (file, &sbuf) != 0)\n      result |= 1;\n    else if (!(sbuf.st_atime == timeval[0].tv_sec\n               && sbuf.st_mtime == timeval[1].tv_sec))\n      result |= 4;\n    if (unlink (file) != 0)\n      result |= 1;\n  }\n\n  /* Test whether utimes() with a NULL argument sets the file's timestamp\n     to the current time.  Use 'fstat' as well as 'time' to\n     determine the \"current\" time, to accommodate NFS file systems\n     if there is a time skew between the host and the NFS server.  */\n  {\n    int fd = open (file, O_WRONLY|O_CREAT, 0644);\n    if (fd < 0)\n      result |= 1;\n    else\n      {\n        time_t t0, t2;\n        struct stat st0, st1, st2;\n        if (time (&t0) == (time_t) -1)\n          result |= 1;\n        else if (fstat (fd, &st0) != 0)\n          result |= 1;\n        else if (utimes (file, timeval) != 0\n                 && (errno != EACCES\n                     /* OS/2 kLIBC utimes fails on opened files.  */\n                     || close (fd) != 0\n                     || utimes (file, timeval) != 0\n                     || (fd = open (file, O_WRONLY)) < 0))\n          result |= 2;\n        else if (utimes (file, NULL) != 0\n                 && (errno != EACCES\n                     /* OS/2 kLIBC utimes fails on opened files.  */\n                     || close (fd) != 0\n                     || utimes (file, NULL) != 0\n                     || (fd = open (file, O_WRONLY)) < 0))\n          result |= 8;\n        else if (fstat (fd, &st1) != 0)\n          result |= 1;\n        else if (write (fd, \"\\n\", 1) != 1)\n          result |= 1;\n        else if (fstat (fd, &st2) != 0)\n          result |= 1;\n        else if (time (&t2) == (time_t) -1)\n          result |= 1;\n        else\n          {\n            int m_ok_POSIX = inorder (t0, st1.st_mtime, t2);\n            int m_ok_NFS = inorder (st0.st_mtime, st1.st_mtime, st2.st_mtime);\n            if (! (st1.st_atime == st1.st_mtime))\n              result |= 16;\n            if (! (m_ok_POSIX || m_ok_NFS))\n              result |= 32;\n          }\n        if (close (fd) != 0)\n          result |= 1;\n      }\n    if (unlink (file) != 0)\n      result |= 1;\n  }\n\n  /* Test whether utimes() with a NULL argument works on read-only files.  */\n  {\n    int fd = open (file, O_WRONLY|O_CREAT, 0444);\n    if (fd < 0)\n      result |= 1;\n    else if (close (fd) != 0)\n      result |= 1;\n    else if (utimes (file, NULL) != 0)\n      result |= 64;\n    if (unlink (file) != 0)\n      result |= 1;\n  }\n\n  return result;\n}\n  ]])],\n       [gl_cv_func_working_utimes=yes],\n       [gl_cv_func_working_utimes=no],\n       [case \"$host_os\" in\n                             # Guess yes on musl systems.\n          *-musl*)           gl_cv_func_working_utimes=\"guessing yes\" ;;\n                             # Guess no on native Windows.\n          mingw* | windows*) gl_cv_func_working_utimes=\"guessing no\" ;;\n          *)                 gl_cv_func_working_utimes=\"$gl_cross_guess_normal\" ;;\n        esac\n       ])\n    ])\n\n  case \"$gl_cv_func_working_utimes\" in\n    *yes)\n      AC_DEFINE([HAVE_WORKING_UTIMES], [1], [Define if utimes works properly.])\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}