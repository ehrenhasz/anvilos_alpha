{
  "module_name": "printf.m4",
  "hash_id": "069858b4a90ac05c720b4263f2ece4973577bedf82477ddd6bcfb68fcc57254a",
  "original_prompt": "Ingested from coreutils-9.4/m4/printf.m4",
  "human_readable_source": "# printf.m4 serial 85\ndnl Copyright (C) 2003, 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl Test whether the *printf family of functions supports the 'j', 'z', 't',\ndnl 'L' size specifiers. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_sizes_c99.\n\nAC_DEFUN([gl_PRINTF_SIZES_C99],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_AC_HEADER_STDINT_H])\n  AC_REQUIRE([gl_AC_HEADER_INTTYPES_H])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports size specifiers as in C99],\n    [gl_cv_func_printf_sizes_c99],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#if HAVE_STDINT_H_WITH_UINTMAX\n# include <stdint.h>\n#endif\n#if HAVE_INTTYPES_H_WITH_UINTMAX\n# include <inttypes.h>\n#endif\nstatic char buf[100];\nint main ()\n{\n  int result = 0;\n#if HAVE_STDINT_H_WITH_UINTMAX || HAVE_INTTYPES_H_WITH_UINTMAX\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%ju %d\", (uintmax_t) 12345671, 33, 44, 55) < 0\n      || strcmp (buf, \"12345671 33\") != 0)\n    result |= 1;\n#else\n  result |= 1;\n#endif\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%zu %d\", (size_t) 12345672, 33, 44, 55) < 0\n      || strcmp (buf, \"12345672 33\") != 0)\n    result |= 2;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%tu %d\", (ptrdiff_t) 12345673, 33, 44, 55) < 0\n      || strcmp (buf, \"12345673 33\") != 0)\n    result |= 4;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%Lg %d\", (long double) 1.5, 33, 44, 55) < 0\n      || strcmp (buf, \"1.5 33\") != 0)\n    result |= 8;\n  return result;\n}]])],\n        [gl_cv_func_printf_sizes_c99=yes],\n        [gl_cv_func_printf_sizes_c99=no],\n        [\n         case \"$host_os\" in\nchangequote(,)dnl\n                                 # Guess yes on glibc systems.\n           *-gnu* | gnu*)        gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n                                 # Guess yes on FreeBSD >= 5.\n           freebsd[1-4].*)       gl_cv_func_printf_sizes_c99=\"guessing no\";;\n           freebsd* | kfreebsd*) gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n           midnightbsd*)         gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n                                 # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)        gl_cv_func_printf_sizes_c99=\"guessing no\";;\n           darwin*)              gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n                                 # Guess yes on OpenBSD >= 3.9.\n           openbsd[1-2].* | openbsd3.[0-8] | openbsd3.[0-8].*)\n                                 gl_cv_func_printf_sizes_c99=\"guessing no\";;\n           openbsd*)             gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n                                 # Guess yes on Solaris >= 2.10.\n           solaris2.[1-9][0-9]*) gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n           solaris*)             gl_cv_func_printf_sizes_c99=\"guessing no\";;\n                                 # Guess yes on NetBSD >= 3.\n           netbsd[1-2]* | netbsdelf[1-2]* | netbsdaout[1-2]* | netbsdcoff[1-2]*)\n                                 gl_cv_func_printf_sizes_c99=\"guessing no\";;\n           netbsd*)              gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n                                 # Guess yes on Android.\n           linux*-android*)      gl_cv_func_printf_sizes_c99=\"guessing yes\";;\nchangequote([,])dnl\n                                 # Guess yes on MSVC, no on mingw.\n           windows*-gnu*)        gl_cv_func_printf_sizes_c99=\"guessing no\" ;;\n           windows*-msvc*)       gl_cv_func_printf_sizes_c99=\"guessing yes\" ;;\n           mingw* | windows*)    AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                                   ],\n                                   [gl_cv_func_printf_sizes_c99=\"guessing yes\"],\n                                   [gl_cv_func_printf_sizes_c99=\"guessing no\"])\n                                 ;;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_printf_sizes_c99=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the 'w8', 'w16',\ndnl 'w32', 'w64', 'wf8', 'wf16', 'wf32', 'wf64' size specifiers. (ISO C23)\ndnl Result is gl_cv_func_printf_sizes_c23.\n\nAC_DEFUN([gl_PRINTF_SIZES_C23],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_AC_HEADER_STDINT_H])\n  AC_REQUIRE([gl_AC_HEADER_INTTYPES_H])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports size specifiers as in C23],\n    [gl_cv_func_printf_sizes_c23],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#if HAVE_STDINT_H_WITH_UINTMAX\n# include <stdint.h>\n#endif\n#if HAVE_INTTYPES_H_WITH_UINTMAX\n# include <inttypes.h>\n#endif\nstatic char buf[100];\nint main ()\n{\n  int result = 0;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%w8u %d\", (uint8_t) 123, 33, 44, 55) < 0\n      || strcmp (buf, \"123 33\") != 0)\n    result |= 1;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%wf8u %d\", (uint_fast8_t) 123, 33, 44, 55) < 0\n      || strcmp (buf, \"123 33\") != 0)\n    result |= 1;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%w16u %d\", (uint16_t) 12345, 33, 44, 55) < 0\n      || strcmp (buf, \"12345 33\") != 0)\n    result |= 2;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%wf16u %d\", (uint_fast16_t) 12345, 33, 44, 55) < 0\n      || strcmp (buf, \"12345 33\") != 0)\n    result |= 2;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%w32u %d\", (uint32_t) 12345671, 33, 44, 55) < 0\n      || strcmp (buf, \"12345671 33\") != 0)\n    result |= 4;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%wf32u %d\", (uint_fast32_t) 12345671, 33, 44, 55) < 0\n      || strcmp (buf, \"12345671 33\") != 0)\n    result |= 4;\n#if HAVE_STDINT_H_WITH_UINTMAX || HAVE_INTTYPES_H_WITH_UINTMAX\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%w64u %d\", (uint64_t) 12345671, 33, 44, 55) < 0\n      || strcmp (buf, \"12345671 33\") != 0)\n    result |= 8;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%wf64u %d\", (uint_fast64_t) 12345671, 33, 44, 55) < 0\n      || strcmp (buf, \"12345671 33\") != 0)\n    result |= 8;\n#else\n  result |= 8;\n#endif\n  return result;\n}]])],\n        [gl_cv_func_printf_sizes_c23=yes],\n        [gl_cv_func_printf_sizes_c23=no],\n        [\n         case \"$host_os\" in\n                               # Guess no on glibc systems.\n           *-gnu* | gnu*)      gl_cv_func_printf_sizes_c23=\"guessing no\";;\n                               # Guess no on musl systems.\n           *-musl* | midipix*) gl_cv_func_printf_sizes_c23=\"guessing no\";;\n                               # Guess no on Android.\n           linux*-android*)    gl_cv_func_printf_sizes_c23=\"guessing no\";;\n                               # Guess no on native Windows.\n           mingw* | windows*)  gl_cv_func_printf_sizes_c23=\"guessing no\";;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_printf_sizes_c23=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports 'long double'\ndnl arguments together with the 'L' size specifier. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_long_double.\n\nAC_DEFUN([gl_PRINTF_LONG_DOUBLE],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports 'long double' arguments],\n    [gl_cv_func_printf_long_double],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[10000];\nint main ()\n{\n  int result = 0;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%Lf %d\", 1.75L, 33, 44, 55) < 0\n      || strcmp (buf, \"1.750000 33\") != 0)\n    result |= 1;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%Le %d\", 1.75L, 33, 44, 55) < 0\n      || strcmp (buf, \"1.750000e+00 33\") != 0)\n    result |= 2;\n  buf[0] = '\\0';\n  if (sprintf (buf, \"%Lg %d\", 1.75L, 33, 44, 55) < 0\n      || strcmp (buf, \"1.75 33\") != 0)\n    result |= 4;\n  return result;\n}]])],\n        [gl_cv_func_printf_long_double=yes],\n        [gl_cv_func_printf_long_double=no],\n        [case \"$host_os\" in\n                              # Guess no on BeOS.\n           beos*)             gl_cv_func_printf_long_double=\"guessing no\";;\n                              # Guess yes on Android.\n           linux*-android*)   gl_cv_func_printf_long_double=\"guessing yes\";;\n                              # Guess yes on MSVC, no on mingw.\n           windows*-gnu*)     gl_cv_func_printf_long_double=\"guessing no\" ;;\n           windows*-msvc*)    gl_cv_func_printf_long_double=\"guessing yes\" ;;\n           mingw* | windows*) AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                                ],\n                                [gl_cv_func_printf_long_double=\"guessing yes\"],\n                                [gl_cv_func_printf_long_double=\"guessing no\"])\n                              ;;\n           *)                 gl_cv_func_printf_long_double=\"guessing yes\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports infinite and NaN\ndnl 'double' arguments and negative zero arguments in the %f, %e, %g\ndnl directives. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_infinite.\n\nAC_DEFUN([gl_PRINTF_INFINITE],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports infinite 'double' arguments],\n    [gl_cv_func_printf_infinite],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic int\nstrisnan (const char *string, size_t start_index, size_t end_index)\n{\n  if (start_index < end_index)\n    {\n      if (string[start_index] == '-')\n        start_index++;\n      if (start_index + 3 <= end_index\n          && memcmp (string + start_index, \"nan\", 3) == 0)\n        {\n          start_index += 3;\n          if (start_index == end_index\n              || (string[start_index] == '(' && string[end_index - 1] == ')'))\n            return 1;\n        }\n    }\n  return 0;\n}\nstatic int\nhave_minus_zero ()\n{\n  static double plus_zero = 0.0;\n  double minus_zero = - plus_zero;\n  return memcmp (&plus_zero, &minus_zero, sizeof (double)) != 0;\n}\nstatic char buf[10000];\nstatic double zero = 0.0;\nint main ()\n{\n  int result = 0;\n  if (sprintf (buf, \"%f\", 1.0 / zero) < 0\n      || (strcmp (buf, \"inf\") != 0 && strcmp (buf, \"infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%f\", -1.0 / zero) < 0\n      || (strcmp (buf, \"-inf\") != 0 && strcmp (buf, \"-infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%f\", zero / zero) < 0\n      || !strisnan (buf, 0, strlen (buf)))\n    result |= 2;\n  if (sprintf (buf, \"%e\", 1.0 / zero) < 0\n      || (strcmp (buf, \"inf\") != 0 && strcmp (buf, \"infinity\") != 0))\n    result |= 4;\n  if (sprintf (buf, \"%e\", -1.0 / zero) < 0\n      || (strcmp (buf, \"-inf\") != 0 && strcmp (buf, \"-infinity\") != 0))\n    result |= 4;\n  if (sprintf (buf, \"%e\", zero / zero) < 0\n      || !strisnan (buf, 0, strlen (buf)))\n    result |= 8;\n  if (sprintf (buf, \"%g\", 1.0 / zero) < 0\n      || (strcmp (buf, \"inf\") != 0 && strcmp (buf, \"infinity\") != 0))\n    result |= 16;\n  if (sprintf (buf, \"%g\", -1.0 / zero) < 0\n      || (strcmp (buf, \"-inf\") != 0 && strcmp (buf, \"-infinity\") != 0))\n    result |= 16;\n  if (sprintf (buf, \"%g\", zero / zero) < 0\n      || !strisnan (buf, 0, strlen (buf)))\n    result |= 32;\n  /* This test fails on HP-UX 10.20.  */\n  if (have_minus_zero ())\n    if (sprintf (buf, \"%g\", - zero) < 0\n        || strcmp (buf, \"-0\") != 0)\n    result |= 64;\n  return result;\n}]])],\n        [gl_cv_func_printf_infinite=yes],\n        [gl_cv_func_printf_infinite=no],\n        [\n         case \"$host_os\" in\nchangequote(,)dnl\n                                 # Guess yes on glibc systems.\n           *-gnu* | gnu*)        gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on FreeBSD >= 6.\n           freebsd[1-5].*)       gl_cv_func_printf_infinite=\"guessing no\";;\n           freebsd* | kfreebsd*) gl_cv_func_printf_infinite=\"guessing yes\";;\n           midnightbsd*)         gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)        gl_cv_func_printf_infinite=\"guessing no\";;\n           darwin*)              gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on HP-UX >= 11.\n           hpux[7-9]* | hpux10*) gl_cv_func_printf_infinite=\"guessing no\";;\n           hpux*)                gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on NetBSD >= 3.\n           netbsd[1-2]* | netbsdelf[1-2]* | netbsdaout[1-2]* | netbsdcoff[1-2]*)\n                                 gl_cv_func_printf_infinite=\"guessing no\";;\n           netbsd*)              gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on OpenBSD >= 6.0.\n           openbsd[1-5].*)       gl_cv_func_printf_infinite=\"guessing no\";;\n           openbsd*)             gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess yes on BeOS.\n           beos*)                gl_cv_func_printf_infinite=\"guessing yes\";;\n                                 # Guess no on Android.\n           linux*-android*)      gl_cv_func_printf_infinite=\"guessing no\";;\nchangequote([,])dnl\n                                 # Guess yes on MSVC, no on mingw.\n           windows*-gnu*)        gl_cv_func_printf_infinite=\"guessing no\" ;;\n           windows*-msvc*)       gl_cv_func_printf_infinite=\"guessing yes\" ;;\n           mingw* | windows*)    AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                                   ],\n                                   [gl_cv_func_printf_infinite=\"guessing yes\"],\n                                   [gl_cv_func_printf_infinite=\"guessing no\"])\n                                 ;;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_printf_infinite=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports infinite and NaN\ndnl 'long double' arguments in the %f, %e, %g directives. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_infinite_long_double.\n\nAC_DEFUN([gl_PRINTF_INFINITE_LONG_DOUBLE],\n[\n  AC_REQUIRE([gl_PRINTF_LONG_DOUBLE])\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_BIGENDIAN])\n  AC_REQUIRE([gl_LONG_DOUBLE_VS_DOUBLE])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  dnl The user can set or unset the variable gl_printf_safe to indicate\n  dnl that he wishes a safe handling of non-IEEE-754 'long double' values.\n  if test -n \"$gl_printf_safe\"; then\n    AC_DEFINE([CHECK_PRINTF_SAFE], [1],\n      [Define if you wish *printf() functions that have a safe handling of\n       non-IEEE-754 'long double' values.])\n  fi\n  case \"$gl_cv_func_printf_long_double\" in\n    *yes)\n      AC_CACHE_CHECK([whether printf supports infinite 'long double' arguments],\n        [gl_cv_func_printf_infinite_long_double],\n        [\n          AC_RUN_IFELSE(\n            [AC_LANG_SOURCE([[\n]GL_NOCRASH[\n#include <float.h>\n#include <stdio.h>\n#include <string.h>\nstatic int\nstrisnan (const char *string, size_t start_index, size_t end_index)\n{\n  if (start_index < end_index)\n    {\n      if (string[start_index] == '-')\n        start_index++;\n      if (start_index + 3 <= end_index\n          && memcmp (string + start_index, \"nan\", 3) == 0)\n        {\n          start_index += 3;\n          if (start_index == end_index\n              || (string[start_index] == '(' && string[end_index - 1] == ')'))\n            return 1;\n        }\n    }\n  return 0;\n}\nstatic char buf[10000];\nstatic long double zeroL = 0.0L;\nint main ()\n{\n  int result = 0;\n  nocrash_init();\n  if (sprintf (buf, \"%Lf\", 1.0L / zeroL) < 0\n      || (strcmp (buf, \"inf\") != 0 && strcmp (buf, \"infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%Lf\", -1.0L / zeroL) < 0\n      || (strcmp (buf, \"-inf\") != 0 && strcmp (buf, \"-infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%Lf\", zeroL / zeroL) < 0\n      || !strisnan (buf, 0, strlen (buf)))\n    result |= 1;\n  if (sprintf (buf, \"%Le\", 1.0L / zeroL) < 0\n      || (strcmp (buf, \"inf\") != 0 && strcmp (buf, \"infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%Le\", -1.0L / zeroL) < 0\n      || (strcmp (buf, \"-inf\") != 0 && strcmp (buf, \"-infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%Le\", zeroL / zeroL) < 0\n      || !strisnan (buf, 0, strlen (buf)))\n    result |= 1;\n  if (sprintf (buf, \"%Lg\", 1.0L / zeroL) < 0\n      || (strcmp (buf, \"inf\") != 0 && strcmp (buf, \"infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%Lg\", -1.0L / zeroL) < 0\n      || (strcmp (buf, \"-inf\") != 0 && strcmp (buf, \"-infinity\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%Lg\", zeroL / zeroL) < 0\n      || !strisnan (buf, 0, strlen (buf)))\n    result |= 1;\n#if CHECK_PRINTF_SAFE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n/* Representation of an 80-bit 'long double' as an initializer for a sequence\n   of 'unsigned int' words.  */\n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  { /* Quiet NaN.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) < 0\n        || !strisnan (buf, 0, strlen (buf)))\n      result |= 2;\n    if (sprintf (buf, \"%Le\", x.value) < 0\n        || !strisnan (buf, 0, strlen (buf)))\n      result |= 2;\n    if (sprintf (buf, \"%Lg\", x.value) < 0\n        || !strisnan (buf, 0, strlen (buf)))\n      result |= 2;\n  }\n  {\n    /* Signalling NaN.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) < 0\n        || !strisnan (buf, 0, strlen (buf)))\n      result |= 2;\n    if (sprintf (buf, \"%Le\", x.value) < 0\n        || !strisnan (buf, 0, strlen (buf)))\n      result |= 2;\n    if (sprintf (buf, \"%Lg\", x.value) < 0\n        || !strisnan (buf, 0, strlen (buf)))\n      result |= 2;\n  }\n  { /* Pseudo-NaN.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) <= 0)\n      result |= 4;\n    if (sprintf (buf, \"%Le\", x.value) <= 0)\n      result |= 4;\n    if (sprintf (buf, \"%Lg\", x.value) <= 0)\n      result |= 4;\n  }\n  { /* Pseudo-Infinity.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) <= 0)\n      result |= 8;\n    if (sprintf (buf, \"%Le\", x.value) <= 0)\n      result |= 8;\n    if (sprintf (buf, \"%Lg\", x.value) <= 0)\n      result |= 8;\n  }\n  { /* Pseudo-Zero.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) <= 0)\n      result |= 16;\n    if (sprintf (buf, \"%Le\", x.value) <= 0)\n      result |= 16;\n    if (sprintf (buf, \"%Lg\", x.value) <= 0)\n      result |= 16;\n  }\n  { /* Unnormalized number.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) <= 0)\n      result |= 32;\n    if (sprintf (buf, \"%Le\", x.value) <= 0)\n      result |= 32;\n    if (sprintf (buf, \"%Lg\", x.value) <= 0)\n      result |= 32;\n  }\n  { /* Pseudo-Denormal.  */\n    static union { unsigned int word[4]; long double value; } x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    if (sprintf (buf, \"%Lf\", x.value) <= 0)\n      result |= 64;\n    if (sprintf (buf, \"%Le\", x.value) <= 0)\n      result |= 64;\n    if (sprintf (buf, \"%Lg\", x.value) <= 0)\n      result |= 64;\n  }\n#endif\n  return result;\n}]])],\n            [gl_cv_func_printf_infinite_long_double=yes],\n            [gl_cv_func_printf_infinite_long_double=no],\n            [case \"$host_cpu\" in\n                                     # Guess no on ia64, x86_64, i386.\n               ia64 | x86_64 | i*86) gl_cv_func_printf_infinite_long_double=\"guessing no\";;\n               *)\n                 case \"$host_os\" in\nchangequote(,)dnl\n                                         # Guess yes on glibc systems.\n                   *-gnu* | gnu*)        gl_cv_func_printf_infinite_long_double=\"guessing yes\";;\n                                         # Guess yes on musl systems.\n                   *-musl* | midipix*)   gl_cv_func_printf_infinite_long_double=\"guessing yes\";;\n                                         # Guess yes on FreeBSD >= 6.\n                   freebsd[1-5].*)       gl_cv_func_printf_infinite_long_double=\"guessing no\";;\n                   freebsd* | kfreebsd*) gl_cv_func_printf_infinite_long_double=\"guessing yes\";;\n                   midnightbsd*)         gl_cv_func_printf_infinite_long_double=\"guessing yes\";;\n                                         # Guess yes on HP-UX >= 11.\n                   hpux[7-9]* | hpux10*) gl_cv_func_printf_infinite_long_double=\"guessing no\";;\n                   hpux*)                gl_cv_func_printf_infinite_long_double=\"guessing yes\";;\n                                         # Guess yes on OpenBSD >= 6.0.\n                   openbsd[1-5].*)       gl_cv_func_printf_infinite_long_double=\"guessing no\";;\n                   openbsd*)             gl_cv_func_printf_infinite_long_double=\"guessing yes\";;\n                                         # Guess no on Android.\n                   linux*-android*)      gl_cv_func_printf_infinite_long_double=\"guessing no\";;\nchangequote([,])dnl\n                                         # Guess yes on MSVC, no on mingw.\n                   windows*-gnu*)        gl_cv_func_printf_infinite_long_double=\"guessing no\" ;;\n                   windows*-msvc*)       gl_cv_func_printf_infinite_long_double=\"guessing yes\" ;;\n                   mingw* | windows*)    AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                                           ],\n                                           [gl_cv_func_printf_infinite_long_double=\"guessing yes\"],\n                                           [gl_cv_func_printf_infinite_long_double=\"guessing no\"])\n                                         ;;\n                                         # If we don't know, obey --enable-cross-guesses.\n                   *)                    gl_cv_func_printf_infinite_long_double=\"$gl_cross_guess_normal\";;\n                 esac\n                 ;;\n             esac\n            ])\n        ])\n      ;;\n    *)\n      gl_cv_func_printf_infinite_long_double=\"irrelevant\"\n      ;;\n  esac\n])\n\ndnl Test whether the *printf family of functions supports the 'a' and 'A'\ndnl conversion specifier for hexadecimal output of floating-point numbers.\ndnl (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_directive_a.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_A],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'a' and 'A' directives],\n    [gl_cv_func_printf_directive_a],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nstatic double zero = 0.0;\nint main ()\n{\n  int result = 0;\n  if (sprintf (buf, \"%a %d\", 3.1416015625, 33, 44, 55) < 0\n      || (strcmp (buf, \"0x1.922p+1 33\") != 0\n          && strcmp (buf, \"0x3.244p+0 33\") != 0\n          && strcmp (buf, \"0x6.488p-1 33\") != 0\n          && strcmp (buf, \"0xc.91p-2 33\") != 0))\n    result |= 1;\n  if (sprintf (buf, \"%A %d\", -3.1416015625, 33, 44, 55) < 0\n      || (strcmp (buf, \"-0X1.922P+1 33\") != 0\n          && strcmp (buf, \"-0X3.244P+0 33\") != 0\n          && strcmp (buf, \"-0X6.488P-1 33\") != 0\n          && strcmp (buf, \"-0XC.91P-2 33\") != 0))\n    result |= 2;\n  /* This catches a FreeBSD 13.0 bug: it doesn't round.  */\n  if (sprintf (buf, \"%.2a %d\", 1.51, 33, 44, 55) < 0\n      || (strcmp (buf, \"0x1.83p+0 33\") != 0\n          && strcmp (buf, \"0x3.05p-1 33\") != 0\n          && strcmp (buf, \"0x6.0ap-2 33\") != 0\n          && strcmp (buf, \"0xc.14p-3 33\") != 0))\n    result |= 4;\n  /* This catches a Mac OS X 10.12.4 (Darwin 16.5) bug: it doesn't round.  */\n  if (sprintf (buf, \"%.0a %d\", 1.51, 33, 44, 55) < 0\n      || (strcmp (buf, \"0x2p+0 33\") != 0\n          && strcmp (buf, \"0x3p-1 33\") != 0\n          && strcmp (buf, \"0x6p-2 33\") != 0\n          && strcmp (buf, \"0xcp-3 33\") != 0))\n    result |= 4;\n  /* This catches a FreeBSD 6.1 bug.  See\n     <https://lists.gnu.org/r/bug-gnulib/2007-04/msg00107.html> */\n  if (sprintf (buf, \"%010a %d\", 1.0 / zero, 33, 44, 55) < 0\n      || buf[0] == '0')\n    result |= 8;\n  /* This catches a Mac OS X 10.3.9 (Darwin 7.9) bug.  */\n  if (sprintf (buf, \"%.1a\", 1.999) < 0\n      || (strcmp (buf, \"0x1.0p+1\") != 0\n          && strcmp (buf, \"0x2.0p+0\") != 0\n          && strcmp (buf, \"0x4.0p-1\") != 0\n          && strcmp (buf, \"0x8.0p-2\") != 0))\n    result |= 16;\n  /* This catches the same Mac OS X 10.3.9 (Darwin 7.9) bug and also a\n     glibc 2.4 bug <https://sourceware.org/bugzilla/show_bug.cgi?id=2908>.  */\n  if (sprintf (buf, \"%.1La\", 1.999L) < 0\n      || (strcmp (buf, \"0x1.0p+1\") != 0\n          && strcmp (buf, \"0x2.0p+0\") != 0\n          && strcmp (buf, \"0x4.0p-1\") != 0\n          && strcmp (buf, \"0x8.0p-2\") != 0))\n    result |= 32;\n  return result;\n}]])],\n        [gl_cv_func_printf_directive_a=yes],\n        [gl_cv_func_printf_directive_a=no],\n        [\n         case \"$host_os\" in\n                                 # Guess yes on glibc >= 2.5 systems.\n           *-gnu* | gnu*)\n             AC_EGREP_CPP([BZ2908], [\n               #include <features.h>\n               #ifdef __GNU_LIBRARY__\n                #if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 5) || (__GLIBC__ > 2)) && !defined __UCLIBC__\n                 BZ2908\n                #endif\n               #endif\n               ],\n               [gl_cv_func_printf_directive_a=\"guessing yes\"],\n               [gl_cv_func_printf_directive_a=\"guessing no\"])\n             ;;\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_printf_directive_a=\"guessing yes\";;\n                                 # Guess no on Android.\n           linux*-android*)      gl_cv_func_printf_directive_a=\"guessing no\";;\n                                 # Guess no on native Windows.\n           mingw* | windows*)    gl_cv_func_printf_directive_a=\"guessing no\";;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_printf_directive_a=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the 'b' conversion\ndnl specifier for binary output of integers.\ndnl (ISO C23)\ndnl Result is gl_cv_func_printf_directive_b.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_B],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'b' directive],\n    [gl_cv_func_printf_directive_b],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nint main ()\n{\n  int result = 0;\n  if (sprintf (buf, \"%b %d\", 12345, 33, 44, 55) < 0\n      || strcmp (buf, \"11000000111001 33\") != 0)\n    result |= 1;\n  return result;\n}]])],\n        [gl_cv_func_printf_directive_b=yes],\n        [gl_cv_func_printf_directive_b=no],\n        [\n         case \"$host_os\" in\n                               # Guess yes on glibc >= 2.35 systems.\n           *-gnu* | gnu*)\n             AC_EGREP_CPP([Lucky], [\n               #include <features.h>\n               #ifdef __GNU_LIBRARY__\n                #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 35) || (__GLIBC__ > 2)\n                 Lucky user\n                #endif\n               #endif\n               ],\n               [gl_cv_func_printf_directive_uppercase_b=\"guessing yes\"],\n               [gl_cv_func_printf_directive_uppercase_b=\"guessing no\"])\n             ;;\n                               # Guess no on musl systems.\n           *-musl* | midipix*) gl_cv_func_printf_directive_b=\"guessing no\";;\n                               # Guess no on Android.\n           linux*-android*)    gl_cv_func_printf_directive_b=\"guessing no\";;\n                               # Guess no on native Windows.\n           mingw* | windows*)  gl_cv_func_printf_directive_b=\"guessing no\";;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_printf_directive_b=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the 'B' conversion\ndnl specifier for binary output of integers.\ndnl (GNU, encouraged by ISO C23 \u00a7 7.23.6.1)\ndnl Result is gl_cv_func_printf_directive_uppercase_b.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_UPPERCASE_B],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'B' directive],\n    [gl_cv_func_printf_directive_uppercase_b],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nint main ()\n{\n  int result = 0;\n  if (sprintf (buf, \"%#B %d\", 12345, 33, 44, 55) < 0\n      || strcmp (buf, \"0B11000000111001 33\") != 0)\n    result |= 1;\n  return result;\n}]])],\n        [gl_cv_func_printf_directive_uppercase_b=yes],\n        [gl_cv_func_printf_directive_uppercase_b=no],\n        [\n         case \"$host_os\" in\n                               # Guess yes on glibc >= 2.35 systems.\n           *-gnu* | gnu*)\n             AC_EGREP_CPP([Lucky], [\n               #include <features.h>\n               #ifdef __GNU_LIBRARY__\n                #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 35) || (__GLIBC__ > 2)\n                 Lucky user\n                #endif\n               #endif\n               ],\n               [gl_cv_func_printf_directive_uppercase_b=\"guessing yes\"],\n               [gl_cv_func_printf_directive_uppercase_b=\"guessing no\"])\n             ;;\n                               # Guess no on musl systems.\n           *-musl* | midipix*) gl_cv_func_printf_directive_uppercase_b=\"guessing no\";;\n                               # Guess no on Android.\n           linux*-android*)    gl_cv_func_printf_directive_uppercase_b=\"guessing no\";;\n                               # Guess no on native Windows.\n           mingw* | windows*)  gl_cv_func_printf_directive_uppercase_b=\"guessing no\";;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_printf_directive_uppercase_b=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the %F format\ndnl directive. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_directive_f.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_F],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'F' directive],\n    [gl_cv_func_printf_directive_f],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nstatic double zero = 0.0;\nint main ()\n{\n  int result = 0;\n  if (sprintf (buf, \"%F %d\", 1234567.0, 33, 44, 55) < 0\n      || strcmp (buf, \"1234567.000000 33\") != 0)\n    result |= 1;\n  if (sprintf (buf, \"%F\", 1.0 / zero) < 0\n      || (strcmp (buf, \"INF\") != 0 && strcmp (buf, \"INFINITY\") != 0))\n    result |= 2;\n  /* This catches a Cygwin 1.5.x bug.  */\n  if (sprintf (buf, \"%.F\", 1234.0) < 0\n      || strcmp (buf, \"1234\") != 0)\n    result |= 4;\n  return result;\n}]])],\n        [gl_cv_func_printf_directive_f=yes],\n        [gl_cv_func_printf_directive_f=no],\n        [\n         case \"$host_os\" in\nchangequote(,)dnl\n                                 # Guess yes on glibc systems.\n           *-gnu* | gnu*)        gl_cv_func_printf_directive_f=\"guessing yes\";;\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_printf_directive_f=\"guessing yes\";;\n                                 # Guess yes on FreeBSD >= 6.\n           freebsd[1-5].*)       gl_cv_func_printf_directive_f=\"guessing no\";;\n           freebsd* | kfreebsd*) gl_cv_func_printf_directive_f=\"guessing yes\";;\n           midnightbsd*)         gl_cv_func_printf_directive_f=\"guessing yes\";;\n                                 # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)        gl_cv_func_printf_directive_f=\"guessing no\";;\n           darwin*)              gl_cv_func_printf_directive_f=\"guessing yes\";;\n                                 # Guess yes on OpenBSD >= 6.0.\n           openbsd[1-5].*)       gl_cv_func_printf_directive_f=\"guessing no\";;\n           openbsd*)             gl_cv_func_printf_directive_f=\"guessing yes\";;\n                                 # Guess yes on Solaris >= 2.10.\n           solaris2.[1-9][0-9]*) gl_cv_func_printf_directive_f=\"guessing yes\";;\n           solaris*)             gl_cv_func_printf_directive_f=\"guessing no\";;\n                                 # Guess no on Android.\n           linux*-android*)      gl_cv_func_printf_directive_f=\"guessing no\";;\nchangequote([,])dnl\n                                 # Guess yes on MSVC, no on mingw.\n           windows*-gnu*)        gl_cv_func_printf_directive_f=\"guessing no\" ;;\n           windows*-msvc*)       gl_cv_func_printf_directive_f=\"guessing yes\" ;;\n           mingw* | windows*)    AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                                   ],\n                                   [gl_cv_func_printf_directive_f=\"guessing yes\"],\n                                   [gl_cv_func_printf_directive_f=\"guessing no\"])\n                                 ;;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_printf_directive_f=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the %n format\ndnl directive. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_printf_directive_n.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_N],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'n' directive],\n    [gl_cv_func_printf_directive_n],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef _MSC_VER\n#include <inttypes.h>\n/* See page about \"Parameter Validation\" on msdn.microsoft.com.\n   <https://docs.microsoft.com/en-us/cpp/c-runtime-library/parameter-validation>\n   <https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/set-invalid-parameter-handler-set-thread-local-invalid-parameter-handler>  */\nstatic void cdecl\ninvalid_parameter_handler (const wchar_t *expression,\n                           const wchar_t *function,\n                           const wchar_t *file, unsigned int line,\n                           uintptr_t dummy)\n{\n  exit (1);\n}\n#endif\nstatic char fmtstring[10];\nstatic char buf[100];\nint main ()\n{\n  int count = -1;\n#ifdef _MSC_VER\n  _set_invalid_parameter_handler (invalid_parameter_handler);\n#endif\n  /* Copy the format string.  Some systems (glibc with _FORTIFY_SOURCE=2)\n     support %n in format strings in read-only memory but not in writable\n     memory.  */\n  strcpy (fmtstring, \"%d %n\");\n  if (sprintf (buf, fmtstring, 123, &count, 33, 44, 55) < 0\n      || strcmp (buf, \"123 \") != 0\n      || count != 4)\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_printf_directive_n=yes],\n        [gl_cv_func_printf_directive_n=no],\n        [case \"$host_os\" in\n                              # Guess no on glibc when _FORTIFY_SOURCE >= 2.\n           *-gnu* | gnu*)     AC_COMPILE_IFELSE(\n                                [AC_LANG_SOURCE(\n                                   [[#if _FORTIFY_SOURCE >= 2\n                                      error fail\n                                     #endif\n                                   ]])],\n                                [gl_cv_func_printf_directive_n=\"guessing yes\"],\n                                [gl_cv_func_printf_directive_n=\"guessing no\"])\n                              ;;\n                              # Guess no on Android.\n           linux*-android*)   gl_cv_func_printf_directive_n=\"guessing no\";;\n                              # Guess no on native Windows.\n           mingw* | windows*) gl_cv_func_printf_directive_n=\"guessing no\";;\n           *)                 gl_cv_func_printf_directive_n=\"guessing yes\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the %ls format\ndnl directive and in particular, when a precision is specified, whether\ndnl the functions stop converting the wide string argument when the number\ndnl of bytes that have been produced by this conversion equals or exceeds\ndnl the precision.\ndnl Result is gl_cv_func_printf_directive_ls.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_LS],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'ls' directive],\n    [gl_cv_func_printf_directive_ls],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\nint main ()\n{\n  int result = 0;\n  char buf[100];\n  /* Test whether %ls works at all.\n     This test fails on OpenBSD 4.0, IRIX 6.5, Solaris 2.6, Haiku, but not on\n     Cygwin 1.5.  */\n  {\n    static const wchar_t wstring[] = { 'a', 'b', 'c', 0 };\n    buf[0] = '\\0';\n    if (sprintf (buf, \"%ls\", wstring) < 0\n        || strcmp (buf, \"abc\") != 0)\n      result |= 1;\n  }\n  /* This test fails on IRIX 6.5, Solaris 2.6, Cygwin 1.5, Haiku (with an\n     assertion failure inside libc), but not on OpenBSD 4.0.  */\n  {\n    static const wchar_t wstring[] = { 'a', 0 };\n    buf[0] = '\\0';\n    if (sprintf (buf, \"%ls\", wstring) < 0\n        || strcmp (buf, \"a\") != 0)\n      result |= 2;\n  }\n  /* Test whether precisions in %ls are supported as specified in ISO C 99\n     section 7.19.6.1:\n       \"If a precision is specified, no more than that many bytes are written\n        (including shift sequences, if any), and the array shall contain a\n        null wide character if, to equal the multibyte character sequence\n        length given by the precision, the function would need to access a\n        wide character one past the end of the array.\"\n     This test fails on Solaris 10.  */\n  {\n    static const wchar_t wstring[] = { 'a', 'b', (wchar_t) 0xfdfdfdfd, 0 };\n    buf[0] = '\\0';\n    if (sprintf (buf, \"%.2ls\", wstring) < 0\n        || strcmp (buf, \"ab\") != 0)\n      result |= 8;\n  }\n  return result;\n}]])],\n        [gl_cv_func_printf_directive_ls=yes],\n        [gl_cv_func_printf_directive_ls=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n                              # Guess yes on OpenBSD >= 6.0.\n           openbsd[1-5].*)    gl_cv_func_printf_directive_ls=\"guessing no\";;\n           openbsd*)          gl_cv_func_printf_directive_ls=\"guessing yes\";;\n           irix*)             gl_cv_func_printf_directive_ls=\"guessing no\";;\n           solaris*)          gl_cv_func_printf_directive_ls=\"guessing no\";;\n           cygwin*)           gl_cv_func_printf_directive_ls=\"guessing no\";;\n           beos* | haiku*)    gl_cv_func_printf_directive_ls=\"guessing no\";;\n                              # Guess no on Android.\n           linux*-android*)   gl_cv_func_printf_directive_ls=\"guessing no\";;\n                              # Guess yes on native Windows.\n           mingw* | windows*) gl_cv_func_printf_directive_ls=\"guessing yes\";;\n           *)                 gl_cv_func_printf_directive_ls=\"guessing yes\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the %lc format\ndnl directive and in particular, when the argument is a null wide character,\ndnl whether the functions don't produce a NUL byte.\ndnl Result is gl_cv_func_printf_directive_lc.\n\nAC_DEFUN([gl_PRINTF_DIRECTIVE_LC],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the 'lc' directive correctly],\n    [gl_cv_func_printf_directive_lc],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <wchar.h>\n#include <string.h>\nint main ()\n{\n  int result = 0;\n  char buf[100];\n  /* This test fails on glibc 2.35, FreeBSD 13.1, NetBSD 9.0, OpenBSD 7.2,\n     macOS 12.5, AIX 7.2, Solaris 11.4.\n     glibc 2.35 bug: <https://sourceware.org/bugzilla/show_bug.cgi?id=30257>  */\n  {\n    buf[0] = '\\0';\n    if (sprintf (buf, \"%lc%lc%lc\", (wint_t) 'a', (wint_t) 0, (wint_t) 'z') < 0\n        || strcmp (buf, \"az\") != 0)\n      result |= 1;\n  }\n  return result;\n}]])],\n        [gl_cv_func_printf_directive_lc=yes],\n        [gl_cv_func_printf_directive_lc=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n                               # Guess yes on musl libc.\n           *-musl* | midipix*) gl_cv_func_printf_directive_lc=\"guessing yes\";;\n                               # Guess no otherwise.\n           *)                  gl_cv_func_printf_directive_lc=\"guessing no\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports POSIX/XSI format\ndnl strings with positions. (POSIX:2001)\ndnl Result is gl_cv_func_printf_positions.\n\nAC_DEFUN_ONCE([gl_PRINTF_POSITIONS],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports POSIX/XSI format strings with positions],\n    [gl_cv_func_printf_positions],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\n/* The string \"%2$d %1$d\", with dollar characters protected from the shell's\n   dollar expansion (possibly an autoconf bug).  */\nstatic char format[] = { '%', '2', '$', 'd', ' ', '%', '1', '$', 'd', '\\0' };\nstatic char buf[100];\nint main ()\n{\n  sprintf (buf, format, 33, 55);\n  return (strcmp (buf, \"55 33\") != 0);\n}]])],\n        [gl_cv_func_printf_positions=yes],\n        [gl_cv_func_printf_positions=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n           netbsd[1-3]* | netbsdelf[1-3]* | netbsdaout[1-3]* | netbsdcoff[1-3]*)\n             gl_cv_func_printf_positions=\"guessing no\";;\n           beos*)\n             gl_cv_func_printf_positions=\"guessing no\";;\n             # Guess yes on Android.\n           linux*-android*)\n             gl_cv_func_printf_positions=\"guessing yes\";;\n             # Guess no on native Windows.\n           mingw* | windows* | pw*)\n             gl_cv_func_printf_positions=\"guessing no\";;\n           *)\n             gl_cv_func_printf_positions=\"guessing yes\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports POSIX/XSI format\ndnl strings with the ' flag for grouping of decimal digits. (POSIX:2001)\ndnl Result is gl_cv_func_printf_flag_grouping.\n\nAC_DEFUN([gl_PRINTF_FLAG_GROUPING],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the grouping flag],\n    [gl_cv_func_printf_flag_grouping],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nint main ()\n{\n  if (sprintf (buf, \"%'d %d\", 1234567, 99) < 0\n      || buf[strlen (buf) - 1] != '9')\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_printf_flag_grouping=yes],\n        [gl_cv_func_printf_flag_grouping=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n           cygwin*)                 gl_cv_func_printf_flag_grouping=\"guessing no\";;\n           netbsd*)                 gl_cv_func_printf_flag_grouping=\"guessing no\";;\n                                    # Guess no on Android.\n           linux*-android*)         gl_cv_func_printf_flag_grouping=\"guessing no\";;\n                                    # Guess no on native Windows.\n           mingw* | windows* | pw*) gl_cv_func_printf_flag_grouping=\"guessing no\";;\n           *)                       gl_cv_func_printf_flag_grouping=\"guessing yes\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports the - flag correctly.\ndnl (ISO C99.) See\ndnl <https://lists.gnu.org/r/bug-coreutils/2008-02/msg00035.html>\ndnl Result is gl_cv_func_printf_flag_leftadjust.\n\nAC_DEFUN([gl_PRINTF_FLAG_LEFTADJUST],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the left-adjust flag correctly],\n    [gl_cv_func_printf_flag_leftadjust],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nint main ()\n{\n  /* Check that a '-' flag is not annihilated by a negative width.  */\n  if (sprintf (buf, \"a%-*sc\", -3, \"b\") < 0\n      || strcmp (buf, \"ab  c\") != 0)\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_printf_flag_leftadjust=yes],\n        [gl_cv_func_printf_flag_leftadjust=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n                              # Guess yes on HP-UX 11.\n           hpux11*)           gl_cv_func_printf_flag_leftadjust=\"guessing yes\";;\n                              # Guess no on HP-UX 10 and older.\n           hpux*)             gl_cv_func_printf_flag_leftadjust=\"guessing no\";;\n                              # Guess yes on Android.\n           linux*-android*)   gl_cv_func_printf_flag_leftadjust=\"guessing yes\";;\n                              # Guess yes on native Windows.\n           mingw* | windows*) gl_cv_func_printf_flag_leftadjust=\"guessing yes\";;\n                              # Guess yes otherwise.\n           *)                 gl_cv_func_printf_flag_leftadjust=\"guessing yes\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports padding of non-finite\ndnl values with the 0 flag correctly. (ISO C99 + TC1 + TC2.) See\ndnl <https://lists.gnu.org/r/bug-gnulib/2007-04/msg00107.html>\ndnl Result is gl_cv_func_printf_flag_zero.\n\nAC_DEFUN([gl_PRINTF_FLAG_ZERO],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports the zero flag correctly],\n    [gl_cv_func_printf_flag_zero],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[100];\nstatic double zero = 0.0;\nint main ()\n{\n  if (sprintf (buf, \"%010f\", 1.0 / zero, 33, 44, 55) < 0\n      || (strcmp (buf, \"       inf\") != 0\n          && strcmp (buf, \"  infinity\") != 0))\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_printf_flag_zero=yes],\n        [gl_cv_func_printf_flag_zero=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n                               # Guess yes on glibc systems.\n           *-gnu* | gnu*)      gl_cv_func_printf_flag_zero=\"guessing yes\";;\n                               # Guess yes on musl systems.\n           *-musl* | midipix*) gl_cv_func_printf_flag_zero=\"guessing yes\";;\n                               # Guess yes on BeOS.\n           beos*)              gl_cv_func_printf_flag_zero=\"guessing yes\";;\n                               # Guess no on Android.\n           linux*-android*)    gl_cv_func_printf_flag_zero=\"guessing no\";;\n                               # Guess no on native Windows.\n           mingw* | windows*)  gl_cv_func_printf_flag_zero=\"guessing no\";;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_printf_flag_zero=\"$gl_cross_guess_normal\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions supports large precisions.\ndnl On mingw, precisions larger than 512 are treated like 512, in integer,\ndnl floating-point or pointer output. On Solaris 10/x86, precisions larger\ndnl than 510 in floating-point output crash the program. On Solaris 10/SPARC,\ndnl precisions larger than 510 in floating-point output yield wrong results.\ndnl On AIX 7.1, precisions larger than 998 in floating-point output yield\ndnl wrong results. On BeOS, precisions larger than 1044 crash the program.\ndnl Result is gl_cv_func_printf_precision.\n\nAC_DEFUN([gl_PRINTF_PRECISION],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf supports large precisions],\n    [gl_cv_func_printf_precision],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\nstatic char buf[5000];\nint main ()\n{\n  int result = 0;\n#ifdef __BEOS__\n  /* On BeOS, this would crash and show a dialog box.  Avoid the crash.  */\n  return 1;\n#endif\n  if (sprintf (buf, \"%.4000d %d\", 1, 33, 44) < 4000 + 3)\n    result |= 1;\n  if (sprintf (buf, \"%.4000f %d\", 1.0, 33, 44) < 4000 + 5)\n    result |= 2;\n  if (sprintf (buf, \"%.511f %d\", 1.0, 33, 44) < 511 + 5\n      || buf[0] != '1')\n    result |= 4;\n  if (sprintf (buf, \"%.999f %d\", 1.0, 33, 44) < 999 + 5\n      || buf[0] != '1')\n    result |= 4;\n  return result;\n}]])],\n        [gl_cv_func_printf_precision=yes],\n        [gl_cv_func_printf_precision=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n           # Guess no only on Solaris, native Windows, and BeOS systems.\n           solaris*)                gl_cv_func_printf_precision=\"guessing no\" ;;\n           mingw* | windows* | pw*) gl_cv_func_printf_precision=\"guessing no\" ;;\n           beos*)                   gl_cv_func_printf_precision=\"guessing no\" ;;\n                                    # Guess yes on Android.\n           linux*-android*)         gl_cv_func_printf_precision=\"guessing yes\" ;;\n           *)                       gl_cv_func_printf_precision=\"guessing yes\" ;;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the *printf family of functions recovers gracefully in case\ndnl of an out-of-memory condition, or whether it crashes the entire program.\ndnl Result is gl_cv_func_printf_enomem.\n\nAC_DEFUN([gl_PRINTF_ENOMEM],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_MULTIARCH])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether printf survives out-of-memory conditions],\n    [gl_cv_func_printf_enomem],\n    [\n      gl_cv_func_printf_enomem=\"guessing no\"\n      if test \"$cross_compiling\" = no; then\n        if test $APPLE_UNIVERSAL_BUILD = 0; then\n          AC_LANG_CONFTEST([AC_LANG_SOURCE([[\n]GL_NOCRASH[\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <errno.h>\nint main()\n{\n  struct rlimit limit;\n  int ret;\n  nocrash_init ();\n  /* Some printf implementations allocate temporary space with malloc.  */\n  /* On BSD systems, malloc() is limited by RLIMIT_DATA.  */\n#ifdef RLIMIT_DATA\n  if (getrlimit (RLIMIT_DATA, &limit) < 0)\n    return 77;\n  if (limit.rlim_max == RLIM_INFINITY || limit.rlim_max > 5000000)\n    limit.rlim_max = 5000000;\n  limit.rlim_cur = limit.rlim_max;\n  if (setrlimit (RLIMIT_DATA, &limit) < 0)\n    return 77;\n#endif\n  /* On Linux systems, malloc() is limited by RLIMIT_AS.  */\n#ifdef RLIMIT_AS\n  if (getrlimit (RLIMIT_AS, &limit) < 0)\n    return 77;\n  if (limit.rlim_max == RLIM_INFINITY || limit.rlim_max > 5000000)\n    limit.rlim_max = 5000000;\n  limit.rlim_cur = limit.rlim_max;\n  if (setrlimit (RLIMIT_AS, &limit) < 0)\n    return 77;\n#endif\n  /* Some printf implementations allocate temporary space on the stack.  */\n#ifdef RLIMIT_STACK\n  if (getrlimit (RLIMIT_STACK, &limit) < 0)\n    return 77;\n  if (limit.rlim_max == RLIM_INFINITY || limit.rlim_max > 5000000)\n    limit.rlim_max = 5000000;\n  limit.rlim_cur = limit.rlim_max;\n  if (setrlimit (RLIMIT_STACK, &limit) < 0)\n    return 77;\n#endif\n  ret = printf (\"%.5000000f\", 1.0);\n  return !(ret == 5000002 || (ret < 0 && errno == ENOMEM));\n}\n          ]])])\n          if AC_TRY_EVAL([ac_link]) && test -s conftest$ac_exeext; then\n            (./conftest 2>&AS_MESSAGE_LOG_FD\n             result=$?\n             _AS_ECHO_LOG([\\$? = $result])\n             if test $result != 0 && test $result != 77; then result=1; fi\n             exit $result\n            ) >/dev/null 2>/dev/null\n            case $? in\n              0) gl_cv_func_printf_enomem=\"yes\" ;;\n              77) gl_cv_func_printf_enomem=\"guessing no\" ;;\n              *) gl_cv_func_printf_enomem=\"no\" ;;\n            esac\n          else\n            gl_cv_func_printf_enomem=\"guessing no\"\n          fi\n          rm -fr conftest*\n        else\n          dnl A universal build on Apple Mac OS X platforms.\n          dnl The result would be 'no' in 32-bit mode and 'yes' in 64-bit mode.\n          dnl But we need a configuration result that is valid in both modes.\n          gl_cv_func_printf_enomem=\"guessing no\"\n        fi\n      fi\n      if test \"$gl_cv_func_printf_enomem\" = \"guessing no\"; then\nchangequote(,)dnl\n        case \"$host_os\" in\n                           # Guess yes on glibc systems.\n          *-gnu* | gnu*)   gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess yes on Solaris.\n          solaris*)        gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess yes on AIX.\n          aix*)            gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess yes on HP-UX/hppa.\n          hpux*)           case \"$host_cpu\" in\n                             hppa*) gl_cv_func_printf_enomem=\"guessing yes\";;\n                             *)     gl_cv_func_printf_enomem=\"guessing no\";;\n                           esac\n                           ;;\n                           # Guess yes on IRIX.\n          irix*)           gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess yes on OSF/1.\n          osf*)            gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess yes on BeOS.\n          beos*)           gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess yes on Haiku.\n          haiku*)          gl_cv_func_printf_enomem=\"guessing yes\";;\n                           # Guess no on Android.\n          linux*-android*) gl_cv_func_printf_enomem=\"guessing no\";;\n                           # If we don't know, obey --enable-cross-guesses.\n          *)               gl_cv_func_printf_enomem=\"$gl_cross_guess_normal\";;\n        esac\nchangequote([,])dnl\n      fi\n    ])\n])\n\ndnl Test whether the snprintf function exists. (ISO C99, POSIX:2001)\ndnl Result is ac_cv_func_snprintf.\n\nAC_DEFUN([gl_SNPRINTF_PRESENCE],\n[\n  AC_CHECK_FUNCS_ONCE([snprintf])\n])\n\ndnl Test whether the string produced by the snprintf function is always NUL\ndnl terminated. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_snprintf_truncation_c99.\n\nAC_DEFUN_ONCE([gl_SNPRINTF_TRUNCATION_C99],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_REQUIRE([gl_SNPRINTF_PRESENCE])\n  AC_CACHE_CHECK([whether snprintf truncates the result as in C99],\n    [gl_cv_func_snprintf_truncation_c99],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\n#if HAVE_SNPRINTF\n# define my_snprintf snprintf\n#else\n# include <stdarg.h>\nstatic int my_snprintf (char *buf, int size, const char *format, ...)\n{\n  va_list args;\n  int ret;\n  va_start (args, format);\n  ret = vsnprintf (buf, size, format, args);\n  va_end (args);\n  return ret;\n}\n#endif\nstatic char buf[100];\nint main ()\n{\n  strcpy (buf, \"ABCDEF\");\n  my_snprintf (buf, 3, \"%d %d\", 4567, 89);\n  if (memcmp (buf, \"45\\0DEF\", 6) != 0)\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_snprintf_truncation_c99=yes],\n        [gl_cv_func_snprintf_truncation_c99=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n                                 # Guess yes on glibc systems.\n           *-gnu* | gnu*)        gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on FreeBSD >= 5.\n           freebsd[1-4].*)       gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           freebsd* | kfreebsd*) gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n           midnightbsd*)         gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)        gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           darwin*)              gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on OpenBSD >= 3.9.\n           openbsd[1-2].* | openbsd3.[0-8] | openbsd3.[0-8].*)\n                                 gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           openbsd*)             gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on Solaris >= 2.6.\n           solaris2.[0-5] | solaris2.[0-5].*)\n                                 gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           solaris*)             gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on AIX >= 4.\n           aix[1-3]*)            gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           aix*)                 gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on HP-UX >= 11.\n           hpux[7-9]* | hpux10*) gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           hpux*)                gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on IRIX >= 6.5.\n           irix6.5)              gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on OSF/1 >= 5.\n           osf[3-4]*)            gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           osf*)                 gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on NetBSD >= 3.\n           netbsd[1-2]* | netbsdelf[1-2]* | netbsdaout[1-2]* | netbsdcoff[1-2]*)\n                                 gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n           netbsd*)              gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on BeOS.\n           beos*)                gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess yes on Android.\n           linux*-android*)      gl_cv_func_snprintf_truncation_c99=\"guessing yes\";;\n                                 # Guess no on native Windows.\n           mingw* | windows*)    gl_cv_func_snprintf_truncation_c99=\"guessing no\";;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_snprintf_truncation_c99=\"$gl_cross_guess_normal\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the return value of the snprintf function is the number\ndnl of bytes (excluding the terminating NUL) that would have been produced\ndnl if the buffer had been large enough. (ISO C99, POSIX:2001)\ndnl For example, this test program fails on IRIX 6.5:\ndnl     ---------------------------------------------------------------------\ndnl     #include <stdio.h>\ndnl     int main()\ndnl     {\ndnl       static char buf[8];\ndnl       int retval = snprintf (buf, 3, \"%d\", 12345);\ndnl       return retval >= 0 && retval < 3;\ndnl     }\ndnl     ---------------------------------------------------------------------\ndnl Result is gl_cv_func_snprintf_retval_c99.\n\nAC_DEFUN_ONCE([gl_SNPRINTF_RETVAL_C99],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_REQUIRE([gl_SNPRINTF_PRESENCE])\n  AC_CACHE_CHECK([whether snprintf returns a byte count as in C99],\n    [gl_cv_func_snprintf_retval_c99],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\n#if HAVE_SNPRINTF\n# define my_snprintf snprintf\n#else\n# include <stdarg.h>\nstatic int my_snprintf (char *buf, int size, const char *format, ...)\n{\n  va_list args;\n  int ret;\n  va_start (args, format);\n  ret = vsnprintf (buf, size, format, args);\n  va_end (args);\n  return ret;\n}\n#endif\nstatic char buf[100];\nint main ()\n{\n  strcpy (buf, \"ABCDEF\");\n  if (my_snprintf (buf, 3, \"%d %d\", 4567, 89) != 7)\n    return 1;\n  if (my_snprintf (buf, 0, \"%d %d\", 4567, 89) != 7)\n    return 2;\n  if (my_snprintf (NULL, 0, \"%d %d\", 4567, 89) != 7)\n    return 3;\n  return 0;\n}]])],\n        [gl_cv_func_snprintf_retval_c99=yes],\n        [gl_cv_func_snprintf_retval_c99=no],\n        [case \"$host_os\" in\nchangequote(,)dnl\n                                 # Guess yes on glibc systems.\n           *-gnu* | gnu*)        gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on FreeBSD >= 5.\n           freebsd[1-4].*)       gl_cv_func_snprintf_retval_c99=\"guessing no\";;\n           freebsd* | kfreebsd*) gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n           midnightbsd*)         gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)        gl_cv_func_snprintf_retval_c99=\"guessing no\";;\n           darwin*)              gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on OpenBSD >= 3.9.\n           openbsd[1-2].* | openbsd3.[0-8] | openbsd3.[0-8].*)\n                                 gl_cv_func_snprintf_retval_c99=\"guessing no\";;\n           openbsd*)             gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on Solaris >= 2.10.\n           solaris2.[1-9][0-9]*) gl_cv_func_printf_sizes_c99=\"guessing yes\";;\n           solaris*)             gl_cv_func_printf_sizes_c99=\"guessing no\";;\n                                 # Guess yes on AIX >= 4.\n           aix[1-3]*)            gl_cv_func_snprintf_retval_c99=\"guessing no\";;\n           aix*)                 gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on NetBSD >= 3.\n           netbsd[1-2]* | netbsdelf[1-2]* | netbsdaout[1-2]* | netbsdcoff[1-2]*)\n                                 gl_cv_func_snprintf_retval_c99=\"guessing no\";;\n           netbsd*)              gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on BeOS.\n           beos*)                gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\n                                 # Guess yes on Android.\n           linux*-android*)      gl_cv_func_snprintf_retval_c99=\"guessing yes\";;\nchangequote([,])dnl\n                                 # Guess yes on MSVC, no on mingw.\n           windows*-gnu*)        gl_cv_func_snprintf_retval_c99=\"guessing no\" ;;\n           windows*-msvc*)       gl_cv_func_snprintf_retval_c99=\"guessing yes\" ;;\n           mingw* | windows*)    AC_EGREP_CPP([Known], [\n#ifdef _MSC_VER\n Known\n#endif\n                                   ],\n                                   [gl_cv_func_snprintf_retval_c99=\"guessing yes\"],\n                                   [gl_cv_func_snprintf_retval_c99=\"guessing no\"])\n                                 ;;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_snprintf_retval_c99=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the snprintf function supports the %n format directive\ndnl also in truncated portions of the format string. (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_snprintf_directive_n.\n\nAC_DEFUN([gl_SNPRINTF_DIRECTIVE_N],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_REQUIRE([gl_SNPRINTF_PRESENCE])\n  AC_CACHE_CHECK([whether snprintf fully supports the 'n' directive],\n    [gl_cv_func_snprintf_directive_n],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\n#if HAVE_SNPRINTF\n# define my_snprintf snprintf\n#else\n# include <stdarg.h>\nstatic int my_snprintf (char *buf, int size, const char *format, ...)\n{\n  va_list args;\n  int ret;\n  va_start (args, format);\n  ret = vsnprintf (buf, size, format, args);\n  va_end (args);\n  return ret;\n}\n#endif\nstatic char fmtstring[10];\nstatic char buf[100];\nint main ()\n{\n  int count = -1;\n  /* Copy the format string.  Some systems (glibc with _FORTIFY_SOURCE=2)\n     support %n in format strings in read-only memory but not in writable\n     memory.  */\n  strcpy (fmtstring, \"%d %n\");\n  my_snprintf (buf, 4, fmtstring, 12345, &count, 33, 44, 55);\n  if (count != 6)\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_snprintf_directive_n=yes],\n        [gl_cv_func_snprintf_directive_n=no],\n        [\n         case \"$host_os\" in\n                                 # Guess no on glibc when _FORTIFY_SOURCE >= 2.\n           *-gnu* | gnu*)        AC_COMPILE_IFELSE(\n                                   [AC_LANG_SOURCE(\n                                      [[#if _FORTIFY_SOURCE >= 2\n                                         error fail\n                                        #endif\n                                      ]])],\n                                   [gl_cv_func_snprintf_directive_n=\"guessing yes\"],\n                                   [gl_cv_func_snprintf_directive_n=\"guessing no\"])\n                                 ;;\nchangequote(,)dnl\n                                 # Guess yes on musl systems.\n           *-musl* | midipix*)   gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on FreeBSD >= 5.\n           freebsd[1-4].*)       gl_cv_func_snprintf_directive_n=\"guessing no\";;\n           freebsd* | kfreebsd*) gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n           midnightbsd*)         gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)        gl_cv_func_snprintf_directive_n=\"guessing no\";;\n           darwin*)              gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on Solaris >= 2.6.\n           solaris2.[0-5] | solaris2.[0-5].*)\n                                 gl_cv_func_snprintf_directive_n=\"guessing no\";;\n           solaris*)             gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on AIX >= 4.\n           aix[1-3]*)            gl_cv_func_snprintf_directive_n=\"guessing no\";;\n           aix*)                 gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on IRIX >= 6.5.\n           irix6.5)              gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on OSF/1 >= 5.\n           osf[3-4]*)            gl_cv_func_snprintf_directive_n=\"guessing no\";;\n           osf*)                 gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on NetBSD >= 3.\n           netbsd[1-2]* | netbsdelf[1-2]* | netbsdaout[1-2]* | netbsdcoff[1-2]*)\n                                 gl_cv_func_snprintf_directive_n=\"guessing no\";;\n           netbsd*)              gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess yes on BeOS.\n           beos*)                gl_cv_func_snprintf_directive_n=\"guessing yes\";;\n                                 # Guess no on Android.\n           linux*-android*)      gl_cv_func_snprintf_directive_n=\"guessing no\";;\n                                 # Guess no on native Windows.\n           mingw* | windows*)    gl_cv_func_snprintf_directive_n=\"guessing no\";;\n                                 # If we don't know, obey --enable-cross-guesses.\n           *)                    gl_cv_func_snprintf_directive_n=\"$gl_cross_guess_normal\";;\nchangequote([,])dnl\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the snprintf function, when passed a size = 1, writes any\ndnl output without bounds in this case, behaving like sprintf. This is the\ndnl case on Linux libc5.\ndnl Result is gl_cv_func_snprintf_size1.\n\nAC_DEFUN([gl_SNPRINTF_SIZE1],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_REQUIRE([gl_SNPRINTF_PRESENCE])\n  AC_CACHE_CHECK([whether snprintf respects a size of 1],\n    [gl_cv_func_snprintf_size1],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#if HAVE_SNPRINTF\n# define my_snprintf snprintf\n#else\n# include <stdarg.h>\nstatic int my_snprintf (char *buf, int size, const char *format, ...)\n{\n  va_list args;\n  int ret;\n  va_start (args, format);\n  ret = vsnprintf (buf, size, format, args);\n  va_end (args);\n  return ret;\n}\n#endif\nint main()\n{\n  static char buf[8] = { 'D', 'E', 'A', 'D', 'B', 'E', 'E', 'F' };\n  my_snprintf (buf, 1, \"%d\", 12345);\n  return buf[1] != 'E';\n}]])],\n        [gl_cv_func_snprintf_size1=yes],\n        [gl_cv_func_snprintf_size1=no],\n        [case \"$host_os\" in\n                              # Guess yes on Android.\n           linux*-android*)   gl_cv_func_snprintf_size1=\"guessing yes\" ;;\n                              # Guess yes on native Windows.\n           mingw* | windows*) gl_cv_func_snprintf_size1=\"guessing yes\" ;;\n           *)                 gl_cv_func_snprintf_size1=\"guessing yes\" ;;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the vsnprintf function, when passed a zero size, produces no\ndnl output. (ISO C99, POSIX:2001)\ndnl For example, snprintf nevertheless writes a NUL byte in this case\ndnl on OSF/1 5.1:\ndnl     ---------------------------------------------------------------------\ndnl     #include <stdio.h>\ndnl     int main()\ndnl     {\ndnl       static char buf[8] = { 'D', 'E', 'A', 'D', 'B', 'E', 'E', 'F' };\ndnl       snprintf (buf, 0, \"%d\", 12345);\ndnl       return buf[0] != 'D';\ndnl     }\ndnl     ---------------------------------------------------------------------\ndnl And vsnprintf writes any output without bounds in this case, behaving like\ndnl vsprintf, on HP-UX 11 and OSF/1 5.1:\ndnl     ---------------------------------------------------------------------\ndnl     #include <stdarg.h>\ndnl     #include <stdio.h>\ndnl     static int my_snprintf (char *buf, int size, const char *format, ...)\ndnl     {\ndnl       va_list args;\ndnl       int ret;\ndnl       va_start (args, format);\ndnl       ret = vsnprintf (buf, size, format, args);\ndnl       va_end (args);\ndnl       return ret;\ndnl     }\ndnl     int main()\ndnl     {\ndnl       static char buf[8] = { 'D', 'E', 'A', 'D', 'B', 'E', 'E', 'F' };\ndnl       my_snprintf (buf, 0, \"%d\", 12345);\ndnl       return buf[0] != 'D';\ndnl     }\ndnl     ---------------------------------------------------------------------\ndnl Result is gl_cv_func_vsnprintf_zerosize_c99.\n\nAC_DEFUN([gl_VSNPRINTF_ZEROSIZE_C99],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether vsnprintf respects a zero size as in C99],\n    [gl_cv_func_vsnprintf_zerosize_c99],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdarg.h>\n#include <stdio.h>\nstatic int my_snprintf (char *buf, int size, const char *format, ...)\n{\n  va_list args;\n  int ret;\n  va_start (args, format);\n  ret = vsnprintf (buf, size, format, args);\n  va_end (args);\n  return ret;\n}\nint main()\n{\n  static char buf[8] = { 'D', 'E', 'A', 'D', 'B', 'E', 'E', 'F' };\n  my_snprintf (buf, 0, \"%d\", 12345);\n  return buf[0] != 'D';\n}]])],\n        [gl_cv_func_vsnprintf_zerosize_c99=yes],\n        [gl_cv_func_vsnprintf_zerosize_c99=no],\n        [\nchangequote(,)dnl\n         case \"$host_os\" in\n                                    # Guess yes on glibc systems.\n           *-gnu* | gnu*)           gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on musl systems.\n           *-musl* | midipix*)      gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on FreeBSD >= 5.\n           freebsd[1-4].*)          gl_cv_func_vsnprintf_zerosize_c99=\"guessing no\";;\n           freebsd* | kfreebsd*)    gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n           midnightbsd*)            gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on Mac OS X >= 10.3.\n           darwin[1-6].*)           gl_cv_func_vsnprintf_zerosize_c99=\"guessing no\";;\n           darwin*)                 gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on Cygwin.\n           cygwin*)                 gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on Solaris >= 2.6.\n           solaris2.[0-5] | solaris2.[0-5].*)\n                                    gl_cv_func_vsnprintf_zerosize_c99=\"guessing no\";;\n           solaris*)                gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on AIX >= 4.\n           aix[1-3]*)               gl_cv_func_vsnprintf_zerosize_c99=\"guessing no\";;\n           aix*)                    gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on IRIX >= 6.5.\n           irix6.5)                 gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on NetBSD >= 3.\n           netbsd[1-2]* | netbsdelf[1-2]* | netbsdaout[1-2]* | netbsdcoff[1-2]*)\n                                    gl_cv_func_vsnprintf_zerosize_c99=\"guessing no\";;\n           netbsd*)                 gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on BeOS.\n           beos*)                   gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on Android.\n           linux*-android*)         gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # Guess yes on native Windows.\n           mingw* | windows* | pw*) gl_cv_func_vsnprintf_zerosize_c99=\"guessing yes\";;\n                                    # If we don't know, obey --enable-cross-guesses.\n           *)                       gl_cv_func_vsnprintf_zerosize_c99=\"$gl_cross_guess_normal\";;\n         esac\nchangequote([,])dnl\n        ])\n    ])\n])\n\ndnl Test whether the swprintf function works correctly when it produces output\ndnl that contains null wide characters.\ndnl Result is gl_cv_func_swprintf_works.\n\nAC_DEFUN([gl_SWPRINTF_WORKS],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CHECK_FUNCS_ONCE([swprintf])\n  AC_CACHE_CHECK([whether swprintf works],\n    [gl_cv_func_swprintf_works],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#ifndef __USE_MINGW_ANSI_STDIO\n# define __USE_MINGW_ANSI_STDIO 1\n#endif\n#include <stdio.h>\n#include <wchar.h>\nint main()\n{\n  int result = 0;\n  { /* This test fails on musl libc 1.2.3, FreeBSD, NetBSD, OpenBSD, macOS, AIX.  */\n    wchar_t buf[5] = { 0xBEEF, 0xBEEF, 0xBEEF, 0xBEEF, 0xBEEF };\n    int ret = swprintf (buf, 4, L\"%cz\", '\\0');\n    /* Expected result:\n         ret = 2, buf[0] = 0x0, buf[1] = 0x7a, buf[2] = 0x0, buf[3] = 0xbeef\n       musl libc 1.2.3:\n         ret = 2, buf[0] = 0x0, buf[1] = 0x0, buf[2] = 0x0, buf[3] = 0x0\n         Reported at <https://www.openwall.com/lists/musl/2023/03/22/9>.\n       FreeBSD 13.1, NetBSD 9.0, OpenBSD 7.2, macOS 12.5, AIX 7.2:\n         ret = 2, buf[0] = 0x0, buf[1] = 0xbeef, buf[2] = 0xbeef, buf[3] = 0xbeef\n     */\n    if (ret < 0 || buf[1] != 'z')\n      result |= 1;\n  }\n  { /* This test fails on mingw.  */\n    wchar_t buf[2];\n    int ret = swprintf (buf, 2, L\"%lc\", (wint_t)0);\n    /* Expected: ret = 1\n       mingw:    ret = 0\n     */\n    if (ret != 1)\n      result |= 2;\n  }\n  return result;\n}]])],\n        [gl_cv_func_swprintf_works=yes],\n        [gl_cv_func_swprintf_works=no],\n        [case \"$host_os\" in\n                                    # Guess yes on glibc systems.\n           *-gnu* | gnu*)           gl_cv_func_swprintf_works=\"guessing yes\";;\n                                    # Guess no on musl systems.\n           *-musl* | midipix*)      gl_cv_func_swprintf_works=\"guessing no\";;\n                                    # Guess no on FreeBSD, NetBSD, OpenBSD, macOS, AIX.\n           freebsd* | midnightbsd* | netbsd* | openbsd* | darwin* | aix*)\n                                    gl_cv_func_swprintf_works=\"guessing no\";;\n                                    # Guess no on native Windows.\n           mingw* | windows* | pw*) gl_cv_func_swprintf_works=\"guessing no\";;\n                                    # If we don't know, obey --enable-cross-guesses.\n           *)                       gl_cv_func_swprintf_works=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *wprintf family of functions supports the 'a' and 'A'\ndnl conversion specifier for hexadecimal output of 'long double' numbers.\ndnl (ISO C99, POSIX:2001)\ndnl Result is gl_cv_func_swprintf_directive_la.\n\nAC_DEFUN([gl_SWPRINTF_DIRECTIVE_LA],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether swprintf supports the 'La' and 'LA' directives],\n    [gl_cv_func_swprintf_directive_la],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <wchar.h>\nstatic wchar_t buf[100];\nint main ()\n{\n  int result = 0;\n  /* This catches a glibc 2.15 and Haiku 2022 bug.  */\n  if (swprintf (buf, sizeof (buf) / sizeof (wchar_t),\n                L\"%La %d\", 3.1416015625L, 33, 44, 55) < 0\n      || (wcscmp (buf, L\"0x1.922p+1 33\") != 0\n          && wcscmp (buf, L\"0x3.244p+0 33\") != 0\n          && wcscmp (buf, L\"0x6.488p-1 33\") != 0\n          && wcscmp (buf, L\"0xc.91p-2 33\") != 0))\n    result |= 1;\n  return result;\n}]])],\n        [gl_cv_func_swprintf_directive_la=yes],\n        [gl_cv_func_swprintf_directive_la=no],\n        [case \"$host_os\" in\n                               # Guess yes on glibc >= 2.17 systems.\n           *-gnu* | gnu*)\n             AC_EGREP_CPP([Unlucky], [\n               #include <features.h>\n               #ifdef __GNU_LIBRARY__\n                #if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 16) || (__GLIBC__ > 2)) && !defined __UCLIBC__\n                 Unlucky\n                #endif\n               #endif\n               ],\n               [gl_cv_func_swprintf_directive_la=\"guessing yes\"],\n               [gl_cv_func_swprintf_directive_la=\"guessing no\"])\n             ;;\n                               # Guess yes on musl systems.\n           *-musl* | midipix*) gl_cv_func_swprintf_directive_la=\"guessing yes\";;\n                               # Guess yes on Android.\n           linux*-android*)    gl_cv_func_swprintf_directive_la=\"guessing yes\";;\n                               # Guess no on native Windows.\n           mingw* | windows*)  gl_cv_func_swprintf_directive_la=\"guessing no\";;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_swprintf_directive_la=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl Test whether the *wprintf family of functions supports the 'lc' conversion\ndnl specifier for all wide characters.\ndnl (ISO C11, POSIX:2001)\ndnl Result is gl_cv_func_swprintf_directive_lc.\n\nAC_DEFUN([gl_SWPRINTF_DIRECTIVE_LC],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether swprintf supports the 'lc' directive],\n    [gl_cv_func_swprintf_directive_lc],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <wchar.h>\nstatic wchar_t buf[100];\nstatic wint_t L_invalid = (wchar_t) 0x76543210;\nint main ()\n{\n  int result = 0;\n  /* This catches a musl libc 1.2.4, Android bug.\n     Reported at <https://www.openwall.com/lists/musl/2023/06/12/3>. */\n  if (swprintf (buf, sizeof (buf) / sizeof (wchar_t),\n                L\"%lc %d\", L_invalid, 33, 44, 55) < 0)\n    result |= 1;\n  return result;\n}]])],\n        [gl_cv_func_swprintf_directive_lc=yes],\n        [gl_cv_func_swprintf_directive_lc=no],\n        [case \"$host_os\" in\n                               # Guess yes on glibc systems.\n           *-gnu* | gnu*)      gl_cv_func_swprintf_directive_lc=\"guessing yes\";;\n                               # Guess no on musl systems.\n           *-musl* | midipix*) gl_cv_func_swprintf_directive_lc=\"guessing no\";;\n                               # Guess no on Android.\n           linux*-android*)    gl_cv_func_swprintf_directive_lc=\"guessing no\";;\n                               # Guess yes on native Windows.\n           mingw* | windows*)  gl_cv_func_swprintf_directive_lc=\"guessing yes\";;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_swprintf_directive_lc=\"$gl_cross_guess_normal\";;\n         esac\n        ])\n    ])\n])\n\ndnl The results of these tests on various platforms are:\ndnl\ndnl 1 = gl_PRINTF_SIZES_C99\ndnl 2 = gl_PRINTF_SIZES_C23\ndnl 3 = gl_PRINTF_LONG_DOUBLE\ndnl 4 = gl_PRINTF_INFINITE\ndnl 5 = gl_PRINTF_INFINITE_LONG_DOUBLE\ndnl 6 = gl_PRINTF_DIRECTIVE_A\ndnl 7 = gl_PRINTF_DIRECTIVE_B\ndnl 8 = gl_PRINTF_DIRECTIVE_UPPERCASE_B\ndnl 9 = gl_PRINTF_DIRECTIVE_F\ndnl 10 = gl_PRINTF_DIRECTIVE_N\ndnl 11 = gl_PRINTF_DIRECTIVE_LS\ndnl 12 = gl_PRINTF_DIRECTIVE_LC\ndnl 13 = gl_PRINTF_POSITIONS\ndnl 14 = gl_PRINTF_FLAG_GROUPING\ndnl 15 = gl_PRINTF_FLAG_LEFTADJUST\ndnl 16 = gl_PRINTF_FLAG_ZERO\ndnl 17 = gl_PRINTF_PRECISION\ndnl 18 = gl_PRINTF_ENOMEM\ndnl 19 = gl_SNPRINTF_PRESENCE\ndnl 20 = gl_SNPRINTF_TRUNCATION_C99\ndnl 21 = gl_SNPRINTF_RETVAL_C99\ndnl 22 = gl_SNPRINTF_DIRECTIVE_N\ndnl 23 = gl_SNPRINTF_SIZE1\ndnl 24 = gl_VSNPRINTF_ZEROSIZE_C99\ndnl 25 = gl_SWPRINTF_WORKS\ndnl 26 = gl_SWPRINTF_DIRECTIVE_LA\ndnl 27 = gl_SWPRINTF_DIRECTIVE_LC\ndnl\ndnl 1 = checking whether printf supports size specifiers as in C99...\ndnl 2 = checking whether printf supports size specifiers as in C23...\ndnl 3 = checking whether printf supports 'long double' arguments...\ndnl 4 = checking whether printf supports infinite 'double' arguments...\ndnl 5 = checking whether printf supports infinite 'long double' arguments...\ndnl 6 = checking whether printf supports the 'a' and 'A' directives...\ndnl 7 = checking whether printf supports the 'b' directive...\ndnl 8 = checking whether printf supports the 'B' directive...\ndnl 9 = checking whether printf supports the 'F' directive...\ndnl 10 = checking whether printf supports the 'n' directive...\ndnl 11 = checking whether printf supports the 'ls' directive...\ndnl 12 = checking whether printf supports the 'lc' directive correctly...\ndnl 13 = checking whether printf supports POSIX/XSI format strings with positions...\ndnl 14 = checking whether printf supports the grouping flag...\ndnl 15 = checking whether printf supports the left-adjust flag correctly...\ndnl 16 = checking whether printf supports the zero flag correctly...\ndnl 17 = checking whether printf supports large precisions...\ndnl 18 = checking whether printf survives out-of-memory conditions...\ndnl 19 = checking for snprintf...\ndnl 20 = checking whether snprintf truncates the result as in C99...\ndnl 21 = checking whether snprintf returns a byte count as in C99...\ndnl 22 = checking whether snprintf fully supports the 'n' directive...\ndnl 23 = checking whether snprintf respects a size of 1...\ndnl 24 = checking whether vsnprintf respects a zero size as in C99...\ndnl 25 = checking whether swprintf works...\ndnl 26 = checking whether swprintf supports the 'La' and 'LA' directives...\ndnl 27 = checking whether swprintf supports the 'lc' directive...\ndnl\ndnl . = yes, # = no.\ndnl\ndnl                                  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27\ndnl   musl libc 1.2.3                .  #  .  .  .  .  #  #  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  #\ndnl   glibc 2.35                     .  #  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .\ndnl   glibc 2.5                      .  #  .  .  .  .  #  #  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .\ndnl   glibc 2.3.6                    .  #  .  .  .  #  #  #  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .\ndnl   FreeBSD 13.0                   .  #  .  .  .  #  #  #  .  .  .  #  .  .  .  .  .  #  .  .  .  .  .  .  #  .  #\ndnl   FreeBSD 5.4, 6.1               .  #  .  .  .  #  #  #  .  .  .  #  .  .  .  #  .  #  .  .  .  .  .  .  #  ?  ?\ndnl   Mac OS X 10.13.5               .  #  .  .  #  #  #  #  .  #  .  #  .  .  .  .  .  .  .  .  .  #  .  .  #  ?  ?\ndnl   Mac OS X 10.5.8                .  #  .  .  #  #  #  #  .  .  .  #  .  .  .  #  .  .  .  .  .  .  .  .  #  ?  ?\ndnl   Mac OS X 10.3.9                .  #  .  .  .  #  #  #  .  .  .  #  .  .  .  #  .  #  .  .  .  .  .  .  #  ?  ?\ndnl   OpenBSD 6.0, 6.7               .  #  .  .  .  #  #  #  .  .  .  #  .  .  .  .  .  #  .  .  .  .  .  .  #  .  #\ndnl   OpenBSD 3.9, 4.0               .  #  .  #  #  #  #  #  #  .  #  #  .  #  .  #  .  #  .  .  .  .  .  .  #  ?  ?\ndnl   Cygwin 1.7.0 (2009)            .  #  .  .  #  .  #  #  .  .  ?  ?  .  .  .  .  .  ?  .  .  .  .  .  .  ?  ?  ?\ndnl   Cygwin 1.5.25 (2008)           .  #  .  .  #  #  #  #  .  .  #  ?  .  .  .  .  .  #  .  .  .  .  .  .  ?  ?  ?\ndnl   Cygwin 1.5.19 (2006)           #  #  .  .  #  #  #  #  #  .  #  ?  .  #  .  #  #  #  .  .  .  .  .  .  ?  ?  ?\ndnl   Solaris 11.4                   .  #  .  #  #  #  #  #  .  .  #  #  .  .  .  #  .  .  .  .  .  .  .  .  .  #  .\ndnl   Solaris 11.3                   .  #  .  .  .  #  #  #  .  .  #  #  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .\ndnl   Solaris 11.0                   .  #  .  #  #  #  #  #  .  .  #  #  .  .  .  #  .  .  .  .  .  .  .  .  ?  ?  ?\ndnl   Solaris 10                     .  #  .  #  #  #  #  #  .  .  #  #  .  .  .  #  #  .  .  .  .  .  .  .  .  #  .\ndnl   Solaris 2.6 ... 9              #  #  .  #  #  #  #  #  #  .  #  #  .  .  .  #  #  .  .  .  #  .  .  .  ?  ?  ?\ndnl   Solaris 2.5.1                  #  #  .  #  #  #  #  #  #  .  #  #  .  .  .  #  .  .  #  #  #  #  #  #  ?  ?  ?\ndnl   AIX 7.1                        .  #  .  #  #  #  #  #  .  .  .  #  .  .  .  #  #  .  .  .  .  .  .  .  #  .  .\ndnl   AIX 5.2                        .  #  .  #  #  #  #  #  .  .  .  #  .  .  .  #  .  .  .  .  .  .  .  .  #  ?  ?\ndnl   AIX 4.3.2, 5.1                 #  #  .  #  #  #  #  #  #  .  .  #  .  .  .  #  .  .  .  .  #  .  .  .  #  ?  ?\ndnl   HP-UX 11.31                    .  #  .  .  .  #  #  #  .  .  .  ?  .  .  .  #  .  .  .  .  #  #  .  .  ?  ?  ?\ndnl   HP-UX 11.{00,11,23}            #  #  .  .  .  #  #  #  #  .  .  ?  .  .  .  #  .  .  .  .  #  #  .  #  ?  ?  ?\ndnl   HP-UX 10.20                    #  #  .  #  .  #  #  #  #  .  ?  ?  .  .  #  #  .  .  .  .  #  #  ?  #  ?  ?  ?\ndnl   IRIX 6.5                       #  #  .  #  #  #  #  #  #  .  #  #  .  .  .  #  .  .  .  .  #  .  .  .  #  ?  ?\ndnl   OSF/1 5.1                      #  #  .  #  #  #  #  #  #  .  .  ?  .  .  .  #  .  .  .  .  #  .  .  #  ?  ?  ?\ndnl   OSF/1 4.0d                     #  #  .  #  #  #  #  #  #  .  .  ?  .  .  .  #  .  .  #  #  #  #  #  #  ?  ?  ?\ndnl   NetBSD 9.0                     .  #  .  .  .  #  #  #  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  #  .  #\ndnl   NetBSD 5.0                     .  #  .  .  #  #  #  #  .  .  .  #  .  .  .  #  .  #  .  .  .  .  .  .  #  ?  ?\ndnl   NetBSD 4.0                     .  #  ?  ?  ?  ?  #  #  ?  .  ?  #  .  ?  ?  ?  ?  ?  .  .  .  ?  ?  ?  #  ?  ?\ndnl   NetBSD 3.0                     .  #  .  .  .  #  #  #  #  .  ?  #  #  #  ?  #  .  #  .  .  .  .  .  .  #  ?  ?\ndnl   Haiku                          .  #  .  .  #  #  #  #  #  .  #  ?  .  .  .  .  .  ?  .  .  ?  .  .  .  .  #  .\ndnl   BeOS                           #  #  #  .  #  #  #  #  #  .  ?  ?  #  .  ?  .  #  ?  .  .  ?  .  .  .  ?  ?  ?\ndnl   Android 4.3                    .  #  .  #  #  #  #  #  #  #  #  ?  .  #  .  #  .  #  .  .  .  #  .  .  ?  ?  ?\ndnl   old mingw / msvcrt             #  #  #  #  #  #  #  #  #  .  .  ?  #  #  .  #  #  ?  .  #  #  #  .  .  #  ?  ?\ndnl   MSVC 9                         #  #  #  #  #  #  #  #  #  #  .  ?  #  #  .  #  #  ?  #  #  #  #  .  .  #  ?  ?\ndnl   mingw 2009-2011                .  #  #  .  #  .  #  #  .  .  .  ?  #  #  .  .  .  ?  .  .  .  .  .  .  #  ?  ?\ndnl   mingw-w64 2011                 #  #  #  #  #  #  #  #  #  .  .  ?  #  #  .  #  #  ?  .  #  #  #  .  .  #  ?  ?\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}