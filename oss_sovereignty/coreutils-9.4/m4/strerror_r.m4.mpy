{
  "module_name": "strerror_r.m4",
  "hash_id": "88e5d720db2de1a331db294c0bd9c0b7e7d7e0c89605807522fe31c5883569e2",
  "original_prompt": "Ingested from coreutils-9.4/m4/strerror_r.m4",
  "human_readable_source": "# strerror_r.m4 serial 26\ndnl Copyright (C) 2002, 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_STRERROR_R],\n[\n  AC_REQUIRE([gl_STRING_H_DEFAULTS])\n  AC_REQUIRE([gl_FUNC_STRERROR_R_WORKS])\n\n  dnl Some systems don't declare strerror_r() if _THREAD_SAFE and _REENTRANT\n  dnl are not defined.\n  AC_CHECK_DECLS_ONCE([strerror_r])\n  if test $ac_cv_have_decl_strerror_r = no; then\n    HAVE_DECL_STRERROR_R=0\n  fi\n\n  if test $ac_cv_func_strerror_r = yes; then\n    if test \"$GL_GENERATE_ERRNO_H:$REPLACE_STRERROR_0\" = false:0; then\n      if test $gl_cv_func_strerror_r_posix_signature = yes; then\n        case \"$gl_cv_func_strerror_r_works\" in\n          dnl The system's strerror_r has bugs.  Replace it.\n          *no) REPLACE_STRERROR_R=1 ;;\n        esac\n      else\n        dnl The system's strerror_r() has a wrong signature. Replace it.\n        REPLACE_STRERROR_R=1\n      fi\n    else\n      dnl The system's strerror_r() cannot know about the new errno values we\n      dnl add to <errno.h>, or any fix for strerror(0). Replace it.\n      REPLACE_STRERROR_R=1\n    fi\n  fi\n])\n\n# Prerequisites of lib/strerror_r.c.\nAC_DEFUN([gl_PREREQ_STRERROR_R], [\n  AC_REQUIRE([AC_FUNC_STRERROR_R])\n  dnl glibc >= 2.3.4 and cygwin 1.7.9 have a function __xpg_strerror_r.\n  AC_CHECK_FUNCS_ONCE([__xpg_strerror_r])\n  gl_CHECK_FUNCS_ANDROID([catgets], [[#include <nl_types.h>]])\n  AC_CHECK_FUNCS_ONCE([snprintf])\n])\n\n# Detect if strerror_r works, but without affecting whether a replacement\n# strerror_r will be used.\nAC_DEFUN([gl_FUNC_STRERROR_R_WORKS],\n[\n  AC_REQUIRE([gl_HEADER_ERRNO_H])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n  dnl Persuade Android <string.h> to use the GNU strerror_r API,\n  dnl and Solaris <string.h> to declare strerror_r.\n  AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])\n\n  AC_REQUIRE([gl_FUNC_STRERROR_0])\n\n  gl_CHECK_FUNCS_ANDROID([strerror_r], [[#include <string.h>]])\n  if test $ac_cv_func_strerror_r = yes; then\n    if test \"$GL_GENERATE_ERRNO_H:$REPLACE_STRERROR_0\" = false:0; then\n      dnl The POSIX prototype is:  int strerror_r (int, char *, size_t);\n      dnl glibc, Cygwin:           char *strerror_r (int, char *, size_t);\n      dnl AIX 5.1, OSF/1 5.1:      int strerror_r (int, char *, int);\n      AC_CACHE_CHECK([for strerror_r with POSIX signature],\n        [gl_cv_func_strerror_r_posix_signature],\n        [AC_COMPILE_IFELSE(\n           [AC_LANG_PROGRAM(\n              [[#include <string.h>\n                int strerror_r (int, char *, size_t);\n              ]],\n              [])],\n           [gl_cv_func_strerror_r_posix_signature=yes],\n           [gl_cv_func_strerror_r_posix_signature=no])\n        ])\n      if test $gl_cv_func_strerror_r_posix_signature = yes; then\n        dnl AIX 6.1 strerror_r fails by returning -1, not an error number.\n        dnl HP-UX 11.31 strerror_r always fails when the buffer length argument\n        dnl is less than 80.\n        dnl FreeBSD 8.s strerror_r claims failure on 0\n        dnl Mac OS X 10.5 strerror_r treats 0 like -1\n        dnl Solaris 10 strerror_r corrupts errno on failure\n        AC_CACHE_CHECK([whether strerror_r works],\n          [gl_cv_func_strerror_r_works],\n          [AC_RUN_IFELSE(\n             [AC_LANG_PROGRAM(\n                [[#include <errno.h>\n                  #include <string.h>\n                ]],\n                [[int result = 0;\n                  char buf[79];\n                  if (strerror_r (EACCES, buf, 0) < 0)\n                    result |= 1;\n                  errno = 0;\n                  if (strerror_r (EACCES, buf, sizeof buf) != 0)\n                    result |= 2;\n                  strcpy (buf, \"Unknown\");\n                  if (strerror_r (0, buf, sizeof buf) != 0)\n                    result |= 4;\n                  if (errno)\n                    result |= 8;\n                  if (strstr (buf, \"nknown\") || strstr (buf, \"ndefined\"))\n                    result |= 0x10;\n                  errno = 0;\n                  *buf = 0;\n                  if (strerror_r (-3, buf, sizeof buf) < 0)\n                    result |= 0x20;\n                  if (errno)\n                    result |= 0x40;\n                  if (!*buf)\n                    result |= 0x80;\n                  return result;\n                ]])],\n             [gl_cv_func_strerror_r_works=yes],\n             [gl_cv_func_strerror_r_works=no],\n             [\nchangequote(,)dnl\n              case \"$host_os\" in\n                       # Guess no on AIX.\n                aix*)  gl_cv_func_strerror_r_works=\"guessing no\";;\n                       # Guess no on HP-UX.\n                hpux*) gl_cv_func_strerror_r_works=\"guessing no\";;\n                       # Guess no on BSD variants.\n                *bsd*)  gl_cv_func_strerror_r_works=\"guessing no\";;\n                       # Guess yes otherwise.\n                *)     gl_cv_func_strerror_r_works=\"guessing yes\";;\n              esac\nchangequote([,])dnl\n             ])\n          ])\n      else\n        dnl The system's strerror() has a wrong signature.\n        dnl glibc >= 2.3.4 and cygwin 1.7.9 have a function __xpg_strerror_r.\n        AC_CHECK_FUNCS_ONCE([__xpg_strerror_r])\n        dnl In glibc < 2.14, __xpg_strerror_r does not populate buf on failure.\n        dnl In cygwin < 1.7.10, __xpg_strerror_r clobbers strerror's buffer.\n        if test $ac_cv_func___xpg_strerror_r = yes; then\n          AC_CACHE_CHECK([whether __xpg_strerror_r works],\n            [gl_cv_func_strerror_r_works],\n            [AC_RUN_IFELSE(\n               [AC_LANG_PROGRAM(\n                  [[#include <errno.h>\n                    #include <string.h>\n                    extern\n                    #ifdef __cplusplus\n                    \"C\"\n                    #endif\n                    int __xpg_strerror_r(int, char *, size_t);\n                  ]],\n                  [[int result = 0;\n                    char buf[256] = \"^\";\n                    char copy[256];\n                    char *str = strerror (-1);\n                    strcpy (copy, str);\n                    if (__xpg_strerror_r (-2, buf, 1) == 0)\n                      result |= 1;\n                    if (*buf)\n                      result |= 2;\n                    __xpg_strerror_r (-2, buf, 256);\n                    if (strcmp (str, copy))\n                      result |= 4;\n                    return result;\n                  ]])],\n               [gl_cv_func_strerror_r_works=yes],\n               [gl_cv_func_strerror_r_works=no],\n               [dnl Guess no on all platforms that have __xpg_strerror_r,\n                dnl at least until fixed glibc and cygwin are more common.\n                gl_cv_func_strerror_r_works=\"$gl_cross_guess_normal\"\n               ])\n            ])\n        fi\n      fi\n    fi\n  else\n    case \"$gl_cv_onwards_func_strerror_r\" in\n      future*) REPLACE_STRERROR_R=1 ;;\n    esac\n  fi\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}