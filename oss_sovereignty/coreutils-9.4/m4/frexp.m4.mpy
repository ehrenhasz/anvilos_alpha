{
  "module_name": "frexp.m4",
  "hash_id": "737fd774fd7caf4cbb1e6f04bb1d1405e8c74f801f045b3ce01153d60e13e403",
  "original_prompt": "Ingested from coreutils-9.4/m4/frexp.m4",
  "human_readable_source": "# frexp.m4 serial 17\ndnl Copyright (C) 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_FREXP],\n[\n  AC_REQUIRE([gl_MATH_H_DEFAULTS])\n  AC_REQUIRE([gl_CHECK_FREXP_NO_LIBM])\n  FREXP_LIBM=\n  if test $gl_cv_func_frexp_no_libm = no; then\n    AC_CACHE_CHECK([whether frexp() can be used with libm],\n      [gl_cv_func_frexp_in_libm],\n      [\n        save_LIBS=\"$LIBS\"\n        LIBS=\"$LIBS -lm\"\n        AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM(\n             [[#include <math.h>\n               double x;]],\n             [[int e; return frexp (x, &e) > 0;]])],\n          [gl_cv_func_frexp_in_libm=yes],\n          [gl_cv_func_frexp_in_libm=no])\n        LIBS=\"$save_LIBS\"\n      ])\n    if test $gl_cv_func_frexp_in_libm = yes; then\n      FREXP_LIBM=-lm\n    fi\n  fi\n  if test $gl_cv_func_frexp_no_libm = yes \\\n     || test $gl_cv_func_frexp_in_libm = yes; then\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS $FREXP_LIBM\"\n    gl_FUNC_FREXP_WORKS\n    LIBS=\"$save_LIBS\"\n    case \"$gl_cv_func_frexp_works\" in\n      *yes) gl_func_frexp=yes ;;\n      *)    gl_func_frexp=no; REPLACE_FREXP=1; FREXP_LIBM= ;;\n    esac\n  else\n    gl_func_frexp=no\n  fi\n  if test $gl_func_frexp = yes; then\n    AC_DEFINE([HAVE_FREXP], [1],\n      [Define if the frexp() function is available and works.])\n  fi\n  AC_SUBST([FREXP_LIBM])\n])\n\nAC_DEFUN([gl_FUNC_FREXP_NO_LIBM],\n[\n  AC_REQUIRE([gl_MATH_H_DEFAULTS])\n  AC_REQUIRE([gl_CHECK_FREXP_NO_LIBM])\n  if test $gl_cv_func_frexp_no_libm = yes; then\n    gl_FUNC_FREXP_WORKS\n    case \"$gl_cv_func_frexp_works\" in\n      *yes) gl_func_frexp_no_libm=yes ;;\n      *)    gl_func_frexp_no_libm=no; REPLACE_FREXP=1 ;;\n    esac\n  else\n    gl_func_frexp_no_libm=no\n    dnl Set REPLACE_FREXP here because the system may have frexp in libm.\n    REPLACE_FREXP=1\n  fi\n  if test $gl_func_frexp_no_libm = yes; then\n    AC_DEFINE([HAVE_FREXP_IN_LIBC], [1],\n      [Define if the frexp() function is available in libc.])\n  fi\n])\n\ndnl Test whether frexp() can be used without linking with libm.\ndnl Set gl_cv_func_frexp_no_libm to 'yes' or 'no' accordingly.\nAC_DEFUN([gl_CHECK_FREXP_NO_LIBM],\n[\n  AC_CACHE_CHECK([whether frexp() can be used without linking with libm],\n    [gl_cv_func_frexp_no_libm],\n    [\n      AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[#include <math.h>\n             double x;]],\n           [[int e; return frexp (x, &e) > 0;]])],\n        [gl_cv_func_frexp_no_libm=yes],\n        [gl_cv_func_frexp_no_libm=no])\n    ])\n])\n\ndnl Test whether frexp() works also on denormalized numbers (this fails e.g. on\ndnl NetBSD 3.0), on infinite numbers (this fails e.g. on IRIX 6.5 and mingw),\ndnl and on negative zero (this fails e.g. on NetBSD 4.99 and mingw).\nAC_DEFUN([gl_FUNC_FREXP_WORKS],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CHECK_DECLS_ONCE([alarm])\n  AC_CACHE_CHECK([whether frexp works], [gl_cv_func_frexp_works],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <float.h>\n#include <math.h>\n#include <string.h>\n#if HAVE_DECL_ALARM\n# include <signal.h>\n# include <unistd.h>\n#endif\n/* HP cc on HP-UX 10.20 has a bug with the constant expression -0.0.\n   ICC 10.0 has a bug when optimizing the expression -zero.\n   The expression -DBL_MIN * DBL_MIN does not work when cross-compiling\n   to PowerPC on Mac OS X 10.5.  */\n#if defined __hpux || defined __sgi || defined __ICC\nstatic double\ncompute_minus_zero (void)\n{\n  return -DBL_MIN * DBL_MIN;\n}\n# define minus_zero compute_minus_zero ()\n#else\ndouble minus_zero = -0.0;\n#endif\nint main()\n{\n  int result = 0;\n  int i;\n  volatile double x;\n  double zero = 0.0;\n#if HAVE_DECL_ALARM\n  /* NeXTstep 3.3 frexp() runs into an endless loop when called on an infinite\n     number.  Let the test fail in this case.  */\n  signal (SIGALRM, SIG_DFL);\n  alarm (5);\n#endif\n  /* Test on denormalized numbers.  */\n  for (i = 1, x = 1.0; i >= DBL_MIN_EXP; i--, x *= 0.5)\n    ;\n  if (x > 0.0)\n    {\n      int exp;\n      double y = frexp (x, &exp);\n      /* On machines with IEEE754 arithmetic: x = 1.11254e-308, exp = -1022.\n         On NetBSD: y = 0.75. Correct: y = 0.5.  */\n      if (y != 0.5)\n        result |= 1;\n    }\n  /* Test on infinite numbers.  */\n  x = 1.0 / zero;\n  {\n    int exp;\n    double y = frexp (x, &exp);\n    if (y != x)\n      result |= 2;\n  }\n  /* Test on negative zero.  */\n  x = minus_zero;\n  {\n    int exp;\n    double y = frexp (x, &exp);\n    if (memcmp (&y, &x, sizeof x))\n      result |= 4;\n  }\n  return result;\n}]])],\n        [gl_cv_func_frexp_works=yes],\n        [gl_cv_func_frexp_works=no],\n        [case \"$host_os\" in\n           netbsd* | irix*) gl_cv_func_frexp_works=\"guessing no\" ;;\n             # Guess yes with MSVC, no with mingw.\n           windows*-gnu*)\n             gl_cv_func_frexp_works=\"guessing no\"\n             ;;\n           windows*-msvc*)\n             gl_cv_func_frexp_works=\"guessing yes\"\n             ;;\n           mingw* | windows*)\n             AC_EGREP_CPP([Good], [\n#ifdef _MSC_VER\n Good\n#endif\n               ],\n               [gl_cv_func_frexp_works=\"guessing yes\"],\n               [gl_cv_func_frexp_works=\"guessing no\"])\n             ;;\n           *) gl_cv_func_frexp_works=\"guessing yes\" ;;\n         esac\n        ])\n    ])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}