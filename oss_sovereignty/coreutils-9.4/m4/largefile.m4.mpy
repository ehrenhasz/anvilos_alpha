{
  "module_name": "largefile.m4",
  "hash_id": "a4ad9aab2cb1f1998f4123b6a5ba602b37dc8267b740e4fa960c384868d1c13d",
  "original_prompt": "Ingested from coreutils-9.4/m4/largefile.m4",
  "human_readable_source": "# Enable large files on systems where this is not the default.\n# Enable support for files on Linux file systems with 64-bit inode numbers.\n\n# Copyright 1992-1996, 1998-2023 Free Software Foundation, Inc.\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# The following macro works around a problem in Autoconf's AC_FUNC_FSEEKO:\n# It does not set _LARGEFILE_SOURCE=1 on HP-UX/ia64 32-bit, although this\n# setting of _LARGEFILE_SOURCE is needed so that <stdio.h> declares fseeko\n# and ftello in C++ mode as well.\n# This problem occurs in Autoconf 2.71 and earlier, which lack AC_SYS_YEAR2038.\nAC_DEFUN([gl_SET_LARGEFILE_SOURCE],\n m4_ifndef([AC_SYS_YEAR2038], [[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_FUNC_FSEEKO\n  case \"$host_os\" in\n    hpux*)\n      AC_DEFINE([_LARGEFILE_SOURCE], [1],\n        [Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2).])\n      ;;\n  esac\n ]])\n)\n\nm4_ifndef([AC_SYS_YEAR2038_RECOMMENDED], [\n# Support AC_SYS_YEAR2038_RECOMMENDED and related macros, even if\n# Autoconf 2.71 or earlier.  This code is taken from Autoconf master.\n\n# _AC_SYS_YEAR2038_TEST_CODE\n# --------------------------\n# C code used to probe for time_t that can represent time points more\n# than 2**31 - 1 seconds after the epoch.  With the usual Unix epoch,\n# these correspond to dates after 2038-01-18 22:14:07 +0000 (Gregorian),\n# hence the name.\nAC_DEFUN([_AC_SYS_YEAR2038_TEST_CODE],\n[[\n  #include <time.h>\n  /* Check that time_t can represent 2**32 - 1 correctly.  */\n  #define LARGE_TIME_T \\\\\n    ((time_t) (((time_t) 1 << 30) - 1 + 3 * ((time_t) 1 << 30)))\n  int verify_time_t_range[(LARGE_TIME_T / 65537 == 65535\n                           && LARGE_TIME_T % 65537 == 0)\n                          ? 1 : -1];\n]])\n\n# _AC_SYS_YEAR2038_OPTIONS\n# ------------------------\n# List of known ways to enable support for large time_t.  If you change\n# this list you probably also need to change the AS_CASE at the end of\n# _AC_SYS_YEAR2038_PROBE.\nm4_define([_AC_SYS_YEAR2038_OPTIONS], m4_normalize(\n    [\"none needed\"]                   dnl 64-bit and newer 32-bit Unix\n    [\"-D_TIME_BITS=64\"]               dnl glibc 2.34 with some 32-bit ABIs\n    [\"-D__MINGW_USE_VC2005_COMPAT\"]   dnl 32-bit MinGW\n    [\"-U_USE_32_BIT_TIME_T -D__MINGW_USE_VC2005_COMPAT\"]\n                                      dnl 32-bit MinGW (misconfiguration)\n))\n\n# _AC_SYS_YEAR2038_PROBE\n# ----------------------\n# Subroutine of AC_SYS_YEAR2038.  Probe for time_t that can represent\n# time points more than 2**31 - 1 seconds after the epoch (dates after\n# 2038-01-18, see above) and set the cache variable ac_cv_sys_year2038_opts\n# to one of the values in the _AC_SYS_YEAR2038_OPTIONS list, or to\n# \"support not detected\" if none of them worked.  Then, set compilation\n# options and #defines as necessary to enable large time_t support.\n#\n# Note that we do not test whether mktime, localtime, etc. handle\n# large values of time_t correctly, as that would require use of\n# AC_TRY_RUN.  Note also that some systems only support large time_t\n# together with large off_t.\n#\n# If you change this macro you may also need to change\n# _AC_SYS_YEAR2038_OPTIONS.\nAC_DEFUN([_AC_SYS_YEAR2038_PROBE],\n[AC_CACHE_CHECK([for $CC option for timestamps after 2038],\n  [ac_cv_sys_year2038_opts],\n  [ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  ac_opt_found=no\n  for ac_opt in _AC_SYS_YEAR2038_OPTIONS; do\n    AS_IF([test x\"$ac_opt\" != x\"none needed\"],\n      [CPPFLAGS=\"$ac_save_CPPFLAGS $ac_opt\"])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([_AC_SYS_YEAR2038_TEST_CODE])],\n      [ac_cv_sys_year2038_opts=\"$ac_opt\"\n      ac_opt_found=yes])\n    test $ac_opt_found = no || break\n  done\n  CPPFLAGS=\"$ac_save_CPPFLAGS\"\n  test $ac_opt_found = yes || ac_cv_sys_year2038_opts=\"support not detected\"])\n\nac_have_year2038=yes\nAS_CASE([$ac_cv_sys_year2038_opts],\n  [\"none needed\"], [],\n  [\"support not detected\"],\n    [ac_have_year2038=no],\n\n  [\"-D_TIME_BITS=64\"],\n    [AC_DEFINE([_TIME_BITS], [64],\n      [Number of bits in time_t, on hosts where this is settable.])],\n\n  [\"-D__MINGW_USE_VC2005_COMPAT\"],\n    [AC_DEFINE([__MINGW_USE_VC2005_COMPAT], [1],\n      [Define to 1 on platforms where this makes time_t a 64-bit type.])],\n\n  [\"-U_USE_32_BIT_TIME_T\"*],\n    [AC_MSG_FAILURE(m4_text_wrap(\n      [the 'time_t' type is currently forced to be 32-bit.\n       It will stop working after mid-January 2038.\n       Remove _USE_32BIT_TIME_T from the compiler flags.],\n      [], [], [55]))],\n\n  [AC_MSG_ERROR(\n    [internal error: bad value for \\$ac_cv_sys_year2038_opts])])\n])\n\n# _AC_SYS_YEAR2038_ENABLE\n# -----------------------\n# Depending on which of the YEAR2038 macros was used, add either an\n# --enable-year2038 or a --disable-year2038 to\n# the configure script.  This is expanded very late and\n# therefore there cannot be any code in the AC_ARG_ENABLE.  The\n# default value for 'enable_year2038' is emitted unconditionally\n# because the generated code always looks at this variable.\nm4_define([_AC_SYS_YEAR2038_ENABLE],\n[m4_divert_text([DEFAULTS],\n  m4_provide_if([AC_SYS_YEAR2038],\n    [enable_year2038=yes],\n    [enable_year2038=no]))]dnl\n[AC_ARG_ENABLE([year2038],\n  m4_provide_if([AC_SYS_YEAR2038],\n    [AS_HELP_STRING([--disable-year2038],\n      [don't support timestamps after 2038])],\n    [AS_HELP_STRING([--enable-year2038],\n      [support timestamps after 2038])]))])\n\n# AC_SYS_YEAR2038\n# ---------------\n# Attempt to detect and activate support for large time_t.\n# On systems where time_t is not always 64 bits, this probe can be\n# skipped by passing the --disable-year2038 option to configure.\nAC_DEFUN([AC_SYS_YEAR2038],\n[AC_REQUIRE([AC_SYS_LARGEFILE])dnl\nAS_IF([test \"$enable_year2038,$ac_have_year2038,$cross_compiling\" = yes,no,no],\n [# If we're not cross compiling and 'touch' works with a large\n  # timestamp, then we can presume the system supports wider time_t\n  # *somehow* and we just weren't able to detect it.  One common\n  # case that we deliberately *don't* probe for is a system that\n  # supports both 32- and 64-bit ABIs but only the 64-bit ABI offers\n  # wide time_t.  (It would be inappropriate for us to override an\n  # intentional use of -m32.)  Error out, demanding use of\n  # --disable-year2038 if this is intentional.\n  AS_IF([TZ=UTC0 touch -t 210602070628.15 conftest.time 2>/dev/null],\n    [AS_CASE([`TZ=UTC0 LC_ALL=C ls -l conftest.time 2>/dev/null`],\n       [*'Feb  7  2106'* | *'Feb  7 17:10'*],\n       [AC_MSG_FAILURE(m4_text_wrap(\n\t  [this system appears to support timestamps after mid-January 2038,\n\t   but no mechanism for enabling wide 'time_t' was detected.\n\t   Did you mean to build a 64-bit binary? (E.g., 'CC=\"${CC} -m64\"'.)\n\t   To proceed with 32-bit time_t, configure with '--disable-year2038'.],\n\t  [], [], [55]))])])])])\n\n# AC_SYS_YEAR2038_RECOMMENDED\n# ---------------------------\n# Same as AC_SYS_YEAR2038, but recommend support for large time_t.\n# If we cannot find any way to make time_t capable of representing\n# values larger than 2**31 - 1, error out unless --disable-year2038 is given.\nAC_DEFUN([AC_SYS_YEAR2038_RECOMMENDED],\n[AC_REQUIRE([AC_SYS_YEAR2038])dnl\nAS_IF([test \"$enable_year2038,$ac_have_year2038\" = yes,no],\n   [AC_MSG_FAILURE(m4_text_wrap(\n      [could not enable timestamps after mid-January 2038.\n       This package recommends support for these later timestamps.\n       However, to proceed with signed 32-bit time_t even though it\n       will fail then, configure with '--disable-year2038'.],\n      [], [], [55]))])])\n\n# _AC_SYS_LARGEFILE_TEST_CODE\n# ---------------------------\n# C code used to probe for large file support.\nm4_define([_AC_SYS_LARGEFILE_TEST_CODE],\n[@%:@include <sys/types.h>\n@%:@ifndef FTYPE\n@%:@ define FTYPE off_t\n@%:@endif\n /* Check that FTYPE can represent 2**63 - 1 correctly.\n    We can't simply define LARGE_FTYPE to be 9223372036854775807,\n    since some C++ compilers masquerading as C compilers\n    incorrectly reject 9223372036854775807.  */\n@%:@define LARGE_FTYPE (((FTYPE) 1 << 31 << 31) - 1 + ((FTYPE) 1 << 31 << 31))\n  int FTYPE_is_large[[(LARGE_FTYPE % 2147483629 == 721\n\t\t       && LARGE_FTYPE % 2147483647 == 1)\n\t\t      ? 1 : -1]];[]dnl\n])\n# Defined by Autoconf 2.71 and circa 2022 Gnulib unwisely depended on it.\nm4_define([_AC_SYS_LARGEFILE_TEST_INCLUDES], [_AC_SYS_LARGEFILE_TEST_CODE])\n\n# _AC_SYS_LARGEFILE_OPTIONS\n# -------------------------\n# List of known ways to enable support for large files.  If you change\n# this list you probably also need to change the AS_CASE at the end of\n# _AC_SYS_LARGEFILE_PROBE.\nm4_define([_AC_SYS_LARGEFILE_OPTIONS], m4_normalize(\n    [\"none needed\"]                   dnl Most current systems\n    [\"-D_FILE_OFFSET_BITS=64\"]        dnl X/Open LFS spec\n    [\"-D_LARGE_FILES=1\"]              dnl 32-bit AIX 4.2.1+, 32-bit z/OS\n    [\"-n32\"]                          dnl 32-bit IRIX 6, SGI cc (obsolete)\n))\n\n# _AC_SYS_LARGEFILE_PROBE\n# -----------------------\n# Subroutine of AC_SYS_LARGEFILE. Probe for large file support and set\n# the cache variable ac_cv_sys_largefile_opts to one of the values in\n# the _AC_SYS_LARGEFILE_OPTIONS list, or to \"support not detected\" if\n# none of the options in that list worked.  Then, set compilation\n# options and #defines as necessary to enable large file support.\n#\n# If large file support is not detected, the behavior depends on which of\n# the top-level AC_SYS_LARGEFILE macros was used (see below).\n#\n# If you change this macro you may also need to change\n# _AC_SYS_LARGEFILE_OPTIONS.\nAC_DEFUN([_AC_SYS_LARGEFILE_PROBE],\n[AC_CACHE_CHECK([for $CC option to enable large file support],\n  [ac_cv_sys_largefile_opts],\n  [ac_save_CC=\"$CC\"\n  ac_opt_found=no\n  for ac_opt in _AC_SYS_LARGEFILE_OPTIONS; do\n    AS_IF([test x\"$ac_opt\" != x\"none needed\"],\n      [CC=\"$ac_save_CC $ac_opt\"])\n    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([_AC_SYS_LARGEFILE_TEST_CODE])],\n     [AS_IF([test x\"$ac_opt\" = x\"none needed\"],\n\t[# GNU/Linux s390x and alpha need _FILE_OFFSET_BITS=64 for wide ino_t.\n\t CC=\"$CC -DFTYPE=ino_t\"\n\t AC_COMPILE_IFELSE([], [],\n\t   [CC=\"$CC -D_FILE_OFFSET_BITS=64\"\n\t    AC_COMPILE_IFELSE([], [ac_opt='-D_FILE_OFFSET_BITS=64'])])])\n      ac_cv_sys_largefile_opts=$ac_opt\n      ac_opt_found=yes])\n    test $ac_opt_found = no || break\n  done\n  CC=\"$ac_save_CC\"\n  dnl Gnulib implements large file support for native Windows, based on the\n  dnl variables WINDOWS_64_BIT_OFF_T, WINDOWS_64_BIT_ST_SIZE.\n  m4_ifdef([gl_LARGEFILE], [\n    AC_REQUIRE([AC_CANONICAL_HOST])\n    if test $ac_opt_found != yes; then\n      AS_CASE([$host_os],\n        [mingw* | windows*],\n          [ac_cv_sys_largefile_opts=\"supported through gnulib\"\n           ac_opt_found=yes]\n      )\n    fi\n  ])\n  test $ac_opt_found = yes || ac_cv_sys_largefile_opts=\"support not detected\"])\n\nac_have_largefile=yes\nAS_CASE([$ac_cv_sys_largefile_opts],\n  [\"none needed\"], [],\n  [\"supported through gnulib\"], [],\n  [\"support not detected\"],\n    [ac_have_largefile=no],\n\n  [\"-D_FILE_OFFSET_BITS=64\"],\n    [AC_DEFINE([_FILE_OFFSET_BITS], [64],\n      [Number of bits in a file offset, on hosts where this is settable.])],\n\n  [\"-D_LARGE_FILES=1\"],\n    [AC_DEFINE([_LARGE_FILES], [1],\n      [Define to 1 on platforms where this makes off_t a 64-bit type.])],\n\n  [\"-n32\"],\n    [CC=\"$CC -n32\"],\n\n  [AC_MSG_ERROR(\n    [internal error: bad value for \\$ac_cv_sys_largefile_opts])])\n\nAS_IF([test \"$enable_year2038\" != no],\n  [_AC_SYS_YEAR2038_PROBE])\nAC_CONFIG_COMMANDS_PRE([_AC_SYS_YEAR2038_ENABLE])])\n\n# AC_SYS_LARGEFILE\n# ----------------\n# By default, many hosts won't let programs access large files;\n# one must use special compiler options to get large-file access to work.\n# For more details about this brain damage please see:\n# http://www.unix.org/version2/whatsnew/lfs20mar.html\n# Additionally, on Linux file systems with 64-bit inodes a file that happens\n# to have a 64-bit inode number cannot be accessed by 32-bit applications on\n# Linux x86/x86_64.  This can occur with file systems such as XFS and NFS.\nAC_DEFUN([AC_SYS_LARGEFILE],\n[AC_ARG_ENABLE([largefile],\n   [AS_HELP_STRING([--disable-largefile],\n      [omit support for large files])])dnl\nAS_IF([test \"$enable_largefile,$enable_year2038\" != no,no],\n  [_AC_SYS_LARGEFILE_PROBE])])\n])# m4_ifndef AC_SYS_YEAR2038_RECOMMENDED\n\n# Enable large files on systems where this is implemented by Gnulib, not by the\n# system headers.\n# Set the variables WINDOWS_64_BIT_OFF_T, WINDOWS_64_BIT_ST_SIZE if Gnulib\n# overrides ensure that off_t or 'struct size.st_size' are 64-bit, respectively.\nAC_DEFUN([gl_LARGEFILE],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  case \"$host_os\" in\n    mingw* | windows*)\n      dnl Native Windows.\n      dnl mingw64 defines off_t to a 64-bit type already, if\n      dnl _FILE_OFFSET_BITS=64, which is ensured by AC_SYS_LARGEFILE.\n      AC_CACHE_CHECK([for 64-bit off_t], [gl_cv_type_off_t_64],\n        [AC_COMPILE_IFELSE(\n           [AC_LANG_PROGRAM(\n              [[#include <sys/types.h>\n                int verify_off_t_size[sizeof (off_t) >= 8 ? 1 : -1];\n              ]],\n              [[]])],\n           [gl_cv_type_off_t_64=yes], [gl_cv_type_off_t_64=no])\n        ])\n      if test $gl_cv_type_off_t_64 = no; then\n        WINDOWS_64_BIT_OFF_T=1\n      else\n        WINDOWS_64_BIT_OFF_T=0\n      fi\n      dnl Some mingw versions define, if _FILE_OFFSET_BITS=64, 'struct stat'\n      dnl to 'struct _stat32i64' or 'struct _stat64' (depending on\n      dnl _USE_32BIT_TIME_T), which has a 32-bit st_size member.\n      AC_CACHE_CHECK([for 64-bit st_size], [gl_cv_member_st_size_64],\n        [AC_COMPILE_IFELSE(\n           [AC_LANG_PROGRAM(\n              [[#include <sys/types.h>\n                struct stat buf;\n                int verify_st_size_size[sizeof (buf.st_size) >= 8 ? 1 : -1];\n              ]],\n              [[]])],\n           [gl_cv_member_st_size_64=yes], [gl_cv_member_st_size_64=no])\n        ])\n      if test $gl_cv_member_st_size_64 = no; then\n        WINDOWS_64_BIT_ST_SIZE=1\n      else\n        WINDOWS_64_BIT_ST_SIZE=0\n      fi\n      ;;\n    *)\n      dnl Nothing to do on gnulib's side.\n      dnl A 64-bit off_t is\n      dnl   - already the default on Mac OS X, FreeBSD, NetBSD, OpenBSD, IRIX,\n      dnl     OSF/1, Cygwin,\n      dnl   - enabled by _FILE_OFFSET_BITS=64 (ensured by AC_SYS_LARGEFILE) on\n      dnl     glibc, HP-UX, Solaris,\n      dnl   - enabled by _LARGE_FILES=1 (ensured by AC_SYS_LARGEFILE) on AIX,\n      dnl   - impossible to achieve on Minix 3.1.8.\n      WINDOWS_64_BIT_OFF_T=0\n      WINDOWS_64_BIT_ST_SIZE=0\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}