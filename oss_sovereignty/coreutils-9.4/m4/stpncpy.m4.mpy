{
  "module_name": "stpncpy.m4",
  "hash_id": "992daea3ef2d67c101f9bf997138bc0197e394cece91ea0854a884b377c5fcc2",
  "original_prompt": "Ingested from coreutils-9.4/m4/stpncpy.m4",
  "human_readable_source": "# stpncpy.m4 serial 22\ndnl Copyright (C) 2002-2003, 2005-2007, 2009-2023 Free Software Foundation,\ndnl Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_STPNCPY],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n  dnl Persuade glibc <string.h> to declare stpncpy().\n  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n\n  dnl The stpncpy() declaration in lib/string.in.h uses 'restrict'.\n  AC_REQUIRE([AC_C_RESTRICT])\n\n  AC_REQUIRE([gl_STRING_H_DEFAULTS])\n\n  dnl Both glibc and AIX (4.3.3, 5.1) have an stpncpy() function\n  dnl declared in <string.h>. Its side effects are the same as those\n  dnl of strncpy():\n  dnl      stpncpy (dest, src, n)\n  dnl overwrites dest[0..n-1], min(strlen(src),n) bytes coming from src,\n  dnl and the remaining bytes being NULs.  However, the return value is\n  dnl   in glibc:   dest + min(strlen(src),n)\n  dnl   in AIX:     dest + max(0,n-1)\n  dnl Only the glibc return value is useful in practice.\n\n  AC_CHECK_DECLS_ONCE([stpncpy])\n  gl_CHECK_FUNCS_ANDROID([stpncpy], [[#include <string.h>]])\n  if test $ac_cv_func_stpncpy = yes; then\n    AC_CACHE_CHECK([for working stpncpy], [gl_cv_func_stpncpy], [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stdlib.h>\n#include <string.h> /* for strcpy */\n/* The stpncpy prototype is missing in <string.h> on AIX 4.  */\n#if !HAVE_DECL_STPNCPY\nextern\n# ifdef __cplusplus\n\"C\"\n# endif\nchar *stpncpy (char *dest, const char *src, size_t n);\n#endif\nint main ()\n{\n  int result = 0;\n  const char *src = \"Hello\";\n  char dest[10];\n  /* AIX 4.3.3 and AIX 5.1 stpncpy() returns dest+1 here.  */\n  {\n    strcpy (dest, \"\\377\\377\\377\\377\\377\\377\");\n    if (stpncpy (dest, src, 2) != dest + 2)\n      result |= 1;\n  }\n  /* AIX 4.3.3 and AIX 5.1 stpncpy() returns dest+4 here.  */\n  {\n    strcpy (dest, \"\\377\\377\\377\\377\\377\\377\");\n    if (stpncpy (dest, src, 5) != dest + 5)\n      result |= 2;\n  }\n  /* AIX 4.3.3 and AIX 5.1 stpncpy() returns dest+6 here.  */\n  {\n    strcpy (dest, \"\\377\\377\\377\\377\\377\\377\");\n    if (stpncpy (dest, src, 7) != dest + 5)\n      result |= 4;\n  }\n  return result;\n}\n]])],\n        [gl_cv_func_stpncpy=yes],\n        [gl_cv_func_stpncpy=no],\n        [dnl Guess yes on glibc systems and musl systems.\n         AC_EGREP_CPP([Thanks for using GNU], [\n#include <features.h>\n#ifdef __GNU_LIBRARY__\n  Thanks for using GNU\n#endif\n],         [gl_cv_func_stpncpy=\"guessing yes\"],\n           [case \"$host_os\" in\n              *-musl* | midipix*) gl_cv_func_stpncpy=\"guessing yes\" ;;\n              *)                  gl_cv_func_stpncpy=\"$gl_cross_guess_normal\" ;;\n            esac\n           ])\n        ])\n    ])\n    case \"$gl_cv_func_stpncpy\" in\n      *yes)\n        AC_DEFINE([HAVE_STPNCPY], [1],\n          [Define if you have the stpncpy() function and it works.])\n        ;;\n      *)\n        REPLACE_STPNCPY=1\n        ;;\n    esac\n  else\n    HAVE_STPNCPY=0\n    case \"$gl_cv_onwards_func_stpncpy\" in\n      future*) REPLACE_STPNCPY=1 ;;\n    esac\n  fi\n])\n\n# Prerequisites of lib/stpncpy.c.\nAC_DEFUN([gl_PREREQ_STPNCPY], [\n  :\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}