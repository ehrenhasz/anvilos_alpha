{
  "module_name": "malloc.m4",
  "hash_id": "8fed00eb25a3adc2159105a0a0e016cf554cf2887bb800d611a67041cde25a13",
  "original_prompt": "Ingested from coreutils-9.4/m4/malloc.m4",
  "human_readable_source": "# malloc.m4 serial 30\ndnl Copyright (C) 2007, 2009-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\n# This is adapted with modifications from upstream Autoconf here:\n# https://git.savannah.gnu.org/cgit/autoconf.git/tree/lib/autoconf/functions.m4?id=v2.70#n949\nAC_DEFUN([_AC_FUNC_MALLOC_IF],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])dnl for cross-compiles\n  AC_CACHE_CHECK([whether malloc (0) returns nonnull],\n    [ac_cv_func_malloc_0_nonnull],\n    [AC_RUN_IFELSE(\n       [AC_LANG_PROGRAM(\n          [[#include <stdlib.h>\n          ]],\n          [[void *p = malloc (0);\n            int result = !p;\n            free (p);\n            return result;]])\n       ],\n       [ac_cv_func_malloc_0_nonnull=yes],\n       [ac_cv_func_malloc_0_nonnull=no],\n       [case \"$host_os\" in\n          # Guess yes on platforms where we know the result.\n          *-gnu* | freebsd* | netbsd* | openbsd* | bitrig* \\\n          | gnu* | *-musl* | midipix* | midnightbsd* \\\n          | hpux* | solaris* | cygwin* | mingw* | windows* | msys* )\n            ac_cv_func_malloc_0_nonnull=\"guessing yes\" ;;\n          # If we don't know, obey --enable-cross-guesses.\n          *) ac_cv_func_malloc_0_nonnull=\"$gl_cross_guess_normal\" ;;\n        esac\n       ])\n    ])\n  AS_CASE([$ac_cv_func_malloc_0_nonnull], [*yes], [$1], [$2])\n])# _AC_FUNC_MALLOC_IF\n\n# gl_FUNC_MALLOC_GNU\n# ------------------\n# Replace malloc if it is not compatible with GNU libc.\nAC_DEFUN([gl_FUNC_MALLOC_GNU],\n[\n  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n  AC_REQUIRE([gl_FUNC_MALLOC_POSIX])\n  REPLACE_MALLOC_FOR_MALLOC_GNU=\"$REPLACE_MALLOC_FOR_MALLOC_POSIX\"\n  if test $REPLACE_MALLOC_FOR_MALLOC_GNU = 0; then\n    _AC_FUNC_MALLOC_IF([], [REPLACE_MALLOC_FOR_MALLOC_GNU=1])\n  fi\n])\n\n# gl_FUNC_MALLOC_PTRDIFF\n# ----------------------\n# Test whether malloc (N) reliably fails when N exceeds PTRDIFF_MAX,\n# and replace malloc otherwise.\nAC_DEFUN([gl_FUNC_MALLOC_PTRDIFF],\n[\n  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n  AC_REQUIRE([gl_CHECK_MALLOC_PTRDIFF])\n  test \"$gl_cv_malloc_ptrdiff\" = yes || REPLACE_MALLOC_FOR_MALLOC_POSIX=1\n])\n\n# Test whether malloc, realloc, calloc refuse to create objects\n# larger than what can be expressed in ptrdiff_t.\n# Set gl_cv_func_malloc_gnu to yes or no accordingly.\nAC_DEFUN([gl_CHECK_MALLOC_PTRDIFF],\n[\n  AC_CACHE_CHECK([whether malloc is ptrdiff_t safe],\n    [gl_cv_malloc_ptrdiff],\n    [AC_COMPILE_IFELSE(\n       [AC_LANG_PROGRAM(\n          [[#include <stdint.h>\n          ]],\n          [[/* 64-bit ptrdiff_t is so wide that no practical platform\n               can exceed it.  */\n            #define WIDE_PTRDIFF (PTRDIFF_MAX >> 31 >> 31 != 0)\n\n            /* On rare machines where size_t fits in ptrdiff_t there\n               is no problem.  */\n            #define NARROW_SIZE (SIZE_MAX <= PTRDIFF_MAX)\n\n            /* glibc 2.30 and later malloc refuses to exceed ptrdiff_t\n               bounds even on 32-bit platforms.  We don't know which\n               non-glibc systems are safe.  */\n            #define KNOWN_SAFE (2 < __GLIBC__ + (30 <= __GLIBC_MINOR__))\n\n            #if WIDE_PTRDIFF || NARROW_SIZE || KNOWN_SAFE\n              return 0;\n            #else\n              #error \"malloc might not be ptrdiff_t safe\"\n              syntax error\n            #endif\n          ]])],\n       [gl_cv_malloc_ptrdiff=yes],\n       [gl_cv_malloc_ptrdiff=no])\n    ])\n])\n\n# gl_FUNC_MALLOC_POSIX\n# --------------------\n# Test whether 'malloc' is POSIX compliant (sets errno to ENOMEM when it\n# fails, and doesn't mess up with ptrdiff_t overflow), and replace\n# malloc if it is not.\nAC_DEFUN([gl_FUNC_MALLOC_POSIX],\n[\n  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n  AC_REQUIRE([gl_FUNC_MALLOC_PTRDIFF])\n  AC_REQUIRE([gl_CHECK_MALLOC_POSIX])\n  if test \"$gl_cv_func_malloc_posix\" = yes; then\n    AC_DEFINE([HAVE_MALLOC_POSIX], [1],\n      [Define if malloc, realloc, and calloc set errno on allocation failure.])\n  else\n    REPLACE_MALLOC_FOR_MALLOC_POSIX=1\n  fi\n])\n\n# Test whether malloc, realloc, calloc set errno to ENOMEM on failure.\n# Set gl_cv_func_malloc_posix to yes or no accordingly.\nAC_DEFUN([gl_CHECK_MALLOC_POSIX],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CACHE_CHECK([whether malloc, realloc, calloc set errno on failure],\n    [gl_cv_func_malloc_posix],\n    [\n      dnl It is too dangerous to try to allocate a large amount of memory:\n      dnl some systems go to their knees when you do that. So assume that\n      dnl all Unix implementations of the function set errno on failure,\n      dnl except on those platforms where we have seen 'test-malloc-gnu',\n      dnl 'test-realloc-gnu', 'test-calloc-gnu' fail.\n      case \"$host_os\" in\n        mingw* | windows*)\n          gl_cv_func_malloc_posix=no ;;\n        irix* | solaris*)\n          dnl On IRIX 6.5, the three functions return NULL with errno unset\n          dnl when the argument is larger than PTRDIFF_MAX.\n          dnl On Solaris 11.3, the three functions return NULL with errno set\n          dnl to EAGAIN, not ENOMEM, when the argument is larger than\n          dnl PTRDIFF_MAX.\n          dnl Here is a test program:\nm4_divert_push([KILL])\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define ptrdiff_t long\n#ifndef PTRDIFF_MAX\n# define PTRDIFF_MAX ((ptrdiff_t) ((1UL << (8 * sizeof (ptrdiff_t) - 1)) - 1))\n#endif\n\nint main ()\n{\n  void *p;\n\n  fprintf (stderr, \"PTRDIFF_MAX = %lu\\n\", (unsigned long) PTRDIFF_MAX);\n\n  errno = 0;\n  p = malloc ((unsigned long) PTRDIFF_MAX + 1);\n  fprintf (stderr, \"p=%p errno=%d\\n\", p, errno);\n\n  errno = 0;\n  p = calloc (PTRDIFF_MAX / 2 + 1, 2);\n  fprintf (stderr, \"p=%p errno=%d\\n\", p, errno);\n\n  errno = 0;\n  p = realloc (NULL, (unsigned long) PTRDIFF_MAX + 1);\n  fprintf (stderr, \"p=%p errno=%d\\n\", p, errno);\n\n  return 0;\n}\nm4_divert_pop([KILL])\n          gl_cv_func_malloc_posix=no ;;\n        *)\n          gl_cv_func_malloc_posix=yes ;;\n      esac\n    ])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}