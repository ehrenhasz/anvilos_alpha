{
  "module_name": "threadlib.m4",
  "hash_id": "f6e39780b610269b09d3b7846f6a6de2f7dd7015214e103d7d70f45d0f040f50",
  "original_prompt": "Ingested from coreutils-9.4/m4/threadlib.m4",
  "human_readable_source": "# threadlib.m4 serial 39\ndnl Copyright (C) 2005-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ([2.60])\n\ndnl The general structure of the multithreading modules in gnulib is that we\ndnl have three set of modules:\ndnl\ndnl   * POSIX API:\ndnl     pthread, which combines\ndnl       pthread-h\ndnl       pthread-thread\ndnl       pthread-once\ndnl       pthread-mutex\ndnl       pthread-rwlock\ndnl       pthread-cond\ndnl       pthread-tss\ndnl       pthread-spin\ndnl     sched_yield\ndnl\ndnl   * ISO C API:\ndnl     threads, which combines\ndnl       threads-h\ndnl       thrd\ndnl       mtx\ndnl       cnd\ndnl       tss\ndnl\ndnl   * Gnulib API, with an implementation that can be chosen at configure\ndnl     time through the option --enable-threads=...\ndnl       thread\ndnl       lock\ndnl       cond\ndnl       tls\ndnl       yield\ndnl\ndnl They are independent, except for the fact that\ndnl   - the implementation of the ISO C API may use the POSIX (or some other\ndnl     platform dependent) API,\ndnl   - the implementation of the Gnulib API may use the POSIX or ISO C or\ndnl     some other platform dependent API, depending on the --enable-threads\ndnl     option.\ndnl\ndnl This file contains macros for all of these APIs!\n\ndnl ============================================================================\ndnl Macros for all thread APIs\n\nAC_DEFUN([gl_ANYTHREADLIB_EARLY],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  if test -z \"$gl_anythreadlib_early_done\"; then\n    case \"$host_os\" in\n      osf*)\n        # On OSF/1, the compiler needs the flag -D_REENTRANT so that it\n        # groks <pthread.h>. cc also understands the flag -pthread, but\n        # we don't use it because 1. gcc-2.95 doesn't understand -pthread,\n        # 2. putting a flag into CPPFLAGS that has an effect on the linker\n        # causes the AC_LINK_IFELSE test below to succeed unexpectedly,\n        # leading to wrong values of LIBTHREAD and LTLIBTHREAD.\n        CPPFLAGS=\"$CPPFLAGS -D_REENTRANT\"\n        ;;\n    esac\n    # Some systems optimize for single-threaded programs by default, and\n    # need special flags to disable these optimizations. For example, the\n    # definition of 'errno' in <errno.h>.\n    case \"$host_os\" in\n      aix* | freebsd*) CPPFLAGS=\"$CPPFLAGS -D_THREAD_SAFE\" ;;\n      solaris*) CPPFLAGS=\"$CPPFLAGS -D_REENTRANT\" ;;\n    esac\n    gl_anythreadlib_early_done=done\n  fi\n])\n\ndnl Checks whether the compiler and linker support weak declarations of symbols.\n\nAC_DEFUN([gl_WEAK_SYMBOLS],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CACHE_CHECK([whether imported symbols can be declared weak],\n    [gl_cv_have_weak],\n    [case \"$host_os\" in\n       cygwin* | mingw* | windows*)\n         dnl On Cygwin 3.2.0 with gcc 10.2, and likewise on mingw 10.0.0 with\n         dnl gcc 11.3, the test below would succeed, but programs that use\n         dnl pthread_in_use() with weak symbol references crash miserably at\n         dnl runtime.\n         gl_cv_have_weak=\"guessing no\"\n         ;;\n       *)\n         gl_cv_have_weak=no\n         dnl First, test whether the compiler accepts it syntactically.\n         AC_LINK_IFELSE(\n           [AC_LANG_PROGRAM(\n              [[extern void xyzzy ();\n#pragma weak xyzzy]],\n              [[xyzzy();]])],\n           [gl_cv_have_weak=maybe])\n         if test $gl_cv_have_weak = maybe; then\n           dnl Second, test whether it actually works. On Cygwin 1.7.2, with\n           dnl gcc 4.3, symbols declared weak always evaluate to the address 0.\n           AC_RUN_IFELSE(\n             [AC_LANG_SOURCE([[\n#include <stdio.h>\n#pragma weak fputs\nint main ()\n{\n  return (fputs == NULL);\n}]])],\n             [gl_cv_have_weak=yes],\n             [gl_cv_have_weak=no],\n             [dnl When cross-compiling, assume that only ELF platforms support\n              dnl weak symbols.\n              AC_EGREP_CPP([Extensible Linking Format],\n                [#ifdef __ELF__\n                 Extensible Linking Format\n                 #endif\n                ],\n                [gl_cv_have_weak=\"guessing yes\"],\n                [gl_cv_have_weak=\"guessing no\"])\n             ])\n         fi\n         ;;\n     esac\n     dnl But when linking statically, weak symbols don't work.\n     case \" $LDFLAGS \" in\n       *\" -static \"*) gl_cv_have_weak=no ;;\n     esac\n     dnl Test for a bug in FreeBSD 11: A link error occurs when using a weak\n     dnl symbol and linking against a shared library that has a dependency on\n     dnl the shared library that defines the symbol.\n     case \"$gl_cv_have_weak\" in\n       *yes)\n         case \"$host_os\" in\n           freebsd* | dragonfly* | midnightbsd*)\n             : > conftest1.c\n             $CC $CPPFLAGS $CFLAGS $LDFLAGS -fPIC -shared -o libempty.so conftest1.c -lpthread >&AS_MESSAGE_LOG_FD 2>&1\n             cat <<EOF > conftest2.c\n#include <pthread.h>\n#pragma weak pthread_mutexattr_gettype\nint main ()\n{\n  return (pthread_mutexattr_gettype != NULL);\n}\nEOF\n             $CC $CPPFLAGS $CFLAGS $LDFLAGS -o conftest conftest2.c libempty.so >&AS_MESSAGE_LOG_FD 2>&1 \\\n               || gl_cv_have_weak=no\n             rm -f conftest1.c libempty.so conftest2.c conftest\n             ;;\n         esac\n         ;;\n     esac\n    ])\n  case \"$gl_cv_have_weak\" in\n    *yes)\n      AC_DEFINE([HAVE_WEAK_SYMBOLS], [1],\n        [Define to 1 if the compiler and linker support weak declarations of symbols.])\n      ;;\n  esac\n])\n\ndnl ============================================================================\ndnl Macros for the POSIX API\n\ndnl gl_PTHREADLIB\ndnl -------------\ndnl Tests for the libraries needs for using the POSIX threads API.\ndnl Sets the variable LIBPTHREAD to the linker options for use in a Makefile.\ndnl Sets the variable LIBPMULTITHREAD, for programs that really need\ndnl multithread functionality. The difference between LIBPTHREAD and\ndnl LIBPMULTITHREAD is that on platforms supporting weak symbols, typically\ndnl LIBPTHREAD is empty whereas LIBPMULTITHREAD is not.\ndnl Sets the variable SCHED_YIELD_LIB to the linker options needed to use the\ndnl sched_yield() function.\ndnl Adds to CPPFLAGS the flag -D_REENTRANT or -D_THREAD_SAFE if needed for\ndnl multithread-safe programs.\ndnl Defines the C macro HAVE_PTHREAD_API if (at least parts of) the POSIX\ndnl threads API is available.\n\ndnl The guts of gl_PTHREADLIB. Needs to be expanded only once.\n\nAC_DEFUN([gl_PTHREADLIB_BODY],\n[\n  AC_REQUIRE([gl_ANYTHREADLIB_EARLY])\n  if test -z \"$gl_pthreadlib_body_done\"; then\n    gl_pthread_api=no\n    LIBPTHREAD=\n    LIBPMULTITHREAD=\n    # On OSF/1, the compiler needs the flag -pthread or -D_REENTRANT so that\n    # it groks <pthread.h>. It's added above, in gl_ANYTHREADLIB_EARLY.\n    AC_CHECK_HEADER([pthread.h],\n      [gl_have_pthread_h=yes], [gl_have_pthread_h=no])\n    if test \"$gl_have_pthread_h\" = yes; then\n      # Other possible tests:\n      #   -lpthreads (FSU threads, PCthreads)\n      #   -lgthreads\n      # Test whether both pthread_mutex_lock and pthread_mutexattr_init exist\n      # in libc. IRIX 6.5 has the first one in both libc and libpthread, but\n      # the second one only in libpthread, and lock.c needs it.\n      #\n      # If -pthread works, prefer it to -lpthread, since Ubuntu 14.04\n      # needs -pthread for some reason.  See:\n      # https://lists.gnu.org/r/bug-gnulib/2014-09/msg00023.html\n      save_LIBS=$LIBS\n      for gl_pthread in '' '-pthread'; do\n        LIBS=\"$LIBS $gl_pthread\"\n        AC_LINK_IFELSE(\n          [AC_LANG_PROGRAM(\n             [[#include <pthread.h>\n               pthread_mutex_t m;\n               pthread_mutexattr_t ma;\n             ]],\n             [[pthread_mutex_lock (&m);\n               pthread_mutexattr_init (&ma);]])],\n          [gl_pthread_api=yes\n           LIBPTHREAD=$gl_pthread\n           LIBPMULTITHREAD=$gl_pthread])\n        LIBS=$save_LIBS\n        test $gl_pthread_api = yes && break\n      done\n      echo \"$as_me:__oline__: gl_pthread_api=$gl_pthread_api\" >&AS_MESSAGE_LOG_FD\n      echo \"$as_me:__oline__: LIBPTHREAD=$LIBPTHREAD\" >&AS_MESSAGE_LOG_FD\n\n      gl_pthread_in_glibc=no\n      # On Linux with glibc >= 2.34, libc contains the fully functional\n      # pthread functions.\n      case \"$host_os\" in\n        linux*)\n          AC_EGREP_CPP([Lucky user],\n            [#include <features.h>\n             #ifdef __GNU_LIBRARY__\n              #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 34) || (__GLIBC__ > 2)\n               Lucky user\n              #endif\n             #endif\n            ],\n            [gl_pthread_in_glibc=yes],\n            [])\n          ;;\n      esac\n      echo \"$as_me:__oline__: gl_pthread_in_glibc=$gl_pthread_in_glibc\" >&AS_MESSAGE_LOG_FD\n\n      # Test for libpthread by looking for pthread_kill. (Not pthread_self,\n      # since it is defined as a macro on OSF/1.)\n      if test $gl_pthread_api = yes && test -z \"$LIBPTHREAD\"; then\n        # The program links fine without libpthread. But it may actually\n        # need to link with libpthread in order to create multiple threads.\n        AC_CHECK_LIB([pthread], [pthread_kill],\n          [if test $gl_pthread_in_glibc = yes; then\n             LIBPMULTITHREAD=\n           else\n             LIBPMULTITHREAD=-lpthread\n             # On Solaris and HP-UX, most pthread functions exist also in libc.\n             # Therefore pthread_in_use() needs to actually try to create a\n             # thread: pthread_create from libc will fail, whereas\n             # pthread_create will actually create a thread.\n             # On Solaris 10 or newer, this test is no longer needed, because\n             # libc contains the fully functional pthread functions.\n             case \"$host_os\" in\nchangequote(,)dnl\n               solaris | solaris2.[1-9] | solaris2.[1-9].* | hpux*)\nchangequote([,])dnl\n                 AC_DEFINE([PTHREAD_IN_USE_DETECTION_HARD], [1],\n                   [Define if the pthread_in_use() detection is hard.])\n             esac\n           fi\n          ])\n      elif test $gl_pthread_api != yes; then\n        # Some library is needed. Try libpthread and libc_r.\n        AC_CHECK_LIB([pthread], [pthread_kill],\n          [gl_pthread_api=yes\n           LIBPTHREAD=-lpthread\n           LIBPMULTITHREAD=-lpthread])\n        if test $gl_pthread_api != yes; then\n          # For FreeBSD 4.\n          AC_CHECK_LIB([c_r], [pthread_kill],\n            [gl_pthread_api=yes\n             LIBPTHREAD=-lc_r\n             LIBPMULTITHREAD=-lc_r])\n        fi\n      fi\n      echo \"$as_me:__oline__: LIBPMULTITHREAD=$LIBPMULTITHREAD\" >&AS_MESSAGE_LOG_FD\n    fi\n    AC_MSG_CHECKING([whether POSIX threads API is available])\n    AC_MSG_RESULT([$gl_pthread_api])\n    AC_SUBST([LIBPTHREAD])\n    AC_SUBST([LIBPMULTITHREAD])\n    if test $gl_pthread_api = yes; then\n      AC_DEFINE([HAVE_PTHREAD_API], [1],\n        [Define if you have the <pthread.h> header and the POSIX threads API.])\n    fi\n\n    dnl On some systems, sched_yield is in librt, rather than in libpthread.\n    AC_LINK_IFELSE(\n      [AC_LANG_PROGRAM(\n         [[#include <sched.h>]],\n         [[sched_yield ();]])],\n      [SCHED_YIELD_LIB=\n      ],\n      [dnl Solaris 7...10 has sched_yield in librt, not in libpthread or libc.\n       AC_CHECK_LIB([rt], [sched_yield], [SCHED_YIELD_LIB=-lrt],\n         [dnl Solaris 2.5.1, 2.6 has sched_yield in libposix4, not librt.\n          AC_CHECK_LIB([posix4], [sched_yield], [SCHED_YIELD_LIB=-lposix4])])\n      ])\n    AC_SUBST([SCHED_YIELD_LIB])\n    dnl For backward compatibility.\n    LIB_SCHED_YIELD=\"$SCHED_YIELD_LIB\"\n    AC_SUBST([LIB_SCHED_YIELD])\n\n    gl_pthreadlib_body_done=done\n  fi\n])\n\nAC_DEFUN([gl_PTHREADLIB],\n[\n  AC_REQUIRE([gl_ANYTHREADLIB_EARLY])\n  gl_PTHREADLIB_BODY\n])\n\ndnl ============================================================================\ndnl Macros for the ISO C API\n\ndnl gl_STDTHREADLIB\ndnl ---------------\ndnl Tests for the libraries needs for using the ISO C threads API.\ndnl Sets the variable LIBSTDTHREAD to the linker options for use in a Makefile.\ndnl Adds to CPPFLAGS the flag -D_REENTRANT or -D_THREAD_SAFE if needed for\ndnl multithread-safe programs.\ndnl Defines the C macro HAVE_THREADS_H if (at least parts of) the ISO C threads\ndnl API is available.\n\ndnl The guts of gl_STDTHREADLIB. Needs to be expanded only once.\n\nAC_DEFUN([gl_STDTHREADLIB_BODY],\n[\n  AC_REQUIRE([gl_ANYTHREADLIB_EARLY])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  if test -z \"$gl_stdthreadlib_body_done\"; then\n    AC_CHECK_HEADERS_ONCE([threads.h])\n\n    case \"$host_os\" in\n      mingw* | windows*)\n        LIBSTDTHREAD=\n        ;;\n      *)\n        gl_PTHREADLIB_BODY\n        if test $ac_cv_header_threads_h = yes; then\n          dnl glibc >= 2.29 has thrd_create in libpthread.\n          dnl FreeBSD >= 10 has thrd_create in libstdthreads; this library depends\n          dnl on libpthread (for the symbol 'pthread_mutexattr_gettype').\n          dnl glibc >= 2.34, AIX >= 7.1, and Solaris >= 11.4 have thrd_create in\n          dnl libc.\n          gl_CHECK_FUNCS_ANDROID([thrd_create], [[#include <threads.h>]])\n          if test $ac_cv_func_thrd_create = yes; then\n            LIBSTDTHREAD=\n          else\n            AC_CHECK_LIB([stdthreads], [thrd_create], [\n              LIBSTDTHREAD='-lstdthreads -lpthread'\n            ], [\n              dnl Guess that thrd_create is in libpthread.\n              LIBSTDTHREAD=\"$LIBPMULTITHREAD\"\n            ])\n          fi\n        else\n          dnl Libraries needed by thrd.c, mtx.c, cnd.c, tss.c.\n          LIBSTDTHREAD=\"$LIBPMULTITHREAD $SCHED_YIELD_LIB\"\n        fi\n        ;;\n    esac\n    AC_SUBST([LIBSTDTHREAD])\n\n    AC_MSG_CHECKING([whether ISO C threads API is available])\n    AC_MSG_RESULT([$ac_cv_header_threads_h])\n    gl_stdthreadlib_body_done=done\n  fi\n])\n\nAC_DEFUN([gl_STDTHREADLIB],\n[\n  AC_REQUIRE([gl_ANYTHREADLIB_EARLY])\n  gl_STDTHREADLIB_BODY\n])\n\ndnl ============================================================================\ndnl Macros for the Gnulib API\n\ndnl gl_THREADLIB\ndnl ------------\ndnl Tests for a multithreading library to be used.\ndnl If the configure.ac contains a definition of the gl_THREADLIB_DEFAULT_NO\ndnl (it must be placed before the invocation of gl_THREADLIB_EARLY!), then the\ndnl default is 'no', otherwise it is system dependent. In both cases, the user\ndnl can change the choice through the options --enable-threads=choice or\ndnl --disable-threads.\ndnl Defines at most one of the macros USE_ISOC_THREADS, USE_POSIX_THREADS,\ndnl USE_ISOC_AND_POSIX_THREADS, USE_WINDOWS_THREADS.\ndnl The choice --enable-threads=isoc+posix is available only on platforms that\ndnl have both the ISO C and the POSIX threads APIs. It has the effect of using\ndnl the ISO C API for most things and the POSIX API only for creating and\ndnl controlling threads (because there is no equivalent to pthread_atfork in\ndnl the ISO C API).\ndnl Sets the variables LIBTHREAD and LTLIBTHREAD to the linker options for use\ndnl in a Makefile (LIBTHREAD for use without libtool, LTLIBTHREAD for use with\ndnl libtool).\ndnl Sets the variables LIBMULTITHREAD and LTLIBMULTITHREAD similarly, for\ndnl programs that really need multithread functionality. The difference\ndnl between LIBTHREAD and LIBMULTITHREAD is that on platforms supporting weak\ndnl symbols, typically LIBTHREAD is empty whereas LIBMULTITHREAD is not.\ndnl Adds to CPPFLAGS the flag -D_REENTRANT or -D_THREAD_SAFE if needed for\ndnl multithread-safe programs.\ndnl Since support for GNU pth was removed, $LTLIBTHREAD and $LIBTHREAD have the\ndnl same value, and similarly $LTLIBMULTITHREAD and $LIBMULTITHREAD have the\ndnl same value. Only system libraries are needed.\n\nAC_DEFUN([gl_THREADLIB_EARLY],\n[\n  AC_REQUIRE([gl_THREADLIB_EARLY_BODY])\n])\n\ndnl The guts of gl_THREADLIB_EARLY. Needs to be expanded only once.\n\nAC_DEFUN([gl_THREADLIB_EARLY_BODY],\n[\n  dnl Ordering constraints: This macro modifies CPPFLAGS in a way that\n  dnl influences the result of the autoconf tests that test for *_unlocked\n  dnl declarations, on AIX 5 at least. Therefore it must come early.\n  AC_BEFORE([$0], [gl_FUNC_GLIBC_UNLOCKED_IO])dnl\n  AC_BEFORE([$0], [gl_ARGP])dnl\n\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  dnl _GNU_SOURCE is needed for pthread_rwlock_t on glibc systems.\n  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n  dnl Check for multithreading.\n  m4_ifdef([gl_THREADLIB_DEFAULT_NO],\n    [m4_divert_text([DEFAULTS], [gl_use_threads_default=no])],\n    [m4_divert_text([DEFAULTS], [gl_use_threads_default=])])\n  dnl gl_use_winpthreads_default defaults to 'no', because in mingw 10, like\n  dnl in mingw 5, the use of libwinpthread still makes test-pthread-tss crash.\n  m4_divert_text([DEFAULTS], [gl_use_winpthreads_default=no])\n  AC_ARG_ENABLE([threads],\nAS_HELP_STRING([[--enable-threads={isoc|posix|isoc+posix|windows}]], [specify multithreading API])m4_ifdef([gl_THREADLIB_DEFAULT_NO], [], [\nAS_HELP_STRING([[--disable-threads]], [build without multithread safety])]),\n    [gl_use_threads=$enableval],\n    [if test -n \"$gl_use_threads_default\"; then\n       gl_use_threads=\"$gl_use_threads_default\"\n     else\nchangequote(,)dnl\n       case \"$host_os\" in\n         dnl Disable multithreading by default on OSF/1, because it interferes\n         dnl with fork()/exec(): When msgexec is linked with -lpthread, its\n         dnl child process gets an endless segmentation fault inside execvp().\n         osf*) gl_use_threads=no ;;\n         dnl Disable multithreading by default on Cygwin 1.5.x, because it has\n         dnl bugs that lead to endless loops or crashes. See\n         dnl <https://cygwin.com/ml/cygwin/2009-08/msg00283.html>.\n         cygwin*)\n               case `uname -r` in\n                 1.[0-5].*) gl_use_threads=no ;;\n                 *)         gl_use_threads=yes ;;\n               esac\n               ;;\n         dnl Obey gl_AVOID_WINPTHREAD on mingw.\n         mingw* | windows*)\n               case \"$gl_use_winpthreads_default\" in\n                 yes) gl_use_threads=posix ;;\n                 no)  gl_use_threads=windows ;;\n                 *)   gl_use_threads=yes ;;\n               esac\n               ;;\n         *)    gl_use_threads=yes ;;\n       esac\nchangequote([,])dnl\n     fi\n    ])\n  if test \"$gl_use_threads\" = yes \\\n     || test \"$gl_use_threads\" = isoc \\\n     || test \"$gl_use_threads\" = posix \\\n     || test \"$gl_use_threads\" = isoc+posix; then\n    # For using <threads.h> or <pthread.h>:\n    gl_ANYTHREADLIB_EARLY\n  fi\n])\n\ndnl The guts of gl_THREADLIB. Needs to be expanded only once.\n\nAC_DEFUN([gl_THREADLIB_BODY],\n[\n  AC_REQUIRE([gl_THREADLIB_EARLY_BODY])\n  gl_threads_api=none\n  LIBTHREAD=\n  LTLIBTHREAD=\n  LIBMULTITHREAD=\n  LTLIBMULTITHREAD=\n  if test \"$gl_use_threads\" != no; then\n    dnl Check whether the compiler and linker support weak declarations.\n    gl_WEAK_SYMBOLS\n    if case \"$gl_cv_have_weak\" in *yes) true;; *) false;; esac; then\n      dnl If we use weak symbols to implement pthread_in_use / pth_in_use /\n      dnl thread_in_use, we also need to test whether the ISO C 11 thrd_create\n      dnl facility is in use.\n      AC_CHECK_HEADERS_ONCE([threads.h])\n      :\n    fi\n    if test \"$gl_use_threads\" = isoc || test \"$gl_use_threads\" = isoc+posix; then\n      AC_CHECK_HEADERS_ONCE([threads.h])\n      gl_have_isoc_threads=\"$ac_cv_header_threads_h\"\n    fi\n    if test \"$gl_use_threads\" = yes \\\n       || test \"$gl_use_threads\" = posix \\\n       || test \"$gl_use_threads\" = isoc+posix; then\n      gl_PTHREADLIB_BODY\n      LIBTHREAD=$LIBPTHREAD LTLIBTHREAD=$LIBPTHREAD\n      LIBMULTITHREAD=$LIBPMULTITHREAD LTLIBMULTITHREAD=$LIBPMULTITHREAD\n      if test $gl_pthread_api = yes; then\n        if test \"$gl_use_threads\" = isoc+posix && test \"$gl_have_isoc_threads\" = yes; then\n          gl_threads_api='isoc+posix'\n          AC_DEFINE([USE_ISOC_AND_POSIX_THREADS], [1],\n            [Define if the combination of the ISO C and POSIX multithreading APIs can be used.])\n          LIBTHREAD= LTLIBTHREAD=\n        else\n          gl_threads_api=posix\n          AC_DEFINE([USE_POSIX_THREADS], [1],\n            [Define if the POSIX multithreading library can be used.])\n          if test -z \"$LIBMULTITHREAD\" && test -z \"$LTLIBMULTITHREAD\"; then\n            AC_DEFINE([USE_POSIX_THREADS_FROM_LIBC], [1],\n              [Define if references to the POSIX multithreading library are satisfied by libc.])\n          else\n            if case \"$gl_cv_have_weak\" in *yes) true;; *) false;; esac; then\n              AC_DEFINE([USE_POSIX_THREADS_WEAK], [1],\n                [Define if references to the POSIX multithreading library should be made weak.])\n              LIBTHREAD= LTLIBTHREAD=\n            else\n              case \"$host_os\" in\n                freebsd* | dragonfly* | midnightbsd*)\n                  if test \"x$LIBTHREAD\" != \"x$LIBMULTITHREAD\"; then\n                    dnl If weak symbols can't tell whether pthread_create(), pthread_key_create()\n                    dnl etc. will succeed, we need a runtime test.\n                    AC_DEFINE([PTHREAD_IN_USE_DETECTION_HARD], [1],\n                      [Define if the pthread_in_use() detection is hard.])\n                  fi\n                  ;;\n              esac\n            fi\n          fi\n        fi\n      fi\n    fi\n    if test $gl_threads_api = none; then\n      if test \"$gl_use_threads\" = isoc && test \"$gl_have_isoc_threads\" = yes; then\n        gl_STDTHREADLIB_BODY\n        LIBTHREAD=$LIBSTDTHREAD LTLIBTHREAD=$LIBSTDTHREAD\n        LIBMULTITHREAD=$LIBSTDTHREAD LTLIBMULTITHREAD=$LIBSTDTHREAD\n        gl_threads_api=isoc\n        AC_DEFINE([USE_ISOC_THREADS], [1],\n          [Define if the ISO C multithreading library can be used.])\n      fi\n    fi\n    if test $gl_threads_api = none; then\n      case \"$gl_use_threads\" in\n        yes | windows | win32) # The 'win32' is for backward compatibility.\n          if { case \"$host_os\" in\n                 mingw* | windows*) true;;\n                 *) false;;\n               esac\n             }; then\n            gl_threads_api=windows\n            AC_DEFINE([USE_WINDOWS_THREADS], [1],\n              [Define if the native Windows multithreading API can be used.])\n          fi\n          ;;\n      esac\n    fi\n  fi\n  AC_MSG_CHECKING([for multithread API to use])\n  AC_MSG_RESULT([$gl_threads_api])\n  AC_SUBST([LIBTHREAD])\n  AC_SUBST([LTLIBTHREAD])\n  AC_SUBST([LIBMULTITHREAD])\n  AC_SUBST([LTLIBMULTITHREAD])\n])\n\nAC_DEFUN([gl_THREADLIB],\n[\n  AC_REQUIRE([gl_THREADLIB_EARLY])\n  AC_REQUIRE([gl_THREADLIB_BODY])\n])\n\n\ndnl gl_DISABLE_THREADS\ndnl ------------------\ndnl Sets the gl_THREADLIB default so that threads are not used by default.\ndnl The user can still override it at installation time, by using the\ndnl configure option '--enable-threads'.\n\nAC_DEFUN([gl_DISABLE_THREADS], [\n  m4_divert_text([INIT_PREPARE], [gl_use_threads_default=no])\n])\n\n\ndnl gl_AVOID_WINPTHREAD\ndnl -------------------\ndnl Sets the gl_THREADLIB default so that on mingw, a dependency to the\ndnl libwinpthread DLL (mingw-w64 winpthreads library) is avoided.\ndnl The user can still override it at installation time, by using the\ndnl configure option '--enable-threads=posix'.\ndnl As of 2023, this is now the default.\n\nAC_DEFUN([gl_AVOID_WINPTHREAD], [\n  m4_divert_text([INIT_PREPARE], [gl_use_winpthreads_default=no])\n])\n\n\ndnl ============================================================================\n\n\ndnl Survey of platforms:\ndnl\ndnl Platform           Available  Compiler    Supports   test-lock\ndnl                    flavours   option      weak       result\ndnl ---------------    ---------  ---------   --------   ---------\ndnl Linux 2.4/glibc    posix      -lpthread       Y      OK\ndnl\ndnl Linux/glibc 2.34   posix                      Y      OK\ndnl\ndnl GNU Hurd/glibc     posix      -lpthread       Y      OK\ndnl\ndnl Ubuntu 14.04       posix      -pthread        Y      OK\ndnl\ndnl FreeBSD 5.3        posix      -lc_r           Y\ndnl                    posix      -lkse ?         Y\ndnl                    posix      -lpthread ?     Y\ndnl                    posix      -lthr           Y\ndnl\ndnl FreeBSD 5.2        posix      -lc_r           Y\ndnl                    posix      -lkse           Y\ndnl                    posix      -lthr           Y\ndnl\ndnl FreeBSD 4.0,4.10   posix      -lc_r           Y      OK\ndnl\ndnl NetBSD 1.6         --\ndnl\ndnl OpenBSD 3.4        posix      -lpthread       Y      OK\ndnl\ndnl Mac OS X 10.[123]  posix      -lpthread       Y      OK\ndnl\ndnl Solaris 7,8,9      posix      -lpthread       Y      Sol 7,8: 0.0; Sol 9: OK\ndnl\ndnl HP-UX 11           posix      -lpthread       N (cc) OK\ndnl                                               Y (gcc)\ndnl\ndnl IRIX 6.5           posix      -lpthread       Y      0.5\ndnl\ndnl AIX 4.3,5.1        posix      -lpthread       N      AIX 4: 0.5; AIX 5: OK\ndnl\ndnl OSF/1 4.0,5.1      posix      -pthread (cc)   N      OK\ndnl                               -lpthread (gcc) Y\ndnl\ndnl Cygwin             posix      -lpthread       Y      OK\ndnl\ndnl Mingw              windows                    N      OK\ndnl\ndnl BeOS 5             --\ndnl\ndnl The test-lock result shows what happens if in test-lock.c EXPLICIT_YIELD is\ndnl turned off:\ndnl   OK if all three tests terminate OK,\ndnl   0.5 if the first test terminates OK but the second one loops endlessly,\ndnl   0.0 if the first test already loops endlessly.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}