{
  "module_name": "exponentf.m4",
  "hash_id": "b9425a8794a18d5f8793cfad66de1fd738f3838d333010eb4cae96ffe39a00f6",
  "original_prompt": "Ingested from coreutils-9.4/m4/exponentf.m4",
  "human_readable_source": "# exponentf.m4 serial 3\ndnl Copyright (C) 2007-2008, 2010-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\nAC_DEFUN_ONCE([gl_FLOAT_EXPONENT_LOCATION],\n[\n  AC_CACHE_CHECK([where to find the exponent in a 'float'],\n    [gl_cv_cc_float_expbit0],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <float.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#define NWORDS \\\n  ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\ntypedef union { float value; unsigned int word[NWORDS]; } memory_float;\nstatic unsigned int ored_words[NWORDS];\nstatic unsigned int anded_words[NWORDS];\nstatic void add_to_ored_words (float x)\n{\n  memory_float m;\n  size_t i;\n  /* Clear it first, in case\n     sizeof (float) < sizeof (memory_float).  */\n  memset (&m, 0, sizeof (memory_float));\n  m.value = x;\n  for (i = 0; i < NWORDS; i++)\n    {\n      ored_words[i] |= m.word[i];\n      anded_words[i] &= m.word[i];\n    }\n}\nint main ()\n{\n  size_t j;\n  FILE *fp = fopen (\"conftest.out\", \"w\");\n  if (fp == NULL)\n    return 1;\n  for (j = 0; j < NWORDS; j++)\n    anded_words[j] = ~ (unsigned int) 0;\n  add_to_ored_words (0.25f);\n  add_to_ored_words (0.5f);\n  add_to_ored_words (1.0f);\n  add_to_ored_words (2.0f);\n  add_to_ored_words (4.0f);\n  /* Remove bits that are common (e.g. if representation of the first mantissa\n     bit is explicit).  */\n  for (j = 0; j < NWORDS; j++)\n    ored_words[j] &= ~anded_words[j];\n  /* Now find the nonzero word.  */\n  for (j = 0; j < NWORDS; j++)\n    if (ored_words[j] != 0)\n      break;\n  if (j < NWORDS)\n    {\n      size_t i;\n      for (i = j + 1; i < NWORDS; i++)\n        if (ored_words[i] != 0)\n          {\n            fprintf (fp, \"unknown\");\n            return (fclose (fp) != 0);\n          }\n      for (i = 0; ; i++)\n        if ((ored_words[j] >> i) & 1)\n          {\n            fprintf (fp, \"word %d bit %d\", (int) j, (int) i);\n            return (fclose (fp) != 0);\n          }\n    }\n  fprintf (fp, \"unknown\");\n  return (fclose (fp) != 0);\n}\n        ]])],\n        [gl_cv_cc_float_expbit0=`cat conftest.out`],\n        [gl_cv_cc_float_expbit0=\"unknown\"],\n        [gl_cv_cc_float_expbit0=\"word 0 bit 23\"])\n      rm -f conftest.out\n    ])\n  case \"$gl_cv_cc_float_expbit0\" in\n    word*bit*)\n      word=`echo \"$gl_cv_cc_float_expbit0\" | sed -e 's/word //' -e 's/ bit.*//'`\n      bit=`echo \"$gl_cv_cc_float_expbit0\" | sed -e 's/word.*bit //'`\n      AC_DEFINE_UNQUOTED([FLT_EXPBIT0_WORD], [$word],\n        [Define as the word index where to find the exponent of 'float'.])\n      AC_DEFINE_UNQUOTED([FLT_EXPBIT0_BIT], [$bit],\n        [Define as the bit index in the word where to find bit 0 of the exponent of 'float'.])\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}