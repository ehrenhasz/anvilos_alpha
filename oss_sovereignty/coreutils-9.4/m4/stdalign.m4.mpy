{
  "module_name": "stdalign.m4",
  "hash_id": "dfa7ce67a9df03dcf0c1a97ccadbcfa16fe9c74480e7a9e13e5b8ecfa983c9f4",
  "original_prompt": "Ingested from coreutils-9.4/m4/stdalign.m4",
  "human_readable_source": "# Check for alignas and alignof that conform to C23.\n\ndnl Copyright 2011-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl Written by Paul Eggert and Bruno Haible.\n\n# Prepare for substituting <stdalign.h> if it is not supported.\n\nAC_DEFUN([gl_ALIGNASOF],\n[\n  AC_CACHE_CHECK([for alignas and alignof],\n    [gl_cv_header_working_stdalign_h],\n    [gl_save_CFLAGS=$CFLAGS\n     for gl_working in \"yes, keywords\" \"yes, <stdalign.h> macros\"; do\n      AS_CASE([$gl_working],\n        [*stdalign.h*], [CFLAGS=\"$gl_save_CFLAGS -DINCLUDE_STDALIGN_H\"])\n      AC_COMPILE_IFELSE(\n       [AC_LANG_PROGRAM(\n          [[#include <stdint.h>\n            #ifdef INCLUDE_STDALIGN_H\n             #include <stdalign.h>\n            #endif\n            #include <stddef.h>\n\n            /* Test that alignof yields a result consistent with offsetof.\n               This catches GCC bug 52023\n               <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52023>.  */\n            #ifdef __cplusplus\n               template <class t> struct alignof_helper { char a; t b; };\n            # define ao(type) offsetof (alignof_helper<type>, b)\n            #else\n            # define ao(type) offsetof (struct { char a; type b; }, b)\n            #endif\n            char test_double[ao (double) % _Alignof (double) == 0 ? 1 : -1];\n            char test_long[ao (long int) % _Alignof (long int) == 0 ? 1 : -1];\n            char test_alignof[alignof (double) == _Alignof (double) ? 1 : -1];\n\n            /* Test alignas only on platforms where gnulib can help.  */\n            #if \\\n                ((defined __cplusplus && 201103 <= __cplusplus) \\\n                 || (__TINYC__ && defined __attribute__) \\\n                 || (defined __APPLE__ && defined __MACH__ \\\n                     ? 4 < __GNUC__ + (1 <= __GNUC_MINOR__) \\\n                     : __GNUC__) \\\n                 || (__ia64 && (61200 <= __HP_cc || 61200 <= __HP_aCC)) \\\n                 || __ICC || 0x590 <= __SUNPRO_C || 0x0600 <= __xlC__ \\\n                 || 1300 <= _MSC_VER)\n              struct alignas_test { char c; char alignas (8) alignas_8; };\n              char test_alignas[offsetof (struct alignas_test, alignas_8) == 8\n                                ? 1 : -1];\n            #endif\n          ]])],\n       [gl_cv_header_working_stdalign_h=$gl_working],\n       [gl_cv_header_working_stdalign_h=no])\n\n      CFLAGS=$gl_save_CFLAGS\n      test \"$gl_cv_header_working_stdalign_h\" != no && break\n     done])\n\n  AS_CASE([$gl_cv_header_working_stdalign_h],\n    [yes*keyword*],\n      [AC_DEFINE([HAVE_C_ALIGNASOF], [1],\n         [Define to 1 if the alignas and alignof keywords work.])])\n\n  dnl The \"zz\" puts this toward config.h's end, to avoid potential\n  dnl collisions with other definitions.\n  AH_VERBATIM([zzalignas],\n[#if !defined HAVE_C_ALIGNASOF \\\n    && !(defined __cplusplus && 201103 <= __cplusplus) \\\n    && !defined alignof\n# if defined HAVE_STDALIGN_H\n#  include <stdalign.h>\n# endif\n\n/* ISO C23 alignas and alignof for platforms that lack it.\n\n   References:\n   ISO C23 (latest free draft\n   <http://www.open-std.org/jtc1/sc22/wg14/www/docs/n3047.pdf>)\n   sections 6.5.3.4, 6.7.5, 7.15.\n   C++11 (latest free draft\n   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf>)\n   section 18.10. */\n\n/* alignof (TYPE), also known as _Alignof (TYPE), yields the alignment\n   requirement of a structure member (i.e., slot or field) that is of\n   type TYPE, as an integer constant expression.\n\n   This differs from GCC's and clang's __alignof__ operator, which can\n   yield a better-performing alignment for an object of that type.  For\n   example, on x86 with GCC and on Linux/x86 with clang,\n   __alignof__ (double) and __alignof__ (long long) are 8, whereas\n   alignof (double) and alignof (long long) are 4 unless the option\n   '-malign-double' is used.\n\n   The result cannot be used as a value for an 'enum' constant, if you\n   want to be portable to HP-UX 10.20 cc and AIX 3.2.5 xlc.  */\n\n/* GCC releases before GCC 4.9 had a bug in _Alignof.  See GCC bug 52023\n   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52023>.\n   clang versions < 8.0.0 have the same bug.  */\n#  if (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112 \\\n       || (defined __GNUC__ && __GNUC__ < 4 + (__GNUC_MINOR__ < 9) \\\n           && !defined __clang__) \\\n       || (defined __clang__ && __clang_major__ < 8))\n#   undef/**/_Alignof\n#   ifdef __cplusplus\n#    if (201103 <= __cplusplus || defined _MSC_VER)\n#     define _Alignof(type) alignof (type)\n#    else\n      template <class __t> struct __alignof_helper { char __a; __t __b; };\n#     if (defined __GNUC__ && 4 <= __GNUC__) || defined __clang__\n#      define _Alignof(type) __builtin_offsetof (__alignof_helper<type>, __b)\n#     else\n#      define _Alignof(type) offsetof (__alignof_helper<type>, __b)\n#     endif\n#     define _GL_STDALIGN_NEEDS_STDDEF 1\n#    endif\n#   else\n#    if (defined __GNUC__ && 4 <= __GNUC__) || defined __clang__\n#     define _Alignof(type) __builtin_offsetof (struct { char __a; type __b; }, __b)\n#    else\n#     define _Alignof(type) offsetof (struct { char __a; type __b; }, __b)\n#     define _GL_STDALIGN_NEEDS_STDDEF 1\n#    endif\n#   endif\n#  endif\n#  if ! (defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER))\n#   undef/**/alignof\n#   define alignof _Alignof\n#  endif\n\n/* alignas (A), also known as _Alignas (A), aligns a variable or type\n   to the alignment A, where A is an integer constant expression.  For\n   example:\n\n      int alignas (8) foo;\n      struct s { int a; int alignas (8) bar; };\n\n   aligns the address of FOO and the offset of BAR to be multiples of 8.\n\n   A should be a power of two that is at least the type's alignment\n   and at most the implementation's alignment limit.  This limit is\n   2**28 on typical GNUish hosts, and 2**13 on MSVC.  To be portable\n   to MSVC through at least version 10.0, A should be an integer\n   constant, as MSVC does not support expressions such as 1 << 3.\n   To be portable to Sun C 5.11, do not align auto variables to\n   anything stricter than their default alignment.\n\n   The following C23 requirements are not supported here:\n\n     - If A is zero, alignas has no effect.\n     - alignas can be used multiple times; the strictest one wins.\n     - alignas (TYPE) is equivalent to alignas (alignof (TYPE)).\n\n   */\n# if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112\n#  if defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER)\n#   define _Alignas(a) alignas (a)\n#  elif (!defined __attribute__ \\\n         && ((defined __APPLE__ && defined __MACH__ \\\n              ? 4 < __GNUC__ + (1 <= __GNUC_MINOR__) \\\n              : __GNUC__ && !defined __ibmxl__) \\\n             || (4 <= __clang_major__) \\\n             || (__ia64 && (61200 <= __HP_cc || 61200 <= __HP_aCC)) \\\n             || __ICC || 0x590 <= __SUNPRO_C || 0x0600 <= __xlC__))\n#   define _Alignas(a) __attribute__ ((__aligned__ (a)))\n#  elif 1300 <= _MSC_VER\n#   define _Alignas(a) __declspec (align (a))\n#  endif\n# endif\n# if !defined HAVE_STDALIGN_H\n#  if ((defined _Alignas \\\n        && !(defined __cplusplus \\\n             && (201103 <= __cplusplus || defined _MSC_VER))) \\\n       || (defined __STDC_VERSION__ && 201112 <= __STDC_VERSION__))\n#   define alignas _Alignas\n#  endif\n# endif\n\n# if defined _GL_STDALIGN_NEEDS_STDDEF\n#  include <stddef.h>\n# endif\n#endif])\n])\n\nAC_DEFUN([gl_STDALIGN_H],\n[\n  AC_REQUIRE([gl_ALIGNASOF])\n  if test \"$gl_cv_header_working_stdalign_h\" = no; then\n    GL_GENERATE_STDALIGN_H=true\n  else\n    GL_GENERATE_STDALIGN_H=false\n  fi\n\n  gl_CHECK_NEXT_HEADERS([stdalign.h])\n  if test $ac_cv_header_stdalign_h = yes; then\n    HAVE_STDALIGN_H=1\n  else\n    HAVE_STDALIGN_H=0\n  fi\n  AC_SUBST([HAVE_STDALIGN_H])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}