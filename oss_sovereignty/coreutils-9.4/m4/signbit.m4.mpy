{
  "module_name": "signbit.m4",
  "hash_id": "2360cfa04cb3cb7c3dac1c9b060f0beb16ef42870d6fc60aec77414b0c610162",
  "original_prompt": "Ingested from coreutils-9.4/m4/signbit.m4",
  "human_readable_source": "# signbit.m4 serial 22\ndnl Copyright (C) 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_SIGNBIT],\n[\n  AC_REQUIRE([gl_MATH_H_DEFAULTS])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_CACHE_CHECK([for signbit macro], [gl_cv_func_signbit],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <math.h>\n/* If signbit is defined as a function, don't use it, since calling it for\n   'float' or 'long double' arguments would involve conversions.\n   If signbit is not declared at all but exists as a library function, don't\n   use it, since the prototype may not match.\n   If signbit is not declared at all but exists as a compiler built-in, don't\n   use it, since it's preferable to use __builtin_signbit* (no warnings,\n   no conversions).  */\n#ifndef signbit\n# error \"signbit should be a macro\"\n#endif\n#include <string.h>\n]gl_SIGNBIT_TEST_PROGRAM\n])],\n        [gl_cv_func_signbit=yes],\n        [gl_cv_func_signbit=no],\n        [case \"$host_os\" in\n                               # Guess yes on glibc systems.\n           *-gnu* | gnu*)      gl_cv_func_signbit=\"guessing yes\" ;;\n                               # Guess yes on musl systems.\n           *-musl* | midipix*) gl_cv_func_signbit=\"guessing yes\" ;;\n                               # Guess yes on native Windows.\n           mingw* | windows*)  gl_cv_func_signbit=\"guessing yes\" ;;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_signbit=\"$gl_cross_guess_normal\" ;;\n         esac\n        ])\n    ])\n  dnl GCC >= 4.0 and clang provide three built-ins for signbit.\n  dnl They can be used without warnings, also in C++, regardless of <math.h>.\n  dnl But they may expand to calls to functions, which may or may not be in\n  dnl libc.\n  AC_CACHE_CHECK([for signbit compiler built-ins],\n    [gl_cv_func_signbit_builtins],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#if (__GNUC__ >= 4) || (__clang_major__ >= 4)\n# define signbit(x) \\\n   (sizeof (x) == sizeof (long double) ? __builtin_signbitl (x) : \\\n    sizeof (x) == sizeof (double) ? __builtin_signbit (x) : \\\n    __builtin_signbitf (x))\n#else\n# error \"signbit should be three compiler built-ins\"\n#endif\n#include <string.h>\n]gl_SIGNBIT_TEST_PROGRAM\n])],\n        [gl_cv_func_signbit_builtins=yes],\n        [gl_cv_func_signbit_builtins=no],\n        [case \"$host_os\" in\n                               # Guess yes on glibc systems.\n           *-gnu* | gnu*)      gl_cv_func_signbit_builtins=\"guessing yes\" ;;\n                               # Guess yes on musl systems.\n           *-musl* | midipix*) gl_cv_func_signbit_builtins=\"guessing yes\" ;;\n                               # Guess yes on mingw, no on MSVC.\n           mingw* | windows*)  if test -n \"$GCC\"; then\n                                 gl_cv_func_signbit_builtins=\"guessing yes\"\n                               else\n                                 gl_cv_func_signbit_builtins=\"guessing no\"\n                               fi\n                               ;;\n                               # If we don't know, obey --enable-cross-guesses.\n           *)                  gl_cv_func_signbit_builtins=\"$gl_cross_guess_normal\" ;;\n         esac\n        ])\n    ])\n  dnl Use the compiler built-ins whenever possible, because they are more\n  dnl efficient than the system library functions (if they exist).\n  case \"$gl_cv_func_signbit_builtins\" in\n    *yes)\n      REPLACE_SIGNBIT_USING_BUILTINS=1\n      ;;\n    *)\n      case \"$gl_cv_func_signbit\" in\n        *yes) ;;\n        *)\n          dnl REPLACE_SIGNBIT=1 makes sure the signbit[fdl] functions get built.\n          REPLACE_SIGNBIT=1\n          ;;\n      esac\n      ;;\n  esac\n  dnl On Solaris 10, with CC in C++ mode, signbit is not available although\n  dnl is with cc in C mode. This cannot be worked around by defining\n  dnl _XOPEN_SOURCE=600, because the latter does not work in C++ mode on\n  dnl Solaris 11.0. Therefore use the replacement functions on Solaris.\n  case \"$host_os\" in\n    solaris*)\n      REPLACE_SIGNBIT=1\n      ;;\n  esac\n  if test $REPLACE_SIGNBIT = 1; then\n    gl_FLOAT_SIGN_LOCATION\n    gl_DOUBLE_SIGN_LOCATION\n    gl_LONG_DOUBLE_SIGN_LOCATION\n    if test \"$gl_cv_cc_float_signbit\" = unknown; then\n      dnl Test whether copysignf() is declared.\n      AC_CHECK_DECLS([copysignf], , , [[#include <math.h>]])\n      if test \"$ac_cv_have_decl_copysignf\" = yes; then\n        dnl Test whether copysignf() can be used without libm.\n        AC_CACHE_CHECK([whether copysignf can be used without linking with libm],\n          [gl_cv_func_copysignf_no_libm],\n          [\n            AC_LINK_IFELSE(\n              [AC_LANG_PROGRAM(\n                 [[#include <math.h>\n                   float x, y;]],\n                 [[return copysignf (x, y) < 0;]])],\n              [gl_cv_func_copysignf_no_libm=yes],\n              [gl_cv_func_copysignf_no_libm=no])\n          ])\n        if test $gl_cv_func_copysignf_no_libm = yes; then\n          AC_DEFINE([HAVE_COPYSIGNF_IN_LIBC], [1],\n            [Define if the copysignf function is declared in <math.h> and available in libc.])\n        fi\n      fi\n    fi\n    if test \"$gl_cv_cc_double_signbit\" = unknown; then\n      dnl Test whether copysign() is declared.\n      AC_CHECK_DECLS([copysign], , , [[#include <math.h>]])\n      if test \"$ac_cv_have_decl_copysign\" = yes; then\n        dnl Test whether copysign() can be used without libm.\n        AC_CACHE_CHECK([whether copysign can be used without linking with libm],\n          [gl_cv_func_copysign_no_libm],\n          [\n            AC_LINK_IFELSE(\n              [AC_LANG_PROGRAM(\n                 [[#include <math.h>\n                   double x, y;]],\n                 [[return copysign (x, y) < 0;]])],\n              [gl_cv_func_copysign_no_libm=yes],\n              [gl_cv_func_copysign_no_libm=no])\n          ])\n        if test $gl_cv_func_copysign_no_libm = yes; then\n          AC_DEFINE([HAVE_COPYSIGN_IN_LIBC], [1],\n            [Define if the copysign function is declared in <math.h> and available in libc.])\n        fi\n      fi\n    fi\n    if test \"$gl_cv_cc_long_double_signbit\" = unknown; then\n      dnl Test whether copysignl() is declared.\n      AC_CHECK_DECLS([copysignl], , , [[#include <math.h>]])\n      if test \"$ac_cv_have_decl_copysignl\" = yes; then\n        dnl Test whether copysignl() can be used without libm.\n        AC_CACHE_CHECK([whether copysignl can be used without linking with libm],\n          [gl_cv_func_copysignl_no_libm],\n          [\n            AC_LINK_IFELSE(\n              [AC_LANG_PROGRAM(\n                 [[#include <math.h>\n                   long double x, y;]],\n                 [[return copysignl (x, y) < 0;]])],\n              [gl_cv_func_copysignl_no_libm=yes],\n              [gl_cv_func_copysignl_no_libm=no])\n          ])\n        if test $gl_cv_func_copysignl_no_libm = yes; then\n          AC_DEFINE([HAVE_COPYSIGNL_IN_LIBC], [1],\n            [Define if the copysignl function is declared in <math.h> and available in libc.])\n        fi\n      fi\n    fi\n  fi\n])\n\nAC_DEFUN([gl_SIGNBIT_TEST_PROGRAM], [[\n/* Global variables.\n   Needed because GCC 4 constant-folds __builtin_signbitl (literal)\n   but cannot constant-fold            __builtin_signbitl (variable).  */\nfloat vf;\ndouble vd;\nlong double vl;\nint main ()\n{\n/* HP cc on HP-UX 10.20 has a bug with the constant expression -0.0.\n   So we use -p0f and -p0d instead.  */\nfloat p0f = 0.0f;\nfloat m0f = -p0f;\ndouble p0d = 0.0;\ndouble m0d = -p0d;\n/* On HP-UX 10.20, negating 0.0L does not yield -0.0L.\n   So we use another constant expression instead.\n   But that expression does not work on other platforms, such as when\n   cross-compiling to PowerPC on Mac OS X 10.5.  */\nlong double p0l = 0.0L;\n#if defined __hpux || defined __sgi\nlong double m0l = -LDBL_MIN * LDBL_MIN;\n#else\nlong double m0l = -p0l;\n#endif\n  int result = 0;\n  if (signbit (vf)) /* link check */\n    vf++;\n  {\n    float plus_inf = 1.0f / p0f;\n    float minus_inf = -1.0f / p0f;\n    if (!(!signbit (255.0f)\n          && signbit (-255.0f)\n          && !signbit (p0f)\n          && (memcmp (&m0f, &p0f, sizeof (float)) == 0 || signbit (m0f))\n          && !signbit (plus_inf)\n          && signbit (minus_inf)))\n      result |= 1;\n  }\n  if (signbit (vd)) /* link check */\n    vd++;\n  {\n    double plus_inf = 1.0 / p0d;\n    double minus_inf = -1.0 / p0d;\n    if (!(!signbit (255.0)\n          && signbit (-255.0)\n          && !signbit (p0d)\n          && (memcmp (&m0d, &p0d, sizeof (double)) == 0 || signbit (m0d))\n          && !signbit (plus_inf)\n          && signbit (minus_inf)))\n      result |= 2;\n  }\n  if (signbit (vl)) /* link check */\n    vl++;\n  {\n    long double plus_inf = 1.0L / p0l;\n    long double minus_inf = -1.0L / p0l;\n    if (signbit (255.0L))\n      result |= 4;\n    if (!signbit (-255.0L))\n      result |= 4;\n    if (signbit (p0l))\n      result |= 8;\n    if (!(memcmp (&m0l, &p0l, sizeof (long double)) == 0 || signbit (m0l)))\n      result |= 16;\n    if (signbit (plus_inf))\n      result |= 32;\n    if (!signbit (minus_inf))\n      result |= 64;\n  }\n  return result;\n}\n]])\n\nAC_DEFUN([gl_FLOAT_SIGN_LOCATION],\n[\n  gl_FLOATTYPE_SIGN_LOCATION([float], [gl_cv_cc_float_signbit], [f], [FLT])\n])\n\nAC_DEFUN([gl_DOUBLE_SIGN_LOCATION],\n[\n  gl_FLOATTYPE_SIGN_LOCATION([double], [gl_cv_cc_double_signbit], [], [DBL])\n])\n\nAC_DEFUN([gl_LONG_DOUBLE_SIGN_LOCATION],\n[\n  gl_FLOATTYPE_SIGN_LOCATION([long double], [gl_cv_cc_long_double_signbit], [L], [LDBL])\n])\n\nAC_DEFUN([gl_FLOATTYPE_SIGN_LOCATION],\n[\n  AC_CACHE_CHECK([where to find the sign bit in a '$1'],\n    [$2],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <stddef.h>\n#include <stdio.h>\n#define NWORDS \\\n  ((sizeof ($1) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\ntypedef union { $1 value; unsigned int word[NWORDS]; }\n        memory_float;\nstatic memory_float plus = { 1.0$3 };\nstatic memory_float minus = { -1.0$3 };\nint main ()\n{\n  size_t j, k, i;\n  unsigned int m;\n  FILE *fp = fopen (\"conftest.out\", \"w\");\n  if (fp == NULL)\n    return 1;\n  /* Find the different bit.  */\n  k = 0; m = 0;\n  for (j = 0; j < NWORDS; j++)\n    {\n      unsigned int x = plus.word[j] ^ minus.word[j];\n      if ((x & (x - 1)) || (x && m))\n        {\n          /* More than one bit difference.  */\n          fprintf (fp, \"unknown\");\n          fclose (fp);\n          return 2;\n        }\n      if (x)\n        {\n          k = j;\n          m = x;\n        }\n    }\n  if (m == 0)\n    {\n      /* No difference.  */\n      fprintf (fp, \"unknown\");\n      fclose (fp);\n      return 3;\n    }\n  /* Now m = plus.word[k] ^ ~minus.word[k].  */\n  if (plus.word[k] & ~minus.word[k])\n    {\n      /* Oh? The sign bit is set in the positive and cleared in the negative\n         numbers?  */\n      fprintf (fp, \"unknown\");\n      fclose (fp);\n      return 4;\n    }\n  for (i = 0; ; i++)\n    if ((m >> i) & 1)\n      break;\n  fprintf (fp, \"word %d bit %d\", (int) k, (int) i);\n  if (fclose (fp) != 0)\n    return 5;\n  return 0;\n}\n        ]])],\n        [$2=`cat conftest.out`],\n        [$2=\"unknown\"],\n        [\n          dnl When cross-compiling, we don't know. It depends on the\n          dnl ABI and compiler version. There are too many cases.\n          $2=\"unknown\"\n        ])\n      rm -f conftest.out\n    ])\n  case \"$]$2[\" in\n    word*bit*)\n      word=`echo \"$]$2[\" | sed -e 's/word //' -e 's/ bit.*//'`\n      bit=`echo \"$]$2[\" | sed -e 's/word.*bit //'`\n      AC_DEFINE_UNQUOTED([$4][_SIGNBIT_WORD], [$word],\n        [Define as the word index where to find the sign of '$1'.])\n      AC_DEFINE_UNQUOTED([$4][_SIGNBIT_BIT], [$bit],\n        [Define as the bit index in the word where to find the sign of '$1'.])\n      ;;\n  esac\n])\n\n# Expands to code that defines a function signbitf(float).\n# It extracts the sign bit of a non-NaN value.\nAC_DEFUN([gl_FLOAT_SIGNBIT_CODE],\n[\n  gl_FLOATTYPE_SIGNBIT_CODE([float], [f], [f])\n])\n\n# Expands to code that defines a function signbitd(double).\n# It extracts the sign bit of a non-NaN value.\nAC_DEFUN([gl_DOUBLE_SIGNBIT_CODE],\n[\n  gl_FLOATTYPE_SIGNBIT_CODE([double], [d], [])\n])\n\n# Expands to code that defines a function signbitl(long double).\n# It extracts the sign bit of a non-NaN value.\nAC_DEFUN([gl_LONG_DOUBLE_SIGNBIT_CODE],\n[\n  gl_FLOATTYPE_SIGNBIT_CODE([long double], [l], [L])\n])\n\nAC_DEFUN([gl_FLOATTYPE_SIGNBIT_CODE],\n[[\nstatic int\nsignbit$2 ($1 value)\n{\n  typedef union { $1 f; unsigned char b[sizeof ($1)]; } float_union;\n  static float_union plus_one = { 1.0$3 };   /* unused bits are zero here */\n  static float_union minus_one = { -1.0$3 }; /* unused bits are zero here */\n  /* Compute the sign bit mask as the XOR of plus_one and minus_one.  */\n  float_union u;\n  unsigned int i;\n  u.f = value;\n  for (i = 0; i < sizeof ($1); i++)\n    if (u.b[i] & (plus_one.b[i] ^ minus_one.b[i]))\n      return 1;\n  return 0;\n}\n]])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}