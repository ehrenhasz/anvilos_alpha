{
  "module_name": "isnanl.m4",
  "hash_id": "b347ba079d588868bd13e293b44872726075e9a7ed4b7cbe719337fa3e3d6724",
  "original_prompt": "Ingested from coreutils-9.4/m4/isnanl.m4",
  "human_readable_source": "# isnanl.m4 serial 23\ndnl Copyright (C) 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_ISNANL],\n[\n  AC_REQUIRE([gl_MATH_H_DEFAULTS])\n  ISNANL_LIBM=\n  gl_HAVE_ISNANL_NO_LIBM\n  if test $gl_cv_func_isnanl_no_libm = no; then\n    gl_HAVE_ISNANL_IN_LIBM\n    if test $gl_cv_func_isnanl_in_libm = yes; then\n      ISNANL_LIBM=-lm\n    fi\n  fi\n  dnl The variable gl_func_isnanl set here is used by isnan.m4.\n  if test $gl_cv_func_isnanl_no_libm = yes \\\n     || test $gl_cv_func_isnanl_in_libm = yes; then\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS $ISNANL_LIBM\"\n    gl_FUNC_ISNANL_WORKS\n    LIBS=\"$save_LIBS\"\n    case \"$gl_cv_func_isnanl_works\" in\n      *yes) gl_func_isnanl=yes ;;\n      *)    gl_func_isnanl=no; ISNANL_LIBM= ;;\n    esac\n  else\n    gl_func_isnanl=no\n  fi\n  if test $gl_func_isnanl != yes; then\n    HAVE_ISNANL=0\n  fi\n  AC_SUBST([ISNANL_LIBM])\n])\n\nAC_DEFUN([gl_FUNC_ISNANL_NO_LIBM],\n[\n  gl_HAVE_ISNANL_NO_LIBM\n  gl_func_isnanl_no_libm=$gl_cv_func_isnanl_no_libm\n  if test $gl_func_isnanl_no_libm = yes; then\n    gl_FUNC_ISNANL_WORKS\n    case \"$gl_cv_func_isnanl_works\" in\n      *yes) ;;\n      *)    gl_func_isnanl_no_libm=no ;;\n    esac\n  fi\n  if test $gl_func_isnanl_no_libm = yes; then\n    AC_DEFINE([HAVE_ISNANL_IN_LIBC], [1],\n      [Define if the isnan(long double) function is available in libc.])\n  fi\n])\n\ndnl Prerequisites of replacement isnanl definition. It does not need -lm.\nAC_DEFUN([gl_PREREQ_ISNANL],\n[\n  gl_LONG_DOUBLE_EXPONENT_LOCATION\n  AC_REQUIRE([gl_LONG_DOUBLE_VS_DOUBLE])\n])\n\ndnl Test whether isnanl() can be used without libm.\nAC_DEFUN([gl_HAVE_ISNANL_NO_LIBM],\n[\n  AC_CACHE_CHECK([whether isnan(long double) can be used without linking with libm],\n    [gl_cv_func_isnanl_no_libm],\n    [\n      AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[#include <math.h>\n             #if (__GNUC__ >= 4) || (__clang_major__ >= 4)\n             # undef isnanl\n             # define isnanl(x) __builtin_isnan ((long double)(x))\n             #elif defined isnan\n             # undef isnanl\n             # define isnanl(x) isnan ((long double)(x))\n             #endif\n             long double x;]],\n           [[return isnanl (x);]])],\n        [gl_cv_func_isnanl_no_libm=yes],\n        [gl_cv_func_isnanl_no_libm=no])\n    ])\n])\n\ndnl Test whether isnanl() can be used with libm.\nAC_DEFUN([gl_HAVE_ISNANL_IN_LIBM],\n[\n  AC_CACHE_CHECK([whether isnan(long double) can be used with libm],\n    [gl_cv_func_isnanl_in_libm],\n    [\n      save_LIBS=\"$LIBS\"\n      LIBS=\"$LIBS -lm\"\n      AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[#include <math.h>\n             #if (__GNUC__ >= 4) || (__clang_major__ >= 4)\n             # undef isnanl\n             # define isnanl(x) __builtin_isnan ((long double)(x))\n             #elif defined isnan\n             # undef isnanl\n             # define isnanl(x) isnan ((long double)(x))\n             #endif\n             long double x;]],\n           [[return isnanl (x);]])],\n        [gl_cv_func_isnanl_in_libm=yes],\n        [gl_cv_func_isnanl_in_libm=no])\n      LIBS=\"$save_LIBS\"\n    ])\n])\n\ndnl Test whether isnanl() recognizes all canonical numbers which are neither\ndnl finite nor infinite.\nAC_DEFUN([gl_FUNC_ISNANL_WORKS],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_BIGENDIAN])\n  AC_REQUIRE([gl_LONG_DOUBLE_VS_DOUBLE])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CACHE_CHECK([whether isnanl works], [gl_cv_func_isnanl_works],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#if (__GNUC__ >= 4) || (__clang_major__ >= 4)\n# undef isnanl\n# define isnanl(x) __builtin_isnan ((long double)(x))\n#elif defined isnan\n# undef isnanl\n# define isnanl(x) isnan ((long double)(x))\n#endif\n#define NWORDS \\\n  ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\ntypedef union { unsigned int word[NWORDS]; long double value; }\n        memory_long_double;\n/* On Irix 6.5, gcc 3.4.3 can't compute compile-time NaN, and needs the\n   runtime type conversion.  */\n#ifdef __sgi\nstatic long double NaNl ()\n{\n  double zero = 0.0;\n  return zero / zero;\n}\n#else\n# define NaNl() (0.0L / 0.0L)\n#endif\nint main ()\n{\n  int result = 0;\n\n  if (!isnanl (NaNl ()))\n    result |= 1;\n\n  {\n    memory_long_double m;\n    unsigned int i;\n\n    /* The isnanl function should be immune against changes in the sign bit and\n       in the mantissa bits.  The xor operation twiddles a bit that can only be\n       a sign bit or a mantissa bit (since the exponent never extends to\n       bit 31).  */\n    m.value = NaNl ();\n    m.word[NWORDS / 2] ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n    for (i = 0; i < NWORDS; i++)\n      m.word[i] |= 1;\n    if (!isnanl (m.value))\n      result |= 1;\n  }\n\n#if ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n/* Representation of an 80-bit 'long double' as an initializer for a sequence\n   of 'unsigned int' words.  */\n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  { /* Quiet NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    if (!isnanl (x.value))\n      result |= 2;\n  }\n  {\n    /* Signalling NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    if (!isnanl (x.value))\n      result |= 2;\n  }\n  /* isnanl should return something even for noncanonical values.  */\n  { /* Pseudo-NaN.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    if (isnanl (x.value) && !isnanl (x.value))\n      result |= 4;\n  }\n  { /* Pseudo-Infinity.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    if (isnanl (x.value) && !isnanl (x.value))\n      result |= 8;\n  }\n  { /* Pseudo-Zero.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    if (isnanl (x.value) && !isnanl (x.value))\n      result |= 16;\n  }\n  { /* Unnormalized number.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    if (isnanl (x.value) && !isnanl (x.value))\n      result |= 32;\n  }\n  { /* Pseudo-Denormal.  */\n    static memory_long_double x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    if (isnanl (x.value) && !isnanl (x.value))\n      result |= 64;\n  }\n#endif\n\n  return result;\n}]])],\n        [gl_cv_func_isnanl_works=yes],\n        [gl_cv_func_isnanl_works=no],\n        [case \"$host_os\" in\n           mingw* | windows*) # Guess yes on mingw, no on MSVC.\n             AC_EGREP_CPP([Known], [\n#ifdef __MINGW32__\n Known\n#endif\n               ],\n               [gl_cv_func_isnanl_works=\"guessing yes\"],\n               [gl_cv_func_isnanl_works=\"guessing no\"])\n             ;;\n           *) gl_cv_func_isnanl_works=\"guessing yes\" ;;\n         esac\n        ])\n    ])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}