{
  "module_name": "ftello.m4",
  "hash_id": "1a52d03a3d3439ee165076ca40961f1efe793d282885df57f29780ec4bbb6564",
  "original_prompt": "Ingested from coreutils-9.4/m4/ftello.m4",
  "human_readable_source": "# ftello.m4 serial 16\ndnl Copyright (C) 2007-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_FTELLO],\n[\n  AC_REQUIRE([gl_STDIO_H_DEFAULTS])\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([gl_STDIN_LARGE_OFFSET])\n  AC_REQUIRE([gl_SYS_TYPES_H])\n\n  dnl Persuade glibc <stdio.h> to declare ftello().\n  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n\n  AC_CHECK_DECLS_ONCE([ftello])\n  if test $ac_cv_have_decl_ftello = no; then\n    HAVE_DECL_FTELLO=0\n  fi\n\n  AC_CACHE_CHECK([for ftello], [gl_cv_func_ftello],\n    [\n      AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[#include <stdio.h>]],\n           [[ftello (stdin);]])],\n        [gl_cv_func_ftello=yes],\n        [gl_cv_func_ftello=no])\n    ])\n  if test $gl_cv_func_ftello = no; then\n    HAVE_FTELLO=0\n  else\n    if test $WINDOWS_64_BIT_OFF_T = 1; then\n      REPLACE_FTELLO=1\n    fi\n    if test $gl_cv_var_stdin_large_offset = no; then\n      REPLACE_FTELLO=1\n    fi\n    AC_REQUIRE([AC_CANONICAL_HOST])\n    if test $REPLACE_FTELLO = 0; then\n      dnl On native Windows, in some circumstances, ftell(), ftello(),\n      dnl fgetpos(), lseek(), _lseeki64() all succeed on devices of type\n      dnl FILE_TYPE_PIPE. However, to match POSIX behaviour, we want\n      dnl ftell(), ftello(), fgetpos(), lseek() to fail when the argument fd\n      dnl designates a pipe. See also\n      dnl https://github.com/python/cpython/issues/78961#issuecomment-1093800325\n      case \"$host_os\" in\n        mingw* | windows*) REPLACE_FTELLO=1 ;;\n      esac\n    fi\n    if test $REPLACE_FTELLO = 0; then\n      dnl Detect bug on Solaris.\n      dnl ftell and ftello produce incorrect results after putc that followed a\n      dnl getc call that reached EOF on Solaris. This is because the _IOREAD\n      dnl flag does not get cleared in this case, even though _IOWRT gets set,\n      dnl and ftell and ftello look whether the _IOREAD flag is set.\n      AC_CACHE_CHECK([whether ftello works],\n        [gl_cv_func_ftello_works],\n        [\n          dnl Initial guess, used when cross-compiling or when /dev/tty cannot\n          dnl be opened.\nchangequote(,)dnl\n          case \"$host_os\" in\n                               # Guess no on Solaris.\n            solaris*)          gl_cv_func_ftello_works=\"guessing no\" ;;\n                               # Guess yes on native Windows.\n            mingw* | windows*) gl_cv_func_ftello_works=\"guessing yes\" ;;\n                               # Guess yes otherwise.\n            *)                 gl_cv_func_ftello_works=\"guessing yes\" ;;\n          esac\nchangequote([,])dnl\n          AC_RUN_IFELSE(\n            [AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define TESTFILE \"conftest.tmp\"\nint\nmain (void)\n{\n  FILE *fp;\n\n  /* Create a file with some contents.  */\n  fp = fopen (TESTFILE, \"w\");\n  if (fp == NULL)\n    return 70;\n  if (fwrite (\"foogarsh\", 1, 8, fp) < 8)\n    { fclose (fp); return 71; }\n  if (fclose (fp))\n    return 72;\n\n  /* The file's contents is now \"foogarsh\".  */\n\n  /* Try writing after reading to EOF.  */\n  fp = fopen (TESTFILE, \"r+\");\n  if (fp == NULL)\n    return 73;\n  if (fseek (fp, -1, SEEK_END))\n    { fclose (fp); return 74; }\n  if (!(getc (fp) == 'h'))\n    { fclose (fp); return 1; }\n  if (!(getc (fp) == EOF))\n    { fclose (fp); return 2; }\n  if (!(ftell (fp) == 8))\n    { fclose (fp); return 3; }\n  if (!(ftell (fp) == 8))\n    { fclose (fp); return 4; }\n  if (!(putc ('!', fp) == '!'))\n    { fclose (fp); return 5; }\n  if (!(ftell (fp) == 9))\n    { fclose (fp); return 6; }\n  if (!(fclose (fp) == 0))\n    return 7;\n  fp = fopen (TESTFILE, \"r\");\n  if (fp == NULL)\n    return 75;\n  {\n    char buf[10];\n    if (!(fread (buf, 1, 10, fp) == 9))\n      { fclose (fp); return 10; }\n    if (!(memcmp (buf, \"foogarsh!\", 9) == 0))\n      { fclose (fp); return 11; }\n  }\n  if (!(fclose (fp) == 0))\n    return 12;\n\n  /* The file's contents is now \"foogarsh!\".  */\n\n  return 0;\n}]])],\n            [gl_cv_func_ftello_works=yes],\n            [gl_cv_func_ftello_works=no], [:])\n        ])\n      case \"$gl_cv_func_ftello_works\" in\n        *yes) ;;\n        *)\n          REPLACE_FTELLO=1\n          AC_DEFINE([FTELLO_BROKEN_AFTER_SWITCHING_FROM_READ_TO_WRITE], [1],\n            [Define to 1 if the system's ftello function has the Solaris bug.])\n          ;;\n      esac\n    fi\n    if test $REPLACE_FTELLO = 0; then\n      dnl Detect bug on macOS >= 10.15.\n      gl_FUNC_UNGETC_WORKS\n      if test $gl_ftello_broken_after_ungetc = yes; then\n        REPLACE_FTELLO=1\n        AC_DEFINE([FTELLO_BROKEN_AFTER_UNGETC], [1],\n          [Define to 1 if the system's ftello function has the macOS bug.])\n      fi\n    fi\n  fi\n])\n\n# Prerequisites of lib/ftello.c.\nAC_DEFUN([gl_PREREQ_FTELLO],\n[\n  dnl Native Windows has the function _ftelli64. mingw hides it, but mingw64\n  dnl makes it usable again.\n  AC_CHECK_FUNCS([_ftelli64])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}