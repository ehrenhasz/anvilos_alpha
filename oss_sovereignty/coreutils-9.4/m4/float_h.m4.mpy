{
  "module_name": "float_h.m4",
  "hash_id": "603fc196e02b01462806622803db1db76e30a4857db9a58db4c11c4c1c114eb2",
  "original_prompt": "Ingested from coreutils-9.4/m4/float_h.m4",
  "human_readable_source": "# float_h.m4 serial 14\ndnl Copyright (C) 2007, 2009-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FLOAT_H],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  GL_GENERATE_FLOAT_H=false\n  REPLACE_FLOAT_LDBL=0\n  case \"$host_os\" in\n    aix* | beos* | openbsd* | mirbsd* | irix*)\n      GL_GENERATE_FLOAT_H=true\n      ;;\n    freebsd* | dragonfly*)\n      case \"$host_cpu\" in\nchangequote(,)dnl\n        i[34567]86 )\nchangequote([,])dnl\n          GL_GENERATE_FLOAT_H=true\n          ;;\n        x86_64 )\n          # On x86_64 systems, the C compiler may still be generating\n          # 32-bit code.\n          AC_COMPILE_IFELSE(\n            [AC_LANG_SOURCE(\n               [[#if defined __LP64__ || defined __x86_64__ || defined __amd64__\n                  int ok;\n                 #else\n                  error fail\n                 #endif\n               ]])],\n            [],\n            [GL_GENERATE_FLOAT_H=true])\n          ;;\n      esac\n      ;;\n    linux*)\n      case \"$host_cpu\" in\n        powerpc*)\n          GL_GENERATE_FLOAT_H=true\n          ;;\n      esac\n      ;;\n  esac\n  case \"$host_os\" in\n    aix* | freebsd* | dragonfly* | linux*)\n      if $GL_GENERATE_FLOAT_H; then\n        REPLACE_FLOAT_LDBL=1\n      fi\n      ;;\n  esac\n\n  dnl Test against glibc-2.7 Linux/SPARC64 bug.\n  REPLACE_ITOLD=0\n  AC_CACHE_CHECK([whether conversion from 'int' to 'long double' works],\n    [gl_cv_func_itold_works],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\nint i = -1;\nvolatile long double ld;\nint main ()\n{\n  ld += i * 1.0L;\n  if (ld > 0)\n    return 1;\n  return 0;\n}]])],\n        [gl_cv_func_itold_works=yes],\n        [gl_cv_func_itold_works=no],\n        [case \"$host\" in\n           sparc*-*-linux*)\n             AC_COMPILE_IFELSE(\n               [AC_LANG_SOURCE(\n                 [[#if defined __LP64__ || defined __arch64__\n                    int ok;\n                   #else\n                    error fail\n                   #endif\n                 ]])],\n               [gl_cv_func_itold_works=\"guessing no\"],\n               [gl_cv_func_itold_works=\"guessing yes\"])\n             ;;\n             # Guess yes on native Windows.\n           mingw* | windows*)\n             gl_cv_func_itold_works=\"guessing yes\" ;;\n           *)\n             gl_cv_func_itold_works=\"guessing yes\" ;;\n         esac\n        ])\n    ])\n  case \"$gl_cv_func_itold_works\" in\n    *no)\n      REPLACE_ITOLD=1\n      dnl We add the workaround to <float.h> but also to <math.h>,\n      dnl to increase the chances that the fix function gets pulled in.\n      GL_GENERATE_FLOAT_H=true\n      ;;\n  esac\n\n  if $GL_GENERATE_FLOAT_H; then\n    gl_NEXT_HEADERS([float.h])\n  fi\n  AC_SUBST([REPLACE_ITOLD])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}