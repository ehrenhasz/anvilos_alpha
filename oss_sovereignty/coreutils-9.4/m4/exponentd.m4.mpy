{
  "module_name": "exponentd.m4",
  "hash_id": "cda70f0f180ae7dfd162388d471ed8041aea664ebffcf09497c483374638c289",
  "original_prompt": "Ingested from coreutils-9.4/m4/exponentd.m4",
  "human_readable_source": "# exponentd.m4 serial 4\ndnl Copyright (C) 2007-2008, 2010-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\nAC_DEFUN_ONCE([gl_DOUBLE_EXPONENT_LOCATION],\n[\n  AC_CACHE_CHECK([where to find the exponent in a 'double'],\n    [gl_cv_cc_double_expbit0],\n    [\n      AC_RUN_IFELSE(\n        [AC_LANG_SOURCE([[\n#include <float.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#define NWORDS \\\n  ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\ntypedef union { double value; unsigned int word[NWORDS]; } memory_double;\nstatic unsigned int ored_words[NWORDS];\nstatic unsigned int anded_words[NWORDS];\nstatic void add_to_ored_words (double x)\n{\n  memory_double m;\n  size_t i;\n  /* Clear it first, in case sizeof (double) < sizeof (memory_double).  */\n  memset (&m, 0, sizeof (memory_double));\n  m.value = x;\n  for (i = 0; i < NWORDS; i++)\n    {\n      ored_words[i] |= m.word[i];\n      anded_words[i] &= m.word[i];\n    }\n}\nint main ()\n{\n  size_t j;\n  FILE *fp = fopen (\"conftest.out\", \"w\");\n  if (fp == NULL)\n    return 1;\n  for (j = 0; j < NWORDS; j++)\n    anded_words[j] = ~ (unsigned int) 0;\n  add_to_ored_words (0.25);\n  add_to_ored_words (0.5);\n  add_to_ored_words (1.0);\n  add_to_ored_words (2.0);\n  add_to_ored_words (4.0);\n  /* Remove bits that are common (e.g. if representation of the first mantissa\n     bit is explicit).  */\n  for (j = 0; j < NWORDS; j++)\n    ored_words[j] &= ~anded_words[j];\n  /* Now find the nonzero word.  */\n  for (j = 0; j < NWORDS; j++)\n    if (ored_words[j] != 0)\n      break;\n  if (j < NWORDS)\n    {\n      size_t i;\n      for (i = j + 1; i < NWORDS; i++)\n        if (ored_words[i] != 0)\n          {\n            fprintf (fp, \"unknown\");\n            return (fclose (fp) != 0);\n          }\n      for (i = 0; ; i++)\n        if ((ored_words[j] >> i) & 1)\n          {\n            fprintf (fp, \"word %d bit %d\", (int) j, (int) i);\n            return (fclose (fp) != 0);\n          }\n    }\n  fprintf (fp, \"unknown\");\n  return (fclose (fp) != 0);\n}\n        ]])],\n        [gl_cv_cc_double_expbit0=`cat conftest.out`],\n        [gl_cv_cc_double_expbit0=\"unknown\"],\n        [\n          dnl On ARM, there are two 'double' floating-point formats, used by\n          dnl different sets of instructions: The older FPA instructions assume\n          dnl that they are stored in big-endian word order, while the words\n          dnl (like integer types) are stored in little-endian byte order.\n          dnl The newer VFP instructions assume little-endian order\n          dnl consistently.\n          AC_EGREP_CPP([mixed_endianness], [\n#if defined arm || defined __arm || defined __arm__\n  mixed_endianness\n#endif\n            ],\n            [gl_cv_cc_double_expbit0=\"unknown\"],\n            [\n              pushdef([AC_MSG_CHECKING],[:])dnl\n              pushdef([AC_MSG_RESULT],[:])dnl\n              pushdef([AC_MSG_RESULT_UNQUOTED],[:])dnl\n              AC_C_BIGENDIAN(\n                [gl_cv_cc_double_expbit0=\"word 0 bit 20\"],\n                [gl_cv_cc_double_expbit0=\"word 1 bit 20\"],\n                [gl_cv_cc_double_expbit0=\"unknown\"])\n              popdef([AC_MSG_RESULT_UNQUOTED])dnl\n              popdef([AC_MSG_RESULT])dnl\n              popdef([AC_MSG_CHECKING])dnl\n            ])\n        ])\n      rm -f conftest.out\n    ])\n  case \"$gl_cv_cc_double_expbit0\" in\n    word*bit*)\n      word=`echo \"$gl_cv_cc_double_expbit0\" | sed -e 's/word //' -e 's/ bit.*//'`\n      bit=`echo \"$gl_cv_cc_double_expbit0\" | sed -e 's/word.*bit //'`\n      AC_DEFINE_UNQUOTED([DBL_EXPBIT0_WORD], [$word],\n        [Define as the word index where to find the exponent of 'double'.])\n      AC_DEFINE_UNQUOTED([DBL_EXPBIT0_BIT], [$bit],\n        [Define as the bit index in the word where to find bit 0 of the exponent of 'double'.])\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}