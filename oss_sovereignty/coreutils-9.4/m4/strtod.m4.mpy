{
  "module_name": "strtod.m4",
  "hash_id": "a91c11dd8d8a1698c1002a638258191ed553459ced5a84f3a3c8e62e8330d179",
  "original_prompt": "Ingested from coreutils-9.4/m4/strtod.m4",
  "human_readable_source": "# strtod.m4 serial 29\ndnl Copyright (C) 2002-2003, 2006-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_STRTOD],\n[\n  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  m4_ifdef([gl_FUNC_STRTOD_OBSOLETE], [\n    dnl Test whether strtod is declared.\n    dnl Don't call AC_FUNC_STRTOD, because it does not have the right guess\n    dnl when cross-compiling.\n    dnl Don't call AC_CHECK_FUNCS([strtod]) because it would collide with the\n    dnl ac_cv_func_strtod variable set by the AC_FUNC_STRTOD macro.\n    AC_CHECK_DECLS_ONCE([strtod])\n    if test $ac_cv_have_decl_strtod != yes; then\n      HAVE_STRTOD=0\n    fi\n  ])\n  if test $HAVE_STRTOD = 1; then\n    AC_CACHE_CHECK([whether strtod obeys C99], [gl_cv_func_strtod_works],\n      [AC_RUN_IFELSE([AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <math.h>\n#include <errno.h>\n/* Compare two numbers with ==.\n   This is a separate function because IRIX 6.5 \"cc -O\" miscompiles an\n   'x == x' test.  */\nstatic int\nnumeric_equal (double x, double y)\n{\n  return x == y;\n}\n]], [[\n  int result = 0;\n  {\n    /* In some old versions of Linux (2000 or before), strtod mis-parses\n       strings with leading '+'.  */\n    const char *string = \" +69\";\n    char *term;\n    double value = strtod (string, &term);\n    if (value != 69 || term != (string + 4))\n      result |= 1;\n  }\n  {\n    /* Under Solaris 2.4, strtod returns the wrong value for the\n       terminating character under some conditions.  */\n    const char *string = \"NaN\";\n    char *term;\n    strtod (string, &term);\n    if (term != string && *(term - 1) == 0)\n      result |= 2;\n  }\n  {\n    /* Older glibc and Cygwin mis-parse \"-0x\".  */\n    const char *string = \"-0x\";\n    char *term;\n    double value = strtod (string, &term);\n    double zero = 0.0;\n    if (1.0 / value != -1.0 / zero || term != (string + 2))\n      result |= 4;\n  }\n  {\n    /* Many platforms do not parse hex floats.  */\n    const char *string = \"0XaP+1\";\n    char *term;\n    double value = strtod (string, &term);\n    if (value != 20.0 || term != (string + 6))\n      result |= 8;\n  }\n  {\n    /* Many platforms do not parse infinities.  HP-UX 11.31 parses inf,\n       but mistakenly sets errno.  */\n    const char *string = \"inf\";\n    char *term;\n    double value;\n    errno = 0;\n    value = strtod (string, &term);\n    if (value != HUGE_VAL || term != (string + 3) || errno)\n      result |= 16;\n  }\n  {\n    /* glibc 2.7 and cygwin 1.5.24 misparse \"nan()\".  */\n    const char *string = \"nan()\";\n    char *term;\n    double value = strtod (string, &term);\n    if (numeric_equal (value, value) || term != (string + 5))\n      result |= 32;\n  }\n  {\n    /* darwin 10.6.1 misparses \"nan(\".  */\n    const char *string = \"nan(\";\n    char *term;\n    double value = strtod (string, &term);\n    if (numeric_equal (value, value) || term != (string + 3))\n      result |= 64;\n  }\n  return result;\n]])],\n        [gl_cv_func_strtod_works=yes],\n        [gl_cv_func_strtod_works=no],\n        [dnl The last known bugs in glibc strtod(), as of this writing,\n         dnl were fixed in version 2.8\n         AC_EGREP_CPP([Lucky user],\n           [\n#include <features.h>\n#ifdef __GNU_LIBRARY__\n #if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8) || (__GLIBC__ > 2)) \\\n     && !defined __UCLIBC__\n  Lucky user\n #endif\n#endif\n           ],\n           [gl_cv_func_strtod_works=\"guessing yes\"],\n           [case \"$host_os\" in\n                                  # Guess yes on musl systems.\n              *-musl* | midipix*) gl_cv_func_strtod_works=\"guessing yes\" ;;\n                                  # Guess yes on native Windows.\n              mingw* | windows*)  gl_cv_func_strtod_works=\"guessing yes\" ;;\n              *)                  gl_cv_func_strtod_works=\"$gl_cross_guess_normal\" ;;\n            esac\n           ])\n        ])\n      ])\n    case \"$gl_cv_func_strtod_works\" in\n      *yes) ;;\n      *)\n        REPLACE_STRTOD=1\n        ;;\n    esac\n  fi\n])\n\n# Prerequisites of lib/strtod.c.\nAC_DEFUN([gl_PREREQ_STRTOD], [\n  AC_REQUIRE([gl_CHECK_LDEXP_NO_LIBM])\n  if test $gl_cv_func_ldexp_no_libm = yes; then\n    AC_DEFINE([HAVE_LDEXP_IN_LIBC], [1],\n      [Define if the ldexp function is available in libc.])\n  fi\n  gl_CHECK_FUNCS_ANDROID([nl_langinfo], [[#include <langinfo.h>]])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}