{
  "module_name": "getcwd.m4",
  "hash_id": "c4b625647a81a54bf94d05a6ac48fa32202f48f1592c370be5a0075c8a7a50d5",
  "original_prompt": "Ingested from coreutils-9.4/m4/getcwd.m4",
  "human_readable_source": "# getcwd.m4 - check for working getcwd that is compatible with glibc\n\n# Copyright (C) 2001, 2003-2007, 2009-2023 Free Software Foundation, Inc.\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# Written by Paul Eggert.\n# serial 21\n\nAC_DEFUN([gl_FUNC_GETCWD_NULL],\n  [\n   AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n   AC_CHECK_HEADERS_ONCE([unistd.h])\n   AC_CACHE_CHECK([whether getcwd (NULL, 0) allocates memory for result],\n     [gl_cv_func_getcwd_null],\n     [AC_RUN_IFELSE([AC_LANG_PROGRAM([[\n#\t include <stdlib.h>\n#        if HAVE_UNISTD_H\n#         include <unistd.h>\n#        else /* on Windows with MSVC */\n#         include <direct.h>\n#        endif\n         ]GL_MDA_DEFINES[\n#        ifndef getcwd\n         char *getcwd ();\n#        endif\n]], [[\n#if defined _WIN32 && ! defined __CYGWIN__\n/* mingw cwd does not start with '/', but _getcwd does allocate.\n   However, mingw fails to honor non-zero size.  */\n#else\n           if (chdir (\"/\") != 0)\n             return 1;\n           else\n             {\n               char *f = getcwd (NULL, 0);\n               if (! f)\n                 return 2;\n               if (f[0] != '/')\n                 { free (f); return 3; }\n               if (f[1] != '\\0')\n                 { free (f); return 4; }\n               free (f);\n               return 0;\n             }\n#endif\n         ]])],\n        [gl_cv_func_getcwd_null=yes],\n        [gl_cv_func_getcwd_null=no],\n        [[case \"$host_os\" in\n                           # Guess yes on glibc systems.\n            *-gnu* | gnu*) gl_cv_func_getcwd_null=\"guessing yes\";;\n                           # Guess yes on musl systems.\n            *-musl*)       gl_cv_func_getcwd_null=\"guessing yes\";;\n                           # Guess yes on systems that emulate the Linux system calls.\n            midipix*)      gl_cv_func_getcwd_null=\"guessing yes\";;\n                           # Guess yes on Cygwin.\n            cygwin*)       gl_cv_func_getcwd_null=\"guessing yes\";;\n                           # If we don't know, obey --enable-cross-guesses.\n            *)             gl_cv_func_getcwd_null=\"$gl_cross_guess_normal\";;\n          esac\n        ]])])\n])\n\nAC_DEFUN([gl_FUNC_GETCWD_SIGNATURE],\n[\n  AC_CACHE_CHECK([for getcwd with POSIX signature],\n    [gl_cv_func_getcwd_posix_signature],\n    [AC_COMPILE_IFELSE(\n      [AC_LANG_PROGRAM(\n         [[#include <unistd.h>\n         ]GL_MDA_DEFINES],\n         [[extern\n           #ifdef __cplusplus\n           \"C\"\n           #endif\n           char *getcwd (char *, size_t);\n         ]])\n      ],\n      [gl_cv_func_getcwd_posix_signature=yes],\n      [gl_cv_func_getcwd_posix_signature=no])\n   ])\n])\n\ndnl Guarantee that getcwd will malloc with a NULL first argument.  Assumes\ndnl that either the system getcwd is robust, or that calling code is okay\ndnl with spurious failures when run from a directory with an absolute name\ndnl larger than 4k bytes.\ndnl\ndnl Assumes that getcwd exists; if you are worried about obsolete\ndnl platforms that lacked getcwd(), then you need to use the GPL module.\nAC_DEFUN([gl_FUNC_GETCWD_LGPL],\n[\n  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])\n  AC_REQUIRE([gl_FUNC_GETCWD_NULL])\n  AC_REQUIRE([gl_FUNC_GETCWD_SIGNATURE])\n\n  case $gl_cv_func_getcwd_null,$gl_cv_func_getcwd_posix_signature in\n  *yes,yes) ;;\n  *)\n    dnl Minimal replacement lib/getcwd-lgpl.c.\n    REPLACE_GETCWD=1\n    ;;\n  esac\n])\n\ndnl Check for all known getcwd bugs; useful for a program likely to be\ndnl executed from an arbitrary location.\nAC_DEFUN([gl_FUNC_GETCWD],\n[\n  AC_REQUIRE([gl_UNISTD_H_DEFAULTS])\n  AC_REQUIRE([gl_FUNC_GETCWD_NULL])\n  AC_REQUIRE([gl_FUNC_GETCWD_SIGNATURE])\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n  gl_abort_bug=no\n  case \"$host_os\" in\n    mingw* | windows*)\n      gl_cv_func_getcwd_path_max=yes\n      ;;\n    *)\n      gl_FUNC_GETCWD_PATH_MAX\n      case \"$gl_cv_func_getcwd_null\" in\n        *yes)\n          gl_FUNC_GETCWD_ABORT_BUG([gl_abort_bug=yes])\n          ;;\n      esac\n      ;;\n  esac\n  dnl Define HAVE_MINIMALLY_WORKING_GETCWD and HAVE_PARTLY_WORKING_GETCWD\n  dnl if appropriate.\n  case \"$gl_cv_func_getcwd_path_max\" in\n    *\"no\" | *\"no, it has the AIX bug\") ;;\n    *)\n      AC_DEFINE([HAVE_MINIMALLY_WORKING_GETCWD], [1],\n        [Define to 1 if getcwd minimally works, that is, its result can be\n         trusted when it succeeds.])\n      ;;\n  esac\n  case \"$gl_cv_func_getcwd_path_max\" in\n    *\"no, but it is partly working\")\n      AC_DEFINE([HAVE_PARTLY_WORKING_GETCWD], [1],\n        [Define to 1 if getcwd works, except it sometimes fails when it\n         shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.])\n      ;;\n    *\"yes, but with shorter paths\")\n      AC_DEFINE([HAVE_GETCWD_SHORTER], [1],\n        [Define to 1 if getcwd works, but with shorter paths\n         than is generally tested with the replacement.])\n      ;;\n  esac\n\n  if { case \"$gl_cv_func_getcwd_null\" in *yes) false;; *) true;; esac; } \\\n     || test $gl_cv_func_getcwd_posix_signature != yes \\\n     || { case \"$gl_cv_func_getcwd_path_max\" in *yes*) false;; *) true;; esac; } \\\n     || test $gl_abort_bug = yes; then\n    REPLACE_GETCWD=1\n  fi\n])\n\n# Prerequisites of lib/getcwd.c, when full replacement is in effect.\nAC_DEFUN([gl_PREREQ_GETCWD],\n[\n  AC_REQUIRE([gl_USE_SYSTEM_EXTENSIONS])\n  AC_REQUIRE([gl_CHECK_TYPE_STRUCT_DIRENT_D_INO])\n  :\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}