{
  "module_name": "uchar_h.m4",
  "hash_id": "0b517b6045f3cf04788623dd5023db11f38080093ad06e06c837c514d5fdb698",
  "original_prompt": "Ingested from coreutils-9.4/m4/uchar_h.m4",
  "human_readable_source": "# uchar_h.m4 serial 31\ndnl Copyright (C) 2019-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\ndnl Prepare the overridden <uchar.h>.\n\nAC_DEFUN_ONCE([gl_UCHAR_H],\n[\n  AC_REQUIRE([gl_UCHAR_H_DEFAULTS])\n\n  gl_CHECK_NEXT_HEADERS([uchar.h])\n  if test $ac_cv_header_uchar_h = yes; then\n    HAVE_UCHAR_H=1\n  else\n    HAVE_UCHAR_H=0\n  fi\n  AC_SUBST([HAVE_UCHAR_H])\n\n  gl_TYPE_CHAR8_T\n  gl_TYPE_CHAR16_T\n  gl_TYPE_CHAR32_T\n\n  dnl In C++ mode, clang defines 'char16_t' and 'char32_t' as built-in types\n  dnl on some platforms (e.g. OpenBSD 6.7), and as types defined by many\n  dnl header files (<limits.h>, <stddef.h>, <stdint.h>, <stdio.h>, <stdlib.h>\n  dnl and others) on some platforms (e.g. Mac OS X 10.13).\n  dnl The same thing may also happen for 'char8_t'; so, be prepared for it.\n  m4_ifdef([gl_ANSI_CXX], [AC_REQUIRE([gl_ANSI_CXX])])\n  CXX_HAS_UCHAR_TYPES=0\n  if test $HAVE_UCHAR_H = 0; then\n    if test \"$CXX\" != no; then\n      AC_CACHE_CHECK([whether the C++ compiler predefines the <uchar.h> types],\n        [gl_cv_cxx_has_uchar_types],\n        [dnl We can't use AC_LANG_PUSH([C++]) and AC_LANG_POP([C++]) here, due to\n         dnl an autoconf bug <https://savannah.gnu.org/support/?110294>.\n         cat > conftest.cpp <<\\EOF\n#include <stddef.h>\nchar16_t a;\nchar32_t b;\nEOF\n         gl_command=\"$CXX $CXXFLAGS $CPPFLAGS -c conftest.cpp\"\n         if AC_TRY_EVAL([gl_command]); then\n           gl_cv_cxx_has_uchar_types=yes\n         else\n           gl_cv_cxx_has_uchar_types=no\n         fi\n         rm -fr conftest*\n        ])\n      if test $gl_cv_cxx_has_uchar_types = yes; then\n        CXX_HAS_UCHAR_TYPES=1\n      fi\n    fi\n  fi\n  AC_SUBST([CXX_HAS_UCHAR_TYPES])\n  CXX_HAS_CHAR8_TYPE=0\n  if test $HAVE_UCHAR_H = 0; then\n    if test \"$CXX\" != no; then\n      AC_CACHE_CHECK([whether the C++ compiler predefines the char8_t types],\n        [gl_cv_cxx_has_char8_type],\n        [dnl We can't use AC_LANG_PUSH([C++]) and AC_LANG_POP([C++]) here, due to\n         dnl an autoconf bug <https://savannah.gnu.org/support/?110294>.\n         cat > conftest.cpp <<\\EOF\n#include <stddef.h>\nchar8_t a;\nEOF\n         gl_command=\"$CXX $CXXFLAGS $CPPFLAGS -c conftest.cpp\"\n         if AC_TRY_EVAL([gl_command]); then\n           gl_cv_cxx_has_char8_type=yes\n         else\n           gl_cv_cxx_has_char8_type=no\n         fi\n         rm -fr conftest*\n        ])\n      if test $gl_cv_cxx_has_char8_type = yes; then\n        CXX_HAS_CHAR8_TYPE=1\n      fi\n    fi\n  fi\n  AC_SUBST([CXX_HAS_CHAR8_TYPE])\n\n  dnl Test whether a 'char32_t' can hold more characters than a 'wchar_t'.\n  gl_STDINT_BITSIZEOF([wchar_t], [gl_STDINT_INCLUDES])\n  if test $BITSIZEOF_WCHAR_T -lt 32; then\n    SMALL_WCHAR_T=1\n  else\n    SMALL_WCHAR_T=0\n  fi\n  dnl SMALL_WCHAR_T is expected to be 1 on 32-bit AIX, Cygwin, native Windows.\n  AC_SUBST([SMALL_WCHAR_T])\n\n  dnl Check for declarations of anything we want to poison if the\n  dnl corresponding gnulib module is not in use, and which is not\n  dnl guaranteed by C11.\n  gl_WARN_ON_USE_PREPARE([[\n      #ifdef __HAIKU__\n       #include <stdint.h>\n      #endif\n      #include <uchar.h>\n    ]], [c32rtomb mbrtoc16 mbrtoc32])\n])\n\nAC_DEFUN_ONCE([gl_TYPE_CHAR8_T],\n[\n  dnl Determine whether gnulib's <uchar.h> would, if present, override char8_t.\n  AC_CACHE_CHECK([whether char8_t is correctly defined],\n    [gl_cv_type_char8_t_works],\n    [AC_COMPILE_IFELSE(\n       [AC_LANG_PROGRAM([[\n          #ifdef __HAIKU__\n           #include <stdint.h>\n          #endif\n          #include <uchar.h>\n          int verify[(char8_t)(-1) >= 0 && sizeof (char8_t) == sizeof (unsigned char) ? 1 : -1];\n          ]])\n       ],\n       [gl_cv_type_char8_t_works=yes],\n       [gl_cv_type_char8_t_works=no])\n    ])\n  if test $gl_cv_type_char8_t_works = no; then\n    GNULIBHEADERS_OVERRIDE_CHAR8_T=1\n  else\n    GNULIBHEADERS_OVERRIDE_CHAR8_T=0\n  fi\n  AC_SUBST([GNULIBHEADERS_OVERRIDE_CHAR8_T])\n])\n\ndnl On Haiku 2020, char16_t and char32_t are incorrectly defined.\ndnl See <https://dev.haiku-os.org/ticket/15990>.\nAC_DEFUN_ONCE([gl_TYPE_CHAR16_T],\n[\n  dnl Determine whether gnulib's <uchar.h> would, if present, override char16_t.\n  AC_CACHE_CHECK([whether char16_t is correctly defined],\n    [gl_cv_type_char16_t_works],\n    [AC_COMPILE_IFELSE(\n       [AC_LANG_PROGRAM([[\n          #ifdef __HAIKU__\n           #include <stdint.h>\n          #endif\n          #include <uchar.h>\n          /* For simplicity, assume that uint16_least_t is equivalent to\n             'unsigned short'.  */\n          int verify[(char16_t)(-1) >= 0 && sizeof (char16_t) == sizeof (unsigned short) ? 1 : -1];\n          ]])\n       ],\n       [gl_cv_type_char16_t_works=yes],\n       [gl_cv_type_char16_t_works=no])\n    ])\n  if test $gl_cv_type_char16_t_works = no; then\n    GNULIBHEADERS_OVERRIDE_CHAR16_T=1\n  else\n    GNULIBHEADERS_OVERRIDE_CHAR16_T=0\n  fi\n  AC_SUBST([GNULIBHEADERS_OVERRIDE_CHAR16_T])\n])\nAC_DEFUN_ONCE([gl_TYPE_CHAR32_T],\n[\n  dnl Determine whether gnulib's <uchar.h> would, if present, override char32_t.\n  AC_CACHE_CHECK([whether char32_t is correctly defined],\n    [gl_cv_type_char32_t_works],\n    [AC_COMPILE_IFELSE(\n       [AC_LANG_PROGRAM([[\n          #ifdef __HAIKU__\n           #include <stdint.h>\n          #endif\n          #include <uchar.h>\n          /* For simplicity, assume that uint32_least_t is equivalent to\n             'unsigned int'.  */\n          int verify[(char32_t)(-1) >= 0 && sizeof (char32_t) == sizeof (unsigned int) ? 1 : -1];\n          ]])\n       ],\n       [gl_cv_type_char32_t_works=yes],\n       [gl_cv_type_char32_t_works=no])\n    ])\n  if test $gl_cv_type_char32_t_works = no; then\n    GNULIBHEADERS_OVERRIDE_CHAR32_T=1\n  else\n    GNULIBHEADERS_OVERRIDE_CHAR32_T=0\n  fi\n  AC_SUBST([GNULIBHEADERS_OVERRIDE_CHAR32_T])\n])\n\n# gl_UCHAR_MODULE_INDICATOR([modulename])\n# sets the shell variable that indicates the presence of the given module\n# to a C preprocessor expression that will evaluate to 1.\n# This macro invocation must not occur in macros that are AC_REQUIREd.\nAC_DEFUN([gl_UCHAR_MODULE_INDICATOR],\n[\n  dnl Ensure to expand the default settings once only.\n  gl_UCHAR_H_REQUIRE_DEFAULTS\n  gl_MODULE_INDICATOR_SET_VARIABLE([$1])\n  dnl Define it also as a C macro, for the benefit of the unit tests.\n  gl_MODULE_INDICATOR_FOR_TESTS([$1])\n])\n\n# Initializes the default values for AC_SUBSTed shell variables.\n# This macro must not be AC_REQUIREd.  It must only be invoked, and only\n# outside of macros or in macros that are not AC_REQUIREd.\nAC_DEFUN([gl_UCHAR_H_REQUIRE_DEFAULTS],\n[\n  m4_defun(GL_MODULE_INDICATOR_PREFIX[_UCHAR_H_MODULE_INDICATOR_DEFAULTS], [\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_BTOC32])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISALNUM])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISALPHA])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISBLANK])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISCNTRL])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISDIGIT])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISGRAPH])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISLOWER])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISPRINT])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISPUNCT])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISSPACE])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISUPPER])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32ISXDIGIT])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32TOLOWER])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32TOUPPER])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32WIDTH])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32RTOMB])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32SNRTOMBS])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32SRTOMBS])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32STOMBS])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32SWIDTH])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32TOB])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32_APPLY_MAPPING])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32_APPLY_TYPE_TEST])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32_GET_MAPPING])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_C32_GET_TYPE_TEST])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_MBRTOC16])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_MBRTOC32])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_MBSNRTOC32S])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_MBSRTOC32S])\n    gl_MODULE_INDICATOR_INIT_VARIABLE([GNULIB_MBSTOC32S])\n  ])\n  m4_require(GL_MODULE_INDICATOR_PREFIX[_UCHAR_H_MODULE_INDICATOR_DEFAULTS])\n  AC_REQUIRE([gl_UCHAR_H_DEFAULTS])\n])\n\nAC_DEFUN([gl_UCHAR_H_DEFAULTS],\n[\n  dnl Assume proper GNU behavior unless another module says otherwise.\n  HAVE_C32RTOMB=1;             AC_SUBST([HAVE_C32RTOMB])\n  HAVE_MBRTOC16=1;             AC_SUBST([HAVE_MBRTOC16])\n  HAVE_MBRTOC32=1;             AC_SUBST([HAVE_MBRTOC32])\n  REPLACE_C32RTOMB=0;          AC_SUBST([REPLACE_C32RTOMB])\n  REPLACE_MBRTOC16=0;          AC_SUBST([REPLACE_MBRTOC16])\n  REPLACE_MBRTOC32=0;          AC_SUBST([REPLACE_MBRTOC32])\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}