{
  "module_name": "wcrtomb.m4",
  "hash_id": "45d1c706b5cb83169151e9a220f0658a8788ebe24bbf23456deb49ffb20382ba",
  "original_prompt": "Ingested from coreutils-9.4/m4/wcrtomb.m4",
  "human_readable_source": "# wcrtomb.m4 serial 19\ndnl Copyright (C) 2008-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_DEFUN([gl_FUNC_WCRTOMB],\n[\n  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])\n\n  AC_REQUIRE([AC_TYPE_MBSTATE_T])\n  gl_MBSTATE_T_BROKEN\n\n  AC_CHECK_FUNCS_ONCE([wcrtomb])\n  if test $ac_cv_func_wcrtomb = no; then\n    HAVE_WCRTOMB=0\n    AC_CHECK_DECLS([wcrtomb],,, [[\n      #include <wchar.h>\n    ]])\n    if test $ac_cv_have_decl_wcrtomb = yes; then\n      dnl On Minix 3.1.8, the system's <wchar.h> declares wcrtomb() although\n      dnl it does not have the function. Avoid a collision with gnulib's\n      dnl replacement.\n      REPLACE_WCRTOMB=1\n    fi\n  else\n    dnl We don't actually need to override wcrtomb when redefining the semantics\n    dnl of the mbstate_t type. Tested on 32-bit AIX.\n    dnl if test $REPLACE_MBSTATE_T = 1; then\n    dnl   REPLACE_WCRTOMB=1\n    dnl fi\n    if test $REPLACE_WCRTOMB = 0; then\n      dnl On Android 4.3, wcrtomb produces wrong characters in the C locale.\n      dnl On AIX 4.3, OSF/1 5.1 and Solaris <= 11.3, wcrtomb (NULL, 0, NULL)\n      dnl sometimes returns 0 instead of 1.\n      AC_REQUIRE([AC_PROG_CC])\n      AC_REQUIRE([gt_LOCALE_FR])\n      AC_REQUIRE([gt_LOCALE_FR_UTF8])\n      AC_REQUIRE([gt_LOCALE_JA])\n      AC_REQUIRE([gt_LOCALE_ZH_CN])\n      AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n      AC_CACHE_CHECK([whether wcrtomb works in the C locale],\n        [gl_cv_func_wcrtomb_works],\n        [AC_RUN_IFELSE(\n           [AC_LANG_SOURCE([[\n#include <string.h>\n#include <stdlib.h>\n#include <wchar.h>\nint main ()\n{\n  mbstate_t state;\n  char out[64];\n  int count;\n  memset (&state, 0, sizeof (state));\n  out[0] = 'x';\n  count = wcrtomb (out, L'a', &state);\n  return !(count == 1 && out[0] == 'a');\n}]])],\n           [gl_cv_func_wcrtomb_works=yes],\n           [gl_cv_func_wcrtomb_works=no],\n           [case \"$host_os\" in\n                               # Guess no on Android.\n              linux*-android*) gl_cv_func_wcrtomb_works=\"guessing no\";;\n                               # Guess yes otherwise.\n              *)               gl_cv_func_wcrtomb_works=\"guessing yes\";;\n            esac\n           ])\n        ])\n      case \"$gl_cv_func_wcrtomb_works\" in\n        *yes) ;;\n        *) AC_DEFINE([WCRTOMB_C_LOCALE_BUG], [1],\n             [Define if the wcrtomb function does not work in the C locale.])\n           REPLACE_WCRTOMB=1 ;;\n      esac\n    fi\n    if test $REPLACE_WCRTOMB = 0; then\n      AC_CACHE_CHECK([whether wcrtomb return value is correct],\n        [gl_cv_func_wcrtomb_retval],\n        [\n          dnl Initial guess, used when cross-compiling or when no suitable locale\n          dnl is present.\nchangequote(,)dnl\n          case \"$host_os\" in\n            # Guess no on AIX 4, OSF/1, Solaris, native Windows.\n            aix4* | osf* | solaris* | mingw* | windows*)\n              gl_cv_func_wcrtomb_retval=\"guessing no\" ;;\n            # Guess yes otherwise.\n            *)\n              gl_cv_func_wcrtomb_retval=\"guessing yes\" ;;\n          esac\nchangequote([,])dnl\n          if test $LOCALE_FR != none || test $LOCALE_FR_UTF8 != none || test $LOCALE_JA != none || test $LOCALE_ZH_CN != none; then\n            AC_RUN_IFELSE(\n              [AC_LANG_SOURCE([[\n#include <locale.h>\n#include <string.h>\n#include <wchar.h>\n#include <stdlib.h>\nint main ()\n{\n  int result = 0;\n  if (strcmp (\"$LOCALE_FR\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_FR\") != NULL)\n    {\n      if (wcrtomb (NULL, 0, NULL) != 1)\n        result |= 1;\n    }\n  if (strcmp (\"$LOCALE_FR_UTF8\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_FR_UTF8\") != NULL)\n    {\n      if (wcrtomb (NULL, 0, NULL) != 1)\n        result |= 2;\n      {\n        wchar_t wc = (wchar_t) 0xBADFACE;\n        if (mbtowc (&wc, \"\\303\\274\", 2) == 2)\n          if (wcrtomb (NULL, wc, NULL) != 1)\n            result |= 2;\n      }\n    }\n  if (strcmp (\"$LOCALE_JA\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_JA\") != NULL)\n    {\n      if (wcrtomb (NULL, 0, NULL) != 1)\n        result |= 4;\n    }\n  if (strcmp (\"$LOCALE_ZH_CN\", \"none\") != 0\n      && setlocale (LC_ALL, \"$LOCALE_ZH_CN\") != NULL)\n    {\n      if (wcrtomb (NULL, 0, NULL) != 1)\n        result |= 8;\n    }\n  return result;\n}]])],\n              [gl_cv_func_wcrtomb_retval=yes],\n              [gl_cv_func_wcrtomb_retval=no],\n              [:])\n          fi\n        ])\n      case \"$gl_cv_func_wcrtomb_retval\" in\n        *yes) ;;\n        *) AC_DEFINE([WCRTOMB_RETVAL_BUG], [1],\n             [Define if the wcrtomb function has an incorrect return value.])\n           REPLACE_WCRTOMB=1 ;;\n      esac\n    fi\n  fi\n])\n\n# Prerequisites of lib/wcrtomb.c.\nAC_DEFUN([gl_PREREQ_WCRTOMB], [\n  :\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}