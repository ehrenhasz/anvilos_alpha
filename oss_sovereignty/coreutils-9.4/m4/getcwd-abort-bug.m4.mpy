{
  "module_name": "getcwd-abort-bug.m4",
  "hash_id": "68c3178e9498a40534781aa3b6f1fcbdb33e6a20384bcba9a9ac68259918edbf",
  "original_prompt": "Ingested from coreutils-9.4/m4/getcwd-abort-bug.m4",
  "human_readable_source": "# serial 16\n# Determine whether getcwd aborts when the length of the working directory\n# name is unusually large.  Any length between 4k and 16k trigger the bug\n# when using glibc-2.4.90-9 or older.\n\n# Copyright (C) 2006, 2009-2023 Free Software Foundation, Inc.\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# From Jim Meyering\n\n# gl_FUNC_GETCWD_ABORT_BUG([ACTION-IF-BUGGY[, ACTION-IF-WORKS]])\nAC_DEFUN([gl_FUNC_GETCWD_ABORT_BUG],\n[\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n  AC_CHECK_DECLS_ONCE([getcwd])\n  AC_CHECK_HEADERS_ONCE([unistd.h])\n  AC_REQUIRE([gl_PATHMAX_SNIPPET_PREREQ])\n\n  gl_CHECK_FUNC_GETPAGESIZE\n  if test $gl_cv_func_getpagesize = yes; then\n    AC_DEFINE_UNQUOTED([HAVE_GETPAGESIZE], [1],\n      [Define to 1 if the system has the 'getpagesize' function.])\n  fi\n\n  AC_CACHE_CHECK([whether getcwd succeeds when 4k < cwd_length < 16k],\n    [gl_cv_func_getcwd_succeeds_beyond_4k],\n    [# Remove any remnants of a previous test.\n     rm -rf confdir-14B---\n     # Arrange for deletion of the temporary directory this test creates.\n     ac_clean_files=\"$ac_clean_files confdir-14B---\"\n     dnl Please keep this in sync with tests/test-getcwd.c.\n     AC_RUN_IFELSE(\n       [AC_LANG_SOURCE(\n          [[\n#include <errno.h>\n#include <stdlib.h>\n#if HAVE_UNISTD_H\n# include <unistd.h>\n#else /* on Windows with MSVC */\n# include <direct.h>\n#endif\n#include <string.h>\n#include <sys/stat.h>\n\n]gl_PATHMAX_SNIPPET[\n]GL_MDA_DEFINES[\n\n#ifndef S_IRWXU\n# define S_IRWXU 0700\n#endif\n\n/* FIXME: skip the run-test altogether on systems without getpagesize.  */\n#if ! HAVE_GETPAGESIZE\n# define getpagesize() 0\n#endif\n\n/* This size is chosen to be larger than PATH_MAX (4k), yet smaller than\n   the 16kB pagesize on ia64 linux.  Those conditions make the code below\n   trigger a bug in glibc's getcwd implementation before 2.4.90-10.  */\n#define TARGET_LEN (5 * 1024)\n\nint\nmain ()\n{\n  char *cwd;\n  size_t initial_cwd_len;\n  int fail = 0;\n\n  /* The bug is triggered when PATH_MAX < getpagesize (), so skip\n     this relatively expensive and invasive test if that's not true.  */\n#ifdef PATH_MAX\n  int bug_possible = PATH_MAX < getpagesize ();\n#else\n  int bug_possible = 0;\n#endif\n  if (! bug_possible)\n    return 0;\n\n  cwd = getcwd (NULL, 0);\n  if (cwd == NULL)\n    return 2;\n\n  initial_cwd_len = strlen (cwd);\n  free (cwd);\n\n  if (1)\n    {\n      static char const dir_name[] = \"confdir-14B---\";\n      size_t desired_depth = ((TARGET_LEN - 1 - initial_cwd_len)\n                              / sizeof dir_name);\n      size_t d;\n      for (d = 0; d < desired_depth; d++)\n        {\n          if (mkdir (dir_name, S_IRWXU) < 0 || chdir (dir_name) < 0)\n            {\n              if (! (errno == ERANGE || errno == ENAMETOOLONG\n                     || errno == ENOENT))\n                fail = 3; /* Unable to construct deep hierarchy.  */\n              break;\n            }\n        }\n\n      /* If libc has the bug in question, this invocation of getcwd\n         results in a failed assertion.  */\n      cwd = getcwd (NULL, 0);\n      if (cwd == NULL)\n        fail = 4; /* getcwd didn't assert, but it failed for a long name\n                     where the answer could have been learned.  */\n      free (cwd);\n\n      /* Call rmdir first, in case the above chdir failed.  */\n      rmdir (dir_name);\n      while (0 < d--)\n        {\n          if (chdir (\"..\") < 0)\n            {\n              fail = 5;\n              break;\n            }\n          rmdir (dir_name);\n        }\n    }\n\n  return fail;\n}\n          ]])],\n       [gl_cv_func_getcwd_succeeds_beyond_4k=yes],\n       [dnl An abort will provoke an exit code of something like 134 (128 + 6).\n        dnl An exit code of 4 can also occur (for example in\n        dnl musl libc 1.2.2/powerpc64le, NetBSD 9.0, OpenBSD 6.7:\n        dnl getcwd (NULL, 0) fails rather than returning a string longer than\n        dnl PATH_MAX.  This may be POSIX compliant (in some interpretations of\n        dnl POSIX).  But gnulib's getcwd module wants to provide a non-NULL\n        dnl value in this case.\n        ret=$?\n        if test $ret -ge 128 || test $ret = 4; then\n          gl_cv_func_getcwd_succeeds_beyond_4k=no\n        else\n          gl_cv_func_getcwd_succeeds_beyond_4k=yes\n        fi\n       ],\n       [case \"$host_os\" in\n             # Guess no otherwise, even on glibc systems and musl systems.\n          *) gl_cv_func_getcwd_succeeds_beyond_4k=\"guessing no\"\n        esac\n       ])\n    ])\n  case \"$gl_cv_func_getcwd_succeeds_beyond_4k\" in\n    *no)\n      $1\n      ;;\n    *)\n      $2\n      ;;\n  esac\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}