{
  "module_name": "errno_h.m4",
  "hash_id": "af365da56779ed7751793af2afb659754a6300e284ce3455ce2f110d07685758",
  "original_prompt": "Ingested from coreutils-9.4/m4/errno_h.m4",
  "human_readable_source": "# errno_h.m4 serial 14\ndnl Copyright (C) 2004, 2006, 2008-2023 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\nAC_PREREQ([2.61])\n\nAC_DEFUN_ONCE([gl_HEADER_ERRNO_H],\n[\n  AC_REQUIRE([AC_PROG_CC])\n  AC_CACHE_CHECK([for complete errno.h], [gl_cv_header_errno_h_complete], [\n    AC_EGREP_CPP([booboo],[\n#include <errno.h>\n#if !defined ETXTBSY\nbooboo\n#endif\n#if !defined ENOMSG\nbooboo\n#endif\n#if !defined EIDRM\nbooboo\n#endif\n#if !defined ENOLINK\nbooboo\n#endif\n#if !defined EPROTO\nbooboo\n#endif\n#if !defined EMULTIHOP\nbooboo\n#endif\n#if !defined EBADMSG\nbooboo\n#endif\n#if !defined EOVERFLOW\nbooboo\n#endif\n#if !defined ENOTSUP\nbooboo\n#endif\n#if !defined ENETRESET\nbooboo\n#endif\n#if !defined ECONNABORTED\nbooboo\n#endif\n#if !defined ESTALE\nbooboo\n#endif\n#if !defined EDQUOT\nbooboo\n#endif\n#if !defined ECANCELED\nbooboo\n#endif\n#if !defined EOWNERDEAD\nbooboo\n#endif\n#if !defined ENOTRECOVERABLE\nbooboo\n#endif\n#if !defined EILSEQ\nbooboo\n#endif\n      ],\n      [gl_cv_header_errno_h_complete=no],\n      [gl_cv_header_errno_h_complete=yes])\n  ])\n  if test $gl_cv_header_errno_h_complete = yes; then\n    GL_GENERATE_ERRNO_H=false\n  else\n    gl_NEXT_HEADERS([errno.h])\n    GL_GENERATE_ERRNO_H=true\n  fi\n  gl_REPLACE_ERRNO_VALUE([EMULTIHOP])\n  gl_REPLACE_ERRNO_VALUE([ENOLINK])\n  gl_REPLACE_ERRNO_VALUE([EOVERFLOW])\n])\n\n# Assuming $1 = EOVERFLOW.\n# The EOVERFLOW errno value ought to be defined in <errno.h>, according to\n# POSIX.  But some systems (like OpenBSD 4.0 or AIX 3) don't define it, and\n# some systems (like OSF/1) define it when _XOPEN_SOURCE_EXTENDED is defined.\n# Check for the value of EOVERFLOW.\n# Set the variables EOVERFLOW_HIDDEN and EOVERFLOW_VALUE.\nAC_DEFUN([gl_REPLACE_ERRNO_VALUE],\n[\n  if $GL_GENERATE_ERRNO_H; then\n    AC_CACHE_CHECK([for ]$1[ value], [gl_cv_header_errno_h_]$1, [\n      AC_EGREP_CPP([yes],[\n#include <errno.h>\n#ifdef ]$1[\nyes\n#endif\n      ],\n      [gl_cv_header_errno_h_]$1[=yes],\n      [gl_cv_header_errno_h_]$1[=no])\n      if test $gl_cv_header_errno_h_]$1[ = no; then\n        AC_EGREP_CPP([yes],[\n#define _XOPEN_SOURCE_EXTENDED 1\n#include <errno.h>\n#ifdef ]$1[\nyes\n#endif\n          ], [gl_cv_header_errno_h_]$1[=hidden])\n        if test $gl_cv_header_errno_h_]$1[ = hidden; then\n          dnl The macro exists but is hidden.\n          dnl Define it to the same value.\n          AC_COMPUTE_INT([gl_cv_header_errno_h_]$1, $1, [\n#define _XOPEN_SOURCE_EXTENDED 1\n#include <errno.h>\n/* The following two lines are a workaround against an autoconf-2.52 bug.  */\n#include <stdio.h>\n#include <stdlib.h>\n])\n        fi\n      fi\n    ])\n    case $gl_cv_header_errno_h_]$1[ in\n      yes | no)\n        ]$1[_HIDDEN=0; ]$1[_VALUE=\n        ;;\n      *)\n        ]$1[_HIDDEN=1; ]$1[_VALUE=\"$gl_cv_header_errno_h_]$1[\"\n        ;;\n    esac\n    AC_SUBST($1[_HIDDEN])\n    AC_SUBST($1[_VALUE])\n  fi\n])\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}