{
  "module_name": "init.cfg",
  "hash_id": "5637d0127f030a8e9b5f5b45008241c797249152a224d0c5b3e3082218e08351",
  "original_prompt": "Ingested from coreutils-9.4/init.cfg",
  "human_readable_source": "# This file is sourced by init.sh, *before* its initialization.\n\n# Copyright (C) 2010-2023 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n# This goes hand in hand with the \"exec 9>&2;\" in tests/Makefile.am's\n# TESTS_ENVIRONMENT definition.\nstderr_fileno_=9\n\n# Having an unsearchable directory in PATH causes execve to fail with EACCES\n# when applied to an unresolvable program name, contrary to the desired ENOENT.\n# Avoid the problem by rewriting PATH to exclude unsearchable directories.\n# Also, if PATH lacks /sbin and/or /usr/sbin, append it/them.\nsanitize_path_()\n{\n  # FIXME: remove double quotes around $IFS when all tests use init.sh.\n  # They constitute a work-around for a bug in FreeBSD 8.1's /bin/sh.\n  local saved_IFS=\"$IFS\"\n    IFS=:\n    set -- $PATH\n  IFS=$saved_IFS\n\n  local d d1\n  local colon=\n  local new_path=\n  for d in \"$@\"; do\n    test -z \"$d\" && d1=. || d1=$d\n    if ls -d \"$d1/.\" > /dev/null 2>&1; then\n      new_path=\"$new_path$colon$d\"\n      colon=':'\n    fi\n  done\n\n  for d in /sbin /usr/sbin ; do\n    case \":$new_path:\" in\n      *:$d:*) ;;\n      *) new_path=\"$new_path:$d\" ;;\n    esac\n  done\n\n  PATH=$new_path\n  export PATH\n}\n\ngetlimits_()\n{\n  eval $(getlimits)\n  test \"$INT_MAX\" || fatal_ \"running getlimits\"\n}\n\nrequire_no_default_acl_()\n{\n  if getfacl --version < /dev/null > /dev/null 2>&1; then\n    getfacl \"$1\" | grep '^default:' && skip_ 'Default ACL detected'\n  else\n    ls -ld \"$1\" | grep '.........+' && skip_ 'ACL detected'\n  fi\n}\n\nrequire_acl_()\n{\n  getfacl --version < /dev/null > /dev/null 2>&1 \\\n    && setfacl --version < /dev/null > /dev/null 2>&1 \\\n      || skip_ \"This test requires getfacl and setfacl.\"\n\n  id -u bin > /dev/null 2>&1 \\\n    || skip_ \"This test requires a local user named bin.\"\n}\n\nis_local_dir_()\n{\n  test $# = 1 || framework_failure_\n  df --local \"$1\" >/dev/null 2>&1\n}\n\nrequire_mount_list_()\n{\n  local mount_list_fail='cannot read table of mounted file systems'\n  df --local 2>&1 | grep -F \"$mount_list_fail\" >/dev/null &&\n    skip_ \"$mount_list_fail\"\n}\n\ndump_mount_list_()\n{\n  cat /proc/self/mountinfo ||\n  cat /proc/self/mounts ||\n  cat /proc/mounts ||\n  cat /etc/mtab\n}\n\nrequire_local_dir_()\n{\n  require_mount_list_\n  is_local_dir_ . ||\n    skip_ \"This test must be run on a local file system.\"\n}\n\nrequire_selinux_()\n{\n  # When in a chroot of an SELinux-enabled system, but with a mock-simulated\n  # SELinux-*disabled* system, recognize that SELinux is disabled system wide:\n  grep 'selinuxfs$' /proc/filesystems > /dev/null \\\n    || skip_ \"this system lacks SELinux support\"\n\n  # Independent of whether SELinux is enabled system-wide,\n  # the current file system may lack SELinux support.\n  # Also the current build may have SELinux support disabled.\n  case $(ls -Zd .) in\n    '? .'|'unlabeled .')\n      test -z \"$CONFIG_HEADER\" \\\n        && framework_failure_ 'CONFIG_HEADER not defined'\n      grep '^#define HAVE_SELINUX_SELINUX_H 1' \"$CONFIG_HEADER\" > /dev/null \\\n        && selinux_missing_=\"(file) system\" || selinux_missing_=\"build\"\n      skip_ \"this $selinux_missing_ lacks SELinux support\"\n    ;;\n  esac\n}\n\n# Return the SELinux type component if available\nget_selinux_type() { ls -Zd \"$1\" | sed -n 's/.*:\\(.*_t\\)[: ].*/\\1/p'; }\n\n# Whether SELinux Multi Level Security is enabled\nmls_enabled_() {\n  sestatus 2>&1 |\n  grep 'Policy MLS status:.*enabled' > /dev/null\n}\n\n# Skip this test if we're not in SELinux \"enforcing\" mode.\nrequire_selinux_enforcing_()\n{\n  require_selinux_\n  test \"$(getenforce)\" = Enforcing \\\n    || skip_ \"This test is useful only with SELinux in Enforcing mode.\"\n}\n\nrequire_smack_()\n{\n  grep 'smackfs$' /proc/filesystems > /dev/null \\\n    || skip_ \"this system lacks SMACK support\"\n\n  test \"$(ls -Zd .)\" != '? .' \\\n    || skip_ \"this file system lacks SMACK support\"\n}\n\nrequire_openat_support_()\n{\n  # Skip this test if your system has neither the openat-style functions\n  # nor /proc/self/fd support with which to emulate them.\n\n  test -z \"$CONFIG_HEADER\" \\\n    && framework_failure_ 'CONFIG_HEADER not defined'\n\n  _skip=yes\n  grep '^#define HAVE_OPENAT' \"$CONFIG_HEADER\" > /dev/null && _skip=no\n  test -d /proc/self/fd && _skip=no\n  if test $_skip = yes; then\n    skip_ 'this system lacks openat support'\n  fi\n}\n\n# Return true if command runs with the\n# ulimit specified in the first argument\nulimit_supported_()\n{\n  local v\n  v=\"$1\"\n  shift\n\n  (\n    # Try to disable core dumps which may\n    # occur with memory constraints\n    trap '' SEGV; ulimit -c 0;\n\n    ulimit -v $v && \"$@\"\n  ) >/dev/null 2>&1\n}\n\n# Determine the minimum required VM limit to run the given command.\n# Output that value to stdout ... to be used by the caller.\n# Return 0 in case of success, and a non-Zero value otherwise.\nget_min_ulimit_v_()\n{\n  local v\n  local page_size\n\n  # Increase result by this amount to avoid alignment issues\n  page_size=$(getconf PAGESIZE || echo 4096)\n  page_size=$(($page_size / 1024))\n\n  for v in $( seq 5000 5000 50000 ); do\n    if ulimit_supported_ $v \"$@\"; then\n      local prev_v\n      prev_v=$v\n      for v in $( seq $(($prev_v-1000)) -1000 1000 ); do\n        ulimit_supported_ $v \"$@\" ||\n          {\n            ret_v=$((prev_v + $page_size))\n            echo $ret_v\n            return 0\n          }\n        prev_v=$v\n      done\n    fi\n  done\n  # The above did not find a working limit.  Echo a very small number - just\n  # in case the caller does not handle the non-Zero return value.\n  echo 1; return 1\n}\n\nrequire_readable_root_()\n{\n  test -r / || skip_ \"/ is not readable\"\n}\n\n# Skip the current test if strace is not available or doesn't work\n# with the named syscall.  Usage: require_strace_ unlink\nrequire_strace_()\n{\n  test $# = 1 || framework_failure_\n\n  strace -V < /dev/null > /dev/null 2>&1 ||\n    skip_ 'no strace program'\n\n  strace -qe \"$1\" echo > /dev/null 2>&1 ||\n    skip_ 'strace -qe \"'\"$1\"'\" does not work'\n\n  # On some linux/sparc64 systems, strace works fine on 32-bit executables,\n  # but prints only one line of output for every 64-bit executable.\n  strace -o log-help ls --help >/dev/null || framework_failure_\n  n_lines_help=$(wc -l < log-help)\n  rm -f log-help\n  if test $n_lines_help = 0 || test $n_lines_help = 1; then\n    skip_ 'strace produces no more than one line of output'\n  fi\n}\n\n# Skip the current test if valgrind doesn't work,\n# which could happen if not installed,\n# or hasn't support for the built architecture,\n# or hasn't appropriate error suppressions installed etc.\nrequire_valgrind_()\n{\n  valgrind --error-exitcode=1 true 2>/dev/null ||\n    skip_ \"requires a working valgrind\"\n}\n\n# Skip the current test if setfacl doesn't work on the current file system,\n# which could happen if not installed, or if ACLs are not supported by the\n# kernel or the file system, or are turned off via mount options.\n#\n# Work around the following two issues:\n#\n# 1) setfacl maps ACLs into file permission bits if on \"noacl\" file systems.\n#\n# On file systems which do not support ACLs (e.g. ext4 mounted with -o noacl),\n# setfacl operates on the regular file permission bits, and only fails if the\n# given ACL spec does not fit into there.  Thus, to test if ACLs really work\n# on the current file system, pass an ACL spec which can't be mapped that way.\n# \"Default\" ACLs (-d) seem to fulfill this requirement.\n#\n# 2) setfacl only invokes the underlying system call if the ACL would change.\n#\n# If the given ACL spec would not change the ACLs on the file, then setfacl\n# does not invoke the underlying system call - setxattr().  Therefore, to test\n# if setting ACLs really works on the current file system, call setfacl twice\n# with conflicting ACL specs.\nrequire_setfacl_()\n{\n  local d='acltestdir_'\n  mkdir $d || framework_failure_\n  local f=0\n\n  setfacl -d -m user::r-x $d \\\n    && setfacl -d -m user::rwx $d \\\n    || f=1\n  rm -rf $d || framework_failure_\n  test $f = 0 \\\n    || skip_ \"setfacl does not work on the current file system\"\n}\n\n# Require a controlling input 'terminal'.\nrequire_controlling_input_terminal_()\n{\n  have_input_tty=yes\n  tty -s || have_input_tty=no\n  test -t 0 || have_input_tty=no\n  if test \"$have_input_tty\" = no; then\n    skip_ 'requires controlling input terminal\nThis test must have a controlling input \"terminal\", so it may not be\nrun via \"batch\", \"at\", or \"ssh\".  On some systems, it may not even be\nrun in the background.'\n  fi\n}\n\nrequire_built_()\n{\n  skip_=no\n  for i in \"$@\"; do\n    case \" $built_programs \" in\n      *\" $i \"*) ;;\n      *) echo \"$i: not built\" 1>&2; skip_=yes ;;\n    esac\n  done\n\n  test $skip_ = yes && skip_ \"required program(s) not built\"\n}\n\nrequire_file_system_bytes_free_()\n{\n  local req=$1\n  local expr=$(stat -f --printf \"$req / %S <= %a\" .)\n  $AWK \"BEGIN{ exit !($expr) }\" \\\n    || skip_ \"this test needs at least $req bytes of free space\"\n}\n\nuid_is_privileged_()\n{\n  # Make sure id -u succeeds.\n  my_uid=$(id -u) \\\n    || { echo \"$0: cannot run 'id -u'\" 1>&2; return 1; }\n\n  # Make sure it gives valid output.\n  case $my_uid in\n    0) ;;\n    *[!0-9]*)\n      echo \"$0: invalid output ('$my_uid') from 'id -u'\" 1>&2\n      return 1 ;;\n    *) return 1 ;;\n  esac\n}\n\nget_process_status_()\n{\n  sed -n '/^State:[\t ]*\\([[:alpha:]]\\).*/s//\\1/p' /proc/$1/status\n}\n\n# Convert an ls-style permission string, like drwxr----x and -rw-r-x-wx\n# to the equivalent chmod --mode (-m) argument, (=,u=rwx,g=r,o=x and\n# =,u=rw,g=rx,o=wx).  Ignore ACLs.\nrwx_to_mode_()\n{\n  case $# in\n    1) rwx=$1;;\n    *) echo \"$0: wrong number of arguments\" 1>&2\n      echo \"Usage: $0 ls-style-mode-string\" 1>&2\n      return;;\n  esac\n\n  case $rwx in\n    [ld-][rwx-][rwx-][rwxsS-][rwx-][rwx-][rwxsS-][rwx-][rwx-][rwxtT-]) ;;\n    [ld-][rwx-][rwx-][rwxsS-][rwx-][rwx-][rwxsS-][rwx-][rwx-][rwxtT-][+.]) ;;\n    *) echo \"$0: invalid mode string: $rwx\" 1>&2; return;;\n  esac\n\n  # Perform these conversions:\n  # S  s\n  # s  xs\n  # T  t\n  # t  xt\n  # The 'T' and 't' ones are only valid for 'other'.\n  s='s/S/@/;s/s/x@/;s/@/s/'\n  t='s/T/@/;s/t/x@/;s/@/t/'\n\n  u=$(echo $rwx|sed 's/^.\\(...\\).*/,u=\\1/;s/-//g;s/^,u=$//;'$s)\n  g=$(echo $rwx|sed 's/^....\\(...\\).*/,g=\\1/;s/-//g;s/^,g=$//;'$s)\n  o=$(echo $rwx|sed 's/^.......\\(...\\).*/,o=\\1/;s/-//g;s/^,o=$//;'$s';'$t)\n  echo \"=$u$g$o\"\n}\n\n# Set the global variable stty_reversible_ to a space-separated list of the\n# reversible settings from stty.c.  stty_reversible_ also starts and ends\n# with a space.\nstty_reversible_init_()\n{\n  require_perl_\n  # Pad start with one space for the first option to match in query function.\n  stty_reversible_=' '$(perl -lne '/^ *{\"(.*?)\",.*\\bREV\\b/ and print $1' \\\n    \"$abs_top_srcdir\"/src/stty.c | tr '\\n' ' ')\n  # Ensure that there are at least 62, i.e., so we're alerted if\n  # reformatting the source empties the list.\n  test 62 -le $(echo \"$stty_reversible_\"|wc -w)  \\\n    || framework_failure_ \"too few reversible settings\"\n}\n\n# Test whether $1 is one of stty's reversible options.\nstty_reversible_query_()\n{\n  case $stty_reversible_ in\n    '')\n      framework_failure_ \"stty_reversible_init_() not called?\";;\n    *\" $1 \"*)\n      return 0;;\n    *)\n      return 1;;\n  esac\n}\n\nskip_if_()\n{\n  case $1 in\n    root) skip_ must be run as root ;;\n    non-root) skip_ must be run as non-root ;;\n    *) ;;  # FIXME?\n  esac\n}\n\nvery_expensive_()\n{\n  if test \"$RUN_VERY_EXPENSIVE_TESTS\" != yes; then\n    skip_ 'very expensive: disabled by default\nThis test is very expensive, so it is disabled by default.\nTo run it anyway, rerun make check with the RUN_VERY_EXPENSIVE_TESTS\nenvironment variable set to yes.  E.g.,\n\n  env RUN_VERY_EXPENSIVE_TESTS=yes make check\n\nor use the shortcut target of the toplevel Makefile,\n\n  make check-very-expensive\n'\n  fi\n}\n\nexpensive_()\n{\n  if test \"$RUN_EXPENSIVE_TESTS\" != yes; then\n    skip_ 'expensive: disabled by default\nThis test is relatively expensive, so it is disabled by default.\nTo run it anyway, rerun make check with the RUN_EXPENSIVE_TESTS\nenvironment variable set to yes.  E.g.,\n\n  env RUN_EXPENSIVE_TESTS=yes make check\n\nor use the shortcut target of the toplevel Makefile,\n\n  make check-expensive\n'\n  fi\n}\n\n# Test whether we can run our just-built root owned rm,\n# i.e., that $NON_ROOT_USERNAME has access to the build directory.\nnonroot_has_perm_()\n{\n  require_built_ chroot\n\n  local rm_version=$(\n    chroot --skip-chdir --user=$NON_ROOT_USERNAME / env PATH=\"$PATH\" \\\n      rm --version |\n    sed -n '1s/.* //p'\n  )\n  case \":$rm_version:\" in\n      :$PACKAGE_VERSION:) ;;\n      *) return 1;;\n  esac\n}\n\nrequire_root_()\n{\n  uid_is_privileged_ || skip_ \"must be run as root\"\n  NON_ROOT_USERNAME=${NON_ROOT_USERNAME=nobody}\n  NON_ROOT_GID=${NON_ROOT_GID=$(id -g $NON_ROOT_USERNAME)}\n\n  # When the current test invokes chroot, call nonroot_has_perm_\n  # to check for a common problem.\n  grep '^[ ]*chroot' \"../$0\" \\\n    && { nonroot_has_perm_ \\\n           || skip_ \"user $NON_ROOT_USERNAME lacks execute permissions\"; }\n}\n\nskip_if_root_() { uid_is_privileged_ && skip_ \"must be run as non-root\"; }\n\n# Set 'groups' to a space-separated list of at least two groups\n# of which the user is a member.\nrequire_membership_in_two_groups_()\n{\n  test $# = 0 || framework_failure_\n\n  groups=\n  for group_ in 1 \\\n    ${COREUTILS_GROUPS-$( (id -G || /usr/xpg4/bin/id -G) 2>/dev/null)}\n  do\n    # Skip group numbers equal to 2**N - 1 for common N,\n    # as they are possibly reserved groups like 'nogroup'.\n    case $group_ in\n      1 | 32767 | 65535 | 2147483647 | 4294967295) ;;\n      9223372036854775807 | 18446744073709551615) ;;\n      *) test -z \"$groups\" || groups=\"$groups \"\n         groups=\"$groups$group_\";;\n    esac\n  done\n  case \"$groups\" in\n    *' '*) ;;\n    *) skip_ 'requires membership in two groups\nthis test requires that you be a member of more than one group,\nbut running '\\''id -G'\\'' either failed or found just one.  If you really\nare a member of at least two groups, then rerun this test with\nCOREUTILS_GROUPS set in your environment to the space-separated list\nof group names or numbers.  E.g.,\n\n  env COREUTILS_GROUPS='\\''users cdrom'\\'' make check\n\n'\n     ;;\n  esac\n}\n\n# Is /proc/$PID/status supported?\nrequire_proc_pid_status_()\n{\n    sleep 2 &\n    local pid=$!\n    sleep .5\n    grep '^State:[\t ]*[S]' /proc/$pid/status > /dev/null 2>&1 ||\n    skip_ \"/proc/$pid/status: missing or 'different'\"\n    kill $pid\n}\n\n# Does trap support signal names?\n# Old versions of ash did not.\nrequire_trap_signame_()\n{\n    (trap '' CHLD) || skip_ 'requires trap with signal name support'\n}\n\n# Does kill support sending signal to whole group?\n# dash 0.5.8 at least does not.\nrequire_kill_group_()\n{\n    kill -0 -- -1 || skip_ 'requires kill with group signaling support'\n}\n\n# Return nonzero if the specified path is on a file system for\n# which SEEK_DATA support exists.\nseek_data_capable_()\n{\n  # Check that SEEK_HOLE support is enabled\n  # Note APFS was seen to not create sparse files < 16MiB\n  if ! truncate -s16M file.sparse_; then\n      warn_ \"can't create a sparse file: assuming not SEEK_DATA capable\"\n      return 1\n  fi\n  if ! cp --debug --reflink=never file.sparse_ file.sparse_.cp \\\n       | grep SEEK_HOLE; then\n      return 1\n  fi\n\n  # Check that SEEK_HOLE is supported on the passed file\n  { python3 < /dev/null && PYTHON_=python3; } ||\n  { python  < /dev/null && PYTHON_=python; }\n\n  if test x\"$PYTHON_\" = x; then\n      warn_ 'seek_data_capable_: python missing: assuming not SEEK_DATA capable'\n      return 1\n  fi\n\n  # Use timeout if available to skip cases where SEEK_DATA takes a long time.\n  # We saw FreeBSD 9.1 take 35s to return from SEEK_DATA for a 1TiB empty file.\n  # Note lseek() is uninterruptible on FreeBSD 9.1, but it does eventually\n  # return, and the timeout will ensure a failure return from the process.\n  timeout --version >/dev/null && TIMEOUT_='timeout 10'\n\n  $TIMEOUT_ $PYTHON_ \"$abs_srcdir\"/tests/seek-data-capable \"$@\"\n}\n\n# Skip the current test if \".\" lacks d_type support.\nrequire_dirent_d_type_()\n{\n  python < /dev/null \\\n    || skip_ python missing: assuming no d_type support\n\n  python \"$abs_srcdir\"/tests/d_type-check \\\n    || skip_ requires d_type support\n}\n\n# Skip the current test if we lack Perl.\nrequire_perl_()\n{\n  : ${PERL=perl}\n  $PERL -e 'use warnings' > /dev/null 2>&1 \\\n    || skip_ 'configure did not find a usable version of Perl'\n}\n\n# Does the current (working-dir) file system support sparse files?\nrequire_sparse_support_()\n{\n  test $# = 0 || framework_failure_\n  # Test whether we can create a sparse file.\n  # For example, on Darwin6.5 with a file system of type hfs, it's not possible.\n  # NTFS requires 128K before a hole appears in a sparse file.\n  t=sparse.$$\n  dd bs=1 seek=128K of=$t < /dev/null 2> /dev/null\n  set x $(du -sk $t)\n  kb_size=$2\n  rm -f $t\n  if test $kb_size -ge 128; then\n    skip_ 'this file system does not support sparse files'\n  fi\n}\n\n# Libraries needed when we compile a shared library.\ngcc_shared_libs_=\n\n# Compile a shared lib using the GCC options for doing so.\n# Pass input and output file as parameters respectively.\n# Any other optional parameters are passed to $CC.\ngcc_shared_()\n{\n  local in=$1\n  local out=$2\n  shift 2 || return 1\n\n  $CC -Wall -shared --std=gnu99 -fPIC -O2 $* \"$in\" -o \"$out\" $gcc_shared_libs_\n}\n\n# There are a myriad of ways to build shared libs,\n# so we only consider running tests requiring shared libs,\n# on platforms that support building them as follows.\nrequire_gcc_shared_()\n{\n  # Try two different values for gcc_shared_libs_.\n  gcc_shared_libs_='-ldl'\n  if gcc_shared_ '-' 'd.so' -xc < /dev/null 2>&1; then\n    :\n  else\n    gcc_shared_libs_=\n    if gcc_shared_ '-' 'd.so' -xc < /dev/null 2>&1; then\n      :\n    else\n      skip_ '$CC -shared ... failed to build a shared lib'\n    fi\n  fi\n  rm -f d.so\n}\n\nmkfifo_or_skip_()\n{\n  test $# = 1 || framework_failure_\n  if ! mkfifo \"$1\"; then\n    # Make an exception of this case -- usually we interpret framework-creation\n    # failure as a test failure.  However, in this case, when running on a SunOS\n    # system using a file system NFS mounted from OpenBSD, the above fails like\n    # this:\n    # mkfifo: cannot make fifo 'fifo-10558': Not owner\n    skip_ 'unable to create a fifo'\n  fi\n}\n\ntrap_sigpipe_or_skip_()\n{\n  timeout --version >/dev/null ||\n    skip_ 'trapping SIGPIPE cannot be safely checked'\n\n  (trap '' PIPE && timeout 10 yes |:) 2>&1 | grep 'Broken pipe' >/dev/null ||\n    skip_ 'trapping SIGPIPE is not supported'\n}\n\nrequire_bash_as_SHELL_()\n{\n  if bash --version >/dev/null 2>&1; then\n    SHELL='bash'\n  else\n    skip_ 'bash is required'\n  fi\n}\n\n# Disable the current test if the working directory seems to have\n# the setgid bit set.\nskip_if_setgid_()\n{\n  setgid_tmpdir=setgid-$$\n  (umask 77; mkdir $setgid_tmpdir)\n  perms=$(stat --printf %A $setgid_tmpdir)\n  rmdir $setgid_tmpdir\n  case $perms in\n    drwx------);;\n    drwxr-xr-x);;  # Windows98 + DJGPP 2.03\n    *) skip_ 'this directory has the setgid bit set';;\n  esac\n}\n\n# Skip if files are created with a different group to the current user\n# This can happen due to a setgid dir, or by some other mechanism on OS X:\n# https://unix.stackexchange.com/q/63865\n# https://bugs.gnu.org/14024#41\nskip_if_nondefault_group_()\n{\n  touch grp.$$\n  gen_ug=$(stat -c '%u:%g' grp.$$)\n  rm grp.$$\n  test \"$gen_ug\" = \"$(id -ru):$(id -rg)\" ||\n    skip_ 'Files are created with a different gid'\n}\n\nskip_if_mcstransd_is_running_()\n{\n  test $# = 0 || framework_failure_\n\n  # When mcstransd is running, you'll see only the 3-component\n  # version of file-system context strings.  Detect that,\n  # and if it's running, skip this test.\n  __ctx=$(stat --printf='%C\\n' .) || framework_failure_\n  case $__ctx in\n    *:*:*:*) __ctx_ok=1 ;; # four components is ok\n    *:*:*)  # three components is ok too if there is no MLS\n        mls_enabled_ || __ctx_ok=1 ;;\n  esac\n\n  test \"$__ctx_ok\" ||\n   skip_ \"unexpected context '$__ctx'; turn off mcstransd\"\n}\n\n# Skip the current test if umask doesn't work as usual.\n# This test should be run in the temporary directory that ends\n# up being removed via the trap commands.\nworking_umask_or_skip_()\n{\n  umask 022\n  touch file1 file2\n  chmod 644 file2\n  perms=$(ls -l file1 file2 | sed 's/ .*//' | uniq)\n  rm -f file1 file2\n\n  case $perms in\n  *'\n  '*) skip_ 'your build directory has unusual umask semantics'\n  esac\n}\n\n# Retry a function requiring a sufficient delay to _pass_\n# using a truncated exponential backoff method.\n#     Example: retry_delay_ dd_reblock_1 .1 6\n# This example will call the dd_reblock_1 function with\n# an initial delay of .1 second and call it at most 6 times\n# with a max delay of 3.2s (doubled each time), or a total of 6.3s\n# Note ensure you do _not_ quote the parameter to GNU sleep in\n# your function, as it may contain separate values that sleep\n# needs to accumulate.\n# Further function arguments will be forwarded to the test function.\nretry_delay_()\n{\n  local test_func=$1\n  local init_delay=$2\n  local max_n_tries=$3\n  shift 3 || return 1\n\n  local attempt=1\n  local num_sleeps=$attempt\n  local time_fail\n  while test $attempt -le $max_n_tries; do\n    local delay=$($AWK -v n=$num_sleeps -v s=\"$init_delay\" \\\n                  'BEGIN { print s * n }')\n    \"$test_func\" \"$delay\" \"$@\" && { time_fail=0; break; } || time_fail=1\n    attempt=$(expr $attempt + 1)\n    num_sleeps=$(expr $num_sleeps '*' 2)\n  done\n  test \"$time_fail\" = 0\n}\n\n# Call this with a list of programs under test immediately after\n# sourcing init.sh.\nprint_ver_()\n{\n  require_built_ \"$@\"\n  if test \"$VERBOSE\" = yes; then\n    local i\n    for i in $*; do\n      env $i --version\n    done\n  fi\n}\n\n# Are we running on GNU/Hurd?\nrequire_gnu_()\n{\n  test \"$(uname)\" = GNU \\\n    || skip_ 'not running on GNU/Hurd'\n}\n\nsanitize_path_\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}