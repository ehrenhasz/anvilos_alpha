{
  "module_name": "announce-gen",
  "hash_id": "02d205a5d73672349dd93d0c8ac13a9f4e71ee5b72a9cc4a0ef49352135dfecd",
  "original_prompt": "Ingested from coreutils-9.4/build-aux/announce-gen",
  "human_readable_source": "#!/bin/sh\n#! -*-perl-*-\n\n# Generate a release announcement message.\n\n# Copyright (C) 2002-2023 Free Software Foundation, Inc.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n#\n# Written by Jim Meyering\n\n# This is a prologue that allows to run a perl script as an executable\n# on systems that are compliant to a POSIX version before POSIX:2017.\n# On such systems, the usual invocation of an executable through execlp()\n# or execvp() fails with ENOEXEC if it is a script that does not start\n# with a #! line.  The script interpreter mentioned in the #! line has\n# to be /bin/sh, because on GuixSD systems that is the only program that\n# has a fixed file name.  The second line is essential for perl and is\n# also useful for editing this file in Emacs.  The next two lines below\n# are valid code in both sh and perl.  When executed by sh, they re-execute\n# the script through the perl program found in $PATH.  The '-x' option\n# is essential as well; without it, perl would re-execute the script\n# through /bin/sh.  When executed by perl, the next two lines are a no-op.\neval 'exec perl -wSx \"$0\" \"$@\"'\n     if 0;\n\nmy $VERSION = '2023-07-17 20:05'; # UTC\n# The definition above must lie within the first 8 lines in order\n# for the Emacs time-stamp write hook (at end) to update it.\n# If you change this file with Emacs, please let the write hook\n# do its job.  Otherwise, update this string manually.\n\nmy $copyright_year = '2022';\n\nuse strict;\nuse Getopt::Long;\nuse POSIX qw(strftime);\n\n(my $ME = $0) =~ s|.*/||;\n\nmy %valid_release_types = map {$_ => 1} qw (alpha beta stable);\nmy @archive_suffixes = qw (tar.gz tar.bz2 tar.lz tar.lzma tar.xz);\nmy $srcdir = '.';\n\nsub usage ($)\n{\n  my ($exit_code) = @_;\n  my $STREAM = ($exit_code == 0 ? *STDOUT : *STDERR);\n  if ($exit_code != 0)\n    {\n      print $STREAM \"Try '$ME --help' for more information.\\n\";\n    }\n  else\n    {\n      my @types = sort keys %valid_release_types;\n      print $STREAM <<EOF;\nUsage: $ME [OPTIONS]\nGenerate an announcement message.  Run this from builddir.\n\nOPTIONS:\n\nThese options must be specified:\n\n   --release-type=TYPE          TYPE must be one of @types\n   --package-name=PACKAGE_NAME\n   --previous-version=VER\n   --current-version=VER\n   --gpg-key-id=ID         The GnuPG ID of the key used to sign the tarballs\n   --url-directory=URL_DIR\n\nThe following are optional:\n\n   --news=NEWS_FILE             include the NEWS section about this release\n                                from this NEWS_FILE; accumulates.\n   --srcdir=DIR                 where to find the NEWS_FILEs (default: $srcdir)\n   --bootstrap-tools=TOOL_LIST  a comma-separated list of tools, e.g.,\n                                autoconf,automake,bison,gnulib\n   --gnulib-version=VERSION     report VERSION as the gnulib version, where\n                                VERSION is the result of running git describe\n                                in the gnulib source directory.\n                                required if gnulib is in TOOL_LIST.\n   --gpg-key-email=EMAIL        The email address of the key used to\n                                sign the tarballs\n   --gpg-keyring-url=URL        URL pointing to keyring containing the key used\n                                to sign the tarballs\n   --no-print-checksums         do not emit SHA1 or SHA256 checksums\n   --archive-suffix=SUF         add SUF to the list of archive suffixes\n   --mail-headers=HEADERS       a space-separated list of mail headers, e.g.,\n                                To: x\\@example.com Cc: y-announce\\@example.com,...\n\n   --help             display this help and exit\n   --version          output version information and exit\n\nEOF\n    }\n  exit $exit_code;\n}\n\n\n=item C<%size> = C<sizes (@file)>\n\nCompute the sizes of the C<@file> and return them as a hash.  Return\nC<undef> if one of the computation failed.\n\n=cut\n\nsub sizes (@)\n{\n  my (@file) = @_;\n\n  my $fail = 0;\n  my %res;\n  foreach my $f (@file)\n    {\n      my $cmd = \"du -h $f\";\n      my $t = `$cmd`;\n      # FIXME-someday: give a better diagnostic, a la $PROCESS_STATUS\n      $@\n        and (warn \"command failed: '$cmd'\\n\"), $fail = 1;\n      chomp $t;\n      $t =~ s/^\\s*([\\d.]+[MkK]).*/${1}B/;\n      $res{$f} = $t;\n    }\n  return $fail ? undef : %res;\n}\n\n=item C<print_locations ($title, \\@url, \\%size, @file)\n\nPrint a section C<$title> dedicated to the list of <@file>, which\nsizes are stored in C<%size>, and which are available from the C<@url>.\n\n=cut\n\nsub print_locations ($\\@\\%@)\n{\n  my ($title, $url, $size, @file) = @_;\n  print \"Here are the $title:\\n\";\n  foreach my $url (@{$url})\n    {\n      for my $file (@file)\n        {\n          print \"  $url/$file\";\n          print \"   (\", $$size{$file}, \")\"\n            if exists $$size{$file};\n          print \"\\n\";\n        }\n    }\n  print \"\\n\";\n}\n\n=item C<print_checksums (@file)\n\nPrint the SHA1 and SHA256 signature section for each C<@file>.\n\n=cut\n\n# This digest function omits the \"=\" padding that is required by cksum,\n# so add the 0..2 bytes of padding required for each of Digest's algorithms.\nsub digest_file_base64_wrap ($$)\n{\n  my ($file, $alg) = @_;\n  my $h = digest_file_base64($file, $alg);\n  $alg =~ tr{-}{}d;\n  my %pad = (MD5 => 2, SHA1 => 1, SHA256 => 1, SHA384 => 0, SHA512 => 2);\n  return $h . '=' x $pad{$alg};\n}\n\nsub print_checksums (@)\n{\n  my (@file) = @_;\n\n  print \"Here are the SHA1 and SHA256 checksums:\\n\";\n  print \"\\n\";\n\n  use Digest::file qw(digest_file_hex digest_file_base64);\n\n  foreach my $f (@file)\n    {\n      print '  ', digest_file_hex ($f, \"SHA-1\"), \"  $f\\n\";\n      print '  ', digest_file_base64_wrap ($f, \"SHA-256\"), \"  $f\\n\";\n    }\n  print \"\\nVerify the base64 SHA256 checksum with cksum -a sha256 --check\\n\";\n  print \"from coreutils-9.2 or OpenBSD's cksum since 2007.\\n\\n\";\n}\n\n=item C<print_news_deltas ($news_file, $prev_version, $curr_version)\n\nPrint the section of the NEWS file C<$news_file> addressing changes\nbetween versions C<$prev_version> and C<$curr_version>.\n\n=cut\n\nsub print_news_deltas ($$$)\n{\n  my ($news_file, $prev_version, $curr_version) = @_;\n\n  my $news_name = $news_file;\n  $news_name =~ s|^\\Q$srcdir\\E/||;\n\n  print \"\\n$news_name\\n\\n\";\n\n  # Print all lines from $news_file, starting with the first one\n  # that mentions $curr_version up to but not including\n  # the first occurrence of $prev_version.\n  my $in_items;\n\n  my $re_prefix = qr/(?:\\* )?(?:Noteworthy c|Major c|C)(?i:hanges)/;\n\n  my $found_news;\n  open NEWS, '<', $news_file\n    or die \"$ME: $news_file: cannot open for reading: $!\\n\";\n  while (defined (my $line = <NEWS>))\n    {\n      if ( ! $in_items)\n        {\n          # Match lines like these:\n          # * Major changes in release 5.0.1:\n          # * Noteworthy changes in release 6.6 (2006-11-22) [stable]\n          $line =~ /^$re_prefix.*(?:[^\\d.]|$)\\Q$curr_version\\E(?:[^\\d.]|$)/o\n            or next;\n          $in_items = 1;\n          print $line;\n        }\n      else\n        {\n          # This regexp must not match version numbers in NEWS items.\n          # For example, they might well say \"introduced in 4.5.5\",\n          # and we don't want that to match.\n          $line =~ /^$re_prefix.*(?:[^\\d.]|$)\\Q$prev_version\\E(?:[^\\d.]|$)/o\n            and last;\n          print $line;\n          $line =~ /\\S/\n            and $found_news = 1;\n        }\n    }\n  close NEWS;\n\n  $in_items\n    or die \"$ME: $news_file: no matching lines for '$curr_version'\\n\";\n  $found_news\n    or die \"$ME: $news_file: no news item found for '$curr_version'\\n\";\n}\n\nsub print_changelog_deltas ($$)\n{\n  my ($package_name, $prev_version) = @_;\n\n  # Print new ChangeLog entries.\n\n  # First find all CVS-controlled ChangeLog files.\n  use File::Find;\n  my @changelog;\n  find ({wanted => sub {$_ eq 'ChangeLog' && -d 'CVS'\n                          and push @changelog, $File::Find::name}},\n        '.');\n\n  # If there are no ChangeLog files, we're done.\n  @changelog\n    or return;\n  my %changelog = map {$_ => 1} @changelog;\n\n  # Reorder the list of files so that if there are ChangeLog\n  # files in the specified directories, they're listed first,\n  # in this order:\n  my @dir = qw ( . src lib m4 config doc );\n\n  # A typical @changelog array might look like this:\n  # ./ChangeLog\n  # ./po/ChangeLog\n  # ./m4/ChangeLog\n  # ./lib/ChangeLog\n  # ./doc/ChangeLog\n  # ./config/ChangeLog\n  my @reordered;\n  foreach my $d (@dir)\n    {\n      my $dot_slash = $d eq '.' ? $d : \"./$d\";\n      my $target = \"$dot_slash/ChangeLog\";\n      delete $changelog{$target}\n        and push @reordered, $target;\n    }\n\n  # Append any remaining ChangeLog files.\n  push @reordered, sort keys %changelog;\n\n  # Remove leading './'.\n  @reordered = map { s!^\\./!!; $_ } @reordered;\n\n  print \"\\nChangeLog entries:\\n\\n\";\n  # print join (\"\\n\", @reordered), \"\\n\";\n\n  $prev_version =~ s/\\./_/g;\n  my $prev_cvs_tag = \"\\U$package_name\\E-$prev_version\";\n\n  my $cmd = \"cvs -n diff -u -r$prev_cvs_tag -rHEAD @reordered\";\n  open DIFF, '-|', $cmd\n    or die \"$ME: cannot run '$cmd': $!\\n\";\n  # Print two types of lines, making minor changes:\n  # Lines starting with '+++ ', e.g.,\n  # +++ ChangeLog   22 Feb 2003 16:52:51 -0000      1.247\n  # and those starting with '+'.\n  # Don't print the others.\n  my $prev_printed_line_empty = 1;\n  while (defined (my $line = <DIFF>))\n    {\n      if ($line =~ /^\\+\\+\\+ /)\n        {\n          my $separator = \"*\"x70 .\"\\n\";\n          $line =~ s///;\n          $line =~ s/\\s.*//;\n          $prev_printed_line_empty\n            or print \"\\n\";\n          print $separator, $line, $separator;\n        }\n      elsif ($line =~ /^\\+/)\n        {\n          $line =~ s///;\n          print $line;\n          $prev_printed_line_empty = ($line =~ /^$/);\n        }\n    }\n  close DIFF;\n\n  # The exit code should be 1.\n  # Allow in case there are no modified ChangeLog entries.\n  $? == 256 || $? == 128\n    or warn \"warning: '$cmd' had unexpected exit code or signal ($?)\\n\";\n}\n\nsub get_tool_versions ($$)\n{\n  my ($tool_list, $gnulib_version) = @_;\n  @$tool_list\n    or return ();\n\n  my $fail;\n  my @tool_version_pair;\n  foreach my $t (@$tool_list)\n    {\n      if ($t eq 'gnulib')\n        {\n          push @tool_version_pair, ucfirst $t . ' ' . $gnulib_version;\n          next;\n        }\n      # Assume that the last \"word\" on the first line of\n      # 'tool --version' output is the version string.\n      my ($first_line, undef) = split (\"\\n\", `$t --version`);\n      if ($first_line =~ /.* (\\d[\\w.-]+)$/)\n        {\n          $t = ucfirst $t;\n          push @tool_version_pair, \"$t $1\";\n        }\n      else\n        {\n          defined $first_line\n            and $first_line = '';\n          warn \"$t: unexpected --version output\\n:$first_line\";\n          $fail = 1;\n        }\n    }\n\n  $fail\n    and exit 1;\n\n  return @tool_version_pair;\n}\n\n# Print a more human-friendly representation of $SEC seconds.\nsub readable_interval0($)\n{\n  my $sec = shift;\n  $sec < 60 and return \"$sec seconds\";\n\n  my $min = int($sec / 60); $sec %= 60;\n  30 < $sec and $min++;\n  $min < 60 and return \"$min minutes\";\n\n  my $hr = int($min / 60); $min %= 60;\n  30 < $min and $hr++;\n  $hr < 24 and return \"$hr hours\";\n\n  my $day = int($hr / 24); $hr %= 24;\n  12 < $hr and $day++;\n  $day < 50 and return \"$day days\";\n\n  my $wk = int($day / 7); $day %= 7;\n  4 < $day and $wk++;\n  return \"$wk weeks\";\n}\n\n# Convert e.g., \"1 weeks\", to \"1 week\".\nsub readable_interval($)\n{\n  my $interval_str = shift;\n  my $i = readable_interval0 $interval_str;\n  $i =~ m{^1 \\w+s$} and chop $i;\n  return $i;\n}\n\n{\n  # Use the C locale so that, for instance, \"du\" does not\n  # print \"1,2\" instead of \"1.2\", which would confuse our regexps.\n  $ENV{LC_ALL} = \"C\";\n\n  my $mail_headers;\n  my $release_type;\n  my $package_name;\n  my $prev_version;\n  my $curr_version;\n  my $gpg_key_id;\n  my @url_dir_list;\n  my @news_file;\n  my $bootstrap_tools;\n  my $gnulib_version;\n  my $print_checksums_p = 1;\n  my $gpg_key_email;\n  my $gpg_keyring_url;\n\n  # Reformat the warnings before displaying them.\n  local $SIG{__WARN__} = sub\n    {\n      my ($msg) = @_;\n      # Warnings from GetOptions.\n      $msg =~ s/Option (\\w)/option --$1/;\n      warn \"$ME: $msg\";\n    };\n\n  GetOptions\n    (\n     'mail-headers=s'     => \\$mail_headers,\n     'release-type=s'     => \\$release_type,\n     'package-name=s'     => \\$package_name,\n     'previous-version=s' => \\$prev_version,\n     'current-version=s'  => \\$curr_version,\n     'gpg-key-id=s'       => \\$gpg_key_id,\n     'gpg-key-email=s'    => \\$gpg_key_email,\n     'gpg-keyring-url=s'  => \\$gpg_keyring_url,\n     'url-directory=s'    => \\@url_dir_list,\n     'news=s'             => \\@news_file,\n     'srcdir=s'           => \\$srcdir,\n     'bootstrap-tools=s'  => \\$bootstrap_tools,\n     'gnulib-version=s'   => \\$gnulib_version,\n     'print-checksums!'   => \\$print_checksums_p,\n     'archive-suffix=s'   => \\@archive_suffixes,\n\n     help => sub { usage 0 },\n     version =>\n       sub\n       {\n         print \"$ME version $VERSION\\n\";\n         print \"Copyright (C) $copyright_year Free Software Foundation, Inc.\\n\";\n         print \"License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.\\n\"\n             . \"This is free software: you are free to change and redistribute it.\\n\"\n             . \"There is NO WARRANTY, to the extent permitted by law.\\n\";\n         print \"\\n\";\n         my $author = \"Jim Meyering\";\n         print \"Written by $author.\\n\";\n         exit\n       },\n    ) or usage 1;\n\n  my $fail = 0;\n  # Ensure that each required option is specified.\n  $release_type\n    or (warn \"release type not specified\\n\"), $fail = 1;\n  $package_name\n    or (warn \"package name not specified\\n\"), $fail = 1;\n  $prev_version\n    or (warn \"previous version string not specified\\n\"), $fail = 1;\n  $curr_version\n    or (warn \"current version string not specified\\n\"), $fail = 1;\n  $gpg_key_id\n    or (warn \"GnuPG key ID not specified\\n\"), $fail = 1;\n  @url_dir_list\n    or (warn \"URL directory name(s) not specified\\n\"), $fail = 1;\n\n  my @tool_list = split ',', $bootstrap_tools\n    if $bootstrap_tools;\n\n  grep (/^gnulib$/, @tool_list) && ! defined $gnulib_version\n    and (warn \"when specifying gnulib as a tool, you must also specify\\n\"\n        . \"--gnulib-version=V, where V is the result of running git describe\\n\"\n        . \"in the gnulib source directory.\\n\"), $fail = 1;\n\n  ! grep (/^gnulib$/, @tool_list) && defined $gnulib_version\n    and (warn \"with --gnulib-version=V you must use --bootstrap-tools=...\\n\"\n         . \"including gnulib in that list\"), $fail = 1;\n\n  !$release_type || exists $valid_release_types{$release_type}\n    or (warn \"'$release_type': invalid release type\\n\"), $fail = 1;\n\n  @ARGV\n    and (warn \"too many arguments:\\n\", join (\"\\n\", @ARGV), \"\\n\"),\n      $fail = 1;\n  $fail\n    and usage 1;\n\n  my $my_distdir = \"$package_name-$curr_version\";\n\n  my $xd = \"$package_name-$prev_version-$curr_version.xdelta\";\n\n  my @candidates = map { \"$my_distdir.$_\" } @archive_suffixes;\n  my @tarballs = grep {-f $_} @candidates;\n\n  @tarballs\n    or die \"$ME: none of \" . join(', ', @candidates) . \" were found\\n\";\n  my @sizable = @tarballs;\n  -f $xd\n    and push @sizable, $xd;\n  my %size = sizes (@sizable);\n  %size\n    or exit 1;\n\n  my $headers = '';\n  if (defined $mail_headers)\n    {\n      ($headers = $mail_headers) =~ s/\\s+(\\S+:)/\\n$1/g;\n      $headers .= \"\\n\";\n    }\n\n  # The markup is escaped as <\\# so that when this script is sent by\n  # mail (or part of a diff), Gnus is not triggered.\n  print <<EOF;\n\n${headers}Subject: $my_distdir released [$release_type]\n\n<\\#secure method=pgpmime mode=sign>\nThis is to announce $package_name-$curr_version, a $release_type release.\n\nFIXME: put comments here\n\nEOF\n\n  my $v0 = $prev_version;\n  my $v1 = $curr_version;\n\n  (my $first_name = `git config user.name|cut -d' ' -f1`)\n    =~ m{\\S} or die \"no name? set user.name in ~/.gitconfig\\n\";\n\n  chomp (my $n_ci = `git rev-list \"v$v0..v$v1\" | wc -l`);\n  chomp (my $n_p = `git shortlog \"v$v0..v$v1\" | grep -c '^[^ ]'`);\n\n  my $prev_release_date = `git log --pretty=%ct -1 \"v$v0\"`;\n  my $this_release_date = `git log --pretty=%ct -1 \"v$v1\"`;\n  my $n_seconds = $this_release_date - $prev_release_date;\n  my $time_since_prev = readable_interval $n_seconds;\n  my $names = `git shortlog \"v$v0..v$v1\"|perl -lne '/^(\\\\w.*):/ and print \"  \".\\$1'`;\n\n  print <<EOF;\nThere have been $n_ci commits by $n_p people in the $time_since_prev since $v0.\n\nSee the NEWS below for a brief summary.\n\nThanks to everyone who has contributed!\nThe following people contributed changes to this release:\n\n$names\n$first_name [on behalf of the $package_name maintainers]\n==================================================================\n\nHere is the GNU $package_name home page:\n    http://gnu.org/s/$package_name/\n\nFor a summary of changes and contributors, see:\n  http://git.sv.gnu.org/gitweb/?p=$package_name.git;a=shortlog;h=v$v1\nor run this command from a git-cloned $package_name directory:\n  git shortlog v$v0..v$v1\n\nEOF\n\n  if (@url_dir_list == 1 && @tarballs == 1)\n    {\n      # When there's only one tarball and one URL, use a more concise form.\n      my $m = \"$url_dir_list[0]/$tarballs[0]\";\n      print \"Here are the compressed sources and a GPG detached signature:\\n\"\n        . \"  $m\\n\"\n        . \"  $m.sig\\n\\n\";\n    }\n  else\n    {\n      print_locations (\"compressed sources\", @url_dir_list, %size, @tarballs);\n      -f $xd\n        and print_locations (\"xdelta diffs (useful? if so, \"\n                             . \"please tell bug-gnulib\\@gnu.org)\",\n                             @url_dir_list, %size, $xd);\n      my @sig_files = map { \"$_.sig\" } @tarballs;\n      print_locations (\"GPG detached signatures\", @url_dir_list, %size,\n                       @sig_files);\n    }\n\n  if ($url_dir_list[0] =~ \"gnu\\.org\")\n    {\n      print \"Use a mirror for higher download bandwidth:\\n\";\n      if (@tarballs == 1 && $url_dir_list[0] =~ m!https://ftp\\.gnu\\.org/gnu/!)\n        {\n          (my $m = \"$url_dir_list[0]/$tarballs[0]\")\n            =~ s!https://ftp\\.gnu\\.org/gnu/!https://ftpmirror\\.gnu\\.org/!;\n          print \"  $m\\n\"\n              . \"  $m.sig\\n\\n\";\n\n        }\n      else\n        {\n          print \"  https://www.gnu.org/order/ftp.html\\n\\n\";\n        }\n    }\n\n  $print_checksums_p\n    and print_checksums (@sizable);\n\n  print <<EOF;\nUse a .sig file to verify that the corresponding file (without the\n.sig suffix) is intact.  First, be sure to download both the .sig file\nand the corresponding tarball.  Then, run a command like this:\n\n  gpg --verify $tarballs[0].sig\n\nEOF\n  my $gpg_fingerprint = `LC_ALL=C gpg --fingerprint $gpg_key_id | grep -v ^sub`;\n  if ($gpg_fingerprint =~ /^pub/)\n    {\n      chop $gpg_fingerprint;\n      $gpg_fingerprint =~ s/ \\[expires:.*//mg;\n      $gpg_fingerprint =~ s/^uid           \\[ultimate\\]/uid  /mg;\n      $gpg_fingerprint =~ s/^/  /mg;\n      print<<EOF\nThe signature should match the fingerprint of the following key:\n\n$gpg_fingerprint\nEOF\n    }\n  print <<EOF;\nIf that command fails because you don't have the required public key,\nor that public key has expired, try the following commands to retrieve\nor refresh it, and then rerun the 'gpg --verify' command.\nEOF\n  if ($gpg_key_email) {\n    print <<EOF;\n\n  gpg --locate-external-key $gpg_key_email\nEOF\n    }\n  print <<EOF;\n\n  gpg --recv-keys $gpg_key_id\nEOF\n    if ($gpg_keyring_url) {\n      print <<EOF;\n\n  wget -q -O- '$gpg_keyring_url' | gpg --import -\nEOF\n      }\n  print <<EOF;\n\nAs a last resort to find the key, you can try the official GNU\nkeyring:\n\n  wget -q https://ftp.gnu.org/gnu/gnu-keyring.gpg\n  gpg --keyring gnu-keyring.gpg --verify $tarballs[0].sig\nEOF\n\n  my @tool_versions = get_tool_versions (\\@tool_list, $gnulib_version);\n  @tool_versions\n    and print \"\\nThis release was bootstrapped with the following tools:\",\n      join ('', map {\"\\n  $_\"} @tool_versions), \"\\n\";\n\n  print_news_deltas ($_, $prev_version, $curr_version)\n    foreach @news_file;\n\n  $release_type eq 'stable'\n    or print_changelog_deltas ($package_name, $prev_version);\n\n  exit 0;\n}\n\n### Setup \"GNU\" style for perl-mode and cperl-mode.\n## Local Variables:\n## mode: perl\n## perl-indent-level: 2\n## perl-continued-statement-offset: 2\n## perl-continued-brace-offset: 0\n## perl-brace-offset: 0\n## perl-brace-imaginary-offset: 0\n## perl-label-offset: -2\n## perl-extra-newline-before-brace: t\n## perl-merge-trailing-else: nil\n## eval: (add-hook 'before-save-hook 'time-stamp)\n## time-stamp-line-limit: 50\n## time-stamp-start: \"my $VERSION = '\"\n## time-stamp-format: \"%:y-%02m-%02d %02H:%02M\"\n## time-stamp-time-zone: \"UTC0\"\n## time-stamp-end: \"'; # UTC\"\n## End:\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}