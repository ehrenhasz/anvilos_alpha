{
  "module_name": "help2man",
  "hash_id": "1423949113128d082c4f1c439448caffd4c324024faddd8d99e320f0d93a2a76",
  "original_prompt": "Ingested from coreutils-9.4/man/help2man",
  "human_readable_source": "#!/usr/bin/perl -w\n\n# Generate a short man page from --help and --version output.\n# Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2009,\n# 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2020, 2021 Free Software\n# Foundation, Inc.\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3, or (at your option)\n# any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, see <https://www.gnu.org/licenses/>.\n\n# Written by Brendan O'Dea <bod@debian.org>\n# Available from https://ftp.gnu.org/gnu/help2man/\n\nuse 5.008;\nuse strict;\nuse Getopt::Long;\nuse Text::ParseWords qw(shellwords);\nuse Text::Tabs qw(expand);\nuse POSIX qw(strftime setlocale LC_ALL);\n\nmy $this_program = 'help2man';\nmy $this_version = '1.48.5';\n\nsub _ { $_[0] }\nsub configure_locale\n{\n    my $locale = shift;\n    die \"$this_program: no locale support (Locale::gettext required)\\n\"\n\tunless $locale eq 'C';\n}\n\nsub dec { $_[0] }\nsub enc { $_[0] }\nsub enc_user { $_[0] }\nsub kark { die +(sprintf shift, @_), \"\\n\" }\nsub N_ { $_[0] }\n\nsub program_basename;\nsub get_option_value;\nsub convert_option;\nsub fix_italic_spacing;\n\nmy $version_info = enc_user sprintf _(<<'EOT'), $this_program, $this_version;\nGNU %s %s\n\nCopyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2009,\n2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2020, 2021 Free Software\nFoundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nWritten by Brendan O'Dea <bod@debian.org>\nEOT\n\nmy $help_info = enc_user sprintf _(<<'EOT'), $this_program, $this_program;\n`%s' generates a man page out of `--help' and `--version' output.\n\nUsage: %s [OPTION]... EXECUTABLE\n\n -n, --name=STRING       description for the NAME paragraph\n -s, --section=SECTION   section number for manual page (1, 6, 8)\n -m, --manual=TEXT       name of manual (User Commands, ...)\n -S, --source=TEXT       source of program (FSF, Debian, ...)\n -L, --locale=STRING     select locale (default \"C\")\n -i, --include=FILE      include material from `FILE'\n -I, --opt-include=FILE  include material from `FILE' if it exists\n -o, --output=FILE       send output to `FILE'\n -p, --info-page=TEXT    name of Texinfo manual\n -N, --no-info           suppress pointer to Texinfo manual\n -l, --libtool           exclude the `lt-' from the program name\n -b, --bold-refs         apply bold style to references\n     --help              print this help, then exit\n     --version           print version number, then exit\n\nEXECUTABLE should accept `--help' and `--version' options and produce output on\nstdout although alternatives may be specified using:\n\n -h, --help-option=STRING     help option string\n -v, --version-option=STRING  version option string\n --version-string=STRING      version string\n --no-discard-stderr          include stderr when parsing option output\n\nReport bugs to <bug-help2man@gnu.org>.\nEOT\n\nmy $section = 1;\nmy $manual = '';\nmy $source = '';\nmy $help_option = '--help';\nmy $version_option = '--version';\nmy $discard_stderr = 1;\nmy ($opt_name, @opt_include, $opt_output, $opt_info, $opt_no_info, $opt_libtool,\n    $opt_bold_refs, $version_text);\n\nmy %opt_def = (\n    'n|name=s'\t\t => \\$opt_name,\n    's|section=s'\t => \\$section,\n    'm|manual=s'\t => \\$manual,\n    'S|source=s'\t => \\$source,\n    'L|locale=s'\t => sub { configure_locale pop },\n    'i|include=s'\t => sub { push @opt_include, [ pop, 1 ] },\n    'I|opt-include=s'\t => sub { push @opt_include, [ pop, 0 ] },\n    'o|output=s'\t => \\$opt_output,\n    'p|info-page=s'\t => \\$opt_info,\n    'N|no-info'\t\t => \\$opt_no_info,\n    'l|libtool'\t\t => \\$opt_libtool,\n    'b|bold-refs'\t => \\$opt_bold_refs,\n    'help'\t\t => sub { print $help_info; exit },\n    'version'\t\t => sub { print $version_info; exit },\n    'h|help-option=s'\t => \\$help_option,\n    'v|version-option=s' => \\$version_option,\n    'version-string=s'\t => \\$version_text,\n    'discard-stderr!'\t => \\$discard_stderr,\n);\n\n# Parse options.\nGetopt::Long::config('bundling');\ndie $help_info unless GetOptions %opt_def and @ARGV == 1;\n\nmy %include = ();\nmy %replace = ();\nmy %append = ();\nmy %append_match = ();\nmy @sections = ();  # retain order of include file or in-line *section*s\n\n# Process include file (if given).  Format is:\n#\n#   Optional initial text, ignored.  May include lines starting with `-'\n#   which are processed as options.\n#\n#   [section]\n#   Verbatim text to be included in the named section.  By default at\n#   the start, but in the case of `name' and `synopsis' the content\n#   will replace the autogenerated contents.\n#\n#   [<section]\n#   Verbatim text to be inserted at the start of the named section.\n#\n#   [=section]\n#   Verbatim text to replace the named section.\n#\n#   [>section]\n#   Verbatim text to be appended to the end of the named section.\n#\n#   /pattern/\n#   Verbatim text for inclusion below a paragraph matching `pattern'.\n#\n\nwhile (@opt_include)\n{\n    my ($inc, $required) = @{shift @opt_include};\n\n    next unless -f $inc or $required;\n    kark N_(\"%s: can't open `%s' (%s)\"), $this_program, $inc, $!\n\tunless open INC, $inc;\n\n    my $key;\n    my $hash;\n\n    while (<INC>)\n    {\n\t# Convert input to internal Perl format, so that multibyte\n\t# sequences are treated as single characters.\n\t$_ = dec $_;\n\n\t# [section]\n\tif (/^\\[([^]]+)\\]\\s*$/)\n\t{\n\t    $key = uc $1;\n\t    $key =~ s/^\\s+//;\n\t    $key =~ s/\\s+$//;\n\t    $hash = \\%include;\n\t    # Handle explicit [<section], [=section] and [>section]\n\t    if ($key =~ s/^([<>=])\\s*//)\n\t    {\n\t\tif    ($1 eq '>') { $hash = \\%append; }\n\t\telsif ($1 eq '=') { $hash = \\%replace; }\n\t    }\n\t    # NAME/SYNOPSIS replace by default\n\t    elsif ($key eq _('NAME') or $key eq _('SYNOPSIS'))\n\t    {\n\t\t$hash = \\%replace;\n\t    }\n\t    else\n\t    {\n\t\t$hash = \\%include;\n\t    }\n\n\t    push @sections, $key;\n\t    next;\n\t}\n\n\t# /pattern/\n\tif (m!^/(.*)/([ims]*)\\s*$!)\n\t{\n\t    my $pat = $2 ? \"(?$2)$1\" : $1;\n\n\t    # Check pattern.\n\t    eval { $key = qr($pat) };\n\t    if ($@)\n\t    {\n\t\t$@ =~ s/ at .*? line \\d.*//;\n\t\tdie \"$inc:$.:$@\";\n\t    }\n\n\t    $hash = \\%append_match;\n\t    next;\n\t}\n\n\t# Check for options before the first section--anything else is\n\t# silently ignored, allowing the first for comments and\n\t# revision info.\n\tunless ($key)\n\t{\n\t    # handle options\n\t    if (/^-/)\n\t    {\n\t\tlocal @ARGV = shellwords $_;\n\t\tGetOptions %opt_def;\n\t    }\n\n\t    next;\n\t}\n\n\t$hash->{$key} .= $_;\n    }\n\n    close INC;\n\n    kark N_(\"%s: no valid information found in `%s'\"), $this_program, $inc\n\tunless $key;\n}\n\n# Compress trailing blank lines.\nfor my $hash (\\(%include, %replace, %append, %append_match))\n{\n    for (keys %$hash) { $hash->{$_} =~ s/\\n+$/\\n/ }\n}\n\n# Grab help and version info from executable.\nmy $help_text   = get_option_value $ARGV[0], $help_option;\n$version_text ||= get_option_value $ARGV[0], $version_option;\n\n# By default the generated manual pages will include the current date.  This may\n# however be overridden by setting the environment variable $SOURCE_DATE_EPOCH\n# to an integer value of the seconds since the UNIX epoch.  This is primarily\n# intended to support reproducible builds (wiki.debian.org/ReproducibleBuilds)\n# and will additionally ensure that the output date string is UTC.\nmy $epoch_secs = time;\nif (exists $ENV{SOURCE_DATE_EPOCH} and $ENV{SOURCE_DATE_EPOCH} =~ /^(\\d+)$/)\n{\n    $epoch_secs = $1;\n    $ENV{TZ} = 'UTC0';\n}\n\n# Translators: the following message is a strftime(3) format string, which in\n# the English version expands to the month as a word and the full year.  It\n# is used on the footer of the generated manual pages.  If in doubt, you may\n# just use %x as the value (which should be the full locale-specific date).\nmy $date = enc strftime _(\"%B %Y\"), localtime $epoch_secs;\nmy $program = program_basename $ARGV[0];\nmy $package = $program;\nmy $version;\n\nif ($opt_output)\n{\n    unlink $opt_output or kark N_(\"%s: can't unlink %s (%s)\"),\n\t$this_program, $opt_output, $! if -e $opt_output;\n\n    open STDOUT, \">$opt_output\"\n\tor kark N_(\"%s: can't create %s (%s)\"), $this_program, $opt_output, $!;\n}\n\n# The first line of the --version information is assumed to be in one\n# of the following formats:\n#\n#   <version>\n#   <program> <version>\n#   {GNU,Free} <program> <version>\n#   <program> ({GNU,Free,} <package>) <version>\n#   <program> - {GNU,Free,} <package> <version>\n#   <program> - {GNU,Free,} <package> - <version>\n#\n# and separated from any copyright/author details by a blank line.\n\n($_, $version_text) = ((split /\\n+/, $version_text, 2), '');\n\nif (/^(\\S+) +\\(((?:(?:GNU|Free) +)?[^)]+)\\) +(\\S.*)$/ or\n    /^(\\S+) +- +((?:(?:GNU|Free) +)?\\S.*) +- +(\\S.*)$/ or\n    /^(\\S+) +- +((?:(?:GNU|Free) +)?\\S+) +(\\S.*)$/)\n{\n    $program = program_basename $1;\n    $package = $2;\n    $version = $3;\n}\nelsif (/^((?:GNU|Free) +)?(\\S+) +(\\S.*)$/)\n{\n    $program = program_basename $2;\n    $package = $1 ? \"$1$program\" : $program;\n    $version = $3;\n}\nelse\n{\n    $version = $_;\n}\n\n# No info for `info' itself.\n$opt_no_info = 1 if $program eq 'info';\n\nif ($opt_name)\n{\n    # --name overrides --include contents.\n    $replace{_('NAME')} = \"$program \\\\- $opt_name\\n\";\n}\n\n# Translators: \"NAME\", \"SYNOPSIS\" and other one or two word strings in all\n# upper case are manual page section headings.  The man(1) manual page in your\n# language, if available should provide the conventional translations.\nfor ($replace{_('NAME')} || ($include{_('NAME')} ||= ''))\n{\n    if ($_) # Use first name given as $program\n    {\n\t$program = $1 if /^([^\\s,]+)(?:,?\\s*[^\\s,\\\\-]+)*\\s+\\\\?-/;\n    }\n    else # Set a default (useless) NAME paragraph.\n    {\n\t$_ = sprintf _(\"%s \\\\- manual page for %s %s\") . \"\\n\", $program,\n\t    $program, $version;\n    }\n}\n\n# Man pages traditionally have the page title in caps.\nmy $PROGRAM = uc $program;\n\n# Set default page head/footers\n$source ||= \"$package $version\";\nunless ($manual)\n{\n    for ($section)\n    {\n\tif (/^(1[Mm]|8)/) { $manual = enc _('System Administration Utilities') }\n\telsif (/^6/)\t  { $manual = enc _('Games') }\n\telse\t\t  { $manual = enc _('User Commands') }\n    }\n}\n\n# Extract usage clause(s) [if any] for SYNOPSIS.\n# Translators: \"Usage\" and \"or\" here are patterns (regular expressions) which\n# are used to match the usage synopsis in program output.  An example from cp\n# (GNU coreutils) which contains both strings:\n#  Usage: cp [OPTION]... [-T] SOURCE DEST\n#    or:  cp [OPTION]... SOURCE... DIRECTORY\n#    or:  cp [OPTION]... -t DIRECTORY SOURCE...\nmy $PAT_USAGE = _('Usage');\nmy $PAT_USAGE_CONT = _('or');\nif ($help_text =~ s/^($PAT_USAGE):( +(\\S+))(.*)((?:\\n(?: {6}\\1| *($PAT_USAGE_CONT): +\\S).*)*)//om)\n{\n    my @syn = $3 . $4;\n\n    if ($_ = $5)\n    {\n\ts/^\\n//;\n\tfor (split /\\n/) { s/^ *(($PAT_USAGE_CONT): +)?//o; push @syn, $_ }\n    }\n\n    my $synopsis = '';\n    for (@syn)\n    {\n\t$synopsis .= \".br\\n\" if $synopsis;\n\ts!^\\S*/!!;\n\ts/^lt-// if $opt_libtool;\n\ts/^(\\S+) *//;\n\t$synopsis .= \".B $1\\n\";\n\ts/\\s+$//;\n\ts/(([][]|\\.\\.+)+)/\\\\fR$1\\\\fI/g;\n\ts/^/\\\\fI/ unless s/^\\\\fR//;\n\t$_ .= '\\fR';\n\ts/(\\\\fI)( *)/$2$1/g;\n\ts/\\\\fI\\\\fR//g;\n\ts/^\\\\fR//;\n\ts/\\\\fI$//;\n\ts/^\\./\\\\&./;\n\n\t$_ = fix_italic_spacing $_;\n\t$synopsis .= \"$_\\n\";\n    }\n\n    $include{_('SYNOPSIS')} .= $synopsis;\n}\n\n# Process text, initial section is DESCRIPTION.\nmy $sect = _('DESCRIPTION');\n$_ = \"$help_text\\n\\n$version_text\";\n\n# Normalise paragraph breaks.\ns/^\\n+//;\ns/\\n*$/\\n/;\ns/\\n\\n+/\\n\\n/g;\n\n# Join hyphenated lines.\ns/([A-Za-z])-\\n *([A-Za-z])/$1$2/g;\n\n# Temporarily exchange leading dots, apostrophes and backslashes for\n# tokens.\ns/^\\./\\x80/mg;\ns/^'/\\x81/mg;\ns/\\\\/\\x82/g;\n\n# Translators: patterns are used to match common program output. In the source\n# these strings are all of the form of \"my $PAT_something = _('...');\" and are\n# regular expressions.  If there is more than one commonly used string, you\n# may separate alternatives with \"|\".  Spaces in these expressions are written\n# as \" +\" to indicate that more than one space may be matched.  The string\n# \"(?:[\\\\w-]+ +)?\" in the bug reporting pattern is used to indicate an\n# optional word, so that either \"Report bugs\" or \"Report _program_ bugs\" will\n# be matched.\nmy $PAT_BUGS          = _('Report +(?:[\\w-]+ +)?bugs|' .\n                          'Email +bug +reports +to|' .\n                          '.* +online +help:');\nmy $PAT_AUTHOR        = _('Written +by');\nmy $PAT_OPTIONS       = _('Options');\nmy $PAT_ENVIRONMENT   = _('Environment');\nmy $PAT_FILES         = _('Files');\nmy $PAT_EXAMPLES      = _('Examples');\nmy $PAT_FREE_SOFTWARE = _('This +is +free +software');\nmy $PAT_SEE_ALSO      = _('Full +documentation');\n\n# Start a new paragraph (if required) for these.\ns/([^\\n])\\n($PAT_BUGS|$PAT_AUTHOR|$PAT_SEE_ALSO) /$1\\n\\n$2 /og;\n\n# Convert iso-8859-1 copyright symbol or (c) to nroff\n# character.\ns/^Copyright +(?:\\xa9|\\([Cc]\\))/Copyright \\\\(co/mg;\n\nwhile (length)\n{\n    # Convert some standard paragraph names.\n    if (s/^($PAT_OPTIONS): *\\n+//o)\n    {\n\t$sect = _('OPTIONS');\n\tnext;\n    }\n    if (s/^($PAT_ENVIRONMENT): *\\n+//o)\n    {\n\t$sect = _('ENVIRONMENT');\n\tnext;\n    }\n    if (s/^($PAT_FILES): *\\n+//o)\n    {\n\t$sect = _('FILES');\n\tnext;\n    }\n    elsif (s/^($PAT_EXAMPLES): *\\n+//o)\n    {\n\t$sect = _('EXAMPLES');\n\tnext;\n    }\n\n    # Custom section indicated by a line containing \"*Section Name*\".\n    if (s/^\\*(\\w(.*\\w)?)\\* *\\n+//)\n    {\n\t$sect = uc $1;\n\t$sect =~ tr/*/ /;  # also accept *Section*Name*\n\tpush @sections, $sect;\n\tnext;\n    }\n\n    # Copyright section.\n    if (/^Copyright /)\n    {\n\t$sect = _('COPYRIGHT');\n    }\n\n    # Bug reporting section.\n    elsif (/^($PAT_BUGS) /o)\n    {\n\t$sect = _('REPORTING BUGS');\n    }\n\n    # Author section.\n    elsif (/^($PAT_AUTHOR)/o)\n    {\n\t$sect = _('AUTHOR');\n    }\n\n    elsif (/^($PAT_SEE_ALSO)/o)\n    {\n\t$sect = _('SEE ALSO');\n\t$opt_no_info = 1;\n    }\n\n    # Examples, indicated by an indented leading $, % or > are\n    # rendered in a constant width font.\n    if (/^( +)([\\$\\%>] )\\S/)\n    {\n\tmy $indent = $1;\n\tmy $prefix = $2;\n\tmy $break = '.IP';\n\twhile (s/^$indent\\Q$prefix\\E(\\S.*)\\n*//)\n\t{\n\t    $include{$sect} .= \"$break\\n\\\\f(CW$prefix$1\\\\fR\\n\";\n\t    $break = '.br';\n\t}\n\n\tnext;\n    }\n\n    my $matched = '';\n\n    # Sub-sections have a trailing colon and the second line indented.\n    if (s/^(\\S.*:) *\\n / /)\n    {\n\t$matched .= $& if %append_match;\n\t$include{$sect} .= qq(.SS \"$1\"\\n);\n    }\n\n    my $indent = 0;\n    my $content = '';\n\n    # Option with description.\n    if (s/^( {1,10}([+-]\\S.*?))(?:(  +(?!-))|\\n( {20,}))(\\S.*)\\n//)\n    {\n\t$matched .= $& if %append_match;\n\t$indent = length ($4 || \"$1$3\");\n\t$content = \".TP\\n\\x84$2\\n\\x84$5\\n\";\n\tunless ($4)\n\t{\n\t    # Indent may be different on second line.\n\t    $indent = length $& if /^ {20,}/;\n\t}\n    }\n\n    # Option without description.\n    elsif (s/^ {1,10}([+-]\\S.*)\\n//)\n    {\n\t$matched .= $& if %append_match;\n\t$content = \".HP\\n\\x84$1\\n\";\n\t$indent = 80; # not continued\n    }\n\n    # Indented paragraph with tag.\n    elsif (s/^( +(\\S.*?)  +)(\\S.*)\\n//)\n    {\n\t$matched .= $& if %append_match;\n\t$indent = length $1;\n\t$content = \".TP\\n\\x84$2\\n\\x84$3\\n\";\n    }\n\n    # Indented paragraph.\n    elsif (s/^( +)(\\S.*)\\n//)\n    {\n\t$matched .= $& if %append_match;\n\t$indent = length $1;\n\t$content = \".IP\\n\\x84$2\\n\";\n    }\n\n    # Left justified paragraph.\n    else\n    {\n\ts/(.*)\\n//;\n\t$matched .= $& if %append_match;\n\t$content = \".PP\\n\" if $include{$sect};\n\t$content .= \"$1\\n\";\n    }\n\n    # Append continuations.\n    while ($indent ? s/^ {$indent}(\\S.*)\\n// : s/^(\\S.*)\\n//)\n    {\n\t$matched .= $& if %append_match;\n\t$content .= \"\\x84$1\\n\";\n    }\n\n    # Move to next paragraph.\n    s/^\\n+//;\n\n    for ($content)\n    {\n\t# Leading dot and apostrophe protection.\n\ts/\\x84\\./\\x80/g;\n\ts/\\x84'/\\x81/g;\n\ts/\\x84//g;\n\n\t# Examples should be verbatim.\n\tunless ($sect eq _('EXAMPLES'))\n\t{\n\t    # Convert options.\n\t    s/(^|[ (])(-[][\\w=-]+)/$1 . convert_option $2/mge;\n\n\t    # Italicise filenames: /a/b, $VAR/c/d, ~/e/f\n\t    s!\n\t\t(^|[ (])\t\t\t# space/punctuation before\n\t\t(\n\t\t    (?:\\$\\w+|~)?\t\t# leading variable, or tilde\n\t\t    (?:/\\w(?:[\\w.-]*\\w)?)+\t# path components\n\t\t)\n\t\t($|[ ,;.)])\t\t\t# space/punctuation after\n\t    !$1\\\\fI$2\\\\fP$3!xmg;\n\n\t    $_ = fix_italic_spacing $_;\n\t}\n\n\t# Escape remaining hyphens.\n\ts/-/\\x83/g;\n\n\tif ($sect eq _('COPYRIGHT'))\n\t{\n\t    # Insert line breaks before additional copyright messages\n\t    # and the disclaimer.\n\t    s/\\n(Copyright |$PAT_FREE_SOFTWARE)/\\n.br\\n$1/og;\n\t}\n\telsif ($sect eq _('REPORTING BUGS'))\n\t{\n\t    # Handle multi-line bug reporting sections of the form:\n\t    #\n\t    #   Report <program> bugs to <addr>\n\t    #   GNU <package> home page: <url>\n\t    #   ...\n\t    s/\\n([[:upper:]])/\\n.br\\n$1/g;\n\t}\n\telsif ($sect eq _('SEE ALSO'))\n\t{\n\t    # Handle external references of the form:\n\t    #\n\t    #   GNU <package> online resources: <addr>\n\t    #   Full documentation at: <addr>\n\t    #   or available locally via: info ...\n\t    #\n\t    s/\\'/\\\\(aq/g;\t\t\t# shell quotes for info command\n\t    s/\\n(.)/\\n.br\\n$1/g;\t\t# separate lines for each item\n\t}\n    }\n\n    # Check if matched paragraph contains /pat/.\n    if (%append_match)\n    {\n\tfor my $pat (keys %append_match)\n\t{\n\t    if ($matched =~ $pat)\n\t    {\n\t\t$content .= \".PP\\n\" unless $append_match{$pat} =~ /^\\./;\n\t\t$content .= $append_match{$pat};\n\t    }\n\t}\n    }\n\n    $include{$sect} .= $content;\n}\n\n# Refer to the real documentation.\nunless ($opt_no_info)\n{\n    my $info_page = $opt_info || $program;\n\n    $sect = _('SEE ALSO');\n    $include{$sect} .= \".PP\\n\" if $include{$sect};\n    $include{$sect} .= sprintf _(<<'EOT'), $program, $program, $info_page;\nThe full documentation for\n.B %s\nis maintained as a Texinfo manual.  If the\n.B info\nand\n.B %s\nprograms are properly installed at your site, the command\n.IP\n.B info %s\n.PP\nshould give you access to the complete manual.\nEOT\n}\n\n# Append additional text.\nwhile (my ($sect, $text) = each %append)\n{\n    $include{$sect} .= $append{$sect};\n}\n\n# Replace sections.\nwhile (my ($sect, $text) = each %replace)\n{\n    $include{$sect} = $replace{$sect};\n}\n\n# Output header.\nprint <<EOT;\n.\\\\\" DO NOT MODIFY THIS FILE!  It was generated by $this_program $this_version.\n.TH $PROGRAM \"$section\" \"$date\" \"$source\" \"$manual\"\nEOT\n\n# Section ordering.\nmy @pre = (_('NAME'), _('SYNOPSIS'), _('DESCRIPTION'), _('OPTIONS'),\n    _('EXAMPLES'));\nmy @post = (_('ENVIRONMENT'), _('FILES'), _('AUTHOR'),\n    _('REPORTING BUGS'), _('COPYRIGHT'), _('SEE ALSO'));\nmy %filter = map { $_ => 1 } @pre, @post;\n\n# Output content.\nmy %done;\nfor my $sect (@pre, (grep !$filter{$_}, @sections), @post)\n{\n    next if $done{$sect}++;  # ignore duplicates\n    next unless $include{$sect};\n    if ($include{$sect})\n    {\n\tmy $quote = $sect =~ /\\W/ ? '\"' : '';\n\tprint enc \".SH $quote$sect$quote\\n\";\n\n\tfor ($include{$sect})\n\t{\n            # Add bold style around referenced pages.\n            if ($opt_bold_refs)\n            {\n                # This will ignore entries already marked up (with \\)\n                s/(^|\\s|,)([\\[\\w\\x83]+)\\(([1-9][[:lower:]]?)\\)/$1\\\\fB$2\\\\fP($3)/g;\n            }\n\n\t    # Replace leading dot, apostrophe, backslash and hyphen\n\t    # tokens.\n\t    s/\\x80/\\\\&./g;\n\t    s/\\x81/\\\\&'/g;\n\t    s/\\x82/\\\\e/g;\n\t    s/\\x83/\\\\-/g;\n\n\t    # Convert some latin1 chars to troff equivalents\n\t    s/\\xa0/\\\\ /g; # non-breaking space\n\n\t    print enc $_;\n\t}\n    }\n}\n\nclose STDOUT or kark N_(\"%s: error writing to %s (%s)\"), $this_program,\n    $opt_output || 'stdout', $!;\n\nexit;\n\n# Get program basename, and strip libtool \"lt-\" prefix if required.\nsub program_basename\n{\n    local $_ = shift;\n    s!.*/!!;\n    s/^lt-// if $opt_libtool;\n    $_;\n}\n\n# Call program with given option and return results.\nsub get_option_value\n{\n    my ($prog, $opt) = @_;\n    my $stderr = $discard_stderr ? '/dev/null' : '&1';\n    my $value = join '',\n\tmap { s/ +$//; expand $_ }\n\tmap { dec $_ }\n\t`$prog $opt 2>$stderr`;\n\n    unless ($value)\n    {\n\tmy $err = N_(\"%s: can't get `%s' info from %s%s\");\n\tmy $extra = $discard_stderr\n\t    ? \"\\n\" . N_(\"Try `--no-discard-stderr' if option outputs to stderr\")\n\t    : '';\n\n\tkark $err, $this_program, $opt, $prog, $extra;\n    }\n\n    $value;\n}\n\n# Convert option dashes to \\- to stop nroff from hyphenating 'em, and\n# embolden.  Option arguments get italicised.\nsub convert_option\n{\n    local $_ = '\\fB' . shift;\n\n    s/-/\\x83/g;\n    unless (s/\\[=(.*)\\]$/\\\\fR[=\\\\fI$1\\\\fR]/)\n    {\n\ts/=(.)/\\\\fR=\\\\fI$1/;\n\ts/ (.)/ \\\\fI$1/;\n\t$_ .= '\\fR';\n    }\n\n    $_;\n}\n\n# Insert spacing escape characters \\, and \\/ before and after italic text.  See\n# https://www.gnu.org/software/groff/manual/html_node/Ligatures-and-Kerning.html\nsub fix_italic_spacing\n{\n    local $_ = shift;\n    s!\\\\fI(.*?)\\\\f([BRP])!\\\\fI\\\\,$1\\\\/\\\\f$2!g;\n    return $_;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}