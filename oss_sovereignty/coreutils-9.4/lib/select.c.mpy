{
  "module_name": "select.c",
  "hash_id": "fe8f27b2689f45a05fb0ca327745df4380803201ddcea11a13d250e56892392a",
  "original_prompt": "Ingested from coreutils-9.4/lib/select.c",
  "human_readable_source": " \n#include <sys/select.h>\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n\n#include <alloca.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits.h>\n\n#include <winsock2.h>\n#include <windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <conio.h>\n#include <time.h>\n\n \n#include <sys/time.h>\n\n#if GNULIB_MSVC_NOTHROW\n# include \"msvc-nothrow.h\"\n#else\n# include <io.h>\n#endif\n\n#undef select\n\n \n#undef GetModuleHandle\n#define GetModuleHandle GetModuleHandleA\n#undef PeekConsoleInput\n#define PeekConsoleInput PeekConsoleInputA\n#undef CreateEvent\n#define CreateEvent CreateEventA\n#undef PeekMessage\n#define PeekMessage PeekMessageA\n#undef DispatchMessage\n#define DispatchMessage DispatchMessageA\n\n \n#define GetProcAddress \\\n  (void *) GetProcAddress\n\nstruct bitset {\n  unsigned char in[FD_SETSIZE / CHAR_BIT];\n  unsigned char out[FD_SETSIZE / CHAR_BIT];\n};\n\n \ntypedef struct _FILE_PIPE_LOCAL_INFORMATION {\n  ULONG NamedPipeType;\n  ULONG NamedPipeConfiguration;\n  ULONG MaximumInstances;\n  ULONG CurrentInstances;\n  ULONG InboundQuota;\n  ULONG ReadDataAvailable;\n  ULONG OutboundQuota;\n  ULONG WriteQuotaAvailable;\n  ULONG NamedPipeState;\n  ULONG NamedPipeEnd;\n} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;\n\ntypedef struct _IO_STATUS_BLOCK\n{\n  union {\n    DWORD Status;\n    PVOID Pointer;\n  } u;\n  ULONG_PTR Information;\n} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;\n\ntypedef enum _FILE_INFORMATION_CLASS {\n  FilePipeLocalInformation = 24\n} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;\n\ntypedef DWORD (WINAPI *PNtQueryInformationFile)\n         (HANDLE, IO_STATUS_BLOCK *, VOID *, ULONG, FILE_INFORMATION_CLASS);\n\n#ifndef PIPE_BUF\n#define PIPE_BUF        512\n#endif\n\nstatic BOOL IsConsoleHandle (HANDLE h)\n{\n  DWORD mode;\n  return GetConsoleMode (h, &mode) != 0;\n}\n\nstatic BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n   \n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}\n\n \n\nstatic int\nwindows_poll_handle (HANDLE h, int fd,\n                     struct bitset *rbits,\n                     struct bitset *wbits,\n                     struct bitset *xbits)\n{\n  BOOL read, write, except;\n  int i, ret;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  read = write = except = FALSE;\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_DISK:\n      read = TRUE;\n      write = TRUE;\n      break;\n\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            read = TRUE;\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        ;\n\n      else\n        {\n           \n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            write = TRUE;\n        }\n      break;\n\n    case FILE_TYPE_CHAR:\n      write = TRUE;\n      if (!(rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n        break;\n\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        {\n          if (!IsConsoleHandle (h))\n            {\n              read = TRUE;\n              break;\n            }\n\n          nbuffer = avail = 0;\n          bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n\n           \n          assert (bRet);\n          if (nbuffer == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              read = TRUE;\n        }\n      break;\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      write = TRUE;\n      if (ret == WAIT_OBJECT_0)\n        read = TRUE;\n\n      break;\n    }\n\n  ret = 0;\n  if (read && (rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      rbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (write && (wbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      wbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (except && (xbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      xbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  return ret;\n}\n\nint\nrpl_select (int nfds, fd_set *rfds, fd_set *wfds, fd_set *xfds,\n            struct timeval *timeout)\n#undef timeval\n{\n  static struct timeval tv0;\n  static HANDLE hEvent;\n  HANDLE h, handle_array[FD_SETSIZE + 2];\n  fd_set handle_rfds, handle_wfds, handle_xfds;\n  struct bitset rbits, wbits, xbits;\n  unsigned char anyfds_in[FD_SETSIZE / CHAR_BIT];\n  DWORD ret, wait_timeout, nhandles, nsock, nbuffer;\n  MSG msg;\n  int i, fd, rc;\n  clock_t tend;\n\n  if (nfds < 0 || nfds > FD_SETSIZE)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (!timeout)\n    wait_timeout = INFINITE;\n  else\n    {\n      wait_timeout = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;\n\n       \n      if (!rfds && !wfds && !xfds)\n        {\n          Sleep (wait_timeout);\n          return 0;\n        }\n    }\n\n  if (!hEvent)\n    hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);\n\n  handle_array[0] = hEvent;\n  nhandles = 1;\n  nsock = 0;\n\n   \n  memset (&rbits, 0, sizeof (rbits));\n  memset (&wbits, 0, sizeof (wbits));\n  memset (&xbits, 0, sizeof (xbits));\n  memset (anyfds_in, 0, sizeof (anyfds_in));\n  if (rfds)\n    for (i = 0; i < rfds->fd_count; i++)\n      {\n        fd = rfds->fd_array[i];\n        h = (HANDLE) _get_osfhandle (fd);\n        if (IsConsoleHandle (h)\n            && !GetNumberOfConsoleInputEvents (h, &nbuffer))\n          continue;\n\n        rbits.in[fd / CHAR_BIT] |= 1 << (fd & (CHAR_BIT - 1));\n        anyfds_in[fd / CHAR_BIT] |= 1 << (fd & (CHAR_BIT - 1));\n      }\n  else\n    rfds = (fd_set *) alloca (sizeof (fd_set));\n\n  if (wfds)\n    for (i = 0; i < wfds->fd_count; i++)\n      {\n        fd = wfds->fd_array[i];\n        h = (HANDLE) _get_osfhandle (fd);\n        if (IsConsoleHandle (h)\n            && GetNumberOfConsoleInputEvents (h, &nbuffer))\n          continue;\n\n        wbits.in[fd / CHAR_BIT] |= 1 << (fd & (CHAR_BIT - 1));\n        anyfds_in[fd / CHAR_BIT] |= 1 << (fd & (CHAR_BIT - 1));\n      }\n  else\n    wfds = (fd_set *) alloca (sizeof (fd_set));\n\n  if (xfds)\n    for (i = 0; i < xfds->fd_count; i++)\n      {\n        fd = xfds->fd_array[i];\n        xbits.in[fd / CHAR_BIT] |= 1 << (fd & (CHAR_BIT - 1));\n        anyfds_in[fd / CHAR_BIT] |= 1 << (fd & (CHAR_BIT - 1));\n      }\n  else\n    xfds = (fd_set *) alloca (sizeof (fd_set));\n\n   \n  FD_ZERO (rfds);\n  FD_ZERO (wfds);\n  FD_ZERO (xfds);\n  FD_ZERO (&handle_rfds);\n  FD_ZERO (&handle_wfds);\n  FD_ZERO (&handle_xfds);\n\n   \n  for (i = 0; i < nfds; i++)\n    {\n      if ((anyfds_in[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1)))) == 0)\n        continue;\n\n      h = (HANDLE) _get_osfhandle (i);\n      if (!h)\n        {\n          errno = EBADF;\n          return -1;\n        }\n\n      if (IsSocketHandle (h))\n        {\n          int requested = FD_CLOSE;\n\n           \n          if (rbits.in[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n            {\n              requested |= FD_READ | FD_ACCEPT;\n              FD_SET ((SOCKET) h, rfds);\n              FD_SET ((SOCKET) h, &handle_rfds);\n            }\n          if (wbits.in[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n            {\n              requested |= FD_WRITE | FD_CONNECT;\n              FD_SET ((SOCKET) h, wfds);\n              FD_SET ((SOCKET) h, &handle_wfds);\n            }\n          if (xbits.in[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n            {\n              requested |= FD_OOB;\n              FD_SET ((SOCKET) h, xfds);\n              FD_SET ((SOCKET) h, &handle_xfds);\n            }\n\n          WSAEventSelect ((SOCKET) h, hEvent, requested);\n          nsock++;\n        }\n      else\n        {\n          handle_array[nhandles++] = h;\n\n           \n          if (wait_timeout != 0\n              && windows_poll_handle (h, i, &rbits, &wbits, &xbits))\n            wait_timeout = 0;\n        }\n    }\n\n   \n  handle_array[nhandles] = NULL;\n\n   \n  if (wait_timeout != INFINITE)\n    tend = clock () + wait_timeout;\n\nrestart:\n  if (wait_timeout == 0 || nsock == 0)\n    rc = 0;\n  else\n    {\n       \n      rc = select (0, &handle_rfds, &handle_wfds, &handle_xfds, &tv0);\n      if (rc == 0)\n        {\n           \n          memcpy (&handle_rfds, rfds, sizeof (fd_set));\n          memcpy (&handle_wfds, wfds, sizeof (fd_set));\n          memcpy (&handle_xfds, xfds, sizeof (fd_set));\n        }\n      else\n        wait_timeout = 0;\n    }\n\n   \n  if (wait_timeout != INFINITE)\n    {\n      clock_t tnow = clock ();\n      if (tend >= tnow)\n        wait_timeout = tend - tnow;\n      else\n        wait_timeout = 0;\n    }\n\n  for (;;)\n    {\n      ret = MsgWaitForMultipleObjects (nhandles, handle_array, FALSE,\n                                       wait_timeout, QS_ALLINPUT);\n\n      if (ret == WAIT_OBJECT_0 + nhandles)\n        {\n           \n          BOOL bRet;\n          while ((bRet = PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) != 0)\n            {\n              TranslateMessage (&msg);\n              DispatchMessage (&msg);\n            }\n        }\n      else\n        break;\n    }\n\n   \n  if (rc == 0 && nsock > 0)\n    rc = select (0, &handle_rfds, &handle_wfds, &handle_xfds, &tv0);\n\n  if (nhandles > 1)\n    {\n       \n      nhandles = 1;\n      for (i = 0; i < nfds; i++)\n        {\n          if ((anyfds_in[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1)))) == 0)\n            continue;\n\n          h = (HANDLE) _get_osfhandle (i);\n          if (h == handle_array[nhandles])\n            {\n               \n              nhandles++;\n              windows_poll_handle (h, i, &rbits, &wbits, &xbits);\n              if (rbits.out[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1)))\n                  || wbits.out[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1)))\n                  || xbits.out[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n                rc++;\n            }\n        }\n\n      if (rc == 0\n          && (wait_timeout == INFINITE\n               \n              || (wait_timeout != 0 && nhandles > 1)))\n        {\n           \n          memcpy (&handle_rfds, rfds, sizeof (fd_set));\n          memcpy (&handle_wfds, wfds, sizeof (fd_set));\n          memcpy (&handle_xfds, xfds, sizeof (fd_set));\n          SleepEx (1, TRUE);\n          goto restart;\n        }\n      if (timeout && wait_timeout == 0 && rc == 0)\n        timeout->tv_sec = timeout->tv_usec = 0;\n    }\n\n   \n  FD_ZERO (rfds);\n  FD_ZERO (wfds);\n  FD_ZERO (xfds);\n  nhandles = 1;\n  for (i = 0; i < nfds; i++)\n    {\n      if ((anyfds_in[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1)))) == 0)\n        continue;\n\n      h = (HANDLE) _get_osfhandle (i);\n      if (h != handle_array[nhandles])\n        {\n           \n          SOCKET s = (SOCKET) h;\n          WSAEventSelect (s, NULL, 0);\n          if (FD_ISSET (s, &handle_rfds))\n            FD_SET (i, rfds);\n          if (FD_ISSET (s, &handle_wfds))\n            FD_SET (i, wfds);\n          if (FD_ISSET (s, &handle_xfds))\n            FD_SET (i, xfds);\n        }\n      else\n        {\n           \n          nhandles++;\n          if (rbits.out[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n            FD_SET (i, rfds);\n          if (wbits.out[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n            FD_SET (i, wfds);\n          if (xbits.out[i / CHAR_BIT] & (1 << (i & (CHAR_BIT - 1))))\n            FD_SET (i, xfds);\n        }\n    }\n\n  return rc;\n}\n\n#else  \n\n#include <stddef.h>  \n#include <errno.h>\n#include <unistd.h>\n\n#undef select\n\nint\nrpl_select (int nfds, fd_set *rfds, fd_set *wfds, fd_set *xfds,\n            struct timeval *timeout)\n{\n  int i;\n\n   \n  if (nfds < 0 || nfds > FD_SETSIZE)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  for (i = 0; i < nfds; i++)\n    {\n      if (((rfds && FD_ISSET (i, rfds))\n           || (wfds && FD_ISSET (i, wfds))\n           || (xfds && FD_ISSET (i, xfds)))\n          && dup2 (i, i) != i)\n        return -1;\n    }\n\n   \n  if (nfds == 0)\n    {\n      nfds = 1;\n      rfds = NULL;\n      wfds = NULL;\n      xfds = NULL;\n    }\n  return select (nfds, rfds, wfds, xfds, timeout);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}