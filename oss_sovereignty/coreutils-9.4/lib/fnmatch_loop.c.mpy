{
  "module_name": "fnmatch_loop.c",
  "hash_id": "92a8a9dc33e9904c0def5fd02fc2aa5e3c01be8ac8d7be9f6f119987ebce5fe3",
  "original_prompt": "Ingested from coreutils-9.4/lib/fnmatch_loop.c",
  "human_readable_source": " \nstatic int FCT (const CHAR *pattern, const CHAR *string,\n                const CHAR *string_end, bool no_leading_period, int flags,\n                struct STRUCT *ends, size_t alloca_used);\nstatic int EXT (INT opt, const CHAR *pattern, const CHAR *string,\n                const CHAR *string_end, bool no_leading_period, int flags,\n                size_t alloca_used);\nstatic const CHAR *END (const CHAR *patternp);\n\nstatic int\nFCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags, struct STRUCT *ends, size_t alloca_used)\n{\n  const CHAR *p = pattern, *n = string;\n  UCHAR c;\n#ifdef _LIBC\n# if WIDE_CHAR_VERSION\n  const char *collseq = (const char *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n# else\n  const UCHAR *collseq = (const UCHAR *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n# endif\n#endif\n\n  while ((c = *p++) != L_('\\0'))\n    {\n      bool new_no_leading_period = false;\n      c = FOLD (c);\n\n      switch (c)\n        {\n        case L_('?'):\n          if (__glibc_unlikely (flags & FNM_EXTMATCH) && *p == '(')\n            {\n              int res = EXT (c, p, n, string_end, no_leading_period,\n                             flags, alloca_used);\n              if (res != -1)\n                return res;\n            }\n\n          if (n == string_end)\n            return FNM_NOMATCH;\n          else if (*n == L_('/') && (flags & FNM_FILE_NAME))\n            return FNM_NOMATCH;\n          else if (*n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('\\\\'):\n          if (!(flags & FNM_NOESCAPE))\n            {\n              c = *p++;\n              if (c == L_('\\0'))\n                 \n                return FNM_NOMATCH;\n              c = FOLD (c);\n            }\n          if (n == string_end || FOLD ((UCHAR) *n) != c)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('*'):\n          if (__glibc_unlikely (flags & FNM_EXTMATCH) && *p == '(')\n            {\n              int res = EXT (c, p, n, string_end, no_leading_period,\n                             flags, alloca_used);\n              if (res != -1)\n                return res;\n            }\n          else if (ends != NULL)\n            {\n              ends->pattern = p - 1;\n              ends->string = n;\n              ends->no_leading_period = no_leading_period;\n              return 0;\n            }\n\n          if (n != string_end && *n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n\n          for (c = *p++; c == L_('?') || c == L_('*'); c = *p++)\n            {\n              if (*p == L_('(') && (flags & FNM_EXTMATCH) != 0)\n                {\n                  const CHAR *endp = END (p);\n                  if (endp != p)\n                    {\n                       \n                      p = endp;\n                      continue;\n                    }\n                }\n\n              if (c == L_('?'))\n                {\n                   \n                  if (n == string_end)\n                     \n                    return FNM_NOMATCH;\n                  else if (*n == L_('/')\n                           && __glibc_unlikely (flags & FNM_FILE_NAME))\n                     \n                    return FNM_NOMATCH;\n                  else\n                     \n                    ++n;\n                }\n            }\n\n          if (c == L_('\\0'))\n             \n            {\n              int result = (flags & FNM_FILE_NAME) == 0 ? 0 : FNM_NOMATCH;\n\n              if (flags & FNM_FILE_NAME)\n                {\n                  if (flags & FNM_LEADING_DIR)\n                    result = 0;\n                  else\n                    {\n                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)\n                        result = 0;\n                    }\n                }\n\n              return result;\n            }\n          else\n            {\n              const CHAR *endp;\n              struct STRUCT end;\n\n              end.pattern = NULL;\n              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\\0'),\n                             string_end - n);\n              if (endp == NULL)\n                endp = string_end;\n\n              if (c == L_('[')\n                  || (__glibc_unlikely (flags & FNM_EXTMATCH)\n                      && (c == L_('@') || c == L_('+') || c == L_('!'))\n                      && *p == L_('(')))\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n\n                  for (--p; n < endp; ++n, no_leading_period = false)\n                    if (FCT (p, n, string_end, no_leading_period, flags2,\n                             &end, alloca_used) == 0)\n                      goto found;\n                }\n              else if (c == L_('/') && (flags & FNM_FILE_NAME))\n                {\n                  while (n < string_end && *n != L_('/'))\n                    ++n;\n                  if (n < string_end && *n == L_('/')\n                      && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags,\n                               NULL, alloca_used) == 0))\n                    return 0;\n                }\n              else\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n\n                  if (c == L_('\\\\') && !(flags & FNM_NOESCAPE))\n                    c = *p;\n                  c = FOLD (c);\n                  for (--p; n < endp; ++n, no_leading_period = false)\n                    if (FOLD ((UCHAR) *n) == c\n                        && (FCT (p, n, string_end, no_leading_period, flags2,\n                                 &end, alloca_used) == 0))\n                      {\n                      found:\n                        if (end.pattern == NULL)\n                          return 0;\n                        break;\n                      }\n                  if (end.pattern != NULL)\n                    {\n                      p = end.pattern;\n                      n = end.string;\n                      no_leading_period = end.no_leading_period;\n                      continue;\n                    }\n                }\n            }\n\n           \n          return FNM_NOMATCH;\n\n        case L_('['):\n          {\n             \n            const CHAR *p_init = p;\n            const CHAR *n_init = n;\n            bool not;\n            CHAR cold;\n            UCHAR fn;\n\n            if (posixly_correct == 0)\n              posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n            if (n == string_end)\n              return FNM_NOMATCH;\n\n            if (*n == L_('.') && no_leading_period)\n              return FNM_NOMATCH;\n\n            if (*n == L_('/') && (flags & FNM_FILE_NAME))\n               \n              return FNM_NOMATCH;\n\n            not = (*p == L_('!') || (posixly_correct < 0 && *p == L_('^')));\n            if (not)\n              ++p;\n\n            fn = FOLD ((UCHAR) *n);\n\n            c = *p++;\n            for (;;)\n              {\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = FOLD ((UCHAR) *p);\n                    ++p;\n\n                    goto normal_bracket;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                     \n                    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];\n                    size_t c1 = 0;\n                    WCTYPE_T wt;\n                    const CHAR *startp = p;\n\n                    for (;;)\n                      {\n                        if (c1 == CHAR_CLASS_MAX_LENGTH)\n                           \n                          return FNM_NOMATCH;\n\n                        c = *++p;\n                        if (c == L_(':') && p[1] == L_(']'))\n                          {\n                            p += 2;\n                            break;\n                          }\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                             \n                            p = startp;\n                            c = L_('[');\n                            goto normal_bracket;\n                          }\n                        str[c1++] = c;\n                      }\n                    str[c1] = L_('\\0');\n\n                    wt = IS_CHAR_CLASS (str);\n                    if (wt == 0)\n                       \n                      return FNM_NOMATCH;\n\n#if defined _LIBC && ! WIDE_CHAR_VERSION\n                     \n                    if (_ISCTYPE ((UCHAR) *n, wt))\n                      goto matched;\n#else\n                    if (ISWCTYPE (UCHAR_TO_WCHAR ((UCHAR) *n), wt))\n                      goto matched;\n#endif\n                    c = *p++;\n                  }\n#ifdef _LIBC\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                     \n                    UCHAR str;\n                    uint32_t nrules =\n                      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                    const CHAR *startp = p;\n\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    str = c;\n\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    p += 2;\n\n                    if (nrules == 0)\n                      {\n                        if ((UCHAR) *n == str)\n                          goto matched;\n                      }\n                    else\n                      {\n                        const int32_t *table;\n# if WIDE_CHAR_VERSION\n                        const int32_t *weights;\n                        const wint_t *extra;\n# else\n                        const unsigned char *weights;\n                        const unsigned char *extra;\n# endif\n                        const int32_t *indirect;\n                        int32_t idx;\n                        const UCHAR *cp = (const UCHAR *) &str;\n\n# if WIDE_CHAR_VERSION\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);\n                        weights = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);\n                        extra = (const wint_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);\n# else\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n                        weights = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n                        extra = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n# endif\n\n                        idx = FINDIDX (table, indirect, extra, &cp, 1);\n                        if (idx != 0)\n                          {\n                             \n                            int len = weights[idx & 0xffffff];\n                            int32_t idx2;\n                            const UCHAR *np = (const UCHAR *) n;\n\n                            idx2 = FINDIDX (table, indirect, extra,\n                                            &np, string_end - n);\n                            if (idx2 != 0\n                                && (idx >> 24) == (idx2 >> 24)\n                                && len == weights[idx2 & 0xffffff])\n                              {\n                                int cnt = 0;\n\n                                idx &= 0xffffff;\n                                idx2 &= 0xffffff;\n\n                                while (cnt < len\n                                       && (weights[idx + 1 + cnt]\n                                           == weights[idx2 + 1 + cnt]))\n                                  ++cnt;\n\n                                if (cnt == len)\n                                  goto matched;\n                              }\n                          }\n                      }\n\n                    c = *p++;\n                  }\n#endif\n                else if (c == L_('\\0'))\n                  {\n                     \n                    p = p_init;\n                    n = n_init;\n                    c = L_('[');\n                    goto normal_match;\n                  }\n                else\n                  {\n                    bool is_range = false;\n\n#ifdef _LIBC\n                    bool is_seqval = false;\n\n                    if (c == L_('[') && *p == L_('.'))\n                      {\n                        uint32_t nrules =\n                          _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                        const CHAR *startp = p;\n                        size_t c1 = 0;\n\n                        while (1)\n                          {\n                            c = *++p;\n                            if (c == L_('.') && p[1] == L_(']'))\n                              {\n                                p += 2;\n                                break;\n                              }\n                            if (c == '\\0')\n                              return FNM_NOMATCH;\n                            ++c1;\n                          }\n\n                         \n                        is_range = *p == L_('-') && p[1] != L_('\\0');\n\n                        if (nrules == 0)\n                          {\n                             \n                            if (c1 != 1)\n                              return FNM_NOMATCH;\n\n                            if (!is_range && *n == startp[1])\n                              goto matched;\n\n                            cold = startp[1];\n                            c = *p++;\n                          }\n                        else\n                          {\n                            int32_t table_size;\n                            const int32_t *symb_table;\n                            const unsigned char *extra;\n                            int32_t idx;\n                            int32_t elem;\n# if WIDE_CHAR_VERSION\n                            CHAR *wextra;\n# endif\n\n                            table_size =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_SYMB_HASH_SIZEMB);\n                            symb_table = (const int32_t *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_TABLEMB);\n                            extra = (const unsigned char *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_EXTRAMB);\n\n                            for (elem = 0; elem < table_size; elem++)\n                              if (symb_table[2 * elem] != 0)\n                                {\n                                  idx = symb_table[2 * elem + 1];\n                                   \n                                  idx += 1 + extra[idx];\n# if WIDE_CHAR_VERSION\n                                   \n                                  idx += 1 + extra[idx];\n                                   \n                                  idx = (idx + 3) & ~3;\n\n                                  wextra = (CHAR *) &extra[idx + 4];\n\n                                  if ( \n                                      c1 == wextra[0]\n                                       \n                                      && (__wmemcmp (startp + 1, &wextra[1],\n                                                     c1)\n                                          == 0))\n                                     \n                                    break;\n# else\n                                  if ( \n                                      c1 == extra[idx]\n                                       \n                                      && memcmp (startp + 1,\n                                                 &extra[idx + 1], c1) == 0)\n                                     \n                                    break;\n# endif\n                                }\n\n                            if (elem < table_size)\n                              {\n                                 \n                                if (! is_range\n\n# if WIDE_CHAR_VERSION\n                                    && __wmemcmp (n, &wextra[1], c1) == 0\n# else\n                                    && memcmp (n, &extra[idx + 1], c1) == 0\n# endif\n                                    )\n                                  {\n                                    n += c1 - 1;\n                                    goto matched;\n                                  }\n\n                                 \n                                is_seqval = true;\n# if WIDE_CHAR_VERSION\n                                cold = wextra[1 + wextra[0]];\n# else\n                                idx += 1 + extra[idx];\n                                 \n                                idx = (idx + 3) & ~3;\n                                cold = *((int32_t *) &extra[idx]);\n# endif\n\n                                c = *p++;\n                              }\n                            else if (c1 == 1)\n                              {\n                                 \n                                if (!is_range && *n == startp[1])\n                                  goto matched;\n\n                                cold = startp[1];\n                                c = *p++;\n                              }\n                            else\n                              return FNM_NOMATCH;\n                          }\n                      }\n                    else\n#endif\n                      {\n                        c = FOLD (c);\n                      normal_bracket:\n\n                         \n                        is_range = (*p == L_('-') && p[1] != L_('\\0')\n                                    && p[1] != L_(']'));\n\n                        if (!is_range && c == fn)\n                          goto matched;\n\n#if _LIBC\n                         \n                        is_seqval = false;\n#endif\n                        cold = c;\n                        c = *p++;\n                      }\n\n                    if (c == L_('-') && *p != L_(']'))\n                      {\n#if _LIBC\n                         \n                        uint32_t fcollseq;\n                        uint32_t lcollseq;\n                        UCHAR cend = *p++;\n\n# if WIDE_CHAR_VERSION\n                         \n                        fcollseq = __collseq_table_lookup (collseq, fn);\n                        if (fcollseq == ~((uint32_t) 0))\n                           \n                          goto range_not_matched;\n\n                        if (is_seqval)\n                          lcollseq = cold;\n                        else\n                          lcollseq = __collseq_table_lookup (collseq, cold);\n# else\n                        fcollseq = collseq[fn];\n                        lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];\n# endif\n\n                        is_seqval = false;\n                        if (cend == L_('[') && *p == L_('.'))\n                          {\n                            uint32_t nrules =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_NRULES);\n                            const CHAR *startp = p;\n                            size_t c1 = 0;\n\n                            while (1)\n                              {\n                                c = *++p;\n                                if (c == L_('.') && p[1] == L_(']'))\n                                  {\n                                    p += 2;\n                                    break;\n                                  }\n                                if (c == '\\0')\n                                  return FNM_NOMATCH;\n                                ++c1;\n                              }\n\n                            if (nrules == 0)\n                              {\n                                 \n                                if (c1 != 1)\n                                  return FNM_NOMATCH;\n\n                                cend = startp[1];\n                              }\n                            else\n                              {\n                                int32_t table_size;\n                                const int32_t *symb_table;\n                                const unsigned char *extra;\n                                int32_t idx;\n                                int32_t elem;\n# if WIDE_CHAR_VERSION\n                                CHAR *wextra;\n# endif\n\n                                table_size =\n                                  _NL_CURRENT_WORD (LC_COLLATE,\n                                                    _NL_COLLATE_SYMB_HASH_SIZEMB);\n                                symb_table = (const int32_t *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_TABLEMB);\n                                extra = (const unsigned char *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_EXTRAMB);\n\n                                for (elem = 0; elem < table_size; elem++)\n                                  if (symb_table[2 * elem] != 0)\n                                    {\n                                      idx = symb_table[2 * elem + 1];\n                                       \n                                      idx += 1 + extra[idx];\n# if WIDE_CHAR_VERSION\n                                       \n                                      idx += 1 + extra[idx];\n                                       \n                                      idx = (idx + 3) & ~3;\n\n                                      wextra = (CHAR *) &extra[idx + 4];\n\n                                      if ( \n                                          c1 == wextra[0]\n                                           \n                                          && (__wmemcmp (startp + 1,\n                                                         &wextra[1], c1)\n                                              == 0))\n                                         \n                                        break;\n# else\n                                      if ( \n                                          c1 == extra[idx]\n                                           \n                                          && memcmp (startp + 1,\n                                                     &extra[idx + 1], c1) == 0)\n                                         \n                                        break;\n# endif\n                                    }\n\n                                if (elem < table_size)\n                                  {\n                                     \n                                    is_seqval = true;\n# if WIDE_CHAR_VERSION\n                                    cend = wextra[1 + wextra[0]];\n# else\n                                    idx += 1 + extra[idx];\n                                     \n                                    idx = (idx + 3) & ~3;\n                                    cend = *((int32_t *) &extra[idx]);\n# endif\n                                  }\n                                else if (c1 == 1)\n                                  {\n                                    cend = startp[1];\n                                    c = *p++;\n                                  }\n                                else\n                                  return FNM_NOMATCH;\n                              }\n                          }\n                        else\n                          {\n                            if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                              cend = *p++;\n                            if (cend == L_('\\0'))\n                              return FNM_NOMATCH;\n                            cend = FOLD (cend);\n                          }\n\n                         \n                        if (\n# if WIDE_CHAR_VERSION\n                            lcollseq == 0xffffffff ||\n# endif\n                            lcollseq <= fcollseq)\n                          {\n                             \n                            uint32_t hcollseq;\n\n                            if (is_seqval)\n                              hcollseq = cend;\n                            else\n                              {\n# if WIDE_CHAR_VERSION\n                                hcollseq =\n                                  __collseq_table_lookup (collseq, cend);\n                                if (hcollseq == ~((uint32_t) 0))\n                                  {\n                                     \n                                    if (lcollseq != fcollseq)\n                                      goto range_not_matched;\n\n                                    goto matched;\n                                  }\n# else\n                                hcollseq = collseq[cend];\n# endif\n                              }\n\n                            if (lcollseq <= hcollseq && fcollseq <= hcollseq)\n                              goto matched;\n                          }\n# if WIDE_CHAR_VERSION\n                      range_not_matched:\n# endif\n#else\n                         \n                        UCHAR cend = *p++;\n\n                        if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                          cend = *p++;\n                        if (cend == L_('\\0'))\n                          return FNM_NOMATCH;\n\n                         \n                        if ((UCHAR) cold <= fn && fn <= cend)\n                          goto matched;\n#endif\n\n                        c = *p++;\n                      }\n                  }\n\n                if (c == L_(']'))\n                  break;\n              }\n\n            if (!not)\n              return FNM_NOMATCH;\n            break;\n\n          matched:\n             \n            while ((c = *p++) != L_(']'))\n              {\n                if (c == L_('\\0'))\n                   \n                  return FNM_NOMATCH;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                     \n                    ++p;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    int c1 = 0;\n                    const CHAR *startp = p;\n\n                    while (1)\n                      {\n                        c = *++p;\n                        if (++c1 == CHAR_CLASS_MAX_LENGTH)\n                          return FNM_NOMATCH;\n\n                        if (*p == L_(':') && p[1] == L_(']'))\n                          break;\n\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            p = startp - 2;\n                            break;\n                          }\n                      }\n                    p += 2;\n                  }\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      return FNM_NOMATCH;\n                    p += 2;\n                  }\n                else if (c == L_('[') && *p == L_('.'))\n                  {\n                    while (1)\n                      {\n                        c = *++p;\n                        if (c == L_('\\0'))\n                          return FNM_NOMATCH;\n\n                        if (c == L_('.') && p[1] == L_(']'))\n                          break;\n                      }\n                    p += 2;\n                  }\n              }\n            if (not)\n              return FNM_NOMATCH;\n          }\n          break;\n\n        case L_('+'):\n        case L_('@'):\n        case L_('!'):\n          if (__glibc_unlikely (flags & FNM_EXTMATCH) && *p == '(')\n            {\n              int res = EXT (c, p, n, string_end, no_leading_period, flags,\n                             alloca_used);\n              if (res != -1)\n                return res;\n            }\n          goto normal_match;\n\n        case L_('/'):\n          if (NO_LEADING_PERIOD (flags))\n            {\n              if (n == string_end || c != (UCHAR) *n)\n                return FNM_NOMATCH;\n\n              new_no_leading_period = true;\n              break;\n            }\n          FALLTHROUGH;\n        default:\n        normal_match:\n          if (n == string_end || c != FOLD ((UCHAR) *n))\n            return FNM_NOMATCH;\n        }\n\n      no_leading_period = new_no_leading_period;\n      ++n;\n    }\n\n  if (n == string_end)\n    return 0;\n\n  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))\n     \n    return 0;\n\n  return FNM_NOMATCH;\n}\n\n\nstatic const CHAR *\nEND (const CHAR *pattern)\n{\n  const CHAR *p = pattern;\n\n  while (1)\n    if (*++p == L_('\\0'))\n       \n      return pattern;\n    else if (*p == L_('['))\n      {\n         \n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n         \n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n         \n        if (*p == L_(']'))\n          ++p;\n         \n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n             \n            return pattern;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      {\n        p = END (p + 1);\n        if (*p == L_('\\0'))\n           \n          return pattern;\n      }\n    else if (*p == L_(')'))\n      break;\n\n  return p + 1;\n}\n\n\nstatic int\nEXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags, size_t alloca_used)\n{\n  const CHAR *startp;\n  ptrdiff_t level;\n  struct patternlist\n  {\n    struct patternlist *next;\n    CHAR malloced;\n    CHAR str __flexarr;\n  } *list = NULL;\n  struct patternlist **lastp = &list;\n  size_t pattern_len = STRLEN (pattern);\n  bool any_malloced = false;\n  const CHAR *p;\n  const CHAR *rs;\n  int retval = 0;\n\n   \n  level = 0;\n  for (startp = p = pattern + 1; level >= 0; ++p)\n    if (*p == L_('\\0'))\n      {\n         \n        retval = -1;\n        goto out;\n      }\n    else if (*p == L_('['))\n      {\n         \n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n         \n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n         \n        if (*p == L_(']'))\n          ++p;\n         \n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            {\n               \n              retval = -1;\n              goto out;\n            }\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n       \n      ++level;\n    else if (*p == L_(')'))\n      {\n        if (level-- == 0)\n          {\n             \n#define NEW_PATTERN \\\n            struct patternlist *newp;                                         \\\n            size_t plen = (opt == L_('?') || opt == L_('@')                   \\\n                           ? pattern_len : (p - startp + 1UL));               \\\n            idx_t slen = FLEXSIZEOF (struct patternlist, str, 0);             \\\n            idx_t new_used = alloca_used + slen;                              \\\n            idx_t plensize;                                                   \\\n            if (ckd_mul (&plensize, plen, sizeof (CHAR))                      \\\n                || ckd_add (&new_used, new_used, plensize))                   \\\n              {                                                               \\\n                retval = -2;                                                  \\\n                goto out;                                                     \\\n              }                                                               \\\n            slen += plensize;                                                 \\\n            bool malloced = ! __libc_use_alloca (new_used);                   \\\n            if (__glibc_unlikely (malloced))                                  \\\n              {                                                               \\\n                newp = malloc (slen);                                         \\\n                if (newp == NULL)                                             \\\n                  {                                                           \\\n                    retval = -2;                                              \\\n                    goto out;                                                 \\\n                  }                                                           \\\n                any_malloced = true;                                          \\\n              }                                                               \\\n            else                                                              \\\n              newp = alloca_account (slen, alloca_used);                      \\\n            newp->next = NULL;                                                \\\n            newp->malloced = malloced;                                        \\\n            *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L_('\\0');   \\\n            *lastp = newp;                                                    \\\n            lastp = &newp->next\n            NEW_PATTERN;\n          }\n      }\n    else if (*p == L_('|'))\n      {\n        if (level == 0)\n          {\n            NEW_PATTERN;\n            startp = p + 1;\n          }\n      }\n  assert (list != NULL);\n  assert (p[-1] == L_(')'));\n#undef NEW_PATTERN\n\n  switch (opt)\n    {\n    case L_('*'):\n      if (FCT (p, string, string_end, no_leading_period, flags, NULL,\n               alloca_used) == 0)\n        goto success;\n      FALLTHROUGH;\n    case L_('+'):\n      do\n        {\n          for (rs = string; rs <= string_end; ++rs)\n             \n            if (FCT (list->str, string, rs, no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD,\n                     NULL, alloca_used) == 0\n                 \n                && (FCT (p, rs, string_end,\n                         rs == string\n                         ? no_leading_period\n                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                         flags & FNM_FILE_NAME\n                         ? flags : flags & ~FNM_PERIOD, NULL, alloca_used) == 0\n                     \n                    || (rs != string\n                        && FCT (pattern - 1, rs, string_end,\n                                rs == string\n                                ? no_leading_period\n                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                                flags & FNM_FILE_NAME\n                                ? flags : flags & ~FNM_PERIOD, NULL,\n                                alloca_used) == 0)))\n               \n              goto success;\n        }\n      while ((list = list->next) != NULL);\n\n       \n      retval = FNM_NOMATCH;\n      break;\n\n    case L_('?'):\n      if (FCT (p, string, string_end, no_leading_period, flags, NULL,\n               alloca_used) == 0)\n        goto success;\n      FALLTHROUGH;\n    case L_('@'):\n      do\n         \n        if (FCT (STRCAT (list->str, p), string, string_end,\n                 no_leading_period,\n                 flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD,\n                 NULL, alloca_used) == 0)\n           \n          goto success;\n      while ((list = list->next) != NULL);\n\n       \n      retval = FNM_NOMATCH;\n      break;\n\n    case L_('!'):\n      for (rs = string; rs <= string_end; ++rs)\n        {\n          struct patternlist *runp;\n\n          for (runp = list; runp != NULL; runp = runp->next)\n            if (FCT (runp->str, string, rs,  no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD,\n                     NULL, alloca_used) == 0)\n              break;\n\n           \n          if (runp == NULL\n              && (FCT (p, rs, string_end,\n                       rs == string\n                       ? no_leading_period\n                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                       flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD,\n                       NULL, alloca_used) == 0))\n             \n            goto success;\n        }\n\n       \n      retval = FNM_NOMATCH;\n      break;\n\n    default:\n      assert (! \"Invalid extended matching operator\");\n      retval = -1;\n      break;\n    }\n\n success:\n out:\n  if (any_malloced)\n    while (list != NULL)\n      {\n        struct patternlist *old = list;\n        list = list->next;\n        if (old->malloced)\n          free (old);\n      }\n\n  return retval;\n}\n\n\n#undef FOLD\n#undef CHAR\n#undef UCHAR\n#undef INT\n#undef FCT\n#undef EXT\n#undef END\n#undef STRUCT\n#undef MEMPCPY\n#undef MEMCHR\n#undef STRLEN\n#undef STRCAT\n#undef L_\n#undef UCHAR_TO_WCHAR\n#undef WIDE_CHAR_VERSION\n#undef FINDIDX\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}