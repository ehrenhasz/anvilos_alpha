{
  "module_name": "nproc.c",
  "hash_id": "a20dcaa66a89562307b9459d22f3f751e8fcd09a8741ed739f89cf4ae2a1407d",
  "original_prompt": "Ingested from coreutils-9.4/lib/nproc.c",
  "human_readable_source": " \n\n#include <config.h>\n#include \"nproc.h\"\n\n#include <limits.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#if HAVE_PTHREAD_GETAFFINITY_NP && 0\n# include <pthread.h>\n# include <sched.h>\n#endif\n#if HAVE_SCHED_GETAFFINITY_LIKE_GLIBC || HAVE_SCHED_GETAFFINITY_NP\n# include <sched.h>\n#endif\n\n#include <sys/types.h>\n\n#if HAVE_SYS_PSTAT_H\n# include <sys/pstat.h>\n#endif\n\n#if HAVE_SYS_SYSMP_H\n# include <sys/sysmp.h>\n#endif\n\n#if HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n\n#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__)\n# include <sys/sysctl.h>\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n#endif\n\n#include \"c-ctype.h\"\n\n#include \"minmax.h\"\n\n#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))\n\n \nstatic unsigned long\nnum_processors_via_affinity_mask (void)\n{\n   \n#if HAVE_PTHREAD_GETAFFINITY_NP && defined __GLIBC__ && 0\n  {\n    cpu_set_t set;\n\n    if (pthread_getaffinity_np (pthread_self (), sizeof (set), &set) == 0)\n      {\n        unsigned long count;\n\n# ifdef CPU_COUNT\n         \n        count = CPU_COUNT (&set);\n# else\n        size_t i;\n\n        count = 0;\n        for (i = 0; i < CPU_SETSIZE; i++)\n          if (CPU_ISSET (i, &set))\n            count++;\n# endif\n        if (count > 0)\n          return count;\n      }\n  }\n#elif HAVE_PTHREAD_GETAFFINITY_NP && defined __NetBSD__ && 0\n  {\n    cpuset_t *set;\n\n    set = cpuset_create ();\n    if (set != NULL)\n      {\n        unsigned long count = 0;\n\n        if (pthread_getaffinity_np (pthread_self (), cpuset_size (set), set)\n            == 0)\n          {\n            cpuid_t i;\n\n            for (i = 0;; i++)\n              {\n                int ret = cpuset_isset (i, set);\n                if (ret < 0)\n                  break;\n                if (ret > 0)\n                  count++;\n              }\n          }\n        cpuset_destroy (set);\n        if (count > 0)\n          return count;\n      }\n  }\n#elif HAVE_SCHED_GETAFFINITY_LIKE_GLIBC  \n  {\n    cpu_set_t set;\n\n    if (sched_getaffinity (0, sizeof (set), &set) == 0)\n      {\n        unsigned long count;\n\n# ifdef CPU_COUNT\n         \n        count = CPU_COUNT (&set);\n# else\n        size_t i;\n\n        count = 0;\n        for (i = 0; i < CPU_SETSIZE; i++)\n          if (CPU_ISSET (i, &set))\n            count++;\n# endif\n        if (count > 0)\n          return count;\n      }\n  }\n#elif HAVE_SCHED_GETAFFINITY_NP  \n  {\n    cpuset_t *set;\n\n    set = cpuset_create ();\n    if (set != NULL)\n      {\n        unsigned long count = 0;\n\n        if (sched_getaffinity_np (getpid (), cpuset_size (set), set) == 0)\n          {\n            cpuid_t i;\n\n            for (i = 0;; i++)\n              {\n                int ret = cpuset_isset (i, set);\n                if (ret < 0)\n                  break;\n                if (ret > 0)\n                  count++;\n              }\n          }\n        cpuset_destroy (set);\n        if (count > 0)\n          return count;\n      }\n  }\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n  {  \n    DWORD_PTR process_mask;\n    DWORD_PTR system_mask;\n\n    if (GetProcessAffinityMask (GetCurrentProcess (),\n                                &process_mask, &system_mask))\n      {\n        DWORD_PTR mask = process_mask;\n        unsigned long count = 0;\n\n        for (; mask != 0; mask = mask >> 1)\n          if (mask & 1)\n            count++;\n        if (count > 0)\n          return count;\n      }\n  }\n#endif\n\n  return 0;\n}\n\n\n \nstatic unsigned long int\nnum_processors_ignoring_omp (enum nproc_query query)\n{\n   \n\n  if (query == NPROC_CURRENT)\n    {\n       \n      {\n        unsigned long nprocs = num_processors_via_affinity_mask ();\n\n        if (nprocs > 0)\n          return nprocs;\n      }\n\n#if defined _SC_NPROCESSORS_ONLN\n      {  \n        long int nprocs = sysconf (_SC_NPROCESSORS_ONLN);\n        if (nprocs > 0)\n          return nprocs;\n      }\n#endif\n    }\n  else  \n    {\n#if defined _SC_NPROCESSORS_CONF\n      {  \n        long int nprocs = sysconf (_SC_NPROCESSORS_CONF);\n\n# if __GLIBC__ >= 2 && defined __linux__\n         \n        if (nprocs == 1 || nprocs == 2)\n          {\n            unsigned long nprocs_current = num_processors_via_affinity_mask ();\n\n            if (  nprocs_current > nprocs)\n              nprocs = nprocs_current;\n          }\n# endif\n\n        if (nprocs > 0)\n          return nprocs;\n      }\n#endif\n    }\n\n#if HAVE_PSTAT_GETDYNAMIC\n  {  \n    struct pst_dynamic psd;\n    if (pstat_getdynamic (&psd, sizeof psd, 1, 0) >= 0)\n      {\n         \n        if (query == NPROC_CURRENT)\n          {\n            if (psd.psd_proc_cnt > 0)\n              return psd.psd_proc_cnt;\n          }\n        else\n          {\n            if (psd.psd_max_proc_cnt > 0)\n              return psd.psd_max_proc_cnt;\n          }\n      }\n  }\n#endif\n\n#if HAVE_SYSMP && defined MP_NAPROCS && defined MP_NPROCS\n  {  \n     \n    int nprocs =\n      sysmp (query == NPROC_CURRENT && getuid () != 0\n             ? MP_NAPROCS\n             : MP_NPROCS);\n    if (nprocs > 0)\n      return nprocs;\n  }\n#endif\n\n   \n\n#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_NCPU\n  {  \n    int nprocs;\n    size_t len = sizeof (nprocs);\n    static int mib[][2] = {\n# ifdef HW_NCPUONLINE\n      { CTL_HW, HW_NCPUONLINE },\n# endif\n      { CTL_HW, HW_NCPU }\n    };\n    for (int i = 0; i < ARRAY_SIZE (mib); i++)\n      {\n        if (sysctl (mib[i], ARRAY_SIZE (mib[i]), &nprocs, &len, NULL, 0) == 0\n            && len == sizeof (nprocs)\n            && 0 < nprocs)\n          return nprocs;\n      }\n  }\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n  {  \n    SYSTEM_INFO system_info;\n    GetSystemInfo (&system_info);\n    if (0 < system_info.dwNumberOfProcessors)\n      return system_info.dwNumberOfProcessors;\n  }\n#endif\n\n  return 1;\n}\n\n \nstatic unsigned long int\nparse_omp_threads (char const* threads)\n{\n  unsigned long int ret = 0;\n\n  if (threads == NULL)\n    return ret;\n\n   \n  while (*threads != '\\0' && c_isspace (*threads))\n    threads++;\n\n   \n  if (c_isdigit (*threads))\n    {\n      char *endptr = NULL;\n      unsigned long int value = strtoul (threads, &endptr, 10);\n\n      if (endptr != NULL)\n        {\n          while (*endptr != '\\0' && c_isspace (*endptr))\n            endptr++;\n          if (*endptr == '\\0')\n            return value;\n           \n          else if (*endptr == ',')\n            return value;\n        }\n    }\n\n  return ret;\n}\n\nunsigned long int\nnum_processors (enum nproc_query query)\n{\n  unsigned long int omp_env_limit = ULONG_MAX;\n\n  if (query == NPROC_CURRENT_OVERRIDABLE)\n    {\n      unsigned long int omp_env_threads;\n       \n      omp_env_threads = parse_omp_threads (getenv (\"OMP_NUM_THREADS\"));\n      omp_env_limit = parse_omp_threads (getenv (\"OMP_THREAD_LIMIT\"));\n      if (! omp_env_limit)\n        omp_env_limit = ULONG_MAX;\n\n      if (omp_env_threads)\n        return MIN (omp_env_threads, omp_env_limit);\n\n      query = NPROC_CURRENT;\n    }\n   \n  {\n    unsigned long nprocs = num_processors_ignoring_omp (query);\n    return MIN (nprocs, omp_env_limit);\n  }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}