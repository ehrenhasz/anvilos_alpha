{
  "module_name": "acl-internal.h",
  "hash_id": "f3a07bf0a80c86a14dbd5958b43042bea3473b246f0e2b81c7f55292ae2956c0",
  "original_prompt": "Ingested from coreutils-9.4/lib/acl-internal.h",
  "human_readable_source": " \n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#include \"acl.h\"\n\n#include <stdlib.h>\n\n \n#if HAVE_SYS_ACL_H\n# include <sys/acl.h>\n#endif\n#if defined HAVE_FACL && ! defined GETACLCNT && defined ACL_CNT\n# define GETACLCNT ACL_CNT\n#endif\n\n \n#ifdef HAVE_ACL_LIBACL_H\n# include <acl/libacl.h>\n#endif\n\n \n#if HAVE_ACLV_H\n# include <sys/types.h>\n# include <aclv.h>\n \nextern int acl (char *, int, int, struct acl *);\nextern int aclsort (int, int, struct acl *);\n#endif\n\n#include <errno.h>\n\n#include <limits.h>\n#ifndef MIN\n# define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef SIZE_MAX\n# define SIZE_MAX ((size_t) -1)\n#endif\n\n#ifndef HAVE_FCHMOD\n# define HAVE_FCHMOD false\n# define fchmod(fd, mode) (-1)\n#endif\n\n_GL_INLINE_HEADER_BEGIN\n#ifndef ACL_INTERNAL_INLINE\n# define ACL_INTERNAL_INLINE _GL_INLINE\n#endif\n\n#if USE_ACL\n\n# if HAVE_ACL_GET_FILE\n \n \n\n#  ifndef MIN_ACL_ENTRIES\n#   define MIN_ACL_ENTRIES 4\n#  endif\n\n \n#  ifdef HAVE_ACL_GET_FD\n \n#   if HAVE_ACL_FREE_TEXT  \nACL_INTERNAL_INLINE acl_t\nrpl_acl_get_fd (int fd)\n{\n  return acl_get_fd (fd, ACL_TYPE_ACCESS);\n}\n#    undef acl_get_fd\n#    define acl_get_fd rpl_acl_get_fd\n#   endif\n#  else\n#   define HAVE_ACL_GET_FD false\n#   undef acl_get_fd\n#   define acl_get_fd(fd) (NULL)\n#  endif\n\n \n#  ifdef HAVE_ACL_SET_FD\n \n#   if HAVE_ACL_FREE_TEXT  \nACL_INTERNAL_INLINE int\nrpl_acl_set_fd (int fd, acl_t acl)\n{\n  return acl_set_fd (fd, ACL_TYPE_ACCESS, acl);\n}\n#    undef acl_set_fd\n#    define acl_set_fd rpl_acl_set_fd\n#   endif\n#  else\n#   define HAVE_ACL_SET_FD false\n#   undef acl_set_fd\n#   define acl_set_fd(fd, acl) (-1)\n#  endif\n\n \n#  if ! HAVE_ACL_FREE_TEXT\n#   define acl_free_text(buf) acl_free (buf)\n#  endif\n\n \n \n#  if !defined HAVE_ACL_EXTENDED_FILE || defined __CYGWIN__\n#   undef HAVE_ACL_EXTENDED_FILE\n#   define HAVE_ACL_EXTENDED_FILE false\n#   define acl_extended_file(name) (-1)\n#  endif\n\n#  if ! defined HAVE_ACL_FROM_MODE && ! defined HAVE_ACL_FROM_TEXT\n#   define acl_from_mode (NULL)\n#  endif\n\n \n#  if (HAVE_ACL_COPY_EXT_NATIVE && HAVE_ACL_CREATE_ENTRY_NP) || defined __sgi  \n#   define MODE_INSIDE_ACL 0\n#  endif\n\n \n \n#  if !HAVE_ACL_ENTRIES\n#   define acl_entries rpl_acl_entries\nextern int acl_entries (acl_t);\n#  endif\n\n#  if HAVE_ACL_TYPE_EXTENDED  \n \nextern int acl_extended_nontrivial (acl_t);\n#  else\n \nextern int acl_access_nontrivial (acl_t);\n\n \nextern int acl_default_nontrivial (acl_t);\n#  endif\n\n# elif HAVE_FACL && defined GETACL  \n\n \n#  if defined __CYGWIN__  \n#   define MODE_INSIDE_ACL 0\n#  endif\n\n \nextern int acl_nontrivial (int count, aclent_t *entries) _GL_ATTRIBUTE_PURE;\n\n#  ifdef ACE_GETACL  \n\n \nextern int acl_ace_nontrivial (int count, ace_t *entries) _GL_ATTRIBUTE_PURE;\n\n \n \n#   define OLD_ALLOW 0\n#   define OLD_DENY  1\n#   define NEW_ACE_ACCESS_ALLOWED_ACE_TYPE 0  \n#   define NEW_ACE_ACCESS_DENIED_ACE_TYPE  1  \n \n#   define OLD_ACE_OWNER            0x0100\n#   define OLD_ACE_GROUP            0x0200\n#   define OLD_ACE_OTHER            0x0400\n#   define NEW_ACE_OWNER            0x1000\n#   define NEW_ACE_GROUP            0x2000\n#   define NEW_ACE_IDENTIFIER_GROUP 0x0040\n#   define NEW_ACE_EVERYONE         0x4000\n \n#   define NEW_ACE_READ_DATA         0x001  \n#   define NEW_ACE_WRITE_DATA        0x002  \n#   define NEW_ACE_APPEND_DATA       0x004\n#   define NEW_ACE_READ_NAMED_ATTRS  0x008\n#   define NEW_ACE_WRITE_NAMED_ATTRS 0x010\n#   define NEW_ACE_EXECUTE           0x020\n#   define NEW_ACE_DELETE_CHILD      0x040\n#   define NEW_ACE_READ_ATTRIBUTES   0x080\n#   define NEW_ACE_WRITE_ATTRIBUTES  0x100\n#   define NEW_ACE_DELETE          0x10000\n#   define NEW_ACE_READ_ACL        0x20000\n#   define NEW_ACE_WRITE_ACL       0x40000\n#   define NEW_ACE_WRITE_OWNER     0x80000\n#   define NEW_ACE_SYNCHRONIZE    0x100000\n\n#  endif\n\n# elif HAVE_GETACL  \n\n \nextern int acl_nontrivial (int count, struct acl_entry *entries);\n\n#  if HAVE_ACLV_H  \n\n \nextern int aclv_nontrivial (int count, struct acl *entries);\n\n#  endif\n\n# elif HAVE_ACLX_GET && 0  \n\n \n\n# elif HAVE_STATACL  \n\n \nextern int acl_nontrivial (struct acl *a);\n\n# elif HAVE_ACLSORT  \n\n \nextern int acl_nontrivial (int count, struct acl *entries);\n\n# endif\n\n \n# ifndef MODE_INSIDE_ACL\n#  define MODE_INSIDE_ACL 1\n# endif\n\n#endif\n\nstruct permission_context {\n  mode_t mode;\n#if USE_ACL\n# if HAVE_ACL_GET_FILE  \n  acl_t acl;\n#  if !HAVE_ACL_TYPE_EXTENDED\n  acl_t default_acl;\n#  endif\n  bool acls_not_supported;\n\n# elif defined GETACL  \n  int count;\n  aclent_t *entries;\n#  ifdef ACE_GETACL\n  int ace_count;\n  ace_t *ace_entries;\n#  endif\n\n# elif HAVE_GETACL  \n  struct acl_entry entries[NACLENTRIES];\n  int count;\n#  if HAVE_ACLV_H\n  struct acl aclv_entries[NACLVENTRIES];\n  int aclv_count;\n#  endif\n\n# elif HAVE_STATACL  \n  union { struct acl a; char room[4096]; } u;\n  bool have_u;\n\n# elif HAVE_ACLSORT  \n  struct acl entries[NACLENTRIES];\n  int count;\n\n# endif\n#endif\n};\n\nint get_permissions (const char *, int, mode_t, struct permission_context *);\nint set_permissions (struct permission_context *, const char *, int);\nvoid free_permission_context (struct permission_context *);\n\n_GL_INLINE_HEADER_END\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}