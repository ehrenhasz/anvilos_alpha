{
  "module_name": "pthread-mutex.c",
  "hash_id": "6657ea5c0f62d97e2916913ec96a34053097e4a1b79f1473c63f3a314434cde5",
  "original_prompt": "Ingested from coreutils-9.4/lib/pthread-mutex.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <pthread.h>\n\n#if (defined _WIN32 && ! defined __CYGWIN__) && USE_WINDOWS_THREADS\n# include \"windows-timedmutex.h\"\n# include \"windows-timedrecmutex.h\"\n#else\n# include <stdlib.h>\n#endif\n\n#if ((defined _WIN32 && ! defined __CYGWIN__) && USE_WINDOWS_THREADS) || !HAVE_PTHREAD_H\n\nint\npthread_mutexattr_init (pthread_mutexattr_t *attr)\n{\n  *attr = (PTHREAD_MUTEX_STALLED << 2) | PTHREAD_MUTEX_DEFAULT;\n  return 0;\n}\n\nint\npthread_mutexattr_gettype (const pthread_mutexattr_t *attr, int *typep)\n{\n  *typep = *attr & (PTHREAD_MUTEX_DEFAULT | PTHREAD_MUTEX_NORMAL\n                    | PTHREAD_MUTEX_ERRORCHECK | PTHREAD_MUTEX_RECURSIVE);\n  return 0;\n}\n\nint\npthread_mutexattr_settype (pthread_mutexattr_t *attr, int type)\n{\n  if (!(type == PTHREAD_MUTEX_DEFAULT\n        || type == PTHREAD_MUTEX_NORMAL\n        || type == PTHREAD_MUTEX_ERRORCHECK\n        || type == PTHREAD_MUTEX_RECURSIVE))\n    return EINVAL;\n  *attr ^= (*attr ^ type)\n           & (PTHREAD_MUTEX_DEFAULT | PTHREAD_MUTEX_NORMAL\n              | PTHREAD_MUTEX_ERRORCHECK | PTHREAD_MUTEX_RECURSIVE);\n  return 0;\n}\n\nint\npthread_mutexattr_getrobust (const pthread_mutexattr_t *attr, int *robustp)\n{\n  *robustp = (*attr >> 2) & (PTHREAD_MUTEX_STALLED | PTHREAD_MUTEX_ROBUST);\n  return 0;\n}\n\nint\npthread_mutexattr_setrobust (pthread_mutexattr_t *attr, int robust)\n{\n  if (!(robust == PTHREAD_MUTEX_STALLED || robust == PTHREAD_MUTEX_ROBUST))\n    return EINVAL;\n  *attr ^= (*attr ^ (robust << 2))\n           & ((PTHREAD_MUTEX_STALLED | PTHREAD_MUTEX_ROBUST) << 2);\n  return 0;\n}\n\nint\npthread_mutexattr_destroy (_GL_UNUSED pthread_mutexattr_t *attr)\n{\n  return 0;\n}\n\n#elif PTHREAD_MUTEXATTR_ROBUST_UNIMPLEMENTED\n\nint\npthread_mutexattr_getrobust (const pthread_mutexattr_t *attr, int *robustp)\n{\n  *robustp = PTHREAD_MUTEX_STALLED;\n  return 0;\n}\n\nint\npthread_mutexattr_setrobust (pthread_mutexattr_t *attr, int robust)\n{\n  if (!(robust == PTHREAD_MUTEX_STALLED || robust == PTHREAD_MUTEX_ROBUST))\n    return EINVAL;\n  if (!(robust == PTHREAD_MUTEX_STALLED))\n    return ENOTSUP;\n  return 0;\n}\n\n#endif\n\n#if (defined _WIN32 && ! defined __CYGWIN__) && USE_WINDOWS_THREADS\n \n\nint\npthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n   \n  if (attr != NULL\n      && (*attr & (PTHREAD_MUTEX_DEFAULT | PTHREAD_MUTEX_NORMAL\n                   | PTHREAD_MUTEX_ERRORCHECK | PTHREAD_MUTEX_RECURSIVE))\n         == PTHREAD_MUTEX_RECURSIVE)\n    {\n      mutex->type = 2;\n      return glwthread_timedrecmutex_init (&mutex->u.u_timedrecmutex);\n    }\n  else\n    {\n      mutex->type = 1;\n      return glwthread_timedmutex_init (&mutex->u.u_timedmutex);\n    }\n}\n\nint\npthread_mutex_lock (pthread_mutex_t *mutex)\n{\n  switch (mutex->type)\n    {\n    case 1:\n      return glwthread_timedmutex_lock (&mutex->u.u_timedmutex);\n    case 2:\n      return glwthread_timedrecmutex_lock (&mutex->u.u_timedrecmutex);\n    default:\n      abort ();\n    }\n}\n\nint\npthread_mutex_trylock (pthread_mutex_t *mutex)\n{\n  switch (mutex->type)\n    {\n    case 1:\n      return glwthread_timedmutex_trylock (&mutex->u.u_timedmutex);\n    case 2:\n      return glwthread_timedrecmutex_trylock (&mutex->u.u_timedrecmutex);\n    default:\n      abort ();\n    }\n}\n\nint\npthread_mutex_timedlock (pthread_mutex_t *mutex, const struct timespec *abstime)\n{\n  switch (mutex->type)\n    {\n    case 1:\n      return glwthread_timedmutex_timedlock (&mutex->u.u_timedmutex, abstime);\n    case 2:\n      return glwthread_timedrecmutex_timedlock (&mutex->u.u_timedrecmutex,\n                                                abstime);\n    default:\n      abort ();\n    }\n}\n\nint\npthread_mutex_unlock (pthread_mutex_t *mutex)\n{\n  switch (mutex->type)\n    {\n    case 1:\n      return glwthread_timedmutex_unlock (&mutex->u.u_timedmutex);\n    case 2:\n      return glwthread_timedrecmutex_unlock (&mutex->u.u_timedrecmutex);\n    default:\n      abort ();\n    }\n}\n\nint\npthread_mutex_destroy (pthread_mutex_t *mutex)\n{\n  switch (mutex->type)\n    {\n    case 1:\n      return glwthread_timedmutex_destroy (&mutex->u.u_timedmutex);\n    case 2:\n      return glwthread_timedrecmutex_destroy (&mutex->u.u_timedrecmutex);\n    default:\n      abort ();\n    }\n}\n\n#elif HAVE_PTHREAD_H\n \n\n \n\n#else\n \n\nint\npthread_mutex_init (_GL_UNUSED pthread_mutex_t *mutex,\n                    _GL_UNUSED const pthread_mutexattr_t *attr)\n{\n   \n  return 0;\n}\n\nint\npthread_mutex_lock (_GL_UNUSED pthread_mutex_t *mutex)\n{\n   \n  return 0;\n}\n\nint\npthread_mutex_trylock (_GL_UNUSED pthread_mutex_t *mutex)\n{\n   \n  return 0;\n}\n\nint\npthread_mutex_timedlock (_GL_UNUSED pthread_mutex_t *mutex,\n                         _GL_UNUSED const struct timespec *abstime)\n{\n   \n  return 0;\n}\n\nint\npthread_mutex_unlock (_GL_UNUSED pthread_mutex_t *mutex)\n{\n   \n  return 0;\n}\n\nint\npthread_mutex_destroy (_GL_UNUSED pthread_mutex_t *mutex)\n{\n   \n  return 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}