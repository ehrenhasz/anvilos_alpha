{
  "module_name": "read-file.c",
  "hash_id": "98efa8a1fc8c674e9cdabac9f5ae80d2b18d79729e2c8afd179e0714deda11fd",
  "original_prompt": "Ingested from coreutils-9.4/lib/read-file.c",
  "human_readable_source": " \n#include <sys/stat.h>\n\n \n#include <stdio.h>\n\n \n#include <stdint.h>\n\n \n#include <stdlib.h>\n\n \n#include <string.h>\n\n \n#include <errno.h>\n\n \nchar *\nfread_file (FILE *stream, int flags, size_t *length)\n{\n  char *buf = NULL;\n  size_t alloc = BUFSIZ;\n\n   \n  {\n    struct stat st;\n\n    if (fstat (fileno (stream), &st) >= 0 && S_ISREG (st.st_mode))\n      {\n        off_t pos = ftello (stream);\n\n        if (pos >= 0 && pos < st.st_size)\n          {\n            off_t alloc_off = st.st_size - pos;\n\n             \n            if (PTRDIFF_MAX - 1 < alloc_off)\n              {\n                errno = ENOMEM;\n                return NULL;\n              }\n\n            alloc = alloc_off + 1;\n          }\n      }\n  }\n\n  if (!(buf = malloc (alloc)))\n    return NULL;  \n\n  {\n    size_t size = 0;  \n    int save_errno;\n\n    for (;;)\n      {\n         \n        size_t requested = alloc - size;\n        size_t count = fread (buf + size, 1, requested, stream);\n        size += count;\n\n        if (count != requested)\n          {\n            save_errno = errno;\n            if (ferror (stream))\n              break;\n\n             \n            if (size < alloc - 1)\n              {\n                if (flags & RF_SENSITIVE)\n                  {\n                    char *smaller_buf = malloc (size + 1);\n                    if (smaller_buf == NULL)\n                      memset_explicit (buf + size, 0, alloc - size);\n                    else\n                      {\n                        memcpy (smaller_buf, buf, size);\n                        memset_explicit (buf, 0, alloc);\n                        free (buf);\n                        buf = smaller_buf;\n                      }\n                  }\n                else\n                  {\n                    char *smaller_buf = realloc (buf, size + 1);\n                    if (smaller_buf != NULL)\n                      buf = smaller_buf;\n                  }\n              }\n\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n          }\n\n        {\n          char *new_buf;\n          size_t save_alloc = alloc;\n\n          if (alloc == PTRDIFF_MAX)\n            {\n              save_errno = ENOMEM;\n              break;\n            }\n\n          if (alloc < PTRDIFF_MAX - alloc / 2)\n            alloc = alloc + alloc / 2;\n          else\n            alloc = PTRDIFF_MAX;\n\n          if (flags & RF_SENSITIVE)\n            {\n              new_buf = malloc (alloc);\n              if (!new_buf)\n                {\n                   \n                  save_errno = errno;\n                  break;\n                }\n              memcpy (new_buf, buf, save_alloc);\n              memset_explicit (buf, 0, save_alloc);\n              free (buf);\n            }\n          else if (!(new_buf = realloc (buf, alloc)))\n            {\n              save_errno = errno;\n              break;\n            }\n\n          buf = new_buf;\n        }\n      }\n\n    if (flags & RF_SENSITIVE)\n      memset_explicit (buf, 0, alloc);\n\n    free (buf);\n    errno = save_errno;\n    return NULL;\n  }\n}\n\n \nchar *\nread_file (const char *filename, int flags, size_t *length)\n{\n  const char *mode = (flags & RF_BINARY) ? \"rbe\" : \"re\";\n  FILE *stream = fopen (filename, mode);\n  char *out;\n\n  if (!stream)\n    return NULL;\n\n  if (flags & RF_SENSITIVE)\n    setvbuf (stream, NULL, _IONBF, 0);\n\n  out = fread_file (stream, flags, length);\n\n  if (fclose (stream) != 0)\n    {\n      if (out)\n        {\n          if (flags & RF_SENSITIVE)\n            memset_explicit (out, 0, *length);\n          free (out);\n        }\n      return NULL;\n    }\n\n  return out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}