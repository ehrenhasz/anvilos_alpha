{
  "module_name": "setenv.c",
  "hash_id": "05a621bdba2315640948f2a00c3bd44853f43d377df541aa1f7b7dda31aec692",
  "original_prompt": "Ingested from coreutils-9.4/lib/setenv.c",
  "human_readable_source": " \n# define _GL_ARG_NONNULL(params)\n\n# define _GL_USE_STDLIB_ALLOC 1\n# include <config.h>\n#endif\n\n#include <alloca.h>\n\n \n#include <stdlib.h>\n\n#include <errno.h>\n#ifndef __set_errno\n# define __set_errno(ev) ((errno) = (ev))\n#endif\n\n#include <string.h>\n#if _LIBC || HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#if !_LIBC\n# include \"malloca.h\"\n#endif\n\n#if _LIBC || !HAVE_SETENV\n\n#if !_LIBC\n# define __environ      environ\n#endif\n\n#if _LIBC\n \n# include <bits/libc-lock.h>\n__libc_lock_define_initialized (static, envlock)\n# define LOCK   __libc_lock_lock (envlock)\n# define UNLOCK __libc_lock_unlock (envlock)\n#else\n# define LOCK\n# define UNLOCK\n#endif\n\n \n#ifdef _LIBC\n# define setenv __setenv\n# define clearenv __clearenv\n# define tfind __tfind\n# define tsearch __tsearch\n#endif\n\n \n#if defined _LIBC || (defined HAVE_SEARCH_H && defined HAVE_TSEARCH \\\n                      && (defined __GNUC__ || defined __clang__))\n# define USE_TSEARCH    1\n# include <search.h>\ntypedef int (*compar_fn_t) (const void *, const void *);\n\n \nstatic void *known_values;\n\n# define KNOWN_VALUE(Str) \\\n  ({                                                                          \\\n    void *value = tfind (Str, &known_values, (compar_fn_t) strcmp);           \\\n    value != NULL ? *(char **) value : NULL;                                  \\\n  })\n# define STORE_VALUE(Str) \\\n  tsearch (Str, &known_values, (compar_fn_t) strcmp)\n\n#else\n# undef USE_TSEARCH\n\n# define KNOWN_VALUE(Str) NULL\n# define STORE_VALUE(Str) do { } while (0)\n\n#endif\n\n\n \nstatic char **last_environ;\n\n\n \nint\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n   \n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n       \n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n           \n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n       \n      if (combined != NULL)\n         \n        new_environ[size] = (char *) combined;\n      else\n        {\n           \n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n               \n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n       \n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n               \n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}\n\nint\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}\n\n \nint\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n       \n      free (__environ);\n      last_environ = NULL;\n    }\n\n   \n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}\n\n#ifdef _LIBC\nstatic void\nfree_mem (void)\n{\n   \n  clearenv ();\n\n   \n  __tdestroy (known_values, free);\n  known_values = NULL;\n}\ntext_set_element (__libc_subfreeres, free_mem);\n\n\n# undef setenv\n# undef clearenv\nweak_alias (__setenv, setenv)\nweak_alias (__clearenv, clearenv)\n#endif\n\n#endif  \n\n \n#if HAVE_SETENV\n\n# undef setenv\n# if !HAVE_DECL_SETENV\nextern int setenv (const char *, const char *, int);\n# endif\n# define STREQ(a, b) (strcmp (a, b) == 0)\n\nint\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n   \n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          if (tmp == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n           \n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}