{
  "module_name": "getaddrinfo.c",
  "hash_id": "8df61301df0dab37aef5b7d661be03030346999b13379d127bd5a17eadf67f5c",
  "original_prompt": "Ingested from coreutils-9.4/lib/getaddrinfo.c",
  "human_readable_source": " \n#define _GL_ARG_NONNULL(params)\n\n#include <config.h>\n\n#include <netdb.h>\n\n#if HAVE_NETINET_IN_H\n# include <netinet/in.h>\n#endif\n\n \n#include <arpa/inet.h>\n\n \n#include <stdlib.h>\n\n \n#include <string.h>\n\n \n#include <stdio.h>\n\n#include \"gettext.h\"\n#define _(String) gettext (String)\n#define N_(String) String\n\n \n#ifndef PF_INET\n# define PF_INET AF_INET\n#endif\n \n#ifndef PF_UNSPEC\n# define PF_UNSPEC 0\n#endif\n\n#if HAVE_GETADDRINFO\n\n \n\nint\ngetaddrinfo (const char *restrict nodename,\n             const char *restrict servname,\n             const struct addrinfo *restrict hints,\n             struct addrinfo **restrict res)\n# undef getaddrinfo\n{\n  return getaddrinfo (nodename, servname, hints, res);\n}\n\nvoid\nfreeaddrinfo (struct addrinfo *ai)\n# undef freeaddrinfo\n{\n  freeaddrinfo (ai);\n}\n\n#else\n\n# if defined _WIN32 && !defined __CYGWIN__\n#  define WINDOWS_NATIVE\n# endif\n\n \n# include \"sockets.h\"\n\n# ifdef WINDOWS_NATIVE\n\n \n#  undef GetModuleHandle\n#  define GetModuleHandle GetModuleHandleA\n\n#  if !(_WIN32_WINNT >= _WIN32_WINNT_WINXP)\n\n \n#   define GetProcAddress \\\n     (void *) GetProcAddress\n\ntypedef int (WSAAPI *getaddrinfo_func) (const char*, const char*,\n                                        const struct addrinfo*,\n                                        struct addrinfo**);\ntypedef void (WSAAPI *freeaddrinfo_func) (struct addrinfo*);\ntypedef int (WSAAPI *getnameinfo_func) (const struct sockaddr*,\n                                        socklen_t, char*, DWORD,\n                                        char*, DWORD, int);\n\nstatic getaddrinfo_func getaddrinfo_ptr = NULL;\nstatic freeaddrinfo_func freeaddrinfo_ptr = NULL;\nstatic getnameinfo_func getnameinfo_ptr = NULL;\n\nstatic int\nuse_win32_p (void)\n{\n  static int done = 0;\n  HMODULE h;\n\n  if (done)\n    return getaddrinfo_ptr ? 1 : 0;\n\n  done = 1;\n\n  h = GetModuleHandle (\"ws2_32.dll\");\n\n  if (h)\n    {\n      getaddrinfo_ptr = (getaddrinfo_func) GetProcAddress (h, \"getaddrinfo\");\n      freeaddrinfo_ptr = (freeaddrinfo_func) GetProcAddress (h, \"freeaddrinfo\");\n      getnameinfo_ptr = (getnameinfo_func) GetProcAddress (h, \"getnameinfo\");\n    }\n\n   \n  if (!getaddrinfo_ptr || !freeaddrinfo_ptr || !getnameinfo_ptr)\n    {\n      getaddrinfo_ptr = NULL;\n      freeaddrinfo_ptr = NULL;\n      getnameinfo_ptr = NULL;\n      return 0;\n    }\n\n  gl_sockets_startup (SOCKETS_1_1);\n\n  return 1;\n}\n\n#  else\n\nstatic int\nuse_win32_p (void)\n{\n  static int done = 0;\n\n  if (!done)\n    {\n      done = 1;\n\n      gl_sockets_startup (SOCKETS_1_1);\n    }\n\n  return 1;\n}\n\n#   define getaddrinfo_ptr getaddrinfo\n#   define freeaddrinfo_ptr freeaddrinfo\n#   define getnameinfo_ptr getnameinfo\n\n#  endif\n# endif\n\nstatic bool\nvalidate_family (int family)\n{\n   \n# if HAVE_IPV4\n     if (family == PF_INET)\n       return true;\n# endif\n# if HAVE_IPV6\n     if (family == PF_INET6)\n       return true;\n# endif\n     if (family == PF_UNSPEC)\n       return true;\n     return false;\n}\n\n \nint\ngetaddrinfo (const char *restrict nodename,\n             const char *restrict servname,\n             const struct addrinfo *restrict hints,\n             struct addrinfo **restrict res)\n#undef getaddrinfo\n{\n  struct addrinfo *tmp;\n  int port = 0;\n  struct hostent *he;\n  void *storage;\n  size_t size;\n# if HAVE_IPV6\n  struct v6_pair {\n    struct addrinfo addrinfo;\n    struct sockaddr_in6 sockaddr_in6;\n  };\n# endif\n# if HAVE_IPV4\n  struct v4_pair {\n    struct addrinfo addrinfo;\n    struct sockaddr_in sockaddr_in;\n  };\n# endif\n\n# ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    return getaddrinfo_ptr (nodename, servname, hints, res);\n# endif\n\n  if (hints && (hints->ai_flags & ~(AI_CANONNAME|AI_PASSIVE)))\n     \n    return EAI_BADFLAGS;\n\n  if (hints && !validate_family (hints->ai_family))\n    return EAI_FAMILY;\n\n  if (hints &&\n      hints->ai_socktype != SOCK_STREAM && hints->ai_socktype != SOCK_DGRAM)\n     \n    return EAI_SOCKTYPE;  \n\n  if (!nodename)\n    {\n      if (!(hints->ai_flags & AI_PASSIVE))\n        return EAI_NONAME;\n\n# ifdef HAVE_IPV6\n      nodename = (hints->ai_family == AF_INET6) ? \"::\" : \"0.0.0.0\";\n# else\n      nodename = \"0.0.0.0\";\n# endif\n    }\n\n  if (servname)\n    {\n      struct servent *se = NULL;\n      const char *proto =\n        (hints && hints->ai_socktype == SOCK_DGRAM) ? \"udp\" : \"tcp\";\n\n      if (hints == NULL || !(hints->ai_flags & AI_NUMERICSERV))\n         \n        se = getservbyname (servname, proto);\n\n      if (!se)\n        {\n          char *c;\n          if (!(*servname >= '0' && *servname <= '9'))\n            return EAI_NONAME;\n          port = strtoul (servname, &c, 10);\n          if (*c || port > 0xffff)\n            return EAI_NONAME;\n          port = htons (port);\n        }\n      else\n        port = se->s_port;\n    }\n\n   \n  he = gethostbyname (nodename);\n  if (!he || he->h_addr_list[0] == NULL)\n    return EAI_NONAME;\n\n  switch (he->h_addrtype)\n    {\n# if HAVE_IPV6\n    case PF_INET6:\n      size = sizeof (struct v6_pair);\n      break;\n# endif\n\n# if HAVE_IPV4\n    case PF_INET:\n      size = sizeof (struct v4_pair);\n      break;\n# endif\n\n    default:\n      return EAI_NODATA;\n    }\n\n  storage = calloc (1, size);\n  if (!storage)\n    return EAI_MEMORY;\n\n  switch (he->h_addrtype)\n    {\n# if HAVE_IPV6\n    case PF_INET6:\n      {\n        struct v6_pair *p = storage;\n        struct sockaddr_in6 *sinp = &p->sockaddr_in6;\n        tmp = &p->addrinfo;\n\n        if (port)\n          sinp->sin6_port = port;\n\n        if (he->h_length != sizeof (sinp->sin6_addr))\n          {\n            free (storage);\n            return EAI_SYSTEM;  \n          }\n\n        memcpy (&sinp->sin6_addr, he->h_addr_list[0], sizeof sinp->sin6_addr);\n\n        tmp->ai_addr = (struct sockaddr *) sinp;\n        tmp->ai_addrlen = sizeof *sinp;\n      }\n      break;\n# endif\n\n# if HAVE_IPV4\n    case PF_INET:\n      {\n        struct v4_pair *p = storage;\n        struct sockaddr_in *sinp = &p->sockaddr_in;\n        tmp = &p->addrinfo;\n\n        if (port)\n          sinp->sin_port = port;\n\n        if (he->h_length != sizeof (sinp->sin_addr))\n          {\n            free (storage);\n            return EAI_SYSTEM;  \n          }\n\n        memcpy (&sinp->sin_addr, he->h_addr_list[0], sizeof sinp->sin_addr);\n\n        tmp->ai_addr = (struct sockaddr *) sinp;\n        tmp->ai_addrlen = sizeof *sinp;\n      }\n      break;\n# endif\n\n    default:\n      free (storage);\n      return EAI_NODATA;\n    }\n\n  if (hints && hints->ai_flags & AI_CANONNAME)\n    {\n      const char *cn;\n      if (he->h_name)\n        cn = he->h_name;\n      else\n        cn = nodename;\n\n      tmp->ai_canonname = strdup (cn);\n      if (!tmp->ai_canonname)\n        {\n          free (storage);\n          return EAI_MEMORY;\n        }\n    }\n\n  tmp->ai_protocol = (hints) ? hints->ai_protocol : 0;\n  tmp->ai_socktype = (hints) ? hints->ai_socktype : 0;\n  tmp->ai_addr->sa_family = he->h_addrtype;\n  tmp->ai_family = he->h_addrtype;\n\n# ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n  switch (he->h_addrtype)\n    {\n#  if HAVE_IPV4\n    case AF_INET:\n      tmp->ai_addr->sa_len = sizeof (struct sockaddr_in);\n      break;\n#  endif\n#  if HAVE_IPV6\n    case AF_INET6:\n      tmp->ai_addr->sa_len = sizeof (struct sockaddr_in6);\n      break;\n#  endif\n    }\n# endif\n\n   \n\n  *res = tmp;\n\n  return 0;\n}\n\n \nvoid\nfreeaddrinfo (struct addrinfo *ai)\n#undef freeaddrinfo\n{\n# ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    {\n      freeaddrinfo_ptr (ai);\n      return;\n    }\n# endif\n\n  while (ai)\n    {\n      struct addrinfo *cur;\n\n      cur = ai;\n      ai = ai->ai_next;\n\n      free (cur->ai_canonname);\n      free (cur);\n    }\n}\n\nint\ngetnameinfo (const struct sockaddr *restrict sa, socklen_t salen,\n             char *restrict node, socklen_t nodelen,\n             char *restrict service, socklen_t servicelen,\n             int flags)\n#undef getnameinfo\n{\n# ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    return getnameinfo_ptr (sa, salen, node, nodelen,\n                            service, servicelen, flags);\n# endif\n\n   \n  if ((node && nodelen > 0 && !(flags & NI_NUMERICHOST)) ||\n      (service && servicelen > 0 && !(flags & NI_NUMERICHOST)) ||\n      (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV)))\n    return EAI_BADFLAGS;\n\n  if (sa == NULL || salen < sizeof (sa->sa_family))\n    return EAI_FAMILY;\n\n  switch (sa->sa_family)\n    {\n# if HAVE_IPV4\n    case AF_INET:\n      if (salen < sizeof (struct sockaddr_in))\n        return EAI_FAMILY;\n      break;\n# endif\n# if HAVE_IPV6\n    case AF_INET6:\n      if (salen < sizeof (struct sockaddr_in6))\n        return EAI_FAMILY;\n      break;\n# endif\n    default:\n      return EAI_FAMILY;\n    }\n\n  if (node && nodelen > 0 && flags & NI_NUMERICHOST)\n    {\n      switch (sa->sa_family)\n        {\n# if HAVE_IPV4\n        case AF_INET:\n          if (!inet_ntop (AF_INET,\n                          &(((const struct sockaddr_in *) sa)->sin_addr),\n                          node, nodelen))\n            return EAI_SYSTEM;\n          break;\n# endif\n\n# if HAVE_IPV6\n        case AF_INET6:\n          if (!inet_ntop (AF_INET6,\n                          &(((const struct sockaddr_in6 *) sa)->sin6_addr),\n                          node, nodelen))\n            return EAI_SYSTEM;\n          break;\n# endif\n\n        default:\n          return EAI_FAMILY;\n        }\n    }\n\n  if (service && servicelen > 0 && flags & NI_NUMERICSERV)\n    switch (sa->sa_family)\n      {\n# if HAVE_IPV4\n      case AF_INET:\n# endif\n# if HAVE_IPV6\n      case AF_INET6:\n# endif\n        {\n          unsigned short int port\n            = ntohs (((const struct sockaddr_in *) sa)->sin_port);\n          if (servicelen <= snprintf (service, servicelen, \"%u\", port))\n            return EAI_OVERFLOW;\n        }\n        break;\n      }\n\n  return 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}