{
  "module_name": "windows-timedmutex.c",
  "hash_id": "d5a90fd42bb6dc26e22d642dc9550afdf61a20ac19395ad87e6249a735ce5f04",
  "original_prompt": "Ingested from coreutils-9.4/lib/windows-timedmutex.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"windows-timedmutex.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n \n#undef CreateEvent\n#define CreateEvent CreateEventA\n\nint\nglwthread_timedmutex_init (glwthread_timedmutex_t *mutex)\n{\n   \n   \n          int err = glwthread_timedmutex_init (mutex);\n          if (err != 0)\n            {\n               \n              InterlockedDecrement (&mutex->guard.started);\n              return err;\n            }\n        }\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          while (!mutex->guard.done)\n            Sleep (0);\n        }\n    }\n  EnterCriticalSection (&mutex->lock);\n  return 0;\n}\n\nint\nglwthread_timedmutex_trylock (glwthread_timedmutex_t *mutex)\n{\n  if (!mutex->guard.done)\n    {\n      if (InterlockedIncrement (&mutex->guard.started) == 0)\n        {\n           \n          int err = glwthread_timedmutex_init (mutex);\n          if (err != 0)\n            {\n               \n              InterlockedDecrement (&mutex->guard.started);\n              return err;\n            }\n        }\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          return EBUSY;\n        }\n    }\n  if (!TryEnterCriticalSection (&mutex->lock))\n    return EBUSY;\n  return 0;\n}\n\nint\nglwthread_timedmutex_timedlock (glwthread_timedmutex_t *mutex,\n                                const struct timespec *abstime)\n{\n  if (!mutex->guard.done)\n    {\n      if (InterlockedIncrement (&mutex->guard.started) == 0)\n        {\n           \n          int err = glwthread_timedmutex_init (mutex);\n          if (err != 0)\n            {\n               \n              InterlockedDecrement (&mutex->guard.started);\n              return err;\n            }\n        }\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          while (!mutex->guard.done)\n            Sleep (0);\n        }\n    }\n\n   \n  for (;;)\n    {\n      if (TryEnterCriticalSection (&mutex->lock))\n        break;\n\n      {\n        struct timeval currtime;\n        DWORD timeout;\n        DWORD result;\n\n        gettimeofday (&currtime, NULL);\n\n         \n        if (currtime.tv_sec > abstime->tv_sec)\n          timeout = 0;\n        else\n          {\n            unsigned long seconds = abstime->tv_sec - currtime.tv_sec;\n            timeout = seconds * 1000;\n            if (timeout / 1000 != seconds)  \n              timeout = INFINITE;\n            else\n              {\n                long milliseconds =\n                  abstime->tv_nsec / 1000000 - currtime.tv_usec / 1000;\n                if (milliseconds >= 0)\n                  {\n                    timeout += milliseconds;\n                    if (timeout < milliseconds)  \n                      timeout = INFINITE;\n                  }\n                else\n                  {\n                    if (timeout >= - milliseconds)\n                      timeout -= (- milliseconds);\n                    else\n                      timeout = 0;\n                  }\n              }\n          }\n        if (timeout == 0)\n          return ETIMEDOUT;\n\n         \n      }\n    }\n  return 0;\n}\n\nint\nglwthread_timedmutex_unlock (glwthread_timedmutex_t *mutex)\n{\n  if (!mutex->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&mutex->lock);\n   \n  /* SetEvent\n     <https:\n  SetEvent (mutex->event);\n  return 0;\n}\n\nint\nglwthread_timedmutex_destroy (glwthread_timedmutex_t *mutex)\n{\n  if (!mutex->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&mutex->lock);\n  /* CloseHandle\n     <https:\n  CloseHandle (mutex->event);\n  mutex->guard.done = 0;\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}