{
  "module_name": "utime.c",
  "hash_id": "3193466f95c54a6d929c5ade1e8ea2fde1b5c2afac1bfd6200b97e78e5f1d112",
  "original_prompt": "Ingested from coreutils-9.4/lib/utime.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <utime.h>\n\n#if defined _WIN32 && ! defined __CYGWIN__\n\n# include <errno.h>\n# include <windows.h>\n# include \"filename.h\"\n# include \"malloca.h\"\n\n \n# undef CreateFile\n# define CreateFile CreateFileA\n# undef GetFileAttributes\n# define GetFileAttributes GetFileAttributesA\n\nint\n_gl_utimens_windows (const char *name, struct timespec ts[2])\n{\n   \n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n   \n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n  DWORD error;\n\n   \n  HANDLE handle =\n    CreateFile (rname,\n                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,\n                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                NULL,\n                OPEN_EXISTING,\n                 \n                FILE_FLAG_BACKUP_SEMANTICS  ,\n                NULL);\n  if (handle == INVALID_HANDLE_VALUE)\n    {\n      error = GetLastError ();\n      goto failed;\n    }\n\n  if (check_dir)\n    {\n       \n      DWORD attributes = GetFileAttributes (rname);\n      if (attributes == INVALID_FILE_ATTRIBUTES)\n        {\n          error = GetLastError ();\n          CloseHandle (handle);\n          goto failed;\n        }\n      if ((attributes & FILE_ATTRIBUTE_DIRECTORY) == 0)\n        {\n          CloseHandle (handle);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n\n  {\n     \n    FILETIME last_access_time;\n    FILETIME last_write_time;\n    if (ts == NULL)\n      {\n         \n        FILETIME current_time;\n        GetSystemTimeAsFileTime (&current_time);\n        last_access_time = current_time;\n        last_write_time = current_time;\n      }\n    else\n      {\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n          last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n          last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n      }\n    if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n      {\n        CloseHandle (handle);\n        if (malloca_rname != NULL)\n          freea (malloca_rname);\n        return 0;\n      }\n    else\n      {\n        #if 0\n        DWORD sft_error = GetLastError ();\n        fprintf (stderr, \"utimens SetFileTime error 0x%x\\n\", (unsigned int) sft_error);\n        #endif\n        CloseHandle (handle);\n        if (malloca_rname != NULL)\n          freea (malloca_rname);\n        errno = EINVAL;\n        return -1;\n      }\n  }\n\n failed:\n  {\n    #if 0\n    fprintf (stderr, \"utimens CreateFile/GetFileAttributes error 0x%x\\n\", (unsigned int) error);\n    #endif\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n       \n      case ERROR_FILE_NOT_FOUND:  \n      case ERROR_PATH_NOT_FOUND:  \n      case ERROR_BAD_PATHNAME:    \n      case ERROR_BAD_NETPATH:     \n      case ERROR_BAD_NET_NAME:    \n      case ERROR_INVALID_NAME:    \n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:   \n      case ERROR_SHARING_VIOLATION:  \n        errno = (ts != NULL ? EPERM : EACCES);\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING:  \n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n}\n\nint\nutime (const char *name, const struct utimbuf *ts)\n{\n  if (ts == NULL)\n    return _gl_utimens_windows (name, NULL);\n  else\n    {\n      struct timespec ts_with_nanoseconds[2];\n      ts_with_nanoseconds[0].tv_sec = ts->actime;\n      ts_with_nanoseconds[0].tv_nsec = 0;\n      ts_with_nanoseconds[1].tv_sec = ts->modtime;\n      ts_with_nanoseconds[1].tv_nsec = 0;\n      return _gl_utimens_windows (name, ts_with_nanoseconds);\n    }\n}\n\n#else\n\n# include <errno.h>\n# include <sys/stat.h>\n# include \"filename.h\"\n\nint\nutime (const char *name, const struct utimbuf *ts)\n#undef utime\n{\n# if REPLACE_FUNC_UTIME_FILE\n   \n  size_t len = strlen (name);\n  if (len > 0 && ISSLASH (name[len - 1]))\n    {\n      struct stat buf;\n\n      if (stat (name, &buf) == -1 && errno != EOVERFLOW)\n        return -1;\n    }\n# endif  \n\n  return utime (name, ts);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}