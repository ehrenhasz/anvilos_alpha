{
  "module_name": "mktime.c",
  "hash_id": "815a1a02838131486be30ee50322ddfb7caf4ffd68619125750dcaadaef76864",
  "original_prompt": "Ingested from coreutils-9.4/lib/mktime.c",
  "human_readable_source": " \n\n#ifndef _LIBC\n# include <libc-config.h>\n#endif\n\n \n#ifndef LEAP_SECONDS_POSSIBLE\n# define LEAP_SECONDS_POSSIBLE 1\n#endif\n\n#include <time.h>\n\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdckdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <intprops.h>\n#include <verify.h>\n\n#ifndef NEED_MKTIME_INTERNAL\n# define NEED_MKTIME_INTERNAL 0\n#endif\n#ifndef NEED_MKTIME_WINDOWS\n# define NEED_MKTIME_WINDOWS 0\n#endif\n#ifndef NEED_MKTIME_WORKING\n# define NEED_MKTIME_WORKING 0\n#endif\n\n#include \"mktime-internal.h\"\n\n#if !defined _LIBC && (NEED_MKTIME_WORKING || NEED_MKTIME_WINDOWS)\nstatic void\nmy_tzset (void)\n{\n# if NEED_MKTIME_WINDOWS\n   \n  const char *tz = getenv (\"TZ\");\n  if (tz != NULL && strchr (tz, '/') != NULL)\n    _putenv (\"TZ=\");\n# else\n  tzset ();\n# endif\n}\n# undef __tzset\n# define __tzset() my_tzset ()\n#endif\n\n#if defined _LIBC || NEED_MKTIME_WORKING || NEED_MKTIME_INTERNAL\n\n \n\n#if INT_MAX <= LONG_MAX / 4 / 366 / 24 / 60 / 60\ntypedef long int long_int;\n#else\ntypedef long long int long_int;\n#endif\nverify (INT_MAX <= TYPE_MAXIMUM (long_int) / 4 / 366 / 24 / 60 / 60);\n\n \n\nstatic long_int\nshr (long_int a, int b)\n{\n  long_int one = 1;\n  return (-one >> 1 == -1\n\t  ? a >> b\n\t  : (a + (a < 0)) / (one << b) - (a < 0));\n}\n\n \n\nstatic long_int const mktime_min\n  = ((TYPE_SIGNED (__time64_t)\n      && TYPE_MINIMUM (__time64_t) < TYPE_MINIMUM (long_int))\n     ? TYPE_MINIMUM (long_int) : TYPE_MINIMUM (__time64_t));\nstatic long_int const mktime_max\n  = (TYPE_MAXIMUM (long_int) < TYPE_MAXIMUM (__time64_t)\n     ? TYPE_MAXIMUM (long_int) : TYPE_MAXIMUM (__time64_t));\n\n#define EPOCH_YEAR 1970\n#define TM_YEAR_BASE 1900\nverify (TM_YEAR_BASE % 100 == 0);\n\n \nstatic bool\nleapyear (long_int year)\n{\n   \n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}\n\n \n#ifndef _LIBC\nstatic\n#endif\nconst unsigned short int __mon_yday[2][13] =\n  {\n     \n    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },\n     \n    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }\n  };\n\n\n \nstatic bool\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}\n\n \n\nstatic long_int\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (-1 / 2 == 0);\n\n   \n  int a4 = shr (year1, 2) + shr (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = shr (year0, 2) + shr (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = (a4 + (a4 < 0)) / 25 - (a4 < 0);\n  int b100 = (b4 + (b4 < 0)) / 25 - (b4 < 0);\n  int a400 = shr (a100, 2);\n  int b400 = shr (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n   \n  long_int years = year1 - year0;\n  long_int days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  long_int hours = 24 * days + hour1 - hour0;\n  long_int minutes = 60 * hours + min1 - min0;\n  long_int seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}\n\n \nstatic long_int\nlong_int_avg (long_int a, long_int b)\n{\n  return shr (a, 1) + shr (b, 1) + ((a | b) & 1);\n}\n\n \nstatic long_int\ntm_diff (long_int year, long_int yday, int hour, int min, int sec,\n\t struct tm const *tp)\n{\n  return ydhms_diff (year, yday, hour, min, sec,\n\t\t     tp->tm_year, tp->tm_yday,\n\t\t     tp->tm_hour, tp->tm_min, tp->tm_sec);\n}\n\n \nstatic struct tm *\nconvert_time (struct tm *(*convert) (const __time64_t *, struct tm *),\n\t      long_int t, struct tm *tm)\n{\n  __time64_t x = t;\n  return convert (&x, tm);\n}\n\n \nstatic struct tm *\nranged_convert (struct tm *(*convert) (const __time64_t *, struct tm *),\n\t\tlong_int *t, struct tm *tp)\n{\n  long_int t1 = (*t < mktime_min ? mktime_min\n\t\t : *t <= mktime_max ? *t : mktime_max);\n  struct tm *r = convert_time (convert, t1, tp);\n  if (r)\n    {\n      *t = t1;\n      return r;\n    }\n  if (errno != EOVERFLOW)\n    return NULL;\n\n  long_int bad = t1;\n  long_int ok = 0;\n  struct tm oktm; oktm.tm_sec = -1;\n\n   \n  while (true)\n    {\n      long_int mid = long_int_avg (ok, bad);\n      if (mid == ok || mid == bad)\n\tbreak;\n      if (convert_time (convert, mid, tp))\n\tok = mid, oktm = *tp;\n      else if (errno != EOVERFLOW)\n\treturn NULL;\n      else\n\tbad = mid;\n    }\n\n  if (oktm.tm_sec < 0)\n    return NULL;\n  *t = ok;\n  *tp = oktm;\n  return tp;\n}\n\n\n \n__time64_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const __time64_t *, struct tm *),\n\t\t   mktime_offset_t *offset)\n{\n  struct tm tm;\n\n   \n  int remaining_probes = 6;\n\n   \n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n   \n  int dst2 = 0;\n\n   \n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n   \n\n   \n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  mktime_offset_t off = *offset;\n  int negative_offset_guess;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n       \n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n   \n\n  ckd_sub (&negative_offset_guess, 0, off);\n  long_int t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t    EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0,\n\t\t\t    negative_offset_guess);\n  long_int t = t0, t1 = t0, t2 = t0;\n\n   \n\n  while (true)\n    {\n      if (! ranged_convert (convert, &t, &tm))\n\treturn -1;\n      long_int dt = tm_diff (year, yday, hour, min, sec, &tm);\n      if (dt == 0)\n\tbreak;\n\n      if (t == t1 && t != t2\n\t  && (tm.tm_isdst < 0\n\t      || (isdst < 0\n\t\t  ? dst2 <= (tm.tm_isdst != 0)\n\t\t  : (isdst != 0) != (tm.tm_isdst != 0))))\n\t \n\tgoto offset_found;\n\n      remaining_probes--;\n      if (remaining_probes == 0)\n\t{\n\t  __set_errno (EOVERFLOW);\n\t  return -1;\n\t}\n\n      t1 = t2, t2 = t, t += dt, dst2 = tm.tm_isdst != 0;\n    }\n\n   \n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n       \n\n       \n      int dst_difference = (isdst == 0) - (tm.tm_isdst == 0);\n\n       \n      int stride = 601200;\n\n       \n      int duration_max = 457243209;\n\n       \n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  {\n\t    long_int ot;\n\t    if (! ckd_add (&ot, t, delta * direction))\n\t      {\n\t\tstruct tm otm;\n\t\tif (! ranged_convert (convert, &ot, &otm))\n\t\t  return -1;\n\t\tif (! isdst_differ (isdst, otm.tm_isdst))\n\t\t  {\n\t\t     \n\t\t    long_int gt = ot + tm_diff (year, yday, hour, min, sec,\n\t\t\t\t\t\t&otm);\n\t\t    if (mktime_min <= gt && gt <= mktime_max)\n\t\t      {\n\t\t\tif (convert_time (convert, gt, &tm))\n\t\t\t  {\n\t\t\t    t = gt;\n\t\t\t    goto offset_found;\n\t\t\t  }\n\t\t\tif (errno != EOVERFLOW)\n\t\t\t  return -1;\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n\n       \n      t += 60 * 60 * dst_difference;\n      if (mktime_min <= t && t <= mktime_max && convert_time (convert, t, &tm))\n\tgoto offset_found;\n\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n\n offset_found:\n   \n  ckd_sub (offset, t, t0);\n  ckd_sub (offset, *offset, negative_offset_guess);\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n       \n      long_int sec_adjustment = sec == 0 && tm.tm_sec == 60;\n      sec_adjustment -= sec;\n      sec_adjustment += sec_requested;\n      if (ckd_add (&t, t, sec_adjustment)\n\t  || ! (mktime_min <= t && t <= mktime_max))\n\t{\n\t  __set_errno (EOVERFLOW);\n\t  return -1;\n\t}\n      if (! convert_time (convert, t, &tm))\n\treturn -1;\n    }\n\n  *tp = tm;\n  return t;\n}\n\n#endif  \n\n#if defined _LIBC || NEED_MKTIME_WORKING || NEED_MKTIME_WINDOWS\n\n \n__time64_t\n__mktime64 (struct tm *tp)\n{\n   \n  __tzset ();\n\n# if defined _LIBC || NEED_MKTIME_WORKING\n  static mktime_offset_t localtime_offset;\n  return __mktime_internal (tp, __localtime64_r, &localtime_offset);\n# else\n#  undef mktime\n  return mktime (tp);\n# endif\n}\n#endif  \n\n#if defined _LIBC && __TIMESIZE != 64\n\nlibc_hidden_def (__mktime64)\n\ntime_t\nmktime (struct tm *tp)\n{\n  struct tm tm = *tp;\n  __time64_t t = __mktime64 (&tm);\n  if (in_time_t_range (t))\n    {\n      *tp = tm;\n      return t;\n    }\n  else\n    {\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n}\n\n#endif\n\nweak_alias (mktime, timelocal)\nlibc_hidden_def (mktime)\nlibc_hidden_weak (timelocal)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}