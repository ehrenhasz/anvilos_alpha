{
  "module_name": "areadlink-with-size.c",
  "hash_id": "63d5e4e24e4fea7300eccd4841ffba3431987dca5c04c2fa34c9fa6a0323cc1d",
  "original_prompt": "Ingested from coreutils-9.4/lib/areadlink-with-size.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"areadlink.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n \n#ifndef SYMLINK_MAX\n# define SYMLINK_MAX 1024\n#endif\n\n#define MAXSIZE (SIZE_MAX < SSIZE_MAX ? SIZE_MAX : SSIZE_MAX)\n\n \n\nchar *\nareadlink_with_size (char const *file, size_t size)\n{\n   \n  size_t symlink_max = SYMLINK_MAX;\n  size_t INITIAL_LIMIT_BOUND = 8 * 1024;\n  size_t initial_limit = (symlink_max < INITIAL_LIMIT_BOUND\n                          ? symlink_max + 1\n                          : INITIAL_LIMIT_BOUND);\n\n  enum { stackbuf_size = 128 };\n\n   \n  size_t buf_size = (size == 0 ? stackbuf_size\n                     : size < initial_limit ? size + 1 : initial_limit);\n\n  while (1)\n    {\n      ssize_t r;\n      size_t link_length;\n      char stackbuf[stackbuf_size];\n      char *buf = stackbuf;\n      char *buffer = NULL;\n\n      if (! (size == 0 && buf_size == stackbuf_size))\n        {\n          buf = buffer = malloc (buf_size);\n          if (!buffer)\n            {\n              errno = ENOMEM;\n              return NULL;\n            }\n        }\n\n      r = readlink (file, buf, buf_size);\n      link_length = r;\n\n      if (r < 0)\n        {\n          free (buffer);\n          return NULL;\n        }\n\n      if (link_length < buf_size)\n        {\n          buf[link_length] = 0;\n          if (!buffer)\n            {\n              buffer = malloc (link_length + 1);\n              if (buffer)\n                return memcpy (buffer, buf, link_length + 1);\n            }\n          else if (link_length + 1 < buf_size)\n            {\n               \n              char *shrinked_buffer = realloc (buffer, link_length + 1);\n              if (shrinked_buffer != NULL)\n                buffer = shrinked_buffer;\n            }\n          return buffer;\n        }\n\n      free (buffer);\n      if (buf_size <= MAXSIZE / 2)\n        buf_size *= 2;\n      else if (buf_size < MAXSIZE)\n        buf_size = MAXSIZE;\n      else\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}