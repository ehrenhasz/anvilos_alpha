{
  "module_name": "sha256.c",
  "hash_id": "4eeb2169cf15340dcefb08826563d202ff250bd905c3ef4d83744ae56eb21e28",
  "original_prompt": "Ingested from coreutils-9.4/lib/sha256.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#if HAVE_OPENSSL_SHA256\n# define GL_OPENSSL_INLINE _GL_EXTERN_INLINE\n#endif\n#include \"sha256.h\"\n\n#include <stdint.h>\n#include <string.h>\n\n#include <byteswap.h>\n#ifdef WORDS_BIGENDIAN\n# define SWAP(n) (n)\n#else\n# define SWAP(n) bswap_32 (n)\n#endif\n\n#if ! HAVE_OPENSSL_SHA256\n\n \nstatic const unsigned char fillbuf[64] = { 0x80, 0   };\n\n\n \nvoid\nsha256_init_ctx (struct sha256_ctx *ctx)\n{\n  ctx->state[0] = 0x6a09e667UL;\n  ctx->state[1] = 0xbb67ae85UL;\n  ctx->state[2] = 0x3c6ef372UL;\n  ctx->state[3] = 0xa54ff53aUL;\n  ctx->state[4] = 0x510e527fUL;\n  ctx->state[5] = 0x9b05688cUL;\n  ctx->state[6] = 0x1f83d9abUL;\n  ctx->state[7] = 0x5be0cd19UL;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}\n\nvoid\nsha224_init_ctx (struct sha256_ctx *ctx)\n{\n  ctx->state[0] = 0xc1059ed8UL;\n  ctx->state[1] = 0x367cd507UL;\n  ctx->state[2] = 0x3070dd17UL;\n  ctx->state[3] = 0xf70e5939UL;\n  ctx->state[4] = 0xffc00b31UL;\n  ctx->state[5] = 0x68581511UL;\n  ctx->state[6] = 0x64f98fa7UL;\n  ctx->state[7] = 0xbefa4fa4UL;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}\n\n \nstatic void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}\n\n \nvoid *\nsha256_read_ctx (const struct sha256_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 8; i++)\n    set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}\n\nvoid *\nsha224_read_ctx (const struct sha256_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 7; i++)\n    set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}\n\n \nstatic void\nsha256_conclude_ctx (struct sha256_ctx *ctx)\n{\n   \n  size_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n   \n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n   \n  set_uint32 ((char *) &ctx->buffer[size - 2],\n              SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29)));\n  set_uint32 ((char *) &ctx->buffer[size - 1],\n              SWAP (ctx->total[0] << 3));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n   \n  sha256_process_block (ctx->buffer, size * 4, ctx);\n}\n\nvoid *\nsha256_finish_ctx (struct sha256_ctx *ctx, void *resbuf)\n{\n  sha256_conclude_ctx (ctx);\n  return sha256_read_ctx (ctx, resbuf);\n}\n\nvoid *\nsha224_finish_ctx (struct sha256_ctx *ctx, void *resbuf)\n{\n  sha256_conclude_ctx (ctx);\n  return sha224_read_ctx (ctx, resbuf);\n}\n\n \nvoid *\nsha256_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha256_ctx ctx;\n\n   \n  sha256_init_ctx (&ctx);\n\n   \n  sha256_process_bytes (buffer, len, &ctx);\n\n   \n  return sha256_finish_ctx (&ctx, resblock);\n}\n\nvoid *\nsha224_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha256_ctx ctx;\n\n   \n  sha224_init_ctx (&ctx);\n\n   \n  sha256_process_bytes (buffer, len, &ctx);\n\n   \n  return sha224_finish_ctx (&ctx, resblock);\n}\n\nvoid\nsha256_process_bytes (const void *buffer, size_t len, struct sha256_ctx *ctx)\n{\n   \n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          sha256_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n           \n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n   \n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            sha256_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          sha256_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n   \n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          sha256_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n           \n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}\n\n \n\n \n#define K(I) sha256_round_constants[I]\nstatic const uint32_t sha256_round_constants[64] = {\n  0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,\n  0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,\n  0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,\n  0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,\n  0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,\n  0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,\n  0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,\n  0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,\n  0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,\n  0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,\n  0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,\n  0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,\n  0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,\n  0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,\n  0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,\n  0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL,\n};\n\n \n#define F2(A,B,C) ( ( A & B ) | ( C & ( A | B ) ) )\n#define F1(E,F,G) ( G ^ ( E & ( F ^ G ) ) )\n\n \n\nvoid\nsha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)\n{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->state[0];\n  uint32_t b = ctx->state[1];\n  uint32_t c = ctx->state[2];\n  uint32_t d = ctx->state[3];\n  uint32_t e = ctx->state[4];\n  uint32_t f = ctx->state[5];\n  uint32_t g = ctx->state[6];\n  uint32_t h = ctx->state[7];\n  uint32_t lolen = len;\n\n   \n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n#define S0(x) (rol(x,25)^rol(x,14)^(x>>3))\n#define S1(x) (rol(x,15)^rol(x,13)^(x>>10))\n#define SS0(x) (rol(x,30)^rol(x,19)^rol(x,10))\n#define SS1(x) (rol(x,26)^rol(x,21)^rol(x,7))\n\n#define M(I) ( tm =   S1(x[(I-2)&0x0f]) + x[(I-7)&0x0f] \\\n                    + S0(x[(I-15)&0x0f]) + x[I&0x0f]    \\\n               , x[I&0x0f] = tm )\n\n#define R(A,B,C,D,E,F,G,H,K,M)  do { t0 = SS0(A) + F2(A,B,C); \\\n                                     t1 = H + SS1(E)  \\\n                                      + F1(E,F,G)     \\\n                                      + K             \\\n                                      + M;            \\\n                                     D += t1;  H = t0 + t1; \\\n                               } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      uint32_t t0, t1;\n      int t;\n       \n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n      R( g, h, a, b, c, d, e, f, K(10), x[10] );\n      R( f, g, h, a, b, c, d, e, K(11), x[11] );\n      R( e, f, g, h, a, b, c, d, K(12), x[12] );\n      R( d, e, f, g, h, a, b, c, K(13), x[13] );\n      R( c, d, e, f, g, h, a, b, K(14), x[14] );\n      R( b, c, d, e, f, g, h, a, K(15), x[15] );\n      R( a, b, c, d, e, f, g, h, K(16), M(16) );\n      R( h, a, b, c, d, e, f, g, K(17), M(17) );\n      R( g, h, a, b, c, d, e, f, K(18), M(18) );\n      R( f, g, h, a, b, c, d, e, K(19), M(19) );\n      R( e, f, g, h, a, b, c, d, K(20), M(20) );\n      R( d, e, f, g, h, a, b, c, K(21), M(21) );\n      R( c, d, e, f, g, h, a, b, K(22), M(22) );\n      R( b, c, d, e, f, g, h, a, K(23), M(23) );\n      R( a, b, c, d, e, f, g, h, K(24), M(24) );\n      R( h, a, b, c, d, e, f, g, K(25), M(25) );\n      R( g, h, a, b, c, d, e, f, K(26), M(26) );\n      R( f, g, h, a, b, c, d, e, K(27), M(27) );\n      R( e, f, g, h, a, b, c, d, K(28), M(28) );\n      R( d, e, f, g, h, a, b, c, K(29), M(29) );\n      R( c, d, e, f, g, h, a, b, K(30), M(30) );\n      R( b, c, d, e, f, g, h, a, K(31), M(31) );\n      R( a, b, c, d, e, f, g, h, K(32), M(32) );\n      R( h, a, b, c, d, e, f, g, K(33), M(33) );\n      R( g, h, a, b, c, d, e, f, K(34), M(34) );\n      R( f, g, h, a, b, c, d, e, K(35), M(35) );\n      R( e, f, g, h, a, b, c, d, K(36), M(36) );\n      R( d, e, f, g, h, a, b, c, K(37), M(37) );\n      R( c, d, e, f, g, h, a, b, K(38), M(38) );\n      R( b, c, d, e, f, g, h, a, K(39), M(39) );\n      R( a, b, c, d, e, f, g, h, K(40), M(40) );\n      R( h, a, b, c, d, e, f, g, K(41), M(41) );\n      R( g, h, a, b, c, d, e, f, K(42), M(42) );\n      R( f, g, h, a, b, c, d, e, K(43), M(43) );\n      R( e, f, g, h, a, b, c, d, K(44), M(44) );\n      R( d, e, f, g, h, a, b, c, K(45), M(45) );\n      R( c, d, e, f, g, h, a, b, K(46), M(46) );\n      R( b, c, d, e, f, g, h, a, K(47), M(47) );\n      R( a, b, c, d, e, f, g, h, K(48), M(48) );\n      R( h, a, b, c, d, e, f, g, K(49), M(49) );\n      R( g, h, a, b, c, d, e, f, K(50), M(50) );\n      R( f, g, h, a, b, c, d, e, K(51), M(51) );\n      R( e, f, g, h, a, b, c, d, K(52), M(52) );\n      R( d, e, f, g, h, a, b, c, K(53), M(53) );\n      R( c, d, e, f, g, h, a, b, K(54), M(54) );\n      R( b, c, d, e, f, g, h, a, K(55), M(55) );\n      R( a, b, c, d, e, f, g, h, K(56), M(56) );\n      R( h, a, b, c, d, e, f, g, K(57), M(57) );\n      R( g, h, a, b, c, d, e, f, K(58), M(58) );\n      R( f, g, h, a, b, c, d, e, K(59), M(59) );\n      R( e, f, g, h, a, b, c, d, K(60), M(60) );\n      R( d, e, f, g, h, a, b, c, K(61), M(61) );\n      R( c, d, e, f, g, h, a, b, K(62), M(62) );\n      R( b, c, d, e, f, g, h, a, K(63), M(63) );\n\n      a = ctx->state[0] += a;\n      b = ctx->state[1] += b;\n      c = ctx->state[2] += c;\n      d = ctx->state[3] += d;\n      e = ctx->state[4] += e;\n      f = ctx->state[5] += f;\n      g = ctx->state[6] += g;\n      h = ctx->state[7] += h;\n    }\n}\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}