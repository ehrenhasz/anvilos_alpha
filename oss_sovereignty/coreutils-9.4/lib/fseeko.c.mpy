{
  "module_name": "fseeko.c",
  "hash_id": "95d9b7f21da097eb352661e2988c1fec39827cfbe633b085d3588a563a2e0fef",
  "original_prompt": "Ingested from coreutils-9.4/lib/fseeko.c",
  "human_readable_source": " \n#include <stdio.h>\n\n \n#include <unistd.h>\n\n#include \"stdio-impl.h\"\n\nint\nfseeko (FILE *fp, off_t offset, int whence)\n#undef fseeko\n#if !HAVE_FSEEKO\n# undef fseek\n# define fseeko fseek\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n# undef fseeko\n# if HAVE__FSEEKI64 && HAVE_DECL__FSEEKI64  \n#  define fseeko _fseeki64\n# else  \n#  define fseeko fseeko64\n# endif\n#endif\n{\n#if LSEEK_PIPE_BROKEN\n   \n  if (lseek (fileno (fp), 0, SEEK_CUR) == -1)\n    return EOF;\n#endif\n\n   \n#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n   \n  if (fp->_IO_read_end == fp->_IO_read_ptr\n      && fp->_IO_write_ptr == fp->_IO_write_base\n      && fp->_IO_save_base == NULL)\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n   \n# if defined __SL64 && defined __SCLE  \n  if ((fp->_flags & __SL64) == 0)\n    {\n       \n      FILE *tmp = fopen (\"/dev/null\", \"r\");\n      if (!tmp)\n        return -1;\n      fp->_flags |= __SL64;\n      fp->_seek64 = tmp->_seek64;\n      fclose (tmp);\n    }\n# endif\n  if (fp_->_p == fp_->_bf._base\n      && fp_->_r == 0\n      && fp_->_w == ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0  \n                     ? fp_->_bf._size\n                     : 0)\n      && fp_ub._base == NULL)\n#elif defined __EMX__                \n  if (fp->_ptr == fp->_buffer\n      && fp->_rcount == 0\n      && fp->_wcount == 0\n      && fp->_ungetc_count == 0)\n#elif defined __minix                \n  if (fp_->_ptr == fp_->_buf\n      && (fp_->_ptr == NULL || fp_->_count == 0))\n#elif defined _IOERR                 \n  if (fp_->_ptr == fp_->_base\n      && (fp_->_ptr == NULL || fp_->_cnt == 0))\n#elif defined __UCLIBC__             \n  if (((fp->__modeflags & __FLAG_WRITING) == 0\n       || fp->__bufpos == fp->__bufstart)\n      && ((fp->__modeflags & (__FLAG_READONLY | __FLAG_READING)) == 0\n          || fp->__bufpos == fp->__bufread))\n#elif defined __QNX__                \n  if ((fp->_Mode & 0x2000   ? fp->_Next == fp->_Buf : fp->_Next == fp->_Rend)\n      && fp->_Rback == fp->_Back + sizeof (fp->_Back)\n      && fp->_Rsave == NULL)\n#elif defined __MINT__               \n  if (fp->__bufp == fp->__buffer\n      && fp->__get_limit == fp->__bufp\n      && fp->__put_limit == fp->__bufp\n      && !fp->__pushed_back)\n#elif defined EPLAN9                 \n  if (fp->rp == fp->buf\n      && fp->wp == fp->buf)\n#elif FUNC_FFLUSH_STDIN < 0 && 200809 <= _POSIX_VERSION\n   \n  if (0)\n#else\n  #error \"Please port gnulib fseeko.c to your platform! Look at the code in fseeko.c, then report this to bug-gnulib.\"\n#endif\n    {\n       \n      off_t pos = lseek (fileno (fp), offset, whence);\n      if (pos == -1)\n        {\n#if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n           \n          fp_->_flags &= ~__SOFF;\n#endif\n          return -1;\n        }\n\n#if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n       \n      fp->_flags &= ~_IO_EOF_SEEN;\n      fp->_offset = pos;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n       \n# if defined __CYGWIN__ || (defined __NetBSD__ && __NetBSD_Version__ >= 600000000) || defined __minix\n       \n      fp_->_offset = pos;\n# else\n       \n      {\n         \n        union\n          {\n            fpos_t f;\n            off_t o;\n          } u;\n        u.o = pos;\n        fp_->_offset = u.f;\n      }\n# endif\n      fp_->_flags |= __SOFF;\n      fp_->_flags &= ~__SEOF;\n#elif defined __EMX__                \n      fp->_flags &= ~_IOEOF;\n#elif defined _IOERR                 \n      fp_->_flag &= ~_IOEOF;\n#elif defined __MINT__               \n      fp->__offset = pos;\n      fp->__eof = 0;\n#endif\n      return 0;\n    }\n  return fseeko (fp, offset, whence);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}