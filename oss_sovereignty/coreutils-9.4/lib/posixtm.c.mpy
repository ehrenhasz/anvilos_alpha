{
  "module_name": "posixtm.c",
  "hash_id": "caa66f26793039220a1f8d0c380d33c8ecbc3b5fcd8b927c771e37e1376f9c2d",
  "original_prompt": "Ingested from coreutils-9.4/lib/posixtm.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"posixtm.h\"\n\n#include \"c-ctype.h\"\n#include \"idx.h\"\n#include \"verify.h\"\n\n#include <stdckdint.h>\n#include <string.h>\n\n \n\nstatic bool\nyear (struct tm *tm, const int *digit_pair, idx_t n, unsigned int syntax_bits)\n{\n  switch (n)\n    {\n    case 1:\n      tm->tm_year = *digit_pair;\n       \n      if (digit_pair[0] <= 68)\n        {\n          if (syntax_bits & PDS_PRE_2000)\n            return false;\n          tm->tm_year += 100;\n        }\n      break;\n\n    case 2:\n      if (! (syntax_bits & PDS_CENTURY))\n        return false;\n      tm->tm_year = digit_pair[0] * 100 + digit_pair[1] - 1900;\n      break;\n\n    case 0:\n      {\n         \n        time_t now = time (NULL);\n        struct tm *tmp = localtime (&now);\n        if (! tmp)\n          return false;\n        tm->tm_year = tmp->tm_year;\n      }\n      break;\n\n    default:\n      assume (false);\n    }\n\n  return true;\n}\n\nstatic bool\nposix_time_parse (struct tm *tm, const char *s, unsigned int syntax_bits)\n{\n  const char *dot = NULL;\n  int pair[6];\n\n  idx_t s_len = strlen (s);\n  idx_t len = s_len;\n\n  if (syntax_bits & PDS_SECONDS)\n    {\n      dot = strchr (s, '.');\n      if (dot)\n        {\n          len = dot - s;\n          if (s_len - len != 3)\n            return false;\n        }\n    }\n\n  if (! (8 <= len && len <= 12 && len % 2 == 0))\n    return false;\n\n  for (idx_t i = 0; i < len; i++)\n    if (!c_isdigit (s[i]))\n      return false;\n\n  len /= 2;\n  for (idx_t i = 0; i < len; i++)\n    pair[i] = 10 * (s[2*i] - '0') + s[2*i + 1] - '0';\n\n  int *p = pair;\n  if (! (syntax_bits & PDS_TRAILING_YEAR))\n    {\n      if (! year (tm, p, len - 4, syntax_bits))\n        return false;\n      p += len - 4;\n      len = 4;\n    }\n\n   \n  tm->tm_mon = *p++ - 1;\n  tm->tm_mday = *p++;\n  tm->tm_hour = *p++;\n  tm->tm_min = *p++;\n  len -= 4;\n\n   \n  if (syntax_bits & PDS_TRAILING_YEAR)\n    {\n      if (! year (tm, p, len, syntax_bits))\n        return false;\n    }\n\n   \n  if (!dot)\n    tm->tm_sec = 0;\n  else if (c_isdigit (dot[1]) && c_isdigit (dot[2]))\n    tm->tm_sec = 10 * (dot[1] - '0') + dot[2] - '0';\n  else\n    return false;\n\n  return true;\n}\n\n \n\nbool\nposixtime (time_t *p, const char *s, unsigned int syntax_bits)\n{\n  struct tm tm0;\n  bool leapsec = false;\n\n  if (! posix_time_parse (&tm0, s, syntax_bits))\n    return false;\n\n  while (true)\n    {\n      struct tm tm1;\n      tm1.tm_sec = tm0.tm_sec;\n      tm1.tm_min = tm0.tm_min;\n      tm1.tm_hour = tm0.tm_hour;\n      tm1.tm_mday = tm0.tm_mday;\n      tm1.tm_mon = tm0.tm_mon;\n      tm1.tm_year = tm0.tm_year;\n      tm1.tm_wday = -1;\n      tm1.tm_isdst = -1;\n      time_t t = mktime (&tm1);\n\n      if (tm1.tm_wday < 0)\n        return false;\n\n       \n      if (! ((tm0.tm_year ^ tm1.tm_year)\n             | (tm0.tm_mon ^ tm1.tm_mon)\n             | (tm0.tm_mday ^ tm1.tm_mday)\n             | (tm0.tm_hour ^ tm1.tm_hour)\n             | (tm0.tm_min ^ tm1.tm_min)\n             | (tm0.tm_sec ^ tm1.tm_sec)))\n        {\n          if (ckd_add (&t, t, leapsec))\n            return false;\n          *p = t;\n          return true;\n        }\n\n       \n      if (tm0.tm_sec != 60)\n        return false;\n\n       \n      tm0.tm_sec = 59;\n      leapsec = true;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}