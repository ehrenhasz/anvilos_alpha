{
  "module_name": "link.c",
  "hash_id": "ed73cde071cb9c89140f3eb0f08bae5c2522d756d9ab6c57428ad3cbc3e65862",
  "original_prompt": "Ingested from coreutils-9.4/lib/link.c",
  "human_readable_source": " \n#  undef GetModuleHandle\n#  define GetModuleHandle GetModuleHandleA\n#  undef CreateHardLink\n#  define CreateHardLink CreateHardLinkA\n\n#  if !(_WIN32_WINNT >= _WIN32_WINNT_WINXP)\n\n \n#   define GetProcAddress \\\n     (void *) GetProcAddress\n\n \ntypedef BOOL (WINAPI * CreateHardLinkFuncType) (LPCSTR lpFileName,\n                                                LPCSTR lpExistingFileName,\n                                                LPSECURITY_ATTRIBUTES lpSecurityAttributes);\nstatic CreateHardLinkFuncType CreateHardLinkFunc = NULL;\nstatic BOOL initialized = FALSE;\n\nstatic void\ninitialize (void)\n{\n  HMODULE kernel32 = GetModuleHandle (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n      CreateHardLinkFunc =\n        (CreateHardLinkFuncType) GetProcAddress (kernel32, \"CreateHardLinkA\");\n    }\n  initialized = TRUE;\n}\n\n#  else\n\n#   define CreateHardLinkFunc CreateHardLink\n\n#  endif\n\nint\nlink (const char *file1, const char *file2)\n{\n  char *dir;\n  size_t len1 = strlen (file1);\n  size_t len2 = strlen (file2);\n\n#  if !(_WIN32_WINNT >= _WIN32_WINNT_WINXP)\n  if (!initialized)\n    initialize ();\n#  endif\n\n  if (CreateHardLinkFunc == NULL)\n    {\n       \n      errno = EPERM;\n      return -1;\n    }\n   \n  if ((len1 && (file1[len1 - 1] == '/' || file1[len1 - 1] == '\\\\'))\n      || (len2 && (file2[len2 - 1] == '/' || file2[len2 - 1] == '\\\\')))\n    {\n       \n      struct stat st;\n      if (stat (file1, &st))\n        {\n          if (errno == EOVERFLOW)\n             \n            errno = ENOTDIR;\n          return -1;\n        }\n      if (!S_ISDIR (st.st_mode))\n        errno = ENOTDIR;\n      else\n        errno = EPERM;\n      return -1;\n    }\n   \n  dir = strdup (file2);\n  if (!dir)\n    return -1;\n  {\n    struct stat st;\n    char *p = strchr (dir, '\\0');\n    while (dir < p && (*--p != '/' && *p != '\\\\'));\n    *p = '\\0';\n    if (p != dir && stat (dir, &st) != 0 && errno != EOVERFLOW)\n      {\n        free (dir);\n        return -1;\n      }\n    free (dir);\n  }\n   \n  if (CreateHardLinkFunc (file2, file1, NULL) == 0)\n    {\n       \n      DWORD err = GetLastError ();\n      switch (err)\n        {\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          break;\n\n        case ERROR_INVALID_FUNCTION:     \n          errno = EPERM;\n          break;\n\n        case ERROR_NOT_SAME_DEVICE:\n          errno = EXDEV;\n          break;\n\n        case ERROR_PATH_NOT_FOUND:\n        case ERROR_FILE_NOT_FOUND:\n          errno = ENOENT;\n          break;\n\n        case ERROR_INVALID_PARAMETER:\n          errno = ENAMETOOLONG;\n          break;\n\n        case ERROR_TOO_MANY_LINKS:\n          errno = EMLINK;\n          break;\n\n        case ERROR_ALREADY_EXISTS:\n          errno = EEXIST;\n          break;\n\n        default:\n          errno = EIO;\n        }\n      return -1;\n    }\n\n  return 0;\n}\n\n# else  \n\n#  error \"This platform lacks a link function, and Gnulib doesn't provide a replacement. This is a bug in Gnulib.\"\n\n# endif  \n#else  \n\n# undef link\n\n \nint\nrpl_link (char const *file1, char const *file2)\n{\n  size_t len1;\n  size_t len2;\n  struct stat st;\n\n   \n  if (lstat (file2, &st) == 0 || errno == EOVERFLOW)\n    {\n      errno = EEXIST;\n      return -1;\n    }\n\n   \n  len1 = strlen (file1);\n  len2 = strlen (file2);\n  if ((len1 && file1[len1 - 1] == '/')\n      || (len2 && file2[len2 - 1] == '/'))\n    {\n       \n      if (stat (file1, &st))\n        return -1;\n      if (!S_ISDIR (st.st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n  else\n    {\n       \n      char *dir = strdup (file2);\n      char *p;\n      if (!dir)\n        return -1;\n       \n      p = strrchr (dir, '/');\n      if (p)\n        {\n          *p = '\\0';\n          if (stat (dir, &st) != 0 && errno != EOVERFLOW)\n            {\n              free (dir);\n              return -1;\n            }\n        }\n      free (dir);\n    }\n  return link (file1, file2);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}