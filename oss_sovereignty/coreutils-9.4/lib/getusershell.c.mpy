{
  "module_name": "getusershell.c",
  "hash_id": "97fe9f88c07115edb434b896b2a9a47e5cf8df3c077713ce5081be801d6c3dec",
  "original_prompt": "Ingested from coreutils-9.4/lib/getusershell.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <unistd.h>\n\n#ifndef SHELLS_FILE\n# ifndef __DJGPP__\n \n#  define SHELLS_FILE \"/etc/shells\"\n# else\n \n#  define SHELLS_FILE \"/dev/env/DJDIR/etc/shells\"\n# endif\n#endif\n\n#include <stdlib.h>\n#include <ctype.h>\n\n#include \"stdio--.h\"\n#include \"xalloc.h\"\n\n#if GNULIB_GETUSERSHELL_SINGLE_THREAD\n# include \"unlocked-io.h\"\n#endif\n\nstatic idx_t readname (char **, idx_t *, FILE *);\n\n#if ! defined ADDITIONAL_DEFAULT_SHELLS && defined __MSDOS__\n# define ADDITIONAL_DEFAULT_SHELLS \\\n  \"c:/dos/command.com\", \"c:/windows/command.com\", \"c:/command.com\",\n#else\n# define ADDITIONAL_DEFAULT_SHELLS  \n#endif\n\n \nstatic char const* const default_shells[] =\n{\n  ADDITIONAL_DEFAULT_SHELLS\n  \"/bin/sh\", \"/bin/csh\", \"/usr/bin/sh\", \"/usr/bin/csh\", NULL\n};\n\n \nstatic size_t default_index = 0;\n\n \nstatic FILE *shellstream = NULL;\n\n \nstatic char *line = NULL;\n\n \nstatic idx_t line_size = 0;\n\f\n \n\nchar *\ngetusershell (void)\n{\n  if (default_index > 0)\n    {\n      if (default_shells[default_index])\n         \n        return xstrdup (default_shells[default_index++]);\n      return NULL;\n    }\n\n  if (shellstream == NULL)\n    {\n      shellstream = fopen (SHELLS_FILE, \"r\");\n      if (shellstream == NULL)\n        {\n           \n          default_index = 1;\n          return xstrdup (default_shells[0]);\n        }\n    }\n\n  while (readname (&line, &line_size, shellstream))\n    {\n      if (*line != '#')\n        return line;\n    }\n  return NULL;                   \n}\n\n \n\nvoid\nsetusershell (void)\n{\n  default_index = 0;\n  if (shellstream)\n    rewind (shellstream);\n}\n\n \n\nvoid\nendusershell (void)\n{\n  if (shellstream)\n    {\n      fclose (shellstream);\n      shellstream = NULL;\n    }\n}\n\n \n\nstatic idx_t\nreadname (char **name, idx_t *size, FILE *stream)\n{\n  int c;\n  size_t name_index = 0;\n\n   \n  while ((c = getc (stream)) != EOF && isspace (c))\n      ;\n\n  for (;;)\n    {\n      if (*size <= name_index)\n        *name = xpalloc (*name, size, 1, -1, sizeof **name);\n      if (c == EOF || isspace (c))\n        break;\n      (*name)[name_index++] = c;\n      c = getc (stream);\n    }\n  (*name)[name_index] = '\\0';\n  return name_index;\n}\n\n#ifdef TEST\nint\nmain (void)\n{\n  char *s;\n\n  while (s = getusershell ())\n    puts (s);\n  exit (0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}