{
  "module_name": "exclude.c",
  "hash_id": "fc4f18118db36bedaf2a37f975fd0bb6cb0ec64d44db55c7274f47acb92a8739",
  "original_prompt": "Ingested from coreutils-9.4/lib/exclude.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <regex.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <uchar.h>\n\n#include \"exclude.h\"\n#include \"filename.h\"\n#include \"fnmatch.h\"\n#include \"hash.h\"\n#include \"mbuiter.h\"\n#include \"xalloc.h\"\n\n#if GNULIB_EXCLUDE_SINGLE_THREAD\n# include \"unlocked-io.h\"\n#endif\n\n \n#ifndef FNM_CASEFOLD\n# define FNM_CASEFOLD 0\n#endif\n#ifndef FNM_EXTMATCH\n# define FNM_EXTMATCH 0\n#endif\n#ifndef FNM_LEADING_DIR\n# define FNM_LEADING_DIR 0\n#endif\n\nstatic_assert (((EXCLUDE_ANCHORED | EXCLUDE_INCLUDE | EXCLUDE_WILDCARDS)\n                & (FNM_PATHNAME | FNM_NOESCAPE | FNM_PERIOD | FNM_LEADING_DIR\n                   | FNM_CASEFOLD | FNM_EXTMATCH))\n               == 0);\n\n\n \n\n\n \n\nstruct patopts\n  {\n    int options;\n    union\n    {\n      char const *pattern;\n      regex_t re;\n    } v;\n  };\n\n \n\nstruct exclude_pattern\n  {\n    struct patopts *exclude;\n    idx_t exclude_alloc;\n    idx_t exclude_count;\n  };\n\nenum exclude_type\n  {\n    exclude_hash,                     \n    exclude_pattern                   \n  };\n\nstruct exclude_segment\n  {\n    struct exclude_segment *next;     \n    enum exclude_type type;           \n    int options;                      \n    union\n    {\n      Hash_table *table;              \n      struct exclude_pattern pat;     \n    } v;\n  };\n\nstruct pattern_buffer\n  {\n    struct pattern_buffer *next;\n    char *base;\n  };\n\n \nstruct exclude\n  {\n    struct exclude_segment *head;\n    struct pattern_buffer *patbuf;\n  };\n\n \nvoid\nexclude_add_pattern_buffer (struct exclude *ex, char *buf)\n{\n  struct pattern_buffer *pbuf = xmalloc (sizeof *pbuf);\n  pbuf->base = buf;\n  pbuf->next = ex->patbuf;\n  ex->patbuf = pbuf;\n}\n\n \nbool\nfnmatch_pattern_has_wildcards (const char *str, int options)\n{\n  while (true)\n    {\n      switch (*str++)\n        {\n        case '.':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n          if (options & EXCLUDE_REGEX)\n            return true;\n          break;\n\n        case '\\\\':\n          if (options & EXCLUDE_REGEX)\n            continue;\n          else\n            str += ! (options & FNM_NOESCAPE) && *str;\n          break;\n\n        case '+': case '@': case '!':\n          if (options & FNM_EXTMATCH && *str == '(')\n            return true;\n          break;\n\n        case '?': case '*': case '[':\n          return true;\n\n        case '\\0':\n          return false;\n        }\n    }\n}\n\nstatic void\nunescape_pattern (char *str)\n{\n  char const *q = str;\n  do\n    q += *q == '\\\\' && q[1];\n  while ((*str++ = *q++));\n}\n\n \n\nstruct exclude *\nnew_exclude (void)\n{\n  return xzalloc (sizeof *new_exclude ());\n}\n\n \nstatic size_t\nstring_hasher (void const *data, size_t n_buckets)\n{\n  return hash_string (data, n_buckets);\n}\n\n \nstatic size_t\nstring_hasher_ci (void const *data, size_t n_buckets)\n{\n  char const *p = data;\n  size_t value = 0;\n\n  mbui_iterator_t iter;\n  for (mbui_init (iter, p); mbui_avail (iter); mbui_advance (iter))\n    {\n      mbchar_t m = mbui_cur (iter);\n      char32_t wc;\n\n      if (m.wc_valid)\n        wc = c32tolower (m.wc);\n      else\n        wc = *m.ptr;\n\n      value = value * 31 + wc;\n    }\n\n  return value % n_buckets;\n}\n\n \nstatic bool\nstring_compare (void const *data1, void const *data2)\n{\n  return strcmp (data1, data2) == 0;\n}\n\n \nstatic bool\nstring_compare_ci (void const *data1, void const *data2)\n{\n  return mbscasecmp (data1, data2) == 0;\n}\n\n \nstatic void\nnew_exclude_segment (struct exclude *ex, enum exclude_type type, int options)\n{\n  struct exclude_segment *sp = xmalloc (sizeof (struct exclude_segment));\n  sp->type = type;\n  sp->options = options;\n  switch (type)\n    {\n    case exclude_pattern:\n      sp->v.pat = (struct exclude_pattern) {0};\n      break;\n\n    case exclude_hash:\n      sp->v.table = hash_initialize (0, nullptr,\n                                     (options & FNM_CASEFOLD\n                                      ? string_hasher_ci\n                                      : string_hasher),\n                                     (options & FNM_CASEFOLD\n                                      ? string_compare_ci\n                                      : string_compare),\n                                     free);\n      break;\n    }\n  sp->next = ex->head;\n  ex->head = sp;\n}\n\n \nstatic void\nfree_exclude_segment (struct exclude_segment *seg)\n{\n  switch (seg->type)\n    {\n    case exclude_pattern:\n      for (idx_t i = 0; i < seg->v.pat.exclude_count; i++)\n        if (seg->v.pat.exclude[i].options & EXCLUDE_REGEX)\n          regfree (&seg->v.pat.exclude[i].v.re);\n      free (seg->v.pat.exclude);\n      break;\n\n    case exclude_hash:\n      hash_free (seg->v.table);\n      break;\n    }\n  free (seg);\n}\n\n \nvoid\nfree_exclude (struct exclude *ex)\n{\n  for (struct exclude_segment *seg = ex->head; seg; )\n    {\n      struct exclude_segment *next = seg->next;\n      free_exclude_segment (seg);\n      seg = next;\n    }\n\n  for (struct pattern_buffer *pbuf = ex->patbuf; pbuf; )\n    {\n      struct pattern_buffer *next = pbuf->next;\n      free (pbuf->base);\n      free (pbuf);\n      pbuf = next;\n    }\n\n  free (ex);\n}\n\n \n\nstatic int\nfnmatch_no_wildcards (char const *pattern, char const *f, int options)\n{\n  if (! (options & FNM_LEADING_DIR))\n    return ((options & FNM_CASEFOLD)\n            ? mbscasecmp (pattern, f)\n            : strcmp (pattern, f));\n  else if (! (options & FNM_CASEFOLD))\n    {\n      idx_t patlen = strlen (pattern);\n      int r = strncmp (pattern, f, patlen);\n      if (! r)\n        {\n          r = f[patlen];\n          if (r == '/')\n            r = 0;\n        }\n      return r;\n    }\n  else\n    {\n       \n\n      char *fcopy = xstrdup (f);\n      int r;\n      for (char *p = fcopy; ; *p++ = '/')\n        {\n          p = strchr (p, '/');\n          if (p)\n            *p = '\\0';\n          r = mbscasecmp (pattern, fcopy);\n          if (!p || r <= 0)\n            break;\n        }\n      free (fcopy);\n      return r;\n    }\n}\n\nbool\nexclude_fnmatch (char const *pattern, char const *f, int options)\n{\n  int (*matcher) (char const *, char const *, int) =\n    (options & EXCLUDE_WILDCARDS\n     ? fnmatch\n     : fnmatch_no_wildcards);\n  bool matched = matcher (pattern, f, options) == 0;\n\n  if (! (options & EXCLUDE_ANCHORED))\n    for (char const *p = f; *p && ! matched; p++)\n      if (*p == '/' && p[1] != '/')\n        matched = matcher (pattern, p + 1, options) == 0;\n\n  return matched;\n}\n\nstatic bool\nexclude_patopts (struct patopts const *opts, char const *f)\n{\n  int options = opts->options;\n\n  return (options & EXCLUDE_REGEX\n          ? regexec (&opts->v.re, f, 0, nullptr, 0) == 0\n          : exclude_fnmatch (opts->v.pattern, f, options));\n}\n\n \n\nstatic bool\nfile_pattern_matches (struct exclude_segment const *seg, char const *f)\n{\n  idx_t exclude_count = seg->v.pat.exclude_count;\n  struct patopts const *exclude = seg->v.pat.exclude;\n\n  for (idx_t i = 0; i < exclude_count; i++)\n    if (exclude_patopts (exclude + i, f))\n      return true;\n  return false;\n}\n\n \nstatic bool\nfile_name_matches (struct exclude_segment const *seg, char const *f,\n                   char *buffer)\n{\n  int options = seg->options;\n  Hash_table *table = seg->v.table;\n\n  do\n    {\n       \n      strcpy (buffer, f);\n\n      while (true)\n        {\n          if (hash_lookup (table, buffer))\n            return true;\n          if (options & FNM_LEADING_DIR)\n            {\n              char *p = strrchr (buffer, '/');\n              if (p)\n                {\n                  *p = '\\0';\n                  continue;\n                }\n            }\n          break;\n        }\n\n      if (!(options & EXCLUDE_ANCHORED))\n        {\n          f = strchr (f, '/');\n          if (f)\n            f++;\n        }\n      else\n        break;\n    }\n  while (f);\n\n  return false;\n}\n\n \n\nbool\nexcluded_file_name (struct exclude const *ex, char const *f)\n{\n   \n  if (!ex->head)\n    return false;\n\n  bool invert = false;\n  char *filename = nullptr;\n\n   \n  struct exclude_segment *seg;\n  for (seg = ex->head; ; seg = seg->next)\n    {\n      if (seg->type == exclude_hash)\n        {\n          if (!filename)\n            filename = xmalloc (strlen (f) + 1);\n          if (file_name_matches (seg, f, filename))\n            break;\n        }\n      else\n        {\n          if (file_pattern_matches (seg, f))\n            break;\n        }\n\n      if (! seg->next)\n        {\n           \n          invert = true;\n          break;\n        }\n    }\n\n  free (filename);\n  return invert ^ ! (seg->options & EXCLUDE_INCLUDE);\n}\n\n \n\nvoid\nadd_exclude (struct exclude *ex, char const *pattern, int options)\n{\n  if ((options & (EXCLUDE_REGEX|EXCLUDE_WILDCARDS))\n      && fnmatch_pattern_has_wildcards (pattern, options))\n    {\n      if (! (ex->head && ex->head->type == exclude_pattern\n             && ((ex->head->options & EXCLUDE_INCLUDE)\n                 == (options & EXCLUDE_INCLUDE))))\n        new_exclude_segment (ex, exclude_pattern, options);\n\n      struct exclude_pattern *pat = &ex->head->v.pat;\n      if (pat->exclude_count == pat->exclude_alloc)\n        pat->exclude = xpalloc (pat->exclude, &pat->exclude_alloc, 1, -1,\n                                sizeof *pat->exclude);\n      struct patopts *patopts = &pat->exclude[pat->exclude_count++];\n\n      patopts->options = options;\n      if (options & EXCLUDE_REGEX)\n        {\n          int rc;\n          int cflags = (REG_NOSUB | REG_EXTENDED\n                        | (options & FNM_CASEFOLD ? REG_ICASE : 0));\n\n          if (! (options & FNM_LEADING_DIR))\n            rc = regcomp (&patopts->v.re, pattern, cflags);\n          else\n            for (idx_t len = strlen (pattern); ; len--)\n              {\n                if (len == 0)\n                  {\n                    rc = 1;\n                    break;\n                  }\n                if (!ISSLASH (pattern[len - 1]))\n                  {\n                    static char const patsuffix[] = \"(/.*)?\";\n                    char *tmp = ximalloc (len + sizeof patsuffix);\n                    memcpy (tmp, pattern, len);\n                    strcpy (tmp + len, patsuffix);\n                    rc = regcomp (&patopts->v.re, tmp, cflags);\n                    free (tmp);\n                    break;\n                  }\n              }\n\n          if (rc)\n            {\n              pat->exclude_count--;\n              return;\n            }\n        }\n      else\n        {\n          if (options & EXCLUDE_ALLOC)\n            {\n              char *dup = xstrdup (pattern);\n              pattern = dup;\n              exclude_add_pattern_buffer (ex, dup);\n            }\n          patopts->v.pattern = pattern;\n        }\n    }\n  else\n    {\n      int exclude_hash_flags = (EXCLUDE_INCLUDE | EXCLUDE_ANCHORED\n                                | FNM_LEADING_DIR | FNM_CASEFOLD);\n      if (! (ex->head && ex->head->type == exclude_hash\n             && ((ex->head->options & exclude_hash_flags)\n                 == (options & exclude_hash_flags))))\n        new_exclude_segment (ex, exclude_hash, options);\n\n      char *str = xstrdup (pattern);\n      if ((options & (EXCLUDE_WILDCARDS | FNM_NOESCAPE)) == EXCLUDE_WILDCARDS)\n        unescape_pattern (str);\n      if (hash_insert (ex->head->v.table, str) != str)\n        free (str);\n    }\n}\n\n \n\nint\nadd_exclude_fp (void (*add_func) (struct exclude *, char const *, int, void *),\n                struct exclude *ex, FILE *fp, int options,\n                char line_end, void *data)\n{\n  char *buf = nullptr;\n  idx_t buf_alloc = 0;\n  idx_t buf_count = 0;\n\n  for (int c; (c = getc (fp)) != EOF; )\n    {\n      if (buf_count == buf_alloc)\n        buf = xpalloc (buf, &buf_alloc, 1, -1, 1);\n      buf[buf_count++] = c;\n    }\n\n  int e = ferror (fp) ? errno : 0;\n\n  buf = xirealloc (buf, buf_count + 1);\n  buf[buf_count] = line_end;\n  char const *lim = (buf + buf_count\n                     + ! (buf_count == 0 || buf[buf_count - 1] == line_end));\n\n  exclude_add_pattern_buffer (ex, buf);\n\n  char *pattern = buf;\n\n  for (char *p = buf; p < lim; p++)\n    if (*p == line_end)\n      {\n        char *pattern_end = p;\n\n        if (isspace ((unsigned char) line_end))\n          {\n             \n            for (; ; pattern_end--)\n              if (pattern_end == pattern)\n                goto next_pattern;\n              else if (! isspace ((unsigned char) pattern_end[-1]))\n                break;\n          }\n\n        *pattern_end = '\\0';\n        add_func (ex, pattern, options, data);\n\n      next_pattern:\n        pattern = p + 1;\n      }\n\n  errno = e;\n  return e ? -1 : 0;\n}\n\nstatic void\ncall_addfn (struct exclude *ex, char const *pattern, int options, void *data)\n{\n  void (**addfnptr) (struct exclude *, char const *, int) = data;\n  (*addfnptr) (ex, pattern, options);\n}\n\nint\nadd_exclude_file (void (*add_func) (struct exclude *, char const *, int),\n                  struct exclude *ex, char const *file_name, int options,\n                  char line_end)\n{\n  if (strcmp (file_name, \"-\") == 0)\n    return add_exclude_fp (call_addfn, ex, stdin, options, line_end, &add_func);\n\n  FILE *in = fopen (file_name, \"re\");\n  if (!in)\n    return -1;\n  int rc = add_exclude_fp (call_addfn, ex, in, options, line_end, &add_func);\n  int e = errno;\n  if (fclose (in) < 0)\n    return -1;\n  errno = e;\n  return rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}