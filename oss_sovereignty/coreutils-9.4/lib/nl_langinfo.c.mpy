{
  "module_name": "nl_langinfo.c",
  "hash_id": "2b4d33161f8a7fd5612a201eede45214ef7021c9e0ffb889719bd210ff5c0fdd",
  "original_prompt": "Ingested from coreutils-9.4/lib/nl_langinfo.c",
  "human_readable_source": " \n#include <langinfo.h>\n\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#if defined _WIN32 && ! defined __CYGWIN__\n# define WIN32_LEAN_AND_MEAN   \n# include <windows.h>\n# include <stdio.h>\n#endif\n\n#if REPLACE_NL_LANGINFO && !NL_LANGINFO_MTSAFE\n# if defined _WIN32 && !defined __CYGWIN__\n\n#  define WIN32_LEAN_AND_MEAN   \n#  include <windows.h>\n\n# elif HAVE_PTHREAD_API\n\n#  include <pthread.h>\n#  if HAVE_THREADS_H && HAVE_WEAK_SYMBOLS\n#   include <threads.h>\n#   pragma weak thrd_exit\n#   define c11_threads_in_use() (thrd_exit != NULL)\n#  else\n#   define c11_threads_in_use() 0\n#  endif\n\n# elif HAVE_THREADS_H\n\n#  include <threads.h>\n\n# endif\n#endif\n\n \n\n#if !REPLACE_NL_LANGINFO || GNULIB_defined_CODESET\n \nstatic char *\nctype_codeset (void)\n{\n   \n  static char result[2 + 10 + 1];\n  char buf[2 + 10 + 1];\n  char locale[SETLOCALE_NULL_MAX];\n  char *codeset;\n  size_t codesetlen;\n\n  if (setlocale_null_r (LC_CTYPE, locale, sizeof (locale)))\n    locale[0] = '\\0';\n\n  codeset = buf;\n  codeset[0] = '\\0';\n\n  if (locale[0])\n    {\n       \n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n           \n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n# if defined _WIN32 && ! defined __CYGWIN__\n   \n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n   \n  if (strcmp (buf + 2, \"65001\") == 0 || strcmp (buf + 2, \"utf8\") == 0)\n    return (char *) \"UTF-8\";\n  else\n    {\n      memcpy (buf, \"CP\", 2);\n      strcpy (result, buf);\n      return result;\n    }\n# else\n  strcpy (result, codeset);\n  return result;\n#endif\n}\n#endif\n\n\n#if REPLACE_NL_LANGINFO\n\n \n\n# undef nl_langinfo\n\n \n\n# if !NL_LANGINFO_MTSAFE  \n\n#  define ITEMS (MAXSTRMSG + 1)\n#  define MAX_RESULT_LEN 80\n\nstatic char *\nnl_langinfo_unlocked (nl_item item)\n{\n  static char result[ITEMS][MAX_RESULT_LEN];\n\n   \n  char *tmp = nl_langinfo (item);\n  if (item >= 0 && item < ITEMS && tmp != NULL)\n    {\n      size_t tmp_len = strlen (tmp);\n      if (tmp_len < MAX_RESULT_LEN)\n        strcpy (result[item], tmp);\n      else\n        {\n           \n          result[item][MAX_RESULT_LEN - 1] = '\\0';\n          memcpy (result[item], tmp, MAX_RESULT_LEN - 1);\n        }\n      return result[item];\n    }\n  else\n    return tmp;\n}\n\n \n\n \n#  undef gl_get_nl_langinfo_lock\n\n#  if defined _WIN32 && !defined __CYGWIN__\n\nextern __declspec(dllimport) CRITICAL_SECTION *gl_get_nl_langinfo_lock (void);\n\nstatic char *\nnl_langinfo_with_lock (nl_item item)\n{\n  CRITICAL_SECTION *lock = gl_get_nl_langinfo_lock ();\n  char *ret;\n\n  EnterCriticalSection (lock);\n  ret = nl_langinfo_unlocked (item);\n  LeaveCriticalSection (lock);\n\n  return ret;\n}\n\n#  elif HAVE_PTHREAD_API\n\nextern\n#   if defined _WIN32 || defined __CYGWIN__\n  __declspec(dllimport)\n#   endif\n  pthread_mutex_t *gl_get_nl_langinfo_lock (void);\n\n#   if HAVE_WEAK_SYMBOLS  \n\n      \n#    pragma weak pthread_mutex_lock\n#    pragma weak pthread_mutex_unlock\n\n      \n#    pragma weak pthread_mutexattr_gettype\n      \n#    define pthread_in_use() \\\n       (pthread_mutexattr_gettype != NULL || c11_threads_in_use ())\n\n#   else\n#    define pthread_in_use() 1\n#   endif\n\nstatic char *\nnl_langinfo_with_lock (nl_item item)\n{\n  if (pthread_in_use())\n    {\n      pthread_mutex_t *lock = gl_get_nl_langinfo_lock ();\n      char *ret;\n\n      if (pthread_mutex_lock (lock))\n        abort ();\n      ret = nl_langinfo_unlocked (item);\n      if (pthread_mutex_unlock (lock))\n        abort ();\n\n      return ret;\n    }\n  else\n    return nl_langinfo_unlocked (item);\n}\n\n#  elif HAVE_THREADS_H\n\nextern mtx_t *gl_get_nl_langinfo_lock (void);\n\nstatic char *\nnl_langinfo_with_lock (nl_item item)\n{\n  mtx_t *lock = gl_get_nl_langinfo_lock ();\n  char *ret;\n\n  if (mtx_lock (lock) != thrd_success)\n    abort ();\n  ret = nl_langinfo_unlocked (item);\n  if (mtx_unlock (lock) != thrd_success)\n    abort ();\n\n  return ret;\n}\n\n#  endif\n\n# else\n\n \n#  define nl_langinfo_with_lock nl_langinfo\n\n# endif\n\nchar *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ALTMON\n    case ALTMON_1:\n    case ALTMON_2:\n    case ALTMON_3:\n    case ALTMON_4:\n    case ALTMON_5:\n    case ALTMON_6:\n    case ALTMON_7:\n    case ALTMON_8:\n    case ALTMON_9:\n    case ALTMON_10:\n    case ALTMON_11:\n    case ALTMON_12:\n       \n      item = item - ALTMON_1 + MON_1;\n      break;\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n       \n      return (char *) \"\";\n    case ERA_D_FMT:\n       \n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n       \n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n       \n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n       \n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo_with_lock (item);\n}\n\n#else\n\n \n\n# include <time.h>\n\nchar *\nnl_langinfo (nl_item item)\n{\n  char buf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n     \n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return (char *) \"UTF-8\";\n# else\n      return (char *) \"ISO-8859-1\";\n# endif\n     \n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n# ifdef GROUPING\n    case GROUPING:\n      return localeconv () ->grouping;\n# endif\n     \n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return (char *) \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return (char *) \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return (char *) \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return (char *) \"%I:%M:%S %p\";\n    case AM_STR:\n      {\n        static char result[80];\n        if (!strftime (buf, sizeof result, \"%p\", &tmm))\n          return (char *) \"AM\";\n        strcpy (result, buf);\n        return result;\n      }\n    case PM_STR:\n      {\n        static char result[80];\n        tmm.tm_hour = 12;\n        if (!strftime (buf, sizeof result, \"%p\", &tmm))\n          return (char *) \"PM\";\n        strcpy (result, buf);\n        return result;\n      }\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char result[7][50];\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (buf, sizeof result[0], \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        strcpy (result[item - DAY_1], buf);\n        return result[item - DAY_1];\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char result[7][30];\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (buf, sizeof result[0], \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        strcpy (result[item - ABDAY_1], buf);\n        return result[item - ABDAY_1];\n      }\n    {\n      static char const months[][sizeof \"September\"] = {\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n        \"September\", \"October\", \"November\", \"December\"\n      };\n      case MON_1:\n      case MON_2:\n      case MON_3:\n      case MON_4:\n      case MON_5:\n      case MON_6:\n      case MON_7:\n      case MON_8:\n      case MON_9:\n      case MON_10:\n      case MON_11:\n      case MON_12:\n        {\n          static char result[12][50];\n          tmm.tm_mon = item - MON_1;\n          if (!strftime (buf, sizeof result[0], \"%B\", &tmm))\n            return (char *) months[item - MON_1];\n          strcpy (result[item - MON_1], buf);\n          return result[item - MON_1];\n        }\n      case ALTMON_1:\n      case ALTMON_2:\n      case ALTMON_3:\n      case ALTMON_4:\n      case ALTMON_5:\n      case ALTMON_6:\n      case ALTMON_7:\n      case ALTMON_8:\n      case ALTMON_9:\n      case ALTMON_10:\n      case ALTMON_11:\n      case ALTMON_12:\n        {\n          static char result[12][50];\n          tmm.tm_mon = item - ALTMON_1;\n           \n          #if 0\n          if (!strftime (buf, sizeof result[0], \"%OB\", &tmm))\n          #endif\n            if (!strftime (buf, sizeof result[0], \"%B\", &tmm))\n              return (char *) months[item - ALTMON_1];\n          strcpy (result[item - ALTMON_1], buf);\n          return result[item - ALTMON_1];\n        }\n    }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char result[12][30];\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (buf, sizeof result[0], \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        strcpy (result[item - ABMON_1], buf);\n        return result[item - ABMON_1];\n      }\n    case ERA:\n      return (char *) \"\";\n    case ALT_DIGITS:\n      return (char *) \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n     \n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n# ifdef INT_CURR_SYMBOL\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n# endif\n     \n    case YESEXPR:\n      return (char *) \"^[yY]\";\n    case NOEXPR:\n      return (char *) \"^[nN]\";\n    default:\n      return (char *) \"\";\n    }\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}