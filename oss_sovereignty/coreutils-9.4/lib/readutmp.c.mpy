{
  "module_name": "readutmp.c",
  "hash_id": "4ff7fa9b131a284e0ed9ccfb2f1f873923b6bce00d2cf4e153c38069c052de4f",
  "original_prompt": "Ingested from coreutils-9.4/lib/readutmp.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"readutmp.h\"\n\n#include <errno.h>\n#include <stdio.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#if defined __linux__ || defined __ANDROID__\n# include <sys/sysinfo.h>\n# include <time.h>\n#endif\n#if READUTMP_USE_SYSTEMD\n# include <dirent.h>\n# include <systemd/sd-login.h>\n#endif\n\n#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__) && !defined __minix\n# if HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n# endif\n# include <sys/sysctl.h>\n#endif\n\n#if HAVE_OS_H\n# include <OS.h>\n#endif\n\n#include \"stat-time.h\"\n#include \"xalloc.h\"\n\n \n#include \"unlocked-io.h\"\n\n \n#include \"boot-time-aux.h\"\n\n \n#undef UT_USER\n#undef UT_TIME_MEMBER\n#undef UT_PID\n#undef UT_TYPE_EQ\n#undef UT_TYPE_NOT_DEFINED\n#undef UT_EXIT_E_TERMINATION\n#undef UT_EXIT_E_EXIT\n\n \n#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_NAME \\\n     : HAVE_UTMP_H && HAVE_STRUCT_UTMP_UT_NAME)\n# define UT_USER(UT) ((UT)->ut_name)\n#else\n# define UT_USER(UT) ((UT)->ut_user)\n#endif\n\n \n#if HAVE_UTMPX_H || (HAVE_UTMP_H && HAVE_STRUCT_UTMP_UT_TV)\n# define UT_TIME_MEMBER(UT) ((UT)->ut_tv.tv_sec)\n#else\n# define UT_TIME_MEMBER(UT) ((UT)->ut_time)\n#endif\n\n \n#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_PID : HAVE_STRUCT_UTMP_UT_PID)\n# define UT_PID(UT) ((UT)->ut_pid)\n#else\n# define UT_PID(UT) 0\n#endif\n\n \n#if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_TYPE : HAVE_STRUCT_UTMP_UT_TYPE)\n# define UT_TYPE_EQ(UT, V) ((UT)->ut_type == (V))\n# define UT_TYPE_NOT_DEFINED 0\n#else\n# define UT_TYPE_EQ(UT, V) 0\n# define UT_TYPE_NOT_DEFINED 1\n#endif\n\n#if HAVE_UTMPX_H\n# if HAVE_STRUCT_UTMPX_UT_EXIT_E_TERMINATION\n#  define UT_EXIT_E_TERMINATION(UT) ((UT)->ut_exit.e_termination)\n# elif HAVE_STRUCT_UTMPX_UT_EXIT_UT_TERMINATION  \n#  define UT_EXIT_E_TERMINATION(UT) ((UT)->ut_exit.ut_termination)\n# else\n#  define UT_EXIT_E_TERMINATION(UT) 0\n# endif\n#elif HAVE_UTMP_H\n# if HAVE_STRUCT_UTMP_UT_EXIT_E_TERMINATION\n#  define UT_EXIT_E_TERMINATION(UT) ((UT)->ut_exit.e_termination)\n# else\n#  define UT_EXIT_E_TERMINATION(UT) 0\n# endif\n#endif\n\n#if HAVE_UTMPX_H\n# if HAVE_STRUCT_UTMPX_UT_EXIT_E_EXIT\n#  define UT_EXIT_E_EXIT(UT) ((UT)->ut_exit.e_exit)\n# elif HAVE_STRUCT_UTMPX_UT_EXIT_UT_EXIT  \n#  define UT_EXIT_E_EXIT(UT) ((UT)->ut_exit.ut_exit)\n# else\n#  define UT_EXIT_E_EXIT(UT) 0\n# endif\n#elif HAVE_UTMP_H\n# if HAVE_STRUCT_UTMP_UT_EXIT_E_EXIT\n#  define UT_EXIT_E_EXIT(UT) ((UT)->ut_exit.e_exit)\n# else\n#  define UT_EXIT_E_EXIT(UT) 0\n# endif\n#endif\n\n \n#define UT_USER_SIZE  sizeof UT_USER ((struct UTMP_STRUCT_NAME *) 0)\n \n#define UT_ID_SIZE    sizeof (((struct UTMP_STRUCT_NAME *) 0)->ut_id)\n \n#define UT_LINE_SIZE  sizeof (((struct UTMP_STRUCT_NAME *) 0)->ut_line)\n \n#define UT_HOST_SIZE  sizeof (((struct UTMP_STRUCT_NAME *) 0)->ut_host)\n\n#if 8 <= __GNUC__\n# pragma GCC diagnostic ignored \"-Wsizeof-pointer-memaccess\"\n#endif\n\n \n\nchar *\nextract_trimmed_name (const STRUCT_UTMP *ut)\n{\n  char const *name = ut->ut_user;\n  idx_t len = strlen (name);\n  char const *p;\n  for (p = name + len; name < p && p[-1] == ' '; p--)\n    continue;\n  return ximemdup0 (name, p - name);\n}\n\n#if READ_UTMP_SUPPORTED\n\n \n\nstatic bool\ndesirable_utmp_entry (STRUCT_UTMP const *ut, int options)\n{\n# if defined __OpenBSD__ && !HAVE_UTMPX_H\n   \n  if (ut->ut_ts.tv_sec == 0 && ut->ut_user[0] == '\\0'\n      && ut->ut_line[0] == '\\0' && ut->ut_host[0] == '\\0')\n    return false;\n# endif\n\n  bool boot_time = UT_TYPE_BOOT_TIME (ut);\n  if ((options & READ_UTMP_BOOT_TIME) && !boot_time)\n    return false;\n  if ((options & READ_UTMP_NO_BOOT_TIME) && boot_time)\n    return false;\n\n  bool user_proc = IS_USER_PROCESS (ut);\n  if ((options & READ_UTMP_USER_PROCESS) && !user_proc)\n    return false;\n# if !(defined __CYGWIN__ || defined _WIN32)\n  if ((options & READ_UTMP_CHECK_PIDS)\n      && user_proc\n      && 0 < UT_PID (ut)\n      && (kill (UT_PID (ut), 0) < 0 && errno == ESRCH))\n    return false;\n# endif\n\n  return true;\n}\n\n \n\nstruct utmp_alloc\n{\n   \n  struct gl_utmp *utmp;\n\n   \n  idx_t filled;\n\n   \n  idx_t string_bytes;\n\n   \n  idx_t alloc_bytes;\n};\n\n \n\nstatic struct utmp_alloc\nadd_utmp (struct utmp_alloc a, int options,\n          char const *user, idx_t user_len,\n          char const *id, idx_t id_len,\n          char const *line, idx_t line_len,\n          char const *host, idx_t host_len,\n          pid_t pid, short type, struct timespec ts, long session,\n          int termination, int exit)\n{\n  int entry_bytes = sizeof (struct gl_utmp);\n  idx_t avail = a.alloc_bytes - (entry_bytes * a.filled + a.string_bytes);\n  idx_t needed_string_bytes =\n    (user_len + 1) + (id_len + 1) + (line_len + 1) + (host_len + 1);\n  idx_t needed = entry_bytes + needed_string_bytes;\n  if (avail < needed)\n    {\n      idx_t old_string_offset = a.alloc_bytes - a.string_bytes;\n      void *new = xpalloc (a.utmp, &a.alloc_bytes, needed - avail, -1, 1);\n      idx_t new_string_offset = a.alloc_bytes - a.string_bytes;\n      a.utmp = new;\n      char *q = new;\n      memmove (q + new_string_offset, q + old_string_offset, a.string_bytes);\n    }\n  struct gl_utmp *ut = &a.utmp[a.filled];\n  char *stringlim = (char *) a.utmp + a.alloc_bytes;\n  char *p = stringlim - a.string_bytes;\n  *--p = '\\0';  \n  ut->ut_user = p = memcpy (p - user_len, user, user_len);\n  *--p = '\\0';  \n  ut->ut_id   = p = memcpy (p -   id_len,   id,   id_len);\n  *--p = '\\0';  \n  ut->ut_line = p = memcpy (p - line_len, line, line_len);\n  *--p = '\\0';  \n  ut->ut_host =     memcpy (p - host_len, host, host_len);\n  ut->ut_ts = ts;\n  ut->ut_pid = pid;\n  ut->ut_session = session;\n  ut->ut_type = type;\n  ut->ut_exit.e_termination = termination;\n  ut->ut_exit.e_exit = exit;\n  if (desirable_utmp_entry (ut, options))\n    {\n       \n      ut->ut_user = (char *) (intptr_t) (ut->ut_user - stringlim);\n      ut->ut_id   = (char *) (intptr_t) (ut->ut_id   - stringlim);\n      ut->ut_line = (char *) (intptr_t) (ut->ut_line - stringlim);\n      ut->ut_host = (char *) (intptr_t) (ut->ut_host - stringlim);\n      a.filled++;\n      a.string_bytes += needed_string_bytes;\n    }\n  return a;\n}\n\n \nstatic struct utmp_alloc\nfinish_utmp (struct utmp_alloc a)\n{\n  char *stringlim = (char *) a.utmp + a.alloc_bytes;\n\n  for (idx_t i = 0; i < a.filled; i++)\n    {\n      a.utmp[i].ut_user = (intptr_t) a.utmp[i].ut_user + stringlim;\n      a.utmp[i].ut_id   = (intptr_t) a.utmp[i].ut_id   + stringlim;\n      a.utmp[i].ut_line = (intptr_t) a.utmp[i].ut_line + stringlim;\n      a.utmp[i].ut_host = (intptr_t) a.utmp[i].ut_host + stringlim;\n    }\n\n  return a;\n}\n\n \n_GL_ATTRIBUTE_MAYBE_UNUSED\nstatic bool\nhave_boot_time (struct utmp_alloc a)\n{\n  for (idx_t i = 0; i < a.filled; i++)\n    {\n      struct gl_utmp *ut = &a.utmp[i];\n      if (UT_TYPE_BOOT_TIME (ut))\n        return true;\n    }\n  return false;\n}\n\n#if !HAVE_UTMPX_H && HAVE_UTMP_H && defined UTMP_NAME_FUNCTION\n# if !HAVE_DECL_ENDUTENT  \nvoid endutent (void);\n# endif\n#endif\n\nstatic int\nread_utmp_from_file (char const *file, idx_t *n_entries, STRUCT_UTMP **utmp_buf,\n                     int options)\n{\n  if ((options & READ_UTMP_BOOT_TIME) != 0\n      && (options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) != 0)\n    {\n       \n      *n_entries = 0;\n      *utmp_buf = NULL;\n      return 0;\n    }\n\n  struct utmp_alloc a = {0};\n\n# if READUTMP_USE_SYSTEMD || HAVE_UTMPX_H || HAVE_UTMP_H\n\n#  if defined UTMP_NAME_FUNCTION  \n\n   \n  UTMP_NAME_FUNCTION ((char *) file);\n\n  SET_UTMP_ENT ();\n\n#   if (defined __linux__ && !defined __ANDROID__) || defined __minix\n  bool file_is_utmp = (strcmp (file, UTMP_FILE) == 0);\n   \n  struct timespec runlevel_ts = {0};\n#   endif\n\n  void const *entry;\n\n  while ((entry = GET_UTMP_ENT ()) != NULL)\n    {\n      struct UTMP_STRUCT_NAME const *ut = (struct UTMP_STRUCT_NAME const *) entry;\n\n      struct timespec ts =\n        #if (HAVE_UTMPX_H ? 1 : HAVE_STRUCT_UTMP_UT_TV)\n        { .tv_sec = ut->ut_tv.tv_sec, .tv_nsec = ut->ut_tv.tv_usec * 1000 };\n        #else\n        { .tv_sec = ut->ut_time, .tv_nsec = 0 };\n        #endif\n\n      a = add_utmp (a, options,\n                    UT_USER (ut), strnlen (UT_USER (ut), UT_USER_SIZE),\n                    #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_ID : HAVE_STRUCT_UTMP_UT_ID)\n                    ut->ut_id, strnlen (ut->ut_id, UT_ID_SIZE),\n                    #else\n                    \"\", 0,\n                    #endif\n                    ut->ut_line, strnlen (ut->ut_line, UT_LINE_SIZE),\n                    #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_HOST : HAVE_STRUCT_UTMP_UT_HOST)\n                    ut->ut_host, strnlen (ut->ut_host, UT_HOST_SIZE),\n                    #else\n                    \"\", 0,\n                    #endif\n                    #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_PID : HAVE_STRUCT_UTMP_UT_PID)\n                    ut->ut_pid,\n                    #else\n                    0,\n                    #endif\n                    #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_TYPE : HAVE_STRUCT_UTMP_UT_TYPE)\n                    ut->ut_type,\n                    #else\n                    0,\n                    #endif\n                    ts,\n                    #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_SESSION : HAVE_STRUCT_UTMP_UT_SESSION)\n                    ut->ut_session,\n                    #else\n                    0,\n                    #endif\n                    UT_EXIT_E_TERMINATION (ut), UT_EXIT_E_EXIT (ut)\n                   );\n#   if defined __linux__ && !defined __ANDROID__\n      if (file_is_utmp\n          && memcmp (UT_USER (ut), \"runlevel\", strlen (\"runlevel\") + 1) == 0\n          && memcmp (ut->ut_line, \"~\", strlen (\"~\") + 1) == 0)\n        runlevel_ts = ts;\n#   endif\n#   if defined __minix\n      if (file_is_utmp\n          && UT_USER (ut)[0] == '\\0'\n          && memcmp (ut->ut_line, \"run-level \", strlen (\"run-level \")) == 0)\n        runlevel_ts = ts;\n#   endif\n    }\n\n  END_UTMP_ENT ();\n\n#   if defined __linux__ && !defined __ANDROID__\n   \n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && file_is_utmp)\n    {\n      for (idx_t i = 0; i < a.filled; i++)\n        {\n          struct gl_utmp *ut = &a.utmp[i];\n          if (UT_TYPE_BOOT_TIME (ut))\n            {\n               \n              if (ut->ut_ts.tv_sec <= 60 && runlevel_ts.tv_sec != 0)\n                ut->ut_ts = runlevel_ts;\n              break;\n            }\n        }\n      if (!have_boot_time (a))\n        {\n           \n          struct timespec boot_time;\n          if (get_linux_boot_time_fallback (&boot_time) >= 0)\n            a = add_utmp (a, options,\n                          \"reboot\", strlen (\"reboot\"),\n                          \"\", 0,\n                          \"~\", strlen (\"~\"),\n                          \"\", 0,\n                          0, BOOT_TIME, boot_time, 0, 0, 0);\n        }\n    }\n#   endif\n\n#   if defined __ANDROID__\n   \n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_android_boot_time (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"\", 0,\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n#   endif\n\n#   if defined __minix\n   \n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && file_is_utmp)\n    {\n      for (idx_t i = 0; i < a.filled; i++)\n        {\n          struct gl_utmp *ut = &a.utmp[i];\n          if (UT_TYPE_BOOT_TIME (ut))\n            {\n              if (ut->ut_ts.tv_sec <= 60 && runlevel_ts.tv_sec != 0)\n                ut->ut_ts = runlevel_ts;\n              break;\n            }\n        }\n    }\n#   endif\n\n#  else  \n\n  FILE *f = fopen (file, \"re\");\n\n  if (f != NULL)\n    {\n      for (;;)\n        {\n          struct UTMP_STRUCT_NAME ut;\n\n          if (fread (&ut, sizeof ut, 1, f) == 0)\n            break;\n          a = add_utmp (a, options,\n                        UT_USER (&ut), strnlen (UT_USER (&ut), UT_USER_SIZE),\n                        #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_ID : HAVE_STRUCT_UTMP_UT_ID)\n                        ut.ut_id, strnlen (ut.ut_id, UT_ID_SIZE),\n                        #else\n                        \"\", 0,\n                        #endif\n                        ut.ut_line, strnlen (ut.ut_line, UT_LINE_SIZE),\n                        #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_HOST : HAVE_STRUCT_UTMP_UT_HOST)\n                        ut.ut_host, strnlen (ut.ut_host, UT_HOST_SIZE),\n                        #else\n                        \"\", 0,\n                        #endif\n                        #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_PID : HAVE_STRUCT_UTMP_UT_PID)\n                        ut.ut_pid,\n                        #else\n                        0,\n                        #endif\n                        #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_TYPE : HAVE_STRUCT_UTMP_UT_TYPE)\n                        ut.ut_type,\n                        #else\n                        0,\n                        #endif\n                        #if (HAVE_UTMPX_H ? 1 : HAVE_STRUCT_UTMP_UT_TV)\n                        (struct timespec) { .tv_sec = ut.ut_tv.tv_sec, .tv_nsec = ut.ut_tv.tv_usec * 1000 },\n                        #else\n                        (struct timespec) { .tv_sec = ut.ut_time, .tv_nsec = 0 },\n                        #endif\n                        #if (HAVE_UTMPX_H ? HAVE_STRUCT_UTMPX_UT_SESSION : HAVE_STRUCT_UTMP_UT_SESSION)\n                        ut.ut_session,\n                        #else\n                        0,\n                        #endif\n                        UT_EXIT_E_TERMINATION (&ut), UT_EXIT_E_EXIT (&ut)\n                       );\n        }\n\n      int saved_errno = ferror (f) ? errno : 0;\n      if (fclose (f) != 0)\n        saved_errno = errno;\n      if (saved_errno != 0)\n        {\n          free (a.utmp);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  else\n    {\n      if (strcmp (file, UTMP_FILE) != 0)\n        {\n          int saved_errno = errno;\n          free (a.utmp);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n\n#   if defined __OpenBSD__\n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_openbsd_boot_time (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"\", 0,\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n#   endif\n\n#  endif\n\n#  if defined __linux__ && !defined __ANDROID__\n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_linux_boot_time_final_fallback (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"~\", strlen (\"~\"),\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n\n#  endif\n\n#  if HAVE_SYS_SYSCTL_H && HAVE_SYSCTL \\\n      && defined CTL_KERN && defined KERN_BOOTTIME \\\n      && !defined __minix\n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_bsd_boot_time_final_fallback (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"\", 0,\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n#  endif\n\n#  if defined __HAIKU__\n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_haiku_boot_time (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"\", 0,\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n#  endif\n\n#  if HAVE_OS_H  \n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_haiku_boot_time_final_fallback (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"\", 0,\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n#  endif\n\n# endif\n\n# if defined __CYGWIN__ || defined _WIN32\n  if ((options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)) == 0\n      && strcmp (file, UTMP_FILE) == 0\n      && !have_boot_time (a))\n    {\n      struct timespec boot_time;\n      if (get_windows_boot_time (&boot_time) >= 0)\n        a = add_utmp (a, options,\n                      \"reboot\", strlen (\"reboot\"),\n                      \"\", 0,\n                      \"\", 0,\n                      \"\", 0,\n                      0, BOOT_TIME, boot_time, 0, 0, 0);\n    }\n# endif\n\n  a = finish_utmp (a);\n\n  *n_entries = a.filled;\n  *utmp_buf = a.utmp;\n\n  return 0;\n}\n\n# if READUTMP_USE_SYSTEMD\n \n\nstatic struct timespec\nget_boot_time_uncached (void)\n{\n   \n  {\n    idx_t n_entries = 0;\n    STRUCT_UTMP *utmp = NULL;\n    read_utmp_from_file (UTMP_FILE, &n_entries, &utmp, READ_UTMP_BOOT_TIME);\n    if (n_entries > 0)\n      {\n        struct timespec result = utmp[0].ut_ts;\n        free (utmp);\n        return result;\n      }\n    free (utmp);\n  }\n\n   \n  return (struct timespec) {0};\n}\n\nstatic struct timespec\nget_boot_time (void)\n{\n  static bool volatile cached;\n  static struct timespec volatile boot_time;\n\n  if (!cached)\n    {\n      boot_time = get_boot_time_uncached ();\n      cached = true;\n    }\n  return boot_time;\n}\n\n \nstatic char *\nguess_pty_name (uid_t uid, const struct timespec at)\n{\n   \n  DIR *dirp = opendir (\"/dev/pts\");\n  if (dirp != NULL)\n    {\n       \n      char name_buf[9 + 10 + 1];\n      memcpy (name_buf, \"/dev/pts/\", 9);\n\n      char best_name[9 + 10 + 1];\n      struct timespec best_time = { .tv_sec = 0, .tv_nsec = 0 };\n\n      for (;;)\n        {\n          struct dirent *dp = readdir (dirp);\n          if (dp == NULL)\n            break;\n          if (dp->d_name[0] != '.' && strlen (dp->d_name) <= 10)\n            {\n               \n              strcpy (name_buf + 9, dp->d_name);\n\n               \n              struct stat st;\n              if (stat (name_buf, &st) >= 0\n                  && st.st_uid == uid\n                  && (st.st_ctim.tv_sec > at.tv_sec\n                      || (st.st_ctim.tv_sec == at.tv_sec\n                          && st.st_ctim.tv_nsec >= at.tv_nsec)))\n                {\n                   \n                   \n                  if ((best_time.tv_sec == 0 && best_time.tv_nsec == 0)\n                      || (st.st_ctim.tv_sec < best_time.tv_sec\n                          || (st.st_ctim.tv_sec == best_time.tv_sec\n                              && st.st_ctim.tv_nsec < best_time.tv_nsec)))\n                    {\n                      strcpy (best_name, name_buf);\n                      best_time = st.st_ctim;\n                    }\n                }\n            }\n        }\n\n      closedir (dirp);\n\n       \n      if (!(best_time.tv_sec == 0 && best_time.tv_nsec == 0)\n          && (best_time.tv_sec < at.tv_sec + 5\n              || (best_time.tv_sec == at.tv_sec + 5\n                  && best_time.tv_nsec <= at.tv_nsec)))\n        return xstrdup (best_name + 5);\n    }\n\n  return NULL;\n}\n\nstatic int\nread_utmp_from_systemd (idx_t *n_entries, STRUCT_UTMP **utmp_buf, int options)\n{\n   \n  struct utmp_alloc a = {0};\n\n   \n  if (!(options & (READ_UTMP_USER_PROCESS | READ_UTMP_NO_BOOT_TIME)))\n    a = add_utmp (a, options,\n                  \"reboot\", strlen (\"reboot\"),\n                  \"\", 0,\n                  \"~\", strlen (\"~\"),\n                  \"\", 0,\n                  0, BOOT_TIME, get_boot_time (), 0, 0, 0);\n\n   \n  if (!(options & READ_UTMP_BOOT_TIME))\n    {\n      char **sessions;\n      int num_sessions = sd_get_sessions (&sessions);\n      if (num_sessions >= 0)\n        {\n          char **session_ptr;\n          for (session_ptr = sessions; *session_ptr != NULL; session_ptr++)\n            {\n              char *session = *session_ptr;\n\n              uint64_t start_usec;\n              if (sd_session_get_start_time (session, &start_usec) < 0)\n                start_usec = 0;\n              struct timespec start_ts;\n              start_ts.tv_sec = start_usec / 1000000;\n              start_ts.tv_nsec = start_usec % 1000000 * 1000;\n\n              char *seat;\n              if (sd_session_get_seat (session, &seat) < 0)\n                seat = NULL;\n\n              char missing[] = \"\";\n\n              char *type = NULL;\n              char *tty;\n              if (sd_session_get_tty (session, &tty) < 0)\n                {\n                  tty = NULL;\n                   \n                  if (sd_session_get_type (session, &type) < 0)\n                    type = missing;\n                  if (strcmp (type, \"tty\") == 0)\n                    {\n                      char *service;\n                      if (sd_session_get_service (session, &service) < 0)\n                        service = NULL;\n\n                      uid_t uid;\n                      char *pty = (sd_session_get_uid (session, &uid) < 0 ? NULL\n                                   : guess_pty_name (uid, start_ts));\n\n                      if (service != NULL && pty != NULL)\n                        {\n                          tty = xmalloc (strlen (service) + 1 + strlen (pty) + 1);\n                          stpcpy (stpcpy (stpcpy (tty, service), \" \"), pty);\n                          free (pty);\n                          free (service);\n                        }\n                      else if (service != NULL)\n                        tty = service;\n                      else if (pty != NULL)\n                        tty = pty;\n                    }\n                }\n\n               \n              if (seat != NULL || tty != NULL)\n                {\n                  char *user;\n                  if (sd_session_get_username (session, &user) < 0)\n                    user = missing;\n\n                  pid_t leader_pid;\n                  if (sd_session_get_leader (session, &leader_pid) < 0)\n                    leader_pid = 0;\n\n                  char *host;\n                  char *remote_host;\n                  if (sd_session_get_remote_host (session, &remote_host) < 0)\n                    {\n                      host = missing;\n                       \n                      if (!type && sd_session_get_type (session, &type) < 0)\n                        type = missing;\n                      if (strcmp (type, \"x11\") == 0)\n                        {\n                          char *display;\n                          if (sd_session_get_display (session, &display) < 0)\n                            display = NULL;\n                          host = display;\n                        }\n                    }\n                  else\n                    {\n                      char *remote_user;\n                      if (sd_session_get_remote_user (session, &remote_user) < 0)\n                        host = remote_host;\n                      else\n                        {\n                          host = xmalloc (strlen (remote_user) + 1\n                                          + strlen (remote_host) + 1);\n                          stpcpy (stpcpy (stpcpy (host, remote_user), \"@\"),\n                                  remote_host);\n                          free (remote_user);\n                          free (remote_host);\n                        }\n                    }\n\n                  if (seat != NULL)\n                    a = add_utmp (a, options,\n                                  user, strlen (user),\n                                  session, strlen (session),\n                                  seat, strlen (seat),\n                                  host, strlen (host),\n                                  leader_pid  ,\n                                  USER_PROCESS, start_ts, leader_pid, 0, 0);\n                  if (tty != NULL)\n                    a = add_utmp (a, options,\n                                  user, strlen (user),\n                                  session, strlen (session),\n                                  tty, strlen (tty),\n                                  host, strlen (host),\n                                  leader_pid  ,\n                                  USER_PROCESS, start_ts, leader_pid, 0, 0);\n\n                  if (host != missing)\n                    free (host);\n                  if (user != missing)\n                    free (user);\n                }\n\n              if (type != missing)\n                free (type);\n              free (tty);\n              free (seat);\n              free (session);\n            }\n          free (sessions);\n        }\n    }\n\n  a = finish_utmp (a);\n\n  *n_entries = a.filled;\n  *utmp_buf = a.utmp;\n\n  return 0;\n}\n\n# endif\n\nint\nread_utmp (char const *file, idx_t *n_entries, STRUCT_UTMP **utmp_buf,\n           int options)\n{\n# if READUTMP_USE_SYSTEMD\n  if (strcmp (file, UTMP_FILE) == 0)\n     \n    return read_utmp_from_systemd (n_entries, utmp_buf, options);\n# endif\n\n  return read_utmp_from_file (file, n_entries, utmp_buf, options);\n}\n\n#else  \n\nint\nread_utmp (char const *file, idx_t *n_entries, STRUCT_UTMP **utmp_buf,\n           int options)\n{\n  errno = ENOSYS;\n  return -1;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}