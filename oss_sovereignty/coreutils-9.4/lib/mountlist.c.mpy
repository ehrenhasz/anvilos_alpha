{
  "module_name": "mountlist.c",
  "hash_id": "f3d6a41dfec052ace901ca9952ddab835d18795d9c3e399fb1f7349d55c481f5",
  "original_prompt": "Ingested from coreutils-9.4/lib/mountlist.c",
  "human_readable_source": " \n# if HAVE_SYS_UCRED_H\n#  include <grp.h>  \n#  include <sys/ucred.h>  \n# endif\n# if HAVE_SYS_MOUNT_H\n#  include <sys/mount.h>\n# endif\n# if HAVE_SYS_FS_TYPES_H\n#  include <sys/fs_types.h>  \n# endif\n# if HAVE_STRUCT_FSSTAT_F_FSTYPENAME\n#  define FS_TYPE(Ent) ((Ent).f_fstypename)\n# else\n#  define FS_TYPE(Ent) mnt_names[(Ent).f_type]\n# endif\n#endif  \n\n#ifdef MOUNTED_GETMNTENT1        \n# include <mntent.h>\n# include <sys/types.h>\n# if defined __ANDROID__         \n    \n#  undef MOUNTED\n#  define MOUNTED \"/proc/mounts\"\n# elif !defined MOUNTED\n#  if defined _PATH_MOUNTED      \n#   define MOUNTED _PATH_MOUNTED\n#  endif\n#  if defined MNT_MNTTAB         \n#   define MOUNTED MNT_MNTTAB\n#  endif\n# endif\n#endif\n\n#ifdef MOUNTED_GETMNTINFO        \n# include <sys/mount.h>\n#endif\n\n#ifdef MOUNTED_GETMNTINFO2       \n# include <sys/statvfs.h>\n#endif\n\n#ifdef MOUNTED_FS_STAT_DEV       \n# include <fs_info.h>\n# include <dirent.h>\n#endif\n\n#ifdef MOUNTED_FREAD_FSTYP       \n# include <mnttab.h>\n# include <sys/fstyp.h>\n# include <sys/statfs.h>\n#endif\n\n#ifdef MOUNTED_GETEXTMNTENT      \n# include <sys/mnttab.h>\n#endif\n\n#ifdef MOUNTED_GETMNTENT2        \n# include <sys/mnttab.h>\n#endif\n\n#ifdef MOUNTED_VMOUNT            \n# include <fshelp.h>\n# include <sys/vfs.h>\n#endif\n\n#ifdef MOUNTED_INTERIX_STATVFS   \n# include <sys/statvfs.h>\n# include <dirent.h>\n#endif\n\n#if HAVE_SYS_MNTENT_H\n \n# include <sys/mntent.h>\n#endif\n\n#ifdef MOUNTED_GETMNTENT1\n# if !HAVE_SETMNTENT             \n#  define setmntent(fp,mode) fopen (fp, mode \"e\")\n# endif\n# if !HAVE_ENDMNTENT             \n#  define endmntent(fp) fclose (fp)\n# endif\n#endif\n\n#ifndef HAVE_HASMNTOPT\n# define hasmntopt(mnt, opt) ((char *) 0)\n#endif\n\n#undef MNT_IGNORE\n#ifdef MNTOPT_IGNORE\n# if defined __sun && defined __SVR4\n \n#  define MNT_IGNORE(M) hasmntopt (M, (char *) MNTOPT_IGNORE)\n# else\n#  define MNT_IGNORE(M) hasmntopt (M, MNTOPT_IGNORE)\n# endif\n#else\n# define MNT_IGNORE(M) 0\n#endif\n\n \n#include \"unlocked-io.h\"\n\n \n#ifdef GNULIB_defined_DIR\n# undef DIR\n# undef opendir\n# undef closedir\n# undef readdir\n#else\n# ifdef GNULIB_defined_opendir\n#  undef opendir\n# endif\n# ifdef GNULIB_defined_closedir\n#  undef closedir\n# endif\n#endif\n\n#define ME_DUMMY_0(Fs_name, Fs_type)            \\\n  (strcmp (Fs_type, \"autofs\") == 0              \\\n   || strcmp (Fs_type, \"proc\") == 0             \\\n   || strcmp (Fs_type, \"subfs\") == 0            \\\n                          \\\n   || strcmp (Fs_type, \"debugfs\") == 0          \\\n   || strcmp (Fs_type, \"devpts\") == 0           \\\n   || strcmp (Fs_type, \"fusectl\") == 0          \\\n   || strcmp (Fs_type, \"fuse.portal\") == 0      \\\n   || strcmp (Fs_type, \"mqueue\") == 0           \\\n   || strcmp (Fs_type, \"rpc_pipefs\") == 0       \\\n   || strcmp (Fs_type, \"sysfs\") == 0            \\\n                         \\\n   || strcmp (Fs_type, \"devfs\") == 0            \\\n                             \\\n   || strcmp (Fs_type, \"kernfs\") == 0           \\\n                               \\\n   || strcmp (Fs_type, \"ignore\") == 0)\n\n \n#ifdef MOUNTED_GETMNTENT1\n# define ME_DUMMY(Fs_name, Fs_type, Bind)\t\\\n  (ME_DUMMY_0 (Fs_name, Fs_type)\t\t\\\n   || (strcmp (Fs_type, \"none\") == 0 && !Bind))\n#else\n# define ME_DUMMY(Fs_name, Fs_type)\t\t\\\n  (ME_DUMMY_0 (Fs_name, Fs_type) || strcmp (Fs_type, \"none\") == 0)\n#endif\n\n#ifdef __CYGWIN__\n# include <windows.h>\n \n# undef GetDriveType\n# define GetDriveType GetDriveTypeA\n# define ME_REMOTE me_remote\n \nstatic bool\nme_remote (char const *fs_name, _GL_UNUSED char const *fs_type)\n{\n  if (fs_name[0] && fs_name[1] == ':')\n    {\n      char drive[4];\n      sprintf (drive, \"%c:\\\\\", fs_name[0]);\n      switch (GetDriveType (drive))\n        {\n        case DRIVE_REMOVABLE:\n        case DRIVE_FIXED:\n        case DRIVE_CDROM:\n        case DRIVE_RAMDISK:\n          return false;\n        }\n    }\n  return true;\n}\n#endif\n\n#ifndef ME_REMOTE\n \n# define ME_REMOTE(Fs_name, Fs_type)            \\\n    (strchr (Fs_name, ':') != NULL              \\\n     || ((Fs_name)[0] == '/'                    \\\n         && (Fs_name)[1] == '/'                 \\\n         && (strcmp (Fs_type, \"smbfs\") == 0     \\\n             || strcmp (Fs_type, \"smb3\") == 0   \\\n             || strcmp (Fs_type, \"cifs\") == 0)) \\\n     || strcmp (Fs_type, \"acfs\") == 0           \\\n     || strcmp (Fs_type, \"afs\") == 0            \\\n     || strcmp (Fs_type, \"coda\") == 0           \\\n     || strcmp (Fs_type, \"auristorfs\") == 0     \\\n     || strcmp (Fs_type, \"fhgfs\") == 0          \\\n     || strcmp (Fs_type, \"gpfs\") == 0           \\\n     || strcmp (Fs_type, \"ibrix\") == 0          \\\n     || strcmp (Fs_type, \"ocfs2\") == 0          \\\n     || strcmp (Fs_type, \"vxfs\") == 0           \\\n     || strcmp (\"-hosts\", Fs_name) == 0)\n#endif\n\n#if MOUNTED_GETMNTINFO           \n\n# if ! HAVE_STRUCT_STATFS_F_FSTYPENAME\nstatic char *\nfstype_to_string (short int t)\n{\n  switch (t)\n    {\n#  ifdef MOUNT_PC\n    case MOUNT_PC:\n      return \"pc\";\n#  endif\n#  ifdef MOUNT_MFS\n    case MOUNT_MFS:\n      return \"mfs\";\n#  endif\n#  ifdef MOUNT_LO\n    case MOUNT_LO:\n      return \"lo\";\n#  endif\n#  ifdef MOUNT_TFS\n    case MOUNT_TFS:\n      return \"tfs\";\n#  endif\n#  ifdef MOUNT_TMP\n    case MOUNT_TMP:\n      return \"tmp\";\n#  endif\n#  ifdef MOUNT_UFS\n   case MOUNT_UFS:\n     return \"ufs\" ;\n#  endif\n#  ifdef MOUNT_NFS\n   case MOUNT_NFS:\n     return \"nfs\" ;\n#  endif\n#  ifdef MOUNT_MSDOS\n   case MOUNT_MSDOS:\n     return \"msdos\" ;\n#  endif\n#  ifdef MOUNT_LFS\n   case MOUNT_LFS:\n     return \"lfs\" ;\n#  endif\n#  ifdef MOUNT_LOFS\n   case MOUNT_LOFS:\n     return \"lofs\" ;\n#  endif\n#  ifdef MOUNT_FDESC\n   case MOUNT_FDESC:\n     return \"fdesc\" ;\n#  endif\n#  ifdef MOUNT_PORTAL\n   case MOUNT_PORTAL:\n     return \"portal\" ;\n#  endif\n#  ifdef MOUNT_NULL\n   case MOUNT_NULL:\n     return \"null\" ;\n#  endif\n#  ifdef MOUNT_UMAP\n   case MOUNT_UMAP:\n     return \"umap\" ;\n#  endif\n#  ifdef MOUNT_KERNFS\n   case MOUNT_KERNFS:\n     return \"kernfs\" ;\n#  endif\n#  ifdef MOUNT_PROCFS\n   case MOUNT_PROCFS:\n     return \"procfs\" ;\n#  endif\n#  ifdef MOUNT_AFS\n   case MOUNT_AFS:\n     return \"afs\" ;\n#  endif\n#  ifdef MOUNT_CD9660\n   case MOUNT_CD9660:\n     return \"cd9660\" ;\n#  endif\n#  ifdef MOUNT_UNION\n   case MOUNT_UNION:\n     return \"union\" ;\n#  endif\n#  ifdef MOUNT_DEVFS\n   case MOUNT_DEVFS:\n     return \"devfs\" ;\n#  endif\n#  ifdef MOUNT_EXT2FS\n   case MOUNT_EXT2FS:\n     return \"ext2fs\" ;\n#  endif\n    default:\n      return \"?\";\n    }\n}\n# endif\n\nstatic char *\nfsp_to_string (const struct statfs *fsp)\n{\n# if HAVE_STRUCT_STATFS_F_FSTYPENAME\n  return (char *) (fsp->f_fstypename);\n# else\n  return fstype_to_string (fsp->f_type);\n# endif\n}\n\n#endif  \n\n#ifdef MOUNTED_VMOUNT            \nstatic char *\nfstype_to_string (int t)\n{\n  struct vfs_ent *e;\n\n  e = getvfsbytype (t);\n  if (!e || !e->vfsent_name)\n    return \"none\";\n  else\n    return e->vfsent_name;\n}\n#endif  \n\n\n#if defined MOUNTED_GETMNTENT1 || defined MOUNTED_GETMNTENT2\n\n \nstatic dev_t\ndev_from_mount_options (char const *mount_options)\n{\n   \n# ifndef __linux__\n\n  static char const dev_pattern[] = \",dev=\";\n  char const *devopt = strstr (mount_options, dev_pattern);\n\n  if (devopt)\n    {\n      char const *optval = devopt + sizeof dev_pattern - 1;\n      char *optvalend;\n      unsigned long int dev;\n      errno = 0;\n      dev = strtoul (optval, &optvalend, 16);\n      if (optval != optvalend\n          && (*optvalend == '\\0' || *optvalend == ',')\n          && ! (dev == ULONG_MAX && errno == ERANGE)\n          && dev == (dev_t) dev)\n        return dev;\n    }\n\n# endif\n  (void) mount_options;\n  return -1;\n}\n\n#endif\n\n#if defined MOUNTED_GETMNTENT1 && (defined __linux__ || defined __ANDROID__)  \n\n \n\nstatic void\nunescape_tab (char *str)\n{\n  size_t i, j = 0;\n  size_t len = strlen (str) + 1;\n  for (i = 0; i < len; i++)\n    {\n      if (str[i] == '\\\\' && (i + 4 < len)\n          && str[i + 1] >= '0' && str[i + 1] <= '3'\n          && str[i + 2] >= '0' && str[i + 2] <= '7'\n          && str[i + 3] >= '0' && str[i + 3] <= '7')\n        {\n          str[j++] = (str[i + 1] - '0') * 64 +\n                     (str[i + 2] - '0') * 8 +\n                     (str[i + 3] - '0');\n          i += 3;\n        }\n      else\n        str[j++] = str[i];\n    }\n}\n\n \n\nstatic char *\nterminate_at_blank (char *str)\n{\n  char *s = strchr (str, ' ');\n  if (s)\n    *s = '\\0';\n  return s;\n}\n#endif\n\n \n\nstruct mount_entry *\nread_file_system_list (bool need_fs_type)\n{\n  struct mount_entry *mount_list;\n  struct mount_entry *me;\n  struct mount_entry **mtail = &mount_list;\n  (void) need_fs_type;\n\n#ifdef MOUNTED_GETMNTENT1        \n  {\n    FILE *fp;\n\n# if defined __linux__ || defined __ANDROID__\n     \n    char const *mountinfo = \"/proc/self/mountinfo\";\n    fp = fopen (mountinfo, \"re\");\n    if (fp != NULL)\n      {\n        char *line = NULL;\n        size_t buf_size = 0;\n\n        while (getline (&line, &buf_size, fp) != -1)\n          {\n            unsigned int devmaj, devmin;\n            int rc, mntroot_s;\n\n            rc = sscanf(line, \"%*u \"         \n                              \"%*u \"         \n                              \"%u:%u \"       \n                              \"%n\",          \n                              &devmaj, &devmin,\n                              &mntroot_s);\n\n            if (rc != 2 && rc != 3)   \n              continue;\n\n             \n            char *mntroot = line + mntroot_s;\n            char *blank = terminate_at_blank (mntroot);\n            if (! blank)\n              continue;\n\n             \n            char *target = blank + 1;\n            blank = terminate_at_blank (target);\n            if (! blank)\n              continue;\n\n             \n            char *dash = strstr (blank + 1, \" - \");\n            if (! dash)\n              continue;\n\n             \n            char *fstype = dash + 3;\n            blank = terminate_at_blank (fstype);\n            if (! blank)\n              continue;\n\n             \n            char *source = blank + 1;\n            if (! terminate_at_blank (source))\n              continue;\n\n             \n            unescape_tab (source);\n            unescape_tab (target);\n            unescape_tab (mntroot);\n            unescape_tab (fstype);\n\n            me = xmalloc (sizeof *me);\n\n            me->me_devname = xstrdup (source);\n            me->me_mountdir = xstrdup (target);\n            me->me_mntroot = xstrdup (mntroot);\n            me->me_type = xstrdup (fstype);\n            me->me_type_malloced = 1;\n            me->me_dev = makedev (devmaj, devmin);\n             \n            me->me_dummy = ME_DUMMY (me->me_devname, me->me_type, false);\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n\n             \n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        free (line);\n\n        if (ferror (fp))\n          {\n            int saved_errno = errno;\n            fclose (fp);\n            errno = saved_errno;\n            goto free_then_fail;\n          }\n\n        if (fclose (fp) == EOF)\n          goto free_then_fail;\n      }\n    else  \n# endif  \n      {\n        struct mntent *mnt;\n        char const *table = MOUNTED;\n\n        fp = setmntent (table, \"r\");\n        if (fp == NULL)\n          return NULL;\n\n        while ((mnt = getmntent (fp)))\n          {\n            bool bind = hasmntopt (mnt, \"bind\");\n\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (mnt->mnt_fsname);\n            me->me_mountdir = xstrdup (mnt->mnt_dir);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (mnt->mnt_type);\n            me->me_type_malloced = 1;\n            me->me_dummy = ME_DUMMY (me->me_devname, me->me_type, bind);\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = dev_from_mount_options (mnt->mnt_opts);\n\n             \n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        if (endmntent (fp) == 0)\n          goto free_then_fail;\n      }\n  }\n#endif  \n\n#ifdef MOUNTED_GETMNTINFO        \n  {\n    struct statfs *fsp;\n    int entries;\n\n    entries = getmntinfo (&fsp, MNT_NOWAIT);\n    if (entries < 0)\n      return NULL;\n    for (; entries-- > 0; fsp++)\n      {\n        char *fs_type = fsp_to_string (fsp);\n\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (fsp->f_mntfromname);\n        me->me_mountdir = xstrdup (fsp->f_mntonname);\n        me->me_mntroot = NULL;\n        me->me_type = fs_type;\n        me->me_type_malloced = 0;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;         \n\n         \n        *mtail = me;\n        mtail = &me->me_next;\n      }\n  }\n#endif  \n\n#ifdef MOUNTED_GETMNTINFO2       \n  {\n    struct statvfs *fsp;\n    int entries;\n\n    entries = getmntinfo (&fsp, MNT_NOWAIT);\n    if (entries < 0)\n      return NULL;\n    for (; entries-- > 0; fsp++)\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (fsp->f_mntfromname);\n        me->me_mountdir = xstrdup (fsp->f_mntonname);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (fsp->f_fstypename);\n        me->me_type_malloced = 1;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;         \n\n         \n        *mtail = me;\n        mtail = &me->me_next;\n      }\n  }\n#endif  \n\n#if defined MOUNTED_FS_STAT_DEV  \n  {\n     \n\n    DIR *dirp;\n    struct rootdir_entry\n      {\n        char *name;\n        dev_t dev;\n        ino_t ino;\n        struct rootdir_entry *next;\n      };\n    struct rootdir_entry *rootdir_list;\n    struct rootdir_entry **rootdir_tail;\n    int32 pos;\n    dev_t dev;\n    fs_info fi;\n\n     \n    rootdir_list = NULL;\n    rootdir_tail = &rootdir_list;\n    dirp = opendir (\"/\");\n    if (dirp)\n      {\n        struct dirent *d;\n\n        while ((d = readdir (dirp)) != NULL)\n          {\n            char *name;\n            struct stat statbuf;\n\n            if (strcmp (d->d_name, \"..\") == 0)\n              continue;\n\n            if (strcmp (d->d_name, \".\") == 0)\n              name = xstrdup (\"/\");\n            else\n              {\n                name = xmalloc (1 + strlen (d->d_name) + 1);\n                name[0] = '/';\n                strcpy (name + 1, d->d_name);\n              }\n\n            if (lstat (name, &statbuf) >= 0 && S_ISDIR (statbuf.st_mode))\n              {\n                struct rootdir_entry *re = xmalloc (sizeof *re);\n                re->name = name;\n                re->dev = statbuf.st_dev;\n                re->ino = statbuf.st_ino;\n\n                 \n                *rootdir_tail = re;\n                rootdir_tail = &re->next;\n              }\n            else\n              free (name);\n          }\n        closedir (dirp);\n      }\n    *rootdir_tail = NULL;\n\n    for (pos = 0; (dev = next_dev (&pos)) >= 0; )\n      if (fs_stat_dev (dev, &fi) >= 0)\n        {\n           \n          struct rootdir_entry *re;\n\n          for (re = rootdir_list; re; re = re->next)\n            if (re->dev == fi.dev && re->ino == fi.root)\n              break;\n\n          me = xmalloc (sizeof *me);\n          me->me_devname = xstrdup (fi.device_name[0] != '\\0'\n                                    ? fi.device_name : fi.fsh_name);\n          me->me_mountdir = xstrdup (re != NULL ? re->name : fi.fsh_name);\n          me->me_mntroot = NULL;\n          me->me_type = xstrdup (fi.fsh_name);\n          me->me_type_malloced = 1;\n          me->me_dev = fi.dev;\n          me->me_dummy = 0;\n          me->me_remote = (fi.flags & B_FS_IS_SHARED) != 0;\n\n           \n          *mtail = me;\n          mtail = &me->me_next;\n        }\n    *mtail = NULL;\n\n    while (rootdir_list != NULL)\n      {\n        struct rootdir_entry *re = rootdir_list;\n        rootdir_list = re->next;\n        free (re->name);\n        free (re);\n      }\n  }\n#endif  \n\n#if defined MOUNTED_GETFSSTAT    \n  {\n    int numsys, counter;\n    size_t bufsize;\n    struct statfs *stats;\n\n    numsys = getfsstat (NULL, 0L, MNT_NOWAIT);\n    if (numsys < 0)\n      return NULL;\n    if (SIZE_MAX / sizeof *stats <= numsys)\n      xalloc_die ();\n\n    bufsize = (1 + numsys) * sizeof *stats;\n    stats = xmalloc (bufsize);\n    numsys = getfsstat (stats, bufsize, MNT_NOWAIT);\n\n    if (numsys < 0)\n      {\n        free (stats);\n        return NULL;\n      }\n\n    for (counter = 0; counter < numsys; counter++)\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (stats[counter].f_mntfromname);\n        me->me_mountdir = xstrdup (stats[counter].f_mntonname);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (FS_TYPE (stats[counter]));\n        me->me_type_malloced = 1;\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n        me->me_dev = (dev_t) -1;         \n\n         \n        *mtail = me;\n        mtail = &me->me_next;\n      }\n\n    free (stats);\n  }\n#endif  \n\n#if defined MOUNTED_FREAD_FSTYP  \n  {\n    struct mnttab mnt;\n    char *table = \"/etc/mnttab\";\n    FILE *fp;\n\n    fp = fopen (table, \"re\");\n    if (fp == NULL)\n      return NULL;\n\n    while (fread (&mnt, sizeof mnt, 1, fp) > 0)\n      {\n        me = xmalloc (sizeof *me);\n        me->me_devname = xstrdup (mnt.mt_dev);\n        me->me_mountdir = xstrdup (mnt.mt_filsys);\n        me->me_mntroot = NULL;\n        me->me_dev = (dev_t) -1;         \n        me->me_type = \"\";\n        me->me_type_malloced = 0;\n        if (need_fs_type)\n          {\n            struct statfs fsd;\n            char typebuf[FSTYPSZ];\n\n            if (statfs (me->me_mountdir, &fsd, sizeof fsd, 0) != -1\n                && sysfs (GETFSTYP, fsd.f_fstyp, typebuf) != -1)\n              {\n                me->me_type = xstrdup (typebuf);\n                me->me_type_malloced = 1;\n              }\n          }\n        me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n        me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n\n         \n        *mtail = me;\n        mtail = &me->me_next;\n      }\n\n    if (ferror (fp))\n      {\n         \n        int saved_errno = errno;\n        fclose (fp);\n        errno = saved_errno;\n        goto free_then_fail;\n      }\n\n    if (fclose (fp) == EOF)\n      goto free_then_fail;\n  }\n#endif  \n\n#ifdef MOUNTED_GETEXTMNTENT      \n  {\n    struct extmnttab mnt;\n    const char *table = MNTTAB;\n    FILE *fp;\n    int ret;\n\n     \n\n    errno = 0;\n    fp = fopen (table, \"re\");\n    if (fp == NULL)\n      ret = errno;\n    else\n      {\n        while ((ret = getextmntent (fp, &mnt, 1)) == 0)\n          {\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (mnt.mnt_special);\n            me->me_mountdir = xstrdup (mnt.mnt_mountp);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (mnt.mnt_fstype);\n            me->me_type_malloced = 1;\n            me->me_dummy = MNT_IGNORE (&mnt) != 0;\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = makedev (mnt.mnt_major, mnt.mnt_minor);\n\n             \n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        ret = fclose (fp) == EOF ? errno : 0 < ret ? 0 : -1;\n         \n      }\n\n    if (0 <= ret)\n      {\n        errno = ret;\n        goto free_then_fail;\n      }\n  }\n#endif  \n\n#ifdef MOUNTED_GETMNTENT2        \n  {\n    struct mnttab mnt;\n    const char *table = MNTTAB;\n    FILE *fp;\n    int ret;\n    int lockfd = -1;\n\n# if defined F_RDLCK && defined F_SETLKW\n     \n#  ifndef MNTTAB_LOCK\n#   define MNTTAB_LOCK \"/etc/.mnttab.lock\"\n#  endif\n    lockfd = open (MNTTAB_LOCK, O_RDONLY | O_CLOEXEC);\n    if (0 <= lockfd)\n      {\n        struct flock flock;\n        flock.l_type = F_RDLCK;\n        flock.l_whence = SEEK_SET;\n        flock.l_start = 0;\n        flock.l_len = 0;\n        while (fcntl (lockfd, F_SETLKW, &flock) == -1)\n          if (errno != EINTR)\n            {\n              int saved_errno = errno;\n              close (lockfd);\n              errno = saved_errno;\n              return NULL;\n            }\n      }\n    else if (errno != ENOENT)\n      return NULL;\n# endif\n\n    errno = 0;\n    fp = fopen (table, \"re\");\n    if (fp == NULL)\n      ret = errno;\n    else\n      {\n        while ((ret = getmntent (fp, &mnt)) == 0)\n          {\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (mnt.mnt_special);\n            me->me_mountdir = xstrdup (mnt.mnt_mountp);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (mnt.mnt_fstype);\n            me->me_type_malloced = 1;\n            me->me_dummy = MNT_IGNORE (&mnt) != 0;\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = dev_from_mount_options (mnt.mnt_mntopts);\n\n             \n            *mtail = me;\n            mtail = &me->me_next;\n          }\n\n        ret = fclose (fp) == EOF ? errno : 0 < ret ? 0 : -1;\n         \n      }\n\n    if (0 <= lockfd && close (lockfd) != 0)\n      ret = errno;\n\n    if (0 <= ret)\n      {\n        errno = ret;\n        goto free_then_fail;\n      }\n  }\n#endif  \n\n#ifdef MOUNTED_VMOUNT            \n  {\n    int bufsize;\n    void *entries;\n    char *thisent;\n    struct vmount *vmp;\n    int n_entries;\n    int i;\n\n     \n    entries = &bufsize;\n    if (mntctl (MCTL_QUERY, sizeof bufsize, entries) != 0)\n      return NULL;\n    entries = xmalloc (bufsize);\n\n     \n    n_entries = mntctl (MCTL_QUERY, bufsize, entries);\n    if (n_entries < 0)\n      {\n        free (entries);\n        return NULL;\n      }\n\n    for (i = 0, thisent = entries;\n         i < n_entries;\n         i++, thisent += vmp->vmt_length)\n      {\n        char *options, *ignore;\n\n        vmp = (struct vmount *) thisent;\n        me = xmalloc (sizeof *me);\n        if (vmp->vmt_flags & MNT_REMOTE)\n          {\n            char *host, *dir;\n\n            me->me_remote = 1;\n             \n            host = thisent + vmp->vmt_data[VMT_HOSTNAME].vmt_off;\n            dir = thisent + vmp->vmt_data[VMT_OBJECT].vmt_off;\n            me->me_devname = xmalloc (strlen (host) + strlen (dir) + 2);\n            strcpy (me->me_devname, host);\n            strcat (me->me_devname, \":\");\n            strcat (me->me_devname, dir);\n          }\n        else\n          {\n            me->me_remote = 0;\n            me->me_devname = xstrdup (thisent +\n                                      vmp->vmt_data[VMT_OBJECT].vmt_off);\n          }\n        me->me_mountdir = xstrdup (thisent + vmp->vmt_data[VMT_STUB].vmt_off);\n        me->me_mntroot = NULL;\n        me->me_type = xstrdup (fstype_to_string (vmp->vmt_gfstype));\n        me->me_type_malloced = 1;\n        options = thisent + vmp->vmt_data[VMT_ARGS].vmt_off;\n        ignore = strstr (options, \"ignore\");\n        me->me_dummy = (ignore\n                        && (ignore == options || ignore[-1] == ',')\n                        && (ignore[sizeof \"ignore\" - 1] == ','\n                            || ignore[sizeof \"ignore\" - 1] == '\\0'));\n        me->me_dev = (dev_t) -1;  \n\n         \n        *mtail = me;\n        mtail = &me->me_next;\n      }\n    free (entries);\n  }\n#endif  \n\n#ifdef MOUNTED_INTERIX_STATVFS   \n  {\n    DIR *dirp = opendir (\"/dev/fs\");\n    char node[9 + NAME_MAX];\n\n    if (!dirp)\n      goto free_then_fail;\n\n    while (1)\n      {\n        struct statvfs dev;\n        struct dirent entry;\n        struct dirent *result;\n\n         \n        if (readdir_r (dirp, &entry, &result) || result == NULL)\n          break;\n\n        strcpy (node, \"/dev/fs/\");\n        strcat (node, entry.d_name);\n\n        if (statvfs (node, &dev) == 0)\n          {\n            me = xmalloc (sizeof *me);\n            me->me_devname = xstrdup (dev.f_mntfromname);\n            me->me_mountdir = xstrdup (dev.f_mntonname);\n            me->me_mntroot = NULL;\n            me->me_type = xstrdup (dev.f_fstypename);\n            me->me_type_malloced = 1;\n            me->me_dummy = ME_DUMMY (me->me_devname, me->me_type);\n            me->me_remote = ME_REMOTE (me->me_devname, me->me_type);\n            me->me_dev = (dev_t) -1;         \n\n             \n            *mtail = me;\n            mtail = &me->me_next;\n          }\n      }\n    closedir (dirp);\n  }\n#endif  \n\n  *mtail = NULL;\n  return mount_list;\n\n\n free_then_fail: _GL_UNUSED_LABEL;\n  {\n    int saved_errno = errno;\n    *mtail = NULL;\n\n    while (mount_list)\n      {\n        me = mount_list->me_next;\n        free_mount_entry (mount_list);\n        mount_list = me;\n      }\n\n    errno = saved_errno;\n    return NULL;\n  }\n}\n\n \n\nvoid\nfree_mount_entry (struct mount_entry *me)\n{\n  free (me->me_devname);\n  free (me->me_mountdir);\n  free (me->me_mntroot);\n  if (me->me_type_malloced)\n    free (me->me_type);\n  free (me);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}