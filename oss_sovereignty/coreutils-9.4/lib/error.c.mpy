{
  "module_name": "error.c",
  "hash_id": "99d7445e1b2ded19ea6f42aff4e1fc08a4412ae5777bc32ffa4a0c10d31d7edf",
  "original_prompt": "Ingested from coreutils-9.4/lib/error.c",
  "human_readable_source": " \n\n#if !_LIBC\n# include <config.h>\n# define _GL_NO_INLINE_ERROR\n#endif\n\n#include \"error.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if !_LIBC && ENABLE_NLS\n# include \"gettext.h\"\n# define _(msgid) gettext (msgid)\n#endif\n\n#ifdef _LIBC\n# include <libintl.h>\n# include <stdbool.h>\n# include <stdint.h>\n# include <wchar.h>\n# define mbsrtowcs __mbsrtowcs\n# define USE_UNLOCKED_IO 0\n# define _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD(a, b)\n# define _GL_ARG_NONNULL(a)\n#endif\n\n#if USE_UNLOCKED_IO\n# include \"unlocked-io.h\"\n#endif\n\n#ifndef _\n# define _(String) String\n#endif\n\n \nvoid (*error_print_progname) (void);\n\n \nunsigned int error_message_count;\n\n#ifdef _LIBC\n \n\n# define program_name program_invocation_name\n# include <errno.h>\n# include <limits.h>\n# include <libio/libioP.h>\n\n \nextern void __error (int status, int errnum, const char *message, ...)\n     __attribute__ ((__format__ (__printf__, 3, 4)));\nextern void __error_at_line (int status, int errnum, const char *file_name,\n                             unsigned int line_number, const char *message,\n                             ...)\n     __attribute__ ((__format__ (__printf__, 5, 6)));\n# define error __error\n# define error_at_line __error_at_line\n\n# include <libio/iolibio.h>\n# define fflush(s) _IO_fflush (s)\n# undef putc\n# define putc(c, fp) _IO_putc (c, fp)\n\n# include <bits/libc-lock.h>\n\n#else  \n\n# include <fcntl.h>\n# include <unistd.h>\n\n# if defined _WIN32 && ! defined __CYGWIN__\n \n#  define WIN32_LEAN_AND_MEAN\n#  include <windows.h>\n \n#  if GNULIB_MSVC_NOTHROW\n#   include \"msvc-nothrow.h\"\n#  else\n#   include <io.h>\n#  endif\n# endif\n\n \n# undef fcntl\n\n# if !(GNULIB_STRERROR_R_POSIX || HAVE_DECL_STRERROR_R)\n#  ifndef HAVE_DECL_STRERROR_R\n\"this configure-time declaration test was not run\"\n#  endif\n#  if STRERROR_R_CHAR_P\nchar *strerror_r (int errnum, char *buf, size_t buflen);\n#  else\nint strerror_r (int errnum, char *buf, size_t buflen);\n#  endif\n# endif\n\n# define program_name getprogname ()\n\n# if GNULIB_STRERROR_R_POSIX || HAVE_STRERROR_R || defined strerror_r\n#  define __strerror_r strerror_r\n# endif  \n#endif   \n\n#if !_LIBC\n \nstatic int\nis_open (int fd)\n{\n# if defined _WIN32 && ! defined __CYGWIN__\n   \n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}\n#endif\n\nstatic void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n   \n  stdout_fd = STDOUT_FILENO;\n# else\n   \n  stdout_fd = fileno (stdout);\n# endif\n   \n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}\n\nstatic void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if _LIBC || GNULIB_STRERROR_R_POSIX || defined HAVE_STRERROR_R\n  char errbuf[1024];\n# if _LIBC || (!GNULIB_STRERROR_R_POSIX && STRERROR_R_CHAR_P)\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}\n\nstatic void _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (3, 0) _GL_ARG_NONNULL ((3))\nerror_tail (int status, int errnum, const char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n               \n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n           \n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}\n\n\n \nvoid\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n   \n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}\n\f\n \nint error_one_per_line;\n\nvoid\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n         \n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n   \n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n  va_end (args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}\n\n#ifdef _LIBC\n \n# undef error\n# undef error_at_line\nweak_alias (__error, error)\nweak_alias (__error_at_line, error_at_line)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}