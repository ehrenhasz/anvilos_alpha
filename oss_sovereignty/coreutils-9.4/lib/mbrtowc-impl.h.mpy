{
  "module_name": "mbrtowc-impl.h",
  "hash_id": "c64b81e14471c3e37aa2710aa7e685878b746b4a97b4c0564458bfd62eac779a",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbrtowc-impl.h",
  "human_readable_source": " \n\n \n\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n   \n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n    enc_t enc;\n    int res;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        FALLTHROUGH;\n      case 2:\n        buf[1] = pstate[2];\n        FALLTHROUGH;\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n     \n\n    enc = locale_encoding_classification ();\n\n    if (enc == enc_utf8)  \n      {\n         \n#include \"mbrtowc-impl-utf8.h\"\n      }\n    else\n      {\n         \n        wchar_t wc;\n        res = mbtowc_with_lock (&wc, p, m);\n\n        if (res >= 0)\n          {\n            if ((wc == 0) != (res == 0))\n              abort ();\n            if (pwc != NULL)\n              *pwc = wc;\n            goto success;\n          }\n\n         \n        if (m >= 4 || m >= MB_CUR_MAX)\n          goto invalid;\n         \n        switch (enc)\n          {\n           \n\n          case enc_eucjp:  \n            {\n              if (m == 1)\n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                    goto incomplete;\n                }\n              if (m == 2)\n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if (c == 0x8f)\n                    {\n                      unsigned char c2 = (unsigned char) p[1];\n\n                      if (c2 >= 0xa1 && c2 < 0xff)\n                        goto incomplete;\n                    }\n                }\n              goto invalid;\n            }\n\n          case enc_94:  \n            {\n              if (m == 1)\n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if (c >= 0xa1 && c < 0xff)\n                    goto incomplete;\n                }\n              goto invalid;\n            }\n\n          case enc_euctw:  \n            {\n              if (m == 1)\n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                    goto incomplete;\n                }\n              else  \n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if (c == 0x8e)\n                    goto incomplete;\n                }\n              goto invalid;\n            }\n\n          case enc_gb18030:  \n            {\n              if (m == 1)\n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                    goto incomplete;\n                }\n              else  \n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if (c >= 0x90 && c <= 0xe3)\n                    {\n                      unsigned char c2 = (unsigned char) p[1];\n\n                      if (c2 >= 0x30 && c2 <= 0x39)\n                        {\n                          if (m == 2)\n                            goto incomplete;\n                          else  \n                            {\n                              unsigned char c3 = (unsigned char) p[2];\n\n                              if (c3 >= 0x81 && c3 <= 0xfe)\n                                goto incomplete;\n                            }\n                        }\n                    }\n                }\n              goto invalid;\n            }\n\n          case enc_sjis:  \n            {\n              if (m == 1)\n                {\n                  unsigned char c = (unsigned char) p[0];\n\n                  if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                      || (c >= 0xf0 && c <= 0xf9))\n                    goto incomplete;\n                }\n              goto invalid;\n            }\n\n          default:\n             \n            goto incomplete;\n          }\n      }\n\n   success:\n     \n    if (nstate >= (res > 0 ? res : 1))\n      abort ();\n    res -= nstate;\n    pstate[0] = 0;\n    return res;\n\n   incomplete:\n    {\n      size_t k = nstate;\n       \n      pstate[++k] = s[0];\n      if (k < m)\n        {\n          pstate[++k] = s[1];\n          if (k < m)\n            pstate[++k] = s[2];\n        }\n      if (k != m)\n        abort ();\n    }\n    pstate[0] = m;\n    return (size_t)(-2);\n\n   invalid:\n    errno = EILSEQ;\n     \n    return (size_t)(-1);\n  }\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}