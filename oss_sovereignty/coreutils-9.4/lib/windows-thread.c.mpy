{
  "module_name": "windows-thread.c",
  "hash_id": "fecb41fb810167d7658c8de8c62fef979a67c25c1d291d44c6a6f4d6599728bb",
  "original_prompt": "Ingested from coreutils-9.4/lib/windows-thread.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"windows-thread.h\"\n\n#include <errno.h>\n#include <process.h>\n#include <stdlib.h>\n\n#include \"windows-once.h\"\n#include \"windows-tls.h\"\n\n \nstatic DWORD self_key = (DWORD)-1;\n\n \nstatic void\ndo_init_self_key (void)\n{\n  self_key = TlsAlloc ();\n   \n  if (self_key == (DWORD)-1)\n    abort ();\n}\n\n \nstatic void\ninit_self_key (void)\n{\n  static glwthread_once_t once = GLWTHREAD_ONCE_INIT;\n  glwthread_once (&once, do_init_self_key);\n}\n\n \nstruct glwthread_thread_struct\n{\n   \n  HANDLE volatile handle;\n  CRITICAL_SECTION handle_lock;\n   \n  BOOL volatile detached;\n  void * volatile result;\n   \n  void * (*func) (void *);\n  void *arg;\n};\n\n \nstatic HANDLE\nget_current_thread_handle (void)\n{\n  HANDLE this_handle;\n\n   \n  if (!DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),\n                        GetCurrentProcess (), &this_handle,\n                        0, FALSE, DUPLICATE_SAME_ACCESS))\n    abort ();\n  return this_handle;\n}\n\nglwthread_thread_t\nglwthread_thread_self (void)\n{\n  glwthread_thread_t thread;\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  thread = TlsGetValue (self_key);\n  if (thread == NULL)\n    {\n       \n      for (;;)\n        {\n          thread =\n            (struct glwthread_thread_struct *)\n            malloc (sizeof (struct glwthread_thread_struct));\n          if (thread != NULL)\n            break;\n           \n          Sleep (1);\n        }\n\n      thread->handle = get_current_thread_handle ();\n      InitializeCriticalSection (&thread->handle_lock);\n      thread->detached = FALSE;  \n      thread->result = NULL;  \n      TlsSetValue (self_key, thread);\n    }\n  return thread;\n}\n\n \nstatic unsigned int WINAPI\nwrapper_func (void *varg)\n{\n  struct glwthread_thread_struct *thread =\n    (struct glwthread_thread_struct *) varg;\n\n  EnterCriticalSection (&thread->handle_lock);\n   \n  if (thread->handle == NULL)\n    thread->handle = get_current_thread_handle ();\n  LeaveCriticalSection (&thread->handle_lock);\n\n  if (self_key == (DWORD)-1)\n    init_self_key ();\n  TlsSetValue (self_key, thread);\n\n   \n  thread->result = thread->func (thread->arg);\n\n   \n  glwthread_tls_process_destructors ();\n\n  if (thread->detached)\n    {\n       \n      DeleteCriticalSection (&thread->handle_lock);\n      CloseHandle (thread->handle);\n      free (thread);\n    }\n\n  return 0;\n}\n\nint\nglwthread_thread_create (glwthread_thread_t *threadp, unsigned int attr,\n                         void * (*func) (void *), void *arg)\n{\n  struct glwthread_thread_struct *thread =\n    (struct glwthread_thread_struct *)\n    malloc (sizeof (struct glwthread_thread_struct));\n  if (thread == NULL)\n    return ENOMEM;\n  thread->handle = NULL;\n  InitializeCriticalSection (&thread->handle_lock);\n  thread->detached = (attr & GLWTHREAD_ATTR_DETACHED ? TRUE : FALSE);\n  thread->result = NULL;  \n  thread->func = func;\n  thread->arg = arg;\n\n  {\n    unsigned int thread_id;\n    HANDLE thread_handle;\n\n    thread_handle = (HANDLE)\n      _beginthreadex (NULL, 100000, wrapper_func, thread, 0, &thread_id);\n       \n    if (thread_handle == NULL)\n      {\n        DeleteCriticalSection (&thread->handle_lock);\n        free (thread);\n        return EAGAIN;\n      }\n\n    EnterCriticalSection (&thread->handle_lock);\n    if (thread->handle == NULL)\n      thread->handle = thread_handle;\n    else\n       \n      CloseHandle (thread_handle);\n    LeaveCriticalSection (&thread->handle_lock);\n\n    *threadp = thread;\n    return 0;\n  }\n}\n\nint\nglwthread_thread_join (glwthread_thread_t thread, void **retvalp)\n{\n  if (thread == NULL)\n    return EINVAL;\n\n  if (thread == glwthread_thread_self ())\n    return EDEADLK;\n\n  if (thread->detached)\n    return EINVAL;\n\n  if (WaitForSingleObject (thread->handle, INFINITE) == WAIT_FAILED)\n    return EINVAL;\n\n  if (retvalp != NULL)\n    *retvalp = thread->result;\n\n  DeleteCriticalSection (&thread->handle_lock);\n  CloseHandle (thread->handle);\n  free (thread);\n\n  return 0;\n}\n\nint\nglwthread_thread_detach (glwthread_thread_t thread)\n{\n  if (thread == NULL)\n    return EINVAL;\n\n  if (thread->detached)\n    return EINVAL;\n\n  thread->detached = TRUE;\n  return 0;\n}\n\nvoid\nglwthread_thread_exit (void *retval)\n{\n  glwthread_thread_t thread = glwthread_thread_self ();\n  thread->result = retval;\n  glwthread_tls_process_destructors ();\n  _endthreadex (0);  \n  abort ();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}