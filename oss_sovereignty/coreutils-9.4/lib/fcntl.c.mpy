{
  "module_name": "fcntl.c",
  "hash_id": "c77a0e4cbbb65828bf31b6be9b57263ae0d115ef77a7d7f80a9220835b4ef6e0",
  "original_prompt": "Ingested from coreutils-9.4/lib/fcntl.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <fcntl.h>\n\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#ifdef __KLIBC__\n# define INCL_DOS\n# include <os2.h>\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n\n \n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n\n \n# define OPEN_MAX_MAX 0x10000\n\n \nstatic int\ndupfd (int oldfd, int newfd, int flags)\n{\n   \n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = _setmode (oldfd, O_BINARY)) == -1)\n    {\n       \n      errno = EBADF;\n      return -1;\n    }\n  _setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,            \n                            old_handle,              \n                            curr_process,            \n                            (PHANDLE) &new_handle,   \n                            (DWORD) 0,               \n                            inherit,                 \n                            DUPLICATE_SAME_ACCESS))  \n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n       \n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n             \n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n   \n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}\n#endif  \n\n \n \nstatic int rpl_fcntl_DUPFD (int fd, int target);\n \nstatic int rpl_fcntl_DUPFD_CLOEXEC (int fd, int target);\n#ifdef __KLIBC__\n \nstatic int klibc_fcntl (int fd, int action,  ...);\n#endif\n\n\n \n\nint\nfcntl (int fd, int action,  ...)\n#undef fcntl\n#ifdef __KLIBC__\n# define fcntl klibc_fcntl\n#endif\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = rpl_fcntl_DUPFD (fd, target);\n        break;\n      }\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n        result = rpl_fcntl_DUPFD_CLOEXEC (fd, target);\n        break;\n      }\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if defined _WIN32 && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else  \n         \n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif  \n        break;\n      }  \n#endif  \n\n       \n\n    default:\n      {\n#if HAVE_FCNTL\n        switch (action)\n          {\n          #ifdef F_BARRIERFSYNC                   \n          case F_BARRIERFSYNC:\n          #endif\n          #ifdef F_CHKCLEAN                       \n          case F_CHKCLEAN:\n          #endif\n          #ifdef F_CLOSEM                         \n          case F_CLOSEM:\n          #endif\n          #ifdef F_FLUSH_DATA                     \n          case F_FLUSH_DATA:\n          #endif\n          #ifdef F_FREEZE_FS                      \n          case F_FREEZE_FS:\n          #endif\n          #ifdef F_FULLFSYNC                      \n          case F_FULLFSYNC:\n          #endif\n          #ifdef F_GETCONFINED                    \n          case F_GETCONFINED:\n          #endif\n          #ifdef F_GETDEFAULTPROTLEVEL            \n          case F_GETDEFAULTPROTLEVEL:\n          #endif\n          #ifdef F_GETFD                          \n          case F_GETFD:\n          #endif\n          #ifdef F_GETFL                          \n          case F_GETFL:\n          #endif\n          #ifdef F_GETLEASE                       \n          case F_GETLEASE:\n          #endif\n          #ifdef F_GETNOSIGPIPE                   \n          case F_GETNOSIGPIPE:\n          #endif\n          #ifdef F_GETOWN                         \n          case F_GETOWN:\n          #endif\n          #ifdef F_GETPIPE_SZ                     \n          case F_GETPIPE_SZ:\n          #endif\n          #ifdef F_GETPROTECTIONCLASS             \n          case F_GETPROTECTIONCLASS:\n          #endif\n          #ifdef F_GETPROTECTIONLEVEL             \n          case F_GETPROTECTIONLEVEL:\n          #endif\n          #ifdef F_GET_SEALS                      \n          case F_GET_SEALS:\n          #endif\n          #ifdef F_GETSIG                         \n          case F_GETSIG:\n          #endif\n          #ifdef F_MAXFD                          \n          case F_MAXFD:\n          #endif\n          #ifdef F_RECYCLE                        \n          case F_RECYCLE:\n          #endif\n          #ifdef F_SETFIFOENH                     \n          case F_SETFIFOENH:\n          #endif\n          #ifdef F_THAW_FS                        \n          case F_THAW_FS:\n          #endif\n             \n            result = fcntl (fd, action);\n            break;\n\n          #ifdef F_ADD_SEALS                      \n          case F_ADD_SEALS:\n          #endif\n          #ifdef F_BADFD                          \n          case F_BADFD:\n          #endif\n          #ifdef F_CHECK_OPENEVT                  \n          case F_CHECK_OPENEVT:\n          #endif\n          #ifdef F_DUP2FD                         \n          case F_DUP2FD:\n          #endif\n          #ifdef F_DUP2FD_CLOEXEC                 \n          case F_DUP2FD_CLOEXEC:\n          #endif\n          #ifdef F_DUP2FD_CLOFORK                 \n          case F_DUP2FD_CLOFORK:\n          #endif\n          #ifdef F_DUPFD                          \n          case F_DUPFD:\n          #endif\n          #ifdef F_DUPFD_CLOEXEC                  \n          case F_DUPFD_CLOEXEC:\n          #endif\n          #ifdef F_DUPFD_CLOFORK                  \n          case F_DUPFD_CLOFORK:\n          #endif\n          #ifdef F_GETXFL                         \n          case F_GETXFL:\n          #endif\n          #ifdef F_GLOBAL_NOCACHE                 \n          case F_GLOBAL_NOCACHE:\n          #endif\n          #ifdef F_MAKECOMPRESSED                 \n          case F_MAKECOMPRESSED:\n          #endif\n          #ifdef F_MOVEDATAEXTENTS                \n          case F_MOVEDATAEXTENTS:\n          #endif\n          #ifdef F_NOCACHE                        \n          case F_NOCACHE:\n          #endif\n          #ifdef F_NODIRECT                       \n          case F_NODIRECT:\n          #endif\n          #ifdef F_NOTIFY                         \n          case F_NOTIFY:\n          #endif\n          #ifdef F_OPLKACK                        \n          case F_OPLKACK:\n          #endif\n          #ifdef F_OPLKREG                        \n          case F_OPLKREG:\n          #endif\n          #ifdef F_RDAHEAD                        \n          case F_RDAHEAD:\n          #endif\n          #ifdef F_SETBACKINGSTORE                \n          case F_SETBACKINGSTORE:\n          #endif\n          #ifdef F_SETCONFINED                    \n          case F_SETCONFINED:\n          #endif\n          #ifdef F_SETFD                          \n          case F_SETFD:\n          #endif\n          #ifdef F_SETFL                          \n          case F_SETFL:\n          #endif\n          #ifdef F_SETLEASE                       \n          case F_SETLEASE:\n          #endif\n          #ifdef F_SETNOSIGPIPE                   \n          case F_SETNOSIGPIPE:\n          #endif\n          #ifdef F_SETOWN                         \n          case F_SETOWN:\n          #endif\n          #ifdef F_SETPIPE_SZ                     \n          case F_SETPIPE_SZ:\n          #endif\n          #ifdef F_SETPROTECTIONCLASS             \n          case F_SETPROTECTIONCLASS:\n          #endif\n          #ifdef F_SETSIG                         \n          case F_SETSIG:\n          #endif\n          #ifdef F_SINGLE_WRITER                  \n          case F_SINGLE_WRITER:\n          #endif\n             \n            {\n              int x = va_arg (arg, int);\n              result = fcntl (fd, action, x);\n            }\n            break;\n\n          default:\n             \n            {\n              void *p = va_arg (arg, void *);\n              result = fcntl (fd, action, p);\n            }\n            break;\n          }\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}\n\nstatic int\nrpl_fcntl_DUPFD (int fd, int target)\n{\n  int result;\n#if !HAVE_FCNTL\n  result = dupfd (fd, target, 0);\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n   \n  if (target < 0 || getdtablesize () <= target)\n    {\n      result = -1;\n      errno = EINVAL;\n    }\n  else\n    {\n       \n      int flags = fcntl (fd, F_GETFD);\n      if (flags < 0)\n        result = -1;\n      else\n        {\n          result = fcntl (fd, F_DUPFD, target);\n          if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n            {\n              int saved_errno = errno;\n              close (result);\n              result = -1;\n              errno = saved_errno;\n            }\n# if REPLACE_FCHDIR\n          if (0 <= result)\n            result = _gl_register_dup (fd, result);\n# endif\n        }\n    }\n#else\n  result = fcntl (fd, F_DUPFD, target);\n#endif\n  return result;\n}\n\nstatic int\nrpl_fcntl_DUPFD_CLOEXEC (int fd, int target)\n{\n  int result;\n#if !HAVE_FCNTL\n  result = dupfd (fd, target, O_CLOEXEC);\n#else  \n# if defined __NetBSD__ || defined __HAIKU__\n   \n   \n#  define have_dupfd_cloexec -1\n# else\n   \n  static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n  if (0 <= have_dupfd_cloexec)\n    {\n      result = fcntl (fd, F_DUPFD_CLOEXEC, target);\n      if (0 <= result || errno != EINVAL)\n        {\n          have_dupfd_cloexec = 1;\n#  if REPLACE_FCHDIR\n          if (0 <= result)\n            result = _gl_register_dup (fd, result);\n#  endif\n        }\n      else\n        {\n          result = rpl_fcntl_DUPFD (fd, target);\n          if (result >= 0)\n            have_dupfd_cloexec = -1;\n        }\n    }\n  else\n# endif\n    result = rpl_fcntl_DUPFD (fd, target);\n  if (0 <= result && have_dupfd_cloexec == -1)\n    {\n      int flags = fcntl (result, F_GETFD);\n      if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n        {\n          int saved_errno = errno;\n          close (result);\n          errno = saved_errno;\n          result = -1;\n        }\n    }\n#endif  \n  return result;\n}\n\n#undef fcntl\n\n#ifdef __KLIBC__\n\nstatic int\nklibc_fcntl (int fd, int action,  ...)\n{\n  va_list arg_ptr;\n  int arg;\n  struct stat sbuf;\n  int result;\n\n  va_start (arg_ptr, action);\n  arg = va_arg (arg_ptr, int);\n  result = fcntl (fd, action, arg);\n   \n  if (result == -1 && (errno == EPERM || errno == ENOTSUP)\n      && !fstat (fd, &sbuf) && S_ISDIR (sbuf.st_mode))\n    {\n      ULONG ulMode;\n\n      switch (action)\n        {\n        case F_DUPFD:\n           \n          while (fcntl (arg, F_GETFL) != -1 || errno != EBADF)\n            arg++;\n\n          result = dup2 (fd, arg);\n          break;\n\n         \n        case F_GETFD:\n          if (DosQueryFHState (fd, &ulMode))\n            break;\n\n          result = (ulMode & OPEN_FLAGS_NOINHERIT) ? FD_CLOEXEC : 0;\n          break;\n\n        case F_SETFD:\n          if (arg & ~FD_CLOEXEC)\n            break;\n\n          if (DosQueryFHState (fd, &ulMode))\n            break;\n\n          if (arg & FD_CLOEXEC)\n            ulMode |= OPEN_FLAGS_NOINHERIT;\n          else\n            ulMode &= ~OPEN_FLAGS_NOINHERIT;\n\n           \n          ulMode &= (OPEN_FLAGS_WRITE_THROUGH | OPEN_FLAGS_FAIL_ON_ERROR\n                     | OPEN_FLAGS_NO_CACHE | OPEN_FLAGS_NOINHERIT);\n\n          if (DosSetFHState (fd, ulMode))\n            break;\n\n          result = 0;\n          break;\n\n        case F_GETFL:\n          result = 0;\n          break;\n\n        case F_SETFL:\n          if (arg != 0)\n            break;\n\n          result = 0;\n          break;\n\n        default:\n          errno = EINVAL;\n          break;\n        }\n    }\n\n  va_end (arg_ptr);\n\n  return result;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}