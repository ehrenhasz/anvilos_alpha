{
  "module_name": "set-permissions.c",
  "hash_id": "bfc39a98fd1a9f791fb34985bb40e58d330845e91e00cad15aee09ac4ca0da27",
  "original_prompt": "Ingested from coreutils-9.4/lib/set-permissions.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"acl.h\"\n\n#include \"acl-internal.h\"\n\n#if USE_ACL\n# if ! defined HAVE_ACL_FROM_MODE && defined HAVE_ACL_FROM_TEXT  \n#  if HAVE_ACL_GET_FILE && !HAVE_ACL_TYPE_EXTENDED\n\nstatic acl_t\nacl_from_mode (mode_t mode)\n{\n#  if HAVE_ACL_FREE_TEXT  \n  char acl_text[] = \"u::---,g::---,o::---,\";\n#  else  \n  char acl_text[] = \"u::---,g::---,o::---\";\n#  endif\n\n  if (mode & S_IRUSR) acl_text[ 3] = 'r';\n  if (mode & S_IWUSR) acl_text[ 4] = 'w';\n  if (mode & S_IXUSR) acl_text[ 5] = 'x';\n  if (mode & S_IRGRP) acl_text[10] = 'r';\n  if (mode & S_IWGRP) acl_text[11] = 'w';\n  if (mode & S_IXGRP) acl_text[12] = 'x';\n  if (mode & S_IROTH) acl_text[17] = 'r';\n  if (mode & S_IWOTH) acl_text[18] = 'w';\n  if (mode & S_IXOTH) acl_text[19] = 'x';\n\n  return acl_from_text (acl_text);\n}\n#  endif\n# endif\n\n# if HAVE_FACL && defined GETACL  \nstatic int\nset_acls_from_mode (const char *name, int desc, mode_t mode, bool *must_chmod)\n{\n#  ifdef ACE_GETACL\n   \n\n   \n  int convention;\n\n  {\n     \n    enum\n      {\n        alloc_init = 4000 / sizeof (ace_t),  \n        alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n      };\n    ace_t buf[alloc_init];\n    size_t alloc = alloc_init;\n    ace_t *entries = buf;\n    ace_t *malloced = NULL;\n    int count;\n\n    for (;;)\n      {\n        count = (desc != -1\n                 ? facl (desc, ACE_GETACL, alloc, entries)\n                 : acl (name, ACE_GETACL, alloc, entries));\n        if (count < 0 && errno == ENOSPC)\n          {\n             \n            free (malloced);\n            if (alloc > alloc_max / 2)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            alloc = 2 * alloc;  \n            entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n            if (entries == NULL)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            continue;\n          }\n        break;\n      }\n\n    if (count <= 0)\n      convention = -1;\n    else\n      {\n        int i;\n\n        convention = 0;\n        for (i = 0; i < count; i++)\n          if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n            {\n              convention = 1;\n              break;\n            }\n      }\n    free (malloced);\n  }\n\n  if (convention >= 0)\n    {\n      ace_t entries[6];\n      int count;\n      int ret;\n\n      if (convention)\n        {\n           \n          entries[0].a_type = OLD_ALLOW;\n          entries[0].a_flags = OLD_ACE_OWNER;\n          entries[0].a_who = 0;  \n          entries[0].a_access_mask = (mode >> 6) & 7;\n          entries[1].a_type = OLD_ALLOW;\n          entries[1].a_flags = OLD_ACE_GROUP;\n          entries[1].a_who = 0;  \n          entries[1].a_access_mask = (mode >> 3) & 7;\n          entries[2].a_type = OLD_ALLOW;\n          entries[2].a_flags = OLD_ACE_OTHER;\n          entries[2].a_who = 0;\n          entries[2].a_access_mask = mode & 7;\n          count = 3;\n        }\n      else\n        {\n           \n          entries[0].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[0].a_flags = NEW_ACE_OWNER;\n          entries[0].a_who = 0;  \n          entries[0].a_access_mask = 0;\n          entries[1].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[1].a_flags = NEW_ACE_OWNER;\n          entries[1].a_who = 0;  \n          entries[1].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          if (mode & 0400)\n            entries[1].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0200)\n            entries[1].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0100)\n            entries[1].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[0].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[2].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[2].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[2].a_who = 0;  \n          entries[2].a_access_mask = 0;\n          entries[3].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[3].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[3].a_who = 0;  \n          entries[3].a_access_mask = 0;\n          if (mode & 0040)\n            entries[3].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0020)\n            entries[3].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0010)\n            entries[3].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[2].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[4].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[4].a_flags = NEW_ACE_EVERYONE;\n          entries[4].a_who = 0;\n          entries[4].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          entries[5].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[5].a_flags = NEW_ACE_EVERYONE;\n          entries[5].a_who = 0;\n          entries[5].a_access_mask = NEW_ACE_READ_NAMED_ATTRS\n                                     | NEW_ACE_READ_ATTRIBUTES\n                                     | NEW_ACE_READ_ACL\n                                     | NEW_ACE_SYNCHRONIZE;\n          if (mode & 0004)\n            entries[5].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0002)\n            entries[5].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0001)\n            entries[5].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[4].a_access_mask |= NEW_ACE_EXECUTE;\n          count = 6;\n        }\n      if (desc != -1)\n        ret = facl (desc, ACE_SETACL, count, entries);\n      else\n        ret = acl (name, ACE_SETACL, count, entries);\n      if (ret < 0 && errno != EINVAL && errno != ENOTSUP)\n        {\n          if (errno == ENOSYS)\n            {\n              *must_chmod = true;\n              return 0;\n            }\n          return -1;\n        }\n      if (ret == 0)\n        return 0;\n    }\n#  endif\n\n  {\n    aclent_t entries[3];\n    int ret;\n\n    entries[0].a_type = USER_OBJ;\n    entries[0].a_id = 0;  \n    entries[0].a_perm = (mode >> 6) & 7;\n    entries[1].a_type = GROUP_OBJ;\n    entries[1].a_id = 0;  \n    entries[1].a_perm = (mode >> 3) & 7;\n    entries[2].a_type = OTHER_OBJ;\n    entries[2].a_id = 0;\n    entries[2].a_perm = mode & 7;\n\n    if (desc != -1)\n      ret = facl (desc, SETACL,\n                  sizeof (entries) / sizeof (aclent_t), entries);\n    else\n      ret = acl (name, SETACL,\n                 sizeof (entries) / sizeof (aclent_t), entries);\n    if (ret < 0)\n      {\n        if (errno == ENOSYS || errno == EOPNOTSUPP)\n          {\n            *must_chmod = true;\n            return 0;\n          }\n        return -1;\n      }\n    return 0;\n  }\n}\n\n# elif HAVE_GETACL  \nstatic int\ncontext_acl_from_mode (struct permission_context *ctx, const char *name, int desc)\n{\n  struct stat statbuf;\n  int ret;\n\n  if (desc != -1)\n    ret = fstat (desc, &statbuf);\n  else\n    ret = stat (name, &statbuf);\n  if (ret < 0)\n    return -1;\n\n  ctx->entries[0].uid = statbuf.st_uid;\n  ctx->entries[0].gid = ACL_NSGROUP;\n  ctx->entries[0].mode = (ctx->mode >> 6) & 7;\n  ctx->entries[1].uid = ACL_NSUSER;\n  ctx->entries[1].gid = statbuf.st_gid;\n  ctx->entries[1].mode = (ctx->mode >> 3) & 7;\n  ctx->entries[2].uid = ACL_NSUSER;\n  ctx->entries[2].gid = ACL_NSGROUP;\n  ctx->entries[2].mode = ctx->mode & 7;\n  ctx->count = 3;\n  return 0;\n}\n\n#  if HAVE_ACLV_H  \nstatic int\ncontext_aclv_from_mode (struct permission_context *ctx)\n{\n  int ret;\n\n  ctx->aclv_entries[0].a_type = USER_OBJ;\n  ctx->aclv_entries[0].a_id = 0;  \n  ctx->aclv_entries[0].a_perm = (ctx->mode >> 6) & 7;\n  ctx->aclv_entries[1].a_type = GROUP_OBJ;\n  ctx->aclv_entries[1].a_id = 0;  \n  ctx->aclv_entries[1].a_perm = (ctx->mode >> 3) & 7;\n  ctx->aclv_entries[2].a_type = CLASS_OBJ;\n  ctx->aclv_entries[2].a_id = 0;\n  ctx->aclv_entries[2].a_perm = (ctx->mode >> 3) & 7;\n  ctx->aclv_entries[3].a_type = OTHER_OBJ;\n  ctx->aclv_entries[3].a_id = 0;\n  ctx->aclv_entries[3].a_perm = ctx->mode & 7;\n  ctx->aclv_count = 4;\n\n  ret = aclsort (ctx->aclv_count, 1, ctx->aclv_entries);\n  if (ret > 0)\n    abort ();\n  return ret;\n}\n#  endif\n\n# elif HAVE_ACLX_GET && defined ACL_AIX_WIP  \nstatic int\nset_acls_from_mode (const char *name, int desc, mode_t mode, bool *must_chmod)\n{\n  acl_type_list_t types;\n  size_t types_size = sizeof (types);\n  acl_type_t type;\n\n  if (aclx_gettypes (name, &types, &types_size) < 0\n      || types.num_entries == 0)\n    {\n      *must_chmod = true;\n      return 0;\n    }\n\n   \n  type = types.entries[0];\n  if (type.u64 == ACL_AIXC)\n    {\n      union { struct acl a; char room[128]; } u;\n      int ret;\n\n      u.a.acl_len = (char *) &u.a.acl_ext[0] - (char *) &u.a;  \n      u.a.acl_mode = mode & ~(S_IXACL | 0777);\n      u.a.u_access = (mode >> 6) & 7;\n      u.a.g_access = (mode >> 3) & 7;\n      u.a.o_access = mode & 7;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.acl_len, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.acl_len, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n  else if (type.u64 == ACL_NFS4)\n    {\n      union { nfs4_acl_int_t a; char room[128]; } u;\n      nfs4_ace_int_t *ace;\n      int ret;\n\n      u.a.aclVersion = NFS4_ACL_INT_STRUCT_VERSION;\n      u.a.aclEntryN = 0;\n      ace = &u.a.aclEntry[0];\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_OWNER;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0400 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0200\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0100 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_GROUP;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0040 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0020\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0010 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_EVERYONE;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0004 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0002\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0001 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      u.a.aclLength = (char *) ace - (char *) &u.a;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.aclLength, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.aclLength, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n\n  *must_chmod = true;\n  return 0;\n}\n\n# elif HAVE_STATACL  \nstatic int\ncontext_acl_from_mode (struct permission_context *ctx)\n{\n  ctx->u.a.acl_len = (char *) &ctx->u.a.acl_ext[0] - (char *) &ctx->u.a;  \n  ctx->u.a.acl_mode = ctx->mode & ~(S_IXACL | 0777);\n  ctx->u.a.u_access = (ctx->mode >> 6) & 7;\n  ctx->u.a.g_access = (ctx->mode >> 3) & 7;\n  ctx->u.a.o_access = ctx->mode & 7;\n  ctx->have_u = true;\n  return 0;\n}\n\n# elif HAVE_ACLSORT  \nstatic int\ncontext_acl_from_mode (struct permission_context *ctx)\n{\n  int ret;\n\n  ctx->entries[0].a_type = USER_OBJ;\n  ctx->entries[0].a_id = 0;  \n  ctx->entries[0].a_perm = (ctx->mode >> 6) & 7;\n  ctx->entries[1].a_type = GROUP_OBJ;\n  ctx->entries[1].a_id = 0;  \n  ctx->entries[1].a_perm = (ctx->mode >> 3) & 7;\n  ctx->entries[2].a_type = CLASS_OBJ;\n  ctx->entries[2].a_id = 0;\n  ctx->entries[2].a_perm = (ctx->mode >> 3) & 7;\n  ctx->entries[3].a_type = OTHER_OBJ;\n  ctx->entries[3].a_id = 0;\n  ctx->entries[3].a_perm = ctx->mode & 7;\n  ctx->count = 4;\n\n  ret = aclsort (ctx->count, 1, entries);\n  if (ret > 0)\n    abort ();\n  return ret;\n}\n# endif\n\nstatic int\nset_acls (struct permission_context *ctx, const char *name, int desc,\n          int from_mode, bool *must_chmod, bool *acls_set)\n{\n  int ret = 0;\n\n# if HAVE_ACL_GET_FILE\n   \n   \n#  if !HAVE_ACL_TYPE_EXTENDED\n   \n\n#   ifndef HAVE_ACL_FROM_TEXT\n#    error Must have acl_from_text (see POSIX 1003.1e draft 17).\n#   endif\n#   ifndef HAVE_ACL_DELETE_DEF_FILE\n#    error Must have acl_delete_def_file (see POSIX 1003.1e draft 17).\n#   endif\n\n  if (! ctx->acls_not_supported)\n    {\n      if (ret == 0 && from_mode)\n        {\n          if (ctx->acl)\n            acl_free (ctx->acl);\n          ctx->acl = acl_from_mode (ctx->mode);\n          if (ctx->acl == NULL)\n            ret = -1;\n        }\n\n      if (ret == 0 && ctx->acl)\n        {\n          if (HAVE_ACL_SET_FD && desc != -1)\n            ret = acl_set_fd (desc, ctx->acl);\n          else\n            ret = acl_set_file (name, ACL_TYPE_ACCESS, ctx->acl);\n          if (ret != 0)\n            {\n              if (! acl_errno_valid (errno))\n                {\n                  ctx->acls_not_supported = true;\n                  if (from_mode || acl_access_nontrivial (ctx->acl) == 0)\n                    ret = 0;\n                }\n            }\n          else\n            {\n              *acls_set = true;\n              if (S_ISDIR(ctx->mode))\n                {\n                  if (! from_mode && ctx->default_acl &&\n                      acl_default_nontrivial (ctx->default_acl))\n                    ret = acl_set_file (name, ACL_TYPE_DEFAULT,\n                                        ctx->default_acl);\n                  else\n                    ret = acl_delete_def_file (name);\n                }\n            }\n        }\n    }\n\n#   if HAVE_ACL_TYPE_NFS4   \n\n   \n\n   \n\n#   endif\n\n#  else  \n   \n\n   \n\n  if (ctx->acl == NULL)\n    {\n      acl_t acl;\n\n       \n      if (HAVE_ACL_GET_FD && desc != -1)\n        acl = acl_get_fd (desc);\n      else\n        acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n      if (acl)\n        {\n          acl_free (acl);\n\n          acl = acl_init (0);\n          if (acl)\n            {\n              if (HAVE_ACL_SET_FD && desc != -1)\n                ret = acl_set_fd (desc, acl);\n              else\n                ret = acl_set_file (name, ACL_TYPE_EXTENDED, acl);\n              acl_free (acl);\n            }\n          else\n            ret = -1;\n        }\n    }\n  else\n    {\n      if (HAVE_ACL_SET_FD && desc != -1)\n        ret = acl_set_fd (desc, ctx->acl);\n      else\n        ret = acl_set_file (name, ACL_TYPE_EXTENDED, ctx->acl);\n      if (ret != 0)\n        {\n          if (! acl_errno_valid (errno)\n              && ! acl_extended_nontrivial (ctx->acl))\n            ret = 0;\n        }\n    }\n  *acls_set = true;\n\n#  endif\n\n# elif defined GETACL  \n\n   \n\n   \n\n  if (from_mode)\n    return set_acls_from_mode (name, desc, ctx->mode, must_chmod);\n\n  if (ret == 0 && ctx->count)\n    {\n      if (desc != -1)\n        ret = facl (desc, SETACL, ctx->count, ctx->entries);\n      else\n        ret = acl (name, SETACL, ctx->count, ctx->entries);\n      if (ret < 0)\n        {\n          if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              && acl_nontrivial (ctx->count, ctx->entries) == 0)\n            ret = 0;\n        }\n      else\n        *acls_set = true;\n    }\n\n#  ifdef ACE_GETACL\n  if (ret == 0 && ctx->ace_count)\n    {\n      if (desc != -1)\n        ret = facl (desc, ACE_SETACL, ctx->ace_count, ctx->ace_entries);\n      else\n        ret = acl (name, ACE_SETACL, ctx->ace_count, ctx->ace_entries);\n      if (ret < 0)\n        {\n          if ((errno == ENOSYS || errno == EINVAL || errno == ENOTSUP)\n              && acl_ace_nontrivial (ctx->ace_count, ctx->ace_entries) == 0)\n            ret = 0;\n        }\n      else\n        *acls_set = true;\n    }\n#  endif\n\n# elif HAVE_GETACL  \n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx, name, desc);\n\n  if (ret == 0 && ctx->count > 0)\n    {\n      if (desc != -1)\n        ret = fsetacl (desc, ctx->count, ctx->entries);\n      else\n        ret = setacl (name, ctx->count, ctx->entries);\n      if (ret < 0)\n        {\n          if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n              && (from_mode || !acl_nontrivial (ctx->count, ctx->entries)))\n            ret = 0;\n        }\n      else\n        *acls_set = true;\n    }\n\n#  if HAVE_ACLV_H\n  if (from_mode)\n    ret = context_aclv_from_mode (ctx);\n\n  if (ret == 0 && ctx->aclv_count > 0)\n    {\n      ret = acl ((char *) name, ACL_SET, ctx->aclv_count, ctx->aclv_entries);\n      if (ret < 0)\n        {\n          if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              && (from_mode || !aclv_nontrivial (ctx->aclv_count, ctx->aclv_entries)))\n            ret = 0;\n        }\n      else\n        *acls_set = true;\n    }\n#  endif\n\n# elif HAVE_ACLX_GET && ACL_AIX_WIP  \n\n   \n\n  if (from_mode)\n    ret = set_acls_from_mode (name, desc, mode, must_chmod);\n\n# elif HAVE_STATACL  \n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx);\n\n  if (ret == 0 && ctx->have_u)\n    {\n      if (desc != -1)\n        ret = fchacl (desc, &ctx->u.a, ctx->u.a.acl_len);\n      else\n        ret = chacl ((char *) name, &ctx->u.a, ctx->u.a.acl_len);\n      if (ret < 0)\n        {\n          if (errno == ENOSYS && from_mode)\n            ret = 0;\n        }\n      else\n        *acls_set = true;\n    }\n\n# elif HAVE_ACLSORT  \n\n  if (from_mode)\n    ret = context_acl_from_mode (ctx);\n\n  if (ret == 0 && ctx->count)\n    {\n      ret = acl ((char *) name, ACL_SET, ctx->count, ctx->entries);\n      if (ret != 0)\n        {\n          if (!acl_nontrivial (ctx->count, ctx->entries))\n            ret = 0;\n        }\n      else\n        *acls_set = true;\n    }\n\n# else   \n\n   \n\n# endif\n\n  return ret;\n}\n#endif\n\n \n\nint\nchmod_or_fchmod (const char *name, int desc, mode_t mode)\n{\n  if (HAVE_FCHMOD && desc != -1)\n    return fchmod (desc, mode);\n  else\n    return chmod (name, mode);\n}\n\n \n\nint\nset_permissions (struct permission_context *ctx, const char *name, int desc)\n{\n  _GL_UNUSED bool acls_set = false;\n  bool early_chmod;\n  bool must_chmod = false;\n  int ret = 0;\n\n#if USE_ACL\n# if HAVE_STATACL\n   \n   \n\n  early_chmod = false;\n# else\n   \n   \n\n  early_chmod = (! MODE_INSIDE_ACL || (ctx->mode & (S_ISUID | S_ISGID | S_ISVTX)));\n# endif\n#else\n   \n\n  early_chmod = true;\n#endif\n\n  if (early_chmod)\n    {\n      ret = chmod_or_fchmod (name, desc, ctx->mode);\n      if (ret != 0)\n        return -1;\n    }\n\n#if USE_ACL\n  ret = set_acls (ctx, name, desc, false, &must_chmod, &acls_set);\n  if (! acls_set)\n    {\n      int saved_errno = ret ? errno : 0;\n\n       \n\n      ret = set_acls (ctx, name, desc, true, &must_chmod, &acls_set);\n      if (! acls_set)\n        must_chmod = true;\n\n      if (saved_errno)\n        {\n          errno = saved_errno;\n          ret = -1;\n        }\n    }\n#endif\n\n  if (must_chmod && ! early_chmod)\n    {\n      int saved_errno = ret ? errno : 0;\n\n      ret = chmod_or_fchmod (name, desc, ctx->mode);\n\n      if (saved_errno)\n        {\n          errno = saved_errno;\n          ret = -1;\n        }\n    }\n\n  return ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}