{
  "module_name": "regcomp.c",
  "hash_id": "286ee7c7b859675385003015e043d30250c8a59803659cf4d0e1b1e29e60dd09",
  "original_prompt": "Ingested from coreutils-9.4/lib/regcomp.c",
  "human_readable_source": " \n\nstatic const char __re_error_msgid[] =\n  {\n#define REG_NOERROR_IDX\t0\n    gettext_noop (\"Success\")\t \n    \"\\0\"\n#define REG_NOMATCH_IDX (REG_NOERROR_IDX + sizeof \"Success\")\n    gettext_noop (\"No match\")\t \n    \"\\0\"\n#define REG_BADPAT_IDX\t(REG_NOMATCH_IDX + sizeof \"No match\")\n    gettext_noop (\"Invalid regular expression\")  \n    \"\\0\"\n#define REG_ECOLLATE_IDX (REG_BADPAT_IDX + sizeof \"Invalid regular expression\")\n    gettext_noop (\"Invalid collation character\")  \n    \"\\0\"\n#define REG_ECTYPE_IDX\t(REG_ECOLLATE_IDX + sizeof \"Invalid collation character\")\n    gettext_noop (\"Invalid character class name\")  \n    \"\\0\"\n#define REG_EESCAPE_IDX\t(REG_ECTYPE_IDX + sizeof \"Invalid character class name\")\n    gettext_noop (\"Trailing backslash\")  \n    \"\\0\"\n#define REG_ESUBREG_IDX\t(REG_EESCAPE_IDX + sizeof \"Trailing backslash\")\n    gettext_noop (\"Invalid back reference\")  \n    \"\\0\"\n#define REG_EBRACK_IDX\t(REG_ESUBREG_IDX + sizeof \"Invalid back reference\")\n    gettext_noop (\"Unmatched [, [^, [:, [., or [=\")\t \n    \"\\0\"\n#define REG_EPAREN_IDX\t(REG_EBRACK_IDX + sizeof \"Unmatched [, [^, [:, [., or [=\")\n    gettext_noop (\"Unmatched ( or \\\\(\")  \n    \"\\0\"\n#define REG_EBRACE_IDX\t(REG_EPAREN_IDX + sizeof \"Unmatched ( or \\\\(\")\n    gettext_noop (\"Unmatched \\\\{\")  \n    \"\\0\"\n#define REG_BADBR_IDX\t(REG_EBRACE_IDX + sizeof \"Unmatched \\\\{\")\n    gettext_noop (\"Invalid content of \\\\{\\\\}\")  \n    \"\\0\"\n#define REG_ERANGE_IDX\t(REG_BADBR_IDX + sizeof \"Invalid content of \\\\{\\\\}\")\n    gettext_noop (\"Invalid range end\")\t \n    \"\\0\"\n#define REG_ESPACE_IDX\t(REG_ERANGE_IDX + sizeof \"Invalid range end\")\n    gettext_noop (\"Memory exhausted\")  \n    \"\\0\"\n#define REG_BADRPT_IDX\t(REG_ESPACE_IDX + sizeof \"Memory exhausted\")\n    gettext_noop (\"Invalid preceding regular expression\")  \n    \"\\0\"\n#define REG_EEND_IDX\t(REG_BADRPT_IDX + sizeof \"Invalid preceding regular expression\")\n    gettext_noop (\"Premature end of regular expression\")  \n    \"\\0\"\n#define REG_ESIZE_IDX\t(REG_EEND_IDX + sizeof \"Premature end of regular expression\")\n    gettext_noop (\"Regular expression too big\")  \n    \"\\0\"\n#define REG_ERPAREN_IDX\t(REG_ESIZE_IDX + sizeof \"Regular expression too big\")\n    gettext_noop (\"Unmatched ) or \\\\)\")  \n  };\n\nstatic const size_t __re_error_msgid_idx[] =\n  {\n    REG_NOERROR_IDX,\n    REG_NOMATCH_IDX,\n    REG_BADPAT_IDX,\n    REG_ECOLLATE_IDX,\n    REG_ECTYPE_IDX,\n    REG_EESCAPE_IDX,\n    REG_ESUBREG_IDX,\n    REG_EBRACK_IDX,\n    REG_EPAREN_IDX,\n    REG_EBRACE_IDX,\n    REG_BADBR_IDX,\n    REG_ERANGE_IDX,\n    REG_ESPACE_IDX,\n    REG_BADRPT_IDX,\n    REG_EEND_IDX,\n    REG_ESIZE_IDX,\n    REG_ERPAREN_IDX\n  };\n\f\n \n\n \n\nconst char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n   \n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n   \n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}\nweak_alias (__re_compile_pattern, re_compile_pattern)\n\n \n \nreg_syntax_t re_syntax_options;\n\n\n \n\nreg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}\nweak_alias (__re_set_syntax, re_set_syntax)\n\nint\nre_compile_fastmap (struct re_pattern_buffer *bufp)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}\nweak_alias (__re_compile_fastmap, re_compile_fastmap)\n\nstatic __always_inline void\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}\n\n \n\nstatic void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, __towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n#ifdef _LIBC\n\t   \n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n#endif  \n\n\t   \n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n#ifdef _LIBC\n\t\t  || cset->nequiv_classes\n#endif  \n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t       \n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, __towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else if (type == OP_PERIOD || type == OP_UTF8_PERIOD || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}\n\f\n \n \n\nint\nregcomp (regex_t *__restrict preg, const char *__restrict pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n   \n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (__glibc_unlikely (preg->fastmap == NULL))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n   \n  if (cflags & REG_NEWLINE)\n    {  \n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n       \n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n   \n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n   \n  if (__glibc_likely (ret == REG_NOERROR))\n     \n    (void) re_compile_fastmap (preg);\n  else\n    {\n       \n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}\nlibc_hidden_def (__regcomp)\nweak_alias (__regcomp, regcomp)\n\n \n\nsize_t\nregerror (int errcode, const regex_t *__restrict preg, char *__restrict errbuf,\n\t  size_t errbuf_size)\n{\n  const char *msg;\n  size_t msg_size;\n  int nerrcodes = sizeof __re_error_msgid_idx / sizeof __re_error_msgid_idx[0];\n\n  if (__glibc_unlikely (errcode < 0 || errcode >= nerrcodes))\n     \n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1;  \n\n  if (__glibc_likely (errbuf_size != 0))\n    {\n      size_t cpy_size = msg_size;\n      if (__glibc_unlikely (msg_size > errbuf_size))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}\nweak_alias (__regerror, regerror)\n\n\n \nstatic const bitset_t utf8_sb_map =\n{\n   \n#if (defined __GNUC__ || __clang_major__ >= 4) && !defined __STRICT_ANSI__\n  [0 ... 0x80 / BITSET_WORD_BITS - 1] = BITSET_WORD_MAX\n#else\n# if 4 * BITSET_WORD_BITS < ASCII_CHARS\n#  error \"bitset_word_t is narrower than 32 bits\"\n# elif 3 * BITSET_WORD_BITS < ASCII_CHARS\n  BITSET_WORD_MAX, BITSET_WORD_MAX, BITSET_WORD_MAX,\n# elif 2 * BITSET_WORD_BITS < ASCII_CHARS\n  BITSET_WORD_MAX, BITSET_WORD_MAX,\n# elif 1 * BITSET_WORD_BITS < ASCII_CHARS\n  BITSET_WORD_MAX,\n# endif\n  (BITSET_WORD_MAX\n   >> (SBC_MAX % BITSET_WORD_BITS == 0\n       ? 0\n       : BITSET_WORD_BITS - SBC_MAX % BITSET_WORD_BITS))\n#endif\n};\n\n\nstatic void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}\n\n\n \n\nvoid\nregfree (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  if (__glibc_likely (dfa != NULL))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n    }\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}\nlibc_hidden_def (__regfree)\nweak_alias (__regfree, regfree)\n\f\n \n\n#if defined _REGEX_RE_COMP || defined _LIBC\n\n \nstatic struct re_pattern_buffer re_comp_buf;\n\nchar *\n# ifdef _LIBC\n \nweak_function\n# endif\nre_comp (const char *s)\n{\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = re_malloc (char, SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n   \n\n   \n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n   \n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}\n\n#ifdef _LIBC\nlibc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}\n#endif\n\n#endif  \n\f\n \n\nstatic reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n   \n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n   \n  dfa = preg->buffer;\n  if (__glibc_unlikely (preg->allocated < sizeof (re_dfa_t)))\n    {\n       \n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (__glibc_unlikely (err == REG_NOERROR && lock_init (dfa->lock) != 0))\n    err = REG_ESPACE;\n  if (__glibc_unlikely (err != REG_NOERROR))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n   \n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (__glibc_unlikely (err != REG_NOERROR))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n   \n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (__glibc_unlikely (dfa->str_tree == NULL))\n    goto re_compile_internal_free_return;\n\n   \n  err = analyze (preg);\n  if (__glibc_unlikely (err != REG_NOERROR))\n    goto re_compile_internal_free_return;\n\n   \n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n\n   \n  err = create_initial_state (dfa);\n\n   \n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (__glibc_unlikely (err != REG_NOERROR))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}\n\n \n\nstatic reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n   \n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n   \n  if (__glibc_unlikely (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2\n\t\t\t<= pat_len))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n   \n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n   \n  dfa->map_notascii = 0;\n#endif\n\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (__glibc_unlikely (dfa->sb_char == NULL))\n\t    return REG_ESPACE;\n\n\t   \n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n#ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n#endif\n\t      }\n\t}\n    }\n\n  if (__glibc_unlikely (dfa->nodes == NULL || dfa->state_table == NULL))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}\n\n \n\nstatic void\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (__glibc_likely (dfa->map_notascii == 0))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t   \n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (__glibc_likely (dfa->is_utf8))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}\n\n \n\nstatic void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}\n\n \n\nstatic reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n   \n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (__glibc_unlikely (err != REG_NOERROR))\n    return err;\n\n   \n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n   \n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n   \n  if (__glibc_unlikely (dfa->init_state == NULL))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (__glibc_unlikely (dfa->init_state_word == NULL\n\t\t\t    || dfa->init_state_nl == NULL\n\t\t\t    || dfa->init_state_begbuf == NULL))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}\n\f\n \n\nstatic void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t     \n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t \n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n   \n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}\n\f\n \n\nstatic reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n   \n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (__glibc_unlikely (dfa->nexts == NULL || dfa->org_indices == NULL\n\t\t\t|| dfa->edests == NULL || dfa->eclosures == NULL))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  re_free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (__glibc_unlikely (ret != REG_NOERROR))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (__glibc_unlikely (ret != REG_NOERROR))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (__glibc_unlikely (ret != REG_NOERROR))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (__glibc_unlikely (ret != REG_NOERROR))\n    return ret;\n\n   \n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (__glibc_unlikely (dfa->inveclosures == NULL))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}\n\n \nstatic reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n       \n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (__glibc_unlikely (err != REG_NOERROR))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n       \n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}\n\nstatic reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (__glibc_unlikely (err != REG_NOERROR))\n\treturn err;\n\n       \n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}\n\n \nstatic reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}\n\n \nstatic reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}\n\nstatic bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n       \n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n   \n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (__glibc_unlikely (tree == NULL || tree1 == NULL\n\t\t\t|| op == NULL || cls == NULL))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}\n\n \nstatic reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (__glibc_unlikely (node->node_idx == -1))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}\n\n \nstatic reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}\n\n \nstatic reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      DEBUG_ASSERT (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tDEBUG_ASSERT (left > -1);\n\tDEBUG_ASSERT (right > -1);\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      DEBUG_ASSERT (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}\n\n \n\nstatic reg_errcode_t\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t   \n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (__glibc_unlikely (clone_dest == -1))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (__glibc_unlikely (! ok))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t   \n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t   \n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t   \n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (__glibc_unlikely (! ok))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t   \n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (__glibc_unlikely (clone_dest == -1))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (__glibc_unlikely (! ok))\n\t    return REG_ESPACE;\n\t}\n      else  \n\t{\n\t   \n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t   \n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == -1)\n\t    {\n\t       \n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (__glibc_unlikely (clone_dest == -1))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (__glibc_unlikely (! ok))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (__glibc_unlikely (err != REG_NOERROR))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t       \n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (__glibc_unlikely (! ok))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (__glibc_unlikely (clone_dest == -1))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (__glibc_unlikely (! ok))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}\n\n \n\nstatic Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx;  \n    }\n  return -1;  \n}\n\n \n\nstatic Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (__glibc_likely (dup_idx != -1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n       \n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}\n\nstatic reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (__glibc_unlikely (! ok))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}\n\n \n\nstatic reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n  DEBUG_ASSERT (dfa->nodes_len > 0);\n  incomplete = false;\n   \n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n      DEBUG_ASSERT (dfa->eclosures[node_idx].nelem != -1);\n\n       \n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n       \n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (__glibc_unlikely (err != REG_NOERROR))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}\n\n \n\nstatic reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (__glibc_unlikely (err != REG_NOERROR))\n    return err;\n\n   \n  eclosure.elems[eclosure.nelem++] = node;\n\n   \n  dfa->eclosures[node].nelem = -1;\n\n   \n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (__glibc_unlikely (err != REG_NOERROR))\n\treturn err;\n    }\n\n   \n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t \n\tif (dfa->eclosures[edest].nelem == -1)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t \n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (__glibc_unlikely (err != REG_NOERROR))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t \n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (__glibc_unlikely (err != REG_NOERROR))\n\t  return err;\n\t \n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}\n\f\n \n\n \n\nstatic void\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}\n\n \n\nstatic int\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1\n      && !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE))\n\t  && re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS)\n\t  && re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}\n\n \n\nstatic int\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  if (input->mb_cur_max > 1\n      && !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n       \n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[')  \n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  FALLTHROUGH;\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    case '-':\n       \n      if (! (re_string_cur_idx (input) + 2 < re_string_length (input)\n             && re_string_peek_byte (input, 1) == '-'\n             && re_string_peek_byte (input, 2) == '-'))\n        {\n          token->type = OP_CHARSET_RANGE;\n          break;\n        }\n      re_string_skip_bytes (input, 2);\n      FALLTHROUGH;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}\n\f\n \n\n \n\nstatic bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (__glibc_unlikely (eor == NULL || root == NULL))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}\n\n \n\nstatic bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (__glibc_unlikely (*err != REG_NOERROR && branch == NULL))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}\n\n \n\nstatic bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (__glibc_unlikely (*err != REG_NOERROR && expr == NULL))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n       \n    }\n  return tree;\n}\n\n \n\nstatic bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (__glibc_unlikely (mbc_remain == NULL || tree == NULL))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n      break;\n\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n\treturn NULL;\n      break;\n\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n\treturn NULL;\n      break;\n\n    case OP_BACK_REF:\n      if (!__glibc_likely (dfa->completed_bkref_map & (1 << token->opr.idx)))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      FALLTHROUGH;\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      FALLTHROUGH;\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP)\n\t  && !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      FALLTHROUGH;\n    case OP_CLOSE_DUP_NUM:\n       \n\n       \n      token->type = CHARACTER;\n       \n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (__glibc_unlikely (tree_first == NULL || tree_last == NULL\n\t\t\t\t|| tree == NULL))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (__glibc_unlikely (tree == NULL))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n       \n      fetch_token (token, regexp, syntax);\n      return tree;\n\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (__glibc_unlikely (tree == NULL))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n\treturn NULL;\n      break;\n\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (__glibc_unlikely (*err != REG_NOERROR && tree == NULL))\n\treturn NULL;\n      break;\n\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n\n    default:\n       \n      DEBUG_ASSERT (false);\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (__glibc_unlikely (*err != REG_NOERROR && dup_tree == NULL))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n       \n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}\n\n \n\nstatic bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n   \n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (__glibc_unlikely (*err == REG_NOERROR\n\t\t\t    && token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (__glibc_unlikely (*err != REG_NOERROR))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (__glibc_unlikely (tree == NULL))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}\n\n \n\nstatic bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == -1)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0;  \n\t  else\n\t    {\n\t      *err = REG_BADBR;  \n\t      return NULL;\n\t    }\n\t}\n      if (__glibc_likely (start != -2))\n\t{\n\t   \n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : -2));\n\t}\n      if (__glibc_unlikely (start == -2 || end == -2))\n\t{\n\t   \n\t  if (__glibc_unlikely (!(syntax & RE_INVALID_INTERVAL_ORD)))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t   \n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t   \n\t  return elem;\n\t}\n\n      if (__glibc_unlikely ((end != -1 && start > end)\n\t\t\t    || token->type != OP_CLOSE_DUP_NUM))\n\t{\n\t   \n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (__glibc_unlikely (RE_DUP_MAX < (end == -1 ? start : end)))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : -1;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (__glibc_unlikely (elem == NULL))\n    return NULL;\n  if (__glibc_unlikely (start == 0 && end == 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n   \n  if (__glibc_unlikely (start > 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (__glibc_unlikely (elem == NULL || tree == NULL))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n       \n      elem = duplicate_tree (elem, dfa);\n      if (__glibc_unlikely (elem == NULL))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == -1 ? OP_DUP_ASTERISK : OP_ALT));\n  if (__glibc_unlikely (tree == NULL))\n    goto parse_dup_op_espace;\n\n   \n  if (TYPE_SIGNED (Idx) || end != -1)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (__glibc_unlikely (elem == NULL || tree == NULL))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (__glibc_unlikely (tree == NULL))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}\n\n \n#define BRACKET_NAME_BUF_SIZE 32\n\n#ifndef _LIBC\n\n \nstatic wint_t\nparse_byte (unsigned char b, re_dfa_t const *dfa)\n{\n  return dfa->mb_cur_max > 1 ? __btowc (b) : b;\n}\n\n \n\nstatic reg_errcode_t\nbuild_range_exp (bitset_t sbcset, re_charset_t *mbcset, Idx *range_alloc,\n\t\t bracket_elem_t *start_elem, bracket_elem_t *end_elem,\n\t\t re_dfa_t *dfa, reg_syntax_t syntax, uint_fast32_t nrules,\n\t\t const unsigned char *collseqmb, const char *collseqwc,\n\t\t int_fast32_t table_size, const void *symb_table,\n\t\t const unsigned char *extra)\n{\n   \n  if (__glibc_unlikely (start_elem->type == EQUIV_CLASS\n\t\t\t|| start_elem->type == CHAR_CLASS\n\t\t\t|| end_elem->type == EQUIV_CLASS\n\t\t\t|| end_elem->type == CHAR_CLASS))\n    return REG_ERANGE;\n\n   \n  if (__glibc_unlikely ((start_elem->type == COLL_SYM\n\t\t\t && strlen ((char *) start_elem->opr.name) > 1)\n\t\t\t|| (end_elem->type == COLL_SYM\n\t\t\t    && strlen ((char *) end_elem->opr.name) > 1)))\n    return REG_ECOLLATE;\n\n  unsigned int\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0)),\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n  wint_t\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? parse_byte (start_ch, dfa) : start_elem->opr.wch),\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? parse_byte (end_ch, dfa) : end_elem->opr.wch);\n\n  if (start_wc == WEOF || end_wc == WEOF)\n    return REG_ECOLLATE;\n  else if (__glibc_unlikely ((syntax & RE_NO_EMPTY_RANGES)\n                             && start_wc > end_wc))\n    return REG_ERANGE;\n\n   \n  if (dfa->mb_cur_max > 1)\n    {\n       \n      if (__glibc_unlikely (*range_alloc == mbcset->nranges))\n        {\n           \n          wchar_t *new_array_start, *new_array_end;\n          Idx new_nranges;\n\n           \n          new_nranges = 2 * mbcset->nranges + 1;\n           \n          new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n                                        new_nranges);\n          new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n                                      new_nranges);\n\n          if (__glibc_unlikely (new_array_start == NULL\n                                || new_array_end == NULL))\n            {\n              re_free (new_array_start);\n              re_free (new_array_end);\n              return REG_ESPACE;\n            }\n\n          mbcset->range_starts = new_array_start;\n          mbcset->range_ends = new_array_end;\n          *range_alloc = new_nranges;\n        }\n\n      mbcset->range_starts[mbcset->nranges] = start_wc;\n      mbcset->range_ends[mbcset->nranges++] = end_wc;\n    }\n\n   \n  for (wchar_t wc = 0; wc < SBC_MAX; ++wc)\n    {\n      if (start_wc <= wc && wc <= end_wc)\n        bitset_set (sbcset, wc);\n    }\n\n  return REG_NOERROR;\n}\n#endif  \n\n#ifndef _LIBC\n \n\nstatic reg_errcode_t\nbuild_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\tIdx *coll_sym_alloc, const unsigned char *name,\n\t\t\tuint_fast32_t nrules, int_fast32_t table_size,\n\t\t\tconst void *symb_table, const unsigned char *extra)\n{\n  size_t name_len = strlen ((const char *) name);\n  if (__glibc_unlikely (name_len != 1))\n    return REG_ECOLLATE;\n  else\n    {\n      bitset_set (sbcset, name[0]);\n      return REG_NOERROR;\n    }\n}\n#endif  \n\n#ifdef _LIBC\n \n\nstatic __always_inline int32_t\nseek_collating_symbol_entry (const unsigned char *name, size_t name_len,\n\t\t\t     const int32_t *symb_table,\n\t\t\t     int_fast32_t table_size,\n\t\t\t     const unsigned char *extra)\n{\n  int_fast32_t elem;\n\n  for (elem = 0; elem < table_size; elem++)\n    if (symb_table[2 * elem] != 0)\n      {\n\tint32_t idx = symb_table[2 * elem + 1];\n\t \n\tidx += 1 + extra[idx];\n\tif ( \n\t    name_len == extra[idx]\n\t     \n\t    && memcmp (name, &extra[idx + 1], name_len) == 0)\n\t   \n\t  return elem;\n      }\n  return -1;\n}\n\n \n\nstatic __always_inline unsigned int\nlookup_collation_sequence_value (bracket_elem_t *br_elem, uint32_t nrules,\n\t\t\t\t const unsigned char *collseqmb,\n\t\t\t\t const char *collseqwc,\n\t\t\t\t int_fast32_t table_size,\n\t\t\t\t const int32_t *symb_table,\n\t\t\t\t const unsigned char *extra)\n{\n  if (br_elem->type == SB_CHAR)\n    {\n       \n      if (nrules == 0)\n\treturn collseqmb[br_elem->opr.ch];\n      else\n\t{\n\t  wint_t wc = __btowc (br_elem->opr.ch);\n\t  return __collseq_table_lookup (collseqwc, wc);\n\t}\n    }\n  else if (br_elem->type == MB_CHAR)\n    {\n      if (nrules != 0)\n\treturn __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n    }\n  else if (br_elem->type == COLL_SYM)\n    {\n      size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n      if (nrules != 0)\n\t{\n\t  int32_t elem, idx;\n\t  elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t      sym_name_len,\n\t\t\t\t\t      symb_table, table_size,\n\t\t\t\t\t      extra);\n\t  if (elem != -1)\n\t    {\n\t       \n\t      idx = symb_table[2 * elem + 1];\n\t       \n\t      idx += 1 + extra[idx];\n\t       \n\t      idx += 1 + extra[idx];\n\t       \n\t      idx = (idx + 3) & ~3;\n\t       \n\t      idx += sizeof (unsigned int);\n\t       \n\t      idx += sizeof (unsigned int) *\n\t\t(1 + *(unsigned int *) (extra + idx));\n\t       \n\t      return *(unsigned int *) (extra + idx);\n\t    }\n\t  else if (sym_name_len == 1)\n\t    {\n\t       \n\t      return collseqmb[br_elem->opr.name[0]];\n\t    }\n\t}\n      else if (sym_name_len == 1)\n\treturn collseqmb[br_elem->opr.name[0]];\n    }\n  return UINT_MAX;\n}\n\n \n\nstatic __always_inline reg_errcode_t\nbuild_range_exp (bitset_t sbcset, re_charset_t *mbcset, Idx *range_alloc,\n\t\t bracket_elem_t *start_elem, bracket_elem_t *end_elem,\n\t\t re_dfa_t *dfa, reg_syntax_t syntax, uint32_t nrules,\n\t\t const unsigned char *collseqmb, const char *collseqwc,\n\t\t int_fast32_t table_size, const int32_t *symb_table,\n\t\t const unsigned char *extra)\n{\n  unsigned int ch;\n  uint32_t start_collseq;\n  uint32_t end_collseq;\n\n   \n  if (__glibc_unlikely (start_elem->type == EQUIV_CLASS\n                        || start_elem->type == CHAR_CLASS\n                        || end_elem->type == EQUIV_CLASS\n                        || end_elem->type == CHAR_CLASS))\n    return REG_ERANGE;\n\n   \n  start_collseq = lookup_collation_sequence_value (start_elem, nrules, collseqmb, collseqwc,\n\t\t\t\t\t\t   table_size, symb_table, extra);\n  end_collseq = lookup_collation_sequence_value (end_elem, nrules, collseqmb, collseqwc,\n\t\t\t\t\t\t table_size, symb_table, extra);\n   \n  if (__glibc_unlikely (start_collseq == UINT_MAX\n                        || end_collseq == UINT_MAX))\n    return REG_ECOLLATE;\n  if (__glibc_unlikely ((syntax & RE_NO_EMPTY_RANGES)\n                        && start_collseq > end_collseq))\n    return REG_ERANGE;\n\n   \n  if (nrules > 0 || dfa->mb_cur_max > 1)\n    {\n       \n      if (__glibc_unlikely (*range_alloc == mbcset->nranges))\n\t{\n\t   \n\t  uint32_t *new_array_start;\n\t  uint32_t *new_array_end;\n\t  int new_nranges;\n\n\t   \n\t  new_nranges = 2 * mbcset->nranges + 1;\n\t  new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\tnew_nranges);\n\t  new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t      new_nranges);\n\n          if (__glibc_unlikely (new_array_start == NULL\n                                || new_array_end == NULL))\n\t    return REG_ESPACE;\n\n\t  mbcset->range_starts = new_array_start;\n\t  mbcset->range_ends = new_array_end;\n\t  *range_alloc = new_nranges;\n\t}\n\n      mbcset->range_starts[mbcset->nranges] = start_collseq;\n      mbcset->range_ends[mbcset->nranges++] = end_collseq;\n    }\n\n   \n  for (ch = 0; ch < SBC_MAX; ch++)\n    {\n      uint32_t ch_collseq;\n       \n      if (nrules == 0)\n\tch_collseq = collseqmb[ch];\n      else\n\tch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n      if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\tbitset_set (sbcset, ch);\n    }\n  return REG_NOERROR;\n}\n\n \n\nstatic __always_inline reg_errcode_t\nbuild_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\tIdx *coll_sym_alloc, const unsigned char *name,\n\t\t\tuint_fast32_t nrules, int_fast32_t table_size,\n\t\t\tconst int32_t *symb_table, const unsigned char *extra)\n{\n  int32_t elem, idx;\n  size_t name_len = strlen ((const char *) name);\n  if (nrules != 0)\n    {\n      elem = seek_collating_symbol_entry (name, name_len, symb_table,\n\t\t\t\t\t  table_size, extra);\n      if (elem != -1)\n\t{\n\t   \n\t  idx = symb_table[2 * elem + 1];\n\t   \n\t  idx += 1 + extra[idx];\n\t}\n      else if (name_len == 1)\n\t{\n\t   \n\t  bitset_set (sbcset, name[0]);\n\t  return REG_NOERROR;\n\t}\n      else\n\treturn REG_ECOLLATE;\n\n       \n       \n      if (__glibc_unlikely (*coll_sym_alloc == mbcset->ncoll_syms))\n\t{\n\t   \n\t   \n\t  int new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t   \n\t  int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t       new_coll_sym_alloc);\n          if (__glibc_unlikely (new_coll_syms == NULL))\n\t    return REG_ESPACE;\n\t  mbcset->coll_syms = new_coll_syms;\n\t  *coll_sym_alloc = new_coll_sym_alloc;\n\t}\n      mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n      return REG_NOERROR;\n    }\n  else\n    {\n      if (__glibc_unlikely (name_len != 1))\n\treturn REG_ECOLLATE;\n      else\n\t{\n\t  bitset_set (sbcset, name[0]);\n\t  return REG_NOERROR;\n\t}\n    }\n}\n#endif  \n\n \n\nstatic bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n  const unsigned char *collseqmb = NULL;\n  const char *collseqwc = NULL;\n  uint_fast32_t nrules = 0;\n  int_fast32_t table_size = 0;\n  const void *symb_table = NULL;\n  const unsigned char *extra = NULL;\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n       \n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n  if (__glibc_unlikely (sbcset == NULL || mbcset == NULL))\n    {\n      re_free (sbcset);\n      re_free (mbcset);\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (__glibc_unlikely (token->type == END_OF_RE))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n      mbcset->non_match = 1;\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len);  \n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (__glibc_unlikely (token->type == END_OF_RE))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n   \n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      start_elem.type = COLL_SYM;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (__glibc_unlikely (ret != REG_NOERROR))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n       \n      token_len = peek_token_bracket (token, regexp, syntax);\n\n       \n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (__glibc_unlikely (token->type == END_OF_RE))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len);  \n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (__glibc_unlikely (token2.type == END_OF_RE))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t   \n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  end_elem.type = COLL_SYM;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (__glibc_unlikely (ret != REG_NOERROR))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem,\n\t\t\t\t  dfa, syntax, nrules, collseqmb, collseqwc,\n\t\t\t\t  table_size, symb_table, extra);\n\t  if (__glibc_unlikely (*err != REG_NOERROR))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n\t    case MB_CHAR:\n\t       \n\t      if (__glibc_unlikely (mbchar_alloc == mbcset->nmbchars))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t   \n\t\t   \n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t   \n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (__glibc_unlikely (new_mbchars == NULL))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (__glibc_unlikely (*err != REG_NOERROR))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n\t\t\t\t\t     start_elem.opr.name,\n\t\t\t\t\t     nrules, table_size, symb_table, extra);\n\t      if (__glibc_unlikely (*err != REG_NOERROR))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n\t\t\t\t      mbcset, &char_class_alloc,\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (__glibc_unlikely (*err != REG_NOERROR))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      DEBUG_ASSERT (false);\n\t      break;\n\t    }\n\t}\n      if (__glibc_unlikely (token->type == END_OF_RE))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len);  \n\n   \n  if (non_match)\n    bitset_not (sbcset);\n\n   \n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n       \n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (__glibc_unlikely (mbc_tree == NULL))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n       \n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t   \n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (__glibc_unlikely (work_tree == NULL))\n\t    goto parse_bracket_exp_espace;\n\n\t   \n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (__glibc_unlikely (work_tree == NULL))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n    {\n      free_charset (mbcset);\n       \n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (__glibc_unlikely (work_tree == NULL))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n  free_charset (mbcset);\n  return NULL;\n}\n\n \n\nstatic reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n  re_string_skip_bytes (regexp, token_len);  \n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (__glibc_unlikely (token->type == OP_CHARSET_RANGE) && !accept_hyphen)\n    {\n       \n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t \n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}\n\n \n\nstatic reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}\n\n   \n\nstatic reg_errcode_t\nbuild_equiv_class (bitset_t sbcset, re_charset_t *mbcset,\n\t\t   Idx *equiv_class_alloc, const unsigned char *name)\n{\n#ifdef _LIBC\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules != 0)\n    {\n      const int32_t *table, *indirect;\n      const unsigned char *weights, *extra, *cp;\n      unsigned char char_buf[2];\n      int32_t idx1, idx2;\n      unsigned int ch;\n      size_t len;\n       \n      cp = name;\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      weights = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t       _NL_COLLATE_WEIGHTMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      idx1 = findidx (table, indirect, extra, &cp, -1);\n      if (__glibc_unlikely (idx1 == 0 || *cp != '\\0'))\n\t \n\treturn REG_ECOLLATE;\n\n       \n      len = weights[idx1 & 0xffffff];\n      for (ch = 0; ch < SBC_MAX; ++ch)\n\t{\n\t  char_buf[0] = ch;\n\t  cp = char_buf;\n\t  idx2 = findidx (table, indirect, extra, &cp, 1);\n \n\t  if (idx2 == 0)\n\t     \n\t    continue;\n\t   \n\t  if (len == weights[idx2 & 0xffffff] && (idx1 >> 24) == (idx2 >> 24)\n\t      && memcmp (weights + (idx1 & 0xffffff) + 1,\n\t\t\t weights + (idx2 & 0xffffff) + 1, len) == 0)\n\t    bitset_set (sbcset, ch);\n\t}\n       \n      if (__glibc_unlikely (*equiv_class_alloc == mbcset->nequiv_classes))\n\t{\n\t   \n\t   \n\t  Idx new_equiv_class_alloc = 2 * mbcset->nequiv_classes + 1;\n\t   \n\t  int32_t *new_equiv_classes = re_realloc (mbcset->equiv_classes,\n\t\t\t\t\t\t   int32_t,\n\t\t\t\t\t\t   new_equiv_class_alloc);\n\t  if (__glibc_unlikely (new_equiv_classes == NULL))\n\t    return REG_ESPACE;\n\t  mbcset->equiv_classes = new_equiv_classes;\n\t  *equiv_class_alloc = new_equiv_class_alloc;\n\t}\n      mbcset->equiv_classes[mbcset->nequiv_classes++] = idx1;\n    }\n  else\n#endif  \n    {\n      if (__glibc_unlikely (strlen ((const char *) name) != 1))\n\treturn REG_ECOLLATE;\n      bitset_set (sbcset, *name);\n    }\n  return REG_NOERROR;\n}\n\n   \n\nstatic reg_errcode_t\nbuild_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,\n\t\t re_charset_t *mbcset, Idx *char_class_alloc,\n\t\t const char *class_name, reg_syntax_t syntax)\n{\n  int i;\n  const char *name = class_name;\n\n   \n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n   \n  if (__glibc_unlikely (*char_class_alloc == mbcset->nchar_classes))\n    {\n       \n       \n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n       \n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (__glibc_unlikely (new_char_classes == NULL))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (__glibc_unlikely (trans != NULL))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}\n\nstatic bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n  reg_errcode_t ret;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n  if (__glibc_unlikely (sbcset == NULL))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n  if (__glibc_unlikely (mbcset == NULL))\n    {\n      re_free (sbcset);\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  mbcset->non_match = non_match;\n\n   \n  ret = build_charclass (trans, sbcset, mbcset, &alloc, class_name, 0);\n\n  if (__glibc_unlikely (ret != REG_NOERROR))\n    {\n      re_free (sbcset);\n      free_charset (mbcset);\n      *err = ret;\n      return NULL;\n    }\n   \n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n   \n  if (non_match)\n    bitset_not (sbcset);\n\n   \n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n   \n  re_token_t br_token = { .type = SIMPLE_BRACKET, .opr.sbcset = sbcset };\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (__glibc_unlikely (tree == NULL))\n    goto build_word_op_espace;\n\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n       \n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (__glibc_unlikely (mbc_tree == NULL))\n\tgoto build_word_op_espace;\n       \n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (__glibc_likely (mbc_tree != NULL))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n\n build_word_op_espace:\n  re_free (sbcset);\n  free_charset (mbcset);\n  *err = REG_ESPACE;\n  return NULL;\n}\n\n \n\nstatic Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = -1;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (__glibc_unlikely (token->type == END_OF_RE))\n\treturn -2;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2)\n\t     ? -2\n\t     : num == -1\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}\n\f\nstatic void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n#ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n#endif\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n  re_free (cset->char_classes);\n  re_free (cset);\n}\n\f\n \n\n \n\nstatic bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t = { .type = type };\n  return create_token_tree (dfa, left, right, &t);\n}\n\nstatic bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (__glibc_unlikely (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = -1;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}\n\n \n\nstatic reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}\n\n \n\nstatic void\nfree_token (re_token_t *node)\n{\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n    re_free (node->opr.sbcset);\n}\n\n \n\nstatic reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}\n\n\n \n\nstatic bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n       \n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n       \n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}