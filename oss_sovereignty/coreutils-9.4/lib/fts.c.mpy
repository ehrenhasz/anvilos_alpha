{
  "module_name": "fts.c",
  "hash_id": "855b3792929203f55bea56ec3c4d51a371d68ad087ec001957260b0785777732",
  "original_prompt": "Ingested from coreutils-9.4/lib/fts.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#if defined LIBC_SCCS && !defined GCC_LINT && !defined lint\nstatic char sccsid[] = \"@(#)fts.c       8.6 (Berkeley) 8/14/94\";\n#endif\n\n#include \"fts_.h\"\n\n#if HAVE_SYS_PARAM_H || defined _LIBC\n# include <sys/param.h>\n#endif\n#ifdef _LIBC\n# include <include/sys/stat.h>\n#else\n# include <sys/stat.h>\n#endif\n#include <fcntl.h>\n#include <errno.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#if ! _LIBC\n# include \"attribute.h\"\n# include \"fcntl--.h\"\n# include \"flexmember.h\"\n# include \"openat.h\"\n# include \"opendirat.h\"\n# include \"same-inode.h\"\n#endif\n\n#include <dirent.h>\n#ifndef _D_EXACT_NAMLEN\n# define _D_EXACT_NAMLEN(dirent) strlen ((dirent)->d_name)\n#endif\n\n#if HAVE_STRUCT_DIRENT_D_TYPE\n \n# define DT_IS_KNOWN(d) ((d)->d_type != DT_UNKNOWN)\n \n# define DT_MUST_BE(d, t) ((d)->d_type == (t))\n# define D_TYPE(d) ((d)->d_type)\n#else\n# define DT_IS_KNOWN(d) false\n# define DT_MUST_BE(d, t) false\n# define D_TYPE(d) DT_UNKNOWN\n\n# undef DT_UNKNOWN\n# define DT_UNKNOWN 0\n\n \n# undef DT_BLK\n# undef DT_CHR\n# undef DT_DIR\n# undef DT_FIFO\n# undef DT_LNK\n# undef DT_REG\n# undef DT_SOCK\n# define DT_BLK 1\n# define DT_CHR 2\n# define DT_DIR 3\n# define DT_FIFO 4\n# define DT_LNK 5\n# define DT_REG 6\n# define DT_SOCK 7\n#endif\n\n#ifndef S_IFBLK\n# define S_IFBLK 0\n#endif\n#ifndef S_IFLNK\n# define S_IFLNK 0\n#endif\n#ifndef S_IFSOCK\n# define S_IFSOCK 0\n#endif\n\nenum\n{\n  NOT_AN_INODE_NUMBER = 0\n};\n\n#ifdef D_INO_IN_DIRENT\n# define D_INO(dp) (dp)->d_ino\n#else\n \n# define D_INO(dp) NOT_AN_INODE_NUMBER\n#endif\n\n \n#ifndef FTS_MAX_READDIR_ENTRIES\n# define FTS_MAX_READDIR_ENTRIES 100000\n#endif\n\n \n#ifndef FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD\n# define FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD 10000\n#endif\n\nenum\n{\n  _FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD = FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD\n};\n\nenum Fts_stat\n{\n  FTS_NO_STAT_REQUIRED = 1,\n  FTS_STAT_REQUIRED = 2\n};\n\n#ifdef _LIBC\n# undef close\n# define close __close\n# undef closedir\n# define closedir __closedir\n# undef fchdir\n# define fchdir __fchdir\n# undef open\n# define open __open\n# undef readdir\n# define readdir __readdir\n#else\n# undef internal_function\n# define internal_function  \n#endif\n\n#ifndef __set_errno\n# define __set_errno(Val) errno = (Val)\n#endif\n\n \n#ifdef HAVE_OPENAT\n# define HAVE_OPENAT_SUPPORT 1\n#else\n# define HAVE_OPENAT_SUPPORT 0\n#endif\n\n#ifdef NDEBUG\n# define fts_assert(expr) ((void) (0 && (expr)))\n#else\n# define fts_assert(expr)       \\\n    do                          \\\n      {                         \\\n        if (!(expr))            \\\n          abort ();             \\\n      }                         \\\n    while (false)\n#endif\n\n#ifdef _LIBC\n# if __glibc_has_attribute (__fallthrough__)\n#  define FALLTHROUGH __attribute__ ((__fallthrough__))\n# else\n#  define FALLTHROUGH ((void) 0)\n# endif\n#endif\n\nstatic FTSENT   *fts_alloc (FTS *, const char *, size_t) internal_function;\nstatic FTSENT   *fts_build (FTS *, int) internal_function;\nstatic void      fts_lfree (FTSENT *) internal_function;\nstatic void      fts_load (FTS *, FTSENT *) internal_function;\nstatic size_t    fts_maxarglen (char * const *) internal_function;\nstatic void      fts_padjust (FTS *, FTSENT *) internal_function;\nstatic bool      fts_palloc (FTS *, size_t) internal_function;\nstatic FTSENT   *fts_sort (FTS *, FTSENT *, size_t) internal_function;\nstatic unsigned short int fts_stat (FTS *, FTSENT *, bool) internal_function;\nstatic int      fts_safe_changedir (FTS *, FTSENT *, int, const char *)\n     internal_function;\n\n#include \"fts-cycle.c\"\n\n#ifndef MAX\n# define MAX(a,b) ((a) > (b) ? (a) : (b))\n#endif\n\n#ifndef SIZE_MAX\n# define SIZE_MAX ((size_t) -1)\n#endif\n\n#define ISDOT(a)        (a[0] == '.' && (!a[1] || (a[1] == '.' && !a[2])))\n#define STREQ(a, b)     (strcmp (a, b) == 0)\n\n#define CLR(opt)        (sp->fts_options &= ~(opt))\n#define ISSET(opt)      ((sp->fts_options & (opt)) != 0)\n#define SET(opt)        (sp->fts_options |= (opt))\n\n \n#define FCHDIR(sp, fd)                                  \\\n  (!ISSET(FTS_NOCHDIR) && (ISSET(FTS_CWDFD)             \\\n                           ? (cwd_advance_fd ((sp), (fd), true), 0) \\\n                           : fchdir (fd)))\n\n\n \n \n#define BCHILD          1                \n#define BNAMES          2                \n#define BREAD           3                \n\n#if GNULIB_FTS_DEBUG\n# include <inttypes.h>\n# include <stdio.h>\nbool fts_debug = false;\n# define Dprintf(x) do { if (fts_debug) printf x; } while (false)\nstatic void fd_ring_check (FTS const *);\nstatic void fd_ring_print (FTS const *, FILE *, char const *);\n#else\n# define Dprintf(x)\n# define fd_ring_check(x)\n# define fd_ring_print(a, b, c)\n#endif\n\n#define LEAVE_DIR(Fts, Ent, Tag)                                \\\n  do                                                            \\\n    {                                                           \\\n      Dprintf ((\"  %s-leaving: %s\\n\", Tag, (Ent)->fts_path));   \\\n      leave_dir (Fts, Ent);                                     \\\n      fd_ring_check (Fts);                                      \\\n    }                                                           \\\n  while (false)\n\nstatic void\nfd_ring_clear (I_ring *fd_ring)\n{\n  while ( ! i_ring_empty (fd_ring))\n    {\n      int fd = i_ring_pop (fd_ring);\n      if (0 <= fd)\n        close (fd);\n    }\n}\n\n \nstatic void\nfts_set_stat_required (FTSENT *p, bool required)\n{\n  fts_assert (p->fts_info == FTS_NSOK);\n  p->fts_statp->st_size = (required\n                           ? FTS_STAT_REQUIRED\n                           : FTS_NO_STAT_REQUIRED);\n}\n\n \nstatic void\ninternal_function\ncwd_advance_fd (FTS *sp, int fd, bool chdir_down_one)\n{\n  int old = sp->fts_cwd_fd;\n  fts_assert (old != fd || old == AT_FDCWD);\n\n  if (chdir_down_one)\n    {\n       \n      int prev_fd_in_slot = i_ring_push (&sp->fts_fd_ring, old);\n      fd_ring_print (sp, stderr, \"post-push\");\n      if (0 <= prev_fd_in_slot)\n        close (prev_fd_in_slot);  \n    }\n  else if ( ! ISSET (FTS_NOCHDIR))\n    {\n      if (0 <= old)\n        close (old);  \n    }\n\n  sp->fts_cwd_fd = fd;\n}\n\n \nstatic int\nrestore_initial_cwd (FTS *sp)\n{\n  int fail = FCHDIR (sp, ISSET (FTS_CWDFD) ? AT_FDCWD : sp->fts_rfd);\n  fd_ring_clear (&(sp->fts_fd_ring));\n  return fail;\n}\n\n \n\nstatic int\ninternal_function\ndiropen (FTS const *sp, char const *dir)\n{\n  int open_flags = (O_SEARCH | O_CLOEXEC | O_DIRECTORY | O_NOCTTY | O_NONBLOCK\n                    | (ISSET (FTS_PHYSICAL) ? O_NOFOLLOW : 0));\n\n  int fd = (ISSET (FTS_CWDFD)\n            ? openat (sp->fts_cwd_fd, dir, open_flags)\n            : open (dir, open_flags));\n  return fd;\n}\n\nFTS *\nfts_open (char * const *argv,\n          register int options,\n          int (*compar) (FTSENT const **, FTSENT const **))\n{\n        register FTS *sp;\n        register FTSENT *p, *root;\n        register size_t nitems;\n        FTSENT *parent = NULL;\n        FTSENT *tmp = NULL;      \n        bool defer_stat;\n\n         \n        if (options & ~FTS_OPTIONMASK) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n        if ((options & FTS_NOCHDIR) && (options & FTS_CWDFD)) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n        if ( ! (options & (FTS_LOGICAL | FTS_PHYSICAL))) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n\n         \n        sp = calloc (1, sizeof *sp);\n        if (sp == NULL)\n                return (NULL);\n        sp->fts_compar = compar;\n        sp->fts_options = options;\n\n         \n        if (ISSET(FTS_LOGICAL)) {\n                SET(FTS_NOCHDIR);\n                CLR(FTS_CWDFD);\n        }\n\n         \n        sp->fts_cwd_fd = AT_FDCWD;\n        if ( ISSET(FTS_CWDFD) && ! HAVE_OPENAT_SUPPORT)\n          {\n             \n            int fd = open (\".\", O_SEARCH | O_CLOEXEC);\n            if (fd < 0)\n              {\n                 \n                if ( openat_needs_fchdir ())\n                  {\n                    SET(FTS_NOCHDIR);\n                    CLR(FTS_CWDFD);\n                  }\n              }\n            else\n              {\n                close (fd);\n              }\n          }\n\n         \n#ifndef MAXPATHLEN\n# define MAXPATHLEN 1024\n#endif\n        {\n          size_t maxarglen = fts_maxarglen(argv);\n          if (! fts_palloc(sp, MAX(maxarglen, MAXPATHLEN)))\n                  goto mem1;\n        }\n\n         \n        if (*argv != NULL) {\n                if ((parent = fts_alloc(sp, \"\", 0)) == NULL)\n                        goto mem2;\n                parent->fts_level = FTS_ROOTPARENTLEVEL;\n          }\n\n         \n        defer_stat = (compar == NULL || ISSET(FTS_DEFER_STAT));\n\n         \n        for (root = NULL, nitems = 0; *argv != NULL; ++argv, ++nitems) {\n                 \n                size_t len = strlen(*argv);\n\n                if ( ! (options & FTS_VERBATIM))\n                  {\n                     \n                    char const *v = *argv;\n                    if (2 < len && v[len - 1] == '/')\n                      while (1 < len && v[len - 2] == '/')\n                        --len;\n                  }\n\n                if ((p = fts_alloc(sp, *argv, len)) == NULL)\n                        goto mem3;\n                p->fts_level = FTS_ROOTLEVEL;\n                p->fts_parent = parent;\n                p->fts_accpath = p->fts_name;\n                 \n                if (defer_stat && root != NULL) {\n                        p->fts_info = FTS_NSOK;\n                        fts_set_stat_required(p, true);\n                } else {\n                        p->fts_info = fts_stat(sp, p, false);\n                }\n\n                 \n                if (compar) {\n                        p->fts_link = root;\n                        root = p;\n                } else {\n                        p->fts_link = NULL;\n                        if (root == NULL)\n                                tmp = root = p;\n                        else {\n                                tmp->fts_link = p;\n                                tmp = p;\n                        }\n                }\n        }\n        if (compar && nitems > 1)\n                root = fts_sort(sp, root, nitems);\n\n         \n        if ((sp->fts_cur = fts_alloc(sp, \"\", 0)) == NULL)\n                goto mem3;\n        sp->fts_cur->fts_link = root;\n        sp->fts_cur->fts_info = FTS_INIT;\n        sp->fts_cur->fts_level = 1;\n        if (! setup_dir (sp))\n                goto mem3;\n\n         \n        if (!ISSET(FTS_NOCHDIR) && !ISSET(FTS_CWDFD)\n            && (sp->fts_rfd = diropen (sp, \".\")) < 0)\n                SET(FTS_NOCHDIR);\n\n        i_ring_init (&sp->fts_fd_ring, -1);\n        return (sp);\n\nmem3:   fts_lfree(root);\n        free(parent);\nmem2:   free(sp->fts_path);\nmem1:   free(sp);\n        return (NULL);\n}\n\nstatic void\ninternal_function\nfts_load (FTS *sp, register FTSENT *p)\n{\n        register size_t len;\n        register char *cp;\n\n         \n        len = p->fts_pathlen = p->fts_namelen;\n        memmove(sp->fts_path, p->fts_name, len + 1);\n        if ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {\n                len = strlen(++cp);\n                memmove(p->fts_name, cp, len + 1);\n                p->fts_namelen = len;\n        }\n        p->fts_accpath = p->fts_path = sp->fts_path;\n}\n\nint\nfts_close (FTS *sp)\n{\n        register FTSENT *freep, *p;\n        int saved_errno = 0;\n\n         \n        if (sp->fts_cur) {\n                for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {\n                        freep = p;\n                        p = p->fts_link != NULL ? p->fts_link : p->fts_parent;\n                        free(freep);\n                }\n                free(p);\n        }\n\n         \n        if (sp->fts_child)\n                fts_lfree(sp->fts_child);\n        free(sp->fts_array);\n        free(sp->fts_path);\n\n        if (ISSET(FTS_CWDFD))\n          {\n            if (0 <= sp->fts_cwd_fd)\n              if (close (sp->fts_cwd_fd))\n                saved_errno = errno;\n          }\n        else if (!ISSET(FTS_NOCHDIR))\n          {\n             \n            if (fchdir(sp->fts_rfd))\n              saved_errno = errno;\n\n             \n            if (close (sp->fts_rfd))\n              if (saved_errno == 0)\n                saved_errno = errno;\n          }\n\n        fd_ring_clear (&sp->fts_fd_ring);\n\n        if (sp->fts_leaf_optimization_works_ht)\n          hash_free (sp->fts_leaf_optimization_works_ht);\n\n        free_dir (sp);\n\n         \n        free(sp);\n\n         \n        if (saved_errno) {\n                __set_errno (saved_errno);\n                return (-1);\n        }\n\n        return (0);\n}\n\n \nenum { MIN_DIR_NLINK = 2 };\n\n \nenum leaf_optimization\n  {\n     \n    NO_LEAF_OPTIMIZATION,\n\n     \n    OK_LEAF_OPTIMIZATION\n  };\n\n#if (defined __linux__ || defined __ANDROID__) \\\n  && HAVE_SYS_VFS_H && HAVE_FSTATFS && HAVE_STRUCT_STATFS_F_TYPE\n\n# include <sys/vfs.h>\n\n \n# define S_MAGIC_AFS 0x5346414F\n# define S_MAGIC_CIFS 0xFF534D42\n# define S_MAGIC_NFS 0x6969\n# define S_MAGIC_PROC 0x9FA0\n# define S_MAGIC_TMPFS 0x1021994\n\n# ifdef HAVE___FSWORD_T\ntypedef __fsword_t fsword;\n# else\ntypedef long int fsword;\n# endif\n\n \nstruct dev_type\n{\n  dev_t st_dev;\n  fsword f_type;\n};\n\n \nenum { DEV_TYPE_HT_INITIAL_SIZE = 13 };\n\nstatic size_t\ndev_type_hash (void const *x, size_t table_size)\n{\n  struct dev_type const *ax = x;\n  uintmax_t dev = ax->st_dev;\n  return dev % table_size;\n}\n\nstatic bool\ndev_type_compare (void const *x, void const *y)\n{\n  struct dev_type const *ax = x;\n  struct dev_type const *ay = y;\n  return ax->st_dev == ay->st_dev;\n}\n\n \n\nstatic fsword\nfilesystem_type (FTSENT const *p, int fd)\n{\n  FTS *sp = p->fts_fts;\n  Hash_table *h = sp->fts_leaf_optimization_works_ht;\n  struct dev_type *ent;\n  struct statfs fs_buf;\n\n   \n  if (!ISSET (FTS_CWDFD))\n    return 0;\n\n  if (! h)\n    h = sp->fts_leaf_optimization_works_ht\n      = hash_initialize (DEV_TYPE_HT_INITIAL_SIZE, NULL, dev_type_hash,\n                         dev_type_compare, free);\n  if (h)\n    {\n      struct dev_type tmp;\n      tmp.st_dev = p->fts_statp->st_dev;\n      ent = hash_lookup (h, &tmp);\n      if (ent)\n        return ent->f_type;\n    }\n\n   \n  if (fd < 0 || fstatfs (fd, &fs_buf) != 0)\n    return 0;\n\n  if (h)\n    {\n      struct dev_type *t2 = malloc (sizeof *t2);\n      if (t2)\n        {\n          t2->st_dev = p->fts_statp->st_dev;\n          t2->f_type = fs_buf.f_type;\n\n          ent = hash_insert (h, t2);\n          if (ent)\n            fts_assert (ent == t2);\n          else\n            free (t2);\n        }\n    }\n\n  return fs_buf.f_type;\n}\n\n \nstatic bool\ndirent_inode_sort_may_be_useful (FTSENT const *p, int dir_fd)\n{\n   \n\n  switch (filesystem_type (p, dir_fd))\n    {\n    case S_MAGIC_CIFS:\n    case S_MAGIC_NFS:\n    case S_MAGIC_TMPFS:\n       \n      return false;\n\n    default:\n      return true;\n    }\n}\n\n \nstatic enum leaf_optimization\nleaf_optimization (FTSENT const *p, int dir_fd)\n{\n  switch (filesystem_type (p, dir_fd))\n    {\n    case 0:\n       \n      FALLTHROUGH;\n    case S_MAGIC_AFS:\n       \n      FALLTHROUGH;\n    case S_MAGIC_CIFS:\n       \n      FALLTHROUGH;\n    case S_MAGIC_NFS:\n       \n      FALLTHROUGH;\n    case S_MAGIC_PROC:\n       \n      return NO_LEAF_OPTIMIZATION;\n\n    default:\n      return OK_LEAF_OPTIMIZATION;\n    }\n}\n\n#else\nstatic bool\ndirent_inode_sort_may_be_useful (_GL_UNUSED FTSENT const *p,\n                                 _GL_UNUSED int dir_fd)\n{\n  return true;\n}\nstatic enum leaf_optimization\nleaf_optimization (_GL_UNUSED FTSENT const *p, _GL_UNUSED int dir_fd)\n{\n  return NO_LEAF_OPTIMIZATION;\n}\n#endif\n\n \n#define NAPPEND(p)                                                      \\\n        (p->fts_path[p->fts_pathlen - 1] == '/'                         \\\n            ? p->fts_pathlen - 1 : p->fts_pathlen)\n\nFTSENT *\nfts_read (register FTS *sp)\n{\n        register FTSENT *p, *tmp;\n        register unsigned short int instr;\n        register char *t;\n\n         \n        if (sp->fts_cur == NULL || ISSET(FTS_STOP))\n                return (NULL);\n\n         \n        p = sp->fts_cur;\n\n         \n        instr = p->fts_instr;\n        p->fts_instr = FTS_NOINSTR;\n\n         \n        if (instr == FTS_AGAIN) {\n                p->fts_info = fts_stat(sp, p, false);\n                return (p);\n        }\n        Dprintf ((\"fts_read: p=%s\\n\",\n                  p->fts_info == FTS_INIT ? \"\" : p->fts_path));\n\n         \n        if (instr == FTS_FOLLOW &&\n            (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n                p->fts_info = fts_stat(sp, p, true);\n                if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                        if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                p->fts_errno = errno;\n                                p->fts_info = FTS_ERR;\n                        } else\n                                p->fts_flags |= FTS_SYMFOLLOW;\n                }\n                goto check_for_dir;\n        }\n\n         \n        if (p->fts_info == FTS_D) {\n                 \n                if (instr == FTS_SKIP ||\n                    (ISSET(FTS_XDEV) && p->fts_statp->st_dev != sp->fts_dev)) {\n                        if (p->fts_flags & FTS_SYMFOLLOW)\n                                (void)close(p->fts_symfd);\n                        if (sp->fts_child) {\n                                fts_lfree(sp->fts_child);\n                                sp->fts_child = NULL;\n                        }\n                        p->fts_info = FTS_DP;\n                        LEAVE_DIR (sp, p, \"1\");\n                        return (p);\n                }\n\n                 \n                if (sp->fts_child != NULL && ISSET(FTS_NAMEONLY)) {\n                        CLR(FTS_NAMEONLY);\n                        fts_lfree(sp->fts_child);\n                        sp->fts_child = NULL;\n                }\n\n                 \n                if (sp->fts_child != NULL) {\n                        if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n                                p->fts_errno = errno;\n                                p->fts_flags |= FTS_DONTCHDIR;\n                                for (p = sp->fts_child; p != NULL;\n                                     p = p->fts_link)\n                                        p->fts_accpath =\n                                            p->fts_parent->fts_accpath;\n                        }\n                } else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n                        if (ISSET(FTS_STOP))\n                                return (NULL);\n                         \n                        if (p->fts_errno && p->fts_info != FTS_DNR)\n                                p->fts_info = FTS_ERR;\n                        LEAVE_DIR (sp, p, \"2\");\n                        return (p);\n                }\n                p = sp->fts_child;\n                sp->fts_child = NULL;\n                goto name;\n        }\n\n         \nnext:   tmp = p;\n\n         \n        if (p->fts_link == NULL && p->fts_parent->fts_dirp)\n          {\n            p = tmp->fts_parent;\n            sp->fts_cur = p;\n            sp->fts_path[p->fts_pathlen] = '\\0';\n\n            if ((p = fts_build (sp, BREAD)) == NULL)\n              {\n                if (ISSET(FTS_STOP))\n                  return NULL;\n                goto cd_dot_dot;\n              }\n\n            free(tmp);\n            goto name;\n          }\n\n        if ((p = p->fts_link) != NULL) {\n                sp->fts_cur = p;\n                free(tmp);\n\n                 \n                if (p->fts_level == FTS_ROOTLEVEL) {\n                        if (restore_initial_cwd(sp)) {\n                                SET(FTS_STOP);\n                                return (NULL);\n                        }\n                        free_dir(sp);\n                        fts_load(sp, p);\n                        if (! setup_dir(sp)) {\n                                free_dir(sp);\n                                return (NULL);\n                        }\n                        goto check_for_dir;\n                }\n\n                 \n                if (p->fts_instr == FTS_SKIP)\n                        goto next;\n                if (p->fts_instr == FTS_FOLLOW) {\n                        p->fts_info = fts_stat(sp, p, true);\n                        if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                                if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                        p->fts_errno = errno;\n                                        p->fts_info = FTS_ERR;\n                                } else\n                                        p->fts_flags |= FTS_SYMFOLLOW;\n                        }\n                        p->fts_instr = FTS_NOINSTR;\n                }\n\nname:           t = sp->fts_path + NAPPEND(p->fts_parent);\n                *t++ = '/';\n                memmove(t, p->fts_name, p->fts_namelen + 1);\ncheck_for_dir:\n                sp->fts_cur = p;\n                if (p->fts_info == FTS_NSOK)\n                  {\n                    if (p->fts_statp->st_size == FTS_STAT_REQUIRED)\n                      p->fts_info = fts_stat(sp, p, false);\n                    else\n                      fts_assert (p->fts_statp->st_size == FTS_NO_STAT_REQUIRED);\n                  }\n\n                if (p->fts_info == FTS_D)\n                  {\n                     \n                    if (p->fts_level == FTS_ROOTLEVEL)\n                      sp->fts_dev = p->fts_statp->st_dev;\n                    Dprintf ((\"  entering: %s\\n\", p->fts_path));\n                    if (! enter_dir (sp, p))\n                      return NULL;\n                  }\n                return p;\n        }\ncd_dot_dot:\n\n         \n        p = tmp->fts_parent;\n        sp->fts_cur = p;\n        free(tmp);\n\n        if (p->fts_level == FTS_ROOTPARENTLEVEL) {\n                 \n                free(p);\n                __set_errno (0);\n                return (sp->fts_cur = NULL);\n        }\n\n        fts_assert (p->fts_info != FTS_NSOK);\n\n         \n        sp->fts_path[p->fts_pathlen] = '\\0';\n\n         \n        if (p->fts_level == FTS_ROOTLEVEL) {\n                if (restore_initial_cwd(sp)) {\n                        p->fts_errno = errno;\n                        SET(FTS_STOP);\n                }\n        } else if (p->fts_flags & FTS_SYMFOLLOW) {\n                if (FCHDIR(sp, p->fts_symfd)) {\n                        p->fts_errno = errno;\n                        SET(FTS_STOP);\n                }\n                (void)close(p->fts_symfd);\n        } else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n                   fts_safe_changedir(sp, p->fts_parent, -1, \"..\")) {\n                p->fts_errno = errno;\n                SET(FTS_STOP);\n        }\n\n         \n        if (p->fts_info != FTS_DC) {\n                p->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n                if (p->fts_errno == 0)\n                        LEAVE_DIR (sp, p, \"3\");\n        }\n        return ISSET(FTS_STOP) ? NULL : p;\n}\n\n \n \nint\nfts_set(_GL_UNUSED FTS *sp, FTSENT *p, int instr)\n{\n        if (instr != 0 && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n            instr != FTS_NOINSTR && instr != FTS_SKIP) {\n                __set_errno (EINVAL);\n                return (1);\n        }\n        p->fts_instr = instr;\n        return (0);\n}\n\nFTSENT *\nfts_children (register FTS *sp, int instr)\n{\n        register FTSENT *p;\n        int fd;\n\n        if (instr != 0 && instr != FTS_NAMEONLY) {\n                __set_errno (EINVAL);\n                return (NULL);\n        }\n\n         \n        p = sp->fts_cur;\n\n         \n        __set_errno (0);\n\n         \n        if (ISSET(FTS_STOP))\n                return (NULL);\n\n         \n        if (p->fts_info == FTS_INIT)\n                return (p->fts_link);\n\n         \n        if (p->fts_info != FTS_D  )\n                return (NULL);\n\n         \n        if (sp->fts_child != NULL)\n                fts_lfree(sp->fts_child);\n\n        if (instr == FTS_NAMEONLY) {\n                SET(FTS_NAMEONLY);\n                instr = BNAMES;\n        } else\n                instr = BCHILD;\n\n         \n        if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n            ISSET(FTS_NOCHDIR))\n                return (sp->fts_child = fts_build(sp, instr));\n\n        if ((fd = diropen (sp, \".\")) < 0)\n                return (sp->fts_child = NULL);\n        sp->fts_child = fts_build(sp, instr);\n        if (ISSET(FTS_CWDFD))\n          {\n            cwd_advance_fd (sp, fd, true);\n          }\n        else\n          {\n            if (fchdir(fd))\n              {\n                int saved_errno = errno;\n                close (fd);\n                __set_errno (saved_errno);\n                return NULL;\n              }\n            close (fd);\n          }\n        return (sp->fts_child);\n}\n\n \nstatic int\nfts_compare_ino (struct _ftsent const **a, struct _ftsent const **b)\n{\n  return _GL_CMP (a[0]->fts_statp->st_ino, b[0]->fts_statp->st_ino);\n}\n\n \nstatic void\nset_stat_type (struct stat *st, unsigned int dtype)\n{\n  mode_t type;\n  switch (dtype)\n    {\n    case DT_BLK:\n      type = S_IFBLK;\n      break;\n    case DT_CHR:\n      type = S_IFCHR;\n      break;\n    case DT_DIR:\n      type = S_IFDIR;\n      break;\n    case DT_FIFO:\n      type = S_IFIFO;\n      break;\n    case DT_LNK:\n      type = S_IFLNK;\n      break;\n    case DT_REG:\n      type = S_IFREG;\n      break;\n    case DT_SOCK:\n      type = S_IFSOCK;\n      break;\n    default:\n      type = 0;\n    }\n  st->st_mode = type;\n}\n\n#define closedir_and_clear(dirp)                \\\n  do                                            \\\n    {                                           \\\n      closedir (dirp);                          \\\n      dirp = NULL;                              \\\n    }                                           \\\n  while (0)\n\n#define fts_opendir(file, Pdir_fd)                              \\\n        opendirat((! ISSET(FTS_NOCHDIR) && ISSET(FTS_CWDFD)     \\\n                   ? sp->fts_cwd_fd : AT_FDCWD),                \\\n                  file,                                         \\\n                  (((ISSET(FTS_PHYSICAL)                        \\\n                     && ! (ISSET(FTS_COMFOLLOW)                 \\\n                           && cur->fts_level == FTS_ROOTLEVEL)) \\\n                    ? O_NOFOLLOW : 0)),                         \\\n                  Pdir_fd)\n\n \nstatic FTSENT *\ninternal_function\nfts_build (register FTS *sp, int type)\n{\n        register FTSENT *p, *head;\n        register size_t nitems;\n        FTSENT *tail;\n        int saved_errno;\n        bool descend;\n        bool doadjust;\n        ptrdiff_t level;\n        size_t len, maxlen, new_len;\n        char *cp;\n        int dir_fd;\n        FTSENT *cur = sp->fts_cur;\n        bool continue_readdir = !!cur->fts_dirp;\n        bool sort_by_inode = false;\n        size_t max_entries;\n\n         \n        if (continue_readdir)\n          {\n            DIR *dp = cur->fts_dirp;\n            dir_fd = dirfd (dp);\n            if (dir_fd < 0)\n              {\n                int dirfd_errno = errno;\n                closedir_and_clear (cur->fts_dirp);\n                if (type == BREAD)\n                  {\n                    cur->fts_info = FTS_DNR;\n                    cur->fts_errno = dirfd_errno;\n                  }\n                return NULL;\n              }\n          }\n        else\n          {\n             \n            if ((cur->fts_dirp = fts_opendir(cur->fts_accpath, &dir_fd)) == NULL)\n              {\n                if (type == BREAD)\n                  {\n                    cur->fts_info = FTS_DNR;\n                    cur->fts_errno = errno;\n                  }\n                return NULL;\n              }\n             \n            bool stat_optimization = cur->fts_info == FTS_NSOK;\n\n            if (stat_optimization\n                 \n                || ISSET (FTS_TIGHT_CYCLE_CHECK))\n              {\n                if (!stat_optimization)\n                  LEAVE_DIR (sp, cur, \"4\");\n                if (fstat (dir_fd, cur->fts_statp) != 0)\n                  {\n                    int fstat_errno = errno;\n                    closedir_and_clear (cur->fts_dirp);\n                    if (type == BREAD)\n                      {\n                        cur->fts_errno = fstat_errno;\n                        cur->fts_info = FTS_NS;\n                      }\n                    __set_errno (fstat_errno);\n                    return NULL;\n                  }\n                if (stat_optimization)\n                  cur->fts_info = FTS_D;\n                else if (! enter_dir (sp, cur))\n                  {\n                    int err = errno;\n                    closedir_and_clear (cur->fts_dirp);\n                    __set_errno (err);\n                    return NULL;\n                  }\n              }\n          }\n\n         \n        max_entries = sp->fts_compar ? SIZE_MAX : FTS_MAX_READDIR_ENTRIES;\n\n         \n        if (continue_readdir)\n          {\n             \n            descend = true;\n          }\n        else\n          {\n             \n            descend = (type != BNAMES\n                       && ! (ISSET (FTS_NOSTAT) && ISSET (FTS_PHYSICAL)\n                             && ! ISSET (FTS_SEEDOT)\n                             && cur->fts_statp->st_nlink == MIN_DIR_NLINK\n                             && (leaf_optimization (cur, dir_fd)\n                                 != NO_LEAF_OPTIMIZATION)));\n            if (descend || type == BREAD)\n              {\n                if (ISSET(FTS_CWDFD))\n                  dir_fd = fcntl (dir_fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n                if (dir_fd < 0 || fts_safe_changedir(sp, cur, dir_fd, NULL)) {\n                        if (descend && type == BREAD)\n                                cur->fts_errno = errno;\n                        cur->fts_flags |= FTS_DONTCHDIR;\n                        descend = false;\n                        closedir_and_clear(cur->fts_dirp);\n                        if (ISSET(FTS_CWDFD) && 0 <= dir_fd)\n                                close (dir_fd);\n                        cur->fts_dirp = NULL;\n                } else\n                        descend = true;\n              }\n          }\n\n         \n        len = NAPPEND(cur);\n        if (ISSET(FTS_NOCHDIR)) {\n                cp = sp->fts_path + len;\n                *cp++ = '/';\n        } else {\n                 \n                cp = NULL;\n        }\n        len++;\n        maxlen = sp->fts_pathlen - len;\n\n        level = cur->fts_level + 1;\n\n         \n        doadjust = false;\n        head = NULL;\n        tail = NULL;\n        nitems = 0;\n        while (cur->fts_dirp) {\n                size_t d_namelen;\n                __set_errno (0);\n                struct dirent *dp = readdir(cur->fts_dirp);\n                if (dp == NULL) {\n                        if (errno) {\n                                cur->fts_errno = errno;\n                                 \n                                cur->fts_info = (continue_readdir || nitems)\n                                                ? FTS_ERR : FTS_DNR;\n                        }\n                        closedir_and_clear(cur->fts_dirp);\n                        break;\n                }\n                if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))\n                        continue;\n\n                d_namelen = _D_EXACT_NAMLEN (dp);\n                p = fts_alloc (sp, dp->d_name, d_namelen);\n                if (!p)\n                        goto mem1;\n                if (d_namelen >= maxlen) {\n                         \n                        uintptr_t oldaddr = (uintptr_t) sp->fts_path;\n                        if (! fts_palloc(sp, d_namelen + len + 1)) {\n                                 \nmem1:                           saved_errno = errno;\n                                free(p);\n                                fts_lfree(head);\n                                closedir_and_clear(cur->fts_dirp);\n                                cur->fts_info = FTS_ERR;\n                                SET(FTS_STOP);\n                                __set_errno (saved_errno);\n                                return (NULL);\n                        }\n                         \n                        if (oldaddr != (uintptr_t) sp->fts_path) {\n                                doadjust = true;\n                                if (ISSET(FTS_NOCHDIR))\n                                        cp = sp->fts_path + len;\n                        }\n                        maxlen = sp->fts_pathlen - len;\n                }\n\n                new_len = len + d_namelen;\n                if (new_len < len) {\n                         \n                        free(p);\n                        fts_lfree(head);\n                        closedir_and_clear(cur->fts_dirp);\n                        cur->fts_info = FTS_ERR;\n                        SET(FTS_STOP);\n                        __set_errno (ENAMETOOLONG);\n                        return (NULL);\n                }\n                p->fts_level = level;\n                p->fts_parent = sp->fts_cur;\n                p->fts_pathlen = new_len;\n\n                 \n                p->fts_statp->st_ino = D_INO (dp);\n\n                 \n                if (ISSET(FTS_NOCHDIR)) {\n                        p->fts_accpath = p->fts_path;\n                        memmove(cp, p->fts_name, p->fts_namelen + 1);\n                } else\n                        p->fts_accpath = p->fts_name;\n\n                if (sp->fts_compar == NULL || ISSET(FTS_DEFER_STAT)) {\n                         \n                        bool skip_stat = (ISSET(FTS_NOSTAT)\n                                          && DT_IS_KNOWN(dp)\n                                          && ! DT_MUST_BE(dp, DT_DIR)\n                                          && (ISSET(FTS_PHYSICAL)\n                                              || ! DT_MUST_BE(dp, DT_LNK)));\n                        p->fts_info = FTS_NSOK;\n                         \n                        set_stat_type (p->fts_statp, D_TYPE (dp));\n                        fts_set_stat_required(p, !skip_stat);\n                } else {\n                        p->fts_info = fts_stat(sp, p, false);\n                }\n\n                 \n                p->fts_link = NULL;\n                if (head == NULL)\n                        head = tail = p;\n                else {\n                        tail->fts_link = p;\n                        tail = p;\n                }\n\n                 \n                if (nitems == _FTS_INODE_SORT_DIR_ENTRIES_THRESHOLD\n                    && !sp->fts_compar)\n                  sort_by_inode = dirent_inode_sort_may_be_useful (cur, dir_fd);\n\n                ++nitems;\n                if (max_entries <= nitems) {\n                         \n                        break;\n                }\n        }\n\n         \n        if (doadjust)\n                fts_padjust(sp, head);\n\n         \n        if (ISSET(FTS_NOCHDIR)) {\n                if (len == sp->fts_pathlen || nitems == 0)\n                        --cp;\n                *cp = '\\0';\n        }\n\n         \n        if (!continue_readdir && descend && (type == BCHILD || !nitems) &&\n            (cur->fts_level == FTS_ROOTLEVEL\n             ? restore_initial_cwd(sp)\n             : fts_safe_changedir(sp, cur->fts_parent, -1, \"..\"))) {\n                cur->fts_info = FTS_ERR;\n                SET(FTS_STOP);\n                fts_lfree(head);\n                return (NULL);\n        }\n\n         \n        if (!nitems) {\n                if (type == BREAD\n                    && cur->fts_info != FTS_DNR && cur->fts_info != FTS_ERR)\n                        cur->fts_info = FTS_DP;\n                fts_lfree(head);\n                return (NULL);\n        }\n\n        if (sort_by_inode) {\n                sp->fts_compar = fts_compare_ino;\n                head = fts_sort (sp, head, nitems);\n                sp->fts_compar = NULL;\n        }\n\n         \n        if (sp->fts_compar && nitems > 1)\n                head = fts_sort(sp, head, nitems);\n        return (head);\n}\n\n#if GNULIB_FTS_DEBUG\n\nstruct devino {\n  intmax_t dev, ino;\n};\n#define PRINT_DEVINO \"(%jd,%jd)\"\n\nstatic struct devino\ngetdevino (int fd)\n{\n  struct stat st;\n  return (fd == AT_FDCWD\n          ? (struct devino) { -1, 0 }\n          : fstat (fd, &st) == 0\n          ? (struct devino) { st.st_dev, st.st_ino }\n          : (struct devino) { -1, errno });\n}\n\n \nstatic void\nfind_matching_ancestor (FTSENT const *e_curr, struct Active_dir const *ad)\n{\n  FTSENT const *ent;\n  for (ent = e_curr; ent->fts_level >= FTS_ROOTLEVEL; ent = ent->fts_parent)\n    {\n      if (ad->ino == ent->fts_statp->st_ino\n          && ad->dev == ent->fts_statp->st_dev)\n        return;\n    }\n  printf (\"ERROR: tree dir, %s, not active\\n\", ad->fts_ent->fts_accpath);\n  printf (\"active dirs:\\n\");\n  for (ent = e_curr;\n       ent->fts_level >= FTS_ROOTLEVEL; ent = ent->fts_parent)\n    printf (\"  %s(%\"PRIuMAX\"/%\"PRIuMAX\") to %s(%\"PRIuMAX\"/%\"PRIuMAX\")...\\n\",\n            ad->fts_ent->fts_accpath,\n            (uintmax_t) ad->dev,\n            (uintmax_t) ad->ino,\n            ent->fts_accpath,\n            (uintmax_t) ent->fts_statp->st_dev,\n            (uintmax_t) ent->fts_statp->st_ino);\n}\n\nvoid\nfts_cross_check (FTS const *sp)\n{\n  FTSENT const *ent = sp->fts_cur;\n  FTSENT const *t;\n  if ( ! ISSET (FTS_TIGHT_CYCLE_CHECK))\n    return;\n\n  Dprintf ((\"fts-cross-check cur=%s\\n\", ent->fts_path));\n   \n  for (t = ent->fts_parent; t->fts_level >= FTS_ROOTLEVEL; t = t->fts_parent)\n    {\n      struct Active_dir ad;\n      ad.ino = t->fts_statp->st_ino;\n      ad.dev = t->fts_statp->st_dev;\n      if ( ! hash_lookup (sp->fts_cycle.ht, &ad))\n        printf (\"ERROR: active dir, %s, not in tree\\n\", t->fts_path);\n    }\n\n   \n  if (ent->fts_parent->fts_level >= FTS_ROOTLEVEL\n      && (ent->fts_info == FTS_DP\n          || ent->fts_info == FTS_D))\n    {\n      struct Active_dir *ad;\n      for (ad = hash_get_first (sp->fts_cycle.ht); ad != NULL;\n           ad = hash_get_next (sp->fts_cycle.ht, ad))\n        {\n          find_matching_ancestor (ent, ad);\n        }\n    }\n}\n\nstatic bool\nsame_fd (int fd1, int fd2)\n{\n  struct stat sb1, sb2;\n  return (fstat (fd1, &sb1) == 0\n          && fstat (fd2, &sb2) == 0\n          && SAME_INODE (sb1, sb2));\n}\n\nstatic void\nfd_ring_print (FTS const *sp, FILE *stream, char const *msg)\n{\n  if (!fts_debug)\n    return;\n  I_ring const *fd_ring = &sp->fts_fd_ring;\n  unsigned int i = fd_ring->ir_front;\n  struct devino cwd = getdevino (sp->fts_cwd_fd);\n  fprintf (stream, \"=== %s ========== \"PRINT_DEVINO\"\\n\", msg, cwd.dev, cwd.ino);\n  if (i_ring_empty (fd_ring))\n    return;\n\n  while (true)\n    {\n      int fd = fd_ring->ir_data[i];\n      if (fd < 0)\n        fprintf (stream, \"%u: %d:\\n\", i, fd);\n      else\n        {\n          struct devino wd = getdevino (fd);\n          fprintf (stream, \"%u: %d: \"PRINT_DEVINO\"\\n\", i, fd, wd.dev, wd.ino);\n        }\n      if (i == fd_ring->ir_back)\n        break;\n      i = (i + I_RING_SIZE - 1) % I_RING_SIZE;\n    }\n}\n\n \nstatic void\nfd_ring_check (FTS const *sp)\n{\n  if (!fts_debug)\n    return;\n\n   \n  I_ring fd_w = sp->fts_fd_ring;\n\n  int cwd_fd = sp->fts_cwd_fd;\n  cwd_fd = fcntl (cwd_fd, F_DUPFD_CLOEXEC, STDERR_FILENO + 1);\n  struct devino dot = getdevino (cwd_fd);\n  fprintf (stderr, \"===== check ===== cwd: \"PRINT_DEVINO\"\\n\",\n           dot.dev, dot.ino);\n  while ( ! i_ring_empty (&fd_w))\n    {\n      int fd = i_ring_pop (&fd_w);\n      if (0 <= fd)\n        {\n          int open_flags = O_SEARCH | O_CLOEXEC;\n          int parent_fd = openat (cwd_fd, \"..\", open_flags);\n          if (parent_fd < 0)\n            {\n               \n              break;\n            }\n          if (!same_fd (fd, parent_fd))\n            {\n              struct devino cwd = getdevino (fd);\n              fprintf (stderr, \"ring  : \"PRINT_DEVINO\"\\n\", cwd.dev, cwd.ino);\n              struct devino c2 = getdevino (parent_fd);\n              fprintf (stderr, \"parent: \"PRINT_DEVINO\"\\n\", c2.dev, c2.ino);\n              fts_assert (0);\n            }\n          close (cwd_fd);\n          cwd_fd = parent_fd;\n        }\n    }\n  close (cwd_fd);\n}\n#endif\n\nstatic unsigned short int\ninternal_function\nfts_stat(FTS *sp, register FTSENT *p, bool follow)\n{\n        struct stat *sbp = p->fts_statp;\n\n        if (ISSET (FTS_LOGICAL)\n            || (ISSET (FTS_COMFOLLOW) && p->fts_level == FTS_ROOTLEVEL))\n                follow = true;\n\n         \n        int flags = follow ? 0 : AT_SYMLINK_NOFOLLOW;\n        if (fstatat (sp->fts_cwd_fd, p->fts_accpath, sbp, flags) < 0)\n          {\n            if (follow && errno == ENOENT\n                && 0 <= fstatat (sp->fts_cwd_fd, p->fts_accpath, sbp,\n                                 AT_SYMLINK_NOFOLLOW))\n              {\n                __set_errno (0);\n                return FTS_SLNONE;\n              }\n\n            p->fts_errno = errno;\n            memset (sbp, 0, sizeof *sbp);\n            return FTS_NS;\n          }\n\n        if (S_ISDIR(sbp->st_mode)) {\n                if (ISDOT(p->fts_name)) {\n                         \n                        return (p->fts_level == FTS_ROOTLEVEL ? FTS_D : FTS_DOT);\n                }\n\n                return (FTS_D);\n        }\n        if (S_ISLNK(sbp->st_mode))\n                return (FTS_SL);\n        if (S_ISREG(sbp->st_mode))\n                return (FTS_F);\n        return (FTS_DEFAULT);\n}\n\nstatic int\nfts_compar (void const *a, void const *b)\n{\n   \n  FTSENT const **pa = (FTSENT const **) a;\n  FTSENT const **pb = (FTSENT const **) b;\n  return pa[0]->fts_fts->fts_compar (pa, pb);\n}\n\nstatic FTSENT *\ninternal_function\nfts_sort (FTS *sp, FTSENT *head, register size_t nitems)\n{\n        register FTSENT **ap, *p;\n\n         \n        FTSENT *dummy;\n        int (*compare) (void const *, void const *) =\n          ((sizeof &dummy == sizeof (void *)\n            && (long int) &dummy == (long int) (void *) &dummy)\n           ? (int (*) (void const *, void const *)) sp->fts_compar\n           : fts_compar);\n\n         \n        if (nitems > sp->fts_nitems) {\n                FTSENT **a;\n\n                sp->fts_nitems = nitems + 40;\n                if (SIZE_MAX / sizeof *a < sp->fts_nitems\n                    || ! (a = realloc (sp->fts_array,\n                                       sp->fts_nitems * sizeof *a))) {\n                        free(sp->fts_array);\n                        sp->fts_array = NULL;\n                        sp->fts_nitems = 0;\n                        return (head);\n                }\n                sp->fts_array = a;\n        }\n        for (ap = sp->fts_array, p = head; p; p = p->fts_link)\n                *ap++ = p;\n        qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);\n        for (head = *(ap = sp->fts_array); --nitems; ++ap)\n                ap[0]->fts_link = ap[1];\n        ap[0]->fts_link = NULL;\n        return (head);\n}\n\nstatic FTSENT *\ninternal_function\nfts_alloc (FTS *sp, const char *name, register size_t namelen)\n{\n        register FTSENT *p;\n        size_t len;\n\n         \n        len = FLEXSIZEOF(FTSENT, fts_name, namelen + 1);\n        if ((p = malloc(len)) == NULL)\n                return (NULL);\n\n         \n        memcpy(p->fts_name, name, namelen);\n        p->fts_name[namelen] = '\\0';\n\n        p->fts_namelen = namelen;\n        p->fts_fts = sp;\n        p->fts_path = sp->fts_path;\n        p->fts_errno = 0;\n        p->fts_dirp = NULL;\n        p->fts_flags = 0;\n        p->fts_instr = FTS_NOINSTR;\n        p->fts_number = 0;\n        p->fts_pointer = NULL;\n        return (p);\n}\n\nstatic void\ninternal_function\nfts_lfree (register FTSENT *head)\n{\n        register FTSENT *p;\n        int err = errno;\n\n         \n        while ((p = head)) {\n                head = head->fts_link;\n                if (p->fts_dirp)\n                        closedir (p->fts_dirp);\n                free(p);\n        }\n\n        __set_errno (err);\n}\n\n \nstatic bool\ninternal_function\nfts_palloc (FTS *sp, size_t more)\n{\n        char *p;\n        size_t new_len = sp->fts_pathlen + more + 256;\n\n         \n        if (new_len < sp->fts_pathlen) {\n                free(sp->fts_path);\n                sp->fts_path = NULL;\n                __set_errno (ENAMETOOLONG);\n                return false;\n        }\n        sp->fts_pathlen = new_len;\n        p = realloc(sp->fts_path, sp->fts_pathlen);\n        if (p == NULL) {\n                free(sp->fts_path);\n                sp->fts_path = NULL;\n                return false;\n        }\n        sp->fts_path = p;\n        return true;\n}\n\n \nstatic void\ninternal_function\nfts_padjust (FTS *sp, FTSENT *head)\n{\n        FTSENT *p;\n        char *addr = sp->fts_path;\n\n         \n\n#define ADJUST(p) do {                                                  \\\n        uintptr_t old_accpath = (uintptr_t) (p)->fts_accpath;           \\\n        if (old_accpath != (uintptr_t) (p)->fts_name) {                 \\\n                (p)->fts_accpath =                                      \\\n                  addr + (old_accpath - (uintptr_t) (p)->fts_path);     \\\n        }                                                               \\\n        (p)->fts_path = addr;                                           \\\n} while (0)\n         \n        for (p = sp->fts_child; p; p = p->fts_link)\n                ADJUST(p);\n\n         \n        for (p = head; p->fts_level >= FTS_ROOTLEVEL;) {\n                ADJUST(p);\n                p = p->fts_link ? p->fts_link : p->fts_parent;\n        }\n}\n\nstatic size_t\ninternal_function _GL_ATTRIBUTE_PURE\nfts_maxarglen (char * const *argv)\n{\n        size_t len, max;\n\n        for (max = 0; *argv; ++argv)\n                if ((len = strlen(*argv)) > max)\n                        max = len;\n        return (max + 1);\n}\n\n \nstatic int\ninternal_function\nfts_safe_changedir (FTS *sp, FTSENT *p, int fd, char const *dir)\n{\n        int ret;\n        bool is_dotdot = dir && STREQ (dir, \"..\");\n        int newfd;\n\n         \n        if (ISSET (FTS_NOCHDIR))\n          {\n            if (ISSET (FTS_CWDFD) && 0 <= fd)\n              close (fd);\n            return 0;\n          }\n\n        if (fd < 0 && is_dotdot && ISSET (FTS_CWDFD))\n          {\n             \n            if ( ! i_ring_empty (&sp->fts_fd_ring))\n              {\n                int parent_fd;\n                fd_ring_print (sp, stderr, \"pre-pop\");\n                parent_fd = i_ring_pop (&sp->fts_fd_ring);\n                if (0 <= parent_fd)\n                  {\n                    fd = parent_fd;\n                    dir = NULL;\n                  }\n              }\n          }\n\n        newfd = fd;\n        if (fd < 0 && (newfd = diropen (sp, dir)) < 0)\n          return -1;\n\n         \n        if (ISSET(FTS_LOGICAL) || ! HAVE_WORKING_O_NOFOLLOW\n            || (dir && STREQ (dir, \"..\")))\n          {\n            struct stat sb;\n            if (fstat(newfd, &sb))\n              {\n                ret = -1;\n                goto bail;\n              }\n            if (p->fts_statp->st_dev != sb.st_dev\n                || p->fts_statp->st_ino != sb.st_ino)\n              {\n                __set_errno (ENOENT);            \n                ret = -1;\n                goto bail;\n              }\n          }\n\n        if (ISSET(FTS_CWDFD))\n          {\n            cwd_advance_fd (sp, newfd, ! is_dotdot);\n            return 0;\n          }\n\n        ret = fchdir(newfd);\nbail:\n        if (fd < 0)\n          {\n            int oerrno = errno;\n            (void)close(newfd);\n            __set_errno (oerrno);\n          }\n        return ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}