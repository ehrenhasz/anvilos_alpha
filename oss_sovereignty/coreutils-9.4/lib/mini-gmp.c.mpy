{
  "module_name": "mini-gmp.c",
  "hash_id": "205969b81dbaabc8fcfa775f0a60b155abdb0939f6dbf90f962528a4d86702dc",
  "original_prompt": "Ingested from coreutils-9.4/lib/mini-gmp.c",
  "human_readable_source": " \n\n \n\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"mini-gmp.h\"\n\n#if !defined(MINI_GMP_DONT_USE_FLOAT_H)\n#include <float.h>\n#endif\n\n\f\n \n#define GMP_LIMB_BITS (sizeof(mp_limb_t) * CHAR_BIT)\n\n#define GMP_LIMB_MAX ((mp_limb_t) ~ (mp_limb_t) 0)\n#define GMP_LIMB_HIGHBIT ((mp_limb_t) 1 << (GMP_LIMB_BITS - 1))\n\n#define GMP_HLIMB_BIT ((mp_limb_t) 1 << (GMP_LIMB_BITS / 2))\n#define GMP_LLIMB_MASK (GMP_HLIMB_BIT - 1)\n\n#define GMP_ULONG_BITS (sizeof(unsigned long) * CHAR_BIT)\n#define GMP_ULONG_HIGHBIT ((unsigned long) 1 << (GMP_ULONG_BITS - 1))\n\n#define GMP_ABS(x) ((x) >= 0 ? (x) : -(x))\n#define GMP_NEG_CAST(T,x) (-((T)((x) + 1) - 1))\n\n#define GMP_MIN(a, b) ((a) < (b) ? (a) : (b))\n#define GMP_MAX(a, b) ((a) > (b) ? (a) : (b))\n\n#define GMP_CMP(a,b) (((a) > (b)) - ((a) < (b)))\n\n#if defined(DBL_MANT_DIG) && FLT_RADIX == 2\n#define GMP_DBL_MANT_BITS DBL_MANT_DIG\n#else\n#define GMP_DBL_MANT_BITS (53)\n#endif\n\n \n#define GMP_MPN_OVERLAP_P(xp, xsize, yp, ysize)\t\t\t\t\\\n  ((xp) + (xsize) > (yp) && (yp) + (ysize) > (xp))\n\n#define gmp_assert_nocarry(x) do { \\\n    mp_limb_t __cy = (x);\t   \\\n    assert (__cy == 0);\t\t   \\\n    (void) (__cy);\t\t   \\\n  } while (0)\n\n#define gmp_clz(count, x) do {\t\t\t\t\t\t\\\n    mp_limb_t __clz_x = (x);\t\t\t\t\t\t\\\n    unsigned __clz_c = 0;\t\t\t\t\t\t\\\n    int LOCAL_SHIFT_BITS = 8;\t\t\t\t\t\t\\\n    if (GMP_LIMB_BITS > LOCAL_SHIFT_BITS)\t\t\t\t\\\n      for (;\t\t\t\t\t\t\t\t\\\n\t   (__clz_x & ((mp_limb_t) 0xff << (GMP_LIMB_BITS - 8))) == 0;\t\\\n\t   __clz_c += 8)\t\t\t\t\t\t\\\n\t{ __clz_x <<= LOCAL_SHIFT_BITS;\t}\t\t\t\t\\\n    for (; (__clz_x & GMP_LIMB_HIGHBIT) == 0; __clz_c++)\t\t\\\n      __clz_x <<= 1;\t\t\t\t\t\t\t\\\n    (count) = __clz_c;\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define gmp_ctz(count, x) do {\t\t\t\t\t\t\\\n    mp_limb_t __ctz_x = (x);\t\t\t\t\t\t\\\n    unsigned __ctz_c = 0;\t\t\t\t\t\t\\\n    gmp_clz (__ctz_c, __ctz_x & - __ctz_x);\t\t\t\t\\\n    (count) = GMP_LIMB_BITS - 1 - __ctz_c;\t\t\t\t\\\n  } while (0)\n\n#define gmp_add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_limb_t __x;\t\t\t\t\t\t\t\\\n    __x = (al) + (bl);\t\t\t\t\t\t\t\\\n    (sh) = (ah) + (bh) + (__x < (al));\t\t\t\t\t\\\n    (sl) = __x;\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define gmp_sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_limb_t __x;\t\t\t\t\t\t\t\\\n    __x = (al) - (bl);\t\t\t\t\t\t\t\\\n    (sh) = (ah) - (bh) - ((al) < (bl));\t\t\t\t\t\\\n    (sl) = __x;\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define gmp_umul_ppmm(w1, w0, u, v)\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    int LOCAL_GMP_LIMB_BITS = GMP_LIMB_BITS;\t\t\t\t\\\n    if (sizeof(unsigned int) * CHAR_BIT >= 2 * GMP_LIMB_BITS)\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tunsigned int __ww = (unsigned int) (u) * (v);\t\t\t\\\n\tw0 = (mp_limb_t) __ww;\t\t\t\t\t\t\\\n\tw1 = (mp_limb_t) (__ww >> LOCAL_GMP_LIMB_BITS);\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    else if (GMP_ULONG_BITS >= 2 * GMP_LIMB_BITS)\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tunsigned long int __ww = (unsigned long int) (u) * (v);\t\t\\\n\tw0 = (mp_limb_t) __ww;\t\t\t\t\t\t\\\n\tw1 = (mp_limb_t) (__ww >> LOCAL_GMP_LIMB_BITS);\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    else {\t\t\t\t\t\t\t\t\\\n      mp_limb_t __x0, __x1, __x2, __x3;\t\t\t\t\t\\\n      unsigned __ul, __vl, __uh, __vh;\t\t\t\t\t\\\n      mp_limb_t __u = (u), __v = (v);\t\t\t\t\t\\\n      assert (sizeof (unsigned) * 2 >= sizeof (mp_limb_t));\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      __ul = __u & GMP_LLIMB_MASK;\t\t\t\t\t\\\n      __uh = __u >> (GMP_LIMB_BITS / 2);\t\t\t\t\\\n      __vl = __v & GMP_LLIMB_MASK;\t\t\t\t\t\\\n      __vh = __v >> (GMP_LIMB_BITS / 2);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      __x0 = (mp_limb_t) __ul * __vl;\t\t\t\t\t\\\n      __x1 = (mp_limb_t) __ul * __vh;\t\t\t\t\t\\\n      __x2 = (mp_limb_t) __uh * __vl;\t\t\t\t\t\\\n      __x3 = (mp_limb_t) __uh * __vh;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      __x1 += __x0 >> (GMP_LIMB_BITS / 2); \t\\\n      __x1 += __x2;\t\t \t\t\\\n      if (__x1 < __x2)\t\t \t\t\t\\\n\t__x3 += GMP_HLIMB_BIT;\t \t\\\n\t\t\t\t\t\t\t\t\t\\\n      (w1) = __x3 + (__x1 >> (GMP_LIMB_BITS / 2));\t\t\t\\\n      (w0) = (__x1 << (GMP_LIMB_BITS / 2)) + (__x0 & GMP_LLIMB_MASK);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n \n#define gmp_umullo_limb(u, v) \\\n  ((sizeof(mp_limb_t) >= sizeof(int)) ? (u)*(v) : (unsigned int)(u) * (v))\n\n#define gmp_udiv_qrnnd_preinv(q, r, nh, nl, d, di)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_limb_t _qh, _ql, _r, _mask;\t\t\t\t\t\\\n    gmp_umul_ppmm (_qh, _ql, (nh), (di));\t\t\t\t\\\n    gmp_add_ssaaaa (_qh, _ql, _qh, _ql, (nh) + 1, (nl));\t\t\\\n    _r = (nl) - gmp_umullo_limb (_qh, (d));\t\t\t\t\\\n    _mask = -(mp_limb_t) (_r > _ql);  \t\t\\\n    _qh += _mask;\t\t\t\t\t\t\t\\\n    _r += _mask & (d);\t\t\t\t\t\t\t\\\n    if (_r >= (d))\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t_r -= (d);\t\t\t\t\t\t\t\\\n\t_qh++;\t\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (r) = _r;\t\t\t\t\t\t\t\t\\\n    (q) = _qh;\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n#define gmp_udiv_qr_3by2(q, r1, r0, n2, n1, n0, d1, d0, dinv)\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_limb_t _q0, _t1, _t0, _mask;\t\t\t\t\t\\\n    gmp_umul_ppmm ((q), _q0, (n2), (dinv));\t\t\t\t\\\n    gmp_add_ssaaaa ((q), _q0, (q), _q0, (n2), (n1));\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n     \t\t\\\n    (r1) = (n1) - gmp_umullo_limb ((d1), (q));\t\t\t\t\\\n    gmp_sub_ddmmss ((r1), (r0), (r1), (n0), (d1), (d0));\t\t\\\n    gmp_umul_ppmm (_t1, _t0, (d0), (q));\t\t\t\t\\\n    gmp_sub_ddmmss ((r1), (r0), (r1), (r0), _t1, _t0);\t\t\t\\\n    (q)++;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n     \t\t\t\\\n    _mask = - (mp_limb_t) ((r1) >= _q0);\t\t\t\t\\\n    (q) += _mask;\t\t\t\t\t\t\t\\\n    gmp_add_ssaaaa ((r1), (r0), (r1), (r0), _mask & (d1), _mask & (d0)); \\\n    if ((r1) >= (d1))\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tif ((r1) > (d1) || (r0) >= (d0))\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    (q)++;\t\t\t\t\t\t\t\\\n\t    gmp_sub_ddmmss ((r1), (r0), (r1), (r0), (d1), (d0));\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n \n#define MP_LIMB_T_SWAP(x, y)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_limb_t __mp_limb_t_swap__tmp = (x);\t\t\t\t\\\n    (x) = (y);\t\t\t\t\t\t\t\t\\\n    (y) = __mp_limb_t_swap__tmp;\t\t\t\t\t\\\n  } while (0)\n#define MP_SIZE_T_SWAP(x, y)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_size_t __mp_size_t_swap__tmp = (x);\t\t\t\t\\\n    (x) = (y);\t\t\t\t\t\t\t\t\\\n    (y) = __mp_size_t_swap__tmp;\t\t\t\t\t\\\n  } while (0)\n#define MP_BITCNT_T_SWAP(x,y)\t\t\t\\\n  do {\t\t\t\t\t\t\\\n    mp_bitcnt_t __mp_bitcnt_t_swap__tmp = (x);\t\\\n    (x) = (y);\t\t\t\t\t\\\n    (y) = __mp_bitcnt_t_swap__tmp;\t\t\\\n  } while (0)\n#define MP_PTR_SWAP(x, y)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_ptr __mp_ptr_swap__tmp = (x);\t\t\t\t\t\\\n    (x) = (y);\t\t\t\t\t\t\t\t\\\n    (y) = __mp_ptr_swap__tmp;\t\t\t\t\t\t\\\n  } while (0)\n#define MP_SRCPTR_SWAP(x, y)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mp_srcptr __mp_srcptr_swap__tmp = (x);\t\t\t\t\\\n    (x) = (y);\t\t\t\t\t\t\t\t\\\n    (y) = __mp_srcptr_swap__tmp;\t\t\t\t\t\\\n  } while (0)\n\n#define MPN_PTR_SWAP(xp,xs, yp,ys)\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    MP_PTR_SWAP (xp, yp);\t\t\t\t\t\t\\\n    MP_SIZE_T_SWAP (xs, ys);\t\t\t\t\t\t\\\n  } while(0)\n#define MPN_SRCPTR_SWAP(xp,xs, yp,ys)\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    MP_SRCPTR_SWAP (xp, yp);\t\t\t\t\t\t\\\n    MP_SIZE_T_SWAP (xs, ys);\t\t\t\t\t\t\\\n  } while(0)\n\n#define MPZ_PTR_SWAP(x, y)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mpz_ptr __mpz_ptr_swap__tmp = (x);\t\t\t\t\t\\\n    (x) = (y);\t\t\t\t\t\t\t\t\\\n    (y) = __mpz_ptr_swap__tmp;\t\t\t\t\t\t\\\n  } while (0)\n#define MPZ_SRCPTR_SWAP(x, y)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    mpz_srcptr __mpz_srcptr_swap__tmp = (x);\t\t\t\t\\\n    (x) = (y);\t\t\t\t\t\t\t\t\\\n    (y) = __mpz_srcptr_swap__tmp;\t\t\t\t\t\\\n  } while (0)\n\nconst int mp_bits_per_limb = GMP_LIMB_BITS;\n\n\f\n \nstatic void\ngmp_die (const char *msg)\n{\n  fprintf (stderr, \"%s\\n\", msg);\n  abort();\n}\n\nstatic void *\ngmp_default_alloc (size_t size)\n{\n  void *p;\n\n  assert (size > 0);\n\n  p = malloc (size);\n  if (!p)\n    gmp_die(\"gmp_default_alloc: Virtual memory exhausted.\");\n\n  return p;\n}\n\nstatic void *\ngmp_default_realloc (void *old, size_t unused_old_size, size_t new_size)\n{\n  void * p;\n\n  p = realloc (old, new_size);\n\n  if (!p)\n    gmp_die(\"gmp_default_realloc: Virtual memory exhausted.\");\n\n  return p;\n}\n\nstatic void\ngmp_default_free (void *p, size_t unused_size)\n{\n  free (p);\n}\n\nstatic void * (*gmp_allocate_func) (size_t) = gmp_default_alloc;\nstatic void * (*gmp_reallocate_func) (void *, size_t, size_t) = gmp_default_realloc;\nstatic void (*gmp_free_func) (void *, size_t) = gmp_default_free;\n\nvoid\nmp_get_memory_functions (void *(**alloc_func) (size_t),\n\t\t\t void *(**realloc_func) (void *, size_t, size_t),\n\t\t\t void (**free_func) (void *, size_t))\n{\n  if (alloc_func)\n    *alloc_func = gmp_allocate_func;\n\n  if (realloc_func)\n    *realloc_func = gmp_reallocate_func;\n\n  if (free_func)\n    *free_func = gmp_free_func;\n}\n\nvoid\nmp_set_memory_functions (void *(*alloc_func) (size_t),\n\t\t\t void *(*realloc_func) (void *, size_t, size_t),\n\t\t\t void (*free_func) (void *, size_t))\n{\n  if (!alloc_func)\n    alloc_func = gmp_default_alloc;\n  if (!realloc_func)\n    realloc_func = gmp_default_realloc;\n  if (!free_func)\n    free_func = gmp_default_free;\n\n  gmp_allocate_func = alloc_func;\n  gmp_reallocate_func = realloc_func;\n  gmp_free_func = free_func;\n}\n\n#define gmp_alloc(size) ((*gmp_allocate_func)((size)))\n#define gmp_free(p, size) ((*gmp_free_func) ((p), (size)))\n#define gmp_realloc(ptr, old_size, size) ((*gmp_reallocate_func)(ptr, old_size, size))\n\nstatic mp_ptr\ngmp_alloc_limbs (mp_size_t size)\n{\n  return (mp_ptr) gmp_alloc (size * sizeof (mp_limb_t));\n}\n\nstatic mp_ptr\ngmp_realloc_limbs (mp_ptr old, mp_size_t old_size, mp_size_t size)\n{\n  assert (size > 0);\n  return (mp_ptr) gmp_realloc (old, old_size * sizeof (mp_limb_t), size * sizeof (mp_limb_t));\n}\n\nstatic void\ngmp_free_limbs (mp_ptr old, mp_size_t size)\n{\n  gmp_free (old, size * sizeof (mp_limb_t));\n}\n\n\f\n \n\nvoid\nmpn_copyi (mp_ptr d, mp_srcptr s, mp_size_t n)\n{\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    d[i] = s[i];\n}\n\nvoid\nmpn_copyd (mp_ptr d, mp_srcptr s, mp_size_t n)\n{\n  while (--n >= 0)\n    d[n] = s[n];\n}\n\nint\nmpn_cmp (mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  while (--n >= 0)\n    {\n      if (ap[n] != bp[n])\n\treturn ap[n] > bp[n] ? 1 : -1;\n    }\n  return 0;\n}\n\nstatic int\nmpn_cmp4 (mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  if (an != bn)\n    return an < bn ? -1 : 1;\n  else\n    return mpn_cmp (ap, bp, an);\n}\n\nstatic mp_size_t\nmpn_normalized_size (mp_srcptr xp, mp_size_t n)\n{\n  while (n > 0 && xp[n-1] == 0)\n    --n;\n  return n;\n}\n\nint\nmpn_zero_p(mp_srcptr rp, mp_size_t n)\n{\n  return mpn_normalized_size (rp, n) == 0;\n}\n\nvoid\nmpn_zero (mp_ptr rp, mp_size_t n)\n{\n  while (--n >= 0)\n    rp[n] = 0;\n}\n\nmp_limb_t\nmpn_add_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n\n  assert (n > 0);\n  i = 0;\n  do\n    {\n      mp_limb_t r = ap[i] + b;\n       \n      b = (r < b);\n      rp[i] = r;\n    }\n  while (++i < n);\n\n  return b;\n}\n\nmp_limb_t\nmpn_add_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t cy;\n\n  for (i = 0, cy = 0; i < n; i++)\n    {\n      mp_limb_t a, b, r;\n      a = ap[i]; b = bp[i];\n      r = a + cy;\n      cy = (r < cy);\n      r += b;\n      cy += (r < b);\n      rp[i] = r;\n    }\n  return cy;\n}\n\nmp_limb_t\nmpn_add (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  assert (an >= bn);\n\n  cy = mpn_add_n (rp, ap, bp, bn);\n  if (an > bn)\n    cy = mpn_add_1 (rp + bn, ap + bn, an - bn, cy);\n  return cy;\n}\n\nmp_limb_t\nmpn_sub_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n\n  assert (n > 0);\n\n  i = 0;\n  do\n    {\n      mp_limb_t a = ap[i];\n       \n      mp_limb_t cy = a < b;\n      rp[i] = a - b;\n      b = cy;\n    }\n  while (++i < n);\n\n  return b;\n}\n\nmp_limb_t\nmpn_sub_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t cy;\n\n  for (i = 0, cy = 0; i < n; i++)\n    {\n      mp_limb_t a, b;\n      a = ap[i]; b = bp[i];\n      b += cy;\n      cy = (b < cy);\n      cy += (a < b);\n      rp[i] = a - b;\n    }\n  return cy;\n}\n\nmp_limb_t\nmpn_sub (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  assert (an >= bn);\n\n  cy = mpn_sub_n (rp, ap, bp, bn);\n  if (an > bn)\n    cy = mpn_sub_1 (rp + bn, ap + bn, an - bn, cy);\n  return cy;\n}\n\nmp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}\n\nmp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl + lpl;\n      cl += lpl < rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}\n\nmp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl - lpl;\n      cl += lpl > rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}\n\nmp_limb_t\nmpn_mul (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr vp, mp_size_t vn)\n{\n  assert (un >= vn);\n  assert (vn >= 1);\n  assert (!GMP_MPN_OVERLAP_P(rp, un + vn, up, un));\n  assert (!GMP_MPN_OVERLAP_P(rp, un + vn, vp, vn));\n\n   \n\n  rp[un] = mpn_mul_1 (rp, up, un, vp[0]);\n\n   \n\n  while (--vn >= 1)\n    {\n      rp += 1, vp += 1;\n      rp[un] = mpn_addmul_1 (rp, up, un, vp[0]);\n    }\n  return rp[un];\n}\n\nvoid\nmpn_mul_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mpn_mul (rp, ap, n, bp, n);\n}\n\nvoid\nmpn_sqr (mp_ptr rp, mp_srcptr ap, mp_size_t n)\n{\n  mpn_mul (rp, ap, n, ap, n);\n}\n\nmp_limb_t\nmpn_lshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_limb_t retval;\n\n  assert (n >= 1);\n  assert (cnt >= 1);\n  assert (cnt < GMP_LIMB_BITS);\n\n  up += n;\n  rp += n;\n\n  tnc = GMP_LIMB_BITS - cnt;\n  low_limb = *--up;\n  retval = low_limb >> tnc;\n  high_limb = (low_limb << cnt);\n\n  while (--n != 0)\n    {\n      low_limb = *--up;\n      *--rp = high_limb | (low_limb >> tnc);\n      high_limb = (low_limb << cnt);\n    }\n  *--rp = high_limb;\n\n  return retval;\n}\n\nmp_limb_t\nmpn_rshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_limb_t retval;\n\n  assert (n >= 1);\n  assert (cnt >= 1);\n  assert (cnt < GMP_LIMB_BITS);\n\n  tnc = GMP_LIMB_BITS - cnt;\n  high_limb = *up++;\n  retval = (high_limb << tnc);\n  low_limb = high_limb >> cnt;\n\n  while (--n != 0)\n    {\n      high_limb = *up++;\n      *rp++ = low_limb | (high_limb << tnc);\n      low_limb = high_limb >> cnt;\n    }\n  *rp = low_limb;\n\n  return retval;\n}\n\nstatic mp_bitcnt_t\nmpn_common_scan (mp_limb_t limb, mp_size_t i, mp_srcptr up, mp_size_t un,\n\t\t mp_limb_t ux)\n{\n  unsigned cnt;\n\n  assert (ux == 0 || ux == GMP_LIMB_MAX);\n  assert (0 <= i && i <= un );\n\n  while (limb == 0)\n    {\n      i++;\n      if (i == un)\n\treturn (ux == 0 ? ~(mp_bitcnt_t) 0 : un * GMP_LIMB_BITS);\n      limb = ux ^ up[i];\n    }\n  gmp_ctz (cnt, limb);\n  return (mp_bitcnt_t) i * GMP_LIMB_BITS + cnt;\n}\n\nmp_bitcnt_t\nmpn_scan1 (mp_srcptr ptr, mp_bitcnt_t bit)\n{\n  mp_size_t i;\n  i = bit / GMP_LIMB_BITS;\n\n  return mpn_common_scan ( ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),\n\t\t\t  i, ptr, i, 0);\n}\n\nmp_bitcnt_t\nmpn_scan0 (mp_srcptr ptr, mp_bitcnt_t bit)\n{\n  mp_size_t i;\n  i = bit / GMP_LIMB_BITS;\n\n  return mpn_common_scan (~ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),\n\t\t\t  i, ptr, i, GMP_LIMB_MAX);\n}\n\nvoid\nmpn_com (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  while (--n >= 0)\n    *rp++ = ~ *up++;\n}\n\nmp_limb_t\nmpn_neg (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  while (*up == 0)\n    {\n      *rp = 0;\n      if (!--n)\n\treturn 0;\n      ++up; ++rp;\n    }\n  *rp = - *up;\n  mpn_com (++rp, ++up, --n);\n  return 1;\n}\n\n\f\n \n\n \nmp_limb_t\nmpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)\n{\n  mp_limb_t r, m;\n\n  {\n    mp_limb_t p, ql;\n    unsigned ul, uh, qh;\n\n    assert (sizeof (unsigned) * 2 >= sizeof (mp_limb_t));\n     \n    ul = u1 & GMP_LLIMB_MASK;\n    uh = u1 >> (GMP_LIMB_BITS / 2);\n\n     \n    qh = (u1 ^ GMP_LIMB_MAX) / uh;\n\n     \n\n    r = ((~u1 - (mp_limb_t) qh * uh) << (GMP_LIMB_BITS / 2)) | GMP_LLIMB_MASK;\n\n    p = (mp_limb_t) qh * ul;\n     \n    if (r < p)\n      {\n\tqh--;\n\tr += u1;\n\tif (r >= u1)  \n\t  if (r < p)\n\t    {\n\t      qh--;\n\t      r += u1;\n\t    }\n      }\n    r -= p;\n\n     \n\n    p = (r >> (GMP_LIMB_BITS / 2)) * qh + r;\n     \n    ql = (p >> (GMP_LIMB_BITS / 2)) + 1;\n\n     \n    r = (r << (GMP_LIMB_BITS / 2)) + GMP_LLIMB_MASK - ql * u1;\n\n    if (r >= (GMP_LIMB_MAX & (p << (GMP_LIMB_BITS / 2))))\n      {\n\tql--;\n\tr += u1;\n      }\n    m = ((mp_limb_t) qh << (GMP_LIMB_BITS / 2)) + ql;\n    if (r >= u1)\n      {\n\tm++;\n\tr -= u1;\n      }\n  }\n\n   \n  if (u0 > 0)\n    {\n      mp_limb_t th, tl;\n      r = ~r;\n      r += u0;\n      if (r < u0)\n\t{\n\t  m--;\n\t  if (r >= u1)\n\t    {\n\t      m--;\n\t      r -= u1;\n\t    }\n\t  r -= u1;\n\t}\n      gmp_umul_ppmm (th, tl, u0, m);\n      r += th;\n      if (r < th)\n\t{\n\t  m--;\n\t  m -= ((r > u1) | ((r == u1) & (tl > u0)));\n\t}\n    }\n\n  return m;\n}\n\nstruct gmp_div_inverse\n{\n   \n  unsigned shift;\n   \n  mp_limb_t d1, d0;\n   \n  mp_limb_t di;\n};\n\nstatic void\nmpn_div_qr_1_invert (struct gmp_div_inverse *inv, mp_limb_t d)\n{\n  unsigned shift;\n\n  assert (d > 0);\n  gmp_clz (shift, d);\n  inv->shift = shift;\n  inv->d1 = d << shift;\n  inv->di = mpn_invert_limb (inv->d1);\n}\n\nstatic void\nmpn_div_qr_2_invert (struct gmp_div_inverse *inv,\n\t\t     mp_limb_t d1, mp_limb_t d0)\n{\n  unsigned shift;\n\n  assert (d1 > 0);\n  gmp_clz (shift, d1);\n  inv->shift = shift;\n  if (shift > 0)\n    {\n      d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n      d0 <<= shift;\n    }\n  inv->d1 = d1;\n  inv->d0 = d0;\n  inv->di = mpn_invert_3by2 (d1, d0);\n}\n\nstatic void\nmpn_div_qr_invert (struct gmp_div_inverse *inv,\n\t\t   mp_srcptr dp, mp_size_t dn)\n{\n  assert (dn > 0);\n\n  if (dn == 1)\n    mpn_div_qr_1_invert (inv, dp[0]);\n  else if (dn == 2)\n    mpn_div_qr_2_invert (inv, dp[1], dp[0]);\n  else\n    {\n      unsigned shift;\n      mp_limb_t d1, d0;\n\n      d1 = dp[dn-1];\n      d0 = dp[dn-2];\n      assert (d1 > 0);\n      gmp_clz (shift, d1);\n      inv->shift = shift;\n      if (shift > 0)\n\t{\n\t  d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n\t  d0 = (d0 << shift) | (dp[dn-3] >> (GMP_LIMB_BITS - shift));\n\t}\n      inv->d1 = d1;\n      inv->d0 = d0;\n      inv->di = mpn_invert_3by2 (d1, d0);\n    }\n}\n\n \nstatic mp_limb_t\nmpn_div_qr_1_preinv (mp_ptr qp, mp_srcptr np, mp_size_t nn,\n\t\t     const struct gmp_div_inverse *inv)\n{\n  mp_limb_t d, di;\n  mp_limb_t r;\n  mp_ptr tp = NULL;\n  mp_size_t tn = 0;\n\n  if (inv->shift > 0)\n    {\n       \n      tp = qp;\n      if (!tp)\n        {\n\t   tn = nn;\n\t   tp = gmp_alloc_limbs (tn);\n        }\n      r = mpn_lshift (tp, np, nn, inv->shift);\n      np = tp;\n    }\n  else\n    r = 0;\n\n  d = inv->d1;\n  di = inv->di;\n  while (--nn >= 0)\n    {\n      mp_limb_t q;\n\n      gmp_udiv_qrnnd_preinv (q, r, r, np[nn], d, di);\n      if (qp)\n\tqp[nn] = q;\n    }\n  if (tn)\n    gmp_free_limbs (tp, tn);\n\n  return r >> inv->shift;\n}\n\nstatic void\nmpn_div_qr_2_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t     const struct gmp_div_inverse *inv)\n{\n  unsigned shift;\n  mp_size_t i;\n  mp_limb_t d1, d0, di, r1, r0;\n\n  assert (nn >= 2);\n  shift = inv->shift;\n  d1 = inv->d1;\n  d0 = inv->d0;\n  di = inv->di;\n\n  if (shift > 0)\n    r1 = mpn_lshift (np, np, nn, shift);\n  else\n    r1 = 0;\n\n  r0 = np[nn - 1];\n\n  i = nn - 2;\n  do\n    {\n      mp_limb_t n0, q;\n      n0 = np[i];\n      gmp_udiv_qr_3by2 (q, r1, r0, r1, r0, n0, d1, d0, di);\n\n      if (qp)\n\tqp[i] = q;\n    }\n  while (--i >= 0);\n\n  if (shift > 0)\n    {\n      assert ((r0 & (GMP_LIMB_MAX >> (GMP_LIMB_BITS - shift))) == 0);\n      r0 = (r0 >> shift) | (r1 << (GMP_LIMB_BITS - shift));\n      r1 >>= shift;\n    }\n\n  np[1] = r1;\n  np[0] = r0;\n}\n\nstatic void\nmpn_div_qr_pi1 (mp_ptr qp,\n\t\tmp_ptr np, mp_size_t nn, mp_limb_t n1,\n\t\tmp_srcptr dp, mp_size_t dn,\n\t\tmp_limb_t dinv)\n{\n  mp_size_t i;\n\n  mp_limb_t d1, d0;\n  mp_limb_t cy, cy1;\n  mp_limb_t q;\n\n  assert (dn > 2);\n  assert (nn >= dn);\n\n  d1 = dp[dn - 1];\n  d0 = dp[dn - 2];\n\n  assert ((d1 & GMP_LIMB_HIGHBIT) != 0);\n   \n\n  i = nn - dn;\n  do\n    {\n      mp_limb_t n0 = np[dn-1+i];\n\n      if (n1 == d1 && n0 == d0)\n\t{\n\t  q = GMP_LIMB_MAX;\n\t  mpn_submul_1 (np+i, dp, dn, q);\n\t  n1 = np[dn-1+i];\t \n\t}\n      else\n\t{\n\t  gmp_udiv_qr_3by2 (q, n1, n0, n1, n0, np[dn-2+i], d1, d0, dinv);\n\n\t  cy = mpn_submul_1 (np + i, dp, dn-2, q);\n\n\t  cy1 = n0 < cy;\n\t  n0 = n0 - cy;\n\t  cy = n1 < cy1;\n\t  n1 = n1 - cy1;\n\t  np[dn-2+i] = n0;\n\n\t  if (cy != 0)\n\t    {\n\t      n1 += d1 + mpn_add_n (np + i, np + i, dp, dn - 1);\n\t      q--;\n\t    }\n\t}\n\n      if (qp)\n\tqp[i] = q;\n    }\n  while (--i >= 0);\n\n  np[dn - 1] = n1;\n}\n\nstatic void\nmpn_div_qr_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t   mp_srcptr dp, mp_size_t dn,\n\t\t   const struct gmp_div_inverse *inv)\n{\n  assert (dn > 0);\n  assert (nn >= dn);\n\n  if (dn == 1)\n    np[0] = mpn_div_qr_1_preinv (qp, np, nn, inv);\n  else if (dn == 2)\n    mpn_div_qr_2_preinv (qp, np, nn, inv);\n  else\n    {\n      mp_limb_t nh;\n      unsigned shift;\n\n      assert (inv->d1 == dp[dn-1]);\n      assert (inv->d0 == dp[dn-2]);\n      assert ((inv->d1 & GMP_LIMB_HIGHBIT) != 0);\n\n      shift = inv->shift;\n      if (shift > 0)\n\tnh = mpn_lshift (np, np, nn, shift);\n      else\n\tnh = 0;\n\n      mpn_div_qr_pi1 (qp, np, nn, nh, dp, dn, inv->di);\n\n      if (shift > 0)\n\tgmp_assert_nocarry (mpn_rshift (np, np, dn, shift));\n    }\n}\n\nstatic void\nmpn_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)\n{\n  struct gmp_div_inverse inv;\n  mp_ptr tp = NULL;\n\n  assert (dn > 0);\n  assert (nn >= dn);\n\n  mpn_div_qr_invert (&inv, dp, dn);\n  if (dn > 2 && inv.shift > 0)\n    {\n      tp = gmp_alloc_limbs (dn);\n      gmp_assert_nocarry (mpn_lshift (tp, dp, dn, inv.shift));\n      dp = tp;\n    }\n  mpn_div_qr_preinv (qp, np, nn, dp, dn, &inv);\n  if (tp)\n    gmp_free_limbs (tp, dn);\n}\n\n\f\n \nstatic unsigned\nmpn_base_power_of_two_p (unsigned b)\n{\n  switch (b)\n    {\n    case 2: return 1;\n    case 4: return 2;\n    case 8: return 3;\n    case 16: return 4;\n    case 32: return 5;\n    case 64: return 6;\n    case 128: return 7;\n    case 256: return 8;\n    default: return 0;\n    }\n}\n\nstruct mpn_base_info\n{\n   \n  unsigned exp;\n  mp_limb_t bb;\n};\n\nstatic void\nmpn_get_base_info (struct mpn_base_info *info, mp_limb_t b)\n{\n  mp_limb_t m;\n  mp_limb_t p;\n  unsigned exp;\n\n  m = GMP_LIMB_MAX / b;\n  for (exp = 1, p = b; p <= m; exp++)\n    p *= b;\n\n  info->exp = exp;\n  info->bb = p;\n}\n\nstatic mp_bitcnt_t\nmpn_limb_size_in_base_2 (mp_limb_t u)\n{\n  unsigned shift;\n\n  assert (u > 0);\n  gmp_clz (shift, u);\n  return GMP_LIMB_BITS - shift;\n}\n\nstatic size_t\nmpn_get_str_bits (unsigned char *sp, unsigned bits, mp_srcptr up, mp_size_t un)\n{\n  unsigned char mask;\n  size_t sn, j;\n  mp_size_t i;\n  unsigned shift;\n\n  sn = ((un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1])\n\t+ bits - 1) / bits;\n\n  mask = (1U << bits) - 1;\n\n  for (i = 0, j = sn, shift = 0; j-- > 0;)\n    {\n      unsigned char digit = up[i] >> shift;\n\n      shift += bits;\n\n      if (shift >= GMP_LIMB_BITS && ++i < un)\n\t{\n\t  shift -= GMP_LIMB_BITS;\n\t  digit |= up[i] << (bits - shift);\n\t}\n      sp[j] = digit & mask;\n    }\n  return sn;\n}\n\n \nstatic size_t\nmpn_limb_get_str (unsigned char *sp, mp_limb_t w,\n\t\t  const struct gmp_div_inverse *binv)\n{\n  mp_size_t i;\n  for (i = 0; w > 0; i++)\n    {\n      mp_limb_t h, l, r;\n\n      h = w >> (GMP_LIMB_BITS - binv->shift);\n      l = w << binv->shift;\n\n      gmp_udiv_qrnnd_preinv (w, r, h, l, binv->d1, binv->di);\n      assert ((r & (GMP_LIMB_MAX >> (GMP_LIMB_BITS - binv->shift))) == 0);\n      r >>= binv->shift;\n\n      sp[i] = r;\n    }\n  return i;\n}\n\nstatic size_t\nmpn_get_str_other (unsigned char *sp,\n\t\t   int base, const struct mpn_base_info *info,\n\t\t   mp_ptr up, mp_size_t un)\n{\n  struct gmp_div_inverse binv;\n  size_t sn;\n  size_t i;\n\n  mpn_div_qr_1_invert (&binv, base);\n\n  sn = 0;\n\n  if (un > 1)\n    {\n      struct gmp_div_inverse bbinv;\n      mpn_div_qr_1_invert (&bbinv, info->bb);\n\n      do\n\t{\n\t  mp_limb_t w;\n\t  size_t done;\n\t  w = mpn_div_qr_1_preinv (up, up, un, &bbinv);\n\t  un -= (up[un-1] == 0);\n\t  done = mpn_limb_get_str (sp + sn, w, &binv);\n\n\t  for (sn += done; done < info->exp; done++)\n\t    sp[sn++] = 0;\n\t}\n      while (un > 1);\n    }\n  sn += mpn_limb_get_str (sp + sn, up[0], &binv);\n\n   \n  for (i = 0; 2*i + 1 < sn; i++)\n    {\n      unsigned char t = sp[i];\n      sp[i] = sp[sn - i - 1];\n      sp[sn - i - 1] = t;\n    }\n\n  return sn;\n}\n\nsize_t\nmpn_get_str (unsigned char *sp, int base, mp_ptr up, mp_size_t un)\n{\n  unsigned bits;\n\n  assert (un > 0);\n  assert (up[un-1] > 0);\n\n  bits = mpn_base_power_of_two_p (base);\n  if (bits)\n    return mpn_get_str_bits (sp, bits, up, un);\n  else\n    {\n      struct mpn_base_info info;\n\n      mpn_get_base_info (&info, base);\n      return mpn_get_str_other (sp, base, &info, up, un);\n    }\n}\n\nstatic mp_size_t\nmpn_set_str_bits (mp_ptr rp, const unsigned char *sp, size_t sn,\n\t\t  unsigned bits)\n{\n  mp_size_t rn;\n  mp_limb_t limb;\n  unsigned shift;\n\n  for (limb = 0, rn = 0, shift = 0; sn-- > 0; )\n    {\n      limb |= (mp_limb_t) sp[sn] << shift;\n      shift += bits;\n      if (shift >= GMP_LIMB_BITS)\n\t{\n\t  shift -= GMP_LIMB_BITS;\n\t  rp[rn++] = limb;\n\t   \n\t  limb = (unsigned int) sp[sn] >> (bits - shift);\n\t}\n    }\n  if (limb != 0)\n    rp[rn++] = limb;\n  else\n    rn = mpn_normalized_size (rp, rn);\n  return rn;\n}\n\n \nstatic mp_size_t\nmpn_set_str_other (mp_ptr rp, const unsigned char *sp, size_t sn,\n\t\t   mp_limb_t b, const struct mpn_base_info *info)\n{\n  mp_size_t rn;\n  mp_limb_t w;\n  unsigned k;\n  size_t j;\n\n  assert (sn > 0);\n\n  k = 1 + (sn - 1) % info->exp;\n\n  j = 0;\n  w = sp[j++];\n  while (--k != 0)\n    w = w * b + sp[j++];\n\n  rp[0] = w;\n\n  for (rn = 1; j < sn;)\n    {\n      mp_limb_t cy;\n\n      w = sp[j++];\n      for (k = 1; k < info->exp; k++)\n\tw = w * b + sp[j++];\n\n      cy = mpn_mul_1 (rp, rp, rn, info->bb);\n      cy += mpn_add_1 (rp, rp, rn, w);\n      if (cy > 0)\n\trp[rn++] = cy;\n    }\n  assert (j == sn);\n\n  return rn;\n}\n\nmp_size_t\nmpn_set_str (mp_ptr rp, const unsigned char *sp, size_t sn, int base)\n{\n  unsigned bits;\n\n  if (sn == 0)\n    return 0;\n\n  bits = mpn_base_power_of_two_p (base);\n  if (bits)\n    return mpn_set_str_bits (rp, sp, sn, bits);\n  else\n    {\n      struct mpn_base_info info;\n\n      mpn_get_base_info (&info, base);\n      return mpn_set_str_other (rp, sp, sn, base, &info);\n    }\n}\n\n\f\n \nvoid\nmpz_init (mpz_t r)\n{\n  static const mp_limb_t dummy_limb = GMP_LIMB_MAX & 0xc1a0;\n\n  r->_mp_alloc = 0;\n  r->_mp_size = 0;\n  r->_mp_d = (mp_ptr) &dummy_limb;\n}\n\n \nvoid\nmpz_init2 (mpz_t r, mp_bitcnt_t bits)\n{\n  mp_size_t rn;\n\n  bits -= (bits != 0);\t\t \n  rn = 1 + bits / GMP_LIMB_BITS;\n\n  r->_mp_alloc = rn;\n  r->_mp_size = 0;\n  r->_mp_d = gmp_alloc_limbs (rn);\n}\n\nvoid\nmpz_clear (mpz_t r)\n{\n  if (r->_mp_alloc)\n    gmp_free_limbs (r->_mp_d, r->_mp_alloc);\n}\n\nstatic mp_ptr\nmpz_realloc (mpz_t r, mp_size_t size)\n{\n  size = GMP_MAX (size, 1);\n\n  if (r->_mp_alloc)\n    r->_mp_d = gmp_realloc_limbs (r->_mp_d, r->_mp_alloc, size);\n  else\n    r->_mp_d = gmp_alloc_limbs (size);\n  r->_mp_alloc = size;\n\n  if (GMP_ABS (r->_mp_size) > size)\n    r->_mp_size = 0;\n\n  return r->_mp_d;\n}\n\n \n#define MPZ_REALLOC(z,n) ((n) > (z)->_mp_alloc\t\t\t\\\n\t\t\t  ? mpz_realloc(z,n)\t\t\t\\\n\t\t\t  : (z)->_mp_d)\n\f\n \nvoid\nmpz_set_si (mpz_t r, signed long int x)\n{\n  if (x >= 0)\n    mpz_set_ui (r, x);\n  else  \n    if (GMP_LIMB_BITS < GMP_ULONG_BITS)\n      {\n\tmpz_set_ui (r, GMP_NEG_CAST (unsigned long int, x));\n\tmpz_neg (r, r);\n      }\n  else\n    {\n      r->_mp_size = -1;\n      MPZ_REALLOC (r, 1)[0] = GMP_NEG_CAST (unsigned long int, x);\n    }\n}\n\nvoid\nmpz_set_ui (mpz_t r, unsigned long int x)\n{\n  if (x > 0)\n    {\n      r->_mp_size = 1;\n      MPZ_REALLOC (r, 1)[0] = x;\n      if (GMP_LIMB_BITS < GMP_ULONG_BITS)\n\t{\n\t  int LOCAL_GMP_LIMB_BITS = GMP_LIMB_BITS;\n\t  while (x >>= LOCAL_GMP_LIMB_BITS)\n\t    {\n\t      ++ r->_mp_size;\n\t      MPZ_REALLOC (r, r->_mp_size)[r->_mp_size - 1] = x;\n\t    }\n\t}\n    }\n  else\n    r->_mp_size = 0;\n}\n\nvoid\nmpz_set (mpz_t r, const mpz_t x)\n{\n   \n  if (r != x)\n    {\n      mp_size_t n;\n      mp_ptr rp;\n\n      n = GMP_ABS (x->_mp_size);\n      rp = MPZ_REALLOC (r, n);\n\n      mpn_copyi (rp, x->_mp_d, n);\n      r->_mp_size = x->_mp_size;\n    }\n}\n\nvoid\nmpz_init_set_si (mpz_t r, signed long int x)\n{\n  mpz_init (r);\n  mpz_set_si (r, x);\n}\n\nvoid\nmpz_init_set_ui (mpz_t r, unsigned long int x)\n{\n  mpz_init (r);\n  mpz_set_ui (r, x);\n}\n\nvoid\nmpz_init_set (mpz_t r, const mpz_t x)\n{\n  mpz_init (r);\n  mpz_set (r, x);\n}\n\nint\nmpz_fits_slong_p (const mpz_t u)\n{\n  return mpz_cmp_si (u, LONG_MAX) <= 0 && mpz_cmp_si (u, LONG_MIN) >= 0;\n}\n\nstatic int\nmpn_absfits_ulong_p (mp_srcptr up, mp_size_t un)\n{\n  int ulongsize = GMP_ULONG_BITS / GMP_LIMB_BITS;\n  mp_limb_t ulongrem = 0;\n\n  if (GMP_ULONG_BITS % GMP_LIMB_BITS != 0)\n    ulongrem = (mp_limb_t) (ULONG_MAX >> GMP_LIMB_BITS * ulongsize) + 1;\n\n  return un <= ulongsize || (up[ulongsize] < ulongrem && un == ulongsize + 1);\n}\n\nint\nmpz_fits_ulong_p (const mpz_t u)\n{\n  mp_size_t us = u->_mp_size;\n\n  return us >= 0 && mpn_absfits_ulong_p (u->_mp_d, us);\n}\n\nint\nmpz_fits_sint_p (const mpz_t u)\n{\n  return mpz_cmp_si (u, INT_MAX) <= 0 && mpz_cmp_si (u, INT_MIN) >= 0;\n}\n\nint\nmpz_fits_uint_p (const mpz_t u)\n{\n  return u->_mp_size >= 0 && mpz_cmpabs_ui (u, UINT_MAX) <= 0;\n}\n\nint\nmpz_fits_sshort_p (const mpz_t u)\n{\n  return mpz_cmp_si (u, SHRT_MAX) <= 0 && mpz_cmp_si (u, SHRT_MIN) >= 0;\n}\n\nint\nmpz_fits_ushort_p (const mpz_t u)\n{\n  return u->_mp_size >= 0 && mpz_cmpabs_ui (u, USHRT_MAX) <= 0;\n}\n\nlong int\nmpz_get_si (const mpz_t u)\n{\n  unsigned long r = mpz_get_ui (u);\n  unsigned long c = -LONG_MAX - LONG_MIN;\n\n  if (u->_mp_size < 0)\n     \n    return -(long) c - (long) ((r - c) & LONG_MAX);\n  else\n    return (long) (r & LONG_MAX);\n}\n\nunsigned long int\nmpz_get_ui (const mpz_t u)\n{\n  if (GMP_LIMB_BITS < GMP_ULONG_BITS)\n    {\n      int LOCAL_GMP_LIMB_BITS = GMP_LIMB_BITS;\n      unsigned long r = 0;\n      mp_size_t n = GMP_ABS (u->_mp_size);\n      n = GMP_MIN (n, 1 + (mp_size_t) (GMP_ULONG_BITS - 1) / GMP_LIMB_BITS);\n      while (--n >= 0)\n\tr = (r << LOCAL_GMP_LIMB_BITS) + u->_mp_d[n];\n      return r;\n    }\n\n  return u->_mp_size == 0 ? 0 : u->_mp_d[0];\n}\n\nsize_t\nmpz_size (const mpz_t u)\n{\n  return GMP_ABS (u->_mp_size);\n}\n\nmp_limb_t\nmpz_getlimbn (const mpz_t u, mp_size_t n)\n{\n  if (n >= 0 && n < GMP_ABS (u->_mp_size))\n    return u->_mp_d[n];\n  else\n    return 0;\n}\n\nvoid\nmpz_realloc2 (mpz_t x, mp_bitcnt_t n)\n{\n  mpz_realloc (x, 1 + (n - (n != 0)) / GMP_LIMB_BITS);\n}\n\nmp_srcptr\nmpz_limbs_read (mpz_srcptr x)\n{\n  return x->_mp_d;\n}\n\nmp_ptr\nmpz_limbs_modify (mpz_t x, mp_size_t n)\n{\n  assert (n > 0);\n  return MPZ_REALLOC (x, n);\n}\n\nmp_ptr\nmpz_limbs_write (mpz_t x, mp_size_t n)\n{\n  return mpz_limbs_modify (x, n);\n}\n\nvoid\nmpz_limbs_finish (mpz_t x, mp_size_t xs)\n{\n  mp_size_t xn;\n  xn = mpn_normalized_size (x->_mp_d, GMP_ABS (xs));\n  x->_mp_size = xs < 0 ? -xn : xn;\n}\n\nstatic mpz_srcptr\nmpz_roinit_normal_n (mpz_t x, mp_srcptr xp, mp_size_t xs)\n{\n  x->_mp_alloc = 0;\n  x->_mp_d = (mp_ptr) xp;\n  x->_mp_size = xs;\n  return x;\n}\n\nmpz_srcptr\nmpz_roinit_n (mpz_t x, mp_srcptr xp, mp_size_t xs)\n{\n  mpz_roinit_normal_n (x, xp, xs);\n  mpz_limbs_finish (x, xs);\n  return x;\n}\n\n\f\n \nvoid\nmpz_set_d (mpz_t r, double x)\n{\n  int sign;\n  mp_ptr rp;\n  mp_size_t rn, i;\n  double B;\n  double Bi;\n  mp_limb_t f;\n\n   \n  if (x != x || x == x * 0.5)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  sign = x < 0.0 ;\n  if (sign)\n    x = - x;\n\n  if (x < 1.0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n  B = 4.0 * (double) (GMP_LIMB_HIGHBIT >> 1);\n  Bi = 1.0 / B;\n  for (rn = 1; x >= B; rn++)\n    x *= Bi;\n\n  rp = MPZ_REALLOC (r, rn);\n\n  f = (mp_limb_t) x;\n  x -= f;\n  assert (x < 1.0);\n  i = rn-1;\n  rp[i] = f;\n  while (--i >= 0)\n    {\n      x = B * x;\n      f = (mp_limb_t) x;\n      x -= f;\n      assert (x < 1.0);\n      rp[i] = f;\n    }\n\n  r->_mp_size = sign ? - rn : rn;\n}\n\nvoid\nmpz_init_set_d (mpz_t r, double x)\n{\n  mpz_init (r);\n  mpz_set_d (r, x);\n}\n\ndouble\nmpz_get_d (const mpz_t u)\n{\n  int m;\n  mp_limb_t l;\n  mp_size_t un;\n  double x;\n  double B = 4.0 * (double) (GMP_LIMB_HIGHBIT >> 1);\n\n  un = GMP_ABS (u->_mp_size);\n\n  if (un == 0)\n    return 0.0;\n\n  l = u->_mp_d[--un];\n  gmp_clz (m, l);\n  m = m + GMP_DBL_MANT_BITS - GMP_LIMB_BITS;\n  if (m < 0)\n    l &= GMP_LIMB_MAX << -m;\n\n  for (x = l; --un >= 0;)\n    {\n      x = B*x;\n      if (m > 0) {\n\tl = u->_mp_d[un];\n\tm -= GMP_LIMB_BITS;\n\tif (m < 0)\n\t  l &= GMP_LIMB_MAX << -m;\n\tx += l;\n      }\n    }\n\n  if (u->_mp_size < 0)\n    x = -x;\n\n  return x;\n}\n\nint\nmpz_cmpabs_d (const mpz_t x, double d)\n{\n  mp_size_t xn;\n  double B, Bi;\n  mp_size_t i;\n\n  xn = x->_mp_size;\n  d = GMP_ABS (d);\n\n  if (xn != 0)\n    {\n      xn = GMP_ABS (xn);\n\n      B = 4.0 * (double) (GMP_LIMB_HIGHBIT >> 1);\n      Bi = 1.0 / B;\n\n       \n      for (i = 1; i < xn; i++)\n\td *= Bi;\n\n      if (d >= B)\n\treturn -1;\n\n       \n      for (i = xn; i-- > 0;)\n\t{\n\t  mp_limb_t f, xl;\n\n\t  f = (mp_limb_t) d;\n\t  xl = x->_mp_d[i];\n\t  if (xl > f)\n\t    return 1;\n\t  else if (xl < f)\n\t    return -1;\n\t  d = B * (d - f);\n\t}\n    }\n  return - (d > 0.0);\n}\n\nint\nmpz_cmp_d (const mpz_t x, double d)\n{\n  if (x->_mp_size < 0)\n    {\n      if (d >= 0.0)\n\treturn -1;\n      else\n\treturn -mpz_cmpabs_d (x, d);\n    }\n  else\n    {\n      if (d < 0.0)\n\treturn 1;\n      else\n\treturn mpz_cmpabs_d (x, d);\n    }\n}\n\n\f\n \nint\nmpz_sgn (const mpz_t u)\n{\n  return GMP_CMP (u->_mp_size, 0);\n}\n\nint\nmpz_cmp_si (const mpz_t u, long v)\n{\n  mp_size_t usize = u->_mp_size;\n\n  if (v >= 0)\n    return mpz_cmp_ui (u, v);\n  else if (usize >= 0)\n    return 1;\n  else\n    return - mpz_cmpabs_ui (u, GMP_NEG_CAST (unsigned long int, v));\n}\n\nint\nmpz_cmp_ui (const mpz_t u, unsigned long v)\n{\n  mp_size_t usize = u->_mp_size;\n\n  if (usize < 0)\n    return -1;\n  else\n    return mpz_cmpabs_ui (u, v);\n}\n\nint\nmpz_cmp (const mpz_t a, const mpz_t b)\n{\n  mp_size_t asize = a->_mp_size;\n  mp_size_t bsize = b->_mp_size;\n\n  if (asize != bsize)\n    return (asize < bsize) ? -1 : 1;\n  else if (asize >= 0)\n    return mpn_cmp (a->_mp_d, b->_mp_d, asize);\n  else\n    return mpn_cmp (b->_mp_d, a->_mp_d, -asize);\n}\n\nint\nmpz_cmpabs_ui (const mpz_t u, unsigned long v)\n{\n  mp_size_t un = GMP_ABS (u->_mp_size);\n\n  if (! mpn_absfits_ulong_p (u->_mp_d, un))\n    return 1;\n  else\n    {\n      unsigned long uu = mpz_get_ui (u);\n      return GMP_CMP(uu, v);\n    }\n}\n\nint\nmpz_cmpabs (const mpz_t u, const mpz_t v)\n{\n  return mpn_cmp4 (u->_mp_d, GMP_ABS (u->_mp_size),\n\t\t   v->_mp_d, GMP_ABS (v->_mp_size));\n}\n\nvoid\nmpz_abs (mpz_t r, const mpz_t u)\n{\n  mpz_set (r, u);\n  r->_mp_size = GMP_ABS (r->_mp_size);\n}\n\nvoid\nmpz_neg (mpz_t r, const mpz_t u)\n{\n  mpz_set (r, u);\n  r->_mp_size = -r->_mp_size;\n}\n\nvoid\nmpz_swap (mpz_t u, mpz_t v)\n{\n  MP_SIZE_T_SWAP (u->_mp_alloc, v->_mp_alloc);\n  MPN_PTR_SWAP (u->_mp_d, u->_mp_size, v->_mp_d, v->_mp_size);\n}\n\n\f\n \n\n\nvoid\nmpz_add_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  mpz_t bb;\n  mpz_init_set_ui (bb, b);\n  mpz_add (r, a, bb);\n  mpz_clear (bb);\n}\n\nvoid\nmpz_sub_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  mpz_ui_sub (r, b, a);\n  mpz_neg (r, r);\n}\n\nvoid\nmpz_ui_sub (mpz_t r, unsigned long a, const mpz_t b)\n{\n  mpz_neg (r, b);\n  mpz_add_ui (r, r, a);\n}\n\nstatic mp_size_t\nmpz_abs_add (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_size_t bn = GMP_ABS (b->_mp_size);\n  mp_ptr rp;\n  mp_limb_t cy;\n\n  if (an < bn)\n    {\n      MPZ_SRCPTR_SWAP (a, b);\n      MP_SIZE_T_SWAP (an, bn);\n    }\n\n  rp = MPZ_REALLOC (r, an + 1);\n  cy = mpn_add (rp, a->_mp_d, an, b->_mp_d, bn);\n\n  rp[an] = cy;\n\n  return an + cy;\n}\n\nstatic mp_size_t\nmpz_abs_sub (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_size_t bn = GMP_ABS (b->_mp_size);\n  int cmp;\n  mp_ptr rp;\n\n  cmp = mpn_cmp4 (a->_mp_d, an, b->_mp_d, bn);\n  if (cmp > 0)\n    {\n      rp = MPZ_REALLOC (r, an);\n      gmp_assert_nocarry (mpn_sub (rp, a->_mp_d, an, b->_mp_d, bn));\n      return mpn_normalized_size (rp, an);\n    }\n  else if (cmp < 0)\n    {\n      rp = MPZ_REALLOC (r, bn);\n      gmp_assert_nocarry (mpn_sub (rp, b->_mp_d, bn, a->_mp_d, an));\n      return -mpn_normalized_size (rp, bn);\n    }\n  else\n    return 0;\n}\n\nvoid\nmpz_add (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t rn;\n\n  if ( (a->_mp_size ^ b->_mp_size) >= 0)\n    rn = mpz_abs_add (r, a, b);\n  else\n    rn = mpz_abs_sub (r, a, b);\n\n  r->_mp_size = a->_mp_size >= 0 ? rn : - rn;\n}\n\nvoid\nmpz_sub (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t rn;\n\n  if ( (a->_mp_size ^ b->_mp_size) >= 0)\n    rn = mpz_abs_sub (r, a, b);\n  else\n    rn = mpz_abs_add (r, a, b);\n\n  r->_mp_size = a->_mp_size >= 0 ? rn : - rn;\n}\n\n\f\n \nvoid\nmpz_mul_si (mpz_t r, const mpz_t u, long int v)\n{\n  if (v < 0)\n    {\n      mpz_mul_ui (r, u, GMP_NEG_CAST (unsigned long int, v));\n      mpz_neg (r, r);\n    }\n  else\n    mpz_mul_ui (r, u, v);\n}\n\nvoid\nmpz_mul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t vv;\n  mpz_init_set_ui (vv, v);\n  mpz_mul (r, u, vv);\n  mpz_clear (vv);\n  return;\n}\n\nvoid\nmpz_mul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  int sign;\n  mp_size_t un, vn, rn;\n  mpz_t t;\n  mp_ptr tp;\n\n  un = u->_mp_size;\n  vn = v->_mp_size;\n\n  if (un == 0 || vn == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  sign = (un ^ vn) < 0;\n\n  un = GMP_ABS (un);\n  vn = GMP_ABS (vn);\n\n  mpz_init2 (t, (un + vn) * GMP_LIMB_BITS);\n\n  tp = t->_mp_d;\n  if (un >= vn)\n    mpn_mul (tp, u->_mp_d, un, v->_mp_d, vn);\n  else\n    mpn_mul (tp, v->_mp_d, vn, u->_mp_d, un);\n\n  rn = un + vn;\n  rn -= tp[rn-1] == 0;\n\n  t->_mp_size = sign ? - rn : rn;\n  mpz_swap (r, t);\n  mpz_clear (t);\n}\n\nvoid\nmpz_mul_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bits)\n{\n  mp_size_t un, rn;\n  mp_size_t limbs;\n  unsigned shift;\n  mp_ptr rp;\n\n  un = GMP_ABS (u->_mp_size);\n  if (un == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  limbs = bits / GMP_LIMB_BITS;\n  shift = bits % GMP_LIMB_BITS;\n\n  rn = un + limbs + (shift > 0);\n  rp = MPZ_REALLOC (r, rn);\n  if (shift > 0)\n    {\n      mp_limb_t cy = mpn_lshift (rp + limbs, u->_mp_d, un, shift);\n      rp[rn-1] = cy;\n      rn -= (cy == 0);\n    }\n  else\n    mpn_copyd (rp + limbs, u->_mp_d, un);\n\n  mpn_zero (rp, limbs);\n\n  r->_mp_size = (u->_mp_size < 0) ? - rn : rn;\n}\n\nvoid\nmpz_addmul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t t;\n  mpz_init_set_ui (t, v);\n  mpz_mul (t, u, t);\n  mpz_add (r, r, t);\n  mpz_clear (t);\n}\n\nvoid\nmpz_submul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t t;\n  mpz_init_set_ui (t, v);\n  mpz_mul (t, u, t);\n  mpz_sub (r, r, t);\n  mpz_clear (t);\n}\n\nvoid\nmpz_addmul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul (t, u, v);\n  mpz_add (r, r, t);\n  mpz_clear (t);\n}\n\nvoid\nmpz_submul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul (t, u, v);\n  mpz_sub (r, r, t);\n  mpz_clear (t);\n}\n\n\f\n \nenum mpz_div_round_mode { GMP_DIV_FLOOR, GMP_DIV_CEIL, GMP_DIV_TRUNC };\n\n \nstatic int\nmpz_div_qr (mpz_t q, mpz_t r,\n\t    const mpz_t n, const mpz_t d, enum mpz_div_round_mode mode)\n{\n  mp_size_t ns, ds, nn, dn, qs;\n  ns = n->_mp_size;\n  ds = d->_mp_size;\n\n  if (ds == 0)\n    gmp_die(\"mpz_div_qr: Divide by zero.\");\n\n  if (ns == 0)\n    {\n      if (q)\n\tq->_mp_size = 0;\n      if (r)\n\tr->_mp_size = 0;\n      return 0;\n    }\n\n  nn = GMP_ABS (ns);\n  dn = GMP_ABS (ds);\n\n  qs = ds ^ ns;\n\n  if (nn < dn)\n    {\n      if (mode == GMP_DIV_CEIL && qs >= 0)\n\t{\n\t   \n\t  if (r)\n\t    mpz_sub (r, n, d);\n\t  if (q)\n\t    mpz_set_ui (q, 1);\n\t}\n      else if (mode == GMP_DIV_FLOOR && qs < 0)\n\t{\n\t   \n\t  if (r)\n\t    mpz_add (r, n, d);\n\t  if (q)\n\t    mpz_set_si (q, -1);\n\t}\n      else\n\t{\n\t   \n\t  if (r)\n\t    mpz_set (r, n);\n\t  if (q)\n\t    q->_mp_size = 0;\n\t}\n      return 1;\n    }\n  else\n    {\n      mp_ptr np, qp;\n      mp_size_t qn, rn;\n      mpz_t tq, tr;\n\n      mpz_init_set (tr, n);\n      np = tr->_mp_d;\n\n      qn = nn - dn + 1;\n\n      if (q)\n\t{\n\t  mpz_init2 (tq, qn * GMP_LIMB_BITS);\n\t  qp = tq->_mp_d;\n\t}\n      else\n\tqp = NULL;\n\n      mpn_div_qr (qp, np, nn, d->_mp_d, dn);\n\n      if (qp)\n\t{\n\t  qn -= (qp[qn-1] == 0);\n\n\t  tq->_mp_size = qs < 0 ? -qn : qn;\n\t}\n      rn = mpn_normalized_size (np, dn);\n      tr->_mp_size = ns < 0 ? - rn : rn;\n\n      if (mode == GMP_DIV_FLOOR && qs < 0 && rn != 0)\n\t{\n\t  if (q)\n\t    mpz_sub_ui (tq, tq, 1);\n\t  if (r)\n\t    mpz_add (tr, tr, d);\n\t}\n      else if (mode == GMP_DIV_CEIL && qs >= 0 && rn != 0)\n\t{\n\t  if (q)\n\t    mpz_add_ui (tq, tq, 1);\n\t  if (r)\n\t    mpz_sub (tr, tr, d);\n\t}\n\n      if (q)\n\t{\n\t  mpz_swap (tq, q);\n\t  mpz_clear (tq);\n\t}\n      if (r)\n\tmpz_swap (tr, r);\n\n      mpz_clear (tr);\n\n      return rn != 0;\n    }\n}\n\nvoid\nmpz_cdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_CEIL);\n}\n\nvoid\nmpz_fdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_FLOOR);\n}\n\nvoid\nmpz_tdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_TRUNC);\n}\n\nvoid\nmpz_cdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_CEIL);\n}\n\nvoid\nmpz_fdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_FLOOR);\n}\n\nvoid\nmpz_tdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC);\n}\n\nvoid\nmpz_cdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_CEIL);\n}\n\nvoid\nmpz_fdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_FLOOR);\n}\n\nvoid\nmpz_tdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_TRUNC);\n}\n\nvoid\nmpz_mod (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, d->_mp_size >= 0 ? GMP_DIV_FLOOR : GMP_DIV_CEIL);\n}\n\nstatic void\nmpz_div_q_2exp (mpz_t q, const mpz_t u, mp_bitcnt_t bit_index,\n\t\tenum mpz_div_round_mode mode)\n{\n  mp_size_t un, qn;\n  mp_size_t limb_cnt;\n  mp_ptr qp;\n  int adjust;\n\n  un = u->_mp_size;\n  if (un == 0)\n    {\n      q->_mp_size = 0;\n      return;\n    }\n  limb_cnt = bit_index / GMP_LIMB_BITS;\n  qn = GMP_ABS (un) - limb_cnt;\n  bit_index %= GMP_LIMB_BITS;\n\n  if (mode == ((un > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR))  \n     \n    adjust = (qn <= 0\n\t      || !mpn_zero_p (u->_mp_d, limb_cnt)\n\t      || (u->_mp_d[limb_cnt]\n\t\t  & (((mp_limb_t) 1 << bit_index) - 1)));\n  else\n    adjust = 0;\n\n  if (qn <= 0)\n    qn = 0;\n  else\n    {\n      qp = MPZ_REALLOC (q, qn);\n\n      if (bit_index != 0)\n\t{\n\t  mpn_rshift (qp, u->_mp_d + limb_cnt, qn, bit_index);\n\t  qn -= qp[qn - 1] == 0;\n\t}\n      else\n\t{\n\t  mpn_copyi (qp, u->_mp_d + limb_cnt, qn);\n\t}\n    }\n\n  q->_mp_size = qn;\n\n  if (adjust)\n    mpz_add_ui (q, q, 1);\n  if (un < 0)\n    mpz_neg (q, q);\n}\n\nstatic void\nmpz_div_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bit_index,\n\t\tenum mpz_div_round_mode mode)\n{\n  mp_size_t us, un, rn;\n  mp_ptr rp;\n  mp_limb_t mask;\n\n  us = u->_mp_size;\n  if (us == 0 || bit_index == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n  rn = (bit_index + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  assert (rn > 0);\n\n  rp = MPZ_REALLOC (r, rn);\n  un = GMP_ABS (us);\n\n  mask = GMP_LIMB_MAX >> (rn * GMP_LIMB_BITS - bit_index);\n\n  if (rn > un)\n    {\n       \n      if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR))  \n\t{\n\t   \n\t  mp_size_t i;\n\n\t  gmp_assert_nocarry (! mpn_neg (rp, u->_mp_d, un));\n\t  for (i = un; i < rn - 1; i++)\n\t    rp[i] = GMP_LIMB_MAX;\n\n\t  rp[rn-1] = mask;\n\t  us = -us;\n\t}\n      else\n\t{\n\t   \n\t  if (r != u)\n\t    mpn_copyi (rp, u->_mp_d, un);\n\n\t  rn = un;\n\t}\n    }\n  else\n    {\n      if (r != u)\n\tmpn_copyi (rp, u->_mp_d, rn - 1);\n\n      rp[rn-1] = u->_mp_d[rn-1] & mask;\n\n      if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR))  \n\t{\n\t   \n\t  mpn_neg (rp, rp, rn);\n\n\t  rp[rn-1] &= mask;\n\n\t   \n\t  us = -us;\n\t}\n    }\n  rn = mpn_normalized_size (rp, rn);\n  r->_mp_size = us < 0 ? -rn : rn;\n}\n\nvoid\nmpz_cdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_CEIL);\n}\n\nvoid\nmpz_fdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_FLOOR);\n}\n\nvoid\nmpz_tdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_TRUNC);\n}\n\nvoid\nmpz_cdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_CEIL);\n}\n\nvoid\nmpz_fdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_FLOOR);\n}\n\nvoid\nmpz_tdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_TRUNC);\n}\n\nvoid\nmpz_divexact (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  gmp_assert_nocarry (mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC));\n}\n\nint\nmpz_divisible_p (const mpz_t n, const mpz_t d)\n{\n  return mpz_div_qr (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;\n}\n\nint\nmpz_congruent_p (const mpz_t a, const mpz_t b, const mpz_t m)\n{\n  mpz_t t;\n  int res;\n\n   \n  if (mpz_sgn (m) == 0)\n    return (mpz_cmp (a, b) == 0);\n\n  mpz_init (t);\n  mpz_sub (t, a, b);\n  res = mpz_divisible_p (t, m);\n  mpz_clear (t);\n\n  return res;\n}\n\nstatic unsigned long\nmpz_div_qr_ui (mpz_t q, mpz_t r,\n\t       const mpz_t n, unsigned long d, enum mpz_div_round_mode mode)\n{\n  unsigned long ret;\n  mpz_t rr, dd;\n\n  mpz_init (rr);\n  mpz_init_set_ui (dd, d);\n  mpz_div_qr (q, rr, n, dd, mode);\n  mpz_clear (dd);\n  ret = mpz_get_ui (rr);\n\n  if (r)\n    mpz_swap (r, rr);\n  mpz_clear (rr);\n\n  return ret;\n}\n\nunsigned long\nmpz_cdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_CEIL);\n}\n\nunsigned long\nmpz_fdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_FLOOR);\n}\n\nunsigned long\nmpz_tdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_TRUNC);\n}\n\nunsigned long\nmpz_cdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_CEIL);\n}\n\nunsigned long\nmpz_fdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_FLOOR);\n}\n\nunsigned long\nmpz_tdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC);\n}\n\nunsigned long\nmpz_cdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_CEIL);\n}\nunsigned long\nmpz_fdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);\n}\nunsigned long\nmpz_tdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_TRUNC);\n}\n\nunsigned long\nmpz_cdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_CEIL);\n}\n\nunsigned long\nmpz_fdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_FLOOR);\n}\n\nunsigned long\nmpz_tdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC);\n}\n\nunsigned long\nmpz_mod_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);\n}\n\nvoid\nmpz_divexact_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  gmp_assert_nocarry (mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC));\n}\n\nint\nmpz_divisible_ui_p (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;\n}\n\n\f\n \nstatic mp_limb_t\nmpn_gcd_11 (mp_limb_t u, mp_limb_t v)\n{\n  unsigned shift;\n\n  assert ( (u | v) > 0);\n\n  if (u == 0)\n    return v;\n  else if (v == 0)\n    return u;\n\n  gmp_ctz (shift, u | v);\n\n  u >>= shift;\n  v >>= shift;\n\n  if ( (u & 1) == 0)\n    MP_LIMB_T_SWAP (u, v);\n\n  while ( (v & 1) == 0)\n    v >>= 1;\n\n  while (u != v)\n    {\n      if (u > v)\n\t{\n\t  u -= v;\n\t  do\n\t    u >>= 1;\n\t  while ( (u & 1) == 0);\n\t}\n      else\n\t{\n\t  v -= u;\n\t  do\n\t    v >>= 1;\n\t  while ( (v & 1) == 0);\n\t}\n    }\n  return u << shift;\n}\n\nunsigned long\nmpz_gcd_ui (mpz_t g, const mpz_t u, unsigned long v)\n{\n  mpz_t t;\n  mpz_init_set_ui(t, v);\n  mpz_gcd (t, u, t);\n  if (v > 0)\n    v = mpz_get_ui (t);\n\n  if (g)\n    mpz_swap (t, g);\n\n  mpz_clear (t);\n\n  return v;\n}\n\nstatic mp_bitcnt_t\nmpz_make_odd (mpz_t r)\n{\n  mp_bitcnt_t shift;\n\n  assert (r->_mp_size > 0);\n   \n  shift = mpn_scan1 (r->_mp_d, 0);\n  mpz_tdiv_q_2exp (r, r, shift);\n\n  return shift;\n}\n\nvoid\nmpz_gcd (mpz_t g, const mpz_t u, const mpz_t v)\n{\n  mpz_t tu, tv;\n  mp_bitcnt_t uz, vz, gz;\n\n  if (u->_mp_size == 0)\n    {\n      mpz_abs (g, v);\n      return;\n    }\n  if (v->_mp_size == 0)\n    {\n      mpz_abs (g, u);\n      return;\n    }\n\n  mpz_init (tu);\n  mpz_init (tv);\n\n  mpz_abs (tu, u);\n  uz = mpz_make_odd (tu);\n  mpz_abs (tv, v);\n  vz = mpz_make_odd (tv);\n  gz = GMP_MIN (uz, vz);\n\n  if (tu->_mp_size < tv->_mp_size)\n    mpz_swap (tu, tv);\n\n  mpz_tdiv_r (tu, tu, tv);\n  if (tu->_mp_size == 0)\n    {\n      mpz_swap (g, tv);\n    }\n  else\n    for (;;)\n      {\n\tint c;\n\n\tmpz_make_odd (tu);\n\tc = mpz_cmp (tu, tv);\n\tif (c == 0)\n\t  {\n\t    mpz_swap (g, tu);\n\t    break;\n\t  }\n\tif (c < 0)\n\t  mpz_swap (tu, tv);\n\n\tif (tv->_mp_size == 1)\n\t  {\n\t    mp_limb_t *gp;\n\n\t    mpz_tdiv_r (tu, tu, tv);\n\t    gp = MPZ_REALLOC (g, 1);  \n\t    *gp = mpn_gcd_11 (tu->_mp_d[0], tv->_mp_d[0]);\n\n\t    g->_mp_size = *gp != 0;  \n\t    break;\n\t  }\n\tmpz_sub (tu, tu, tv);\n      }\n  mpz_clear (tu);\n  mpz_clear (tv);\n  mpz_mul_2exp (g, g, gz);\n}\n\nvoid\nmpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)\n{\n  mpz_t tu, tv, s0, s1, t0, t1;\n  mp_bitcnt_t uz, vz, gz;\n  mp_bitcnt_t power;\n\n  if (u->_mp_size == 0)\n    {\n       \n      signed long sign = mpz_sgn (v);\n      mpz_abs (g, v);\n      if (s)\n\ts->_mp_size = 0;\n      if (t)\n\tmpz_set_si (t, sign);\n      return;\n    }\n\n  if (v->_mp_size == 0)\n    {\n       \n      signed long sign = mpz_sgn (u);\n      mpz_abs (g, u);\n      if (s)\n\tmpz_set_si (s, sign);\n      if (t)\n\tt->_mp_size = 0;\n      return;\n    }\n\n  mpz_init (tu);\n  mpz_init (tv);\n  mpz_init (s0);\n  mpz_init (s1);\n  mpz_init (t0);\n  mpz_init (t1);\n\n  mpz_abs (tu, u);\n  uz = mpz_make_odd (tu);\n  mpz_abs (tv, v);\n  vz = mpz_make_odd (tv);\n  gz = GMP_MIN (uz, vz);\n\n  uz -= gz;\n  vz -= gz;\n\n   \n  if (tu->_mp_size < tv->_mp_size)\n    {\n      mpz_swap (tu, tv);\n      MPZ_SRCPTR_SWAP (u, v);\n      MPZ_PTR_SWAP (s, t);\n      MP_BITCNT_T_SWAP (uz, vz);\n    }\n\n   \n\n   \n\n  mpz_tdiv_qr (t1, tu, tu, tv);\n  mpz_mul_2exp (t1, t1, uz);\n\n  mpz_setbit (s1, vz);\n  power = uz + vz;\n\n  if (tu->_mp_size > 0)\n    {\n      mp_bitcnt_t shift;\n      shift = mpz_make_odd (tu);\n      mpz_setbit (t0, uz + shift);\n      power += shift;\n\n      for (;;)\n\t{\n\t  int c;\n\t  c = mpz_cmp (tu, tv);\n\t  if (c == 0)\n\t    break;\n\n\t  if (c < 0)\n\t    {\n\t       \n\n\t      mpz_sub (tv, tv, tu);\n\t      mpz_add (t0, t0, t1);\n\t      mpz_add (s0, s0, s1);\n\n\t      shift = mpz_make_odd (tv);\n\t      mpz_mul_2exp (t1, t1, shift);\n\t      mpz_mul_2exp (s1, s1, shift);\n\t    }\n\t  else\n\t    {\n\t      mpz_sub (tu, tu, tv);\n\t      mpz_add (t1, t0, t1);\n\t      mpz_add (s1, s0, s1);\n\n\t      shift = mpz_make_odd (tu);\n\t      mpz_mul_2exp (t0, t0, shift);\n\t      mpz_mul_2exp (s0, s0, shift);\n\t    }\n\t  power += shift;\n\t}\n    }\n  else\n    mpz_setbit (t0, uz);\n\n   \n\n  mpz_mul_2exp (tv, tv, gz);\n  mpz_neg (s0, s0);\n\n   \n\n  mpz_divexact (s1, v, tv);\n  mpz_abs (s1, s1);\n  mpz_divexact (t1, u, tv);\n  mpz_abs (t1, t1);\n\n  while (power-- > 0)\n    {\n       \n      if (mpz_odd_p (s0) || mpz_odd_p (t0))\n\t{\n\t  mpz_sub (s0, s0, s1);\n\t  mpz_add (t0, t0, t1);\n\t}\n      assert (mpz_even_p (t0) && mpz_even_p (s0));\n      mpz_tdiv_q_2exp (s0, s0, 1);\n      mpz_tdiv_q_2exp (t0, t0, 1);\n    }\n\n   \n  mpz_add (s1, s0, s1);\n  if (mpz_cmpabs (s0, s1) > 0)\n    {\n      mpz_swap (s0, s1);\n      mpz_sub (t0, t0, t1);\n    }\n  if (u->_mp_size < 0)\n    mpz_neg (s0, s0);\n  if (v->_mp_size < 0)\n    mpz_neg (t0, t0);\n\n  mpz_swap (g, tv);\n  if (s)\n    mpz_swap (s, s0);\n  if (t)\n    mpz_swap (t, t0);\n\n  mpz_clear (tu);\n  mpz_clear (tv);\n  mpz_clear (s0);\n  mpz_clear (s1);\n  mpz_clear (t0);\n  mpz_clear (t1);\n}\n\nvoid\nmpz_lcm (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t g;\n\n  if (u->_mp_size == 0 || v->_mp_size == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  mpz_init (g);\n\n  mpz_gcd (g, u, v);\n  mpz_divexact (g, u, g);\n  mpz_mul (r, g, v);\n\n  mpz_clear (g);\n  mpz_abs (r, r);\n}\n\nvoid\nmpz_lcm_ui (mpz_t r, const mpz_t u, unsigned long v)\n{\n  if (v == 0 || u->_mp_size == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  v /= mpz_gcd_ui (NULL, u, v);\n  mpz_mul_ui (r, u, v);\n\n  mpz_abs (r, r);\n}\n\nint\nmpz_invert (mpz_t r, const mpz_t u, const mpz_t m)\n{\n  mpz_t g, tr;\n  int invertible;\n\n  if (u->_mp_size == 0 || mpz_cmpabs_ui (m, 1) <= 0)\n    return 0;\n\n  mpz_init (g);\n  mpz_init (tr);\n\n  mpz_gcdext (g, tr, NULL, u, m);\n  invertible = (mpz_cmp_ui (g, 1) == 0);\n\n  if (invertible)\n    {\n      if (tr->_mp_size < 0)\n\t{\n\t  if (m->_mp_size >= 0)\n\t    mpz_add (tr, tr, m);\n\t  else\n\t    mpz_sub (tr, tr, m);\n\t}\n      mpz_swap (r, tr);\n    }\n\n  mpz_clear (g);\n  mpz_clear (tr);\n  return invertible;\n}\n\n\f\n \n\nvoid\nmpz_pow_ui (mpz_t r, const mpz_t b, unsigned long e)\n{\n  unsigned long bit;\n  mpz_t tr;\n  mpz_init_set_ui (tr, 1);\n\n  bit = GMP_ULONG_HIGHBIT;\n  do\n    {\n      mpz_mul (tr, tr, tr);\n      if (e & bit)\n\tmpz_mul (tr, tr, b);\n      bit >>= 1;\n    }\n  while (bit > 0);\n\n  mpz_swap (r, tr);\n  mpz_clear (tr);\n}\n\nvoid\nmpz_ui_pow_ui (mpz_t r, unsigned long blimb, unsigned long e)\n{\n  mpz_t b;\n\n  mpz_init_set_ui (b, blimb);\n  mpz_pow_ui (r, b, e);\n  mpz_clear (b);\n}\n\nvoid\nmpz_powm (mpz_t r, const mpz_t b, const mpz_t e, const mpz_t m)\n{\n  mpz_t tr;\n  mpz_t base;\n  mp_size_t en, mn;\n  mp_srcptr mp;\n  struct gmp_div_inverse minv;\n  unsigned shift;\n  mp_ptr tp = NULL;\n\n  en = GMP_ABS (e->_mp_size);\n  mn = GMP_ABS (m->_mp_size);\n  if (mn == 0)\n    gmp_die (\"mpz_powm: Zero modulo.\");\n\n  if (en == 0)\n    {\n      mpz_set_ui (r, mpz_cmpabs_ui (m, 1));\n      return;\n    }\n\n  mp = m->_mp_d;\n  mpn_div_qr_invert (&minv, mp, mn);\n  shift = minv.shift;\n\n  if (shift > 0)\n    {\n       \n      minv.shift = 0;\n\n      tp = gmp_alloc_limbs (mn);\n      gmp_assert_nocarry (mpn_lshift (tp, mp, mn, shift));\n      mp = tp;\n    }\n\n  mpz_init (base);\n\n  if (e->_mp_size < 0)\n    {\n      if (!mpz_invert (base, b, m))\n\tgmp_die (\"mpz_powm: Negative exponent and non-invertible base.\");\n    }\n  else\n    {\n      mp_size_t bn;\n      mpz_abs (base, b);\n\n      bn = base->_mp_size;\n      if (bn >= mn)\n\t{\n\t  mpn_div_qr_preinv (NULL, base->_mp_d, base->_mp_size, mp, mn, &minv);\n\t  bn = mn;\n\t}\n\n       \n      if (b->_mp_size < 0)\n\t{\n\t  mp_ptr bp = MPZ_REALLOC (base, mn);\n\t  gmp_assert_nocarry (mpn_sub (bp, mp, mn, bp, bn));\n\t  bn = mn;\n\t}\n      base->_mp_size = mpn_normalized_size (base->_mp_d, bn);\n    }\n  mpz_init_set_ui (tr, 1);\n\n  while (--en >= 0)\n    {\n      mp_limb_t w = e->_mp_d[en];\n      mp_limb_t bit;\n\n      bit = GMP_LIMB_HIGHBIT;\n      do\n\t{\n\t  mpz_mul (tr, tr, tr);\n\t  if (w & bit)\n\t    mpz_mul (tr, tr, base);\n\t  if (tr->_mp_size > mn)\n\t    {\n\t      mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);\n\t      tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);\n\t    }\n\t  bit >>= 1;\n\t}\n      while (bit > 0);\n    }\n\n   \n  if (tr->_mp_size >= mn)\n    {\n      minv.shift = shift;\n      mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);\n      tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);\n    }\n  if (tp)\n    gmp_free_limbs (tp, mn);\n\n  mpz_swap (r, tr);\n  mpz_clear (tr);\n  mpz_clear (base);\n}\n\nvoid\nmpz_powm_ui (mpz_t r, const mpz_t b, unsigned long elimb, const mpz_t m)\n{\n  mpz_t e;\n\n  mpz_init_set_ui (e, elimb);\n  mpz_powm (r, b, e, m);\n  mpz_clear (e);\n}\n\n \nvoid\nmpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, unsigned long z)\n{\n  int sgn;\n  mp_bitcnt_t bc;\n  mpz_t t, u;\n\n  sgn = y->_mp_size < 0;\n  if ((~z & sgn) != 0)\n    gmp_die (\"mpz_rootrem: Negative argument, with even root.\");\n  if (z == 0)\n    gmp_die (\"mpz_rootrem: Zeroth root.\");\n\n  if (mpz_cmpabs_ui (y, 1) <= 0) {\n    if (x)\n      mpz_set (x, y);\n    if (r)\n      r->_mp_size = 0;\n    return;\n  }\n\n  mpz_init (u);\n  mpz_init (t);\n  bc = (mpz_sizeinbase (y, 2) - 1) / z + 1;\n  mpz_setbit (t, bc);\n\n  if (z == 2)  \n    do {\n      mpz_swap (u, t);\t\t\t \n      mpz_tdiv_q (t, y, u);\t\t \n      mpz_add (t, t, u);\t\t \n      mpz_tdiv_q_2exp (t, t, 1);\t \n    } while (mpz_cmpabs (t, u) < 0);\t \n  else   {\n    mpz_t v;\n\n    mpz_init (v);\n    if (sgn)\n      mpz_neg (t, t);\n\n    do {\n      mpz_swap (u, t);\t\t\t \n      mpz_pow_ui (t, u, z - 1);\t\t \n      mpz_tdiv_q (t, y, t);\t\t \n      mpz_mul_ui (v, u, z - 1);\t\t \n      mpz_add (t, t, v);\t\t \n      mpz_tdiv_q_ui (t, t, z);\t\t \n    } while (mpz_cmpabs (t, u) < 0);\t \n\n    mpz_clear (v);\n  }\n\n  if (r) {\n    mpz_pow_ui (t, u, z);\n    mpz_sub (r, y, t);\n  }\n  if (x)\n    mpz_swap (x, u);\n  mpz_clear (u);\n  mpz_clear (t);\n}\n\nint\nmpz_root (mpz_t x, const mpz_t y, unsigned long z)\n{\n  int res;\n  mpz_t r;\n\n  mpz_init (r);\n  mpz_rootrem (x, r, y, z);\n  res = r->_mp_size == 0;\n  mpz_clear (r);\n\n  return res;\n}\n\n \nvoid\nmpz_sqrtrem (mpz_t s, mpz_t r, const mpz_t u)\n{\n  mpz_rootrem (s, r, u, 2);\n}\n\nvoid\nmpz_sqrt (mpz_t s, const mpz_t u)\n{\n  mpz_rootrem (s, NULL, u, 2);\n}\n\nint\nmpz_perfect_square_p (const mpz_t u)\n{\n  if (u->_mp_size <= 0)\n    return (u->_mp_size == 0);\n  else\n    return mpz_root (NULL, u, 2);\n}\n\nint\nmpn_perfect_square_p (mp_srcptr p, mp_size_t n)\n{\n  mpz_t t;\n\n  assert (n > 0);\n  assert (p [n-1] != 0);\n  return mpz_root (NULL, mpz_roinit_normal_n (t, p, n), 2);\n}\n\nmp_size_t\nmpn_sqrtrem (mp_ptr sp, mp_ptr rp, mp_srcptr p, mp_size_t n)\n{\n  mpz_t s, r, u;\n  mp_size_t res;\n\n  assert (n > 0);\n  assert (p [n-1] != 0);\n\n  mpz_init (r);\n  mpz_init (s);\n  mpz_rootrem (s, r, mpz_roinit_normal_n (u, p, n), 2);\n\n  assert (s->_mp_size == (n+1)/2);\n  mpn_copyd (sp, s->_mp_d, s->_mp_size);\n  mpz_clear (s);\n  res = r->_mp_size;\n  if (rp)\n    mpn_copyd (rp, r->_mp_d, res);\n  mpz_clear (r);\n  return res;\n}\n\f\n \n\nvoid\nmpz_mfac_uiui (mpz_t x, unsigned long n, unsigned long m)\n{\n  mpz_set_ui (x, n + (n == 0));\n  if (m + 1 < 2) return;\n  while (n > m + 1)\n    mpz_mul_ui (x, x, n -= m);\n}\n\nvoid\nmpz_2fac_ui (mpz_t x, unsigned long n)\n{\n  mpz_mfac_uiui (x, n, 2);\n}\n\nvoid\nmpz_fac_ui (mpz_t x, unsigned long n)\n{\n  mpz_mfac_uiui (x, n, 1);\n}\n\nvoid\nmpz_bin_uiui (mpz_t r, unsigned long n, unsigned long k)\n{\n  mpz_t t;\n\n  mpz_set_ui (r, k <= n);\n\n  if (k > (n >> 1))\n    k = (k <= n) ? n - k : 0;\n\n  mpz_init (t);\n  mpz_fac_ui (t, k);\n\n  for (; k > 0; --k)\n    mpz_mul_ui (r, r, n--);\n\n  mpz_divexact (r, r, t);\n  mpz_clear (t);\n}\n\n\f\n \n\n \n \nstatic int\ngmp_jacobi_coprime (mp_limb_t a, mp_limb_t b)\n{\n  int c, bit = 0;\n\n  assert (b & 1);\n  assert (a != 0);\n   \n\n   \n  b >>= 1;\n\n  gmp_ctz(c, a);\n  a >>= 1;\n\n  for (;;)\n    {\n      a >>= c;\n       \n      bit ^= c & (b ^ (b >> 1));\n      if (a < b)\n\t{\n\t  if (a == 0)\n\t    return bit & 1 ? -1 : 1;\n\t  bit ^= a & b;\n\t  a = b - a;\n\t  b -= a;\n\t}\n      else\n\t{\n\t  a -= b;\n\t  assert (a != 0);\n\t}\n\n      gmp_ctz(c, a);\n      ++c;\n    }\n}\n\nstatic void\ngmp_lucas_step_k_2k (mpz_t V, mpz_t Qk, const mpz_t n)\n{\n  mpz_mod (Qk, Qk, n);\n   \n  mpz_mul (V, V, V);\n  mpz_submul_ui (V, Qk, 2);\n  mpz_tdiv_r (V, V, n);\n   \n  mpz_mul (Qk, Qk, Qk);\n}\n\n \n \n \n \nstatic int\ngmp_lucas_mod (mpz_t V, mpz_t Qk, long Q,\n\t       mp_bitcnt_t b0, const mpz_t n)\n{\n  mp_bitcnt_t bs;\n  mpz_t U;\n  int res;\n\n  assert (b0 > 0);\n  assert (Q <= - (LONG_MIN / 2));\n  assert (Q >= - (LONG_MAX / 2));\n  assert (mpz_cmp_ui (n, 4) > 0);\n  assert (mpz_odd_p (n));\n\n  mpz_init_set_ui (U, 1);  \n  mpz_set_ui (V, 1);  \n  mpz_set_si (Qk, Q);\n\n  for (bs = mpz_sizeinbase (n, 2) - 1; --bs >= b0;)\n    {\n       \n      mpz_mul (U, U, V);\n       \n       \n      gmp_lucas_step_k_2k (V, Qk, n);\n\n       \n       \n       \n      if (b0 == bs || mpz_tstbit (n, bs))\n\t{\n\t   \n\t  mpz_mul_si (Qk, Qk, Q);\n\t   \n\t  mpz_swap (U, V);  \n\t  mpz_add (U, U, V);\n\t   \n\t   \n\t  if (mpz_odd_p (U))\n\t    mpz_add (U, U, n);\n\t  mpz_tdiv_q_2exp (U, U, 1);\n\t   \n\t  mpz_mul_si (V, V, -2*Q);\n\t  mpz_add (V, U, V);\n\t  mpz_tdiv_r (V, V, n);\n\t}\n      mpz_tdiv_r (U, U, n);\n    }\n\n  res = U->_mp_size == 0;\n  mpz_clear (U);\n  return res;\n}\n\n \n \n \nstatic int\ngmp_stronglucas (const mpz_t x, mpz_t Qk)\n{\n  mp_bitcnt_t b0;\n  mpz_t V, n;\n  mp_limb_t maxD, D;  \n  long Q;\n  mp_limb_t tl;\n\n   \n  mpz_roinit_normal_n (n, x->_mp_d, GMP_ABS (x->_mp_size));\n\n  assert (mpz_odd_p (n));\n   \n  if (mpz_root (Qk, n, 2))\n    return 0;  \n\n   \n  maxD = (Qk->_mp_size == 1) ? Qk->_mp_d [0] - 1 : GMP_LIMB_MAX;\n\n  D = 3;\n   \n   \n  do\n    {\n      if (D >= maxD)\n\treturn 1 + (D != GMP_LIMB_MAX);  \n      D += 2;\n      tl = mpz_tdiv_ui (n, D);\n      if (tl == 0)\n\treturn 0;\n    }\n  while (gmp_jacobi_coprime (tl, D) == 1);\n\n  mpz_init (V);\n\n   \n  b0 = mpn_common_scan (~ n->_mp_d[0], 0, n->_mp_d, n->_mp_size, GMP_LIMB_MAX);\n   \n\n   \n  Q = (D & 2) ? (long) (D >> 2) + 1 : -(long) (D >> 2);\n\n  if (! gmp_lucas_mod (V, Qk, Q, b0, n))\t \n    while (V->_mp_size != 0 && --b0 != 0)\t \n       \n       \n      gmp_lucas_step_k_2k (V, Qk, n);\n\n  mpz_clear (V);\n  return (b0 != 0);\n}\n\nstatic int\ngmp_millerrabin (const mpz_t n, const mpz_t nm1, mpz_t y,\n\t\t const mpz_t q, mp_bitcnt_t k)\n{\n  assert (k > 0);\n\n   \n  mpz_powm (y, y, q, n);\n\n  if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)\n    return 1;\n\n  while (--k > 0)\n    {\n      mpz_powm_ui (y, y, 2, n);\n      if (mpz_cmp (y, nm1) == 0)\n\treturn 1;\n    }\n  return 0;\n}\n\n \n#define GMP_PRIME_PRODUCT \\\n  (3UL*5UL*7UL*11UL*13UL*17UL*19UL*23UL*29UL)\n\n \n#define GMP_PRIME_MASK 0xc96996dcUL\n\nint\nmpz_probab_prime_p (const mpz_t n, int reps)\n{\n  mpz_t nm1;\n  mpz_t q;\n  mpz_t y;\n  mp_bitcnt_t k;\n  int is_prime;\n  int j;\n\n   \n  if (mpz_even_p (n))\n    return (mpz_cmpabs_ui (n, 2) == 0) ? 2 : 0;\n\n   \n  assert (n->_mp_size != 0);\n\n  if (mpz_cmpabs_ui (n, 64) < 0)\n    return (GMP_PRIME_MASK >> (n->_mp_d[0] >> 1)) & 2;\n\n  if (mpz_gcd_ui (NULL, n, GMP_PRIME_PRODUCT) != 1)\n    return 0;\n\n   \n  if (mpz_cmpabs_ui (n, 31*31) < 0)\n    return 2;\n\n  mpz_init (nm1);\n  mpz_init (q);\n\n   \n  mpz_abs (nm1, n);\n  nm1->_mp_d[0] -= 1;\n   \n  k = mpn_scan1 (nm1->_mp_d, 0);\n  mpz_tdiv_q_2exp (q, nm1, k);\n\n   \n  mpz_init_set_ui (y, 2);\n  is_prime = gmp_millerrabin (n, nm1, y, q, k) && gmp_stronglucas (n, y);\n  reps -= 24;  \n\n   \n\n  for (j = 0; is_prime & (j < reps); j++)\n    {\n      mpz_set_ui (y, (unsigned long) j*j+j+41);\n      if (mpz_cmp (y, nm1) >= 0)\n\t{\n\t   \n\t  assert (j >= 30);\n\t  break;\n\t}\n      is_prime = gmp_millerrabin (n, nm1, y, q, k);\n    }\n  mpz_clear (nm1);\n  mpz_clear (q);\n  mpz_clear (y);\n\n  return is_prime;\n}\n\n\f\n \n\n \n\nint\nmpz_tstbit (const mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t limb_index;\n  unsigned shift;\n  mp_size_t ds;\n  mp_size_t dn;\n  mp_limb_t w;\n  int bit;\n\n  ds = d->_mp_size;\n  dn = GMP_ABS (ds);\n  limb_index = bit_index / GMP_LIMB_BITS;\n  if (limb_index >= dn)\n    return ds < 0;\n\n  shift = bit_index % GMP_LIMB_BITS;\n  w = d->_mp_d[limb_index];\n  bit = (w >> shift) & 1;\n\n  if (ds < 0)\n    {\n       \n      if (shift > 0 && (mp_limb_t) (w << (GMP_LIMB_BITS - shift)) > 0)\n\treturn bit ^ 1;\n      while (--limb_index >= 0)\n\tif (d->_mp_d[limb_index] > 0)\n\t  return bit ^ 1;\n    }\n  return bit;\n}\n\nstatic void\nmpz_abs_add_bit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dn, limb_index;\n  mp_limb_t bit;\n  mp_ptr dp;\n\n  dn = GMP_ABS (d->_mp_size);\n\n  limb_index = bit_index / GMP_LIMB_BITS;\n  bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);\n\n  if (limb_index >= dn)\n    {\n      mp_size_t i;\n       \n      dp = MPZ_REALLOC (d, limb_index + 1);\n\n      dp[limb_index] = bit;\n      for (i = dn; i < limb_index; i++)\n\tdp[i] = 0;\n      dn = limb_index + 1;\n    }\n  else\n    {\n      mp_limb_t cy;\n\n      dp = d->_mp_d;\n\n      cy = mpn_add_1 (dp + limb_index, dp + limb_index, dn - limb_index, bit);\n      if (cy > 0)\n\t{\n\t  dp = MPZ_REALLOC (d, dn + 1);\n\t  dp[dn++] = cy;\n\t}\n    }\n\n  d->_mp_size = (d->_mp_size < 0) ? - dn : dn;\n}\n\nstatic void\nmpz_abs_sub_bit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dn, limb_index;\n  mp_ptr dp;\n  mp_limb_t bit;\n\n  dn = GMP_ABS (d->_mp_size);\n  dp = d->_mp_d;\n\n  limb_index = bit_index / GMP_LIMB_BITS;\n  bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);\n\n  assert (limb_index < dn);\n\n  gmp_assert_nocarry (mpn_sub_1 (dp + limb_index, dp + limb_index,\n\t\t\t\t dn - limb_index, bit));\n  dn = mpn_normalized_size (dp, dn);\n  d->_mp_size = (d->_mp_size < 0) ? - dn : dn;\n}\n\nvoid\nmpz_setbit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (!mpz_tstbit (d, bit_index))\n    {\n      if (d->_mp_size >= 0)\n\tmpz_abs_add_bit (d, bit_index);\n      else\n\tmpz_abs_sub_bit (d, bit_index);\n    }\n}\n\nvoid\nmpz_clrbit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (mpz_tstbit (d, bit_index))\n    {\n      if (d->_mp_size >= 0)\n\tmpz_abs_sub_bit (d, bit_index);\n      else\n\tmpz_abs_add_bit (d, bit_index);\n    }\n}\n\nvoid\nmpz_combit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (mpz_tstbit (d, bit_index) ^ (d->_mp_size < 0))\n    mpz_abs_sub_bit (d, bit_index);\n  else\n    mpz_abs_add_bit (d, bit_index);\n}\n\nvoid\nmpz_com (mpz_t r, const mpz_t u)\n{\n  mpz_add_ui (r, u, 1);\n  mpz_neg (r, r);\n}\n\nvoid\nmpz_and (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, rn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc & vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n   \n  rn = vx ? un : vn;\n\n  rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = ( (ul & vl) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < rn; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = ( (ul & vx) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[rn++] = rc;\n  else\n    rn = mpn_normalized_size (rp, rn);\n\n  r->_mp_size = rx ? -rn : rn;\n}\n\nvoid\nmpz_ior (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, rn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      mpz_set (r, u);\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc | vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n   \n  rn = vx ? vn : un;\n\n  rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = ( (ul | vl) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < rn; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = ( (ul | vx) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[rn++] = rc;\n  else\n    rn = mpn_normalized_size (rp, rn);\n\n  r->_mp_size = rx ? -rn : rn;\n}\n\nvoid\nmpz_xor (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      mpz_set (r, u);\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc ^ vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  rp = MPZ_REALLOC (r, un + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = (ul ^ vl ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < un; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = (ul ^ ux) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[un++] = rc;\n  else\n    un = mpn_normalized_size (rp, un);\n\n  r->_mp_size = rx ? -un : un;\n}\n\nstatic unsigned\ngmp_popcount_limb (mp_limb_t x)\n{\n  unsigned c;\n\n   \n  int LOCAL_SHIFT_BITS = 16;\n  for (c = 0; x > 0;)\n    {\n      unsigned w = x - ((x >> 1) & 0x5555);\n      w = ((w >> 2) & 0x3333) + (w & 0x3333);\n      w =  (w >> 4) + w;\n      w = ((w >> 8) & 0x000f) + (w & 0x000f);\n      c += w;\n      if (GMP_LIMB_BITS > LOCAL_SHIFT_BITS)\n\tx >>= LOCAL_SHIFT_BITS;\n      else\n\tx = 0;\n    }\n  return c;\n}\n\nmp_bitcnt_t\nmpn_popcount (mp_srcptr p, mp_size_t n)\n{\n  mp_size_t i;\n  mp_bitcnt_t c;\n\n  for (c = 0, i = 0; i < n; i++)\n    c += gmp_popcount_limb (p[i]);\n\n  return c;\n}\n\nmp_bitcnt_t\nmpz_popcount (const mpz_t u)\n{\n  mp_size_t un;\n\n  un = u->_mp_size;\n\n  if (un < 0)\n    return ~(mp_bitcnt_t) 0;\n\n  return mpn_popcount (u->_mp_d, un);\n}\n\nmp_bitcnt_t\nmpz_hamdist (const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, i;\n  mp_limb_t uc, vc, ul, vl, comp;\n  mp_srcptr up, vp;\n  mp_bitcnt_t c;\n\n  un = u->_mp_size;\n  vn = v->_mp_size;\n\n  if ( (un ^ vn) < 0)\n    return ~(mp_bitcnt_t) 0;\n\n  comp = - (uc = vc = (un < 0));\n  if (uc)\n    {\n      assert (vn < 0);\n      un = -un;\n      vn = -vn;\n    }\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  if (un < vn)\n    MPN_SRCPTR_SWAP (up, un, vp, vn);\n\n  for (i = 0, c = 0; i < vn; i++)\n    {\n      ul = (up[i] ^ comp) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ comp) + vc;\n      vc = vl < vc;\n\n      c += gmp_popcount_limb (ul ^ vl);\n    }\n  assert (vc == 0);\n\n  for (; i < un; i++)\n    {\n      ul = (up[i] ^ comp) + uc;\n      uc = ul < uc;\n\n      c += gmp_popcount_limb (ul ^ comp);\n    }\n\n  return c;\n}\n\nmp_bitcnt_t\nmpz_scan1 (const mpz_t u, mp_bitcnt_t starting_bit)\n{\n  mp_ptr up;\n  mp_size_t us, un, i;\n  mp_limb_t limb, ux;\n\n  us = u->_mp_size;\n  un = GMP_ABS (us);\n  i = starting_bit / GMP_LIMB_BITS;\n\n   \n  if (i >= un)\n    return (us >= 0 ? ~(mp_bitcnt_t) 0 : starting_bit);\n\n  up = u->_mp_d;\n  ux = 0;\n  limb = up[i];\n\n  if (starting_bit != 0)\n    {\n      if (us < 0)\n\t{\n\t  ux = mpn_zero_p (up, i);\n\t  limb = ~ limb + ux;\n\t  ux = - (mp_limb_t) (limb >= ux);\n\t}\n\n       \n      limb &= GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS);\n    }\n\n  return mpn_common_scan (limb, i, up, un, ux);\n}\n\nmp_bitcnt_t\nmpz_scan0 (const mpz_t u, mp_bitcnt_t starting_bit)\n{\n  mp_ptr up;\n  mp_size_t us, un, i;\n  mp_limb_t limb, ux;\n\n  us = u->_mp_size;\n  ux = - (mp_limb_t) (us >= 0);\n  un = GMP_ABS (us);\n  i = starting_bit / GMP_LIMB_BITS;\n\n   \n  if (i >= un)\n    return (ux ? starting_bit : ~(mp_bitcnt_t) 0);\n\n  up = u->_mp_d;\n  limb = up[i] ^ ux;\n\n  if (ux == 0)\n    limb -= mpn_zero_p (up, i);  \n\n   \n  limb &= GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS);\n\n  return mpn_common_scan (limb, i, up, un, ux);\n}\n\n\f\n \n\nsize_t\nmpz_sizeinbase (const mpz_t u, int base)\n{\n  mp_size_t un, tn;\n  mp_srcptr up;\n  mp_ptr tp;\n  mp_bitcnt_t bits;\n  struct gmp_div_inverse bi;\n  size_t ndigits;\n\n  assert (base >= 2);\n  assert (base <= 62);\n\n  un = GMP_ABS (u->_mp_size);\n  if (un == 0)\n    return 1;\n\n  up = u->_mp_d;\n\n  bits = (un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1]);\n  switch (base)\n    {\n    case 2:\n      return bits;\n    case 4:\n      return (bits + 1) / 2;\n    case 8:\n      return (bits + 2) / 3;\n    case 16:\n      return (bits + 3) / 4;\n    case 32:\n      return (bits + 4) / 5;\n       \n    }\n\n  tp = gmp_alloc_limbs (un);\n  mpn_copyi (tp, up, un);\n  mpn_div_qr_1_invert (&bi, base);\n\n  tn = un;\n  ndigits = 0;\n  do\n    {\n      ndigits++;\n      mpn_div_qr_1_preinv (tp, tp, tn, &bi);\n      tn -= (tp[tn-1] == 0);\n    }\n  while (tn > 0);\n\n  gmp_free_limbs (tp, un);\n  return ndigits;\n}\n\nchar *\nmpz_get_str (char *sp, int base, const mpz_t u)\n{\n  unsigned bits;\n  const char *digits;\n  mp_size_t un;\n  size_t i, sn, osn;\n\n  digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  if (base > 1)\n    {\n      if (base <= 36)\n\tdigits = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n      else if (base > 62)\n\treturn NULL;\n    }\n  else if (base >= -1)\n    base = 10;\n  else\n    {\n      base = -base;\n      if (base > 36)\n\treturn NULL;\n    }\n\n  sn = 1 + mpz_sizeinbase (u, base);\n  if (!sp)\n    {\n      osn = 1 + sn;\n      sp = (char *) gmp_alloc (osn);\n    }\n  else\n    osn = 0;\n  un = GMP_ABS (u->_mp_size);\n\n  if (un == 0)\n    {\n      sp[0] = '0';\n      sn = 1;\n      goto ret;\n    }\n\n  i = 0;\n\n  if (u->_mp_size < 0)\n    sp[i++] = '-';\n\n  bits = mpn_base_power_of_two_p (base);\n\n  if (bits)\n     \n    sn = i + mpn_get_str_bits ((unsigned char *) sp + i, bits, u->_mp_d, un);\n  else\n    {\n      struct mpn_base_info info;\n      mp_ptr tp;\n\n      mpn_get_base_info (&info, base);\n      tp = gmp_alloc_limbs (un);\n      mpn_copyi (tp, u->_mp_d, un);\n\n      sn = i + mpn_get_str_other ((unsigned char *) sp + i, base, &info, tp, un);\n      gmp_free_limbs (tp, un);\n    }\n\n  for (; i < sn; i++)\n    sp[i] = digits[(unsigned char) sp[i]];\n\nret:\n  sp[sn] = '\\0';\n  if (osn && osn != sn + 1)\n    sp = (char*) gmp_realloc (sp, osn, sn + 1);\n  return sp;\n}\n\nint\nmpz_set_str (mpz_t r, const char *sp, int base)\n{\n  unsigned bits, value_of_a;\n  mp_size_t rn, alloc;\n  mp_ptr rp;\n  size_t dn, sn;\n  int sign;\n  unsigned char *dp;\n\n  assert (base == 0 || (base >= 2 && base <= 62));\n\n  while (isspace( (unsigned char) *sp))\n    sp++;\n\n  sign = (*sp == '-');\n  sp += sign;\n\n  if (base == 0)\n    {\n      if (sp[0] == '0')\n\t{\n\t  if (sp[1] == 'x' || sp[1] == 'X')\n\t    {\n\t      base = 16;\n\t      sp += 2;\n\t    }\n\t  else if (sp[1] == 'b' || sp[1] == 'B')\n\t    {\n\t      base = 2;\n\t      sp += 2;\n\t    }\n\t  else\n\t    base = 8;\n\t}\n      else\n\tbase = 10;\n    }\n\n  if (!*sp)\n    {\n      r->_mp_size = 0;\n      return -1;\n    }\n  sn = strlen(sp);\n  dp = (unsigned char *) gmp_alloc (sn);\n\n  value_of_a = (base > 36) ? 36 : 10;\n  for (dn = 0; *sp; sp++)\n    {\n      unsigned digit;\n\n      if (isspace ((unsigned char) *sp))\n\tcontinue;\n      else if (*sp >= '0' && *sp <= '9')\n\tdigit = *sp - '0';\n      else if (*sp >= 'a' && *sp <= 'z')\n\tdigit = *sp - 'a' + value_of_a;\n      else if (*sp >= 'A' && *sp <= 'Z')\n\tdigit = *sp - 'A' + 10;\n      else\n\tdigit = base;  \n\n      if (digit >= (unsigned) base)\n\t{\n\t  gmp_free (dp, sn);\n\t  r->_mp_size = 0;\n\t  return -1;\n\t}\n\n      dp[dn++] = digit;\n    }\n\n  if (!dn)\n    {\n      gmp_free (dp, sn);\n      r->_mp_size = 0;\n      return -1;\n    }\n  bits = mpn_base_power_of_two_p (base);\n\n  if (bits > 0)\n    {\n      alloc = (dn * bits + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n      rp = MPZ_REALLOC (r, alloc);\n      rn = mpn_set_str_bits (rp, dp, dn, bits);\n    }\n  else\n    {\n      struct mpn_base_info info;\n      mpn_get_base_info (&info, base);\n      alloc = (dn + info.exp - 1) / info.exp;\n      rp = MPZ_REALLOC (r, alloc);\n      rn = mpn_set_str_other (rp, dp, dn, base, &info);\n       \n      assert (rn > 0);\n      rn -= rp[rn-1] == 0;\n    }\n  assert (rn <= alloc);\n  gmp_free (dp, sn);\n\n  r->_mp_size = sign ? - rn : rn;\n\n  return 0;\n}\n\nint\nmpz_init_set_str (mpz_t r, const char *sp, int base)\n{\n  mpz_init (r);\n  return mpz_set_str (r, sp, base);\n}\n\nsize_t\nmpz_out_str (FILE *stream, int base, const mpz_t x)\n{\n  char *str;\n  size_t len, n;\n\n  str = mpz_get_str (NULL, base, x);\n  if (!str)\n    return 0;\n  len = strlen (str);\n  n = fwrite (str, 1, len, stream);\n  gmp_free (str, len + 1);\n  return n;\n}\n\n\f\nstatic int\ngmp_detect_endian (void)\n{\n  static const int i = 2;\n  const unsigned char *p = (const unsigned char *) &i;\n  return 1 - *p;\n}\n\n \nvoid\nmpz_import (mpz_t r, size_t count, int order, size_t size, int endian,\n\t    size_t nails, const void *src)\n{\n  const unsigned char *p;\n  ptrdiff_t word_step;\n  mp_ptr rp;\n  mp_size_t rn;\n\n   \n  mp_limb_t limb;\n   \n  size_t bytes;\n   \n  mp_size_t i;\n\n  if (nails != 0)\n    gmp_die (\"mpz_import: Nails not supported.\");\n\n  assert (order == 1 || order == -1);\n  assert (endian >= -1 && endian <= 1);\n\n  if (endian == 0)\n    endian = gmp_detect_endian ();\n\n  p = (unsigned char *) src;\n\n  word_step = (order != endian) ? 2 * size : 0;\n\n   \n  if (order == 1)\n    {\n      p += size * (count - 1);\n      word_step = - word_step;\n    }\n\n   \n  if (endian == 1)\n    p += (size - 1);\n\n  rn = (size * count + sizeof(mp_limb_t) - 1) / sizeof(mp_limb_t);\n  rp = MPZ_REALLOC (r, rn);\n\n  for (limb = 0, bytes = 0, i = 0; count > 0; count--, p += word_step)\n    {\n      size_t j;\n      for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)\n\t{\n\t  limb |= (mp_limb_t) *p << (bytes++ * CHAR_BIT);\n\t  if (bytes == sizeof(mp_limb_t))\n\t    {\n\t      rp[i++] = limb;\n\t      bytes = 0;\n\t      limb = 0;\n\t    }\n\t}\n    }\n  assert (i + (bytes > 0) == rn);\n  if (limb != 0)\n    rp[i++] = limb;\n  else\n    i = mpn_normalized_size (rp, i);\n\n  r->_mp_size = i;\n}\n\nvoid *\nmpz_export (void *r, size_t *countp, int order, size_t size, int endian,\n\t    size_t nails, const mpz_t u)\n{\n  size_t count;\n  mp_size_t un;\n\n  if (nails != 0)\n    gmp_die (\"mpz_export: Nails not supported.\");\n\n  assert (order == 1 || order == -1);\n  assert (endian >= -1 && endian <= 1);\n  assert (size > 0 || u->_mp_size == 0);\n\n  un = u->_mp_size;\n  count = 0;\n  if (un != 0)\n    {\n      size_t k;\n      unsigned char *p;\n      ptrdiff_t word_step;\n       \n      mp_limb_t limb;\n       \n      size_t bytes;\n       \n      mp_size_t i;\n\n      un = GMP_ABS (un);\n\n       \n      limb = u->_mp_d[un-1];\n      assert (limb != 0);\n\n      k = (GMP_LIMB_BITS <= CHAR_BIT);\n      if (!k)\n\t{\n\t  do {\n\t    int LOCAL_CHAR_BIT = CHAR_BIT;\n\t    k++; limb >>= LOCAL_CHAR_BIT;\n\t  } while (limb != 0);\n\t}\n       \n\n      count = (k + (un-1) * sizeof (mp_limb_t) + size - 1) / size;\n\n      if (!r)\n\tr = gmp_alloc (count * size);\n\n      if (endian == 0)\n\tendian = gmp_detect_endian ();\n\n      p = (unsigned char *) r;\n\n      word_step = (order != endian) ? 2 * size : 0;\n\n       \n      if (order == 1)\n\t{\n\t  p += size * (count - 1);\n\t  word_step = - word_step;\n\t}\n\n       \n      if (endian == 1)\n\tp += (size - 1);\n\n      for (bytes = 0, i = 0, k = 0; k < count; k++, p += word_step)\n\t{\n\t  size_t j;\n\t  for (j = 0; j < size; ++j, p -= (ptrdiff_t) endian)\n\t    {\n\t      if (sizeof (mp_limb_t) == 1)\n\t\t{\n\t\t  if (i < un)\n\t\t    *p = u->_mp_d[i++];\n\t\t  else\n\t\t    *p = 0;\n\t\t}\n\t      else\n\t\t{\n\t\t  int LOCAL_CHAR_BIT = CHAR_BIT;\n\t\t  if (bytes == 0)\n\t\t    {\n\t\t      if (i < un)\n\t\t\tlimb = u->_mp_d[i++];\n\t\t      bytes = sizeof (mp_limb_t);\n\t\t    }\n\t\t  *p = limb;\n\t\t  limb >>= LOCAL_CHAR_BIT;\n\t\t  bytes--;\n\t\t}\n\t    }\n\t}\n      assert (i == un);\n      assert (k == count);\n    }\n\n  if (countp)\n    *countp = count;\n\n  return r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}