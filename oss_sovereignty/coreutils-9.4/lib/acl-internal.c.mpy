{
  "module_name": "acl-internal.c",
  "hash_id": "8cb0a6b9bf124d69d220d0286ff70af6af37db3f30aee9d64dae4236fd1d6724",
  "original_prompt": "Ingested from coreutils-9.4/lib/acl-internal.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"acl.h\"\n\n#include \"acl-internal.h\"\n\n#if USE_ACL && HAVE_ACL_GET_FILE  \n\n# if HAVE_ACL_TYPE_EXTENDED  \n\n \nint\nacl_extended_nontrivial (acl_t acl)\n{\n   \n  return (acl_entries (acl) > 0);\n}\n\n# else  \n\n \nint\nacl_access_nontrivial (acl_t acl)\n{\n   \n#  if HAVE_ACL_FIRST_ENTRY  \n\n  acl_entry_t ace;\n  int got_one;\n\n  for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n       got_one > 0;\n       got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n    {\n      acl_tag_t tag;\n      if (acl_get_tag_type (ace, &tag) < 0)\n        return -1;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n    }\n  return got_one;\n\n#  elif HAVE_ACL_TO_SHORT_TEXT  \n   \n\n  int count = acl->acl_cnt;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      acl_entry_t ace = &acl->acl_entry[i];\n      acl_tag_t tag = ace->ae_tag;\n\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ\n            || tag == ACL_OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n\n#  elif HAVE_ACL_FREE_TEXT  \n   \n\n  int count = acl->acl_num;\n  acl_entry_t ace;\n\n  for (ace = acl->acl_first; count > 0; ace = ace->next, count--)\n    {\n      acl_tag_t tag;\n      acl_perm_t perm;\n\n      tag = ace->entry->acl_type;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n\n      perm = ace->entry->acl_perm;\n       \n      if ((perm & ~(ACL_READ | ACL_WRITE | ACL_EXECUTE)) != 0)\n        return 1;\n    }\n  return 0;\n\n#  else\n\n  errno = ENOSYS;\n  return -1;\n#  endif\n}\n\nint\nacl_default_nontrivial (acl_t acl)\n{\n   \n  return (acl_entries (acl) > 0);\n}\n\n# endif\n\n#elif USE_ACL && HAVE_FACL && defined GETACL  \n\n \nint\nacl_nontrivial (int count, aclent_t *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      aclent_t *ace = &entries[i];\n\n       \n      if (!(ace->a_type == USER_OBJ\n            || ace->a_type == GROUP_OBJ\n            || ace->a_type == OTHER_OBJ\n             \n            || ace->a_type == CLASS_OBJ))\n        return 1;\n    }\n  return 0;\n}\n\n# ifdef ACE_GETACL\n\n \n#  define NEW_ACE_WRITEA_DATA (NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA)\n\n \nint\nacl_ace_nontrivial (int count, ace_t *entries)\n{\n  int i;\n\n   \n  int old_convention = 0;\n\n  for (i = 0; i < count; i++)\n    if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n      {\n        old_convention = 1;\n        break;\n      }\n\n  if (old_convention)\n     \n    for (i = 0; i < count; i++)\n      {\n        ace_t *ace = &entries[i];\n\n         \n        if (!(ace->a_type == OLD_ALLOW\n              && (ace->a_flags == OLD_ACE_OWNER\n                  || ace->a_flags == OLD_ACE_GROUP\n                  || ace->a_flags == OLD_ACE_OTHER)))\n          return 1;\n      }\n  else\n    {\n       \n      unsigned int access_masks[6] =\n        {\n          0,  \n          0,  \n          0,  \n          0,  \n          0,  \n          0   \n        };\n\n      for (i = 0; i < count; i++)\n        {\n          ace_t *ace = &entries[i];\n          unsigned int index1;\n          unsigned int index2;\n\n          if (ace->a_type == NEW_ACE_ACCESS_ALLOWED_ACE_TYPE)\n            index1 = 1;\n          else if (ace->a_type == NEW_ACE_ACCESS_DENIED_ACE_TYPE)\n            index1 = 0;\n          else\n            return 1;\n\n          if (ace->a_flags == NEW_ACE_OWNER)\n            index2 = 0;\n          else if (ace->a_flags == (NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP))\n            index2 = 2;\n          else if (ace->a_flags == NEW_ACE_EVERYONE)\n            index2 = 4;\n          else\n            return 1;\n\n          access_masks[index1 + index2] |= ace->a_access_mask;\n        }\n\n       \n      if (access_masks[0] & access_masks[1])\n        return 1;\n      if (access_masks[2] & access_masks[3])\n        return 1;\n      if (access_masks[4] & access_masks[5])\n        return 1;\n\n       \n      if ((NEW_ACE_WRITE_NAMED_ATTRS\n           | NEW_ACE_WRITE_ATTRIBUTES\n           | NEW_ACE_WRITE_ACL\n           | NEW_ACE_WRITE_OWNER)\n          & ~ access_masks[1])\n        return 1;\n      access_masks[1] &= ~(NEW_ACE_WRITE_NAMED_ATTRS\n                           | NEW_ACE_WRITE_ATTRIBUTES\n                           | NEW_ACE_WRITE_ACL\n                           | NEW_ACE_WRITE_OWNER);\n      if ((NEW_ACE_READ_NAMED_ATTRS\n           | NEW_ACE_READ_ATTRIBUTES\n           | NEW_ACE_READ_ACL\n           | NEW_ACE_SYNCHRONIZE)\n          & ~ access_masks[5])\n        return 1;\n      access_masks[5] &= ~(NEW_ACE_READ_NAMED_ATTRS\n                           | NEW_ACE_READ_ATTRIBUTES\n                           | NEW_ACE_READ_ACL\n                           | NEW_ACE_SYNCHRONIZE);\n\n       \n      switch ((access_masks[0] | access_masks[1])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[2] | access_masks[3])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[4] | access_masks[5])\n              & ~(NEW_ACE_WRITE_NAMED_ATTRS\n                  | NEW_ACE_WRITE_ATTRIBUTES\n                  | NEW_ACE_WRITE_ACL\n                  | NEW_ACE_WRITE_OWNER))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n\n       \n      if (((access_masks[0] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[0] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[2] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[2] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[4] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[4] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n    }\n\n  return 0;\n}\n\n# endif\n\n#elif USE_ACL && HAVE_GETACL  \n\n \nint\nacl_nontrivial (int count, struct acl_entry *entries)\n{\n  int i;\n\n  if (count > 3)\n    return 1;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl_entry *ace = &entries[i];\n\n      if (ace->uid != ACL_NSUSER && ace->gid != ACL_NSGROUP)\n        return 1;\n    }\n  return 0;\n}\n\n# if HAVE_ACLV_H  \n\n \nint\naclv_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n       \n      if (!(ace->a_type == USER_OBJ  \n            || ace->a_type == GROUP_OBJ  \n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}\n\n# endif\n\n#elif USE_ACL && (HAVE_ACLX_GET || HAVE_STATACL)  \n\n \nint\nacl_nontrivial (struct acl *a)\n{\n   \n  return (acl_last (a) != a->acl_ext ? 1 : 0);\n}\n\n# if HAVE_ACLX_GET && defined ACL_AIX_WIP  \n\n \nint\nacl_nfs4_nontrivial (nfs4_acl_int_t *a)\n{\n#  if 1  \n  return (a->aclEntryN > 0 ? 1 : 0);\n#  else\n  int count = a->aclEntryN;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      nfs4_ace_int_t *ace = &a->aclEntry[i];\n\n      if (!((ace->flags & ACE4_ID_SPECIAL) != 0\n            && (ace->aceWho.special_whoid == ACE4_WHO_OWNER\n                || ace->aceWho.special_whoid == ACE4_WHO_GROUP\n                || ace->aceWho.special_whoid == ACE4_WHO_EVERYONE)\n            && ace->aceType == ACE4_ACCESS_ALLOWED_ACE_TYPE\n            && ace->aceFlags == 0\n            && (ace->aceMask & ~(ACE4_READ_DATA | ACE4_LIST_DIRECTORY\n                                 | ACE4_WRITE_DATA | ACE4_ADD_FILE\n                                 | ACE4_EXECUTE)) == 0))\n        return 1;\n    }\n  return 0;\n#  endif\n}\n\n# endif\n\n#elif USE_ACL && HAVE_ACLSORT  \n\n \nint\nacl_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n       \n      if (!(ace->a_type == USER_OBJ  \n            || ace->a_type == GROUP_OBJ  \n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}\n\n#endif\n\nvoid\nfree_permission_context (struct permission_context *ctx)\n{\n#if USE_ACL\n# if HAVE_ACL_GET_FILE  \n  if (ctx->acl)\n    acl_free (ctx->acl);\n#  if !HAVE_ACL_TYPE_EXTENDED\n  if (ctx->default_acl)\n    acl_free (ctx->default_acl);\n#  endif\n\n# elif defined GETACL  \n  free (ctx->entries);\n#  ifdef ACE_GETACL\n  free (ctx->ace_entries);\n#  endif\n\n# elif HAVE_GETACL  \n\n#  if HAVE_ACLV_H\n#  endif\n\n# elif HAVE_STATACL  \n\n# elif HAVE_ACLSORT  \n\n# endif\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}