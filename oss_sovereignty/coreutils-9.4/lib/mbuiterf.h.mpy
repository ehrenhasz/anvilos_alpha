{
  "module_name": "mbuiterf.h",
  "hash_id": "0e68d9b25232c3a152d0c2702873a7053fa3320d3cdb14917965bdb635e5dc78",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbuiterf.h",
  "human_readable_source": " \n\n \n\n#ifndef _MBUITERF_H\n#define _MBUITERF_H 1\n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#include <assert.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <uchar.h>\n#include <wchar.h>\n\n#include \"mbchar.h\"\n#include \"strnlen1.h\"\n\n_GL_INLINE_HEADER_BEGIN\n#ifndef MBUITERF_INLINE\n# define MBUITERF_INLINE _GL_INLINE _GL_ATTRIBUTE_ALWAYS_INLINE\n#endif\n\nstruct mbuif_state\n{\n  #if !GNULIB_MBRTOC32_REGULAR\n  bool in_shift;         \n                         \n  #endif\n  mbstate_t state;       \n                         \n  unsigned int cur_max;  \n};\n\nMBUITERF_INLINE mbchar_t\nmbuiterf_next (struct mbuif_state *ps, const char *iter)\n{\n  #if !GNULIB_MBRTOC32_REGULAR\n  if (ps->in_shift)\n    goto with_shift;\n  #endif\n   \n  if (is_basic (*iter))\n    {\n       \n      return (mbchar_t) { .ptr = iter, .bytes = 1, .wc_valid = true, .wc = *iter };\n    }\n  else\n    {\n      assert (mbsinit (&ps->state));\n      #if !GNULIB_MBRTOC32_REGULAR\n      ps->in_shift = true;\n    with_shift:;\n      #endif\n      size_t bytes;\n      char32_t wc;\n      bytes = mbrtoc32 (&wc, iter, strnlen1 (iter, ps->cur_max), &ps->state);\n      if (bytes == (size_t) -1)\n        {\n           \n           \n          #if !GNULIB_MBRTOC32_REGULAR\n          ps->in_shift = false;\n          #endif\n          mbszero (&ps->state);\n          return (mbchar_t) { .ptr = iter, .bytes = 1, .wc_valid = false };\n        }\n      else if (bytes == (size_t) -2)\n        {\n           \n           \n          return (mbchar_t) { .ptr = iter, .bytes = strlen (iter), .wc_valid = false };\n        }\n      else\n        {\n          if (bytes == 0)\n            {\n               \n              bytes = 1;\n              assert (*iter == '\\0');\n              assert (wc == 0);\n            }\n          #if !GNULIB_MBRTOC32_REGULAR\n          else if (bytes == (size_t) -3)\n             \n            bytes = 0;\n          #endif\n\n           \n          #if !GNULIB_MBRTOC32_REGULAR\n          if (mbsinit (&ps->state))\n            ps->in_shift = false;\n          #endif\n          return (mbchar_t) { .ptr = iter, .bytes = bytes, .wc_valid = true, .wc = wc };\n        }\n    }\n}\n\n \ntypedef struct mbuif_state mbuif_state_t;\n#if !GNULIB_MBRTOC32_REGULAR\n#define mbuif_init(st) \\\n  ((st).in_shift = false, mbszero (&(st).state), \\\n   (st).cur_max = MB_CUR_MAX)\n#else\n \n#define mbuif_init(st) \\\n  (mbszero (&(st).state), \\\n   (st).cur_max = MB_CUR_MAX)\n#endif\n#if !GNULIB_MBRTOC32_REGULAR\n#define mbuif_avail(st, iter) ((st).in_shift || (*(iter) != '\\0'))\n#else\n \n#define mbuif_avail(st, iter) (*(iter) != '\\0')\n#endif\n#define mbuif_next(st, iter) \\\n  mbuiterf_next (&(st), (iter))\n\n_GL_INLINE_HEADER_END\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}