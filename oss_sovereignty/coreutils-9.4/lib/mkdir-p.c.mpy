{
  "module_name": "mkdir-p.c",
  "hash_id": "9ecbd343d5c8e584c77e61c4bc9beec6b638050cdaa391acfc24473402e1aea7",
  "original_prompt": "Ingested from coreutils-9.4/lib/mkdir-p.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"mkdir-p.h\"\n\n#include <errno.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"gettext.h\"\n#define _(msgid) gettext (msgid)\n\n#include \"dirchownmod.h\"\n#include \"dirname.h\"\n#include \"error.h\"\n#include \"quote.h\"\n#include \"mkancesdirs.h\"\n#include \"savewd.h\"\n\n#ifndef HAVE_FCHMOD\n# define HAVE_FCHMOD false\n#endif\n\n \n\nbool\nmake_dir_parents (char *dir,\n                  struct savewd *wd,\n                  int (*make_ancestor) (char const *, char const *, void *),\n                  void *options,\n                  mode_t mode,\n                  void (*announce) (char const *, void *),\n                  mode_t mode_bits,\n                  uid_t owner,\n                  gid_t group,\n                  bool preserve_existing)\n{\n  int mkdir_errno = (IS_ABSOLUTE_FILE_NAME (dir) ? 0 : savewd_errno (wd));\n\n  if (mkdir_errno == 0)\n    {\n      ptrdiff_t prefix_len = 0;\n      int savewd_chdir_options = (HAVE_FCHMOD ? SAVEWD_CHDIR_SKIP_READABLE : 0);\n\n      if (make_ancestor)\n        {\n          prefix_len = mkancesdirs (dir, wd, make_ancestor, options);\n          if (prefix_len < 0)\n            {\n              if (prefix_len < -1)\n                return true;\n              mkdir_errno = errno;\n            }\n        }\n\n      if (0 <= prefix_len)\n        {\n           \n          bool keep_owner = owner == (uid_t) -1 && group == (gid_t) -1;\n          bool keep_special_mode_bits =\n            ((mode_bits & (S_ISUID | S_ISGID)) | (mode & S_ISVTX)) == 0;\n          mode_t mkdir_mode = mode;\n          if (! keep_owner)\n            mkdir_mode &= ~ (S_IRWXG | S_IRWXO);\n          else if (! keep_special_mode_bits)\n            mkdir_mode &= ~ (S_IWGRP | S_IWOTH);\n\n          if (mkdir (dir + prefix_len, mkdir_mode) == 0)\n            {\n               \n              bool umask_must_be_ok = (mode & mode_bits & S_IRWXUGO) == 0;\n\n              announce (dir, options);\n              preserve_existing = (keep_owner & keep_special_mode_bits\n                                   & umask_must_be_ok);\n              savewd_chdir_options |= SAVEWD_CHDIR_NOFOLLOW;\n            }\n          else\n            {\n              mkdir_errno = errno;\n              mkdir_mode = -1;\n            }\n\n          if (preserve_existing)\n            {\n              if (mkdir_errno == 0)\n                return true;\n              if (mkdir_errno != ENOENT && make_ancestor)\n                {\n                  struct stat st;\n                  if (stat (dir + prefix_len, &st) == 0)\n                    {\n                      if (S_ISDIR (st.st_mode))\n                        return true;\n                    }\n                  else if (mkdir_errno == EEXIST\n                           && errno != ENOENT && errno != ENOTDIR)\n                    {\n                      error (0, errno, _(\"cannot stat %s\"), quote (dir));\n                      return false;\n                    }\n                }\n            }\n          else\n            {\n              int open_result[2];\n              int chdir_result =\n                savewd_chdir (wd, dir + prefix_len,\n                              savewd_chdir_options, open_result);\n              if (chdir_result < -1)\n                return true;\n              else\n                {\n                  bool chdir_ok = (chdir_result == 0);\n                  char const *subdir = (chdir_ok ? \".\" : dir + prefix_len);\n                  if (dirchownmod (open_result[0], subdir, mkdir_mode,\n                                   owner, group, mode, mode_bits)\n                      == 0)\n                    return true;\n\n                  if (mkdir_errno == 0\n                      || (mkdir_errno != ENOENT && make_ancestor\n                          && errno != ENOTDIR))\n                    {\n                      error (0, errno,\n                             _(keep_owner\n                               ? \"cannot change permissions of %s\"\n                               : \"cannot change owner and permissions of %s\"),\n                             quote (dir));\n                      return false;\n                    }\n                }\n            }\n        }\n    }\n\n  error (0, mkdir_errno, _(\"cannot create directory %s\"), quote (dir));\n  return false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}