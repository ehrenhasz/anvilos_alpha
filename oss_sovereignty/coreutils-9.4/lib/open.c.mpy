{
  "module_name": "open.c",
  "hash_id": "28d31e4befa5475815c2781d68f757860fc2ee4cdf857a204925c19dcddeb1ec",
  "original_prompt": "Ingested from coreutils-9.4/lib/open.c",
  "human_readable_source": " \n\n \n#define __need_system_fcntl_h\n#include <config.h>\n\n \n#include <fcntl.h>\n#include <sys/types.h>\n#undef __need_system_fcntl_h\n\nstatic int\norig_open (const char *filename, int flags, mode_t mode)\n{\n#if defined _WIN32 && !defined __CYGWIN__\n  return _open (filename, flags, mode);\n#else\n  return open (filename, flags, mode);\n#endif\n}\n\n \n \n#include \"fcntl.h\"\n\n#include \"cloexec.h\"\n\n#include <errno.h>\n#include <stdarg.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#ifndef REPLACE_OPEN_DIRECTORY\n# define REPLACE_OPEN_DIRECTORY 0\n#endif\n\nint\nopen (const char *filename, int flags, ...)\n{\n   \n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n       \n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n   \n  flags &= ~O_NONBLOCK;\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n   \n  if ((flags & O_CREAT)\n      || (flags & O_ACCMODE) == O_RDWR\n      || (flags & O_ACCMODE) == O_WRONLY)\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename,\n                  flags & ~(have_cloexec < 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_open (filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n#if REPLACE_FCHDIR\n   \n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n           \n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n   \n  if (fd >= 0)\n    {\n       \n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}