{
  "module_name": "sigaction.c",
  "hash_id": "fc17fda95a682704811cefa3cd8d65b0b1c4a0819a99883d880b35a2cc93ffaa",
  "original_prompt": "Ingested from coreutils-9.4/lib/sigaction.c",
  "human_readable_source": " \n#include <signal.h>\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n \n\n \n#if defined SIGCHLD || defined HAVE_SIGALTSTACK || defined HAVE_SIGINTERRUPT\n# error \"Revisit the assumptions made in the sigaction module\"\n#endif\n\n \n#ifndef SIGKILL\n# define SIGKILL (-1)\n#endif\n#ifndef SIGSTOP\n# define SIGSTOP (-1)\n#endif\n\n \n#if defined _WIN32 && ! defined __CYGWIN__\n# undef SIGABRT_COMPAT\n# define SIGABRT_COMPAT 6\n#endif\n\n \ntypedef void (*handler_t) (int signal);\n\n \nstatic struct sigaction volatile action_array[NSIG]  ;\n\n \nstatic void\nsigaction_handler (int sig)\n{\n  handler_t handler;\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno = errno;\n  if (sig < 0 || NSIG <= sig || !action_array[sig].sa_handler)\n    {\n       \n      if (sig == SIGABRT)\n        signal (SIGABRT, SIG_DFL);\n      abort ();\n    }\n\n   \n  handler = action_array[sig].sa_handler;\n  if ((action_array[sig].sa_flags & SA_RESETHAND) == 0)\n    signal (sig, sigaction_handler);\n  else\n    action_array[sig].sa_handler = NULL;\n\n   \n  mask = action_array[sig].sa_mask;\n  if ((action_array[sig].sa_flags & SA_NODEFER) == 0)\n    sigaddset (&mask, sig);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n\n   \n  errno = saved_errno;\n  handler (sig);\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n}\n\n \nint\nsigaction (int sig, const struct sigaction *restrict act,\n           struct sigaction *restrict oact)\n{\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno;\n\n  if (sig < 0 || NSIG <= sig || sig == SIGKILL || sig == SIGSTOP\n      || (act && act->sa_handler == SIG_ERR))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef SIGABRT_COMPAT\n  if (sig == SIGABRT_COMPAT)\n    sig = SIGABRT;\n#endif\n\n   \n  if (!act && !oact)\n    return 0;\n  sigfillset (&mask);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n  if (oact)\n    {\n      if (action_array[sig].sa_handler)\n        *oact = action_array[sig];\n      else\n        {\n           \n          oact->sa_handler = signal (sig, SIG_DFL);\n          if (oact->sa_handler == SIG_ERR)\n            goto failure;\n          signal (sig, oact->sa_handler);\n          oact->sa_flags = SA_RESETHAND | SA_NODEFER;\n          sigemptyset (&oact->sa_mask);\n        }\n    }\n\n  if (act)\n    {\n       \n      if (act->sa_handler == SIG_DFL || act->sa_handler == SIG_IGN)\n        {\n          if (signal (sig, act->sa_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig].sa_handler = NULL;\n        }\n      else\n        {\n          if (signal (sig, sigaction_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig] = *act;\n        }\n    }\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  return 0;\n\n failure:\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n  return -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}