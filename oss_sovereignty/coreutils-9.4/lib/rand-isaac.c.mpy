{
  "module_name": "rand-isaac.c",
  "hash_id": "abe442169671fbbac19e9bfeb56429a595dd5ab1b6c54e7220d5deae52325e99",
  "original_prompt": "Ingested from coreutils-9.4/lib/rand-isaac.c",
  "human_readable_source": " \n\n \n#include <config.h>\n\n#include \"rand-isaac.h\"\n\n#include <limits.h>\n#include <string.h>\n\n \n#undef ATTRIBUTE_NO_WARN_SANITIZE_UNDEFINED\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned) \\\n    || __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 9)\n# define ATTRIBUTE_NO_WARN_SANITIZE_UNDEFINED  \n#else\n# define ATTRIBUTE_NO_WARN_SANITIZE_UNDEFINED \\\n  __attribute__ ((__no_sanitize_undefined__))\n#endif\n\n \n#define IF32(a, b) (ISAAC_BITS == 32 ? (a) : (b))\n\n \nstatic inline isaac_word\njust (isaac_word a)\n{\n  isaac_word desired_bits = ((isaac_word) 1 << 1 << (ISAAC_BITS - 1)) - 1;\n  return a & desired_bits;\n}\n\n \nstatic inline isaac_word\nind (isaac_word const *m, isaac_word x)\n{\n  if (sizeof *m * CHAR_BIT == ISAAC_BITS)\n    {\n       \n      void const *void_m = m;\n      char const *base_p = void_m;\n      void const *word_p = base_p + (x & ((ISAAC_WORDS - 1) * sizeof *m));\n      isaac_word const *p = word_p;\n      return *p;\n    }\n  else\n    {\n       \n      return m[(x / (ISAAC_BITS / CHAR_BIT)) & (ISAAC_WORDS - 1)];\n    }\n}\n\n \nvoid ATTRIBUTE_NO_WARN_SANITIZE_UNDEFINED\nisaac_refill (struct isaac_state *s, isaac_word result[ISAAC_WORDS])\n{\n   \n  isaac_word a = s->a;\n  isaac_word b = s->b + (++s->c);\n\n   \n  isaac_word *m = s->m;\n  isaac_word *r = result;\n\n  enum { HALF = ISAAC_WORDS / 2 };\n\n   \n  #define ISAAC_STEP(i, off, mix)                             \\\n    {                                                         \\\n      isaac_word x, y;                                        \\\n      a = (IF32 (a, 0) ^ (mix)) + m[off + (i)];               \\\n      x = m[i];                                               \\\n      m[i] = y = ind (s->m, x) + a + b;                       \\\n      r[i] = b = just (ind (s->m, y >> ISAAC_WORDS_LOG) + x); \\\n    }\n\n  do\n    {\n      ISAAC_STEP (0, HALF, IF32 (      a  << 13, ~ (a ^ (a << 21))));\n      ISAAC_STEP (1, HALF, IF32 (just (a) >>  6, a ^ (just (a) >>  5)));\n      ISAAC_STEP (2, HALF, IF32 (      a  <<  2, a ^ (      a  << 12)));\n      ISAAC_STEP (3, HALF, IF32 (just (a) >> 16, a ^ (just (a) >> 33)));\n      r += 4;\n    }\n  while ((m += 4) < s->m + HALF);\n\n  do\n    {\n      ISAAC_STEP (0, -HALF, IF32 (      a  << 13, ~ (a ^ (a << 21))));\n      ISAAC_STEP (1, -HALF, IF32 (just (a) >>  6, a ^ (just (a) >>  5)));\n      ISAAC_STEP (2, -HALF, IF32 (      a  <<  2, a ^ (      a  << 12)));\n      ISAAC_STEP (3, -HALF, IF32 (just (a) >> 16, a ^ (just (a) >> 33)));\n      r += 4;\n    }\n  while ((m += 4) < s->m + ISAAC_WORDS);\n\n  s->a = a;\n  s->b = b;\n}\n\n \n#if ISAAC_BITS == 32\n #define mix(a, b, c, d, e, f, g, h)       \\\n    {                                      \\\n              a ^=       b  << 11; d += a; \\\n      b += c; b ^= just (c) >>  2; e += b; \\\n      c += d; c ^=       d  <<  8; f += c; \\\n      d += e; d ^= just (e) >> 16; g += d; \\\n      e += f; e ^=       f  << 10; h += e; \\\n      f += g; f ^= just (g) >>  4; a += f; \\\n      g += h; g ^=       h  <<  8; b += g; \\\n      h += a; h ^= just (a) >>  9; c += h; \\\n      a += b;                              \\\n    }\n#else\n #define mix(a, b, c, d, e, f, g, h)       \\\n    {                                      \\\n      a -= e; f ^= just (h) >>  9; h += a; \\\n      b -= f; g ^=       a  <<  9; a += b; \\\n      c -= g; h ^= just (b) >> 23; b += c; \\\n      d -= h; a ^=       c  << 15; c += d; \\\n      e -= a; b ^= just (d) >> 14; d += e; \\\n      f -= b; c ^=       e  << 20; e += f; \\\n      g -= c; d ^= just (f) >> 17; f += g; \\\n      h -= d; e ^=       g  << 14; g += h; \\\n    }\n#endif\n\n\n \n#define ISAAC_MIX(s, a, b, c, d, e, f, g, h, seed) \\\n  {                                                \\\n    int i;                                         \\\n                                                   \\\n    for (i = 0; i < ISAAC_WORDS; i += 8)           \\\n      {                                            \\\n        a += seed[i];                              \\\n        b += seed[i + 1];                          \\\n        c += seed[i + 2];                          \\\n        d += seed[i + 3];                          \\\n        e += seed[i + 4];                          \\\n        f += seed[i + 5];                          \\\n        g += seed[i + 6];                          \\\n        h += seed[i + 7];                          \\\n        mix (a, b, c, d, e, f, g, h);              \\\n        s->m[i] = a;                               \\\n        s->m[i + 1] = b;                           \\\n        s->m[i + 2] = c;                           \\\n        s->m[i + 3] = d;                           \\\n        s->m[i + 4] = e;                           \\\n        s->m[i + 5] = f;                           \\\n        s->m[i + 6] = g;                           \\\n        s->m[i + 7] = h;                           \\\n      }                                            \\\n  }\n\n#if 0  \n \nstatic void\nisaac_init (struct isaac_state *s, isaac_word const *seed, size_t seedsize)\n{\n  isaac_word a, b, c, d, e, f, g, h;\n\n  a = b = c = d = e = f = g = h =           \n    IF32 (UINT32_C (0x9e3779b9), UINT64_C (0x9e3779b97f4a7c13));\n  for (int i = 0; i < 4; i++)               \n    mix (a, b, c, d, e, f, g, h);\n  s->a = s->b = s->c = 0;\n\n  if (seedsize)\n    {\n       \n      ISAAC_MIX (s, a, b, c, d, e, f, g, h, seed);\n       \n      while (seedsize -= ISAAC_BYTES)\n        {\n          seed += ISAAC_WORDS;\n          for (i = 0; i < ISAAC_WORDS; i++)\n            s->m[i] += seed[i];\n          ISAAC_MIX (s, a, b, c, d, e, f, g, h, s->m);\n        }\n    }\n  else\n    {\n       \n      for (i = 0; i < ISAAC_WORDS; i++)\n        s->m[i] = 0;\n    }\n\n   \n  ISAAC_MIX (s, a, b, c, d, e, f, g, h, s->m);\n}\n#endif\n\n \nvoid\nisaac_seed (struct isaac_state *s)\n{\n  isaac_word a = IF32 (UINT32_C (0x1367df5a), UINT64_C (0x647c4677a2884b7c));\n  isaac_word b = IF32 (UINT32_C (0x95d90059), UINT64_C (0xb9f8b322c73ac862));\n  isaac_word c = IF32 (UINT32_C (0xc3163e4b), UINT64_C (0x8c0ea5053d4712a0));\n  isaac_word d = IF32 (UINT32_C (0x0f421ad8), UINT64_C (0xb29b2e824a595524));\n  isaac_word e = IF32 (UINT32_C (0xd92a4a78), UINT64_C (0x82f053db8355e0ce));\n  isaac_word f = IF32 (UINT32_C (0xa51a3c49), UINT64_C (0x48fe4a0fa5a09315));\n  isaac_word g = IF32 (UINT32_C (0xc4efea1b), UINT64_C (0xae985bf2cbfc89ed));\n  isaac_word h = IF32 (UINT32_C (0x30609119), UINT64_C (0x98f5704f6c44c0ab));\n\n#if 0\n   \n  a = b = c = d = e = f = g = h =           \n    IF32 (UINT32_C (0x9e3779b9), UINT64_C (0x9e3779b97f4a7c13));\n  for (int i = 0; i < 4; i++)               \n    mix (a, b, c, d, e, f, g, h);\n#endif\n\n   \n  ISAAC_MIX (s, a, b, c, d, e, f, g, h, s->m);\n  ISAAC_MIX (s, a, b, c, d, e, f, g, h, s->m);\n\n  s->a = s->b = s->c = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}