{
  "module_name": "base64.c",
  "hash_id": "ebe6343b5ebed8d17655549e0d02a44c299d606044229e1962afe238ff926769",
  "original_prompt": "Ingested from coreutils-9.4/lib/base64.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"base64.h\"\n\n \n#include <ialloc.h>\n\n#include <intprops.h>\n\n \n#include <limits.h>\n\n#include <string.h>\n\n \nstatic unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}\n\nstatic const char b64c[64] =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n \nstatic void\nbase64_encode_fast (const char *restrict in, idx_t inlen, char *restrict out)\n{\n  while (inlen)\n    {\n      *out++ = b64c[(to_uchar (in[0]) >> 2) & 0x3f];\n      *out++ = b64c[((to_uchar (in[0]) << 4) + (to_uchar (in[1]) >> 4)) & 0x3f];\n      *out++ = b64c[((to_uchar (in[1]) << 2) + (to_uchar (in[2]) >> 6)) & 0x3f];\n      *out++ = b64c[to_uchar (in[2]) & 0x3f];\n\n      inlen -= 3;\n      in += 3;\n    }\n}\n\n \nvoid\nbase64_encode (const char *restrict in, idx_t inlen,\n               char *restrict out, idx_t outlen)\n{\n   \n  if (outlen % 4 == 0 && inlen == (outlen >> 2) * 3)\n    {\n      base64_encode_fast (in, inlen, out);\n      return;\n    }\n\n  while (inlen && outlen)\n    {\n      *out++ = b64c[(to_uchar (in[0]) >> 2) & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ = b64c[((to_uchar (in[0]) << 4)\n                       + (--inlen ? to_uchar (in[1]) >> 4 : 0))\n                      & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b64c[((to_uchar (in[1]) << 2)\n                   + (--inlen ? to_uchar (in[2]) >> 6 : 0))\n                  & 0x3f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b64c[to_uchar (in[2]) & 0x3f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 3;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}\n\n \nidx_t\nbase64_encode_alloc (const char *in, idx_t inlen, char **out)\n{\n   \n  idx_t in_over_3 = inlen / 3 + (inlen % 3 != 0), outlen;\n  if (! INT_MULTIPLY_OK (in_over_3, 4, &outlen) || inlen < 0)\n    {\n      *out = NULL;\n      return 0;\n    }\n  outlen++;\n\n  *out = imalloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base64_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}\n\n \n#define B64(_)                                  \\\n  ((_) == 'A' ? 0                               \\\n   : (_) == 'B' ? 1                             \\\n   : (_) == 'C' ? 2                             \\\n   : (_) == 'D' ? 3                             \\\n   : (_) == 'E' ? 4                             \\\n   : (_) == 'F' ? 5                             \\\n   : (_) == 'G' ? 6                             \\\n   : (_) == 'H' ? 7                             \\\n   : (_) == 'I' ? 8                             \\\n   : (_) == 'J' ? 9                             \\\n   : (_) == 'K' ? 10                            \\\n   : (_) == 'L' ? 11                            \\\n   : (_) == 'M' ? 12                            \\\n   : (_) == 'N' ? 13                            \\\n   : (_) == 'O' ? 14                            \\\n   : (_) == 'P' ? 15                            \\\n   : (_) == 'Q' ? 16                            \\\n   : (_) == 'R' ? 17                            \\\n   : (_) == 'S' ? 18                            \\\n   : (_) == 'T' ? 19                            \\\n   : (_) == 'U' ? 20                            \\\n   : (_) == 'V' ? 21                            \\\n   : (_) == 'W' ? 22                            \\\n   : (_) == 'X' ? 23                            \\\n   : (_) == 'Y' ? 24                            \\\n   : (_) == 'Z' ? 25                            \\\n   : (_) == 'a' ? 26                            \\\n   : (_) == 'b' ? 27                            \\\n   : (_) == 'c' ? 28                            \\\n   : (_) == 'd' ? 29                            \\\n   : (_) == 'e' ? 30                            \\\n   : (_) == 'f' ? 31                            \\\n   : (_) == 'g' ? 32                            \\\n   : (_) == 'h' ? 33                            \\\n   : (_) == 'i' ? 34                            \\\n   : (_) == 'j' ? 35                            \\\n   : (_) == 'k' ? 36                            \\\n   : (_) == 'l' ? 37                            \\\n   : (_) == 'm' ? 38                            \\\n   : (_) == 'n' ? 39                            \\\n   : (_) == 'o' ? 40                            \\\n   : (_) == 'p' ? 41                            \\\n   : (_) == 'q' ? 42                            \\\n   : (_) == 'r' ? 43                            \\\n   : (_) == 's' ? 44                            \\\n   : (_) == 't' ? 45                            \\\n   : (_) == 'u' ? 46                            \\\n   : (_) == 'v' ? 47                            \\\n   : (_) == 'w' ? 48                            \\\n   : (_) == 'x' ? 49                            \\\n   : (_) == 'y' ? 50                            \\\n   : (_) == 'z' ? 51                            \\\n   : (_) == '0' ? 52                            \\\n   : (_) == '1' ? 53                            \\\n   : (_) == '2' ? 54                            \\\n   : (_) == '3' ? 55                            \\\n   : (_) == '4' ? 56                            \\\n   : (_) == '5' ? 57                            \\\n   : (_) == '6' ? 58                            \\\n   : (_) == '7' ? 59                            \\\n   : (_) == '8' ? 60                            \\\n   : (_) == '9' ? 61                            \\\n   : (_) == '+' ? 62                            \\\n   : (_) == '/' ? 63                            \\\n   : -1)\n\nstatic const signed char b64[0x100] = {\n  B64 (0), B64 (1), B64 (2), B64 (3),\n  B64 (4), B64 (5), B64 (6), B64 (7),\n  B64 (8), B64 (9), B64 (10), B64 (11),\n  B64 (12), B64 (13), B64 (14), B64 (15),\n  B64 (16), B64 (17), B64 (18), B64 (19),\n  B64 (20), B64 (21), B64 (22), B64 (23),\n  B64 (24), B64 (25), B64 (26), B64 (27),\n  B64 (28), B64 (29), B64 (30), B64 (31),\n  B64 (32), B64 (33), B64 (34), B64 (35),\n  B64 (36), B64 (37), B64 (38), B64 (39),\n  B64 (40), B64 (41), B64 (42), B64 (43),\n  B64 (44), B64 (45), B64 (46), B64 (47),\n  B64 (48), B64 (49), B64 (50), B64 (51),\n  B64 (52), B64 (53), B64 (54), B64 (55),\n  B64 (56), B64 (57), B64 (58), B64 (59),\n  B64 (60), B64 (61), B64 (62), B64 (63),\n  B64 (64), B64 (65), B64 (66), B64 (67),\n  B64 (68), B64 (69), B64 (70), B64 (71),\n  B64 (72), B64 (73), B64 (74), B64 (75),\n  B64 (76), B64 (77), B64 (78), B64 (79),\n  B64 (80), B64 (81), B64 (82), B64 (83),\n  B64 (84), B64 (85), B64 (86), B64 (87),\n  B64 (88), B64 (89), B64 (90), B64 (91),\n  B64 (92), B64 (93), B64 (94), B64 (95),\n  B64 (96), B64 (97), B64 (98), B64 (99),\n  B64 (100), B64 (101), B64 (102), B64 (103),\n  B64 (104), B64 (105), B64 (106), B64 (107),\n  B64 (108), B64 (109), B64 (110), B64 (111),\n  B64 (112), B64 (113), B64 (114), B64 (115),\n  B64 (116), B64 (117), B64 (118), B64 (119),\n  B64 (120), B64 (121), B64 (122), B64 (123),\n  B64 (124), B64 (125), B64 (126), B64 (127),\n  B64 (128), B64 (129), B64 (130), B64 (131),\n  B64 (132), B64 (133), B64 (134), B64 (135),\n  B64 (136), B64 (137), B64 (138), B64 (139),\n  B64 (140), B64 (141), B64 (142), B64 (143),\n  B64 (144), B64 (145), B64 (146), B64 (147),\n  B64 (148), B64 (149), B64 (150), B64 (151),\n  B64 (152), B64 (153), B64 (154), B64 (155),\n  B64 (156), B64 (157), B64 (158), B64 (159),\n  B64 (160), B64 (161), B64 (162), B64 (163),\n  B64 (164), B64 (165), B64 (166), B64 (167),\n  B64 (168), B64 (169), B64 (170), B64 (171),\n  B64 (172), B64 (173), B64 (174), B64 (175),\n  B64 (176), B64 (177), B64 (178), B64 (179),\n  B64 (180), B64 (181), B64 (182), B64 (183),\n  B64 (184), B64 (185), B64 (186), B64 (187),\n  B64 (188), B64 (189), B64 (190), B64 (191),\n  B64 (192), B64 (193), B64 (194), B64 (195),\n  B64 (196), B64 (197), B64 (198), B64 (199),\n  B64 (200), B64 (201), B64 (202), B64 (203),\n  B64 (204), B64 (205), B64 (206), B64 (207),\n  B64 (208), B64 (209), B64 (210), B64 (211),\n  B64 (212), B64 (213), B64 (214), B64 (215),\n  B64 (216), B64 (217), B64 (218), B64 (219),\n  B64 (220), B64 (221), B64 (222), B64 (223),\n  B64 (224), B64 (225), B64 (226), B64 (227),\n  B64 (228), B64 (229), B64 (230), B64 (231),\n  B64 (232), B64 (233), B64 (234), B64 (235),\n  B64 (236), B64 (237), B64 (238), B64 (239),\n  B64 (240), B64 (241), B64 (242), B64 (243),\n  B64 (244), B64 (245), B64 (246), B64 (247),\n  B64 (248), B64 (249), B64 (250), B64 (251),\n  B64 (252), B64 (253), B64 (254), B64 (255)\n};\n\n#if UCHAR_MAX == 255\n# define uchar_in_range(c) true\n#else\n# define uchar_in_range(c) ((c) <= 255)\n#endif\n\n \nbool\nisbase64 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];\n}\n\n \nvoid\nbase64_decode_ctx_init (struct base64_decode_context *ctx)\n{\n  ctx->i = 0;\n}\n\n \nstatic char *\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       idx_t *n_non_newline)\n{\n  if (ctx->i == 4)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (4 <= in_end - *in && memchr (t, '\\n', 4) == NULL)\n        {\n           \n          *in += 4;\n          *n_non_newline = 4;\n          return (char *) t;\n        }\n    }\n\n  {\n     \n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 4)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}\n\n#define return_false                            \\\n  do                                            \\\n    {                                           \\\n      *outp = out;                              \\\n      return false;                             \\\n    }                                           \\\n  while (false)\n\n \nstatic bool\ndecode_4 (char const *restrict in, idx_t inlen,\n          char *restrict *outp, idx_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 2)\n    return false;\n\n  if (!isbase64 (in[0]) || !isbase64 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b64[to_uchar (in[0])] << 2)\n                | (b64[to_uchar (in[1])] >> 4));\n      --*outleft;\n    }\n\n  if (inlen == 2)\n    return_false;\n\n  if (in[2] == '=')\n    {\n      if (inlen != 4)\n        return_false;\n\n      if (in[3] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase64 (in[2]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n                    | (b64[to_uchar (in[2])] >> 2));\n          --*outleft;\n        }\n\n      if (inlen == 3)\n        return_false;\n\n      if (in[3] == '=')\n        {\n          if (inlen != 4)\n            return_false;\n        }\n      else\n        {\n          if (!isbase64 (in[3]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n                        | b64[to_uchar (in[3])]);\n              --*outleft;\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}\n\n \n\nbool\nbase64_decode_ctx (struct base64_decode_context *ctx,\n                   const char *restrict in, idx_t inlen,\n                   char *restrict out, idx_t *outlen)\n{\n  idx_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      idx_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n               \n              outleft_save = outleft;\n              if (!decode_4 (in, inlen, &out, &outleft))\n                break;\n\n              in += 4;\n              inlen -= 4;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n       \n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n       \n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_4 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;   \n\n         \n        if (inlen == 0 || (inlen < 4 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_4 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}\n\n \nbool\nbase64_decode_alloc_ctx (struct base64_decode_context *ctx,\n                         const char *in, idx_t inlen, char **out,\n                         idx_t *outlen)\n{\n   \n  idx_t needlen = 3 * ((inlen >> 2) + 1);\n\n  *out = imalloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}