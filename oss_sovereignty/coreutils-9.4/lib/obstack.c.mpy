{
  "module_name": "obstack.c",
  "hash_id": "084ae0d5550aab27d77da1c50f41655ed6a09f90c47196d868b7367bee005bbd",
  "original_prompt": "Ingested from coreutils-9.4/lib/obstack.c",
  "human_readable_source": " \n\n \n#if !defined _LIBC && defined __GNU_LIBRARY__ && __GNU_LIBRARY__ > 1\n# include <gnu-versions.h>\n# if (_GNU_OBSTACK_INTERFACE_VERSION == _OBSTACK_INTERFACE_VERSION\t      \\\n      || (_GNU_OBSTACK_INTERFACE_VERSION == 1\t\t\t\t      \\\n          && _OBSTACK_INTERFACE_VERSION == 2\t\t\t\t      \\\n          && defined SIZEOF_INT && defined SIZEOF_SIZE_T\t\t      \\\n          && SIZEOF_INT == SIZEOF_SIZE_T))\n#  define _OBSTACK_ELIDE_CODE\n# endif\n#endif\n\n#ifndef _OBSTACK_ELIDE_CODE\n \n# if !defined __GNUC__ && !defined __alignof__\n#  include <alignof.h>\n#  define __alignof__(type) alignof_type (type)\n# endif\n# include <stdlib.h>\n# include <stdint.h>\n\n# ifndef MAX\n#  define MAX(a,b) ((a) > (b) ? (a) : (b))\n# endif\n\n \n\n \n#define DEFAULT_ALIGNMENT MAX (__alignof__ (long double),\t\t      \\\n                               MAX (__alignof__ (uintmax_t),\t\t      \\\n                                    __alignof__ (void *)))\n#define DEFAULT_ROUNDING MAX (sizeof (long double),\t\t\t      \\\n                               MAX (sizeof (uintmax_t),\t\t\t      \\\n                                    sizeof (void *)))\n\n \n\nstatic void *\ncall_chunkfun (struct obstack *h, size_t size)\n{\n  if (h->use_extra_arg)\n    return h->chunkfun.extra (h->extra_arg, size);\n  else\n    return h->chunkfun.plain (size);\n}\n\nstatic void\ncall_freefun (struct obstack *h, void *old_chunk)\n{\n  if (h->use_extra_arg)\n    h->freefun.extra (h->extra_arg, old_chunk);\n  else\n    h->freefun.plain (old_chunk);\n}\n\n\n \n\nstatic int\n_obstack_begin_worker (struct obstack *h,\n                       _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n{\n  struct _obstack_chunk *chunk;  \n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n     \n    {\n       \n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n\n  chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n   \n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}\n\nint\n_obstack_begin (struct obstack *h,\n                _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                void *(*chunkfun) (size_t),\n                void (*freefun) (void *))\n{\n  h->chunkfun.plain = chunkfun;\n  h->freefun.plain = freefun;\n  h->use_extra_arg = 0;\n  return _obstack_begin_worker (h, size, alignment);\n}\n\nint\n_obstack_begin_1 (struct obstack *h,\n                  _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                  void *(*chunkfun) (void *, size_t),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  h->chunkfun.extra = chunkfun;\n  h->freefun.extra = freefun;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n  return _obstack_begin_worker (h, size, alignment);\n}\n\n \n\nvoid\n_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n{\n  struct _obstack_chunk *old_chunk = h->chunk;\n  struct _obstack_chunk *new_chunk = 0;\n  size_t obj_size = h->next_free - h->object_base;\n  char *object_base;\n\n   \n  size_t sum1 = obj_size + length;\n  size_t sum2 = sum1 + h->alignment_mask;\n  size_t new_size = sum2 + (obj_size >> 3) + 100;\n  if (new_size < sum2)\n    new_size = sum2;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n   \n  if (obj_size <= sum1 && sum1 <= sum2)\n    new_chunk = call_chunkfun (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler)();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n   \n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n   \n  memcpy (object_base, h->object_base, obj_size);\n\n   \n  if (!h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      call_freefun (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n   \n  h->maybe_empty_object = 0;\n}\n\n \n\n \nint _obstack_allocated_p (struct obstack *h, void *obj) __attribute_pure__;\n\nint\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;     \n  struct _obstack_chunk *plp;    \n\n  lp = (h)->chunk;\n   \n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}\n\n \n\nvoid\n_obstack_free (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;     \n  struct _obstack_chunk *plp;    \n\n  lp = h->chunk;\n   \n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      call_freefun (h, lp);\n      lp = plp;\n       \n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n     \n    abort ();\n}\n\n_OBSTACK_SIZE_T\n_obstack_memory_used (struct obstack *h)\n{\n  struct _obstack_chunk *lp;\n  _OBSTACK_SIZE_T nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}\n\n# ifndef _OBSTACK_NO_ERROR_HANDLER\n \n#  include <stdio.h>\n\n \n#  ifdef _LIBC\nint obstack_exit_failure = EXIT_FAILURE;\n#  else\n#   include \"exitfail.h\"\n#   define obstack_exit_failure exit_failure\n#  endif\n\n#  ifdef _LIBC\n#   include <libintl.h>\n#  else\n#   include \"gettext.h\"\n#  endif\n#  ifndef _\n#   define _(msgid) gettext (msgid)\n#  endif\n\n#  ifdef _LIBC\n#   include <libio/iolibio.h>\n#  endif\n\nstatic __attribute_noreturn__ void\nprint_and_abort (void)\n{\n   \n#  ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n#  else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n#  endif\n  exit (obstack_exit_failure);\n}\n\n \n__attribute_noreturn__ void (*obstack_alloc_failed_handler) (void)\n  = print_and_abort;\n# endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}