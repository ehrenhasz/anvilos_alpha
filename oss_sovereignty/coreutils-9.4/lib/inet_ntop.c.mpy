{
  "module_name": "inet_ntop.c",
  "hash_id": "2f8d8e5d38ec5c977b0cdc649cc14bd1b802ad2f20df5cc3771f157d2a7dcbd5",
  "original_prompt": "Ingested from coreutils-9.4/lib/inet_ntop.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <arpa/inet.h>\n\n \n#ifndef IF_LINT\n# if defined GCC_LINT || defined lint\n#  define IF_LINT(Code) Code\n# else\n#  define IF_LINT(Code)  \n# endif\n#endif\n\n#if HAVE_DECL_INET_NTOP\n\n# undef inet_ntop\n\nconst char *\nrpl_inet_ntop (int af, const void *restrict src,\n               char *restrict dst, socklen_t cnt)\n{\n  return inet_ntop (af, src, dst, cnt);\n}\n\n#else\n\n# include <stdio.h>\n# include <string.h>\n# include <errno.h>\n\n# define NS_IN6ADDRSZ 16\n# define NS_INT16SZ 2\n\n \ntypedef int verify_int_size[4 <= sizeof (int) ? 1 : -1];\n\nstatic const char *inet_ntop4 (const unsigned char *src, char *dst, socklen_t size);\n# if HAVE_IPV6\nstatic const char *inet_ntop6 (const unsigned char *src, char *dst, socklen_t size);\n# endif\n\n\n \nconst char *\ninet_ntop (int af, const void *restrict src,\n           char *restrict dst, socklen_t cnt)\n{\n  switch (af)\n    {\n# if HAVE_IPV4\n    case AF_INET:\n      return (inet_ntop4 (src, dst, cnt));\n# endif\n\n# if HAVE_IPV6\n    case AF_INET6:\n      return (inet_ntop6 (src, dst, cnt));\n# endif\n\n    default:\n      errno = EAFNOSUPPORT;\n      return (NULL);\n    }\n   \n}\n\n \nstatic const char *\ninet_ntop4 (const unsigned char *src, char *dst, socklen_t size)\n{\n  char tmp[sizeof \"255.255.255.255\"];\n  int len;\n\n  len = sprintf (tmp, \"%u.%u.%u.%u\", src[0], src[1], src[2], src[3]);\n  if (len < 0)\n    return NULL;\n\n  if (len > size)\n    {\n      errno = ENOSPC;\n      return NULL;\n    }\n\n  return strcpy (dst, tmp);\n}\n\n# if HAVE_IPV6\n\n \nstatic const char *\ninet_ntop6 (const unsigned char *src, char *dst, socklen_t size)\n{\n   \n  char tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"], *tp;\n  struct\n  {\n    int base, len;\n  } best, cur;\n  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n  int i;\n\n   \n  memset (words, '\\0', sizeof words);\n  for (i = 0; i < NS_IN6ADDRSZ; i += 2)\n    words[i / 2] = (src[i] << 8) | src[i + 1];\n  best.base = -1;\n  cur.base = -1;\n  IF_LINT(best.len = 0);\n  IF_LINT(cur.len = 0);\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n    {\n      if (words[i] == 0)\n        {\n          if (cur.base == -1)\n            cur.base = i, cur.len = 1;\n          else\n            cur.len++;\n        }\n      else\n        {\n          if (cur.base != -1)\n            {\n              if (best.base == -1 || cur.len > best.len)\n                best = cur;\n              cur.base = -1;\n            }\n        }\n    }\n  if (cur.base != -1)\n    {\n      if (best.base == -1 || cur.len > best.len)\n        best = cur;\n    }\n  if (best.base != -1 && best.len < 2)\n    best.base = -1;\n\n   \n  tp = tmp;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n    {\n       \n      if (best.base != -1 && i >= best.base && i < (best.base + best.len))\n        {\n          if (i == best.base)\n            *tp++ = ':';\n          continue;\n        }\n       \n      if (i != 0)\n        *tp++ = ':';\n       \n      if (i == 6 && best.base == 0 &&\n          (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))\n        {\n          if (!inet_ntop4 (src + 12, tp, sizeof tmp - (tp - tmp)))\n            return (NULL);\n          tp += strlen (tp);\n          break;\n        }\n      {\n        int len = sprintf (tp, \"%x\", words[i]);\n        if (len < 0)\n          return NULL;\n        tp += len;\n      }\n    }\n   \n  if (best.base != -1 && (best.base + best.len) ==\n      (NS_IN6ADDRSZ / NS_INT16SZ))\n    *tp++ = ':';\n  *tp++ = '\\0';\n\n   \n  if ((socklen_t) (tp - tmp) > size)\n    {\n      errno = ENOSPC;\n      return NULL;\n    }\n\n  return strcpy (dst, tmp);\n}\n\n# endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}