{
  "module_name": "mbuiter.h",
  "hash_id": "0c8a53ae27586cf16b25dc359f0ec4799fd9bfd579b194feb41934288e529e46",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbuiter.h",
  "human_readable_source": " \n\n \n\n#ifndef _MBUITER_H\n#define _MBUITER_H 1\n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#include <assert.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <uchar.h>\n#include <wchar.h>\n\n#include \"mbchar.h\"\n#include \"strnlen1.h\"\n\n_GL_INLINE_HEADER_BEGIN\n#ifndef MBUITER_INLINE\n# define MBUITER_INLINE _GL_INLINE _GL_ATTRIBUTE_ALWAYS_INLINE\n#endif\n\nstruct mbuiter_multi\n{\n  #if !GNULIB_MBRTOC32_REGULAR\n  bool in_shift;         \n                         \n  #endif\n  mbstate_t state;       \n                         \n  bool next_done;        \n  unsigned int cur_max;  \n  struct mbchar cur;     \n};\n\nMBUITER_INLINE void\nmbuiter_multi_next (struct mbuiter_multi *iter)\n{\n  if (iter->next_done)\n    return;\n  #if !GNULIB_MBRTOC32_REGULAR\n  if (iter->in_shift)\n    goto with_shift;\n  #endif\n   \n  if (is_basic (*iter->cur.ptr))\n    {\n       \n      iter->cur.bytes = 1;\n      iter->cur.wc = *iter->cur.ptr;\n      iter->cur.wc_valid = true;\n    }\n  else\n    {\n      assert (mbsinit (&iter->state));\n      #if !GNULIB_MBRTOC32_REGULAR\n      iter->in_shift = true;\n    with_shift:\n      #endif\n      iter->cur.bytes = mbrtoc32 (&iter->cur.wc, iter->cur.ptr,\n                                  strnlen1 (iter->cur.ptr, iter->cur_max),\n                                  &iter->state);\n      if (iter->cur.bytes == (size_t) -1)\n        {\n           \n          iter->cur.bytes = 1;\n          iter->cur.wc_valid = false;\n           \n          #if !GNULIB_MBRTOC32_REGULAR\n          iter->in_shift = false;\n          #endif\n          mbszero (&iter->state);\n        }\n      else if (iter->cur.bytes == (size_t) -2)\n        {\n           \n          iter->cur.bytes = strlen (iter->cur.ptr);\n          iter->cur.wc_valid = false;\n           \n        }\n      else\n        {\n          if (iter->cur.bytes == 0)\n            {\n               \n              iter->cur.bytes = 1;\n              assert (*iter->cur.ptr == '\\0');\n              assert (iter->cur.wc == 0);\n            }\n          #if !GNULIB_MBRTOC32_REGULAR\n          else if (iter->cur.bytes == (size_t) -3)\n             \n            iter->cur.bytes = 0;\n          #endif\n          iter->cur.wc_valid = true;\n\n           \n          #if !GNULIB_MBRTOC32_REGULAR\n          if (mbsinit (&iter->state))\n            iter->in_shift = false;\n          #endif\n        }\n    }\n  iter->next_done = true;\n}\n\nMBUITER_INLINE void\nmbuiter_multi_reloc (struct mbuiter_multi *iter, ptrdiff_t ptrdiff)\n{\n  iter->cur.ptr += ptrdiff;\n}\n\nMBUITER_INLINE void\nmbuiter_multi_copy (struct mbuiter_multi *new_iter, const struct mbuiter_multi *old_iter)\n{\n  #if !GNULIB_MBRTOC32_REGULAR\n  if ((new_iter->in_shift = old_iter->in_shift))\n    memcpy (&new_iter->state, &old_iter->state, sizeof (mbstate_t));\n  else\n  #endif\n    mbszero (&new_iter->state);\n  new_iter->next_done = old_iter->next_done;\n  new_iter->cur_max = old_iter->cur_max;\n  mb_copy (&new_iter->cur, &old_iter->cur);\n}\n\n \ntypedef struct mbuiter_multi mbui_iterator_t;\n#if !GNULIB_MBRTOC32_REGULAR\n#define mbui_init(iter, startptr) \\\n  ((iter).cur.ptr = (startptr), \\\n   (iter).in_shift = false, mbszero (&(iter).state), \\\n   (iter).next_done = false, \\\n   (iter).cur_max = MB_CUR_MAX)\n#else\n \n#define mbui_init(iter, startptr) \\\n  ((iter).cur.ptr = (startptr), \\\n   mbszero (&(iter).state), \\\n   (iter).next_done = false, \\\n   (iter).cur_max = MB_CUR_MAX)\n#endif\n#define mbui_avail(iter) \\\n  (mbuiter_multi_next (&(iter)), !mb_isnul ((iter).cur))\n#define mbui_advance(iter) \\\n  ((iter).cur.ptr += (iter).cur.bytes, (iter).next_done = false)\n\n \n#define mbui_cur(iter) (iter).cur\n#define mbui_cur_ptr(iter) (iter).cur.ptr\n\n \n#define mbui_reloc(iter, ptrdiff) mbuiter_multi_reloc (&iter, ptrdiff)\n\n \n#define mbui_copy mbuiter_multi_copy\n\n_GL_INLINE_HEADER_END\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}