{
  "module_name": "rpmatch.c",
  "hash_id": "19096a596399c71a1896a9a9671a0c10060e017f9d4f5b1517151fb815e47d9b",
  "original_prompt": "Ingested from coreutils-9.4/lib/rpmatch.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <stdlib.h>\n\n#include <stddef.h>\n\n#if ENABLE_NLS\n# include <sys/types.h>\n# include <limits.h>\n# include <string.h>\n# if HAVE_LANGINFO_YESEXPR\n#  include <langinfo.h>\n# endif\n# include <regex.h>\n# include \"gettext.h\"\n# define _(msgid) gettext (msgid)\n# define N_(msgid) gettext_noop (msgid)\n\n# if HAVE_LANGINFO_YESEXPR\n \nstatic const char *\nlocalized_pattern (const char *english_pattern, nl_item nl_index,\n                   bool posixly_correct)\n{\n  const char *translated_pattern;\n\n   \n\n   \n  if (posixly_correct)\n    {\n      translated_pattern = nl_langinfo (nl_index);\n       \n      if (translated_pattern != NULL && translated_pattern[0] != '\\0')\n        return translated_pattern;\n   }\n\n   \n  translated_pattern = _(english_pattern);\n  if (translated_pattern == english_pattern)\n    {\n       \n      translated_pattern = nl_langinfo (nl_index);\n       \n      if (translated_pattern != NULL && translated_pattern[0] != '\\0')\n        return translated_pattern;\n       \n      translated_pattern = english_pattern;\n    }\n  return translated_pattern;\n}\n# else\n#  define localized_pattern(english_pattern,nl_index,posixly_correct) \\\n     _(english_pattern)\n# endif\n\nstatic int\ntry (const char *response, const char *pattern, char **lastp, regex_t *re)\n{\n  if (*lastp == NULL || strcmp (pattern, *lastp) != 0)\n    {\n      char *safe_pattern;\n\n       \n      if (*lastp != NULL)\n        {\n           \n          regfree (re);\n          free (*lastp);\n          *lastp = NULL;\n        }\n       \n      safe_pattern = strdup (pattern);\n      if (safe_pattern == NULL)\n        return -1;\n       \n      if (regcomp (re, safe_pattern, REG_EXTENDED) != 0)\n        {\n          free (safe_pattern);\n          return -1;\n        }\n      *lastp = safe_pattern;\n    }\n\n   \n  return regexec (re, response, 0, NULL, 0) == 0;\n}\n#endif\n\n\nint\nrpmatch (const char *response)\n{\n#if ENABLE_NLS\n   \n\n   \n  static char *last_yesexpr, *last_noexpr;\n  static regex_t cached_yesre, cached_nore;\n\n# if HAVE_LANGINFO_YESEXPR\n  bool posixly_correct = (getenv (\"POSIXLY_CORRECT\") != NULL);\n# endif\n\n  const char *yesexpr, *noexpr;\n  int result;\n\n   \n  yesexpr = localized_pattern (N_(\"^[yY]\"), YESEXPR, posixly_correct);\n  result = try (response, yesexpr, &last_yesexpr, &cached_yesre);\n  if (result < 0)\n    return -1;\n  if (result)\n    return 1;\n\n   \n  noexpr = localized_pattern (N_(\"^[nN]\"), NOEXPR, posixly_correct);\n  result = try (response, noexpr, &last_noexpr, &cached_nore);\n  if (result < 0)\n    return -1;\n  if (result)\n    return 0;\n\n  return -1;\n#else\n   \n  return (*response == 'y' || *response == 'Y' ? 1\n          : *response == 'n' || *response == 'N' ? 0 : -1);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}