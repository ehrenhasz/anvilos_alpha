{
  "module_name": "getloadavg.c",
  "hash_id": "8bad9d997d23bf2ae35e71962c411f37e6bb0d54c8a4d45913cfda44af335526",
  "original_prompt": "Ingested from coreutils-9.4/lib/getloadavg.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <stdlib.h>\n\n#include <errno.h>\n#include <stdio.h>\n\n# include <sys/types.h>\n\n# if HAVE_SYS_PARAM_H\n#  include <sys/param.h>\n# endif\n\n# include \"intprops.h\"\n\n# if defined _WIN32 && ! defined __CYGWIN__ && ! defined WINDOWS32\n#  define WINDOWS32\n# endif\n\n# ifdef NeXT\n \n#  undef BSD\n\n \n#  undef FSCALE\n# endif\n\n \n# ifdef __GNU__\n#  undef BSD\n#  undef FSCALE\n# endif  \n\n \n\n\n \n\n# if defined (HPUX) && !defined (hpux)\n#  define hpux\n# endif\n\n# if defined (__hpux) && !defined (hpux)\n#  define hpux\n# endif\n\n# if defined (__sun) && !defined (sun)\n#  define sun\n# endif\n\n# if defined (hp300) && !defined (hpux)\n#  define MORE_BSD\n# endif\n\n# if defined (__SVR4) && !defined (SVR4)\n#  define SVR4\n# endif\n\n# if (defined (sun) && defined (SVR4)) || defined (SOLARIS2)\n#  define SUNOS_5\n# endif\n\n# if defined (__osf__) && (defined (__alpha) || defined (__alpha__))\n#  define OSF_ALPHA\n#  include <sys/mbuf.h>\n#  include <sys/socket.h>\n#  include <net/route.h>\n#  include <sys/table.h>\n \n#  undef sys\n# endif\n\n# if defined (__osf__) && (defined (mips) || defined (__mips__))\n#  define OSF_MIPS\n#  include <sys/table.h>\n# endif\n\n\n \n# ifndef LOAD_AVE_TYPE\n\n#  ifdef MORE_BSD\n#   define LOAD_AVE_TYPE long\n#  endif\n\n#  ifdef sun\n#   define LOAD_AVE_TYPE long\n#  endif\n\n#  ifdef sgi\n#   define LOAD_AVE_TYPE long\n#  endif\n\n#  ifdef SVR4\n#   define LOAD_AVE_TYPE long\n#  endif\n\n#  ifdef OSF_ALPHA\n#   define LOAD_AVE_TYPE long\n#  endif\n\n#  if defined _AIX && ! defined HAVE_LIBPERFSTAT\n#   define LOAD_AVE_TYPE long\n#  endif\n\n# endif  \n\n# ifdef OSF_ALPHA\n \n#  undef FSCALE\n#  define FSCALE 1024.0\n# endif\n\n\n# ifndef FSCALE\n\n \n\n#  ifdef MORE_BSD\n#   define FSCALE 2048.0\n#  endif\n\n#  if defined (MIPS) || defined (SVR4)\n#   define FSCALE 256\n#  endif\n\n#  if defined (sgi)\n \n#   undef FSCALE\n#   define FSCALE 1000.0\n#  endif\n\n#  if defined _AIX && !defined HAVE_LIBPERFSTAT\n#   define FSCALE 65536.0\n#  endif\n\n# endif  \n\n# if !defined (LDAV_CVT) && defined (FSCALE)\n#  define LDAV_CVT(n) (((double) (n)) / FSCALE)\n# endif\n\n# ifndef NLIST_STRUCT\n#  if HAVE_NLIST_H\n#   define NLIST_STRUCT\n#  endif\n# endif\n\n# if defined (sgi) || (defined (mips) && !defined (BSD))\n#  define FIXUP_KERNEL_SYMBOL_ADDR(nl) ((nl)[0].n_value &= ~(1 << 31))\n# endif\n\n\n# if !defined (KERNEL_FILE) && defined (hpux)\n#  define KERNEL_FILE \"/hp-ux\"\n# endif\n\n# if !defined (KERNEL_FILE) && (defined (MIPS) || defined (SVR4) || defined (ISC) || defined (sgi))\n#  define KERNEL_FILE \"/unix\"\n# endif\n\n\n# if !defined (LDAV_SYMBOL) && (defined (hpux) || defined (SVR4) || defined (ISC) || defined (sgi) || (defined (_AIX) && !defined(HAVE_LIBPERFSTAT)))\n#  define LDAV_SYMBOL \"avenrun\"\n# endif\n\n# ifdef HAVE_UNISTD_H\n#  include <unistd.h>\n# endif\n\n \n# if !defined (LOAD_AVE_TYPE) && (defined (BSD) || defined (LDAV_CVT) || defined (KERNEL_FILE) || defined (LDAV_SYMBOL))\n#  define LOAD_AVE_TYPE double\n# endif\n\n# ifdef LOAD_AVE_TYPE\n\n#  ifndef __VMS\n#   if !(defined __linux__ || defined __ANDROID__)\n#    ifndef NLIST_STRUCT\n#     include <a.out.h>\n#    else  \n#     include <nlist.h>\n#    endif  \n\n#    ifdef SUNOS_5\n#     include <kvm.h>\n#     include <kstat.h>\n#    endif\n\n#    if defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)\n#     include <sys/pstat.h>\n#    endif\n\n#    ifndef KERNEL_FILE\n#     define KERNEL_FILE \"/vmunix\"\n#    endif  \n\n#    ifndef LDAV_SYMBOL\n#     define LDAV_SYMBOL \"_avenrun\"\n#    endif  \n#   endif  \n\n#  else  \n\n#   ifndef eunice\n#    include <iodef.h>\n#    include <descrip.h>\n#   else  \n#    include <vms/iodef.h>\n#   endif  \n#  endif  \n\n#  ifndef LDAV_CVT\n#   define LDAV_CVT(n) ((double) (n))\n#  endif  \n\n# endif  \n\n# if defined HAVE_LIBPERFSTAT\n#  include <sys/protosw.h>\n#  include <libperfstat.h>\n#  include <sys/proc.h>\n#  ifndef SBITS\n#   define SBITS 16\n#  endif\n# endif\n\n# if defined (__GNU__) && !defined (NeXT)\n \n \n#  define NeXT\n#  define host_self mach_host_self\n# endif\n\n# ifdef NeXT\n#  ifdef HAVE_MACH_MACH_H\n#   include <mach/mach.h>\n#  else\n#   include <mach.h>\n#  endif\n# endif  \n\n# ifdef sgi\n#  include <sys/sysmp.h>\n# endif  \n\n# ifdef UMAX\n#  include <signal.h>\n#  include <sys/time.h>\n#  include <sys/wait.h>\n#  include <sys/syscall.h>\n\n#  ifdef UMAX_43\n#   include <machine/cpu.h>\n#   include <inq_stats/statistics.h>\n#   include <inq_stats/sysstats.h>\n#   include <inq_stats/cpustats.h>\n#   include <inq_stats/procstats.h>\n#  else  \n#   include <sys/sysdefs.h>\n#   include <sys/statistics.h>\n#   include <sys/sysstats.h>\n#   include <sys/cpudefs.h>\n#   include <sys/cpustats.h>\n#   include <sys/procstats.h>\n#  endif  \n# endif  \n\n# ifdef DGUX\n#  include <sys/dg_sys_info.h>\n# endif\n\n# if (defined __linux__ || defined __ANDROID__ \\\n      || defined __CYGWIN__ || defined SUNOS_5 \\\n      || (defined LOAD_AVE_TYPE && ! defined __VMS))\n#  include <fcntl.h>\n# endif\n\f\n \n\n# ifdef NeXT\nstatic processor_set_t default_set;\nstatic bool getloadavg_initialized;\n# endif  \n\n# ifdef UMAX\nstatic unsigned int cpus = 0;\nstatic unsigned int samples;\n# endif  \n\n# ifdef DGUX\nstatic struct dg_sys_info_load_info load_info;   \n# endif  \n\n# if !defined (HAVE_LIBKSTAT) && defined (LOAD_AVE_TYPE)\n \nstatic int channel;\n \nstatic bool getloadavg_initialized;\n \nstatic long offset;\n\n#  if ! defined __VMS && ! defined sgi && ! (defined __linux__ || defined __ANDROID__)\nstatic struct nlist name_list[2];\n#  endif\n\n#  ifdef SUNOS_5\nstatic kvm_t *kd;\n#  endif  \n\n# endif  \n\f\n \n\nint\ngetloadavg (double loadavg[], int nelem)\n{\n  int elem = 0;                  \n\n# ifdef NO_GET_LOAD_AVG\n#  define LDAV_DONE\n  errno = ENOSYS;\n  elem = -1;\n# endif\n\n# if !defined (LDAV_DONE) && defined (HAVE_LIBKSTAT)        \n \n#  define LDAV_DONE\n  kstat_ctl_t *kc;\n  kstat_t *ksp;\n  kstat_named_t *kn;\n  int saved_errno;\n\n  kc = kstat_open ();\n  if (kc == NULL)\n    return -1;\n  ksp = kstat_lookup (kc, \"unix\", 0, \"system_misc\");\n  if (ksp == NULL)\n    return -1;\n  if (kstat_read (kc, ksp, 0) == -1)\n    return -1;\n\n\n  kn = kstat_data_lookup (ksp, \"avenrun_1min\");\n  if (kn == NULL)\n    {\n       \n      nelem = 0;\n      elem = -1;\n    }\n\n  if (nelem >= 1)\n    loadavg[elem++] = (double) kn->value.ul / FSCALE;\n\n  if (nelem >= 2)\n    {\n      kn = kstat_data_lookup (ksp, \"avenrun_5min\");\n      if (kn != NULL)\n        {\n          loadavg[elem++] = (double) kn->value.ul / FSCALE;\n\n          if (nelem >= 3)\n            {\n              kn = kstat_data_lookup (ksp, \"avenrun_15min\");\n              if (kn != NULL)\n                loadavg[elem++] = (double) kn->value.ul / FSCALE;\n            }\n        }\n    }\n\n  saved_errno = errno;\n  kstat_close (kc);\n  errno = saved_errno;\n# endif  \n\n# if !defined (LDAV_DONE) && defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)\n                                                            \n \n#  define LDAV_DONE\n#  undef LOAD_AVE_TYPE\n\n  struct pst_dynamic dyn_info;\n  if (pstat_getdynamic (&dyn_info, sizeof (dyn_info), 0, 0) < 0)\n    return -1;\n  if (nelem > 0)\n    loadavg[elem++] = dyn_info.psd_avg_1_min;\n  if (nelem > 1)\n    loadavg[elem++] = dyn_info.psd_avg_5_min;\n  if (nelem > 2)\n    loadavg[elem++] = dyn_info.psd_avg_15_min;\n\n# endif  \n\n# if ! defined LDAV_DONE && defined HAVE_LIBPERFSTAT        \n#  define LDAV_DONE\n#  undef LOAD_AVE_TYPE\n \n  {\n    perfstat_cpu_total_t cpu_stats;\n    int result = perfstat_cpu_total (NULL, &cpu_stats, sizeof cpu_stats, 1);\n    if (result == -1)\n      return result;\n    loadavg[0] = cpu_stats.loadavg[0] / (double)(1 << SBITS);\n    loadavg[1] = cpu_stats.loadavg[1] / (double)(1 << SBITS);\n    loadavg[2] = cpu_stats.loadavg[2] / (double)(1 << SBITS);\n    elem = 3;\n  }\n# endif\n\n# if !defined (LDAV_DONE) && (defined __linux__ || defined __ANDROID__ || defined __CYGWIN__)\n                                       \n#  define LDAV_DONE\n#  undef LOAD_AVE_TYPE\n\n#  ifndef LINUX_LDAV_FILE\n#   define LINUX_LDAV_FILE \"/proc/loadavg\"\n#  endif\n\n  char ldavgbuf[3 * (INT_STRLEN_BOUND (int) + sizeof \".00 \")];\n  char const *ptr = ldavgbuf;\n  int fd, count, saved_errno;\n\n  fd = open (LINUX_LDAV_FILE, O_RDONLY | O_CLOEXEC);\n  if (fd == -1)\n    return -1;\n  count = read (fd, ldavgbuf, sizeof ldavgbuf - 1);\n  saved_errno = errno;\n  (void) close (fd);\n  errno = saved_errno;\n  if (count <= 0)\n    return -1;\n  ldavgbuf[count] = '\\0';\n\n  for (elem = 0; elem < nelem; elem++)\n    {\n      double numerator = 0;\n      double denominator = 1;\n\n      while (*ptr == ' ')\n        ptr++;\n\n       \n      if (! ('0' <= *ptr && *ptr <= '9'))\n        {\n          if (elem == 0)\n            {\n              errno = ENOTSUP;\n              return -1;\n            }\n          break;\n        }\n\n      while ('0' <= *ptr && *ptr <= '9')\n        numerator = 10 * numerator + (*ptr++ - '0');\n\n      if (*ptr == '.')\n        for (ptr++; '0' <= *ptr && *ptr <= '9'; ptr++)\n          numerator = 10 * numerator + (*ptr - '0'), denominator *= 10;\n\n      loadavg[elem] = numerator / denominator;\n    }\n\n  return elem;\n\n# endif  \n\n# if !defined (LDAV_DONE) && defined (__NetBSD__)           \n#  define LDAV_DONE\n#  undef LOAD_AVE_TYPE\n\n#  ifndef NETBSD_LDAV_FILE\n#   define NETBSD_LDAV_FILE \"/kern/loadavg\"\n#  endif\n\n  unsigned long int load_ave[3], scale;\n  int count;\n  char readbuf[4 * INT_BUFSIZE_BOUND (unsigned long int) + 1];\n  int fd = open (NETBSD_LDAV_FILE, O_RDONLY | O_CLOEXEC);\n  if (fd < 0)\n    return fd;\n  int nread = read (fd, readbuf, sizeof readbuf - 1);\n  int err = errno;\n  close (fd);\n  if (nread < 0)\n    {\n      errno = err;\n      return -1;\n    }\n  readbuf[nread] = '\\0';\n  count = sscanf (readbuf, \"%lu %lu %lu %lu\\n\",\n                  &load_ave[0], &load_ave[1], &load_ave[2],\n                  &scale);\n  if (count != 4)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n\n  for (elem = 0; elem < nelem; elem++)\n    loadavg[elem] = (double) load_ave[elem] / (double) scale;\n\n  return elem;\n\n# endif  \n\n# if !defined (LDAV_DONE) && defined (NeXT)                 \n#  define LDAV_DONE\n   \n\n  host_t host;\n  struct processor_set_basic_info info;\n  unsigned int info_count;\n\n   \n\n  if (!getloadavg_initialized)\n    {\n      if (processor_set_default (host_self (), &default_set) == KERN_SUCCESS)\n        getloadavg_initialized = true;\n    }\n\n  if (getloadavg_initialized)\n    {\n      info_count = PROCESSOR_SET_BASIC_INFO_COUNT;\n      if (processor_set_info (default_set, PROCESSOR_SET_BASIC_INFO, &host,\n                              (processor_set_info_t) &info, &info_count)\n          != KERN_SUCCESS)\n        getloadavg_initialized = false;\n      else\n        {\n          if (nelem > 0)\n            loadavg[elem++] = (double) info.load_average / LOAD_SCALE;\n        }\n    }\n\n  if (!getloadavg_initialized)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n# endif  \n\n# if !defined (LDAV_DONE) && defined (UMAX)\n#  define LDAV_DONE\n \n\n  struct proc_summary proc_sum_data;\n  struct stat_descr proc_info;\n  double load;\n  register unsigned int i, j;\n\n  if (cpus == 0)\n    {\n      register unsigned int c, i;\n      struct cpu_config conf;\n      struct stat_descr desc;\n\n      desc.sd_next = 0;\n      desc.sd_subsys = SUBSYS_CPU;\n      desc.sd_type = CPUTYPE_CONFIG;\n      desc.sd_addr = (char *) &conf;\n      desc.sd_size = sizeof conf;\n\n      if (inq_stats (1, &desc))\n        return -1;\n\n      c = 0;\n      for (i = 0; i < conf.config_maxclass; ++i)\n        {\n          struct class_stats stats;\n          memset (&stats, 0, sizeof stats);\n\n          desc.sd_type = CPUTYPE_CLASS;\n          desc.sd_objid = i;\n          desc.sd_addr = (char *) &stats;\n          desc.sd_size = sizeof stats;\n\n          if (inq_stats (1, &desc))\n            return -1;\n\n          c += stats.class_numcpus;\n        }\n      cpus = c;\n      samples = cpus < 2 ? 3 : (2 * cpus / 3);\n    }\n\n  proc_info.sd_next = 0;\n  proc_info.sd_subsys = SUBSYS_PROC;\n  proc_info.sd_type = PROCTYPE_SUMMARY;\n  proc_info.sd_addr = (char *) &proc_sum_data;\n  proc_info.sd_size = sizeof (struct proc_summary);\n  proc_info.sd_sizeused = 0;\n\n  if (inq_stats (1, &proc_info) != 0)\n    return -1;\n\n  load = proc_sum_data.ps_nrunnable;\n  j = 0;\n  for (i = samples - 1; i > 0; --i)\n    {\n      load += proc_sum_data.ps_nrun[j];\n      if (j++ == PS_NRUNSIZE)\n        j = 0;\n    }\n\n  if (nelem > 0)\n    loadavg[elem++] = load / samples / cpus;\n# endif  \n\n# if !defined (LDAV_DONE) && defined (DGUX)\n#  define LDAV_DONE\n   \n  dg_sys_info ((long int *) &load_info,\n               DG_SYS_INFO_LOAD_INFO_TYPE,\n               DG_SYS_INFO_LOAD_VERSION_0);\n\n  if (nelem > 0)\n    loadavg[elem++] = load_info.one_minute;\n  if (nelem > 1)\n    loadavg[elem++] = load_info.five_minute;\n  if (nelem > 2)\n    loadavg[elem++] = load_info.fifteen_minute;\n# endif  \n\n# if !defined (LDAV_DONE) && defined (apollo)\n#  define LDAV_DONE\n \n\n  extern void proc1_$get_loadav ();\n  unsigned long load_ave[3];\n\n  proc1_$get_loadav (load_ave);\n\n  if (nelem > 0)\n    loadavg[elem++] = load_ave[0] / 65536.0;\n  if (nelem > 1)\n    loadavg[elem++] = load_ave[1] / 65536.0;\n  if (nelem > 2)\n    loadavg[elem++] = load_ave[2] / 65536.0;\n# endif  \n\n# if !defined (LDAV_DONE) && defined (OSF_MIPS)\n#  define LDAV_DONE\n\n  struct tbl_loadavg load_ave;\n  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));\n  loadavg[elem++]\n    = (load_ave.tl_lscale == 0\n       ? load_ave.tl_avenrun.d[0]\n       : (load_ave.tl_avenrun.l[0] / (double) load_ave.tl_lscale));\n# endif  \n\n# if !defined (LDAV_DONE) && (defined (__MSDOS__) || defined (WINDOWS32))\n                                                            \n#  define LDAV_DONE\n\n   \n  for ( ; elem < nelem; elem++)\n    {\n      loadavg[elem] = 0.0;\n    }\n# endif   \n\n# if !defined (LDAV_DONE) && defined (OSF_ALPHA)            \n#  define LDAV_DONE\n\n  struct tbl_loadavg load_ave;\n  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));\n  for (elem = 0; elem < nelem; elem++)\n    loadavg[elem]\n      = (load_ave.tl_lscale == 0\n         ? load_ave.tl_avenrun.d[elem]\n         : (load_ave.tl_avenrun.l[elem] / (double) load_ave.tl_lscale));\n# endif  \n\n# if ! defined LDAV_DONE && defined __VMS                   \n   \n\n  LOAD_AVE_TYPE load_ave[3];\n  static bool getloadavg_initialized;\n#  ifdef eunice\n  struct\n  {\n    int dsc$w_length;\n    char *dsc$a_pointer;\n  } descriptor;\n#  endif\n\n   \n  if (!getloadavg_initialized)\n    {\n       \n#  ifdef eunice\n      descriptor.dsc$w_length = 18;\n      descriptor.dsc$a_pointer = \"$$VMS_LOAD_AVERAGE\";\n#  else\n      $DESCRIPTOR (descriptor, \"LAV0:\");\n#  endif\n      if (sys$assign (&descriptor, &channel, 0, 0) & 1)\n        getloadavg_initialized = true;\n    }\n\n   \n  if (getloadavg_initialized\n      && !(sys$qiow (0, channel, IO$_READVBLK, 0, 0, 0,\n                     load_ave, 12, 0, 0, 0, 0) & 1))\n    {\n      sys$dassgn (channel);\n      getloadavg_initialized = false;\n    }\n\n  if (!getloadavg_initialized)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n# endif  \n\n# if ! defined LDAV_DONE && defined LOAD_AVE_TYPE && ! defined __VMS\n                                                   \n\n   \n\n#  define LDAV_PRIVILEGED                \n\n  LOAD_AVE_TYPE load_ave[3];\n\n   \n  if (offset == 0)\n    {\n#  ifndef sgi\n#   if ! defined NLIST_STRUCT || ! defined N_NAME_POINTER\n      strcpy (name_list[0].n_name, LDAV_SYMBOL);\n      strcpy (name_list[1].n_name, \"\");\n#   else  \n#    ifdef HAVE_STRUCT_NLIST_N_UN_N_NAME\n      name_list[0].n_un.n_name = LDAV_SYMBOL;\n      name_list[1].n_un.n_name = 0;\n#    else  \n      name_list[0].n_name = LDAV_SYMBOL;\n      name_list[1].n_name = 0;\n#    endif  \n#   endif  \n\n#   ifndef SUNOS_5\n      if (\n#    if !defined (_AIX)\n          nlist (KERNEL_FILE, name_list)\n#    else   \n          knlist (name_list, 1, sizeof (name_list[0]))\n#    endif\n          >= 0)\n           \n          {\n#    ifdef FIXUP_KERNEL_SYMBOL_ADDR\n            FIXUP_KERNEL_SYMBOL_ADDR (name_list);\n#    endif\n            offset = name_list[0].n_value;\n          }\n#   endif  \n#  else   \n      ptrdiff_t ldav_off = sysmp (MP_KERNADDR, MPKA_AVENRUN);\n      if (ldav_off != -1)\n        offset = (long int) ldav_off & 0x7fffffff;\n#  endif  \n    }\n\n   \n  if (!getloadavg_initialized)\n    {\n#  ifndef SUNOS_5\n      int fd = open (\"/dev/kmem\", O_RDONLY | O_CLOEXEC);\n      if (0 <= fd)\n        {\n          channel = fd;\n          getloadavg_initialized = true;\n        }\n#  else  \n       \n      kd = kvm_open (0, 0, 0, O_RDONLY, 0);\n      if (kd != NULL)\n        {\n           \n          kvm_nlist (kd, name_list);\n          offset = name_list[0].n_value;\n          getloadavg_initialized = true;\n        }\n#  endif  \n    }\n\n   \n  if (offset && getloadavg_initialized)\n    {\n       \n#  ifndef SUNOS_5\n      if (lseek (channel, offset, 0) == -1L\n          || read (channel, (char *) load_ave, sizeof (load_ave))\n          != sizeof (load_ave))\n        {\n          close (channel);\n          getloadavg_initialized = false;\n        }\n#  else   \n      if (kvm_read (kd, offset, (char *) load_ave, sizeof (load_ave))\n          != sizeof (load_ave))\n        {\n          kvm_close (kd);\n          getloadavg_initialized = false;\n        }\n#  endif  \n    }\n\n  if (offset == 0 || !getloadavg_initialized)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n# endif  \n\n# if !defined (LDAV_DONE) && defined (LOAD_AVE_TYPE)  \n  if (nelem > 0)\n    loadavg[elem++] = LDAV_CVT (load_ave[0]);\n  if (nelem > 1)\n    loadavg[elem++] = LDAV_CVT (load_ave[1]);\n  if (nelem > 2)\n    loadavg[elem++] = LDAV_CVT (load_ave[2]);\n\n#  define LDAV_DONE\n# endif  \n\n# if !defined LDAV_DONE\n  errno = ENOSYS;\n  elem = -1;\n# endif\n  return elem;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}