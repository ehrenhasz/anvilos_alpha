{
  "module_name": "utimecmp.c",
  "hash_id": "72750e9478d47702baab0f148d74286e964b199f641bbe80de7979e62630bfde",
  "original_prompt": "Ingested from coreutils-9.4/lib/utimecmp.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"utimecmp.h\"\n\n#include <fcntl.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"dirname.h\"\n#include \"hash.h\"\n#include \"intprops.h\"\n#include \"stat-time.h\"\n\n#ifndef MAX\n# define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n#define BILLION (1000 * 1000 * 1000)\n\n \n#if HAVE_UTIMENSAT\nenum { SYSCALL_RESOLUTION = 1 };\n#elif defined _WIN32 && ! defined __CYGWIN__\n \nstruct fs_res\n{\n   \n  dev_t dev;\n\n   \n  int resolution;\n\n   \n  bool exact;\n};\n\n \nstatic size_t\ndev_info_hash (void const *x, size_t table_size)\n{\n  struct fs_res const *p = x;\n\n   \n  if (TYPE_SIGNED (dev_t) && SIZE_MAX < MAX (INT_MAX, TYPE_MAXIMUM (dev_t)))\n    {\n      uintmax_t dev = p->dev;\n      return dev % table_size;\n    }\n\n  return p->dev % table_size;\n}\n\n \nstatic bool\ndev_info_compare (void const *x, void const *y)\n{\n  struct fs_res const *a = x;\n  struct fs_res const *b = y;\n  return a->dev == b->dev;\n}\n\n \n\nint\nutimecmp (char const *dst_name,\n          struct stat const *dst_stat,\n          struct stat const *src_stat,\n          int options)\n{\n  return utimecmpat (AT_FDCWD, dst_name, dst_stat, src_stat, options);\n}\n\nint\nutimecmpat (int dfd, char const *dst_name,\n            struct stat const *dst_stat,\n            struct stat const *src_stat,\n            int options)\n{\n   \n\n  static_assert (TYPE_IS_INTEGER (time_t));\n\n   \n  time_t dst_s = dst_stat->st_mtime;\n  time_t src_s = src_stat->st_mtime;\n  int dst_ns = get_stat_mtime_ns (dst_stat);\n  int src_ns = get_stat_mtime_ns (src_stat);\n\n  if (options & UTIMECMP_TRUNCATE_SOURCE)\n    {\n#if defined _AIX\n       \n      long long difference =\n        ((long long) dst_s - (long long) src_s) * BILLION\n        + ((long long) dst_ns - (long long) src_ns);\n      if (difference < 10000000 && difference > -10000000)\n        return 0;\n#endif\n\n       \n\n       \n      static Hash_table *ht;\n\n       \n      static struct fs_res *new_dst_res;\n      struct fs_res *dst_res = NULL;\n      struct fs_res tmp_dst_res;\n\n       \n      int res;\n\n       \n      if (dst_s == src_s && dst_ns == src_ns)\n        return 0;\n      if (dst_s <= src_s - 2)\n        return -1;\n      if (src_s <= dst_s - 2)\n        return 1;\n\n       \n      if (! ht)\n        ht = hash_initialize (16, NULL, dev_info_hash, dev_info_compare, free);\n      if (ht)\n        {\n          if (! new_dst_res)\n            {\n              new_dst_res = malloc (sizeof *new_dst_res);\n              if (!new_dst_res)\n                goto low_memory;\n              new_dst_res->resolution = 2 * BILLION;\n              new_dst_res->exact = false;\n            }\n          new_dst_res->dev = dst_stat->st_dev;\n          dst_res = hash_insert (ht, new_dst_res);\n          if (! dst_res)\n            goto low_memory;\n\n          if (dst_res == new_dst_res)\n            {\n               \n              new_dst_res = NULL;\n            }\n        }\n      else\n        {\n        low_memory:\n          if (ht)\n            {\n              tmp_dst_res.dev = dst_stat->st_dev;\n              dst_res = hash_lookup (ht, &tmp_dst_res);\n            }\n          if (!dst_res)\n            {\n              dst_res = &tmp_dst_res;\n              dst_res->resolution = 2 * BILLION;\n              dst_res->exact = false;\n            }\n        }\n\n      res = dst_res->resolution;\n\n#ifdef _PC_TIMESTAMP_RESOLUTION\n       \n      if (! dst_res->exact)\n        {\n          res = -1;\n          if (dfd == AT_FDCWD)\n            res = pathconf (dst_name, _PC_TIMESTAMP_RESOLUTION);\n          else\n            {\n              char *dstdir = mdir_name (dst_name);\n              if (dstdir)\n                {\n                  int destdirfd = openat (dfd, dstdir,\n                                          O_SEARCH | O_CLOEXEC | O_DIRECTORY);\n                  if (0 <= destdirfd)\n                    {\n                      res = fpathconf (destdirfd, _PC_TIMESTAMP_RESOLUTION);\n                      close (destdirfd);\n                    }\n                  free (dstdir);\n                }\n            }\n          if (0 < res)\n            {\n              dst_res->resolution = res;\n              dst_res->exact = true;\n            }\n        }\n#endif\n\n      if (! dst_res->exact)\n        {\n           \n\n          time_t dst_a_s = dst_stat->st_atime;\n          time_t dst_c_s = dst_stat->st_ctime;\n          time_t dst_m_s = dst_s;\n          int dst_a_ns = get_stat_atime_ns (dst_stat);\n          int dst_c_ns = get_stat_ctime_ns (dst_stat);\n          int dst_m_ns = dst_ns;\n\n           \n          {\n            bool odd_second = (dst_a_s | dst_c_s | dst_m_s) & 1;\n\n            if (SYSCALL_RESOLUTION == BILLION)\n              {\n                if (odd_second | dst_a_ns | dst_c_ns | dst_m_ns)\n                  res = BILLION;\n              }\n            else\n              {\n                int a = dst_a_ns;\n                int c = dst_c_ns;\n                int m = dst_m_ns;\n\n                 \n                int SR10 = SYSCALL_RESOLUTION;  SR10 *= 10;\n\n                if ((a % SR10 | c % SR10 | m % SR10) != 0)\n                  res = SYSCALL_RESOLUTION;\n                else\n                  for (res = SR10, a /= SR10, c /= SR10, m /= SR10;\n                       (res < dst_res->resolution\n                        && (a % 10 | c % 10 | m % 10) == 0);\n                       res *= 10, a /= 10, c /= 10, m /= 10)\n                    if (res == BILLION)\n                      {\n                        if (! odd_second)\n                          res *= 2;\n                        break;\n                      }\n              }\n\n            dst_res->resolution = res;\n          }\n\n          if (SYSCALL_RESOLUTION < res)\n            {\n              struct stat dst_status;\n\n               \n              src_ns -= src_ns % SYSCALL_RESOLUTION;\n\n               \n              {\n                time_t s = src_s & ~ (res == 2 * BILLION ? 1 : 0);\n                if (src_s < dst_s || (src_s == dst_s && src_ns <= dst_ns))\n                  return 1;\n                if (dst_s < s\n                    || (dst_s == s && dst_ns < src_ns - src_ns % res))\n                  return -1;\n              }\n\n               \n\n              struct timespec timespec[2] = {\n                [0].tv_sec = dst_a_s,\n                [0].tv_nsec = dst_a_ns,\n                [1].tv_sec = dst_m_s | (res == 2 * BILLION),\n                [1].tv_nsec = dst_m_ns + res / 9\n              };\n\n              if (utimensat (dfd, dst_name, timespec, AT_SYMLINK_NOFOLLOW))\n                return -2;\n\n               \n              {\n                int stat_result\n                  = fstatat (dfd, dst_name, &dst_status, AT_SYMLINK_NOFOLLOW);\n\n                if (stat_result\n                    | (dst_status.st_mtime ^ dst_m_s)\n                    | (get_stat_mtime_ns (&dst_status) ^ dst_m_ns))\n                  {\n                     \n                    timespec[1].tv_sec = dst_m_s;\n                    timespec[1].tv_nsec = dst_m_ns;\n                    utimensat (dfd, dst_name, timespec, AT_SYMLINK_NOFOLLOW);\n                  }\n\n                if (stat_result != 0)\n                  return -2;\n              }\n\n               \n              {\n                int old_res = res;\n                int a = (BILLION * (dst_status.st_mtime & 1)\n                         + get_stat_mtime_ns (&dst_status));\n\n                res = SYSCALL_RESOLUTION;\n\n                for (a /= res; a % 10 == 0; a /= 10)\n                  {\n                    if (res == BILLION)\n                      {\n                        res *= 2;\n                        break;\n                      }\n                    res *= 10;\n                    if (res == old_res)\n                      break;\n                  }\n              }\n            }\n\n          dst_res->resolution = res;\n          dst_res->exact = true;\n        }\n\n       \n      src_s &= ~ (res == 2 * BILLION ? 1 : 0);\n      src_ns -= src_ns % res;\n    }\n\n   \n  return (_GL_CMP (dst_s, src_s)\n          + ((dst_s == src_s ? ~0 : 0) & _GL_CMP (dst_ns, src_ns)));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}