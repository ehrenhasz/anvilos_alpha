{
  "module_name": "boot-time-aux.h",
  "hash_id": "b4436acb4a1b318ecad4107a883798d033f8997ab3ea459f54c01edd413e44d9",
  "original_prompt": "Ingested from coreutils-9.4/lib/boot-time-aux.h",
  "human_readable_source": " \n\n#define SIZEOF(a) (sizeof(a)/sizeof(a[0]))\n\n#if defined __linux__ || defined __ANDROID__\n\n \n_GL_ATTRIBUTE_MAYBE_UNUSED\nstatic int\nget_linux_uptime (struct timespec *p_uptime)\n{\n   \n# if !defined __GLIBC__ || 2 < __GLIBC__ + (17 <= __GLIBC_MINOR__)\n  if (clock_gettime (CLOCK_BOOTTIME, p_uptime) >= 0)\n    return 0;\n# endif\n\n   \n# if !defined __ANDROID__\n  FILE *fp = fopen (\"/proc/uptime\", \"re\");\n  if (fp != NULL)\n    {\n      char buf[32 + 1];\n      size_t n = fread (buf, 1, sizeof (buf) - 1, fp);\n      fclose (fp);\n      if (n > 0)\n        {\n          buf[n] = '\\0';\n           \n          time_t s = 0;\n          char *p;\n          for (p = buf; '0' <= *p && *p <= '9'; p++)\n            s = 10 * s + (*p - '0');\n          if (buf < p)\n            {\n              long ns = 0;\n              if (*p++ == '.')\n                for (int i = 0; i < 9; i++)\n                  ns = 10 * ns + ('0' <= *p && *p <= '9' ? *p++ - '0' : 0);\n              p_uptime->tv_sec = s;\n              p_uptime->tv_nsec = ns;\n              return 0;\n            }\n        }\n    }\n# endif\n\n# if HAVE_DECL_SYSINFO  \n   \n  struct sysinfo info;\n  if (sysinfo (&info) >= 0)\n    {\n      p_uptime->tv_sec = info.uptime;\n      p_uptime->tv_nsec = 0;\n      return 0;\n    }\n# endif\n\n  return -1;\n}\n\n#endif\n\n#if defined __linux__ && !defined __ANDROID__\n\nstatic int\nget_linux_boot_time_fallback (struct timespec *p_boot_time)\n{\n   \n\n  const char * const boot_touched_files[] =\n    {\n      \"/var/lib/systemd/random-seed\",  \n      \"/var/lib/urandom/random-seed\",  \n      \"/var/lib/random-seed\",          \n       \n      \"/var/run/utmp\"                  \n    };\n  for (idx_t i = 0; i < SIZEOF (boot_touched_files); i++)\n    {\n      const char *filename = boot_touched_files[i];\n      struct stat statbuf;\n      if (stat (filename, &statbuf) >= 0)\n        {\n          *p_boot_time = get_stat_mtime (&statbuf);\n          return 0;\n        }\n    }\n  return -1;\n}\n\n \nstatic int\nget_linux_boot_time_final_fallback (struct timespec *p_boot_time)\n{\n  struct timespec uptime;\n  if (get_linux_uptime (&uptime) >= 0)\n    {\n      struct timespec result;\n# if !defined __GLIBC__ || 2 < __GLIBC__ + (16 <= __GLIBC_MINOR__)\n       \n      if (! timespec_get (&result, TIME_UTC))\n        return -1;\n#  else\n       \n      struct timeval tv;\n      int r = gettimeofday (&tv, NULL);\n      if (r < 0)\n        return r;\n      result.tv_sec = tv.tv_sec;\n      result.tv_nsec = tv.tv_usec * 1000;\n#  endif\n\n      if (result.tv_nsec < uptime.tv_nsec)\n        {\n          result.tv_nsec += 1000000000;\n          result.tv_sec -= 1;\n        }\n      result.tv_sec -= uptime.tv_sec;\n      result.tv_nsec -= uptime.tv_nsec;\n      *p_boot_time = result;\n      return 0;\n    }\n  return -1;\n}\n\n#endif\n\n#if defined __ANDROID__\n\nstatic int\nget_android_boot_time (struct timespec *p_boot_time)\n{\n   \n  struct timespec uptime;\n  if (get_linux_uptime (&uptime) >= 0)\n    {\n      struct timespec result;\n      if (clock_gettime (CLOCK_REALTIME, &result) >= 0)\n        {\n          if (result.tv_nsec < uptime.tv_nsec)\n            {\n              result.tv_nsec += 1000000000;\n              result.tv_sec -= 1;\n            }\n          result.tv_sec -= uptime.tv_sec;\n          result.tv_nsec -= uptime.tv_nsec;\n          *p_boot_time = result;\n          return 0;\n        }\n    }\n  return -1;\n}\n\n#endif\n\n#if defined __OpenBSD__\n\nstatic int\nget_openbsd_boot_time (struct timespec *p_boot_time)\n{\n   \n  const char * const boot_touched_files[] =\n    {\n      \"/var/db/host.random\",\n      \"/var/run/utmp\"\n    };\n  for (idx_t i = 0; i < SIZEOF (boot_touched_files); i++)\n    {\n      const char *filename = boot_touched_files[i];\n      struct stat statbuf;\n      if (stat (filename, &statbuf) >= 0)\n        {\n          *p_boot_time = get_stat_mtime (&statbuf);\n          return 0;\n        }\n    }\n  return -1;\n}\n\n#endif\n\n#if HAVE_SYS_SYSCTL_H && HAVE_SYSCTL \\\n    && defined CTL_KERN && defined KERN_BOOTTIME \\\n    && !defined __minix\n \n \n\n \nstatic int\nget_bsd_boot_time_final_fallback (struct timespec *p_boot_time)\n{\n  static int request[2] = { CTL_KERN, KERN_BOOTTIME };\n  struct timeval result;\n  size_t result_len = sizeof result;\n\n  if (sysctl (request, 2, &result, &result_len, NULL, 0) >= 0)\n    {\n      p_boot_time->tv_sec = result.tv_sec;\n      p_boot_time->tv_nsec = result.tv_usec * 1000;\n      return 0;\n    }\n  return -1;\n}\n\n#endif\n\n#if defined __HAIKU__\n\nstatic int\nget_haiku_boot_time (struct timespec *p_boot_time)\n{\n   \n  const char * const boot_touched_file = \"/dev/input\";\n  struct stat statbuf;\n  if (stat (boot_touched_file, &statbuf) >= 0)\n    {\n      *p_boot_time = get_stat_mtime (&statbuf);\n      return 0;\n    }\n  return -1;\n}\n\n#endif\n\n#if HAVE_OS_H  \n\n \nstatic int\nget_haiku_boot_time_final_fallback (struct timespec *p_boot_time)\n{\n  system_info si;\n\n  get_system_info (&si);\n  p_boot_time->tv_sec = si.boot_time / 1000000;\n  p_boot_time->tv_nsec = (si.boot_time % 1000000) * 1000;\n  return 0;\n}\n\n#endif\n\n#if defined __CYGWIN__ || defined _WIN32\n\nstatic int\nget_windows_boot_time (struct timespec *p_boot_time)\n{\n   \n  const char * const boot_touched_file =\n    #if defined __CYGWIN__ && !defined _WIN32\n    \"/cygdrive/c/pagefile.sys\"\n    #else\n    \"C:\\\\pagefile.sys\"\n    #endif\n    ;\n  struct stat statbuf;\n  if (stat (boot_touched_file, &statbuf) >= 0)\n    {\n      *p_boot_time = get_stat_mtime (&statbuf);\n      return 0;\n    }\n  return -1;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}