{
  "module_name": "at-func.c",
  "hash_id": "e45d3845853f3b2daa4c6e52ea95a30aaeca0d133d5e824dc0371617b0ac4c1d",
  "original_prompt": "Ingested from coreutils-9.4/lib/at-func.c",
  "human_readable_source": " \n\n#include \"filename.h\"  \n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n# include <errno.h>\n# ifndef ENOTSUP\n#  define ENOTSUP EINVAL\n# endif\n#else\n# include \"openat.h\"\n# include \"openat-priv.h\"\n# include \"save-cwd.h\"\n#endif\n\n#ifdef AT_FUNC_USE_F1_COND\n# define CALL_FUNC(F)                           \\\n  (flag == AT_FUNC_USE_F1_COND                  \\\n    ? AT_FUNC_F1 (F AT_FUNC_POST_FILE_ARGS)     \\\n    : AT_FUNC_F2 (F AT_FUNC_POST_FILE_ARGS))\n# define VALIDATE_FLAG(F)                       \\\n  if (flag & ~AT_FUNC_USE_F1_COND)              \\\n    {                                           \\\n      errno = EINVAL;                           \\\n      return FUNC_FAIL;                         \\\n    }\n#else\n# define CALL_FUNC(F) (AT_FUNC_F1 (F AT_FUNC_POST_FILE_ARGS))\n# define VALIDATE_FLAG(F)  \n#endif\n\n#ifdef AT_FUNC_RESULT\n# define FUNC_RESULT AT_FUNC_RESULT\n#else\n# define FUNC_RESULT int\n#endif\n\n#ifdef AT_FUNC_FAIL\n# define FUNC_FAIL AT_FUNC_FAIL\n#else\n# define FUNC_FAIL -1\n#endif\n\n \nFUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n   \n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n         \n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n       \n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}\n#undef CALL_FUNC\n#undef FUNC_RESULT\n#undef FUNC_FAIL\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}