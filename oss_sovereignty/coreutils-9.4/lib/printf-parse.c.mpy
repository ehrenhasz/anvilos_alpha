{
  "module_name": "printf-parse.c",
  "hash_id": "1dc9e4ba8a1f0da9b4c4f5df4286166536c3e6370332a67de45ce80b43b968f8",
  "original_prompt": "Ingested from coreutils-9.4/lib/printf-parse.c",
  "human_readable_source": " \n\n#ifndef PRINTF_PARSE\n# include <config.h>\n#endif\n\n \n#ifndef PRINTF_PARSE\n# include \"printf-parse.h\"\n#endif\n\n \n#ifndef PRINTF_PARSE\n# define PRINTF_PARSE printf_parse\n# define CHAR_T char\n# define DIRECTIVE char_directive\n# define DIRECTIVES char_directives\n#endif\n\n \n#include <stddef.h>\n\n \n#include <stdint.h>\n\n \n#include <stdlib.h>\n\n \n#include <string.h>\n\n \n#include <errno.h>\n\n \n#include \"xsize.h\"\n\n#if CHAR_T_ONLY_ASCII\n \n# include \"c-ctype.h\"\n#endif\n\n#ifdef STATIC\nSTATIC\n#endif\nint\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;     \n  size_t arg_posn = 0;           \n  size_t d_allocated;            \n  size_t a_allocated;            \n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n                            \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n                                                    \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n                           \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count];  \n\n           \n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n           \n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                     \n                    goto error;\n                  if (size_overflow_p (n))\n                     \n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n           \n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n           \n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n               \n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                         \n                        goto error;\n                      if (size_overflow_p (n))\n                         \n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                     \n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n           \n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                   \n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                             \n                            goto error;\n                          if (size_overflow_p (n))\n                             \n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                         \n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n             \n             \n            arg_type signed_type = TYPE_INT;\n             \n            arg_type unsigned_type = TYPE_UINT;\n             \n            arg_type pointer_type = TYPE_COUNT_INT_POINTER;\n             \n            arg_type floatingpoint_type = TYPE_DOUBLE;\n\n            if (*cp == 'h')\n              {\n                if (cp[1] == 'h')\n                  {\n                    signed_type = TYPE_SCHAR;\n                    unsigned_type = TYPE_UCHAR;\n                    pointer_type = TYPE_COUNT_SCHAR_POINTER;\n                    cp += 2;\n                  }\n                else\n                  {\n                    signed_type = TYPE_SHORT;\n                    unsigned_type = TYPE_USHORT;\n                    pointer_type = TYPE_COUNT_SHORT_POINTER;\n                    cp++;\n                  }\n              }\n            else if (*cp == 'l')\n              {\n                if (cp[1] == 'l')\n                  {\n                    signed_type = TYPE_LONGLONGINT;\n                    unsigned_type = TYPE_ULONGLONGINT;\n                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                     \n                    floatingpoint_type = TYPE_LONGDOUBLE;\n                    cp += 2;\n                  }\n                else\n                  {\n                    signed_type = TYPE_LONGINT;\n                    unsigned_type = TYPE_ULONGINT;\n                    pointer_type = TYPE_COUNT_LONGINT_POINTER;\n                    cp++;\n                  }\n              }\n            else if (*cp == 'j')\n              {\n                if (sizeof (intmax_t) > sizeof (long))\n                  {\n                     \n                    signed_type = TYPE_LONGLONGINT;\n                    unsigned_type = TYPE_ULONGLONGINT;\n                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                     \n                    floatingpoint_type = TYPE_LONGDOUBLE;\n                  }\n                else if (sizeof (intmax_t) > sizeof (int))\n                  {\n                     \n                    signed_type = TYPE_LONGINT;\n                    unsigned_type = TYPE_ULONGINT;\n                    pointer_type = TYPE_COUNT_LONGINT_POINTER;\n                  }\n                cp++;\n              }\n            else if (*cp == 'z' || *cp == 'Z')\n              {\n                 \n                if (sizeof (size_t) > sizeof (long))\n                  {\n                     \n                    signed_type = TYPE_LONGLONGINT;\n                    unsigned_type = TYPE_ULONGLONGINT;\n                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                     \n                    floatingpoint_type = TYPE_LONGDOUBLE;\n                  }\n                else if (sizeof (size_t) > sizeof (int))\n                  {\n                     \n                    signed_type = TYPE_LONGINT;\n                    unsigned_type = TYPE_ULONGINT;\n                    pointer_type = TYPE_COUNT_LONGINT_POINTER;\n                  }\n                cp++;\n              }\n            else if (*cp == 't')\n              {\n                if (sizeof (ptrdiff_t) > sizeof (long))\n                  {\n                     \n                    signed_type = TYPE_LONGLONGINT;\n                    unsigned_type = TYPE_ULONGLONGINT;\n                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                     \n                    floatingpoint_type = TYPE_LONGDOUBLE;\n                  }\n                else if (sizeof (ptrdiff_t) > sizeof (int))\n                  {\n                     \n                    signed_type = TYPE_LONGINT;\n                    unsigned_type = TYPE_ULONGINT;\n                    pointer_type = TYPE_COUNT_LONGINT_POINTER;\n                  }\n                cp++;\n              }\n            else if (*cp == 'w')\n              {\n                 \n                if (cp[1] == 'f')\n                  {\n                    if (cp[2] == '8')\n                      {\n                        signed_type = TYPE_INT_FAST8_T;\n                        unsigned_type = TYPE_UINT_FAST8_T;\n                        pointer_type = TYPE_COUNT_INT_FAST8_T_POINTER;\n                        cp += 3;\n                      }\n                    else if (cp[2] == '1' && cp[3] == '6')\n                      {\n                        signed_type = TYPE_INT_FAST16_T;\n                        unsigned_type = TYPE_UINT_FAST16_T;\n                        pointer_type = TYPE_COUNT_INT_FAST16_T_POINTER;\n                        cp += 4;\n                      }\n                    else if (cp[2] == '3' && cp[3] == '2')\n                      {\n                        signed_type = TYPE_INT_FAST32_T;\n                        unsigned_type = TYPE_UINT_FAST32_T;\n                        pointer_type = TYPE_COUNT_INT_FAST32_T_POINTER;\n                        cp += 4;\n                      }\n                    else if (cp[2] == '6' && cp[3] == '4')\n                      {\n                        signed_type = TYPE_INT_FAST64_T;\n                        unsigned_type = TYPE_UINT_FAST64_T;\n                        pointer_type = TYPE_COUNT_INT_FAST64_T_POINTER;\n                        cp += 4;\n                      }\n                  }\n                else\n                  {\n                    if (cp[1] == '8')\n                      {\n                        signed_type = TYPE_INT8_T;\n                        unsigned_type = TYPE_UINT8_T;\n                        pointer_type = TYPE_COUNT_INT8_T_POINTER;\n                        cp += 2;\n                      }\n                    else if (cp[1] == '1' && cp[2] == '6')\n                      {\n                        signed_type = TYPE_INT16_T;\n                        unsigned_type = TYPE_UINT16_T;\n                        pointer_type = TYPE_COUNT_INT16_T_POINTER;\n                        cp += 3;\n                      }\n                    else if (cp[1] == '3' && cp[2] == '2')\n                      {\n                        signed_type = TYPE_INT32_T;\n                        unsigned_type = TYPE_UINT32_T;\n                        pointer_type = TYPE_COUNT_INT32_T_POINTER;\n                        cp += 3;\n                      }\n                    else if (cp[1] == '6' && cp[2] == '4')\n                      {\n                        signed_type = TYPE_INT64_T;\n                        unsigned_type = TYPE_UINT64_T;\n                        pointer_type = TYPE_COUNT_INT64_T_POINTER;\n                        cp += 3;\n                      }\n                  }\n              }\n            else if (*cp == 'L')\n              {\n                signed_type = TYPE_LONGLONGINT;\n                unsigned_type = TYPE_ULONGLONGINT;\n                pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                floatingpoint_type = TYPE_LONGDOUBLE;\n                cp++;\n              }\n#if defined __APPLE__ && defined __MACH__\n             \n            else if (*cp == 'q')\n              {\n                if (64 / 8 > sizeof (long))\n                  {\n                     \n                    signed_type = TYPE_LONGLONGINT;\n                    unsigned_type = TYPE_ULONGLONGINT;\n                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                     \n                    floatingpoint_type = TYPE_LONGDOUBLE;\n                  }\n                else\n                  {\n                     \n                    signed_type = TYPE_LONGINT;\n                    unsigned_type = TYPE_ULONGINT;\n                    pointer_type = TYPE_COUNT_LONGINT_POINTER;\n                  }\n                cp++;\n              }\n#endif\n#if defined _WIN32 && ! defined __CYGWIN__\n             \n            else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n              {\n                if (64 / 8 > sizeof (long))\n                  {\n                     \n                    signed_type = TYPE_LONGLONGINT;\n                    unsigned_type = TYPE_ULONGLONGINT;\n                    pointer_type = TYPE_COUNT_LONGLONGINT_POINTER;\n                     \n                    floatingpoint_type = TYPE_LONGDOUBLE;\n                  }\n                else\n                  {\n                     \n                    signed_type = TYPE_LONGINT;\n                    unsigned_type = TYPE_ULONGINT;\n                    pointer_type = TYPE_COUNT_LONGINT_POINTER;\n                  }\n                cp++;\n              }\n#endif\n\n             \n            c = *cp++;\n            switch (c)\n              {\n              case 'd': case 'i':\n                type = signed_type;\n                break;\n              case 'b': case 'o': case 'u': case 'x': case 'X':\n              #if SUPPORT_GNU_PRINTF_DIRECTIVES \\\n                  || (__GLIBC__ + (__GLIBC_MINOR__ >= 35) > 2)\n              case 'B':\n              #endif\n                type = unsigned_type;\n                break;\n              case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n              case 'a': case 'A':\n                type = floatingpoint_type;\n                break;\n              case 'c':\n                if (signed_type == TYPE_LONGINT\n                     \n                    || signed_type == TYPE_LONGLONGINT)\n#if HAVE_WINT_T\n                  type = TYPE_WIDE_CHAR;\n#else\n                  goto error;\n#endif\n                else\n                  type = TYPE_CHAR;\n                break;\n#if HAVE_WINT_T\n              case 'C':\n                type = TYPE_WIDE_CHAR;\n                c = 'c';\n                break;\n#endif\n              case 's':\n                if (signed_type == TYPE_LONGINT\n                     \n                    || signed_type == TYPE_LONGLONGINT)\n#if HAVE_WCHAR_T\n                  type = TYPE_WIDE_STRING;\n#else\n                  goto error;\n#endif\n                else\n                  type = TYPE_STRING;\n                break;\n#if HAVE_WCHAR_T\n              case 'S':\n                type = TYPE_WIDE_STRING;\n                c = 's';\n                break;\n#endif\n              case 'p':\n                type = TYPE_POINTER;\n                break;\n              case 'n':\n                type = pointer_type;\n                break;\n#if ENABLE_UNISTDIO\n               \n              case 'U':\n                if (signed_type == TYPE_LONGLONGINT)\n                  type = TYPE_U32_STRING;\n                else if (signed_type == TYPE_LONGINT)\n                  type = TYPE_U16_STRING;\n                else\n                  type = TYPE_U8_STRING;\n                break;\n#endif\n              case '%':\n                type = TYPE_NONE;\n                break;\n              default:\n                 \n                goto error;\n              }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                       \n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                 \n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                 \n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n           \n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}\n\n#undef PRINTF_PARSE\n#undef DIRECTIVES\n#undef DIRECTIVE\n#undef CHAR_T_ONLY_ASCII\n#undef CHAR_T\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}