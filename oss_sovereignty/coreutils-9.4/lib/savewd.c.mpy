{
  "module_name": "savewd.c",
  "hash_id": "2dbf4c27e66ab77d713406f00c5cd2e3fdcbe2eb3dbe4835a302e7c537a521cc",
  "original_prompt": "Ingested from coreutils-9.4/lib/savewd.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#define SAVEWD_INLINE _GL_EXTERN_INLINE\n\n#include \"savewd.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"assure.h\"\n#include \"attribute.h\"\n#include \"fcntl-safer.h\"\n#include \"filename.h\"\n\n \nstatic bool\nsavewd_save (struct savewd *wd)\n{\n  switch (wd->state)\n    {\n    case INITIAL_STATE:\n       \n      {\n        int fd = open_safer (\".\", O_SEARCH);\n        if (0 <= fd)\n          {\n            wd->state = FD_STATE;\n            wd->val.fd = fd;\n            break;\n          }\n        if (errno != EACCES && errno != ESTALE)\n          {\n            wd->state = ERROR_STATE;\n            wd->val.errnum = errno;\n            break;\n          }\n      }\n      wd->state = FORKING_STATE;\n      wd->val.child = -1;\n      FALLTHROUGH;\n    case FORKING_STATE:\n      if (wd->val.child < 0)\n        {\n           \n          wd->val.child = fork ();\n          if (wd->val.child != 0)\n            {\n              if (0 < wd->val.child)\n                return true;\n              wd->state = ERROR_STATE;\n              wd->val.errnum = errno;\n            }\n        }\n      break;\n\n    case FD_STATE:\n    case FD_POST_CHDIR_STATE:\n    case ERROR_STATE:\n    case FINAL_STATE:\n      break;\n\n    default:\n      assure (false);\n    }\n\n  return false;\n}\n\nint\nsavewd_chdir (struct savewd *wd, char const *dir, int options,\n              int open_result[2])\n{\n  int fd = -1;\n  int result = 0;\n\n   \n  if (open_result\n      || (options & (HAVE_WORKING_O_NOFOLLOW ? SAVEWD_CHDIR_NOFOLLOW : 0)))\n    {\n      fd = open (dir,\n                 (O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK\n                  | (options & SAVEWD_CHDIR_NOFOLLOW ? O_NOFOLLOW : 0)));\n\n      if (open_result)\n        {\n          open_result[0] = fd;\n          open_result[1] = errno;\n        }\n\n      if (fd < 0 && errno != EACCES)\n        result = -1;\n    }\n\n  if (result == 0 && ! (0 <= fd && options & SAVEWD_CHDIR_SKIP_READABLE))\n    {\n      if (savewd_save (wd))\n        {\n          open_result = NULL;\n          result = -2;\n        }\n      else\n        {\n          result = (fd < 0 ? chdir (dir) : fchdir (fd));\n\n          if (result == 0)\n            switch (wd->state)\n              {\n              case FD_STATE:\n                wd->state = FD_POST_CHDIR_STATE;\n                break;\n\n              case ERROR_STATE:\n              case FD_POST_CHDIR_STATE:\n              case FINAL_STATE:\n                break;\n\n              case FORKING_STATE:\n                assure (wd->val.child == 0);\n                break;\n\n              default:\n                assure (false);\n              }\n        }\n    }\n\n  if (0 <= fd && ! open_result)\n    {\n      int e = errno;\n      close (fd);\n      errno = e;\n    }\n\n  return result;\n}\n\nint\nsavewd_restore (struct savewd *wd, int status)\n{\n  switch (wd->state)\n    {\n    case INITIAL_STATE:\n    case FD_STATE:\n       \n      break;\n\n    case FD_POST_CHDIR_STATE:\n       \n      if (fchdir (wd->val.fd) == 0)\n        {\n          wd->state = FD_STATE;\n          break;\n        }\n      else\n        {\n          int chdir_errno = errno;\n          close (wd->val.fd);\n          wd->state = ERROR_STATE;\n          wd->val.errnum = chdir_errno;\n        }\n      FALLTHROUGH;\n    case ERROR_STATE:\n       \n      errno = wd->val.errnum;\n      return -1;\n\n    case FORKING_STATE:\n       \n      {\n        pid_t child = wd->val.child;\n        if (child == 0)\n          _exit (status);\n        if (0 < child)\n          {\n            int child_status;\n            while (waitpid (child, &child_status, 0) < 0)\n              assure (errno == EINTR);\n            wd->val.child = -1;\n            if (! WIFEXITED (child_status))\n              raise (WTERMSIG (child_status));\n            return WEXITSTATUS (child_status);\n          }\n      }\n      break;\n\n    default:\n      assure (false);\n    }\n\n  return 0;\n}\n\nvoid\nsavewd_finish (struct savewd *wd)\n{\n  switch (wd->state)\n    {\n    case INITIAL_STATE:\n    case ERROR_STATE:\n      break;\n\n    case FD_STATE:\n    case FD_POST_CHDIR_STATE:\n      close (wd->val.fd);\n      break;\n\n    case FORKING_STATE:\n      assure (wd->val.child < 0);\n      break;\n\n    default:\n      assure (false);\n    }\n\n  wd->state = FINAL_STATE;\n}\n\n \nstatic bool\nsavewd_delegating (struct savewd const *wd)\n{\n  return wd->state == FORKING_STATE && 0 < wd->val.child;\n}\n\nint\nsavewd_process_files (int n_files, char **file,\n                      int (*act) (char *, struct savewd *, void *),\n                      void *options)\n{\n  int i = 0;\n  int last_relative;\n  int exit_status = EXIT_SUCCESS;\n  struct savewd wd;\n  savewd_init (&wd);\n\n  for (last_relative = n_files - 1; 0 <= last_relative; last_relative--)\n    if (! IS_ABSOLUTE_FILE_NAME (file[last_relative]))\n      break;\n\n  for (; i < last_relative; i++)\n    {\n      if (! savewd_delegating (&wd))\n        {\n          int s = act (file[i], &wd, options);\n          if (exit_status < s)\n            exit_status = s;\n        }\n\n      if (! IS_ABSOLUTE_FILE_NAME (file[i + 1]))\n        {\n          int r = savewd_restore (&wd, exit_status);\n          if (exit_status < r)\n            exit_status = r;\n        }\n    }\n\n  savewd_finish (&wd);\n\n  for (; i < n_files; i++)\n    {\n      int s = act (file[i], &wd, options);\n      if (exit_status < s)\n        exit_status = s;\n    }\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}