{
  "module_name": "sm3.c",
  "hash_id": "5d5c887296a7c99f61c17c718bb52a57d412d634b0e51ed76b8fbb39731e6756",
  "original_prompt": "Ingested from coreutils-9.4/lib/sm3.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#if HAVE_OPENSSL_SM3\n# define GL_OPENSSL_INLINE _GL_EXTERN_INLINE\n#endif\n#include \"sm3.h\"\n\n#include <stdint.h>\n#include <string.h>\n\n#include <byteswap.h>\n#ifdef WORDS_BIGENDIAN\n# define SWAP(n) (n)\n#else\n# define SWAP(n) bswap_32 (n)\n#endif\n\n#ifndef DEBUG_SM3\n# define DEBUG_SM3 0\n#endif\n\n#if ! DEBUG_SM3\n# define dbg_printf(fmt, ...) do { } while (0)\n#else\n# define dbg_printf printf\n#endif\n\n#if ! HAVE_OPENSSL_SM3\n\n \nstatic const unsigned char fillbuf[64] = { 0x80, 0   };\n\n\n \nvoid\nsm3_init_ctx (struct sm3_ctx *ctx)\n{\n  ctx->state[0] = 0x7380166fUL;\n  ctx->state[1] = 0x4914b2b9UL;\n  ctx->state[2] = 0x172442d7UL;\n  ctx->state[3] = 0xda8a0600UL;\n  ctx->state[4] = 0xa96f30bcUL;\n  ctx->state[5] = 0x163138aaUL;\n  ctx->state[6] = 0xe38dee4dUL;\n  ctx->state[7] = 0xb0fb0e4eUL;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}\n\n \nstatic void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}\n\n \nvoid *\nsm3_read_ctx (const struct sm3_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 8; i++)\n    set_uint32 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}\n\n \nstatic void\nsm3_conclude_ctx (struct sm3_ctx *ctx)\n{\n   \n  size_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n   \n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n   \n  set_uint32 ((char *) &ctx->buffer[size - 2],\n              SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29)));\n  set_uint32 ((char *) &ctx->buffer[size - 1],\n              SWAP (ctx->total[0] << 3));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n   \n  sm3_process_block (ctx->buffer, size * 4, ctx);\n}\n\nvoid *\nsm3_finish_ctx (struct sm3_ctx *ctx, void *resbuf)\n{\n  sm3_conclude_ctx (ctx);\n  return sm3_read_ctx (ctx, resbuf);\n}\n\n \nvoid *\nsm3_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sm3_ctx ctx;\n\n   \n  sm3_init_ctx (&ctx);\n\n   \n  sm3_process_bytes (buffer, len, &ctx);\n\n   \n  return sm3_finish_ctx (&ctx, resblock);\n}\n\nvoid\nsm3_process_bytes (const void *buffer, size_t len, struct sm3_ctx *ctx)\n{\n   \n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          sm3_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n           \n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n   \n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            sm3_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          sm3_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n   \n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          sm3_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n           \n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}\n\n \n\n \n#define T(j) sm3_round_constants[j]\nstatic const uint32_t sm3_round_constants[64] = {\n  0x79cc4519UL, 0xf3988a32UL, 0xe7311465UL, 0xce6228cbUL,\n  0x9cc45197UL, 0x3988a32fUL, 0x7311465eUL, 0xe6228cbcUL,\n  0xcc451979UL, 0x988a32f3UL, 0x311465e7UL, 0x6228cbceUL,\n  0xc451979cUL, 0x88a32f39UL, 0x11465e73UL, 0x228cbce6UL,\n  0x9d8a7a87UL, 0x3b14f50fUL, 0x7629ea1eUL, 0xec53d43cUL,\n  0xd8a7a879UL, 0xb14f50f3UL, 0x629ea1e7UL, 0xc53d43ceUL,\n  0x8a7a879dUL, 0x14f50f3bUL, 0x29ea1e76UL, 0x53d43cecUL,\n  0xa7a879d8UL, 0x4f50f3b1UL, 0x9ea1e762UL, 0x3d43cec5UL,\n  0x7a879d8aUL, 0xf50f3b14UL, 0xea1e7629UL, 0xd43cec53UL,\n  0xa879d8a7UL, 0x50f3b14fUL, 0xa1e7629eUL, 0x43cec53dUL,\n  0x879d8a7aUL, 0x0f3b14f5UL, 0x1e7629eaUL, 0x3cec53d4UL,\n  0x79d8a7a8UL, 0xf3b14f50UL, 0xe7629ea1UL, 0xcec53d43UL,\n  0x9d8a7a87UL, 0x3b14f50fUL, 0x7629ea1eUL, 0xec53d43cUL,\n  0xd8a7a879UL, 0xb14f50f3UL, 0x629ea1e7UL, 0xc53d43ceUL,\n  0x8a7a879dUL, 0x14f50f3bUL, 0x29ea1e76UL, 0x53d43cecUL,\n  0xa7a879d8UL, 0x4f50f3b1UL, 0x9ea1e762UL, 0x3d43cec5UL,\n};\n\n \n#define FF1(X,Y,Z) ( X ^ Y ^ Z )\n#define FF2(X,Y,Z) ( ( X & Y ) | ( X & Z ) | ( Y & Z ) )\n#define GG1(X,Y,Z) ( X ^ Y ^ Z )\n#define GG2(X,Y,Z) ( ( X & Y ) | ( ~X & Z ) )\n\n \n\nvoid\nsm3_process_block (const void *buffer, size_t len, struct sm3_ctx *ctx)\n{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->state[0];\n  uint32_t b = ctx->state[1];\n  uint32_t c = ctx->state[2];\n  uint32_t d = ctx->state[3];\n  uint32_t e = ctx->state[4];\n  uint32_t f = ctx->state[5];\n  uint32_t g = ctx->state[6];\n  uint32_t h = ctx->state[7];\n  uint32_t lolen = len;\n\n   \n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << ((n) & 31)) | ((x) >> ((32 - (n)) & 31)))\n#define P0(x) ((x)^rol(x,9)^rol(x,17))\n#define P1(x) ((x)^rol(x,15)^rol(x,23))\n\n#define W1(I) ( x[I&0x0f] )\n#define W2(I) ( tw =   P1(x[I&0x0f]^x[(I-9)&0x0f]^rol(x[(I-3)&0x0f],15)) \\\n                     ^ rol(x[(I-13)&0x0f],7) ^ x[(I-6)&0x0f] \\\n                , x[I&0x0f] = tw )\n\n#define R(i,A,B,C,D,E,F,G,H,T,W1,W2) \\\n  do { \\\n       if (++j) \\\n         dbg_printf(\"%2d %08x %08x %08x %08x %08x %08x %08x %08x\\n\", \\\n                    j-1, A, B, C, D, E, F, G, H); \\\n       ss1 = rol(rol(A,12) + E + T,7); \\\n       ss2 = ss1 ^ rol(A,12); \\\n       D += FF##i(A,B,C) + ss2 + (W1 ^ W2); \\\n       H += GG##i(E,F,G) + ss1 + W1; \\\n       B = rol(B,9); \\\n       F = rol(F,19); \\\n       H = P0(H); \\\n     } while(0)\n\n#define R1(A,B,C,D,E,F,G,H,T,W1,W2) R(1,A,B,C,D,E,F,G,H,T,W1,W2)\n#define R2(A,B,C,D,E,F,G,H,T,W1,W2) R(2,A,B,C,D,E,F,G,H,T,W1,W2)\n\n  while (words < endp)\n    {\n      uint32_t tw;\n      uint32_t ss1, ss2;\n      int j;\n\n      for (j = 0; j < 16; j++)\n        {\n          x[j] = SWAP (*words);\n          words++;\n        }\n\n      j = -1;\n\n      dbg_printf (\" j    A        B        C        D        E  \"\n                  \"      F        G        H\\n\"\n                  \"   %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n                  a, b, c, d, e, f, g, h);\n\n      R1( a, b, c, d, e, f, g, h, T( 0), W1( 0), W1( 4) );\n      R1( d, a, b, c, h, e, f, g, T( 1), W1( 1), W1( 5) );\n      R1( c, d, a, b, g, h, e, f, T( 2), W1( 2), W1( 6) );\n      R1( b, c, d, a, f, g, h, e, T( 3), W1( 3), W1( 7) );\n      R1( a, b, c, d, e, f, g, h, T( 4), W1( 4), W1( 8) );\n      R1( d, a, b, c, h, e, f, g, T( 5), W1( 5), W1( 9) );\n      R1( c, d, a, b, g, h, e, f, T( 6), W1( 6), W1(10) );\n      R1( b, c, d, a, f, g, h, e, T( 7), W1( 7), W1(11) );\n      R1( a, b, c, d, e, f, g, h, T( 8), W1( 8), W1(12) );\n      R1( d, a, b, c, h, e, f, g, T( 9), W1( 9), W1(13) );\n      R1( c, d, a, b, g, h, e, f, T(10), W1(10), W1(14) );\n      R1( b, c, d, a, f, g, h, e, T(11), W1(11), W1(15) );\n      R1( a, b, c, d, e, f, g, h, T(12), W1(12), W2(16) );\n      R1( d, a, b, c, h, e, f, g, T(13), W1(13), W2(17) );\n      R1( c, d, a, b, g, h, e, f, T(14), W1(14), W2(18) );\n      R1( b, c, d, a, f, g, h, e, T(15), W1(15), W2(19) );\n      R2( a, b, c, d, e, f, g, h, T(16), W1(16), W2(20) );\n      R2( d, a, b, c, h, e, f, g, T(17), W1(17), W2(21) );\n      R2( c, d, a, b, g, h, e, f, T(18), W1(18), W2(22) );\n      R2( b, c, d, a, f, g, h, e, T(19), W1(19), W2(23) );\n      R2( a, b, c, d, e, f, g, h, T(20), W1(20), W2(24) );\n      R2( d, a, b, c, h, e, f, g, T(21), W1(21), W2(25) );\n      R2( c, d, a, b, g, h, e, f, T(22), W1(22), W2(26) );\n      R2( b, c, d, a, f, g, h, e, T(23), W1(23), W2(27) );\n      R2( a, b, c, d, e, f, g, h, T(24), W1(24), W2(28) );\n      R2( d, a, b, c, h, e, f, g, T(25), W1(25), W2(29) );\n      R2( c, d, a, b, g, h, e, f, T(26), W1(26), W2(30) );\n      R2( b, c, d, a, f, g, h, e, T(27), W1(27), W2(31) );\n      R2( a, b, c, d, e, f, g, h, T(28), W1(28), W2(32) );\n      R2( d, a, b, c, h, e, f, g, T(29), W1(29), W2(33) );\n      R2( c, d, a, b, g, h, e, f, T(30), W1(30), W2(34) );\n      R2( b, c, d, a, f, g, h, e, T(31), W1(31), W2(35) );\n      R2( a, b, c, d, e, f, g, h, T(32), W1(32), W2(36) );\n      R2( d, a, b, c, h, e, f, g, T(33), W1(33), W2(37) );\n      R2( c, d, a, b, g, h, e, f, T(34), W1(34), W2(38) );\n      R2( b, c, d, a, f, g, h, e, T(35), W1(35), W2(39) );\n      R2( a, b, c, d, e, f, g, h, T(36), W1(36), W2(40) );\n      R2( d, a, b, c, h, e, f, g, T(37), W1(37), W2(41) );\n      R2( c, d, a, b, g, h, e, f, T(38), W1(38), W2(42) );\n      R2( b, c, d, a, f, g, h, e, T(39), W1(39), W2(43) );\n      R2( a, b, c, d, e, f, g, h, T(40), W1(40), W2(44) );\n      R2( d, a, b, c, h, e, f, g, T(41), W1(41), W2(45) );\n      R2( c, d, a, b, g, h, e, f, T(42), W1(42), W2(46) );\n      R2( b, c, d, a, f, g, h, e, T(43), W1(43), W2(47) );\n      R2( a, b, c, d, e, f, g, h, T(44), W1(44), W2(48) );\n      R2( d, a, b, c, h, e, f, g, T(45), W1(45), W2(49) );\n      R2( c, d, a, b, g, h, e, f, T(46), W1(46), W2(50) );\n      R2( b, c, d, a, f, g, h, e, T(47), W1(47), W2(51) );\n      R2( a, b, c, d, e, f, g, h, T(48), W1(48), W2(52) );\n      R2( d, a, b, c, h, e, f, g, T(49), W1(49), W2(53) );\n      R2( c, d, a, b, g, h, e, f, T(50), W1(50), W2(54) );\n      R2( b, c, d, a, f, g, h, e, T(51), W1(51), W2(55) );\n      R2( a, b, c, d, e, f, g, h, T(52), W1(52), W2(56) );\n      R2( d, a, b, c, h, e, f, g, T(53), W1(53), W2(57) );\n      R2( c, d, a, b, g, h, e, f, T(54), W1(54), W2(58) );\n      R2( b, c, d, a, f, g, h, e, T(55), W1(55), W2(59) );\n      R2( a, b, c, d, e, f, g, h, T(56), W1(56), W2(60) );\n      R2( d, a, b, c, h, e, f, g, T(57), W1(57), W2(61) );\n      R2( c, d, a, b, g, h, e, f, T(58), W1(58), W2(62) );\n      R2( b, c, d, a, f, g, h, e, T(59), W1(59), W2(63) );\n      R2( a, b, c, d, e, f, g, h, T(60), W1(60), W2(64) );\n      R2( d, a, b, c, h, e, f, g, T(61), W1(61), W2(65) );\n      R2( c, d, a, b, g, h, e, f, T(62), W1(62), W2(66) );\n      R2( b, c, d, a, f, g, h, e, T(63), W1(63), W2(67) );\n\n      dbg_printf(\"%2d %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n                 j, a, b, c, d, e, f, g, h);\n\n      a = ctx->state[0] ^= a;\n      b = ctx->state[1] ^= b;\n      c = ctx->state[2] ^= c;\n      d = ctx->state[3] ^= d;\n      e = ctx->state[4] ^= e;\n      f = ctx->state[5] ^= f;\n      g = ctx->state[6] ^= g;\n      h = ctx->state[7] ^= h;\n    }\n}\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}