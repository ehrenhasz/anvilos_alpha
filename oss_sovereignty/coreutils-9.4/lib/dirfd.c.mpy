{
  "module_name": "dirfd.c",
  "hash_id": "dd3bf51b4b8567da1fe6c52600ea4b8881640bdf054e23c2be62fe88d3497bc6",
  "original_prompt": "Ingested from coreutils-9.4/lib/dirfd.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <dirent.h>\n#include <errno.h>\n\n#if GNULIB_defined_DIR\n# include \"dirent-private.h\"\n#endif\n\n#ifdef __KLIBC__\n# include <stdlib.h>\n# include <io.h>\n\nstatic struct dirp_fd_list\n{\n  DIR *dirp;\n  int fd;\n  struct dirp_fd_list *next;\n} *dirp_fd_start = NULL;\n\n \nint\n_gl_register_dirp_fd (int fd, DIR *dirp)\n{\n  struct dirp_fd_list *new_dirp_fd = malloc (sizeof *new_dirp_fd);\n  if (!new_dirp_fd)\n    return -1;\n\n  new_dirp_fd->dirp = dirp;\n  new_dirp_fd->fd = fd;\n  new_dirp_fd->next = dirp_fd_start;\n\n  dirp_fd_start = new_dirp_fd;\n\n  return 0;\n}\n\n \nvoid\n_gl_unregister_dirp_fd (int fd)\n{\n  struct dirp_fd_list *dirp_fd;\n  struct dirp_fd_list *dirp_fd_prev;\n\n  for (dirp_fd_prev = NULL, dirp_fd = dirp_fd_start; dirp_fd;\n       dirp_fd_prev = dirp_fd, dirp_fd = dirp_fd->next)\n    {\n      if (dirp_fd->fd == fd)\n        {\n          if (dirp_fd_prev)\n            dirp_fd_prev->next = dirp_fd->next;\n          else   \n            dirp_fd_start = dirp_fd_start->next;\n\n          close (fd);\n          free (dirp_fd);\n          break;\n        }\n    }\n}\n#endif\n\nint\ndirfd (DIR *dir_p)\n{\n#if GNULIB_defined_DIR\n  int fd = dir_p->fd_to_close;\n  if (fd == -1)\n    errno = EINVAL;\n  return fd;\n#else\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n# ifndef __KLIBC__\n    errno = ENOTSUP;\n# else\n    {\n      struct dirp_fd_list *dirp_fd;\n\n      for (dirp_fd = dirp_fd_start; dirp_fd; dirp_fd = dirp_fd->next)\n        if (dirp_fd->dirp == dir_p)\n          return dirp_fd->fd;\n\n      errno = EINVAL;\n    }\n# endif\n\n  return fd;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}