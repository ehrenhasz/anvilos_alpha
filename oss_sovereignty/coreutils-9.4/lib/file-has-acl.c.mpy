{
  "module_name": "file-has-acl.c",
  "hash_id": "cfdfe6bdf70c65e09cc4d7cc93cf49f2fc8a8d5b21cb905428b8dec01e82013d",
  "original_prompt": "Ingested from coreutils-9.4/lib/file-has-acl.c",
  "human_readable_source": " \n\n \n#if (__GNUC__ == 4 && 6 <= __GNUC_MINOR__) || 4 < __GNUC__\n# pragma GCC diagnostic ignored \"-Wsuggest-attribute=const\"\n#endif\n\n#include <config.h>\n\n#include \"acl.h\"\n\n#include \"acl-internal.h\"\n#include \"attribute.h\"\n#include \"minmax.h\"\n\n#if USE_ACL && HAVE_LINUX_XATTR_H && HAVE_LISTXATTR\n# include <stdckdint.h>\n# include <string.h>\n# include <arpa/inet.h>\n# include <sys/xattr.h>\n# include <linux/xattr.h>\n# ifndef XATTR_NAME_NFSV4_ACL\n#  define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n# endif\n# ifndef XATTR_NAME_POSIX_ACL_ACCESS\n#  define XATTR_NAME_POSIX_ACL_ACCESS \"system.posix_acl_access\"\n# endif\n# ifndef XATTR_NAME_POSIX_ACL_DEFAULT\n#  define XATTR_NAME_POSIX_ACL_DEFAULT \"system.posix_acl_default\"\n# endif\n\nenum {\n   \n  ACE4_ACCESS_DENIED_ACE_TYPE  = 0x00000001,\n  ACE4_IDENTIFIER_GROUP        = 0x00000040\n};\n\n \n\nATTRIBUTE_PURE static bool\nhave_xattr (char const *attr, char const *listbuf, ssize_t listsize)\n{\n  char const *blim = listbuf + listsize;\n  for (char const *b = listbuf; b < blim; b += strlen (b) + 1)\n    for (char const *a = attr; *a == *b; a++, b++)\n      if (!*a)\n        return true;\n  return false;\n}\n\n \n\nstatic int\nacl_nfs4_nontrivial (uint32_t *xattr, ssize_t nbytes)\n{\n  enum { BYTES_PER_NETWORK_UINT = 4};\n\n   \n  nbytes -= BYTES_PER_NETWORK_UINT;\n  if (nbytes < 0)\n    return -1;\n  uint32_t num_aces = ntohl (*xattr++);\n  if (6 < num_aces)\n    return 1;\n  int ace_found = 0;\n\n  for (int ace_n = 0; ace_n < num_aces; ace_n++)\n    {\n       \n      nbytes -= 4 * BYTES_PER_NETWORK_UINT;\n      if (nbytes < 0)\n        return -1;\n      uint32_t type = ntohl (xattr[0]);\n      uint32_t flag = ntohl (xattr[1]);\n      uint32_t wholen = ntohl (xattr[3]);\n      xattr += 4;\n      int whowords = (wholen / BYTES_PER_NETWORK_UINT\n                      + (wholen % BYTES_PER_NETWORK_UINT != 0));\n      int64_t wholen4 = whowords;\n      wholen4 *= BYTES_PER_NETWORK_UINT;\n\n       \n      if (ACE4_ACCESS_DENIED_ACE_TYPE < type)\n        return 1;\n\n       \n      if (flag & ~ACE4_IDENTIFIER_GROUP)\n        return 1;\n\n       \n      if (nbytes - wholen4 < 0)\n        return -1;\n      nbytes -= wholen4;\n\n       \n      int who2\n        = (wholen == 6 && memcmp (xattr, \"OWNER@\", 6) == 0 ? 0\n           : wholen == 6 && memcmp (xattr, \"GROUP@\", 6) == 0 ? 2\n           : wholen == 9 && memcmp (xattr, \"EVERYONE@\", 9) == 0 ? 4\n           : -1);\n      if (who2 < 0)\n        return 1;\n      int ace_found_bit = 1 << (who2 | type);\n      if (ace_found & ace_found_bit)\n        return 1;\n      ace_found |= ace_found_bit;\n\n      xattr += whowords;\n    }\n\n  return 0;\n}\n#endif\n\n \n\nint\nfile_has_acl (char const *name, struct stat const *sb)\n{\n#if USE_ACL\n  if (! S_ISLNK (sb->st_mode))\n    {\n\n# if HAVE_LINUX_XATTR_H && HAVE_LISTXATTR\n      int initial_errno = errno;\n\n       \n      typedef uint32_t trivial_NFSv4_xattr_buf[2 * (6 + 6 + 7)];\n\n       \n      union {\n        trivial_NFSv4_xattr_buf xattr;\n        char ch[sizeof (trivial_NFSv4_xattr_buf)];\n      } stackbuf;\n\n      char *listbuf = stackbuf.ch;\n      ssize_t listbufsize = sizeof stackbuf.ch;\n      char *heapbuf = NULL;\n      ssize_t listsize;\n\n       \n      while ((listsize = listxattr (name, listbuf, listbufsize)) < 0\n             && errno == ERANGE)\n        {\n          free (heapbuf);\n          ssize_t newsize = listxattr (name, NULL, 0);\n          if (newsize <= 0)\n            return newsize;\n\n           \n          bool overflow = ckd_add (&listbufsize, listbufsize, listbufsize >> 1);\n          listbufsize = MAX (listbufsize, newsize);\n          if (overflow || SIZE_MAX < listbufsize)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n\n          listbuf = heapbuf = malloc (listbufsize);\n          if (!listbuf)\n            return -1;\n        }\n\n       \n      bool nfsv4_acl\n        = 0 < listsize && have_xattr (XATTR_NAME_NFSV4_ACL, listbuf, listsize);\n      int ret\n        = (listsize <= 0 ? listsize\n           : (nfsv4_acl\n              || have_xattr (XATTR_NAME_POSIX_ACL_ACCESS, listbuf, listsize)\n              || (S_ISDIR (sb->st_mode)\n                  && have_xattr (XATTR_NAME_POSIX_ACL_DEFAULT,\n                                 listbuf, listsize))));\n      free (heapbuf);\n\n       \n      if (nfsv4_acl)\n        {\n          ret = getxattr (name, XATTR_NAME_NFSV4_ACL,\n                          stackbuf.xattr, sizeof stackbuf.xattr);\n          if (ret < 0)\n            switch (errno)\n              {\n              case ENODATA: return 0;\n              case ERANGE : return 1;  \n              }\n          else\n            {\n               \n              ret = acl_nfs4_nontrivial (stackbuf.xattr, ret);\n              if (ret < 0)\n                {\n                  errno = EINVAL;\n                  return ret;\n                }\n              errno = initial_errno;\n            }\n        }\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_ACL_GET_FILE\n\n       \n       \n      int ret;\n\n      if (HAVE_ACL_EXTENDED_FILE)  \n        {\n           \n          ret = acl_extended_file (name);\n        }\n      else  \n        {\n#  if HAVE_ACL_TYPE_EXTENDED  \n           \n          acl_t acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n          if (acl)\n            {\n              ret = acl_extended_nontrivial (acl);\n              acl_free (acl);\n            }\n          else\n            ret = -1;\n#  else  \n          acl_t acl = acl_get_file (name, ACL_TYPE_ACCESS);\n          if (acl)\n            {\n              int saved_errno;\n\n              ret = acl_access_nontrivial (acl);\n              saved_errno = errno;\n              acl_free (acl);\n              errno = saved_errno;\n#   if HAVE_ACL_FREE_TEXT  \n               \n#   else  \n               \n              if (ret == 0 && S_ISDIR (sb->st_mode))\n                {\n                  acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n                  if (acl)\n                    {\n#    ifdef __CYGWIN__  \n                      ret = acl_access_nontrivial (acl);\n                      saved_errno = errno;\n                      acl_free (acl);\n                      errno = saved_errno;\n#    else\n                      ret = (0 < acl_entries (acl));\n                      acl_free (acl);\n#    endif\n                    }\n                  else\n                    ret = -1;\n                }\n#   endif\n            }\n          else\n            ret = -1;\n#  endif\n        }\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_FACL && defined GETACL  \n\n#  if defined ACL_NO_TRIVIAL\n\n       \n      return acl_trivial (name);\n\n#  else  \n\n       \n      {\n         \n        enum\n          {\n            alloc_init = 4000 / sizeof (aclent_t),  \n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (aclent_t))\n          };\n        aclent_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        aclent_t *entries = buf;\n        aclent_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                 \n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc;  \n                entries = malloced =\n                  (aclent_t *) malloc (alloc * sizeof (aclent_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              {\n                free (malloced);\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n             \n            if (count > 4)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n\n#   ifdef ACE_GETACL\n       \n      {\n         \n        enum\n          {\n            alloc_init = 4000 / sizeof (ace_t),  \n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n          };\n        ace_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        ace_t *entries = buf;\n        ace_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, ACE_GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                 \n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc;  \n                entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == EINVAL)\n              ;\n            else\n              {\n                free (malloced);\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n             \n            if (count > 6)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_ace_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n#   endif\n\n      return 0;\n#  endif\n\n# elif HAVE_GETACL  \n\n      {\n        struct acl_entry entries[NACLENTRIES];\n        int count;\n\n        count = getacl (name, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n             \n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else  \n          {\n            if (count > NACLENTRIES)\n               \n              abort ();\n\n             \n            if (count > 3)\n              return 1;\n\n            {\n              struct stat statbuf;\n\n              if (stat (name, &statbuf) == -1 && errno != EOVERFLOW)\n                return -1;\n\n              return acl_nontrivial (count, entries);\n            }\n          }\n      }\n\n#  if HAVE_ACLV_H  \n\n      {\n        struct acl entries[NACLVENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLVENTRIES, entries);\n\n        if (count < 0)\n          {\n             \n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else  \n          {\n            if (count > NACLVENTRIES)\n               \n              abort ();\n\n             \n            if (count > 4)\n              return 1;\n\n            return aclv_nontrivial (count, entries);\n          }\n      }\n\n#  endif\n\n# elif HAVE_ACLX_GET && defined ACL_AIX_WIP  \n\n      acl_type_t type;\n      char aclbuf[1024];\n      void *acl = aclbuf;\n      size_t aclsize = sizeof (aclbuf);\n      mode_t mode;\n\n      for (;;)\n        {\n           \n          type.u64 = ACL_ANY;\n          if (aclx_get (name, 0, &type, aclbuf, &aclsize, &mode) >= 0)\n            break;\n          if (errno == ENOSYS)\n            return 0;\n          if (errno != ENOSPC)\n            {\n              if (acl != aclbuf)\n                free (acl);\n              return -1;\n            }\n          aclsize = 2 * aclsize;\n          if (acl != aclbuf)\n            free (acl);\n          acl = malloc (aclsize);\n          if (acl == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n\n      if (type.u64 == ACL_AIXC)\n        {\n          int result = acl_nontrivial ((struct acl *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else if (type.u64 == ACL_NFS4)\n        {\n          int result = acl_nfs4_nontrivial ((nfs4_acl_int_t *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else\n        {\n           \n          if (acl != aclbuf)\n            free (acl);\n          errno = EINVAL;\n          return -1;\n        }\n\n# elif HAVE_STATACL  \n\n      union { struct acl a; char room[4096]; } u;\n\n      if (statacl ((char *) name, STX_NORMAL, &u.a, sizeof (u)) < 0)\n        return -1;\n\n      return acl_nontrivial (&u.a);\n\n# elif HAVE_ACLSORT  \n\n      {\n        struct acl entries[NACLENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else  \n          {\n            if (count > NACLENTRIES)\n               \n              abort ();\n\n             \n            if (count > 4)\n              return 1;\n\n            return acl_nontrivial (count, entries);\n          }\n      }\n\n# endif\n    }\n#endif\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}