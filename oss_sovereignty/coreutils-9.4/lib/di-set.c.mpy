{
  "module_name": "di-set.c",
  "hash_id": "777bb316ceb9d9cb64e9acbb4b370b3ec524b63bc14317f39b6e003ba29d1275",
  "original_prompt": "Ingested from coreutils-9.4/lib/di-set.c",
  "human_readable_source": " \n\n#include <config.h>\n#include \"di-set.h\"\n\n#include \"hash.h\"\n#include \"ino-map.h\"\n\n#include <limits.h>\n#include <stdlib.h>\n\n \ntypedef size_t hashint;\n#define HASHINT_MAX ((hashint) -1)\n\n \n#define LARGE_INO_MIN (HASHINT_MAX / 2)\n\n \n\n \nstruct di_ent\n{\n  dev_t dev;\n  struct hash_table *ino_set;\n};\n\n \nstruct di_set\n{\n   \n  struct hash_table *dev_map;\n\n   \n  struct ino_map *ino_map;\n\n   \n  struct di_ent *probe;\n};\n\n \nstatic size_t\ndi_ent_hash (void const *x, size_t table_size)\n{\n  struct di_ent const *p = x;\n  dev_t dev = p->dev;\n\n   \n  size_t h = dev;\n  unsigned int i;\n  unsigned int n_words = sizeof dev / sizeof h + (sizeof dev % sizeof h != 0);\n  for (i = 1; i < n_words; i++)\n    h ^= dev >> CHAR_BIT * sizeof h * i;\n\n  return h % table_size;\n}\n\n \nstatic bool\ndi_ent_compare (void const *x, void const *y)\n{\n  struct di_ent const *a = x;\n  struct di_ent const *b = y;\n  return a->dev == b->dev;\n}\n\n \nstatic void\ndi_ent_free (void *v)\n{\n  struct di_ent *a = v;\n  hash_free (a->ino_set);\n  free (a);\n}\n\n \nstruct di_set *\ndi_set_alloc (void)\n{\n  struct di_set *dis = malloc (sizeof *dis);\n  if (dis)\n    {\n      enum { INITIAL_DEV_MAP_SIZE = 11 };\n      dis->dev_map = hash_initialize (INITIAL_DEV_MAP_SIZE, NULL,\n                                      di_ent_hash, di_ent_compare,\n                                      di_ent_free);\n      if (! dis->dev_map)\n        {\n          free (dis);\n          return NULL;\n        }\n      dis->ino_map = NULL;\n      dis->probe = NULL;\n    }\n\n  return dis;\n}\n\n \nvoid\ndi_set_free (struct di_set *dis)\n{\n  hash_free (dis->dev_map);\n  if (dis->ino_map)\n    ino_map_free (dis->ino_map);\n  free (dis->probe);\n  free (dis);\n}\n\n \nstatic size_t\ndi_ino_hash (void const *i, size_t table_size)\n{\n  return (hashint) i % table_size;\n}\n\n \nstatic struct hash_table *\nmap_device (struct di_set *dis, dev_t dev)\n{\n   \n  struct di_ent *ent;\n  struct di_ent *probe = dis->probe;\n  if (probe)\n    {\n       \n      if (probe->dev == dev)\n        return probe->ino_set;\n    }\n  else\n    {\n      dis->probe = probe = malloc (sizeof *probe);\n      if (! probe)\n        return NULL;\n    }\n\n   \n  probe->dev = dev;\n  ent = hash_insert (dis->dev_map, probe);\n  if (! ent)\n    return NULL;\n\n  if (ent != probe)\n    {\n       \n      probe->ino_set = ent->ino_set;\n    }\n  else\n    {\n      enum { INITIAL_INO_SET_SIZE = 1021 };\n\n       \n      dis->probe = NULL;\n\n       \n      probe->ino_set = hash_initialize (INITIAL_INO_SET_SIZE, NULL,\n                                        di_ino_hash, NULL, NULL);\n    }\n\n  return probe->ino_set;\n}\n\n \nstatic hashint\nmap_inode_number (struct di_set *dis, ino_t ino)\n{\n  if (0 < ino && ino < LARGE_INO_MIN)\n    return ino;\n\n  if (! dis->ino_map)\n    {\n      dis->ino_map = ino_map_alloc (LARGE_INO_MIN);\n      if (! dis->ino_map)\n        return INO_MAP_INSERT_FAILURE;\n    }\n\n  return ino_map_insert (dis->ino_map, ino);\n}\n\n \nint\ndi_set_insert (struct di_set *dis, dev_t dev, ino_t ino)\n{\n  hashint i;\n\n   \n  struct hash_table *ino_set = map_device (dis, dev);\n  if (! ino_set)\n    return -1;\n\n   \n  i = map_inode_number (dis, ino);\n  if (i == INO_MAP_INSERT_FAILURE)\n    return -1;\n\n   \n  return hash_insert_if_absent (ino_set, (void const *) i, NULL);\n}\n\n \nint\ndi_set_lookup (struct di_set *dis, dev_t dev, ino_t ino)\n{\n  hashint i;\n\n   \n  struct hash_table *ino_set = map_device (dis, dev);\n  if (! ino_set)\n    return -1;\n\n   \n  i = map_inode_number (dis, ino);\n  if (i == INO_MAP_INSERT_FAILURE)\n    return -1;\n\n   \n  return !!hash_lookup (ino_set, (void const *) i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}