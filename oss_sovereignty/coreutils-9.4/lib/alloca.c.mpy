{
  "module_name": "alloca.c",
  "hash_id": "258a18ff6e1495ae689c75098bf0193028c86eb75eb779829208562b184dbe01",
  "original_prompt": "Ingested from coreutils-9.4/lib/alloca.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <alloca.h>\n\n#include <string.h>\n#include <stdlib.h>\n\n \n#if !(defined __GNUC__ || defined __clang__)\n\n \n# ifndef alloca\n\n \n\n#  ifndef STACK_DIRECTION\n#   define STACK_DIRECTION      0        \n#  endif\n\n#  if STACK_DIRECTION != 0\n\n#   define STACK_DIR    STACK_DIRECTION  \n\n#  else  \n\nstatic int stack_dir;            \n#   define STACK_DIR    stack_dir\n\nstatic int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}\n\n#  endif  \n\n \n\n#  ifndef       ALIGN_SIZE\n#   define ALIGN_SIZE   sizeof(double)\n#  endif\n\ntypedef union hdr\n{\n  char align[ALIGN_SIZE];        \n  struct\n    {\n      union hdr *next;           \n      char *deep;                \n    } h;\n} header;\n\nstatic header *last_alloca_header = NULL;        \n\n \n\nvoid *\nalloca (size_t size)\n{\n  auto char probe;               \n  register char *depth = &probe;\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)            \n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n   \n\n  {\n    register header *hp;         \n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);             \n\n          hp = np;               \n        }\n      else\n        break;                   \n\n    last_alloca_header = hp;     \n  }\n\n  if (size == 0)\n    return NULL;                 \n\n   \n\n  {\n     \n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n     \n\n    return (void *) (new + 1);\n  }\n}\n\n# endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}