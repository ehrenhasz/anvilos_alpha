{
  "module_name": "mbswidth.c",
  "hash_id": "c5010d8dae666dedf9a21e14456010578e4bab24c403f560444db5cfa99b5187",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbswidth.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"mbswidth.h\"\n\n \n#include <stdlib.h>\n\n#include <string.h>\n\n \n#include <ctype.h>\n\n \n#include <wchar.h>\n\n \n#include <uchar.h>\n\n \n#include <limits.h>\n\n \nint\nmbswidth (const char *string, int flags)\n{\n  return mbsnwidth (string, strlen (string), flags);\n}\n\n \nint\nmbsnwidth (const char *string, size_t nbytes, int flags)\n{\n  const char *p = string;\n  const char *plimit = p + nbytes;\n  int width;\n\n  width = 0;\n  if (MB_CUR_MAX > 1)\n    {\n      while (p < plimit)\n        switch (*p)\n          {\n            case ' ': case '!': case '\"': case '#': case '$': case '%':\n            case '&': case '\\'': case '(': case ')': case '*':\n            case '+': case ',': case '-': case '.': case '/':\n            case '0': case '1': case '2': case '3': case '4':\n            case '5': case '6': case '7': case '8': case '9':\n            case ':': case ';': case '<': case '=': case '>':\n            case '?': case '@':\n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'I': case 'J':\n            case 'K': case 'L': case 'M': case 'N': case 'O':\n            case 'P': case 'Q': case 'R': case 'S': case 'T':\n            case 'U': case 'V': case 'W': case 'X': case 'Y':\n            case 'Z':\n            case '[': case '\\\\': case ']': case '^': case '_': case '`':\n            case 'a': case 'b': case 'c': case 'd': case 'e':\n            case 'f': case 'g': case 'h': case 'i': case 'j':\n            case 'k': case 'l': case 'm': case 'n': case 'o':\n            case 'p': case 'q': case 'r': case 's': case 't':\n            case 'u': case 'v': case 'w': case 'x': case 'y':\n            case 'z': case '{': case '|': case '}': case '~':\n               \n              p++;\n              width++;\n              break;\n            default:\n               \n              {\n                mbstate_t mbstate;\n                mbszero (&mbstate);\n                for (;;)\n                  {\n                    char32_t wc;\n                    size_t bytes;\n                    int w;\n\n                    bytes = mbrtoc32 (&wc, p, plimit - p, &mbstate);\n\n                    if (bytes == (size_t) -1)\n                       \n                      {\n                        if (!(flags & MBSW_REJECT_INVALID))\n                          {\n                            p++;\n                            width++;\n                            break;\n                          }\n                        else\n                          return -1;\n                      }\n\n                    if (bytes == (size_t) -2)\n                       \n                      {\n                        if (!(flags & MBSW_REJECT_INVALID))\n                          {\n                            p = plimit;\n                            width++;\n                            break;\n                          }\n                        else\n                          return -1;\n                      }\n\n                    if (bytes == 0)\n                       \n                      bytes = 1;\n                    #if !GNULIB_MBRTOC32_REGULAR\n                    else if (bytes == (size_t) -3)\n                      bytes = 0;\n                    #endif\n\n                    w = c32width (wc);\n                    if (w >= 0)\n                       \n                      {\n                        if (w > INT_MAX - width)\n                          goto overflow;\n                        width += w;\n                      }\n                    else\n                       \n                      if (!(flags & MBSW_REJECT_UNPRINTABLE))\n                        {\n                          if (!c32iscntrl (wc))\n                            {\n                              if (width == INT_MAX)\n                                goto overflow;\n                              width++;\n                            }\n                        }\n                      else\n                        return -1;\n\n                    p += bytes;\n                    #if !GNULIB_MBRTOC32_REGULAR\n                    if (mbsinit (&mbstate))\n                    #endif\n                      break;\n                  }\n              }\n              break;\n          }\n      return width;\n    }\n\n  while (p < plimit)\n    {\n      unsigned char c = (unsigned char) *p++;\n\n      if (isprint (c))\n        {\n          if (width == INT_MAX)\n            goto overflow;\n          width++;\n        }\n      else if (!(flags & MBSW_REJECT_UNPRINTABLE))\n        {\n          if (!iscntrl (c))\n            {\n              if (width == INT_MAX)\n                goto overflow;\n              width++;\n            }\n        }\n      else\n        return -1;\n    }\n  return width;\n\n overflow:\n  return INT_MAX;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}