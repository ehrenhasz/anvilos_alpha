{
  "module_name": "human.c",
  "hash_id": "42827412fecb62889036a56ed7148475a4f397d4357385c0a2d1ec2b893804c3",
  "original_prompt": "Ingested from coreutils-9.4/lib/human.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"human.h\"\n\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <argmatch.h>\n#include <error.h>\n#include <intprops.h>\n\n \n#define HUMAN_READABLE_SUFFIX_LENGTH_MAX 3\n\nstatic const char power_letter[] =\n{\n  0,     \n  'K',   \n  'M',   \n  'G',   \n  'T',   \n  'P',   \n  'E',   \n  'Z',   \n  'Y',   \n  'R',   \n  'Q'    \n};\n\n\n \n\nstatic long double\nadjust_value (int inexact_style, long double value)\n{\n   \n  if (inexact_style != human_round_to_nearest && value < UINTMAX_MAX)\n    {\n      uintmax_t u = value;\n      value = u + (inexact_style == human_ceiling && u != value);\n    }\n\n  return value;\n}\n\n \n\nstatic char *\ngroup_number (char *number, size_t numberlen,\n              char const *grouping, char const *thousands_sep)\n{\n  register char *d;\n  size_t grouplen = SIZE_MAX;\n  size_t thousands_seplen = strlen (thousands_sep);\n  size_t i = numberlen;\n\n   \n  char buf[2 * INT_STRLEN_BOUND (uintmax_t) + 1];\n\n  memcpy (buf, number, numberlen);\n  d = number + numberlen;\n\n  for (;;)\n    {\n      unsigned char g = *grouping;\n\n      if (g)\n        {\n          grouplen = g < CHAR_MAX ? g : i;\n          grouping++;\n        }\n\n      if (i < grouplen)\n        grouplen = i;\n\n      d -= grouplen;\n      i -= grouplen;\n      memcpy (d, buf + i, grouplen);\n      if (i == 0)\n        return d;\n\n      d -= thousands_seplen;\n      memcpy (d, thousands_sep, thousands_seplen);\n    }\n}\n\n \n\nchar *\nhuman_readable (uintmax_t n, char *buf, int opts,\n                uintmax_t from_block_size, uintmax_t to_block_size)\n{\n  int inexact_style =\n    opts & (human_round_to_nearest | human_floor | human_ceiling);\n  unsigned int base = opts & human_base_1024 ? 1024 : 1000;\n  uintmax_t amt;\n  int tenths;\n  int exponent = -1;\n  int exponent_max = sizeof power_letter - 1;\n  char *p;\n  char *psuffix;\n  char const *integerlim;\n\n   \n  int rounding;\n\n  char const *decimal_point = \".\";\n  size_t decimal_pointlen = 1;\n  char const *grouping = \"\";\n  char const *thousands_sep = \"\";\n  struct lconv const *l = localeconv ();\n  size_t pointlen = strlen (l->decimal_point);\n  if (0 < pointlen && pointlen <= MB_LEN_MAX)\n    {\n      decimal_point = l->decimal_point;\n      decimal_pointlen = pointlen;\n    }\n  grouping = l->grouping;\n  if (strlen (l->thousands_sep) <= MB_LEN_MAX)\n    thousands_sep = l->thousands_sep;\n\n   \n  psuffix = buf + LONGEST_HUMAN_READABLE - 1 - HUMAN_READABLE_SUFFIX_LENGTH_MAX;\n  p = psuffix;\n\n   \n  if (to_block_size <= from_block_size)\n    {\n      if (from_block_size % to_block_size == 0)\n        {\n          uintmax_t multiplier = from_block_size / to_block_size;\n          amt = n * multiplier;\n          if (amt / multiplier == n)\n            {\n              tenths = 0;\n              rounding = 0;\n              goto use_integer_arithmetic;\n            }\n        }\n    }\n  else if (from_block_size != 0 && to_block_size % from_block_size == 0)\n    {\n      uintmax_t divisor = to_block_size / from_block_size;\n      uintmax_t r10 = (n % divisor) * 10;\n      uintmax_t r2 = (r10 % divisor) * 2;\n      amt = n / divisor;\n      tenths = r10 / divisor;\n      rounding = r2 < divisor ? 0 < r2 : 2 + (divisor < r2);\n      goto use_integer_arithmetic;\n    }\n\n  {\n     \n\n    long double dto_block_size = to_block_size;\n    long double damt = n * (from_block_size / dto_block_size);\n    size_t buflen;\n    size_t nonintegerlen;\n\n    if (! (opts & human_autoscale))\n      {\n        sprintf (buf, \"%.0Lf\", adjust_value (inexact_style, damt));\n        buflen = strlen (buf);\n        nonintegerlen = 0;\n      }\n    else\n      {\n        long double e = 1;\n        exponent = 0;\n\n        do\n          {\n            e *= base;\n            exponent++;\n          }\n        while (e * base <= damt && exponent < exponent_max);\n\n        damt /= e;\n\n        sprintf (buf, \"%.1Lf\", adjust_value (inexact_style, damt));\n        buflen = strlen (buf);\n        nonintegerlen = decimal_pointlen + 1;\n\n        if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen\n            || ((opts & human_suppress_point_zero)\n                && buf[buflen - 1] == '0'))\n          {\n            sprintf (buf, \"%.0Lf\",\n                     adjust_value (inexact_style, damt * 10) / 10);\n            buflen = strlen (buf);\n            nonintegerlen = 0;\n          }\n      }\n\n    p = psuffix - buflen;\n    memmove (p, buf, buflen);\n    integerlim = p + buflen - nonintegerlen;\n  }\n  goto do_grouping;\n\n use_integer_arithmetic:\n  {\n     \n\n    if (opts & human_autoscale)\n      {\n        exponent = 0;\n\n        if (base <= amt)\n          {\n            do\n              {\n                unsigned int r10 = (amt % base) * 10 + tenths;\n                unsigned int r2 = (r10 % base) * 2 + (rounding >> 1);\n                amt /= base;\n                tenths = r10 / base;\n                rounding = (r2 < base\n                            ? (r2 + rounding) != 0\n                            : 2 + (base < r2 + rounding));\n                exponent++;\n              }\n            while (base <= amt && exponent < exponent_max);\n\n            if (amt < 10)\n              {\n                if (inexact_style == human_round_to_nearest\n                    ? 2 < rounding + (tenths & 1)\n                    : inexact_style == human_ceiling && 0 < rounding)\n                  {\n                    tenths++;\n                    rounding = 0;\n\n                    if (tenths == 10)\n                      {\n                        amt++;\n                        tenths = 0;\n                      }\n                  }\n\n                if (amt < 10\n                    && (tenths || ! (opts & human_suppress_point_zero)))\n                  {\n                    *--p = '0' + tenths;\n                    p -= decimal_pointlen;\n                    memcpy (p, decimal_point, decimal_pointlen);\n                    tenths = rounding = 0;\n                  }\n              }\n          }\n      }\n\n    if (inexact_style == human_round_to_nearest\n        ? 5 < tenths + (0 < rounding + (amt & 1))\n        : inexact_style == human_ceiling && 0 < tenths + rounding)\n      {\n        amt++;\n\n        if ((opts & human_autoscale)\n            && amt == base && exponent < exponent_max)\n          {\n            exponent++;\n            if (! (opts & human_suppress_point_zero))\n              {\n                *--p = '0';\n                p -= decimal_pointlen;\n                memcpy (p, decimal_point, decimal_pointlen);\n              }\n            amt = 1;\n          }\n      }\n\n    integerlim = p;\n\n    do\n      {\n        int digit = amt % 10;\n        *--p = digit + '0';\n      }\n    while ((amt /= 10) != 0);\n  }\n\n do_grouping:\n  if (opts & human_group_digits)\n    p = group_number (p, integerlim - p, grouping, thousands_sep);\n\n  if (opts & human_SI)\n    {\n      if (exponent < 0)\n        {\n          uintmax_t power;\n          exponent = 0;\n          for (power = 1; power < to_block_size; power *= base)\n            if (++exponent == exponent_max)\n              break;\n        }\n\n      if ((exponent | (opts & human_B)) && (opts & human_space_before_unit))\n        *psuffix++ = ' ';\n\n      if (exponent)\n        *psuffix++ = (! (opts & human_base_1024) && exponent == 1\n                      ? 'k'\n                      : power_letter[exponent]);\n\n      if (opts & human_B)\n        {\n          if ((opts & human_base_1024) && exponent)\n            *psuffix++ = 'i';\n          *psuffix++ = 'B';\n        }\n    }\n\n  *psuffix = '\\0';\n\n  return p;\n}\n\n\n \n#ifndef DEFAULT_BLOCK_SIZE\n# define DEFAULT_BLOCK_SIZE 1024\n#endif\n\nstatic char const *const block_size_args[] = { \"human-readable\", \"si\", 0 };\nstatic int const block_size_opts[] =\n  {\n    human_autoscale + human_SI + human_base_1024,\n    human_autoscale + human_SI\n  };\n\nstatic uintmax_t\ndefault_block_size (void)\n{\n  return getenv (\"POSIXLY_CORRECT\") ? 512 : DEFAULT_BLOCK_SIZE;\n}\n\nstatic strtol_error\nhumblock (char const *spec, uintmax_t *block_size, int *options)\n{\n  int i;\n  int opts = 0;\n\n  if (! spec\n      && ! (spec = getenv (\"BLOCK_SIZE\"))\n      && ! (spec = getenv (\"BLOCKSIZE\")))\n    *block_size = default_block_size ();\n  else\n    {\n      if (*spec == '\\'')\n        {\n          opts |= human_group_digits;\n          spec++;\n        }\n\n      if (0 <= (i = ARGMATCH (spec, block_size_args, block_size_opts)))\n        {\n          opts |= block_size_opts[i];\n          *block_size = 1;\n        }\n      else\n        {\n          char *ptr;\n          strtol_error e = xstrtoumax (spec, &ptr, 0, block_size,\n                                       \"eEgGkKmMpPtTyYzZ0\");\n          if (e != LONGINT_OK)\n            {\n              *options = 0;\n              return e;\n            }\n          for (; ! ('0' <= *spec && *spec <= '9'); spec++)\n            if (spec == ptr)\n              {\n                opts |= human_SI;\n                if (ptr[-1] == 'B')\n                  opts |= human_B;\n                if (ptr[-1] != 'B' || ptr[-2] == 'i')\n                  opts |= human_base_1024;\n                break;\n              }\n        }\n    }\n\n  *options = opts;\n  return LONGINT_OK;\n}\n\nenum strtol_error\nhuman_options (char const *spec, int *opts, uintmax_t *block_size)\n{\n  strtol_error e = humblock (spec, block_size, opts);\n  if (*block_size == 0)\n    {\n      *block_size = default_block_size ();\n      e = LONGINT_INVALID;\n    }\n  return e;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}