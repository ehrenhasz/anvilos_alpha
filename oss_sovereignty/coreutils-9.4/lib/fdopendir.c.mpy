{
  "module_name": "fdopendir.c",
  "hash_id": "5db7f2d2397f5278c1a2bf70d0304364a4652118374c21ee7f1af673c8690c7a",
  "original_prompt": "Ingested from coreutils-9.4/lib/fdopendir.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <dirent.h>\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#if !HAVE_FDOPENDIR\n\n# if GNULIB_defined_DIR\n \n\n#  include \"dirent-private.h\"\n\n#  if !REPLACE_FCHDIR\n#   error \"unexpected configuration: GNULIB_defined_DIR but fchdir not replaced\"\n#  endif\n\nDIR *\nfdopendir (int fd)\n{\n  char const *name = _gl_directory_name (fd);\n  DIR *dirp = name ? opendir (name) : NULL;\n  if (dirp != NULL)\n    dirp->fd_to_close = fd;\n  return dirp;\n}\n\n# elif defined __KLIBC__\n\n#  include <InnoTekLIBC/backend.h>\n\nDIR *\nfdopendir (int fd)\n{\n  char path[_MAX_PATH];\n  DIR *dirp;\n\n   \n  if (__libc_Back_ioFHToPath (fd, path, sizeof (path)))\n    return NULL;\n\n  dirp = opendir (path);\n  if (!dirp)\n    return NULL;\n\n   \n  _gl_unregister_dirp_fd (dirfd (dirp));\n\n   \n  if (_gl_register_dirp_fd (fd, dirp))\n    {\n      int saved_errno = errno;\n\n      closedir (dirp);\n\n      errno = saved_errno;\n\n      dirp = NULL;\n    }\n\n  return dirp;\n}\n\n# else\n \n\n#  include \"openat.h\"\n#  include \"openat-priv.h\"\n#  include \"save-cwd.h\"\n\n#  if GNULIB_DIRENT_SAFER\n#   include \"dirent--.h\"\n#  endif\n\n#  ifndef REPLACE_FCHDIR\n#   define REPLACE_FCHDIR 0\n#  endif\n\nstatic DIR *fdopendir_with_dup (int, int, struct saved_cwd const *);\nstatic DIR *fd_clone_opendir (int, struct saved_cwd const *);\n\n \nDIR *\nfdopendir (int fd)\n{\n  DIR *dir = fdopendir_with_dup (fd, -1, NULL);\n\n  if (! REPLACE_FCHDIR && ! dir)\n    {\n      int saved_errno = errno;\n      if (EXPECTED_ERRNO (saved_errno))\n        {\n          struct saved_cwd cwd;\n          if (save_cwd (&cwd) != 0)\n            openat_save_fail (errno);\n          dir = fdopendir_with_dup (fd, -1, &cwd);\n          saved_errno = errno;\n          free_cwd (&cwd);\n          errno = saved_errno;\n        }\n    }\n\n  return dir;\n}\n\n \nstatic DIR *\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)\n{\n  int dupfd = dup (fd);\n  if (dupfd < 0 && errno == EMFILE)\n    dupfd = older_dupfd;\n  if (dupfd < 0)\n    return NULL;\n  else\n    {\n      DIR *dir;\n      int saved_errno;\n      if (dupfd < fd - 1 && dupfd != older_dupfd)\n        {\n          dir = fdopendir_with_dup (fd, dupfd, cwd);\n          saved_errno = errno;\n        }\n      else\n        {\n          close (fd);\n          dir = fd_clone_opendir (dupfd, cwd);\n          saved_errno = errno;\n          if (! dir)\n            {\n              int fd1 = dup (dupfd);\n              if (fd1 != fd)\n                openat_save_fail (fd1 < 0 ? errno : EBADF);\n            }\n        }\n\n      if (dupfd != older_dupfd)\n        close (dupfd);\n      errno = saved_errno;\n      return dir;\n    }\n}\n\n \nstatic DIR *\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)\n{\n  if (REPLACE_FCHDIR || ! cwd)\n    {\n      DIR *dir = NULL;\n      int saved_errno = EOPNOTSUPP;\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          dir = opendir (proc_file);\n          saved_errno = errno;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n#  if REPLACE_FCHDIR\n      if (! dir && EXPECTED_ERRNO (saved_errno))\n        {\n          char const *name = _gl_directory_name (fd);\n          DIR *dp = name ? opendir (name) : NULL;\n\n           \n          if (dp && dirfd (dp) < 0)\n            dup (fd);\n\n          return dp;\n        }\n#  endif\n      errno = saved_errno;\n      return dir;\n    }\n  else\n    {\n      if (fchdir (fd) != 0)\n        return NULL;\n      else\n        {\n          DIR *dir = opendir (\".\");\n          int saved_errno = errno;\n          if (restore_cwd (cwd) != 0)\n            openat_restore_fail (errno);\n          errno = saved_errno;\n          return dir;\n        }\n    }\n}\n\n# endif\n\n#else  \n\n# include <errno.h>\n# include <sys/stat.h>\n\n# undef fdopendir\n\n \n\nDIR *\nrpl_fdopendir (int fd)\n{\n  struct stat st;\n  if (fstat (fd, &st))\n    return NULL;\n  if (!S_ISDIR (st.st_mode))\n    {\n      errno = ENOTDIR;\n      return NULL;\n    }\n  return fdopendir (fd);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}