{
  "module_name": "write.c",
  "hash_id": "8b99a3f75fba9400a11916996455d7fd2ee4dd6c3e472708e01880849b73bad1",
  "original_prompt": "Ingested from coreutils-9.4/lib/write.c",
  "human_readable_source": " \n#include <unistd.h>\n\n \n\n#if defined _WIN32 && ! defined __CYGWIN__\n\n# include <errno.h>\n# include <signal.h>\n# include <io.h>\n\n# define WIN32_LEAN_AND_MEAN   \n# include <windows.h>\n\n# if HAVE_MSVC_INVALID_PARAMETER_HANDLER\n#  include \"msvc-inval.h\"\n# endif\n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n\n \n# undef GetNamedPipeHandleState\n# define GetNamedPipeHandleState GetNamedPipeHandleStateA\n\n# undef write\n\n# if HAVE_MSVC_INVALID_PARAMETER_HANDLER\nstatic ssize_t\nwrite_nothrow (int fd, const void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _write (fd, buf, count);\n    }\n  CATCH_MSVC_INVAL\n    {\n      result = -1;\n      errno = EBADF;\n    }\n  DONE_MSVC_INVAL;\n\n  return result;\n}\n# else\n#  define write_nothrow _write\n# endif\n\nssize_t\nrpl_write (int fd, const void *buf, size_t count)\n{\n  for (;;)\n    {\n      ssize_t ret = write_nothrow (fd, buf, count);\n\n      if (ret < 0)\n        {\n# if GNULIB_NONBLOCKING\n          if (errno == ENOSPC)\n            {\n              HANDLE h = (HANDLE) _get_osfhandle (fd);\n              if (GetFileType (h) == FILE_TYPE_PIPE)\n                {\n                   \n                  DWORD state;\n                  if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL,\n                                               NULL, 0)\n                      && (state & PIPE_NOWAIT) != 0)\n                    {\n                       \n                      DWORD out_size;  \n                      DWORD in_size;   \n                      if (GetNamedPipeInfo (h, NULL, &out_size, &in_size, NULL))\n                        {\n                          size_t reduced_count = count;\n                           \n                          if (out_size != 0 && out_size < reduced_count)\n                            reduced_count = out_size;\n                          if (in_size != 0 && in_size < reduced_count)\n                            reduced_count = in_size;\n                          if (reduced_count < count)\n                            {\n                               \n                              count = reduced_count;\n                              continue;\n                            }\n                        }\n                       \n                      errno = EAGAIN;\n                    }\n                }\n            }\n          else\n# endif\n            {\n# if GNULIB_SIGPIPE\n              if (GetLastError () == ERROR_NO_DATA\n                  && GetFileType ((HANDLE) _get_osfhandle (fd))\n                     == FILE_TYPE_PIPE)\n                {\n                   \n                  raise (SIGPIPE);\n                   \n                  errno = EPIPE;\n                }\n# endif\n            }\n        }\n      return ret;\n    }\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}