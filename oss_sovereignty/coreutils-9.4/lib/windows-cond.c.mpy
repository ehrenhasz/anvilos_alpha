{
  "module_name": "windows-cond.c",
  "hash_id": "c9383f6f00cf8ef4d68328e191848ecdf5fa64c803648ed5139283401606d08f",
  "original_prompt": "Ingested from coreutils-9.4/lib/windows-cond.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"windows-cond.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n \n#undef CreateEvent\n#define CreateEvent CreateEventA\n\n \n#define glwthread_waitqueue_t glwthread_linked_waitqueue_t\n\n \nstruct glwthread_waitqueue_element\n{\n  struct glwthread_waitqueue_link link;  \n  HANDLE event;  \n};\n\nstatic void\nglwthread_waitqueue_init (glwthread_waitqueue_t *wq)\n{\n  wq->wq_list.wql_next = &wq->wq_list;\n  wq->wq_list.wql_prev = &wq->wq_list;\n}\n\n \nstatic struct glwthread_waitqueue_element *\nglwthread_waitqueue_add (glwthread_waitqueue_t *wq)\n{\n  struct glwthread_waitqueue_element *elt;\n  HANDLE event;\n\n   \n  elt =\n    (struct glwthread_waitqueue_element *)\n    malloc (sizeof (struct glwthread_waitqueue_element));\n  if (elt == NULL)\n     \n    return NULL;\n\n   \n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    {\n       \n      free (elt);\n      return NULL;\n    }\n  elt->event = event;\n   \n  (elt->link.wql_prev = wq->wq_list.wql_prev)->wql_next = &elt->link;\n  (elt->link.wql_next = &wq->wq_list)->wql_prev = &elt->link;\n  return elt;\n}\n\n \nstatic bool\nglwthread_waitqueue_remove (glwthread_waitqueue_t *wq,\n                            struct glwthread_waitqueue_element *elt)\n{\n  if (elt->link.wql_next != NULL && elt->link.wql_prev != NULL)\n    {\n       \n      struct glwthread_waitqueue_link *prev = elt->link.wql_prev;\n      struct glwthread_waitqueue_link *next = elt->link.wql_next;\n      prev->wql_next = next;\n      next->wql_prev = prev;\n      elt->link.wql_next = NULL;\n      elt->link.wql_prev = NULL;\n      return true;\n    }\n  else\n    return false;\n}\n\n \nstatic void\nglwthread_waitqueue_notify_first (glwthread_waitqueue_t *wq)\n{\n  if (wq->wq_list.wql_next != &wq->wq_list)\n    {\n      struct glwthread_waitqueue_element *elt =\n        (struct glwthread_waitqueue_element *) wq->wq_list.wql_next;\n      struct glwthread_waitqueue_link *prev;\n      struct glwthread_waitqueue_link *next;\n\n       \n      prev = &wq->wq_list;  \n      next = elt->link.wql_next;\n      prev->wql_next = next;\n      next->wql_prev = prev;\n      elt->link.wql_next = NULL;\n      elt->link.wql_prev = NULL;\n\n      SetEvent (elt->event);\n       \n    }\n}\n\n \nstatic void\nglwthread_waitqueue_notify_all (glwthread_waitqueue_t *wq)\n{\n  struct glwthread_waitqueue_link *l;\n\n  for (l = wq->wq_list.wql_next; l != &wq->wq_list; )\n    {\n      struct glwthread_waitqueue_element *elt =\n        (struct glwthread_waitqueue_element *) l;\n      struct glwthread_waitqueue_link *prev;\n      struct glwthread_waitqueue_link *next;\n\n       \n      prev = &wq->wq_list;  \n      next = elt->link.wql_next;\n      prev->wql_next = next;\n      next->wql_prev = prev;\n      elt->link.wql_next = NULL;\n      elt->link.wql_prev = NULL;\n\n      SetEvent (elt->event);\n       \n\n      l = next;\n    }\n  if (!(wq->wq_list.wql_next == &wq->wq_list\n        && wq->wq_list.wql_prev == &wq->wq_list))\n    abort ();\n}\n\nint\nglwthread_cond_init (glwthread_cond_t *cond)\n{\n  InitializeCriticalSection (&cond->lock);\n  glwthread_waitqueue_init (&cond->waiters);\n\n  cond->guard.done = 1;\n  return 0;\n}\n\nint\nglwthread_cond_wait (glwthread_cond_t *cond,\n                     void *mutex, int (*mutex_lock) (void *), int (*mutex_unlock) (void *))\n{\n  if (!cond->guard.done)\n    {\n      if (InterlockedIncrement (&cond->guard.started) == 0)\n         \n        glwthread_cond_init (cond);\n      else\n        {\n           \n          InterlockedDecrement (&cond->guard.started);\n           \n          while (!cond->guard.done)\n            Sleep (0);\n        }\n    }\n\n  EnterCriticalSection (&cond->lock);\n  {\n    struct glwthread_waitqueue_element *elt =\n      glwthread_waitqueue_add (&cond->waiters);\n    LeaveCriticalSection (&cond->lock);\n    if (elt == NULL)\n      {\n         \n        return EAGAIN;\n      }\n    else\n      {\n        HANDLE event = elt->event;\n        int err;\n        DWORD result;\n\n         \n        err = mutex_unlock (mutex);\n        if (err != 0)\n          {\n            EnterCriticalSection (&cond->lock);\n            glwthread_waitqueue_remove (&cond->waiters, elt);\n            LeaveCriticalSection (&cond->lock);\n            CloseHandle (event);\n            free (elt);\n            return err;\n          }\n         \n         \n        result = WaitForSingleObject (event, INFINITE);\n        if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n          abort ();\n        CloseHandle (event);\n        free (elt);\n         \n        return mutex_lock (mutex);\n      }\n  }\n}\n\nint\nglwthread_cond_timedwait (glwthread_cond_t *cond,\n                          void *mutex, int (*mutex_lock) (void *), int (*mutex_unlock) (void *),\n                          const struct timespec *abstime)\n{\n  if (!cond->guard.done)\n    {\n      if (InterlockedIncrement (&cond->guard.started) == 0)\n         \n        glwthread_cond_init (cond);\n      else\n        {\n           \n          InterlockedDecrement (&cond->guard.started);\n           \n          while (!cond->guard.done)\n            Sleep (0);\n        }\n    }\n\n  {\n    struct timeval currtime;\n\n    gettimeofday (&currtime, NULL);\n    if (currtime.tv_sec > abstime->tv_sec\n        || (currtime.tv_sec == abstime->tv_sec\n            && currtime.tv_usec * 1000 >= abstime->tv_nsec))\n      return ETIMEDOUT;\n\n    EnterCriticalSection (&cond->lock);\n    {\n      struct glwthread_waitqueue_element *elt =\n        glwthread_waitqueue_add (&cond->waiters);\n      LeaveCriticalSection (&cond->lock);\n      if (elt == NULL)\n        {\n           \n          return EAGAIN;\n        }\n      else\n        {\n          HANDLE event = elt->event;\n          int err;\n          DWORD timeout;\n          DWORD result;\n\n           \n          err = mutex_unlock (mutex);\n          if (err != 0)\n            {\n              EnterCriticalSection (&cond->lock);\n              glwthread_waitqueue_remove (&cond->waiters, elt);\n              LeaveCriticalSection (&cond->lock);\n              CloseHandle (event);\n              free (elt);\n              return err;\n            }\n           \n           \n          gettimeofday (&currtime, NULL);\n          if (currtime.tv_sec > abstime->tv_sec)\n            timeout = 0;\n          else\n            {\n              unsigned long seconds = abstime->tv_sec - currtime.tv_sec;\n              timeout = seconds * 1000;\n              if (timeout / 1000 != seconds)  \n                timeout = INFINITE;\n              else\n                {\n                  long milliseconds =\n                    abstime->tv_nsec / 1000000 - currtime.tv_usec / 1000;\n                  if (milliseconds >= 0)\n                    {\n                      timeout += milliseconds;\n                      if (timeout < milliseconds)  \n                        timeout = INFINITE;\n                    }\n                  else\n                    {\n                      if (timeout >= - milliseconds)\n                        timeout -= (- milliseconds);\n                      else\n                        timeout = 0;\n                    }\n                }\n            }\n          result = WaitForSingleObject (event, timeout);\n          if (result == WAIT_FAILED)\n            abort ();\n          if (result == WAIT_TIMEOUT)\n            {\n              EnterCriticalSection (&cond->lock);\n              if (glwthread_waitqueue_remove (&cond->waiters, elt))\n                {\n                   \n                  if (!(WaitForSingleObject (event, 0) == WAIT_TIMEOUT))\n                    abort ();\n                }\n              else\n                {\n                   \n                  if (!(WaitForSingleObject (event, 0) == WAIT_OBJECT_0))\n                    abort ();\n                   \n                  result = WAIT_OBJECT_0;\n                }\n              LeaveCriticalSection (&cond->lock);\n            }\n          else\n            {\n               \n            }\n          CloseHandle (event);\n          free (elt);\n           \n          err = mutex_lock (mutex);\n          return (err ? err :\n                  result == WAIT_OBJECT_0 ? 0 :\n                  result == WAIT_TIMEOUT ? ETIMEDOUT :\n                    EAGAIN);\n        }\n    }\n  }\n}\n\nint\nglwthread_cond_signal (glwthread_cond_t *cond)\n{\n  if (!cond->guard.done)\n    return EINVAL;\n\n  EnterCriticalSection (&cond->lock);\n   \n  if (cond->waiters.wq_list.wql_next != &cond->waiters.wq_list)\n    glwthread_waitqueue_notify_first (&cond->waiters);\n  LeaveCriticalSection (&cond->lock);\n\n  return 0;\n}\n\nint\nglwthread_cond_broadcast (glwthread_cond_t *cond)\n{\n  if (!cond->guard.done)\n    return EINVAL;\n\n  EnterCriticalSection (&cond->lock);\n   \n  glwthread_waitqueue_notify_all (&cond->waiters);\n  LeaveCriticalSection (&cond->lock);\n\n  return 0;\n}\n\nint\nglwthread_cond_destroy (glwthread_cond_t *cond)\n{\n  if (!cond->guard.done)\n    return EINVAL;\n  if (cond->waiters.wq_list.wql_next != &cond->waiters.wq_list)\n    return EBUSY;\n  DeleteCriticalSection (&cond->lock);\n  cond->guard.done = 0;\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}