{
  "module_name": "linkat.c",
  "hash_id": "1d9240cedb4724a00dea722eb62fac3504d5fbaad3bb67a73530fca473b7be4c",
  "original_prompt": "Ingested from coreutils-9.4/lib/linkat.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <unistd.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n\n#include \"areadlink.h\"\n#include \"dirname.h\"\n#include \"eloop-threshold.h\"\n#include \"filenamecat.h\"\n#include \"openat-priv.h\"\n\n#if !HAVE_LINKAT || LINKAT_SYMLINK_NOTSUP\n\n \n# if LINK_FOLLOWS_SYMLINKS == 0\n#  define link_immediate link\n# else\nstatic int\nlink_immediate (char const *file1, char const *file2)\n{\n  char *target = areadlink (file1);\n  if (target)\n    {\n       \n      struct stat st1;\n      struct stat st2;\n      char *dir = mdir_name (file2);\n      if (!dir)\n        {\n          free (target);\n          errno = ENOMEM;\n          return -1;\n        }\n      if (lstat (file1, &st1) == 0 && stat (dir, &st2) == 0)\n        {\n          if (st1.st_dev == st2.st_dev)\n            {\n              int result = symlink (target, file2);\n              free (target);\n              free (dir);\n              return result;\n            }\n          free (target);\n          free (dir);\n          errno = EXDEV;\n          return -1;\n        }\n      free (target);\n      free (dir);\n    }\n  if (errno == ENOMEM)\n    return -1;\n  return link (file1, file2);\n}\n# endif  \n\n \n# if 0 < LINK_FOLLOWS_SYMLINKS\n#  define link_follow link\n# else\nstatic int\nlink_follow (char const *file1, char const *file2)\n{\n  char *name = (char *) file1;\n  char *target;\n  int result;\n  int i = __eloop_threshold ();\n\n   \n  while (i-- && (target = areadlink (name)))\n    {\n      if (IS_ABSOLUTE_FILE_NAME (target))\n        {\n          if (name != file1)\n            free (name);\n          name = target;\n        }\n      else\n        {\n          char *dir = mdir_name (name);\n          if (name != file1)\n            free (name);\n          if (!dir)\n            {\n              free (target);\n              errno = ENOMEM;\n              return -1;\n            }\n          name = mfile_name_concat (dir, target, NULL);\n          free (dir);\n          free (target);\n          if (!name)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n    }\n  if (i < 0)\n    {\n      target = NULL;\n      errno = ELOOP;\n    }\n  if (!target && errno != EINVAL)\n    {\n      if (name != file1)\n        free (name);\n      return -1;\n    }\n  result = link (name, file2);\n  if (name != file1)\n    free (name);\n  return result;\n}\n# endif  \n\n \n# if LINK_FOLLOWS_SYMLINKS == -1\n\n \nextern int __xpg4;\n\nstatic int\nsolaris_optimized_link_immediate (char const *file1, char const *file2)\n{\n  if (__xpg4 == 0)\n    return link (file1, file2);\n  return link_immediate (file1, file2);\n}\n\nstatic int\nsolaris_optimized_link_follow (char const *file1, char const *file2)\n{\n  if (__xpg4 != 0)\n    return link (file1, file2);\n  return link_follow (file1, file2);\n}\n\n#  define link_immediate solaris_optimized_link_immediate\n#  define link_follow solaris_optimized_link_follow\n\n# endif\n\n#endif  \n\n#if !HAVE_LINKAT\n\n \n\nint\nlinkat (int fd1, char const *file1, int fd2, char const *file2, int flag)\n{\n  if (flag & ~AT_SYMLINK_FOLLOW)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  return at_func2 (fd1, file1, fd2, file2,\n                   flag ? link_follow : link_immediate);\n}\n\n#else  \n\n# undef linkat\n\n \n\nstatic int\nlinkat_follow (int fd1, char const *file1, int fd2, char const *file2)\n{\n  char *name = (char *) file1;\n  char *target;\n  int result;\n  int i = __eloop_threshold ();\n\n   \n  while (i-- && (target = areadlinkat (fd1, name)))\n    {\n      if (IS_ABSOLUTE_FILE_NAME (target))\n        {\n          if (name != file1)\n            free (name);\n          name = target;\n        }\n      else\n        {\n          char *dir = mdir_name (name);\n          if (name != file1)\n            free (name);\n          if (!dir)\n            {\n              free (target);\n              errno = ENOMEM;\n              return -1;\n            }\n          name = mfile_name_concat (dir, target, NULL);\n          free (dir);\n          free (target);\n          if (!name)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n    }\n  if (i < 0)\n    {\n      target = NULL;\n      errno = ELOOP;\n    }\n  if (!target && errno != EINVAL)\n    {\n      if (name != file1)\n        free (name);\n      return -1;\n    }\n  result = linkat (fd1, name, fd2, file2, 0);\n  if (name != file1)\n    free (name);\n  return result;\n}\n\n\n \n\nint\nrpl_linkat (int fd1, char const *file1, int fd2, char const *file2, int flag)\n{\n  if (flag & ~AT_SYMLINK_FOLLOW)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n# if LINKAT_TRAILING_SLASH_BUG\n   \n  {\n    size_t len1 = strlen (file1);\n    size_t len2 = strlen (file2);\n    if ((len1 && file1[len1 - 1] == '/')\n        || (len2 && file2[len2 - 1] == '/'))\n      {\n         \n        struct stat st;\n        if (fstatat (fd1, file1, &st, flag ? 0 : AT_SYMLINK_NOFOLLOW))\n          return -1;\n        if (!S_ISDIR (st.st_mode))\n          {\n            errno = ENOTDIR;\n            return -1;\n          }\n      }\n  }\n# endif\n\n  if (!flag)\n    {\n      int result = linkat (fd1, file1, fd2, file2, flag);\n# if LINKAT_SYMLINK_NOTSUP\n       \n      if (result == -1 && (errno == ENOTSUP || errno == EOPNOTSUPP))\n        return at_func2 (fd1, file1, fd2, file2, link_immediate);\n# endif\n      return result;\n    }\n\n   \n  {\n    static int have_follow_really;  \n    if (0 <= have_follow_really)\n    {\n      int result = linkat (fd1, file1, fd2, file2, flag);\n      if (!(result == -1 && errno == EINVAL))\n        {\n          have_follow_really = 1;\n          return result;\n        }\n      have_follow_really = -1;\n    }\n  }\n  return linkat_follow (fd1, file1, fd2, file2);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}