{
  "module_name": "strtod.c",
  "hash_id": "e15d02648696477bef86a406a5e2be2d0d2f0ab0456ae8faf26cdc13a72e40dd",
  "original_prompt": "Ingested from coreutils-9.4/lib/strtod.c",
  "human_readable_source": " \n#include <stdlib.h>\n\n#include <ctype.h>       \n#include <errno.h>\n#include <float.h>       \n#include <limits.h>      \n#include <locale.h>      \n#include <math.h>        \n#include <stdio.h>       \n#include <string.h>      \n#if HAVE_NL_LANGINFO\n# include <langinfo.h>\n#endif\n\n#include \"c-ctype.h\"\n\n#undef MIN\n#undef MAX\n#ifdef USE_LONG_DOUBLE\n# define STRTOD strtold\n# define LDEXP ldexpl\n# if defined __hpux && defined __hppa\n    \n#  define HAVE_UNDERLYING_STRTOD 0\n# elif STRTOLD_HAS_UNDERFLOW_BUG\n    \n#  define HAVE_UNDERLYING_STRTOD 0\n# else\n#  define HAVE_UNDERLYING_STRTOD HAVE_STRTOLD\n# endif\n# define DOUBLE long double\n# define MIN LDBL_MIN\n# define MAX LDBL_MAX\n# define L_(literal) literal##L\n#else\n# define STRTOD strtod\n# define LDEXP ldexp\n# define HAVE_UNDERLYING_STRTOD 1\n# define DOUBLE double\n# define MIN DBL_MIN\n# define MAX DBL_MAX\n# define L_(literal) literal\n#endif\n\n#if (defined USE_LONG_DOUBLE ? HAVE_LDEXPM_IN_LIBC : HAVE_LDEXP_IN_LIBC)\n# define USE_LDEXP 1\n#else\n# define USE_LDEXP 0\n#endif\n\n \nstatic bool\nlocale_isspace (char c)\n{\n  unsigned char uc = c;\n  return isspace (uc) != 0;\n}\n\n \nstatic char\ndecimal_point_char (void)\n{\n  const char *point;\n   \n#if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#else\n  point = localeconv () -> decimal_point;\n#endif\n   \n  return (point[0] != '\\0' ? point[0] : '.');\n}\n\n#if !USE_LDEXP\n #undef LDEXP\n #define LDEXP dummy_ldexp\n  \n static DOUBLE LDEXP (_GL_UNUSED DOUBLE x, _GL_UNUSED int exponent)\n {\n   abort ();\n   return L_(0.0);\n }\n#endif\n\n \nstatic DOUBLE\nscale_radix_exp (DOUBLE x, int radix, long int exponent)\n{\n   \n\n  long int e = exponent;\n\n  if (USE_LDEXP && radix == 2)\n    return LDEXP (x, e < INT_MIN ? INT_MIN : INT_MAX < e ? INT_MAX : e);\n  else\n    {\n      DOUBLE r = x;\n\n      if (r != 0)\n        {\n          if (e < 0)\n            {\n              while (e++ != 0)\n                {\n                  r /= radix;\n                  if (r == 0 && x != 0)\n                    {\n                      errno = ERANGE;\n                      break;\n                    }\n                }\n            }\n          else\n            {\n              while (e-- != 0)\n                {\n                  if (r < -MAX / radix)\n                    {\n                      errno = ERANGE;\n                      return -HUGE_VAL;\n                    }\n                  else if (MAX / radix < r)\n                    {\n                      errno = ERANGE;\n                      return HUGE_VAL;\n                    }\n                  else\n                    r *= radix;\n                }\n            }\n        }\n\n      return r;\n    }\n}\n\n \nstatic DOUBLE\nparse_number (const char *nptr,\n              int base, int radix, int radix_multiplier, char radixchar,\n              char expchar,\n              char **endptr)\n{\n  const char *s = nptr;\n  const char *digits_start;\n  const char *digits_end;\n  const char *radixchar_ptr;\n  long int exponent;\n  DOUBLE num;\n\n   \n  digits_start = s;\n  radixchar_ptr = NULL;\n  for (;; ++s)\n    {\n      if (base == 16 ? c_isxdigit (*s) : c_isdigit (*s))\n        ;\n      else if (radixchar_ptr == NULL && *s == radixchar)\n        {\n           \n          radixchar_ptr = s;\n        }\n      else\n         \n        break;\n    }\n  digits_end = s;\n   \n\n  if (false)\n    {  \n      exponent =\n        (radixchar_ptr != NULL\n         ? - (long int) (digits_end - radixchar_ptr - 1)\n         : 0);\n    }\n  else\n    {  \n      while (digits_end > digits_start)\n        {\n          if (digits_end - 1 == radixchar_ptr || *(digits_end - 1) == '0')\n            digits_end--;\n          else\n            break;\n        }\n      exponent =\n        (radixchar_ptr != NULL\n         ? (digits_end > radixchar_ptr\n            ? - (long int) (digits_end - radixchar_ptr - 1)\n            : (long int) (radixchar_ptr - digits_end))\n         : (long int) (s - digits_end));\n    }\n\n   \n  {\n    const char *dp;\n    num = 0;\n    for (dp = digits_start; dp < digits_end; dp++)\n      if (dp != radixchar_ptr)\n        {\n          int digit;\n\n           \n          if (!(num <= MAX / base))\n            {\n               \n              exponent +=\n                (digits_end - dp)\n                - (radixchar_ptr >= dp && radixchar_ptr < digits_end ? 1 : 0);\n              break;\n            }\n\n           \n          if (c_isdigit (*dp))\n            digit = *dp - '0';\n          else if (base == 16 && c_isxdigit (*dp))\n            digit = c_tolower (*dp) - ('a' - 10);\n          else\n            abort ();\n          num = num * base + digit;\n        }\n  }\n\n  exponent = exponent * radix_multiplier;\n\n   \n  if (c_tolower (*s) == expchar && ! locale_isspace (s[1]))\n    {\n       \n      int saved_errno = errno;\n      char *end;\n      long int value = strtol (s + 1, &end, 10);\n      errno = saved_errno;\n\n      if (s + 1 != end)\n        {\n           \n          s = end;\n          exponent =\n            (exponent < 0\n             ? (value < LONG_MIN - exponent ? LONG_MIN : exponent + value)\n             : (LONG_MAX - exponent < value ? LONG_MAX : exponent + value));\n        }\n    }\n\n  *endptr = (char *) s;\n  return scale_radix_exp (num, radix, exponent);\n}\n\n \nstatic DOUBLE\nminus_zero (void)\n{\n#if defined __hpux || defined __sgi || defined __ICC\n  return -MIN * MIN;\n#else\n  return -0.0;\n#endif\n}\n\n \nDOUBLE\nSTRTOD (const char *nptr, char **endptr)\n#if HAVE_UNDERLYING_STRTOD\n# ifdef USE_LONG_DOUBLE\n#  undef strtold\n# else\n#  undef strtod\n# endif\n#else\n# undef STRTOD\n# define STRTOD(NPTR,ENDPTR) \\\n   parse_number (NPTR, 10, 10, 1, radixchar, 'e', ENDPTR)\n#endif\n \n{\n  char radixchar;\n  bool negative = false;\n\n   \n  DOUBLE num;\n\n  const char *s = nptr;\n  const char *end;\n  char *endbuf;\n  int saved_errno = errno;\n\n  radixchar = decimal_point_char ();\n\n   \n  while (locale_isspace (*s))\n    ++s;\n\n   \n  negative = *s == '-';\n  if (*s == '-' || *s == '+')\n    ++s;\n\n  num = STRTOD (s, &endbuf);\n  end = endbuf;\n\n  if (c_isdigit (s[*s == radixchar]))\n    {\n       \n      if (*s == '0' && c_tolower (s[1]) == 'x')\n        {\n          if (! c_isxdigit (s[2 + (s[2] == radixchar)]))\n            {\n              end = s + 1;\n\n               \n              errno = saved_errno;\n            }\n          else if (end <= s + 2)\n            {\n              num = parse_number (s + 2, 16, 2, 4, radixchar, 'p', &endbuf);\n              end = endbuf;\n            }\n          else\n            {\n              const char *p = s + 2;\n              while (p < end && c_tolower (*p) != 'p')\n                p++;\n              if (p < end && ! c_isdigit (p[1 + (p[1] == '-' || p[1] == '+')]))\n                {\n                  char *dup = strdup (s);\n                  errno = saved_errno;\n                  if (!dup)\n                    {\n                       \n                      num =\n                        parse_number (s + 2, 16, 2, 4, radixchar, 'p', &endbuf);\n                    }\n                  else\n                    {\n                      dup[p - s] = '\\0';\n                      num = STRTOD (dup, &endbuf);\n                      saved_errno = errno;\n                      free (dup);\n                      errno = saved_errno;\n                    }\n                  end = p;\n                }\n            }\n        }\n      else\n        {\n           \n          const char *e = s + 1;\n          while (e < end && c_tolower (*e) != 'e')\n            e++;\n          if (e < end && ! c_isdigit (e[1 + (e[1] == '-' || e[1] == '+')]))\n            {\n              char *dup = strdup (s);\n              errno = saved_errno;\n              if (!dup)\n                {\n                   \n                  num = parse_number (s, 10, 10, 1, radixchar, 'e', &endbuf);\n                }\n              else\n                {\n                  dup[e - s] = '\\0';\n                  num = STRTOD (dup, &endbuf);\n                  saved_errno = errno;\n                  free (dup);\n                  errno = saved_errno;\n                }\n              end = e;\n            }\n        }\n\n      s = end;\n    }\n\n   \n  else if (c_tolower (*s) == 'i'\n           && c_tolower (s[1]) == 'n'\n           && c_tolower (s[2]) == 'f')\n    {\n      s += 3;\n      if (c_tolower (*s) == 'i'\n          && c_tolower (s[1]) == 'n'\n          && c_tolower (s[2]) == 'i'\n          && c_tolower (s[3]) == 't'\n          && c_tolower (s[4]) == 'y')\n        s += 5;\n      num = HUGE_VAL;\n      errno = saved_errno;\n    }\n  else if (c_tolower (*s) == 'n'\n           && c_tolower (s[1]) == 'a'\n           && c_tolower (s[2]) == 'n')\n    {\n      s += 3;\n      if (*s == '(')\n        {\n          const char *p = s + 1;\n          while (c_isalnum (*p))\n            p++;\n          if (*p == ')')\n            s = p + 1;\n        }\n\n       \n      if (s != end || num == num)\n        num = NAN;\n      errno = saved_errno;\n    }\n  else\n    {\n       \n      errno = EINVAL;\n      s = nptr;\n    }\n\n  if (endptr != NULL)\n    *endptr = (char *) s;\n   \n  if (!num && negative)\n    return minus_zero ();\n  return negative ? -num : num;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}