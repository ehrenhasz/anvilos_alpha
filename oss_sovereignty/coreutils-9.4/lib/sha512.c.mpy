{
  "module_name": "sha512.c",
  "hash_id": "c98671ec7ff07042bd9bdaf5fe9a13dd5e3a4d094dcd78436386cc69fa874c0d",
  "original_prompt": "Ingested from coreutils-9.4/lib/sha512.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#if HAVE_OPENSSL_SHA512\n# define GL_OPENSSL_INLINE _GL_EXTERN_INLINE\n#endif\n#include \"sha512.h\"\n\n#include <stdint.h>\n#include <string.h>\n\n#include <byteswap.h>\n#ifdef WORDS_BIGENDIAN\n# define SWAP(n) (n)\n#else\n# define SWAP(n) bswap_64 (n)\n#endif\n\n#if ! HAVE_OPENSSL_SHA512\n\n \nstatic const unsigned char fillbuf[128] = { 0x80, 0   };\n\n\n \nvoid\nsha512_init_ctx (struct sha512_ctx *ctx)\n{\n  ctx->state[0] = u64hilo (0x6a09e667, 0xf3bcc908);\n  ctx->state[1] = u64hilo (0xbb67ae85, 0x84caa73b);\n  ctx->state[2] = u64hilo (0x3c6ef372, 0xfe94f82b);\n  ctx->state[3] = u64hilo (0xa54ff53a, 0x5f1d36f1);\n  ctx->state[4] = u64hilo (0x510e527f, 0xade682d1);\n  ctx->state[5] = u64hilo (0x9b05688c, 0x2b3e6c1f);\n  ctx->state[6] = u64hilo (0x1f83d9ab, 0xfb41bd6b);\n  ctx->state[7] = u64hilo (0x5be0cd19, 0x137e2179);\n\n  ctx->total[0] = ctx->total[1] = u64lo (0);\n  ctx->buflen = 0;\n}\n\nvoid\nsha384_init_ctx (struct sha512_ctx *ctx)\n{\n  ctx->state[0] = u64hilo (0xcbbb9d5d, 0xc1059ed8);\n  ctx->state[1] = u64hilo (0x629a292a, 0x367cd507);\n  ctx->state[2] = u64hilo (0x9159015a, 0x3070dd17);\n  ctx->state[3] = u64hilo (0x152fecd8, 0xf70e5939);\n  ctx->state[4] = u64hilo (0x67332667, 0xffc00b31);\n  ctx->state[5] = u64hilo (0x8eb44a87, 0x68581511);\n  ctx->state[6] = u64hilo (0xdb0c2e0d, 0x64f98fa7);\n  ctx->state[7] = u64hilo (0x47b5481d, 0xbefa4fa4);\n\n  ctx->total[0] = ctx->total[1] = u64lo (0);\n  ctx->buflen = 0;\n}\n\n \nstatic void\nset_uint64 (char *cp, u64 v)\n{\n  memcpy (cp, &v, sizeof v);\n}\n\n \nvoid *\nsha512_read_ctx (const struct sha512_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 8; i++)\n    set_uint64 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}\n\nvoid *\nsha384_read_ctx (const struct sha512_ctx *ctx, void *resbuf)\n{\n  int i;\n  char *r = resbuf;\n\n  for (i = 0; i < 6; i++)\n    set_uint64 (r + i * sizeof ctx->state[0], SWAP (ctx->state[i]));\n\n  return resbuf;\n}\n\n \nstatic void\nsha512_conclude_ctx (struct sha512_ctx *ctx)\n{\n   \n  size_t bytes = ctx->buflen;\n  size_t size = (bytes < 112) ? 128 / 8 : 128 * 2 / 8;\n\n   \n  ctx->total[0] = u64plus (ctx->total[0], u64lo (bytes));\n  if (u64lt (ctx->total[0], u64lo (bytes)))\n    ctx->total[1] = u64plus (ctx->total[1], u64lo (1));\n\n   \n  set_uint64 ((char *) &ctx->buffer[size - 2],\n              SWAP (u64or (u64shl (ctx->total[1], 3),\n                           u64shr (ctx->total[0], 61))));\n  set_uint64 ((char *) &ctx->buffer[size - 1],\n              SWAP (u64shl (ctx->total[0], 3)));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 8 - bytes);\n\n   \n  sha512_process_block (ctx->buffer, size * 8, ctx);\n}\n\nvoid *\nsha512_finish_ctx (struct sha512_ctx *ctx, void *resbuf)\n{\n  sha512_conclude_ctx (ctx);\n  return sha512_read_ctx (ctx, resbuf);\n}\n\nvoid *\nsha384_finish_ctx (struct sha512_ctx *ctx, void *resbuf)\n{\n  sha512_conclude_ctx (ctx);\n  return sha384_read_ctx (ctx, resbuf);\n}\n\n \nvoid *\nsha512_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha512_ctx ctx;\n\n   \n  sha512_init_ctx (&ctx);\n\n   \n  sha512_process_bytes (buffer, len, &ctx);\n\n   \n  return sha512_finish_ctx (&ctx, resblock);\n}\n\nvoid *\nsha384_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha512_ctx ctx;\n\n   \n  sha384_init_ctx (&ctx);\n\n   \n  sha512_process_bytes (buffer, len, &ctx);\n\n   \n  return sha384_finish_ctx (&ctx, resblock);\n}\n\nvoid\nsha512_process_bytes (const void *buffer, size_t len, struct sha512_ctx *ctx)\n{\n   \n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 256 - left_over > len ? len : 256 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 128)\n        {\n          sha512_process_block (ctx->buffer, ctx->buflen & ~127, ctx);\n\n          ctx->buflen &= 127;\n           \n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~127],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n   \n  if (len >= 128)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (u64) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 128)\n          {\n            sha512_process_block (memcpy (ctx->buffer, buffer, 128), 128, ctx);\n            buffer = (const char *) buffer + 128;\n            len -= 128;\n          }\n      else\n#endif\n        {\n          sha512_process_block (buffer, len & ~127, ctx);\n          buffer = (const char *) buffer + (len & ~127);\n          len &= 127;\n        }\n    }\n\n   \n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 128)\n        {\n          sha512_process_block (ctx->buffer, 128, ctx);\n          left_over -= 128;\n           \n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}\n\n \n\n \n#define K(I) sha512_round_constants[I]\nstatic u64 const sha512_round_constants[80] = {\n  u64init (0x428a2f98, 0xd728ae22), u64init (0x71374491, 0x23ef65cd),\n  u64init (0xb5c0fbcf, 0xec4d3b2f), u64init (0xe9b5dba5, 0x8189dbbc),\n  u64init (0x3956c25b, 0xf348b538), u64init (0x59f111f1, 0xb605d019),\n  u64init (0x923f82a4, 0xaf194f9b), u64init (0xab1c5ed5, 0xda6d8118),\n  u64init (0xd807aa98, 0xa3030242), u64init (0x12835b01, 0x45706fbe),\n  u64init (0x243185be, 0x4ee4b28c), u64init (0x550c7dc3, 0xd5ffb4e2),\n  u64init (0x72be5d74, 0xf27b896f), u64init (0x80deb1fe, 0x3b1696b1),\n  u64init (0x9bdc06a7, 0x25c71235), u64init (0xc19bf174, 0xcf692694),\n  u64init (0xe49b69c1, 0x9ef14ad2), u64init (0xefbe4786, 0x384f25e3),\n  u64init (0x0fc19dc6, 0x8b8cd5b5), u64init (0x240ca1cc, 0x77ac9c65),\n  u64init (0x2de92c6f, 0x592b0275), u64init (0x4a7484aa, 0x6ea6e483),\n  u64init (0x5cb0a9dc, 0xbd41fbd4), u64init (0x76f988da, 0x831153b5),\n  u64init (0x983e5152, 0xee66dfab), u64init (0xa831c66d, 0x2db43210),\n  u64init (0xb00327c8, 0x98fb213f), u64init (0xbf597fc7, 0xbeef0ee4),\n  u64init (0xc6e00bf3, 0x3da88fc2), u64init (0xd5a79147, 0x930aa725),\n  u64init (0x06ca6351, 0xe003826f), u64init (0x14292967, 0x0a0e6e70),\n  u64init (0x27b70a85, 0x46d22ffc), u64init (0x2e1b2138, 0x5c26c926),\n  u64init (0x4d2c6dfc, 0x5ac42aed), u64init (0x53380d13, 0x9d95b3df),\n  u64init (0x650a7354, 0x8baf63de), u64init (0x766a0abb, 0x3c77b2a8),\n  u64init (0x81c2c92e, 0x47edaee6), u64init (0x92722c85, 0x1482353b),\n  u64init (0xa2bfe8a1, 0x4cf10364), u64init (0xa81a664b, 0xbc423001),\n  u64init (0xc24b8b70, 0xd0f89791), u64init (0xc76c51a3, 0x0654be30),\n  u64init (0xd192e819, 0xd6ef5218), u64init (0xd6990624, 0x5565a910),\n  u64init (0xf40e3585, 0x5771202a), u64init (0x106aa070, 0x32bbd1b8),\n  u64init (0x19a4c116, 0xb8d2d0c8), u64init (0x1e376c08, 0x5141ab53),\n  u64init (0x2748774c, 0xdf8eeb99), u64init (0x34b0bcb5, 0xe19b48a8),\n  u64init (0x391c0cb3, 0xc5c95a63), u64init (0x4ed8aa4a, 0xe3418acb),\n  u64init (0x5b9cca4f, 0x7763e373), u64init (0x682e6ff3, 0xd6b2b8a3),\n  u64init (0x748f82ee, 0x5defb2fc), u64init (0x78a5636f, 0x43172f60),\n  u64init (0x84c87814, 0xa1f0ab72), u64init (0x8cc70208, 0x1a6439ec),\n  u64init (0x90befffa, 0x23631e28), u64init (0xa4506ceb, 0xde82bde9),\n  u64init (0xbef9a3f7, 0xb2c67915), u64init (0xc67178f2, 0xe372532b),\n  u64init (0xca273ece, 0xea26619c), u64init (0xd186b8c7, 0x21c0c207),\n  u64init (0xeada7dd6, 0xcde0eb1e), u64init (0xf57d4f7f, 0xee6ed178),\n  u64init (0x06f067aa, 0x72176fba), u64init (0x0a637dc5, 0xa2c898a6),\n  u64init (0x113f9804, 0xbef90dae), u64init (0x1b710b35, 0x131c471b),\n  u64init (0x28db77f5, 0x23047d84), u64init (0x32caab7b, 0x40c72493),\n  u64init (0x3c9ebe0a, 0x15c9bebc), u64init (0x431d67c4, 0x9c100d4c),\n  u64init (0x4cc5d4be, 0xcb3e42b6), u64init (0x597f299c, 0xfc657e2a),\n  u64init (0x5fcb6fab, 0x3ad6faec), u64init (0x6c44198c, 0x4a475817),\n};\n\n \n#define F2(A, B, C) u64or (u64and (A, B), u64and (C, u64or (A, B)))\n#define F1(E, F, G) u64xor (G, u64and (E, u64xor (F, G)))\n\n \n\nvoid\nsha512_process_block (const void *buffer, size_t len, struct sha512_ctx *ctx)\n{\n  u64 const *words = buffer;\n  u64 const *endp = words + len / sizeof (u64);\n  u64 x[16];\n  u64 a = ctx->state[0];\n  u64 b = ctx->state[1];\n  u64 c = ctx->state[2];\n  u64 d = ctx->state[3];\n  u64 e = ctx->state[4];\n  u64 f = ctx->state[5];\n  u64 g = ctx->state[6];\n  u64 h = ctx->state[7];\n  u64 lolen = u64size (len);\n\n   \n  ctx->total[0] = u64plus (ctx->total[0], lolen);\n  ctx->total[1] = u64plus (ctx->total[1],\n                           u64plus (u64size (len >> 31 >> 31 >> 2),\n                                    u64lo (u64lt (ctx->total[0], lolen))));\n\n#define S0(x) u64xor (u64rol(x, 63), u64xor (u64rol (x, 56), u64shr (x, 7)))\n#define S1(x) u64xor (u64rol (x, 45), u64xor (u64rol (x, 3), u64shr (x, 6)))\n#define SS0(x) u64xor (u64rol (x, 36), u64xor (u64rol (x, 30), u64rol (x, 25)))\n#define SS1(x) u64xor (u64rol(x, 50), u64xor (u64rol (x, 46), u64rol (x, 23)))\n\n#define M(I) (x[(I) & 15]                                                 \\\n              = u64plus (x[(I) & 15],                                     \\\n                         u64plus (S1 (x[((I) - 2) & 15]),                 \\\n                                  u64plus (x[((I) - 7) & 15],             \\\n                                           S0 (x[((I) - 15) & 15])))))\n\n#define R(A, B, C, D, E, F, G, H, K, M)                                   \\\n  do                                                                      \\\n    {                                                                     \\\n      u64 t0 = u64plus (SS0 (A), F2 (A, B, C));                           \\\n      u64 t1 =                                                            \\\n        u64plus (H, u64plus (SS1 (E),                                     \\\n                             u64plus (F1 (E, F, G), u64plus (K, M))));    \\\n      D = u64plus (D, t1);                                                \\\n      H = u64plus (t0, t1);                                               \\\n    }                                                                     \\\n  while (0)\n\n  while (words < endp)\n    {\n      int t;\n       \n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, f, g, h, K( 0), x[ 0] );\n      R( h, a, b, c, d, e, f, g, K( 1), x[ 1] );\n      R( g, h, a, b, c, d, e, f, K( 2), x[ 2] );\n      R( f, g, h, a, b, c, d, e, K( 3), x[ 3] );\n      R( e, f, g, h, a, b, c, d, K( 4), x[ 4] );\n      R( d, e, f, g, h, a, b, c, K( 5), x[ 5] );\n      R( c, d, e, f, g, h, a, b, K( 6), x[ 6] );\n      R( b, c, d, e, f, g, h, a, K( 7), x[ 7] );\n      R( a, b, c, d, e, f, g, h, K( 8), x[ 8] );\n      R( h, a, b, c, d, e, f, g, K( 9), x[ 9] );\n      R( g, h, a, b, c, d, e, f, K(10), x[10] );\n      R( f, g, h, a, b, c, d, e, K(11), x[11] );\n      R( e, f, g, h, a, b, c, d, K(12), x[12] );\n      R( d, e, f, g, h, a, b, c, K(13), x[13] );\n      R( c, d, e, f, g, h, a, b, K(14), x[14] );\n      R( b, c, d, e, f, g, h, a, K(15), x[15] );\n      R( a, b, c, d, e, f, g, h, K(16), M(16) );\n      R( h, a, b, c, d, e, f, g, K(17), M(17) );\n      R( g, h, a, b, c, d, e, f, K(18), M(18) );\n      R( f, g, h, a, b, c, d, e, K(19), M(19) );\n      R( e, f, g, h, a, b, c, d, K(20), M(20) );\n      R( d, e, f, g, h, a, b, c, K(21), M(21) );\n      R( c, d, e, f, g, h, a, b, K(22), M(22) );\n      R( b, c, d, e, f, g, h, a, K(23), M(23) );\n      R( a, b, c, d, e, f, g, h, K(24), M(24) );\n      R( h, a, b, c, d, e, f, g, K(25), M(25) );\n      R( g, h, a, b, c, d, e, f, K(26), M(26) );\n      R( f, g, h, a, b, c, d, e, K(27), M(27) );\n      R( e, f, g, h, a, b, c, d, K(28), M(28) );\n      R( d, e, f, g, h, a, b, c, K(29), M(29) );\n      R( c, d, e, f, g, h, a, b, K(30), M(30) );\n      R( b, c, d, e, f, g, h, a, K(31), M(31) );\n      R( a, b, c, d, e, f, g, h, K(32), M(32) );\n      R( h, a, b, c, d, e, f, g, K(33), M(33) );\n      R( g, h, a, b, c, d, e, f, K(34), M(34) );\n      R( f, g, h, a, b, c, d, e, K(35), M(35) );\n      R( e, f, g, h, a, b, c, d, K(36), M(36) );\n      R( d, e, f, g, h, a, b, c, K(37), M(37) );\n      R( c, d, e, f, g, h, a, b, K(38), M(38) );\n      R( b, c, d, e, f, g, h, a, K(39), M(39) );\n      R( a, b, c, d, e, f, g, h, K(40), M(40) );\n      R( h, a, b, c, d, e, f, g, K(41), M(41) );\n      R( g, h, a, b, c, d, e, f, K(42), M(42) );\n      R( f, g, h, a, b, c, d, e, K(43), M(43) );\n      R( e, f, g, h, a, b, c, d, K(44), M(44) );\n      R( d, e, f, g, h, a, b, c, K(45), M(45) );\n      R( c, d, e, f, g, h, a, b, K(46), M(46) );\n      R( b, c, d, e, f, g, h, a, K(47), M(47) );\n      R( a, b, c, d, e, f, g, h, K(48), M(48) );\n      R( h, a, b, c, d, e, f, g, K(49), M(49) );\n      R( g, h, a, b, c, d, e, f, K(50), M(50) );\n      R( f, g, h, a, b, c, d, e, K(51), M(51) );\n      R( e, f, g, h, a, b, c, d, K(52), M(52) );\n      R( d, e, f, g, h, a, b, c, K(53), M(53) );\n      R( c, d, e, f, g, h, a, b, K(54), M(54) );\n      R( b, c, d, e, f, g, h, a, K(55), M(55) );\n      R( a, b, c, d, e, f, g, h, K(56), M(56) );\n      R( h, a, b, c, d, e, f, g, K(57), M(57) );\n      R( g, h, a, b, c, d, e, f, K(58), M(58) );\n      R( f, g, h, a, b, c, d, e, K(59), M(59) );\n      R( e, f, g, h, a, b, c, d, K(60), M(60) );\n      R( d, e, f, g, h, a, b, c, K(61), M(61) );\n      R( c, d, e, f, g, h, a, b, K(62), M(62) );\n      R( b, c, d, e, f, g, h, a, K(63), M(63) );\n      R( a, b, c, d, e, f, g, h, K(64), M(64) );\n      R( h, a, b, c, d, e, f, g, K(65), M(65) );\n      R( g, h, a, b, c, d, e, f, K(66), M(66) );\n      R( f, g, h, a, b, c, d, e, K(67), M(67) );\n      R( e, f, g, h, a, b, c, d, K(68), M(68) );\n      R( d, e, f, g, h, a, b, c, K(69), M(69) );\n      R( c, d, e, f, g, h, a, b, K(70), M(70) );\n      R( b, c, d, e, f, g, h, a, K(71), M(71) );\n      R( a, b, c, d, e, f, g, h, K(72), M(72) );\n      R( h, a, b, c, d, e, f, g, K(73), M(73) );\n      R( g, h, a, b, c, d, e, f, K(74), M(74) );\n      R( f, g, h, a, b, c, d, e, K(75), M(75) );\n      R( e, f, g, h, a, b, c, d, K(76), M(76) );\n      R( d, e, f, g, h, a, b, c, K(77), M(77) );\n      R( c, d, e, f, g, h, a, b, K(78), M(78) );\n      R( b, c, d, e, f, g, h, a, K(79), M(79) );\n\n      a = ctx->state[0] = u64plus (ctx->state[0], a);\n      b = ctx->state[1] = u64plus (ctx->state[1], b);\n      c = ctx->state[2] = u64plus (ctx->state[2], c);\n      d = ctx->state[3] = u64plus (ctx->state[3], d);\n      e = ctx->state[4] = u64plus (ctx->state[4], e);\n      f = ctx->state[5] = u64plus (ctx->state[5], f);\n      g = ctx->state[6] = u64plus (ctx->state[6], g);\n      h = ctx->state[7] = u64plus (ctx->state[7], h);\n    }\n}\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}