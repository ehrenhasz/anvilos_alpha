{
  "module_name": "strtol.c",
  "hash_id": "76542b6c97dfcb681727b87da3425cd861fc3a4319fbc01463ca05b082db1578",
  "original_prompt": "Ingested from coreutils-9.4/lib/strtol.c",
  "human_readable_source": " \n#ifndef UNSIGNED\n# define UNSIGNED 0\n# define INT LONG int\n#else\n# define INT unsigned LONG int\n#endif\n\n \n#ifdef USE_IN_EXTENDED_LOCALE_MODEL\n# undef strtol\n# if UNSIGNED\n#  ifdef USE_WIDE_CHAR\n#   ifdef QUAD\n#    define strtol __wcstoull_l\n#   else\n#    define strtol __wcstoul_l\n#   endif\n#  else\n#   ifdef QUAD\n#    define strtol __strtoull_l\n#   else\n#    define strtol __strtoul_l\n#   endif\n#  endif\n# else\n#  ifdef USE_WIDE_CHAR\n#   ifdef QUAD\n#    define strtol __wcstoll_l\n#   else\n#    define strtol __wcstol_l\n#   endif\n#  else\n#   ifdef QUAD\n#    define strtol __strtoll_l\n#   else\n#    define strtol __strtol_l\n#   endif\n#  endif\n# endif\n#else\n# if UNSIGNED\n#  undef strtol\n#  ifdef USE_WIDE_CHAR\n#   ifdef QUAD\n#    define strtol wcstoull\n#   else\n#    define strtol wcstoul\n#   endif\n#  else\n#   ifdef QUAD\n#    define strtol strtoull\n#   else\n#    define strtol strtoul\n#   endif\n#  endif\n# else\n#  ifdef USE_WIDE_CHAR\n#   undef strtol\n#   ifdef QUAD\n#    define strtol wcstoll\n#   else\n#    define strtol wcstol\n#   endif\n#  else\n#   ifdef QUAD\n#    undef strtol\n#    define strtol strtoll\n#   endif\n#  endif\n# endif\n#endif\n\n \n#ifdef QUAD\n# define LONG long long\n# define STRTOL_LONG_MIN LLONG_MIN\n# define STRTOL_LONG_MAX LLONG_MAX\n# define STRTOL_ULONG_MAX ULLONG_MAX\n# if __GNUC__ == 2 && __GNUC_MINOR__ < 7\n    \n   static const unsigned long long int maxquad = ULLONG_MAX;\n#  undef STRTOL_ULONG_MAX\n#  define STRTOL_ULONG_MAX maxquad\n# endif\n#else\n# define LONG long\n# define STRTOL_LONG_MIN LONG_MIN\n# define STRTOL_LONG_MAX LONG_MAX\n# define STRTOL_ULONG_MAX ULONG_MAX\n#endif\n\n\n#ifdef USE_NUMBER_GROUPING\n# define GROUP_PARAM_PROTO , int group\n#else\n# define GROUP_PARAM_PROTO\n#endif\n\n \n#ifdef USE_IN_EXTENDED_LOCALE_MODEL\n# undef _NL_CURRENT\n# define _NL_CURRENT(category, item) \\\n  (current->values[_NL_ITEM_INDEX (item)].string)\n# define LOCALE_PARAM , loc\n# define LOCALE_PARAM_PROTO , __locale_t loc\n#else\n# define LOCALE_PARAM\n# define LOCALE_PARAM_PROTO\n#endif\n\n#ifdef USE_WIDE_CHAR\n# include <wchar.h>\n# include <wctype.h>\n# define L_(Ch) L##Ch\n# define UCHAR_TYPE wint_t\n# define STRING_TYPE wchar_t\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n#  define ISSPACE(Ch) __iswspace_l ((Ch), loc)\n#  define ISALPHA(Ch) __iswalpha_l ((Ch), loc)\n#  define TOUPPER(Ch) __towupper_l ((Ch), loc)\n# else\n#  define ISSPACE(Ch) iswspace (Ch)\n#  define ISALPHA(Ch) iswalpha (Ch)\n#  define TOUPPER(Ch) towupper (Ch)\n# endif\n#else\n# define L_(Ch) Ch\n# define UCHAR_TYPE unsigned char\n# define STRING_TYPE char\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n#  define ISSPACE(Ch) __isspace_l ((unsigned char) (Ch), loc)\n#  define ISALPHA(Ch) __isalpha_l ((unsigned char) (Ch), loc)\n#  define TOUPPER(Ch) __toupper_l ((unsigned char) (Ch), loc)\n# else\n#  define ISSPACE(Ch) isspace ((unsigned char) (Ch))\n#  define ISALPHA(Ch) isalpha ((unsigned char) (Ch))\n#  define TOUPPER(Ch) toupper ((unsigned char) (Ch))\n# endif\n#endif\n\n#ifdef USE_NUMBER_GROUPING\n# define INTERNAL(X) INTERNAL1(X)\n# define INTERNAL1(X) __##X##_internal\n# define WEAKNAME(X) WEAKNAME1(X)\n#else\n# define INTERNAL(X) X\n#endif\n\n#ifdef USE_NUMBER_GROUPING\n \n# include \"grouping.h\"\n#endif\n\n\n\n \n\nINT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n                   int base GROUP_PARAM_PROTO LOCALE_PARAM_PROTO)\n{\n  int negative;\n  register unsigned LONG int cutoff;\n  register unsigned int cutlim;\n  register unsigned LONG int i;\n  register const STRING_TYPE *s;\n  register UCHAR_TYPE c;\n  const STRING_TYPE *save, *end;\n  int overflow;\n\n#ifdef USE_NUMBER_GROUPING\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n  struct locale_data *current = loc->__locales[LC_NUMERIC];\n# endif\n   \n  wchar_t thousands = L'\\0';\n   \n  const char *grouping;\n\n  if (group)\n    {\n      grouping = _NL_CURRENT (LC_NUMERIC, GROUPING);\n      if (*grouping <= 0 || *grouping == CHAR_MAX)\n        grouping = NULL;\n      else\n        {\n           \n# if defined _LIBC || defined _HAVE_BTOWC\n          thousands = __btowc (*_NL_CURRENT (LC_NUMERIC, THOUSANDS_SEP));\n          if (thousands == WEOF)\n            thousands = L'\\0';\n# endif\n          if (thousands == L'\\0')\n            grouping = NULL;\n        }\n    }\n  else\n    grouping = NULL;\n#endif\n\n  if (base < 0 || base == 1 || base > 36)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  save = s = nptr;\n\n   \n  while (ISSPACE (*s))\n    ++s;\n  if (*s == L_('\\0'))\n    goto noconv;\n\n   \n  if (*s == L_('-'))\n    {\n      negative = 1;\n      ++s;\n    }\n  else if (*s == L_('+'))\n    {\n      negative = 0;\n      ++s;\n    }\n  else\n    negative = 0;\n\n   \n  if (*s == L_('0'))\n    {\n      if ((base == 0 || base == 16) && TOUPPER (s[1]) == L_('X'))\n        {\n          s += 2;\n          base = 16;\n        }\n      else if ((base == 0 || base == 2) && TOUPPER (s[1]) == L_('B'))\n        {\n          s += 2;\n          base = 2;\n        }\n      else if (base == 0)\n        base = 8;\n    }\n  else if (base == 0)\n    base = 10;\n\n   \n  save = s;\n\n#ifdef USE_NUMBER_GROUPING\n  if (group)\n    {\n       \n      end = s;\n      for (c = *end; c != L_('\\0'); c = *++end)\n        if ((wchar_t) c != thousands\n            && ((wchar_t) c < L_('0') || (wchar_t) c > L_('9'))\n            && (!ISALPHA (c) || (int) (TOUPPER (c) - L_('A') + 10) >= base))\n          break;\n      if (*s == thousands)\n        end = s;\n      else\n        end = correctly_grouped_prefix (s, end, thousands, grouping);\n    }\n  else\n#endif\n    end = NULL;\n\n  cutoff = STRTOL_ULONG_MAX / (unsigned LONG int) base;\n  cutlim = STRTOL_ULONG_MAX % (unsigned LONG int) base;\n\n  overflow = 0;\n  i = 0;\n  for (c = *s; c != L_('\\0'); c = *++s)\n    {\n      if (s == end)\n        break;\n      if (c >= L_('0') && c <= L_('9'))\n        c -= L_('0');\n      else if (ISALPHA (c))\n        c = TOUPPER (c) - L_('A') + 10;\n      else\n        break;\n      if ((int) c >= base)\n        break;\n       \n      if (i > cutoff || (i == cutoff && c > cutlim))\n        overflow = 1;\n      else\n        {\n          i *= (unsigned LONG int) base;\n          i += c;\n        }\n    }\n\n   \n  if (s == save)\n    goto noconv;\n\n   \n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) s;\n\n#if !UNSIGNED\n   \n  if (overflow == 0\n      && i > (negative\n              ? -((unsigned LONG int) (STRTOL_LONG_MIN + 1)) + 1\n              : (unsigned LONG int) STRTOL_LONG_MAX))\n    overflow = 1;\n#endif\n\n  if (overflow)\n    {\n      __set_errno (ERANGE);\n#if UNSIGNED\n      return STRTOL_ULONG_MAX;\n#else\n      return negative ? STRTOL_LONG_MIN : STRTOL_LONG_MAX;\n#endif\n    }\n\n   \n  return negative ? -i : i;\n\nnoconv:\n   \n  if (endptr != NULL)\n    {\n      if (save - nptr >= 2\n          && (TOUPPER (save[-1]) == L_('X') || TOUPPER (save[-1]) == L_('B'))\n          && save[-2] == L_('0'))\n        *endptr = (STRING_TYPE *) &save[-1];\n      else\n         \n        *endptr = (STRING_TYPE *) nptr;\n    }\n\n  return 0L;\n}\n\f\n#ifdef USE_NUMBER_GROUPING\n \n\nINT\n# ifdef weak_function\nweak_function\n# endif\nstrtol (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n        int base LOCALE_PARAM_PROTO)\n{\n  return INTERNAL (strtol) (nptr, endptr, base, 0 LOCALE_PARAM);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}