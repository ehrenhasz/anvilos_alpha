{
  "module_name": "randperm.c",
  "hash_id": "c86829fc99916d36a207f066cf59456701aa6106b4b734873d0d3015a5e2d5a6",
  "original_prompt": "Ingested from coreutils-9.4/lib/randperm.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"randperm.h\"\n\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"attribute.h\"\n#include \"count-leading-zeros.h\"\n#include \"hash.h\"\n#include \"xalloc.h\"\n\n \n\nATTRIBUTE_CONST static int\nfloor_lg (size_t n)\n{\n  static_assert (SIZE_WIDTH <= ULLONG_WIDTH);\n  return (n == 0 ? -1\n          : SIZE_WIDTH <= UINT_WIDTH\n          ? UINT_WIDTH - 1 - count_leading_zeros (n)\n          : SIZE_WIDTH <= ULONG_WIDTH\n          ? ULONG_WIDTH - 1 - count_leading_zeros_l (n)\n          : ULLONG_WIDTH - 1 - count_leading_zeros_ll (n));\n}\n\n \n\nsize_t\nrandperm_bound (size_t h, size_t n)\n{\n   \n  uintmax_t lg_n = floor_lg (n) + 1;\n\n   \n  uintmax_t ar = lg_n * h;\n\n   \n  size_t bound = (ar + CHAR_BIT - 1) / CHAR_BIT;\n\n  return bound;\n}\n\n \n\nstatic void\nswap (size_t *v, size_t i, size_t j)\n{\n  size_t t = v[i];\n  v[i] = v[j];\n  v[j] = t;\n}\n\n \n\nstruct sparse_ent_\n{\n   size_t index;\n   size_t val;\n};\n\nstatic size_t\nsparse_hash_ (void const *x, size_t table_size)\n{\n  struct sparse_ent_ const *ent = x;\n  return ent->index % table_size;\n}\n\nstatic bool\nsparse_cmp_ (void const *x, void const *y)\n{\n  struct sparse_ent_ const *ent1 = x;\n  struct sparse_ent_ const *ent2 = y;\n  return ent1->index == ent2->index;\n}\n\ntypedef Hash_table sparse_map;\n\n \n\nstatic sparse_map *\nsparse_new (size_t size_hint)\n{\n  return hash_initialize (size_hint, nullptr, sparse_hash_, sparse_cmp_, free);\n}\n\n \n\nstatic void\nsparse_swap (sparse_map *sv, size_t *v, size_t i, size_t j)\n{\n  struct sparse_ent_ *v1 = hash_remove (sv, &(struct sparse_ent_) {i,0});\n  struct sparse_ent_ *v2 = hash_remove (sv, &(struct sparse_ent_) {j,0});\n\n   \n  if (!v1)\n    {\n      v1 = xmalloc (sizeof *v1);\n      v1->index = v1->val = i;\n    }\n  if (!v2)\n    {\n      v2 = xmalloc (sizeof *v2);\n      v2->index = v2->val = j;\n    }\n\n  size_t t = v1->val;\n  v1->val = v2->val;\n  v2->val = t;\n  if (!hash_insert (sv, v1))\n    xalloc_die ();\n  if (!hash_insert (sv, v2))\n    xalloc_die ();\n\n  v[i] = v1->val;\n}\n\nstatic void\nsparse_free (sparse_map *sv)\n{\n  hash_free (sv);\n}\n\n\n \n\nsize_t *\nrandperm_new (struct randint_source *r, size_t h, size_t n)\n{\n  size_t *v;\n\n  switch (h)\n    {\n    case 0:\n      v = nullptr;\n      break;\n\n    case 1:\n      v = xmalloc (sizeof *v);\n      v[0] = randint_choose (r, n);\n      break;\n\n    default:\n      {\n         \n        bool sparse = (n >= (128 * 1024)) && (n / h >= 32);\n\n        size_t i;\n        sparse_map *sv;\n\n        if (sparse)\n          {\n            sv = sparse_new (h * 2);\n            if (sv == nullptr)\n              xalloc_die ();\n            v = xnmalloc (h, sizeof *v);\n          }\n        else\n          {\n            sv = nullptr;  \n            v = xnmalloc (n, sizeof *v);\n            for (i = 0; i < n; i++)\n              v[i] = i;\n          }\n\n        for (i = 0; i < h; i++)\n          {\n            size_t j = i + randint_choose (r, n - i);\n            if (sparse)\n              sparse_swap (sv, v, i, j);\n            else\n              swap (v, i, j);\n          }\n\n        if (sparse)\n          sparse_free (sv);\n        else\n          v = xnrealloc (v, h, sizeof *v);\n      }\n      break;\n    }\n\n  return v;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}