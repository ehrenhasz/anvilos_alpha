{
  "module_name": "xstrtol.c",
  "hash_id": "76b08f48c3caf9e4585decbd4a30924e464fabf64ceff3b5d61ae04b42291cd9",
  "original_prompt": "Ingested from coreutils-9.4/lib/xstrtol.c",
  "human_readable_source": " \n\n#ifndef __strtol\n# define __strtol strtol\n# define __strtol_t long int\n# define __xstrtol xstrtol\n# define STRTOL_T_MINIMUM LONG_MIN\n# define STRTOL_T_MAXIMUM LONG_MAX\n#endif\n\n#include <config.h>\n\n#include \"xstrtol.h\"\n\n \n#include <stdio.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdckdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if XSTRTOL_INCLUDE_INTTYPES_H\n# include <inttypes.h>\n#endif\n\n#include \"assure.h\"\n#include \"intprops.h\"\n\nstatic strtol_error\nbkm_scale (__strtol_t *x, int scale_factor)\n{\n  __strtol_t scaled;\n  if (ckd_mul (&scaled, *x, scale_factor))\n    {\n      *x = *x < 0 ? TYPE_MINIMUM (__strtol_t) : TYPE_MAXIMUM (__strtol_t);\n      return LONGINT_OVERFLOW;\n    }\n\n  *x = scaled;\n\n  return LONGINT_OK;\n}\n\nstatic strtol_error\nbkm_scale_by_power (__strtol_t *x, int base, int power)\n{\n  strtol_error err = LONGINT_OK;\n  while (power--)\n    err |= bkm_scale (x, base);\n  return err;\n}\n\n \n\nstrtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assure (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  errno = 0;\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n       \n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n   \n   \n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      switch (**p)\n        {\n        case 'E': case 'G': case 'g': case 'k': case 'K': case 'M': case 'm':\n        case 'P': case 'Q': case 'R': case 'T': case 't': case 'Y': case 'Z':\n\n           \n\n          if (strchr (valid_suffixes, '0'))\n            switch (p[0][1])\n              {\n              case 'i':\n                if (p[0][2] == 'B')\n                  suffixes += 2;\n                break;\n\n              case 'B':\n              case 'D':  \n                base = 1000;\n                suffixes++;\n                break;\n              }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n           \n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = LONGINT_OK;\n          break;\n\n        case 'E':  \n          overflow = bkm_scale_by_power (&tmp, base, 6);\n          break;\n\n        case 'G':  \n        case 'g':  \n          overflow = bkm_scale_by_power (&tmp, base, 3);\n          break;\n\n        case 'k':  \n        case 'K':  \n          overflow = bkm_scale_by_power (&tmp, base, 1);\n          break;\n\n        case 'M':  \n        case 'm':  \n          overflow = bkm_scale_by_power (&tmp, base, 2);\n          break;\n\n        case 'P':  \n          overflow = bkm_scale_by_power (&tmp, base, 5);\n          break;\n\n        case 'Q':  \n          overflow = bkm_scale_by_power (&tmp, base, 10);\n          break;\n\n        case 'R':  \n          overflow = bkm_scale_by_power (&tmp, base, 9);\n          break;\n\n        case 'T':  \n        case 't':  \n          overflow = bkm_scale_by_power (&tmp, base, 4);\n          break;\n\n        case 'w':\n          overflow = bkm_scale (&tmp, 2);\n          break;\n\n        case 'Y':  \n          overflow = bkm_scale_by_power (&tmp, base, 8);\n          break;\n\n        case 'Z':  \n          overflow = bkm_scale_by_power (&tmp, base, 7);\n          break;\n\n        default:\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      err |= overflow;\n      *p += suffixes;\n      if (**p)\n        err |= LONGINT_INVALID_SUFFIX_CHAR;\n    }\n\n  *val = tmp;\n  return err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}