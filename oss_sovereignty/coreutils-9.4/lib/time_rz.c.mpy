{
  "module_name": "time_rz.c",
  "hash_id": "95ba9c5c17c9eda1e9a5f4448b49667b1d9c5e43cdcffb12082b9651ab518706",
  "original_prompt": "Ingested from coreutils-9.4/lib/time_rz.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include <time.h>\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"flexmember.h\"\n#include \"idx.h\"\n#include \"time-internal.h\"\n\n \nenum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n \nenum { ABBR_SIZE_MIN = DEFAULT_MXFAST - offsetof (struct tm_zone, abbrs) };\n\n \nstatic timezone_t const local_tz = (timezone_t) 1;\n\n \nstatic void\nextend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n{\n  memcpy (abbrs, abbr, abbr_size);\n  abbrs[abbr_size] = '\\0';\n}\n\n \ntimezone_t\ntzalloc (char const *name)\n{\n  size_t name_size = name ? strlen (name) + 1 : 0;\n  size_t abbr_size = name_size < ABBR_SIZE_MIN ? ABBR_SIZE_MIN : name_size + 1;\n  timezone_t tz = malloc (FLEXSIZEOF (struct tm_zone, abbrs, abbr_size));\n  if (tz)\n    {\n      tz->next = NULL;\n#if HAVE_TZNAME && !HAVE_STRUCT_TM_TM_ZONE\n      tz->tzname_copy[0] = tz->tzname_copy[1] = NULL;\n#endif\n      tz->tz_is_set = !!name;\n      tz->abbrs[0] = '\\0';\n      if (name)\n        extend_abbrs (tz->abbrs, name, name_size);\n    }\n  return tz;\n}\n\n \nstatic bool\nsave_abbr (timezone_t tz, struct tm *tm)\n{\n#if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME\n  char const *zone = NULL;\n  char *zone_copy = (char *) \"\";\n\n# if HAVE_TZNAME\n  int tzname_index = -1;\n# endif\n\n# if HAVE_STRUCT_TM_TM_ZONE\n  zone = tm->tm_zone;\n# endif\n\n# if HAVE_TZNAME\n  if (! (zone && *zone) && 0 <= tm->tm_isdst)\n    {\n      tzname_index = tm->tm_isdst != 0;\n      zone = tzname[tzname_index];\n    }\n# endif\n\n   \n  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))\n    return true;\n\n  if (*zone)\n    {\n      zone_copy = tz->abbrs;\n\n      while (strcmp (zone_copy, zone) != 0)\n        {\n          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))\n            {\n              idx_t zone_size = strlen (zone) + 1;\n              if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)\n                extend_abbrs (zone_copy, zone, zone_size);\n              else\n                {\n                  tz = tz->next = tzalloc (zone);\n                  if (!tz)\n                    return false;\n                  tz->tz_is_set = 0;\n                  zone_copy = tz->abbrs;\n                }\n              break;\n            }\n\n          zone_copy += strlen (zone_copy) + 1;\n          if (!*zone_copy && tz->next)\n            {\n              tz = tz->next;\n              zone_copy = tz->abbrs;\n            }\n        }\n    }\n\n   \n# if HAVE_STRUCT_TM_TM_ZONE\n  tm->tm_zone = zone_copy;\n# else\n  if (0 <= tzname_index)\n    tz->tzname_copy[tzname_index] = zone_copy;\n# endif\n#endif\n\n  return true;\n}\n\n \nvoid\ntzfree (timezone_t tz)\n{\n  if (tz != local_tz)\n    while (tz)\n      {\n        timezone_t next = tz->next;\n        free (tz);\n        tz = next;\n      }\n}\n\n \n\n#ifndef getenv_TZ\nstatic char *\ngetenv_TZ (void)\n{\n  return getenv (\"TZ\");\n}\n#endif\n\n#ifndef setenv_TZ\nstatic int\nsetenv_TZ (char const *tz)\n{\n  return tz ? setenv (\"TZ\", tz, 1) : unsetenv (\"TZ\");\n}\n#endif\n\n \nstatic bool\nchange_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}\n\n \nstatic timezone_t\nset_tz (timezone_t tz)\n{\n  char *env_tz = getenv_TZ ();\n  if (env_tz\n      ? tz->tz_is_set && strcmp (tz->abbrs, env_tz) == 0\n      : !tz->tz_is_set)\n    return local_tz;\n  else\n    {\n      timezone_t old_tz = tzalloc (env_tz);\n      if (!old_tz)\n        return old_tz;\n      if (! change_env (tz))\n        {\n          int saved_errno = errno;\n          tzfree (old_tz);\n          errno = saved_errno;\n          return NULL;\n        }\n      return old_tz;\n    }\n}\n\n \nstatic bool\nrevert_tz (timezone_t tz)\n{\n  if (tz == local_tz)\n    return true;\n  else\n    {\n      int saved_errno = errno;\n      bool ok = change_env (tz);\n      if (!ok)\n        saved_errno = errno;\n      tzfree (tz);\n      errno = saved_errno;\n      return ok;\n    }\n}\n\n \nstruct tm *\nlocaltime_rz (timezone_t tz, time_t const *t, struct tm *tm)\n{\n#ifdef HAVE_LOCALTIME_INFLOOP_BUG\n   \n  if (! (-67768038400665599 <= *t && *t <= 67768036191766798))\n    {\n      errno = EOVERFLOW;\n      return NULL;\n    }\n#endif\n\n  if (!tz)\n    return gmtime_r (t, tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          bool abbr_saved = localtime_r (t, tm) && save_abbr (tz, tm);\n          if (revert_tz (old_tz) && abbr_saved)\n            return tm;\n        }\n      return NULL;\n    }\n}\n\n \ntime_t\nmktime_z (timezone_t tz, struct tm *tm)\n{\n  if (!tz)\n    return timegm (tm);\n  else\n    {\n      timezone_t old_tz = set_tz (tz);\n      if (old_tz)\n        {\n          struct tm tm_1;\n          tm_1.tm_sec = tm->tm_sec;\n          tm_1.tm_min = tm->tm_min;\n          tm_1.tm_hour = tm->tm_hour;\n          tm_1.tm_mday = tm->tm_mday;\n          tm_1.tm_mon = tm->tm_mon;\n          tm_1.tm_year = tm->tm_year;\n          tm_1.tm_yday = -1;\n          tm_1.tm_isdst = tm->tm_isdst;\n          time_t t = mktime (&tm_1);\n          bool ok = 0 <= tm_1.tm_yday;\n#if HAVE_STRUCT_TM_TM_ZONE || HAVE_TZNAME\n          ok = ok && save_abbr (tz, &tm_1);\n#endif\n          if (revert_tz (old_tz) && ok)\n            {\n              *tm = tm_1;\n              return t;\n            }\n        }\n      return -1;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}