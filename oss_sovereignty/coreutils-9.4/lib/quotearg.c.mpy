{
  "module_name": "quotearg.c",
  "hash_id": "02555095b14030e239aaa4ce6a0b68acb65e4439b306061c7320030eecce8a80",
  "original_prompt": "Ingested from coreutils-9.4/lib/quotearg.c",
  "human_readable_source": " \n\n \n#if (__GNUC__ == 4 && 6 <= __GNUC_MINOR__) || 4 < __GNUC__\n# pragma GCC diagnostic ignored \"-Wsuggest-attribute=pure\"\n#endif\n\n#include <config.h>\n\n#include \"quotearg.h\"\n#include \"quote.h\"\n\n#include \"attribute.h\"\n#include \"minmax.h\"\n#include \"xalloc.h\"\n#include \"c-strcaseeq.h\"\n#include \"localcharset.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <uchar.h>\n#include <wchar.h>\n\n#include \"gettext.h\"\n#define _(msgid) gettext (msgid)\n#define N_(msgid) msgid\n\n#ifndef SIZE_MAX\n# define SIZE_MAX ((size_t) -1)\n#endif\n\n#define INT_BITS (sizeof (int) * CHAR_BIT)\n\nstruct quoting_options\n{\n   \n  enum quoting_style style;\n\n   \n  int flags;\n\n   \n  unsigned int quote_these_too[(UCHAR_MAX / INT_BITS) + 1];\n\n   \n  char const *left_quote;\n\n   \n  char const *right_quote;\n};\n\n \nchar const *const quoting_style_args[] =\n{\n  \"literal\",\n  \"shell\",\n  \"shell-always\",\n  \"shell-escape\",\n  \"shell-escape-always\",\n  \"c\",\n  \"c-maybe\",\n  \"escape\",\n  \"locale\",\n  \"clocale\",\n  0\n};\n\n \nenum quoting_style const quoting_style_vals[] =\n{\n  literal_quoting_style,\n  shell_quoting_style,\n  shell_always_quoting_style,\n  shell_escape_quoting_style,\n  shell_escape_always_quoting_style,\n  c_quoting_style,\n  c_maybe_quoting_style,\n  escape_quoting_style,\n  locale_quoting_style,\n  clocale_quoting_style\n};\n\n \nstatic struct quoting_options default_quoting_options;\n\n \nstruct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}\n\n \nenum quoting_style\nget_quoting_style (struct quoting_options const *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}\n\n \nvoid\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}\n\n \nint\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}\n\n \nint\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}\n\nvoid\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}\n\n \nstatic struct quoting_options  \nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { literal_quoting_style, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}\n\n \nstatic char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n   \n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}\n\n \n\nstatic size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  size_t orig_buffersize = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n  bool pending_shell_escape_end = false;\n  bool encountered_single_quote = false;\n  bool all_c_and_shell_quote_compat = true;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n#define START_ESC() \\\n    do \\\n      { \\\n        if (elide_outer_quotes) \\\n          goto force_outer_quoting_style; \\\n        escaping = true; \\\n        if (quoting_style == shell_always_quoting_style \\\n            && ! pending_shell_escape_end) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('$'); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = true; \\\n          } \\\n        STORE ('\\\\'); \\\n      } \\\n    while (0)\n\n#define END_ESC() \\\n    do \\\n      { \\\n        if (pending_shell_escape_end && ! escaping) \\\n          { \\\n            STORE ('\\''); \\\n            STORE ('\\''); \\\n            pending_shell_escape_end = false; \\\n          } \\\n      } \\\n    while (0)\n\n process_input:\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n             \n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_escape_quoting_style:\n      backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_quoting_style:\n      elide_outer_quotes = true;\n      FALLTHROUGH;\n    case shell_escape_always_quoting_style:\n      if (!elide_outer_quotes)\n        backslash_escapes = true;\n      FALLTHROUGH;\n    case shell_always_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n      bool escaping = false;\n      bool c_and_shell_quote_compat = false;\n\n      if (backslash_escapes\n          && quoting_style != shell_always_quoting_style\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                   \n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              START_ESC ();\n               \n              if (quoting_style != shell_always_quoting_style\n                  && i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n               \n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                     \n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n           \n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              goto store_c;\n            }\n\n           \n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n           \n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}':  \n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          FALLTHROUGH;\n        case '#': case '~':\n          if (i != 0)\n            break;\n          FALLTHROUGH;\n        case ' ':\n          c_and_shell_quote_compat = true;\n          FALLTHROUGH;\n        case '!':  \n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=':  \n        case '>': case '[':\n        case '^':  \n        case '`': case '|':\n           \n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          encountered_single_quote = true;\n          c_and_shell_quote_compat = true;\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n\n              if (buffersize && ! orig_buffersize)\n                {\n                   \n                  orig_buffersize = buffersize;\n                  buffersize = 0;\n                }\n\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n              pending_shell_escape_end = false;\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n           \n          c_and_shell_quote_compat = true;\n          break;\n\n        default:\n           \n          {\n             \n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                mbszero (&mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                for (;;)\n                  {\n                    char32_t w;\n                    size_t bytes = mbrtoc32 (&w, &arg[i + m],\n                                             argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        #if !GNULIB_MBRTOC32_REGULAR\n                        if (bytes == (size_t) -3)\n                          bytes = 0;\n                        #endif\n                         \n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! c32isprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                    #if !GNULIB_MBRTOC32_REGULAR\n                    if (mbsinit (&mbstate))\n                    #endif\n                      break;\n                  }\n              }\n\n            c_and_shell_quote_compat = printable;\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                 \n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        START_ESC ();\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    END_ESC ();\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! (((backslash_escapes && quoting_style != shell_always_quoting_style)\n              || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      START_ESC ();\n\n    store_c:\n      END_ESC ();\n      STORE (c);\n\n      if (! c_and_shell_quote_compat)\n        all_c_and_shell_quote_compat = false;\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n   \n  if (quoting_style == shell_always_quoting_style && ! elide_outer_quotes\n      && encountered_single_quote)\n    {\n      if (all_c_and_shell_quote_compat)\n        return quotearg_buffer_restyled (buffer, orig_buffersize, arg, argsize,\n                                         c_quoting_style,\n                                         flags, quote_these_too,\n                                         left_quote, right_quote);\n      else if (! buffersize && orig_buffersize)\n        {\n           \n          buffersize = orig_buffersize;\n          len = 0;\n          goto process_input;\n        }\n    }\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n   \n  if (quoting_style == shell_always_quoting_style && backslash_escapes)\n    quoting_style = shell_escape_always_quoting_style;\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}\n\n \nsize_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}\n\nchar *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}\n\n \nchar *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n   \n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}\n\n \nstruct slotvec\n{\n  size_t size;\n  char *val;\n};\n\n \nstatic char slot0[256];\nstatic int nslots = 1;\nstatic struct slotvec slotvec0 = {sizeof slot0, slot0};\nstatic struct slotvec *slotvec = &slotvec0;\n\nvoid\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}\n\n \nstatic char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  struct slotvec *sv = slotvec;\n\n  int nslots_max = MIN (INT_MAX, IDX_MAX);\n  if (! (0 <= n && n < nslots_max))\n    abort ();\n\n  if (nslots <= n)\n    {\n      bool preallocated = (sv == &slotvec0);\n      idx_t new_nslots = nslots;\n\n      slotvec = sv = xpalloc (preallocated ? NULL : sv, &new_nslots,\n                              n - nslots + 1, nslots_max, sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (new_nslots - nslots) * sizeof *sv);\n      nslots = new_nslots;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n     \n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}\n\nchar *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}\n\nchar *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}\n\nchar *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}\n\nchar *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}\n\nchar *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}\n\nchar *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}\n\nchar *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}\n\nchar *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}\n\nchar *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}\n\nchar *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}\n\nchar *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}\n\nchar *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}\n\nchar *\nquotearg_n_style_colon (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options options;\n  options = quoting_options_from_style (s);\n  set_char_quoting (&options, ':', 1);\n  return quotearg_n_options (n, arg, SIZE_MAX, &options);\n}\n\nchar *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}\n\nchar *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}\n\nchar *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}\n\nchar *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}\n\n\n \nstruct quoting_options quote_quoting_options =\n  {\n    locale_quoting_style,\n    0,\n    { 0 },\n    NULL, NULL\n  };\n\nchar const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}\n\nchar const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}\n\nchar const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}\n\nchar const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}