{
  "module_name": "userspec.c",
  "hash_id": "28d3014ad93a41ce9e5fe584053db4fea53a7736198b13862ac28ed0905ea8c4",
  "original_prompt": "Ingested from coreutils-9.4/lib/userspec.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"userspec.h\"\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n\n#if HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <unistd.h>\n\n#include \"intprops.h\"\n#include \"inttostr.h\"\n#include \"xalloc.h\"\n#include \"xstrtol.h\"\n\n#include \"gettext.h\"\n#define _(msgid) gettext (msgid)\n#define N_(msgid) msgid\n\n#ifndef HAVE_ENDGRENT\n# define endgrent() ((void) 0)\n#endif\n\n#ifndef HAVE_ENDPWENT\n# define endpwent() ((void) 0)\n#endif\n\n#ifndef UID_T_MAX\n# define UID_T_MAX TYPE_MAXIMUM (uid_t)\n#endif\n\n#ifndef GID_T_MAX\n# define GID_T_MAX TYPE_MAXIMUM (gid_t)\n#endif\n\n \n#ifndef MAXUID\n# define MAXUID UID_T_MAX\n#endif\n#ifndef MAXGID\n# define MAXGID GID_T_MAX\n#endif\n\n#ifdef __DJGPP__\n\n \n# define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)\n\n \n\nstatic bool\nis_number (const char *str)\n{\n  do\n    {\n      if (!ISDIGIT (*str))\n        return false;\n    }\n  while (*++str);\n\n  return true;\n}\n#endif\n\nstatic char const *\nparse_with_separator (char const *spec, char const *separator,\n                      uid_t *uid, gid_t *gid,\n                      char **username, char **groupname)\n{\n  const char *error_msg;\n  struct passwd *pwd;\n  struct group *grp;\n  char *u;\n  char const *g;\n  char *gname = NULL;\n  uid_t unum = *uid;\n  gid_t gnum = gid ? *gid : -1;\n\n  error_msg = NULL;\n  if (username)\n    *username = NULL;\n  if (groupname)\n    *groupname = NULL;\n\n   \n\n  u = NULL;\n  if (separator == NULL)\n    {\n      if (*spec)\n        u = xstrdup (spec);\n    }\n  else\n    {\n      idx_t ulen = separator - spec;\n      if (ulen != 0)\n        {\n          u = ximemdup (spec, ulen + 1);\n          u[ulen] = '\\0';\n        }\n    }\n\n  g = (separator == NULL || *(separator + 1) == '\\0'\n       ? NULL\n       : separator + 1);\n\n#ifdef __DJGPP__\n   \n  if (u && !is_number (u))\n    setenv (\"USER\", u, 1);\n  if (g && !is_number (g))\n    setenv (\"GROUP\", g, 1);\n#endif\n\n  if (u != NULL)\n    {\n       \n      pwd = (*u == '+' ? NULL : getpwnam (u));\n      if (pwd == NULL)\n        {\n          username = NULL;\n          bool use_login_group = (separator != NULL && g == NULL);\n          if (use_login_group)\n            {\n               \n              error_msg = N_(\"invalid spec\");\n            }\n          else\n            {\n              unsigned long int tmp;\n              if (xstrtoul (u, NULL, 10, &tmp, \"\") == LONGINT_OK\n                  && tmp <= MAXUID && (uid_t) tmp != (uid_t) -1)\n                unum = tmp;\n              else\n                error_msg = N_(\"invalid user\");\n            }\n        }\n      else\n        {\n          unum = pwd->pw_uid;\n          if (g == NULL && separator != NULL)\n            {\n               \n              char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n              gnum = pwd->pw_gid;\n              grp = getgrgid (gnum);\n              gname = xstrdup (grp ? grp->gr_name : umaxtostr (gnum, buf));\n              endgrent ();\n            }\n        }\n      endpwent ();\n    }\n\n  if (g != NULL && error_msg == NULL)\n    {\n       \n       \n      grp = (*g == '+' ? NULL : getgrnam (g));\n      if (grp == NULL)\n        {\n          groupname = NULL;\n          unsigned long int tmp;\n          if (xstrtoul (g, NULL, 10, &tmp, \"\") == LONGINT_OK\n              && tmp <= MAXGID && (gid_t) tmp != (gid_t) -1)\n            gnum = tmp;\n          else\n            error_msg = N_(\"invalid group\");\n        }\n      else\n        gnum = grp->gr_gid;\n      endgrent ();               \n      gname = xstrdup (g);\n    }\n\n  if (error_msg == NULL)\n    {\n      *uid = unum;\n      if (gid)\n        *gid = gnum;\n      if (username)\n        {\n          *username = u;\n          u = NULL;\n        }\n      if (groupname)\n        {\n          *groupname = gname;\n          gname = NULL;\n        }\n    }\n\n  free (u);\n  free (gname);\n  return error_msg ? _(error_msg) : NULL;\n}\n\n \n\nchar const *\nparse_user_spec_warn (char const *spec, uid_t *uid, gid_t *gid,\n                      char **username, char **groupname, bool *pwarn)\n{\n  char const *colon = gid ? strchr (spec, ':') : NULL;\n  char const *error_msg =\n    parse_with_separator (spec, colon, uid, gid, username, groupname);\n  bool warn = false;\n\n  if (gid && !colon && error_msg)\n    {\n       \n\n      char const *dot = strchr (spec, '.');\n      if (dot\n          && ! parse_with_separator (spec, dot, uid, gid, username, groupname))\n        {\n          warn = true;\n          error_msg = pwarn ? N_(\"warning: '.' should be ':'\") : NULL;\n        }\n    }\n\n  if (pwarn)\n    *pwarn = warn;\n  return error_msg;\n}\n\n \n\nchar const *\nparse_user_spec (char const *spec, uid_t *uid, gid_t *gid,\n                 char **username, char **groupname)\n{\n  return parse_user_spec_warn (spec, uid, gid, username, groupname, NULL);\n}\n\n#ifdef TEST\n\n# define NULL_CHECK(s) ((s) == NULL ? \"(null)\" : (s))\n\nint\nmain (int argc, char **argv)\n{\n  int i;\n\n  for (i = 1; i < argc; i++)\n    {\n      const char *e;\n      char *username, *groupname;\n      uid_t uid;\n      gid_t gid;\n      char *tmp;\n\n      tmp = strdup (argv[i]);\n      e = parse_user_spec (tmp, &uid, &gid, &username, &groupname);\n      free (tmp);\n      printf (\"%s: %lu %lu %s %s %s\\n\",\n              argv[i],\n              (unsigned long int) uid,\n              (unsigned long int) gid,\n              NULL_CHECK (username),\n              NULL_CHECK (groupname),\n              NULL_CHECK (e));\n    }\n\n  exit (0);\n}\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}