{
  "module_name": "mbrtoc32.c",
  "hash_id": "298eb0ab0983bed78cb2fd5c4fb00f74829fe6dc64672317ee65b062119cd6ca",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbrtoc32.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <uchar.h>\n\n#include \"attribute.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n\n#if GL_CHAR32_T_IS_UNICODE\n# include \"lc-charset-unicode.h\"\n#endif\n\n#if GNULIB_defined_mbstate_t  \n \n\n \n\n# if defined _WIN32 && !defined __CYGWIN__\n\n#  define WIN32_LEAN_AND_MEAN   \n#  include <windows.h>\n\n# elif HAVE_PTHREAD_API\n\n#  include <pthread.h>\n#  if HAVE_THREADS_H && HAVE_WEAK_SYMBOLS\n#   include <threads.h>\n#   pragma weak thrd_exit\n#   define c11_threads_in_use() (thrd_exit != NULL)\n#  else\n#   define c11_threads_in_use() 0\n#  endif\n\n# elif HAVE_THREADS_H\n\n#  include <threads.h>\n\n# endif\n\n# include \"lc-charset-dispatch.h\"\n# include \"mbtowc-lock.h\"\n\nstatic_assert (sizeof (mbstate_t) >= 4);\nstatic char internal_state[4];\n\nsize_t\nmbrtoc32 (char32_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# define FITS_IN_CHAR_TYPE(wc)  1\n# include \"mbrtowc-impl.h\"\n}\n\n#else  \n\n \n\n# include <wchar.h>\n\n# include \"localcharset.h\"\n# include \"streq.h\"\n\n# if MBRTOC32_IN_C_LOCALE_MAYBE_EILSEQ\n#  include \"hard-locale.h\"\n#  include <locale.h>\n# endif\n\nstatic mbstate_t internal_state;\n\nsize_t\nmbrtoc32 (char32_t *pwc, const char *s, size_t n, mbstate_t *ps)\n# undef mbrtoc32\n{\n   \n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n# if MBRTOC32_EMPTY_INPUT_BUG || _GL_SMALL_WCHAR_T\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n  if (ps == NULL)\n    ps = &internal_state;\n\n# if HAVE_WORKING_MBRTOC32\n   \n\n#  if defined _WIN32 && !defined __CYGWIN__\n  char32_t wc;\n  size_t ret = mbrtoc32 (&wc, s, n, ps);\n  if (ret < (size_t) -2 && pwc != NULL)\n    *pwc = wc;\n#  else\n  size_t ret = mbrtoc32 (pwc, s, n, ps);\n#  endif\n\n#  if GNULIB_MBRTOC32_REGULAR\n   \n  if (ret < (size_t) -3 && ! mbsinit (ps))\n     \n    mbszero (ps);\n  if (ret == (size_t) -3)\n    abort ();\n#  endif\n\n#  if MBRTOC32_IN_C_LOCALE_MAYBE_EILSEQ\n  if ((size_t) -2 <= ret && n != 0 && ! hard_locale (LC_CTYPE))\n    {\n      if (pwc != NULL)\n        *pwc = (unsigned char) *s;\n      return 1;\n    }\n#  endif\n\n  return ret;\n\n# elif _GL_SMALL_WCHAR_T\n\n   \n  const char *encoding = locale_charset ();\n  if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n    {\n       \n       \n      char *pstate = (char *)ps;\n      size_t nstate = pstate[0];\n      char buf[4];\n      const char *p;\n      size_t m;\n      int res;\n\n      switch (nstate)\n        {\n        case 0:\n          p = s;\n          m = n;\n          break;\n        case 3:\n          buf[2] = pstate[3];\n          FALLTHROUGH;\n        case 2:\n          buf[1] = pstate[2];\n          FALLTHROUGH;\n        case 1:\n          buf[0] = pstate[1];\n          p = buf;\n          m = nstate;\n          buf[m++] = s[0];\n          if (n >= 2 && m < 4)\n            {\n              buf[m++] = s[1];\n              if (n >= 3 && m < 4)\n                buf[m++] = s[2];\n            }\n          break;\n        default:\n          errno = EINVAL;\n          return (size_t)(-1);\n        }\n\n       \n\n      {\n#  define FITS_IN_CHAR_TYPE(wc)  1\n#  include \"mbrtowc-impl-utf8.h\"\n      }\n\n     success:\n      if (nstate >= (res > 0 ? res : 1))\n        abort ();\n      res -= nstate;\n       \n#  if defined _WIN32 && !defined __CYGWIN__\n       \n       \n      *(unsigned int *)pstate = 0;\n#  elif defined __CYGWIN__\n       \n      ps->__count = 0;\n#  else\n      pstate[0] = 0;\n#  endif\n      return res;\n\n     incomplete:\n      {\n        size_t k = nstate;\n         \n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n       \n      return (size_t)(-1);\n    }\n  else\n    {\n      wchar_t wc;\n      size_t ret = mbrtowc (&wc, s, n, ps);\n      if (ret < (size_t) -2 && pwc != NULL)\n        *pwc = wc;\n      return ret;\n    }\n\n# else\n\n   \n  wchar_t wc;\n  size_t ret = mbrtowc (&wc, s, n, ps);\n\n#  if GNULIB_MBRTOC32_REGULAR\n   \n  if (ret < (size_t) -2 && ! mbsinit (ps))\n     \n    mbszero (ps);\n#  endif\n\n#  if GL_CHAR32_T_IS_UNICODE && GL_CHAR32_T_VS_WCHAR_T_NEEDS_CONVERSION\n  if (ret < (size_t) -2 && wc != 0)\n    {\n      wc = locale_encoding_to_unicode (wc);\n      if (wc == 0)\n        {\n          ret = (size_t) -1;\n          errno = EILSEQ;\n        }\n    }\n#  endif\n  if (ret < (size_t) -2 && pwc != NULL)\n    *pwc = wc;\n  return ret;\n\n# endif\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}