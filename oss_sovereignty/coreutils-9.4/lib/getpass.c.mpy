{
  "module_name": "getpass.c",
  "hash_id": "84205180f6d0b88e982b10fe84520216d5c943cdfe33c58685c1e9af57a5f666",
  "original_prompt": "Ingested from coreutils-9.4/lib/getpass.c",
  "human_readable_source": " \n# define _GL_ARG_NONNULL(params)\n# include <config.h>\n#endif\n\n#include \"getpass.h\"\n\n#include <stdio.h>\n\n#if !(defined _WIN32 && !defined __CYGWIN__)\n\n# if HAVE_DECL___FSETLOCKING && HAVE___FSETLOCKING\n#  if HAVE_STDIO_EXT_H\n#   include <stdio_ext.h>\n#  endif\n# else\n#  define __fsetlocking(stream, type)     \n# endif\n\n# if HAVE_TERMIOS_H\n#  include <termios.h>\n# endif\n\n# if USE_UNLOCKED_IO\n#  include \"unlocked-io.h\"\n# else\n#  if !HAVE_DECL_FFLUSH_UNLOCKED\n#   undef fflush_unlocked\n#   define fflush_unlocked(x) fflush (x)\n#  endif\n#  if !HAVE_DECL_FLOCKFILE\n#   undef flockfile\n#   define flockfile(x) ((void) 0)\n#  endif\n#  if !HAVE_DECL_FUNLOCKFILE\n#   undef funlockfile\n#   define funlockfile(x) ((void) 0)\n#  endif\n#  if !HAVE_DECL_FPUTS_UNLOCKED\n#   undef fputs_unlocked\n#   define fputs_unlocked(str,stream) fputs (str, stream)\n#  endif\n#  if !HAVE_DECL_PUTC_UNLOCKED\n#   undef putc_unlocked\n#   define putc_unlocked(c,stream) putc (c, stream)\n#  endif\n# endif\n\n \n\n# ifndef TCSASOFT\n#  define TCSASOFT 0\n# endif\n\nstatic void\ncall_fclose (void *arg)\n{\n  if (arg != NULL)\n    fclose (arg);\n}\n\nchar *\ngetpass (const char *prompt)\n{\n  FILE *tty;\n  FILE *in, *out;\n# if HAVE_TCGETATTR\n  struct termios s, t;\n# endif\n  bool tty_changed = false;\n  static char *buf;\n  static size_t bufsize;\n  ssize_t nread;\n\n   \n\n  tty = fopen (\"/dev/tty\", \"w+e\");\n  if (tty == NULL)\n    {\n      in = stdin;\n      out = stderr;\n    }\n  else\n    {\n       \n      __fsetlocking (tty, FSETLOCKING_BYCALLER);\n\n      out = in = tty;\n    }\n\n  flockfile (out);\n\n   \n# if HAVE_TCGETATTR\n  if (tcgetattr (fileno (in), &t) == 0)\n    {\n       \n      s = t;\n       \n      t.c_lflag &= ~(ECHO | ISIG);\n      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &t) == 0);\n    }\n# endif\n\n  if (prompt)\n    {\n       \n      fputs_unlocked (prompt, out);\n      fflush_unlocked (out);\n    }\n\n   \n  nread = getline (&buf, &bufsize, in);\n\n   \n  fseeko (out, 0, SEEK_CUR);\n\n  if (buf != NULL)\n    {\n      if (nread < 0)\n        buf[0] = '\\0';\n      else if (buf[nread - 1] == '\\n')\n        {\n           \n          buf[nread - 1] = '\\0';\n          if (tty_changed)\n            {\n               \n              putc_unlocked ('\\n', out);\n            }\n        }\n    }\n\n   \n# if HAVE_TCSETATTR\n  if (tty_changed)\n    tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &s);\n# endif\n\n  funlockfile (out);\n\n  call_fclose (tty);\n\n  return buf;\n}\n\n#else  \n\n \n\n \n# include <limits.h>\n \n# include <conio.h>\n \n# include <string.h>\n\n# ifndef PASS_MAX\n#  define PASS_MAX 512\n# endif\n\nchar *\ngetpass (const char *prompt)\n{\n  char getpassbuf[PASS_MAX + 1];\n  size_t i = 0;\n  int c;\n\n  if (prompt)\n    {\n      fputs (prompt, stderr);\n      fflush (stderr);\n    }\n\n  for (;;)\n    {\n      c = _getch ();\n      if (c == '\\r')\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n      else if (i < PASS_MAX)\n        {\n          getpassbuf[i++] = c;\n        }\n\n      if (i >= PASS_MAX)\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n    }\n\n  if (prompt)\n    {\n      fputs (\"\\r\\n\", stderr);\n      fflush (stderr);\n    }\n\n  return strdup (getpassbuf);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}