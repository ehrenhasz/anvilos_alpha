{
  "module_name": "fpurge.c",
  "hash_id": "9a77cd6b5274c7b325d28ebb1025fa52c6fd927a8da7914c603202fc280c301f",
  "original_prompt": "Ingested from coreutils-9.4/lib/fpurge.c",
  "human_readable_source": " \n#include <stdio.h>\n\n#if HAVE___FPURGE                    \n# if HAVE_STDIO_EXT_H\n#  include <stdio_ext.h>\n# endif\n#endif\n#include <stdlib.h>\n\n#include \"stdio-impl.h\"\n\nint\nfpurge (FILE *fp)\n{\n#if HAVE___FPURGE                    \n\n  __fpurge (fp);\n   \n  return 0;\n\n#elif HAVE_FPURGE                    \n\n   \n# undef fpurge\n# if !HAVE_DECL_FPURGE\n  extern int fpurge (FILE *);\n# endif\n  int result = fpurge (fp);\n# if defined __sferror || defined __DragonFly__ || defined __ANDROID__\n   \n  if (result == 0)\n     \n    if ((fp_->_flags & __SRD) != 0)\n      fp_->_w = 0;\n# endif\n  return result;\n\n#else\n\n   \n# if defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n   \n  fp->_IO_read_end = fp->_IO_read_ptr;\n  fp->_IO_write_ptr = fp->_IO_write_base;\n   \n  if (fp->_IO_save_base != NULL)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n  return 0;\n# elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n   \n  fp_->_p = fp_->_bf._base;\n  fp_->_r = 0;\n  fp_->_w = ((fp_->_flags & (__SLBF | __SNBF | __SRD)) == 0  \n             ? fp_->_bf._size\n             : 0);\n   \n  if (fp_ub._base != NULL)\n    {\n      if (fp_ub._base != fp_->_ubuf)\n        free (fp_ub._base);\n      fp_ub._base = NULL;\n    }\n  return 0;\n# elif defined __EMX__               \n  fp->_ptr = fp->_buffer;\n  fp->_rcount = 0;\n  fp->_wcount = 0;\n  fp->_ungetc_count = 0;\n  return 0;\n# elif defined __minix               \n  fp->_ptr = fp->_buf;\n  if (fp->_ptr != NULL)\n    fp->_count = 0;\n  return 0;\n# elif defined _IOERR                \n  fp_->_ptr = fp_->_base;\n  if (fp_->_ptr != NULL)\n    fp_->_cnt = 0;\n  return 0;\n# elif defined __UCLIBC__            \n#  ifdef __STDIO_BUFFERS\n  if (fp->__modeflags & __FLAG_WRITING)\n    fp->__bufpos = fp->__bufstart;\n  else if (fp->__modeflags & (__FLAG_READONLY | __FLAG_READING))\n    fp->__bufpos = fp->__bufread;\n#  endif\n  return 0;\n# elif defined __QNX__               \n  fp->_Rback = fp->_Back + sizeof (fp->_Back);\n  fp->_Rsave = NULL;\n  if (fp->_Mode & 0x2000  )\n     \n    fp->_Next = fp->_Buf;\n  else\n     \n    fp->_Rend = fp->_Next;\n  return 0;\n# elif defined __MINT__              \n  if (fp->__pushed_back)\n    {\n      fp->__bufp = fp->__pushback_bufp;\n      fp->__pushed_back = 0;\n    }\n   \n  if (fp->__target != -1)\n    fp->__target += fp->__bufp - fp->__buffer;\n  fp->__bufp = fp->__buffer;\n   \n  fp->__get_limit = fp->__bufp;\n   \n  fp->__put_limit = fp->__buffer;\n  return 0;\n# elif defined EPLAN9                \n  fp->rp = fp->wp = fp->lp = fp->buf;\n  return 0;\n# else\n#  error \"Please port gnulib fpurge.c to your platform! Look at the definitions of fflush, setvbuf and ungetc on your system, then report this to bug-gnulib.\"\n# endif\n\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}