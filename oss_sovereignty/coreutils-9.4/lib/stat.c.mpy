{
  "module_name": "stat.c",
  "hash_id": "3b5b646e1ba604ee40d7b9503ccd2a16957b50a7e084343ed4fc76c8bf54837c",
  "original_prompt": "Ingested from coreutils-9.4/lib/stat.c",
  "human_readable_source": " \n\n \n#define __need_system_sys_stat_h\n#include <config.h>\n\n \n#include <sys/types.h>\n#include <sys/stat.h>\n#undef __need_system_sys_stat_h\n\n#if defined _WIN32 && ! defined __CYGWIN__\n# define WINDOWS_NATIVE\n#endif\n\n#if !defined WINDOWS_NATIVE\n\nstatic int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}\n\n#endif\n\n \n#ifdef __osf__\n \n# include \"sys/stat.h\"\n#else\n# include <sys/stat.h>\n#endif\n\n#include \"stat-time.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include \"filename.h\"\n#include \"malloca.h\"\n\n#ifdef WINDOWS_NATIVE\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n# include \"stat-w32.h\"\n \n# undef WIN32_FIND_DATA\n# define WIN32_FIND_DATA WIN32_FIND_DATAA\n# undef CreateFile\n# define CreateFile CreateFileA\n# undef FindFirstFile\n# define FindFirstFile FindFirstFileA\n#endif\n\n#ifdef WINDOWS_NATIVE\n \nstatic BOOL\nis_unc_root (const char *rname)\n{\n   \n  if (ISSLASH (rname[0]) && ISSLASH (rname[1]))\n    {\n       \n      const char *p = rname + 2;\n      const char *q = p;\n      while (*q != '\\0' && !ISSLASH (*q))\n        q++;\n      if (q > p && *q != '\\0')\n        {\n           \n          q++;\n          const char *r = q;\n          while (*r != '\\0' && !ISSLASH (*r))\n            r++;\n          if (r > q && *r == '\\0')\n            return TRUE;\n        }\n    }\n  return FALSE;\n}\n#endif\n\n \n\nint\nrpl_stat (char const *name, struct stat *buf)\n{\n#ifdef WINDOWS_NATIVE\n   \n\n   \n  if (ISSLASH (name[0]) && ISSLASH (name[1]) && ISSLASH (name[2]))\n    {\n      name += 2;\n      while (ISSLASH (name[1]))\n        name++;\n    }\n\n  size_t len = strlen (name);\n  size_t drive_prefix_len = (HAS_DEVICE (name) ? 2 : 0);\n\n   \n  size_t rlen;\n  bool check_dir = false;\n\n  rlen = len;\n  while (rlen > drive_prefix_len && ISSLASH (name[rlen-1]))\n    {\n      check_dir = true;\n      if (rlen == drive_prefix_len + 1)\n        break;\n      rlen--;\n    }\n\n   \n  if (!check_dir && rlen == drive_prefix_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n   \n  if (rlen == 1 && ISSLASH (name[0]) && len >= 2)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n\n  const char *rname;\n  char *malloca_rname;\n  if (rlen == len)\n    {\n      rname = name;\n      malloca_rname = NULL;\n    }\n  else\n    {\n      malloca_rname = malloca (rlen + 1);\n      if (malloca_rname == NULL)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      memcpy (malloca_rname, name, rlen);\n      malloca_rname[rlen] = '\\0';\n      rname = malloca_rname;\n    }\n\n   \n  {\n    int ret;\n\n    {\n       \n\n       \n      HANDLE h =\n        CreateFile (rname,\n                    FILE_READ_ATTRIBUTES,\n                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                    NULL,\n                    OPEN_EXISTING,\n                     \n                    FILE_FLAG_BACKUP_SEMANTICS  ,\n                    NULL);\n      if (h != INVALID_HANDLE_VALUE)\n        {\n          ret = _gl_fstat_by_handle (h, rname, buf);\n          CloseHandle (h);\n          goto done;\n        }\n    }\n\n     \n    if ((rlen == drive_prefix_len + 1 && ISSLASH (rname[drive_prefix_len]))\n        || is_unc_root (rname))\n      goto failed;\n\n     \n    {\n       \n\n      if (strchr (rname, '?') != NULL || strchr (rname, '*') != NULL)\n        {\n           \n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = ENOENT;\n          return -1;\n        }\n\n       \n      WIN32_FIND_DATA info;\n      HANDLE h = FindFirstFile (rname, &info);\n      if (h == INVALID_HANDLE_VALUE)\n        goto failed;\n\n       \n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          FindClose (h);\n          if (malloca_rname != NULL)\n            freea (malloca_rname);\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n# if _GL_WINDOWS_STAT_INODES\n      buf->st_dev = 0;\n#  if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#  else  \n      buf->st_ino = 0;\n#  endif\n# else\n       \n      buf->st_dev = 0;\n      buf->st_ino = 0;\n# endif\n\n       \n      unsigned int mode =\n         \n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n           \n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              const char *last_dot = NULL;\n              const char *p;\n              for (p = info.cFileName; *p != '\\0'; p++)\n                if (*p == '.')\n                  last_dot = p;\n              if (last_dot != NULL)\n                {\n                  const char *suffix = last_dot + 1;\n                  if (_stricmp (suffix, \"exe\") == 0\n                      || _stricmp (suffix, \"bat\") == 0\n                      || _stricmp (suffix, \"cmd\") == 0\n                      || _stricmp (suffix, \"com\") == 0)\n                    mode |= S_IEXEC_UGO;\n                }\n            }\n        }\n      buf->st_mode = mode;\n\n       \n      buf->st_nlink = 1;\n\n       \n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n       \n      buf->st_rdev = 0;\n\n       \n      if (sizeof (buf->st_size) <= 4)\n         \n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n       \n# if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n# else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n# endif\n\n      FindClose (h);\n\n      ret = 0;\n    }\n\n   done:\n    if (ret >= 0 && check_dir && !S_ISDIR (buf->st_mode))\n      {\n        errno = ENOTDIR;\n        ret = -1;\n      }\n    if (malloca_rname != NULL)\n      {\n        int saved_errno = errno;\n        freea (malloca_rname);\n        errno = saved_errno;\n      }\n    return ret;\n  }\n\n failed:\n  {\n    DWORD error = GetLastError ();\n    #if 0\n    fprintf (stderr, \"rpl_stat error 0x%x\\n\", (unsigned int) error);\n    #endif\n\n    if (malloca_rname != NULL)\n      freea (malloca_rname);\n\n    switch (error)\n      {\n       \n      case ERROR_FILE_NOT_FOUND:  \n      case ERROR_PATH_NOT_FOUND:  \n      case ERROR_BAD_PATHNAME:    \n      case ERROR_BAD_NET_NAME:    \n      case ERROR_INVALID_NAME:    \n      case ERROR_DIRECTORY:\n        errno = ENOENT;\n        break;\n\n      case ERROR_ACCESS_DENIED:   \n      case ERROR_SHARING_VIOLATION:  \n                                     \n        errno = EACCES;\n        break;\n\n      case ERROR_OUTOFMEMORY:\n        errno = ENOMEM;\n        break;\n\n      case ERROR_WRITE_PROTECT:\n        errno = EROFS;\n        break;\n\n      case ERROR_WRITE_FAULT:\n      case ERROR_READ_FAULT:\n      case ERROR_GEN_FAILURE:\n        errno = EIO;\n        break;\n\n      case ERROR_BUFFER_OVERFLOW:\n      case ERROR_FILENAME_EXCED_RANGE:\n        errno = ENAMETOOLONG;\n        break;\n\n      case ERROR_DELETE_PENDING:  \n        errno = EPERM;\n        break;\n\n      default:\n        errno = EINVAL;\n        break;\n      }\n\n    return -1;\n  }\n#else\n  int result = orig_stat (name, buf);\n  if (result == 0)\n    {\n# if REPLACE_FUNC_STAT_FILE\n       \n      if (!S_ISDIR (buf->st_mode))\n        {\n          size_t len = strlen (name);\n          if (ISSLASH (name[len - 1]))\n            {\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n# endif  \n      result = stat_time_normalize (result, buf);\n    }\n  return result;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}