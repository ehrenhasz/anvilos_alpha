{
  "module_name": "windows-rwlock.c",
  "hash_id": "b01d52a596f8ebe05b3b6d4ad295cf27f21bfafb09330f35b6adb2ecc4c8fc8b",
  "original_prompt": "Ingested from coreutils-9.4/lib/windows-rwlock.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"windows-rwlock.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n\n \n#undef CreateEvent\n#define CreateEvent CreateEventA\n\n \n#define glwthread_waitqueue_t glwthread_carray_waitqueue_t\n\nstatic void\nglwthread_waitqueue_init (glwthread_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}\n\n \nstatic HANDLE\nglwthread_waitqueue_add (glwthread_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n         \n        return INVALID_HANDLE_VALUE;\n       \n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n   \n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n     \n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}\n\n \nstatic void\nglwthread_waitqueue_notify_first (glwthread_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}\n\n \nstatic void\nglwthread_waitqueue_notify_all (glwthread_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}\n\nvoid\nglwthread_rwlock_init (glwthread_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  glwthread_waitqueue_init (&lock->waiting_readers);\n  glwthread_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}\n\nint\nglwthread_rwlock_rdlock (glwthread_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n         \n        glwthread_rwlock_init (lock);\n      else\n        {\n           \n          InterlockedDecrement (&lock->guard.started);\n           \n          while (!lock->guard.done)\n            Sleep (0);\n        }\n    }\n  EnterCriticalSection (&lock->lock);\n   \n  if (!(lock->runcount + 1 > 0 && lock->waiting_writers.count == 0))\n    {\n       \n      HANDLE event = glwthread_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n           \n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n           \n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n           \n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}\n\nint\nglwthread_rwlock_wrlock (glwthread_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n         \n        glwthread_rwlock_init (lock);\n      else\n        {\n           \n          InterlockedDecrement (&lock->guard.started);\n           \n          while (!lock->guard.done)\n            Sleep (0);\n        }\n    }\n  EnterCriticalSection (&lock->lock);\n   \n  if (!(lock->runcount == 0))\n    {\n       \n      HANDLE event = glwthread_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n           \n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n           \n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n           \n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--;  \n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}\n\nint\nglwthread_rwlock_tryrdlock (glwthread_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n         \n        glwthread_rwlock_init (lock);\n      else\n        {\n           \n          InterlockedDecrement (&lock->guard.started);\n           \n          while (!lock->guard.done)\n            Sleep (0);\n        }\n    }\n   \n  EnterCriticalSection (&lock->lock);\n   \n  if (!(lock->runcount + 1 > 0 && lock->waiting_writers.count == 0))\n    {\n       \n      LeaveCriticalSection (&lock->lock);\n      return EBUSY;\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}\n\nint\nglwthread_rwlock_trywrlock (glwthread_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n         \n        glwthread_rwlock_init (lock);\n      else\n        {\n           \n          InterlockedDecrement (&lock->guard.started);\n           \n          while (!lock->guard.done)\n            Sleep (0);\n        }\n    }\n   \n  EnterCriticalSection (&lock->lock);\n   \n  if (!(lock->runcount == 0))\n    {\n       \n      LeaveCriticalSection (&lock->lock);\n      return EBUSY;\n    }\n  lock->runcount--;  \n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}\n\nint\nglwthread_rwlock_unlock (glwthread_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n       \n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n       \n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n       \n      if (lock->waiting_writers.count > 0)\n        {\n           \n          lock->runcount--;\n          glwthread_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n           \n          lock->runcount += lock->waiting_readers.count;\n          glwthread_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}\n\nint\nglwthread_rwlock_destroy (glwthread_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}