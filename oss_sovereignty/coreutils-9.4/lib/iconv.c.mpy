{
  "module_name": "iconv.c",
  "hash_id": "845528616cc60762c25dfc9f7b2565a657b8a26447c4fff11464a96b82c88f3f",
  "original_prompt": "Ingested from coreutils-9.4/lib/iconv.c",
  "human_readable_source": " \n#include <iconv.h>\n\n#include <stddef.h>\n\n#if REPLACE_ICONV_UTF\n# include <errno.h>\n# include <stdint.h>\n# include <stdlib.h>\n# include \"unistr.h\"\n#endif\n\n#if REPLACE_ICONV_UTF\n\n \n\n \n# define RET_ILSEQ      -1\n \n# define RET_TOOFEW     -2\n\n \n# define RET_ILUNI      -1\n \n# define RET_TOOSMALL   -2\n\n \n\n \n\nstatic int\nutf16be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = (s[0] << 8) + s[1];\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = (s[2] << 8) + s[3];\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}\n\nstatic int\nutf16be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) (wc >> 8);\n              r[1] = (unsigned char) wc;\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) (wc1 >> 8);\n              r[1] = (unsigned char) wc1;\n              r[2] = (unsigned char) (wc2 >> 8);\n              r[3] = (unsigned char) wc2;\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}\n\n \n\n \n\nstatic int\nutf16le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8);\n      if (wc >= 0xd800 && wc < 0xdc00)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc2 = s[2] + (s[3] << 8);\n              if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n                return RET_ILSEQ;\n              *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n              return 4;\n            }\n        }\n      else if (wc >= 0xdc00 && wc < 0xe000)\n        {\n          return RET_ILSEQ;\n        }\n      else\n        {\n          *pwc = wc;\n          return 2;\n        }\n    }\n  return RET_TOOFEW;\n}\n\nstatic int\nutf16le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (wc < 0x10000)\n        {\n          if (n >= 2)\n            {\n              r[0] = (unsigned char) wc;\n              r[1] = (unsigned char) (wc >> 8);\n              return 2;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n      else if (wc < 0x110000)\n        {\n          if (n >= 4)\n            {\n              ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n              ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n              r[0] = (unsigned char) wc1;\n              r[1] = (unsigned char) (wc1 >> 8);\n              r[2] = (unsigned char) wc2;\n              r[3] = (unsigned char) (wc2 >> 8);\n              return 4;\n            }\n          else\n            return RET_TOOSMALL;\n        }\n    }\n  return RET_ILUNI;\n}\n\n \n\n \n\nstatic int\nutf32be_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}\n\nstatic int\nutf32be_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = 0;\n          r[1] = (unsigned char) (wc >> 16);\n          r[2] = (unsigned char) (wc >> 8);\n          r[3] = (unsigned char) wc;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}\n\n \n\n \n\nstatic int\nutf32le_mbtowc (ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4)\n    {\n      ucs4_t wc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n        {\n          *pwc = wc;\n          return 4;\n        }\n      else\n        return RET_ILSEQ;\n    }\n  return RET_TOOFEW;\n}\n\nstatic int\nutf32le_wctomb (unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000))\n    {\n      if (n >= 4)\n        {\n          r[0] = (unsigned char) wc;\n          r[1] = (unsigned char) (wc >> 8);\n          r[2] = (unsigned char) (wc >> 16);\n          r[3] = 0;\n          return 4;\n        }\n      else\n        return RET_TOOSMALL;\n    }\n  return RET_ILUNI;\n}\n\n#endif\n\nsize_t\nrpl_iconv (iconv_t cd,\n           ICONV_CONST char **inbuf, size_t *inbytesleft,\n           char **outbuf, size_t *outbytesleft)\n#undef iconv\n{\n#if REPLACE_ICONV_UTF\n  switch ((uintptr_t) cd)\n    {\n      {\n        int (*xxx_wctomb) (unsigned char *, ucs4_t, size_t);\n\n        case (uintptr_t) _ICONV_UTF8_UTF16BE:\n          xxx_wctomb = utf16be_wctomb;\n          goto loop_from_utf8;\n        case (uintptr_t) _ICONV_UTF8_UTF16LE:\n          xxx_wctomb = utf16le_wctomb;\n          goto loop_from_utf8;\n        case (uintptr_t) _ICONV_UTF8_UTF32BE:\n          xxx_wctomb = utf32be_wctomb;\n          goto loop_from_utf8;\n        case (uintptr_t) _ICONV_UTF8_UTF32LE:\n          xxx_wctomb = utf32le_wctomb;\n          goto loop_from_utf8;\n\n       loop_from_utf8:\n        if (inbuf == NULL || *inbuf == NULL)\n          return 0;\n        {\n          ICONV_CONST char *inptr = *inbuf;\n          size_t inleft = *inbytesleft;\n          char *outptr = *outbuf;\n          size_t outleft = *outbytesleft;\n          size_t res = 0;\n          while (inleft > 0)\n            {\n              ucs4_t uc;\n              int m = u8_mbtoucr (&uc, (const uint8_t *) inptr, inleft);\n              if (m <= 0)\n                {\n                  if (m == -1)\n                    {\n                      errno = EILSEQ;\n                      res = (size_t)(-1);\n                      break;\n                    }\n                  if (m == -2)\n                    {\n                      errno = EINVAL;\n                      res = (size_t)(-1);\n                      break;\n                    }\n                  abort ();\n                }\n              else\n                {\n                  int n = xxx_wctomb ((uint8_t *) outptr, uc, outleft);\n                  if (n < 0)\n                    {\n                      if (n == RET_ILUNI)\n                        {\n                          errno = EILSEQ;\n                          res = (size_t)(-1);\n                          break;\n                        }\n                      if (n == RET_TOOSMALL)\n                        {\n                          errno = E2BIG;\n                          res = (size_t)(-1);\n                          break;\n                        }\n                      abort ();\n                    }\n                  else\n                    {\n                      inptr += m;\n                      inleft -= m;\n                      outptr += n;\n                      outleft -= n;\n                    }\n                }\n            }\n          *inbuf = inptr;\n          *inbytesleft = inleft;\n          *outbuf = outptr;\n          *outbytesleft = outleft;\n          return res;\n        }\n      }\n\n      {\n        int (*xxx_mbtowc) (ucs4_t *, const unsigned char *, size_t);\n\n        case (uintptr_t) _ICONV_UTF16BE_UTF8:\n          xxx_mbtowc = utf16be_mbtowc;\n          goto loop_to_utf8;\n        case (uintptr_t) _ICONV_UTF16LE_UTF8:\n          xxx_mbtowc = utf16le_mbtowc;\n          goto loop_to_utf8;\n        case (uintptr_t) _ICONV_UTF32BE_UTF8:\n          xxx_mbtowc = utf32be_mbtowc;\n          goto loop_to_utf8;\n        case (uintptr_t) _ICONV_UTF32LE_UTF8:\n          xxx_mbtowc = utf32le_mbtowc;\n          goto loop_to_utf8;\n\n       loop_to_utf8:\n        if (inbuf == NULL || *inbuf == NULL)\n          return 0;\n        {\n          ICONV_CONST char *inptr = *inbuf;\n          size_t inleft = *inbytesleft;\n          char *outptr = *outbuf;\n          size_t outleft = *outbytesleft;\n          size_t res = 0;\n          while (inleft > 0)\n            {\n              ucs4_t uc;\n              int m = xxx_mbtowc (&uc, (const uint8_t *) inptr, inleft);\n              if (m <= 0)\n                {\n                  if (m == RET_ILSEQ)\n                    {\n                      errno = EILSEQ;\n                      res = (size_t)(-1);\n                      break;\n                    }\n                  if (m == RET_TOOFEW)\n                    {\n                      errno = EINVAL;\n                      res = (size_t)(-1);\n                      break;\n                    }\n                  abort ();\n                }\n              else\n                {\n                  int n = u8_uctomb ((uint8_t *) outptr, uc, outleft);\n                  if (n < 0)\n                    {\n                      if (n == -1)\n                        {\n                          errno = EILSEQ;\n                          res = (size_t)(-1);\n                          break;\n                        }\n                      if (n == -2)\n                        {\n                          errno = E2BIG;\n                          res = (size_t)(-1);\n                          break;\n                        }\n                      abort ();\n                    }\n                  else\n                    {\n                      inptr += m;\n                      inleft -= m;\n                      outptr += n;\n                      outleft -= n;\n                    }\n                }\n            }\n          *inbuf = inptr;\n          *inbytesleft = inleft;\n          *outbuf = outptr;\n          *outbytesleft = outleft;\n          return res;\n        }\n      }\n    }\n#endif\n  return iconv (cd, inbuf, inbytesleft, outbuf, outbytesleft);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}