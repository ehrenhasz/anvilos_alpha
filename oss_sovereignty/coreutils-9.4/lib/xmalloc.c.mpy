{
  "module_name": "xmalloc.c",
  "hash_id": "20013533ed97f45d526e27d460729f13814a846a6b4fe1f568f6686cf7b6e934",
  "original_prompt": "Ingested from coreutils-9.4/lib/xmalloc.c",
  "human_readable_source": " \n\nvoid *\nxmalloc (size_t s)\n{\n  return nonnull (malloc (s));\n}\n\nvoid *\nximalloc (idx_t s)\n{\n  return nonnull (imalloc (s));\n}\n\nchar *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}\n\n \n\nvoid *\nxrealloc (void *p, size_t s)\n{\n  void *r = realloc (p, s);\n  if (!r && (!p || s))\n    xalloc_die ();\n  return r;\n}\n\nvoid *\nxirealloc (void *p, idx_t s)\n{\n  return nonnull (irealloc (p, s));\n}\n\n \n\nvoid *\nxreallocarray (void *p, size_t n, size_t s)\n{\n  void *r = reallocarray (p, n, s);\n  if (!r && (!p || (n && s)))\n    xalloc_die ();\n  return r;\n}\n\nvoid *\nxireallocarray (void *p, idx_t n, idx_t s)\n{\n  return nonnull (ireallocarray (p, n, s));\n}\n\n \n\nvoid *\nxnmalloc (size_t n, size_t s)\n{\n  return xreallocarray (NULL, n, s);\n}\n\nvoid *\nxinmalloc (idx_t n, idx_t s)\n{\n  return xireallocarray (NULL, n, s);\n}\n\n \n\nvoid *\nx2realloc (void *p, size_t *ps)\n{\n  return x2nrealloc (p, ps, 1);\n}\n\n \n\nvoid *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n           \n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n       \n      if (ckd_add (&n, n, (n >> 1) + 1))\n        xalloc_die ();\n    }\n\n  p = xreallocarray (p, n, s);\n  *pn = n;\n  return p;\n}\n\n \n\nvoid *\nxpalloc (void *pa, idx_t *pn, idx_t n_incr_min, ptrdiff_t n_max, idx_t s)\n{\n  idx_t n0 = *pn;\n\n   \n  enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n   \n\n  idx_t n;\n  if (ckd_add (&n, n0, n0 >> 1))\n    n = IDX_MAX;\n  if (0 <= n_max && n_max < n)\n    n = n_max;\n\n   \n#if IDX_MAX <= SIZE_MAX\n  idx_t nbytes;\n#else\n  size_t nbytes;\n#endif\n  idx_t adjusted_nbytes\n    = (ckd_mul (&nbytes, n, s)\n       ? MIN (IDX_MAX, SIZE_MAX)\n       : nbytes < DEFAULT_MXFAST ? DEFAULT_MXFAST : 0);\n  if (adjusted_nbytes)\n    {\n      n = adjusted_nbytes / s;\n      nbytes = adjusted_nbytes - adjusted_nbytes % s;\n    }\n\n  if (! pa)\n    *pn = 0;\n  if (n - n0 < n_incr_min\n      && (ckd_add (&n, n0, n_incr_min)\n          || (0 <= n_max && n_max < n)\n          || ckd_mul (&nbytes, n, s)))\n    xalloc_die ();\n  pa = xrealloc (pa, nbytes);\n  *pn = n;\n  return pa;\n}\n\n \n\nvoid *\nxzalloc (size_t s)\n{\n  return xcalloc (s, 1);\n}\n\nvoid *\nxizalloc (idx_t s)\n{\n  return xicalloc (s, 1);\n}\n\n \n\nvoid *\nxcalloc (size_t n, size_t s)\n{\n  return nonnull (calloc (n, s));\n}\n\nvoid *\nxicalloc (idx_t n, idx_t s)\n{\n  return nonnull (icalloc (n, s));\n}\n\n \n\nvoid *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}\n\nvoid *\nximemdup (void const *p, idx_t s)\n{\n  return memcpy (ximalloc (s), p, s);\n}\n\n \n\nchar *\nximemdup0 (void const *p, idx_t s)\n{\n  char *result = ximalloc (s + 1);\n  result[s] = 0;\n  return memcpy (result, p, s);\n}\n\n \n\nchar *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}