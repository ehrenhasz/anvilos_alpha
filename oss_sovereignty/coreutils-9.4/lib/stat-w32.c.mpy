{
  "module_name": "stat-w32.c",
  "hash_id": "467346d42d95586aa488f7d53a8a1949e9b5f4f04046652b5a2f53ee9a20050c",
  "original_prompt": "Ingested from coreutils-9.4/lib/stat-w32.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#if defined _WIN32 && ! defined __CYGWIN__\n\n \n#if HAVE_SDKDDKVER_H\n# include <sdkddkver.h>\n# if _WIN32_WINNT >= _WIN32_WINNT_VISTA\n#  define WIN32_ASSUME_VISTA 1\n# else\n#  define WIN32_ASSUME_VISTA 0\n# endif\n# if !defined _WIN32_WINNT || (_WIN32_WINNT < _WIN32_WINNT_WIN8)\n#  undef _WIN32_WINNT\n#  define _WIN32_WINNT _WIN32_WINNT_WIN8\n# endif\n#else\n# define WIN32_ASSUME_VISTA (_WIN32_WINNT >= _WIN32_WINNT_VISTA)\n#endif\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n#include <windows.h>\n\n \n#include \"stat-w32.h\"\n\n#include \"pathmax.h\"\n\n \n#undef LoadLibrary\n#define LoadLibrary LoadLibraryA\n#undef GetFinalPathNameByHandle\n#define GetFinalPathNameByHandle GetFinalPathNameByHandleA\n\n \n#ifndef VOLUME_NAME_NONE\n# define VOLUME_NAME_NONE 4\n#endif\n\n#if !WIN32_ASSUME_VISTA\n\n \n# define GetProcAddress \\\n   (void *) GetProcAddress\n\n# if _GL_WINDOWS_STAT_INODES == 2\n \ntypedef DWORD (WINAPI * GetFileInformationByHandleExFuncType) (HANDLE hFile,\n                                                               FILE_INFO_BY_HANDLE_CLASS fiClass,\n                                                               LPVOID lpBuffer,\n                                                               DWORD dwBufferSize);\nstatic GetFileInformationByHandleExFuncType GetFileInformationByHandleExFunc = NULL;\n# endif\n \ntypedef DWORD (WINAPI * GetFinalPathNameByHandleFuncType) (HANDLE hFile,\n                                                           LPSTR lpFilePath,\n                                                           DWORD lenFilePath,\n                                                           DWORD dwFlags);\nstatic GetFinalPathNameByHandleFuncType GetFinalPathNameByHandleFunc = NULL;\nstatic BOOL initialized = FALSE;\n\nstatic void\ninitialize (void)\n{\n  HMODULE kernel32 = LoadLibrary (\"kernel32.dll\");\n  if (kernel32 != NULL)\n    {\n# if _GL_WINDOWS_STAT_INODES == 2\n      GetFileInformationByHandleExFunc =\n        (GetFileInformationByHandleExFuncType) GetProcAddress (kernel32, \"GetFileInformationByHandleEx\");\n# endif\n      GetFinalPathNameByHandleFunc =\n        (GetFinalPathNameByHandleFuncType) GetProcAddress (kernel32, \"GetFinalPathNameByHandleA\");\n    }\n  initialized = TRUE;\n}\n\n#else\n\n# define GetFileInformationByHandleExFunc GetFileInformationByHandleEx\n# define GetFinalPathNameByHandleFunc GetFinalPathNameByHandle\n\n#endif\n\n \n#if _GL_WINDOWS_STAT_TIMESPEC\nstruct timespec\n_gl_convert_FILETIME_to_timespec (const FILETIME *ft)\n{\n  struct timespec result;\n   \n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      result.tv_sec = since_1970 / (unsigned long long) 10000000;\n      result.tv_nsec = (unsigned long) (since_1970 % (unsigned long long) 10000000) * 100;\n    }\n  return result;\n}\n#else\ntime_t\n_gl_convert_FILETIME_to_POSIX (const FILETIME *ft)\n{\n   \n      unsigned long long since_1970 =\n        since_1601 - (unsigned long long) 134774 * (unsigned long long) 86400 * (unsigned long long) 10000000;\n      return since_1970 / (unsigned long long) 10000000;\n    }\n}\n#endif\n\n \nint\n_gl_fstat_by_handle (HANDLE h, const char *path, struct stat *buf)\n{\n   \n      BY_HANDLE_FILE_INFORMATION info;\n      if (! GetFileInformationByHandle (h, &info))\n        goto failed;\n\n       \n      if (sizeof (buf->st_size) <= 4 && info.nFileSizeHigh > 0)\n        {\n          errno = EOVERFLOW;\n          return -1;\n        }\n\n#if _GL_WINDOWS_STAT_INODES\n       \n       \n# if _GL_WINDOWS_STAT_INODES == 2\n      if (GetFileInformationByHandleExFunc != NULL)\n        {\n          FILE_ID_INFO id;\n          if (GetFileInformationByHandleExFunc (h, FileIdInfo, &id, sizeof (id)))\n            {\n              buf->st_dev = id.VolumeSerialNumber;\n              static_assert (sizeof (ino_t) == sizeof (id.FileId));\n              memcpy (&buf->st_ino, &id.FileId, sizeof (ino_t));\n              goto ino_done;\n            }\n          else\n            {\n              switch (GetLastError ())\n                {\n                case ERROR_INVALID_PARAMETER:  \n                case ERROR_INVALID_LEVEL:  \n                  goto fallback;\n                default:\n                  goto failed;\n                }\n            }\n        }\n     fallback: ;\n       \n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino._gl_ino[0] = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n      buf->st_ino._gl_ino[1] = 0;\n     ino_done: ;\n# else  \n      buf->st_dev = info.dwVolumeSerialNumber;\n      buf->st_ino = ((ULONGLONG) info.nFileIndexHigh << 32) | (ULONGLONG) info.nFileIndexLow;\n# endif\n#else\n       \n      buf->st_dev = 0;\n      buf->st_ino = 0;\n#endif\n\n       \n      unsigned int mode =\n         \n        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)\n        | S_IREAD_UGO\n        | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);\n      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))\n        {\n           \n          if (info.nFileSizeHigh > 0 || info.nFileSizeLow > 0)\n            {\n              char fpath[PATH_MAX];\n              if (path != NULL\n                  || (GetFinalPathNameByHandleFunc != NULL\n                      && GetFinalPathNameByHandleFunc (h, fpath, sizeof (fpath), VOLUME_NAME_NONE)\n                         < sizeof (fpath)\n                      && (path = fpath, 1)))\n                {\n                  const char *last_dot = NULL;\n                  const char *p;\n                  for (p = path; *p != '\\0'; p++)\n                    if (*p == '.')\n                      last_dot = p;\n                  if (last_dot != NULL)\n                    {\n                      const char *suffix = last_dot + 1;\n                      if (_stricmp (suffix, \"exe\") == 0\n                          || _stricmp (suffix, \"bat\") == 0\n                          || _stricmp (suffix, \"cmd\") == 0\n                          || _stricmp (suffix, \"com\") == 0)\n                        mode |= S_IEXEC_UGO;\n                    }\n                }\n              else\n                 \n                mode |= S_IEXEC_UGO;\n            }\n        }\n      buf->st_mode = mode;\n\n       \n      buf->st_nlink = (info.nNumberOfLinks > SHRT_MAX ? SHRT_MAX : info.nNumberOfLinks);\n\n       \n      buf->st_uid = 0;\n      buf->st_gid = 0;\n\n       \n      buf->st_rdev = 0;\n\n       \n      if (sizeof (buf->st_size) <= 4)\n         \n        buf->st_size = info.nFileSizeLow;\n      else\n        buf->st_size = ((long long) info.nFileSizeHigh << 32) | (long long) info.nFileSizeLow;\n\n       \n#if _GL_WINDOWS_STAT_TIMESPEC\n      buf->st_atim = _gl_convert_FILETIME_to_timespec (&info.ftLastAccessTime);\n      buf->st_mtim = _gl_convert_FILETIME_to_timespec (&info.ftLastWriteTime);\n      buf->st_ctim = _gl_convert_FILETIME_to_timespec (&info.ftCreationTime);\n#else\n      buf->st_atime = _gl_convert_FILETIME_to_POSIX (&info.ftLastAccessTime);\n      buf->st_mtime = _gl_convert_FILETIME_to_POSIX (&info.ftLastWriteTime);\n      buf->st_ctime = _gl_convert_FILETIME_to_POSIX (&info.ftCreationTime);\n#endif\n\n      return 0;\n    }\n  else if (type == FILE_TYPE_CHAR || type == FILE_TYPE_PIPE)\n    {\n      buf->st_dev = 0;\n#if _GL_WINDOWS_STAT_INODES == 2\n      buf->st_ino._gl_ino[0] = buf->st_ino._gl_ino[1] = 0;\n#else\n      buf->st_ino = 0;\n#endif\n      buf->st_mode = (type == FILE_TYPE_PIPE ? _S_IFIFO : _S_IFCHR);\n      buf->st_nlink = 1;\n      buf->st_uid = 0;\n      buf->st_gid = 0;\n      buf->st_rdev = 0;\n      if (type == FILE_TYPE_PIPE)\n        {\n           \ntypedef int dummy;\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}