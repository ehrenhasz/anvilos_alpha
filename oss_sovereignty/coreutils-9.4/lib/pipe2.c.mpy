{
  "module_name": "pipe2.c",
  "hash_id": "f4677cfd1e1b4927fb084f8a6a72e73a00cdcb6642d3ad54e2ac44d1b6cc149b",
  "original_prompt": "Ingested from coreutils-9.4/lib/pipe2.c",
  "human_readable_source": " \n#include <unistd.h>\n\n#include <errno.h>\n#include <fcntl.h>\n\n#include \"binary-io.h\"\n\n#if GNULIB_defined_O_NONBLOCK\n# include \"nonblocking.h\"\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n\n# include <io.h>\n\n#endif\n\nint\npipe2 (int fd[2], int flags)\n{\n   \n  {\n     \n    static int have_pipe2_really;  \n    if (have_pipe2_really >= 0)\n      {\n        int result = pipe2 (fd, flags);\n        if (!(result < 0 && errno == ENOSYS))\n          {\n            have_pipe2_really = 1;\n            return result;\n          }\n        have_pipe2_really = -1;\n      }\n  }\n#endif\n\n   \n  if ((flags & ~(O_CLOEXEC | O_NONBLOCK | O_BINARY | O_TEXT)) != 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n\n  if (_pipe (fd, 4096, flags & ~O_NONBLOCK) < 0)\n    {\n      fd[0] = tmp[0];\n      fd[1] = tmp[1];\n      return -1;\n    }\n\n   \n# if GNULIB_defined_O_NONBLOCK\n  if (flags & O_NONBLOCK)\n    {\n      if (set_nonblocking_flag (fd[0], true) != 0\n          || set_nonblocking_flag (fd[1], true) != 0)\n        goto fail;\n    }\n# else\n  {\n    static_assert (O_NONBLOCK == 0);\n  }\n# endif\n\n  return 0;\n\n#else\n \n\n  if (pipe (fd) < 0)\n    return -1;\n\n   \n\n   \n  if (flags & O_NONBLOCK)\n    {\n      int fcntl_flags;\n\n      if ((fcntl_flags = fcntl (fd[1], F_GETFL, 0)) < 0\n          || fcntl (fd[1], F_SETFL, fcntl_flags | O_NONBLOCK) == -1\n          || (fcntl_flags = fcntl (fd[0], F_GETFL, 0)) < 0\n          || fcntl (fd[0], F_SETFL, fcntl_flags | O_NONBLOCK) == -1)\n        goto fail;\n    }\n\n  if (flags & O_CLOEXEC)\n    {\n      int fcntl_flags;\n\n      if ((fcntl_flags = fcntl (fd[1], F_GETFD, 0)) < 0\n          || fcntl (fd[1], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1\n          || (fcntl_flags = fcntl (fd[0], F_GETFD, 0)) < 0\n          || fcntl (fd[0], F_SETFD, fcntl_flags | FD_CLOEXEC) == -1)\n        goto fail;\n    }\n\n# if O_BINARY\n  if (flags & O_BINARY)\n    {\n      set_binary_mode (fd[1], O_BINARY);\n      set_binary_mode (fd[0], O_BINARY);\n    }\n  else if (flags & O_TEXT)\n    {\n      set_binary_mode (fd[1], O_TEXT);\n      set_binary_mode (fd[0], O_TEXT);\n    }\n# endif\n\n  return 0;\n\n#endif\n\n#if GNULIB_defined_O_NONBLOCK || !(defined _WIN32 && ! defined __CYGWIN__)\n fail:\n  {\n    int saved_errno = errno;\n    close (fd[0]);\n    close (fd[1]);\n    fd[0] = tmp[0];\n    fd[1] = tmp[1];\n    errno = saved_errno;\n    return -1;\n  }\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}