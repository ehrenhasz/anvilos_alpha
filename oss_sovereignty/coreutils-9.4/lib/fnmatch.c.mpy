{
  "module_name": "fnmatch.c",
  "hash_id": "cd4969330b65b8704ab44d54f42c3417c6d71b43ba7c8524edafa74c05579505",
  "original_prompt": "Ingested from coreutils-9.4/lib/fnmatch.c",
  "human_readable_source": " \n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE    1\n#endif\n\n#include <fnmatch.h>\n\n#include <assert.h>\n#include <errno.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdckdint.h>\n#include <stdlib.h>\n#if defined _LIBC || HAVE_ALLOCA\n# include <alloca.h>\n#endif\n#include <stddef.h>\n#include <uchar.h>\n#if defined _LIBC || !_GL_SMALL_WCHAR_T\n \n# include <wchar.h>\n# include <wctype.h>\n# define WCHAR_T wchar_t\n# define WINT_T wint_t\n# define BTOWC btowc\n# define MBSRTOWCS mbsrtowcs\n# define WCSLEN wcslen\n# define WCSCAT wcscat\n# define WMEMPCPY wmempcpy\n# define WMEMCHR wmemchr\n# define TOWLOWER towlower\n# define WCTYPE_T wctype_t\n# define WCTYPE wctype\n# define ISWCTYPE iswctype\n#else\n \n# include \"unistr.h\"\n# define WCHAR_T char32_t\n# define WINT_T char32_t\n# define BTOWC btoc32\n# define MBSRTOWCS mbsrtoc32s\n# define WCSLEN u32_strlen\n# define WCSCAT u32_strcat\n# define WMEMPCPY u32_pcpy\n# define WMEMCHR(S, C, N) u32_chr (S, N, C)\n# define TOWLOWER c32tolower\n# define WCTYPE_T c32_type_test_t\n# define WCTYPE c32_get_type_test\n# define ISWCTYPE c32_apply_type_test\n#endif\n\n \n#ifdef _LIBC\n# include \"../locale/localeinfo.h\"\n# include \"../locale/coll-lookup.h\"\n# include <shlib-compat.h>\n\n# define CONCAT(a,b) __CONCAT(a,b)\n# define btowc __btowc\n# define iswctype __iswctype\n# define mbsrtowcs __mbsrtowcs\n# define mempcpy __mempcpy\n# define strnlen __strnlen\n# define towlower __towlower\n# define wcscat __wcscat\n# define wcslen __wcslen\n# define wctype __wctype\n# define wmemchr __wmemchr\n# define wmempcpy __wmempcpy\n# define fnmatch __fnmatch\nextern int fnmatch (const char *pattern, const char *string, int flags);\n#endif\n\n#ifdef _LIBC\n# if __glibc_has_attribute (__fallthrough__)\n#  define FALLTHROUGH __attribute__ ((__fallthrough__))\n# else\n#  define FALLTHROUGH ((void) 0)\n# endif\n#else\n# include \"attribute.h\"\n#endif\n\n#include <flexmember.h>\n\n#ifdef _LIBC\ntypedef ptrdiff_t idx_t;\n#else\n# include \"idx.h\"\n#endif\n\n \n#define NO_LEADING_PERIOD(flags) \\\n  ((flags & (FNM_FILE_NAME | FNM_PERIOD)) == (FNM_FILE_NAME | FNM_PERIOD))\n\n#ifndef _LIBC\n# if HAVE_ALLOCA\n \n#  define __libc_use_alloca(n) ((n) < 4032)\n# else\n \n#  define __libc_use_alloca(n) false\n#  undef alloca\n#  define alloca(n) malloc (n)\n# endif\n# define alloca_account(size, avar) ((avar) += (size), alloca (size))\n#endif\n\n \n#ifdef CHARCLASS_NAME_MAX\n# define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX\n#else\n \n# define CHAR_CLASS_MAX_LENGTH 256\n#endif\n\n#define IS_CHAR_CLASS(string) WCTYPE (string)\n\n \n\n \nstatic int posixly_correct;\n\n \n#define FOLD(c) ((flags & FNM_CASEFOLD) ? tolower (c) : (c))\n#define CHAR    char\n#define UCHAR   unsigned char\n#define INT     int\n#define FCT     internal_fnmatch\n#define EXT     ext_match\n#define END     end_pattern\n#define STRUCT  fnmatch_struct\n#define L_(CS)  CS\n#define UCHAR_TO_WCHAR(C) BTOWC (C)\n#define STRLEN(S) strlen (S)\n#define STRCAT(D, S) strcat (D, S)\n#define MEMPCPY(D, S, N) mempcpy (D, S, N)\n#define MEMCHR(S, C, N) memchr (S, C, N)\n#define WIDE_CHAR_VERSION 0\n#ifdef _LIBC\n# include <locale/weight.h>\n# define FINDIDX findidx\n#endif\n#include \"fnmatch_loop.c\"\n\n\n#define FOLD(c) ((flags & FNM_CASEFOLD) ? TOWLOWER (c) : (c))\n#define CHAR    WCHAR_T\n#define UCHAR   WINT_T\n#define INT     WINT_T\n#define FCT     internal_fnwmatch\n#define EXT     ext_wmatch\n#define END     end_wpattern\n#define L_(CS)  L##CS\n#define UCHAR_TO_WCHAR(C) (C)\n#define STRLEN(S) WCSLEN (S)\n#define STRCAT(D, S) WCSCAT (D, S)\n#define MEMPCPY(D, S, N) WMEMPCPY (D, S, N)\n#define MEMCHR(S, C, N) WMEMCHR (S, C, N)\n#define WIDE_CHAR_VERSION 1\n#ifdef _LIBC\n \n# define findidx findidxwc\n# include <locale/weightwc.h>\n# undef findidx\n# define FINDIDX findidxwc\n#endif\n\n#undef IS_CHAR_CLASS\n \nstatic WCTYPE_T\nis_char_class (const WCHAR_T *wcs)\n{\n  char s[CHAR_CLASS_MAX_LENGTH + 1];\n  char *cp = s;\n\n  do\n    {\n       \n#ifdef _LIBC\n      if (*wcs < 0x20 || *wcs > 0x7e\n          || *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)\n        return (WCTYPE_T) 0;\n#else\n      switch (*wcs)\n        {\n        case L' ': case L'!': case L'\"': case L'#': case L'%':\n        case L'&': case L'\\'': case L'(': case L')': case L'*':\n        case L'+': case L',': case L'-': case L'.': case L'/':\n        case L'0': case L'1': case L'2': case L'3': case L'4':\n        case L'5': case L'6': case L'7': case L'8': case L'9':\n        case L':': case L';': case L'<': case L'=': case L'>':\n        case L'?':\n        case L'A': case L'B': case L'C': case L'D': case L'E':\n        case L'F': case L'G': case L'H': case L'I': case L'J':\n        case L'K': case L'L': case L'M': case L'N': case L'O':\n        case L'P': case L'Q': case L'R': case L'S': case L'T':\n        case L'U': case L'V': case L'W': case L'X': case L'Y':\n        case L'Z':\n        case L'[': case L'\\\\': case L']': case L'^': case L'_':\n        case L'a': case L'b': case L'c': case L'd': case L'e':\n        case L'f': case L'g': case L'h': case L'i': case L'j':\n        case L'k': case L'l': case L'm': case L'n': case L'o':\n        case L'p': case L'q': case L'r': case L's': case L't':\n        case L'u': case L'v': case L'w': case L'x': case L'y':\n        case L'z': case L'{': case L'|': case L'}': case L'~':\n          break;\n        default:\n          return (WCTYPE_T) 0;\n        }\n#endif\n\n       \n      if (cp == s + CHAR_CLASS_MAX_LENGTH)\n        return (WCTYPE_T) 0;\n\n      *cp++ = (char) *wcs++;\n    }\n  while (*wcs != L'\\0');\n\n  *cp = '\\0';\n\n  return WCTYPE (s);\n}\n#define IS_CHAR_CLASS(string) is_char_class (string)\n\n#include \"fnmatch_loop.c\"\n\n\nint\nfnmatch (const char *pattern, const char *string, int flags)\n{\n  if (__glibc_unlikely (MB_CUR_MAX != 1))\n    {\n      mbstate_t ps;\n      size_t n;\n      const char *p;\n      WCHAR_T *wpattern_malloc = NULL;\n      WCHAR_T *wpattern;\n      WCHAR_T *wstring_malloc = NULL;\n      WCHAR_T *wstring;\n      size_t alloca_used = 0;\n\n       \n      memset (&ps, '\\0', sizeof (ps));\n      p = pattern;\n      n = strnlen (pattern, 1024);\n      if (__glibc_likely (n < 1024))\n        {\n          wpattern = (WCHAR_T *) alloca_account ((n + 1) * sizeof (WCHAR_T),\n                                                 alloca_used);\n          n = MBSRTOWCS (wpattern, &p, n + 1, &ps);\n          if (__glibc_unlikely (n == (size_t) -1))\n             \n            return -1;\n          if (p)\n            {\n              memset (&ps, '\\0', sizeof (ps));\n              goto prepare_wpattern;\n            }\n        }\n      else\n        {\n        prepare_wpattern:\n          n = MBSRTOWCS (NULL, &pattern, 0, &ps);\n          if (__glibc_unlikely (n == (size_t) -1))\n             \n            return -1;\n          if (__glibc_unlikely (n >= (size_t) -1 / sizeof (WCHAR_T)))\n            {\n              __set_errno (ENOMEM);\n              return -2;\n            }\n          wpattern_malloc = wpattern\n            = (WCHAR_T *) malloc ((n + 1) * sizeof (WCHAR_T));\n          assert (mbsinit (&ps));\n          if (wpattern == NULL)\n            return -2;\n          (void) MBSRTOWCS (wpattern, &pattern, n + 1, &ps);\n        }\n\n      assert (mbsinit (&ps));\n      n = strnlen (string, 1024);\n      p = string;\n      if (__glibc_likely (n < 1024))\n        {\n          wstring = (WCHAR_T *) alloca_account ((n + 1) * sizeof (WCHAR_T),\n                                                alloca_used);\n          n = MBSRTOWCS (wstring, &p, n + 1, &ps);\n          if (__glibc_unlikely (n == (size_t) -1))\n            {\n               \n            free_return:\n              free (wpattern_malloc);\n              return -1;\n            }\n          if (p)\n            {\n              memset (&ps, '\\0', sizeof (ps));\n              goto prepare_wstring;\n            }\n        }\n      else\n        {\n        prepare_wstring:\n          n = MBSRTOWCS (NULL, &string, 0, &ps);\n          if (__glibc_unlikely (n == (size_t) -1))\n             \n            goto free_return;\n          if (__glibc_unlikely (n >= (size_t) -1 / sizeof (WCHAR_T)))\n            {\n              free (wpattern_malloc);\n              __set_errno (ENOMEM);\n              return -2;\n            }\n\n          wstring_malloc = wstring\n            = (WCHAR_T *) malloc ((n + 1) * sizeof (WCHAR_T));\n          if (wstring == NULL)\n            {\n              free (wpattern_malloc);\n              return -2;\n            }\n          assert (mbsinit (&ps));\n          (void) MBSRTOWCS (wstring, &string, n + 1, &ps);\n        }\n\n      int res = internal_fnwmatch (wpattern, wstring, wstring + n,\n                                   flags & FNM_PERIOD, flags, NULL,\n                                   alloca_used);\n\n      free (wstring_malloc);\n      free (wpattern_malloc);\n\n      return res;\n    }\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags, NULL, 0);\n}\n\n#undef fnmatch\nversioned_symbol (libc, __fnmatch, fnmatch, GLIBC_2_2_3);\n#if SHLIB_COMPAT(libc, GLIBC_2_0, GLIBC_2_2_3)\nstrong_alias (__fnmatch, __fnmatch_old)\ncompat_symbol (libc, __fnmatch_old, fnmatch, GLIBC_2_0);\n#endif\nlibc_hidden_ver (__fnmatch, fnmatch)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}