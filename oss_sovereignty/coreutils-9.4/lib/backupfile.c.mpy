{
  "module_name": "backupfile.c",
  "hash_id": "cce4cfbf393fc5011cb48011885083dac1c7161ae18716127bbb8d32fdc06acf",
  "original_prompt": "Ingested from coreutils-9.4/lib/backupfile.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"backup-internal.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <stdckdint.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"attribute.h\"\n#include \"basename-lgpl.h\"\n#include \"ialloc.h\"\n#include \"opendirat.h\"\n#include \"renameatu.h\"\n\n#ifndef _D_EXACT_NAMLEN\n# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)\n#endif\n\n#if ! (HAVE_PATHCONF && defined _PC_NAME_MAX)\n# define pathconf(file, option) (errno = -1)\n# define fpathconf(fd, option) (errno = -1)\n#endif\n\n#ifndef _POSIX_NAME_MAX\n# define _POSIX_NAME_MAX 14\n#endif\n\n#if defined _XOPEN_NAME_MAX\n# define NAME_MAX_MINIMUM _XOPEN_NAME_MAX\n#else\n# define NAME_MAX_MINIMUM _POSIX_NAME_MAX\n#endif\n\n#ifndef HAVE_DOS_FILE_NAMES\n# define HAVE_DOS_FILE_NAMES 0\n#endif\n#ifndef HAVE_LONG_FILE_NAMES\n# define HAVE_LONG_FILE_NAMES 0\n#endif\n\n \n#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)\n\n \nchar const *simple_backup_suffix = NULL;\n\n \nvoid\nset_simple_backup_suffix (char const *s)\n{\n  if (!s)\n    s = getenv (\"SIMPLE_BACKUP_SUFFIX\");\n  simple_backup_suffix = s && *s && s == last_component (s) ? s : \"~\";\n}\n\n \n\nstatic bool\ncheck_extension (char *file, idx_t filelen, char e,\n                 int dir_fd, idx_t *base_max)\n{\n  char *base = last_component (file);\n  idx_t baselen = base_len (base);\n  idx_t baselen_max = HAVE_LONG_FILE_NAMES ? 255 : NAME_MAX_MINIMUM;\n\n  if (HAVE_DOS_FILE_NAMES || NAME_MAX_MINIMUM < baselen)\n    {\n       \n      if (*base_max == 0)\n        {\n          long name_max;\n          if (dir_fd < 0)\n            {\n               \n              char tmp[sizeof \".\"];\n              memcpy (tmp, base, sizeof \".\");\n              strcpy (base, \".\");\n              errno = 0;\n              name_max = pathconf (file, _PC_NAME_MAX);\n              name_max -= !errno;\n              memcpy (base, tmp, sizeof \".\");\n            }\n          else\n            {\n              errno = 0;\n              name_max = fpathconf (dir_fd, _PC_NAME_MAX);\n              name_max -= !errno;\n            }\n\n          *base_max = (0 <= name_max && name_max <= SIZE_MAX ? name_max\n                       : name_max < -1 ? NAME_MAX_MINIMUM : SIZE_MAX);\n        }\n\n      baselen_max = *base_max;\n    }\n\n  if (HAVE_DOS_FILE_NAMES && baselen_max <= 12)\n    {\n       \n      char *dot = strchr (base, '.');\n      if (!dot)\n        baselen_max = 8;\n      else\n        {\n          char const *second_dot = strchr (dot + 1, '.');\n          baselen_max = (second_dot\n                         ? second_dot - base\n                         : dot + 1 - base + 3);\n        }\n    }\n\n  if (baselen <= baselen_max)\n    return true;\n  else\n    {\n      baselen = file + filelen - base;\n      if (baselen_max <= baselen)\n        baselen = baselen_max - 1;\n      base[baselen] = e;\n      base[baselen + 1] = '\\0';\n      return false;\n    }\n}\n\n \n\nenum numbered_backup_result\n  {\n     \n    BACKUP_IS_SAME_LENGTH,\n\n     \n    BACKUP_IS_LONGER,\n\n     \n    BACKUP_IS_NEW,\n\n     \n    BACKUP_NOMEM\n  };\n\n \n\nstatic enum numbered_backup_result\nnumbered_backup (int dir_fd, char **buffer, idx_t buffer_size, idx_t filelen,\n                 idx_t base_offset, DIR **dirpp, int *pnew_fd)\n{\n  enum numbered_backup_result result = BACKUP_IS_NEW;\n  DIR *dirp = *dirpp;\n  char *buf = *buffer;\n  idx_t versionlenmax = 1;\n  idx_t baselen = filelen - base_offset;\n\n  if (dirp)\n    rewinddir (dirp);\n  else\n    {\n       \n      char tmp[sizeof \".\"];\n      char *base = buf + base_offset;\n      memcpy (tmp, base, sizeof \".\");\n      strcpy (base, \".\");\n      dirp = opendirat (dir_fd, buf, 0, pnew_fd);\n      if (!dirp && errno == ENOMEM)\n        result = BACKUP_NOMEM;\n      memcpy (base, tmp, sizeof \".\");\n      strcpy (base + baselen, \".~1~\");\n      if (!dirp)\n        return result;\n      *dirpp = dirp;\n    }\n\n  for (struct dirent *dp; (dp = readdir (dirp)) != NULL; )\n    {\n      if (_D_EXACT_NAMLEN (dp) < baselen + 4)\n        continue;\n\n      if (memcmp (buf + base_offset, dp->d_name, baselen + 2) != 0)\n        continue;\n\n      char const *p = dp->d_name + baselen + 2;\n\n       \n\n      if (! ('1' <= *p && *p <= '9'))\n        continue;\n      bool all_9s = (*p == '9');\n      idx_t versionlen;\n      for (versionlen = 1; ISDIGIT (p[versionlen]); versionlen++)\n        all_9s &= (p[versionlen] == '9');\n\n      if (! (p[versionlen] == '~' && !p[versionlen + 1]\n             && (versionlenmax < versionlen\n                 || (versionlenmax == versionlen\n                     && memcmp (buf + filelen + 2, p, versionlen) <= 0))))\n        continue;\n\n       \n\n      versionlenmax = all_9s + versionlen;\n      result = (all_9s ? BACKUP_IS_LONGER : BACKUP_IS_SAME_LENGTH);\n      idx_t new_buffer_size = filelen + 2 + versionlenmax + 2;\n      if (buffer_size < new_buffer_size)\n        {\n          idx_t grown;\n          if (! ckd_add (&grown, new_buffer_size, new_buffer_size >> 1))\n            new_buffer_size = grown;\n          char *new_buf = irealloc (buf, new_buffer_size);\n          if (!new_buf)\n            {\n              *buffer = buf;\n              return BACKUP_NOMEM;\n            }\n          buf = new_buf;\n          buffer_size = new_buffer_size;\n        }\n      char *q = buf + filelen;\n      *q++ = '.';\n      *q++ = '~';\n      *q = '0';\n      q += all_9s;\n      memcpy (q, p, versionlen + 2);\n\n       \n\n      q += versionlen;\n      while (*--q == '9')\n        *q = '0';\n      ++*q;\n    }\n\n  *buffer = buf;\n  return result;\n}\n\n \n\nchar *\nbackupfile_internal (int dir_fd, char const *file,\n                     enum backup_type backup_type, bool rename)\n{\n  idx_t base_offset = last_component (file) - file;\n  idx_t filelen = base_offset + base_len (file + base_offset);\n\n  if (! simple_backup_suffix)\n    set_simple_backup_suffix (NULL);\n\n   \n  idx_t simple_backup_suffix_size = strlen (simple_backup_suffix) + 1;\n  idx_t backup_suffix_size_guess = simple_backup_suffix_size;\n  enum { GUESS = sizeof \".~12345~\" };\n  if (backup_suffix_size_guess < GUESS)\n    backup_suffix_size_guess = GUESS;\n\n  idx_t ssize = filelen + backup_suffix_size_guess + 1;\n  char *s = imalloc (ssize);\n  if (!s)\n    return s;\n\n  DIR *dirp = NULL;\n  int sdir = -1;\n  idx_t base_max = 0;\n  while (true)\n    {\n      bool extended = true;\n      memcpy (s, file, filelen);\n\n      if (backup_type == simple_backups)\n        memcpy (s + filelen, simple_backup_suffix, simple_backup_suffix_size);\n      else\n        switch (numbered_backup (dir_fd, &s, ssize, filelen, base_offset,\n                                 &dirp, &sdir))\n          {\n          case BACKUP_IS_SAME_LENGTH:\n            break;\n\n          case BACKUP_IS_NEW:\n            if (backup_type == numbered_existing_backups)\n              {\n                backup_type = simple_backups;\n                memcpy (s + filelen, simple_backup_suffix,\n                        simple_backup_suffix_size);\n              }\n            FALLTHROUGH;\n          case BACKUP_IS_LONGER:\n            extended = check_extension (s, filelen, '~', sdir, &base_max);\n            break;\n\n          case BACKUP_NOMEM:\n            if (dirp)\n              closedir (dirp);\n            free (s);\n            errno = ENOMEM;\n            return NULL;\n          }\n\n      if (! rename)\n        break;\n\n      dir_fd = sdir < 0 ? dir_fd : sdir;\n      idx_t offset = sdir < 0 ? 0 : base_offset;\n      unsigned flags = backup_type == simple_backups ? 0 : RENAME_NOREPLACE;\n      if (renameatu (dir_fd, file + offset, dir_fd, s + offset, flags) == 0)\n        break;\n      int e = errno;\n      if (! (e == EEXIST && extended))\n        {\n          if (dirp)\n            closedir (dirp);\n          free (s);\n          errno = e;\n          return NULL;\n        }\n    }\n\n  if (dirp)\n    closedir (dirp);\n  return s;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}