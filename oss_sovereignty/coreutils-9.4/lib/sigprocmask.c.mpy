{
  "module_name": "sigprocmask.c",
  "hash_id": "afc05df1a0191e777d391f0f7b5724dc48f3530ecc0f116e4c2dac9a5eea5dc8",
  "original_prompt": "Ingested from coreutils-9.4/lib/sigprocmask.c",
  "human_readable_source": " \n#include <signal.h>\n\n#include <errno.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER\n# include \"msvc-inval.h\"\n#endif\n\n \n\n \n#undef signal\n\n \n#ifndef SIGKILL\n# define SIGKILL (-1)\n#endif\n#ifndef SIGSTOP\n# define SIGSTOP (-1)\n#endif\n\n \n#if defined _WIN32 && ! defined __CYGWIN__\n# undef SIGABRT_COMPAT\n# define SIGABRT_COMPAT 6\n#endif\n#ifdef SIGABRT_COMPAT\n# define SIGABRT_COMPAT_MASK (1U << SIGABRT_COMPAT)\n#else\n# define SIGABRT_COMPAT_MASK 0\n#endif\n\ntypedef void (*handler_t) (int);\n\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER\nstatic handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }\n  CATCH_MSVC_INVAL\n    {\n      result = SIG_ERR;\n      errno = EINVAL;\n    }\n  DONE_MSVC_INVAL;\n\n  return result;\n}\n# define signal signal_nothrow\n#endif\n\n \n\n#if GNULIB_defined_SIGPIPE\nstatic handler_t SIGPIPE_handler = SIG_DFL;\n#endif\n\n#if GNULIB_defined_SIGPIPE\nstatic handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default:  \n      return signal (sig, handler);\n    }\n}\n# undef signal\n# define signal ext_signal\n#endif\n\nint\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}\n\nint\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}\n\nint\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}\n\nint\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}\n\n\nint\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}\n\n \nstatic volatile sigset_t blocked_set  ;\n\n \nstatic volatile sig_atomic_t pending_array[NSIG]  ;\n\n \nstatic void\nblocked_handler (int sig)\n{\n   \n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}\n\nint\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}\n\n \nstatic volatile handler_t old_handlers[NSIG];\n\nint\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                   \n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}\n\n \nhandler_t\nrpl_signal (int sig, handler_t handler)\n{\n   \n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n           \n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}\n\n#if GNULIB_defined_SIGPIPE\n \nint\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}