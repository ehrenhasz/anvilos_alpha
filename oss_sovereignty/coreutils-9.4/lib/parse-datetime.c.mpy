{
  "module_name": "parse-datetime.c",
  "hash_id": "26b4f41bf0179f3f244d360df0e0190ac09dab270f5c19c075993503fd0a2f76",
  "original_prompt": "Ingested from coreutils-9.4/lib/parse-datetime.c",
  "human_readable_source": " \n\n \n\n \n\n \n\n \n\n \n#define YYBISON 30802\n\n \n#define YYBISON_VERSION \"3.8.2\"\n\n \n#define YYSKELETON_NAME \"yacc.c\"\n\n \n#define YYPURE 1\n\n \n#define YYPUSH 0\n\n \n#define YYPULL 1\n\n\n\n\n \n#line 1 \"parse-datetime.y\"\n\n \n\n \n\n#include <config.h>\n\n#include \"parse-datetime.h\"\n\n#include \"idx.h\"\n#include \"intprops.h\"\n#include \"timespec.h\"\n#include \"strftime.h\"\n\n \n#define YYSTACK_USE_ALLOCA 0\n\n \n#define YYMAXDEPTH 20\n#define YYINITDEPTH YYMAXDEPTH\n\n#include <inttypes.h>\n#include <c-ctype.h>\n#include <stdarg.h>\n#include <stdckdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gettext.h\"\n\n#define _(str) gettext (str)\n\n \n \n#ifdef _STDLIB_H_\n# undef _STDLIB_H\n# define _STDLIB_H 1\n#endif\n\n \n#define SHR(a, b)       \\\n  (-1 >> 1 == -1        \\\n   ? (a) >> (b)         \\\n   : (a) / (1 << (b)) - ((a) % (1 << (b)) < 0))\n\n#define HOUR(x) (60 * 60 * (x))\n\n#define STREQ(a, b) (strcmp (a, b) == 0)\n\n \nstatic_assert (TYPE_IS_INTEGER (time_t));\nstatic_assert (!TYPE_SIGNED (time_t) || INTMAX_MIN <= TYPE_MINIMUM (time_t));\nstatic_assert (TYPE_MAXIMUM (time_t) <= INTMAX_MAX);\n\n \nstatic bool\ntime_overflow (intmax_t n)\n{\n  return ! ((TYPE_SIGNED (time_t) ? TYPE_MINIMUM (time_t) <= n : 0 <= n)\n            && n <= TYPE_MAXIMUM (time_t));\n}\n\n \nstatic unsigned char to_uchar (char ch) { return ch; }\n\nstatic void _GL_ATTRIBUTE_FORMAT ((__printf__, 1, 2))\ndbg_printf (char const *msg, ...)\n{\n  va_list args;\n   \n  fputs (\"date: \", stderr);\n\n  va_start (args, msg);\n  vfprintf (stderr, msg, args);\n  va_end (args);\n}\n\n\n \ntypedef struct\n{\n  bool negative;\n  intmax_t value;\n  idx_t digits;\n} textint;\n\n \ntypedef struct\n{\n  char const *name;\n  int type;\n  int value;\n} table;\n\n \nenum { MERam, MERpm, MER24 };\n\n \nenum { DBGBUFSIZE = 100 };\n\nenum { BILLION = 1000000000, LOG10_BILLION = 9 };\n\n \ntypedef struct\n{\n   \n  intmax_t year;\n  intmax_t month;\n  intmax_t day;\n  intmax_t hour;\n  intmax_t minutes;\n  intmax_t seconds;\n  int ns;\n} relative_time;\n\n#if HAVE_COMPOUND_LITERALS\n# define RELATIVE_TIME_0 ((relative_time) { 0, 0, 0, 0, 0, 0, 0 })\n#else\nstatic relative_time const RELATIVE_TIME_0;\n#endif\n\n \ntypedef struct\n{\n   \n  const char *input;\n\n   \n  intmax_t day_ordinal;\n\n   \n  int day_number;\n\n   \n  int local_isdst;\n\n   \n  int time_zone;\n\n   \n  int meridian;\n\n   \n  textint year;\n  intmax_t month;\n  intmax_t day;\n  intmax_t hour;\n  intmax_t minutes;\n  struct timespec seconds;  \n\n   \n  relative_time rel;\n\n   \n  bool timespec_seen;\n  bool rels_seen;\n  idx_t dates_seen;\n  idx_t days_seen;\n  idx_t J_zones_seen;\n  idx_t local_zones_seen;\n  idx_t dsts_seen;\n  idx_t times_seen;\n  idx_t zones_seen;\n  bool year_seen;\n\n#ifdef GNULIB_PARSE_DATETIME2\n   \n  bool parse_datetime_debug;\n#endif\n\n   \n  bool debug_dates_seen;\n  bool debug_days_seen;\n  bool debug_local_zones_seen;\n  bool debug_times_seen;\n  bool debug_zones_seen;\n  bool debug_year_seen;\n\n   \n  bool debug_ordinal_day_seen;\n\n   \n  table local_time_zone_table[3];\n} parser_control;\n\nstatic bool\ndebugging (parser_control const *pc)\n{\n#ifdef GNULIB_PARSE_DATETIME2\n  return pc->parse_datetime_debug;\n#else\n  return false;\n#endif\n}\n\nunion YYSTYPE;\nstatic int yylex (union YYSTYPE *, parser_control *);\nstatic int yyerror (parser_control const *, char const *);\nstatic bool time_zone_hhmm (parser_control *, textint, intmax_t);\n\n \nstatic void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    {\n      pc->year_seen = true;\n      pc->year = text_int;\n    }\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds = (struct timespec) {0};\n          pc->meridian = MER24;\n        }\n    }\n}\n\n \nstatic bool\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  if (factor < 0\n      ? (ckd_sub (&pc->rel.ns, pc->rel.ns, rel.ns)\n         | ckd_sub (&pc->rel.seconds, pc->rel.seconds, rel.seconds)\n         | ckd_sub (&pc->rel.minutes, pc->rel.minutes, rel.minutes)\n         | ckd_sub (&pc->rel.hour, pc->rel.hour, rel.hour)\n         | ckd_sub (&pc->rel.day, pc->rel.day, rel.day)\n         | ckd_sub (&pc->rel.month, pc->rel.month, rel.month)\n         | ckd_sub (&pc->rel.year, pc->rel.year, rel.year))\n      : (ckd_add (&pc->rel.ns, pc->rel.ns, rel.ns)\n         | ckd_add (&pc->rel.seconds, pc->rel.seconds, rel.seconds)\n         | ckd_add (&pc->rel.minutes, pc->rel.minutes, rel.minutes)\n         | ckd_add (&pc->rel.hour, pc->rel.hour, rel.hour)\n         | ckd_add (&pc->rel.day, pc->rel.day, rel.day)\n         | ckd_add (&pc->rel.month, pc->rel.month, rel.month)\n         | ckd_add (&pc->rel.year, pc->rel.year, rel.year)))\n    return false;\n  pc->rels_seen = true;\n  return true;\n}\n\n \nstatic void\nset_hhmmss (parser_control *pc, intmax_t hour, intmax_t minutes,\n            time_t sec, int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds = (struct timespec) { .tv_sec = sec, .tv_nsec = nsec };\n}\n\n \nstatic const char *\nstr_days (parser_control *pc, char *buffer, int n)\n{\n   \n  static char const ordinal_values[][11] = {\n     \"last\",\n     \"this\",\n     \"next/first\",\n     \"(SECOND)\",  \n     \"third\",\n     \"fourth\",\n     \"fifth\",\n     \"sixth\",\n     \"seventh\",\n     \"eight\",\n     \"ninth\",\n     \"tenth\",\n     \"eleventh\",\n     \"twelfth\"\n  };\n\n  static char const days_values[][4] = {\n     \"Sun\",\n     \"Mon\",\n     \"Tue\",\n     \"Wed\",\n     \"Thu\",\n     \"Fri\",\n     \"Sat\"\n  };\n\n  int len;\n\n   \n  if (pc->debug_ordinal_day_seen)\n    {\n       \n      len = (-1 <= pc->day_ordinal && pc->day_ordinal <= 12\n             ? snprintf (buffer, n, \"%s\", ordinal_values[pc->day_ordinal + 1])\n             : snprintf (buffer, n, \"%\"PRIdMAX, pc->day_ordinal));\n    }\n  else\n    {\n      buffer[0] = '\\0';\n      len = 0;\n    }\n\n   \n  if (0 <= pc->day_number && pc->day_number <= 6 && 0 <= len && len < n)\n    snprintf (buffer + len, n - len, &\" %s\"[len == 0],\n              days_values[pc->day_number]);\n  else\n    {\n       \n    }\n  return buffer;\n}\n\n \n\nenum { TIME_ZONE_BUFSIZE = INT_STRLEN_BOUND (intmax_t) + sizeof \":MM:SS\" } ;\n\nstatic char const *\ntime_zone_str (int time_zone, char time_zone_buf[TIME_ZONE_BUFSIZE])\n{\n  char *p = time_zone_buf;\n  char sign = time_zone < 0 ? '-' : '+';\n  int hour = abs (time_zone / (60 * 60));\n  p += sprintf (time_zone_buf, \"%c%02d\", sign, hour);\n  int offset_from_hour = abs (time_zone % (60 * 60));\n  if (offset_from_hour != 0)\n    {\n      int mm = offset_from_hour / 60;\n      int ss = offset_from_hour % 60;\n      *p++ = ':';\n      *p++ = '0' + mm / 10;\n      *p++ = '0' + mm % 10;\n      if (ss)\n        {\n          *p++ = ':';\n          *p++ = '0' + ss / 10;\n          *p++ = '0' + ss % 10;\n        }\n      *p = '\\0';\n    }\n  return time_zone_buf;\n}\n\n \nstatic void\ndebug_print_current_time (char const *item, parser_control *pc)\n{\n  bool space = false;\n\n  if (!debugging (pc))\n    return;\n\n   \n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->dates_seen && !pc->debug_dates_seen)\n    {\n       \n      fprintf (stderr, \"(Y-M-D) %04\"PRIdMAX\"-%02\"PRIdMAX\"-%02\"PRIdMAX,\n              pc->year.value, pc->month, pc->day);\n      pc->debug_dates_seen = true;\n      space = true;\n    }\n\n  if (pc->year_seen != pc->debug_year_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"year: %04\"PRIdMAX), pc->year.value);\n\n      pc->debug_year_seen = pc->year_seen;\n      space = true;\n    }\n\n  if (pc->times_seen && !pc->debug_times_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      fprintf (stderr, &\" %02\"PRIdMAX\":%02\"PRIdMAX\":%02\"PRIdMAX[!space],\n               pc->hour, pc->minutes, sec);\n      if (pc->seconds.tv_nsec != 0)\n        {\n          int nsec = pc->seconds.tv_nsec;\n          fprintf (stderr, \".%09d\", nsec);\n        }\n      if (pc->meridian == MERpm)\n        fputs (\"pm\", stderr);\n\n      pc->debug_times_seen = true;\n      space = true;\n    }\n\n  if (pc->days_seen && !pc->debug_days_seen)\n    {\n      if (space)\n        fputc (' ', stderr);\n      char tmp[DBGBUFSIZE];\n      fprintf (stderr, _(\"%s (day ordinal=%\"PRIdMAX\" number=%d)\"),\n               str_days (pc, tmp, sizeof tmp),\n               pc->day_ordinal, pc->day_number);\n      pc->debug_days_seen = true;\n      space = true;\n    }\n\n   \n  if (pc->local_zones_seen && !pc->debug_local_zones_seen)\n    {\n      fprintf (stderr, &\" isdst=%d%s\"[!space],\n               pc->local_isdst, pc->dsts_seen ? \" DST\" : \"\");\n      pc->debug_local_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->zones_seen && !pc->debug_zones_seen)\n    {\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      fprintf (stderr, &\" UTC%s\"[!space],\n               time_zone_str (pc->time_zone, time_zone_buf));\n      pc->debug_zones_seen = true;\n      space = true;\n    }\n\n  if (pc->timespec_seen)\n    {\n      intmax_t sec = pc->seconds.tv_sec;\n      if (space)\n        fputc (' ', stderr);\n      fprintf (stderr, _(\"number of seconds: %\"PRIdMAX), sec);\n    }\n\n  fputc ('\\n', stderr);\n}\n\n \n\nstatic bool\nprint_rel_part (bool space, intmax_t val, char const *name)\n{\n  if (val == 0)\n    return space;\n  fprintf (stderr, &\" %+\"PRIdMAX\" %s\"[!space], val, name);\n  return true;\n}\n\nstatic void\ndebug_print_relative_time (char const *item, parser_control const *pc)\n{\n  bool space = false;\n\n  if (!debugging (pc))\n    return;\n\n   \n  dbg_printf (_(\"parsed %s part: \"), item);\n\n  if (pc->rel.year == 0 && pc->rel.month == 0 && pc->rel.day == 0\n      && pc->rel.hour == 0 && pc->rel.minutes == 0 && pc->rel.seconds == 0\n      && pc->rel.ns == 0)\n    {\n       \n      fputs (_(\"today/this/now\\n\"), stderr);\n      return;\n    }\n\n  space = print_rel_part (space, pc->rel.year, \"year(s)\");\n  space = print_rel_part (space, pc->rel.month, \"month(s)\");\n  space = print_rel_part (space, pc->rel.day, \"day(s)\");\n  space = print_rel_part (space, pc->rel.hour, \"hour(s)\");\n  space = print_rel_part (space, pc->rel.minutes, \"minutes\");\n  space = print_rel_part (space, pc->rel.seconds, \"seconds\");\n  print_rel_part (space, pc->rel.ns, \"nanoseconds\");\n\n  fputc ('\\n', stderr);\n}\n\n\n\n\n#line 625 \"parse-datetime.c\"\n\n# ifndef YY_CAST\n#  ifdef __cplusplus\n#   define YY_CAST(Type, Val) static_cast<Type> (Val)\n#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)\n#  else\n#   define YY_CAST(Type, Val) ((Type) (Val))\n#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))\n#  endif\n# endif\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n#include \"parse-datetime-gen.h\"\n \nenum yysymbol_kind_t\n{\n  YYSYMBOL_YYEMPTY = -2,\n  YYSYMBOL_YYEOF = 0,                       \n  YYSYMBOL_YYerror = 1,                     \n  YYSYMBOL_YYUNDEF = 2,                     \n  YYSYMBOL_tAGO = 3,                        \n  YYSYMBOL_tDST = 4,                        \n  YYSYMBOL_tYEAR_UNIT = 5,                  \n  YYSYMBOL_tMONTH_UNIT = 6,                 \n  YYSYMBOL_tHOUR_UNIT = 7,                  \n  YYSYMBOL_tMINUTE_UNIT = 8,                \n  YYSYMBOL_tSEC_UNIT = 9,                   \n  YYSYMBOL_tDAY_UNIT = 10,                  \n  YYSYMBOL_tDAY_SHIFT = 11,                 \n  YYSYMBOL_tDAY = 12,                       \n  YYSYMBOL_tDAYZONE = 13,                   \n  YYSYMBOL_tLOCAL_ZONE = 14,                \n  YYSYMBOL_tMERIDIAN = 15,                  \n  YYSYMBOL_tMONTH = 16,                     \n  YYSYMBOL_tORDINAL = 17,                   \n  YYSYMBOL_tZONE = 18,                      \n  YYSYMBOL_tSNUMBER = 19,                   \n  YYSYMBOL_tUNUMBER = 20,                   \n  YYSYMBOL_tSDECIMAL_NUMBER = 21,           \n  YYSYMBOL_tUDECIMAL_NUMBER = 22,           \n  YYSYMBOL_23_ = 23,                        \n  YYSYMBOL_24_J_ = 24,                      \n  YYSYMBOL_25_T_ = 25,                      \n  YYSYMBOL_26_ = 26,                        \n  YYSYMBOL_27_ = 27,                        \n  YYSYMBOL_28_ = 28,                        \n  YYSYMBOL_YYACCEPT = 29,                   \n  YYSYMBOL_spec = 30,                       \n  YYSYMBOL_timespec = 31,                   \n  YYSYMBOL_items = 32,                      \n  YYSYMBOL_item = 33,                       \n  YYSYMBOL_datetime = 34,                   \n  YYSYMBOL_iso_8601_datetime = 35,          \n  YYSYMBOL_time = 36,                       \n  YYSYMBOL_iso_8601_time = 37,              \n  YYSYMBOL_o_zone_offset = 38,              \n  YYSYMBOL_zone_offset = 39,                \n  YYSYMBOL_local_zone = 40,                 \n  YYSYMBOL_zone = 41,                       \n  YYSYMBOL_day = 42,                        \n  YYSYMBOL_date = 43,                       \n  YYSYMBOL_iso_8601_date = 44,              \n  YYSYMBOL_rel = 45,                        \n  YYSYMBOL_relunit = 46,                    \n  YYSYMBOL_relunit_snumber = 47,            \n  YYSYMBOL_dayshift = 48,                   \n  YYSYMBOL_seconds = 49,                    \n  YYSYMBOL_signed_seconds = 50,             \n  YYSYMBOL_unsigned_seconds = 51,           \n  YYSYMBOL_number = 52,                     \n  YYSYMBOL_hybrid = 53,                     \n  YYSYMBOL_o_colon_minutes = 54             \n};\ntypedef enum yysymbol_kind_t yysymbol_kind_t;\n\n\n\n\n#ifdef short\n# undef short\n#endif\n\n \n\n#ifndef __PTRDIFF_MAX__\n# include <limits.h>  \n# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__\n#  include <stdint.h>  \n#  define YY_STDINT_H\n# endif\n#endif\n\n \n\n#ifdef __INT_LEAST8_MAX__\ntypedef __INT_LEAST8_TYPE__ yytype_int8;\n#elif defined YY_STDINT_H\ntypedef int_least8_t yytype_int8;\n#else\ntypedef signed char yytype_int8;\n#endif\n\n#ifdef __INT_LEAST16_MAX__\ntypedef __INT_LEAST16_TYPE__ yytype_int16;\n#elif defined YY_STDINT_H\ntypedef int_least16_t yytype_int16;\n#else\ntypedef short yytype_int16;\n#endif\n\n \n#  endif\n#  define YYPTRDIFF_T ptrdiff_t\n#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX\n# else\n#  define YYPTRDIFF_T long\n#  define YYPTRDIFF_MAXIMUM LONG_MAX\n# endif\n#endif\n\n#ifndef YYSIZE_T\n# ifdef __SIZE_TYPE__\n#  define YYSIZE_T __SIZE_TYPE__\n# elif defined size_t\n#  define YYSIZE_T size_t\n# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__\n#  include <stddef.h>  \n#  define YYSIZE_T size_t\n# else\n#  define YYSIZE_T unsigned\n# endif\n#endif\n\n#define YYSIZE_MAXIMUM                                  \\\n  YY_CAST (YYPTRDIFF_T,                                 \\\n           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \\\n            ? YYPTRDIFF_MAXIMUM                         \\\n            : YY_CAST (YYSIZE_T, -1)))\n\n#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))\n\n\n \ntypedef yytype_int8 yy_state_t;\n\n \ntypedef int yy_state_fast_t;\n\n#ifndef YY_\n# if defined YYENABLE_NLS && YYENABLE_NLS\n#  if ENABLE_NLS\n#   include <libintl.h>  \n#   define YY_(Msgid) dgettext (\"bison-runtime\", Msgid)\n#  endif\n# endif\n# ifndef YY_\n#  define YY_(Msgid) Msgid\n# endif\n#endif\n\n\n#ifndef YY_ATTRIBUTE_PURE\n# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)\n#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))\n# else\n#  define YY_ATTRIBUTE_PURE\n# endif\n#endif\n\n#ifndef YY_ATTRIBUTE_UNUSED\n# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)\n#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n# else\n#  define YY_ATTRIBUTE_UNUSED\n# endif\n#endif\n\n \n#if ! defined lint || defined __GNUC__\n# define YY_USE(E) ((void) (E))\n#else\n# define YY_USE(E)  \n#endif\n\n \n#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__\n# if __GNUC__ * 100 + __GNUC_MINOR__ < 407\n#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \\\n    _Pragma (\"GCC diagnostic push\")                                     \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")\n# else\n#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \\\n    _Pragma (\"GCC diagnostic push\")                                     \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuninitialized\\\"\")              \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wmaybe-uninitialized\\\"\")\n# endif\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \\\n    _Pragma (\"GCC diagnostic pop\")\n#else\n# define YY_INITIAL_VALUE(Value) Value\n#endif\n#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n# define YY_IGNORE_MAYBE_UNINITIALIZED_END\n#endif\n#ifndef YY_INITIAL_VALUE\n# define YY_INITIAL_VALUE(Value)  \n#endif\n\n#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__\n# define YY_IGNORE_USELESS_CAST_BEGIN                          \\\n    _Pragma (\"GCC diagnostic push\")                            \\\n    _Pragma (\"GCC diagnostic ignored \\\"-Wuseless-cast\\\"\")\n# define YY_IGNORE_USELESS_CAST_END            \\\n    _Pragma (\"GCC diagnostic pop\")\n#endif\n#ifndef YY_IGNORE_USELESS_CAST_BEGIN\n# define YY_IGNORE_USELESS_CAST_BEGIN\n# define YY_IGNORE_USELESS_CAST_END\n#endif\n\n\n#define YY_ASSERT(E) ((void) (0 && (E)))\n\n#if !defined yyoverflow\n\n \n\n# ifdef YYSTACK_USE_ALLOCA\n#  if YYSTACK_USE_ALLOCA\n#   ifdef __GNUC__\n#    define YYSTACK_ALLOC __builtin_alloca\n#   elif defined __BUILTIN_VA_ARG_INCR\n#    include <alloca.h>  \n#   elif defined _AIX\n#    define YYSTACK_ALLOC __alloca\n#   elif defined _MSC_VER\n#    include <malloc.h>  \n#    define alloca _alloca\n#   else\n#    define YYSTACK_ALLOC alloca\n#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS\n#     include <stdlib.h>  \n       \n#     ifndef EXIT_SUCCESS\n#      define EXIT_SUCCESS 0\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n\n# ifdef YYSTACK_ALLOC\n    \n#  define YYSTACK_FREE(Ptr) do {  ; } while (0)\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n     \n#   define YYSTACK_ALLOC_MAXIMUM 4032  \n#  endif\n# else\n#  define YYSTACK_ALLOC YYMALLOC\n#  define YYSTACK_FREE YYFREE\n#  ifndef YYSTACK_ALLOC_MAXIMUM\n#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM\n#  endif\n#  if (defined __cplusplus && ! defined EXIT_SUCCESS \\\n       && ! ((defined YYMALLOC || defined malloc) \\\n             && (defined YYFREE || defined free)))\n#   include <stdlib.h>  \n#   ifndef EXIT_SUCCESS\n#    define EXIT_SUCCESS 0\n#   endif\n#  endif\n#  ifndef YYMALLOC\n#   define YYMALLOC malloc\n#   if ! defined malloc && ! defined EXIT_SUCCESS\nvoid *malloc (YYSIZE_T);  \n#   endif\n#  endif\n#  ifndef YYFREE\n#   define YYFREE free\n#   if ! defined free && ! defined EXIT_SUCCESS\nvoid free (void *);  \n#   endif\n#  endif\n# endif\n#endif  \n\n#if (! defined yyoverflow \\\n     && (! defined __cplusplus \\\n         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))\n\n \nunion yyalloc\n{\n  yy_state_t yyss_alloc;\n  YYSTYPE yyvs_alloc;\n};\n\n \n# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)\n\n \n# define YYSTACK_BYTES(N) \\\n     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \\\n      + YYSTACK_GAP_MAXIMUM)\n\n# define YYCOPY_NEEDED 1\n\n \n# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \\\n    do                                                                  \\\n      {                                                                 \\\n        YYPTRDIFF_T yynewbytes;                                         \\\n        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \\\n        Stack = &yyptr->Stack_alloc;                                    \\\n        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \\\n        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \\\n      }                                                                 \\\n    while (0)\n\n#endif\n\n#if defined YYCOPY_NEEDED && YYCOPY_NEEDED\n \n# ifndef YYCOPY\n#  if defined __GNUC__ && 1 < __GNUC__\n#   define YYCOPY(Dst, Src, Count) \\\n      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))\n#  else\n#   define YYCOPY(Dst, Src, Count)              \\\n      do                                        \\\n        {                                       \\\n          YYPTRDIFF_T yyi;                      \\\n          for (yyi = 0; yyi < (Count); yyi++)   \\\n            (Dst)[yyi] = (Src)[yyi];            \\\n        }                                       \\\n      while (0)\n#  endif\n# endif\n#endif  \n\n \n#define YYFINAL  12\n \n#define YYLAST   114\n\n \n#define YYNTOKENS  29\n \n#define YYNNTS  26\n \n#define YYNRULES  92\n \n#define YYNSTATES  115\n\n \n#define YYMAXUTOK   277\n\n\n \n#define YYTRANSLATE(YYX)                                \\\n  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \\\n   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \\\n   : YYSYMBOL_YYUNDEF)\n\n \nstatic const yytype_int8 yytranslate[] =\n{\n       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,    27,     2,     2,    28,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,    26,     2,\n       2,     2,     2,     2,    23,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,    24,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,    25,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,\n       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,\n      15,    16,    17,    18,    19,    20,    21,    22\n};\n\n#if YYDEBUG\n \nstatic const yytype_int16 yyrline[] =\n{\n       0,   592,   592,   593,   597,   605,   607,   611,   616,   621,\n     626,   631,   636,   641,   646,   650,   654,   661,   665,   669,\n     674,   679,   684,   688,   693,   698,   705,   707,   711,   736,\n     738,   748,   750,   752,   757,   762,   765,   767,   772,   777,\n     782,   788,   797,   802,   835,   843,   851,   856,   862,   867,\n     873,   877,   887,   889,   891,   896,   898,   900,   902,   904,\n     906,   908,   911,   914,   916,   918,   920,   922,   924,   926,\n     928,   930,   932,   934,   936,   938,   942,   944,   946,   949,\n     951,   953,   958,   962,   962,   965,   966,   972,   973,   979,\n     984,   995,   996\n};\n#endif\n\n \n#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])\n\n#if YYDEBUG || 0\n \nstatic const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;\n\n \nstatic const char *const yytname[] =\n{\n  \"\\\"end of file\\\"\", \"error\", \"\\\"invalid token\\\"\", \"tAGO\", \"tDST\",\n  \"tYEAR_UNIT\", \"tMONTH_UNIT\", \"tHOUR_UNIT\", \"tMINUTE_UNIT\", \"tSEC_UNIT\",\n  \"tDAY_UNIT\", \"tDAY_SHIFT\", \"tDAY\", \"tDAYZONE\", \"tLOCAL_ZONE\",\n  \"tMERIDIAN\", \"tMONTH\", \"tORDINAL\", \"tZONE\", \"tSNUMBER\", \"tUNUMBER\",\n  \"tSDECIMAL_NUMBER\", \"tUDECIMAL_NUMBER\", \"'@'\", \"'J'\", \"'T'\", \"':'\",\n  \"','\", \"'/'\", \"$accept\", \"spec\", \"timespec\", \"items\", \"item\", \"datetime\",\n  \"iso_8601_datetime\", \"time\", \"iso_8601_time\", \"o_zone_offset\",\n  \"zone_offset\", \"local_zone\", \"zone\", \"day\", \"date\", \"iso_8601_date\",\n  \"rel\", \"relunit\", \"relunit_snumber\", \"dayshift\", \"seconds\",\n  \"signed_seconds\", \"unsigned_seconds\", \"number\", \"hybrid\",\n  \"o_colon_minutes\", YY_NULLPTR\n};\n\nstatic const char *\nyysymbol_name (yysymbol_kind_t yysymbol)\n{\n  return yytname[yysymbol];\n}\n#endif\n\n#define YYPACT_NINF (-91)\n\n#define yypact_value_is_default(Yyn) \\\n  ((Yyn) == YYPACT_NINF)\n\n#define YYTABLE_NINF (-1)\n\n#define yytable_value_is_error(Yyn) \\\n  0\n\n \nstatic const yytype_int8 yypact[] =\n{\n     -14,     7,    39,   -91,    37,   -91,   -91,   -91,   -91,   -91,\n     -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,\n      14,   -91,    64,    47,    67,     6,    82,    -4,    74,    75,\n     -91,    76,   -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,\n     -91,    69,   -91,    93,   -91,   -91,   -91,   -91,   -91,   -91,\n      79,    72,   -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,\n      26,   -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,\n     -91,   -91,   -91,   -91,   -91,   -91,    62,    11,    80,    81,\n     -91,   -91,   -91,   -91,   -91,    83,   -91,   -91,    84,    85,\n     -91,   -91,   -91,   -91,   -91,    45,    86,   -12,   -91,   -91,\n     -91,   -91,    87,    18,   -91,   -91,    88,    89,    78,   -91,\n      59,   -91,   -91,    18,    91\n};\n\n \nstatic const yytype_int8 yydefact[] =\n{\n       5,     0,     0,     2,     3,    86,    88,    85,    87,     4,\n      83,    84,     1,    57,    60,    66,    69,    74,    63,    82,\n      38,    36,    29,     0,     0,    31,     0,    89,     0,     0,\n      10,    32,     6,     7,    17,     8,    22,     9,    11,    13,\n      12,    50,    14,    53,    75,    54,    15,    16,    39,    30,\n       0,    46,    55,    58,    64,    67,    70,    61,    40,    37,\n      91,    33,    76,    77,    79,    80,    81,    78,    56,    59,\n      65,    68,    71,    62,    41,    19,    48,    91,     0,     0,\n      23,    90,    72,    73,    34,     0,    52,    45,     0,     0,\n      35,    44,    49,    51,    28,    26,    42,     0,    18,    47,\n      92,    20,    91,     0,    24,    27,     0,     0,    26,    43,\n      26,    21,    25,     0,    26\n};\n\n \nstatic const yytype_int8 yypgoto[] =\n{\n     -91,   -91,   -91,   -91,   -91,   -91,   -91,   -91,    17,   -28,\n     -27,   -91,   -91,   -91,   -91,   -91,   -91,   -91,    38,   -91,\n     -91,   -91,   -90,   -91,   -91,    46\n};\n\n \nstatic const yytype_int8 yydefgoto[] =\n{\n       0,     2,     3,     4,    32,    33,    34,    35,    36,   104,\n     105,    37,    38,    39,    40,    41,    42,    43,    44,    45,\n       9,    10,    11,    46,    47,    94\n};\n\n \nstatic const yytype_int8 yytable[] =\n{\n      80,    68,    69,    70,    71,    72,    73,   102,    74,     1,\n      59,    75,    76,   108,   107,    77,    62,    63,    64,    65,\n      66,    67,    78,   114,    79,    60,     5,     6,     7,     8,\n      93,    62,    63,    64,    65,    66,    67,    89,     6,    12,\n       8,    48,    13,    14,    15,    16,    17,    18,    19,    20,\n      21,    22,    89,    23,    24,    25,    26,    27,    28,    29,\n     101,    30,    31,    61,   102,    81,    50,    51,    49,    84,\n      80,   103,    52,    53,    54,    55,    56,    57,   102,    58,\n     112,    91,    92,    82,    83,   113,   112,    62,    63,    64,\n      65,    66,    67,   111,    85,    26,    86,   102,    87,    88,\n      95,    96,    98,    97,    99,   100,    90,     0,   109,   110,\n     102,     0,     0,    89,   106\n};\n\nstatic const yytype_int8 yycheck[] =\n{\n      27,     5,     6,     7,     8,     9,    10,    19,    12,    23,\n       4,    15,    16,   103,    26,    19,     5,     6,     7,     8,\n       9,    10,    26,   113,    28,    19,    19,    20,    21,    22,\n      19,     5,     6,     7,     8,     9,    10,    26,    20,     0,\n      22,    27,     5,     6,     7,     8,     9,    10,    11,    12,\n      13,    14,    26,    16,    17,    18,    19,    20,    21,    22,\n      15,    24,    25,    25,    19,    27,    19,    20,     4,    31,\n      97,    26,     5,     6,     7,     8,     9,    10,    19,    12,\n     108,    19,    20,     9,     9,    26,   114,     5,     6,     7,\n       8,     9,    10,    15,    25,    19,     3,    19,    19,    27,\n      20,    20,    85,    20,    20,    20,    60,    -1,    20,    20,\n      19,    -1,    -1,    26,    28\n};\n\n \nstatic const yytype_int8 yystos[] =\n{\n       0,    23,    30,    31,    32,    19,    20,    21,    22,    49,\n      50,    51,     0,     5,     6,     7,     8,     9,    10,    11,\n      12,    13,    14,    16,    17,    18,    19,    20,    21,    22,\n      24,    25,    33,    34,    35,    36,    37,    40,    41,    42,\n      43,    44,    45,    46,    47,    48,    52,    53,    27,     4,\n      19,    20,     5,     6,     7,     8,     9,    10,    12,     4,\n      19,    47,     5,     6,     7,     8,     9,    10,     5,     6,\n       7,     8,     9,    10,    12,    15,    16,    19,    26,    28,\n      39,    47,     9,     9,    47,    25,     3,    19,    27,    26,\n      54,    19,    20,    19,    54,    20,    20,    20,    37,    20,\n      20,    15,    19,    26,    38,    39,    28,    26,    51,    20,\n      20,    15,    38,    26,    51\n};\n\n \nstatic const yytype_int8 yyr1[] =\n{\n       0,    29,    30,    30,    31,    32,    32,    33,    33,    33,\n      33,    33,    33,    33,    33,    33,    33,    34,    35,    36,\n      36,    36,    36,    37,    37,    37,    38,    38,    39,    40,\n      40,    41,    41,    41,    41,    41,    41,    41,    42,    42,\n      42,    42,    43,    43,    43,    43,    43,    43,    43,    43,\n      43,    44,    45,    45,    45,    46,    46,    46,    46,    46,\n      46,    46,    46,    46,    46,    46,    46,    46,    46,    46,\n      46,    46,    46,    46,    46,    46,    47,    47,    47,    47,\n      47,    47,    48,    49,    49,    50,    50,    51,    51,    52,\n      53,    54,    54\n};\n\n \nstatic const yytype_int8 yyr2[] =\n{\n       0,     2,     1,     1,     2,     0,     2,     1,     1,     1,\n       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,\n       4,     6,     1,     2,     4,     6,     0,     1,     2,     1,\n       2,     1,     1,     2,     2,     3,     1,     2,     1,     2,\n       2,     2,     3,     5,     3,     3,     2,     4,     2,     3,\n       1,     3,     2,     1,     1,     2,     2,     1,     2,     2,\n       1,     2,     2,     1,     2,     2,     1,     2,     2,     1,\n       2,     2,     2,     2,     1,     1,     2,     2,     2,     2,\n       2,     2,     1,     1,     1,     1,     1,     1,     1,     1,\n       2,     0,     2\n};\n\n\nenum { YYENOMEM = -2 };\n\n#define yyerrok         (yyerrstatus = 0)\n#define yyclearin       (yychar = YYEMPTY)\n\n#define YYACCEPT        goto yyacceptlab\n#define YYABORT         goto yyabortlab\n#define YYERROR         goto yyerrorlab\n#define YYNOMEM         goto yyexhaustedlab\n\n\n#define YYRECOVERING()  (!!yyerrstatus)\n\n#define YYBACKUP(Token, Value)                                    \\\n  do                                                              \\\n    if (yychar == YYEMPTY)                                        \\\n      {                                                           \\\n        yychar = (Token);                                         \\\n        yylval = (Value);                                         \\\n        YYPOPSTACK (yylen);                                       \\\n        yystate = *yyssp;                                         \\\n        goto yybackup;                                            \\\n      }                                                           \\\n    else                                                          \\\n      {                                                           \\\n        yyerror (pc, YY_(\"syntax error: cannot back up\")); \\\n        YYERROR;                                                  \\\n      }                                                           \\\n  while (0)\n\n \n#define YYERRCODE YYUNDEF\n\n\n \n#if YYDEBUG\n\n# ifndef YYFPRINTF\n#  include <stdio.h>  \n#  define YYFPRINTF fprintf\n# endif\n\n# define YYDPRINTF(Args)                        \\\ndo {                                            \\\n  if (yydebug)                                  \\\n    YYFPRINTF Args;                             \\\n} while (0)\n\n\n\n\n# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \\\ndo {                                                                      \\\n  if (yydebug)                                                            \\\n    {                                                                     \\\n      YYFPRINTF (stderr, \"%s \", Title);                                   \\\n      yy_symbol_print (stderr,                                            \\\n                  Kind, Value, pc); \\\n      YYFPRINTF (stderr, \"\\n\");                                           \\\n    }                                                                     \\\n} while (0)\n\n\n \n\nstatic void\nyy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, parser_control *pc)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  YY_USE (pc);\n  if (!yyvaluep)\n    return;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}\n\n\n \n\nstatic void\nyy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, parser_control *pc)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n\n  yy_symbol_value_print (yyo, yykind, yyvaluep, pc);\n  YYFPRINTF (yyo, \")\");\n}\n\n \n\nstatic void\nyy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}\n\n# define YY_STACK_PRINT(Bottom, Top)                            \\\ndo {                                                            \\\n  if (yydebug)                                                  \\\n    yy_stack_print ((Bottom), (Top));                           \\\n} while (0)\n\n\n \n\nstatic void\nyy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,\n                 int yyrule, parser_control *pc)\n{\n  int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %d):\\n\",\n             yyrule - 1, yylno);\n   \n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),\n                       &yyvsp[(yyi + 1) - (yynrhs)], pc);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}\n\n# define YY_REDUCE_PRINT(Rule)          \\\ndo {                                    \\\n  if (yydebug)                          \\\n    yy_reduce_print (yyssp, yyvsp, Rule, pc); \\\n} while (0)\n\n \nint yydebug;\n#else  \n# define YYDPRINTF(Args) ((void) 0)\n# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)\n# define YY_STACK_PRINT(Bottom, Top)\n# define YY_REDUCE_PRINT(Rule)\n#endif  \n\n\n \n#ifndef YYINITDEPTH\n# define YYINITDEPTH 200\n#endif\n\n \n\n#ifndef YYMAXDEPTH\n# define YYMAXDEPTH 10000\n#endif\n\n\n\n\n\n\n \n\nstatic void\nyydestruct (const char *yymsg,\n            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, parser_control *pc)\n{\n  YY_USE (yyvaluep);\n  YY_USE (pc);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}\n\n\n\n\n\n\n \n\nint\nyyparse (parser_control *pc)\n{\n \nint yychar;\n\n\n \n \nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n     \n    int yynerrs = 0;\n\n    yy_state_fast_t yystate = 0;\n     \n    int yyerrstatus = 0;\n\n     \n\n     \n    YYPTRDIFF_T yystacksize = YYINITDEPTH;\n\n     \n    yy_state_t yyssa[YYINITDEPTH];\n    yy_state_t *yyss = yyssa;\n    yy_state_t *yyssp = yyss;\n\n     \n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs = yyvsa;\n    YYSTYPE *yyvsp = yyvs;\n\n  int yyn;\n   \n  int yyresult;\n   \n  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;\n   \n  YYSTYPE yyval;\n\n\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n   \n  int yylen = 0;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yychar = YYEMPTY;  \n\n  goto yysetstate;\n\n\n \nyynewstate:\n   \n  yyssp++;\n\n\n \nyysetstate:\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);\n  YY_IGNORE_USELESS_CAST_BEGIN\n  *yyssp = YY_CAST (yy_state_t, yystate);\n  YY_IGNORE_USELESS_CAST_END\n  YY_STACK_PRINT (yyss, yyssp);\n\n  if (yyss + yystacksize - 1 <= yyssp)\n#if !defined yyoverflow && !defined YYSTACK_RELOCATE\n    YYNOMEM;\n#else\n    {\n       \n      YYPTRDIFF_T yysize = yyssp - yyss + 1;\n\n# if defined yyoverflow\n      {\n         \n        yy_state_t *yyss1 = yyss;\n        YYSTYPE *yyvs1 = yyvs;\n\n         \n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * YYSIZEOF (*yyssp),\n                    &yyvs1, yysize * YYSIZEOF (*yyvsp),\n                    &yystacksize);\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n# else  \n       \n      if (YYMAXDEPTH <= yystacksize)\n        YYNOMEM;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yy_state_t *yyss1 = yyss;\n        union yyalloc *yyptr =\n          YY_CAST (union yyalloc *,\n                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));\n        if (! yyptr)\n          YYNOMEM;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YY_IGNORE_USELESS_CAST_BEGIN\n      YYDPRINTF ((stderr, \"Stack size increased to %ld\\n\",\n                  YY_CAST (long, yystacksize)));\n      YY_IGNORE_USELESS_CAST_END\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n#endif  \n\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n\n \nyybackup:\n   \n\n   \n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n   \n\n   \n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token\\n\"));\n      yychar = yylex (&yylval, pc);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = YYEOF;\n      yytoken = YYSYMBOL_YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else if (yychar == YYerror)\n    {\n       \n      yychar = YYUNDEF;\n      yytoken = YYSYMBOL_YYerror;\n      goto yyerrlab1;\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n   \n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n   \n  if (yyerrstatus)\n    yyerrstatus--;\n\n   \n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n   \n  yychar = YYEMPTY;\n  goto yynewstate;\n\n\n \nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n \nyyreduce:\n   \n  yylen = yyr2[yyn];\n\n   \n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n  case 4:  \n#line 598 \"parse-datetime.y\"\n      {\n        pc->seconds = (yyvsp[0].timespec);\n        pc->timespec_seen = true;\n        debug_print_current_time (_(\"number of seconds\"), pc);\n      }\n#line 1761 \"parse-datetime.c\"\n    break;\n\n  case 7:  \n#line 612 \"parse-datetime.y\"\n      {\n        pc->times_seen++; pc->dates_seen++;\n        debug_print_current_time (_(\"datetime\"), pc);\n      }\n#line 1770 \"parse-datetime.c\"\n    break;\n\n  case 8:  \n#line 617 \"parse-datetime.y\"\n      {\n        pc->times_seen++;\n        debug_print_current_time (_(\"time\"), pc);\n      }\n#line 1779 \"parse-datetime.c\"\n    break;\n\n  case 9:  \n#line 622 \"parse-datetime.y\"\n      {\n        pc->local_zones_seen++;\n        debug_print_current_time (_(\"local_zone\"), pc);\n      }\n#line 1788 \"parse-datetime.c\"\n    break;\n\n  case 10:  \n#line 627 \"parse-datetime.y\"\n      {\n        pc->J_zones_seen++;\n        debug_print_current_time (\"J\", pc);\n      }\n#line 1797 \"parse-datetime.c\"\n    break;\n\n  case 11:  \n#line 632 \"parse-datetime.y\"\n      {\n        pc->zones_seen++;\n        debug_print_current_time (_(\"zone\"), pc);\n      }\n#line 1806 \"parse-datetime.c\"\n    break;\n\n  case 12:  \n#line 637 \"parse-datetime.y\"\n      {\n        pc->dates_seen++;\n        debug_print_current_time (_(\"date\"), pc);\n      }\n#line 1815 \"parse-datetime.c\"\n    break;\n\n  case 13:  \n#line 642 \"parse-datetime.y\"\n      {\n        pc->days_seen++;\n        debug_print_current_time (_(\"day\"), pc);\n      }\n#line 1824 \"parse-datetime.c\"\n    break;\n\n  case 14:  \n#line 647 \"parse-datetime.y\"\n      {\n        debug_print_relative_time (_(\"relative\"), pc);\n      }\n#line 1832 \"parse-datetime.c\"\n    break;\n\n  case 15:  \n#line 651 \"parse-datetime.y\"\n      {\n        debug_print_current_time (_(\"number\"), pc);\n      }\n#line 1840 \"parse-datetime.c\"\n    break;\n\n  case 16:  \n#line 655 \"parse-datetime.y\"\n      {\n        debug_print_relative_time (_(\"hybrid\"), pc);\n      }\n#line 1848 \"parse-datetime.c\"\n    break;\n\n  case 19:  \n#line 670 \"parse-datetime.y\"\n      {\n        set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1857 \"parse-datetime.c\"\n    break;\n\n  case 20:  \n#line 675 \"parse-datetime.y\"\n      {\n        set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1866 \"parse-datetime.c\"\n    break;\n\n  case 21:  \n#line 680 \"parse-datetime.y\"\n      {\n        set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n        pc->meridian = (yyvsp[0].intval);\n      }\n#line 1875 \"parse-datetime.c\"\n    break;\n\n  case 23:  \n#line 689 \"parse-datetime.y\"\n      {\n        set_hhmmss (pc, (yyvsp[-1].textintval).value, 0, 0, 0);\n        pc->meridian = MER24;\n      }\n#line 1884 \"parse-datetime.c\"\n    break;\n\n  case 24:  \n#line 694 \"parse-datetime.y\"\n      {\n        set_hhmmss (pc, (yyvsp[-3].textintval).value, (yyvsp[-1].textintval).value, 0, 0);\n        pc->meridian = MER24;\n      }\n#line 1893 \"parse-datetime.c\"\n    break;\n\n  case 25:  \n#line 699 \"parse-datetime.y\"\n      {\n        set_hhmmss (pc, (yyvsp[-5].textintval).value, (yyvsp[-3].textintval).value, (yyvsp[-1].timespec).tv_sec, (yyvsp[-1].timespec).tv_nsec);\n        pc->meridian = MER24;\n      }\n#line 1902 \"parse-datetime.c\"\n    break;\n\n  case 28:  \n#line 712 \"parse-datetime.y\"\n      {\n        pc->zones_seen++;\n        if (! time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval))) YYABORT;\n      }\n#line 1911 \"parse-datetime.c\"\n    break;\n\n  case 29:  \n#line 737 \"parse-datetime.y\"\n      { pc->local_isdst = (yyvsp[0].intval); }\n#line 1917 \"parse-datetime.c\"\n    break;\n\n  case 30:  \n#line 739 \"parse-datetime.y\"\n      {\n        pc->local_isdst = 1;\n        pc->dsts_seen++;\n      }\n#line 1926 \"parse-datetime.c\"\n    break;\n\n  case 31:  \n#line 749 \"parse-datetime.y\"\n      { pc->time_zone = (yyvsp[0].intval); }\n#line 1932 \"parse-datetime.c\"\n    break;\n\n  case 32:  \n#line 751 \"parse-datetime.y\"\n      { pc->time_zone = -HOUR (7); }\n#line 1938 \"parse-datetime.c\"\n    break;\n\n  case 33:  \n#line 753 \"parse-datetime.y\"\n      { pc->time_zone = (yyvsp[-1].intval);\n        if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n        debug_print_relative_time (_(\"relative\"), pc);\n      }\n#line 1947 \"parse-datetime.c\"\n    break;\n\n  case 34:  \n#line 758 \"parse-datetime.y\"\n      { pc->time_zone = -HOUR (7);\n        if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n        debug_print_relative_time (_(\"relative\"), pc);\n      }\n#line 1956 \"parse-datetime.c\"\n    break;\n\n  case 35:  \n#line 763 \"parse-datetime.y\"\n      { if (! time_zone_hhmm (pc, (yyvsp[-1].textintval), (yyvsp[0].intval))) YYABORT;\n        if (ckd_add (&pc->time_zone, pc->time_zone, (yyvsp[-2].intval))) YYABORT; }\n#line 1963 \"parse-datetime.c\"\n    break;\n\n  case 36:  \n#line 766 \"parse-datetime.y\"\n      { pc->time_zone = (yyvsp[0].intval) + 60 * 60; }\n#line 1969 \"parse-datetime.c\"\n    break;\n\n  case 37:  \n#line 768 \"parse-datetime.y\"\n      { pc->time_zone = (yyvsp[-1].intval) + 60 * 60; }\n#line 1975 \"parse-datetime.c\"\n    break;\n\n  case 38:  \n#line 773 \"parse-datetime.y\"\n      {\n        pc->day_ordinal = 0;\n        pc->day_number = (yyvsp[0].intval);\n      }\n#line 1984 \"parse-datetime.c\"\n    break;\n\n  case 39:  \n#line 778 \"parse-datetime.y\"\n      {\n        pc->day_ordinal = 0;\n        pc->day_number = (yyvsp[-1].intval);\n      }\n#line 1993 \"parse-datetime.c\"\n    break;\n\n  case 40:  \n#line 783 \"parse-datetime.y\"\n      {\n        pc->day_ordinal = (yyvsp[-1].intval);\n        pc->day_number = (yyvsp[0].intval);\n        pc->debug_ordinal_day_seen = true;\n      }\n#line 2003 \"parse-datetime.c\"\n    break;\n\n  case 41:  \n#line 789 \"parse-datetime.y\"\n      {\n        pc->day_ordinal = (yyvsp[-1].textintval).value;\n        pc->day_number = (yyvsp[0].intval);\n        pc->debug_ordinal_day_seen = true;\n      }\n#line 2013 \"parse-datetime.c\"\n    break;\n\n  case 42:  \n#line 798 \"parse-datetime.y\"\n      {\n        pc->month = (yyvsp[-2].textintval).value;\n        pc->day = (yyvsp[0].textintval).value;\n      }\n#line 2022 \"parse-datetime.c\"\n    break;\n\n  case 43:  \n#line 803 \"parse-datetime.y\"\n      {\n         \n        if (4 <= (yyvsp[-4].textintval).digits)\n          {\n            if (debugging (pc))\n              {\n                intmax_t digits = (yyvsp[-4].textintval).digits;\n                dbg_printf (_(\"warning: value %\"PRIdMAX\" has %\"PRIdMAX\" digits. \"\n                              \"Assuming YYYY/MM/DD\\n\"),\n                            (yyvsp[-4].textintval).value, digits);\n              }\n\n            pc->year = (yyvsp[-4].textintval);\n            pc->month = (yyvsp[-2].textintval).value;\n            pc->day = (yyvsp[0].textintval).value;\n          }\n        else\n          {\n            if (debugging (pc))\n              dbg_printf (_(\"warning: value %\"PRIdMAX\" has less than 4 digits. \"\n                            \"Assuming MM/DD/YY[YY]\\n\"),\n                          (yyvsp[-4].textintval).value);\n\n            pc->month = (yyvsp[-4].textintval).value;\n            pc->day = (yyvsp[-2].textintval).value;\n            pc->year = (yyvsp[0].textintval);\n          }\n      }\n#line 2059 \"parse-datetime.c\"\n    break;\n\n  case 44:  \n#line 836 \"parse-datetime.y\"\n      {\n         \n        pc->day = (yyvsp[-2].textintval).value;\n        pc->month = (yyvsp[-1].intval);\n        if (ckd_sub (&pc->year.value, 0, (yyvsp[0].textintval).value)) YYABORT;\n        pc->year.digits = (yyvsp[0].textintval).digits;\n      }\n#line 2071 \"parse-datetime.c\"\n    break;\n\n  case 45:  \n#line 844 \"parse-datetime.y\"\n      {\n         \n        pc->month = (yyvsp[-2].intval);\n        if (ckd_sub (&pc->day, 0, (yyvsp[-1].textintval).value)) YYABORT;\n        if (ckd_sub (&pc->year.value, 0, (yyvsp[0].textintval).value)) YYABORT;\n        pc->year.digits = (yyvsp[0].textintval).digits;\n      }\n#line 2083 \"parse-datetime.c\"\n    break;\n\n  case 46:  \n#line 852 \"parse-datetime.y\"\n      {\n        pc->month = (yyvsp[-1].intval);\n        pc->day = (yyvsp[0].textintval).value;\n      }\n#line 2092 \"parse-datetime.c\"\n    break;\n\n  case 47:  \n#line 857 \"parse-datetime.y\"\n      {\n        pc->month = (yyvsp[-3].intval);\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->year = (yyvsp[0].textintval);\n      }\n#line 2102 \"parse-datetime.c\"\n    break;\n\n  case 48:  \n#line 863 \"parse-datetime.y\"\n      {\n        pc->day = (yyvsp[-1].textintval).value;\n        pc->month = (yyvsp[0].intval);\n      }\n#line 2111 \"parse-datetime.c\"\n    break;\n\n  case 49:  \n#line 868 \"parse-datetime.y\"\n      {\n        pc->day = (yyvsp[-2].textintval).value;\n        pc->month = (yyvsp[-1].intval);\n        pc->year = (yyvsp[0].textintval);\n      }\n#line 2121 \"parse-datetime.c\"\n    break;\n\n  case 51:  \n#line 878 \"parse-datetime.y\"\n      {\n         \n        pc->year = (yyvsp[-2].textintval);\n        if (ckd_sub (&pc->month, 0, (yyvsp[-1].textintval).value)) YYABORT;\n        if (ckd_sub (&pc->day, 0, (yyvsp[0].textintval).value)) YYABORT;\n      }\n#line 2132 \"parse-datetime.c\"\n    break;\n\n  case 52:  \n#line 888 \"parse-datetime.y\"\n      { if (! apply_relative_time (pc, (yyvsp[-1].rel), (yyvsp[0].intval))) YYABORT; }\n#line 2138 \"parse-datetime.c\"\n    break;\n\n  case 53:  \n#line 890 \"parse-datetime.y\"\n      { if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT; }\n#line 2144 \"parse-datetime.c\"\n    break;\n\n  case 54:  \n#line 892 \"parse-datetime.y\"\n      { if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT; }\n#line 2150 \"parse-datetime.c\"\n    break;\n\n  case 55:  \n#line 897 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].intval); }\n#line 2156 \"parse-datetime.c\"\n    break;\n\n  case 56:  \n#line 899 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n#line 2162 \"parse-datetime.c\"\n    break;\n\n  case 57:  \n#line 901 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = 1; }\n#line 2168 \"parse-datetime.c\"\n    break;\n\n  case 58:  \n#line 903 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].intval); }\n#line 2174 \"parse-datetime.c\"\n    break;\n\n  case 59:  \n#line 905 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n#line 2180 \"parse-datetime.c\"\n    break;\n\n  case 60:  \n#line 907 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = 1; }\n#line 2186 \"parse-datetime.c\"\n    break;\n\n  case 61:  \n#line 909 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0;\n        if (ckd_mul (&(yyval.rel).day, (yyvsp[-1].intval), (yyvsp[0].intval))) YYABORT; }\n#line 2193 \"parse-datetime.c\"\n    break;\n\n  case 62:  \n#line 912 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0;\n        if (ckd_mul (&(yyval.rel).day, (yyvsp[-1].textintval).value, (yyvsp[0].intval))) YYABORT; }\n#line 2200 \"parse-datetime.c\"\n    break;\n\n  case 63:  \n#line 915 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n#line 2206 \"parse-datetime.c\"\n    break;\n\n  case 64:  \n#line 917 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].intval); }\n#line 2212 \"parse-datetime.c\"\n    break;\n\n  case 65:  \n#line 919 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n#line 2218 \"parse-datetime.c\"\n    break;\n\n  case 66:  \n#line 921 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = 1; }\n#line 2224 \"parse-datetime.c\"\n    break;\n\n  case 67:  \n#line 923 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].intval); }\n#line 2230 \"parse-datetime.c\"\n    break;\n\n  case 68:  \n#line 925 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n#line 2236 \"parse-datetime.c\"\n    break;\n\n  case 69:  \n#line 927 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = 1; }\n#line 2242 \"parse-datetime.c\"\n    break;\n\n  case 70:  \n#line 929 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].intval); }\n#line 2248 \"parse-datetime.c\"\n    break;\n\n  case 71:  \n#line 931 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n#line 2254 \"parse-datetime.c\"\n    break;\n\n  case 72:  \n#line 933 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n#line 2260 \"parse-datetime.c\"\n    break;\n\n  case 73:  \n#line 935 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].timespec).tv_sec; (yyval.rel).ns = (yyvsp[-1].timespec).tv_nsec; }\n#line 2266 \"parse-datetime.c\"\n    break;\n\n  case 74:  \n#line 937 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = 1; }\n#line 2272 \"parse-datetime.c\"\n    break;\n\n  case 76:  \n#line 943 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).year = (yyvsp[-1].textintval).value; }\n#line 2278 \"parse-datetime.c\"\n    break;\n\n  case 77:  \n#line 945 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).month = (yyvsp[-1].textintval).value; }\n#line 2284 \"parse-datetime.c\"\n    break;\n\n  case 78:  \n#line 947 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0;\n        if (ckd_mul (&(yyval.rel).day, (yyvsp[-1].textintval).value, (yyvsp[0].intval))) YYABORT; }\n#line 2291 \"parse-datetime.c\"\n    break;\n\n  case 79:  \n#line 950 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).hour = (yyvsp[-1].textintval).value; }\n#line 2297 \"parse-datetime.c\"\n    break;\n\n  case 80:  \n#line 952 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).minutes = (yyvsp[-1].textintval).value; }\n#line 2303 \"parse-datetime.c\"\n    break;\n\n  case 81:  \n#line 954 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).seconds = (yyvsp[-1].textintval).value; }\n#line 2309 \"parse-datetime.c\"\n    break;\n\n  case 82:  \n#line 959 \"parse-datetime.y\"\n      { (yyval.rel) = RELATIVE_TIME_0; (yyval.rel).day = (yyvsp[0].intval); }\n#line 2315 \"parse-datetime.c\"\n    break;\n\n  case 86:  \n#line 967 \"parse-datetime.y\"\n      { if (time_overflow ((yyvsp[0].textintval).value)) YYABORT;\n        (yyval.timespec) = (struct timespec) { .tv_sec = (yyvsp[0].textintval).value }; }\n#line 2322 \"parse-datetime.c\"\n    break;\n\n  case 88:  \n#line 974 \"parse-datetime.y\"\n      { if (time_overflow ((yyvsp[0].textintval).value)) YYABORT;\n        (yyval.timespec) = (struct timespec) { .tv_sec = (yyvsp[0].textintval).value }; }\n#line 2329 \"parse-datetime.c\"\n    break;\n\n  case 89:  \n#line 980 \"parse-datetime.y\"\n      { digits_to_date_time (pc, (yyvsp[0].textintval)); }\n#line 2335 \"parse-datetime.c\"\n    break;\n\n  case 90:  \n#line 985 \"parse-datetime.y\"\n      {\n         \n        digits_to_date_time (pc, (yyvsp[-1].textintval));\n        if (! apply_relative_time (pc, (yyvsp[0].rel), 1)) YYABORT;\n      }\n#line 2346 \"parse-datetime.c\"\n    break;\n\n  case 91:  \n#line 995 \"parse-datetime.y\"\n      { (yyval.intval) = -1; }\n#line 2352 \"parse-datetime.c\"\n    break;\n\n  case 92:  \n#line 997 \"parse-datetime.y\"\n      { (yyval.intval) = (yyvsp[0].textintval).value; }\n#line 2358 \"parse-datetime.c\"\n    break;\n\n\n#line 2362 \"parse-datetime.c\"\n\n      default: break;\n    }\n   \n  YY_SYMBOL_PRINT (\"-> $$ =\", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n\n  *++yyvsp = yyval;\n\n   \n  {\n    const int yylhs = yyr1[yyn] - YYNTOKENS;\n    const int yyi = yypgoto[yylhs] + *yyssp;\n    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp\n               ? yytable[yyi]\n               : yydefgoto[yylhs]);\n  }\n\n  goto yynewstate;\n\n\n \nyyerrlab:\n   \n  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);\n   \n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n      yyerror (pc, YY_(\"syntax error\"));\n    }\n\n  if (yyerrstatus == 3)\n    {\n       \n\n      if (yychar <= YYEOF)\n        {\n           \n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, pc);\n          yychar = YYEMPTY;\n        }\n    }\n\n   \n  goto yyerrlab1;\n\n\n \nyyerrorlab:\n   \n  if (0)\n    YYERROR;\n  ++yynerrs;\n\n   \n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n \nyyerrlab1:\n  yyerrstatus = 3;       \n\n   \n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYSYMBOL_YYerror;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n       \n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  YY_ACCESSING_SYMBOL (yystate), yyvsp, pc);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n   \n  YY_SYMBOL_PRINT (\"Shifting\", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n \nyyacceptlab:\n  yyresult = 0;\n  goto yyreturnlab;\n\n\n \nyyabortlab:\n  yyresult = 1;\n  goto yyreturnlab;\n\n\n \nyyexhaustedlab:\n  yyerror (pc, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  goto yyreturnlab;\n\n\n \nyyreturnlab:\n  if (yychar != YYEMPTY)\n    {\n       \n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, pc);\n    }\n   \n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, pc);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n\n  return yyresult;\n}\n\n#line 1000 \"parse-datetime.y\"\n\n\nstatic table const meridian_table[] =\n{\n  { \"AM\",   tMERIDIAN, MERam },\n  { \"A.M.\", tMERIDIAN, MERam },\n  { \"PM\",   tMERIDIAN, MERpm },\n  { \"P.M.\", tMERIDIAN, MERpm },\n  { NULL, 0, 0 }\n};\n\nstatic table const dst_table[] =\n{\n  { \"DST\", tDST, 0 }\n};\n\nstatic table const month_and_day_table[] =\n{\n  { \"JANUARY\",  tMONTH,  1 },\n  { \"FEBRUARY\", tMONTH,  2 },\n  { \"MARCH\",    tMONTH,  3 },\n  { \"APRIL\",    tMONTH,  4 },\n  { \"MAY\",      tMONTH,  5 },\n  { \"JUNE\",     tMONTH,  6 },\n  { \"JULY\",     tMONTH,  7 },\n  { \"AUGUST\",   tMONTH,  8 },\n  { \"SEPTEMBER\",tMONTH,  9 },\n  { \"SEPT\",     tMONTH,  9 },\n  { \"OCTOBER\",  tMONTH, 10 },\n  { \"NOVEMBER\", tMONTH, 11 },\n  { \"DECEMBER\", tMONTH, 12 },\n  { \"SUNDAY\",   tDAY,    0 },\n  { \"MONDAY\",   tDAY,    1 },\n  { \"TUESDAY\",  tDAY,    2 },\n  { \"TUES\",     tDAY,    2 },\n  { \"WEDNESDAY\",tDAY,    3 },\n  { \"WEDNES\",   tDAY,    3 },\n  { \"THURSDAY\", tDAY,    4 },\n  { \"THUR\",     tDAY,    4 },\n  { \"THURS\",    tDAY,    4 },\n  { \"FRIDAY\",   tDAY,    5 },\n  { \"SATURDAY\", tDAY,    6 },\n  { NULL, 0, 0 }\n};\n\nstatic table const time_units_table[] =\n{\n  { \"YEAR\",     tYEAR_UNIT,      1 },\n  { \"MONTH\",    tMONTH_UNIT,     1 },\n  { \"FORTNIGHT\",tDAY_UNIT,      14 },\n  { \"WEEK\",     tDAY_UNIT,       7 },\n  { \"DAY\",      tDAY_UNIT,       1 },\n  { \"HOUR\",     tHOUR_UNIT,      1 },\n  { \"MINUTE\",   tMINUTE_UNIT,    1 },\n  { \"MIN\",      tMINUTE_UNIT,    1 },\n  { \"SECOND\",   tSEC_UNIT,       1 },\n  { \"SEC\",      tSEC_UNIT,       1 },\n  { NULL, 0, 0 }\n};\n\n \nstatic table const relative_time_table[] =\n{\n  { \"TOMORROW\", tDAY_SHIFT,      1 },\n  { \"YESTERDAY\",tDAY_SHIFT,     -1 },\n  { \"TODAY\",    tDAY_SHIFT,      0 },\n  { \"NOW\",      tDAY_SHIFT,      0 },\n  { \"LAST\",     tORDINAL,       -1 },\n  { \"THIS\",     tORDINAL,        0 },\n  { \"NEXT\",     tORDINAL,        1 },\n  { \"FIRST\",    tORDINAL,        1 },\n \n  { \"THIRD\",    tORDINAL,        3 },\n  { \"FOURTH\",   tORDINAL,        4 },\n  { \"FIFTH\",    tORDINAL,        5 },\n  { \"SIXTH\",    tORDINAL,        6 },\n  { \"SEVENTH\",  tORDINAL,        7 },\n  { \"EIGHTH\",   tORDINAL,        8 },\n  { \"NINTH\",    tORDINAL,        9 },\n  { \"TENTH\",    tORDINAL,       10 },\n  { \"ELEVENTH\", tORDINAL,       11 },\n  { \"TWELFTH\",  tORDINAL,       12 },\n  { \"AGO\",      tAGO,           -1 },\n  { \"HENCE\",    tAGO,            1 },\n  { NULL, 0, 0 }\n};\n\n \nstatic table const universal_time_zone_table[] =\n{\n  { \"GMT\",      tZONE,     HOUR ( 0) },  \n  { \"UT\",       tZONE,     HOUR ( 0) },  \n  { \"UTC\",      tZONE,     HOUR ( 0) },\n  { NULL, 0, 0 }\n};\n\n \nstatic table const time_zone_table[] =\n{\n  { \"WET\",      tZONE,     HOUR ( 0) },  \n  { \"WEST\",     tDAYZONE,  HOUR ( 0) },  \n  { \"BST\",      tDAYZONE,  HOUR ( 0) },  \n  { \"ART\",      tZONE,    -HOUR ( 3) },  \n  { \"BRT\",      tZONE,    -HOUR ( 3) },  \n  { \"BRST\",     tDAYZONE, -HOUR ( 3) },  \n  { \"NST\",      tZONE,   -(HOUR ( 3) + 30 * 60) },  \n  { \"NDT\",      tDAYZONE,-(HOUR ( 3) + 30 * 60) },  \n  { \"AST\",      tZONE,    -HOUR ( 4) },  \n  { \"ADT\",      tDAYZONE, -HOUR ( 4) },  \n  { \"CLT\",      tZONE,    -HOUR ( 4) },  \n  { \"CLST\",     tDAYZONE, -HOUR ( 4) },  \n  { \"EST\",      tZONE,    -HOUR ( 5) },  \n  { \"EDT\",      tDAYZONE, -HOUR ( 5) },  \n  { \"CST\",      tZONE,    -HOUR ( 6) },  \n  { \"CDT\",      tDAYZONE, -HOUR ( 6) },  \n  { \"MST\",      tZONE,    -HOUR ( 7) },  \n  { \"MDT\",      tDAYZONE, -HOUR ( 7) },  \n  { \"PST\",      tZONE,    -HOUR ( 8) },  \n  { \"PDT\",      tDAYZONE, -HOUR ( 8) },  \n  { \"AKST\",     tZONE,    -HOUR ( 9) },  \n  { \"AKDT\",     tDAYZONE, -HOUR ( 9) },  \n  { \"HST\",      tZONE,    -HOUR (10) },  \n  { \"HAST\",     tZONE,    -HOUR (10) },  \n  { \"HADT\",     tDAYZONE, -HOUR (10) },  \n  { \"SST\",      tZONE,    -HOUR (12) },  \n  { \"WAT\",      tZONE,     HOUR ( 1) },  \n  { \"CET\",      tZONE,     HOUR ( 1) },  \n  { \"CEST\",     tDAYZONE,  HOUR ( 1) },  \n  { \"MET\",      tZONE,     HOUR ( 1) },  \n  { \"MEZ\",      tZONE,     HOUR ( 1) },  \n  { \"MEST\",     tDAYZONE,  HOUR ( 1) },  \n  { \"MESZ\",     tDAYZONE,  HOUR ( 1) },  \n  { \"EET\",      tZONE,     HOUR ( 2) },  \n  { \"EEST\",     tDAYZONE,  HOUR ( 2) },  \n  { \"CAT\",      tZONE,     HOUR ( 2) },  \n  { \"SAST\",     tZONE,     HOUR ( 2) },  \n  { \"EAT\",      tZONE,     HOUR ( 3) },  \n  { \"MSK\",      tZONE,     HOUR ( 3) },  \n  { \"MSD\",      tDAYZONE,  HOUR ( 3) },  \n  { \"IST\",      tZONE,    (HOUR ( 5) + 30 * 60) },  \n  { \"SGT\",      tZONE,     HOUR ( 8) },  \n  { \"KST\",      tZONE,     HOUR ( 9) },  \n  { \"JST\",      tZONE,     HOUR ( 9) },  \n  { \"GST\",      tZONE,     HOUR (10) },  \n  { \"NZST\",     tZONE,     HOUR (12) },  \n  { \"NZDT\",     tDAYZONE,  HOUR (12) },  \n  { NULL, 0, 0 }\n};\n\n \nstatic table const military_table[] =\n{\n  { \"A\", tZONE,  HOUR ( 1) },\n  { \"B\", tZONE,  HOUR ( 2) },\n  { \"C\", tZONE,  HOUR ( 3) },\n  { \"D\", tZONE,  HOUR ( 4) },\n  { \"E\", tZONE,  HOUR ( 5) },\n  { \"F\", tZONE,  HOUR ( 6) },\n  { \"G\", tZONE,  HOUR ( 7) },\n  { \"H\", tZONE,  HOUR ( 8) },\n  { \"I\", tZONE,  HOUR ( 9) },\n  { \"J\", 'J',    0 },\n  { \"K\", tZONE,  HOUR (10) },\n  { \"L\", tZONE,  HOUR (11) },\n  { \"M\", tZONE,  HOUR (12) },\n  { \"N\", tZONE, -HOUR ( 1) },\n  { \"O\", tZONE, -HOUR ( 2) },\n  { \"P\", tZONE, -HOUR ( 3) },\n  { \"Q\", tZONE, -HOUR ( 4) },\n  { \"R\", tZONE, -HOUR ( 5) },\n  { \"S\", tZONE, -HOUR ( 6) },\n  { \"T\", 'T',    0 },\n  { \"U\", tZONE, -HOUR ( 8) },\n  { \"V\", tZONE, -HOUR ( 9) },\n  { \"W\", tZONE, -HOUR (10) },\n  { \"X\", tZONE, -HOUR (11) },\n  { \"Y\", tZONE, -HOUR (12) },\n  { \"Z\", tZONE,  HOUR ( 0) },\n  { NULL, 0, 0 }\n};\n\n\f\n\n \n\nstatic bool\ntime_zone_hhmm (parser_control *pc, textint s, intmax_t mm)\n{\n  intmax_t n_minutes;\n  bool overflow = false;\n\n   \n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    {\n      overflow |= ckd_mul (&n_minutes, s.value, 60);\n      overflow |= (s.negative\n                   ? ckd_sub (&n_minutes, n_minutes, mm)\n                   : ckd_add (&n_minutes, n_minutes, mm));\n    }\n\n  if (overflow || ! (-24 * 60 <= n_minutes && n_minutes <= 24 * 60))\n    return false;\n  pc->time_zone = n_minutes * 60;\n  return true;\n}\n\nstatic int\nto_hour (intmax_t hours, int meridian)\n{\n  switch (meridian)\n    {\n    default:  \n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}\n\nenum { TM_YEAR_BASE = 1900 };\nenum { TM_YEAR_BUFSIZE = INT_BUFSIZE_BOUND (int) + 1 };\n\n \n\nstatic char const *\ntm_year_str (int tm_year, char buf[TM_YEAR_BUFSIZE])\n{\n  static_assert (TM_YEAR_BASE % 100 == 0);\n  sprintf (buf, &\"-%02d%02d\"[-TM_YEAR_BASE <= tm_year],\n           abs (tm_year / 100 + TM_YEAR_BASE / 100),\n           abs (tm_year % 100));\n  return buf;\n}\n\n \n\nstatic bool\nto_tm_year (textint textyear, bool debug, int *tm_year)\n{\n  intmax_t year = textyear.value;\n\n   \n  if (0 <= year && textyear.digits == 2)\n    {\n      year += year < 69 ? 2000 : 1900;\n      if (debug)\n        dbg_printf (_(\"warning: adjusting year value %\"PRIdMAX\n                      \" to %\"PRIdMAX\"\\n\"),\n                    textyear.value, year);\n    }\n\n  if (year < 0\n      ? ckd_sub (tm_year, -TM_YEAR_BASE, year)\n      : ckd_sub (tm_year, year, TM_YEAR_BASE))\n    {\n      if (debug)\n        dbg_printf (_(\"error: out-of-range year %\"PRIdMAX\"\\n\"), year);\n      return false;\n    }\n\n  return true;\n}\n\nstatic table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n   \n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}\n\n#if ! HAVE_TM_GMTOFF\n \nstatic int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n   \n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}\n#endif  \n\nstatic table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  idx_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n   \n  for (p = word; *p; p++)\n    *p = c_toupper (to_uchar (*p));\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n   \n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n   \n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';   \n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n   \n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n   \n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}\n\nstatic int\nyylex (union YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (c_isdigit (c) || c == '-' || c == '+')\n        {\n          char const *p = pc->input;\n          int sign;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *(pc->input = ++p), c_isspace (c))\n                continue;\n              if (! c_isdigit (c))\n                 \n                continue;\n            }\n          else\n            sign = 0;\n\n          time_t value = 0;\n          do\n            {\n              if (ckd_mul (&value, value, 10))\n                return '?';\n              if (ckd_add (&value, value, sign < 0 ? '0' - c : c - '0'))\n                return '?';\n              c = *++p;\n            }\n          while (c_isdigit (c));\n\n          if ((c == '.' || c == ',') && c_isdigit (p[1]))\n            {\n              time_t s = value;\n              int digits;\n\n               \n              p++;\n              int ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (c_isdigit (*p))\n                    ns += *p++ - '0';\n                }\n\n               \n              if (sign < 0)\n                for (; c_isdigit (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (c_isdigit (*p))\n                p++;\n\n               \n              if (sign < 0 && ns)\n                {\n                  if (ckd_sub (&s, s, 1))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec = (struct timespec) { .tv_sec = s,\n                                                    .tv_nsec = ns };\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              lvalp->textintval.value = value;\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p < buff + sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            {\n              if (debugging (pc))\n                dbg_printf (_(\"error: unknown word '%s'\\n\"), buff);\n              return '?';\n            }\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      idx_t count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}\n\n \nstatic int\nyyerror (_GL_UNUSED parser_control const *pc,\n         _GL_UNUSED char const *s)\n{\n  return 0;\n}\n\n \n\nstatic bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1)\n{\n  if (tm1->tm_wday < 0)\n    return false;\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}\n\n \nstatic char const *\ndebug_strfdatetime (struct tm const *tm, parser_control const *pc,\n                    char *buf, int n)\n{\n   \n  int m = nstrftime (buf, n, \"(Y-M-D) %Y-%m-%d %H:%M:%S\", tm, 0, 0);\n\n   \n  if (pc && m < n && pc->zones_seen)\n    {\n      int tz = pc->time_zone;\n\n       \n      if (pc->local_zones_seen && !pc->zones_seen && 0 < pc->local_isdst)\n        tz += 60 * 60;\n\n      char time_zone_buf[TIME_ZONE_BUFSIZE];\n      snprintf (&buf[m], n - m, \" TZ=%s\", time_zone_str (tz, time_zone_buf));\n    }\n  return buf;\n}\n\nstatic char const *\ndebug_strfdate (struct tm const *tm, char *buf, int n)\n{\n  char tm_year_buf[TM_YEAR_BUFSIZE];\n  snprintf (buf, n, \"(Y-M-D) %s-%02d-%02d\",\n            tm_year_str (tm->tm_year, tm_year_buf),\n            tm->tm_mon + 1, tm->tm_mday);\n  return buf;\n}\n\nstatic char const *\ndebug_strftime (struct tm const *tm, char *buf, int n)\n{\n  snprintf (buf, n, \"%02d:%02d:%02d\", tm->tm_hour, tm->tm_min, tm->tm_sec);\n  return buf;\n}\n\n \nstatic void\ndebug_mktime_not_ok (struct tm const *tm0, struct tm const *tm1,\n                     parser_control const *pc, bool time_zone_seen)\n{\n   \n  char tmp[DBGBUFSIZE];\n  int i;\n  const bool eq_sec   = (tm0->tm_sec  == tm1->tm_sec);\n  const bool eq_min   = (tm0->tm_min  == tm1->tm_min);\n  const bool eq_hour  = (tm0->tm_hour == tm1->tm_hour);\n  const bool eq_mday  = (tm0->tm_mday == tm1->tm_mday);\n  const bool eq_month = (tm0->tm_mon  == tm1->tm_mon);\n  const bool eq_year  = (tm0->tm_year == tm1->tm_year);\n\n  const bool dst_shift = eq_sec && eq_min && !eq_hour\n                         && eq_mday && eq_month && eq_year;\n\n  if (!debugging (pc))\n    return;\n\n  dbg_printf (_(\"error: invalid date/time value:\\n\"));\n  dbg_printf (_(\"    user provided time: '%s'\\n\"),\n              debug_strfdatetime (tm0, pc, tmp, sizeof tmp));\n  dbg_printf (_(\"       normalized time: '%s'\\n\"),\n              debug_strfdatetime (tm1, pc, tmp, sizeof tmp));\n   \n  i = snprintf (tmp, sizeof tmp,\n                \"                                 %4s %2s %2s %2s %2s %2s\",\n                eq_year ? \"\" : \"----\",\n                eq_month ? \"\" : \"--\",\n                eq_mday ? \"\" : \"--\",\n                eq_hour ? \"\" : \"--\",\n                eq_min ? \"\" : \"--\",\n                eq_sec ? \"\" : \"--\");\n   \n  if (0 <= i)\n    {\n      if (sizeof tmp - 1 < i)\n        i = sizeof tmp - 1;\n      while (0 < i && tmp[i - 1] == ' ')\n        --i;\n      tmp[i] = '\\0';\n    }\n  dbg_printf (\"%s\\n\", tmp);\n\n  dbg_printf (_(\"     possible reasons:\\n\"));\n  if (dst_shift)\n    dbg_printf (_(\"       nonexistent due to daylight-saving time;\\n\"));\n  if (!eq_mday && !eq_month)\n    dbg_printf (_(\"       invalid day/month combination;\\n\"));\n  dbg_printf (_(\"       numeric values overflow;\\n\"));\n  dbg_printf (\"       %s\\n\", (time_zone_seen ? _(\"incorrect timezone\")\n                              : _(\"missing timezone\")));\n}\n\n \nstatic bool\nparse_datetime_body (struct timespec *result, char const *p,\n                     struct timespec const *now, unsigned int flags,\n                     timezone_t tzdefault, char const *tzstring)\n{\n  struct tm tm;\n  struct tm tm0;\n  char time_zone_buf[TIME_ZONE_BUFSIZE];\n  char dbg_tm[DBGBUFSIZE];\n  bool ok = false;\n  char const *input_sentinel = p + strlen (p);\n  char *tz1alloc = NULL;\n\n   \n  enum { TZBUFSIZE = 100 };\n  char tz1buf[TZBUFSIZE];\n\n  struct timespec gettime_buffer;\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  time_t Start = now->tv_sec;\n  int Start_ns = now->tv_nsec;\n\n  unsigned char c;\n  while (c = *p, c_isspace (c))\n    p++;\n\n  timezone_t tz = tzdefault;\n\n   \n  const relative_time rel_time_0 = RELATIVE_TIME_0;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      idx_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            timezone_t tz1;\n            char *tz1string = tz1buf;\n            char *z;\n            if (TZBUFSIZE < tzsize)\n              {\n                tz1alloc = malloc (tzsize);\n                if (!tz1alloc)\n                  goto fail;\n                tz1string = tz1alloc;\n              }\n            z = tz1string;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            tz1 = tzalloc (tz1string);\n            if (!tz1)\n              goto fail;\n            tz = tz1;\n            tzstring = tz1string;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  struct tm tmp;\n  if (! localtime_rz (tz, &now->tv_sec, &tmp))\n    goto fail;\n\n   \n  if (*p == '\\0')\n    p = \"0\";\n\n  parser_control pc;\n  pc.input = p;\n#ifdef GNULIB_PARSE_DATETIME2\n  pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;\n#endif\n  if (ckd_add (&pc.year.value, tmp.tm_year, TM_YEAR_BASE))\n    {\n      if (debugging (&pc))\n        dbg_printf (_(\"error: initial year out of range\\n\"));\n      goto fail;\n    }\n  pc.year.digits = 0;\n  pc.month = tmp.tm_mon + 1;\n  pc.day = tmp.tm_mday;\n  pc.hour = tmp.tm_hour;\n  pc.minutes = tmp.tm_min;\n  pc.seconds = (struct timespec) { .tv_sec = tmp.tm_sec, .tv_nsec = Start_ns };\n  tm.tm_isdst = tmp.tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = rel_time_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.J_zones_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n  pc.year_seen = false;\n  pc.debug_dates_seen = false;\n  pc.debug_days_seen = false;\n  pc.debug_times_seen = false;\n  pc.debug_local_zones_seen = false;\n  pc.debug_zones_seen = false;\n  pc.debug_year_seen = false;\n  pc.debug_ordinal_day_seen = false;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp.tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp.tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n   \n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe;\n        if (ckd_add (&probe, Start, quarter * (90 * 24 * 60 * 60)))\n          break;\n        struct tm probe_tm;\n        if (localtime_rz (tz, &probe, &probe_tm) && probe_tm.tm_zone\n            && probe_tm.tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm.tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm.tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n       \n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    {\n      if (debugging (&pc))\n        dbg_printf ((input_sentinel <= pc.input\n                     ? _(\"error: parsing failed\\n\")\n                     : _(\"error: parsing failed, stopped at '%s'\\n\")),\n                    pc.input);\n      goto fail;\n    }\n\n\n   \n\n  if (debugging (&pc))\n    {\n      dbg_printf (_(\"input timezone: \"));\n\n      if (pc.timespec_seen)\n        fprintf (stderr, _(\"'@timespec' - always UTC\"));\n      else if (pc.zones_seen)\n        fprintf (stderr, _(\"parsed date/time string\"));\n      else if (tzstring)\n        {\n          if (tz != tzdefault)\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" in date string\"), tzstring);\n          else if (STREQ (tzstring, \"UTC0\"))\n            {\n               \n              fprintf (stderr, _(\"TZ=\\\"UTC0\\\" environment value or -u\"));\n            }\n          else\n            fprintf (stderr, _(\"TZ=\\\"%s\\\" environment value\"), tzstring);\n        }\n      else\n        fprintf (stderr, _(\"system default\"));\n\n       \n      if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)\n        fprintf (stderr, \", dst\");\n\n      if (pc.zones_seen)\n        fprintf (stderr, \" (%s)\", time_zone_str (pc.time_zone, time_zone_buf));\n\n      fputc ('\\n', stderr);\n    }\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.J_zones_seen + pc.local_zones_seen + pc.zones_seen)))\n        {\n          if (debugging (&pc))\n            {\n              if (pc.times_seen > 1)\n                dbg_printf (\"error: seen multiple time parts\\n\");\n              if (pc.dates_seen > 1)\n                dbg_printf (\"error: seen multiple date parts\\n\");\n              if (pc.days_seen > 1)\n                dbg_printf (\"error: seen multiple days parts\\n\");\n              if (pc.dsts_seen > 1)\n                dbg_printf (\"error: seen multiple daylight-saving parts\\n\");\n              if ((pc.J_zones_seen + pc.local_zones_seen + pc.zones_seen) > 1)\n                dbg_printf (\"error: seen multiple time-zone parts\\n\");\n            }\n          goto fail;\n        }\n\n      if (! to_tm_year (pc.year, debugging (&pc), &tm.tm_year)\n          || ckd_add (&tm.tm_mon, pc.month, -1)\n          || ckd_add (&tm.tm_mday, pc.day, 0))\n        {\n          if (debugging (&pc))\n            dbg_printf (_(\"error: year, month, or day overflow\\n\"));\n          goto fail;\n        }\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            {\n              char const *mrd = (pc.meridian == MERam ? \"am\"\n                                 : pc.meridian == MERpm ?\"pm\" : \"\");\n              if (debugging (&pc))\n                dbg_printf (_(\"error: invalid hour %\"PRIdMAX\"%s\\n\"),\n                            pc.hour, mrd);\n              goto fail;\n            }\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n          if (debugging (&pc))\n            dbg_printf ((pc.times_seen\n                         ? _(\"using specified time as starting value: '%s'\\n\")\n                         : _(\"using current time as starting value: '%s'\\n\")),\n                        debug_strftime (&tm, dbg_tm, sizeof dbg_tm));\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n          if (debugging (&pc))\n            dbg_printf (\"warning: using midnight as starting time: 00:00:00\\n\");\n        }\n\n       \n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n       \n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0.tm_sec = tm.tm_sec;\n      tm0.tm_min = tm.tm_min;\n      tm0.tm_hour = tm.tm_hour;\n      tm0.tm_mday = tm.tm_mday;\n      tm0.tm_mon = tm.tm_mon;\n      tm0.tm_year = tm.tm_year;\n      tm0.tm_isdst = tm.tm_isdst;\n      tm.tm_wday = -1;\n\n      Start = mktime_z (tz, &tm);\n\n      if (! mktime_ok (&tm0, &tm))\n        {\n          bool repaired = false;\n          bool time_zone_seen = pc.zones_seen != 0;\n          if (time_zone_seen)\n            {\n               \n\n              char tz2buf[sizeof \"XXX\" - 1 + TIME_ZONE_BUFSIZE];\n              tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';\n              time_zone_str (pc.time_zone, &tz2buf[3]);\n              timezone_t tz2 = tzalloc (tz2buf);\n              if (!tz2)\n                {\n                  if (debugging (&pc))\n                    dbg_printf (_(\"error: tzalloc (\\\"%s\\\") failed\\n\"), tz2buf);\n                  goto fail;\n                }\n              tm.tm_sec = tm0.tm_sec;\n              tm.tm_min = tm0.tm_min;\n              tm.tm_hour = tm0.tm_hour;\n              tm.tm_mday = tm0.tm_mday;\n              tm.tm_mon = tm0.tm_mon;\n              tm.tm_year = tm0.tm_year;\n              tm.tm_isdst = tm0.tm_isdst;\n              tm.tm_wday = -1;\n              Start = mktime_z (tz2, &tm);\n              repaired = mktime_ok (&tm0, &tm);\n              tzfree (tz2);\n            }\n\n          if (! repaired)\n            {\n              debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);\n              goto fail;\n            }\n        }\n\n      char dbg_ord[DBGBUFSIZE];\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          intmax_t dayincr;\n          tm.tm_yday = -1;\n          intmax_t day_ordinal = (pc.day_ordinal\n                                  - (0 < pc.day_ordinal\n                                     && tm.tm_wday != pc.day_number));\n          if (! (ckd_mul (&dayincr, day_ordinal, 7)\n                 || ckd_add (&dayincr, (pc.day_number - tm.tm_wday + 7) % 7,\n                             dayincr)\n                 || ckd_add (&tm.tm_mday, dayincr, tm.tm_mday)))\n            {\n              tm.tm_isdst = -1;\n              Start = mktime_z (tz, &tm);\n            }\n\n          if (tm.tm_yday < 0)\n            {\n              if (debugging (&pc))\n                dbg_printf (_(\"error: day '%s' \"\n                              \"(day ordinal=%\"PRIdMAX\" number=%d) \"\n                              \"resulted in an invalid date: '%s'\\n\"),\n                            str_days (&pc, dbg_ord, sizeof dbg_ord),\n                            pc.day_ordinal, pc.day_number,\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (debugging (&pc))\n            dbg_printf (_(\"new start date: '%s' is '%s'\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord),\n                        debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n\n        }\n\n      if (debugging (&pc))\n        {\n          if (!pc.dates_seen && !pc.days_seen)\n            dbg_printf (_(\"using current date as starting value: '%s'\\n\"),\n                        debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));\n\n          if (pc.days_seen && pc.dates_seen)\n            dbg_printf (_(\"warning: day (%s) ignored when explicit dates \"\n                          \"are given\\n\"),\n                        str_days (&pc, dbg_ord, sizeof dbg_ord));\n\n          dbg_printf (_(\"starting date/time: '%s'\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));\n        }\n\n       \n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          if (debugging (&pc))\n            {\n              if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)\n                dbg_printf (_(\"warning: when adding relative months/years, \"\n                              \"it is recommended to specify the 15th of the \"\n                              \"months\\n\"));\n\n              if (pc.rel.day != 0 && tm.tm_hour != 12)\n                dbg_printf (_(\"warning: when adding relative days, \"\n                              \"it is recommended to specify noon\\n\"));\n            }\n\n          int year, month, day;\n          if (ckd_add (&year, tm.tm_year, pc.rel.year)\n              || ckd_add (&month, tm.tm_mon, pc.rel.month)\n              || ckd_add (&day, tm.tm_mday, pc.rel.day))\n            {\n              if (debugging (&pc))\n                dbg_printf (_(\"error: %s:%d\\n\"), __FILE__, __LINE__);\n              goto fail;\n            }\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          tm.tm_wday = -1;\n          Start = mktime_z (tz, &tm);\n          if (tm.tm_wday < 0)\n            {\n              if (debugging (&pc))\n                dbg_printf (_(\"error: adding relative date resulted \"\n                              \"in an invalid date: '%s'\\n\"),\n                            debug_strfdatetime (&tm, &pc, dbg_tm,\n                                                sizeof dbg_tm));\n              goto fail;\n            }\n\n          if (debugging (&pc))\n            {\n              dbg_printf (_(\"after date adjustment \"\n                            \"(%+\"PRIdMAX\" years, %+\"PRIdMAX\" months, \"\n                            \"%+\"PRIdMAX\" days),\\n\"),\n                          pc.rel.year, pc.rel.month, pc.rel.day);\n              dbg_printf (_(\"    new date/time = '%s'\\n\"),\n                          debug_strfdatetime (&tm, &pc, dbg_tm,\n                                              sizeof dbg_tm));\n\n               \n              if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)\n                dbg_printf (_(\"warning: daylight saving time changed after \"\n                              \"date adjustment\\n\"));\n\n               \n              if (pc.rel.day == 0\n                  && (tm.tm_mday != day\n                      || (pc.rel.month == 0 && tm.tm_mon != month)))\n                {\n                  dbg_printf (_(\"warning: month/year adjustment resulted in \"\n                                \"shifted dates:\\n\"));\n                  char tm_year_buf[TM_YEAR_BUFSIZE];\n                  dbg_printf (_(\"     adjusted Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (year, tm_year_buf), month + 1, day);\n                  dbg_printf (_(\"   normalized Y M D: %s %02d %02d\\n\"),\n                              tm_year_str (tm.tm_year, tm_year_buf),\n                              tm.tm_mon + 1, tm.tm_mday);\n                }\n            }\n\n        }\n\n       \n      if (pc.zones_seen)\n        {\n          bool overflow = false;\n#ifdef HAVE_TM_GMTOFF\n          long int utcoff = tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm gmt;\n          int utcoff = (gmtime_r (&t, &gmt)\n                        ? tm_diff (&tm, &gmt)\n                        : (overflow = true, 0));\n#endif\n          intmax_t delta;\n          overflow |= ckd_sub (&delta, pc.time_zone, utcoff);\n          time_t t1;\n          overflow |= ckd_sub (&t1, Start, delta);\n          if (overflow)\n            {\n              if (debugging (&pc))\n                dbg_printf (_(\"error: timezone %d caused time_t overflow\\n\"),\n                            pc.time_zone);\n              goto fail;\n            }\n          Start = t1;\n        }\n\n      if (debugging (&pc))\n        {\n          intmax_t Starti = Start;\n          dbg_printf (_(\"'%s' = %\"PRIdMAX\" epoch-seconds\\n\"),\n                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),\n                      Starti);\n        }\n\n\n       \n      {\n        intmax_t orig_ns = pc.seconds.tv_nsec;\n        intmax_t sum_ns = orig_ns + pc.rel.ns;\n        int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        int d4 = (sum_ns - normalized_ns) / BILLION;\n        intmax_t d1, t1, d2, t2, t3;\n        time_t t4;\n        if (ckd_mul (&d1, pc.rel.hour, 60 * 60)\n            || ckd_add (&t1, Start, d1)\n            || ckd_mul (&d2, pc.rel.minutes, 60)\n            || ckd_add (&t2, t1, d2)\n            || ckd_add (&t3, t2, pc.rel.seconds)\n            || ckd_add (&t4, t3, d4))\n          {\n            if (debugging (&pc))\n              dbg_printf (_(\"error: adding relative time caused an \"\n                            \"overflow\\n\"));\n            goto fail;\n          }\n\n        result->tv_sec = t4;\n        result->tv_nsec = normalized_ns;\n\n        if (debugging (&pc)\n            && (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))\n          {\n            dbg_printf (_(\"after time adjustment (%+\"PRIdMAX\" hours, \"\n                          \"%+\"PRIdMAX\" minutes, \"\n                          \"%+\"PRIdMAX\" seconds, %+d ns),\\n\"),\n                        pc.rel.hour, pc.rel.minutes, pc.rel.seconds,\n                        pc.rel.ns);\n            intmax_t t4i = t4;\n            dbg_printf (_(\"    new time = %\"PRIdMAX\" epoch-seconds\\n\"), t4i);\n\n             \n            struct tm lmt;\n            if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)\n                && tm.tm_isdst != lmt.tm_isdst)\n              dbg_printf (_(\"warning: daylight saving time changed after \"\n                            \"time adjustment\\n\"));\n          }\n      }\n    }\n\n  if (debugging (&pc))\n    {\n       \n      if (! tzstring)\n        dbg_printf (_(\"timezone: system default\\n\"));\n      else if (STREQ (tzstring, \"UTC0\"))\n        dbg_printf (_(\"timezone: Universal Time\\n\"));\n      else\n        dbg_printf (_(\"timezone: TZ=\\\"%s\\\" environment value\\n\"), tzstring);\n\n      intmax_t sec = result->tv_sec;\n      int nsec = result->tv_nsec;\n      dbg_printf (_(\"final: %\"PRIdMAX\".%09d (epoch-seconds)\\n\"),\n                  sec, nsec);\n\n      struct tm gmt, lmt;\n      bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);\n      if (got_utc)\n        dbg_printf (_(\"final: %s (UTC)\\n\"),\n                    debug_strfdatetime (&gmt, NULL,\n                                        dbg_tm, sizeof dbg_tm));\n      if (localtime_rz (tz, &result->tv_sec, &lmt))\n        {\n#ifdef HAVE_TM_GMTOFF\n          bool got_utcoff = true;\n          long int utcoff = lmt.tm_gmtoff;\n#else\n          bool got_utcoff = got_utc;\n          int utcoff;\n          if (got_utcoff)\n            utcoff = tm_diff (&lmt, &gmt);\n#endif\n          if (got_utcoff)\n            dbg_printf (_(\"final: %s (UTC%s)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),\n                        time_zone_str (utcoff, time_zone_buf));\n          else\n            dbg_printf (_(\"final: %s (unknown time zone offset)\\n\"),\n                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));\n        }\n    }\n\n  ok = true;\n\n fail:\n  if (tz != tzdefault)\n    tzfree (tz);\n  free (tz1alloc);\n  return ok;\n}\n\n#ifdef GNULIB_PARSE_DATETIME2\n \nbool\nparse_datetime2 (struct timespec *result, char const *p,\n                 struct timespec const *now, unsigned int flags,\n                 timezone_t tzdefault, char const *tzstring)\n{\n  return parse_datetime_body (result, p, now, flags, tzdefault, tzstring);\n}\n#endif\n\n\n \nbool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  char const *tzstring = getenv (\"TZ\");\n  timezone_t tz = tzalloc (tzstring);\n  if (!tz)\n    return false;\n  bool ok = parse_datetime_body (result, p, now, 0, tz, tzstring);\n  tzfree (tz);\n  return ok;\n}\n\n#if TEST\n\nint\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          intmax_t sec = d.tv_sec;\n          printf (\"localtime (%\"PRIdMAX\") failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          char tm_year_buf[TM_YEAR_BUFSIZE];\n          printf (\"%s-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm_year_str (tm->tm_year, tm_year_buf),\n                  tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}