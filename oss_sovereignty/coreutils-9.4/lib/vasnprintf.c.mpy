{
  "module_name": "vasnprintf.c",
  "hash_id": "dcad797aa611ec4dcf47b87f837d900dc554702c47eeec22d974a3f09ad97f8d",
  "original_prompt": "Ingested from coreutils-9.4/lib/vasnprintf.c",
  "human_readable_source": " \n\n \n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE    1\n#endif\n\n#ifndef VASNPRINTF\n# include <config.h>\n#endif\n\n \n#if 10 <= __GNUC__\n# pragma GCC diagnostic ignored \"-Wanalyzer-null-argument\"\n#endif\n\n#include <alloca.h>\n\n \n#ifndef VASNPRINTF\n# if WIDE_CHAR_VERSION\n#  include \"vasnwprintf.h\"\n# else\n#  include \"vasnprintf.h\"\n# endif\n#endif\n\n#include <locale.h>      \n#include <stdio.h>       \n#include <stdlib.h>      \n#include <string.h>      \n#include <wchar.h>       \n#include <errno.h>       \n#include <limits.h>      \n#include <float.h>       \n#if HAVE_NL_LANGINFO\n# include <langinfo.h>\n#endif\n#ifndef VASNPRINTF\n# if WIDE_CHAR_VERSION\n#  include \"wprintf-parse.h\"\n# else\n#  include \"printf-parse.h\"\n# endif\n#endif\n\n \n#include \"xsize.h\"\n\n#include \"attribute.h\"\n\n#if NEED_PRINTF_DOUBLE || NEED_PRINTF_LONG_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n# include <math.h>\n# include \"float+.h\"\n#endif\n\n#if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE\n# include <math.h>\n# include \"isnand-nolibm.h\"\n#endif\n\n#if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n# include <math.h>\n# include \"isnanl-nolibm.h\"\n# include \"fpucw.h\"\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE\n# include <math.h>\n# include \"isnand-nolibm.h\"\n# include \"printf-frexp.h\"\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n# include <math.h>\n# include \"isnanl-nolibm.h\"\n# include \"printf-frexpl.h\"\n# include \"fpucw.h\"\n#endif\n\n \n#ifndef VASNPRINTF\n# if WIDE_CHAR_VERSION\n#  define VASNPRINTF vasnwprintf\n#  define FCHAR_T wchar_t\n#  define DCHAR_T wchar_t\n#  define DIRECTIVE wchar_t_directive\n#  define DIRECTIVES wchar_t_directives\n#  define PRINTF_PARSE wprintf_parse\n#  define DCHAR_CPY wmemcpy\n#  define DCHAR_SET wmemset\n# else\n#  define VASNPRINTF vasnprintf\n#  define FCHAR_T char\n#  define DCHAR_T char\n#  define TCHAR_T char\n#  define DCHAR_IS_TCHAR 1\n#  define DIRECTIVE char_directive\n#  define DIRECTIVES char_directives\n#  define PRINTF_PARSE printf_parse\n#  define DCHAR_CPY memcpy\n#  define DCHAR_SET memset\n# endif\n#endif\n#if WIDE_CHAR_VERSION\n   \n# if HAVE_DECL__SNWPRINTF || (HAVE_SWPRINTF && HAVE_WORKING_SWPRINTF)\n#  define TCHAR_T wchar_t\n#  define DCHAR_IS_TCHAR 1\n#  define USE_SNPRINTF 1\n#  if HAVE_DECL__SNWPRINTF\n     \n#   if defined __MINGW32__\n#    define SNPRINTF snwprintf\n#   else\n#    define SNPRINTF _snwprintf\n#    define USE_MSVC__SNPRINTF 1\n#   endif\n#  else\n     \n#   define SNPRINTF swprintf\n#  endif\n# else\n    \n#   define TCHAR_T char\n# endif\n#endif\n#if !WIDE_CHAR_VERSION || !DCHAR_IS_TCHAR\n   \n   \n# if (HAVE_DECL__SNPRINTF || HAVE_SNPRINTF) && !defined __BEOS__ && !(__GNU_LIBRARY__ == 1)\n#  define USE_SNPRINTF 1\n# else\n#  define USE_SNPRINTF 0\n# endif\n# if HAVE_DECL__SNPRINTF\n    \n#  if defined __MINGW32__\n#   define SNPRINTF snprintf\n     \n#   undef snprintf\n#  else\n     \n#   define SNPRINTF _snprintf\n#   define USE_MSVC__SNPRINTF 1\n#  endif\n# else\n    \n#  define SNPRINTF snprintf\n    \n#  undef snprintf\n# endif\n#endif\n \n#undef sprintf\n\n \n#if defined GCC_LINT || defined lint\n# define IF_LINT(Code) Code\n#else\n# define IF_LINT(Code)  \n#endif\n\n \n#undef exp\n#define exp expo\n#undef remainder\n#define remainder rem\n\n#if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF) && !WIDE_CHAR_VERSION\n# if (HAVE_STRNLEN && !defined _AIX)\n#  define local_strnlen strnlen\n# else\n#  ifndef local_strnlen_defined\n#   define local_strnlen_defined 1\nstatic size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}\n#  endif\n# endif\n#endif\n\n#if (((!USE_SNPRINTF || WIDE_CHAR_VERSION || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_WPRINTF_DIRECTIVE_LC) && WIDE_CHAR_VERSION) || ((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_DIRECTIVE_LS) && !WIDE_CHAR_VERSION && DCHAR_IS_TCHAR)) && HAVE_WCHAR_T\n# if HAVE_WCSLEN\n#  define local_wcslen wcslen\n# else\n    \n#  ifndef local_wcslen_defined\n#   define local_wcslen_defined 1\nstatic size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}\n#  endif\n# endif\n#endif\n\n#if (!USE_SNPRINTF || (WIDE_CHAR_VERSION && DCHAR_IS_TCHAR) || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF) && HAVE_WCHAR_T && WIDE_CHAR_VERSION\n# if HAVE_WCSNLEN && HAVE_DECL_WCSNLEN\n#  define local_wcsnlen wcsnlen\n# else\n#  ifndef local_wcsnlen_defined\n#   define local_wcsnlen_defined 1\nstatic size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}\n#  endif\n# endif\n#endif\n\n#if (((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_DIRECTIVE_LS || ENABLE_WCHAR_FALLBACK) && HAVE_WCHAR_T) || ((NEED_PRINTF_DIRECTIVE_LC || ENABLE_WCHAR_FALLBACK) && HAVE_WINT_T)) && !WIDE_CHAR_VERSION\n# if ENABLE_WCHAR_FALLBACK\nstatic size_t\nwctomb_fallback (char *s, wchar_t wc)\n{\n  static char hex[16] = \"0123456789ABCDEF\";\n\n  s[0] = '\\\\';\n  if (sizeof (wchar_t) > 2 && wc > 0xffff)\n    {\n#  if __STDC_ISO_10646__ || (__GLIBC__ >= 2) || (defined _WIN32 || defined __CYGWIN__)\n      s[1] = 'U';\n#  else\n      s[1] = 'W';\n#  endif\n      s[2] = hex[(wc & 0xf0000000U) >> 28];\n      s[3] = hex[(wc & 0xf000000U) >> 24];\n      s[4] = hex[(wc & 0xf00000U) >> 20];\n      s[5] = hex[(wc & 0xf0000U) >> 16];\n      s[6] = hex[(wc & 0xf000U) >> 12];\n      s[7] = hex[(wc & 0xf00U) >> 8];\n      s[8] = hex[(wc & 0xf0U) >> 4];\n      s[9] = hex[wc & 0xfU];\n      return 10;\n    }\n  else\n    {\n#  if __STDC_ISO_10646__ || (__GLIBC__ >= 2) || (defined _WIN32 || defined __CYGWIN__)\n      s[1] = 'u';\n#  else\n      s[1] = 'w';\n#  endif\n      s[2] = hex[(wc & 0xf000U) >> 12];\n      s[3] = hex[(wc & 0xf00U) >> 8];\n      s[4] = hex[(wc & 0xf0U) >> 4];\n      s[5] = hex[wc & 0xfU];\n      return 6;\n    }\n}\n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\nstatic size_t\nlocal_wcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  size_t count = wcrtomb (s, wc, ps);\n  if (count == (size_t)(-1))\n    count = wctomb_fallback (s, wc);\n  return count;\n}\n#  else\nstatic int\nlocal_wctomb (char *s, wchar_t wc)\n{\n  int count = wctomb (s, wc);\n  if (count < 0)\n    count = wctomb_fallback (s, wc);\n  return count;\n}\n#   define local_wcrtomb(S, WC, PS)  local_wctomb ((S), (WC))\n#  endif\n# else\n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n#   define local_wcrtomb(S, WC, PS)  wcrtomb ((S), (WC), (PS))\n#  else\n#   define local_wcrtomb(S, WC, PS)  wctomb ((S), (WC))\n#  endif\n# endif\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n \n# ifndef decimal_point_char_defined\n#  define decimal_point_char_defined 1\nstatic char\ndecimal_point_char (void)\n{\n  const char *point;\n   \n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n   \n  return (point[0] != '\\0' ? point[0] : '.');\n}\n# endif\n#endif\n\n#if NEED_PRINTF_INFINITE_DOUBLE && !NEED_PRINTF_DOUBLE\n\n \nstatic int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}\n\n#endif\n\n#if NEED_PRINTF_INFINITE_LONG_DOUBLE && !NEED_PRINTF_LONG_DOUBLE\n\n \nstatic int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}\n\n#endif\n\n#if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_DOUBLE\n\n \n\ntypedef unsigned int mp_limb_t;\n# define GMP_LIMB_BITS 32\nstatic_assert (sizeof (mp_limb_t) * CHAR_BIT == GMP_LIMB_BITS);\n\ntypedef unsigned long long mp_twolimb_t;\n# define GMP_TWOLIMB_BITS 64\nstatic_assert (sizeof (mp_twolimb_t) * CHAR_BIT == GMP_TWOLIMB_BITS);\n\n \ntypedef struct\n{\n  size_t nlimbs;\n  mp_limb_t *limbs;  \n} mpn_t;\n\n \nstatic void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n   \n  if (len1 == 0)\n    {\n       \n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n       \n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n       \n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}\n\n \nstatic void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n   \n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n   \n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n   \n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n   \n  for (;;)\n    {\n      if (b_len == 0)\n         \n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n   \n\n  if (a_len < b_len)\n    {\n       \n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n       \n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n         \n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n         \n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n       \n       \n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1];  \n         \n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) \\\n     || (__clang_major__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n             \n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n             \n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n       \n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n             \n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n       \n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1;  \n      {\n        size_t j = a_len - b_len;  \n        mp_limb_t b_msd = b_ptr[b_len - 1];  \n        mp_limb_t b_2msd = b_ptr[b_len - 2];  \n        mp_twolimb_t b_msdd =  \n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n         \n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd)  \n              {\n                 \n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                 \n                q_star = (mp_limb_t)~(mp_limb_t)0;  \n                 \n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                   \n                  goto subtract;\n              }\n             \n            {\n              mp_twolimb_t c2 =  \n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 =  \n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n               \n              if (c3 > c2)\n                {\n                  q_star = q_star - 1;  \n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1;  \n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                 \n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                       \n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                       \n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS;  \n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                 \n                if (cr > r_ptr[j + b_len])\n                  {\n                     \n                    q_star = q_star - 1;  \n                     \n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                     \n                  }\n              }\n             \n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n       \n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0  \n       \n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n       \n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n   \n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n     \n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}\n\n \n# if __GNUC__ >= 7\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Walloc-size-larger-than=\"\n# endif\n\n \nstatic char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n   \n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n   \n  char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n           \n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n           \n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n           \n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n       \n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n       \n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n       \n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}\n\n# if __GNUC__ >= 7\n#  pragma GCC diagnostic pop\n# endif\n\n# if NEED_PRINTF_LONG_DOUBLE\n\n \nstatic void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n   \n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n   \n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n   \n   \n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0  \n  if (!(y == 0.0L))\n    abort ();\n#  endif\n   \n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}\n\n# endif\n\n# if NEED_PRINTF_DOUBLE\n\n \nstatic void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n   \n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n   \n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n   \n   \n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n   \n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}\n\n# endif\n\n \nstatic char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n   \n  s = e + n;\n  extra_zeroes = 0;\n   \n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n   \n   \n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n   \n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n   \n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n       \n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n           \n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n           \n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n           \n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n           \n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n           \n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n   \n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}\n\n# if NEED_PRINTF_LONG_DOUBLE\n\n \nstatic char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e;\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  if (memory != NULL)\n    return scale10_round_decimal_decoded (e, m, memory, n);\n  else\n    return NULL;\n}\n\n# endif\n\n# if NEED_PRINTF_DOUBLE\n\n \nstatic char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e;\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  if (memory != NULL)\n    return scale10_round_decimal_decoded (e, m, memory, n);\n  else\n    return NULL;\n}\n\n# endif\n\n# if NEED_PRINTF_LONG_DOUBLE\n\n \nstatic int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n   \n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n   \n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n   \n  z = 1 - z;\n   \n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n   \n  l *= 0.30102999566398119523;\n   \n  return (int) l + (l < 0 ? -1 : 0);\n}\n\n# endif\n\n# if NEED_PRINTF_DOUBLE\n\n \nstatic int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n   \n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n   \n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n   \n  z = 1 - z;\n   \n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n   \n  l *= 0.30102999566398119523;\n   \n  return (int) l + (l < 0 ? -1 : 0);\n}\n\n# endif\n\n \nstatic int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}\n\n#endif\n\n#if !USE_SNPRINTF || (WIDE_CHAR_VERSION && DCHAR_IS_TCHAR) || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n\n \n# if WIDE_CHAR_VERSION\n#  define MAX_ROOM_NEEDED wmax_room_needed\n# else\n#  define MAX_ROOM_NEEDED max_room_needed\n# endif\n\n \nstatic size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n      switch (type)\n        {\n        default:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_LONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (long int) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_ULONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long int) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_LONGLONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (long long int) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_ULONGLONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long long int) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT8_T:\n          tmp_length =\n            (unsigned int) (sizeof (int8_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint8_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT16_T:\n          tmp_length =\n            (unsigned int) (sizeof (int16_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint16_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT32_T:\n          tmp_length =\n            (unsigned int) (sizeof (int32_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint32_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT64_T:\n          tmp_length =\n            (unsigned int) (sizeof (int64_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint64_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT_FAST8_T:\n          tmp_length =\n            (unsigned int) (sizeof (int_fast8_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast8_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT_FAST16_T:\n          tmp_length =\n            (unsigned int) (sizeof (int_fast16_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast16_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT_FAST32_T:\n          tmp_length =\n            (unsigned int) (sizeof (int_fast32_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast32_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_INT_FAST64_T:\n          tmp_length =\n            (unsigned int) (sizeof (int_fast64_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast64_t) * CHAR_BIT\n                            * 0.30103  \n                           )\n            + 1;  \n          break;\n        }\n      if (tmp_length < precision)\n        tmp_length = precision;\n       \n      tmp_length = xsum (tmp_length, tmp_length);\n       \n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'b':\n    #if SUPPORT_GNU_PRINTF_DIRECTIVES \\\n        || (__GLIBC__ + (__GLIBC_MINOR__ >= 35) > 2)\n    case 'B':\n    #endif\n      switch (type)\n        {\n        default:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned int) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_ULONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long int) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_ULONGLONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long long int) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint8_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint16_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint32_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint64_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT_FAST8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast8_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT_FAST16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast16_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT_FAST32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast32_t) * CHAR_BIT)\n            + 1;  \n          break;\n        case TYPE_UINT_FAST64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast64_t) * CHAR_BIT)\n            + 1;  \n          break;\n        }\n      if (tmp_length < precision)\n        tmp_length = precision;\n       \n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'o':\n      switch (type)\n        {\n        default:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_ULONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long int) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_ULONGLONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long long int) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint8_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint16_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint32_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint64_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast8_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast16_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast32_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast64_t) * CHAR_BIT\n                            * 0.333334  \n                           )\n            + 1;  \n          break;\n        }\n      if (tmp_length < precision)\n        tmp_length = precision;\n       \n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n      switch (type)\n        {\n        default:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_ULONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long int) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_ULONGLONGINT:\n          tmp_length =\n            (unsigned int) (sizeof (unsigned long long int) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint8_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint16_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint32_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint64_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST8_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast8_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST16_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast16_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST32_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast32_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        case TYPE_UINT_FAST64_T:\n          tmp_length =\n            (unsigned int) (sizeof (uint_fast64_t) * CHAR_BIT\n                            * 0.25  \n                           )\n            + 1;  \n          break;\n        }\n      if (tmp_length < precision)\n        tmp_length = precision;\n       \n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103  \n                          * 2  \n                         )\n          + 1  \n          + 10;  \n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103  \n                          * 2  \n                         )\n          + 1  \n          + 10;  \n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12;  \n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831  \n                         )\n          + 1;  \n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831  \n                         )\n          + 1;  \n      if (tmp_length < precision)\n        tmp_length = precision;\n       \n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        {\n          tmp_length = MB_CUR_MAX;\n#  if ENABLE_WCHAR_FALLBACK\n          if (tmp_length < (sizeof (wchar_t) > 2 ? 10 : 6))\n            tmp_length = (sizeof (wchar_t) > 2 ? 10 : 6);\n#  endif\n        }\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n           \n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n           \n           \n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n           \n           \n          abort ();\n# else\n           \n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25  \n                       )\n          + 1  \n          + 2;  \n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n       \n      tmp_length = xsum (tmp_length, width);\n# else\n       \n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1);  \n\n  return tmp_length;\n}\n\n#endif\n\nDCHAR_T *\nVASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp,\n            const FCHAR_T *format, va_list args)\n{\n  DIRECTIVES d;\n  arguments a;\n\n  if (PRINTF_PARSE (format, &d, &a) < 0)\n     \n    return NULL;\n\n   \n#define CLEANUP() \\\n  if (d.dir != d.direct_alloc_dir)                                      \\\n    free (d.dir);                                                       \\\n  if (a.arg != a.direct_alloc_arg)                                      \\\n    free (a.arg);\n\n  if (PRINTF_FETCHARGS (args, &a) < 0)\n    goto fail_1_with_EINVAL;\n\n  {\n    size_t buf_neededlength;\n    TCHAR_T *buf;\n    TCHAR_T *buf_malloced;\n    const FCHAR_T *cp;\n    size_t i;\n    DIRECTIVE *dp;\n     \n    DCHAR_T *result;\n    size_t allocated;\n    size_t length;\n\n     \n    buf_neededlength =\n      xsum4 (7, d.max_width_length, d.max_precision_length, 6);\n#if HAVE_ALLOCA\n    if (buf_neededlength < 4000 / sizeof (TCHAR_T))\n      {\n        buf = (TCHAR_T *) alloca (buf_neededlength * sizeof (TCHAR_T));\n        buf_malloced = NULL;\n      }\n    else\n#endif\n      {\n        size_t buf_memsize = xtimes (buf_neededlength, sizeof (TCHAR_T));\n        if (size_overflow_p (buf_memsize))\n          goto out_of_memory_1;\n        buf = (TCHAR_T *) malloc (buf_memsize);\n        if (buf == NULL)\n          goto out_of_memory_1;\n        buf_malloced = buf;\n      }\n\n    result = resultbuf;\n    allocated = (resultbuf != NULL ? *lengthp : 0);\n    length = 0;\n     \n\n     \n#define ENSURE_ALLOCATION_ELSE(needed, oom_statement) \\\n    if ((needed) > allocated)                                                \\\n      {                                                                      \\\n        size_t memory_size;                                                  \\\n        DCHAR_T *memory;                                                     \\\n                                                                             \\\n        allocated = (allocated > 0 ? xtimes (allocated, 2) : 12);            \\\n        if ((needed) > allocated)                                            \\\n          allocated = (needed);                                              \\\n        memory_size = xtimes (allocated, sizeof (DCHAR_T));                  \\\n        if (size_overflow_p (memory_size))                                   \\\n          oom_statement                                                      \\\n        if (result == resultbuf)                                             \\\n          memory = (DCHAR_T *) malloc (memory_size);                         \\\n        else                                                                 \\\n          memory = (DCHAR_T *) realloc (result, memory_size);                \\\n        if (memory == NULL)                                                  \\\n          oom_statement                                                      \\\n        if (result == resultbuf && length > 0)                               \\\n          DCHAR_CPY (memory, result, length);                                \\\n        result = memory;                                                     \\\n      }\n#define ENSURE_ALLOCATION(needed) \\\n  ENSURE_ALLOCATION_ELSE((needed), goto out_of_memory; )\n\n    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)\n      {\n        if (cp != dp->dir_start)\n          {\n            size_t n = dp->dir_start - cp;\n            size_t augmented_length = xsum (length, n);\n\n            ENSURE_ALLOCATION (augmented_length);\n             \n            if (sizeof (FCHAR_T) == sizeof (DCHAR_T))\n              {\n                DCHAR_CPY (result + length, (const DCHAR_T *) cp, n);\n                length = augmented_length;\n              }\n            else\n              {\n                do\n                  result[length++] = *cp++;\n                while (--n > 0);\n              }\n          }\n        if (i == d.count)\n          break;\n\n         \n        if (dp->conversion == '%')\n          {\n            size_t augmented_length;\n\n            if (!(dp->arg_index == ARG_NONE))\n              abort ();\n            augmented_length = xsum (length, 1);\n            ENSURE_ALLOCATION (augmented_length);\n            result[length] = '%';\n            length = augmented_length;\n          }\n        else\n          {\n            if (!(dp->arg_index != ARG_NONE))\n              abort ();\n\n            if (dp->conversion == 'n')\n              {\n                switch (a.arg[dp->arg_index].type)\n                  {\n                  case TYPE_COUNT_SCHAR_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_schar_pointer = length;\n                    break;\n                  case TYPE_COUNT_SHORT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_short_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int_pointer = length;\n                    break;\n                  case TYPE_COUNT_LONGINT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_longint_pointer = length;\n                    break;\n                  case TYPE_COUNT_LONGLONGINT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_longlongint_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT8_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int8_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT16_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int16_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT32_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int32_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT64_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int64_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT_FAST8_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int_fast8_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT_FAST16_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int_fast16_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT_FAST32_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int_fast32_t_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT_FAST64_T_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int_fast64_t_pointer = length;\n                    break;\n                  default:\n                    abort ();\n                  }\n              }\n#if ENABLE_UNISTDIO\n             \n            else if (dp->conversion == 'U')\n              {\n                arg_type type = a.arg[dp->arg_index].type;\n                int flags = dp->flags;\n                int has_width;\n                size_t width;\n                int has_precision;\n                size_t precision;\n\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n\n                has_precision = 0;\n                precision = 0;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                         \n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n                switch (type)\n                  {\n                  case TYPE_U8_STRING:\n                    {\n                      const uint8_t *arg = a.arg[dp->arg_index].a.a_u8_string;\n                      const uint8_t *arg_end;\n                      size_t characters;\n\n                      if (has_precision)\n                        {\n                           \n                          arg_end = arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              int count = u8_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                goto fail_with_EILSEQ;\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else if (has_width)\n                        {\n                           \n                          arg_end = arg;\n                          characters = 0;\n                          for (;;)\n                            {\n                              int count = u8_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                goto fail_with_EILSEQ;\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                           \n                          arg_end = arg + u8_strlen (arg);\n                           \n                          characters = 0;\n                        }\n\n                      if (characters < width && !(flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n\n# if DCHAR_IS_UINT8_T\n                      {\n                        size_t n = arg_end - arg;\n                        ENSURE_ALLOCATION (xsum (length, n));\n                        DCHAR_CPY (result + length, arg, n);\n                        length += n;\n                      }\n# else\n                      {  \n                        DCHAR_T *converted = result + length;\n                        size_t converted_len = allocated - length;\n#  if DCHAR_IS_TCHAR\n                         \n                        converted =\n                          u8_conv_to_encoding (locale_charset (),\n                                               iconveh_question_mark,\n                                               arg, arg_end - arg, NULL,\n                                               converted, &converted_len);\n#  else\n                         \n                        converted =\n                          U8_TO_DCHAR (arg, arg_end - arg,\n                                       converted, &converted_len);\n#  endif\n                        if (converted == NULL)\n                          goto fail_with_errno;\n                        if (converted != result + length)\n                          {\n                            ENSURE_ALLOCATION_ELSE (xsum (length, converted_len),\n                                                    { free (converted); goto out_of_memory; });\n                            DCHAR_CPY (result + length, converted, converted_len);\n                            free (converted);\n                          }\n                        length += converted_len;\n                      }\n# endif\n\n                      if (characters < width && (flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n                    }\n                    break;\n\n                  case TYPE_U16_STRING:\n                    {\n                      const uint16_t *arg = a.arg[dp->arg_index].a.a_u16_string;\n                      const uint16_t *arg_end;\n                      size_t characters;\n\n                      if (has_precision)\n                        {\n                           \n                          arg_end = arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              int count = u16_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                goto fail_with_EILSEQ;\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else if (has_width)\n                        {\n                           \n                          arg_end = arg;\n                          characters = 0;\n                          for (;;)\n                            {\n                              int count = u16_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                goto fail_with_EILSEQ;\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                           \n                          arg_end = arg + u16_strlen (arg);\n                           \n                          characters = 0;\n                        }\n\n                      if (characters < width && !(flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n\n# if DCHAR_IS_UINT16_T\n                      {\n                        size_t n = arg_end - arg;\n                        ENSURE_ALLOCATION (xsum (length, n));\n                        DCHAR_CPY (result + length, arg, n);\n                        length += n;\n                      }\n# else\n                      {  \n                        DCHAR_T *converted = result + length;\n                        size_t converted_len = allocated - length;\n#  if DCHAR_IS_TCHAR\n                         \n                        converted =\n                          u16_conv_to_encoding (locale_charset (),\n                                                iconveh_question_mark,\n                                                arg, arg_end - arg, NULL,\n                                                converted, &converted_len);\n#  else\n                         \n                        converted =\n                          U16_TO_DCHAR (arg, arg_end - arg,\n                                        converted, &converted_len);\n#  endif\n                        if (converted == NULL)\n                          goto fail_with_errno;\n                        if (converted != result + length)\n                          {\n                            ENSURE_ALLOCATION_ELSE (xsum (length, converted_len),\n                                                    { free (converted); goto out_of_memory; });\n                            DCHAR_CPY (result + length, converted, converted_len);\n                            free (converted);\n                          }\n                        length += converted_len;\n                      }\n# endif\n\n                      if (characters < width && (flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n                    }\n                    break;\n\n                  case TYPE_U32_STRING:\n                    {\n                      const uint32_t *arg = a.arg[dp->arg_index].a.a_u32_string;\n                      const uint32_t *arg_end;\n                      size_t characters;\n\n                      if (has_precision)\n                        {\n                           \n                          arg_end = arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              int count = u32_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                goto fail_with_EILSEQ;\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else if (has_width)\n                        {\n                           \n                          arg_end = arg;\n                          characters = 0;\n                          for (;;)\n                            {\n                              int count = u32_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                goto fail_with_EILSEQ;\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                           \n                          arg_end = arg + u32_strlen (arg);\n                           \n                          characters = 0;\n                        }\n\n                      if (characters < width && !(flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n\n# if DCHAR_IS_UINT32_T\n                      {\n                        size_t n = arg_end - arg;\n                        ENSURE_ALLOCATION (xsum (length, n));\n                        DCHAR_CPY (result + length, arg, n);\n                        length += n;\n                      }\n# else\n                      {  \n                        DCHAR_T *converted = result + length;\n                        size_t converted_len = allocated - length;\n#  if DCHAR_IS_TCHAR\n                         \n                        converted =\n                          u32_conv_to_encoding (locale_charset (),\n                                                iconveh_question_mark,\n                                                arg, arg_end - arg, NULL,\n                                                converted, &converted_len);\n#  else\n                         \n                        converted =\n                          U32_TO_DCHAR (arg, arg_end - arg,\n                                        converted, &converted_len);\n#  endif\n                        if (converted == NULL)\n                          goto fail_with_errno;\n                        if (converted != result + length)\n                          {\n                            ENSURE_ALLOCATION_ELSE (xsum (length, converted_len),\n                                                    { free (converted); goto out_of_memory; });\n                            DCHAR_CPY (result + length, converted, converted_len);\n                            free (converted);\n                          }\n                        length += converted_len;\n                      }\n# endif\n\n                      if (characters < width && (flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n                    }\n                    break;\n\n                  default:\n                    abort ();\n                  }\n              }\n#endif\n#if WIDE_CHAR_VERSION && (!DCHAR_IS_TCHAR || NEED_WPRINTF_DIRECTIVE_LC)\n            else if ((dp->conversion == 's'\n                      && a.arg[dp->arg_index].type == TYPE_WIDE_STRING)\n                     || (dp->conversion == 'c'\n                         && a.arg[dp->arg_index].type == TYPE_WIDE_CHAR))\n              {\n                 \n                 \n                int flags = dp->flags;\n                size_t width;\n\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                  }\n\n                {\n                  const wchar_t *ls_arg;\n                  wchar_t lc_arg[1];\n                  size_t characters;\n\n                  if (dp->conversion == 's')\n                    {\n                      int has_precision;\n                      size_t precision;\n\n                      has_precision = 0;\n                      precision = 6;\n                      if (dp->precision_start != dp->precision_end)\n                        {\n                          if (dp->precision_arg_index != ARG_NONE)\n                            {\n                              int arg;\n\n                              if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                                abort ();\n                              arg = a.arg[dp->precision_arg_index].a.a_int;\n                               \n                              if (arg >= 0)\n                                {\n                                  precision = arg;\n                                  has_precision = 1;\n                                }\n                            }\n                          else\n                            {\n                              const FCHAR_T *digitp = dp->precision_start + 1;\n\n                              precision = 0;\n                              while (digitp != dp->precision_end)\n                                precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                              has_precision = 1;\n                            }\n                        }\n\n                      ls_arg = a.arg[dp->arg_index].a.a_wide_string;\n\n                      if (has_precision)\n                        {\n                           \n                          const wchar_t *ls_arg_end;\n\n                          ls_arg_end = ls_arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              if (*ls_arg_end == 0)\n                                 \n                                break;\n                              ls_arg_end++;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                           \n                          characters = local_wcslen (ls_arg);\n                        }\n                    }\n                  else  \n                    {\n                      lc_arg[0] = (wchar_t) a.arg[dp->arg_index].a.a_wide_char;\n                      ls_arg = lc_arg;\n                      characters = 1;\n                    }\n\n                  {\n                    size_t total = (characters < width ? width : characters);\n                    ENSURE_ALLOCATION (xsum (length, total));\n\n                    if (characters < width && !(flags & FLAG_LEFT))\n                      {\n                        size_t n = width - characters;\n                        DCHAR_SET (result + length, ' ', n);\n                        length += n;\n                      }\n\n                    if (characters > 0)\n                      {\n                        DCHAR_CPY (result + length, ls_arg, characters);\n                        length += characters;\n                      }\n\n                    if (characters < width && (flags & FLAG_LEFT))\n                      {\n                        size_t n = width - characters;\n                        DCHAR_SET (result + length, ' ', n);\n                        length += n;\n                      }\n                  }\n                }\n              }\n#endif\n#if (!USE_SNPRINTF || WIDE_CHAR_VERSION || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_DIRECTIVE_LS || ENABLE_WCHAR_FALLBACK) && HAVE_WCHAR_T\n            else if (dp->conversion == 's'\n# if WIDE_CHAR_VERSION\n                     && a.arg[dp->arg_index].type != TYPE_WIDE_STRING\n# else\n                     && a.arg[dp->arg_index].type == TYPE_WIDE_STRING\n# endif\n                    )\n              {\n                 \n                int flags = dp->flags;\n                int has_width;\n                size_t width;\n                int has_precision;\n                size_t precision;\n\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                         \n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n# if WIDE_CHAR_VERSION\n                 \n                {\n                  const char *arg = a.arg[dp->arg_index].a.a_string;\n                  const char *arg_end;\n                  size_t characters;\n\n                  if (has_precision)\n                    {\n                       \n#  if HAVE_MBRTOWC\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n                      arg_end = arg;\n                      characters = 0;\n                      for (; precision > 0; precision--)\n                        {\n                          int count;\n#  if HAVE_MBRTOWC\n                          count = mbrlen (arg_end, MB_CUR_MAX, &state);\n#  else\n                          count = mblen (arg_end, MB_CUR_MAX);\n#  endif\n                          if (count == 0)\n                             \n                            break;\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          arg_end += count;\n                          characters++;\n                        }\n                    }\n                  else if (has_width)\n                    {\n                       \n#  if HAVE_MBRTOWC\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n                      arg_end = arg;\n                      characters = 0;\n                      for (;;)\n                        {\n                          int count;\n#  if HAVE_MBRTOWC\n                          count = mbrlen (arg_end, MB_CUR_MAX, &state);\n#  else\n                          count = mblen (arg_end, MB_CUR_MAX);\n#  endif\n                          if (count == 0)\n                             \n                            break;\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          arg_end += count;\n                          characters++;\n                        }\n                    }\n                  else\n                    {\n                       \n                      arg_end = arg + strlen (arg);\n                       \n                      characters = 0;\n                    }\n\n                  if (characters < width && !(flags & FLAG_LEFT))\n                    {\n                      size_t n = width - characters;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n\n                  if (has_precision || has_width)\n                    {\n                       \n                      size_t remaining;\n#  if HAVE_MBRTOWC\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n                      ENSURE_ALLOCATION (xsum (length, characters));\n                      for (remaining = characters; remaining > 0; remaining--)\n                        {\n                          wchar_t wc;\n                          int count;\n#  if HAVE_MBRTOWC\n                          count = mbrtowc (&wc, arg, arg_end - arg, &state);\n#  else\n                          count = mbtowc (&wc, arg, arg_end - arg);\n#  endif\n                          if (count <= 0)\n                             \n                            abort ();\n                          result[length++] = wc;\n                          arg += count;\n                        }\n                      if (!(arg == arg_end))\n                        abort ();\n                    }\n                  else\n                    {\n#  if HAVE_MBRTOWC\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n                      while (arg < arg_end)\n                        {\n                          wchar_t wc;\n                          int count;\n#  if HAVE_MBRTOWC\n                          count = mbrtowc (&wc, arg, arg_end - arg, &state);\n#  else\n                          count = mbtowc (&wc, arg, arg_end - arg);\n#  endif\n                          if (count == 0)\n                             \n                            abort ();\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          ENSURE_ALLOCATION (xsum (length, 1));\n                          result[length++] = wc;\n                          arg += count;\n                        }\n                    }\n\n                  if (characters < width && (flags & FLAG_LEFT))\n                    {\n                      size_t n = width - characters;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n                }\n# else\n                 \n                {\n                  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                  const wchar_t *arg_end;\n                  size_t characters;\n#  if !DCHAR_IS_TCHAR\n                   \n                  static_assert (sizeof (TCHAR_T) == 1);\n                  TCHAR_T *tmpsrc;\n                  DCHAR_T *tmpdst;\n                  size_t tmpdst_len;\n#  endif\n                  size_t w;\n\n                  if (has_precision)\n                    {\n                       \n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n                      arg_end = arg;\n                      characters = 0;\n                      while (precision > 0)\n                        {\n                          char cbuf[64];  \n                          int count;\n\n                          if (*arg_end == 0)\n                             \n                            break;\n                          count = local_wcrtomb (cbuf, *arg_end, &state);\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          if (precision < (unsigned int) count)\n                            break;\n                          arg_end++;\n                          characters += count;\n                          precision -= count;\n                        }\n                    }\n#  if DCHAR_IS_TCHAR\n                  else if (has_width)\n#  else\n                  else\n#  endif\n                    {\n                       \n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n                      arg_end = arg;\n                      characters = 0;\n                      for (;;)\n                        {\n                          char cbuf[64];  \n                          int count;\n\n                          if (*arg_end == 0)\n                             \n                            break;\n                          count = local_wcrtomb (cbuf, *arg_end, &state);\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          arg_end++;\n                          characters += count;\n                        }\n                    }\n#  if DCHAR_IS_TCHAR\n                  else\n                    {\n                       \n                      arg_end = arg + local_wcslen (arg);\n                       \n                      characters = 0;\n                    }\n#  endif\n\n#  if !DCHAR_IS_TCHAR\n                   \n                  tmpsrc = (TCHAR_T *) malloc (characters * sizeof (TCHAR_T));\n                  if (tmpsrc == NULL)\n                    goto out_of_memory;\n                  {\n                    TCHAR_T *tmpptr = tmpsrc;\n                    size_t remaining;\n#   if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                    mbstate_t state;\n                    mbszero (&state);\n#   endif\n                    for (remaining = characters; remaining > 0; )\n                      {\n                        char cbuf[64];  \n                        int count;\n\n                        if (*arg == 0)\n                          abort ();\n                        count = local_wcrtomb (cbuf, *arg, &state);\n                        if (count <= 0)\n                           \n                          abort ();\n                        memcpy (tmpptr, cbuf, count);\n                        tmpptr += count;\n                        arg++;\n                        remaining -= count;\n                      }\n                    if (!(arg == arg_end))\n                      abort ();\n                  }\n\n                   \n                  tmpdst =\n                    DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                              iconveh_question_mark,\n                                              tmpsrc, characters,\n                                              NULL,\n                                              NULL, &tmpdst_len);\n                  if (tmpdst == NULL)\n                    {\n                      free (tmpsrc);\n                      goto fail_with_errno;\n                    }\n                  free (tmpsrc);\n#  endif\n\n                  if (has_width)\n                    {\n#  if ENABLE_UNISTDIO\n                       \n                      w = DCHAR_MBSNLEN (result + length, characters);\n#  else\n                       \n                      w = characters;\n#  endif\n                    }\n                  else\n                     \n                    w = 0;\n\n                  if (w < width && !(flags & FLAG_LEFT))\n                    {\n                      size_t n = width - w;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n\n#  if DCHAR_IS_TCHAR\n                  if (has_precision || has_width)\n                    {\n                       \n                      size_t remaining;\n#   if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                      mbstate_t state;\n                      mbszero (&state);\n#   endif\n                      ENSURE_ALLOCATION (xsum (length, characters));\n                      for (remaining = characters; remaining > 0; )\n                        {\n                          char cbuf[64];  \n                          int count;\n\n                          if (*arg == 0)\n                            abort ();\n                          count = local_wcrtomb (cbuf, *arg, &state);\n                          if (count <= 0)\n                             \n                            abort ();\n                          memcpy (result + length, cbuf, count);\n                          length += count;\n                          arg++;\n                          remaining -= count;\n                        }\n                      if (!(arg == arg_end))\n                        abort ();\n                    }\n                  else\n                    {\n#   if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                      mbstate_t state;\n                      mbszero (&state);\n#   endif\n                      while (arg < arg_end)\n                        {\n                          char cbuf[64];  \n                          int count;\n\n                          if (*arg == 0)\n                            abort ();\n                          count = local_wcrtomb (cbuf, *arg, &state);\n                          if (count <= 0)\n                             \n                            goto fail_with_EILSEQ;\n                          ENSURE_ALLOCATION (xsum (length, count));\n                          memcpy (result + length, cbuf, count);\n                          length += count;\n                          arg++;\n                        }\n                    }\n#  else\n                  ENSURE_ALLOCATION_ELSE (xsum (length, tmpdst_len),\n                                          { free (tmpdst); goto out_of_memory; });\n                  DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                  free (tmpdst);\n                  length += tmpdst_len;\n#  endif\n\n                  if (w < width && (flags & FLAG_LEFT))\n                    {\n                      size_t n = width - w;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n                }\n# endif\n              }\n#endif\n#if (NEED_PRINTF_DIRECTIVE_LC || ENABLE_WCHAR_FALLBACK) && HAVE_WINT_T && !WIDE_CHAR_VERSION\n            else if (dp->conversion == 'c'\n                     && a.arg[dp->arg_index].type == TYPE_WIDE_CHAR)\n              {\n                 \n                int flags = dp->flags;\n                int has_width;\n                size_t width;\n\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n\n                 \n                {\n                  wchar_t arg = (wchar_t) a.arg[dp->arg_index].a.a_wide_char;\n                  size_t characters;\n# if !DCHAR_IS_TCHAR\n                   \n                  static_assert (sizeof (TCHAR_T) == 1);\n                  TCHAR_T tmpsrc[64];  \n                  DCHAR_T *tmpdst;\n                  size_t tmpdst_len;\n# endif\n                  size_t w;\n\n# if DCHAR_IS_TCHAR\n                  if (has_width)\n# endif\n                    {\n                       \n                      characters = 0;\n                      if (arg != 0)\n                        {\n                          char cbuf[64];  \n                          int count;\n# if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                          mbstate_t state;\n                          mbszero (&state);\n# endif\n\n                          count = local_wcrtomb (cbuf, arg, &state);\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          characters = count;\n                        }\n                    }\n# if DCHAR_IS_TCHAR\n                  else\n                    {\n                       \n                      characters = 0;\n                    }\n# endif\n\n# if !DCHAR_IS_TCHAR\n                   \n                  if (characters > 0)  \n                    {\n                      char cbuf[64];  \n                      int count;\n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                      mbstate_t state;\n                      mbszero (&state);\n#  endif\n\n                      count = local_wcrtomb (cbuf, arg, &state);\n                      if (count <= 0)\n                         \n                        abort ();\n                      memcpy (tmpsrc, cbuf, count);\n                    }\n\n                   \n                  tmpdst =\n                    DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                              iconveh_question_mark,\n                                              tmpsrc, characters,\n                                              NULL,\n                                              NULL, &tmpdst_len);\n                  if (tmpdst == NULL)\n                    goto fail_with_errno;\n# endif\n\n                  if (has_width)\n                    {\n# if ENABLE_UNISTDIO\n                       \n                      w = DCHAR_MBSNLEN (result + length, characters);\n# else\n                       \n                      w = characters;\n# endif\n                    }\n                  else\n                     \n                    w = 0;\n\n                  if (w < width && !(flags & FLAG_LEFT))\n                    {\n                      size_t n = width - w;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n\n# if DCHAR_IS_TCHAR\n                  if (has_width)\n                    {\n                       \n                      ENSURE_ALLOCATION (xsum (length, characters));\n                      if (characters > 0)  \n                        {\n                          int count;\n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                          mbstate_t state;\n                          mbszero (&state);\n#  endif\n\n                          count = local_wcrtomb (result + length, arg, &state);\n                          if (count <= 0)\n                             \n                            abort ();\n                          length += count;\n                        }\n                    }\n                  else\n                    {\n                      if (arg != 0)\n                        {\n                          char cbuf[64];  \n                          int count;\n#  if HAVE_WCRTOMB && !defined GNULIB_defined_mbstate_t\n                          mbstate_t state;\n                          mbszero (&state);\n#  endif\n\n                          count = local_wcrtomb (cbuf, arg, &state);\n                          if (count < 0)\n                             \n                            goto fail_with_EILSEQ;\n                          ENSURE_ALLOCATION (xsum (length, count));\n                          memcpy (result + length, cbuf, count);\n                          length += count;\n                        }\n                    }\n# else\n                  ENSURE_ALLOCATION_ELSE (xsum (length, tmpdst_len),\n                                          { free (tmpdst); goto out_of_memory; });\n                  DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                  free (tmpdst);\n                  length += tmpdst_len;\n# endif\n\n                  if (w < width && (flags & FLAG_LEFT))\n                    {\n                      size_t n = width - w;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n                }\n              }\n#endif\n#if NEED_WPRINTF_DIRECTIVE_C && WIDE_CHAR_VERSION\n            else if (dp->conversion == 'c'\n                     && a.arg[dp->arg_index].type != TYPE_WIDE_CHAR)\n              {\n                 \n                int flags = dp->flags;\n                size_t width;\n\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                  }\n\n                 \n                {\n                  char arg = (char) a.arg[dp->arg_index].a.a_char;\n                  mbstate_t state;\n                  wchar_t wc;\n\n                  mbszero (&state);\n                  int count = mbrtowc (&wc, &arg, 1, &state);\n                  if (count < 0)\n                     \n                    goto fail_with_EILSEQ;\n\n                  if (1 < width && !(flags & FLAG_LEFT))\n                    {\n                      size_t n = width - 1;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n\n                  ENSURE_ALLOCATION (xsum (length, 1));\n                  result[length++] = wc;\n\n                  if (1 < width && (flags & FLAG_LEFT))\n                    {\n                      size_t n = width - 1;\n                      ENSURE_ALLOCATION (xsum (length, n));\n                      DCHAR_SET (result + length, ' ', n);\n                      length += n;\n                    }\n                }\n              }\n#endif\n#if NEED_PRINTF_DIRECTIVE_B || NEED_PRINTF_DIRECTIVE_UPPERCASE_B\n            else if (0\n# if NEED_PRINTF_DIRECTIVE_B\n                     || (dp->conversion == 'b')\n# endif\n# if NEED_PRINTF_DIRECTIVE_UPPERCASE_B\n                     || (dp->conversion == 'B')\n# endif\n                    )\n              {\n                arg_type type = a.arg[dp->arg_index].type;\n                int flags = dp->flags;\n                int has_width;\n                size_t width;\n                int has_precision;\n                size_t precision;\n                size_t tmp_length;\n                size_t count;\n                DCHAR_T tmpbuf[700];\n                DCHAR_T *tmp;\n                DCHAR_T *tmp_end;\n                DCHAR_T *tmp_start;\n                DCHAR_T *pad_ptr;\n                DCHAR_T *p;\n\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n\n                has_precision = 0;\n                precision = 1;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                         \n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n                 \n                switch (type)\n                  {\n                  default:\n                    tmp_length =\n                      (unsigned int) (sizeof (unsigned int) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_ULONGINT:\n                    tmp_length =\n                      (unsigned int) (sizeof (unsigned long int) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_ULONGLONGINT:\n                    tmp_length =\n                      (unsigned int) (sizeof (unsigned long long int) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT8_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint8_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT16_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint16_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT32_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint32_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT64_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint64_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT_FAST8_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint_fast8_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT_FAST16_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint_fast16_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT_FAST32_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint_fast32_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  case TYPE_UINT_FAST64_T:\n                    tmp_length =\n                      (unsigned int) (sizeof (uint_fast64_t) * CHAR_BIT)\n                      + 1;  \n                    break;\n                  }\n                if (tmp_length < precision)\n                  tmp_length = precision;\n                 \n                tmp_length = xsum (tmp_length, 2);\n\n                if (tmp_length < width)\n                  tmp_length = width;\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                       \n                      goto out_of_memory;\n                    tmp = (DCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                       \n                      goto out_of_memory;\n                  }\n\n                tmp_end = tmp + tmp_length;\n\n                unsigned long long arg;\n                switch (type)\n                  {\n                  case TYPE_UCHAR:\n                    arg = a.arg[dp->arg_index].a.a_uchar;\n                    break;\n                  case TYPE_USHORT:\n                    arg = a.arg[dp->arg_index].a.a_ushort;\n                    break;\n                  case TYPE_UINT:\n                    arg = a.arg[dp->arg_index].a.a_uint;\n                    break;\n                  case TYPE_ULONGINT:\n                    arg = a.arg[dp->arg_index].a.a_ulongint;\n                    break;\n                  case TYPE_ULONGLONGINT:\n                    arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                    break;\n                  case TYPE_UINT8_T:\n                    arg = a.arg[dp->arg_index].a.a_uint8_t;\n                    break;\n                  case TYPE_UINT16_T:\n                    arg = a.arg[dp->arg_index].a.a_uint16_t;\n                    break;\n                  case TYPE_UINT32_T:\n                    arg = a.arg[dp->arg_index].a.a_uint32_t;\n                    break;\n                  case TYPE_UINT64_T:\n                    arg = a.arg[dp->arg_index].a.a_uint64_t;\n                    break;\n                  case TYPE_UINT_FAST8_T:\n                    arg = a.arg[dp->arg_index].a.a_uint_fast8_t;\n                    break;\n                  case TYPE_UINT_FAST16_T:\n                    arg = a.arg[dp->arg_index].a.a_uint_fast16_t;\n                    break;\n                  case TYPE_UINT_FAST32_T:\n                    arg = a.arg[dp->arg_index].a.a_uint_fast32_t;\n                    break;\n                  case TYPE_UINT_FAST64_T:\n                    arg = a.arg[dp->arg_index].a.a_uint_fast64_t;\n                    break;\n                  default:\n                    abort ();\n                  }\n                int need_prefix = ((flags & FLAG_ALT) && arg != 0);\n\n                p = tmp_end;\n                 \n                if (!(has_precision && precision == 0 && arg == 0))\n                  {\n                    do\n                      {\n                        *--p = '0' + (arg & 1);\n                        arg = arg >> 1;\n                      }\n                    while (arg != 0);\n                  }\n\n                if (has_precision)\n                  {\n                    DCHAR_T *digits_start = tmp_end - precision;\n                    while (p > digits_start)\n                      *--p = '0';\n                  }\n\n                pad_ptr = p;\n\n                if (need_prefix)\n                  {\n# if NEED_PRINTF_DIRECTIVE_B && !NEED_PRINTF_DIRECTIVE_UPPERCASE_B\n                    *--p = 'b';\n# elif NEED_PRINTF_DIRECTIVE_UPPERCASE_B && !NEED_PRINTF_DIRECTIVE_B\n                    *--p = 'B';\n# else\n                    *--p = dp->conversion;\n# endif\n                    *--p = '0';\n                  }\n                tmp_start = p;\n\n                 \n                count = tmp_end - tmp_start;\n\n                if (count < width)\n                  {\n                    size_t pad = width - count;\n\n                    if (flags & FLAG_LEFT)\n                      {\n                         \n                        for (p = tmp_start; p < tmp_end; p++)\n                          *(p - pad) = *p;\n                        for (p = tmp_end - pad; p < tmp_end; p++)\n                          *p = ' ';\n                      }\n                    else if ((flags & FLAG_ZERO)\n                              \n                             && !(has_width && has_precision))\n                      {\n                         \n                        for (p = tmp_start; p < pad_ptr; p++)\n                          *(p - pad) = *p;\n                        for (p = pad_ptr - pad; p < pad_ptr; p++)\n                          *p = '0';\n                      }\n                    else\n                      {\n                         \n                        for (p = tmp_start - pad; p < tmp_start; p++)\n                          *p = ' ';\n                      }\n\n                    tmp_start = tmp_start - pad;\n                  }\n\n                count = tmp_end - tmp_start;\n\n                if (count > tmp_length)\n                   \n                  abort ();\n\n                 \n                if (count >= allocated - length)\n                  {\n                    size_t n = xsum (length, count);\n\n                    ENSURE_ALLOCATION (n);\n                  }\n\n                 \n                memcpy (result + length, tmp_start, count * sizeof (DCHAR_T));\n                if (tmp != tmpbuf)\n                  free (tmp);\n                length += count;\n              }\n#endif\n#if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n            else if ((dp->conversion == 'a' || dp->conversion == 'A')\n# if !(NEED_PRINTF_DIRECTIVE_A || (NEED_PRINTF_LONG_DOUBLE && NEED_PRINTF_DOUBLE))\n                     && (0\n#  if NEED_PRINTF_DOUBLE\n                         || a.arg[dp->arg_index].type == TYPE_DOUBLE\n#  endif\n#  if NEED_PRINTF_LONG_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n                         || a.arg[dp->arg_index].type == TYPE_LONGDOUBLE\n#  endif\n                        )\n# endif\n                    )\n              {\n                arg_type type = a.arg[dp->arg_index].type;\n                int flags = dp->flags;\n                size_t width;\n                int has_precision;\n                size_t precision;\n                size_t tmp_length;\n                size_t count;\n                DCHAR_T tmpbuf[700];\n                DCHAR_T *tmp;\n                DCHAR_T *pad_ptr;\n                DCHAR_T *p;\n\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                  }\n\n                has_precision = 0;\n                precision = 0;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                         \n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n                 \n                if (type == TYPE_LONGDOUBLE)\n                  tmp_length =\n                    (unsigned int) ((LDBL_DIG + 1)\n                                    * 0.831  \n                                   )\n                    + 1;  \n                else\n                  tmp_length =\n                    (unsigned int) ((DBL_DIG + 1)\n                                    * 0.831  \n                                   )\n                    + 1;  \n                if (tmp_length < precision)\n                  tmp_length = precision;\n                 \n                tmp_length = xsum (tmp_length, 12);\n\n                if (tmp_length < width)\n                  tmp_length = width;\n\n                tmp_length = xsum (tmp_length, 1);  \n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                       \n                      goto out_of_memory;\n                    tmp = (DCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                       \n                      goto out_of_memory;\n                  }\n\n                pad_ptr = NULL;\n                p = tmp;\n                if (type == TYPE_LONGDOUBLE)\n                  {\n# if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || (NEED_WPRINTF_DIRECTIVE_LA && WIDE_CHAR_VERSION)\n                    long double arg = a.arg[dp->arg_index].a.a_longdouble;\n\n                    if (isnanl (arg))\n                      {\n                        if (dp->conversion == 'A')\n                          {\n                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';\n                          }\n                        else\n                          {\n                            *p++ = 'n'; *p++ = 'a'; *p++ = 'n';\n                          }\n                      }\n                    else\n                      {\n                        int sign = 0;\n                        DECL_LONG_DOUBLE_ROUNDING\n\n                        BEGIN_LONG_DOUBLE_ROUNDING ();\n\n                        if (signbit (arg))  \n                          {\n                            sign = -1;\n                            arg = -arg;\n                          }\n\n                        if (sign < 0)\n                          *p++ = '-';\n                        else if (flags & FLAG_SHOWSIGN)\n                          *p++ = '+';\n                        else if (flags & FLAG_SPACE)\n                          *p++ = ' ';\n\n                        if (arg > 0.0L && arg + arg == arg)\n                          {\n                            if (dp->conversion == 'A')\n                              {\n                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';\n                              }\n                            else\n                              {\n                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';\n                              }\n                          }\n                        else\n                          {\n                            int exponent;\n                            long double mantissa;\n\n                            if (arg > 0.0L)\n                              mantissa = printf_frexpl (arg, &exponent);\n                            else\n                              {\n                                exponent = 0;\n                                mantissa = 0.0L;\n                              }\n\n                            if (has_precision\n                                && precision < (unsigned int) ((LDBL_DIG + 1) * 0.831) + 1)\n                              {\n                                 \n                                long double tail = mantissa;\n                                size_t q;\n\n                                for (q = precision; ; q--)\n                                  {\n                                    int digit = (int) tail;\n                                    tail -= digit;\n                                    if (q == 0)\n                                      {\n                                        if (digit & 1 ? tail >= 0.5L : tail > 0.5L)\n                                          tail = 1 - tail;\n                                        else\n                                          tail = - tail;\n                                        break;\n                                      }\n                                    tail *= 16.0L;\n                                  }\n                                if (tail != 0.0L)\n                                  for (q = precision; q > 0; q--)\n                                    tail *= 0.0625L;\n                                mantissa += tail;\n                              }\n\n                            *p++ = '0';\n                            *p++ = dp->conversion - 'A' + 'X';\n                            pad_ptr = p;\n                            {\n                              int digit;\n\n                              digit = (int) mantissa;\n                              mantissa -= digit;\n                              *p++ = '0' + digit;\n                              if ((flags & FLAG_ALT)\n                                  || mantissa > 0.0L || precision > 0)\n                                {\n                                  *p++ = decimal_point_char ();\n                                   \n                                  while (mantissa > 0.0L)\n                                    {\n                                      mantissa *= 16.0L;\n                                      digit = (int) mantissa;\n                                      mantissa -= digit;\n                                      *p++ = digit\n                                             + (digit < 10\n                                                ? '0'\n                                                : dp->conversion - 10);\n                                      if (precision > 0)\n                                        precision--;\n                                    }\n                                  while (precision > 0)\n                                    {\n                                      *p++ = '0';\n                                      precision--;\n                                    }\n                                }\n                              }\n                              *p++ = dp->conversion - 'A' + 'P';\n#  if WIDE_CHAR_VERSION && DCHAR_IS_TCHAR\n                              {\n                                static const wchar_t decimal_format[] =\n                                  { '%', '+', 'd', '\\0' };\n                                SNPRINTF (p, 6 + 1, decimal_format, exponent);\n                              }\n                              while (*p != '\\0')\n                                p++;\n#  else\n                              if (sizeof (DCHAR_T) == 1)\n                                {\n                                  sprintf ((char *) p, \"%+d\", exponent);\n                                  while (*p != '\\0')\n                                    p++;\n                                }\n                              else\n                                {\n                                  char expbuf[6 + 1];\n                                  const char *ep;\n                                  sprintf (expbuf, \"%+d\", exponent);\n                                  for (ep = expbuf; (*p = *ep) != '\\0'; ep++)\n                                    p++;\n                                }\n#  endif\n                          }\n\n                        END_LONG_DOUBLE_ROUNDING ();\n                      }\n# else\n                    abort ();\n# endif\n                  }\n                else\n                  {\n# if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE\n                    double arg = a.arg[dp->arg_index].a.a_double;\n\n                    if (isnand (arg))\n                      {\n                        if (dp->conversion == 'A')\n                          {\n                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';\n                          }\n                        else\n                          {\n                            *p++ = 'n'; *p++ = 'a'; *p++ = 'n';\n                          }\n                      }\n                    else\n                      {\n                        int sign = 0;\n\n                        if (signbit (arg))  \n                          {\n                            sign = -1;\n                            arg = -arg;\n                          }\n\n                        if (sign < 0)\n                          *p++ = '-';\n                        else if (flags & FLAG_SHOWSIGN)\n                          *p++ = '+';\n                        else if (flags & FLAG_SPACE)\n                          *p++ = ' ';\n\n                        if (arg > 0.0 && arg + arg == arg)\n                          {\n                            if (dp->conversion == 'A')\n                              {\n                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';\n                              }\n                            else\n                              {\n                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';\n                              }\n                          }\n                        else\n                          {\n                            int exponent;\n                            double mantissa;\n\n                            if (arg > 0.0)\n                              mantissa = printf_frexp (arg, &exponent);\n                            else\n                              {\n                                exponent = 0;\n                                mantissa = 0.0;\n                              }\n\n                            if (has_precision\n                                && precision < (unsigned int) ((DBL_DIG + 1) * 0.831) + 1)\n                              {\n                                 \n                                double tail = mantissa;\n                                size_t q;\n\n                                for (q = precision; ; q--)\n                                  {\n                                    int digit = (int) tail;\n                                    tail -= digit;\n                                    if (q == 0)\n                                      {\n                                        if (digit & 1 ? tail >= 0.5 : tail > 0.5)\n                                          tail = 1 - tail;\n                                        else\n                                          tail = - tail;\n                                        break;\n                                      }\n                                    tail *= 16.0;\n                                  }\n                                if (tail != 0.0)\n                                  for (q = precision; q > 0; q--)\n                                    tail *= 0.0625;\n                                mantissa += tail;\n                              }\n\n                            *p++ = '0';\n                            *p++ = dp->conversion - 'A' + 'X';\n                            pad_ptr = p;\n                            {\n                              int digit;\n\n                              digit = (int) mantissa;\n                              mantissa -= digit;\n                              *p++ = '0' + digit;\n                              if ((flags & FLAG_ALT)\n                                  || mantissa > 0.0 || precision > 0)\n                                {\n                                  *p++ = decimal_point_char ();\n                                   \n                                  while (mantissa > 0.0)\n                                    {\n                                      mantissa *= 16.0;\n                                      digit = (int) mantissa;\n                                      mantissa -= digit;\n                                      *p++ = digit\n                                             + (digit < 10\n                                                ? '0'\n                                                : dp->conversion - 10);\n                                      if (precision > 0)\n                                        precision--;\n                                    }\n                                  while (precision > 0)\n                                    {\n                                      *p++ = '0';\n                                      precision--;\n                                    }\n                                }\n                              }\n                              *p++ = dp->conversion - 'A' + 'P';\n#  if WIDE_CHAR_VERSION && DCHAR_IS_TCHAR\n                              {\n                                static const wchar_t decimal_format[] =\n                                  { '%', '+', 'd', '\\0' };\n                                SNPRINTF (p, 6 + 1, decimal_format, exponent);\n                              }\n                              while (*p != '\\0')\n                                p++;\n#  else\n                              if (sizeof (DCHAR_T) == 1)\n                                {\n                                  sprintf ((char *) p, \"%+d\", exponent);\n                                  while (*p != '\\0')\n                                    p++;\n                                }\n                              else\n                                {\n                                  char expbuf[6 + 1];\n                                  const char *ep;\n                                  sprintf (expbuf, \"%+d\", exponent);\n                                  for (ep = expbuf; (*p = *ep) != '\\0'; ep++)\n                                    p++;\n                                }\n#  endif\n                          }\n                      }\n# else\n                    abort ();\n# endif\n                  }\n\n                 \n                count = p - tmp;\n\n                if (count < width)\n                  {\n                    size_t pad = width - count;\n                    DCHAR_T *end = p + pad;\n\n                    if (flags & FLAG_LEFT)\n                      {\n                         \n                        for (; pad > 0; pad--)\n                          *p++ = ' ';\n                      }\n                    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                      {\n                         \n                        DCHAR_T *q = end;\n\n                        while (p > pad_ptr)\n                          *--q = *--p;\n                        for (; pad > 0; pad--)\n                          *p++ = '0';\n                      }\n                    else\n                      {\n                         \n                        DCHAR_T *q = end;\n\n                        while (p > tmp)\n                          *--q = *--p;\n                        for (; pad > 0; pad--)\n                          *p++ = ' ';\n                      }\n\n                    p = end;\n                  }\n\n                count = p - tmp;\n\n                if (count >= tmp_length)\n                   \n                  abort ();\n\n                 \n                if (count >= allocated - length)\n                  {\n                    size_t n = xsum (length, count);\n\n                    ENSURE_ALLOCATION (n);\n                  }\n\n                 \n                memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n                if (tmp != tmpbuf)\n                  free (tmp);\n                length += count;\n              }\n#endif\n#if NEED_PRINTF_INFINITE_DOUBLE || NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_LONG_DOUBLE\n            else if ((dp->conversion == 'f' || dp->conversion == 'F'\n                      || dp->conversion == 'e' || dp->conversion == 'E'\n                      || dp->conversion == 'g' || dp->conversion == 'G'\n                      || dp->conversion == 'a' || dp->conversion == 'A')\n                     && (0\n# if NEED_PRINTF_DOUBLE\n                         || a.arg[dp->arg_index].type == TYPE_DOUBLE\n# elif NEED_PRINTF_INFINITE_DOUBLE\n                         || (a.arg[dp->arg_index].type == TYPE_DOUBLE\n                              \n                             && is_infinite_or_zero (a.arg[dp->arg_index].a.a_double))\n# endif\n# if NEED_PRINTF_LONG_DOUBLE\n                         || a.arg[dp->arg_index].type == TYPE_LONGDOUBLE\n# elif NEED_PRINTF_INFINITE_LONG_DOUBLE\n                         || (a.arg[dp->arg_index].type == TYPE_LONGDOUBLE\n                              \n                             && is_infinite_or_zerol (a.arg[dp->arg_index].a.a_longdouble))\n# endif\n                        ))\n              {\n# if (NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) && (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE)\n                arg_type type = a.arg[dp->arg_index].type;\n# endif\n                int flags = dp->flags;\n                size_t width;\n                size_t count;\n                int has_precision;\n                size_t precision;\n                size_t tmp_length;\n                DCHAR_T tmpbuf[700];\n                DCHAR_T *tmp;\n                DCHAR_T *pad_ptr;\n                DCHAR_T *p;\n\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                  }\n\n                has_precision = 0;\n                precision = 0;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                         \n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n                 \n                if (!has_precision)\n                  if (!(dp->conversion == 'a' || dp->conversion == 'A'))\n                    precision = 6;\n\n                 \n# if NEED_PRINTF_DOUBLE && NEED_PRINTF_LONG_DOUBLE\n                tmp_length = (type == TYPE_LONGDOUBLE ? LDBL_DIG + 1 : DBL_DIG + 1);\n# elif NEED_PRINTF_INFINITE_DOUBLE && NEED_PRINTF_LONG_DOUBLE\n                tmp_length = (type == TYPE_LONGDOUBLE ? LDBL_DIG + 1 : 0);\n# elif NEED_PRINTF_LONG_DOUBLE\n                tmp_length = LDBL_DIG + 1;\n# elif NEED_PRINTF_DOUBLE\n                tmp_length = DBL_DIG + 1;\n# else\n                tmp_length = 0;\n# endif\n                if (tmp_length < precision)\n                  tmp_length = precision;\n# if NEED_PRINTF_LONG_DOUBLE\n#  if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE\n                if (type == TYPE_LONGDOUBLE)\n#  endif\n                  if (dp->conversion == 'f' || dp->conversion == 'F')\n                    {\n                      long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                      if (!(isnanl (arg) || arg + arg == arg))\n                        {\n                           \n                          int exponent = floorlog10l (arg < 0 ? -arg : arg);\n                          if (exponent >= 0 && tmp_length < exponent + precision)\n                            tmp_length = exponent + precision;\n                        }\n                    }\n# endif\n# if NEED_PRINTF_DOUBLE\n#  if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE\n                if (type == TYPE_DOUBLE)\n#  endif\n                  if (dp->conversion == 'f' || dp->conversion == 'F')\n                    {\n                      double arg = a.arg[dp->arg_index].a.a_double;\n                      if (!(isnand (arg) || arg + arg == arg))\n                        {\n                           \n                          int exponent = floorlog10 (arg < 0 ? -arg : arg);\n                          if (exponent >= 0 && tmp_length < exponent + precision)\n                            tmp_length = exponent + precision;\n                        }\n                    }\n# endif\n                 \n                tmp_length = xsum (tmp_length, 12);\n\n                if (tmp_length < width)\n                  tmp_length = width;\n\n                tmp_length = xsum (tmp_length, 1);  \n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                       \n                      goto out_of_memory;\n                    tmp = (DCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                       \n                      goto out_of_memory;\n                  }\n\n                pad_ptr = NULL;\n                p = tmp;\n\n# if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE\n#  if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE\n                if (type == TYPE_LONGDOUBLE)\n#  endif\n                  {\n                    long double arg = a.arg[dp->arg_index].a.a_longdouble;\n\n                    if (isnanl (arg))\n                      {\n                        if (dp->conversion >= 'A' && dp->conversion <= 'Z')\n                          {\n                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';\n                          }\n                        else\n                          {\n                            *p++ = 'n'; *p++ = 'a'; *p++ = 'n';\n                          }\n                      }\n                    else\n                      {\n                        int sign = 0;\n                        DECL_LONG_DOUBLE_ROUNDING\n\n                        BEGIN_LONG_DOUBLE_ROUNDING ();\n\n                        if (signbit (arg))  \n                          {\n                            sign = -1;\n                            arg = -arg;\n                          }\n\n                        if (sign < 0)\n                          *p++ = '-';\n                        else if (flags & FLAG_SHOWSIGN)\n                          *p++ = '+';\n                        else if (flags & FLAG_SPACE)\n                          *p++ = ' ';\n\n                        if (arg > 0.0L && arg + arg == arg)\n                          {\n                            if (dp->conversion >= 'A' && dp->conversion <= 'Z')\n                              {\n                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';\n                              }\n                            else\n                              {\n                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';\n                              }\n                          }\n                        else\n                          {\n#  if NEED_PRINTF_LONG_DOUBLE\n                            pad_ptr = p;\n\n                            if (dp->conversion == 'f' || dp->conversion == 'F')\n                              {\n                                char *digits;\n                                size_t ndigits;\n\n                                digits =\n                                  scale10_round_decimal_long_double (arg, precision);\n                                if (digits == NULL)\n                                  {\n                                    END_LONG_DOUBLE_ROUNDING ();\n                                    goto out_of_memory;\n                                  }\n                                ndigits = strlen (digits);\n\n                                if (ndigits > precision)\n                                  do\n                                    {\n                                      --ndigits;\n                                      *p++ = digits[ndigits];\n                                    }\n                                  while (ndigits > precision);\n                                else\n                                  *p++ = '0';\n                                 \n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > ndigits; precision--)\n                                      *p++ = '0';\n                                    while (ndigits > 0)\n                                      {\n                                        --ndigits;\n                                        *p++ = digits[ndigits];\n                                      }\n                                  }\n\n                                free (digits);\n                              }\n                            else if (dp->conversion == 'e' || dp->conversion == 'E')\n                              {\n                                int exponent;\n\n                                if (arg == 0.0L)\n                                  {\n                                    exponent = 0;\n                                    *p++ = '0';\n                                    if ((flags & FLAG_ALT) || precision > 0)\n                                      {\n                                        *p++ = decimal_point_char ();\n                                        for (; precision > 0; precision--)\n                                          *p++ = '0';\n                                      }\n                                  }\n                                else\n                                  {\n                                     \n                                    int adjusted;\n                                    char *digits;\n                                    size_t ndigits;\n\n                                    exponent = floorlog10l (arg);\n                                    adjusted = 0;\n                                    for (;;)\n                                      {\n                                        digits =\n                                          scale10_round_decimal_long_double (arg,\n                                                                             (int)precision - exponent);\n                                        if (digits == NULL)\n                                          {\n                                            END_LONG_DOUBLE_ROUNDING ();\n                                            goto out_of_memory;\n                                          }\n                                        ndigits = strlen (digits);\n\n                                        if (ndigits == precision + 1)\n                                          break;\n                                        if (ndigits < precision\n                                            || ndigits > precision + 2)\n                                           \n                                          abort ();\n                                        if (adjusted)\n                                           \n                                          abort ();\n                                        free (digits);\n                                        if (ndigits == precision)\n                                          exponent -= 1;\n                                        else\n                                          exponent += 1;\n                                        adjusted = 1;\n                                      }\n                                     \n                                    if (is_borderline (digits, precision))\n                                      {\n                                         \n                                        char *digits2 =\n                                          scale10_round_decimal_long_double (arg,\n                                                                             (int)precision - exponent + 1);\n                                        if (digits2 == NULL)\n                                          {\n                                            free (digits);\n                                            END_LONG_DOUBLE_ROUNDING ();\n                                            goto out_of_memory;\n                                          }\n                                        if (strlen (digits2) == precision + 1)\n                                          {\n                                            free (digits);\n                                            digits = digits2;\n                                            exponent -= 1;\n                                          }\n                                        else\n                                          free (digits2);\n                                      }\n                                     \n\n                                    *p++ = digits[--ndigits];\n                                    if ((flags & FLAG_ALT) || precision > 0)\n                                      {\n                                        *p++ = decimal_point_char ();\n                                        while (ndigits > 0)\n                                          {\n                                            --ndigits;\n                                            *p++ = digits[ndigits];\n                                          }\n                                      }\n\n                                    free (digits);\n                                  }\n\n                                *p++ = dp->conversion;  \n#   if WIDE_CHAR_VERSION && DCHAR_IS_TCHAR\n                                {\n                                  static const wchar_t decimal_format[] =\n                                    { '%', '+', '.', '2', 'd', '\\0' };\n                                  SNPRINTF (p, 6 + 1, decimal_format, exponent);\n                                }\n                                while (*p != '\\0')\n                                  p++;\n#   else\n                                if (sizeof (DCHAR_T) == 1)\n                                  {\n                                    sprintf ((char *) p, \"%+.2d\", exponent);\n                                    while (*p != '\\0')\n                                      p++;\n                                  }\n                                else\n                                  {\n                                    char expbuf[6 + 1];\n                                    const char *ep;\n                                    sprintf (expbuf, \"%+.2d\", exponent);\n                                    for (ep = expbuf; (*p = *ep) != '\\0'; ep++)\n                                      p++;\n                                  }\n#   endif\n                              }\n                            else if (dp->conversion == 'g' || dp->conversion == 'G')\n                              {\n                                if (precision == 0)\n                                  precision = 1;\n                                 \n\n                                if (arg == 0.0L)\n                                   \n                                  {\n                                    size_t ndigits = precision;\n                                     \n                                    size_t nzeroes =\n                                      (flags & FLAG_ALT ? 0 : precision - 1);\n\n                                    --ndigits;\n                                    *p++ = '0';\n                                    if ((flags & FLAG_ALT) || ndigits > nzeroes)\n                                      {\n                                        *p++ = decimal_point_char ();\n                                        while (ndigits > nzeroes)\n                                          {\n                                            --ndigits;\n                                            *p++ = '0';\n                                          }\n                                      }\n                                  }\n                                else\n                                  {\n                                     \n                                    int exponent;\n                                    int adjusted;\n                                    char *digits;\n                                    size_t ndigits;\n                                    size_t nzeroes;\n\n                                    exponent = floorlog10l (arg);\n                                    adjusted = 0;\n                                    for (;;)\n                                      {\n                                        digits =\n                                          scale10_round_decimal_long_double (arg,\n                                                                             (int)(precision - 1) - exponent);\n                                        if (digits == NULL)\n                                          {\n                                            END_LONG_DOUBLE_ROUNDING ();\n                                            goto out_of_memory;\n                                          }\n                                        ndigits = strlen (digits);\n\n                                        if (ndigits == precision)\n                                          break;\n                                        if (ndigits < precision - 1\n                                            || ndigits > precision + 1)\n                                           \n                                          abort ();\n                                        if (adjusted)\n                                           \n                                          abort ();\n                                        free (digits);\n                                        if (ndigits < precision)\n                                          exponent -= 1;\n                                        else\n                                          exponent += 1;\n                                        adjusted = 1;\n                                      }\n                                     \n                                    if (is_borderline (digits, precision - 1))\n                                      {\n                                         \n                                        char *digits2 =\n                                          scale10_round_decimal_long_double (arg,\n                                                                             (int)(precision - 1) - exponent + 1);\n                                        if (digits2 == NULL)\n                                          {\n                                            free (digits);\n                                            END_LONG_DOUBLE_ROUNDING ();\n                                            goto out_of_memory;\n                                          }\n                                        if (strlen (digits2) == precision)\n                                          {\n                                            free (digits);\n                                            digits = digits2;\n                                            exponent -= 1;\n                                          }\n                                        else\n                                          free (digits2);\n                                      }\n                                     \n\n                                     \n                                    nzeroes = 0;\n                                    if ((flags & FLAG_ALT) == 0)\n                                      while (nzeroes < ndigits\n                                             && digits[nzeroes] == '0')\n                                        nzeroes++;\n\n                                     \n                                    if (exponent >= -4\n                                        && exponent < (long)precision)\n                                      {\n                                         \n                                        if (exponent >= 0)\n                                          {\n                                            size_t ecount = exponent + 1;\n                                             \n                                            for (; ecount > 0; ecount--)\n                                              *p++ = digits[--ndigits];\n                                            if ((flags & FLAG_ALT) || ndigits > nzeroes)\n                                              {\n                                                *p++ = decimal_point_char ();\n                                                while (ndigits > nzeroes)\n                                                  {\n                                                    --ndigits;\n                                                    *p++ = digits[ndigits];\n                                                  }\n                                              }\n                                          }\n                                        else\n                                          {\n                                            size_t ecount = -exponent - 1;\n                                            *p++ = '0';\n                                            *p++ = decimal_point_char ();\n                                            for (; ecount > 0; ecount--)\n                                              *p++ = '0';\n                                            while (ndigits > nzeroes)\n                                              {\n                                                --ndigits;\n                                                *p++ = digits[ndigits];\n                                              }\n                                          }\n                                      }\n                                    else\n                                      {\n                                         \n                                        *p++ = digits[--ndigits];\n                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)\n                                          {\n                                            *p++ = decimal_point_char ();\n                                            while (ndigits > nzeroes)\n                                              {\n                                                --ndigits;\n                                                *p++ = digits[ndigits];\n                                              }\n                                          }\n                                        *p++ = dp->conversion - 'G' + 'E';  \n#   if WIDE_CHAR_VERSION && DCHAR_IS_TCHAR\n                                        {\n                                          static const wchar_t decimal_format[] =\n                                            { '%', '+', '.', '2', 'd', '\\0' };\n                                          SNPRINTF (p, 6 + 1, decimal_format, exponent);\n                                        }\n                                        while (*p != '\\0')\n                                          p++;\n#   else\n                                        if (sizeof (DCHAR_T) == 1)\n                                          {\n                                            sprintf ((char *) p, \"%+.2d\", exponent);\n                                            while (*p != '\\0')\n                                              p++;\n                                          }\n                                        else\n                                          {\n                                            char expbuf[6 + 1];\n                                            const char *ep;\n                                            sprintf (expbuf, \"%+.2d\", exponent);\n                                            for (ep = expbuf; (*p = *ep) != '\\0'; ep++)\n                                              p++;\n                                          }\n#   endif\n                                      }\n\n                                    free (digits);\n                                  }\n                              }\n                            else\n                              abort ();\n#  else\n                             \n                            if (!(arg == 0.0L))\n                              abort ();\n\n                            pad_ptr = p;\n\n                            if (dp->conversion == 'f' || dp->conversion == 'F')\n                              {\n                                *p++ = '0';\n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > 0; precision--)\n                                      *p++ = '0';\n                                  }\n                              }\n                            else if (dp->conversion == 'e' || dp->conversion == 'E')\n                              {\n                                *p++ = '0';\n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > 0; precision--)\n                                      *p++ = '0';\n                                  }\n                                *p++ = dp->conversion;  \n                                *p++ = '+';\n                                *p++ = '0';\n                                *p++ = '0';\n                              }\n                            else if (dp->conversion == 'g' || dp->conversion == 'G')\n                              {\n                                *p++ = '0';\n                                if (flags & FLAG_ALT)\n                                  {\n                                    size_t ndigits =\n                                      (precision > 0 ? precision - 1 : 0);\n                                    *p++ = decimal_point_char ();\n                                    for (; ndigits > 0; --ndigits)\n                                      *p++ = '0';\n                                  }\n                              }\n                            else if (dp->conversion == 'a' || dp->conversion == 'A')\n                              {\n                                *p++ = '0';\n                                *p++ = dp->conversion - 'A' + 'X';\n                                pad_ptr = p;\n                                *p++ = '0';\n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > 0; precision--)\n                                      *p++ = '0';\n                                  }\n                                *p++ = dp->conversion - 'A' + 'P';\n                                *p++ = '+';\n                                *p++ = '0';\n                              }\n                            else\n                              abort ();\n#  endif\n                          }\n\n                        END_LONG_DOUBLE_ROUNDING ();\n                      }\n                  }\n#  if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE\n                else\n#  endif\n# endif\n# if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE\n                  {\n                    double arg = a.arg[dp->arg_index].a.a_double;\n\n                    if (isnand (arg))\n                      {\n                        if (dp->conversion >= 'A' && dp->conversion <= 'Z')\n                          {\n                            *p++ = 'N'; *p++ = 'A'; *p++ = 'N';\n                          }\n                        else\n                          {\n                            *p++ = 'n'; *p++ = 'a'; *p++ = 'n';\n                          }\n                      }\n                    else\n                      {\n                        int sign = 0;\n\n                        if (signbit (arg))  \n                          {\n                            sign = -1;\n                            arg = -arg;\n                          }\n\n                        if (sign < 0)\n                          *p++ = '-';\n                        else if (flags & FLAG_SHOWSIGN)\n                          *p++ = '+';\n                        else if (flags & FLAG_SPACE)\n                          *p++ = ' ';\n\n                        if (arg > 0.0 && arg + arg == arg)\n                          {\n                            if (dp->conversion >= 'A' && dp->conversion <= 'Z')\n                              {\n                                *p++ = 'I'; *p++ = 'N'; *p++ = 'F';\n                              }\n                            else\n                              {\n                                *p++ = 'i'; *p++ = 'n'; *p++ = 'f';\n                              }\n                          }\n                        else\n                          {\n#  if NEED_PRINTF_DOUBLE\n                            pad_ptr = p;\n\n                            if (dp->conversion == 'f' || dp->conversion == 'F')\n                              {\n                                char *digits;\n                                size_t ndigits;\n\n                                digits =\n                                  scale10_round_decimal_double (arg, precision);\n                                if (digits == NULL)\n                                  goto out_of_memory;\n                                ndigits = strlen (digits);\n\n                                if (ndigits > precision)\n                                  do\n                                    {\n                                      --ndigits;\n                                      *p++ = digits[ndigits];\n                                    }\n                                  while (ndigits > precision);\n                                else\n                                  *p++ = '0';\n                                 \n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > ndigits; precision--)\n                                      *p++ = '0';\n                                    while (ndigits > 0)\n                                      {\n                                        --ndigits;\n                                        *p++ = digits[ndigits];\n                                      }\n                                  }\n\n                                free (digits);\n                              }\n                            else if (dp->conversion == 'e' || dp->conversion == 'E')\n                              {\n                                int exponent;\n\n                                if (arg == 0.0)\n                                  {\n                                    exponent = 0;\n                                    *p++ = '0';\n                                    if ((flags & FLAG_ALT) || precision > 0)\n                                      {\n                                        *p++ = decimal_point_char ();\n                                        for (; precision > 0; precision--)\n                                          *p++ = '0';\n                                      }\n                                  }\n                                else\n                                  {\n                                     \n                                    int adjusted;\n                                    char *digits;\n                                    size_t ndigits;\n\n                                    exponent = floorlog10 (arg);\n                                    adjusted = 0;\n                                    for (;;)\n                                      {\n                                        digits =\n                                          scale10_round_decimal_double (arg,\n                                                                        (int)precision - exponent);\n                                        if (digits == NULL)\n                                          goto out_of_memory;\n                                        ndigits = strlen (digits);\n\n                                        if (ndigits == precision + 1)\n                                          break;\n                                        if (ndigits < precision\n                                            || ndigits > precision + 2)\n                                           \n                                          abort ();\n                                        if (adjusted)\n                                           \n                                          abort ();\n                                        free (digits);\n                                        if (ndigits == precision)\n                                          exponent -= 1;\n                                        else\n                                          exponent += 1;\n                                        adjusted = 1;\n                                      }\n                                     \n                                    if (is_borderline (digits, precision))\n                                      {\n                                         \n                                        char *digits2 =\n                                          scale10_round_decimal_double (arg,\n                                                                        (int)precision - exponent + 1);\n                                        if (digits2 == NULL)\n                                          {\n                                            free (digits);\n                                            goto out_of_memory;\n                                          }\n                                        if (strlen (digits2) == precision + 1)\n                                          {\n                                            free (digits);\n                                            digits = digits2;\n                                            exponent -= 1;\n                                          }\n                                        else\n                                          free (digits2);\n                                      }\n                                     \n\n                                    *p++ = digits[--ndigits];\n                                    if ((flags & FLAG_ALT) || precision > 0)\n                                      {\n                                        *p++ = decimal_point_char ();\n                                        while (ndigits > 0)\n                                          {\n                                            --ndigits;\n                                            *p++ = digits[ndigits];\n                                          }\n                                      }\n\n                                    free (digits);\n                                  }\n\n                                *p++ = dp->conversion;  \n#   if WIDE_CHAR_VERSION && DCHAR_IS_TCHAR\n                                {\n                                  static const wchar_t decimal_format[] =\n                                     \n#    if defined _WIN32 && ! defined __CYGWIN__\n                                    { '%', '+', '.', '3', 'd', '\\0' };\n#    else\n                                    { '%', '+', '.', '2', 'd', '\\0' };\n#    endif\n                                  SNPRINTF (p, 6 + 1, decimal_format, exponent);\n                                }\n                                while (*p != '\\0')\n                                  p++;\n#   else\n                                {\n                                  static const char decimal_format[] =\n                                     \n#    if defined _WIN32 && ! defined __CYGWIN__\n                                    \"%+.3d\";\n#    else\n                                    \"%+.2d\";\n#    endif\n                                  if (sizeof (DCHAR_T) == 1)\n                                    {\n                                      sprintf ((char *) p, decimal_format, exponent);\n                                      while (*p != '\\0')\n                                        p++;\n                                    }\n                                  else\n                                    {\n                                      char expbuf[6 + 1];\n                                      const char *ep;\n                                      sprintf (expbuf, decimal_format, exponent);\n                                      for (ep = expbuf; (*p = *ep) != '\\0'; ep++)\n                                        p++;\n                                    }\n                                }\n#   endif\n                              }\n                            else if (dp->conversion == 'g' || dp->conversion == 'G')\n                              {\n                                if (precision == 0)\n                                  precision = 1;\n                                 \n\n                                if (arg == 0.0)\n                                   \n                                  {\n                                    size_t ndigits = precision;\n                                     \n                                    size_t nzeroes =\n                                      (flags & FLAG_ALT ? 0 : precision - 1);\n\n                                    --ndigits;\n                                    *p++ = '0';\n                                    if ((flags & FLAG_ALT) || ndigits > nzeroes)\n                                      {\n                                        *p++ = decimal_point_char ();\n                                        while (ndigits > nzeroes)\n                                          {\n                                            --ndigits;\n                                            *p++ = '0';\n                                          }\n                                      }\n                                  }\n                                else\n                                  {\n                                     \n                                    int exponent;\n                                    int adjusted;\n                                    char *digits;\n                                    size_t ndigits;\n                                    size_t nzeroes;\n\n                                    exponent = floorlog10 (arg);\n                                    adjusted = 0;\n                                    for (;;)\n                                      {\n                                        digits =\n                                          scale10_round_decimal_double (arg,\n                                                                        (int)(precision - 1) - exponent);\n                                        if (digits == NULL)\n                                          goto out_of_memory;\n                                        ndigits = strlen (digits);\n\n                                        if (ndigits == precision)\n                                          break;\n                                        if (ndigits < precision - 1\n                                            || ndigits > precision + 1)\n                                           \n                                          abort ();\n                                        if (adjusted)\n                                           \n                                          abort ();\n                                        free (digits);\n                                        if (ndigits < precision)\n                                          exponent -= 1;\n                                        else\n                                          exponent += 1;\n                                        adjusted = 1;\n                                      }\n                                     \n                                    if (is_borderline (digits, precision - 1))\n                                      {\n                                         \n                                        char *digits2 =\n                                          scale10_round_decimal_double (arg,\n                                                                        (int)(precision - 1) - exponent + 1);\n                                        if (digits2 == NULL)\n                                          {\n                                            free (digits);\n                                            goto out_of_memory;\n                                          }\n                                        if (strlen (digits2) == precision)\n                                          {\n                                            free (digits);\n                                            digits = digits2;\n                                            exponent -= 1;\n                                          }\n                                        else\n                                          free (digits2);\n                                      }\n                                     \n\n                                     \n                                    nzeroes = 0;\n                                    if ((flags & FLAG_ALT) == 0)\n                                      while (nzeroes < ndigits\n                                             && digits[nzeroes] == '0')\n                                        nzeroes++;\n\n                                     \n                                    if (exponent >= -4\n                                        && exponent < (long)precision)\n                                      {\n                                         \n                                        if (exponent >= 0)\n                                          {\n                                            size_t ecount = exponent + 1;\n                                             \n                                            for (; ecount > 0; ecount--)\n                                              *p++ = digits[--ndigits];\n                                            if ((flags & FLAG_ALT) || ndigits > nzeroes)\n                                              {\n                                                *p++ = decimal_point_char ();\n                                                while (ndigits > nzeroes)\n                                                  {\n                                                    --ndigits;\n                                                    *p++ = digits[ndigits];\n                                                  }\n                                              }\n                                          }\n                                        else\n                                          {\n                                            size_t ecount = -exponent - 1;\n                                            *p++ = '0';\n                                            *p++ = decimal_point_char ();\n                                            for (; ecount > 0; ecount--)\n                                              *p++ = '0';\n                                            while (ndigits > nzeroes)\n                                              {\n                                                --ndigits;\n                                                *p++ = digits[ndigits];\n                                              }\n                                          }\n                                      }\n                                    else\n                                      {\n                                         \n                                        *p++ = digits[--ndigits];\n                                        if ((flags & FLAG_ALT) || ndigits > nzeroes)\n                                          {\n                                            *p++ = decimal_point_char ();\n                                            while (ndigits > nzeroes)\n                                              {\n                                                --ndigits;\n                                                *p++ = digits[ndigits];\n                                              }\n                                          }\n                                        *p++ = dp->conversion - 'G' + 'E';  \n#   if WIDE_CHAR_VERSION && DCHAR_IS_TCHAR\n                                        {\n                                          static const wchar_t decimal_format[] =\n                                             \n#    if defined _WIN32 && ! defined __CYGWIN__\n                                            { '%', '+', '.', '3', 'd', '\\0' };\n#    else\n                                            { '%', '+', '.', '2', 'd', '\\0' };\n#    endif\n                                          SNPRINTF (p, 6 + 1, decimal_format, exponent);\n                                        }\n                                        while (*p != '\\0')\n                                          p++;\n#   else\n                                        {\n                                          static const char decimal_format[] =\n                                             \n#    if defined _WIN32 && ! defined __CYGWIN__\n                                            \"%+.3d\";\n#    else\n                                            \"%+.2d\";\n#    endif\n                                          if (sizeof (DCHAR_T) == 1)\n                                            {\n                                              sprintf ((char *) p, decimal_format, exponent);\n                                              while (*p != '\\0')\n                                                p++;\n                                            }\n                                          else\n                                            {\n                                              char expbuf[6 + 1];\n                                              const char *ep;\n                                              sprintf (expbuf, decimal_format, exponent);\n                                              for (ep = expbuf; (*p = *ep) != '\\0'; ep++)\n                                                p++;\n                                            }\n                                        }\n#   endif\n                                      }\n\n                                    free (digits);\n                                  }\n                              }\n                            else\n                              abort ();\n#  else\n                             \n                            if (!(arg == 0.0))\n                              abort ();\n\n                            pad_ptr = p;\n\n                            if (dp->conversion == 'f' || dp->conversion == 'F')\n                              {\n                                *p++ = '0';\n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > 0; precision--)\n                                      *p++ = '0';\n                                  }\n                              }\n                            else if (dp->conversion == 'e' || dp->conversion == 'E')\n                              {\n                                *p++ = '0';\n                                if ((flags & FLAG_ALT) || precision > 0)\n                                  {\n                                    *p++ = decimal_point_char ();\n                                    for (; precision > 0; precision--)\n                                      *p++ = '0';\n                                  }\n                                *p++ = dp->conversion;  \n                                *p++ = '+';\n                                 \n#   if defined _WIN32 && ! defined __CYGWIN__\n                                *p++ = '0';\n#   endif\n                                *p++ = '0';\n                                *p++ = '0';\n                              }\n                            else if (dp->conversion == 'g' || dp->conversion == 'G')\n                              {\n                                *p++ = '0';\n                                if (flags & FLAG_ALT)\n                                  {\n                                    size_t ndigits =\n                                      (precision > 0 ? precision - 1 : 0);\n                                    *p++ = decimal_point_char ();\n                                    for (; ndigits > 0; --ndigits)\n                                      *p++ = '0';\n                                  }\n                              }\n                            else\n                              abort ();\n#  endif\n                          }\n                      }\n                  }\n# endif\n\n                 \n                count = p - tmp;\n\n                if (count < width)\n                  {\n                    size_t pad = width - count;\n                    DCHAR_T *end = p + pad;\n\n                    if (flags & FLAG_LEFT)\n                      {\n                         \n                        for (; pad > 0; pad--)\n                          *p++ = ' ';\n                      }\n                    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                      {\n                         \n                        DCHAR_T *q = end;\n\n                        while (p > pad_ptr)\n                          *--q = *--p;\n                        for (; pad > 0; pad--)\n                          *p++ = '0';\n                      }\n                    else\n                      {\n                         \n                        DCHAR_T *q = end;\n\n                        while (p > tmp)\n                          *--q = *--p;\n                        for (; pad > 0; pad--)\n                          *p++ = ' ';\n                      }\n\n                    p = end;\n                  }\n\n                count = p - tmp;\n\n                if (count >= tmp_length)\n                   \n                  abort ();\n\n                 \n                if (count >= allocated - length)\n                  {\n                    size_t n = xsum (length, count);\n\n                    ENSURE_ALLOCATION (n);\n                  }\n\n                 \n                memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n                if (tmp != tmpbuf)\n                  free (tmp);\n                length += count;\n              }\n#endif\n            else\n              {\n                arg_type type = a.arg[dp->arg_index].type;\n                int flags = dp->flags;\n#if (WIDE_CHAR_VERSION && MUSL_LIBC) || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                int has_width;\n#endif\n#if !USE_SNPRINTF || WIDE_CHAR_VERSION || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                size_t width;\n#endif\n#if !USE_SNPRINTF || (WIDE_CHAR_VERSION && DCHAR_IS_TCHAR) || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || (WIDE_CHAR_VERSION && MUSL_LIBC) || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                int has_precision;\n                size_t precision;\n#endif\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                int prec_ourselves;\n#else\n#               define prec_ourselves 0\n#endif\n#if (WIDE_CHAR_VERSION && MUSL_LIBC) || NEED_PRINTF_FLAG_LEFTADJUST\n#               define pad_ourselves 1\n#elif !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                int pad_ourselves;\n#else\n#               define pad_ourselves 0\n#endif\n                TCHAR_T *fbp;\n                unsigned int prefix_count;\n                int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if (WIDE_CHAR_VERSION && MUSL_LIBC) || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || WIDE_CHAR_VERSION || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                             \n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n# if (WIDE_CHAR_VERSION && MUSL_LIBC) || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n# endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || (WIDE_CHAR_VERSION && DCHAR_IS_TCHAR) || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || (WIDE_CHAR_VERSION && MUSL_LIBC) || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                         \n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                 \n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'b':\n                  #if SUPPORT_GNU_PRINTF_DIRECTIVES \\\n                      || (__GLIBC__ + (__GLIBC_MINOR__ >= 35) > 2)\n                  case 'B':\n                  #endif\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                 \n#if !((WIDE_CHAR_VERSION && MUSL_LIBC) || NEED_PRINTF_FLAG_LEFTADJUST) && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                   \n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                 \n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                       \n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                       \n                      goto out_of_memory;\n                  }\n#endif\n\n                 \n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                 \n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                         \n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                         \n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n                  #if INT8_WIDTH > LONG_WIDTH\n                  case TYPE_INT8_T:\n                  #endif\n                  #if UINT8_WIDTH > LONG_WIDTH\n                  case TYPE_UINT8_T:\n                  #endif\n                  #if INT16_WIDTH > LONG_WIDTH\n                  case TYPE_INT16_T:\n                  #endif\n                  #if UINT16_WIDTH > LONG_WIDTH\n                  case TYPE_UINT16_T:\n                  #endif\n                  #if INT32_WIDTH > LONG_WIDTH\n                  case TYPE_INT32_T:\n                  #endif\n                  #if UINT32_WIDTH > LONG_WIDTH\n                  case TYPE_UINT32_T:\n                  #endif\n                  #if INT64_WIDTH > LONG_WIDTH\n                  case TYPE_INT64_T:\n                  #endif\n                  #if UINT64_WIDTH > LONG_WIDTH\n                  case TYPE_UINT64_T:\n                  #endif\n                  #if INT_FAST8_WIDTH > LONG_WIDTH\n                  case TYPE_INT_FAST8_T:\n                  #endif\n                  #if UINT_FAST8_WIDTH > LONG_WIDTH\n                  case TYPE_UINT_FAST8_T:\n                  #endif\n                  #if INT_FAST16_WIDTH > LONG_WIDTH\n                  case TYPE_INT_FAST16_T:\n                  #endif\n                  #if UINT_FAST16_WIDTH > LONG_WIDTH\n                  case TYPE_UINT_FAST16_T:\n                  #endif\n                  #if INT_FAST32_WIDTH > LONG_WIDTH\n                  case TYPE_INT3_FAST2_T:\n                  #endif\n                  #if UINT_FAST32_WIDTH > LONG_WIDTH\n                  case TYPE_UINT_FAST32_T:\n                  #endif\n                  #if INT_FAST64_WIDTH > LONG_WIDTH\n                  case TYPE_INT_FAST64_T:\n                  #endif\n                  #if UINT_FAST64_WIDTH > LONG_WIDTH\n                  case TYPE_UINT_FAST64_T:\n                  #endif\n#if defined _WIN32 && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n#else\n                    *fbp++ = 'l';\n#endif\n                    FALLTHROUGH;\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n                  #if INT8_WIDTH > INT_WIDTH && INT8_WIDTH <= LONG_WIDTH\n                  case TYPE_INT8_T:\n                  #endif\n                  #if UINT8_WIDTH > INT_WIDTH && UINT8_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT8_T:\n                  #endif\n                  #if INT16_WIDTH > INT_WIDTH && INT16_WIDTH <= LONG_WIDTH\n                  case TYPE_INT16_T:\n                  #endif\n                  #if UINT16_WIDTH > INT_WIDTH && UINT16_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT16_T:\n                  #endif\n                  #if INT32_WIDTH > INT_WIDTH && INT32_WIDTH <= LONG_WIDTH\n                  case TYPE_INT32_T:\n                  #endif\n                  #if UINT32_WIDTH > INT_WIDTH && UINT32_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT32_T:\n                  #endif\n                  #if INT64_WIDTH > INT_WIDTH && INT64_WIDTH <= LONG_WIDTH\n                  case TYPE_INT64_T:\n                  #endif\n                  #if UINT64_WIDTH > INT_WIDTH && UINT64_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT64_T:\n                  #endif\n                  #if INT_FAST8_WIDTH > INT_WIDTH && INT_FAST8_WIDTH <= LONG_WIDTH\n                  case TYPE_INT_FAST8_T:\n                  #endif\n                  #if UINT_FAST8_WIDTH > INT_WIDTH && UINT_FAST8_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT_FAST8_T:\n                  #endif\n                  #if INT_FAST16_WIDTH > INT_WIDTH && INT_FAST16_WIDTH <= LONG_WIDTH\n                  case TYPE_INT_FAST16_T:\n                  #endif\n                  #if UINT_FAST16_WIDTH > INT_WIDTH && UINT_FAST16_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT_FAST16_T:\n                  #endif\n                  #if INT_FAST32_WIDTH > INT_WIDTH && INT_FAST32_WIDTH <= LONG_WIDTH\n                  case TYPE_INT_FAST32_T:\n                  #endif\n                  #if UINT_FAST32_WIDTH > INT_WIDTH && UINT_FAST32_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT_FAST32_T:\n                  #endif\n                  #if INT_FAST64_WIDTH > INT_WIDTH && INT_FAST64_WIDTH <= LONG_WIDTH\n                  case TYPE_INT_FAST64_T:\n                  #endif\n                  #if UINT_FAST64_WIDTH > INT_WIDTH && UINT_FAST64_WIDTH <= LONG_WIDTH\n                  case TYPE_UINT_FAST64_T:\n                  #endif\n                  #if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n                  #endif\n                  #if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n                  #endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n                 \n# if (((!WIDE_CHAR_VERSION || !DCHAR_IS_TCHAR)                              \\\n       && (HAVE_SNPRINTF_RETVAL_C99 && HAVE_SNPRINTF_TRUNCATION_C99))       \\\n      || ((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))       \\\n          && !defined __UCLIBC__)                                           \\\n      || (defined __APPLE__ && defined __MACH__)                            \\\n      || defined __OpenBSD__                                                \\\n      || defined __ANDROID__                                                \\\n      || (defined _WIN32 && ! defined __CYGWIN__))                          \\\n      || (WIDE_CHAR_VERSION && MUSL_LIBC)\n                 \n                 \n                 \n                 \n                fbp[1] = '\\0';\n# else            \n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                 \n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                 \n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                 \n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                 \n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                     \n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT8_T:\n                        {\n                          int8_t arg = a.arg[dp->arg_index].a.a_int8_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT8_T:\n                        {\n                          uint8_t arg = a.arg[dp->arg_index].a.a_uint8_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT16_T:\n                        {\n                          int16_t arg = a.arg[dp->arg_index].a.a_int16_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT16_T:\n                        {\n                          uint16_t arg = a.arg[dp->arg_index].a.a_uint16_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT32_T:\n                        {\n                          int32_t arg = a.arg[dp->arg_index].a.a_int32_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT32_T:\n                        {\n                          uint32_t arg = a.arg[dp->arg_index].a.a_uint32_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT64_T:\n                        {\n                          int64_t arg = a.arg[dp->arg_index].a.a_int64_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT64_T:\n                        {\n                          uint64_t arg = a.arg[dp->arg_index].a.a_uint64_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT_FAST8_T:\n                        {\n                          int_fast8_t arg = a.arg[dp->arg_index].a.a_int_fast8_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT_FAST8_T:\n                        {\n                          uint_fast8_t arg = a.arg[dp->arg_index].a.a_uint_fast8_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT_FAST16_T:\n                        {\n                          int_fast16_t arg = a.arg[dp->arg_index].a.a_int_fast16_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT_FAST16_T:\n                        {\n                          uint_fast16_t arg = a.arg[dp->arg_index].a.a_uint_fast16_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT_FAST32_T:\n                        {\n                          int_fast32_t arg = a.arg[dp->arg_index].a.a_int_fast32_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT_FAST32_T:\n                        {\n                          uint_fast32_t arg = a.arg[dp->arg_index].a.a_uint_fast32_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT_FAST64_T:\n                        {\n                          int_fast64_t arg = a.arg[dp->arg_index].a.a_int_fast64_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT_FAST64_T:\n                        {\n                          uint_fast64_t arg = a.arg[dp->arg_index].a.a_uint_fast64_t;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                     \n                    if (count >= 0)\n                      {\n                         \n                        if ((unsigned int) count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                         \n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                         \n                        if (fbp[1] != '\\0')\n                          {\n                             \n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                             \n                            if (retcount < 0)\n                              {\n# if (WIDE_CHAR_VERSION && DCHAR_IS_TCHAR) || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF\n                                 \n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                     \n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                     \n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              {\n                                count = retcount;\n# if WIDE_CHAR_VERSION && defined __MINGW32__\n                                if (count == 0 && dp->conversion == 'c')\n                                   \n                                  count = 1;\n# endif\n                              }\n                          }\n                      }\n#endif\n\n                     \n                    if (count < 0)\n                      {\n                         \n                        if (errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              errno = EILSEQ;\n                            else\n                              errno = EINVAL;\n                          }\n\n                        goto fail_with_errno;\n                      }\n\n#if USE_SNPRINTF\n                     \n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                         \n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                             \n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                         \n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                         \n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                         \n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                             \n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                       \n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                     \n                    if (dp->conversion == 'c' || dp->conversion == 's'\n# if __GLIBC__ >= 2 && !defined __UCLIBC__\n                        || (flags & FLAG_LOCALIZED)\n# endif\n                       )\n                      {\n                         \n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                         \n                        static_assert (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n# if WIDE_CHAR_VERSION\n                         \n                        mbstate_t state;\n\n                        mbszero (&state);\n                        tmpdst_len = 0;\n                        {\n                          const TCHAR_T *src = tmpsrc;\n                          size_t srclen = count;\n\n                          for (; srclen > 0; tmpdst_len++)\n                            {\n                               \n                              size_t ret = mbrtowc (NULL, src, srclen, &state);\n                              if (ret == (size_t)(-2) || ret == (size_t)(-1))\n                                goto fail_with_EILSEQ;\n                              if (ret == 0)\n                                ret = 1;\n                              src += ret;\n                              srclen -= ret;\n                            }\n                        }\n\n                        tmpdst =\n                          (wchar_t *) malloc ((tmpdst_len + 1) * sizeof (wchar_t));\n                        if (tmpdst == NULL)\n                          goto out_of_memory;\n\n                        mbszero (&state);\n                        {\n                          DCHAR_T *destptr = tmpdst;\n                          const TCHAR_T *src = tmpsrc;\n                          size_t srclen = count;\n\n                          for (; srclen > 0; destptr++)\n                            {\n                               \n                              size_t ret = mbrtowc (destptr, src, srclen, &state);\n                              if (ret == (size_t)(-2) || ret == (size_t)(-1))\n                                 \n                                abort ();\n                              if (ret == 0)\n                                ret = 1;\n                              src += ret;\n                              srclen -= ret;\n                            }\n                        }\n# else\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          goto fail_with_errno;\n# endif\n                        ENSURE_ALLOCATION_ELSE (xsum (length, tmpdst_len),\n                                                { free (tmpdst); goto out_of_memory; });\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                         \n# if USE_SNPRINTF\n                         \n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                 \n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                 \n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                             \n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                     \n                    if (count > allocated - length)\n                      {\n                         \n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                     \n\n                     \n#if (WIDE_CHAR_VERSION && MUSL_LIBC) || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                         \n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                         \n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                             \n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                 \n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                             \n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                 \n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                   \n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                  else\n                                     \n                                    if (p - rp >= 2\n                                        && *rp == '0'\n                                        && (((dp->conversion == 'a'\n                                              || dp->conversion == 'x')\n                                             && rp[1] == 'x')\n                                            || ((dp->conversion == 'A'\n                                                 || dp->conversion == 'X')\n                                                && rp[1] == 'X')\n                                            || (dp->conversion == 'b'\n                                                && rp[1] == 'b')\n                                            || (dp->conversion == 'B'\n                                                && rp[1] == 'B')))\n                                      pad_ptr += 2;\n                                }\n                               \n\n                              count = count + pad;  \n\n                              if (flags & FLAG_LEFT)\n                                {\n                                   \n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL\n                                        \n                                       && !(has_precision\n                                            && (dp->conversion == 'd'\n                                                || dp->conversion == 'i'\n                                                || dp->conversion == 'o'\n                                                || dp->conversion == 'u'\n                                                || dp->conversion == 'x'\n                                                || dp->conversion == 'X'\n                                                 \n                                                || dp->conversion == 'b'\n                                                || dp->conversion == 'B')))\n                                {\n                                   \n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                   \n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                     \n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                     \n#else\n                     \n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                         \n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }\n          }\n      }\n\n     \n    ENSURE_ALLOCATION (xsum (length, 1));\n    result[length] = '\\0';\n\n    if (result != resultbuf && length + 1 < allocated)\n      {\n         \n        DCHAR_T *memory;\n\n        memory = (DCHAR_T *) realloc (result, (length + 1) * sizeof (DCHAR_T));\n        if (memory != NULL)\n          result = memory;\n      }\n\n    if (buf_malloced != NULL)\n      free (buf_malloced);\n    CLEANUP ();\n    *lengthp = length;\n     \n    return result;\n\n#if USE_SNPRINTF\n  overflow:\n    errno = EOVERFLOW;\n    goto fail_with_errno;\n#endif\n\n  out_of_memory:\n    errno = ENOMEM;\n    goto fail_with_errno;\n\n#if ENABLE_UNISTDIO || ((!USE_SNPRINTF || WIDE_CHAR_VERSION || !HAVE_SNPRINTF_RETVAL_C99 || USE_MSVC__SNPRINTF || NEED_PRINTF_DIRECTIVE_LS || ENABLE_WCHAR_FALLBACK) && HAVE_WCHAR_T) || ((NEED_PRINTF_DIRECTIVE_LC || ENABLE_WCHAR_FALLBACK) && HAVE_WINT_T && !WIDE_CHAR_VERSION) || (NEED_WPRINTF_DIRECTIVE_C && WIDE_CHAR_VERSION)\n  fail_with_EILSEQ:\n    errno = EILSEQ;\n    goto fail_with_errno;\n#endif\n\n  fail_with_errno:\n    if (result != resultbuf)\n      free (result);\n    if (buf_malloced != NULL)\n      free (buf_malloced);\n    CLEANUP ();\n    return NULL;\n  }\n\n out_of_memory_1:\n  errno = ENOMEM;\n  goto fail_1_with_errno;\n\n fail_1_with_EINVAL:\n  errno = EINVAL;\n  goto fail_1_with_errno;\n\n fail_1_with_errno:\n  CLEANUP ();\n  return NULL;\n}\n\n#undef MAX_ROOM_NEEDED\n#undef TCHARS_PER_DCHAR\n#undef SNPRINTF\n#undef USE_SNPRINTF\n#undef DCHAR_SET\n#undef DCHAR_CPY\n#undef PRINTF_PARSE\n#undef DIRECTIVES\n#undef DIRECTIVE\n#undef DCHAR_IS_TCHAR\n#undef TCHAR_T\n#undef DCHAR_T\n#undef FCHAR_T\n#undef VASNPRINTF\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}