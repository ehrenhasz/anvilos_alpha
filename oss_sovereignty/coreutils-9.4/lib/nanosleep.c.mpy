{
  "module_name": "nanosleep.c",
  "hash_id": "f8b2a1a8fe5c09e1b256ef563f80ffd3061bec66f4cc786e704d722631301c5a",
  "original_prompt": "Ingested from coreutils-9.4/lib/nanosleep.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <time.h>\n\n#include \"intprops.h\"\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/select.h>\n#include <signal.h>\n\n#include <errno.h>\n\n#include <unistd.h>\n\n\nenum { BILLION = 1000 * 1000 * 1000 };\n\n#if HAVE_BUG_BIG_NANOSLEEP\n\nint\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n# undef nanosleep\n{\n   \n\n  if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  {\n     \n    static_assert (TYPE_MAXIMUM (time_t) / 24 / 24 / 60 / 60);\n    const time_t limit = 24 * 24 * 60 * 60;\n    time_t seconds = requested_delay->tv_sec;\n    struct timespec intermediate = *requested_delay;\n\n    while (limit < seconds)\n      {\n        int result;\n        intermediate.tv_sec = limit;\n        result = nanosleep (&intermediate, remaining_delay);\n        seconds -= limit;\n        if (result)\n          {\n            if (remaining_delay)\n              remaining_delay->tv_sec += seconds;\n            return result;\n          }\n        intermediate.tv_nsec = 0;\n      }\n    intermediate.tv_sec = seconds;\n    return nanosleep (&intermediate, remaining_delay);\n  }\n}\n\n#elif defined _WIN32 && ! defined __CYGWIN__\n \n\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n\n \n\nint\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n{\n  static bool initialized;\n   \n  static double ticks_per_nanosecond;\n\n  if (requested_delay->tv_nsec < 0 || BILLION <= requested_delay->tv_nsec)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n   \n  if (requested_delay->tv_sec == 0)\n    {\n      if (!initialized)\n        {\n           \n          LARGE_INTEGER ticks_per_second;\n\n          if (QueryPerformanceFrequency (&ticks_per_second))\n            ticks_per_nanosecond =\n              (double) ticks_per_second.QuadPart / 1000000000.0;\n\n          initialized = true;\n        }\n      if (ticks_per_nanosecond)\n        {\n           \n           \n          int sleep_millis = (int) requested_delay->tv_nsec / 1000000 - 10;\n           \n          LONGLONG wait_ticks = requested_delay->tv_nsec * ticks_per_nanosecond;\n           \n          LARGE_INTEGER counter_before;\n          if (QueryPerformanceCounter (&counter_before))\n            {\n               \n              LONGLONG wait_until = counter_before.QuadPart + wait_ticks;\n               \n              if (sleep_millis > 0)\n                Sleep (sleep_millis);\n               \n              for (;;)\n                {\n                  LARGE_INTEGER counter_after;\n                  if (!QueryPerformanceCounter (&counter_after))\n                     \n                    break;\n                  if (counter_after.QuadPart >= wait_until)\n                     \n                    break;\n                }\n              goto done;\n            }\n        }\n    }\n   \n  Sleep (requested_delay->tv_sec * 1000 + requested_delay->tv_nsec / 1000000);\n\n done:\n   \n  if (remaining_delay != NULL)\n    {\n      remaining_delay->tv_sec = 0;\n      remaining_delay->tv_nsec = 0;\n    }\n  return 0;\n}\n\n#else\n \n\n \n\nint\nnanosleep (const struct timespec *requested_delay,\n           struct timespec *remaining_delay)\n{\n  return pselect (0, NULL, NULL, NULL, requested_delay, NULL);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}