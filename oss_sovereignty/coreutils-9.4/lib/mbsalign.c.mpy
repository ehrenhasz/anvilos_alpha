{
  "module_name": "mbsalign.c",
  "hash_id": "87314135458dd2fa0ef4980fa7453e3e322c8276b8270c747d0d74f4c617d055",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbsalign.c",
  "human_readable_source": " \n\n#include <config.h>\n#include \"mbsalign.h\"\n\n#include \"minmax.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <limits.h>\n#include <wchar.h>\n#include <wctype.h>\n\n \n\nstatic bool\nwc_ensure_printable (wchar_t *wchars)\n{\n  bool replaced = false;\n  wchar_t *wc = wchars;\n  while (*wc)\n    {\n      if (!iswprint ((wint_t) *wc))\n        {\n          *wc = 0xFFFD;  \n          replaced = true;\n        }\n      wc++;\n    }\n  return replaced;\n}\n\n \n\nstatic size_t\nwc_truncate (wchar_t *wc, size_t width)\n{\n  size_t cells = 0;\n  int next_cells = 0;\n\n  while (*wc)\n    {\n      next_cells = wcwidth (*wc);\n      if (next_cells == -1)  \n        {\n          *wc = 0xFFFD;  \n          next_cells = 1;\n        }\n      if (cells + next_cells > width)\n        break;\n      cells += next_cells;\n      wc++;\n    }\n  *wc = L'\\0';\n  return cells;\n}\n\n \n\nstatic char *\nmbs_align_pad (char *dest, char const *dest_end, size_t n_spaces)\n{\n   \n  while (n_spaces-- && (dest < dest_end))\n    *dest++ = ' ';\n  *dest = '\\0';\n  return dest;\n}\n\n \n\nsize_t\nmbsalign (char const *src, char *dest, size_t dest_size,\n          size_t *width, mbs_align_t align, int flags)\n{\n  size_t ret = SIZE_MAX;\n  size_t src_size = strlen (src) + 1;\n  char *newstr = nullptr;\n  wchar_t *str_wc = nullptr;\n  char const *str_to_print = src;\n  size_t n_cols = src_size - 1;\n  size_t n_used_bytes = n_cols;  \n  size_t n_spaces = 0;\n  bool conversion = false;\n  bool wc_enabled = false;\n\n   \n  if (!(flags & MBA_UNIBYTE_ONLY) && MB_CUR_MAX > 1)\n    {\n      size_t src_chars = mbstowcs (nullptr, src, 0);\n      if (src_chars == SIZE_MAX)\n        {\n          if (flags & MBA_UNIBYTE_FALLBACK)\n            goto mbsalign_unibyte;\n          else\n            goto mbsalign_cleanup;\n        }\n      src_chars += 1;  \n      str_wc = malloc (src_chars * sizeof (wchar_t));\n      if (str_wc == nullptr)\n        {\n          if (flags & MBA_UNIBYTE_FALLBACK)\n            goto mbsalign_unibyte;\n          else\n            goto mbsalign_cleanup;\n        }\n      if (mbstowcs (str_wc, src, src_chars) != 0)\n        {\n          str_wc[src_chars - 1] = L'\\0';\n          wc_enabled = true;\n          conversion = wc_ensure_printable (str_wc);\n          n_cols = wcswidth (str_wc, src_chars);\n        }\n    }\n\n   \n  if (wc_enabled && (conversion || (n_cols > *width)))\n    {\n        if (conversion)\n          {\n              \n            src_size = wcstombs (nullptr, str_wc, 0) + 1;\n          }\n        newstr = malloc (src_size);\n        if (newstr == nullptr)\n        {\n          if (flags & MBA_UNIBYTE_FALLBACK)\n            goto mbsalign_unibyte;\n          else\n            goto mbsalign_cleanup;\n        }\n        str_to_print = newstr;\n        n_cols = wc_truncate (str_wc, *width);\n        n_used_bytes = wcstombs (newstr, str_wc, src_size);\n    }\n\nmbsalign_unibyte:\n\n  if (n_cols > *width)  \n    {\n      n_cols = *width;\n      n_used_bytes = n_cols;\n    }\n\n  if (*width > n_cols)  \n    n_spaces = *width - n_cols;\n\n   \n  *width = n_cols;\n\n  {\n    size_t start_spaces, end_spaces;\n\n    switch (align)\n      {\n      case MBS_ALIGN_LEFT:\n        start_spaces = 0;\n        end_spaces = n_spaces;\n        break;\n      case MBS_ALIGN_RIGHT:\n        start_spaces = n_spaces;\n        end_spaces = 0;\n        break;\n      case MBS_ALIGN_CENTER:\n      default:\n        start_spaces = n_spaces / 2 + n_spaces % 2;\n        end_spaces = n_spaces / 2;\n        break;\n      }\n\n      if (flags & MBA_NO_LEFT_PAD)\n        start_spaces = 0;\n      if (flags & MBA_NO_RIGHT_PAD)\n        end_spaces = 0;\n\n       \n      if (dest_size != 0)\n        {\n          size_t space_left;\n          char *dest_end = dest + dest_size - 1;\n\n          dest = mbs_align_pad (dest, dest_end, start_spaces);\n          space_left = dest_end - dest;\n          dest = mempcpy (dest, str_to_print, MIN (n_used_bytes, space_left));\n          mbs_align_pad (dest, dest_end, end_spaces);\n        }\n\n     \n    ret = n_used_bytes + ((start_spaces + end_spaces) * 1);\n  }\n\nmbsalign_cleanup:\n\n  free (str_wc);\n  free (newstr);\n\n  return ret;\n}\n\n \n\nchar *\nambsalign (char const *src, size_t *width, mbs_align_t align, int flags)\n{\n  size_t orig_width = *width;\n  size_t size = *width;          \n  size_t req = size;\n  char *buf = nullptr;\n\n  while (req >= size)\n    {\n      char *nbuf;\n      size = req + 1;            \n      nbuf = realloc (buf, size);\n      if (nbuf == nullptr)\n        {\n          free (buf);\n          buf = nullptr;\n          break;\n        }\n      buf = nbuf;\n      *width = orig_width;\n      req = mbsalign (src, buf, size, width, align, flags);\n      if (req == SIZE_MAX)\n        {\n          free (buf);\n          buf = nullptr;\n          break;\n        }\n    }\n\n  return buf;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}