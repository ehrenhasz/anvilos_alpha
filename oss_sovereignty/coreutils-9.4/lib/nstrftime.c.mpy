{
  "module_name": "nstrftime.c",
  "hash_id": "c09d0daafdc7e27979af75191088b0984d8a8e5e7cfb065923c1ede2f4d46c56",
  "original_prompt": "Ingested from coreutils-9.4/lib/nstrftime.c",
  "human_readable_source": " \n#if !(defined __osf__ && 0)\n# define MULTIBYTE_IS_FORMAT_SAFE 1\n#endif\n#define DO_MULTIBYTE (! MULTIBYTE_IS_FORMAT_SAFE)\n\n#if DO_MULTIBYTE\n# include <wchar.h>\n  static const mbstate_t mbstate_zero;\n#endif\n\n#include <limits.h>\n#include <stdckdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"attribute.h\"\n#include <intprops.h>\n\n#ifdef COMPILE_WIDE\n# include <endian.h>\n# define CHAR_T wchar_t\n# define UCHAR_T unsigned int\n# define L_(Str) L##Str\n# define NLW(Sym) _NL_W##Sym\n\n# define MEMCPY(d, s, n) __wmemcpy (d, s, n)\n# define STRLEN(s) __wcslen (s)\n\n#else\n# define CHAR_T char\n# define UCHAR_T unsigned char\n# define L_(Str) Str\n# define NLW(Sym) Sym\n# define ABALTMON_1 _NL_ABALTMON_1\n\n# define MEMCPY(d, s, n) memcpy (d, s, n)\n# define STRLEN(s) strlen (s)\n\n#endif\n\n \n#define SHR(a, b)       \\\n  (-1 >> 1 == -1        \\\n   ? (a) >> (b)         \\\n   : ((a) + ((a) < 0)) / (1 << (b)) - ((a) < 0))\n\n#define TM_YEAR_BASE 1900\n\n#ifndef __isleap\n \n# define __isleap(year) \\\n  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))\n#endif\n\n\n#ifdef _LIBC\n# define mktime_z(tz, tm) mktime (tm)\n# define tzname __tzname\n# define tzset __tzset\n#endif\n\n#ifndef FPRINTFTIME\n# define FPRINTFTIME 0\n#endif\n\n#if FPRINTFTIME\n# define STREAM_OR_CHAR_T FILE\n# define STRFTIME_ARG(x)  \n#else\n# define STREAM_OR_CHAR_T CHAR_T\n# define STRFTIME_ARG(x) x,\n#endif\n\n#if FPRINTFTIME\n# define memset_byte(P, Len, Byte) \\\n  do { size_t _i; for (_i = 0; _i < Len; _i++) fputc (Byte, P); } while (0)\n# define memset_space(P, Len) memset_byte (P, Len, ' ')\n# define memset_zero(P, Len) memset_byte (P, Len, '0')\n#elif defined COMPILE_WIDE\n# define memset_space(P, Len) (wmemset (P, L' ', Len), (P) += (Len))\n# define memset_zero(P, Len) (wmemset (P, L'0', Len), (P) += (Len))\n#else\n# define memset_space(P, Len) (memset (P, ' ', Len), (P) += (Len))\n# define memset_zero(P, Len) (memset (P, '0', Len), (P) += (Len))\n#endif\n\n#if FPRINTFTIME\n# define advance(P, N)\n#else\n# define advance(P, N) ((P) += (N))\n#endif\n\n#define add(n, f) width_add (width, n, f)\n#define width_add(width, n, f)                                                \\\n  do                                                                          \\\n    {                                                                         \\\n      size_t _n = (n);                                                        \\\n      size_t _w = pad == L_('-') || width < 0 ? 0 : width;                    \\\n      size_t _incr = _n < _w ? _w : _n;                                       \\\n      if (_incr >= maxsize - i)                                               \\\n        {                                                                     \\\n          errno = ERANGE;                                                     \\\n          return 0;                                                           \\\n        }                                                                     \\\n      if (p)                                                                  \\\n        {                                                                     \\\n          if (_n < _w)                                                        \\\n            {                                                                 \\\n              size_t _delta = _w - _n;                                        \\\n              if (pad == L_('0') || pad == L_('+'))                           \\\n                memset_zero (p, _delta);                                      \\\n              else                                                            \\\n                memset_space (p, _delta);                                     \\\n            }                                                                 \\\n          f;                                                                  \\\n          advance (p, _n);                                                    \\\n        }                                                                     \\\n      i += _incr;                                                             \\\n    } while (0)\n\n#define add1(c) width_add1 (width, c)\n#if FPRINTFTIME\n# define width_add1(width, c) width_add (width, 1, fputc (c, p))\n#else\n# define width_add1(width, c) width_add (width, 1, *p = c)\n#endif\n\n#define cpy(n, s) width_cpy (width, n, s)\n#if FPRINTFTIME\n# define width_cpy(width, n, s)                                               \\\n    width_add (width, n,                                                      \\\n     do                                                                       \\\n       {                                                                      \\\n         if (to_lowcase)                                                      \\\n           fwrite_lowcase (p, (s), _n);                                       \\\n         else if (to_uppcase)                                                 \\\n           fwrite_uppcase (p, (s), _n);                                       \\\n         else                                                                 \\\n           {                                                                  \\\n                                                       \\\n             fwrite (s, _n, 1, p);                                            \\\n           }                                                                  \\\n       }                                                                      \\\n     while (0)                                                                \\\n    )\n#else\n# define width_cpy(width, n, s)                                               \\\n    width_add (width, n,                                                      \\\n         if (to_lowcase)                                                      \\\n           memcpy_lowcase (p, (s), _n LOCALE_ARG);                            \\\n         else if (to_uppcase)                                                 \\\n           memcpy_uppcase (p, (s), _n LOCALE_ARG);                            \\\n         else                                                                 \\\n           MEMCPY ((void *) p, (void const *) (s), _n))\n#endif\n\n#ifdef COMPILE_WIDE\n# ifndef USE_IN_EXTENDED_LOCALE_MODEL\n#  undef __mbsrtowcs_l\n#  define __mbsrtowcs_l(d, s, l, st, loc) __mbsrtowcs (d, s, l, st)\n# endif\n#endif\n\n\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n \n# define strftime               __strftime_l\n# define wcsftime               __wcsftime_l\n# undef _NL_CURRENT\n# define _NL_CURRENT(category, item) \\\n  (current->values[_NL_ITEM_INDEX (item)].string)\n# define LOCALE_PARAM , locale_t loc\n# define LOCALE_ARG , loc\n# define HELPER_LOCALE_ARG  , current\n#else\n# define LOCALE_PARAM\n# define LOCALE_ARG\n# ifdef _LIBC\n#  define HELPER_LOCALE_ARG , _NL_CURRENT_DATA (LC_TIME)\n# else\n#  define HELPER_LOCALE_ARG\n# endif\n#endif\n\n#ifdef COMPILE_WIDE\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n#  define TOUPPER(Ch, L) __towupper_l (Ch, L)\n#  define TOLOWER(Ch, L) __towlower_l (Ch, L)\n# else\n#  define TOUPPER(Ch, L) towupper (Ch)\n#  define TOLOWER(Ch, L) towlower (Ch)\n# endif\n#else\n# ifdef USE_IN_EXTENDED_LOCALE_MODEL\n#  define TOUPPER(Ch, L) __toupper_l (Ch, L)\n#  define TOLOWER(Ch, L) __tolower_l (Ch, L)\n# else\n#  define TOUPPER(Ch, L) toupper (Ch)\n#  define TOLOWER(Ch, L) tolower (Ch)\n# endif\n#endif\n \n#define ISDIGIT(Ch) ((unsigned int) (Ch) - L_('0') <= 9)\n\n \n#if __GNUC__ >= 7 && !__OPTIMIZE__\n# pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n#endif\n\n#if FPRINTFTIME\nstatic void\nfwrite_lowcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOLOWER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}\n\nstatic void\nfwrite_uppcase (FILE *fp, const CHAR_T *src, size_t len)\n{\n  while (len-- > 0)\n    {\n      fputc (TOUPPER ((UCHAR_T) *src, loc), fp);\n      ++src;\n    }\n}\n#else\nstatic CHAR_T *memcpy_lowcase (CHAR_T *dest, const CHAR_T *src,\n                               size_t len LOCALE_PARAM);\n\nstatic CHAR_T *\nmemcpy_lowcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n{\n  while (len-- > 0)\n    dest[len] = TOLOWER ((UCHAR_T) src[len], loc);\n  return dest;\n}\n\nstatic CHAR_T *memcpy_uppcase (CHAR_T *dest, const CHAR_T *src,\n                               size_t len LOCALE_PARAM);\n\nstatic CHAR_T *\nmemcpy_uppcase (CHAR_T *dest, const CHAR_T *src, size_t len LOCALE_PARAM)\n{\n  while (len-- > 0)\n    dest[len] = TOUPPER ((UCHAR_T) src[len], loc);\n  return dest;\n}\n#endif\n\n\n#if ! HAVE_TM_GMTOFF\n \n# define tm_diff ftime_tm_diff\nstatic int tm_diff (const struct tm *, const struct tm *);\nstatic int\ntm_diff (const struct tm *a, const struct tm *b)\n{\n   \n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = (a4 + (a4 < 0)) / 25 - (a4 < 0);\n  int b100 = (b4 + (b4 < 0)) / 25 - (b4 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  int years = a->tm_year - b->tm_year;\n  int days = (365 * years + intervening_leap_days\n              + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}\n#endif  \n\n\n\n \n#define ISO_WEEK_START_WDAY 1  \n#define ISO_WEEK1_WDAY 4  \n#define YDAY_MINIMUM (-366)\nstatic int iso_week_days (int, int);\nstatic __inline int\niso_week_days (int yday, int wday)\n{\n   \n  int big_enough_multiple_of_7 = (-YDAY_MINIMUM / 7 + 2) * 7;\n  return (yday\n          - (yday - wday + ISO_WEEK1_WDAY + big_enough_multiple_of_7) % 7\n          + ISO_WEEK1_WDAY - ISO_WEEK_START_WDAY);\n}\n\n\n \n\n#if FPRINTFTIME\n# undef my_strftime\n# define my_strftime fprintftime\n#endif\n\n#ifdef my_strftime\n# define extra_args , tz, ns\n# define extra_args_spec , timezone_t tz, int ns\n#else\n# if defined COMPILE_WIDE\n#  define my_strftime wcsftime\n#  define nl_get_alt_digit _nl_get_walt_digit\n# else\n#  define my_strftime strftime\n#  define nl_get_alt_digit _nl_get_alt_digit\n# endif\n# define extra_args\n# define extra_args_spec\n \n# define tz 1\n# define ns 0\n#endif\n\nstatic size_t __strftime_internal (STREAM_OR_CHAR_T *, STRFTIME_ARG (size_t)\n                                   const CHAR_T *, const struct tm *,\n                                   bool, int, int, bool *\n                                   extra_args_spec LOCALE_PARAM);\n\n \nsize_t\nmy_strftime (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n             const CHAR_T *format,\n             const struct tm *tp extra_args_spec LOCALE_PARAM)\n{\n  bool tzset_called = false;\n  return __strftime_internal (s, STRFTIME_ARG (maxsize) format, tp, false,\n                              0, -1, &tzset_called extra_args LOCALE_ARG);\n}\nlibc_hidden_def (my_strftime)\n\n \nstatic size_t\n__strftime_internal (STREAM_OR_CHAR_T *s, STRFTIME_ARG (size_t maxsize)\n                     const CHAR_T *format,\n                     const struct tm *tp, bool upcase,\n                     int yr_spec, int width, bool *tzset_called\n                     extra_args_spec LOCALE_PARAM)\n{\n#if defined _LIBC && defined USE_IN_EXTENDED_LOCALE_MODEL\n  struct __locale_data *const current = loc->__locales[LC_TIME];\n#endif\n#if FPRINTFTIME\n  size_t maxsize = (size_t) -1;\n#endif\n\n  int saved_errno = errno;\n  int hour12 = tp->tm_hour;\n#ifdef _NL_CURRENT\n   \n# define a_wkday \\\n  ((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABDAY_1) + tp->tm_wday)))\n# define f_wkday \\\n  ((const CHAR_T *) (tp->tm_wday < 0 || tp->tm_wday > 6                      \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(DAY_1) + tp->tm_wday)))\n# define a_month \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABMON_1) + tp->tm_mon)))\n# define f_month \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(MON_1) + tp->tm_mon)))\n# define a_altmonth \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ABALTMON_1) + tp->tm_mon)))\n# define f_altmonth \\\n  ((const CHAR_T *) (tp->tm_mon < 0 || tp->tm_mon > 11                       \\\n                     ? \"?\" : _NL_CURRENT (LC_TIME, NLW(ALTMON_1) + tp->tm_mon)))\n# define ampm \\\n  ((const CHAR_T *) _NL_CURRENT (LC_TIME, tp->tm_hour > 11                    \\\n                                 ? NLW(PM_STR) : NLW(AM_STR)))\n\n# define aw_len STRLEN (a_wkday)\n# define am_len STRLEN (a_month)\n# define aam_len STRLEN (a_altmonth)\n# define ap_len STRLEN (ampm)\n#endif\n#if HAVE_TZNAME\n  char **tzname_vec = tzname;\n#endif\n  const char *zone;\n  size_t i = 0;\n  STREAM_OR_CHAR_T *p = s;\n  const CHAR_T *f;\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n  const char *format_end = NULL;\n#endif\n\n  zone = NULL;\n#if HAVE_STRUCT_TM_TM_ZONE\n   \n  zone = (const char *) tp->tm_zone;\n#endif\n#if HAVE_TZNAME\n  if (!tz)\n    {\n      if (! (zone && *zone))\n        zone = \"GMT\";\n    }\n  else\n    {\n# if !HAVE_STRUCT_TM_TM_ZONE\n       \n      tzname_vec = tz->tzname_copy;\n# endif\n    }\n   \n  if (!(zone && *zone) && tp->tm_isdst >= 0)\n    {\n       \n# ifndef my_strftime\n      if (!*tzset_called)\n        {\n          tzset ();\n          *tzset_called = true;\n        }\n# endif\n      zone = tzname_vec[tp->tm_isdst != 0];\n    }\n#endif\n  if (! zone)\n    zone = \"\";\n\n  if (hour12 > 12)\n    hour12 -= 12;\n  else\n    if (hour12 == 0)\n      hour12 = 12;\n\n  for (f = format; *f != '\\0'; width = -1, f++)\n    {\n      int pad = 0;   \n      int modifier;              \n      int digits = 0;            \n      int number_value;          \n      unsigned int u_number_value;  \n      bool negative_number;      \n      bool always_output_a_sign;  \n      int tz_colon_mask;         \n      const CHAR_T *subfmt;\n      CHAR_T *bufp;\n      CHAR_T buf[1\n                 + 2  \n                 + (sizeof (int) < sizeof (time_t)\n                    ? INT_STRLEN_BOUND (time_t)\n                    : INT_STRLEN_BOUND (int))];\n      bool to_lowcase = false;\n      bool to_uppcase = upcase;\n      size_t colons;\n      bool change_case = false;\n      int format_char;\n      int subwidth;\n\n#if DO_MULTIBYTE && !defined COMPILE_WIDE\n      switch (*f)\n        {\n        case L_('%'):\n          break;\n\n        case L_('\\b'): case L_('\\t'): case L_('\\n'):\n        case L_('\\v'): case L_('\\f'): case L_('\\r'):\n        case L_(' '): case L_('!'): case L_('\"'): case L_('#'): case L_('&'):\n        case L_('\\''): case L_('('): case L_(')'): case L_('*'): case L_('+'):\n        case L_(','): case L_('-'): case L_('.'): case L_('/'): case L_('0'):\n        case L_('1'): case L_('2'): case L_('3'): case L_('4'): case L_('5'):\n        case L_('6'): case L_('7'): case L_('8'): case L_('9'): case L_(':'):\n        case L_(';'): case L_('<'): case L_('='): case L_('>'): case L_('?'):\n        case L_('A'): case L_('B'): case L_('C'): case L_('D'): case L_('E'):\n        case L_('F'): case L_('G'): case L_('H'): case L_('I'): case L_('J'):\n        case L_('K'): case L_('L'): case L_('M'): case L_('N'): case L_('O'):\n        case L_('P'): case L_('Q'): case L_('R'): case L_('S'): case L_('T'):\n        case L_('U'): case L_('V'): case L_('W'): case L_('X'): case L_('Y'):\n        case L_('Z'): case L_('['): case L_('\\\\'): case L_(']'): case L_('^'):\n        case L_('_'): case L_('a'): case L_('b'): case L_('c'): case L_('d'):\n        case L_('e'): case L_('f'): case L_('g'): case L_('h'): case L_('i'):\n        case L_('j'): case L_('k'): case L_('l'): case L_('m'): case L_('n'):\n        case L_('o'): case L_('p'): case L_('q'): case L_('r'): case L_('s'):\n        case L_('t'): case L_('u'): case L_('v'): case L_('w'): case L_('x'):\n        case L_('y'): case L_('z'): case L_('{'): case L_('|'): case L_('}'):\n        case L_('~'):\n           \n          add1 (*f);\n          continue;\n\n        default:\n           \n          {\n            mbstate_t mbstate = mbstate_zero;\n            size_t len = 0;\n            size_t fsize;\n\n            if (! format_end)\n              format_end = f + strlen (f) + 1;\n            fsize = format_end - f;\n\n            do\n              {\n                size_t bytes = mbrlen (f + len, fsize - len, &mbstate);\n\n                if (bytes == 0)\n                  break;\n\n                if (bytes == (size_t) -2)\n                  {\n                    len += strlen (f + len);\n                    break;\n                  }\n\n                if (bytes == (size_t) -1)\n                  {\n                    len++;\n                    break;\n                  }\n\n                len += bytes;\n              }\n            while (! mbsinit (&mbstate));\n\n            cpy (len, f);\n            f += len - 1;\n            continue;\n          }\n        }\n\n#else  \n\n       \n      if (*f != L_('%'))\n        {\n          add1 (*f);\n          continue;\n        }\n\n#endif  \n\n      char const *percent = f;\n\n       \n      while (1)\n        {\n          switch (*++f)\n            {\n               \n            case L_('_'):\n            case L_('-'):\n            case L_('+'):\n            case L_('0'):\n              pad = *f;\n              continue;\n\n               \n            case L_('^'):\n              to_uppcase = true;\n              continue;\n            case L_('#'):\n              change_case = true;\n              continue;\n\n            default:\n              break;\n            }\n          break;\n        }\n\n      if (ISDIGIT (*f))\n        {\n          width = 0;\n          do\n            {\n              if (ckd_mul (&width, width, 10)\n                  || ckd_add (&width, width, *f - L_('0')))\n                width = INT_MAX;\n              ++f;\n            }\n          while (ISDIGIT (*f));\n        }\n\n       \n      switch (*f)\n        {\n        case L_('E'):\n        case L_('O'):\n          modifier = *f++;\n          break;\n\n        default:\n          modifier = 0;\n          break;\n        }\n\n       \n      format_char = *f;\n      switch (format_char)\n        {\n#define DO_NUMBER(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number;                                                 \\\n            }                                                                 \\\n          while (0)\n#define DO_SIGNED_NUMBER(d, negative, v) \\\n          DO_MAYBE_SIGNED_NUMBER (d, negative, v, do_signed_number)\n#define DO_YEARISH(d, negative, v) \\\n          DO_MAYBE_SIGNED_NUMBER (d, negative, v, do_yearish)\n#define DO_MAYBE_SIGNED_NUMBER(d, negative, v, label) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              negative_number = negative;                                     \\\n              u_number_value = v;                                             \\\n              goto label;                                                     \\\n            }                                                                 \\\n          while (0)\n\n           \n#define DO_TZ_OFFSET(d, mask, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              tz_colon_mask = mask;                                           \\\n              u_number_value = v;                                             \\\n              goto do_tz_offset;                                              \\\n            }                                                                 \\\n          while (0)\n#define DO_NUMBER_SPACEPAD(d, v) \\\n          do                                                                  \\\n            {                                                                 \\\n              digits = d;                                                     \\\n              number_value = v;                                               \\\n              goto do_number_spacepad;                                        \\\n            }                                                                 \\\n          while (0)\n\n        case L_('%'):\n          if (f - 1 != percent)\n            goto bad_percent;\n          add1 (*f);\n          break;\n\n        case L_('a'):\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (aw_len, a_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case 'A':\n          if (modifier != 0)\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          cpy (STRLEN (f_wkday), f_wkday);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('b'):\n        case L_('h'):\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n          if (modifier == L_('E'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (modifier == L_('O'))\n            cpy (aam_len, a_altmonth);\n          else\n            cpy (am_len, a_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('B'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          if (change_case)\n            {\n              to_uppcase = true;\n              to_lowcase = false;\n            }\n#ifdef _NL_CURRENT\n          if (modifier == L_('O'))\n            cpy (STRLEN (f_altmonth), f_altmonth);\n          else\n            cpy (STRLEN (f_month), f_month);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('c'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                     NLW(ERA_D_T_FMT)))\n                     != '\\0')))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_T_FMT));\n#else\n          goto underlying_strftime;\n#endif\n\n        subformat:\n          subwidth = -1;\n        subformat_width:\n          {\n            size_t len = __strftime_internal (NULL, STRFTIME_ARG ((size_t) -1)\n                                              subfmt, tp, to_uppcase,\n                                              pad, subwidth, tzset_called\n                                              extra_args LOCALE_ARG);\n            add (len, __strftime_internal (p,\n                                           STRFTIME_ARG (maxsize - i)\n                                           subfmt, tp, to_uppcase,\n                                           pad, subwidth, tzset_called\n                                           extra_args LOCALE_ARG));\n          }\n          break;\n\n#if !(defined _NL_CURRENT && HAVE_STRUCT_ERA_ENTRY)\n        underlying_strftime:\n          {\n             \n            char ufmt[5];\n            char *u = ufmt;\n            char ubuf[1024];  \n            size_t len;\n             \n# ifdef strftime\n#  undef strftime\n            size_t strftime ();\n# endif\n\n             \n            *u++ = ' ';\n            *u++ = '%';\n            if (modifier != 0)\n              *u++ = modifier;\n            *u++ = format_char;\n            *u = '\\0';\n            len = strftime (ubuf, sizeof ubuf, ufmt, tp);\n            if (len != 0)\n              cpy (len - 1, ubuf + 1);\n          }\n          break;\n#endif\n\n        case L_('C'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  size_t len = __wcslen (era->era_wname);\n                  cpy (len, era->era_wname);\n# else\n                  size_t len = strlen (era->era_name);\n                  cpy (len, era->era_name);\n# endif\n                  break;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            bool negative_year = tp->tm_year < - TM_YEAR_BASE;\n            bool zero_thru_1899 = !negative_year & (tp->tm_year < 0);\n            int century = ((tp->tm_year - 99 * zero_thru_1899) / 100\n                           + TM_YEAR_BASE / 100);\n            DO_YEARISH (2, negative_year, century);\n          }\n\n        case L_('x'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_D_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(D_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('D'):\n          if (modifier != 0)\n            goto bad_format;\n          subfmt = L_(\"%m/%d/%y\");\n          goto subformat;\n\n        case L_('d'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_mday);\n\n        case L_('e'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_mday);\n\n           \n\n        do_tz_offset:\n          always_output_a_sign = true;\n          goto do_number_body;\n\n        do_yearish:\n          if (pad == 0)\n            pad = yr_spec;\n          always_output_a_sign\n            = (pad == L_('+')\n               && ((digits == 2 ? 99 : 9999) < u_number_value\n                   || digits < width));\n          goto do_maybe_signed_number;\n\n        do_number_spacepad:\n          if (pad == 0)\n            pad = L_('_');\n\n        do_number:\n           \n          negative_number = number_value < 0;\n          u_number_value = number_value;\n\n        do_signed_number:\n          always_output_a_sign = false;\n\n        do_maybe_signed_number:\n          tz_colon_mask = 0;\n\n        do_number_body:\n           \n          if (modifier == L_('O') && !negative_number)\n            {\n#ifdef _NL_CURRENT\n               \n              const CHAR_T *cp = nl_get_alt_digit (u_number_value\n                                                   HELPER_LOCALE_ARG);\n\n              if (cp != NULL)\n                {\n                  size_t digitlen = STRLEN (cp);\n                  if (digitlen != 0)\n                    {\n                      cpy (digitlen, cp);\n                      break;\n                    }\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          bufp = buf + sizeof (buf) / sizeof (buf[0]);\n\n          if (negative_number)\n            u_number_value = - u_number_value;\n\n          do\n            {\n              if (tz_colon_mask & 1)\n                *--bufp = ':';\n              tz_colon_mask >>= 1;\n              *--bufp = u_number_value % 10 + L_('0');\n              u_number_value /= 10;\n            }\n          while (u_number_value != 0 || tz_colon_mask != 0);\n\n        do_number_sign_and_padding:\n          if (pad == 0)\n            pad = L_('0');\n          if (width < 0)\n            width = digits;\n\n          {\n            CHAR_T sign_char = (negative_number ? L_('-')\n                                : always_output_a_sign ? L_('+')\n                                : 0);\n            int numlen = buf + sizeof buf / sizeof buf[0] - bufp;\n            int shortage = width - !!sign_char - numlen;\n            int padding = pad == L_('-') || shortage <= 0 ? 0 : shortage;\n\n            if (sign_char)\n              {\n                if (pad == L_('_'))\n                  {\n                    if (p)\n                      memset_space (p, padding);\n                    i += padding;\n                    width -= padding;\n                  }\n                width_add1 (0, sign_char);\n                width--;\n              }\n\n            cpy (numlen, bufp);\n          }\n          break;\n\n        case L_('F'):\n          if (modifier != 0)\n            goto bad_format;\n          if (pad == 0 && width < 0)\n            {\n              pad = L_('+');\n              subwidth = 4;\n            }\n          else\n            {\n              subwidth = width - 6;\n              if (subwidth < 0)\n                subwidth = 0;\n            }\n          subfmt = L_(\"%Y-%m-%d\");\n          goto subformat_width;\n\n        case L_('H'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_hour);\n\n        case L_('I'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, hour12);\n\n        case L_('k'):            \n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, tp->tm_hour);\n\n        case L_('l'):            \n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER_SPACEPAD (2, hour12);\n\n        case L_('j'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (3, tp->tm_yday < -1, tp->tm_yday + 1U);\n\n        case L_('M'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_min);\n\n        case L_('m'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_SIGNED_NUMBER (2, tp->tm_mon < -1, tp->tm_mon + 1U);\n\n#ifndef _LIBC\n        case L_('N'):            \n          if (modifier == L_('E'))\n            goto bad_format;\n          {\n            int n = ns, ns_digits = 9;\n            if (width <= 0)\n              width = ns_digits;\n            int ndigs = ns_digits;\n            while (width < ndigs || (1 < ndigs && n % 10 == 0))\n              ndigs--, n /= 10;\n            for (int j = ndigs; 0 < j; j--)\n              buf[j - 1] = n % 10 + L_('0'), n /= 10;\n            if (!pad)\n              pad = L_('0');\n            width_cpy (0, ndigs, buf);\n            width_add (width - ndigs, 0, (void) 0);\n          }\n          break;\n#endif\n\n        case L_('n'):\n          add1 (L_('\\n'));\n          break;\n\n        case L_('P'):\n          to_lowcase = true;\n#ifndef _NL_CURRENT\n          format_char = L_('p');\n#endif\n          FALLTHROUGH;\n        case L_('p'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n#ifdef _NL_CURRENT\n          cpy (ap_len, ampm);\n          break;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('q'):            \n          DO_SIGNED_NUMBER (1, false, ((tp->tm_mon * 11) >> 5) + 1);\n\n        case L_('R'):\n          subfmt = L_(\"%H:%M\");\n          goto subformat;\n\n        case L_('r'):\n#ifdef _NL_CURRENT\n          if (*(subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME,\n                                                       NLW(T_FMT_AMPM)))\n              == L_('\\0'))\n            subfmt = L_(\"%I:%M:%S %p\");\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n\n        case L_('S'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, tp->tm_sec);\n\n        case L_('s'):            \n          {\n            struct tm ltm;\n            time_t t;\n\n            ltm = *tp;\n            ltm.tm_yday = -1;\n            t = mktime_z (tz, &ltm);\n            if (ltm.tm_yday < 0)\n              {\n                errno = EOVERFLOW;\n                return 0;\n              }\n\n             \n\n            bufp = buf + sizeof (buf) / sizeof (buf[0]);\n            negative_number = t < 0;\n\n            do\n              {\n                int d = t % 10;\n                t /= 10;\n                *--bufp = (negative_number ? -d : d) + L_('0');\n              }\n            while (t != 0);\n\n            digits = 1;\n            always_output_a_sign = false;\n            goto do_number_sign_and_padding;\n          }\n\n        case L_('X'):\n          if (modifier == L_('O'))\n            goto bad_format;\n#ifdef _NL_CURRENT\n          if (! (modifier == L_('E')\n                 && (*(subfmt =\n                       (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(ERA_T_FMT)))\n                     != L_('\\0'))))\n            subfmt = (const CHAR_T *) _NL_CURRENT (LC_TIME, NLW(T_FMT));\n          goto subformat;\n#else\n          goto underlying_strftime;\n#endif\n        case L_('T'):\n          subfmt = L_(\"%H:%M:%S\");\n          goto subformat;\n\n        case L_('t'):\n          add1 (L_('\\t'));\n          break;\n\n        case L_('u'):\n          DO_NUMBER (1, (tp->tm_wday - 1 + 7) % 7 + 1);\n\n        case L_('U'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - tp->tm_wday + 7) / 7);\n\n        case L_('V'):\n        case L_('g'):\n        case L_('G'):\n          if (modifier == L_('E'))\n            goto bad_format;\n          {\n             \n            int year = (tp->tm_year\n                        + (tp->tm_year < 0\n                           ? TM_YEAR_BASE % 400\n                           : TM_YEAR_BASE % 400 - 400));\n            int year_adjust = 0;\n            int days = iso_week_days (tp->tm_yday, tp->tm_wday);\n\n            if (days < 0)\n              {\n                 \n                year_adjust = -1;\n                days = iso_week_days (tp->tm_yday + (365 + __isleap (year - 1)),\n                                      tp->tm_wday);\n              }\n            else\n              {\n                int d = iso_week_days (tp->tm_yday - (365 + __isleap (year)),\n                                       tp->tm_wday);\n                if (0 <= d)\n                  {\n                     \n                    year_adjust = 1;\n                    days = d;\n                  }\n              }\n\n            switch (*f)\n              {\n              case L_('g'):\n                {\n                  int yy = (tp->tm_year % 100 + year_adjust) % 100;\n                  DO_YEARISH (2, false,\n                              (0 <= yy\n                               ? yy\n                               : tp->tm_year < -TM_YEAR_BASE - year_adjust\n                               ? -yy\n                               : yy + 100));\n                }\n\n              case L_('G'):\n                DO_YEARISH (4, tp->tm_year < -TM_YEAR_BASE - year_adjust,\n                            (tp->tm_year + (unsigned int) TM_YEAR_BASE\n                             + year_adjust));\n\n              default:\n                DO_NUMBER (2, days / 7 + 1);\n              }\n          }\n\n        case L_('W'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (2, (tp->tm_yday - (tp->tm_wday - 1 + 7) % 7 + 7) / 7);\n\n        case L_('w'):\n          if (modifier == L_('E'))\n            goto bad_format;\n\n          DO_NUMBER (1, tp->tm_wday);\n\n        case L_('Y'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n# ifdef COMPILE_WIDE\n                  subfmt = era->era_wformat;\n# else\n                  subfmt = era->era_format;\n# endif\n                  if (pad == 0)\n                    pad = yr_spec;\n                  goto subformat;\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n          if (modifier == L_('O'))\n            goto bad_format;\n\n          DO_YEARISH (4, tp->tm_year < -TM_YEAR_BASE,\n                      tp->tm_year + (unsigned int) TM_YEAR_BASE);\n\n        case L_('y'):\n          if (modifier == L_('E'))\n            {\n#if HAVE_STRUCT_ERA_ENTRY\n              struct era_entry *era = _nl_get_era_entry (tp HELPER_LOCALE_ARG);\n              if (era)\n                {\n                  int delta = tp->tm_year - era->start_date[0];\n                  if (pad == 0)\n                    pad = yr_spec;\n                  DO_NUMBER (2, (era->offset\n                                 + delta * era->absolute_direction));\n                }\n#else\n              goto underlying_strftime;\n#endif\n            }\n\n          {\n            int yy = tp->tm_year % 100;\n            if (yy < 0)\n              yy = tp->tm_year < - TM_YEAR_BASE ? -yy : yy + 100;\n            DO_YEARISH (2, false, yy);\n          }\n\n        case L_('Z'):\n          if (change_case)\n            {\n              to_uppcase = false;\n              to_lowcase = true;\n            }\n\n#ifdef COMPILE_WIDE\n          {\n             \n            size_t w = pad == L_('-') || width < 0 ? 0 : width;\n            char const *z = zone;\n            mbstate_t st = {0};\n            size_t len = __mbsrtowcs_l (p, &z, maxsize - i, &st, loc);\n            if (len == (size_t) -1)\n              return 0;\n            size_t incr = len < w ? w : len;\n            if (incr >= maxsize - i)\n              {\n                errno = ERANGE;\n                return 0;\n              }\n            if (p)\n              {\n                if (len < w)\n                  {\n                    size_t delta = w - len;\n                    __wmemmove (p + delta, p, len);\n                    wchar_t wc = pad == L_('0') || pad == L_('+') ? L'0' : L' ';\n                    wmemset (p, wc, delta);\n                  }\n                p += incr;\n              }\n            i += incr;\n          }\n#else\n          cpy (strlen (zone), zone);\n#endif\n          break;\n\n        case L_(':'):\n           \n          for (colons = 1; f[colons] == L_(':'); colons++)\n            continue;\n          if (f[colons] != L_('z'))\n            goto bad_format;\n          f += colons;\n          goto do_z_conversion;\n\n        case L_('z'):\n          colons = 0;\n\n        do_z_conversion:\n          if (tp->tm_isdst < 0)\n            break;\n\n          {\n            int diff;\n            int hour_diff;\n            int min_diff;\n            int sec_diff;\n#if HAVE_TM_GMTOFF\n            diff = tp->tm_gmtoff;\n#else\n            if (!tz)\n              diff = 0;\n            else\n              {\n                struct tm gtm;\n                struct tm ltm;\n                time_t lt;\n\n                 \n# ifndef my_strftime\n                if (!*tzset_called)\n                  {\n                    tzset ();\n                    *tzset_called = true;\n                  }\n# endif\n\n                ltm = *tp;\n                ltm.tm_wday = -1;\n                lt = mktime_z (tz, &ltm);\n                if (ltm.tm_wday < 0 || ! localtime_rz (0, &lt, &gtm))\n                  break;\n                diff = tm_diff (&ltm, &gtm);\n              }\n#endif\n\n            negative_number = diff < 0 || (diff == 0 && *zone == '-');\n            hour_diff = diff / 60 / 60;\n            min_diff = diff / 60 % 60;\n            sec_diff = diff % 60;\n\n            switch (colons)\n              {\n              case 0:  \n                DO_TZ_OFFSET (5, 0, hour_diff * 100 + min_diff);\n\n              case 1: tz_hh_mm:  \n                DO_TZ_OFFSET (6, 04, hour_diff * 100 + min_diff);\n\n              case 2: tz_hh_mm_ss:  \n                DO_TZ_OFFSET (9, 024,\n                              hour_diff * 10000 + min_diff * 100 + sec_diff);\n\n              case 3:  \n                if (sec_diff != 0)\n                  goto tz_hh_mm_ss;\n                if (min_diff != 0)\n                  goto tz_hh_mm;\n                DO_TZ_OFFSET (3, 0, hour_diff);\n\n              default:\n                goto bad_format;\n              }\n          }\n\n        case L_('\\0'):           \n        bad_percent:\n            --f;\n            FALLTHROUGH;\n        default:\n           \n        bad_format:\n          cpy (f - percent + 1, percent);\n          break;\n        }\n    }\n\n#if ! FPRINTFTIME\n  if (p && maxsize != 0)\n    *p = L_('\\0');\n#endif\n\n  errno = saved_errno;\n  return i;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}