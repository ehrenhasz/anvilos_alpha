{
  "module_name": "savedir.c",
  "hash_id": "5706dbad47179d6a3675c1656d982a6dd44938d43575946b6c89221b266fae63",
  "original_prompt": "Ingested from coreutils-9.4/lib/savedir.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"savedir.h\"\n\n#include <sys/types.h>\n\n#include <errno.h>\n\n#include \"dirent--.h\"\n#ifndef _D_EXACT_NAMLEN\n# define _D_EXACT_NAMLEN(dp)    strlen ((dp)->d_name)\n#endif\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"xalloc.h\"\n\ntypedef struct\n{\n  char *name;\n#if D_INO_IN_DIRENT\n  ino_t ino;\n#endif\n} direntry_t;\n\n \n\nstatic int\ndirentry_cmp_name (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return strcmp (dea->name, deb->name);\n}\n\n#if D_INO_IN_DIRENT\n \n\nstatic int\ndirentry_cmp_inode (void const *a, void const *b)\n{\n  direntry_t const *dea = a;\n  direntry_t const *deb = b;\n\n  return _GL_CMP (dea->ino, deb->ino);\n}\n#endif\n\ntypedef int (*comparison_function) (void const *, void const *);\n\nstatic comparison_function const comparison_function_table[] =\n  {\n    0,\n    direntry_cmp_name\n#if D_INO_IN_DIRENT\n    , direntry_cmp_inode\n#endif\n  };\n\n \n\nchar *\nstreamsavedir (DIR *dirp, enum savedir_option option)\n{\n  char *name_space = NULL;\n  idx_t allocated = 0;\n  direntry_t *entries = NULL;\n  idx_t entries_allocated = 0;\n  idx_t entries_used = 0;\n  idx_t used = 0;\n  comparison_function cmp = comparison_function_table[option];\n\n  if (dirp == NULL)\n    return NULL;\n\n  for (;;)\n    {\n      struct dirent const *dp;\n      char const *entry;\n\n      errno = 0;\n      dp = readdir (dirp);\n      if (! dp)\n        break;\n\n       \n      entry = dp->d_name;\n      if (entry[entry[0] != '.' ? 0 : entry[1] != '.' ? 1 : 2] != '\\0')\n        {\n          idx_t entry_size = _D_EXACT_NAMLEN (dp) + 1;\n          if (cmp)\n            {\n              if (entries_allocated == entries_used)\n                entries = xpalloc (entries, &entries_allocated, 1, -1,\n                                   sizeof *entries);\n              entries[entries_used].name = xstrdup (entry);\n#if D_INO_IN_DIRENT\n              entries[entries_used].ino = dp->d_ino;\n#endif\n              entries_used++;\n            }\n          else\n            {\n              if (allocated - used <= entry_size)\n                name_space = xpalloc (name_space, &allocated,\n                                      entry_size - (allocated - used),\n                                      IDX_MAX - 1, sizeof *name_space);\n              memcpy (name_space + used, entry, entry_size);\n            }\n          used += entry_size;\n        }\n    }\n\n  if (errno != 0)\n    {\n      free (entries);\n      free (name_space);\n      return NULL;\n    }\n\n  if (cmp)\n    {\n      if (entries_used)\n        qsort (entries, entries_used, sizeof *entries, cmp);\n      name_space = ximalloc (used + 1);\n      used = 0;\n      for (idx_t i = 0; i < entries_used; i++)\n        {\n          char *dest = name_space + used;\n          used += stpcpy (dest, entries[i].name) - dest + 1;\n          free (entries[i].name);\n        }\n      free (entries);\n    }\n  else if (used == allocated)\n    name_space = xirealloc (name_space, used + 1);\n\n  name_space[used] = '\\0';\n  return name_space;\n}\n\n \n\nchar *\nsavedir (char const *dir, enum savedir_option option)\n{\n  DIR *dirp = opendir (dir);\n  if (! dirp)\n    return NULL;\n  else\n    {\n      char *name_space = streamsavedir (dirp, option);\n      if (closedir (dirp) != 0)\n        {\n          free (name_space);\n          return NULL;\n        }\n      return name_space;\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}