{
  "module_name": "obstack.h",
  "hash_id": "04448700e059e80386fdcd53091668823793e9c3122de4c306b8355282d48c2f",
  "original_prompt": "Ingested from coreutils-9.4/lib/obstack.h",
  "human_readable_source": " \n\n\n \n\n#ifndef _OBSTACK_H\n#define _OBSTACK_H 1\n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#ifndef _OBSTACK_INTERFACE_VERSION\n# define _OBSTACK_INTERFACE_VERSION 2\n#endif\n\n#include <stddef.h>              \n#include <string.h>              \n\n#if __STDC_VERSION__ < 199901L || defined __HP_cc\n# define __FLEXIBLE_ARRAY_MEMBER 1\n#else\n# define __FLEXIBLE_ARRAY_MEMBER\n#endif\n\n#if _OBSTACK_INTERFACE_VERSION == 1\n \n# define _OBSTACK_SIZE_T unsigned int\n# define _CHUNK_SIZE_T unsigned long\n# define _OBSTACK_CAST(type, expr) ((type) (expr))\n#else\n \n# define _OBSTACK_SIZE_T size_t\n# define _CHUNK_SIZE_T size_t\n# define _OBSTACK_CAST(type, expr) (expr)\n#endif\n\n \n\n#define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))\n\n \n\n#define __PTR_ALIGN(B, P, A)\t\t\t\t\t\t      \\\n  __BPTR_ALIGN (sizeof (ptrdiff_t) < sizeof (void *) ? (B) : (char *) 0,      \\\n                P, A)\n\n#ifndef __attribute_pure__\n# define __attribute_pure__ _GL_ATTRIBUTE_PURE\n#endif\n\n \n#ifndef __attribute_noreturn__\n# if 2 < __GNUC__ + (8 <= __GNUC_MINOR__) || defined __clang__ || 0x5110 <= __SUNPRO_C\n#  define __attribute_noreturn__ __attribute__ ((__noreturn__))\n# else\n#  define __attribute_noreturn__\n# endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct _obstack_chunk            \n{\n  char *limit;                   \n  struct _obstack_chunk *prev;   \n  char contents[__FLEXIBLE_ARRAY_MEMBER];  \n};\n\nstruct obstack           \n{\n  _CHUNK_SIZE_T chunk_size;      \n  struct _obstack_chunk *chunk;  \n  char *object_base;             \n  char *next_free;               \n  char *chunk_limit;             \n  union\n  {\n    _OBSTACK_SIZE_T i;\n    void *p;\n  } temp;                        \n  _OBSTACK_SIZE_T alignment_mask;   \n\n   \n  union\n  {\n    void *(*plain) (size_t);\n    void *(*extra) (void *, size_t);\n  } chunkfun;\n  union\n  {\n    void (*plain) (void *);\n    void (*extra) (void *, void *);\n  } freefun;\n\n  void *extra_arg;               \n  unsigned use_extra_arg : 1;      \n  unsigned maybe_empty_object : 1;  \n  unsigned alloc_failed : 1;       \n};\n\n \n\nextern void _obstack_newchunk (struct obstack *, _OBSTACK_SIZE_T);\nextern void _obstack_free (struct obstack *, void *);\nextern int _obstack_begin (struct obstack *,\n                           _OBSTACK_SIZE_T, _OBSTACK_SIZE_T,\n                           void *(*) (size_t), void (*) (void *));\nextern int _obstack_begin_1 (struct obstack *,\n                             _OBSTACK_SIZE_T, _OBSTACK_SIZE_T,\n                             void *(*) (void *, size_t),\n                             void (*) (void *, void *), void *);\nextern _OBSTACK_SIZE_T _obstack_memory_used (struct obstack *)\n  __attribute_pure__;\n\n\n \nextern __attribute_noreturn__ void (*obstack_alloc_failed_handler) (void);\n\n \nextern int obstack_exit_failure;\n\n \n\n#define obstack_base(h) ((void *) (h)->object_base)\n\n \n\n#define obstack_chunk_size(h) ((h)->chunk_size)\n\n \n\n#define obstack_next_free(h) ((void *) (h)->next_free)\n\n \n\n#define obstack_alignment_mask(h) ((h)->alignment_mask)\n\n \n#define obstack_init(h)\t\t\t\t\t\t\t      \\\n  _obstack_begin ((h), 0, 0,\t\t\t\t\t\t      \\\n                  _OBSTACK_CAST (void *(*) (size_t), obstack_chunk_alloc),    \\\n                  _OBSTACK_CAST (void (*) (void *), obstack_chunk_free))\n\n#define obstack_begin(h, size)\t\t\t\t\t\t      \\\n  _obstack_begin ((h), (size), 0,\t\t\t\t\t      \\\n                  _OBSTACK_CAST (void *(*) (size_t), obstack_chunk_alloc), \\\n                  _OBSTACK_CAST (void (*) (void *), obstack_chunk_free))\n\n#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)     \\\n  _obstack_begin ((h), (size), (alignment),\t\t\t\t      \\\n                  _OBSTACK_CAST (void *(*) (size_t), chunkfun),\t\t      \\\n                  _OBSTACK_CAST (void (*) (void *), freefun))\n\n#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n  _obstack_begin_1 ((h), (size), (alignment),\t\t\t\t      \\\n                    _OBSTACK_CAST (void *(*) (void *, size_t), chunkfun),     \\\n                    _OBSTACK_CAST (void (*) (void *, void *), freefun), arg)\n\n#define obstack_chunkfun(h, newchunkfun)\t\t\t\t      \\\n  ((void) ((h)->chunkfun.extra = (void *(*) (void *, size_t)) (newchunkfun)))\n\n#define obstack_freefun(h, newfreefun)\t\t\t\t\t      \\\n  ((void) ((h)->freefun.extra = (void *(*) (void *, void *)) (newfreefun)))\n\n#define obstack_1grow_fast(h, achar) ((void) (*((h)->next_free)++ = (achar)))\n\n#define obstack_blank_fast(h, n) ((void) ((h)->next_free += (n)))\n\n#define obstack_memory_used(h) _obstack_memory_used (h)\n\n#if defined __GNUC__ || defined __clang__\n# if !(defined __GNUC_MINOR__ && __GNUC__ * 1000 + __GNUC_MINOR__ >= 2008 \\\n       || defined __clang__)\n#  define __extension__\n# endif\n\n \n\n# define obstack_object_size(OBSTACK)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack const *__o = (OBSTACK);\t\t\t\t      \\\n       (_OBSTACK_SIZE_T) (__o->next_free - __o->object_base); })\n\n \n# define obstack_room(OBSTACK)\t\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack const *__o1 = (OBSTACK);\t\t\t\t      \\\n       (_OBSTACK_SIZE_T) (__o1->chunk_limit - __o1->next_free); })\n\n# define obstack_make_room(OBSTACK, length)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n       if (obstack_room (__o) < __len)\t\t\t\t\t      \\\n         _obstack_newchunk (__o, __len);\t\t\t\t      \\\n       (void) 0; })\n\n# define obstack_empty_p(OBSTACK)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack const *__o = (OBSTACK);\t\t\t\t      \\\n       (__o->chunk->prev == 0\t\t\t\t\t\t      \\\n        && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,\t\t      \\\n                                          __o->chunk->contents,\t\t      \\\n                                          __o->alignment_mask)); })\n\n# define obstack_grow(OBSTACK, where, length)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n       if (obstack_room (__o) < __len)\t\t\t\t\t      \\\n         _obstack_newchunk (__o, __len);\t\t\t\t      \\\n       memcpy (__o->next_free, where, __len);\t\t\t\t      \\\n       __o->next_free += __len;\t\t\t\t\t\t      \\\n       (void) 0; })\n\n# define obstack_grow0(OBSTACK, where, length)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n       if (obstack_room (__o) < __len + 1)\t\t\t\t      \\\n         _obstack_newchunk (__o, __len + 1);\t\t\t\t      \\\n       memcpy (__o->next_free, where, __len);\t\t\t\t      \\\n       __o->next_free += __len;\t\t\t\t\t\t      \\\n       *(__o->next_free)++ = 0;\t\t\t\t\t\t      \\\n       (void) 0; })\n\n# define obstack_1grow(OBSTACK, datum)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       if (obstack_room (__o) < 1)\t\t\t\t\t      \\\n         _obstack_newchunk (__o, 1);\t\t\t\t\t      \\\n       obstack_1grow_fast (__o, datum); })\n\n \n\n# define obstack_ptr_grow(OBSTACK, datum)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       if (obstack_room (__o) < sizeof (void *))\t\t\t      \\\n         _obstack_newchunk (__o, sizeof (void *));\t\t\t      \\\n       obstack_ptr_grow_fast (__o, datum); })\n\n# define obstack_int_grow(OBSTACK, datum)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       if (obstack_room (__o) < sizeof (int))\t\t\t\t      \\\n         _obstack_newchunk (__o, sizeof (int));\t\t\t\t      \\\n       obstack_int_grow_fast (__o, datum); })\n\n# define obstack_ptr_grow_fast(OBSTACK, aptr)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t      \\\n       void *__p1 = __o1->next_free;\t\t\t\t\t      \\\n       *(const void **) __p1 = (aptr);\t\t\t\t\t      \\\n       __o1->next_free += sizeof (const void *);\t\t\t      \\\n       (void) 0; })\n\n# define obstack_int_grow_fast(OBSTACK, aint)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t      \\\n       void *__p1 = __o1->next_free;\t\t\t\t\t      \\\n       *(int *) __p1 = (aint);\t\t\t\t\t\t      \\\n       __o1->next_free += sizeof (int);\t\t\t\t\t      \\\n       (void) 0; })\n\n# define obstack_blank(OBSTACK, length)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       _OBSTACK_SIZE_T __len = (length);\t\t\t\t      \\\n       if (obstack_room (__o) < __len)\t\t\t\t\t      \\\n         _obstack_newchunk (__o, __len);\t\t\t\t      \\\n       obstack_blank_fast (__o, __len); })\n\n# define obstack_alloc(OBSTACK, length)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t      \\\n       obstack_blank (__h, (length));\t\t\t\t\t      \\\n       obstack_finish (__h); })\n\n# define obstack_copy(OBSTACK, where, length)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t      \\\n       obstack_grow (__h, (where), (length));\t\t\t\t      \\\n       obstack_finish (__h); })\n\n# define obstack_copy0(OBSTACK, where, length)\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__h = (OBSTACK);\t\t\t\t\t      \\\n       obstack_grow0 (__h, (where), (length));\t\t\t\t      \\\n       obstack_finish (__h); })\n\n \n# define obstack_finish(OBSTACK)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o1 = (OBSTACK);\t\t\t\t      \\\n       void *__value = (void *) __o1->object_base;\t\t\t      \\\n       if (__o1->next_free == __value)\t\t\t\t\t      \\\n         __o1->maybe_empty_object = 1;\t\t\t\t\t      \\\n       __o1->next_free\t\t\t\t\t\t\t      \\\n         = __PTR_ALIGN (__o1->object_base, __o1->next_free,\t\t      \\\n                        __o1->alignment_mask);\t\t\t\t      \\\n       if ((size_t) (__o1->next_free - (char *) __o1->chunk)\t\t      \\\n           > (size_t) (__o1->chunk_limit - (char *) __o1->chunk))\t      \\\n         __o1->next_free = __o1->chunk_limit;\t\t\t\t      \\\n       __o1->object_base = __o1->next_free;\t\t\t\t      \\\n       __value; })\n\n# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t      \\\n  __extension__\t\t\t\t\t\t\t\t      \\\n    ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t      \\\n       void *__obj = (void *) (OBJ);\t\t\t\t\t      \\\n       if (__obj > (void *) __o->chunk && __obj < (void *) __o->chunk_limit)  \\\n         __o->next_free = __o->object_base = (char *) __obj;\t\t      \\\n       else\t\t\t\t\t\t\t\t      \\\n         _obstack_free (__o, __obj); })\n\n#else  \n\n# define obstack_object_size(h)\t\t\t\t\t\t      \\\n  ((_OBSTACK_SIZE_T) ((h)->next_free - (h)->object_base))\n\n# define obstack_room(h)\t\t\t\t\t\t      \\\n  ((_OBSTACK_SIZE_T) ((h)->chunk_limit - (h)->next_free))\n\n# define obstack_empty_p(h)\t\t\t\t\t\t      \\\n  ((h)->chunk->prev == 0\t\t\t\t\t\t      \\\n   && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,\t\t      \\\n                                     (h)->chunk->contents,\t\t      \\\n                                     (h)->alignment_mask))\n\n \n\n# define obstack_make_room(h, length)\t\t\t\t\t      \\\n  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n   ((obstack_room (h) < (h)->temp.i)\t\t\t\t\t      \\\n    ? (_obstack_newchunk (h, (h)->temp.i), 0) : 0),\t\t\t      \\\n   (void) 0)\n\n# define obstack_grow(h, where, length)\t\t\t\t\t      \\\n  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n   ((obstack_room (h) < (h)->temp.i)\t\t\t\t\t      \\\n   ? (_obstack_newchunk ((h), (h)->temp.i), 0) : 0),\t\t\t      \\\n   memcpy ((h)->next_free, where, (h)->temp.i),\t\t\t\t      \\\n   (h)->next_free += (h)->temp.i,\t\t\t\t\t      \\\n   (void) 0)\n\n# define obstack_grow0(h, where, length)\t\t\t\t      \\\n  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n   ((obstack_room (h) < (h)->temp.i + 1)\t\t\t\t      \\\n   ? (_obstack_newchunk ((h), (h)->temp.i + 1), 0) : 0),\t\t      \\\n   memcpy ((h)->next_free, where, (h)->temp.i),\t\t\t\t      \\\n   (h)->next_free += (h)->temp.i,\t\t\t\t\t      \\\n   *((h)->next_free)++ = 0,\t\t\t\t\t\t      \\\n   (void) 0)\n\n# define obstack_1grow(h, datum)\t\t\t\t\t      \\\n  (((obstack_room (h) < 1)\t\t\t\t\t\t      \\\n    ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t      \\\n   obstack_1grow_fast (h, datum))\n\n# define obstack_ptr_grow(h, datum)\t\t\t\t\t      \\\n  (((obstack_room (h) < sizeof (char *))\t\t\t\t      \\\n    ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t      \\\n   obstack_ptr_grow_fast (h, datum))\n\n# define obstack_int_grow(h, datum)\t\t\t\t\t      \\\n  (((obstack_room (h) < sizeof (int))\t\t\t\t\t      \\\n    ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t      \\\n   obstack_int_grow_fast (h, datum))\n\n# define obstack_ptr_grow_fast(h, aptr)\t\t\t\t\t      \\\n  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr),\t      \\\n   (void) 0)\n\n# define obstack_int_grow_fast(h, aint)\t\t\t\t\t      \\\n  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint),\t\t      \\\n   (void) 0)\n\n# define obstack_blank(h, length)\t\t\t\t\t      \\\n  ((h)->temp.i = (length),\t\t\t\t\t\t      \\\n   ((obstack_room (h) < (h)->temp.i)\t\t\t\t\t      \\\n   ? (_obstack_newchunk ((h), (h)->temp.i), 0) : 0),\t\t\t      \\\n   obstack_blank_fast (h, (h)->temp.i))\n\n# define obstack_alloc(h, length)\t\t\t\t\t      \\\n  (obstack_blank ((h), (length)), obstack_finish ((h)))\n\n# define obstack_copy(h, where, length)\t\t\t\t\t      \\\n  (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n\n# define obstack_copy0(h, where, length)\t\t\t\t      \\\n  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n\n# define obstack_finish(h)\t\t\t\t\t\t      \\\n  (((h)->next_free == (h)->object_base\t\t\t\t\t      \\\n    ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t      \\\n    : 0),\t\t\t\t\t\t\t\t      \\\n   (h)->temp.p = (h)->object_base,\t\t\t\t\t      \\\n   (h)->next_free\t\t\t\t\t\t\t      \\\n     = __PTR_ALIGN ((h)->object_base, (h)->next_free,\t\t\t      \\\n                    (h)->alignment_mask),\t\t\t\t      \\\n   (((size_t) ((h)->next_free - (char *) (h)->chunk)\t\t\t      \\\n     > (size_t) ((h)->chunk_limit - (char *) (h)->chunk))\t\t      \\\n   ? ((h)->next_free = (h)->chunk_limit) : 0),\t\t\t\t      \\\n   (h)->object_base = (h)->next_free,\t\t\t\t\t      \\\n   (h)->temp.p)\n\n# define obstack_free(h, obj)\t\t\t\t\t\t      \\\n  ((h)->temp.p = (void *) (obj),\t\t\t\t\t      \\\n   (((h)->temp.p > (void *) (h)->chunk\t\t\t\t\t      \\\n     && (h)->temp.p < (void *) (h)->chunk_limit)\t\t\t      \\\n    ? (void) ((h)->next_free = (h)->object_base = (char *) (h)->temp.p)       \\\n    : _obstack_free ((h), (h)->temp.p)))\n\n#endif  \n\n#ifdef __cplusplus\n}        \n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}