{
  "module_name": "openat.c",
  "hash_id": "93c9fde63a17dafe596f3854db4dc3cb23f8c817ef5bd4a6287aed15d832d13a",
  "original_prompt": "Ingested from coreutils-9.4/lib/openat.c",
  "human_readable_source": " \n\n \n#define __need_system_fcntl_h\n#include <config.h>\n\n \n#include <fcntl.h>\n#include <sys/types.h>\n#undef __need_system_fcntl_h\n\n#if HAVE_OPENAT\nstatic int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}\n#endif\n\n \n#include \"fcntl.h\"\n\n#include \"openat.h\"\n\n#include \"cloexec.h\"\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <errno.h>\n\n#if HAVE_OPENAT\n\n \nint\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n   \n#if GNULIB_defined_O_CLOEXEC\n  int have_cloexec = -1;\n#else\n  static int have_cloexec;\n#endif\n\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n       \n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n   \n  if ((flags & O_CREAT)\n      || (flags & O_ACCMODE) == O_RDWR\n      || (flags & O_ACCMODE) == O_WRONLY)\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename,\n                    flags & ~(have_cloexec < 0 ? O_CLOEXEC : 0), mode);\n\n  if (flags & O_CLOEXEC)\n    {\n      if (! have_cloexec)\n        {\n          if (0 <= fd)\n            have_cloexec = 1;\n          else if (errno == EINVAL)\n            {\n              fd = orig_openat (dfd, filename, flags & ~O_CLOEXEC, mode);\n              have_cloexec = -1;\n            }\n        }\n      if (have_cloexec < 0 && 0 <= fd)\n        set_cloexec_flag (fd, true);\n    }\n\n\n# if OPEN_TRAILING_SLASH_BUG\n   \n  if (fd >= 0)\n    {\n       \n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}\n\n#else  \n\n# include \"filename.h\"  \n# include \"openat-priv.h\"\n# include \"save-cwd.h\"\n\n \nint\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n       \n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}\n\n \n\nint\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n         \n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n       \n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n               \n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}\n\n \nbool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH | O_CLOEXEC);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}