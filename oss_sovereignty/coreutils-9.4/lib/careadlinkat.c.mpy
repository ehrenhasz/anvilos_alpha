{
  "module_name": "careadlinkat.c",
  "hash_id": "1d35ce9fc616f32b1ed3eb95d96a29ede80bea4b188abcba613f5579b57217d6",
  "original_prompt": "Ingested from coreutils-9.4/lib/careadlinkat.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"careadlinkat.h\"\n\n#include \"idx.h\"\n#include \"minmax.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n\n \n#ifndef SIZE_MAX\n# define SIZE_MAX ((size_t) -1)\n#endif\n\n#include \"allocator.h\"\n\nenum { STACK_BUF_SIZE = 1024 };\n\n \n#if _GL_GNUC_PREREQ (10, 1)\n# if _GL_GNUC_PREREQ (12, 1)\n#  pragma GCC diagnostic ignored \"-Wreturn-local-addr\"\n# elif defined GCC_LINT || defined lint\n__attribute__ ((__noinline__))\n# elif __OPTIMIZE__ && !__NO_INLINE__\n#  define GCC_BOGUS_WRETURN_LOCAL_ADDR\n# endif\n#endif\nstatic char *\nreadlink_stk (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t),\n              char stack_buf[STACK_BUF_SIZE])\n{\n  if (! alloc)\n    alloc = &stdlib_allocator;\n\n  if (!buffer)\n    {\n      buffer = stack_buf;\n      buffer_size = STACK_BUF_SIZE;\n    }\n\n  char *buf = buffer;\n  idx_t buf_size_max = MIN (IDX_MAX, MIN (SSIZE_MAX, SIZE_MAX));\n  idx_t buf_size = MIN (buffer_size, buf_size_max);\n\n  while (buf)\n    {\n       \n      idx_t link_length = preadlinkat (fd, filename, buf, buf_size);\n      if (link_length < 0)\n        {\n          if (buf != buffer)\n            {\n              int readlinkat_errno = errno;\n              alloc->free (buf);\n              errno = readlinkat_errno;\n            }\n          return NULL;\n        }\n\n      idx_t link_size = link_length;\n\n      if (link_size < buf_size)\n        {\n          buf[link_size++] = '\\0';\n\n          if (buf == stack_buf)\n            {\n              char *b = alloc->allocate (link_size);\n              buf_size = link_size;\n              if (! b)\n                break;\n              return memcpy (b, buf, link_size);\n            }\n\n          if (link_size < buf_size && buf != buffer && alloc->reallocate)\n            {\n               \n              char *b = alloc->reallocate (buf, link_size);\n              if (b)\n                return b;\n            }\n\n          return buf;\n        }\n\n      if (buf != buffer)\n        alloc->free (buf);\n\n      if (buf_size_max / 2 <= buf_size)\n        {\n          errno = ENAMETOOLONG;\n          return NULL;\n        }\n\n      buf_size = 2 * buf_size + 1;\n      buf = alloc->allocate (buf_size);\n    }\n\n  if (alloc->die)\n    alloc->die (buf_size);\n  errno = ENOMEM;\n  return NULL;\n}\n\n\n \n\nchar *\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))\n{\n   \n  #ifdef GCC_BOGUS_WRETURN_LOCAL_ADDR\n   #warning \"GCC might issue a bogus -Wreturn-local-addr warning here.\"\n   #warning \"See <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93644>.\"\n  #endif\n  char stack_buf[STACK_BUF_SIZE];\n  return readlink_stk (fd, filename, buffer, buffer_size, alloc,\n                       preadlinkat, stack_buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}