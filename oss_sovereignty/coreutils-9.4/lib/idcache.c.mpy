{
  "module_name": "idcache.c",
  "hash_id": "d7480da5de9f0d5935040a70e20afdb58924dc15aa133cbce3bf031f135a6094",
  "original_prompt": "Ingested from coreutils-9.4/lib/idcache.c",
  "human_readable_source": " \n\nstatic struct userid *user_alist;\n\n \nstatic struct userid *nouser_alist;\n\n \nstatic struct userid *group_alist;\n\n \nstatic struct userid *nogroup_alist;\n\n \n\nchar *\ngetuser (uid_t uid)\n{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = user_alist; tail; tail = tail->next)\n    {\n      if (tail->id.u == uid)\n        {\n          match = tail;\n          break;\n        }\n    }\n\n  if (match == NULL)\n    {\n      struct passwd *pwent = getpwuid (uid);\n      char const *name = pwent ? pwent->pw_name : \"\";\n      match = xmalloc (FLEXSIZEOF (struct userid, name, strlen (name) + 1));\n      match->id.u = uid;\n      strcpy (match->name, name);\n\n       \n      match->next = user_alist;\n      user_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}\n\n \n\nuid_t *\ngetuidbyname (const char *user)\n{\n  struct userid *tail;\n  struct passwd *pwent;\n\n  for (tail = user_alist; tail; tail = tail->next)\n     \n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return &tail->id.u;\n\n  for (tail = nouser_alist; tail; tail = tail->next)\n     \n    if (*tail->name == *user && !strcmp (tail->name, user))\n      return NULL;\n\n  pwent = getpwnam (user);\n#ifdef __DJGPP__\n   \n  if (!pwent && strspn (user, digits) < strlen (user))\n    {\n      setenv (\"USER\", user, 1);\n      pwent = getpwnam (user);   \n    }\n#endif\n\n  tail = xmalloc (FLEXSIZEOF (struct userid, name, strlen (user) + 1));\n  strcpy (tail->name, user);\n\n   \n  if (pwent)\n    {\n      tail->id.u = pwent->pw_uid;\n      tail->next = user_alist;\n      user_alist = tail;\n      return &tail->id.u;\n    }\n\n  tail->next = nouser_alist;\n  nouser_alist = tail;\n  return NULL;\n}\n\n \n\nchar *\ngetgroup (gid_t gid)\n{\n  struct userid *tail;\n  struct userid *match = NULL;\n\n  for (tail = group_alist; tail; tail = tail->next)\n    {\n      if (tail->id.g == gid)\n        {\n          match = tail;\n          break;\n        }\n    }\n\n  if (match == NULL)\n    {\n      struct group *grent = getgrgid (gid);\n      char const *name = grent ? grent->gr_name : \"\";\n      match = xmalloc (FLEXSIZEOF (struct userid, name, strlen (name) + 1));\n      match->id.g = gid;\n      strcpy (match->name, name);\n\n       \n      match->next = group_alist;\n      group_alist = match;\n    }\n\n  return match->name[0] ? match->name : NULL;\n}\n\n \n\ngid_t *\ngetgidbyname (const char *group)\n{\n  struct userid *tail;\n  struct group *grent;\n\n  for (tail = group_alist; tail; tail = tail->next)\n     \n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return &tail->id.g;\n\n  for (tail = nogroup_alist; tail; tail = tail->next)\n     \n    if (*tail->name == *group && !strcmp (tail->name, group))\n      return NULL;\n\n  grent = getgrnam (group);\n#ifdef __DJGPP__\n   \n  if (!grent && strspn (group, digits) < strlen (group))\n    {\n      setenv (\"GROUP\", group, 1);\n      grent = getgrnam (group);  \n    }\n#endif\n\n  tail = xmalloc (FLEXSIZEOF (struct userid, name, strlen (group) + 1));\n  strcpy (tail->name, group);\n\n   \n  if (grent)\n    {\n      tail->id.g = grent->gr_gid;\n      tail->next = group_alist;\n      group_alist = tail;\n      return &tail->id.g;\n    }\n\n  tail->next = nogroup_alist;\n  nogroup_alist = tail;\n  return NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}