{
  "module_name": "lock.c",
  "hash_id": "5edf6703fa68681a83811c267cb218c7736b67920a5de8596482a6fb7d922be9",
  "original_prompt": "Ingested from coreutils-9.4/lib/glthread/lock.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"glthread/lock.h\"\n\n \n\n#if USE_ISOC_THREADS || USE_ISOC_AND_POSIX_THREADS\n\n \n\nint\nglthread_lock_init (gl_lock_t *lock)\n{\n  if (mtx_init (&lock->mutex, mtx_plain) != thrd_success)\n    return ENOMEM;\n  lock->init_needed = 0;\n  return 0;\n}\n\nint\nglthread_lock_lock (gl_lock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_lock (&lock->mutex) != thrd_success)\n    return EAGAIN;\n  return 0;\n}\n\nint\nglthread_lock_unlock (gl_lock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_unlock (&lock->mutex) != thrd_success)\n    return EINVAL;\n  return 0;\n}\n\nint\nglthread_lock_destroy (gl_lock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  mtx_destroy (&lock->mutex);\n  return 0;\n}\n\n \n\nint\nglthread_rwlock_init (gl_rwlock_t *lock)\n{\n  if (mtx_init (&lock->lock, mtx_plain) != thrd_success\n      || cnd_init (&lock->waiting_readers) != thrd_success\n      || cnd_init (&lock->waiting_writers) != thrd_success)\n    return ENOMEM;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  lock->init_needed = 0;\n  return 0;\n}\n\nint\nglthread_rwlock_rdlock (gl_rwlock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_lock (&lock->lock) != thrd_success)\n    return EAGAIN;\n   \n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n       \n      if (cnd_wait (&lock->waiting_readers, &lock->lock) != thrd_success)\n        {\n          mtx_unlock (&lock->lock);\n          return EINVAL;\n        }\n    }\n  lock->runcount++;\n  if (mtx_unlock (&lock->lock) != thrd_success)\n    return EINVAL;\n  return 0;\n}\n\nint\nglthread_rwlock_wrlock (gl_rwlock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_lock (&lock->lock) != thrd_success)\n    return EAGAIN;\n   \n  while (!(lock->runcount == 0))\n    {\n       \n      lock->waiting_writers_count++;\n      if (cnd_wait (&lock->waiting_writers, &lock->lock) != thrd_success)\n        {\n          lock->waiting_writers_count--;\n          mtx_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--;  \n  if (mtx_unlock (&lock->lock) != thrd_success)\n    return EINVAL;\n  return 0;\n}\n\nint\nglthread_rwlock_unlock (gl_rwlock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_lock (&lock->lock) != thrd_success)\n    return EAGAIN;\n  if (lock->runcount < 0)\n    {\n       \n      if (!(lock->runcount == -1))\n        {\n          mtx_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n       \n      if (!(lock->runcount > 0))\n        {\n          mtx_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n       \n      if (lock->waiting_writers_count > 0)\n        {\n           \n          if (cnd_signal (&lock->waiting_writers) != thrd_success)\n            {\n              mtx_unlock (&lock->lock);\n              return EINVAL;\n            }\n        }\n      else\n        {\n           \n          if (cnd_broadcast (&lock->waiting_readers) != thrd_success)\n            {\n              mtx_unlock (&lock->lock);\n              return EINVAL;\n            }\n        }\n    }\n  if (mtx_unlock (&lock->lock) != thrd_success)\n    return EINVAL;\n  return 0;\n}\n\nint\nglthread_rwlock_destroy (gl_rwlock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  mtx_destroy (&lock->lock);\n  cnd_destroy (&lock->waiting_readers);\n  cnd_destroy (&lock->waiting_writers);\n  return 0;\n}\n\n \n\nint\nglthread_recursive_lock_init (gl_recursive_lock_t *lock)\n{\n  if (mtx_init (&lock->mutex, mtx_plain | mtx_recursive) != thrd_success)\n    return ENOMEM;\n  lock->init_needed = 0;\n  return 0;\n}\n\nint\nglthread_recursive_lock_lock (gl_recursive_lock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_lock (&lock->mutex) != thrd_success)\n    return EAGAIN;\n  return 0;\n}\n\nint\nglthread_recursive_lock_unlock (gl_recursive_lock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  if (mtx_unlock (&lock->mutex) != thrd_success)\n    return EINVAL;\n  return 0;\n}\n\nint\nglthread_recursive_lock_destroy (gl_recursive_lock_t *lock)\n{\n  if (lock->init_needed)\n    call_once (&lock->init_once, lock->init_func);\n  mtx_destroy (&lock->mutex);\n  return 0;\n}\n\n \n\n#endif\n\n \n\n#if USE_POSIX_THREADS\n\n \n\n \n\n# if HAVE_PTHREAD_RWLOCK && (HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER || (defined PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP && (__GNU_LIBRARY__ > 1)))\n\n#  if defined PTHREAD_RWLOCK_INITIALIZER || defined PTHREAD_RWLOCK_INITIALIZER_NP\n\n#   if !HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER\n      \n\nint\nglthread_rwlock_init_for_glibc (pthread_rwlock_t *lock)\n{\n  pthread_rwlockattr_t attributes;\n  int err;\n\n  err = pthread_rwlockattr_init (&attributes);\n  if (err != 0)\n    return err;\n   \n  err = pthread_rwlockattr_setkind_np (&attributes,\n                                       PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n  if (err == 0)\n    err = pthread_rwlock_init(lock, &attributes);\n   \n  pthread_rwlockattr_destroy (&attributes);\n  return err;\n}\n\n#   endif\n#  else\n\nint\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}\n\nint\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}\n\nint\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}\n\nint\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}\n\nint\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}\n\n#  endif\n\n# else\n\nint\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}\n\nint\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n   \n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n       \n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}\n\nint\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n   \n  while (!(lock->runcount == 0))\n    {\n       \n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--;  \n  return pthread_mutex_unlock (&lock->lock);\n}\n\nint\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n       \n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n       \n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n       \n      if (lock->waiting_writers_count > 0)\n        {\n           \n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n           \n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}\n\nint\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}\n\n# endif\n\n \n\n# if HAVE_PTHREAD_MUTEX_RECURSIVE\n\n#  if defined PTHREAD_RECURSIVE_MUTEX_INITIALIZER || defined PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n\nint\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}\n\n#  else\n\nint\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}\n\nint\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}\n\nint\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}\n\nint\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}\n\n#  endif\n\n# else\n\nint\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}\n\nint\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0)  \n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}\n\nint\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}\n\nint\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}\n\n# endif\n\n \n\nstatic const pthread_once_t fresh_once = PTHREAD_ONCE_INIT;\n\nint\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n   \n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n       \n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}\n\n# if !(PTHREAD_IN_USE_DETECTION_HARD || USE_POSIX_THREADS_WEAK)\n\nint\nglthread_once_multithreaded (pthread_once_t *once_control,\n                             void (*init_function) (void))\n{\n  int err = pthread_once (once_control, init_function);\n  if (err == ENOSYS)\n    {\n       \n      if (glthread_once_singlethreaded (once_control))\n        init_function ();\n      return 0;\n    }\n  return err;\n}\n\n# endif\n\n#endif\n\n \n\n#if USE_WINDOWS_THREADS\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}