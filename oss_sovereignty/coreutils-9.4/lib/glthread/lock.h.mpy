{
  "module_name": "lock.h",
  "hash_id": "a14c983c26ef06409e7e42b4fff12aafee4563caacb4be2bb17086588c44b4f6",
  "original_prompt": "Ingested from coreutils-9.4/lib/glthread/lock.h",
  "human_readable_source": " \n\n \n\n\n#ifndef _LOCK_H\n#define _LOCK_H\n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#include <errno.h>\n#include <stdlib.h>\n\n#if !defined c11_threads_in_use\n# if HAVE_THREADS_H && USE_POSIX_THREADS_FROM_LIBC\n#  define c11_threads_in_use() 1\n# elif HAVE_THREADS_H && USE_POSIX_THREADS_WEAK\n#  include <threads.h>\n#  pragma weak thrd_exit\n#  define c11_threads_in_use() (thrd_exit != NULL)\n# else\n#  define c11_threads_in_use() 0\n# endif\n#endif\n\n \n\n#if USE_ISOC_THREADS || USE_ISOC_AND_POSIX_THREADS\n\n \n\n# include <threads.h>\n\n# ifdef __cplusplus\nextern \"C\" {\n# endif\n\n \n\ntypedef struct\n        {\n          int volatile init_needed;\n          once_flag init_once;\n          void (*init_func) (void);\n          mtx_t mutex;\n        }\n        gl_lock_t;\n# define gl_lock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_lock_t NAME;\n# define gl_lock_define_initialized(STORAGECLASS, NAME) \\\n    static void _atomic_init_##NAME (void);       \\\n    STORAGECLASS gl_lock_t NAME =                 \\\n      { 1, ONCE_FLAG_INIT, _atomic_init_##NAME }; \\\n    static void _atomic_init_##NAME (void)        \\\n    {                                             \\\n      if (glthread_lock_init (&(NAME)))           \\\n        abort ();                                 \\\n    }\nextern int glthread_lock_init (gl_lock_t *lock);\nextern int glthread_lock_lock (gl_lock_t *lock);\nextern int glthread_lock_unlock (gl_lock_t *lock);\nextern int glthread_lock_destroy (gl_lock_t *lock);\n\n \n\ntypedef struct\n        {\n          int volatile init_needed;\n          once_flag init_once;\n          void (*init_func) (void);\n          mtx_t lock;  \n          cnd_t waiting_readers;  \n          cnd_t waiting_writers;  \n          unsigned int waiting_writers_count;  \n          int runcount;  \n        }\n        gl_rwlock_t;\n# define gl_rwlock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_rwlock_t NAME;\n# define gl_rwlock_define_initialized(STORAGECLASS, NAME) \\\n    static void _atomic_init_##NAME (void);       \\\n    STORAGECLASS gl_rwlock_t NAME =               \\\n      { 1, ONCE_FLAG_INIT, _atomic_init_##NAME }; \\\n    static void _atomic_init_##NAME (void)        \\\n    {                                             \\\n      if (glthread_rwlock_init (&(NAME)))         \\\n        abort ();                                 \\\n    }\nextern int glthread_rwlock_init (gl_rwlock_t *lock);\nextern int glthread_rwlock_rdlock (gl_rwlock_t *lock);\nextern int glthread_rwlock_wrlock (gl_rwlock_t *lock);\nextern int glthread_rwlock_unlock (gl_rwlock_t *lock);\nextern int glthread_rwlock_destroy (gl_rwlock_t *lock);\n\n \n\ntypedef struct\n        {\n          int volatile init_needed;\n          once_flag init_once;\n          void (*init_func) (void);\n          mtx_t mutex;\n        }\n        gl_recursive_lock_t;\n# define gl_recursive_lock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_recursive_lock_t NAME;\n# define gl_recursive_lock_define_initialized(STORAGECLASS, NAME) \\\n    static void _atomic_init_##NAME (void);       \\\n    STORAGECLASS gl_recursive_lock_t NAME =       \\\n      { 1, ONCE_FLAG_INIT, _atomic_init_##NAME }; \\\n    static void _atomic_init_##NAME (void)        \\\n    {                                             \\\n      if (glthread_recursive_lock_init (&(NAME))) \\\n        abort ();                                 \\\n    }\nextern int glthread_recursive_lock_init (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_lock (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_unlock (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_destroy (gl_recursive_lock_t *lock);\n\n \n\ntypedef once_flag gl_once_t;\n# define gl_once_define(STORAGECLASS, NAME) \\\n    STORAGECLASS once_flag NAME = ONCE_FLAG_INIT;\n# define glthread_once(ONCE_CONTROL, INITFUNCTION) \\\n    (call_once (ONCE_CONTROL, INITFUNCTION), 0)\n\n# ifdef __cplusplus\n}\n# endif\n\n#endif\n\n \n\n#if USE_POSIX_THREADS\n\n \n\n# include <pthread.h>\n\n# ifdef __cplusplus\nextern \"C\" {\n# endif\n\n# if PTHREAD_IN_USE_DETECTION_HARD\n\n \n#  define pthread_in_use() \\\n     glthread_in_use ()\nextern int glthread_in_use (void);\n\n# endif\n\n# if USE_POSIX_THREADS_WEAK\n\n \n\n \n\n \n\n#  pragma weak pthread_mutex_init\n#  pragma weak pthread_mutex_lock\n#  pragma weak pthread_mutex_unlock\n#  pragma weak pthread_mutex_destroy\n#  pragma weak pthread_rwlock_init\n#  pragma weak pthread_rwlock_rdlock\n#  pragma weak pthread_rwlock_wrlock\n#  pragma weak pthread_rwlock_unlock\n#  pragma weak pthread_rwlock_destroy\n#  pragma weak pthread_once\n#  pragma weak pthread_cond_init\n#  pragma weak pthread_cond_wait\n#  pragma weak pthread_cond_signal\n#  pragma weak pthread_cond_broadcast\n#  pragma weak pthread_cond_destroy\n#  pragma weak pthread_mutexattr_init\n#  pragma weak pthread_mutexattr_settype\n#  pragma weak pthread_mutexattr_destroy\n#  pragma weak pthread_rwlockattr_init\n#  if __GNU_LIBRARY__ > 1\n#   pragma weak pthread_rwlockattr_setkind_np\n#  endif\n#  pragma weak pthread_rwlockattr_destroy\n#  ifndef pthread_self\n#   pragma weak pthread_self\n#  endif\n\n#  if !PTHREAD_IN_USE_DETECTION_HARD\n     \n#   pragma weak pthread_mutexattr_gettype\n#   define pthread_in_use() \\\n      (pthread_mutexattr_gettype != NULL || c11_threads_in_use ())\n#  endif\n\n# else\n\n#  if !PTHREAD_IN_USE_DETECTION_HARD\n#   define pthread_in_use() 1\n#  endif\n\n# endif\n\n \n\ntypedef pthread_mutex_t gl_lock_t;\n# define gl_lock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS pthread_mutex_t NAME;\n# define gl_lock_define_initialized(STORAGECLASS, NAME) \\\n    STORAGECLASS pthread_mutex_t NAME = gl_lock_initializer;\n# define gl_lock_initializer \\\n    PTHREAD_MUTEX_INITIALIZER\n# define glthread_lock_init(LOCK) \\\n    (pthread_in_use () ? pthread_mutex_init (LOCK, NULL) : 0)\n# define glthread_lock_lock(LOCK) \\\n    (pthread_in_use () ? pthread_mutex_lock (LOCK) : 0)\n# define glthread_lock_unlock(LOCK) \\\n    (pthread_in_use () ? pthread_mutex_unlock (LOCK) : 0)\n# define glthread_lock_destroy(LOCK) \\\n    (pthread_in_use () ? pthread_mutex_destroy (LOCK) : 0)\n\n \n\n# if HAVE_PTHREAD_RWLOCK && (HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER || (defined PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP && (__GNU_LIBRARY__ > 1)))\n\n#  if defined PTHREAD_RWLOCK_INITIALIZER || defined PTHREAD_RWLOCK_INITIALIZER_NP\n\ntypedef pthread_rwlock_t gl_rwlock_t;\n#   define gl_rwlock_define(STORAGECLASS, NAME) \\\n      STORAGECLASS pthread_rwlock_t NAME;\n#   define gl_rwlock_define_initialized(STORAGECLASS, NAME) \\\n      STORAGECLASS pthread_rwlock_t NAME = gl_rwlock_initializer;\n#   if HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER\n#    if defined PTHREAD_RWLOCK_INITIALIZER\n#     define gl_rwlock_initializer \\\n        PTHREAD_RWLOCK_INITIALIZER\n#    else\n#     define gl_rwlock_initializer \\\n        PTHREAD_RWLOCK_INITIALIZER_NP\n#    endif\n#    define glthread_rwlock_init(LOCK) \\\n       (pthread_in_use () ? pthread_rwlock_init (LOCK, NULL) : 0)\n#   else  \n          pthread_rwlock_t rwlock;  \n        }\n        gl_rwlock_t;\n#   define gl_rwlock_define(STORAGECLASS, NAME) \\\n      STORAGECLASS gl_rwlock_t NAME;\n#   define gl_rwlock_define_initialized(STORAGECLASS, NAME) \\\n      STORAGECLASS gl_rwlock_t NAME = gl_rwlock_initializer;\n#   define gl_rwlock_initializer \\\n      { 0, PTHREAD_MUTEX_INITIALIZER }\n#   define glthread_rwlock_init(LOCK) \\\n      (pthread_in_use () ? glthread_rwlock_init_multithreaded (LOCK) : 0)\n#   define glthread_rwlock_rdlock(LOCK) \\\n      (pthread_in_use () ? glthread_rwlock_rdlock_multithreaded (LOCK) : 0)\n#   define glthread_rwlock_wrlock(LOCK) \\\n      (pthread_in_use () ? glthread_rwlock_wrlock_multithreaded (LOCK) : 0)\n#   define glthread_rwlock_unlock(LOCK) \\\n      (pthread_in_use () ? glthread_rwlock_unlock_multithreaded (LOCK) : 0)\n#   define glthread_rwlock_destroy(LOCK) \\\n      (pthread_in_use () ? glthread_rwlock_destroy_multithreaded (LOCK) : 0)\nextern int glthread_rwlock_init_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock);\n\n#  endif\n\n# else\n\ntypedef struct\n        {\n          pthread_mutex_t lock;  \n          pthread_cond_t waiting_readers;  \n          pthread_cond_t waiting_writers;  \n          unsigned int waiting_writers_count;  \n          int runcount;  \n        }\n        gl_rwlock_t;\n# define gl_rwlock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_rwlock_t NAME;\n# define gl_rwlock_define_initialized(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_rwlock_t NAME = gl_rwlock_initializer;\n# define gl_rwlock_initializer \\\n    { PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, 0, 0 }\n# define glthread_rwlock_init(LOCK) \\\n    (pthread_in_use () ? glthread_rwlock_init_multithreaded (LOCK) : 0)\n# define glthread_rwlock_rdlock(LOCK) \\\n    (pthread_in_use () ? glthread_rwlock_rdlock_multithreaded (LOCK) : 0)\n# define glthread_rwlock_wrlock(LOCK) \\\n    (pthread_in_use () ? glthread_rwlock_wrlock_multithreaded (LOCK) : 0)\n# define glthread_rwlock_unlock(LOCK) \\\n    (pthread_in_use () ? glthread_rwlock_unlock_multithreaded (LOCK) : 0)\n# define glthread_rwlock_destroy(LOCK) \\\n    (pthread_in_use () ? glthread_rwlock_destroy_multithreaded (LOCK) : 0)\nextern int glthread_rwlock_init_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock);\nextern int glthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock);\n\n# endif\n\n \n\n# if HAVE_PTHREAD_MUTEX_RECURSIVE\n\n#  if defined PTHREAD_RECURSIVE_MUTEX_INITIALIZER || defined PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n\ntypedef pthread_mutex_t gl_recursive_lock_t;\n#   define gl_recursive_lock_define(STORAGECLASS, NAME) \\\n      STORAGECLASS pthread_mutex_t NAME;\n#   define gl_recursive_lock_define_initialized(STORAGECLASS, NAME) \\\n      STORAGECLASS pthread_mutex_t NAME = gl_recursive_lock_initializer;\n#   ifdef PTHREAD_RECURSIVE_MUTEX_INITIALIZER\n#    define gl_recursive_lock_initializer \\\n       PTHREAD_RECURSIVE_MUTEX_INITIALIZER\n#   else\n#    define gl_recursive_lock_initializer \\\n       PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\n#   endif\n#   define glthread_recursive_lock_init(LOCK) \\\n      (pthread_in_use () ? glthread_recursive_lock_init_multithreaded (LOCK) : 0)\n#   define glthread_recursive_lock_lock(LOCK) \\\n      (pthread_in_use () ? pthread_mutex_lock (LOCK) : 0)\n#   define glthread_recursive_lock_unlock(LOCK) \\\n      (pthread_in_use () ? pthread_mutex_unlock (LOCK) : 0)\n#   define glthread_recursive_lock_destroy(LOCK) \\\n      (pthread_in_use () ? pthread_mutex_destroy (LOCK) : 0)\nextern int glthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock);\n\n#  else\n\ntypedef struct\n        {\n          pthread_mutex_t recmutex;  \n          pthread_mutex_t guard;     \n          int initialized;\n        }\n        gl_recursive_lock_t;\n#   define gl_recursive_lock_define(STORAGECLASS, NAME) \\\n      STORAGECLASS gl_recursive_lock_t NAME;\n#   define gl_recursive_lock_define_initialized(STORAGECLASS, NAME) \\\n      STORAGECLASS gl_recursive_lock_t NAME = gl_recursive_lock_initializer;\n#   define gl_recursive_lock_initializer \\\n      { PTHREAD_MUTEX_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, 0 }\n#   define glthread_recursive_lock_init(LOCK) \\\n      (pthread_in_use () ? glthread_recursive_lock_init_multithreaded (LOCK) : 0)\n#   define glthread_recursive_lock_lock(LOCK) \\\n      (pthread_in_use () ? glthread_recursive_lock_lock_multithreaded (LOCK) : 0)\n#   define glthread_recursive_lock_unlock(LOCK) \\\n      (pthread_in_use () ? glthread_recursive_lock_unlock_multithreaded (LOCK) : 0)\n#   define glthread_recursive_lock_destroy(LOCK) \\\n      (pthread_in_use () ? glthread_recursive_lock_destroy_multithreaded (LOCK) : 0)\nextern int glthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock);\n\n#  endif\n\n# else\n\n \n\ntypedef struct\n        {\n          pthread_mutex_t mutex;\n          pthread_t owner;\n          unsigned long depth;\n        }\n        gl_recursive_lock_t;\n#  define gl_recursive_lock_define(STORAGECLASS, NAME) \\\n     STORAGECLASS gl_recursive_lock_t NAME;\n#  define gl_recursive_lock_define_initialized(STORAGECLASS, NAME) \\\n     STORAGECLASS gl_recursive_lock_t NAME = gl_recursive_lock_initializer;\n#  define gl_recursive_lock_initializer \\\n     { PTHREAD_MUTEX_INITIALIZER, (pthread_t) 0, 0 }\n#  define glthread_recursive_lock_init(LOCK) \\\n     (pthread_in_use () ? glthread_recursive_lock_init_multithreaded (LOCK) : 0)\n#  define glthread_recursive_lock_lock(LOCK) \\\n     (pthread_in_use () ? glthread_recursive_lock_lock_multithreaded (LOCK) : 0)\n#  define glthread_recursive_lock_unlock(LOCK) \\\n     (pthread_in_use () ? glthread_recursive_lock_unlock_multithreaded (LOCK) : 0)\n#  define glthread_recursive_lock_destroy(LOCK) \\\n     (pthread_in_use () ? glthread_recursive_lock_destroy_multithreaded (LOCK) : 0)\nextern int glthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock);\nextern int glthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock);\n\n# endif\n\n \n\ntypedef pthread_once_t gl_once_t;\n# define gl_once_define(STORAGECLASS, NAME) \\\n    STORAGECLASS pthread_once_t NAME = PTHREAD_ONCE_INIT;\n# if PTHREAD_IN_USE_DETECTION_HARD || USE_POSIX_THREADS_WEAK\n#  define glthread_once(ONCE_CONTROL, INITFUNCTION) \\\n     (pthread_in_use ()                                                        \\\n      ? pthread_once (ONCE_CONTROL, INITFUNCTION)                              \\\n      : (glthread_once_singlethreaded (ONCE_CONTROL) ? (INITFUNCTION (), 0) : 0))\n# else\n#  define glthread_once(ONCE_CONTROL, INITFUNCTION) \\\n     (pthread_in_use ()                                                        \\\n      ? glthread_once_multithreaded (ONCE_CONTROL, INITFUNCTION)               \\\n      : (glthread_once_singlethreaded (ONCE_CONTROL) ? (INITFUNCTION (), 0) : 0))\nextern int glthread_once_multithreaded (pthread_once_t *once_control,\n                                        void (*init_function) (void));\n# endif\nextern int glthread_once_singlethreaded (pthread_once_t *once_control);\n\n# ifdef __cplusplus\n}\n# endif\n\n#endif\n\n \n\n#if USE_WINDOWS_THREADS\n\n# define WIN32_LEAN_AND_MEAN   \n# include <windows.h>\n\n# include \"windows-mutex.h\"\n# include \"windows-rwlock.h\"\n# include \"windows-recmutex.h\"\n# include \"windows-once.h\"\n\n# ifdef __cplusplus\nextern \"C\" {\n# endif\n\n \n\n \n\n \n\ntypedef glwthread_mutex_t gl_lock_t;\n# define gl_lock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_lock_t NAME;\n# define gl_lock_define_initialized(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_lock_t NAME = gl_lock_initializer;\n# define gl_lock_initializer \\\n    GLWTHREAD_MUTEX_INIT\n# define glthread_lock_init(LOCK) \\\n    (glwthread_mutex_init (LOCK), 0)\n# define glthread_lock_lock(LOCK) \\\n    glwthread_mutex_lock (LOCK)\n# define glthread_lock_unlock(LOCK) \\\n    glwthread_mutex_unlock (LOCK)\n# define glthread_lock_destroy(LOCK) \\\n    glwthread_mutex_destroy (LOCK)\n\n \n\ntypedef glwthread_rwlock_t gl_rwlock_t;\n# define gl_rwlock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_rwlock_t NAME;\n# define gl_rwlock_define_initialized(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_rwlock_t NAME = gl_rwlock_initializer;\n# define gl_rwlock_initializer \\\n    GLWTHREAD_RWLOCK_INIT\n# define glthread_rwlock_init(LOCK) \\\n    (glwthread_rwlock_init (LOCK), 0)\n# define glthread_rwlock_rdlock(LOCK) \\\n    glwthread_rwlock_rdlock (LOCK)\n# define glthread_rwlock_wrlock(LOCK) \\\n    glwthread_rwlock_wrlock (LOCK)\n# define glthread_rwlock_unlock(LOCK) \\\n    glwthread_rwlock_unlock (LOCK)\n# define glthread_rwlock_destroy(LOCK) \\\n    glwthread_rwlock_destroy (LOCK)\n\n \n\ntypedef glwthread_recmutex_t gl_recursive_lock_t;\n# define gl_recursive_lock_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_recursive_lock_t NAME;\n# define gl_recursive_lock_define_initialized(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_recursive_lock_t NAME = gl_recursive_lock_initializer;\n# define gl_recursive_lock_initializer \\\n    GLWTHREAD_RECMUTEX_INIT\n# define glthread_recursive_lock_init(LOCK) \\\n    (glwthread_recmutex_init (LOCK), 0)\n# define glthread_recursive_lock_lock(LOCK) \\\n    glwthread_recmutex_lock (LOCK)\n# define glthread_recursive_lock_unlock(LOCK) \\\n    glwthread_recmutex_unlock (LOCK)\n# define glthread_recursive_lock_destroy(LOCK) \\\n    glwthread_recmutex_destroy (LOCK)\n\n \n\ntypedef glwthread_once_t gl_once_t;\n# define gl_once_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_once_t NAME = GLWTHREAD_ONCE_INIT;\n# define glthread_once(ONCE_CONTROL, INITFUNCTION) \\\n    (glwthread_once (ONCE_CONTROL, INITFUNCTION), 0)\n\n# ifdef __cplusplus\n}\n# endif\n\n#endif\n\n \n\n#if !(USE_ISOC_THREADS || USE_POSIX_THREADS || USE_ISOC_AND_POSIX_THREADS || USE_WINDOWS_THREADS)\n\n \n\n \n\ntypedef int gl_lock_t;\n# define gl_lock_define(STORAGECLASS, NAME)\n# define gl_lock_define_initialized(STORAGECLASS, NAME)\n# define glthread_lock_init(NAME) 0\n# define glthread_lock_lock(NAME) 0\n# define glthread_lock_unlock(NAME) 0\n# define glthread_lock_destroy(NAME) 0\n\n \n\ntypedef int gl_rwlock_t;\n# define gl_rwlock_define(STORAGECLASS, NAME)\n# define gl_rwlock_define_initialized(STORAGECLASS, NAME)\n# define glthread_rwlock_init(NAME) 0\n# define glthread_rwlock_rdlock(NAME) 0\n# define glthread_rwlock_wrlock(NAME) 0\n# define glthread_rwlock_unlock(NAME) 0\n# define glthread_rwlock_destroy(NAME) 0\n\n \n\ntypedef int gl_recursive_lock_t;\n# define gl_recursive_lock_define(STORAGECLASS, NAME)\n# define gl_recursive_lock_define_initialized(STORAGECLASS, NAME)\n# define glthread_recursive_lock_init(NAME) 0\n# define glthread_recursive_lock_lock(NAME) 0\n# define glthread_recursive_lock_unlock(NAME) 0\n# define glthread_recursive_lock_destroy(NAME) 0\n\n \n\ntypedef int gl_once_t;\n# define gl_once_define(STORAGECLASS, NAME) \\\n    STORAGECLASS gl_once_t NAME = 0;\n# define glthread_once(ONCE_CONTROL, INITFUNCTION) \\\n    (*(ONCE_CONTROL) == 0 ? (*(ONCE_CONTROL) = ~ 0, INITFUNCTION (), 0) : 0)\n\n#endif\n\n \n\n \n\n \n\n#define gl_lock_init(NAME) \\\n   do                                  \\\n     {                                 \\\n       if (glthread_lock_init (&NAME)) \\\n         abort ();                     \\\n     }                                 \\\n   while (0)\n#define gl_lock_lock(NAME) \\\n   do                                  \\\n     {                                 \\\n       if (glthread_lock_lock (&NAME)) \\\n         abort ();                     \\\n     }                                 \\\n   while (0)\n#define gl_lock_unlock(NAME) \\\n   do                                    \\\n     {                                   \\\n       if (glthread_lock_unlock (&NAME)) \\\n         abort ();                       \\\n     }                                   \\\n   while (0)\n#define gl_lock_destroy(NAME) \\\n   do                                     \\\n     {                                    \\\n       if (glthread_lock_destroy (&NAME)) \\\n         abort ();                        \\\n     }                                    \\\n   while (0)\n\n \n\n#define gl_rwlock_init(NAME) \\\n   do                                    \\\n     {                                   \\\n       if (glthread_rwlock_init (&NAME)) \\\n         abort ();                       \\\n     }                                   \\\n   while (0)\n#define gl_rwlock_rdlock(NAME) \\\n   do                                      \\\n     {                                     \\\n       if (glthread_rwlock_rdlock (&NAME)) \\\n         abort ();                         \\\n     }                                     \\\n   while (0)\n#define gl_rwlock_wrlock(NAME) \\\n   do                                      \\\n     {                                     \\\n       if (glthread_rwlock_wrlock (&NAME)) \\\n         abort ();                         \\\n     }                                     \\\n   while (0)\n#define gl_rwlock_unlock(NAME) \\\n   do                                      \\\n     {                                     \\\n       if (glthread_rwlock_unlock (&NAME)) \\\n         abort ();                         \\\n     }                                     \\\n   while (0)\n#define gl_rwlock_destroy(NAME) \\\n   do                                       \\\n     {                                      \\\n       if (glthread_rwlock_destroy (&NAME)) \\\n         abort ();                          \\\n     }                                      \\\n   while (0)\n\n \n\n#define gl_recursive_lock_init(NAME) \\\n   do                                            \\\n     {                                           \\\n       if (glthread_recursive_lock_init (&NAME)) \\\n         abort ();                               \\\n     }                                           \\\n   while (0)\n#define gl_recursive_lock_lock(NAME) \\\n   do                                            \\\n     {                                           \\\n       if (glthread_recursive_lock_lock (&NAME)) \\\n         abort ();                               \\\n     }                                           \\\n   while (0)\n#define gl_recursive_lock_unlock(NAME) \\\n   do                                              \\\n     {                                             \\\n       if (glthread_recursive_lock_unlock (&NAME)) \\\n         abort ();                                 \\\n     }                                             \\\n   while (0)\n#define gl_recursive_lock_destroy(NAME) \\\n   do                                               \\\n     {                                              \\\n       if (glthread_recursive_lock_destroy (&NAME)) \\\n         abort ();                                  \\\n     }                                              \\\n   while (0)\n\n \n\n#define gl_once(NAME, INITFUNCTION) \\\n   do                                           \\\n     {                                          \\\n       if (glthread_once (&NAME, INITFUNCTION)) \\\n         abort ();                              \\\n     }                                          \\\n   while (0)\n\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}