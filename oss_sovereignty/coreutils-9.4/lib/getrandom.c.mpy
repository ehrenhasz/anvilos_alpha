{
  "module_name": "getrandom.c",
  "hash_id": "3c33d64cbcbe35357c42adc8c338ecb1d495a54222e310519ca2a8ed05599dab",
  "original_prompt": "Ingested from coreutils-9.4/lib/getrandom.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <sys/random.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#if defined _WIN32 && ! defined __CYGWIN__\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n# if HAVE_BCRYPT_H\n#  include <bcrypt.h>\n# else\n#  define NTSTATUS LONG\ntypedef void * BCRYPT_ALG_HANDLE;\n#  define BCRYPT_USE_SYSTEM_PREFERRED_RNG 0x00000002\n#  if HAVE_LIB_BCRYPT\nextern NTSTATUS WINAPI BCryptGenRandom (BCRYPT_ALG_HANDLE, UCHAR *, ULONG, ULONG);\n#  endif\n# endif\n# if !HAVE_LIB_BCRYPT\n#  include <wincrypt.h>\n#  ifndef CRYPT_VERIFY_CONTEXT\n#   define CRYPT_VERIFY_CONTEXT 0xF0000000\n#  endif\n# endif\n#endif\n\n#include \"minmax.h\"\n\n#if defined _WIN32 && ! defined __CYGWIN__\n\n \n# undef LoadLibrary\n# define LoadLibrary LoadLibraryA\n# undef CryptAcquireContext\n# define CryptAcquireContext CryptAcquireContextA\n\n# if !HAVE_LIB_BCRYPT\n\n \n#  define GetProcAddress \\\n    (void *) GetProcAddress\n\n \ntypedef NTSTATUS (WINAPI * BCryptGenRandomFuncType) (BCRYPT_ALG_HANDLE, UCHAR *, ULONG, ULONG);\nstatic BCryptGenRandomFuncType BCryptGenRandomFunc = NULL;\nstatic BOOL initialized = FALSE;\n\nstatic void\ninitialize (void)\n{\n  HMODULE bcrypt = LoadLibrary (\"bcrypt.dll\");\n  if (bcrypt != NULL)\n    {\n      BCryptGenRandomFunc =\n        (BCryptGenRandomFuncType) GetProcAddress (bcrypt, \"BCryptGenRandom\");\n    }\n  initialized = TRUE;\n}\n\n# else\n\n#  define BCryptGenRandomFunc BCryptGenRandom\n\n# endif\n\n#else\n \n\n \n# ifndef NAME_OF_RANDOM_DEVICE\n#  define NAME_OF_RANDOM_DEVICE \"/dev/random\"\n# endif\n\n \n# ifndef NAME_OF_NONCE_DEVICE\n#  define NAME_OF_NONCE_DEVICE \"/dev/urandom\"\n# endif\n\n#endif\n\n \nssize_t\ngetrandom (void *buffer, size_t length, unsigned int flags)\n#undef getrandom\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  static int bcrypt_not_working  ;\n  if (!bcrypt_not_working)\n    {\n# if !HAVE_LIB_BCRYPT\n      if (!initialized)\n        initialize ();\n# endif\n      if (BCryptGenRandomFunc != NULL\n          && BCryptGenRandomFunc (NULL, buffer, length,\n                                  BCRYPT_USE_SYSTEM_PREFERRED_RNG)\n             == 0  )\n        return length;\n      bcrypt_not_working = 1;\n    }\n# if !HAVE_LIB_BCRYPT\n   ;\n    static HCRYPTPROV provider;\n    if (!crypt_initialized)\n      {\n        if (CryptAcquireContext (&provider, NULL, NULL, PROV_RSA_FULL,\n                                 CRYPT_VERIFY_CONTEXT))\n          crypt_initialized = 1;\n        else\n          crypt_initialized = -1;\n      }\n    if (crypt_initialized >= 0)\n      {\n        if (!CryptGenRandom (provider, length, buffer))\n          {\n            errno = EIO;\n            return -1;\n          }\n        return length;\n      }\n  }\n# endif\n  errno = ENOSYS;\n  return -1;\n#elif HAVE_GETRANDOM\n  return getrandom (buffer, length, flags);\n#else\n  static int randfd[2] = { -1, -1 };\n  bool devrandom = (flags & GRND_RANDOM) != 0;\n  int fd = randfd[devrandom];\n\n  if (fd < 0)\n    {\n      static char const randdevice[][MAX (sizeof NAME_OF_NONCE_DEVICE,\n                                          sizeof NAME_OF_RANDOM_DEVICE)]\n        = { NAME_OF_NONCE_DEVICE, NAME_OF_RANDOM_DEVICE };\n      int oflags = (O_RDONLY + O_CLOEXEC\n                    + (flags & GRND_NONBLOCK ? O_NONBLOCK : 0));\n      fd = open (randdevice[devrandom], oflags);\n      if (fd < 0)\n        {\n          if (errno == ENOENT || errno == ENOTDIR)\n            errno = ENOSYS;\n          return -1;\n        }\n      randfd[devrandom] = fd;\n    }\n\n  return read (fd, buffer, length);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}