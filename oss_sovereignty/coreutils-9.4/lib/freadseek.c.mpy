{
  "module_name": "freadseek.c",
  "hash_id": "8bc83fa4b3621c83e32befbab04960c59cf248c5e4ee6ca892340539af2664db",
  "original_prompt": "Ingested from coreutils-9.4/lib/freadseek.c",
  "human_readable_source": " \n#include \"freadseek.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"freadahead.h\"\n#include \"freadptr.h\"\n\n#include \"stdio-impl.h\"\n\n \nstatic void\nfreadptrinc (FILE *fp, size_t increment)\n{\n   \n#if HAVE___FREADPTRINC               \n  __freadptrinc (fp, increment);\n#elif defined _IO_EOF_SEEN || defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1\n   \n  fp->_IO_read_ptr += increment;\n#elif defined __sferror || defined __DragonFly__ || defined __ANDROID__\n   \n  fp_->_p += increment;\n  fp_->_r -= increment;\n#elif defined __EMX__                \n  fp->_ptr += increment;\n  fp->_rcount -= increment;\n#elif defined __minix                \n  fp_->_ptr += increment;\n  fp_->_count -= increment;\n#elif defined _IOERR                 \n  fp_->_ptr += increment;\n  fp_->_cnt -= increment;\n#elif defined __UCLIBC__             \n# ifdef __STDIO_BUFFERS\n  fp->__bufpos += increment;\n# else\n  abort ();\n# endif\n#elif defined __QNX__                \n  fp->_Next += increment;\n#elif defined __MINT__               \n  fp->__bufp += increment;\n#elif defined EPLAN9                 \n  fp->rp += increment;\n#elif defined SLOW_BUT_NO_HACKS      \n#else\n #error \"Please port gnulib freadseek.c to your platform! Look at the definition of getc, getc_unlocked on your system, then report this to bug-gnulib.\"\n#endif\n}\n\nint\nfreadseek (FILE *fp, size_t offset)\n{\n  size_t total_buffered;\n  int fd;\n\n  if (offset == 0)\n    return 0;\n\n   \n  total_buffered = freadahead (fp);\n   \n  while (total_buffered > 0)\n    {\n      size_t buffered;\n\n      if (freadptr (fp, &buffered) != NULL && buffered > 0)\n        {\n          size_t increment = (buffered < offset ? buffered : offset);\n\n          freadptrinc (fp, increment);\n          offset -= increment;\n          if (offset == 0)\n            return 0;\n          total_buffered -= increment;\n          if (total_buffered == 0)\n            break;\n        }\n       \n      if (fgetc (fp) == EOF)\n        goto eof;\n      offset--;\n      if (offset == 0)\n        return 0;\n      total_buffered--;\n    }\n\n   \n  fd = fileno (fp);\n  if (fd >= 0 && lseek (fd, 0, SEEK_CUR) >= 0)\n    {\n       \n      return fseeko (fp, offset, SEEK_CUR);\n    }\n  else\n    {\n       \n      char buf[4096];\n\n      do\n        {\n          size_t count = (sizeof (buf) < offset ? sizeof (buf) : offset);\n          if (fread (buf, 1, count, fp) < count)\n            goto eof;\n          offset -= count;\n        }\n      while (offset > 0);\n\n      return 0;\n   }\n\n eof:\n   \n  if (ferror (fp))\n    return EOF;\n  else\n     \n    return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}