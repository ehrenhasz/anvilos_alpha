{
  "module_name": "dynarray-skeleton.c",
  "hash_id": "fefe4dc2f294398a188cf84cfebff4ee4eccfb5d9f1bed76d02350964a081b8b",
  "original_prompt": "Ingested from coreutils-9.4/lib/malloc/dynarray-skeleton.c",
  "human_readable_source": " \n\n#include <malloc/dynarray.h>\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef DYNARRAY_STRUCT\n# error \"DYNARRAY_STRUCT must be defined\"\n#endif\n\n#ifndef DYNARRAY_ELEMENT\n# error \"DYNARRAY_ELEMENT must be defined\"\n#endif\n\n#ifndef DYNARRAY_PREFIX\n# error \"DYNARRAY_PREFIX must be defined\"\n#endif\n\n#ifdef DYNARRAY_INITIAL_SIZE\n# if DYNARRAY_INITIAL_SIZE < 0\n#  error \"DYNARRAY_INITIAL_SIZE must be non-negative\"\n# endif\n# if DYNARRAY_INITIAL_SIZE > 0\n#  define DYNARRAY_HAVE_SCRATCH 1\n# else\n#  define DYNARRAY_HAVE_SCRATCH 0\n# endif\n#else\n \n# define DYNARRAY_INITIAL_SIZE \\\n  (sizeof (DYNARRAY_ELEMENT) > 64 ? 2 : 128 / sizeof (DYNARRAY_ELEMENT))\n# define DYNARRAY_HAVE_SCRATCH 1\n#endif\n\n \n\n \nstruct DYNARRAY_STRUCT\n{\n  union\n  {\n    struct dynarray_header dynarray_abstract;\n    struct\n    {\n       \n      size_t used;\n      size_t allocated;\n      DYNARRAY_ELEMENT *array;\n    } dynarray_header;\n  } u;\n\n#if DYNARRAY_HAVE_SCRATCH\n   \n  DYNARRAY_ELEMENT scratch[DYNARRAY_INITIAL_SIZE];\n#endif\n};\n\n \n\n \n#define DYNARRAY_CONCAT0(prefix, name) prefix##name\n#define DYNARRAY_CONCAT1(prefix, name) DYNARRAY_CONCAT0(prefix, name)\n#define DYNARRAY_NAME(name) DYNARRAY_CONCAT1(DYNARRAY_PREFIX, name)\n\n \n#define DYNARRAY_FREE DYNARRAY_CONCAT1 (DYNARRAY_NAME (f), ree)\n\n \n#if DYNARRAY_HAVE_SCRATCH\n# define DYNARRAY_SCRATCH(list) (list)->scratch\n#else\n# define DYNARRAY_SCRATCH(list) NULL\n#endif\n\n \n\n \nstatic inline void\nDYNARRAY_NAME (free__elements__) (DYNARRAY_ELEMENT *__dynarray_array,\n                                  size_t __dynarray_used)\n{\n#ifdef DYNARRAY_ELEMENT_FREE\n  for (size_t __dynarray_i = 0; __dynarray_i < __dynarray_used; ++__dynarray_i)\n    DYNARRAY_ELEMENT_FREE (&__dynarray_array[__dynarray_i]);\n#endif  \n}\n\n \nstatic inline void\nDYNARRAY_NAME (free__array__) (struct DYNARRAY_STRUCT *list)\n{\n#if DYNARRAY_HAVE_SCRATCH\n  if (list->u.dynarray_header.array != list->scratch)\n    free (list->u.dynarray_header.array);\n#else\n  free (list->u.dynarray_header.array);\n#endif\n}\n\n \n\n \n__attribute_nonnull__ ((1))\nstatic void\nDYNARRAY_NAME (init) (struct DYNARRAY_STRUCT *list)\n{\n  list->u.dynarray_header.used = 0;\n  list->u.dynarray_header.allocated = DYNARRAY_INITIAL_SIZE;\n  list->u.dynarray_header.array = DYNARRAY_SCRATCH (list);\n}\n\n \n__attribute_maybe_unused__ __attribute_nonnull__ ((1))\nstatic void\nDYNARRAY_FREE (struct DYNARRAY_STRUCT *list)\n{\n  DYNARRAY_NAME (free__elements__)\n    (list->u.dynarray_header.array, list->u.dynarray_header.used);\n  DYNARRAY_NAME (free__array__) (list);\n  DYNARRAY_NAME (init) (list);\n}\n\n \n__attribute_nonnull__ ((1))\nstatic inline bool\nDYNARRAY_NAME (has_failed) (const struct DYNARRAY_STRUCT *list)\n{\n  return list->u.dynarray_header.allocated == __dynarray_error_marker ();\n}\n\n \n__attribute_nonnull__ ((1))\nstatic void\nDYNARRAY_NAME (mark_failed) (struct DYNARRAY_STRUCT *list)\n{\n  DYNARRAY_NAME (free__elements__)\n    (list->u.dynarray_header.array, list->u.dynarray_header.used);\n  DYNARRAY_NAME (free__array__) (list);\n  list->u.dynarray_header.array = DYNARRAY_SCRATCH (list);\n  list->u.dynarray_header.used = 0;\n  list->u.dynarray_header.allocated = __dynarray_error_marker ();\n}\n\n \n__attribute_nonnull__ ((1))\nstatic inline size_t\nDYNARRAY_NAME (size) (const struct DYNARRAY_STRUCT *list)\n{\n  return list->u.dynarray_header.used;\n}\n\n \n__attribute_nonnull__ ((1))\nstatic inline DYNARRAY_ELEMENT *\nDYNARRAY_NAME (at) (struct DYNARRAY_STRUCT *list, size_t index)\n{\n  if (__glibc_unlikely (index >= DYNARRAY_NAME (size) (list)))\n    __libc_dynarray_at_failure (DYNARRAY_NAME (size) (list), index);\n  return list->u.dynarray_header.array + index;\n}\n\n \n__attribute_nonnull__ ((1))\nstatic inline DYNARRAY_ELEMENT *\nDYNARRAY_NAME (begin) (struct DYNARRAY_STRUCT *list)\n{\n  return list->u.dynarray_header.array;\n}\n\n \n__attribute_nonnull__ ((1))\nstatic inline DYNARRAY_ELEMENT *\nDYNARRAY_NAME (end) (struct DYNARRAY_STRUCT *list)\n{\n  return list->u.dynarray_header.array + list->u.dynarray_header.used;\n}\n\n \nstatic void\nDYNARRAY_NAME (add__) (struct DYNARRAY_STRUCT *list, DYNARRAY_ELEMENT item)\n{\n  if (__glibc_unlikely\n      (!__libc_dynarray_emplace_enlarge (&list->u.dynarray_abstract,\n                                         DYNARRAY_SCRATCH (list),\n                                         sizeof (DYNARRAY_ELEMENT))))\n    {\n      DYNARRAY_NAME (mark_failed) (list);\n      return;\n    }\n\n   \n  list->u.dynarray_header.array[list->u.dynarray_header.used++] = item;\n}\n\n \n__attribute_nonnull__ ((1))\nstatic inline void\nDYNARRAY_NAME (add) (struct DYNARRAY_STRUCT *list, DYNARRAY_ELEMENT item)\n{\n   \n  if (DYNARRAY_NAME (has_failed) (list))\n    return;\n\n   \n  if (__glibc_unlikely (list->u.dynarray_header.used\n                        == list->u.dynarray_header.allocated))\n    {\n      DYNARRAY_NAME (add__) (list, item);\n      return;\n    }\n\n   \n  list->u.dynarray_header.array[list->u.dynarray_header.used++] = item;\n}\n\n \nstatic inline DYNARRAY_ELEMENT *\nDYNARRAY_NAME (emplace__tail__) (struct DYNARRAY_STRUCT *list)\n{\n  DYNARRAY_ELEMENT *result\n    = &list->u.dynarray_header.array[list->u.dynarray_header.used];\n  ++list->u.dynarray_header.used;\n#if defined (DYNARRAY_ELEMENT_INIT)\n  DYNARRAY_ELEMENT_INIT (result);\n#elif defined (DYNARRAY_ELEMENT_FREE)\n  memset (result, 0, sizeof (*result));\n#endif\n  return result;\n}\n\n \nstatic DYNARRAY_ELEMENT *\nDYNARRAY_NAME (emplace__) (struct DYNARRAY_STRUCT *list)\n{\n  if (__glibc_unlikely\n      (!__libc_dynarray_emplace_enlarge (&list->u.dynarray_abstract,\n                                         DYNARRAY_SCRATCH (list),\n                                         sizeof (DYNARRAY_ELEMENT))))\n    {\n      DYNARRAY_NAME (mark_failed) (list);\n      return NULL;\n    }\n  return DYNARRAY_NAME (emplace__tail__) (list);\n}\n\n \n__attribute_maybe_unused__ __attribute_warn_unused_result__\n__attribute_nonnull__ ((1))\nstatic\n \n#if !(defined (DYNARRAY_ELEMENT_INIT) || defined (DYNARRAY_ELEMENT_FREE))\ninline\n#endif\nDYNARRAY_ELEMENT *\nDYNARRAY_NAME (emplace) (struct DYNARRAY_STRUCT *list)\n{\n   \n  if (DYNARRAY_NAME (has_failed) (list))\n    return NULL;\n\n   \n  if (__glibc_unlikely (list->u.dynarray_header.used\n                        == list->u.dynarray_header.allocated))\n    return (DYNARRAY_NAME (emplace__) (list));\n  return DYNARRAY_NAME (emplace__tail__) (list);\n}\n\n \n__attribute_maybe_unused__ __attribute_nonnull__ ((1))\nstatic bool\nDYNARRAY_NAME (resize) (struct DYNARRAY_STRUCT *list, size_t size)\n{\n  if (size > list->u.dynarray_header.used)\n    {\n      bool ok;\n#if defined (DYNARRAY_ELEMENT_INIT)\n       \n      size_t old_size = list->u.dynarray_header.used;\n      ok = __libc_dynarray_resize (&list->u.dynarray_abstract,\n                                   size, DYNARRAY_SCRATCH (list),\n                                   sizeof (DYNARRAY_ELEMENT));\n      if (ok)\n        for (size_t i = old_size; i < size; ++i)\n          {\n            DYNARRAY_ELEMENT_INIT (&list->u.dynarray_header.array[i]);\n          }\n#elif defined (DYNARRAY_ELEMENT_FREE)\n       \n      ok = __libc_dynarray_resize_clear\n        (&list->u.dynarray_abstract, size,\n         DYNARRAY_SCRATCH (list), sizeof (DYNARRAY_ELEMENT));\n#else\n      ok =  __libc_dynarray_resize (&list->u.dynarray_abstract,\n                                    size, DYNARRAY_SCRATCH (list),\n                                    sizeof (DYNARRAY_ELEMENT));\n#endif\n      if (__glibc_unlikely (!ok))\n        DYNARRAY_NAME (mark_failed) (list);\n      return ok;\n    }\n  else\n    {\n       \n      DYNARRAY_NAME (free__elements__)\n        (list->u.dynarray_header.array + size,\n         list->u.dynarray_header.used - size);\n      list->u.dynarray_header.used = size;\n      return true;\n    }\n}\n\n \n__attribute_maybe_unused__ __attribute_nonnull__ ((1))\nstatic void\nDYNARRAY_NAME (remove_last) (struct DYNARRAY_STRUCT *list)\n{\n   \n  if (list->u.dynarray_header.used > 0)\n    {\n      size_t new_length = list->u.dynarray_header.used - 1;\n#ifdef DYNARRAY_ELEMENT_FREE\n      DYNARRAY_ELEMENT_FREE (&list->u.dynarray_header.array[new_length]);\n#endif\n      list->u.dynarray_header.used = new_length;\n    }\n}\n\n \n__attribute_maybe_unused__ __attribute_nonnull__ ((1))\nstatic void\nDYNARRAY_NAME (clear) (struct DYNARRAY_STRUCT *list)\n{\n   \n  DYNARRAY_NAME (free__elements__)\n    (list->u.dynarray_header.array, list->u.dynarray_header.used);\n  list->u.dynarray_header.used = 0;\n}\n\n#ifdef DYNARRAY_FINAL_TYPE\n \n__attribute_maybe_unused__ __attribute_warn_unused_result__\n__attribute_nonnull__ ((1, 2))\nstatic bool\nDYNARRAY_NAME (finalize) (struct DYNARRAY_STRUCT *list,\n                          DYNARRAY_FINAL_TYPE *result)\n{\n  struct dynarray_finalize_result res;\n  if (__libc_dynarray_finalize (&list->u.dynarray_abstract,\n                                DYNARRAY_SCRATCH (list),\n                                sizeof (DYNARRAY_ELEMENT), &res))\n    {\n       \n      DYNARRAY_NAME (init) (list);\n      *result = (DYNARRAY_FINAL_TYPE) { res.array, res.length };\n      return true;\n    }\n  else\n    {\n       \n      DYNARRAY_FREE (list);\n      errno = ENOMEM;\n      return false;\n    }\n}\n#else  \n \n__attribute_maybe_unused__ __attribute_warn_unused_result__\n__attribute_nonnull__ ((1))\nstatic DYNARRAY_ELEMENT *\nDYNARRAY_NAME (finalize) (struct DYNARRAY_STRUCT *list, size_t *lengthp)\n{\n  struct dynarray_finalize_result res;\n  if (__libc_dynarray_finalize (&list->u.dynarray_abstract,\n                                DYNARRAY_SCRATCH (list),\n                                sizeof (DYNARRAY_ELEMENT), &res))\n    {\n       \n      DYNARRAY_NAME (init) (list);\n      if (lengthp != NULL)\n        *lengthp = res.length;\n      return res.array;\n    }\n  else\n    {\n       \n      DYNARRAY_FREE (list);\n      errno = ENOMEM;\n      return NULL;\n    }\n}\n#endif  \n\n \n\n#undef DYNARRAY_CONCAT0\n#undef DYNARRAY_CONCAT1\n#undef DYNARRAY_NAME\n#undef DYNARRAY_SCRATCH\n#undef DYNARRAY_HAVE_SCRATCH\n\n#undef DYNARRAY_STRUCT\n#undef DYNARRAY_ELEMENT\n#undef DYNARRAY_PREFIX\n#undef DYNARRAY_ELEMENT_FREE\n#undef DYNARRAY_ELEMENT_INIT\n#undef DYNARRAY_INITIAL_SIZE\n#undef DYNARRAY_FINAL_TYPE\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}