{
  "module_name": "utimens.c",
  "hash_id": "8bebf901c495147f2dc0ec5c1a7220bc1df7655b07af6647ec6c7dc8bb71258e",
  "original_prompt": "Ingested from coreutils-9.4/lib/utimens.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#define _GL_UTIMENS_INLINE _GL_EXTERN_INLINE\n#include \"utimens.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <utime.h>\n\n#include \"stat-time.h\"\n#include \"timespec.h\"\n\n \n\n#if defined _WIN32 && ! defined __CYGWIN__ && ! defined EMACS_CONFIGURATION\n# define USE_SETFILETIME\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n#endif\n\n \n#undef futimens\n#if !HAVE_NEARLY_WORKING_UTIMENSAT\n# undef utimensat\n#endif\n\n \n#ifndef REPLACE_FUNC_STAT_FILE\n# define REPLACE_FUNC_STAT_FILE 0\n#endif\n\n#if HAVE_UTIMENSAT || HAVE_FUTIMENS\n \nstatic int utimensat_works_really;\nstatic int lutimensat_works_really;\n#endif  \n\n \nstatic int\nvalidate_timespec (struct timespec timespec[2])\n{\n  int result = 0;\n  int utime_omit_count = 0;\n  if ((timespec[0].tv_nsec != UTIME_NOW\n       && timespec[0].tv_nsec != UTIME_OMIT\n       && ! (0 <= timespec[0].tv_nsec\n             && timespec[0].tv_nsec < TIMESPEC_HZ))\n      || (timespec[1].tv_nsec != UTIME_NOW\n          && timespec[1].tv_nsec != UTIME_OMIT\n          && ! (0 <= timespec[1].tv_nsec\n                && timespec[1].tv_nsec < TIMESPEC_HZ)))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n   \n  if (timespec[0].tv_nsec == UTIME_NOW\n      || timespec[0].tv_nsec == UTIME_OMIT)\n    {\n      timespec[0].tv_sec = 0;\n      result = 1;\n      if (timespec[0].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  if (timespec[1].tv_nsec == UTIME_NOW\n      || timespec[1].tv_nsec == UTIME_OMIT)\n    {\n      timespec[1].tv_sec = 0;\n      result = 1;\n      if (timespec[1].tv_nsec == UTIME_OMIT)\n        utime_omit_count++;\n    }\n  return result + (utime_omit_count == 1);\n}\n\n \nstatic bool\nupdate_timespec (struct stat const *statbuf, struct timespec **ts)\n{\n  struct timespec *timespec = *ts;\n  if (timespec[0].tv_nsec == UTIME_OMIT\n      && timespec[1].tv_nsec == UTIME_OMIT)\n    return true;\n  if (timespec[0].tv_nsec == UTIME_NOW\n      && timespec[1].tv_nsec == UTIME_NOW)\n    {\n      *ts = NULL;\n      return false;\n    }\n\n  if (timespec[0].tv_nsec == UTIME_OMIT)\n    timespec[0] = get_stat_atime (statbuf);\n  else if (timespec[0].tv_nsec == UTIME_NOW)\n    gettime (&timespec[0]);\n\n  if (timespec[1].tv_nsec == UTIME_OMIT)\n    timespec[1] = get_stat_mtime (statbuf);\n  else if (timespec[1].tv_nsec == UTIME_NOW)\n    gettime (&timespec[1]);\n\n  return false;\n}\n\n \n\nint\nfdutimens (int fd, char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n   \n  if (fd < 0 && !file)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n   \n\n#if HAVE_BUGGY_NFS_TIME_STAMPS\n  if (fd < 0)\n    sync ();\n  else\n    fsync (fd);\n#endif\n\n   \n#if HAVE_UTIMENSAT || HAVE_FUTIMENS\n  if (0 <= utimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n       \n      if (adjustment_needed == 2)\n        {\n          if (fd < 0 ? stat (file, &st) : fstat (fd, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n           \n          adjustment_needed++;\n        }\n# endif\n# if HAVE_UTIMENSAT\n      if (fd < 0)\n        {\n#  if defined __APPLE__ && defined __MACH__\n          size_t len = strlen (file);\n          if (len > 0 && file[len - 1] == '/')\n            {\n              struct stat statbuf;\n              if (stat (file, &statbuf) < 0)\n                return -1;\n              if (!S_ISDIR (statbuf.st_mode))\n                {\n                  errno = ENOTDIR;\n                  return -1;\n                }\n            }\n#  endif\n          result = utimensat (AT_FDCWD, file, ts, 0);\n#  ifdef __linux__\n           \n          if (0 < result)\n            errno = ENOSYS;\n#  endif  \n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif  \n# if HAVE_FUTIMENS\n      if (0 <= fd)\n        {\n          result = futimens (fd, ts);\n#  ifdef __linux__\n           \n          if (0 < result)\n            errno = ENOSYS;\n#  endif  \n          if (result == 0 || errno != ENOSYS)\n            {\n              utimensat_works_really = 1;\n              return result;\n            }\n        }\n# endif  \n    }\n  utimensat_works_really = -1;\n  lutimensat_works_really = -1;\n#endif  \n\n#ifdef USE_SETFILETIME\n   \n  if (0 <= fd)\n    {\n      HANDLE handle;\n      FILETIME current_time;\n      FILETIME last_access_time;\n      FILETIME last_write_time;\n\n      handle = (HANDLE) _get_osfhandle (fd);\n      if (handle == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n\n      if (ts == NULL || ts[0].tv_nsec == UTIME_NOW || ts[1].tv_nsec == UTIME_NOW)\n        {\n           \n          GetSystemTimeAsFileTime (&current_time);\n        }\n\n      if (ts == NULL || ts[0].tv_nsec == UTIME_NOW)\n        {\n          last_access_time = current_time;\n        }\n      else if (ts[0].tv_nsec == UTIME_OMIT)\n        {\n          last_access_time.dwLowDateTime = 0;\n          last_access_time.dwHighDateTime = 0;\n        }\n      else\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[0].tv_sec * 10000000 + ts[0].tv_nsec / 100 + 116444736000000000LL;\n          last_access_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_access_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n\n      if (ts == NULL || ts[1].tv_nsec == UTIME_NOW)\n        {\n          last_write_time = current_time;\n        }\n      else if (ts[1].tv_nsec == UTIME_OMIT)\n        {\n          last_write_time.dwLowDateTime = 0;\n          last_write_time.dwHighDateTime = 0;\n        }\n      else\n        {\n          ULONGLONG time_since_16010101 =\n            (ULONGLONG) ts[1].tv_sec * 10000000 + ts[1].tv_nsec / 100 + 116444736000000000LL;\n          last_write_time.dwLowDateTime = (DWORD) time_since_16010101;\n          last_write_time.dwHighDateTime = time_since_16010101 >> 32;\n        }\n\n      if (SetFileTime (handle, NULL, &last_access_time, &last_write_time))\n        return 0;\n      else\n        {\n          DWORD sft_error = GetLastError ();\n          #if 0\n          fprintf (stderr, \"fdutimens SetFileTime error 0x%x\\n\", (unsigned int) sft_error);\n          #endif\n          switch (sft_error)\n            {\n            case ERROR_ACCESS_DENIED:  \n              errno = EACCES;  \n              break;\n            default:\n              errno = EINVAL;\n              break;\n            }\n          return -1;\n        }\n    }\n#endif\n\n   \n\n  if (adjustment_needed || (REPLACE_FUNC_STAT_FILE && fd < 0))\n    {\n      if (adjustment_needed != 3\n          && (fd < 0 ? stat (file, &st) : fstat (fd, &st)))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n  {\n#if HAVE_FUTIMESAT || HAVE_WORKING_UTIMES\n    struct timeval timeval[2];\n    struct timeval *t;\n    if (ts)\n      {\n        timeval[0] = (struct timeval) { .tv_sec  = ts[0].tv_sec,\n                                        .tv_usec = ts[0].tv_nsec / 1000 };\n        timeval[1] = (struct timeval) { .tv_sec  = ts[1].tv_sec,\n                                        .tv_usec = ts[1].tv_nsec / 1000 };\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    if (fd < 0)\n      {\n# if HAVE_FUTIMESAT\n        return futimesat (AT_FDCWD, file, t);\n# endif\n      }\n    else\n      {\n         \n\n# if (HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG) || HAVE_FUTIMES\n#  if HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG\n#   undef futimes\n#   define futimes(fd, t) futimesat (fd, NULL, t)\n#  endif\n        if (futimes (fd, t) == 0)\n          {\n#  if __linux__ && __GLIBC__\n             \n            if (t)\n              {\n                bool abig = 500000 <= t[0].tv_usec;\n                bool mbig = 500000 <= t[1].tv_usec;\n                if ((abig | mbig) && fstat (fd, &st) == 0)\n                  {\n                     \n                    time_t adiff = st.st_atime - t[0].tv_sec;\n                    time_t mdiff = st.st_mtime - t[1].tv_sec;\n\n                    struct timeval *tt = NULL;\n                    struct timeval truncated_timeval[2];\n                    truncated_timeval[0] = t[0];\n                    truncated_timeval[1] = t[1];\n                    if (abig && adiff == 1 && get_stat_atime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[0].tv_usec = 0;\n                      }\n                    if (mbig && mdiff == 1 && get_stat_mtime_ns (&st) == 0)\n                      {\n                        tt = truncated_timeval;\n                        tt[1].tv_usec = 0;\n                      }\n                    if (tt)\n                      futimes (fd, tt);\n                  }\n              }\n#  endif\n\n            return 0;\n          }\n# endif\n      }\n#endif  \n\n    if (!file)\n      {\n#if ! ((HAVE_FUTIMESAT && !FUTIMESAT_NULL_BUG)          \\\n        || (HAVE_WORKING_UTIMES && HAVE_FUTIMES))\n        errno = ENOSYS;\n#endif\n        return -1;\n      }\n\n#ifdef USE_SETFILETIME\n    return _gl_utimens_windows (file, ts);\n#elif HAVE_WORKING_UTIMES\n    return utimes (file, t);\n#else\n    {\n      struct utimbuf utimbuf;\n      struct utimbuf *ut;\n      if (ts)\n        {\n          utimbuf = (struct utimbuf) { .actime  = ts[0].tv_sec,\n                                       .modtime = ts[1].tv_sec };\n          ut = &utimbuf;\n        }\n      else\n        ut = NULL;\n\n      return utime (file, ut);\n    }\n#endif  \n  }\n}\n\n \nint\nutimens (char const *file, struct timespec const timespec[2])\n{\n  return fdutimens (-1, file, timespec);\n}\n\n \nint\nlutimens (char const *file, struct timespec const timespec[2])\n{\n  struct timespec adjusted_timespec[2];\n  struct timespec *ts = timespec ? adjusted_timespec : NULL;\n  int adjustment_needed = 0;\n  struct stat st;\n\n  if (ts)\n    {\n      adjusted_timespec[0] = timespec[0];\n      adjusted_timespec[1] = timespec[1];\n      adjustment_needed = validate_timespec (ts);\n    }\n  if (adjustment_needed < 0)\n    return -1;\n\n   \n\n#if HAVE_UTIMENSAT\n  if (0 <= lutimensat_works_really)\n    {\n      int result;\n# if __linux__ || __sun\n       \n      if (adjustment_needed == 2)\n        {\n          if (lstat (file, &st))\n            return -1;\n          if (ts[0].tv_nsec == UTIME_OMIT)\n            ts[0] = get_stat_atime (&st);\n          else if (ts[1].tv_nsec == UTIME_OMIT)\n            ts[1] = get_stat_mtime (&st);\n           \n          adjustment_needed++;\n        }\n# endif\n      result = utimensat (AT_FDCWD, file, ts, AT_SYMLINK_NOFOLLOW);\n# ifdef __linux__\n       \n      if (0 < result)\n        errno = ENOSYS;\n# endif\n      if (result == 0 || errno != ENOSYS)\n        {\n          utimensat_works_really = 1;\n          lutimensat_works_really = 1;\n          return result;\n        }\n    }\n  lutimensat_works_really = -1;\n#endif  \n\n   \n\n  if (adjustment_needed || REPLACE_FUNC_STAT_FILE)\n    {\n      if (adjustment_needed != 3 && lstat (file, &st))\n        return -1;\n      if (ts && update_timespec (&st, &ts))\n        return 0;\n    }\n\n   \n#if HAVE_LUTIMES && !HAVE_UTIMENSAT\n  {\n    struct timeval timeval[2];\n    struct timeval *t;\n    int result;\n    if (ts)\n      {\n        timeval[0] = (struct timeval) { .tv_sec = ts[0].tv_sec,\n                                        .tv_usec = ts[0].tv_nsec / 1000 };\n        timeval[1] = (struct timeval) { .tv_sec = ts[1].tv_sec,\n                                        .tv_usec = ts[1].tv_nsec / 1000 };\n        t = timeval;\n      }\n    else\n      t = NULL;\n\n    result = lutimes (file, t);\n    if (result == 0 || errno != ENOSYS)\n      return result;\n  }\n#endif  \n\n   \n  if (!(adjustment_needed || REPLACE_FUNC_STAT_FILE) && lstat (file, &st))\n    return -1;\n  if (!S_ISLNK (st.st_mode))\n    return fdutimens (-1, file, ts);\n  errno = ENOSYS;\n  return -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}