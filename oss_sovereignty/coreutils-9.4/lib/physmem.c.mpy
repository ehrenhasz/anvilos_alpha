{
  "module_name": "physmem.c",
  "hash_id": "52061f4f581edb5deb54a95c8a968c55bbdee656a6b67f8c5a4cebbb5d33a1ec",
  "original_prompt": "Ingested from coreutils-9.4/lib/physmem.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"physmem.h\"\n\n#include <unistd.h>\n\n#if HAVE_SYS_PSTAT_H\n# include <sys/pstat.h>\n#endif\n\n#if HAVE_SYS_SYSMP_H\n# include <sys/sysmp.h>\n#endif\n\n#if HAVE_SYS_SYSINFO_H\n# include <sys/sysinfo.h>\n#endif\n\n#if HAVE_MACHINE_HAL_SYSINFO_H\n# include <machine/hal_sysinfo.h>\n#endif\n\n#if HAVE_SYS_TABLE_H\n# include <sys/table.h>\n#endif\n\n#include <sys/types.h>\n\n#if HAVE_SYS_PARAM_H\n# include <sys/param.h>\n#endif\n\n#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__)\n# include <sys/sysctl.h>\n#endif\n\n#if HAVE_SYS_SYSTEMCFG_H\n# include <sys/systemcfg.h>\n#endif\n\n#ifdef _WIN32\n\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n\n \n# undef GetModuleHandle\n# define GetModuleHandle GetModuleHandleA\n\n \n# define GetProcAddress \\\n   (void *) GetProcAddress\n\n \ntypedef struct\n{\n  DWORD dwLength;\n  DWORD dwMemoryLoad;\n  DWORDLONG ullTotalPhys;\n  DWORDLONG ullAvailPhys;\n  DWORDLONG ullTotalPageFile;\n  DWORDLONG ullAvailPageFile;\n  DWORDLONG ullTotalVirtual;\n  DWORDLONG ullAvailVirtual;\n  DWORDLONG ullAvailExtendedVirtual;\n} lMEMORYSTATUSEX;\ntypedef BOOL (WINAPI *PFN_MS_EX) (lMEMORYSTATUSEX*);\n\n#endif\n\n#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))\n\n \ndouble\nphysmem_total (void)\n{\n#if defined _SC_PHYS_PAGES && defined _SC_PAGESIZE\n  {  \n    double pages = sysconf (_SC_PHYS_PAGES);\n    double pagesize = sysconf (_SC_PAGESIZE);\n    if (0 <= pages && 0 <= pagesize)\n      return pages * pagesize;\n  }\n#endif\n\n#if HAVE_SYSINFO && HAVE_STRUCT_SYSINFO_MEM_UNIT\n  {  \n    struct sysinfo si;\n    if (sysinfo(&si) == 0)\n      return (double) si.totalram * si.mem_unit;\n  }\n#endif\n\n#if HAVE_PSTAT_GETSTATIC\n  {  \n    struct pst_static pss;\n    if (0 <= pstat_getstatic (&pss, sizeof pss, 1, 0))\n      {\n        double pages = pss.physical_memory;\n        double pagesize = pss.page_size;\n        if (0 <= pages && 0 <= pagesize)\n          return pages * pagesize;\n      }\n  }\n#endif\n\n#if HAVE_SYSMP && defined MP_SAGET && defined MPSA_RMINFO && defined _SC_PAGESIZE\n  {  \n    struct rminfo realmem;\n    if (sysmp (MP_SAGET, MPSA_RMINFO, &realmem, sizeof realmem) == 0)\n      {\n        double pagesize = sysconf (_SC_PAGESIZE);\n        double pages = realmem.physmem;\n        if (0 <= pages && 0 <= pagesize)\n          return pages * pagesize;\n      }\n  }\n#endif\n\n#if HAVE_GETSYSINFO && defined GSI_PHYSMEM\n  {  \n    int physmem;\n\n    if (getsysinfo (GSI_PHYSMEM, (caddr_t) &physmem, sizeof (physmem),\n                    NULL, NULL, NULL) == 1)\n      {\n        double kbytes = physmem;\n\n        if (0 <= kbytes)\n          return kbytes * 1024.0;\n      }\n  }\n#endif\n\n#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_PHYSMEM\n  {  \n    unsigned int physmem;\n    size_t len = sizeof physmem;\n    static int mib[2] = { CTL_HW, HW_PHYSMEM };\n\n    if (sysctl (mib, ARRAY_SIZE (mib), &physmem, &len, NULL, 0) == 0\n        && len == sizeof (physmem))\n      return (double) physmem;\n  }\n#endif\n\n#if HAVE__SYSTEM_CONFIGURATION\n   \n  return _system_configuration.physmem;\n#endif\n\n#if defined _WIN32\n  {  \n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle (\"kernel32.dll\");\n\n    if (!h)\n      return 0.0;\n\n     \n    if ((pfnex = (PFN_MS_EX) GetProcAddress (h, \"GlobalMemoryStatusEx\")))\n      {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof lms_ex;\n        if (!pfnex (&lms_ex))\n          return 0.0;\n        return (double) lms_ex.ullTotalPhys;\n      }\n\n     \n    else\n      {\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus (&ms);\n        return (double) ms.dwTotalPhys;\n      }\n  }\n#endif\n\n   \n  return 64 * 1024 * 1024;\n}\n\n \ndouble\nphysmem_available (void)\n{\n#if defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE\n  {  \n    double pages = sysconf (_SC_AVPHYS_PAGES);\n    double pagesize = sysconf (_SC_PAGESIZE);\n    if (0 <= pages && 0 <= pagesize)\n      return pages * pagesize;\n  }\n#endif\n\n#if HAVE_SYSINFO && HAVE_STRUCT_SYSINFO_MEM_UNIT\n  {  \n    struct sysinfo si;\n    if (sysinfo(&si) == 0)\n      return ((double) si.freeram + si.bufferram) * si.mem_unit;\n  }\n#endif\n\n#if HAVE_PSTAT_GETSTATIC && HAVE_PSTAT_GETDYNAMIC\n  {  \n    struct pst_static pss;\n    struct pst_dynamic psd;\n    if (0 <= pstat_getstatic (&pss, sizeof pss, 1, 0)\n        && 0 <= pstat_getdynamic (&psd, sizeof psd, 1, 0))\n      {\n        double pages = psd.psd_free;\n        double pagesize = pss.page_size;\n        if (0 <= pages && 0 <= pagesize)\n          return pages * pagesize;\n      }\n  }\n#endif\n\n#if HAVE_SYSMP && defined MP_SAGET && defined MPSA_RMINFO && defined _SC_PAGESIZE\n  {  \n    struct rminfo realmem;\n    if (sysmp (MP_SAGET, MPSA_RMINFO, &realmem, sizeof realmem) == 0)\n      {\n        double pagesize = sysconf (_SC_PAGESIZE);\n        double pages = realmem.availrmem;\n        if (0 <= pages && 0 <= pagesize)\n          return pages * pagesize;\n      }\n  }\n#endif\n\n#if HAVE_TABLE && defined TBL_VMSTATS\n  {  \n    struct tbl_vmstats vmstats;\n\n    if (table (TBL_VMSTATS, 0, &vmstats, 1, sizeof (vmstats)) == 1)\n      {\n        double pages = vmstats.free_count;\n        double pagesize = vmstats.pagesize;\n\n        if (0 <= pages && 0 <= pagesize)\n          return pages * pagesize;\n      }\n  }\n#endif\n\n#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_USERMEM\n  {  \n    unsigned int usermem;\n    size_t len = sizeof usermem;\n    static int mib[2] = { CTL_HW, HW_USERMEM };\n\n    if (sysctl (mib, ARRAY_SIZE (mib), &usermem, &len, NULL, 0) == 0\n        && len == sizeof (usermem))\n      return (double) usermem;\n  }\n#endif\n\n#if defined _WIN32\n  {  \n    PFN_MS_EX pfnex;\n    HMODULE h = GetModuleHandle (\"kernel32.dll\");\n\n    if (!h)\n      return 0.0;\n\n     \n    if ((pfnex = (PFN_MS_EX) GetProcAddress (h, \"GlobalMemoryStatusEx\")))\n      {\n        lMEMORYSTATUSEX lms_ex;\n        lms_ex.dwLength = sizeof lms_ex;\n        if (!pfnex (&lms_ex))\n          return 0.0;\n        return (double) lms_ex.ullAvailPhys;\n      }\n\n     \n    else\n      {\n        MEMORYSTATUS ms;\n        GlobalMemoryStatus (&ms);\n        return (double) ms.dwAvailPhys;\n      }\n  }\n#endif\n\n   \n  return physmem_total () / 4;\n}\n\n\n#if DEBUG\n\n# include <stdio.h>\n# include <stdlib.h>\n\nint\nmain (void)\n{\n  printf (\"%12.f %12.f\\n\", physmem_total (), physmem_available ());\n  exit (0);\n}\n\n#endif  \n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}