{
  "module_name": "readtokens.c",
  "hash_id": "4f88c1c4b03d168c69584a09ceb1e2874b6b95e6a0a7baef5fdf09097dd7d3ef",
  "original_prompt": "Ingested from coreutils-9.4/lib/readtokens.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"readtokens.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"xalloc.h\"\n\n#if USE_UNLOCKED_IO\n# include \"unlocked-io.h\"\n#endif\n\n \n\nvoid\ninit_tokenbuffer (token_buffer *tokenbuffer)\n{\n  tokenbuffer->size = 0;\n  tokenbuffer->buffer = NULL;\n}\n\ntypedef size_t word;\nenum { bits_per_word = sizeof (word) * CHAR_BIT };\n\nstatic bool\nget_nth_bit (size_t n, word const *bitset)\n{\n  return bitset[n / bits_per_word] >> n % bits_per_word & 1;\n}\n\nstatic void\nset_nth_bit (size_t n, word *bitset)\n{\n  size_t one = 1;\n  bitset[n / bits_per_word] |= one << n % bits_per_word;\n}\n\n \n\nsize_t\nreadtoken (FILE *stream,\n           const char *delim,\n           size_t n_delim,\n           token_buffer *tokenbuffer)\n{\n  int c;\n  idx_t i;\n  word isdelim[(UCHAR_MAX + bits_per_word) / bits_per_word];\n\n  memset (isdelim, 0, sizeof isdelim);\n  for (i = 0; i < n_delim; i++)\n    {\n      unsigned char ch = delim[i];\n      set_nth_bit (ch, isdelim);\n    }\n\n   \n  for (c = getc (stream); c >= 0 && get_nth_bit (c, isdelim); c = getc (stream))\n    {\n       \n    }\n\n  char *p = tokenbuffer->buffer;\n  idx_t n = tokenbuffer->size;\n  i = 0;\n  for (;;)\n    {\n      if (c < 0 && i == 0)\n        return -1;\n\n      if (i == n)\n        p = xpalloc (p, &n, 1, -1, sizeof *p);\n\n      if (c < 0)\n        {\n          p[i] = 0;\n          break;\n        }\n      if (get_nth_bit (c, isdelim))\n        {\n          p[i] = 0;\n          break;\n        }\n      p[i++] = c;\n      c = getc (stream);\n    }\n\n  tokenbuffer->buffer = p;\n  tokenbuffer->size = n;\n  return i;\n}\n\n \n\nsize_t\nreadtokens (FILE *stream,\n            size_t projected_n_tokens,\n            const char *delim,\n            size_t n_delim,\n            char ***tokens_out,\n            size_t **token_lengths)\n{\n  token_buffer tb, *token = &tb;\n  char **tokens;\n  size_t *lengths;\n  idx_t sz, n_tokens;\n\n  if (projected_n_tokens == 0)\n    projected_n_tokens = 64;\n  else\n    projected_n_tokens++;        \n\n  sz = projected_n_tokens;\n  tokens = xnmalloc (sz, sizeof *tokens);\n  lengths = xnmalloc (sz, sizeof *lengths);\n\n  n_tokens = 0;\n  init_tokenbuffer (token);\n  for (;;)\n    {\n      char *tmp;\n      size_t token_length = readtoken (stream, delim, n_delim, token);\n      if (n_tokens >= sz)\n        {\n          tokens = xpalloc (tokens, &sz, 1, -1, sizeof *tokens);\n          lengths = xreallocarray (lengths, sz, sizeof *lengths);\n        }\n\n      if (token_length == (size_t) -1)\n        {\n           \n          tokens[n_tokens] = NULL;\n          lengths[n_tokens] = 0;\n          break;\n        }\n      tmp = xnmalloc (token_length + 1, sizeof *tmp);\n      lengths[n_tokens] = token_length;\n      tokens[n_tokens] = memcpy (tmp, token->buffer, token_length + 1);\n      n_tokens++;\n    }\n\n  free (token->buffer);\n  *tokens_out = tokens;\n  if (token_lengths != NULL)\n    *token_lengths = lengths;\n  else\n    free (lengths);\n  return n_tokens;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}