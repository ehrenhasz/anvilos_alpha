{
  "module_name": "chdir-long.c",
  "hash_id": "b9849bc930162e21c24ec12e23ba98b27cefe972975d63d46b964632fa56c34b",
  "original_prompt": "Ingested from coreutils-9.4/lib/chdir-long.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"chdir-long.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"assure.h\"\n\n#ifndef PATH_MAX\n# error \"compile this file only if your system defines PATH_MAX\"\n#endif\n\n \n\nstruct cd_buf\n{\n  int fd;\n};\n\nstatic void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}\n\nstatic int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}\n\nstatic void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}\n\n \nstatic int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}\n\n \nstatic char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}\n\n \n\nint\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n     \n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n     \n    n_leading_slash = strspn (dir, \"/\");\n\n     \n    if (n_leading_slash == 2)\n      {\n        int err;\n         \n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n         \n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}\n\n#if TEST_CHDIR\n\n# include \"closeout.h\"\n# include \"error.h\"\n\nint\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n       \n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}