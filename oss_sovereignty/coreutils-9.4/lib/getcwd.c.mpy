{
  "module_name": "getcwd.c",
  "hash_id": "8f3d492b19e1700693f35a49953f9a8fde1e387eb9ae8e09b352fd03a6ebc288",
  "original_prompt": "Ingested from coreutils-9.4/lib/getcwd.c",
  "human_readable_source": " \n\n \n#if defined HAVE_OPENAT || (defined GNULIB_OPENAT && defined HAVE_FDOPENDIR)\n# define HAVE_OPENAT_SUPPORT 1\n#else\n# define HAVE_OPENAT_SUPPORT 0\n#endif\n\n#ifndef __set_errno\n# define __set_errno(val) (errno = (val))\n#endif\n\n#include <dirent.h>\n#ifndef _D_EXACT_NAMLEN\n# define _D_EXACT_NAMLEN(d) strlen ((d)->d_name)\n#endif\n#ifndef _D_ALLOC_NAMLEN\n# define _D_ALLOC_NAMLEN(d) (_D_EXACT_NAMLEN (d) + 1)\n#endif\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if _LIBC\n# ifndef mempcpy\n#  define mempcpy __mempcpy\n# endif\n#endif\n\n#ifndef MAX\n# define MAX(a, b) ((a) < (b) ? (b) : (a))\n#endif\n#ifndef MIN\n# define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n \n#ifndef PATH_MAX\n# define PATH_MAX 8192\n#endif\n\n#if D_INO_IN_DIRENT\n# define MATCHING_INO(dp, ino) ((dp)->d_ino == (ino))\n#else\n# define MATCHING_INO(dp, ino) true\n#endif\n\n#if HAVE_MSVC_INVALID_PARAMETER_HANDLER\n# include \"msvc-inval.h\"\n#endif\n\n#if !_LIBC\n# define GETCWD_RETURN_TYPE char *\n# define __close_nocancel_nostatus close\n# define __getcwd_generic rpl_getcwd\n# undef stat64\n# define stat64    stat\n# define __fstat64 fstat\n# define __fstatat64 fstatat\n# define __lstat64 lstat\n# define __closedir closedir\n# define __opendir opendir\n# define __readdir64 readdir\n# define __fdopendir fdopendir\n# define __openat openat\n# define __rewinddir rewinddir\n# define __openat64 openat\n# define dirent64 dirent\n#else\n# include <not-cancel.h>\n#endif\n\n \n#ifdef GNULIB_defined_DIR\n# undef DIR\n# undef opendir\n# undef closedir\n# undef readdir\n# undef rewinddir\n#else\n# ifdef GNULIB_defined_opendir\n#  undef opendir\n# endif\n# ifdef GNULIB_defined_closedir\n#  undef closedir\n# endif\n#endif\n\n#if defined _WIN32 && !defined __CYGWIN__\n# if HAVE_MSVC_INVALID_PARAMETER_HANDLER\nstatic char *\ngetcwd_nothrow (char *buf, size_t size)\n{\n  char *result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _getcwd (buf, size);\n    }\n  CATCH_MSVC_INVAL\n    {\n      result = NULL;\n      errno = ERANGE;\n    }\n  DONE_MSVC_INVAL;\n\n  return result;\n}\n# else\n#  define getcwd_nothrow _getcwd\n# endif\n# define getcwd_system getcwd_nothrow\n#else\n# define getcwd_system getcwd\n#endif\n\n \n\nGETCWD_RETURN_TYPE\n__getcwd_generic (char *buf, size_t size)\n{\n   \n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n# if defined __linux__\n  bool proc_fs_not_mounted = false;\n# endif\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct stat64 st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n   \n\n# undef getcwd\n  dir = getcwd_system (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n   \n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd_system (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n   \n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat64 (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat64 (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent64 *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n       \n#if HAVE_OPENAT_SUPPORT\n      fd = __openat64 (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = __fstat64 (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat64 (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n       \n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n       \n#if HAVE_OPENAT_SUPPORT\n      dirstream = __fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n           \n          __set_errno (0);\n          d = __readdir64 (dirstream);\n\n           \n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              __rewinddir (dirstream);\n              d = __readdir64 (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                 \n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = __fstatat64 (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);\n#else\n             \n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                 \n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat64 (dotlist, &st);\n#endif\n             \n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n               \n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n\n#if HAVE_OPENAT_SUPPORT\n       \n# if defined __linux__\n       \n      if (!proc_fs_not_mounted)\n        {\n          char namebuf[14 + 10 + 1];\n          sprintf (namebuf, \"/proc/self/fd/%u\", (unsigned int) fd);\n          char linkbuf[4096];\n          ssize_t linklen = readlink (namebuf, linkbuf, sizeof linkbuf);\n          if (linklen < 0)\n            {\n              if (errno != ENAMETOOLONG)\n                 \n                proc_fs_not_mounted = true;\n            }\n          else\n            {\n              dirroom = dirp - dir;\n              if (dirroom < linklen)\n                {\n                  if (size != 0)\n                    {\n                      __set_errno (ERANGE);\n                      goto lose;\n                    }\n                  else\n                    {\n                      char *tmp;\n                      size_t oldsize = allocated;\n\n                      allocated += linklen - dirroom;\n                      if (allocated < oldsize\n                          || ! (tmp = realloc (dir, allocated)))\n                        goto memory_exhausted;\n\n                       \n                      dirp = memmove (tmp + dirroom + (allocated - oldsize),\n                                      tmp + dirroom,\n                                      oldsize - dirroom);\n                      dir = tmp;\n                    }\n                }\n              dirp -= linklen;\n              memcpy (dirp, linkbuf, linklen);\n              break;\n            }\n        }\n# endif\n#endif\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n     \n    buf = (used < allocated ? realloc (dir, used) : dir);\n\n  if (buf == NULL)\n     \n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n       __close_nocancel_nostatus (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}\n\n#if defined _LIBC && !defined GETCWD_RETURN_TYPE\nlibc_hidden_def (__getcwd)\nweak_alias (__getcwd, getcwd)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}