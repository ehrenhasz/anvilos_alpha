{
  "module_name": "windows-recmutex.c",
  "hash_id": "8953fcd55398ccbb4aaeb785e8c44d02a32f86c5ccb50865109390f425d2254a",
  "original_prompt": "Ingested from coreutils-9.4/lib/windows-recmutex.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"windows-recmutex.h\"\n\n#include <errno.h>\n\nvoid\nglwthread_recmutex_init (glwthread_recmutex_t *mutex)\n{\n  mutex->owner = 0;\n  mutex->depth = 0;\n  InitializeCriticalSection (&mutex->lock);\n  mutex->guard.done = 1;\n}\n\nint\nglwthread_recmutex_lock (glwthread_recmutex_t *mutex)\n{\n  if (!mutex->guard.done)\n    {\n      if (InterlockedIncrement (&mutex->guard.started) == 0)\n         \n        glwthread_recmutex_init (mutex);\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          while (!mutex->guard.done)\n            Sleep (0);\n        }\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (mutex->owner != self)\n      {\n        EnterCriticalSection (&mutex->lock);\n        mutex->owner = self;\n      }\n    if (++(mutex->depth) == 0)  \n      {\n        mutex->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}\n\nint\nglwthread_recmutex_trylock (glwthread_recmutex_t *mutex)\n{\n  if (!mutex->guard.done)\n    {\n      if (InterlockedIncrement (&mutex->guard.started) == 0)\n         \n        glwthread_recmutex_init (mutex);\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          return EBUSY;\n        }\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (mutex->owner != self)\n      {\n        if (!TryEnterCriticalSection (&mutex->lock))\n          return EBUSY;\n        mutex->owner = self;\n      }\n    if (++(mutex->depth) == 0)  \n      {\n        mutex->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}\n\nint\nglwthread_recmutex_unlock (glwthread_recmutex_t *mutex)\n{\n  if (mutex->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (mutex->depth == 0)\n    return EINVAL;\n  if (--(mutex->depth) == 0)\n    {\n      mutex->owner = 0;\n      LeaveCriticalSection (&mutex->lock);\n    }\n  return 0;\n}\n\nint\nglwthread_recmutex_destroy (glwthread_recmutex_t *mutex)\n{\n  if (mutex->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&mutex->lock);\n  mutex->guard.done = 0;\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}