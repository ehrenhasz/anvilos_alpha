{
  "module_name": "randread.c",
  "hash_id": "ab6336dc57f3c057b991c782865df5cfacf9cb78e85ff60cc54f0c949af4d77e",
  "original_prompt": "Ingested from coreutils-9.4/lib/randread.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"randread.h\"\n\n#include <errno.h>\n#include <error.h>\n#include <exitfail.h>\n#include <fcntl.h>\n#include <quote.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/random.h>\n\n#include \"gettext.h\"\n#define _(msgid) gettext (msgid)\n\n#include \"assure.h\"\n#include \"minmax.h\"\n#include \"rand-isaac.h\"\n#include \"stdio-safer.h\"\n#include \"unlocked-io.h\"\n#include \"xalloc.h\"\n\n#if _STRING_ARCH_unaligned || _STRING_INLINE_unaligned\n# define ALIGNED_POINTER(ptr, type) true\n#else\n# define ALIGNED_POINTER(ptr, type) ((size_t) (ptr) % alignof (type) == 0)\n#endif\n\n \n#define RANDREAD_BUFFER_SIZE (2 * ISAAC_BYTES)\n\n \nstruct randread_source\n{\n   \n  FILE *source;\n\n   \n  void (*handler) (void const *);\n  void const *handler_arg;\n\n   \n  union\n  {\n     \n    char c[RANDREAD_BUFFER_SIZE];\n\n     \n    struct isaac\n    {\n       \n      size_t buffered;\n\n       \n      struct isaac_state state;\n\n       \n      union\n      {\n        isaac_word w[ISAAC_WORDS];\n        unsigned char b[ISAAC_BYTES];\n      } data;\n    } isaac;\n  } buf;\n};\n\n\n \n\nstatic void\nrandread_error (void const *file_name)\n{\n  affirm (exit_failure);\n  error (exit_failure, errno,\n         errno == 0 ? _(\"%s: end of file\") : _(\"%s: read error\"),\n         quote (file_name));\n}\n\n \n\nstatic struct randread_source *\nsimple_new (FILE *source, void const *handler_arg)\n{\n  struct randread_source *s = xmalloc (sizeof *s);\n  s->source = source;\n  s->handler = randread_error;\n  s->handler_arg = handler_arg;\n  return s;\n}\n\n \n\nstatic bool\nget_nonce (void *buffer, size_t bufsize)\n{\n  char *buf = buffer, *buflim = buf + bufsize;\n  while (buf < buflim)\n    {\n#if defined __sun\n# define MAX_GETRANDOM 1024\n#else\n# define MAX_GETRANDOM SIZE_MAX\n#endif\n      size_t max_bytes = MIN (buflim - buf, MAX_GETRANDOM);\n      ssize_t nbytes = getrandom (buf, max_bytes, 0);\n      if (0 <= nbytes)\n        buf += nbytes;\n      else if (errno != EINTR)\n        return false;\n    }\n  return true;\n}\n\n \n\nstatic int\nrandread_free_body (struct randread_source *s)\n{\n  FILE *source = s->source;\n  explicit_bzero (s, sizeof *s);\n  free (s);\n  return source ? fclose (source) : 0;\n}\n\n \n\nstruct randread_source *\nrandread_new (char const *name, size_t bytes_bound)\n{\n  if (bytes_bound == 0)\n    return simple_new (nullptr, nullptr);\n  else\n    {\n      FILE *source = nullptr;\n      struct randread_source *s;\n\n      if (name)\n        if (! (source = fopen_safer (name, \"rb\")))\n          return nullptr;\n\n      s = simple_new (source, name);\n\n      if (source)\n        setvbuf (source, s->buf.c, _IOFBF, MIN (sizeof s->buf.c, bytes_bound));\n      else\n        {\n          s->buf.isaac.buffered = 0;\n          if (! get_nonce (s->buf.isaac.state.m,\n                           MIN (sizeof s->buf.isaac.state.m, bytes_bound)))\n            {\n              int e = errno;\n              randread_free_body (s);\n              errno = e;\n              return nullptr;\n            }\n          isaac_seed (&s->buf.isaac.state);\n        }\n\n      return s;\n    }\n}\n\n\n \n\nvoid\nrandread_set_handler (struct randread_source *s, void (*handler) (void const *))\n{\n  s->handler = handler;\n}\n\nvoid\nrandread_set_handler_arg (struct randread_source *s, void const *handler_arg)\n{\n  s->handler_arg = handler_arg;\n}\n\n\n \n\nstatic void\nreadsource (struct randread_source *s, unsigned char *p, size_t size)\n{\n  while (true)\n    {\n      size_t inbytes = fread (p, sizeof *p, size, s->source);\n      int fread_errno = errno;\n      p += inbytes;\n      size -= inbytes;\n      if (size == 0)\n        break;\n      errno = (ferror (s->source) ? fread_errno : 0);\n      s->handler (s->handler_arg);\n    }\n}\n\n\n \n\nstatic void\nreadisaac (struct isaac *isaac, void *p, size_t size)\n{\n  size_t inbytes = isaac->buffered;\n\n  while (true)\n    {\n      char *char_p = p;\n\n      if (size <= inbytes)\n        {\n          memcpy (p, isaac->data.b + ISAAC_BYTES - inbytes, size);\n          isaac->buffered = inbytes - size;\n          return;\n        }\n\n      memcpy (p, isaac->data.b + ISAAC_BYTES - inbytes, inbytes);\n      p = char_p + inbytes;\n      size -= inbytes;\n\n       \n      if (ALIGNED_POINTER (p, isaac_word))\n        {\n          isaac_word *wp = p;\n          while (ISAAC_BYTES <= size)\n            {\n              isaac_refill (&isaac->state, wp);\n              wp += ISAAC_WORDS;\n              size -= ISAAC_BYTES;\n              if (size == 0)\n                {\n                  isaac->buffered = 0;\n                  return;\n                }\n            }\n          p = wp;\n        }\n\n      isaac_refill (&isaac->state, isaac->data.w);\n      inbytes = ISAAC_BYTES;\n    }\n}\n\n\n \n\nvoid\nrandread (struct randread_source *s, void *buf, size_t size)\n{\n  if (s->source)\n    readsource (s, buf, size);\n  else\n    readisaac (&s->buf.isaac, buf, size);\n}\n\n\n \n\nint\nrandread_free (struct randread_source *s)\n{\n  return randread_free_body (s);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}