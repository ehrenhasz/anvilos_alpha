{
  "module_name": "mbchar.h",
  "hash_id": "4190046e265a4c6cc8e53e6e083576e95928c6bc7d9c3afd133dff82b3ec9473",
  "original_prompt": "Ingested from coreutils-9.4/lib/mbchar.h",
  "human_readable_source": " \n\n \n\n#ifndef _MBCHAR_H\n#define _MBCHAR_H 1\n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#include <string.h>\n#include <uchar.h>\n\n_GL_INLINE_HEADER_BEGIN\n#ifndef MBCHAR_INLINE\n# define MBCHAR_INLINE _GL_INLINE\n#endif\n\n \n#define MBCHAR_BUF_SIZE 4\n\nstruct mbchar\n{\n  const char *ptr;       \n  size_t bytes;          \n  bool wc_valid;         \n  char32_t wc;           \n#if defined GNULIB_MBFILE\n  char buf[MBCHAR_BUF_SIZE];  \n#endif\n};\n\n \n\ntypedef struct mbchar mbchar_t;\n\n \n#define mb_ptr(mbc) ((mbc).ptr)\n#define mb_len(mbc) ((mbc).bytes)\n\n \n#define mb_iseq(mbc, sc) ((mbc).wc_valid && (mbc).wc == (sc))\n#define mb_isnul(mbc) ((mbc).wc_valid && (mbc).wc == 0)\n#define mb_cmp(mbc1, mbc2) \\\n  ((mbc1).wc_valid                                                      \\\n   ? ((mbc2).wc_valid                                                   \\\n      ? _GL_CMP ((mbc1).wc, (mbc2).wc)                                  \\\n      : -1)                                                             \\\n   : ((mbc2).wc_valid                                                   \\\n      ? 1                                                               \\\n      : (mbc1).bytes == (mbc2).bytes                                    \\\n        ? memcmp ((mbc1).ptr, (mbc2).ptr, (mbc1).bytes)                 \\\n        : (mbc1).bytes < (mbc2).bytes                                   \\\n          ? (memcmp ((mbc1).ptr, (mbc2).ptr, (mbc1).bytes) > 0 ? 1 : -1) \\\n          : (memcmp ((mbc1).ptr, (mbc2).ptr, (mbc2).bytes) >= 0 ? 1 : -1)))\n#define mb_casecmp(mbc1, mbc2) \\\n  ((mbc1).wc_valid                                                      \\\n   ? ((mbc2).wc_valid                                                   \\\n      ? _GL_CMP (c32tolower ((mbc1).wc), c32tolower ((mbc2).wc))        \\\n      : -1)                                                             \\\n   : ((mbc2).wc_valid                                                   \\\n      ? 1                                                               \\\n      : (mbc1).bytes == (mbc2).bytes                                    \\\n        ? memcmp ((mbc1).ptr, (mbc2).ptr, (mbc1).bytes)                 \\\n        : (mbc1).bytes < (mbc2).bytes                                   \\\n          ? (memcmp ((mbc1).ptr, (mbc2).ptr, (mbc1).bytes) > 0 ? 1 : -1) \\\n          : (memcmp ((mbc1).ptr, (mbc2).ptr, (mbc2).bytes) >= 0 ? 1 : -1)))\n#define mb_equal(mbc1, mbc2) \\\n  ((mbc1).wc_valid && (mbc2).wc_valid                                   \\\n   ? (mbc1).wc == (mbc2).wc                                             \\\n   : (mbc1).bytes == (mbc2).bytes                                       \\\n     && memcmp ((mbc1).ptr, (mbc2).ptr, (mbc1).bytes) == 0)\n#define mb_caseequal(mbc1, mbc2) \\\n  ((mbc1).wc_valid && (mbc2).wc_valid                                   \\\n   ? c32tolower ((mbc1).wc) == c32tolower ((mbc2).wc)                   \\\n   : (mbc1).bytes == (mbc2).bytes                                       \\\n     && memcmp ((mbc1).ptr, (mbc2).ptr, (mbc1).bytes) == 0)\n\n \n#define mb_isascii(mbc) \\\n  ((mbc).wc_valid && (mbc).wc >= 0 && (mbc).wc <= 127)\n#define mb_isalnum(mbc) ((mbc).wc_valid && c32isalnum ((mbc).wc))\n#define mb_isalpha(mbc) ((mbc).wc_valid && c32isalpha ((mbc).wc))\n#define mb_isblank(mbc) ((mbc).wc_valid && c32isblank ((mbc).wc))\n#define mb_iscntrl(mbc) ((mbc).wc_valid && c32iscntrl ((mbc).wc))\n#define mb_isdigit(mbc) ((mbc).wc_valid && c32isdigit ((mbc).wc))\n#define mb_isgraph(mbc) ((mbc).wc_valid && c32isgraph ((mbc).wc))\n#define mb_islower(mbc) ((mbc).wc_valid && c32islower ((mbc).wc))\n#define mb_isprint(mbc) ((mbc).wc_valid && c32isprint ((mbc).wc))\n#define mb_ispunct(mbc) ((mbc).wc_valid && c32ispunct ((mbc).wc))\n#define mb_isspace(mbc) ((mbc).wc_valid && c32isspace ((mbc).wc))\n#define mb_isupper(mbc) ((mbc).wc_valid && c32isupper ((mbc).wc))\n#define mb_isxdigit(mbc) ((mbc).wc_valid && c32isxdigit ((mbc).wc))\n\n \n\n \n#define MB_UNPRINTABLE_WIDTH 1\n\nMBCHAR_INLINE int\nmb_width_aux (char32_t wc)\n{\n  int w = c32width (wc);\n   \n  return (w >= 0 ? w : c32iscntrl (wc) ? 0 : MB_UNPRINTABLE_WIDTH);\n}\n\n#define mb_width(mbc) \\\n  ((mbc).wc_valid ? mb_width_aux ((mbc).wc) : MB_UNPRINTABLE_WIDTH)\n\n \n#define mb_putc(mbc, stream)  fwrite ((mbc).ptr, 1, (mbc).bytes, (stream))\n\n#if defined GNULIB_MBFILE\n \n# define mb_setascii(mbc, sc) \\\n   ((mbc)->ptr = (mbc)->buf, (mbc)->bytes = 1, (mbc)->wc_valid = 1, \\\n    (mbc)->wc = (mbc)->buf[0] = (sc))\n#endif\n\n \nMBCHAR_INLINE void\nmb_copy (mbchar_t *new_mbc, const mbchar_t *old_mbc)\n{\n#if defined GNULIB_MBFILE\n  if (old_mbc->ptr == &old_mbc->buf[0])\n    {\n      memcpy (&new_mbc->buf[0], &old_mbc->buf[0], old_mbc->bytes);\n      new_mbc->ptr = &new_mbc->buf[0];\n    }\n  else\n#endif\n    new_mbc->ptr = old_mbc->ptr;\n  new_mbc->bytes = old_mbc->bytes;\n  if ((new_mbc->wc_valid = old_mbc->wc_valid))\n    new_mbc->wc = old_mbc->wc;\n}\n\n\n \n#if (' ' == 32) && ('!' == 33) && ('\"' == 34) && ('#' == 35) \\\n    && ('$' == 36) && ('%' == 37) && ('&' == 38) && ('\\'' == 39) \\\n    && ('(' == 40) && (')' == 41) && ('*' == 42) && ('+' == 43) \\\n    && (',' == 44) && ('-' == 45) && ('.' == 46) && ('/' == 47) \\\n    && ('0' == 48) && ('1' == 49) && ('2' == 50) && ('3' == 51) \\\n    && ('4' == 52) && ('5' == 53) && ('6' == 54) && ('7' == 55) \\\n    && ('8' == 56) && ('9' == 57) && (':' == 58) && (';' == 59) \\\n    && ('<' == 60) && ('=' == 61) && ('>' == 62) && ('?' == 63) \\\n    && ('@' == 64) && ('A' == 65) && ('B' == 66) && ('C' == 67) \\\n    && ('D' == 68) && ('E' == 69) && ('F' == 70) && ('G' == 71) \\\n    && ('H' == 72) && ('I' == 73) && ('J' == 74) && ('K' == 75) \\\n    && ('L' == 76) && ('M' == 77) && ('N' == 78) && ('O' == 79) \\\n    && ('P' == 80) && ('Q' == 81) && ('R' == 82) && ('S' == 83) \\\n    && ('T' == 84) && ('U' == 85) && ('V' == 86) && ('W' == 87) \\\n    && ('X' == 88) && ('Y' == 89) && ('Z' == 90) && ('[' == 91) \\\n    && ('\\\\' == 92) && (']' == 93) && ('^' == 94) && ('_' == 95) \\\n    && ('`' == 96) && ('a' == 97) && ('b' == 98) && ('c' == 99) \\\n    && ('d' == 100) && ('e' == 101) && ('f' == 102) && ('g' == 103) \\\n    && ('h' == 104) && ('i' == 105) && ('j' == 106) && ('k' == 107) \\\n    && ('l' == 108) && ('m' == 109) && ('n' == 110) && ('o' == 111) \\\n    && ('p' == 112) && ('q' == 113) && ('r' == 114) && ('s' == 115) \\\n    && ('t' == 116) && ('u' == 117) && ('v' == 118) && ('w' == 119) \\\n    && ('x' == 120) && ('y' == 121) && ('z' == 122) && ('{' == 123) \\\n    && ('|' == 124) && ('}' == 125) && ('~' == 126)\n \n# define IS_BASIC_ASCII 1\n\n \n# define is_basic(c) ((unsigned char) (c) < 0x80)\n\n#else\n\nMBCHAR_INLINE bool\nis_basic (char c)\n{\n  switch (c)\n    {\n    case '\\0':\n    case '\\007': case '\\010':\n    case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>':\n    case '?': case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E':\n    case 'F': case 'G': case 'H': case 'I': case 'J':\n    case 'K': case 'L': case 'M': case 'N': case 'O':\n    case 'P': case 'Q': case 'R': case 'S': case 'T':\n    case 'U': case 'V': case 'W': case 'X': case 'Y':\n    case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'i': case 'j':\n    case 'k': case 'l': case 'm': case 'n': case 'o':\n    case 'p': case 'q': case 'r': case 's': case 't':\n    case 'u': case 'v': case 'w': case 'x': case 'y':\n    case 'z': case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n}\n\n#endif\n\n_GL_INLINE_HEADER_END\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}