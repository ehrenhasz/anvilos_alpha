{
  "module_name": "md5.c",
  "hash_id": "c58174d3f91551047cb4992681c254dfdf2a69fb2deeac536a1079024377d649",
  "original_prompt": "Ingested from coreutils-9.4/lib/md5.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#if HAVE_OPENSSL_MD5\n# define GL_OPENSSL_INLINE _GL_EXTERN_INLINE\n#endif\n#include \"md5.h\"\n\n#include <stdint.h>\n#include <string.h>\n#include <sys/types.h>\n\n#ifdef _LIBC\n# include <endian.h>\n# if __BYTE_ORDER == __BIG_ENDIAN\n#  define WORDS_BIGENDIAN 1\n# endif\n \n# define md5_init_ctx __md5_init_ctx\n# define md5_process_block __md5_process_block\n# define md5_process_bytes __md5_process_bytes\n# define md5_finish_ctx __md5_finish_ctx\n# define md5_read_ctx __md5_read_ctx\n# define md5_buffer __md5_buffer\n#endif\n\n#include <byteswap.h>\n#ifdef WORDS_BIGENDIAN\n# define SWAP(n) bswap_32 (n)\n#else\n# define SWAP(n) (n)\n#endif\n\n#if ! HAVE_OPENSSL_MD5\n\n \nstatic const unsigned char fillbuf[64] = { 0x80, 0   };\n\n\n \nvoid\nmd5_init_ctx (struct md5_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}\n\n \nstatic void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}\n\n \nvoid *\nmd5_read_ctx (const struct md5_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n\n  return resbuf;\n}\n\n \nvoid *\nmd5_finish_ctx (struct md5_ctx *ctx, void *resbuf)\n{\n   \n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n   \n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n   \n  ctx->buffer[size - 2] = SWAP (ctx->total[0] << 3);\n  ctx->buffer[size - 1] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n   \n  md5_process_block (ctx->buffer, size * 4, ctx);\n\n  return md5_read_ctx (ctx, resbuf);\n}\n\n \nvoid *\nmd5_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct md5_ctx ctx;\n\n   \n  md5_init_ctx (&ctx);\n\n   \n  md5_process_bytes (buffer, len, &ctx);\n\n   \n  return md5_finish_ctx (&ctx, resblock);\n}\n\n\nvoid\nmd5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n   \n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          md5_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n           \n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n   \n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            md5_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          md5_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n   \n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          md5_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n           \n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}\n\n\n \n \n#define FF(b, c, d) (d ^ (b & (c ^ d)))\n#define FG(b, c, d) FF (d, b, c)\n#define FH(b, c, d) (b ^ c ^ d)\n#define FI(b, c, d) (c ^ (b | ~d))\n\n \n\nvoid\nmd5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)\n{\n  uint32_t correct_words[16];\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t A = ctx->A;\n  uint32_t B = ctx->B;\n  uint32_t C = ctx->C;\n  uint32_t D = ctx->D;\n  uint32_t lolen = len;\n\n   \n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n   \n  while (words < endp)\n    {\n      uint32_t *cwp = correct_words;\n      uint32_t A_save = A;\n      uint32_t B_save = B;\n      uint32_t C_save = C;\n      uint32_t D_save = D;\n\n       \n\n#define OP(a, b, c, d, s, T)                                            \\\n      do                                                                \\\n        {                                                               \\\n          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \\\n          ++words;                                                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n       \n#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))\n\n       \n\n       \n      OP (A, B, C, D, 7, 0xd76aa478);\n      OP (D, A, B, C, 12, 0xe8c7b756);\n      OP (C, D, A, B, 17, 0x242070db);\n      OP (B, C, D, A, 22, 0xc1bdceee);\n      OP (A, B, C, D, 7, 0xf57c0faf);\n      OP (D, A, B, C, 12, 0x4787c62a);\n      OP (C, D, A, B, 17, 0xa8304613);\n      OP (B, C, D, A, 22, 0xfd469501);\n      OP (A, B, C, D, 7, 0x698098d8);\n      OP (D, A, B, C, 12, 0x8b44f7af);\n      OP (C, D, A, B, 17, 0xffff5bb1);\n      OP (B, C, D, A, 22, 0x895cd7be);\n      OP (A, B, C, D, 7, 0x6b901122);\n      OP (D, A, B, C, 12, 0xfd987193);\n      OP (C, D, A, B, 17, 0xa679438e);\n      OP (B, C, D, A, 22, 0x49b40821);\n\n       \n#undef OP\n#define OP(f, a, b, c, d, k, s, T)                                      \\\n      do                                                                \\\n        {                                                               \\\n          a += f (b, c, d) + correct_words[k] + T;                      \\\n          CYCLIC (a, s);                                                \\\n          a += b;                                                       \\\n        }                                                               \\\n      while (0)\n\n       \n      OP (FG, A, B, C, D, 1, 5, 0xf61e2562);\n      OP (FG, D, A, B, C, 6, 9, 0xc040b340);\n      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);\n      OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);\n      OP (FG, A, B, C, D, 5, 5, 0xd62f105d);\n      OP (FG, D, A, B, C, 10, 9, 0x02441453);\n      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);\n      OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);\n      OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);\n      OP (FG, D, A, B, C, 14, 9, 0xc33707d6);\n      OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);\n      OP (FG, B, C, D, A, 8, 20, 0x455a14ed);\n      OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);\n      OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);\n      OP (FG, C, D, A, B, 7, 14, 0x676f02d9);\n      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);\n\n       \n      OP (FH, A, B, C, D, 5, 4, 0xfffa3942);\n      OP (FH, D, A, B, C, 8, 11, 0x8771f681);\n      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);\n      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);\n      OP (FH, A, B, C, D, 1, 4, 0xa4beea44);\n      OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);\n      OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);\n      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);\n      OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);\n      OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);\n      OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);\n      OP (FH, B, C, D, A, 6, 23, 0x04881d05);\n      OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);\n      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);\n      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);\n      OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);\n\n       \n      OP (FI, A, B, C, D, 0, 6, 0xf4292244);\n      OP (FI, D, A, B, C, 7, 10, 0x432aff97);\n      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);\n      OP (FI, B, C, D, A, 5, 21, 0xfc93a039);\n      OP (FI, A, B, C, D, 12, 6, 0x655b59c3);\n      OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);\n      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);\n      OP (FI, B, C, D, A, 1, 21, 0x85845dd1);\n      OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);\n      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);\n      OP (FI, C, D, A, B, 6, 15, 0xa3014314);\n      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);\n      OP (FI, A, B, C, D, 4, 6, 0xf7537e82);\n      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);\n      OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);\n      OP (FI, B, C, D, A, 9, 21, 0xeb86d391);\n\n       \n      A += A_save;\n      B += B_save;\n      C += C_save;\n      D += D_save;\n    }\n\n   \n  ctx->A = A;\n  ctx->B = B;\n  ctx->C = C;\n  ctx->D = D;\n}\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}