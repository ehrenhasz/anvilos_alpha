{
  "module_name": "renameatu.c",
  "hash_id": "7735cfac21c9fe615ace7f48b7d62809d6efc3746f5f6dc3696a487dfecee0a8",
  "original_prompt": "Ingested from coreutils-9.4/lib/renameatu.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"renameatu.h\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#ifdef __linux__\n# include <sys/syscall.h>\n#endif\n\nstatic int\nerrno_fail (int e)\n{\n  errno = e;\n  return -1;\n}\n\n#if HAVE_RENAMEAT\n\n# include <stdlib.h>\n# include <string.h>\n\n# include \"dirname.h\"\n# include \"openat.h\"\n\n#else\n# include \"openat-priv.h\"\n\nstatic int\nrename_noreplace (char const *src, char const *dst)\n{\n   \n  struct stat st;\n  return (lstat (dst, &st) == 0 || errno == EOVERFLOW ? errno_fail (EEXIST)\n          : errno == ENOENT ? rename (src, dst)\n          : -1);\n}\n#endif\n\n#undef renameat\n\n#if HAVE_RENAMEAT\n\n \nstatic int\nrenameat2ish (int fd1, char const *src, int fd2, char const *dst,\n              unsigned int flags)\n{\n# ifdef RENAME_EXCL\n  if (flags)\n    {\n      int r = renameatx_np (fd1, src, fd2, dst, RENAME_EXCL);\n      if (r == 0 || errno != ENOTSUP)\n        return r;\n    }\n# endif\n\n  return renameat (fd1, src, fd2, dst);\n}\n#endif\n\n \n\nint\nrenameatu (int fd1, char const *src, int fd2, char const *dst,\n           unsigned int flags)\n{\n  int ret_val = -1;\n  int err = EINVAL;\n\n#ifdef HAVE_RENAMEAT2\n  ret_val = renameat2 (fd1, src, fd2, dst, flags);\n  err = errno;\n#elif defined SYS_renameat2\n  ret_val = syscall (SYS_renameat2, fd1, src, fd2, dst, flags);\n  err = errno;\n#endif\n\n  if (! (ret_val < 0 && (err == EINVAL || err == ENOSYS || err == ENOTSUP)))\n    return ret_val;\n\n#if HAVE_RENAMEAT\n  {\n  size_t src_len;\n  size_t dst_len;\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n  bool dst_found_nonexistent = false;\n\n  switch (flags)\n    {\n    case 0:\n      break;\n\n    case RENAME_NOREPLACE:\n       \n      if (fstatat (fd2, dst, &dst_st, AT_SYMLINK_NOFOLLOW) == 0\n          || errno == EOVERFLOW)\n        return errno_fail (EEXIST);\n      if (errno != ENOENT)\n        return -1;\n      dst_found_nonexistent = true;\n      break;\n\n    default:\n      return errno_fail (ENOTSUP);\n    }\n\n   \n  src_len = strlen (src);\n  dst_len = strlen (dst);\n  if (!src_len || !dst_len)\n    return renameat2ish (fd1, src, fd2, dst, flags);\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n  if (!src_slash && !dst_slash)\n    return renameat2ish (fd1, src, fd2, dst, flags);\n\n   \n  if (fstatat (fd1, src, &src_st, AT_SYMLINK_NOFOLLOW))\n    return -1;\n  if (dst_found_nonexistent)\n    {\n      if (!S_ISDIR (src_st.st_mode))\n        return errno_fail (ENOENT);\n    }\n  else if (fstatat (fd2, dst, &dst_st, AT_SYMLINK_NOFOLLOW))\n    {\n      if (errno != ENOENT || !S_ISDIR (src_st.st_mode))\n        return -1;\n    }\n  else if (!S_ISDIR (dst_st.st_mode))\n    return errno_fail (ENOTDIR);\n  else if (!S_ISDIR (src_st.st_mode))\n    return errno_fail (EISDIR);\n\n# if RENAME_TRAILING_SLASH_SOURCE_BUG\n   \n  ret_val = -1;\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n           \n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (fstatat (fd1, src_temp, &src_st, AT_SYMLINK_NOFOLLOW))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      char readlink_buf[1];\n      if (readlinkat (fd2, dst_temp, readlink_buf, sizeof readlink_buf) < 0)\n        {\n          if (errno != ENOENT && errno != EINVAL)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else\n        goto out;\n    }\n# endif  \n\n   \n\n  ret_val = renameat2ish (fd1, src_temp, fd2, dst_temp, flags);\n  rename_errno = errno;\n  goto out;\n out:\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n  }\n#else  \n\n   \n  if (flags & ~RENAME_NOREPLACE)\n    return errno_fail (ENOTSUP);\n  return at_func2 (fd1, src, fd2, dst, flags ? rename_noreplace : rename);\n\n#endif  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}