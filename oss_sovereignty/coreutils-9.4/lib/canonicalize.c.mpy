{
  "module_name": "canonicalize.c",
  "hash_id": "1cf8d0d352c88170d1513a0130537f22b16116faa853382d6f2eb880a9413a3a",
  "original_prompt": "Ingested from coreutils-9.4/lib/canonicalize.c",
  "human_readable_source": " \n#if __GNUC__ + (__GNUC_MINOR__ >= 7) > 4\n# pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n\n \nstatic bool\nfile_accessible (char const *file)\n{\n# if HAVE_FACCESSAT\n  return faccessat (AT_FDCWD, file, F_OK, AT_EACCESS) == 0;\n# else\n  struct stat st;\n  return stat (file, &st) == 0 || errno == EOVERFLOW;\n# endif\n}\n\n \n\nstatic bool _GL_ATTRIBUTE_PURE\nsuffix_requires_dir_check (char const *end)\n{\n   \n  while (ISSLASH (*end))\n    {\n       \n      do\n        end++;\n      while (ISSLASH (*end));\n\n      switch (*end++)\n        {\n        default: return false;   \n        case '\\0': return true;  \n        case '.': break;         \n        }\n       \n      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))\n        return true;\n    }\n\n  return false;\n}\n\n \n\n#ifdef LSTAT_FOLLOWS_SLASHED_SYMLINK\nstatic char const dir_suffix[] = \"/\";\n#else\nstatic char const dir_suffix[] = \"/./\";\n#endif\n\n \n\nstatic bool\ndir_check (char *dir, char *dirend)\n{\n  strcpy (dirend, dir_suffix);\n  return file_accessible (dir);\n}\n\n#if !((HAVE_CANONICALIZE_FILE_NAME && FUNC_REALPATH_WORKS)      \\\n      || GNULIB_CANONICALIZE_LGPL)\n \n\nchar *\ncanonicalize_file_name (const char *name)\n{\n  return canonicalize_filename_mode (name, CAN_EXISTING);\n}\n#endif  \n\nstatic bool\nmultiple_bits_set (canonicalize_mode_t i)\n{\n  return (i & (i - 1)) != 0;\n}\n\n \nstatic bool\nseen_triple (Hash_table **ht, char const *filename, struct stat const *st)\n{\n  if (*ht == NULL)\n    {\n      idx_t initial_capacity = 7;\n      *ht = hash_initialize (initial_capacity,\n                            NULL,\n                            triple_hash,\n                            triple_compare_ino_str,\n                            triple_free);\n      if (*ht == NULL)\n        xalloc_die ();\n    }\n\n  if (seen_file (*ht, filename, st))\n    return true;\n\n  record_file (*ht, filename, st);\n  return false;\n}\n\n \nstruct realpath_bufs\n{\n  struct scratch_buffer rname;\n  struct scratch_buffer extra;\n  struct scratch_buffer link;\n};\n\nstatic char *\ncanonicalize_filename_mode_stk (const char *name, canonicalize_mode_t can_mode,\n                                struct realpath_bufs *bufs)\n{\n  char *dest;\n  char const *start;\n  char const *end;\n  Hash_table *ht = NULL;\n  bool logical = (can_mode & CAN_NOLINKS) != 0;\n  int num_links = 0;\n\n  canonicalize_mode_t can_exist = can_mode & CAN_MODE_MASK;\n  if (multiple_bits_set (can_exist))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  if (name == NULL)\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  char *rname = bufs->rname.data;\n  bool end_in_extra_buffer = false;\n  bool failed = true;\n\n   \n  idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      while (!getcwd (bufs->rname.data, bufs->rname.length))\n        {\n          switch (errno)\n            {\n            case ERANGE:\n              if (scratch_buffer_grow (&bufs->rname))\n                break;\n              FALLTHROUGH;\n            case ENOMEM:\n              xalloc_die ();\n\n            default:\n              dest = rname;\n              goto error;\n            }\n          rname = bufs->rname.data;\n        }\n      dest = rawmemchr (rname, '\\0');\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rname);\n    }\n  else\n    {\n      dest = mempcpy (rname, name, prefix_len);\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (prefix_len == 0  \n              && ISSLASH (name[1]) && !ISSLASH (name[2]))\n            {\n              *dest++ = '/';\n#if defined _WIN32 && !defined __CYGWIN__\n               \n              {\n                idx_t i;\n                for (i = 2; name[i] != '\\0' && !ISSLASH (name[i]); )\n                  i++;\n                if (name[i] != '\\0'  \n                    && i + 1 < bufs->rname.length)\n                  {\n                    prefix_len = i;\n                    memcpy (dest, name + 2, i - 2 + 1);\n                    dest += i - 2 + 1;\n                  }\n                else\n                  {\n                     \n                  }\n              }\n#endif\n            }\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for ( ; *start; start = end)\n    {\n       \n      while (ISSLASH (*start))\n        ++start;\n\n       \n      for (end = start; *end && !ISSLASH (*end); ++end)\n         ;\n\n       \n      idx_t startlen = end - start;\n\n      if (startlen == 0)\n        break;\n      else if (startlen == 1 && start[0] == '.')\n         ;\n      else if (startlen == 2 && start[0] == '.' && start[1] == '.')\n        {\n           \n          if (dest > rname + prefix_len + 1)\n            for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n              && dest == rname + 1 && !prefix_len\n              && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          while (rname + bufs->rname.length - dest\n                 < startlen + sizeof dir_suffix)\n            {\n              idx_t dest_offset = dest - rname;\n              if (!scratch_buffer_grow_preserve (&bufs->rname))\n                xalloc_die ();\n              rname = bufs->rname.data;\n              dest = rname + dest_offset;\n            }\n\n          dest = mempcpy (dest, start, startlen);\n          *dest = '\\0';\n\n          char *buf;\n          ssize_t n = -1;\n          if (!logical)\n            {\n              while (true)\n                {\n                  buf = bufs->link.data;\n                  idx_t bufsize = bufs->link.length;\n                  n = readlink (rname, buf, bufsize - 1);\n                  if (n < bufsize - 1)\n                    break;\n                  if (!scratch_buffer_grow (&bufs->link))\n                    xalloc_die ();\n                }\n            }\n          if (0 <= n)\n            {\n               \n\n              if (num_links < 20)\n                num_links++;\n              else if (*start)\n                {\n                   \n                  struct stat st;\n                  dest[- startlen] = '\\0';\n                  if (stat (*rname ? rname : \".\", &st) != 0)\n                    goto error;\n                  dest[- startlen] = *start;\n\n                   \n                  if (seen_triple (&ht, start, &st))\n                    {\n                      if (can_exist == CAN_MISSING)\n                        continue;\n                      errno = ELOOP;\n                      goto error;\n                    }\n                }\n\n              buf[n] = '\\0';\n\n              char *extra_buf = bufs->extra.data;\n              idx_t end_idx;\n              if (end_in_extra_buffer)\n                end_idx = end - extra_buf;\n              size_t len = strlen (end);\n              if (INT_ADD_OVERFLOW (len, n))\n                xalloc_die ();\n              while (bufs->extra.length <= len + n)\n                {\n                  if (!scratch_buffer_grow_preserve (&bufs->extra))\n                    xalloc_die ();\n                  extra_buf = bufs->extra.data;\n                }\n              if (end_in_extra_buffer)\n                end = extra_buf + end_idx;\n\n               \n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n              end_in_extra_buffer = true;\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  idx_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  dest = mempcpy (rname, buf, pfxlen);\n                  *dest++ = '/';  \n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                   \n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                   \n                  if (dest > rname + prefix_len + 1)\n                    for (--dest; dest > rname && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n            }\n          else if (! (can_exist == CAN_MISSING\n                      || (suffix_requires_dir_check (end)\n                          ? dir_check (rname, dest)\n                          : !logical\n                          ? errno == EINVAL\n                          : *end || file_accessible (rname))\n                      || (can_exist == CAN_ALL_BUT_LAST\n                          && errno == ENOENT\n                          && !end[strspn (end, SLASHES)])))\n            goto error;\n        }\n    }\n  if (dest > rname + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rname + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  failed = false;\n\nerror:\n  if (ht)\n    hash_free (ht);\n\n  if (failed)\n    return NULL;\n\n  *dest++ = '\\0';\n  char *result = malloc (dest - rname);\n  if (!result)\n    xalloc_die ();\n  return memcpy (result, rname, dest - rname);\n}\n\n \n\nchar *\ncanonicalize_filename_mode (const char *name, canonicalize_mode_t can_mode)\n{\n  struct realpath_bufs bufs;\n  scratch_buffer_init (&bufs.rname);\n  scratch_buffer_init (&bufs.extra);\n  scratch_buffer_init (&bufs.link);\n  char *result = canonicalize_filename_mode_stk (name, can_mode, &bufs);\n  scratch_buffer_free (&bufs.link);\n  scratch_buffer_free (&bufs.extra);\n  scratch_buffer_free (&bufs.rname);\n  return result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}