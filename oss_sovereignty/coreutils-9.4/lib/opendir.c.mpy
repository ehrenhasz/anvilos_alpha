{
  "module_name": "opendir.c",
  "hash_id": "d6ec678e05e8c3fec936ea4cf245887322579055a4dcf1101f61f0c479ad136a",
  "original_prompt": "Ingested from coreutils-9.4/lib/opendir.c",
  "human_readable_source": " \n#include <dirent.h>\n\n#include <errno.h>\n#include <stddef.h>\n\n#if HAVE_OPENDIR\n\n \n\n#else\n\n# include \"filename.h\"\n\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#if GNULIB_defined_DIR\n# include \"dirent-private.h\"\n#endif\n\n#if REPLACE_FCHDIR\n# include <unistd.h>\n#endif\n\n#ifdef __KLIBC__\n# include <io.h>\n# include <fcntl.h>\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n# undef WIN32_FIND_DATA\n# define WIN32_FIND_DATA WIN32_FIND_DATAA\n# undef GetFullPathName\n# define GetFullPathName GetFullPathNameA\n# undef FindFirstFile\n# define FindFirstFile FindFirstFileA\n#endif\n\nDIR *\nopendir (const char *dir_name)\n#undef opendir\n{\n#if HAVE_DIRENT_H                        \n  DIR *dirp;\n\n# if GNULIB_defined_DIR\n#  undef DIR\n\n  dirp = (struct gl_directory *) malloc (sizeof (struct gl_directory));\n  if (dirp == NULL)\n    {\n      errno = ENOMEM;\n      return NULL;\n    }\n\n  DIR *real_dirp = opendir (dir_name);\n  if (real_dirp == NULL)\n    {\n      int saved_errno = errno;\n      free (dirp);\n      errno = saved_errno;\n      return NULL;\n    }\n\n  dirp->fd_to_close = -1;\n  dirp->real_dirp = real_dirp;\n# else\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n# endif\n\n# ifdef __KLIBC__\n  {\n    int fd = open (dir_name, O_RDONLY);\n    if (fd == -1 || _gl_register_dirp_fd (fd, dirp))\n      {\n        int saved_errno = errno;\n\n        close (fd);\n        closedir (dirp);\n\n        errno = saved_errno;\n\n        return NULL;\n      }\n  }\n# endif\n\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n   \n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n   \n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n   \n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n   \n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->fd_to_close = -1;\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}