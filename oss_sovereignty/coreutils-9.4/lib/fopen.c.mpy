{
  "module_name": "fopen.c",
  "hash_id": "957b13b448882f9e64e4fbf9f0f998e96a17f53c96ab83937547076473b71ded",
  "original_prompt": "Ingested from coreutils-9.4/lib/fopen.c",
  "human_readable_source": " \n\n \n#define _GL_ALREADY_INCLUDING_STDIO_H\n#include <config.h>\n\n \n#include <stdio.h>\n#undef _GL_ALREADY_INCLUDING_STDIO_H\n\nstatic FILE *\norig_fopen (const char *filename, const char *mode)\n{\n  return fopen (filename, mode);\n}\n\n \n \n#include \"stdio.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\nFILE *\nrpl_fopen (const char *filename, const char *mode)\n{\n  int open_direction;\n  int open_flags;\n#if GNULIB_FOPEN_GNU\n  bool open_flags_gnu;\n# define BUF_SIZE 80\n  char fdopen_mode_buf[BUF_SIZE + 1];\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n   \n  open_direction = 0;\n  open_flags = 0;\n#if GNULIB_FOPEN_GNU\n  open_flags_gnu = false;\n#endif\n  {\n    const char *p = mode;\n#if GNULIB_FOPEN_GNU\n    char *q = fdopen_mode_buf;\n#endif\n\n    for (; *p != '\\0'; p++)\n      {\n        switch (*p)\n          {\n          case 'r':\n            open_direction = O_RDONLY;\n#if GNULIB_FOPEN_GNU\n            if (q < fdopen_mode_buf + BUF_SIZE)\n              *q++ = *p;\n#endif\n            continue;\n          case 'w':\n            open_direction = O_WRONLY;\n            open_flags |= O_CREAT | O_TRUNC;\n#if GNULIB_FOPEN_GNU\n            if (q < fdopen_mode_buf + BUF_SIZE)\n              *q++ = *p;\n#endif\n            continue;\n          case 'a':\n            open_direction = O_WRONLY;\n            open_flags |= O_CREAT | O_APPEND;\n#if GNULIB_FOPEN_GNU\n            if (q < fdopen_mode_buf + BUF_SIZE)\n              *q++ = *p;\n#endif\n            continue;\n          case 'b':\n             \n            open_flags |= O_BINARY;\n#if GNULIB_FOPEN_GNU\n            if (q < fdopen_mode_buf + BUF_SIZE)\n              *q++ = *p;\n#endif\n            continue;\n          case '+':\n            open_direction = O_RDWR;\n#if GNULIB_FOPEN_GNU\n            if (q < fdopen_mode_buf + BUF_SIZE)\n              *q++ = *p;\n#endif\n            continue;\n#if GNULIB_FOPEN_GNU\n          case 'x':\n            open_flags |= O_EXCL;\n            open_flags_gnu = true;\n            continue;\n          case 'e':\n            open_flags |= O_CLOEXEC;\n            open_flags_gnu = true;\n            continue;\n#endif\n          default:\n            break;\n          }\n#if GNULIB_FOPEN_GNU\n         \n        {\n          size_t len = strlen (p);\n          if (len > fdopen_mode_buf + BUF_SIZE - q)\n            len = fdopen_mode_buf + BUF_SIZE - q;\n          memcpy (q, p, len);\n          q += len;\n        }\n#endif\n        break;\n      }\n#if GNULIB_FOPEN_GNU\n    *q = '\\0';\n#endif\n  }\n\n#if FOPEN_TRAILING_SLASH_BUG\n   \n  {\n    size_t len = strlen (filename);\n    if (len > 0 && filename[len - 1] == '/')\n      {\n        int fd;\n        struct stat statbuf;\n        FILE *fp;\n\n        if (open_direction != O_RDONLY)\n          {\n            errno = EISDIR;\n            return NULL;\n          }\n\n        fd = open (filename, open_direction | open_flags,\n                   S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n        if (fd < 0)\n          return NULL;\n\n        if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n          {\n            close (fd);\n            errno = ENOTDIR;\n            return NULL;\n          }\n\n# if GNULIB_FOPEN_GNU\n        fp = fdopen (fd, fdopen_mode_buf);\n# else\n        fp = fdopen (fd, mode);\n# endif\n        if (fp == NULL)\n          {\n            int saved_errno = errno;\n            close (fd);\n            errno = saved_errno;\n          }\n        return fp;\n      }\n  }\n#endif\n\n#if GNULIB_FOPEN_GNU\n  if (open_flags_gnu)\n    {\n      int fd;\n      FILE *fp;\n\n      fd = open (filename, open_direction | open_flags,\n                 S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n      if (fd < 0)\n        return NULL;\n\n      fp = fdopen (fd, fdopen_mode_buf);\n      if (fp == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n        }\n      return fp;\n    }\n#endif\n\n   \n  (void) open_direction;\n\n  return orig_fopen (filename, mode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}