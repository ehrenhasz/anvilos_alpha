{
  "module_name": "base32.c",
  "hash_id": "00173e60fb50179c4f72534d3fbf4f840f8506f866f20b5992b29d0da86bf969",
  "original_prompt": "Ingested from coreutils-9.4/lib/base32.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"base32.h\"\n\n \n#include <ialloc.h>\n\n#include <intprops.h>\n\n \n#include <limits.h>\n\n#include <string.h>\n\n \nstatic unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}\n\n \nvoid\nbase32_encode (const char *restrict in, idx_t inlen,\n               char *restrict out, idx_t outlen)\n{\n  static const char b32str[32] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n\n  while (inlen && outlen)\n    {\n      *out++ = b32str[(to_uchar (in[0]) >> 3) & 0x1f];\n      if (!--outlen)\n        break;\n      *out++ = b32str[((to_uchar (in[0]) << 2)\n                       + (--inlen ? to_uchar (in[1]) >> 6 : 0))\n                      & 0x1f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b32str[(to_uchar (in[1]) >> 1) & 0x1f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b32str[((to_uchar (in[1]) << 4)\n                   + (--inlen ? to_uchar (in[2]) >> 4 : 0))\n                  & 0x1f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b32str[((to_uchar (in[2]) << 1)\n                   + (--inlen ? to_uchar (in[3]) >> 7 : 0))\n                  & 0x1f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b32str[(to_uchar (in[3]) >> 2) & 0x1f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b32str[((to_uchar (in[3]) << 3)\n                   + (--inlen ? to_uchar (in[4]) >> 5 : 0))\n                  & 0x1f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b32str[to_uchar (in[4]) & 0x1f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 5;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}\n\n \nidx_t\nbase32_encode_alloc (const char *in, idx_t inlen, char **out)\n{\n   \n  idx_t in_over_5 = inlen / 5 + (inlen % 5 != 0), outlen;\n  if (! INT_MULTIPLY_OK (in_over_5, 8, &outlen) || inlen < 0)\n    {\n      *out = NULL;\n      return 0;\n    }\n  outlen++;\n\n  *out = imalloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base32_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}\n\n \n#define B32(_)                                  \\\n  ((_) == 'A' ? 0                               \\\n   : (_) == 'B' ? 1                             \\\n   : (_) == 'C' ? 2                             \\\n   : (_) == 'D' ? 3                             \\\n   : (_) == 'E' ? 4                             \\\n   : (_) == 'F' ? 5                             \\\n   : (_) == 'G' ? 6                             \\\n   : (_) == 'H' ? 7                             \\\n   : (_) == 'I' ? 8                             \\\n   : (_) == 'J' ? 9                             \\\n   : (_) == 'K' ? 10                            \\\n   : (_) == 'L' ? 11                            \\\n   : (_) == 'M' ? 12                            \\\n   : (_) == 'N' ? 13                            \\\n   : (_) == 'O' ? 14                            \\\n   : (_) == 'P' ? 15                            \\\n   : (_) == 'Q' ? 16                            \\\n   : (_) == 'R' ? 17                            \\\n   : (_) == 'S' ? 18                            \\\n   : (_) == 'T' ? 19                            \\\n   : (_) == 'U' ? 20                            \\\n   : (_) == 'V' ? 21                            \\\n   : (_) == 'W' ? 22                            \\\n   : (_) == 'X' ? 23                            \\\n   : (_) == 'Y' ? 24                            \\\n   : (_) == 'Z' ? 25                            \\\n   : (_) == '2' ? 26                            \\\n   : (_) == '3' ? 27                            \\\n   : (_) == '4' ? 28                            \\\n   : (_) == '5' ? 29                            \\\n   : (_) == '6' ? 30                            \\\n   : (_) == '7' ? 31                            \\\n   : -1)\n\nstatic const signed char b32[0x100] = {\n  B32 (0), B32 (1), B32 (2), B32 (3),\n  B32 (4), B32 (5), B32 (6), B32 (7),\n  B32 (8), B32 (9), B32 (10), B32 (11),\n  B32 (12), B32 (13), B32 (14), B32 (15),\n  B32 (16), B32 (17), B32 (18), B32 (19),\n  B32 (20), B32 (21), B32 (22), B32 (23),\n  B32 (24), B32 (25), B32 (26), B32 (27),\n  B32 (28), B32 (29), B32 (30), B32 (31),\n  B32 (32), B32 (33), B32 (34), B32 (35),\n  B32 (36), B32 (37), B32 (38), B32 (39),\n  B32 (40), B32 (41), B32 (42), B32 (43),\n  B32 (44), B32 (45), B32 (46), B32 (47),\n  B32 (48), B32 (49), B32 (50), B32 (51),\n  B32 (52), B32 (53), B32 (54), B32 (55),\n  B32 (56), B32 (57), B32 (58), B32 (59),\n  B32 (60), B32 (61), B32 (62), B32 (63),\n  B32 (32), B32 (65), B32 (66), B32 (67),\n  B32 (68), B32 (69), B32 (70), B32 (71),\n  B32 (72), B32 (73), B32 (74), B32 (75),\n  B32 (76), B32 (77), B32 (78), B32 (79),\n  B32 (80), B32 (81), B32 (82), B32 (83),\n  B32 (84), B32 (85), B32 (86), B32 (87),\n  B32 (88), B32 (89), B32 (90), B32 (91),\n  B32 (92), B32 (93), B32 (94), B32 (95),\n  B32 (96), B32 (97), B32 (98), B32 (99),\n  B32 (100), B32 (101), B32 (102), B32 (103),\n  B32 (104), B32 (105), B32 (106), B32 (107),\n  B32 (108), B32 (109), B32 (110), B32 (111),\n  B32 (112), B32 (113), B32 (114), B32 (115),\n  B32 (116), B32 (117), B32 (118), B32 (119),\n  B32 (120), B32 (121), B32 (122), B32 (123),\n  B32 (124), B32 (125), B32 (126), B32 (127),\n  B32 (128), B32 (129), B32 (130), B32 (131),\n  B32 (132), B32 (133), B32 (134), B32 (135),\n  B32 (136), B32 (137), B32 (138), B32 (139),\n  B32 (140), B32 (141), B32 (142), B32 (143),\n  B32 (144), B32 (145), B32 (146), B32 (147),\n  B32 (148), B32 (149), B32 (150), B32 (151),\n  B32 (152), B32 (153), B32 (154), B32 (155),\n  B32 (156), B32 (157), B32 (158), B32 (159),\n  B32 (160), B32 (161), B32 (162), B32 (163),\n  B32 (132), B32 (165), B32 (166), B32 (167),\n  B32 (168), B32 (169), B32 (170), B32 (171),\n  B32 (172), B32 (173), B32 (174), B32 (175),\n  B32 (176), B32 (177), B32 (178), B32 (179),\n  B32 (180), B32 (181), B32 (182), B32 (183),\n  B32 (184), B32 (185), B32 (186), B32 (187),\n  B32 (188), B32 (189), B32 (190), B32 (191),\n  B32 (192), B32 (193), B32 (194), B32 (195),\n  B32 (196), B32 (197), B32 (198), B32 (199),\n  B32 (200), B32 (201), B32 (202), B32 (203),\n  B32 (204), B32 (205), B32 (206), B32 (207),\n  B32 (208), B32 (209), B32 (210), B32 (211),\n  B32 (212), B32 (213), B32 (214), B32 (215),\n  B32 (216), B32 (217), B32 (218), B32 (219),\n  B32 (220), B32 (221), B32 (222), B32 (223),\n  B32 (224), B32 (225), B32 (226), B32 (227),\n  B32 (228), B32 (229), B32 (230), B32 (231),\n  B32 (232), B32 (233), B32 (234), B32 (235),\n  B32 (236), B32 (237), B32 (238), B32 (239),\n  B32 (240), B32 (241), B32 (242), B32 (243),\n  B32 (244), B32 (245), B32 (246), B32 (247),\n  B32 (248), B32 (249), B32 (250), B32 (251),\n  B32 (252), B32 (253), B32 (254), B32 (255)\n};\n\n#if UCHAR_MAX == 255\n# define uchar_in_range(c) true\n#else\n# define uchar_in_range(c) ((c) <= 255)\n#endif\n\n \nbool\nisbase32 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b32[to_uchar (ch)];\n}\n\n \nvoid\nbase32_decode_ctx_init (struct base32_decode_context *ctx)\n{\n  ctx->i = 0;\n}\n\n \nstatic char *\nget_8 (struct base32_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       idx_t *n_non_newline)\n{\n  if (ctx->i == 8)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (8 <= in_end - *in && memchr (t, '\\n', 8) == NULL)\n        {\n           \n          *in += 8;\n          *n_non_newline = 8;\n          return (char *) t;\n        }\n    }\n\n  {\n     \n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 8)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}\n\n#define return_false                            \\\n  do                                            \\\n    {                                           \\\n      *outp = out;                              \\\n      return false;                             \\\n    }                                           \\\n  while (false)\n\n \nstatic bool\ndecode_8 (char const *restrict in, idx_t inlen,\n          char *restrict *outp, idx_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 8)\n    return false;\n\n  if (!isbase32 (in[0]) || !isbase32 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b32[to_uchar (in[0])] << 3)\n                | (b32[to_uchar (in[1])] >> 2));\n      --*outleft;\n    }\n\n  if (in[2] == '=')\n    {\n      if (in[3] != '=' || in[4] != '=' || in[5] != '='\n          || in[6] != '=' || in[7] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase32 (in[2]) || !isbase32 (in[3]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = ((b32[to_uchar (in[1])] << 6)\n                    | (b32[to_uchar (in[2])] << 1)\n                    | (b32[to_uchar (in[3])] >> 4));\n          --*outleft;\n        }\n\n      if (in[4] == '=')\n        {\n          if (in[5] != '=' || in[6] != '=' || in[7] != '=')\n            return_false;\n        }\n      else\n        {\n          if (!isbase32 (in[4]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = ((b32[to_uchar (in[3])] << 4)\n                        | (b32[to_uchar (in[4])] >> 1));\n              --*outleft;\n            }\n\n          if (in[5] == '=')\n            {\n              if (in[6] != '=' || in[7] != '=')\n                return_false;\n            }\n          else\n            {\n              if (!isbase32 (in[5]) || !isbase32 (in[6]))\n                return_false;\n\n              if (*outleft)\n                {\n                  *out++ = ((b32[to_uchar (in[4])] << 7)\n                            | (b32[to_uchar (in[5])] << 2)\n                            | (b32[to_uchar (in[6])] >> 3));\n                  --*outleft;\n                }\n\n              if (in[7] != '=')\n                {\n                  if (!isbase32 (in[7]))\n                    return_false;\n\n                  if (*outleft)\n                    {\n                      *out++ = ((b32[to_uchar (in[6])] << 5)\n                                | (b32[to_uchar (in[7])]));\n                      --*outleft;\n                    }\n                }\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}\n\n \n\nbool\nbase32_decode_ctx (struct base32_decode_context *ctx,\n                   const char *restrict in, idx_t inlen,\n                   char *restrict out, idx_t *outlen)\n{\n  idx_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      idx_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n               \n              outleft_save = outleft;\n              if (!decode_8 (in, inlen, &out, &outleft))\n                break;\n\n              in += 8;\n              inlen -= 8;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n       \n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n       \n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_8 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;   \n\n         \n        if (inlen == 0 || (inlen < 8 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_8 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}\n\n \nbool\nbase32_decode_alloc_ctx (struct base32_decode_context *ctx,\n                         const char *in, idx_t inlen, char **out,\n                         idx_t *outlen)\n{\n   \n  idx_t needlen = 5 * ((inlen >> 3) + 1);\n\n  *out = imalloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base32_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}