{
  "module_name": "rename.c",
  "hash_id": "e22d2982b157050e5b4c32de0abef6cfc140dbd1ea0de40bb0f8c23fe33dae79",
  "original_prompt": "Ingested from coreutils-9.4/lib/rename.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <stdio.h>\n\n#undef rename\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n\n# include <errno.h>\n# include <stdlib.h>\n# include <sys/stat.h>\n# include <unistd.h>\n\n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n\n# include \"dirname.h\"\n\n \n# undef MoveFileEx\n# define MoveFileEx MoveFileExA\n\n \nint\nrpl_rename (char const *src, char const *dst)\n{\n  int error;\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_base = last_component (src);\n  char *dst_base = last_component (dst);\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists;\n  struct stat src_st;\n  struct stat dst_st;\n\n   \n  if (!src_len || !dst_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n  if (*src_base == '.')\n    {\n      size_t len = base_len (src_base);\n      if (len == 1 || (len == 2 && src_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n  if (*dst_base == '.')\n    {\n      size_t len = base_len (dst_base);\n      if (len == 1 || (len == 2 && dst_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n\n   \n  src_slash = ISSLASH (src[src_len - 1]);\n  dst_slash = ISSLASH (dst[dst_len - 1]);\n  if (stat (src, &src_st))\n    return -1;\n  if (stat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n      dst_exists = true;\n    }\n\n   \n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      char *cwd = getcwd (NULL, 0);\n      char *src_temp;\n      char *dst_temp;\n      if (!cwd || chdir (cwd))\n        return -1;\n      if (IS_ABSOLUTE_FILE_NAME (src))\n        {\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n        }\n      else\n        {\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n          if (!IS_ABSOLUTE_FILE_NAME (dst) && chdir (cwd))\n            abort ();\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n        }\n      if (chdir (cwd))\n        abort ();\n      free (cwd);\n      if (!src_temp || !dst_temp)\n        {\n          free (src_temp);\n          free (dst_temp);\n          errno = ENOMEM;\n          return -1;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && (ISSLASH (dst_temp[src_len]) || dst_temp[src_len] == '\\0'))\n        {\n          error = dst_temp[src_len];\n          free (src_temp);\n          free (dst_temp);\n          if (error)\n            {\n              errno = EINVAL;\n              return -1;\n            }\n          return 0;\n        }\n      if (rmdir (dst))\n        {\n          free (src_temp);\n          free (dst_temp);\n          return -1;\n        }\n      free (src_temp);\n      free (dst_temp);\n    }\n\n   \n  if (MoveFileEx (src, dst, 0))\n    return 0;\n\n   \n  error = GetLastError ();\n  if (error == ERROR_FILE_EXISTS || error == ERROR_ALREADY_EXISTS)\n    {\n      if (MoveFileEx (src, dst, MOVEFILE_REPLACE_EXISTING))\n        return 0;\n\n      error = GetLastError ();\n    }\n\n  switch (error)\n    {\n    case ERROR_FILE_NOT_FOUND:\n    case ERROR_PATH_NOT_FOUND:\n    case ERROR_BAD_PATHNAME:\n    case ERROR_DIRECTORY:\n      errno = ENOENT;\n      break;\n\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n      errno = EACCES;\n      break;\n\n    case ERROR_OUTOFMEMORY:\n      errno = ENOMEM;\n      break;\n\n    case ERROR_CURRENT_DIRECTORY:\n      errno = EBUSY;\n      break;\n\n    case ERROR_NOT_SAME_DEVICE:\n      errno = EXDEV;\n      break;\n\n    case ERROR_WRITE_PROTECT:\n      errno = EROFS;\n      break;\n\n    case ERROR_WRITE_FAULT:\n    case ERROR_READ_FAULT:\n    case ERROR_GEN_FAILURE:\n      errno = EIO;\n      break;\n\n    case ERROR_HANDLE_DISK_FULL:\n    case ERROR_DISK_FULL:\n    case ERROR_DISK_TOO_FRAGMENTED:\n      errno = ENOSPC;\n      break;\n\n    case ERROR_FILE_EXISTS:\n    case ERROR_ALREADY_EXISTS:\n      errno = EEXIST;\n      break;\n\n    case ERROR_BUFFER_OVERFLOW:\n    case ERROR_FILENAME_EXCED_RANGE:\n      errno = ENAMETOOLONG;\n      break;\n\n    case ERROR_INVALID_NAME:\n    case ERROR_DELETE_PENDING:\n      errno = EPERM;         \n      break;\n\n# ifndef ERROR_FILE_TOO_LARGE\n \n#  define ERROR_FILE_TOO_LARGE 223\n# endif\n    case ERROR_FILE_TOO_LARGE:\n      errno = EFBIG;\n      break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return -1;\n}\n\n#else  \n\n# include <errno.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n# include <sys/stat.h>\n# include <unistd.h>\n\n# include \"dirname.h\"\n# include \"same-inode.h\"\n\n \n\nint\nrpl_rename (char const *src, char const *dst)\n{\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  _GL_UNUSED bool dst_exists;\n  int ret_val = -1;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n\n  if (!src_len || !dst_len)\n    return rename (src, dst);  \n\n# if RENAME_DEST_EXISTS_BUG\n  {\n    char *src_base = last_component (src);\n    char *dst_base = last_component (dst);\n    if (*src_base == '.')\n      {\n        size_t len = base_len (src_base);\n        if (len == 1 || (len == 2 && src_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n    if (*dst_base == '.')\n      {\n        size_t len = base_len (dst_base);\n        if (len == 1 || (len == 2 && dst_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n  }\n# endif  \n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n\n# if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG\n   \n  if (!src_slash && !dst_slash)\n    return rename (src, dst);\n# endif  \n\n   \n  if (lstat (src, &src_st))\n    return -1;\n  if (lstat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n# if RENAME_HARD_LINK_BUG\n      if (SAME_INODE (src_st, dst_st))\n        return 0;\n# endif  \n      dst_exists = true;\n    }\n\n# if (RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG        \\\n      || RENAME_HARD_LINK_BUG)\n   \n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n           \n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstat (src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstat (dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif  \n\n# if RENAME_DEST_EXISTS_BUG\n   \n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      if (src_st.st_dev != dst_st.st_dev)\n        {\n          rename_errno = EXDEV;\n          goto out;\n        }\n      if (src_temp != src)\n        free (src_temp);\n      src_temp = canonicalize_file_name (src);\n      if (dst_temp != dst)\n        free (dst_temp);\n      dst_temp = canonicalize_file_name (dst);\n      if (!src_temp || !dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && dst_temp[src_len] == '/')\n        {\n          rename_errno = EINVAL;\n          goto out;\n        }\n      if (rmdir (dst))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n    }\n# endif  \n\n  ret_val = rename (src_temp, dst_temp);\n  rename_errno = errno;\n\n out: _GL_UNUSED_LABEL;\n\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}