{
  "module_name": "count-leading-zeros.h",
  "hash_id": "798173bccfa595512132f805ee8fb344fe6eab0a3c011c929852268a526d75ee",
  "original_prompt": "Ingested from coreutils-9.4/lib/count-leading-zeros.h",
  "human_readable_source": " \n\n#ifndef COUNT_LEADING_ZEROS_H\n#define COUNT_LEADING_ZEROS_H 1\n\n \n#if !_GL_CONFIG_H_INCLUDED\n #error \"Please include config.h first.\"\n#endif\n\n#include <limits.h>\n#include <stdlib.h>\n\n_GL_INLINE_HEADER_BEGIN\n#ifndef COUNT_LEADING_ZEROS_INLINE\n# define COUNT_LEADING_ZEROS_INLINE _GL_INLINE\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) \\\n    || (__clang_major__ >= 4)\n# define COUNT_LEADING_ZEROS(BUILTIN, MSC_BUILTIN, TYPE)                \\\n  return x ? BUILTIN (x) : CHAR_BIT * sizeof x;\n#elif _MSC_VER\n# pragma intrinsic (_BitScanReverse)\n# if defined _M_X64\n#  pragma intrinsic (_BitScanReverse64)\n# endif\n# define COUNT_LEADING_ZEROS(BUILTIN, MSC_BUILTIN, TYPE)                \\\n    do                                                                  \\\n      {                                                                 \\\n        unsigned long result;                                           \\\n        if (MSC_BUILTIN (&result, x))                                   \\\n          return CHAR_BIT * sizeof x - 1 - result;                      \\\n        return CHAR_BIT * sizeof x;                                     \\\n      }                                                                 \\\n    while (0)\n#else\n# define COUNT_LEADING_ZEROS(BUILTIN, MSC_BUILTIN, TYPE)                \\\n    do                                                                  \\\n      {                                                                 \\\n        int count;                                                      \\\n        unsigned int leading_32;                                        \\\n        if (! x)                                                        \\\n          return CHAR_BIT * sizeof x;                                   \\\n        for (count = 0;                                                 \\\n             (leading_32 = ((x >> (sizeof (TYPE) * CHAR_BIT - 32))      \\\n                            & 0xffffffffU),                             \\\n              count < CHAR_BIT * sizeof x - 32 && !leading_32);         \\\n             count += 32)                                               \\\n          x = x << 31 << 1;                                             \\\n        return count + count_leading_zeros_32 (leading_32);             \\\n      }                                                                 \\\n    while (0)\n\n \nCOUNT_LEADING_ZEROS_INLINE int\ncount_leading_zeros_32 (unsigned int x)\n{\n   \nCOUNT_LEADING_ZEROS_INLINE int\ncount_leading_zeros (unsigned int x)\n{\n  COUNT_LEADING_ZEROS (__builtin_clz, _BitScanReverse, unsigned int);\n}\n\n \nCOUNT_LEADING_ZEROS_INLINE int\ncount_leading_zeros_l (unsigned long int x)\n{\n  COUNT_LEADING_ZEROS (__builtin_clzl, _BitScanReverse, unsigned long int);\n}\n\n \nCOUNT_LEADING_ZEROS_INLINE int\ncount_leading_zeros_ll (unsigned long long int x)\n{\n#if (defined _MSC_VER && !defined __clang__) && !defined _M_X64\n   \n  unsigned long result;\n  if (_BitScanReverse (&result, (unsigned long) (x >> 32)))\n    return CHAR_BIT * sizeof x - 1 - 32 - result;\n  if (_BitScanReverse (&result, (unsigned long) x))\n    return CHAR_BIT * sizeof x - 1 - result;\n  return CHAR_BIT * sizeof x;\n#else\n  COUNT_LEADING_ZEROS (__builtin_clzll, _BitScanReverse64,\n                       unsigned long long int);\n#endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n_GL_INLINE_HEADER_END\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}