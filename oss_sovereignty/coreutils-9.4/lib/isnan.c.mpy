{
  "module_name": "isnan.c",
  "hash_id": "fc9c816f0208793371526f66d289f4325b98e18e3688afe8771528dec9c3881d",
  "original_prompt": "Ingested from coreutils-9.4/lib/isnan.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#ifdef USE_LONG_DOUBLE\n \nextern int rpl_isnanl (long double x) _GL_ATTRIBUTE_CONST;\n#elif ! defined USE_FLOAT\n \nextern int rpl_isnand (double x);\n#else  \n \nextern int rpl_isnanf (float x);\n#endif\n\n#include <float.h>\n#include <string.h>\n\n#include \"float+.h\"\n\n#ifdef USE_LONG_DOUBLE\n# define FUNC rpl_isnanl\n# define DOUBLE long double\n# define MAX_EXP LDBL_MAX_EXP\n# define MIN_EXP LDBL_MIN_EXP\n# if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n#  define KNOWN_EXPBIT0_LOCATION\n#  define EXPBIT0_WORD LDBL_EXPBIT0_WORD\n#  define EXPBIT0_BIT LDBL_EXPBIT0_BIT\n# endif\n# define SIZE SIZEOF_LDBL\n# define L_(literal) literal##L\n#elif ! defined USE_FLOAT\n# define FUNC rpl_isnand\n# define DOUBLE double\n# define MAX_EXP DBL_MAX_EXP\n# define MIN_EXP DBL_MIN_EXP\n# if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n#  define KNOWN_EXPBIT0_LOCATION\n#  define EXPBIT0_WORD DBL_EXPBIT0_WORD\n#  define EXPBIT0_BIT DBL_EXPBIT0_BIT\n# endif\n# define SIZE SIZEOF_DBL\n# define L_(literal) literal\n#else  \n# define FUNC rpl_isnanf\n# define DOUBLE float\n# define MAX_EXP FLT_MAX_EXP\n# define MIN_EXP FLT_MIN_EXP\n# if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n#  define KNOWN_EXPBIT0_LOCATION\n#  define EXPBIT0_WORD FLT_EXPBIT0_WORD\n#  define EXPBIT0_BIT FLT_EXPBIT0_BIT\n# endif\n# define SIZE SIZEOF_FLT\n# define L_(literal) literal##f\n#endif\n\n#define EXP_MASK ((MAX_EXP - MIN_EXP) | 7)\n\n#define NWORDS \\\n  ((sizeof (DOUBLE) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\ntypedef union { DOUBLE value; unsigned int word[NWORDS]; } memory_double;\n\n \n\n#define IEEE_FLOATING_POINT (FLT_RADIX == 2 && FLT_MANT_DIG == 24 \\\n                             && FLT_MIN_EXP == -125 && FLT_MAX_EXP == 128)\n\nint\nFUNC (DOUBLE x)\n{\n#if defined KNOWN_EXPBIT0_LOCATION && IEEE_FLOATING_POINT\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n   \n  memory_double m;\n  unsigned int exponent;\n\n  m.value = x;\n  exponent = (m.word[EXPBIT0_WORD] >> EXPBIT0_BIT) & EXP_MASK;\n#  ifdef WORDS_BIGENDIAN\n   \n  if (exponent == 0)\n    return 1 & (m.word[0] >> 15);\n  else if (exponent == EXP_MASK)\n    return (((m.word[0] ^ 0x8000U) << 16) | m.word[1] | (m.word[2] >> 16)) != 0;\n  else\n    return 1 & ~(m.word[0] >> 15);\n#  else\n   \n  if (exponent == 0)\n    return (m.word[1] >> 31);\n  else if (exponent == EXP_MASK)\n    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;\n  else\n    return (m.word[1] >> 31) ^ 1;\n#  endif\n# else\n   \n#  if defined __SUNPRO_C || defined __ICC || defined _MSC_VER \\\n      || defined __DECC || defined __TINYC__ \\\n      || (defined __sgi && !defined __GNUC__)\n   \n  static DOUBLE zero = L_(0.0);\n  memory_double nan;\n  DOUBLE plus_inf = L_(1.0) / zero;\n  DOUBLE minus_inf = -L_(1.0) / zero;\n  nan.value = zero / zero;\n#  else\n  static memory_double nan = { L_(0.0) / L_(0.0) };\n  static DOUBLE plus_inf = L_(1.0) / L_(0.0);\n  static DOUBLE minus_inf = -L_(1.0) / L_(0.0);\n#  endif\n  {\n    memory_double m;\n\n     \n    m.value = x;\n    if (((m.word[EXPBIT0_WORD] ^ nan.word[EXPBIT0_WORD])\n         & (EXP_MASK << EXPBIT0_BIT))\n        == 0)\n      return (memcmp (&m.value, &plus_inf, SIZE) != 0\n              && memcmp (&m.value, &minus_inf, SIZE) != 0);\n    else\n      return 0;\n  }\n# endif\n#else\n   \n  if (x == x)\n    {\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n       \n      memory_double m1;\n      memory_double m2;\n\n      memset (&m1.value, 0, SIZE);\n      memset (&m2.value, 0, SIZE);\n      m1.value = x;\n      m2.value = x + (x ? 0.0L : -0.0L);\n      if (memcmp (&m1.value, &m2.value, SIZE) != 0)\n        return 1;\n# endif\n      return 0;\n    }\n  else\n    return 1;\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}