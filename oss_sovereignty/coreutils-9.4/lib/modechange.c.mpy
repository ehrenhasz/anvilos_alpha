{
  "module_name": "modechange.c",
  "hash_id": "c64c2a3dcb0d1017794e27470271fed14f0c6cc54f83da8fbfa30a382ec54900",
  "original_prompt": "Ingested from coreutils-9.4/lib/modechange.c",
  "human_readable_source": " \n\n \n\n#include <config.h>\n\n#include \"modechange.h\"\n#include <sys/stat.h>\n#include \"stat-macros.h\"\n#include \"xalloc.h\"\n#include <stdlib.h>\n\n \n#define SUID 04000\n#define SGID 02000\n#define SVTX 01000\n#define RUSR 00400\n#define WUSR 00200\n#define XUSR 00100\n#define RGRP 00040\n#define WGRP 00020\n#define XGRP 00010\n#define ROTH 00004\n#define WOTH 00002\n#define XOTH 00001\n#define ALLM 07777  \n\n \nstatic mode_t\noctal_to_mode (unsigned int octal)\n{\n   \n  return ((S_ISUID == SUID && S_ISGID == SGID && S_ISVTX == SVTX\n           && S_IRUSR == RUSR && S_IWUSR == WUSR && S_IXUSR == XUSR\n           && S_IRGRP == RGRP && S_IWGRP == WGRP && S_IXGRP == XGRP\n           && S_IROTH == ROTH && S_IWOTH == WOTH && S_IXOTH == XOTH)\n          ? octal\n          : (mode_t) ((octal & SUID ? S_ISUID : 0)\n                      | (octal & SGID ? S_ISGID : 0)\n                      | (octal & SVTX ? S_ISVTX : 0)\n                      | (octal & RUSR ? S_IRUSR : 0)\n                      | (octal & WUSR ? S_IWUSR : 0)\n                      | (octal & XUSR ? S_IXUSR : 0)\n                      | (octal & RGRP ? S_IRGRP : 0)\n                      | (octal & WGRP ? S_IWGRP : 0)\n                      | (octal & XGRP ? S_IXGRP : 0)\n                      | (octal & ROTH ? S_IROTH : 0)\n                      | (octal & WOTH ? S_IWOTH : 0)\n                      | (octal & XOTH ? S_IXOTH : 0)));\n}\n\n \nenum\n  {\n     \n    MODE_DONE,\n\n     \n    MODE_ORDINARY_CHANGE,\n\n     \n    MODE_X_IF_ANY_X,\n\n     \n    MODE_COPY_EXISTING\n  };\n\n \nstruct mode_change\n{\n  char op;                       \n  char flag;                     \n  mode_t affected;               \n  mode_t value;                  \n  mode_t mentioned;              \n};\n\n \n\nstatic struct mode_change *\nmake_node_op_equals (mode_t new_mode, mode_t mentioned)\n{\n  struct mode_change *p = xmalloc (2 * sizeof *p);\n  p->op = '=';\n  p->flag = MODE_ORDINARY_CHANGE;\n  p->affected = CHMOD_MODE_BITS;\n  p->value = new_mode;\n  p->mentioned = mentioned;\n  p[1].flag = MODE_DONE;\n  return p;\n}\n\n \n\nstruct mode_change *\nmode_compile (char const *mode_string)\n{\n   \n  struct mode_change *mc;\n  size_t used = 0;\n  char const *p;\n\n  if ('0' <= *mode_string && *mode_string < '8')\n    {\n      unsigned int octal_mode = 0;\n      mode_t mode;\n      mode_t mentioned;\n\n      p = mode_string;\n      do\n        {\n          octal_mode = 8 * octal_mode + *p++ - '0';\n          if (ALLM < octal_mode)\n            return NULL;\n        }\n      while ('0' <= *p && *p < '8');\n\n      if (*p)\n        return NULL;\n\n      mode = octal_to_mode (octal_mode);\n      mentioned = (p - mode_string < 5\n                   ? (mode & (S_ISUID | S_ISGID)) | S_ISVTX | S_IRWXUGO\n                   : CHMOD_MODE_BITS);\n      return make_node_op_equals (mode, mentioned);\n    }\n\n   \n  {\n    size_t needed = 1;\n    for (p = mode_string; *p; p++)\n      needed += (*p == '=' || *p == '+' || *p == '-');\n    mc = xnmalloc (needed, sizeof *mc);\n  }\n\n   \n  for (p = mode_string; ; p++)\n    {\n       \n      mode_t affected = 0;\n\n       \n      for (;; p++)\n        switch (*p)\n          {\n          default:\n            goto invalid;\n          case 'u':\n            affected |= S_ISUID | S_IRWXU;\n            break;\n          case 'g':\n            affected |= S_ISGID | S_IRWXG;\n            break;\n          case 'o':\n            affected |= S_ISVTX | S_IRWXO;\n            break;\n          case 'a':\n            affected |= CHMOD_MODE_BITS;\n            break;\n          case '=': case '+': case '-':\n            goto no_more_affected;\n          }\n    no_more_affected:;\n\n      do\n        {\n          char op = *p++;\n          mode_t value;\n          mode_t mentioned = 0;\n          char flag = MODE_COPY_EXISTING;\n          struct mode_change *change;\n\n          switch (*p)\n            {\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              {\n                unsigned int octal_mode = 0;\n\n                do\n                  {\n                    octal_mode = 8 * octal_mode + *p++ - '0';\n                    if (ALLM < octal_mode)\n                      goto invalid;\n                  }\n                while ('0' <= *p && *p < '8');\n\n                if (affected || (*p && *p != ','))\n                  goto invalid;\n                affected = mentioned = CHMOD_MODE_BITS;\n                value = octal_to_mode (octal_mode);\n                flag = MODE_ORDINARY_CHANGE;\n                break;\n              }\n\n            case 'u':\n               \n              value = S_IRWXU;\n              p++;\n              break;\n            case 'g':\n               \n              value = S_IRWXG;\n              p++;\n              break;\n            case 'o':\n               \n              value = S_IRWXO;\n              p++;\n              break;\n\n            default:\n              value = 0;\n              flag = MODE_ORDINARY_CHANGE;\n\n              for (;; p++)\n                switch (*p)\n                  {\n                  case 'r':\n                    value |= S_IRUSR | S_IRGRP | S_IROTH;\n                    break;\n                  case 'w':\n                    value |= S_IWUSR | S_IWGRP | S_IWOTH;\n                    break;\n                  case 'x':\n                    value |= S_IXUSR | S_IXGRP | S_IXOTH;\n                    break;\n                  case 'X':\n                    flag = MODE_X_IF_ANY_X;\n                    break;\n                  case 's':\n                     \n                    value |= S_ISUID | S_ISGID;\n                    break;\n                  case 't':\n                     \n                    value |= S_ISVTX;\n                    break;\n                  default:\n                    goto no_more_values;\n                  }\n            no_more_values:;\n            }\n\n          change = &mc[used++];\n          change->op = op;\n          change->flag = flag;\n          change->affected = affected;\n          change->value = value;\n          change->mentioned =\n            (mentioned ? mentioned : affected ? affected & value : value);\n        }\n      while (*p == '=' || *p == '+' || *p == '-');\n\n      if (*p != ',')\n        break;\n    }\n\n  if (*p == 0)\n    {\n      mc[used].flag = MODE_DONE;\n      return mc;\n    }\n\ninvalid:\n  free (mc);\n  return NULL;\n}\n\n \n\nstruct mode_change *\nmode_create_from_ref (const char *ref_file)\n{\n  struct stat ref_stats;\n\n  if (stat (ref_file, &ref_stats) != 0)\n    return NULL;\n  return make_node_op_equals (ref_stats.st_mode, CHMOD_MODE_BITS);\n}\n\n \n\nmode_t\nmode_adjust (mode_t oldmode, bool dir, mode_t umask_value,\n             struct mode_change const *changes, mode_t *pmode_bits)\n{\n   \n  mode_t newmode = oldmode & CHMOD_MODE_BITS;\n\n   \n  mode_t mode_bits = 0;\n\n  for (; changes->flag != MODE_DONE; changes++)\n    {\n      mode_t affected = changes->affected;\n      mode_t omit_change =\n        (dir ? S_ISUID | S_ISGID : 0) & ~ changes->mentioned;\n      mode_t value = changes->value;\n\n      switch (changes->flag)\n        {\n        case MODE_ORDINARY_CHANGE:\n          break;\n\n        case MODE_COPY_EXISTING:\n           \n          value &= newmode;\n\n           \n          value |= ((value & (S_IRUSR | S_IRGRP | S_IROTH)\n                     ? S_IRUSR | S_IRGRP | S_IROTH : 0)\n                    | (value & (S_IWUSR | S_IWGRP | S_IWOTH)\n                       ? S_IWUSR | S_IWGRP | S_IWOTH : 0)\n                    | (value & (S_IXUSR | S_IXGRP | S_IXOTH)\n                       ? S_IXUSR | S_IXGRP | S_IXOTH : 0));\n          break;\n\n        case MODE_X_IF_ANY_X:\n           \n          if ((newmode & (S_IXUSR | S_IXGRP | S_IXOTH)) | dir)\n            value |= S_IXUSR | S_IXGRP | S_IXOTH;\n          break;\n        }\n\n       \n      value &= (affected ? affected : ~umask_value) & ~ omit_change;\n\n      switch (changes->op)\n        {\n        case '=':\n           \n          {\n            mode_t preserved = (affected ? ~affected : 0) | omit_change;\n            mode_bits |= CHMOD_MODE_BITS & ~preserved;\n            newmode = (newmode & preserved) | value;\n            break;\n          }\n\n        case '+':\n          mode_bits |= value;\n          newmode |= value;\n          break;\n\n        case '-':\n          mode_bits |= value;\n          newmode &= ~value;\n          break;\n        }\n    }\n\n  if (pmode_bits)\n    *pmode_bits = mode_bits;\n  return newmode;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}