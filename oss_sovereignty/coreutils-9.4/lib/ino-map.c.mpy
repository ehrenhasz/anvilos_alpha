{
  "module_name": "ino-map.c",
  "hash_id": "e495429411621d71a2bee91b683ab41ddbafc4dbfa0a3f91b489dd71bdd63044",
  "original_prompt": "Ingested from coreutils-9.4/lib/ino-map.c",
  "human_readable_source": " \n\n#include <config.h>\n#include \"ino-map.h\"\n\n#include \"hash.h\"\n\n#include <limits.h>\n#include <stdlib.h>\n\n \nstruct ino_map_ent\n{\n  ino_t ino;\n  size_t mapped_ino;\n};\n\n \nstruct ino_map\n{\n   \n  struct hash_table *map;\n\n   \n  size_t next_mapped_ino;\n\n   \n  struct ino_map_ent *probe;\n};\n\n \nstatic size_t\nino_hash (void const *x, size_t table_size)\n{\n  struct ino_map_ent const *p = x;\n  ino_t ino = p->ino;\n\n   \n  size_t h = ino;\n  unsigned int i;\n  unsigned int n_words = sizeof ino / sizeof h + (sizeof ino % sizeof h != 0);\n  for (i = 1; i < n_words; i++)\n    h ^= ino >> CHAR_BIT * sizeof h * i;\n\n  return h % table_size;\n}\n\n \nstatic bool\nino_compare (void const *x, void const *y)\n{\n  struct ino_map_ent const *a = x;\n  struct ino_map_ent const *b = y;\n  return a->ino == b->ino;\n}\n\n \nstruct ino_map *\nino_map_alloc (size_t next_mapped_ino)\n{\n  struct ino_map *im = malloc (sizeof *im);\n\n  if (im)\n    {\n      enum { INITIAL_INO_MAP_TABLE_SIZE = 1021 };\n      im->map = hash_initialize (INITIAL_INO_MAP_TABLE_SIZE, NULL,\n                                 ino_hash, ino_compare, free);\n      if (! im->map)\n        {\n          free (im);\n          return NULL;\n        }\n      im->next_mapped_ino = next_mapped_ino;\n      im->probe = NULL;\n    }\n\n  return im;\n}\n\n \nvoid\nino_map_free (struct ino_map *map)\n{\n  hash_free (map->map);\n  free (map->probe);\n  free (map);\n}\n\n\n \nsize_t\nino_map_insert (struct ino_map *im, ino_t ino)\n{\n  struct ino_map_ent *ent;\n\n   \n  struct ino_map_ent *probe = im->probe;\n  if (probe)\n    {\n       \n      if (probe->ino == ino)\n        return probe->mapped_ino;\n    }\n  else\n    {\n      im->probe = probe = malloc (sizeof *probe);\n      if (! probe)\n        return INO_MAP_INSERT_FAILURE;\n    }\n\n  probe->ino = ino;\n  ent = hash_insert (im->map, probe);\n  if (! ent)\n    return INO_MAP_INSERT_FAILURE;\n\n  if (ent != probe)\n    {\n       \n      probe->mapped_ino = ent->mapped_ino;\n    }\n  else\n    {\n       \n      static_assert (INO_MAP_INSERT_FAILURE + 1 == 0);\n\n       \n      im->probe = NULL;\n\n       \n      probe->mapped_ino = im->next_mapped_ino++;\n    }\n\n  return probe->mapped_ino;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}