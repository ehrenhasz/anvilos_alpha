{
  "module_name": "regex_internal.h",
  "hash_id": "d8aa24ccff7764b403877d5ee47da0d7a23c447c941b74bae356566b1b2f2ea1",
  "original_prompt": "Ingested from coreutils-9.4/lib/regex_internal.h",
  "human_readable_source": " \n# define lock_lock(lock) ((void) dfa)\n# define lock_unlock(lock) ((void) 0)\n#endif\n\n \n#if !defined _LIBC && ! (defined isblank || (HAVE_ISBLANK && HAVE_DECL_ISBLANK))\n# define isblank(ch) ((ch) == ' ' || (ch) == '\\t')\n#endif\n\n \n#ifndef _LIBC\n# undef isascii\n# define isascii(c) (((c) & ~0x7f) == 0)\n#endif\n\n#ifdef _LIBC\n# ifndef _RE_DEFINE_LOCALE_FUNCTIONS\n#  define _RE_DEFINE_LOCALE_FUNCTIONS 1\n#   include <locale/localeinfo.h>\n#   include <locale/coll-lookup.h>\n# endif\n#endif\n\n \n#if (HAVE_LIBINTL_H && ENABLE_NLS) || defined _LIBC\n# include <libintl.h>\n# ifdef _LIBC\n#  undef gettext\n#  define gettext(msgid) \\\n  __dcgettext (_libc_intl_domainname, msgid, LC_MESSAGES)\n# endif\n#else\n# undef gettext\n# define gettext(msgid) (msgid)\n#endif\n\n#ifndef gettext_noop\n \n# define gettext_noop(String) String\n#endif\n\n \n#define ASCII_CHARS 0x80\n\n \n#define SBC_MAX (UCHAR_MAX + 1)\n\n#define COLL_ELEM_LEN_MAX 8\n\n \n#define NEWLINE_CHAR '\\n'\n#define WIDE_NEWLINE_CHAR L'\\n'\n\n \n#ifndef _LIBC\n# undef __wctype\n# undef __iswalnum\n# undef __iswctype\n# undef __towlower\n# undef __towupper\n# define __wctype wctype\n# define __iswalnum iswalnum\n# define __iswctype iswctype\n# define __towlower towlower\n# define __towupper towupper\n# define __btowc btowc\n# define __mbrtowc mbrtowc\n# define __wcrtomb wcrtomb\n# define __regfree regfree\n#endif  \n\n \n\n#ifndef ULONG_WIDTH\n# define ULONG_WIDTH REGEX_UINTEGER_WIDTH (ULONG_MAX)\n \n# define REGEX_UINTEGER_WIDTH(max) REGEX_COB128 (max)\n# define REGEX_COB128(n) (REGEX_COB64 ((n) >> 31 >> 31 >> 2) + REGEX_COB64 (n))\n# define REGEX_COB64(n) (REGEX_COB32 ((n) >> 31 >> 1) + REGEX_COB32 (n))\n# define REGEX_COB32(n) (REGEX_COB16 ((n) >> 16) + REGEX_COB16 (n))\n# define REGEX_COB16(n) (REGEX_COB8 ((n) >> 8) + REGEX_COB8 (n))\n# define REGEX_COB8(n) (REGEX_COB4 ((n) >> 4) + REGEX_COB4 (n))\n# define REGEX_COB4(n) (!!((n) & 8) + !!((n) & 4) + !!((n) & 2) + ((n) & 1))\n# if ULONG_MAX / 2 + 1 != 1ul << (ULONG_WIDTH - 1)\n#  error \"ULONG_MAX out of range\"\n# endif\n#endif\n\n \ntypedef regoff_t Idx;\n#ifdef _REGEX_LARGE_OFFSETS\n# define IDX_MAX SSIZE_MAX\n#else\n# define IDX_MAX INT_MAX\n#endif\n\n \ntypedef __re_size_t re_hashval_t;\n\n \ntypedef unsigned long int bitset_word_t;\n \n#define BITSET_WORD_MAX ULONG_MAX\n \n#define BITSET_WORD_BITS ULONG_WIDTH\n\n \n#define BITSET_WORDS ((SBC_MAX + BITSET_WORD_BITS - 1) / BITSET_WORD_BITS)\n\ntypedef bitset_word_t bitset_t[BITSET_WORDS];\ntypedef bitset_word_t *re_bitset_ptr_t;\ntypedef const bitset_word_t *re_const_bitset_ptr_t;\n\n#define PREV_WORD_CONSTRAINT 0x0001\n#define PREV_NOTWORD_CONSTRAINT 0x0002\n#define NEXT_WORD_CONSTRAINT 0x0004\n#define NEXT_NOTWORD_CONSTRAINT 0x0008\n#define PREV_NEWLINE_CONSTRAINT 0x0010\n#define NEXT_NEWLINE_CONSTRAINT 0x0020\n#define PREV_BEGBUF_CONSTRAINT 0x0040\n#define NEXT_ENDBUF_CONSTRAINT 0x0080\n#define WORD_DELIM_CONSTRAINT 0x0100\n#define NOT_WORD_DELIM_CONSTRAINT 0x0200\n\ntypedef enum\n{\n  INSIDE_WORD = PREV_WORD_CONSTRAINT | NEXT_WORD_CONSTRAINT,\n  WORD_FIRST = PREV_NOTWORD_CONSTRAINT | NEXT_WORD_CONSTRAINT,\n  WORD_LAST = PREV_WORD_CONSTRAINT | NEXT_NOTWORD_CONSTRAINT,\n  INSIDE_NOTWORD = PREV_NOTWORD_CONSTRAINT | NEXT_NOTWORD_CONSTRAINT,\n  LINE_FIRST = PREV_NEWLINE_CONSTRAINT,\n  LINE_LAST = NEXT_NEWLINE_CONSTRAINT,\n  BUF_FIRST = PREV_BEGBUF_CONSTRAINT,\n  BUF_LAST = NEXT_ENDBUF_CONSTRAINT,\n  WORD_DELIM = WORD_DELIM_CONSTRAINT,\n  NOT_WORD_DELIM = NOT_WORD_DELIM_CONSTRAINT\n} re_context_type;\n\ntypedef struct\n{\n  Idx alloc;\n  Idx nelem;\n  Idx *elems;\n} re_node_set;\n\ntypedef enum\n{\n  NON_TYPE = 0,\n\n   \n  CHARACTER = 1,\n  END_OF_RE = 2,\n  SIMPLE_BRACKET = 3,\n  OP_BACK_REF = 4,\n  OP_PERIOD = 5,\n  COMPLEX_BRACKET = 6,\n  OP_UTF8_PERIOD = 7,\n\n   \n#define EPSILON_BIT 8\n  OP_OPEN_SUBEXP = EPSILON_BIT | 0,\n  OP_CLOSE_SUBEXP = EPSILON_BIT | 1,\n  OP_ALT = EPSILON_BIT | 2,\n  OP_DUP_ASTERISK = EPSILON_BIT | 3,\n  ANCHOR = EPSILON_BIT | 4,\n\n   \n  CONCAT = 16,\n  SUBEXP = 17,\n\n   \n  OP_DUP_PLUS = 18,\n  OP_DUP_QUESTION,\n  OP_OPEN_BRACKET,\n  OP_CLOSE_BRACKET,\n  OP_CHARSET_RANGE,\n  OP_OPEN_DUP_NUM,\n  OP_CLOSE_DUP_NUM,\n  OP_NON_MATCH_LIST,\n  OP_OPEN_COLL_ELEM,\n  OP_CLOSE_COLL_ELEM,\n  OP_OPEN_EQUIV_CLASS,\n  OP_CLOSE_EQUIV_CLASS,\n  OP_OPEN_CHAR_CLASS,\n  OP_CLOSE_CHAR_CLASS,\n  OP_WORD,\n  OP_NOTWORD,\n  OP_SPACE,\n  OP_NOTSPACE,\n  BACK_SLASH\n\n} re_token_type_t;\n\ntypedef struct\n{\n   \n  wchar_t *mbchars;\n\n#ifdef _LIBC\n   \n  int32_t *coll_syms;\n#endif\n\n#ifdef _LIBC\n   \n  int32_t *equiv_classes;\n#endif\n\n   \n#ifdef _LIBC\n  uint32_t *range_starts;\n  uint32_t *range_ends;\n#else\n  wchar_t *range_starts;\n  wchar_t *range_ends;\n#endif\n\n   \n  wctype_t *char_classes;\n\n   \n  unsigned int non_match : 1;\n\n   \n  Idx nmbchars;\n\n   \n  Idx ncoll_syms;\n\n   \n  Idx nequiv_classes;\n\n   \n  Idx nranges;\n\n   \n  Idx nchar_classes;\n} re_charset_t;\n\ntypedef struct\n{\n  union\n  {\n    unsigned char c;\t\t \n    re_bitset_ptr_t sbcset;\t \n    re_charset_t *mbcset;\t \n    Idx idx;\t\t\t \n    re_context_type ctx_type;\t \n  } opr;\n#if (__GNUC__ >= 2 || defined __clang__) && !defined __STRICT_ANSI__\n  re_token_type_t type : 8;\n#else\n  re_token_type_t type;\n#endif\n  unsigned int constraint : 10;\t \n  unsigned int duplicated : 1;\n  unsigned int opt_subexp : 1;\n  unsigned int accept_mb : 1;\n   \n  unsigned int mb_partial : 1;\n  unsigned int word_char : 1;\n} re_token_t;\n\n#define IS_EPSILON_NODE(type) ((type) & EPSILON_BIT)\n\nstruct re_string_t\n{\n   \n  const unsigned char *raw_mbs;\n   \n  unsigned char *mbs;\n   \n  wint_t *wcs;\n  Idx *offsets;\n  mbstate_t cur_state;\n   \n  Idx raw_mbs_idx;\n   \n  Idx valid_len;\n   \n  Idx valid_raw_len;\n   \n  Idx bufs_len;\n   \n  Idx cur_idx;\n   \n  Idx raw_len;\n   \n  Idx len;\n   \n  Idx raw_stop;\n   \n  Idx stop;\n\n   \n  unsigned int tip_context;\n   \n  RE_TRANSLATE_TYPE trans;\n   \n  re_const_bitset_ptr_t word_char;\n   \n  unsigned char icase;\n  unsigned char is_utf8;\n  unsigned char map_notascii;\n  unsigned char mbs_allocated;\n  unsigned char offsets_needed;\n  unsigned char newline_anchor;\n  unsigned char word_ops_used;\n  int mb_cur_max;\n};\ntypedef struct re_string_t re_string_t;\n\n\nstruct re_dfa_t;\ntypedef struct re_dfa_t re_dfa_t;\n\n#ifndef _LIBC\n# define IS_IN(libc) false\n#endif\n\n#define re_string_peek_byte(pstr, offset) \\\n  ((pstr)->mbs[(pstr)->cur_idx + offset])\n#define re_string_fetch_byte(pstr) \\\n  ((pstr)->mbs[(pstr)->cur_idx++])\n#define re_string_first_byte(pstr, idx) \\\n  ((idx) == (pstr)->valid_len || (pstr)->wcs[idx] != WEOF)\n#define re_string_is_single_byte_char(pstr, idx) \\\n  ((pstr)->wcs[idx] != WEOF && ((pstr)->valid_len == (idx) + 1 \\\n\t\t\t\t|| (pstr)->wcs[(idx) + 1] != WEOF))\n#define re_string_eoi(pstr) ((pstr)->stop <= (pstr)->cur_idx)\n#define re_string_cur_idx(pstr) ((pstr)->cur_idx)\n#define re_string_get_buffer(pstr) ((pstr)->mbs)\n#define re_string_length(pstr) ((pstr)->len)\n#define re_string_byte_at(pstr,idx) ((pstr)->mbs[idx])\n#define re_string_skip_bytes(pstr,idx) ((pstr)->cur_idx += (idx))\n#define re_string_set_index(pstr,idx) ((pstr)->cur_idx = (idx))\n\n#ifdef _LIBC\n# define MALLOC_0_IS_NONNULL 1\n#elif !defined MALLOC_0_IS_NONNULL\n# define MALLOC_0_IS_NONNULL 0\n#endif\n\n#ifndef MAX\n# define MAX(a,b) ((a) < (b) ? (b) : (a))\n#endif\n#ifndef MIN\n# define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n#define re_malloc(t,n) ((t *) malloc ((n) * sizeof (t)))\n#define re_realloc(p,t,n) ((t *) realloc (p, (n) * sizeof (t)))\n#define re_free(p) free (p)\n\nstruct bin_tree_t\n{\n  struct bin_tree_t *parent;\n  struct bin_tree_t *left;\n  struct bin_tree_t *right;\n  struct bin_tree_t *first;\n  struct bin_tree_t *next;\n\n  re_token_t token;\n\n   \n  Idx node_idx;\n};\ntypedef struct bin_tree_t bin_tree_t;\n\n#define BIN_TREE_STORAGE_SIZE \\\n  ((1024 - sizeof (void *)) / sizeof (bin_tree_t))\n\nstruct bin_tree_storage_t\n{\n  struct bin_tree_storage_t *next;\n  bin_tree_t data[BIN_TREE_STORAGE_SIZE];\n};\ntypedef struct bin_tree_storage_t bin_tree_storage_t;\n\n#define CONTEXT_WORD 1\n#define CONTEXT_NEWLINE (CONTEXT_WORD << 1)\n#define CONTEXT_BEGBUF (CONTEXT_NEWLINE << 1)\n#define CONTEXT_ENDBUF (CONTEXT_BEGBUF << 1)\n\n#define IS_WORD_CONTEXT(c) ((c) & CONTEXT_WORD)\n#define IS_NEWLINE_CONTEXT(c) ((c) & CONTEXT_NEWLINE)\n#define IS_BEGBUF_CONTEXT(c) ((c) & CONTEXT_BEGBUF)\n#define IS_ENDBUF_CONTEXT(c) ((c) & CONTEXT_ENDBUF)\n#define IS_ORDINARY_CONTEXT(c) ((c) == 0)\n\n#define IS_WORD_CHAR(ch) (isalnum (ch) || (ch) == '_')\n#define IS_NEWLINE(ch) ((ch) == NEWLINE_CHAR)\n#define IS_WIDE_WORD_CHAR(ch) (__iswalnum (ch) || (ch) == L'_')\n#define IS_WIDE_NEWLINE(ch) ((ch) == WIDE_NEWLINE_CHAR)\n\n#define NOT_SATISFY_PREV_CONSTRAINT(constraint,context) \\\n ((((constraint) & PREV_WORD_CONSTRAINT) && !IS_WORD_CONTEXT (context)) \\\n  || ((constraint & PREV_NOTWORD_CONSTRAINT) && IS_WORD_CONTEXT (context)) \\\n  || ((constraint & PREV_NEWLINE_CONSTRAINT) && !IS_NEWLINE_CONTEXT (context))\\\n  || ((constraint & PREV_BEGBUF_CONSTRAINT) && !IS_BEGBUF_CONTEXT (context)))\n\n#define NOT_SATISFY_NEXT_CONSTRAINT(constraint,context) \\\n ((((constraint) & NEXT_WORD_CONSTRAINT) && !IS_WORD_CONTEXT (context)) \\\n  || (((constraint) & NEXT_NOTWORD_CONSTRAINT) && IS_WORD_CONTEXT (context)) \\\n  || (((constraint) & NEXT_NEWLINE_CONSTRAINT) && !IS_NEWLINE_CONTEXT (context)) \\\n  || (((constraint) & NEXT_ENDBUF_CONSTRAINT) && !IS_ENDBUF_CONTEXT (context)))\n\nstruct re_dfastate_t\n{\n  re_hashval_t hash;\n  re_node_set nodes;\n  re_node_set non_eps_nodes;\n  re_node_set inveclosure;\n  re_node_set *entrance_nodes;\n  struct re_dfastate_t **trtable, **word_trtable;\n  unsigned int context : 4;\n  unsigned int halt : 1;\n   \n  unsigned int accept_mb : 1;\n   \n  unsigned int has_backref : 1;\n  unsigned int has_constraint : 1;\n};\ntypedef struct re_dfastate_t re_dfastate_t;\n\nstruct re_state_table_entry\n{\n  Idx num;\n  Idx alloc;\n  re_dfastate_t **array;\n};\n\n \n\ntypedef struct\n{\n  Idx next_idx;\n  Idx alloc;\n  re_dfastate_t **array;\n} state_array_t;\n\n \n\ntypedef struct\n{\n  Idx node;\n  Idx str_idx;  \n  state_array_t path;\n} re_sub_match_last_t;\n\n \n\ntypedef struct\n{\n  Idx str_idx;\n  Idx node;\n  state_array_t *path;\n  Idx alasts;  \n  Idx nlasts;  \n  re_sub_match_last_t **lasts;\n} re_sub_match_top_t;\n\nstruct re_backref_cache_entry\n{\n  Idx node;\n  Idx str_idx;\n  Idx subexp_from;\n  Idx subexp_to;\n  bitset_word_t eps_reachable_subexps_map;\n  char more;\n};\n\ntypedef struct\n{\n   \n  re_string_t input;\n  const re_dfa_t *const dfa;\n   \n  int eflags;\n   \n  Idx match_last;\n  Idx last_node;\n   \n  re_dfastate_t **state_log;\n  Idx state_log_top;\n   \n  Idx nbkref_ents;\n  Idx abkref_ents;\n  struct re_backref_cache_entry *bkref_ents;\n  int max_mb_elem_len;\n  Idx nsub_tops;\n  Idx asub_tops;\n  re_sub_match_top_t **sub_tops;\n} re_match_context_t;\n\ntypedef struct\n{\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **limited_states;\n  Idx last_node;\n  Idx last_str_idx;\n  re_node_set limits;\n} re_sift_context_t;\n\nstruct re_fail_stack_ent_t\n{\n  Idx idx;\n  Idx node;\n  regmatch_t *regs;\n  re_node_set eps_via_nodes;\n};\n\nstruct re_fail_stack_t\n{\n  Idx num;\n  Idx alloc;\n  struct re_fail_stack_ent_t *stack;\n};\n\nstruct re_dfa_t\n{\n  re_token_t *nodes;\n  size_t nodes_alloc;\n  size_t nodes_len;\n  Idx *nexts;\n  Idx *org_indices;\n  re_node_set *edests;\n  re_node_set *eclosures;\n  re_node_set *inveclosures;\n  struct re_state_table_entry *state_table;\n  re_dfastate_t *init_state;\n  re_dfastate_t *init_state_word;\n  re_dfastate_t *init_state_nl;\n  re_dfastate_t *init_state_begbuf;\n  bin_tree_t *str_tree;\n  bin_tree_storage_t *str_tree_storage;\n  re_bitset_ptr_t sb_char;\n  int str_tree_storage_idx;\n\n   \n  re_hashval_t state_hash_mask;\n  Idx init_node;\n  Idx nbackref;  \n\n   \n  bitset_word_t used_bkref_map;\n  bitset_word_t completed_bkref_map;\n\n  unsigned int has_plural_match : 1;\n   \n  unsigned int has_mb_node : 1;\n  unsigned int is_utf8 : 1;\n  unsigned int map_notascii : 1;\n  unsigned int word_ops_used : 1;\n  int mb_cur_max;\n  bitset_t word_char;\n  reg_syntax_t syntax;\n  Idx *subexp_map;\n#ifdef DEBUG\n  char* re_str;\n#endif\n  lock_define (lock)\n};\n\n#define re_node_set_init_empty(set) memset (set, '\\0', sizeof (re_node_set))\n#define re_node_set_remove(set,id) \\\n  (re_node_set_remove_at (set, re_node_set_contains (set, id) - 1))\n#define re_node_set_empty(p) ((p)->nelem = 0)\n#define re_node_set_free(set) re_free ((set)->elems)\n\f\n\ntypedef enum\n{\n  SB_CHAR,\n  MB_CHAR,\n  EQUIV_CLASS,\n  COLL_SYM,\n  CHAR_CLASS\n} bracket_elem_type;\n\ntypedef struct\n{\n  bracket_elem_type type;\n  union\n  {\n    unsigned char ch;\n    unsigned char *name;\n    wchar_t wch;\n  } opr;\n} bracket_elem_t;\n\n\n \n\nstatic inline void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}\n\nstatic inline void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}\n\nstatic inline bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}\n\nstatic inline void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}\n\nstatic inline void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}\n\nstatic inline void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}\n\nstatic inline void\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}\n\nstatic inline void\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}\n\nstatic inline void\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}\n\n \nstatic int\n__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}\n\nstatic wint_t\n__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}\n\n#ifdef _LIBC\n# include <locale/weight.h>\n#endif\n\nstatic int\n__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n#ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (table, indirect, extra, &p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n#endif  \n\n  return 1;\n}\n\n#ifdef _LIBC\n# if __glibc_has_attribute (__fallthrough__)\n#  define FALLTHROUGH __attribute__ ((__fallthrough__))\n# else\n#  define FALLTHROUGH ((void) 0)\n# endif\n#else\n# include \"attribute.h\"\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}