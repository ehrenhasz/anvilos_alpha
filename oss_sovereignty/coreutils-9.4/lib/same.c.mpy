{
  "module_name": "same.c",
  "hash_id": "113f66c0ce70aba1cb170cf348739bce839b075bf140ccb495e45cce2d71d8ef",
  "original_prompt": "Ingested from coreutils-9.4/lib/same.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <string.h>\n\n#include <limits.h>\n#ifndef _POSIX_NAME_MAX\n# define _POSIX_NAME_MAX 14\n#endif\n\n#include \"same.h\"\n#include \"dirname.h\"\n#include \"error.h\"\n#include \"same-inode.h\"\n\n#ifndef MIN\n# define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n \n#if !_POSIX_NO_TRUNC && HAVE_FPATHCONF && defined _PC_NAME_MAX\n# define CHECK_TRUNCATION true\n#else\n# define CHECK_TRUNCATION false\n#endif\n\n \n\nbool\nsame_name (const char *source, const char *dest)\n{\n  return same_nameat (AT_FDCWD, source, AT_FDCWD, dest);\n}\n\n \n\nbool\nsame_nameat (int source_dfd, char const *source,\n             int dest_dfd, char const *dest)\n{\n   \n  char const *source_basename = last_component (source);\n  char const *dest_basename = last_component (dest);\n  size_t source_baselen = base_len (source_basename);\n  size_t dest_baselen = base_len (dest_basename);\n  bool identical_basenames =\n    (source_baselen == dest_baselen\n     && memcmp (source_basename, dest_basename, dest_baselen) == 0);\n  bool compare_dirs = identical_basenames;\n  bool same = false;\n\n#if CHECK_TRUNCATION\n  size_t slen_max = HAVE_LONG_FILE_NAMES ? 255 : _POSIX_NAME_MAX;\n  size_t min_baselen = MIN (source_baselen, dest_baselen);\n  if (slen_max <= min_baselen\n      && memcmp (source_basename, dest_basename, slen_max) == 0)\n    compare_dirs = true;\n#endif\n\n  if (compare_dirs)\n    {\n      struct stat source_dir_stats;\n      struct stat dest_dir_stats;\n\n       \n      char *source_dirname = dir_name (source);\n      int flags = AT_SYMLINK_NOFOLLOW;\n      if (fstatat (source_dfd, source_dirname, &source_dir_stats, flags) != 0)\n        {\n           \n          error (1, errno, \"%s\", source_dirname);\n        }\n      free (source_dirname);\n\n      char *dest_dirname = dir_name (dest);\n\n#if CHECK_TRUNCATION\n      int destdir_errno = 0;\n      int open_flags = O_SEARCH | O_CLOEXEC | O_DIRECTORY;\n      int destdir_fd = openat (dest_dfd, dest_dirname, open_flags);\n      if (destdir_fd < 0 || fstat (destdir_fd, &dest_dir_stats) != 0)\n        destdir_errno = errno;\n      else if (SAME_INODE (source_dir_stats, dest_dir_stats))\n        {\n          same = identical_basenames;\n          if (! same)\n            {\n              errno = 0;\n              long name_max = fpathconf (destdir_fd, _PC_NAME_MAX);\n              if (name_max < 0)\n                destdir_errno = errno;\n              else\n                same = (name_max <= min_baselen\n                        && (memcmp (source_basename, dest_basename, name_max)\n                            == 0));\n            }\n        }\n      close (destdir_fd);\n      if (destdir_errno != 0)\n        {\n           \n          error (1, destdir_errno, \"%s\", dest_dirname);\n        }\n#else\n      if (fstatat (dest_dfd, dest_dirname, &dest_dir_stats, flags) != 0)\n        {\n           \n          error (1, errno, \"%s\", dest_dirname);\n        }\n      same = SAME_INODE (source_dir_stats, dest_dir_stats);\n#endif\n\n      free (dest_dirname);\n    }\n\n  return same;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}