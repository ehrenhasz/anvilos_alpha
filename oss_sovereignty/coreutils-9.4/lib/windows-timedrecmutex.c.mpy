{
  "module_name": "windows-timedrecmutex.c",
  "hash_id": "6a62ebd53ea17db5013f538fa8cca531fb4d4b045f0ae1b662fd2ea81549d2bb",
  "original_prompt": "Ingested from coreutils-9.4/lib/windows-timedrecmutex.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"windows-timedrecmutex.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\n \n#undef CreateEvent\n#define CreateEvent CreateEventA\n\nint\nglwthread_timedrecmutex_init (glwthread_timedrecmutex_t *mutex)\n{\n  mutex->owner = 0;\n  mutex->depth = 0;\n   \n   \n          int err = glwthread_timedrecmutex_init (mutex);\n          if (err != 0)\n            {\n               \n              InterlockedDecrement (&mutex->guard.started);\n              return err;\n            }\n        }\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          while (!mutex->guard.done)\n            Sleep (0);\n        }\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (mutex->owner != self)\n      {\n        EnterCriticalSection (&mutex->lock);\n        mutex->owner = self;\n      }\n    if (++(mutex->depth) == 0)  \n      {\n        mutex->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}\n\nint\nglwthread_timedrecmutex_trylock (glwthread_timedrecmutex_t *mutex)\n{\n  if (!mutex->guard.done)\n    {\n      if (InterlockedIncrement (&mutex->guard.started) == 0)\n        {\n           \n          int err = glwthread_timedrecmutex_init (mutex);\n          if (err != 0)\n            {\n               \n              InterlockedDecrement (&mutex->guard.started);\n              return err;\n            }\n        }\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          return EBUSY;\n        }\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (mutex->owner != self)\n      {\n        if (!TryEnterCriticalSection (&mutex->lock))\n          return EBUSY;\n        mutex->owner = self;\n      }\n    if (++(mutex->depth) == 0)  \n      {\n        mutex->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}\n\nint\nglwthread_timedrecmutex_timedlock (glwthread_timedrecmutex_t *mutex,\n                                   const struct timespec *abstime)\n{\n  if (!mutex->guard.done)\n    {\n      if (InterlockedIncrement (&mutex->guard.started) == 0)\n        {\n           \n          int err = glwthread_timedrecmutex_init (mutex);\n          if (err != 0)\n            {\n               \n              InterlockedDecrement (&mutex->guard.started);\n              return err;\n            }\n        }\n      else\n        {\n           \n          InterlockedDecrement (&mutex->guard.started);\n           \n          while (!mutex->guard.done)\n            Sleep (0);\n        }\n    }\n\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (mutex->owner != self)\n      {\n         \n        for (;;)\n          {\n            if (TryEnterCriticalSection (&mutex->lock))\n              break;\n\n            {\n              struct timeval currtime;\n              DWORD timeout;\n              DWORD result;\n\n              gettimeofday (&currtime, NULL);\n\n               \n              if (currtime.tv_sec > abstime->tv_sec)\n                timeout = 0;\n              else\n                {\n                  unsigned long seconds = abstime->tv_sec - currtime.tv_sec;\n                  timeout = seconds * 1000;\n                  if (timeout / 1000 != seconds)  \n                    timeout = INFINITE;\n                  else\n                    {\n                      long milliseconds =\n                        abstime->tv_nsec / 1000000 - currtime.tv_usec / 1000;\n                      if (milliseconds >= 0)\n                        {\n                          timeout += milliseconds;\n                          if (timeout < milliseconds)  \n                            timeout = INFINITE;\n                        }\n                      else\n                        {\n                          if (timeout >= - milliseconds)\n                            timeout -= (- milliseconds);\n                          else\n                            timeout = 0;\n                        }\n                    }\n                }\n              if (timeout == 0)\n                return ETIMEDOUT;\n\n               \n            }\n          }\n        mutex->owner = self;\n      }\n    if (++(mutex->depth) == 0)  \n      {\n        mutex->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}\n\nint\nglwthread_timedrecmutex_unlock (glwthread_timedrecmutex_t *mutex)\n{\n  if (mutex->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (mutex->depth == 0)\n    return EINVAL;\n  if (--(mutex->depth) == 0)\n    {\n      mutex->owner = 0;\n      LeaveCriticalSection (&mutex->lock);\n       \n      /* SetEvent\n         <https:\n      SetEvent (mutex->event);\n    }\n  return 0;\n}\n\nint\nglwthread_timedrecmutex_destroy (glwthread_timedrecmutex_t *mutex)\n{\n  if (mutex->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&mutex->lock);\n  /* CloseHandle\n     <https:\n  CloseHandle (mutex->event);\n  mutex->guard.done = 0;\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}