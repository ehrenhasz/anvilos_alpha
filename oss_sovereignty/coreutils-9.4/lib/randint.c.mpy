{
  "module_name": "randint.c",
  "hash_id": "454fa9786eb088fbde94d7653c1e7c83885dfcc7fb2a9f79af23076da2f0287b",
  "original_prompt": "Ingested from coreutils-9.4/lib/randint.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"randint.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n#if TEST\n# include <inttypes.h>\n# include <stdio.h>\n\nint\nmain (int argc, char **argv)\n{\n  randint i;\n  randint n = strtoumax (argv[1], nullptr, 10);\n  randint choices = strtoumax (argv[2], nullptr, 10);\n  char const *name = argv[3];\n  struct randint_source *ints = randint_all_new (name, SIZE_MAX);\n\n  for (i = 0; i < n; i++)\n    printf (\"%\"PRIuMAX\"\\n\", randint_choose (ints, choices));\n\n  return (randint_all_free (ints) == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n#endif\n\n\n#include \"xalloc.h\"\n\n \nstruct randint_source\n{\n   \n  struct randread_source *source;\n\n   \n  randint randnum;\n  randint randmax;\n};\n\n \n\nstruct randint_source *\nrandint_new (struct randread_source *source)\n{\n  struct randint_source *s = xmalloc (sizeof *s);\n  s->source = source;\n  s->randnum = s->randmax = 0;\n  return s;\n}\n\n \n\nstruct randint_source *\nrandint_all_new (char const *name, size_t bytes_bound)\n{\n  struct randread_source *source = randread_new (name, bytes_bound);\n  return (source ? randint_new (source) : nullptr);\n}\n\n \n\nstruct randread_source *\nrandint_get_source (struct randint_source const *s)\n{\n  return s->source;\n}\n\n \nenum { HUGE_BYTES = RANDINT_MAX == UCHAR_MAX };\n\n \nstatic inline randint shift_left (randint x)\n{\n  return HUGE_BYTES ? 0 : x << CHAR_BIT;\n}\n\n\n \n\nrandint\nrandint_genmax (struct randint_source *s, randint genmax)\n{\n  struct randread_source *source = s->source;\n  randint randnum = s->randnum;\n  randint randmax = s->randmax;\n  randint choices = genmax + 1;\n\n  while (1)\n    {\n      if (randmax < genmax)\n        {\n           \n\n          size_t i = 0;\n          randint rmax = randmax;\n          unsigned char buf[sizeof randnum];\n\n          do\n            {\n              rmax = shift_left (rmax) + UCHAR_MAX;\n              i++;\n            }\n          while (rmax < genmax);\n\n          randread (source, buf, i);\n\n           \n\n          i = 0;\n\n          do\n            {\n              randnum = shift_left (randnum) + buf[i];\n              randmax = shift_left (randmax) + UCHAR_MAX;\n              i++;\n            }\n          while (randmax < genmax);\n        }\n\n      if (randmax == genmax)\n        {\n          s->randnum = s->randmax = 0;\n          return randnum;\n        }\n      else\n        {\n           \n\n          randint excess_choices = randmax - genmax;\n          randint unusable_choices = excess_choices % choices;\n          randint last_usable_choice = randmax - unusable_choices;\n          randint reduced_randnum = randnum % choices;\n\n          if (randnum <= last_usable_choice)\n            {\n              s->randnum = randnum / choices;\n              s->randmax = excess_choices / choices;\n              return reduced_randnum;\n            }\n\n           \n          randnum = reduced_randnum;\n          randmax = unusable_choices - 1;\n        }\n    }\n}\n\n \n\nvoid\nrandint_free (struct randint_source *s)\n{\n  explicit_bzero (s, sizeof *s);\n  free (s);\n}\n\n \n\nint\nrandint_all_free (struct randint_source *s)\n{\n  int r = randread_free (s->source);\n  int e = errno;\n  randint_free (s);\n  errno = e;\n  return r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}