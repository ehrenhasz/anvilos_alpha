{
  "module_name": "argmatch.c",
  "hash_id": "c678a302249d3ccd9c722799921df6370a59f742791a20f8fdf0973591bf9420",
  "original_prompt": "Ingested from coreutils-9.4/lib/argmatch.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"argmatch.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define _(msgid) gettext (msgid)\n\n#include \"error.h\"\n#include \"quotearg.h\"\n\n#if USE_UNLOCKED_IO\n# include \"unlocked-io.h\"\n#endif\n\n \n#ifndef ARGMATCH_QUOTING_STYLE\n# define ARGMATCH_QUOTING_STYLE locale_quoting_style\n#endif\n\n \n#ifndef ARGMATCH_DIE\n# include \"exitfail.h\"\n# define ARGMATCH_DIE exit (exit_failure)\n#endif\n\n#ifdef ARGMATCH_DIE_DECL\nARGMATCH_DIE_DECL;\n#endif\n\nstatic void\n__argmatch_die (void)\n{\n  ARGMATCH_DIE;\n}\n\n \nargmatch_exit_fn argmatch_die = __argmatch_die;\n\n\f\n \n\nptrdiff_t\nargmatch (const char *arg, const char *const *arglist,\n          const void *vallist, size_t valsize)\n{\n  size_t i;                      \n  size_t arglen;                 \n  ptrdiff_t matchind = -1;       \n  bool ambiguous = false;        \n\n  arglen = strlen (arg);\n\n   \n  for (i = 0; arglist[i]; i++)\n    {\n      if (!strncmp (arglist[i], arg, arglen))\n        {\n          if (strlen (arglist[i]) == arglen)\n             \n            return i;\n          else if (matchind == -1)\n             \n            matchind = i;\n          else\n            {\n               \n              if (vallist == NULL\n                  || memcmp ((char const *) vallist + valsize * matchind,\n                             (char const *) vallist + valsize * i, valsize))\n                {\n                   \n                  ambiguous = true;\n                }\n            }\n        }\n    }\n  if (ambiguous)\n    return -2;\n  else\n    return matchind;\n}\n\nptrdiff_t\nargmatch_exact (const char *arg, const char *const *arglist)\n{\n  size_t i;\n\n   \n  for (i = 0; arglist[i]; i++)\n    {\n      if (!strcmp (arglist[i], arg))\n        return i;\n    }\n\n  return -1;\n}\n\n \n\nvoid\nargmatch_invalid (const char *context, const char *value, ptrdiff_t problem)\n{\n  char const *format = (problem == -1\n                        ? _(\"invalid argument %s for %s\")\n                        : _(\"ambiguous argument %s for %s\"));\n\n  error (0, 0, format, quotearg_n_style (0, ARGMATCH_QUOTING_STYLE, value),\n         quote_n (1, context));\n}\n\n \nvoid\nargmatch_valid (const char *const *arglist,\n                const void *vallist, size_t valsize)\n{\n  size_t i;\n  const char *last_val = NULL;\n\n   \n  fputs (_(\"Valid arguments are:\"), stderr);\n  for (i = 0; arglist[i]; i++)\n    if ((i == 0)\n        || memcmp (last_val, (char const *) vallist + valsize * i, valsize))\n      {\n        fprintf (stderr, \"\\n  - %s\", quote (arglist[i]));\n        last_val = (char const *) vallist + valsize * i;\n      }\n    else\n      {\n        fprintf (stderr, \", %s\", quote (arglist[i]));\n      }\n  putc ('\\n', stderr);\n}\n\n \n\nptrdiff_t\n__xargmatch_internal (const char *context,\n                      const char *arg, const char *const *arglist,\n                      const void *vallist, size_t valsize,\n                      argmatch_exit_fn exit_fn,\n                      bool allow_abbreviation)\n{\n  ptrdiff_t res;\n\n  if (allow_abbreviation)\n    res = argmatch (arg, arglist, vallist, valsize);\n  else\n    res = argmatch_exact (arg, arglist);\n\n  if (res >= 0)\n     \n    return res;\n\n   \n  argmatch_invalid (context, arg, res);\n  argmatch_valid (arglist, vallist, valsize);\n  (*exit_fn) ();\n\n  return -1;  \n}\n\n \nconst char *\nargmatch_to_argument (const void *value,\n                      const char *const *arglist,\n                      const void *vallist, size_t valsize)\n{\n  size_t i;\n\n  for (i = 0; arglist[i]; i++)\n    if (!memcmp (value, (char const *) vallist + valsize * i, valsize))\n      return arglist[i];\n  return NULL;\n}\n\n#ifdef TEST\n \n\n \nenum backup_type\n{\n   \n  no_backups,\n\n   \n  simple_backups,\n\n   \n  numbered_existing_backups,\n\n   \n  numbered_backups\n};\n\n \nstatic const char *const backup_args[] =\n{\n  \"no\", \"none\", \"off\",\n  \"simple\", \"never\",\n  \"existing\", \"nil\",\n  \"numbered\", \"t\",\n  0\n};\n\nstatic const enum backup_type backup_vals[] =\n{\n  no_backups, no_backups, no_backups,\n  simple_backups, simple_backups,\n  numbered_existing_backups, numbered_existing_backups,\n  numbered_backups, numbered_backups\n};\n\nint\nmain (int argc, const char *const *argv)\n{\n  const char *cp;\n  enum backup_type backup_type = no_backups;\n\n  if (argc > 2)\n    {\n      fprintf (stderr, \"Usage: %s [VERSION_CONTROL]\\n\", getprogname ());\n      exit (1);\n    }\n\n  if ((cp = getenv (\"VERSION_CONTROL\")))\n    backup_type = XARGMATCH (\"$VERSION_CONTROL\", cp,\n                             backup_args, backup_vals);\n\n  if (argc == 2)\n    backup_type = XARGMATCH (getprogname (), argv[1],\n                             backup_args, backup_vals);\n\n  printf (\"The version control is '%s'\\n\",\n          ARGMATCH_TO_ARGUMENT (&backup_type, backup_args, backup_vals));\n\n  return 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}