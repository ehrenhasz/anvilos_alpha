{
  "module_name": "sha1.c",
  "hash_id": "8808f0bed0e3593462e1534df7f717b8b0d463efa1cc61135e8d9051930e3541",
  "original_prompt": "Ingested from coreutils-9.4/lib/sha1.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#if HAVE_OPENSSL_SHA1\n# define GL_OPENSSL_INLINE _GL_EXTERN_INLINE\n#endif\n#include \"sha1.h\"\n\n#include <stdint.h>\n#include <string.h>\n\n#include <byteswap.h>\n#ifdef WORDS_BIGENDIAN\n# define SWAP(n) (n)\n#else\n# define SWAP(n) bswap_32 (n)\n#endif\n\n#if ! HAVE_OPENSSL_SHA1\n\n \nstatic const unsigned char fillbuf[64] = { 0x80, 0   };\n\n\n \nvoid\nsha1_init_ctx (struct sha1_ctx *ctx)\n{\n  ctx->A = 0x67452301;\n  ctx->B = 0xefcdab89;\n  ctx->C = 0x98badcfe;\n  ctx->D = 0x10325476;\n  ctx->E = 0xc3d2e1f0;\n\n  ctx->total[0] = ctx->total[1] = 0;\n  ctx->buflen = 0;\n}\n\n \nstatic void\nset_uint32 (char *cp, uint32_t v)\n{\n  memcpy (cp, &v, sizeof v);\n}\n\n \nvoid *\nsha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)\n{\n  char *r = resbuf;\n  set_uint32 (r + 0 * sizeof ctx->A, SWAP (ctx->A));\n  set_uint32 (r + 1 * sizeof ctx->B, SWAP (ctx->B));\n  set_uint32 (r + 2 * sizeof ctx->C, SWAP (ctx->C));\n  set_uint32 (r + 3 * sizeof ctx->D, SWAP (ctx->D));\n  set_uint32 (r + 4 * sizeof ctx->E, SWAP (ctx->E));\n\n  return resbuf;\n}\n\n \nvoid *\nsha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)\n{\n   \n  uint32_t bytes = ctx->buflen;\n  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n\n   \n  ctx->total[0] += bytes;\n  if (ctx->total[0] < bytes)\n    ++ctx->total[1];\n\n   \n  ctx->buffer[size - 2] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n  ctx->buffer[size - 1] = SWAP (ctx->total[0] << 3);\n\n  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n\n   \n  sha1_process_block (ctx->buffer, size * 4, ctx);\n\n  return sha1_read_ctx (ctx, resbuf);\n}\n\n \nvoid *\nsha1_buffer (const char *buffer, size_t len, void *resblock)\n{\n  struct sha1_ctx ctx;\n\n   \n  sha1_init_ctx (&ctx);\n\n   \n  sha1_process_bytes (buffer, len, &ctx);\n\n   \n  return sha1_finish_ctx (&ctx, resblock);\n}\n\nvoid\nsha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n   \n  if (ctx->buflen != 0)\n    {\n      size_t left_over = ctx->buflen;\n      size_t add = 128 - left_over > len ? len : 128 - left_over;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n      ctx->buflen += add;\n\n      if (ctx->buflen > 64)\n        {\n          sha1_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n\n          ctx->buflen &= 63;\n           \n          memcpy (ctx->buffer,\n                  &((char *) ctx->buffer)[(left_over + add) & ~63],\n                  ctx->buflen);\n        }\n\n      buffer = (const char *) buffer + add;\n      len -= add;\n    }\n\n   \n  if (len >= 64)\n    {\n#if !(_STRING_ARCH_unaligned || _STRING_INLINE_unaligned)\n# define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)\n      if (UNALIGNED_P (buffer))\n        while (len > 64)\n          {\n            sha1_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n            buffer = (const char *) buffer + 64;\n            len -= 64;\n          }\n      else\n#endif\n        {\n          sha1_process_block (buffer, len & ~63, ctx);\n          buffer = (const char *) buffer + (len & ~63);\n          len &= 63;\n        }\n    }\n\n   \n  if (len > 0)\n    {\n      size_t left_over = ctx->buflen;\n\n      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n      left_over += len;\n      if (left_over >= 64)\n        {\n          sha1_process_block (ctx->buffer, 64, ctx);\n          left_over -= 64;\n           \n          memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n        }\n      ctx->buflen = left_over;\n    }\n}\n\n \n\n \n#define K1 0x5a827999\n#define K2 0x6ed9eba1\n#define K3 0x8f1bbcdc\n#define K4 0xca62c1d6\n\n \n#define F1(B,C,D) ( D ^ ( B & ( C ^ D ) ) )\n#define F2(B,C,D) (B ^ C ^ D)\n#define F3(B,C,D) ( ( B & C ) | ( D & ( B | C ) ) )\n#define F4(B,C,D) (B ^ C ^ D)\n\n \n\nvoid\nsha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)\n{\n  const uint32_t *words = buffer;\n  size_t nwords = len / sizeof (uint32_t);\n  const uint32_t *endp = words + nwords;\n  uint32_t x[16];\n  uint32_t a = ctx->A;\n  uint32_t b = ctx->B;\n  uint32_t c = ctx->C;\n  uint32_t d = ctx->D;\n  uint32_t e = ctx->E;\n  uint32_t lolen = len;\n\n   \n  ctx->total[0] += lolen;\n  ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);\n\n#define rol(x, n) (((x) << (n)) | ((uint32_t) (x) >> (32 - (n))))\n\n#define M(I) ( tm =   x[I&0x0f] ^ x[(I-14)&0x0f] \\\n                    ^ x[(I-8)&0x0f] ^ x[(I-3)&0x0f] \\\n               , (x[I&0x0f] = rol(tm, 1)) )\n\n#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\\n                                      + F( B, C, D )  \\\n                                      + K             \\\n                                      + M;            \\\n                                 B = rol( B, 30 );    \\\n                               } while(0)\n\n  while (words < endp)\n    {\n      uint32_t tm;\n      int t;\n      for (t = 0; t < 16; t++)\n        {\n          x[t] = SWAP (*words);\n          words++;\n        }\n\n      R( a, b, c, d, e, F1, K1, x[ 0] );\n      R( e, a, b, c, d, F1, K1, x[ 1] );\n      R( d, e, a, b, c, F1, K1, x[ 2] );\n      R( c, d, e, a, b, F1, K1, x[ 3] );\n      R( b, c, d, e, a, F1, K1, x[ 4] );\n      R( a, b, c, d, e, F1, K1, x[ 5] );\n      R( e, a, b, c, d, F1, K1, x[ 6] );\n      R( d, e, a, b, c, F1, K1, x[ 7] );\n      R( c, d, e, a, b, F1, K1, x[ 8] );\n      R( b, c, d, e, a, F1, K1, x[ 9] );\n      R( a, b, c, d, e, F1, K1, x[10] );\n      R( e, a, b, c, d, F1, K1, x[11] );\n      R( d, e, a, b, c, F1, K1, x[12] );\n      R( c, d, e, a, b, F1, K1, x[13] );\n      R( b, c, d, e, a, F1, K1, x[14] );\n      R( a, b, c, d, e, F1, K1, x[15] );\n      R( e, a, b, c, d, F1, K1, M(16) );\n      R( d, e, a, b, c, F1, K1, M(17) );\n      R( c, d, e, a, b, F1, K1, M(18) );\n      R( b, c, d, e, a, F1, K1, M(19) );\n      R( a, b, c, d, e, F2, K2, M(20) );\n      R( e, a, b, c, d, F2, K2, M(21) );\n      R( d, e, a, b, c, F2, K2, M(22) );\n      R( c, d, e, a, b, F2, K2, M(23) );\n      R( b, c, d, e, a, F2, K2, M(24) );\n      R( a, b, c, d, e, F2, K2, M(25) );\n      R( e, a, b, c, d, F2, K2, M(26) );\n      R( d, e, a, b, c, F2, K2, M(27) );\n      R( c, d, e, a, b, F2, K2, M(28) );\n      R( b, c, d, e, a, F2, K2, M(29) );\n      R( a, b, c, d, e, F2, K2, M(30) );\n      R( e, a, b, c, d, F2, K2, M(31) );\n      R( d, e, a, b, c, F2, K2, M(32) );\n      R( c, d, e, a, b, F2, K2, M(33) );\n      R( b, c, d, e, a, F2, K2, M(34) );\n      R( a, b, c, d, e, F2, K2, M(35) );\n      R( e, a, b, c, d, F2, K2, M(36) );\n      R( d, e, a, b, c, F2, K2, M(37) );\n      R( c, d, e, a, b, F2, K2, M(38) );\n      R( b, c, d, e, a, F2, K2, M(39) );\n      R( a, b, c, d, e, F3, K3, M(40) );\n      R( e, a, b, c, d, F3, K3, M(41) );\n      R( d, e, a, b, c, F3, K3, M(42) );\n      R( c, d, e, a, b, F3, K3, M(43) );\n      R( b, c, d, e, a, F3, K3, M(44) );\n      R( a, b, c, d, e, F3, K3, M(45) );\n      R( e, a, b, c, d, F3, K3, M(46) );\n      R( d, e, a, b, c, F3, K3, M(47) );\n      R( c, d, e, a, b, F3, K3, M(48) );\n      R( b, c, d, e, a, F3, K3, M(49) );\n      R( a, b, c, d, e, F3, K3, M(50) );\n      R( e, a, b, c, d, F3, K3, M(51) );\n      R( d, e, a, b, c, F3, K3, M(52) );\n      R( c, d, e, a, b, F3, K3, M(53) );\n      R( b, c, d, e, a, F3, K3, M(54) );\n      R( a, b, c, d, e, F3, K3, M(55) );\n      R( e, a, b, c, d, F3, K3, M(56) );\n      R( d, e, a, b, c, F3, K3, M(57) );\n      R( c, d, e, a, b, F3, K3, M(58) );\n      R( b, c, d, e, a, F3, K3, M(59) );\n      R( a, b, c, d, e, F4, K4, M(60) );\n      R( e, a, b, c, d, F4, K4, M(61) );\n      R( d, e, a, b, c, F4, K4, M(62) );\n      R( c, d, e, a, b, F4, K4, M(63) );\n      R( b, c, d, e, a, F4, K4, M(64) );\n      R( a, b, c, d, e, F4, K4, M(65) );\n      R( e, a, b, c, d, F4, K4, M(66) );\n      R( d, e, a, b, c, F4, K4, M(67) );\n      R( c, d, e, a, b, F4, K4, M(68) );\n      R( b, c, d, e, a, F4, K4, M(69) );\n      R( a, b, c, d, e, F4, K4, M(70) );\n      R( e, a, b, c, d, F4, K4, M(71) );\n      R( d, e, a, b, c, F4, K4, M(72) );\n      R( c, d, e, a, b, F4, K4, M(73) );\n      R( b, c, d, e, a, F4, K4, M(74) );\n      R( a, b, c, d, e, F4, K4, M(75) );\n      R( e, a, b, c, d, F4, K4, M(76) );\n      R( d, e, a, b, c, F4, K4, M(77) );\n      R( c, d, e, a, b, F4, K4, M(78) );\n      R( b, c, d, e, a, F4, K4, M(79) );\n\n      a = ctx->A += a;\n      b = ctx->B += b;\n      c = ctx->C += c;\n      d = ctx->D += d;\n      e = ctx->E += e;\n    }\n}\n\n#endif\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}