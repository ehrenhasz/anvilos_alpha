{
  "module_name": "frexp.c",
  "hash_id": "c10380b1cc9debced92dbfefc40e932ecef3bf9882e7bf2380f35f3e44410d26",
  "original_prompt": "Ingested from coreutils-9.4/lib/frexp.c",
  "human_readable_source": " \n\n#if ! defined USE_LONG_DOUBLE\n# include <config.h>\n#endif\n\n \n#include <math.h>\n\n#include <float.h>\n#ifdef USE_LONG_DOUBLE\n# include \"isnanl-nolibm.h\"\n# include \"fpucw.h\"\n#else\n# include \"isnand-nolibm.h\"\n#endif\n\n \n\n#ifdef USE_LONG_DOUBLE\n# define FUNC frexpl\n# define DOUBLE long double\n# define ISNAN isnanl\n# define DECL_ROUNDING DECL_LONG_DOUBLE_ROUNDING\n# define BEGIN_ROUNDING() BEGIN_LONG_DOUBLE_ROUNDING ()\n# define END_ROUNDING() END_LONG_DOUBLE_ROUNDING ()\n# define L_(literal) literal##L\n#else\n# define FUNC frexp\n# define DOUBLE double\n# define ISNAN isnand\n# define DECL_ROUNDING\n# define BEGIN_ROUNDING()\n# define END_ROUNDING()\n# define L_(literal) literal\n#endif\n\nDOUBLE\nFUNC (DOUBLE x, int *expptr)\n{\n  int sign;\n  int exponent;\n  DECL_ROUNDING\n\n   \n  if (ISNAN (x) || x + x == x)\n    {\n      *expptr = 0;\n      return x;\n    }\n\n  sign = 0;\n  if (x < 0)\n    {\n      x = - x;\n      sign = -1;\n    }\n\n  BEGIN_ROUNDING ();\n\n  {\n     \n    DOUBLE pow2[64];  \n    DOUBLE powh[64];  \n    int i;\n\n    exponent = 0;\n    if (x >= L_(1.0))\n      {\n         \n        DOUBLE pow2_i;  \n        DOUBLE powh_i;  \n\n         \n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x >= pow2_i)\n              {\n                exponent += (1 << i);\n                x *= powh_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n         \n        while (i > 0 && x < pow2[i - 1])\n          {\n            i--;\n            powh_i = powh[i];\n          }\n        exponent += (1 << i);\n        x *= powh_i;\n         \n      }\n    else\n      {\n         \n        DOUBLE pow2_i;  \n        DOUBLE powh_i;  \n\n         \n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x < powh_i)\n              {\n                exponent -= (1 << i);\n                x *= pow2_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n         \n      }\n\n     \n    while (i > 0)\n      {\n        i--;\n        if (x < powh[i])\n          {\n            exponent -= (1 << i);\n            x *= pow2[i];\n          }\n      }\n     \n  }\n\n  if (sign < 0)\n    x = - x;\n\n  END_ROUNDING ();\n\n  *expptr = exponent;\n  return x;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}