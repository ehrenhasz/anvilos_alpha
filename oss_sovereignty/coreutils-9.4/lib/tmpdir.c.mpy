{
  "module_name": "tmpdir.c",
  "hash_id": "ebf41d121aa08f8700a31f3c6eb6a271a25fba38cd4258411136d9998f66238e",
  "original_prompt": "Ingested from coreutils-9.4/lib/tmpdir.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"tmpdir.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <errno.h>\n#ifndef __set_errno\n# define __set_errno(Val) errno = (Val)\n#endif\n\n#include <stdio.h>\n#ifndef P_tmpdir\n# ifdef _P_tmpdir  \n#  define P_tmpdir _P_tmpdir\n# else\n#  define P_tmpdir \"/tmp\"\n# endif\n#endif\n\n#include <sys/stat.h>\n\n#if defined _WIN32 && ! defined __CYGWIN__\n# define WIN32_LEAN_AND_MEAN   \n# include <windows.h>\n#endif\n\n#include \"pathmax.h\"\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n# undef GetTempPath\n# define GetTempPath GetTempPathA\n#endif\n\n#if _LIBC\n# define struct_stat64 struct stat64\n#else\n# define struct_stat64 struct stat\n# define __libc_secure_getenv secure_getenv\n# define __xstat64(version, path, buf) stat (path, buf)\n#endif\n\n \n#if defined _WIN32 || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n   \n# define ISSLASH(C) ((C) == '/' || (C) == '\\\\')\n#else\n   \n# define ISSLASH(C) ((C) == '/')\n#endif\n\n\n \nstatic bool\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}\n\n \nint\npath_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n             bool try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n  bool add_slash;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __libc_secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n          ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n#if defined _WIN32 && ! defined __CYGWIN__\n      char dirbuf[PATH_MAX];\n      DWORD retval;\n\n       \n      retval = GetTempPath (PATH_MAX, dirbuf);\n      if (retval > 0 && retval < PATH_MAX && direxists (dirbuf))\n        dir = dirbuf;\n      else\n#endif\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n#ifdef __VMS\n  add_slash = 0;\n#else\n  add_slash = dlen != 0 && !ISSLASH (dir[dlen - 1]);\n#endif\n\n   \n  if (tmpl_len < dlen + add_slash + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  memcpy (tmpl, dir, dlen);\n  sprintf (tmpl + dlen, &\"/%.*sXXXXXX\"[!add_slash], (int) plen, pfx);\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}