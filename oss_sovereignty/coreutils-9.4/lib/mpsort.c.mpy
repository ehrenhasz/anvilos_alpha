{
  "module_name": "mpsort.c",
  "hash_id": "84b16527ac9f55ba332a30104963a6daa6d214005614e228b086c1c3d2e0e0d2",
  "original_prompt": "Ingested from coreutils-9.4/lib/mpsort.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"mpsort.h\"\n\n#include <string.h>\n\n \n\ntypedef int (*comparison_function) (void const *, void const *);\n\nstatic void mpsort_with_tmp (void const **restrict, size_t,\n                             void const **restrict, comparison_function);\n\n \n\nstatic void\nmpsort_into_tmp (void const **restrict base, size_t n,\n                 void const **restrict tmp,\n                 comparison_function cmp)\n{\n  size_t n1 = n / 2;\n  size_t n2 = n - n1;\n  size_t a = 0;\n  size_t alim = n1;\n  size_t b = n1;\n  size_t blim = n;\n  void const *ba;\n  void const *bb;\n\n  mpsort_with_tmp (base + n1, n2, tmp, cmp);\n  mpsort_with_tmp (base, n1, tmp, cmp);\n\n  ba = base[a];\n  bb = base[b];\n\n  for (;;)\n    if (cmp (ba, bb) <= 0)\n      {\n        *tmp++ = ba;\n        a++;\n        if (a == alim)\n          {\n            a = b;\n            alim = blim;\n            break;\n          }\n        ba = base[a];\n      }\n    else\n      {\n        *tmp++ = bb;\n        b++;\n        if (b == blim)\n          break;\n        bb = base[b];\n      }\n\n  memcpy (tmp, base + a, (alim - a) * sizeof *base);\n}\n\n \n\nstatic void\nmpsort_with_tmp (void const **restrict base, size_t n,\n                 void const **restrict tmp,\n                 comparison_function cmp)\n{\n  if (n <= 2)\n    {\n      if (n == 2)\n        {\n          void const *p0 = base[0];\n          void const *p1 = base[1];\n          if (! (cmp (p0, p1) <= 0))\n            {\n              base[0] = p1;\n              base[1] = p0;\n            }\n        }\n    }\n  else\n    {\n      size_t n1 = n / 2;\n      size_t n2 = n - n1;\n      size_t i;\n      size_t t = 0;\n      size_t tlim = n1;\n      size_t b = n1;\n      size_t blim = n;\n      void const *bb;\n      void const *tt;\n\n      mpsort_with_tmp (base + n1, n2, tmp, cmp);\n\n      if (n1 < 2)\n        tmp[0] = base[0];\n      else\n        mpsort_into_tmp (base, n1, tmp, cmp);\n\n      tt = tmp[t];\n      bb = base[b];\n\n      for (i = 0; ; )\n        if (cmp (tt, bb) <= 0)\n          {\n            base[i++] = tt;\n            t++;\n            if (t == tlim)\n              break;\n            tt = tmp[t];\n          }\n        else\n          {\n            base[i++] = bb;\n            b++;\n            if (b == blim)\n              {\n                memcpy (base + i, tmp + t, (tlim - t) * sizeof *base);\n                break;\n              }\n            bb = base[b];\n          }\n    }\n}\n\n \n\nvoid\nmpsort (void const **base, size_t n, comparison_function cmp)\n{\n  mpsort_with_tmp (base, n, base + n, cmp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}