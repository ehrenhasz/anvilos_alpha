{
  "module_name": "test-lock.c",
  "hash_id": "654ffb16081ab5eda299465cbef579f73b3c1aa0d68dbcaf6ff2aa871dcb29c0",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-lock.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#if USE_ISOC_THREADS || USE_POSIX_THREADS || USE_ISOC_AND_POSIX_THREADS || USE_WINDOWS_THREADS\n\n#if USE_ISOC_THREADS\n# define TEST_ISOC_THREADS 1\n#endif\n#if USE_POSIX_THREADS\n# define TEST_POSIX_THREADS 1\n#endif\n#if USE_ISOC_AND_POSIX_THREADS\n# define TEST_ISOC_AND_POSIX_THREADS 1\n#endif\n#if USE_WINDOWS_THREADS\n# define TEST_WINDOWS_THREADS 1\n#endif\n\n \n#define ENABLE_LOCKING 1\n\n \n#define DO_TEST_LOCK 1\n#define DO_TEST_RWLOCK 1\n#define DO_TEST_RECURSIVE_LOCK 1\n#define DO_TEST_ONCE 1\n\n \n#define EXPLICIT_YIELD 1\n\n \n#define ENABLE_DEBUGGING 0\n\n \n#define THREAD_COUNT 10\n\n \n#define REPEAT_COUNT 50000\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if !ENABLE_LOCKING\n# undef USE_ISOC_THREADS\n# undef USE_POSIX_THREADS\n# undef USE_ISOC_AND_POSIX_THREADS\n# undef USE_WINDOWS_THREADS\n#endif\n#include \"glthread/lock.h\"\n\n#if !ENABLE_LOCKING\n# if TEST_ISOC_THREADS\n#  define USE_ISOC_THREADS 1\n# endif\n# if TEST_POSIX_THREADS\n#  define USE_POSIX_THREADS 1\n# endif\n# if TEST_ISOC_AND_POSIX_THREADS\n#  define USE_ISOC_AND_POSIX_THREADS 1\n# endif\n# if TEST_WINDOWS_THREADS\n#  define USE_WINDOWS_THREADS 1\n# endif\n#endif\n\n#include \"glthread/thread.h\"\n#include \"glthread/yield.h\"\n\n#if HAVE_DECL_ALARM\n# include <signal.h>\n# include <unistd.h>\n#endif\n\n#include \"atomic-int-gnulib.h\"\n\n#if ENABLE_DEBUGGING\n# define dbgprintf printf\n#else\n# define dbgprintf if (0) printf\n#endif\n\n#if EXPLICIT_YIELD\n# define yield() gl_thread_yield ()\n#else\n# define yield()\n#endif\n\n#define ACCOUNT_COUNT 4\n\nstatic int account[ACCOUNT_COUNT];\n\nstatic int\nrandom_account (void)\n{\n  return ((unsigned int) rand () >> 3) % ACCOUNT_COUNT;\n}\n\nstatic void\ncheck_accounts (void)\n{\n  int i, sum;\n\n  sum = 0;\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    sum += account[i];\n  if (sum != ACCOUNT_COUNT * 1000)\n    abort ();\n}\n\n\n \n\n \n\ngl_lock_define_initialized(static, my_lock)\n\nstatic void *\nlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic struct atomic_int lock_checker_done;\n\nstatic void *\nlock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&lock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_lock_lock (my_lock);\n      check_accounts ();\n      gl_lock_unlock (my_lock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n   \n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&lock_checker_done);\n  set_atomic_int_value (&lock_checker_done, 0);\n\n   \n  checkerthread = gl_thread_create (lock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (lock_mutator_thread, NULL);\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  set_atomic_int_value (&lock_checker_done, 1);\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}\n\n\n \n\n \n\ngl_rwlock_define_initialized(static, my_rwlock)\n\nstatic void *\nrwlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before wrlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_wrlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  wrlock\\n\", gl_thread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic struct atomic_int rwlock_checker_done;\n\nstatic void *\nrwlock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&rwlock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check rdlock\\n\", gl_thread_self_pointer ());\n      gl_rwlock_rdlock (my_rwlock);\n      check_accounts ();\n      gl_rwlock_unlock (my_rwlock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_rwlock (void)\n{\n  int i;\n  gl_thread_t checkerthreads[THREAD_COUNT];\n  gl_thread_t threads[THREAD_COUNT];\n\n   \n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&rwlock_checker_done);\n  set_atomic_int_value (&rwlock_checker_done, 0);\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    checkerthreads[i] = gl_thread_create (rwlock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (rwlock_mutator_thread, NULL);\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  set_atomic_int_value (&rwlock_checker_done, 1);\n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (checkerthreads[i], NULL);\n  check_accounts ();\n}\n\n\n \n\n \n\ngl_recursive_lock_define_initialized(static, my_reclock)\n\nstatic void\nrecshuffle (void)\n{\n  int i1, i2, value;\n\n  dbgprintf (\"Mutator %p before lock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_lock (my_reclock);\n  dbgprintf (\"Mutator %p after  lock\\n\", gl_thread_self_pointer ());\n\n  i1 = random_account ();\n  i2 = random_account ();\n  value = ((unsigned int) rand () >> 3) % 10;\n  account[i1] += value;\n  account[i2] -= value;\n\n   \n  if (((unsigned int) rand () >> 3) % 2)\n    recshuffle ();\n\n  dbgprintf (\"Mutator %p before unlock\\n\", gl_thread_self_pointer ());\n  gl_recursive_lock_unlock (my_reclock);\n  dbgprintf (\"Mutator %p after  unlock\\n\", gl_thread_self_pointer ());\n}\n\nstatic void *\nreclock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      recshuffle ();\n\n      dbgprintf (\"Mutator %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic struct atomic_int reclock_checker_done;\n\nstatic void *\nreclock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&reclock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", gl_thread_self_pointer ());\n      gl_recursive_lock_lock (my_reclock);\n      check_accounts ();\n      gl_recursive_lock_unlock (my_reclock);\n      dbgprintf (\"Checker %p after  check unlock\\n\", gl_thread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_recursive_lock (void)\n{\n  int i;\n  gl_thread_t checkerthread;\n  gl_thread_t threads[THREAD_COUNT];\n\n   \n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&reclock_checker_done);\n  set_atomic_int_value (&reclock_checker_done, 0);\n\n   \n  checkerthread = gl_thread_create (reclock_checker_thread, NULL);\n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] = gl_thread_create (reclock_mutator_thread, NULL);\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n  set_atomic_int_value (&reclock_checker_done, 1);\n  gl_thread_join (checkerthread, NULL);\n  check_accounts ();\n}\n\n\n \n\n \n\ngl_once_define(static, fresh_once)\nstatic int ready[THREAD_COUNT];\nstatic gl_lock_t ready_lock[THREAD_COUNT];\n#if ENABLE_LOCKING\nstatic gl_rwlock_t fire_signal[REPEAT_COUNT];\n#else\nstatic volatile int fire_signal_state;\n#endif\nstatic gl_once_t once_control;\nstatic int performed;\ngl_lock_define_initialized(static, performed_lock)\n\nstatic void\nonce_execute (void)\n{\n  gl_lock_lock (performed_lock);\n  performed++;\n  gl_lock_unlock (performed_lock);\n}\n\nstatic void *\nonce_contender_thread (void *arg)\n{\n  int id = (int) (intptr_t) arg;\n  int repeat;\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n       \n      gl_lock_lock (ready_lock[id]);\n      ready[id] = 1;\n      gl_lock_unlock (ready_lock[id]);\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n      dbgprintf (\"Contender %p waiting for signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n#if ENABLE_LOCKING\n       \n      gl_rwlock_rdlock (fire_signal[repeat]);\n       \n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n       \n      while (fire_signal_state <= repeat)\n        yield ();\n#endif\n      dbgprintf (\"Contender %p got the     signal for round %d\\n\",\n                 gl_thread_self_pointer (), repeat);\n\n       \n      gl_once (once_control, once_execute);\n    }\n\n  return NULL;\n}\n\nstatic void\ntest_once (void)\n{\n  int i, repeat;\n  gl_thread_t threads[THREAD_COUNT];\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    {\n      ready[i] = 0;\n      gl_lock_init (ready_lock[i]);\n    }\n#if ENABLE_LOCKING\n  for (i = 0; i < REPEAT_COUNT; i++)\n    gl_rwlock_init (fire_signal[i]);\n#else\n  fire_signal_state = 0;\n#endif\n\n#if ENABLE_LOCKING\n   \n  for (i = REPEAT_COUNT-1; i >= 0; i--)\n    gl_rwlock_wrlock (fire_signal[i]);\n#endif\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    threads[i] =\n      gl_thread_create (once_contender_thread, (void *) (intptr_t) i);\n\n  for (repeat = 0; repeat <= REPEAT_COUNT; repeat++)\n    {\n       \n      dbgprintf (\"Main thread before synchronizing for round %d\\n\", repeat);\n      for (;;)\n        {\n          int ready_count = 0;\n          for (i = 0; i < THREAD_COUNT; i++)\n            {\n              gl_lock_lock (ready_lock[i]);\n              ready_count += ready[i];\n              gl_lock_unlock (ready_lock[i]);\n            }\n          if (ready_count == THREAD_COUNT)\n            break;\n          yield ();\n        }\n      dbgprintf (\"Main thread after  synchronizing for round %d\\n\", repeat);\n\n      if (repeat > 0)\n        {\n           \n          if (performed != 1)\n            abort ();\n        }\n\n      if (repeat == REPEAT_COUNT)\n        break;\n\n       \n      memcpy (&once_control, &fresh_once, sizeof (gl_once_t));\n\n       \n      performed = 0;\n\n       \n      for (i = 0; i < THREAD_COUNT; i++)\n        {\n          gl_lock_lock (ready_lock[i]);\n          ready[i] = 0;\n          gl_lock_unlock (ready_lock[i]);\n        }\n\n       \n      dbgprintf (\"Main thread giving signal for round %d\\n\", repeat);\n#if ENABLE_LOCKING\n      gl_rwlock_unlock (fire_signal[repeat]);\n#else\n      fire_signal_state = repeat + 1;\n#endif\n    }\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    gl_thread_join (threads[i], NULL);\n}\n\n\n \n\nint\nmain ()\n{\n#if HAVE_DECL_ALARM\n   \n  int alarm_value = 600;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n#if DO_TEST_LOCK\n  printf (\"Starting test_lock ...\"); fflush (stdout);\n  test_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RWLOCK\n  printf (\"Starting test_rwlock ...\"); fflush (stdout);\n  test_rwlock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RECURSIVE_LOCK\n  printf (\"Starting test_recursive_lock ...\"); fflush (stdout);\n  test_recursive_lock ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_ONCE\n  printf (\"Starting test_once ...\"); fflush (stdout);\n  test_once ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}\n\n#else\n\n \n\n#include <stdio.h>\n\nint\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}