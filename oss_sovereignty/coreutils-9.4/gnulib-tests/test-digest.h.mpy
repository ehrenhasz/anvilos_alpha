{
  "module_name": "test-digest.h",
  "hash_id": "26a8932157f3ad3f612855feeccf9862339a42883762d914c92c90b224db1f4b",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-digest.h",
  "human_readable_source": " \n            break;\n          case 2:\n             \n            fputs (\"ABCD\", fp);\n            FALLTHROUGH;\n          case 1:\n             \n            fputs (\"The quick brown fox jumps over the lazy dog.\\n\", fp);\n            break;\n          case 4:\n             \n            fputs (\"ABCD\", fp);\n            FALLTHROUGH;\n          case 3:\n             \n            {\n              unsigned int i;\n              for (i = 0; i < 0x400000; i++)\n                {\n                  unsigned char c[2];\n                  unsigned int j = i * (i-1) * (i-5);\n                  c[0] = (unsigned char)(j >> 6);\n                  c[1] = (i % 499) + (i % 101);\n                  fwrite (c, 1, 2, fp);\n                }\n            }\n            break;\n          }\n        if (ferror (fp))\n          {\n            fprintf (stderr, \"Could not write data to file %s.\\n\", TESTFILE);\n            exit (1);\n          }\n        fclose (fp);\n      }\n      {\n         \n        char *digest = (char *) malloc (digest_size + 1) + 1;\n        const void *expected;\n        FILE *fp;\n        int ret;\n\n        switch (pass)\n          {\n          case 0:         expected = expected_for_empty_file; break;\n          case 1: case 2: expected = expected_for_small_file; break;\n          case 3: case 4: expected = expected_for_large_file; break;\n          default: abort ();\n          }\n\n        fp = fopen (TESTFILE, \"rb\");\n        if (fp == NULL)\n          {\n            fprintf (stderr, \"Could not open file %s.\\n\", TESTFILE);\n            exit (1);\n          }\n        switch (pass)\n          {\n          case 2:\n          case 4:\n            {\n              char header[4];\n              if (fread (header, 1, sizeof (header), fp) != sizeof (header))\n                {\n                  fprintf (stderr, \"Could not read the header of %s.\\n\",\n                           TESTFILE);\n                  exit (1);\n                }\n            }\n            break;\n          }\n        ret = streamfunc (fp, digest);\n        if (ret)\n          {\n            fprintf (stderr, \"%s failed with error %d\\n\", streamfunc_name, -ret);\n            exit (1);\n          }\n        if (memcmp (digest, expected, digest_size) != 0)\n          {\n            size_t i;\n            fprintf (stderr, \"%s produced wrong result.\\n\", streamfunc_name);\n            fprintf (stderr, \"Expected: \");\n            for (i = 0; i < digest_size; i++)\n              fprintf (stderr, \"\\\\x%02x\", ((const unsigned char *) expected)[i]);\n            fprintf (stderr, \"\\n\");\n            fprintf (stderr, \"Got:      \");\n            for (i = 0; i < digest_size; i++)\n              fprintf (stderr, \"\\\\x%02x\", ((const unsigned char *) digest)[i]);\n            fprintf (stderr, \"\\n\");\n            exit (1);\n          }\n         \n        if (getc (fp) != EOF)\n          {\n            fprintf (stderr, \"%s left the stream not at EOF\\n\", streamfunc_name);\n            exit (1);\n          }\n        fclose (fp);\n        free (digest - 1);\n      }\n    }\n\n  unlink (TESTFILE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}