{
  "module_name": "test-chr.h",
  "hash_id": "cba4da8e31340c5361fdcbb69262c41f1a502b145fa6d23984f205c2ae3834ba",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/unistr/test-chr.h",
  "human_readable_source": " \n\nint\nmain (void)\n{\n  size_t size = 0x100000;\n  size_t i;\n  size_t length;\n  UNIT *input;\n  uint32_t *input32 = (uint32_t *) malloc (size * sizeof (uint32_t));\n  ASSERT (input32);\n\n  input32[0] = 'a';\n  input32[1] = 'b';\n  u32_set (input32 + 2, 'c', 1024);\n  for (i = 1026; i < size - 2; i += 63)\n    {\n      size_t last = i + 63 < size - 2 ? i + 63 : size - 2;\n      ucs4_t uc = 'd' | (i - 1026);\n      if (uc >= 0xd800 && uc <= 0xdfff)\n        uc |= 0x100000;\n      u32_set (input32 + i, uc, last - i);\n    }\n\n  input32[size - 2] = 'e';\n  input32[size - 1] = 'a';\n\n  input = U32_TO_U (input32, size, NULL, &length);\n  ASSERT (input);\n\n   \n  ASSERT (U_CHR (input, length, 'a') == input);\n\n  ASSERT (U_CHR (input, 0, 'a') == NULL);\n  void *page_boundary = zerosize_ptr ();\n  if (page_boundary)\n    ASSERT (U_CHR (page_boundary, 0, 'a') == NULL);\n\n  ASSERT (U_CHR (input, length, 'b') == input + 1);\n  ASSERT (U_CHR (input, length, 'c') == input + 2);\n  ASSERT (U_CHR (input, length, 'd') == input + 1026);\n\n  {\n    UNIT *exp = input + 1026;\n    UNIT *prev = input + 1;\n    for (i = 1026; i < size - 2; i += 63)\n      {\n        UNIT c[6];\n        size_t n;\n        ucs4_t uc = 'd' | (i - 1026);\n        if (uc >= 0xd800 && uc <= 0xdfff)\n          uc |= 0x100000;\n        n = U_UCTOMB (c, uc, 6);\n        ASSERT (exp < input + length - 1);\n        ASSERT (U_CHR (prev, (length - 1) - (prev - input), uc) == exp);\n        ASSERT (memcmp (exp, c, n * sizeof (UNIT)) == 0);\n        prev = exp;\n        exp += n * 63;\n      }\n  }\n\n  ASSERT (U_CHR (input + 1, length - 1, 'a') == input + length - 1);\n  ASSERT (U_CHR (input + 1, length - 1, 'e') == input + length - 2);\n\n  ASSERT (U_CHR (input, length, 'f') == NULL);\n  ASSERT (U_CHR (input, length, '\\0') == NULL);\n\n   \n  {\n    size_t repeat = 10000;\n    for (; repeat > 0; repeat--)\n      {\n        ASSERT (U_CHR (input, length, 'c') == input + 2);\n      }\n  }\n\n   \n  {\n    int i, j;\n    for (i = 0; i < 32; i++)\n      {\n        for (j = 0; j < 128; j++)\n          input[i + j] = j;\n        for (j = 0; j < 128; j++)\n          {\n            ASSERT (U_CHR (input + i, 128, j) == input + i + j);\n          }\n      }\n  }\n\n   \n  {\n    char *page_boundary = (char *) zerosize_ptr ();\n    size_t n;\n\n    if (page_boundary != NULL)\n      {\n        for (n = 1; n <= 500 / sizeof (UNIT); n++)\n          {\n            UNIT *mem = (UNIT *) (page_boundary - n * sizeof (UNIT));\n            U_SET (mem, 'X', n);\n            ASSERT (U_CHR (mem, n, 'U') == NULL);\n\n            {\n              size_t i;\n\n              for (i = 0; i < n; i++)\n                {\n                  mem[i] = 'U';\n                  ASSERT (U_CHR (mem, 4000, 'U') == mem + i);\n                  mem[i] = 'X';\n                }\n            }\n          }\n      }\n  }\n\n  free (input);\n  if (sizeof (UNIT) != sizeof (uint32_t))\n    free (input32);\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}