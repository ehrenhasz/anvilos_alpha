{
  "module_name": "test-getcwd.c",
  "hash_id": "479e66d5562155285d398d4b372f7de98c9567ac0ad78d3809966fad037ef5cf",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-getcwd.c",
  "human_readable_source": " \n#define TARGET_LEN (5 * 1024)\n\n#if defined HAVE_OPENAT || (defined GNULIB_OPENAT && defined HAVE_FDOPENDIR)\n# define HAVE_OPENAT_SUPPORT 1\n#else\n# define HAVE_OPENAT_SUPPORT 0\n#endif\n\n \nstatic int\ntest_abort_bug (void)\n{\n  char *cwd;\n  size_t initial_cwd_len;\n  int fail = 0;\n\n   \n#ifdef PATH_MAX\n  int bug_possible = PATH_MAX < getpagesize ();\n#else\n  int bug_possible = 0;\n#endif\n  if (! bug_possible)\n    return 0;\n\n  cwd = getcwd (NULL, 0);\n  if (cwd == NULL)\n    return 2;\n\n  initial_cwd_len = strlen (cwd);\n  free (cwd);\n\n  if (HAVE_OPENAT_SUPPORT)\n    {\n      static char const dir_name[] = \"confdir-14B---\";\n      size_t desired_depth = ((TARGET_LEN - 1 - initial_cwd_len)\n                              / sizeof dir_name);\n      size_t d;\n      for (d = 0; d < desired_depth; d++)\n        {\n          if (mkdir (dir_name, S_IRWXU) < 0 || chdir (dir_name) < 0)\n            {\n              if (! (errno == ERANGE || errno == ENAMETOOLONG\n                     || errno == ENOENT))\n                fail = 3;  \n              break;\n            }\n        }\n\n       \n      cwd = getcwd (NULL, 0);\n      if (cwd == NULL)\n        fail = 4;  \n      free (cwd);\n\n       \n      rmdir (dir_name);\n      while (0 < d--)\n        {\n          if (chdir (\"..\") < 0)\n            {\n              fail = 5;\n              break;\n            }\n          rmdir (dir_name);\n        }\n    }\n\n  return fail;\n}\n\n \n#define DIR_NAME \"confdir3\"\n#define DIR_NAME_LEN 8\n#define DIR_NAME_SIZE (DIR_NAME_LEN + 1)\n\n \n#define DOTDOTSLASH_LEN 3\n\n \n#define BUF_SLOP 20\n\n \nstatic int\ntest_long_name (void)\n{\n#ifndef PATH_MAX\n   \n  return 0;\n#elif ((INT_MAX / (DIR_NAME_SIZE / DOTDOTSLASH_LEN + 1) \\\n        - DIR_NAME_SIZE - BUF_SLOP) \\\n       <= PATH_MAX)\n   \n  return 0;\n#else\n   \n  if (is_running_under_qemu_user ())\n    return 77;\n\n  char buf[PATH_MAX * (DIR_NAME_SIZE / DOTDOTSLASH_LEN + 1)\n           + DIR_NAME_SIZE + BUF_SLOP];\n  char *cwd = getcwd (buf, PATH_MAX);\n  size_t initial_cwd_len;\n  size_t cwd_len;\n  int fail = 0;\n  size_t n_chdirs = 0;\n\n  if (cwd == NULL)\n    return 1;\n\n  cwd_len = initial_cwd_len = strlen (cwd);\n\n  while (1)\n    {\n# ifdef HAVE_GETCWD_SHORTER\n       \n      size_t dotdot_max = PATH_MAX * 2;\n# else\n      size_t dotdot_max = PATH_MAX * (DIR_NAME_SIZE / DOTDOTSLASH_LEN);\n# endif\n      char *c = NULL;\n\n      cwd_len += DIR_NAME_SIZE;\n       \n      if (mkdir (DIR_NAME, S_IRWXU) < 0 || chdir (DIR_NAME) < 0)\n        {\n          if (! (errno == ERANGE || errno == ENAMETOOLONG || errno == ENOENT))\n            #ifdef __linux__\n            if (! (errno == EINVAL))\n            #endif\n              fail = 2;\n          break;\n        }\n\n      if (PATH_MAX <= cwd_len && cwd_len < PATH_MAX + DIR_NAME_SIZE)\n        {\n          c = getcwd (buf, PATH_MAX);\n          if (!c && errno == ENOENT)\n            {\n              fail = 3;\n              break;\n            }\n          if (c)\n            {\n              fail = 4;\n              break;\n            }\n          if (! (errno == ERANGE || errno == ENAMETOOLONG))\n            {\n              fail = 5;\n              break;\n            }\n        }\n\n      if (dotdot_max <= cwd_len - initial_cwd_len)\n        {\n          if (dotdot_max + DIR_NAME_SIZE < cwd_len - initial_cwd_len)\n            break;\n          c = getcwd (buf, cwd_len + 1);\n          if (!c)\n            {\n              if (! (errno == ERANGE || errno == ENOENT\n                     || errno == ENAMETOOLONG))\n                {\n                  fail = 6;\n                  break;\n                }\n              if (HAVE_OPENAT_SUPPORT || errno == ERANGE || errno == ENOENT)\n                {\n                  fail = 7;\n                  break;\n                }\n            }\n        }\n\n      if (c && strlen (c) != cwd_len)\n        {\n          fail = 8;\n          break;\n        }\n      ++n_chdirs;\n    }\n\n   \n  {\n    size_t i;\n\n     \n    rmdir (DIR_NAME);\n    for (i = 0; i <= n_chdirs; i++)\n      {\n        if (chdir (\"..\") < 0)\n          break;\n        if (rmdir (DIR_NAME) != 0)\n          break;\n      }\n  }\n\n  return fail;\n#endif\n}\n\nint\nmain (int argc, char **argv)\n{\n  int err1 = test_abort_bug ();\n  int err2 = test_long_name ();\n  return err1 * 10 + (err1 != 0 && err2 == 77 ? 0 : err2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}