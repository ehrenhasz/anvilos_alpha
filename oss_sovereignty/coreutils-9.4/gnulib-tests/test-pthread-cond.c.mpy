{
  "module_name": "test-pthread-cond.c",
  "hash_id": "913f32da64a4b16e20c028380cc0135476f8d0e2e4f657f45ae690625ae4652e",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-pthread-cond.c",
  "human_readable_source": " \n#define DO_TEST_COND 1\n#define DO_TEST_TIMEDCOND 1\n\n \n#define EXPLICIT_YIELD 1\n\n \n#define ENABLE_DEBUGGING 0\n\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/time.h>\n\n#if EXPLICIT_YIELD\n# include <sched.h>\n#endif\n\n#if HAVE_DECL_ALARM\n# include <signal.h>\n# include <unistd.h>\n#endif\n\n#include \"macros.h\"\n\n#if ENABLE_DEBUGGING\n# define dbgprintf printf\n#else\n# define dbgprintf if (0) printf\n#endif\n\n#if EXPLICIT_YIELD\n# define yield() sched_yield ()\n#else\n# define yield()\n#endif\n\n\n \nstatic int cond_value = 0;\nstatic pthread_cond_t condtest;\nstatic pthread_mutex_t lockcond;\n\nstatic void *\npthread_cond_wait_routine (void *arg)\n{\n  ASSERT (pthread_mutex_lock (&lockcond) == 0);\n  while (!cond_value)\n    {\n      ASSERT (pthread_cond_wait (&condtest, &lockcond) == 0);\n    }\n  ASSERT (pthread_mutex_unlock (&lockcond) == 0);\n\n  cond_value = 2;\n\n  return NULL;\n}\n\nstatic void\ntest_pthread_cond_wait ()\n{\n  struct timespec remain;\n  pthread_t thread;\n  int ret;\n\n  remain.tv_sec = 2;\n  remain.tv_nsec = 0;\n\n  cond_value = 0;\n\n  ASSERT (pthread_create (&thread, NULL, pthread_cond_wait_routine, NULL) == 0);\n  do\n    {\n      yield ();\n      ret = nanosleep (&remain, &remain);\n      ASSERT (ret >= -1);\n    }\n  while (ret == -1 && (remain.tv_sec != 0 || remain.tv_nsec != 0));\n\n   \n  ASSERT (pthread_mutex_lock (&lockcond) == 0);\n  cond_value = 1;\n  ASSERT (pthread_cond_signal (&condtest) == 0);\n  ASSERT (pthread_mutex_unlock (&lockcond) == 0);\n\n  ASSERT (pthread_join (thread, NULL) == 0);\n\n  if (cond_value != 2)\n    abort ();\n}\n\n\n \nstatic int cond_timeout;\n\nstatic void\nget_ts (struct timespec *ts)\n{\n  struct timeval now;\n\n  gettimeofday (&now, NULL);\n\n  ts->tv_sec = now.tv_sec + 1;\n  ts->tv_nsec = now.tv_usec * 1000;\n}\n\nstatic void *\npthread_cond_timedwait_routine (void *arg)\n{\n  int ret;\n  struct timespec ts;\n\n  ASSERT (pthread_mutex_lock (&lockcond) == 0);\n  while (!cond_value)\n    {\n      get_ts (&ts);\n      ret = pthread_cond_timedwait (&condtest, &lockcond, &ts);\n      if (ret == ETIMEDOUT)\n        cond_timeout = 1;\n    }\n  ASSERT (pthread_mutex_unlock (&lockcond) == 0);\n\n  return NULL;\n}\n\nstatic void\ntest_pthread_cond_timedwait (void)\n{\n  struct timespec remain;\n  pthread_t thread;\n  int ret;\n\n  remain.tv_sec = 2;\n  remain.tv_nsec = 0;\n\n  cond_value = cond_timeout = 0;\n\n  ASSERT (pthread_create (&thread, NULL, pthread_cond_timedwait_routine, NULL)\n          == 0);\n  do\n    {\n      yield ();\n      ret = nanosleep (&remain, &remain);\n      ASSERT (ret >= -1);\n    }\n  while (ret == -1 && (remain.tv_sec != 0 || remain.tv_nsec != 0));\n\n   \n  ASSERT (pthread_mutex_lock (&lockcond) == 0);\n  cond_value = 1;\n  ASSERT (pthread_cond_signal (&condtest) == 0);\n  ASSERT (pthread_mutex_unlock (&lockcond) == 0);\n\n  ASSERT (pthread_join (thread, NULL) == 0);\n\n  if (!cond_timeout)\n    abort ();\n}\n\nint\nmain ()\n{\n#if HAVE_DECL_ALARM\n   \n  int alarm_value = 600;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  ASSERT (pthread_cond_init (&condtest, NULL) == 0);\n\n  {\n    pthread_mutexattr_t attr;\n\n    ASSERT (pthread_mutexattr_init (&attr) == 0);\n    ASSERT (pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_NORMAL) == 0);\n    ASSERT (pthread_mutex_init (&lockcond, &attr) == 0);\n    ASSERT (pthread_mutexattr_destroy (&attr) == 0);\n  }\n\n#if DO_TEST_COND\n  printf (\"Starting test_pthread_cond_wait ...\"); fflush (stdout);\n  test_pthread_cond_wait ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_TIMEDCOND\n  printf (\"Starting test_pthread_cond_timedwait ...\"); fflush (stdout);\n  test_pthread_cond_timedwait ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}\n\n#else\n\n \n\n#include <stdio.h>\n\nint\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}