{
  "module_name": "test-memset_explicit.c",
  "hash_id": "c8bad5c43418912d0771cbf060dec5f528108f7067604fd05046267b64b83fa1",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-memset_explicit.c",
  "human_readable_source": " \n \n\n#include <config.h>\n\n \n#include <string.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (memset_explicit, void *, (void *, int, size_t));\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include \"vma-iter.h\"\n#include \"macros.h\"\n\n#define SECRET \"xyzzy1729\"\n#define SECRET_SIZE 9\n\nstatic char zero[SECRET_SIZE] = { 0 };\n\n \n#if 0\n# define memset_explicit(a, c, n)  memset (a, c, n)\n#endif\n\n \n\nstatic char stbuf[SECRET_SIZE];\n\nstatic void\ntest_static (void)\n{\n  memcpy (stbuf, SECRET, SECRET_SIZE);\n  memset_explicit (stbuf, 0, SECRET_SIZE);\n  ASSERT (memcmp (zero, stbuf, SECRET_SIZE) == 0);\n  for (int i = 1; i <= UCHAR_MAX; i++)\n    {\n      char checkbuf[SECRET_SIZE];\n      memset (checkbuf, i, SECRET_SIZE);\n      memcpy (stbuf, SECRET, SECRET_SIZE);\n      memset_explicit (stbuf, i, SECRET_SIZE);\n      ASSERT (memcmp (checkbuf, stbuf, SECRET_SIZE) == 0);\n    }\n}\n\n \n\n \n#if VMA_ITERATE_SUPPORTED\n\nstruct locals\n{\n  uintptr_t range_start;\n  uintptr_t range_end;\n};\n\nstatic int\nvma_iterate_callback (void *data, uintptr_t start, uintptr_t end,\n                      unsigned int flags)\n{\n  struct locals *lp = (struct locals *) data;\n\n   \n  if (start <= lp->range_start && end > lp->range_start)\n    lp->range_start = (end < lp->range_end ? end : lp->range_end);\n  if (start < lp->range_end && end >= lp->range_end)\n    lp->range_end = (start > lp->range_start ? start : lp->range_start);\n\n  return 0;\n}\n\nstatic bool\nis_range_mapped (uintptr_t range_start, uintptr_t range_end)\n{\n  struct locals l;\n\n  l.range_start = range_start;\n  l.range_end = range_end;\n  vma_iterate (vma_iterate_callback, &l);\n  return l.range_start == l.range_end;\n}\n\n#else\n\nstatic bool\nis_range_mapped (uintptr_t range_start, uintptr_t range_end)\n{\n  return true;\n}\n\n#endif\n\nstatic void\ntest_heap (void)\n{\n  char *heapbuf = (char *) malloc (SECRET_SIZE);\n  ASSERT (heapbuf);\n  uintptr_t volatile addr = (uintptr_t) heapbuf;\n  memcpy (heapbuf, SECRET, SECRET_SIZE);\n  memset_explicit (heapbuf, 0, SECRET_SIZE);\n  free (heapbuf);\n  heapbuf = (char *) addr;\n  if (is_range_mapped (addr, addr + SECRET_SIZE))\n    {\n       \n      ASSERT (memcmp (heapbuf, SECRET, SECRET_SIZE) != 0);\n      printf (\"test_heap: address range is still mapped after free().\\n\");\n    }\n  else\n    printf (\"test_heap: address range is unmapped after free().\\n\");\n}\n\n \n\n \nstatic bool _GL_ATTRIBUTE_NOINLINE\ndo_secret_stuff (int volatile pass, char *volatile *volatile last_stackbuf)\n{\n  char stackbuf[SECRET_SIZE];\n  if (pass == 1)\n    {\n      memcpy (stackbuf, SECRET, SECRET_SIZE);\n      memset_explicit (stackbuf, 0, SECRET_SIZE);\n      *last_stackbuf = stackbuf;\n      return false;\n    }\n  else  \n    {\n       \n      return memcmp (zero, *last_stackbuf, SECRET_SIZE) != 0;\n    }\n}\n\nstatic void\ntest_stack (void)\n{\n  int count = 0;\n  int repeat;\n  char *volatile last_stackbuf;\n\n  for (repeat = 2 * 1000; repeat > 0; repeat--)\n    {\n       \n      if ((repeat % 2) == 0)\n        do_secret_stuff (1, &last_stackbuf);\n      else\n        count += do_secret_stuff (2, &last_stackbuf);\n    }\n   \n  printf (\"test_stack: count = %d\\n\", count);\n  ASSERT (count < 50);\n}\n\n \n\nint\nmain ()\n{\n  test_static ();\n  test_heap ();\n  test_stack ();\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}