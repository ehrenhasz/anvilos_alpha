{
  "module_name": "test-dup-safer.c",
  "hash_id": "13218b9c4b5d60ef4fcc518821df58ec194e7f9872e41038ea11f1838aeaef2a",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-dup-safer.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"unistd--.h\"\n\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"binary-io.h\"\n#include \"cloexec.h\"\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n \n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n#endif\n\n#if !O_BINARY\n# define set_binary_mode(f,m) zero ()\nstatic int zero (void) { return 0; }\n#endif\n\n \n\n#define BACKUP_STDERR_FILENO 10\n#define ASSERT_STREAM myerr\n#include \"macros.h\"\n\nstatic FILE *myerr;\n\n \nstatic bool\nis_open (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}\n\n \nstatic bool\nis_inheritable (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}\n\n \nstatic bool\nis_mode (int fd, int mode)\n{\n  int value = set_binary_mode (fd, O_BINARY);\n  set_binary_mode (fd, value);\n  return mode == value;\n}\n\n#define witness \"test-dup-safer.txt\"\n\nint\nmain (void)\n{\n  int i;\n  int fd;\n  int bad_fd = getdtablesize ();\n\n   \n  if (dup2 (STDERR_FILENO, BACKUP_STDERR_FILENO) != BACKUP_STDERR_FILENO\n      || (myerr = fdopen (BACKUP_STDERR_FILENO, \"w\")) == NULL)\n    return 2;\n\n   \n  fd = creat (witness, 0600);\n  ASSERT (STDERR_FILENO < fd);\n\n   \n  for (i = -1; i <= STDERR_FILENO; i++)\n    {\n      if (0 <= i)\n        ASSERT (close (i) == 0);\n\n       \n      errno = 0;\n      ASSERT (dup (-1) == -1);\n      ASSERT (errno == EBADF);\n      errno = 0;\n      ASSERT (dup (bad_fd) == -1);\n      ASSERT (errno == EBADF);\n      close (fd + 1);\n      errno = 0;\n      ASSERT (dup (fd + 1) == -1);\n      ASSERT (errno == EBADF);\n\n       \n      set_binary_mode (fd, O_BINARY);\n      ASSERT (dup (fd) == fd + 1);\n      ASSERT (is_open (fd + 1));\n      ASSERT (is_inheritable (fd + 1));\n      ASSERT (is_mode (fd + 1, O_BINARY));\n\n      ASSERT (close (fd + 1) == 0);\n      set_binary_mode (fd, O_TEXT);\n      ASSERT (dup (fd) == fd + 1);\n      ASSERT (is_open (fd + 1));\n      ASSERT (is_inheritable (fd + 1));\n      ASSERT (is_mode (fd + 1, O_TEXT));\n\n       \n      ASSERT (close (fd + 1) == 0);\n      ASSERT (fd_safer_flag (dup_cloexec (fd), O_CLOEXEC) == fd + 1);\n      ASSERT (set_cloexec_flag (fd + 1, true) == 0);\n      ASSERT (is_open (fd + 1));\n      ASSERT (!is_inheritable (fd + 1));\n      ASSERT (close (fd) == 0);\n\n       \n      ASSERT (dup (fd + 1) == fd);\n      ASSERT (is_open (fd));\n      ASSERT (is_inheritable (fd));\n      ASSERT (close (fd + 1) == 0);\n    }\n\n   \n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (witness) == 0);\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}