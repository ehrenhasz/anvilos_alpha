{
  "module_name": "test-pipe2.c",
  "hash_id": "e27c48f5a1f6200f84e667711714432b35c875e9b3a74b8913ee727ff41b4d1b",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-pipe2.c",
  "human_readable_source": " \n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n \n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n#endif\n\n#include \"binary-io.h\"\n#include \"macros.h\"\n#if GNULIB_NONBLOCKING\n# include \"nonblocking.h\"\n#endif\n\n \nstatic bool\nis_open (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}\n\n \nstatic bool\nis_cloexec (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  ASSERT (GetHandleInformation (h, &flags));\n  return (flags & HANDLE_FLAG_INHERIT) == 0;\n#else\n  int flags;\n  ASSERT ((flags = fcntl (fd, F_GETFD)) >= 0);\n  return (flags & FD_CLOEXEC) != 0;\n#endif\n}\n\n#if ! GNULIB_NONBLOCKING\nstatic int\nget_nonblocking_flag (int fd)\n{\n# if defined _WIN32 && ! defined __CYGWIN__\n  return 0;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  int flags;\n  ASSERT ((flags = fcntl (fd, F_GETFL)) >= 0);\n  return (flags & O_NONBLOCK) != 0;\n# endif\n}\n#endif\n\nint\nmain ()\n{\n  int use_nonblocking;\n  int use_cloexec;\n\n  for (use_nonblocking = 0; use_nonblocking <= !!O_NONBLOCK; use_nonblocking++)\n    for (use_cloexec = 0; use_cloexec <= !!O_CLOEXEC; use_cloexec++)\n      {\n        int o_flags;\n        int fd[2];\n\n        o_flags = 0;\n        if (use_nonblocking)\n          o_flags |= O_NONBLOCK;\n        if (use_cloexec)\n          o_flags |= O_CLOEXEC;\n\n        fd[0] = -1;\n        fd[1] = -1;\n        ASSERT (pipe2 (fd, o_flags) >= 0);\n        ASSERT (fd[0] >= 0);\n        ASSERT (fd[1] >= 0);\n        ASSERT (fd[0] != fd[1]);\n        ASSERT (is_open (fd[0]));\n        ASSERT (is_open (fd[1]));\n        if (use_cloexec)\n          {\n            ASSERT (is_cloexec (fd[0]));\n            ASSERT (is_cloexec (fd[1]));\n          }\n        else\n          {\n            ASSERT (!is_cloexec (fd[0]));\n            ASSERT (!is_cloexec (fd[1]));\n          }\n        if (use_nonblocking)\n          {\n            ASSERT (get_nonblocking_flag (fd[0]) == 1);\n            ASSERT (get_nonblocking_flag (fd[1]) == 1);\n          }\n        else\n          {\n            ASSERT (get_nonblocking_flag (fd[0]) == 0);\n            ASSERT (get_nonblocking_flag (fd[1]) == 0);\n          }\n\n        ASSERT (close (fd[0]) == 0);\n        ASSERT (close (fd[1]) == 0);\n      }\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}