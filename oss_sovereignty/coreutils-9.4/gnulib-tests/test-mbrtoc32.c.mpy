{
  "module_name": "test-mbrtoc32.c",
  "hash_id": "dccba4a396c531d6972294f7f41f14f096c68e2dbd778dbb6cf7e4ba685834c1",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-mbrtoc32.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <uchar.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (mbrtoc32, size_t,\n                 (char32_t *, const char *, size_t, mbstate_t *));\n\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"macros.h\"\n\nint\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  char32_t wc;\n  size_t ret;\n\n   \n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n   \n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (char32_t) 0xBADFACE;\n    ret = mbrtoc32 (&wc, \"x\", 0, &state);\n    ASSERT (ret == (size_t)(-2));\n    ASSERT (mbsinit (&state));\n  }\n\n   \n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (char32_t) 0xBADFACE;\n    ret = mbrtoc32 (&wc, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n    ret = mbrtoc32 (NULL, \"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n   \n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n           \n          ASSERT (c < 0x80);\n           \n          buf[0] = c;\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == c);\n          ASSERT (mbsinit (&state));\n\n          ret = mbrtoc32 (NULL, buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n\n          break;\n        default:\n          break;\n        }\n  }\n\n   \n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    wc = (char32_t) 0xBADFACE;\n    ret = mbrtoc32 (&wc, NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (char32_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n  }\n\n#ifdef __ANDROID__\n   \n  if (argc > 1 && strcmp (argv[1], \"1\") == 0 && MB_CUR_MAX > 1)\n    argv[1] = \"3\";\n#endif\n\n  if (argc > 1)\n    switch (argv[1][0])\n      {\n      case '1':\n         \n        {\n          int c;\n          char buf[1];\n\n          memset (&state, '\\0', sizeof (mbstate_t));\n          for (c = 0; c < 0x100; c++)\n            if (c != 0)\n              {\n                 \n                buf[0] = c;\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, buf, 1, &state);\n                 \n                ASSERT (ret == 1);\n                if (c < 0x80)\n                   \n                  ASSERT (wc == c);\n                else\n                   \n                  ASSERT (wc == (btoc32 (c) == 0xDF00 + c ? btoc32 (c) : c));\n                ASSERT (mbsinit (&state));\n\n                ret = mbrtoc32 (NULL, buf, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (mbsinit (&state));\n              }\n        }\n        return 0;\n\n      case '2':\n         \n        {\n          char input[] = \"B\\374\\337er\";  \n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'B');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 1, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (c32tob (wc) == (unsigned char) '\\374');\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x00FC);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n\n           \n          ret = mbrtoc32 (NULL, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 2, 3, &state);\n          ASSERT (ret == 1);\n          ASSERT (c32tob (wc) == (unsigned char) '\\337');\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x00DF);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 3, 2, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'e');\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 4, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 'r');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '3':\n         \n        {\n          char input[] = \"s\\303\\274\\303\\237\\360\\237\\230\\213!\";  \n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 's');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (char32_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 2, 7, &state);\n          ASSERT (ret == 1);\n          ASSERT (c32tob (wc) == EOF);\n          ASSERT (wc == 0x00FC);  \n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n           \n          ret = mbrtoc32 (NULL, input + 3, 6, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 3, 6, &state);\n          ASSERT (ret == 2);\n          ASSERT (c32tob (wc) == EOF);\n          ASSERT (wc == 0x00DF);  \n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n\n           \n          ret = mbrtoc32 (NULL, input + 5, 4, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 5, 4, &state);\n          ASSERT (ret == 4);\n          ASSERT (c32tob (wc) == EOF);\n          ASSERT (wc == 0x1F60B);  \n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n          input[6] = '\\0';\n          input[7] = '\\0';\n          input[8] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 9, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '!');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '4':\n         \n        {\n          char input[] = \"<\\306\\374\\313\\334\\270\\354>\";  \n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '<');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 1, 2, &state);\n          ASSERT (ret == 2);\n          ASSERT (c32tob (wc) == EOF);\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x65E5);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[1] = '\\0';\n          input[2] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 3, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (char32_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[3] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 4, 4, &state);\n          ASSERT (ret == 1);\n          ASSERT (c32tob (wc) == EOF);\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x672C);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[4] = '\\0';\n\n           \n          ret = mbrtoc32 (NULL, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (mbsinit (&state));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 5, 3, &state);\n          ASSERT (ret == 2);\n          ASSERT (c32tob (wc) == EOF);\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x8A9E);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 7, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '>');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n\n      case '5':\n         \n        #if (defined __GLIBC__ && __GLIBC__ == 2 && __GLIBC_MINOR__ >= 13 && __GLIBC_MINOR__ <= 15) || (GL_CHAR32_T_IS_UNICODE && (defined __NetBSD__ || defined __sun))\n        fputs (\"Skipping test: The GB18030 converter in this system's iconv is broken.\\n\", stderr);\n        return 77;\n        #endif\n        {\n          char input[] = \"s\\250\\271\\201\\060\\211\\070\\224\\071\\375\\067!\";  \n          memset (&state, '\\0', sizeof (mbstate_t));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == 's');\n          ASSERT (mbsinit (&state));\n          input[0] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 1, 1, &state);\n          ASSERT (ret == (size_t)(-2));\n          ASSERT (wc == (char32_t) 0xBADFACE);\n          ASSERT (!mbsinit (&state));\n          input[1] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 2, 9, &state);\n          ASSERT (ret == 1);\n          ASSERT (c32tob (wc) == EOF);\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x00FC);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[2] = '\\0';\n\n           \n          ret = mbrtoc32 (NULL, input + 3, 8, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 3, 8, &state);\n          ASSERT (ret == 4);\n          ASSERT (c32tob (wc) == EOF);\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x00DF);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[3] = '\\0';\n          input[4] = '\\0';\n          input[5] = '\\0';\n          input[6] = '\\0';\n\n           \n          ret = mbrtoc32 (NULL, input + 7, 4, &state);\n          ASSERT (ret == 4);\n          ASSERT (mbsinit (&state));\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 7, 4, &state);\n          ASSERT (ret == 4);\n          ASSERT (c32tob (wc) == EOF);\n          #if GL_CHAR32_T_IS_UNICODE\n          ASSERT (wc == 0x1F60B);  \n          #endif\n          ASSERT (mbsinit (&state));\n          input[7] = '\\0';\n          input[8] = '\\0';\n          input[9] = '\\0';\n          input[10] = '\\0';\n\n          wc = (char32_t) 0xBADFACE;\n          ret = mbrtoc32 (&wc, input + 11, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (wc == '!');\n          ASSERT (mbsinit (&state));\n        }\n        return 0;\n      }\n\n  return 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}