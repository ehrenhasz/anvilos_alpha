{
  "module_name": "test-mbsrtoc32s.c",
  "hash_id": "395a729a842e5d39028bed5f4b855c66249495f0b782c6ed3bffc397e5fe6012",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-mbsrtoc32s.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <uchar.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (mbsrtoc32s, size_t,\n                 (char32_t *, const char **, size_t, mbstate_t *));\n\n#include <locale.h>\n#include <stdio.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"macros.h\"\n\nint\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  char32_t wc;\n  size_t ret;\n\n   \n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n   \n  {\n    const char *src;\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n\n    src = \"\";\n    ret = mbsrtoc32s (NULL, &src, 0, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n\n    src = \"\";\n    ret = mbsrtoc32s (NULL, &src, 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n\n    wc = (char32_t) 0xBADFACE;\n    src = \"\";\n    ret = mbsrtoc32s (&wc, &src, 0, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (char32_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n\n    wc = (char32_t) 0xBADFACE;\n    src = \"\";\n    ret = mbsrtoc32s (&wc, &src, 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n#ifdef __ANDROID__\n   \n  if (argc > 1 && strcmp (argv[1], \"1\") == 0 && MB_CUR_MAX > 1)\n    argv[1] = \"3\";\n#endif\n\n  if (argc > 1)\n    {\n      int unlimited;\n\n      for (unlimited = 0; unlimited < 2; unlimited++)\n        {\n          #define BUFSIZE 10\n          char32_t buf[BUFSIZE];\n          const char *src;\n          mbstate_t temp_state;\n\n          {\n            size_t i;\n            for (i = 0; i < BUFSIZE; i++)\n              buf[i] = (char32_t) 0xBADFACE;\n          }\n\n          switch (argv[1][0])\n            {\n            case '1':\n               \n              {\n                char input[] = \"n/a\";\n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                src = input;\n                temp_state = state;\n                ret = mbsrtoc32s (NULL, &src, unlimited ? BUFSIZE : 1, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input);\n                ASSERT (mbsinit (&state));\n\n                src = input;\n                ret = mbsrtoc32s (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                ASSERT (ret == (unlimited ? 3 : 1));\n                ASSERT (src == (unlimited ? NULL : input + 1));\n                ASSERT (buf[0] == 'n');\n                if (unlimited)\n                  {\n                    ASSERT (buf[1] == '/');\n                    ASSERT (buf[2] == 'a');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (char32_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[1] == (char32_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              {\n                int c;\n                char input[2];\n\n                memset (&state, '\\0', sizeof (mbstate_t));\n                for (c = 0; c < 0x100; c++)\n                  if (c != 0)\n                    {\n                       \n                      input[0] = c;\n                      input[1] = '\\0';\n\n                      src = input;\n                      ret = mbsrtoc32s (NULL, &src, unlimited ? BUFSIZE : 1, &state);\n                      ASSERT (ret == 1);\n                      ASSERT (src == input);\n                      ASSERT (mbsinit (&state));\n\n                      buf[0] = buf[1] = (char32_t) 0xBADFACE;\n                      src = input;\n                      ret = mbsrtoc32s (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                       \n                      ASSERT (ret == 1);\n                      ASSERT (src == (unlimited ? NULL : input + 1));\n                      if (c < 0x80)\n                         \n                        ASSERT (buf[0] == c);\n                      else\n                         \n                        ASSERT (buf[0] == (btoc32 (c) == 0xDF00 + c ? btoc32 (c) : c));\n                      ASSERT (mbsinit (&state));\n                    }\n              }\n              break;\n\n            case '2':\n               \n              {\n                char input[] = \"B\\374\\337er\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input + 1, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (c32tob (wc) == (unsigned char) '\\374');\n                ASSERT (mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtoc32s (NULL, &src, unlimited ? BUFSIZE : 1, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input + 2);\n                ASSERT (mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtoc32s (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                ASSERT (ret == (unlimited ? 3 : 1));\n                ASSERT (src == (unlimited ? NULL : input + 3));\n                ASSERT (c32tob (buf[0]) == (unsigned char) '\\337');\n                if (unlimited)\n                  {\n                    ASSERT (buf[1] == 'e');\n                    ASSERT (buf[2] == 'r');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (char32_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[1] == (char32_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '3':\n               \n              {\n                char input[] = \"s\\303\\274\\303\\237\\360\\237\\230\\213!\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 's');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input + 1, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (char32_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtoc32s (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 4);\n                ASSERT (src == input + 2);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtoc32s (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 4 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 5));\n                ASSERT (c32tob (buf[0]) == EOF);\n                ASSERT (c32tob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == 0x1F60B);  \n                    ASSERT (buf[3] == '!');\n                    ASSERT (buf[4] == 0);\n                    ASSERT (buf[5] == (char32_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (char32_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '4':\n               \n              {\n                char input[] = \"<\\306\\374\\313\\334\\270\\354>\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == '<');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input + 1, 2, &state);\n                ASSERT (ret == 2);\n                ASSERT (c32tob (wc) == EOF);\n                ASSERT (mbsinit (&state));\n                input[1] = '\\0';\n                input[2] = '\\0';\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input + 3, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (char32_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[3] = '\\0';\n\n                src = input + 4;\n                temp_state = state;\n                ret = mbsrtoc32s (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input + 4);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 4;\n                ret = mbsrtoc32s (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 3 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 7));\n                ASSERT (c32tob (buf[0]) == EOF);\n                ASSERT (c32tob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == '>');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (char32_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (char32_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '5':\n               \n              #if (defined __GLIBC__ && __GLIBC__ == 2 && __GLIBC_MINOR__ >= 13 && __GLIBC_MINOR__ <= 15) || (GL_CHAR32_T_IS_UNICODE && (defined __NetBSD__ || defined __sun))\n              fputs (\"Skipping test: The GB18030 converter in this system's iconv is broken.\\n\", stderr);\n              return 77;\n              #endif\n              {\n                char input[] = \"s\\250\\271\\201\\060\\211\\070\\224\\071\\375\\067!\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 's');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (char32_t) 0xBADFACE;\n                ret = mbrtoc32 (&wc, input + 1, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (char32_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtoc32s (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 4);\n                ASSERT (src == input + 2);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtoc32s (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 4 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 7));\n                ASSERT (c32tob (buf[0]) == EOF);\n                ASSERT (c32tob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (c32tob (buf[2]) == EOF);\n                    ASSERT (buf[3] == '!');\n                    ASSERT (buf[4] == 0);\n                    ASSERT (buf[5] == (char32_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (char32_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            default:\n              return 1;\n            }\n        }\n\n      return 0;\n    }\n\n  return 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}