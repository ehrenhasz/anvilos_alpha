{
  "module_name": "test-readutmp.c",
  "hash_id": "57c92d18d5a1f4f5e7130425a90d58feb0d91c5471ce45dc60f7e1acca37848c",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-readutmp.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"readutmp.h\"\n\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"idx.h\"\n#include \"xalloc.h\"\n\n#define ELEMENT STRUCT_UTMP\n#define COMPARE(entry1, entry2) \\\n  _GL_CMP (UT_TIME_MEMBER (entry1), UT_TIME_MEMBER (entry2))\n#define STATIC static\n#include \"array-mergesort.h\"\n\n#include \"macros.h\"\n\nint\nmain (int argc, char *argv[])\n{\n  STRUCT_UTMP *entries;\n  idx_t num_entries;\n\n  if (read_utmp (UTMP_FILE, &num_entries, &entries, 0) < 0)\n    {\n      #if READ_UTMP_SUPPORTED\n      fprintf (stderr, \"Skipping test: cannot open %s\\n\", UTMP_FILE);\n      #else\n      fprintf (stderr, \"Skipping test: neither <utmpx.h> nor <utmp.h> is available\\n\");\n      #endif\n      return 77;\n    }\n\n  printf (\"Here are the read_utmp results.\\n\");\n  printf (\"Flags: B = Boot, U = User Process\\n\");\n  printf (\"\\n\");\n  printf (\"                                                              Termi\u2010      Flags\\n\");\n  printf (\"    Time (GMT)             User          Device        PID    nation Exit  B U  Host\\n\");\n  printf (\"------------------- ------------------ ----------- ---------- ------ ----  - -  ----\\n\");\n\n   \n  if (num_entries > 0)\n    {\n       \n      merge_sort_inplace (entries, num_entries,\n                          XNMALLOC (num_entries, STRUCT_UTMP));\n\n      idx_t boot_time_count = 0;\n      idx_t i;\n      for (i = 0; i < num_entries; i++)\n        {\n          const STRUCT_UTMP *entry = &entries[i];\n\n          char *user = extract_trimmed_name (entry);\n          const char *device = entry->ut_line;\n          long pid = UT_PID (entry);\n          int termination = UT_EXIT_E_TERMINATION (entry);\n          int exit = UT_EXIT_E_EXIT (entry);\n          const char *host = entry->ut_host;\n\n          time_t tim = UT_TIME_MEMBER (entry);\n          struct tm *gmt = gmtime (&tim);\n          char timbuf[100];\n          if (gmt == NULL\n              || strftime (timbuf, sizeof (timbuf), \"%Y-%m-%d %H:%M:%S\", gmt)\n                 == 0)\n            strcpy (timbuf, \"---\");\n\n          printf (\"%-19s %-18s %-11s %10ld %4d   %3d   %c %c  %s\\n\",\n                  timbuf,\n                  user,\n                  device,\n                  pid,\n                  termination,\n                  exit,\n                  UT_TYPE_BOOT_TIME (entry) ? 'X' : ' ',\n                  UT_TYPE_USER_PROCESS (entry) ? 'X' : ' ',\n                  host);\n\n          if (UT_TYPE_BOOT_TIME (entry))\n            boot_time_count++;\n        }\n      fflush (stdout);\n\n       \n      time_t first = UT_TIME_MEMBER (&entries[0]);\n      time_t last = UT_TIME_MEMBER (&entries[num_entries - 1]);\n      time_t now = time (NULL);\n      ASSERT (first >= now - 157680000);\n      ASSERT (last <= now + 604800);\n\n       \n      ASSERT (boot_time_count <= 1);\n\n       \n      ASSERT (boot_time_count >= 1);\n    }\n\n  free (entries);\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}