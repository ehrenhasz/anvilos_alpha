{
  "module_name": "test-strerror_r.c",
  "hash_id": "97d45fecb935039eeaf0eca33ee40b7ef987127d2b25cb9c085d622fca026484",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-strerror_r.c",
  "human_readable_source": " \n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (EACCES, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (ETIMEDOUT, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n  errno = 0;\n  buf[0] = '\\0';\n  ASSERT (strerror_r (EOVERFLOW, buf, sizeof buf) == 0);\n  ASSERT (buf[0] != '\\0');\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n   \n  errno = 0;\n  buf[0] = '\\0';\n  ret = strerror_r (0, buf, sizeof buf);\n  ASSERT (ret == 0);\n  ASSERT (buf[0]);\n  ASSERT (errno == 0);\n  ASSERT (strstr (buf, \"nknown\") == NULL);\n  ASSERT (strstr (buf, \"ndefined\") == NULL);\n\n   \n  errno = 0;\n  buf[0] = '^';\n  ret = strerror_r (-3, buf, sizeof buf);\n  ASSERT (ret == 0 || ret == EINVAL);\n  ASSERT (buf[0] != '^');\n  ASSERT (*buf);\n  ASSERT (errno == 0);\n  ASSERT (strlen (buf) < sizeof buf);\n\n   \n  {\n    int errs[] = { EACCES, 0, -3, };\n    int j;\n\n    buf[sizeof buf - 1] = '\\0';\n    for (j = 0; j < SIZEOF (errs); j++)\n      {\n        int err = errs[j];\n        char buf2[sizeof buf] = \"\";\n        size_t len;\n        size_t i;\n\n        strerror_r (err, buf2, sizeof buf2);\n        len = strlen (buf2);\n        ASSERT (len < sizeof buf);\n\n        for (i = 0; i <= len; i++)\n          {\n            memset (buf, '^', sizeof buf - 1);\n            errno = 0;\n            ret = strerror_r (err, buf, i);\n            ASSERT (errno == 0);\n            if (j == 2)\n              ASSERT (ret == ERANGE || ret == EINVAL);\n            else\n              ASSERT (ret == ERANGE);\n            if (i)\n              {\n                ASSERT (strncmp (buf, buf2, i - 1) == 0);\n                ASSERT (buf[i - 1] == '\\0');\n              }\n            ASSERT (strspn (buf + i, \"^\") == sizeof buf - 1 - i);\n          }\n\n        strcpy (buf, \"BADFACE\");\n        errno = 0;\n        ret = strerror_r (err, buf, len + 1);\n        ASSERT (ret != ERANGE);\n        ASSERT (errno == 0);\n        ASSERT (strcmp (buf, buf2) == 0);\n      }\n  }\n\n#if GNULIB_STRERROR\n   \n  {\n    const char *msg1;\n    const char *msg2;\n    const char *msg3;\n    const char *msg4;\n    char *str1;\n    char *str2;\n    char *str3;\n    char *str4;\n\n    msg1 = strerror (ENOENT);\n    ASSERT (msg1);\n    str1 = strdup (msg1);\n    ASSERT (str1);\n\n    msg2 = strerror (ERANGE);\n    ASSERT (msg2);\n    str2 = strdup (msg2);\n    ASSERT (str2);\n\n    msg3 = strerror (-4);\n    ASSERT (msg3);\n    str3 = strdup (msg3);\n    ASSERT (str3);\n\n    msg4 = strerror (1729576);\n    ASSERT (msg4);\n    str4 = strdup (msg4);\n    ASSERT (str4);\n\n    strerror_r (EACCES, buf, sizeof buf);\n    strerror_r (-5, buf, sizeof buf);\n    ASSERT (STREQ (msg4, str4));\n\n    free (str1);\n    free (str2);\n    free (str3);\n    free (str4);\n  }\n#endif\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}