{
  "module_name": "array-mergesort.h",
  "hash_id": "b7479c14f4aaa031b77586149ed8c2920d8225347a3d1e07a59ce98d16a21a48",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/array-mergesort.h",
  "human_readable_source": " \n\n \nstatic void\nmerge (const ELEMENT *src1, size_t n1,\n       const ELEMENT *src2, size_t n2,\n       ELEMENT *dst)\n{\n  for (;;)  \n    {\n      if (COMPARE (src1, src2) <= 0)\n        {\n          *dst++ = *src1++;\n          n1--;\n          if (n1 == 0)\n            break;\n        }\n      else\n        {\n          *dst++ = *src2++;\n          n2--;\n          if (n2 == 0)\n            break;\n        }\n    }\n   \n  if (n1 > 0)\n    {\n      if (dst != src1)\n        do\n          {\n            *dst++ = *src1++;\n            n1--;\n          }\n        while (n1 > 0);\n    }\n  else  \n    {\n      if (dst != src2)\n        do\n          {\n            *dst++ = *src2++;\n            n2--;\n          }\n        while (n2 > 0);\n    }\n}\n\n \n#ifdef STATIC_FROMTO\nSTATIC_FROMTO\n#else\nSTATIC\n#endif\nvoid\nmerge_sort_fromto (const ELEMENT *src, ELEMENT *dst, size_t n, ELEMENT *tmp)\n{\n  switch (n)\n    {\n    case 0:\n      return;\n    case 1:\n       \n      dst[0] = src[0];\n      return;\n    case 2:\n       \n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n           \n          dst[0] = src[0];\n          dst[1] = src[1];\n        }\n      else\n        {\n          dst[0] = src[1];\n          dst[1] = src[0];\n        }\n      break;\n    case 3:\n       \n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n               \n              dst[0] = src[0];\n              dst[1] = src[1];\n              dst[2] = src[2];\n            }\n          else if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n               \n              dst[0] = src[0];\n              dst[1] = src[2];\n              dst[2] = src[1];\n            }\n          else\n            {\n               \n              dst[0] = src[2];\n              dst[1] = src[0];\n              dst[2] = src[1];\n            }\n        }\n      else\n        {\n          if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n               \n              dst[0] = src[1];\n              dst[1] = src[0];\n              dst[2] = src[2];\n            }\n          else if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n               \n              dst[0] = src[1];\n              dst[1] = src[2];\n              dst[2] = src[0];\n            }\n          else\n            {\n               \n              dst[0] = src[2];\n              dst[1] = src[1];\n              dst[2] = src[0];\n            }\n        }\n      break;\n    default:\n      {\n        size_t n1 = n / 2;\n        size_t n2 = (n + 1) / 2;\n         \n         \n        merge_sort_fromto (src + n1, dst + n1, n2, tmp);\n         \n        merge_sort_fromto (src, tmp, n1, dst);\n         \n        merge (tmp, n1, dst + n1, n2, dst);\n      }\n      break;\n    }\n}\n\n \nSTATIC void\nmerge_sort_inplace (ELEMENT *src, size_t n, ELEMENT *tmp)\n{\n  switch (n)\n    {\n    case 0:\n    case 1:\n       \n      return;\n    case 2:\n       \n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n           \n        }\n      else\n        {\n          ELEMENT t = src[0];\n          src[0] = src[1];\n          src[1] = t;\n        }\n      break;\n    case 3:\n       \n      if (COMPARE (&src[0], &src[1]) <= 0)\n        {\n          if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n               \n            }\n          else if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n               \n              ELEMENT t = src[1];\n              src[1] = src[2];\n              src[2] = t;\n            }\n          else\n            {\n               \n              ELEMENT t = src[0];\n              src[0] = src[2];\n              src[2] = src[1];\n              src[1] = t;\n            }\n        }\n      else\n        {\n          if (COMPARE (&src[0], &src[2]) <= 0)\n            {\n               \n              ELEMENT t = src[0];\n              src[0] = src[1];\n              src[1] = t;\n            }\n          else if (COMPARE (&src[1], &src[2]) <= 0)\n            {\n               \n              ELEMENT t = src[0];\n              src[0] = src[1];\n              src[1] = src[2];\n              src[2] = t;\n            }\n          else\n            {\n               \n              ELEMENT t = src[0];\n              src[0] = src[2];\n              src[2] = t;\n            }\n        }\n      break;\n    default:\n      {\n        size_t n1 = n / 2;\n        size_t n2 = (n + 1) / 2;\n         \n         \n        merge_sort_inplace (src + n1, n2, tmp);\n         \n        merge_sort_fromto (src, tmp, n1, tmp + n1);\n         \n        merge (tmp, n1, src + n1, n2, src);\n      }\n      break;\n    }\n}\n\n#undef ELEMENT\n#undef COMPARE\n#undef STATIC\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}