{
  "module_name": "atomic-int-posix.h",
  "hash_id": "ef7d01803f58fb70f9dc23c39ce55bcb52711cf25d28e54151f9754c91b14eeb",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/atomic-int-posix.h",
  "human_readable_source": " \n#define USE_VOLATILE 0\n\n#if USE_POSIX_THREADS && HAVE_SEMAPHORE_H\n \n# define USE_SEMAPHORE 1\n \n# if defined __APPLE__ && defined __MACH__\n#  define USE_NAMED_SEMAPHORE 1\n# else\n#  define USE_UNNAMED_SEMAPHORE 1\n# endif\n#endif\n\n\n#if USE_SEMAPHORE\n# include <errno.h>\n# include <fcntl.h>\n# include <semaphore.h>\n# include <unistd.h>\n#endif\n\n\n#if USE_VOLATILE\nstruct atomic_int {\n  volatile int value;\n};\nstatic void\ninit_atomic_int (struct atomic_int *ai)\n{\n}\nstatic int\nget_atomic_int_value (struct atomic_int *ai)\n{\n  return ai->value;\n}\nstatic void\nset_atomic_int_value (struct atomic_int *ai, int new_value)\n{\n  ai->value = new_value;\n}\n#elif USE_SEMAPHORE\n \n# if USE_UNNAMED_SEMAPHORE\nstruct atomic_int {\n  sem_t semaphore;\n};\n#define atomic_int_semaphore(ai) (&(ai)->semaphore)\nstatic void\ninit_atomic_int (struct atomic_int *ai)\n{\n  sem_init (&ai->semaphore, 0, 0);\n}\n# endif\n# if USE_NAMED_SEMAPHORE\nstruct atomic_int {\n  sem_t *semaphore;\n};\n#define atomic_int_semaphore(ai) ((ai)->semaphore)\nstatic void\ninit_atomic_int (struct atomic_int *ai)\n{\n  sem_t *s;\n  unsigned int count;\n  for (count = 0; ; count++)\n    {\n      char name[80];\n       \n      sprintf (name, \"test-lock-%lu-%p-%u\",\n               (unsigned long) getpid (), ai, count);\n      s = sem_open (name, O_CREAT | O_EXCL, 0600, 0);\n      if (s == SEM_FAILED)\n        {\n          if (errno == EEXIST)\n             \n            continue;\n          else\n            {\n              perror (\"sem_open failed\");\n              abort ();\n            }\n        }\n      else\n        {\n           \n          sem_unlink (name);\n          break;\n        }\n    }\n  ai->semaphore = s;\n}\n# endif\nstatic int\nget_atomic_int_value (struct atomic_int *ai)\n{\n  if (sem_trywait (atomic_int_semaphore (ai)) == 0)\n    {\n      if (sem_post (atomic_int_semaphore (ai)))\n        abort ();\n      return 1;\n    }\n  else if (errno == EAGAIN)\n    return 0;\n  else\n    abort ();\n}\nstatic void\nset_atomic_int_value (struct atomic_int *ai, int new_value)\n{\n  if (new_value == 0)\n     \n    return;\n   \n  if (sem_post (atomic_int_semaphore (ai)))\n    abort ();\n}\n#else\nstruct atomic_int {\n  pthread_mutex_t lock;\n  int value;\n};\nstatic void\ninit_atomic_int (struct atomic_int *ai)\n{\n  pthread_mutexattr_t attr;\n\n  ASSERT (pthread_mutexattr_init (&attr) == 0);\n  ASSERT (pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_NORMAL) == 0);\n  ASSERT (pthread_mutex_init (&ai->lock, &attr) == 0);\n  ASSERT (pthread_mutexattr_destroy (&attr) == 0);\n}\nstatic int\nget_atomic_int_value (struct atomic_int *ai)\n{\n  ASSERT (pthread_mutex_lock (&ai->lock) == 0);\n  int ret = ai->value;\n  ASSERT (pthread_mutex_unlock (&ai->lock) == 0);\n  return ret;\n}\nstatic void\nset_atomic_int_value (struct atomic_int *ai, int new_value)\n{\n  ASSERT (pthread_mutex_lock (&ai->lock) == 0);\n  ai->value = new_value;\n  ASSERT (pthread_mutex_unlock (&ai->lock) == 0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}