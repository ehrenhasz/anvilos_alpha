{
  "module_name": "test-isnanl.h",
  "hash_id": "7ab6b2e0265f4ee50fb82b2da368366bbb6d354414b42bba65bb4c5689310a8c",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-isnanl.h",
  "human_readable_source": " \n\n#include <float.h>\n#include <limits.h>\n\n#include \"minus-zero.h\"\n#include \"infinity.h\"\n#include \"nan.h\"\n#include \"macros.h\"\n\nint\nmain ()\n{\n  #define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  typedef union { unsigned int word[NWORDS]; long double value; }\n          memory_long_double;\n\n   \n  ASSERT (!isnanl (3.141L));\n  ASSERT (!isnanl (3.141e30L));\n  ASSERT (!isnanl (3.141e-30L));\n  ASSERT (!isnanl (-2.718L));\n  ASSERT (!isnanl (-2.718e30L));\n  ASSERT (!isnanl (-2.718e-30L));\n  ASSERT (!isnanl (0.0L));\n  ASSERT (!isnanl (minus_zerol));\n   \n  ASSERT (!isnanl (Infinityl ()));\n  ASSERT (!isnanl (- Infinityl ()));\n   \n  ASSERT (isnanl (NaNl ()));\n\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n   \n  {\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n     \n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = NaNl ();\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    ASSERT (isnanl (m.value));\n  }\n#endif\n\n#if ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n \n# ifdef WORDS_BIGENDIAN\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { ((unsigned int) (exponent) << 16) | ((unsigned int) (manthi) >> 16), \\\n       ((unsigned int) (manthi) << 16) | ((unsigned int) (mantlo) >> 16),   \\\n       (unsigned int) (mantlo) << 16                                        \\\n     }\n# else\n#  define LDBL80_WORDS(exponent,manthi,mantlo) \\\n     { mantlo, manthi, exponent }\n# endif\n  {  \n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0xC3333333, 0x00000000) };\n    ASSERT (isnanl (x.value));\n  }\n  {\n     \n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x83333333, 0x00000000) };\n    ASSERT (isnanl (x.value));\n  }\n   \n  {  \n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x40000001, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  {  \n    static memory_long_double x =\n      { LDBL80_WORDS (0xFFFF, 0x00000000, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  {  \n    static memory_long_double x =\n      { LDBL80_WORDS (0x4004, 0x00000000, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  {  \n    static memory_long_double x =\n      { LDBL80_WORDS (0x4000, 0x63333333, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n  {  \n    static memory_long_double x =\n      { LDBL80_WORDS (0x0000, 0x83333333, 0x00000000) };\n    ASSERT (isnanl (x.value) || !isnanl (x.value));\n  }\n#endif\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}