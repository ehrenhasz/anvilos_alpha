{
  "module_name": "test-yesno.sh",
  "hash_id": "78b707049a106fb1aad7bca632f61d1f8430de6b5ab427298d6cc79f6682355b",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-yesno.sh",
  "human_readable_source": "#!/bin/sh\n: \"${srcdir=.}\"\n. \"$srcdir/init.sh\"; path_prepend_ .\n\n# For now, only test with C locale\nLC_ALL=C\nexport LC_ALL\n\n# Find out how to remove carriage returns from output. Solaris /usr/ucb/tr\n# does not understand '\\r'.\nif echo solaris | tr -d '\\r' | grep solais > /dev/null; then\n  cr='\\015'\nelse\n  cr='\\r'\nfi\n\n# Test with seekable stdin; the follow-on process must see remaining data.\ntr @ '\\177' <<EOF > in.tmp\nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn - entire line consumed\ny@n - backspace does not change result\ny\ndoes not match either yesexpr or noexpr\nn\nEOF\n\ncat <<EOF > xout.tmp\nN\nY\nY\nN\nn\nEOF\n\nfail=0\n(${CHECKER} test-yesno; ${CHECKER} test-yesno 3; cat) < in.tmp > out1.tmp || fail=1\nLC_ALL=C tr -d \"$cr\" < out1.tmp > out.tmp || fail=1\ncmp xout.tmp out.tmp || fail=1\n\n(${CHECKER} test-yesno 3; ${CHECKER} test-yesno; cat) < in.tmp > out1.tmp || fail=1\nLC_ALL=C tr -d \"$cr\" < out1.tmp > out.tmp || fail=1\ncmp xout.tmp out.tmp || fail=1\n\n# Test for behavior on pipe\ncat <<EOF > xout.tmp\nY\nN\nEOF\necho yes | ${CHECKER} test-yesno 2 > out1.tmp || fail=1\nLC_ALL=C tr -d \"$cr\" < out1.tmp > out.tmp || fail=1\ncmp xout.tmp out.tmp || fail=1\n\n# Test for behavior with no EOL at EOF\ncat <<EOF > xout.tmp\nY\nEOF\nprintf y | ${CHECKER} test-yesno 1 > out1.tmp || fail=1\nLC_ALL=C tr -d \"$cr\" < out1.tmp > out.tmp || fail=1\ncmp xout.tmp out.tmp || fail=1\n\n# Test for behavior on EOF\ncat <<EOF > xout.tmp\nN\nEOF\n${CHECKER} test-yesno </dev/null > out1.tmp || fail=1\nLC_ALL=C tr -d \"$cr\" < out1.tmp > out.tmp || fail=1\ncmp xout.tmp out.tmp || fail=1\n\n# Test for behavior when stdin is closed\n${CHECKER} test-yesno 0 <&- > out1.tmp 2> err.tmp && fail=1\nLC_ALL=C tr -d \"$cr\" < out1.tmp > out.tmp || fail=1\ncmp xout.tmp out.tmp || fail=1\ntest -s err.tmp || fail=1\n\nExit $fail\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}