{
  "module_name": "init.sh",
  "hash_id": "7152c8dd4d2653f6a4f68779c60328738b682590d7b812d61ec91295a318596d",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/init.sh",
  "human_readable_source": "# source this file; set up for tests\n\n# Copyright (C) 2009-2023 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n# Using this file in a test\n# =========================\n#\n# The typical skeleton of a test looks like this:\n#\n#   #!/bin/sh\n#   . \"${srcdir=.}/init.sh\"; path_prepend_ .\n#   Execute some commands.\n#   Note that these commands are executed in a subdirectory, therefore you\n#   need to prepend \"../\" to relative filenames in the build directory.\n#   Note that the \"path_prepend_ .\" is useful only if the body of your\n#   test invokes programs residing in the initial directory.\n#   For example, if the programs you want to test are in src/, and this test\n#   script is named tests/test-1, then you would use \"path_prepend_ ../src\",\n#   or perhaps export PATH='$(abs_top_builddir)/src$(PATH_SEPARATOR)'\"$$PATH\"\n#   to all tests via automake's TESTS_ENVIRONMENT.\n#   Set the exit code 0 for success, 77 for skipped, or 1 or other for failure.\n#   Use the skip_ and fail_ functions to print a diagnostic and then exit\n#   with the corresponding exit code.\n#   Exit $?\n\n# Executing a test that uses this file\n# ====================================\n#\n# Running a single test:\n#   $ make check TESTS=test-foo.sh\n#\n# Running a single test, with verbose output:\n#   $ make check TESTS=test-foo.sh VERBOSE=yes\n#\n# Running a single test, keeping the temporary directory:\n#   $ make check TESTS=test-foo.sh KEEP=yes\n#\n# Running a single test, with single-stepping:\n#   1. Go into a sub-shell:\n#   $ bash\n#   2. Set relevant environment variables from TESTS_ENVIRONMENT in the\n#      Makefile:\n#   $ export srcdir=../../tests # this is an example\n#   3. Execute the commands from the test, copy&pasting them one by one:\n#   $ . \"$srcdir/init.sh\"; path_prepend_ .\n#   ...\n#   4. Finally\n#   $ exit\n\n# =============================================================================\n# Elementary diagnostics\n\nME_=`expr \"./$0\" : '.*/\\(.*\\)$'`\n\n# Prepare PATH_SEPARATOR.\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  # Determine PATH_SEPARATOR by trying to find /bin/sh in a PATH which\n  # contains only /bin. Note that ksh looks also at the FPATH variable,\n  # so we have to set that as well for the test.\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 \\\n    && { (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 \\\n           || PATH_SEPARATOR=';'\n       }\nfi\n\n# We use a trap below for cleanup.  This requires us to go through\n# hoops to get the right exit status transported through the handler.\n# So use 'Exit STATUS' instead of 'exit STATUS' inside of the tests.\n# Turn off errexit here so that we don't trip the bug with OSF1/Tru64\n# sh inside this function.\nExit () { set +e; (exit $1); exit $1; }\n\n# Print warnings (e.g., about skipped and failed tests) to this file number.\n# Override by defining to say, 9, in init.cfg, and putting say,\n#   export ...ENVVAR_SETTINGS...; $(SHELL) 9>&2\n# in the definition of TESTS_ENVIRONMENT in your tests/Makefile.am file.\n# This is useful when using automake's parallel tests mode, to print\n# the reason for skip/failure to console, rather than to the .log files.\n: ${stderr_fileno_=2}\n\n# Note that correct expansion of \"$*\" depends on IFS starting with ' '.\n# Always write the full diagnostic to stderr.\n# When stderr_fileno_ is not 2, also emit the first line of the\n# diagnostic to that file descriptor.\nwarn_ ()\n{\n  # If IFS does not start with ' ', set it and emit the warning in a subshell.\n  case $IFS in\n    ' '*) printf '%s\\n' \"$*\" >&2\n          test $stderr_fileno_ = 2 \\\n            || { printf '%s\\n' \"$*\" | sed 1q >&$stderr_fileno_ ; } ;;\n    *) (IFS=' '; warn_ \"$@\");;\n  esac\n}\nfail_ () { warn_ \"$ME_: failed test: $@\"; Exit 1; }\nskip_ () { warn_ \"$ME_: skipped test: $@\"; Exit 77; }\nfatal_ () { warn_ \"$ME_: hard error: $@\"; Exit 99; }\nframework_failure_ () { warn_ \"$ME_: set-up failure: $@\"; Exit 99; }\n\n# =============================================================================\n# Ensure the shell supports modern syntax.\n\n# Sanitize this shell to POSIX mode, if possible.\nDUALCASE=1; export DUALCASE\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in\n    *posix*) set -o posix ;;\n  esac\nfi\n\n# We require $(...) support unconditionally.\n# We require that the printf built-in work correctly regarding octal escapes;\n# this eliminates /bin/sh on AIX 7.2.\n# We require non-surprising \"local\" semantics (this eliminates dash).\n# This takes the admittedly draconian step of eliminating dash, because the\n# assignment tab=$(printf '\\t') works fine, yet preceding it with \"local \"\n# transforms it into an assignment that sets the variable to the empty string.\n# That is too counter-intuitive, and can lead to subtle run-time malfunction.\n# The example below is less subtle in that with dash, it evokes the run-time\n# exception \"dash: 1: local: 1: bad variable name\".\n# We require a few additional shell features only when $EXEEXT is nonempty,\n# in order to support automatic $EXEEXT emulation:\n# - hyphen-containing alias names\n# - we prefer to use ${var#...} substitution, rather than having\n#   to work around lack of support for that feature.\n# The following code attempts to find a shell with support for these features.\n# If the current shell passes the test, we're done.  Otherwise, test other\n# shells until we find one that passes.  If one is found, re-exec it.\n# If no acceptable shell is found, skip the current test.\n#\n# The \"...set -x; P=1 true 2>err...\" test is to disqualify any shell that\n# emits \"P=1\" into err, as /bin/sh from SunOS 5.11 and OpenBSD 4.7 do.\n#\n# Use \"9\" to indicate success (rather than 0), in case some shell acts\n# like Solaris 10's /bin/sh but exits successfully instead of with status 2.\n\n# Eval this code in a subshell to determine a shell's suitability.\n# 10 - passes all tests; ok to use\n#  9 - ok, but enabling \"set -x\" corrupts app stderr; prefer higher score\n#  ? - not ok\ngl_shell_test_script_='\ntest $(echo y) = y || exit 1\nLC_ALL=en_US.UTF-8 printf \"\\\\351\" 2>/dev/null \\\n  | LC_ALL=C tr \"\\\\351\" x | LC_ALL=C grep \"^x$\" > /dev/null \\\n  || exit 1\nprintf \"\\\\351\" 2>/dev/null \\\n  | LC_ALL=C tr \"\\\\351\" x | LC_ALL=C grep \"^x$\" > /dev/null \\\n  || exit 1\nf_local_() { local v=1; }; f_local_ || exit 1\nf_dash_local_fail_() { local t=$(printf \" 1\"); }; f_dash_local_fail_\nscore_=10\nif test \"$VERBOSE\" = yes; then\n  test -n \"$( (exec 3>&1; set -x; P=1 true 2>&3) 2> /dev/null)\" && score_=9\nfi\ntest -z \"$EXEEXT\" && exit $score_\nshopt -s expand_aliases\nalias a-b=\"echo zoo\"\nv=abx\n     test ${v%x} = ab \\\n  && test ${v#a} = bx \\\n  && test $(a-b) = zoo \\\n  && exit $score_\n'\n\nif test \"x$1\" = \"x--no-reexec\"; then\n  shift\nelse\n  # Assume a working shell.  Export to subshells (setup_ needs this).\n  gl_set_x_corrupts_stderr_=false\n  export gl_set_x_corrupts_stderr_\n\n  # Record the first marginally acceptable shell.\n  marginal_=\n\n  # Search for a shell that meets our requirements.\n  for re_shell_ in __current__ \"${CONFIG_SHELL:-no_shell}\" \\\n      /bin/sh bash dash zsh pdksh fail\n  do\n    test \"$re_shell_\" = no_shell && continue\n\n    # If we've made it all the way to the sentinel, \"fail\" without\n    # finding even a marginal shell, skip this test.\n    if test \"$re_shell_\" = fail; then\n      test -z \"$marginal_\" && skip_ failed to find an adequate shell\n      re_shell_=$marginal_\n      break\n    fi\n\n    # When testing the current shell, simply \"eval\" the test code.\n    # Otherwise, run it via $re_shell_ -c ...\n    if test \"$re_shell_\" = __current__; then\n      # 'eval'ing this code makes Solaris 10's /bin/sh exit with\n      # $? set to 2.  It does not evaluate any of the code after the\n      # \"unexpected\" first '('.  Thus, we must run it in a subshell.\n      ( eval \"$gl_shell_test_script_\" ) > /dev/null 2>&1\n    else\n      \"$re_shell_\" -c \"$gl_shell_test_script_\" 2>/dev/null\n    fi\n\n    st_=$?\n\n    # $re_shell_ works just fine.  Use it.\n    if test $st_ = 10; then\n      gl_set_x_corrupts_stderr_=false\n      break\n    fi\n\n    # If this is our first marginally acceptable shell, remember it.\n    if test \"$st_:$marginal_\" = 9: ; then\n      marginal_=\"$re_shell_\"\n      gl_set_x_corrupts_stderr_=true\n    fi\n  done\n\n  if test \"$re_shell_\" != __current__; then\n    # Found a usable shell.  Preserve -v and -x.\n    case $- in\n      *v*x* | *x*v*) opts_=-vx ;;\n      *v*) opts_=-v ;;\n      *x*) opts_=-x ;;\n      *) opts_= ;;\n    esac\n    re_shell=$re_shell_\n    export re_shell\n    exec \"$re_shell_\" $opts_ \"$0\" --no-reexec \"$@\"\n    echo \"$ME_: exec failed\" 1>&2\n    exit 127\n  fi\nfi\n\n# =============================================================================\n# Ensure the shell behaves reasonably.\n\n# If this is bash, turn off all aliases.\ntest -n \"$BASH_VERSION\" && unalias -a\n\n# Note that when supporting $EXEEXT (transparently mapping from PROG_NAME to\n# PROG_NAME.exe), we want to support hyphen-containing names like test-acos.\n# That is part of the shell-selection test above.  Why use aliases rather\n# than functions?  Because support for hyphen-containing aliases is more\n# widespread than that for hyphen-containing function names.\ntest -n \"$EXEEXT\" && test -n \"$BASH_VERSION\" && shopt -s expand_aliases\n\n# =============================================================================\n# Creating a temporary directory (needed by the core test framework)\n\n# Create a temporary directory, much like mktemp -d does.\n# Written by Jim Meyering.\n#\n# Usage: mktempd_ /tmp phoey.XXXXXXXXXX\n#\n# First, try to use the mktemp program.\n# Failing that, we'll roll our own mktemp-like function:\n#  - try to get random bytes from /dev/urandom, mapping them to file-name bytes\n#  - failing that, generate output from a combination of quickly-varying\n#      sources and awk.\n#  - try to create the desired directory.\n#  - make only $MAX_TRIES_ attempts\n\n# Helper function.  Print $N pseudo-random bytes from a-zA-Z0-9.\nrand_bytes_ ()\n{\n  n_=$1\n\n  # Maybe try openssl rand -base64 $n_prime_|tr '+/=\\012' abcd first?\n  # But if they have openssl, they probably have mktemp, too.\n\n  chars_=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\n  dev_rand_=/dev/urandom\n  if test -r \"$dev_rand_\"; then\n    # Note: 256-length($chars_) == 194; 3 copies of $chars_ is 186 + 8 = 194.\n    dd ibs=$n_ count=1 if=$dev_rand_ 2>/dev/null \\\n      | LC_ALL=C tr -c $chars_ 01234567$chars_$chars_$chars_\n    return\n  fi\n\n  # Fall back on quickly-varying sources + awk.\n  # Limit awk program to 7th Edition Unix so that it works even on Solaris 10.\n\n  (date; date +%N; free; who -a; w; ps auxww; ps -ef) 2>&1 | awk '\n     BEGIN {\n       n = '\"$n_\"'\n       for (i = 0; i < 256; i++)\n         ordinal[sprintf (\"%c\", i)] = i\n     }\n     {\n       for (i = 1; i <= length; i++)\n         a[ai++ % n] += ordinal[substr ($0, i, 1)]\n     }\n     END {\n       chars = \"'\"$chars_\"'\"\n       charslen = length (chars)\n       for (i = 0; i < n; i++)\n         printf \"%s\", substr (chars, a[i] % charslen + 1, 1)\n       printf \"\\n\"\n     }\n  '\n}\n\nmktempd_ ()\n{\n  case $# in\n  2);;\n  *) fail_ \"Usage: mktempd_ DIR TEMPLATE\";;\n  esac\n\n  destdir_=$1\n  template_=$2\n\n  MAX_TRIES_=4\n\n  # Disallow any trailing slash on specified destdir:\n  # it would subvert the post-mktemp \"case\"-based destdir test.\n  case $destdir_ in\n  / | //) destdir_slash_=$destdir;;\n  */) fail_ \"invalid destination dir: remove trailing slash(es)\";;\n  *) destdir_slash_=$destdir_/;;\n  esac\n\n  case $template_ in\n  *XXXX) ;;\n  *) fail_ \\\n       \"invalid template: $template_ (must have a suffix of at least 4 X's)\";;\n  esac\n\n  # First, try to use mktemp.\n  d=`unset TMPDIR; { mktemp -d -t -p \"$destdir_\" \"$template_\"; } 2>/dev/null` &&\n\n  # The resulting name must be in the specified directory.\n  case $d in \"$destdir_slash_\"*) :;; *) false;; esac &&\n\n  # It must have created the directory.\n  test -d \"$d\" &&\n\n  # It must have 0700 permissions.  Handle sticky \"S\" bits.\n  perms=`ls -dgo \"$d\" 2>/dev/null` &&\n  case $perms in drwx--[-S]---*) :;; *) false;; esac && {\n    echo \"$d\"\n    return\n  }\n\n  # If we reach this point, we'll have to create a directory manually.\n\n  # Get a copy of the template without its suffix of X's.\n  base_template_=`echo \"$template_\"|sed 's/XX*$//'`\n\n  # Calculate how many X's we've just removed.\n  template_length_=`echo \"$template_\" | wc -c`\n  nx_=`echo \"$base_template_\" | wc -c`\n  nx_=`expr $template_length_ - $nx_`\n\n  err_=\n  i_=1\n  while :; do\n    X_=`rand_bytes_ $nx_`\n    candidate_dir_=\"$destdir_slash_$base_template_$X_\"\n    err_=`mkdir -m 0700 \"$candidate_dir_\" 2>&1` \\\n      && { echo \"$candidate_dir_\"; return; }\n    test $MAX_TRIES_ -le $i_ && break;\n    i_=`expr $i_ + 1`\n  done\n  fail_ \"$err_\"\n}\n\n# =============================================================================\n# Core test framework\n\n# An arbitrary prefix to help distinguish test directories.\ntestdir_prefix_ () { printf gt; }\n\n# Set up the environment for the test to run in.\nsetup_ ()\n{\n  if test \"$VERBOSE\" = yes; then\n    # Test whether set -x may cause the selected shell to corrupt an\n    # application's stderr.  Many do, including zsh-4.3.10 and the /bin/sh\n    # from SunOS 5.11, OpenBSD 4.7 and Irix 6.5.\n    # If enabling verbose output this way would cause trouble, simply\n    # issue a warning and refrain.\n    if $gl_set_x_corrupts_stderr_; then\n      warn_ \"using SHELL=$SHELL with 'set -x' corrupts stderr\"\n    else\n      set -x\n    fi\n  fi\n\n  initial_cwd_=$PWD\n\n  # Create and enter the temporary directory.\n  pfx_=`testdir_prefix_`\n  test_dir_=`mktempd_ \"$initial_cwd_\" \"$pfx_-$ME_.XXXX\"` \\\n    || fail_ \"failed to create temporary directory in $initial_cwd_\"\n  cd \"$test_dir_\" || fail_ \"failed to cd to temporary directory\"\n  # Set variables srcdir, builddir, for the convenience of the test.\n  case $srcdir in\n    /* | ?:*) ;;\n    *) srcdir=\"../$srcdir\" ;;\n  esac\n  builddir=\"..\"\n  export srcdir builddir\n\n  # As autoconf-generated configure scripts do, ensure that IFS\n  # is defined initially, so that saving and restoring $IFS works.\n  gl_init_sh_nl_='\n'\n  IFS=\" \"\"\t$gl_init_sh_nl_\"\n\n  # This trap statement, along with a trap on 0 below, ensure that the\n  # temporary directory, $test_dir_, is removed upon exit as well as\n  # upon receipt of any of the listed signals.\n  for sig_ in 1 2 3 13 15; do\n    eval \"trap 'Exit $(expr $sig_ + 128)' $sig_\"\n  done\n\n  # Remove relative and non-accessible directories from PATH, including '.'\n  # and Zero-length entries.\n  saved_IFS=\"$IFS\"\n  IFS=:\n  new_PATH=\n  sep_=\n  for dir in $PATH; do\n    case \"$dir\" in\n      /*) test -d \"$dir/.\" || continue\n          new_PATH=\"${new_PATH}${sep_}${dir}\"\n          sep_=':';;\n    esac\n  done\n  IFS=\"$saved_IFS\"\n  PATH=\"$new_PATH\"\n  export PATH\n}\n\n# This is a stub function that is run upon trap (upon regular exit and\n# interrupt).  Override it with a per-test function, e.g., to unmount\n# a partition, or to undo any other global state changes.\ncleanup_ () { :; }\n\n# Run the user-overridable cleanup_ function, remove the temporary\n# directory and exit with the incoming value of $?.\nremove_tmp_ ()\n{\n  __st=$?\n  cleanup_\n  if test \"$KEEP\" = yes; then\n    echo \"Not removing temporary directory $test_dir_\"\n  else\n    # cd out of the directory we're about to remove\n    cd \"$initial_cwd_\" || cd / || cd /tmp\n    chmod -R u+rwx \"$test_dir_\"\n    # If removal fails and exit status was to be 0, then change it to 1.\n    rm -rf \"$test_dir_\" || { test $__st = 0 && __st=1; }\n  fi\n  exit $__st\n}\n\n# =============================================================================\n# Prepending directories to PATH\n\n# Given a directory name, DIR, if every entry in it that matches *.exe\n# contains only the specified bytes (see the case stmt below), then print\n# a space-separated list of those names and return 0.  Otherwise, don't\n# print anything and return 1.  Naming constraints apply also to DIR.\nfind_exe_basenames_ ()\n{\n  feb_dir_=$1\n  feb_fail_=0\n  feb_result_=\n  feb_sp_=\n  for feb_file_ in $feb_dir_/*.exe; do\n    # If there was no *.exe file, or there existed a file named \"*.exe\" that\n    # was deleted between the above glob expansion and the existence test\n    # below, just skip it.\n    test \"x$feb_file_\" = \"x$feb_dir_/*.exe\" && test ! -f \"$feb_file_\" \\\n      && continue\n    # Exempt [.exe, since we can't create a function by that name, yet\n    # we can't invoke [ by PATH search anyways due to shell builtins.\n    test \"x$feb_file_\" = \"x$feb_dir_/[.exe\" && continue\n    case $feb_file_ in\n      *[!-a-zA-Z/0-9_.+]*) feb_fail_=1; break;;\n      *) # Remove leading file name components as well as the .exe suffix.\n         feb_file_=${feb_file_##*/}\n         feb_file_=${feb_file_%.exe}\n         feb_result_=\"$feb_result_$feb_sp_$feb_file_\";;\n    esac\n    feb_sp_=' '\n  done\n  test $feb_fail_ = 0 && printf %s \"$feb_result_\"\n  return $feb_fail_\n}\n\n# Consider the files in directory, $1.\n# For each file name of the form PROG.exe, create an alias named\n# PROG that simply invokes PROG.exe, then return 0.  If any selected\n# file name or the directory name, $1, contains an unexpected character,\n# define no alias and return 1.\ncreate_exe_shims_ ()\n{\n  case $EXEEXT in\n    '') return 0 ;;\n    .exe) ;;\n    *) echo \"$0: unexpected \\$EXEEXT value: $EXEEXT\" 1>&2; return 1 ;;\n  esac\n\n  base_names_=`find_exe_basenames_ $1` \\\n    || { echo \"$0 (exe_shim): skipping directory: $1\" 1>&2; return 0; }\n\n  if test -n \"$base_names_\"; then\n    for base_ in $base_names_; do\n      alias \"$base_\"=\"$base_$EXEEXT\"\n    done\n  fi\n\n  return 0\n}\n\n# Use this function to prepend to PATH an absolute name for each\n# specified, possibly-$initial_cwd_-relative, directory.\npath_prepend_ ()\n{\n  while test $# != 0; do\n    path_dir_=$1\n    case $path_dir_ in\n      '') fail_ \"invalid path dir: '$1'\";;\n      /* | ?:*) abs_path_dir_=$path_dir_;;\n      *) abs_path_dir_=$initial_cwd_/$path_dir_;;\n    esac\n    case $abs_path_dir_ in\n      *$PATH_SEPARATOR*) fail_ \"invalid path dir: '$abs_path_dir_'\";;\n    esac\n    PATH=\"$abs_path_dir_$PATH_SEPARATOR$PATH\"\n\n    # Create an alias, FOO, for each FOO.exe in this directory.\n    create_exe_shims_ \"$abs_path_dir_\" \\\n      || fail_ \"something failed (above): $abs_path_dir_\"\n    shift\n  done\n  export PATH\n}\n\n# =============================================================================\n# Convenience environment variables for the tests\n\n# -----------------------------------------------------------------------------\n\n# Enable glibc's malloc-perturbing option.\n# This is useful for exposing code that depends on the fact that\n# malloc-related functions often return memory that is mostly zeroed.\n# If you have the time and cycles, use valgrind to do an even better job.\n: ${MALLOC_PERTURB_=87}\nexport MALLOC_PERTURB_\n\n# -----------------------------------------------------------------------------\n\n# The interpreter for Bourne-shell scripts.\n# No special standards compatibility requirements.\n# Some environments, such as Android, don't have /bin/sh.\nif test -f /bin/sh$EXEEXT; then\n  BOURNE_SHELL=/bin/sh\nelse\n  BOURNE_SHELL=sh\nfi\n\n# =============================================================================\n# Convenience functions for the tests\n\n# -----------------------------------------------------------------------------\n# Return value checking\n\n# This is used to simplify checking of the return value\n# which is useful when ensuring a command fails as desired.\n# I.e., just doing `command ... &&fail=1` will not catch\n# a segfault in command for example.  With this helper you\n# instead check an explicit exit code like\n#   returns_ 1 command ... || fail\nreturns_ () {\n  # Disable tracing so it doesn't interfere with stderr of the wrapped command\n  { set +x; } 2>/dev/null\n\n  local exp_exit=\"$1\"\n  shift\n  \"$@\"\n  test $? -eq $exp_exit && ret_=0 || ret_=1\n\n  if test \"$VERBOSE\" = yes && test \"$gl_set_x_corrupts_stderr_\" = false; then\n    set -x\n  fi\n  { return $ret_; } 2>/dev/null\n}\n\n# -----------------------------------------------------------------------------\n# Text file comparison\n\n# Emit a header similar to that from diff -u;  Print the simulated \"diff\"\n# command so that the order of arguments is clear.  Don't bother with @@ lines.\nemit_diff_u_header_ ()\n{\n  printf '%s\\n' \"diff -u $*\" \\\n    \"--- $1\t1970-01-01\" \\\n    \"+++ $2\t1970-01-01\"\n}\n\n# Arrange not to let diff or cmp operate on /dev/null,\n# since on some systems (at least OSF/1 5.1), that doesn't work.\n# When there are not two arguments, or no argument is /dev/null, return 2.\n# When one argument is /dev/null and the other is not empty,\n# cat the nonempty file to stderr and return 1.\n# Otherwise, return 0.\ncompare_dev_null_ ()\n{\n  test $# = 2 || return 2\n\n  if test \"x$1\" = x/dev/null; then\n    test -s \"$2\" || return 0\n    emit_diff_u_header_ \"$@\"; sed 's/^/+/' \"$2\"\n    return 1\n  fi\n\n  if test \"x$2\" = x/dev/null; then\n    test -s \"$1\" || return 0\n    emit_diff_u_header_ \"$@\"; sed 's/^/-/' \"$1\"\n    return 1\n  fi\n\n  return 2\n}\n\nfor diff_opt_ in -u -U3 -c '' no; do\n  test \"$diff_opt_\" != no &&\n    diff_out_=`exec 2>/dev/null\n      LC_ALL=C diff $diff_opt_ \"$0\" \"$0\" < /dev/null` &&\n    break\ndone\nif test \"$diff_opt_\" != no; then\n  if test -z \"$diff_out_\"; then\n    compare_ () { LC_ALL=C diff $diff_opt_ \"$@\"; }\n  else\n    compare_ ()\n    {\n      # If no differences were found, AIX and HP-UX 'diff' produce output\n      # like \"No differences encountered\".  Hide this output.\n      LC_ALL=C diff $diff_opt_ \"$@\" > diff.out\n      diff_status_=$?\n      test $diff_status_ -eq 0 || cat diff.out || diff_status_=2\n      rm -f diff.out || diff_status_=2\n      return $diff_status_\n    }\n  fi\nelif cmp -s /dev/null /dev/null 2>/dev/null; then\n  compare_ () { cmp -s \"$@\"; }\nelse\n  compare_ () { cmp \"$@\"; }\nfi\n\n# Usage: compare EXPECTED ACTUAL\n#\n# Given compare_dev_null_'s preprocessing, defer to compare_ if 2 or more.\n# Otherwise, propagate $? to caller: any diffs have already been printed.\ncompare ()\n{\n  # This looks like it can be factored to use a simple \"case $?\"\n  # after unchecked compare_dev_null_ invocation, but that would\n  # fail in a \"set -e\" environment.\n  if compare_dev_null_ \"$@\"; then\n    return 0\n  else\n    case $? in\n      1) return 1;;\n      *) compare_ \"$@\";;\n    esac\n  fi\n}\n\n# -----------------------------------------------------------------------------\n\n# If you want to override the testdir_prefix_ function,\n# or to add more utility functions, use this file.\ntest -f \"$srcdir/init.cfg\" \\\n  && . \"$srcdir/init.cfg\"\n\n# =============================================================================\n# Set up the environment for the test to run in.\n\nsetup_ \"$@\"\n# This trap is here, rather than in the setup_ function, because some\n# shells run the exit trap at shell function exit, rather than script exit.\ntrap remove_tmp_ EXIT\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}