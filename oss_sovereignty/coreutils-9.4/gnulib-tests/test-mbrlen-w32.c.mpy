{
  "module_name": "test-mbrlen-w32.c",
  "hash_id": "d3cb73e1229e4239624a6ed0e94dc194e9f00e785968ca7bae836794f33e2802",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-mbrlen-w32.c",
  "human_readable_source": " \n  {\n    char name_with_codepage[1024];\n\n    sprintf (name_with_codepage, \"%s.%d\", name, codepage);\n\n     \n    if (setlocale (LC_ALL, name_with_codepage) == NULL)\n      return 77;\n  }\n# else\n   \n  {\n     \n    extern __declspec(dllimport) unsigned int __lc_codepage;\n\n     \n    if (setlocale (LC_ALL, name) == NULL)\n      return 77;\n\n     \n    __lc_codepage = codepage;\n    switch (codepage)\n      {\n      case 1252:\n      case 1256:\n        MB_CUR_MAX = 1;\n        break;\n      case 932:\n      case 950:\n      case 936:\n        MB_CUR_MAX = 2;\n        break;\n      case 54936:\n      case 65001:\n        MB_CUR_MAX = 4;\n        break;\n      }\n\n     \n    memset (&state, '\\0', sizeof (mbstate_t));\n    if (mbrlen (\" \", 1, &state) == (size_t)(-1))\n      return 77;\n  }\n# endif\n\n   \n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    ret = mbrlen (\"x\", 0, &state);\n     \n    ASSERT (ret == (size_t)(-2) || ret == (size_t)(-1) || ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n   \n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    ret = mbrlen (\"\", 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n   \n  {\n    int c;\n    char buf[1];\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n    for (c = 0; c < 0x100; c++)\n      switch (c)\n        {\n        case '\\t': case '\\v': case '\\f':\n        case ' ': case '!': case '\"': case '#': case '%':\n        case '&': case '\\'': case '(': case ')': case '*':\n        case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n        case ':': case ';': case '<': case '=': case '>':\n        case '?':\n        case 'A': case 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U': case 'V': case 'W': case 'X': case 'Y':\n        case 'Z':\n        case '[': case '\\\\': case ']': case '^': case '_':\n        case 'a': case 'b': case 'c': case 'd': case 'e':\n        case 'f': case 'g': case 'h': case 'i': case 'j':\n        case 'k': case 'l': case 'm': case 'n': case 'o':\n        case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y':\n        case 'z': case '{': case '|': case '}': case '~':\n           \n          buf[0] = c;\n          ret = mbrlen (buf, 1, &state);\n          ASSERT (ret == 1);\n          ASSERT (mbsinit (&state));\n          break;\n        }\n  }\n\n   \n  {\n    memset (&state, '\\0', sizeof (mbstate_t));\n    ret = mbrlen (NULL, 5, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n  switch (codepage)\n    {\n    case 1252:\n       \n      {\n        char input[] = \"B\\374\\337er\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        ret = mbrlen (input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        ret = mbrlen (input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 1256:\n       \n      {\n        char input[] = \"x\\302\\341\\346y\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n\n        ret = mbrlen (input + 2, 3, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n\n        ret = mbrlen (input + 4, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n      }\n      return 0;\n\n    case 65001:\n       \n      if (strcmp (locale_charset (), \"UTF-8\") != 0)\n        return 77;\n      {\n        char input[] = \"B\\303\\274\\303\\237er\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        ret = mbrlen (input + 2, 5, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 4, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n\n        ret = mbrlen (input + 5, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n\n        ret = mbrlen (input + 6, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n         \n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\377\", 1, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\303\\300\", 2, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\343\\300\", 2, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\343\\300\\200\", 3, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\343\\200\\300\", 3, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\363\\300\", 2, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\363\\300\\200\\200\", 4, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\363\\200\\300\", 3, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\363\\200\\300\\200\", 4, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\363\\200\\200\\300\", 4, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    case 932:\n       \n      {\n        char input[] = \"<\\223\\372\\226\\173\\214\\352>\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        ret = mbrlen (input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        ret = mbrlen (input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        ret = mbrlen (input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n         \n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\377\", 1, &state);  \n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\225\\377\", 2, &state);  \n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == 2);\n      }\n      return 0;\n\n    case 950:\n       \n      {\n        char input[] = \"<\\244\\351\\245\\273\\273\\171>\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        ret = mbrlen (input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        ret = mbrlen (input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        ret = mbrlen (input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n         \n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\377\", 1, &state);  \n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\225\\377\", 2, &state);  \n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == 2);\n      }\n      return 0;\n\n    case 936:\n       \n      {\n        char input[] = \"<\\310\\325\\261\\276\\325\\132>\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 2, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[1] = '\\0';\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (!mbsinit (&state));\n        input[3] = '\\0';\n\n        ret = mbrlen (input + 4, 4, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[4] = '\\0';\n\n        ret = mbrlen (input + 5, 3, &state);\n        ASSERT (ret == 2);\n        ASSERT (mbsinit (&state));\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        ret = mbrlen (input + 7, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n         \n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\377\", 1, &state);  \n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == (size_t)-2);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\225\\377\", 2, &state);  \n        ASSERT ((ret == (size_t)-1 && errno == EILSEQ) || ret == 2);\n      }\n      return 0;\n\n    case 54936:\n       \n      if (strcmp (locale_charset (), \"GB18030\") != 0)\n        return 77;\n      {\n        char input[] = \"B\\250\\271\\201\\060\\211\\070er\";  \n        memset (&state, '\\0', sizeof (mbstate_t));\n\n        ret = mbrlen (input, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[0] = '\\0';\n\n        ret = mbrlen (input + 1, 1, &state);\n        ASSERT (ret == (size_t)(-2));\n        ASSERT (!mbsinit (&state));\n        input[1] = '\\0';\n\n        ret = mbrlen (input + 2, 7, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[2] = '\\0';\n\n        ret = mbrlen (input + 3, 6, &state);\n        ASSERT (ret == 4);\n        ASSERT (mbsinit (&state));\n        input[3] = '\\0';\n        input[4] = '\\0';\n        input[5] = '\\0';\n        input[6] = '\\0';\n\n        ret = mbrlen (input + 7, 2, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n        input[7] = '\\0';\n\n        ret = mbrlen (input + 8, 1, &state);\n        ASSERT (ret == 1);\n        ASSERT (mbsinit (&state));\n\n         \n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\377\", 1, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\225\\377\", 2, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\201\\045\", 2, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\201\\060\\377\", 3, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\201\\060\\377\\064\", 4, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n\n        memset (&state, '\\0', sizeof (mbstate_t));\n        ret = mbrlen (\"\\201\\060\\211\\072\", 4, &state);  \n        ASSERT (ret == (size_t)-1);\n        ASSERT (errno == EILSEQ);\n      }\n      return 0;\n\n    default:\n      return 1;\n    }\n}\n\nint\nmain (int argc, char *argv[])\n{\n  int codepage = atoi (argv[argc - 1]);\n  int result;\n  int i;\n\n  result = 77;\n  for (i = 1; i < argc - 1; i++)\n    {\n      int ret = test_one_locale (argv[i], codepage);\n\n      if (ret != 77)\n        result = ret;\n    }\n\n  if (result == 77)\n    {\n      fprintf (stderr, \"Skipping test: found no locale with codepage %d\\n\",\n               codepage);\n    }\n  return result;\n}\n\n#else\n\nint\nmain (int argc, char *argv[])\n{\n  fputs (\"Skipping test: not a native Windows system\\n\", stderr);\n  return 77;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}