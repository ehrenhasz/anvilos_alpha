{
  "module_name": "test-mbsrtowcs.c",
  "hash_id": "2c7f32810a140a4b03c4d0f18ad808d6f09d5b6a0d0d4e88fe14bd1be6e57106",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-mbsrtowcs.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <wchar.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (mbsrtowcs, size_t, (wchar_t *, char const **, size_t,\n                                     mbstate_t *));\n\n#include <locale.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"macros.h\"\n\nint\nmain (int argc, char *argv[])\n{\n  mbstate_t state;\n  wchar_t wc;\n  size_t ret;\n\n   \n  if (setlocale (LC_ALL, \"\") == NULL)\n    return 1;\n\n   \n  {\n    const char *src;\n\n    memset (&state, '\\0', sizeof (mbstate_t));\n\n    src = \"\";\n    ret = mbsrtowcs (NULL, &src, 0, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n\n    src = \"\";\n    ret = mbsrtowcs (NULL, &src, 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (mbsinit (&state));\n\n    wc = (wchar_t) 0xBADFACE;\n    src = \"\";\n    ret = mbsrtowcs (&wc, &src, 0, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == (wchar_t) 0xBADFACE);\n    ASSERT (mbsinit (&state));\n\n    wc = (wchar_t) 0xBADFACE;\n    src = \"\";\n    ret = mbsrtowcs (&wc, &src, 1, &state);\n    ASSERT (ret == 0);\n    ASSERT (wc == 0);\n    ASSERT (mbsinit (&state));\n  }\n\n#ifdef __ANDROID__\n   \n  if (argc > 1 && strcmp (argv[1], \"1\") == 0 && MB_CUR_MAX > 1)\n    argv[1] = \"3\";\n#endif\n\n  if (argc > 1)\n    {\n      int unlimited;\n\n      for (unlimited = 0; unlimited < 2; unlimited++)\n        {\n          #define BUFSIZE 10\n          wchar_t buf[BUFSIZE];\n          const char *src;\n          mbstate_t temp_state;\n\n          {\n            size_t i;\n            for (i = 0; i < BUFSIZE; i++)\n              buf[i] = (wchar_t) 0xBADFACE;\n          }\n\n          switch (argv[1][0])\n            {\n            case '1':\n               \n              {\n                char input[] = \"n/a\";\n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                src = input;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 1, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input);\n                ASSERT (mbsinit (&state));\n\n                src = input;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                ASSERT (ret == (unlimited ? 3 : 1));\n                ASSERT (src == (unlimited ? NULL : input + 1));\n                ASSERT (buf[0] == 'n');\n                if (unlimited)\n                  {\n                    ASSERT (buf[1] == '/');\n                    ASSERT (buf[2] == 'a');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[1] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              {\n                int c;\n                char input[2];\n\n                memset (&state, '\\0', sizeof (mbstate_t));\n                for (c = 0; c < 0x100; c++)\n                  if (c != 0)\n                    {\n                       \n                      input[0] = c;\n                      input[1] = '\\0';\n\n                      src = input;\n                      ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 1, &state);\n                      ASSERT (ret == 1);\n                      ASSERT (src == input);\n                      ASSERT (mbsinit (&state));\n\n                      buf[0] = buf[1] = (wchar_t) 0xBADFACE;\n                      src = input;\n                      ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                       \n                      ASSERT (ret == 1);\n                      ASSERT (src == (unlimited ? NULL : input + 1));\n                      if (c < 0x80)\n                         \n                        ASSERT (buf[0] == c);\n                      else\n                         \n                        ASSERT (buf[0] == (btowc (c) == 0xDF00 + c ? btowc (c) : c));\n                      ASSERT (mbsinit (&state));\n                    }\n              }\n              break;\n\n            case '2':\n               \n              {\n                char input[] = \"B\\374\\337er\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wctob (wc) == (unsigned char) '\\374');\n                ASSERT (mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 1, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input + 2);\n                ASSERT (mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 1, &state);\n                ASSERT (ret == (unlimited ? 3 : 1));\n                ASSERT (src == (unlimited ? NULL : input + 3));\n                ASSERT (wctob (buf[0]) == (unsigned char) '\\337');\n                if (unlimited)\n                  {\n                    ASSERT (buf[1] == 'e');\n                    ASSERT (buf[2] == 'r');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[1] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '3':\n               \n              {\n                char input[] = \"B\\303\\274\\303\\237er\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (wchar_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 4);\n                ASSERT (src == input + 2);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 4 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 5));\n                ASSERT (wctob (buf[0]) == EOF);\n                ASSERT (wctob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == 'e');\n                    ASSERT (buf[3] == 'r');\n                    ASSERT (buf[4] == 0);\n                    ASSERT (buf[5] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '4':\n               \n              {\n                char input[] = \"<\\306\\374\\313\\334\\270\\354>\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == '<');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 2, &state);\n                ASSERT (ret == 2);\n                ASSERT (wctob (wc) == EOF);\n                ASSERT (mbsinit (&state));\n                input[1] = '\\0';\n                input[2] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 3, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (wchar_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[3] = '\\0';\n\n                src = input + 4;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 3);\n                ASSERT (src == input + 4);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 4;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 3 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 7));\n                ASSERT (wctob (buf[0]) == EOF);\n                ASSERT (wctob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == '>');\n                    ASSERT (buf[3] == 0);\n                    ASSERT (buf[4] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            case '5':\n               \n              {\n                char input[] = \"B\\250\\271\\201\\060\\211\\070er\";  \n                memset (&state, '\\0', sizeof (mbstate_t));\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input, 1, &state);\n                ASSERT (ret == 1);\n                ASSERT (wc == 'B');\n                ASSERT (mbsinit (&state));\n                input[0] = '\\0';\n\n                wc = (wchar_t) 0xBADFACE;\n                ret = mbrtowc (&wc, input + 1, 1, &state);\n                ASSERT (ret == (size_t)(-2));\n                ASSERT (wc == (wchar_t) 0xBADFACE);\n                ASSERT (!mbsinit (&state));\n                input[1] = '\\0';\n\n                src = input + 2;\n                temp_state = state;\n                ret = mbsrtowcs (NULL, &src, unlimited ? BUFSIZE : 2, &temp_state);\n                ASSERT (ret == 4);\n                ASSERT (src == input + 2);\n                ASSERT (!mbsinit (&state));\n\n                src = input + 2;\n                ret = mbsrtowcs (buf, &src, unlimited ? BUFSIZE : 2, &state);\n                ASSERT (ret == (unlimited ? 4 : 2));\n                ASSERT (src == (unlimited ? NULL : input + 7));\n                ASSERT (wctob (buf[0]) == EOF);\n                ASSERT (wctob (buf[1]) == EOF);\n                if (unlimited)\n                  {\n                    ASSERT (buf[2] == 'e');\n                    ASSERT (buf[3] == 'r');\n                    ASSERT (buf[4] == 0);\n                    ASSERT (buf[5] == (wchar_t) 0xBADFACE);\n                  }\n                else\n                  ASSERT (buf[2] == (wchar_t) 0xBADFACE);\n                ASSERT (mbsinit (&state));\n              }\n              break;\n\n            default:\n              return 1;\n            }\n        }\n\n      return 0;\n    }\n\n  return 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}