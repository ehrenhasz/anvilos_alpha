{
  "module_name": "thread.c",
  "hash_id": "025fe025c3af0549f4487208662480579e88485a0b94267c64787e2f4cf07bce",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/glthread/thread.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include \"glthread/thread.h\"\n\n#include <stdlib.h>\n#include \"glthread/lock.h\"\n\n \n\n#if USE_ISOC_THREADS\n\nstruct thrd_with_exitvalue\n{\n  thrd_t volatile tid;\n  void * volatile exitvalue;\n};\n\n \nstatic tss_t thrd_with_exitvalue_key;\n\n \nstatic void\ndo_init_thrd_with_exitvalue_key (void)\n{\n  if (tss_create (&thrd_with_exitvalue_key, NULL) != thrd_success)\n    abort ();\n}\n\n \nstatic void\ninit_thrd_with_exitvalue_key (void)\n{\n  static once_flag once = ONCE_FLAG_INIT;\n  call_once (&once, do_init_thrd_with_exitvalue_key);\n}\n\ntypedef union\n        {\n          struct thrd_with_exitvalue t;\n          struct\n          {\n            thrd_t tid;  \n            void *(*mainfunc) (void *);\n            void *arg;\n          } a;\n        }\n        main_arg_t;\n\nstatic int\nthrd_main_func (void *pmarg)\n{\n   \n  main_arg_t *main_arg = (main_arg_t *) pmarg;\n  void *(*mainfunc) (void *) = main_arg->a.mainfunc;\n  void *arg = main_arg->a.arg;\n\n  if (tss_set (thrd_with_exitvalue_key, &main_arg->t) != thrd_success)\n    abort ();\n\n   \n  {\n    void *exitvalue = mainfunc (arg);\n     \n    main_arg->t.exitvalue = exitvalue;\n    return 0;\n  }\n}\n\nint\nglthread_create (gl_thread_t *threadp, void *(*mainfunc) (void *), void *arg)\n{\n  init_thrd_with_exitvalue_key ();\n  {\n     \n    main_arg_t *main_arg = (main_arg_t *) malloc (sizeof (main_arg_t));\n    if (main_arg == NULL)\n      return ENOMEM;\n    main_arg->a.mainfunc = mainfunc;\n    main_arg->a.arg = arg;\n    switch (thrd_create ((thrd_t *) &main_arg->t.tid, thrd_main_func, main_arg))\n      {\n      case thrd_success:\n        break;\n      case thrd_nomem:\n        free (main_arg);\n        return ENOMEM;\n      default:\n        free (main_arg);\n        return EAGAIN;\n      }\n    *threadp = &main_arg->t;\n    return 0;\n  }\n}\n\ngl_thread_t\ngl_thread_self (void)\n{\n  init_thrd_with_exitvalue_key ();\n  {\n    gl_thread_t thread =\n      (struct thrd_with_exitvalue *) tss_get (thrd_with_exitvalue_key);\n    if (thread == NULL)\n      {\n         \n        for (;;)\n          {\n            thread =\n              (struct thrd_with_exitvalue *)\n              malloc (sizeof (struct thrd_with_exitvalue));\n            if (thread != NULL)\n              break;\n             \n            {\n              struct timespec ts =\n                {\n                  .tv_sec = 1,\n                  .tv_nsec = 0\n                };\n              thrd_sleep (&ts, NULL);\n            }\n          }\n        thread->tid = thrd_current ();\n        thread->exitvalue = NULL;  \n        if (tss_set (thrd_with_exitvalue_key, thread) != thrd_success)\n          abort ();\n      }\n    return thread;\n  }\n}\n\nint\nglthread_join (gl_thread_t thread, void **return_value_ptr)\n{\n   \n  int dummy;\n\n  if (thread == gl_thread_self ())\n    return EINVAL;\n  if (thrd_join (thread->tid, &dummy) != thrd_success)\n    return EINVAL;\n  if (return_value_ptr != NULL)\n    *return_value_ptr = thread->exitvalue;\n  free (thread);\n  return 0;\n}\n\n_Noreturn void\ngl_thread_exit (void *return_value)\n{\n  gl_thread_t thread = gl_thread_self ();\n  thread->exitvalue = return_value;\n  thrd_exit (0);\n}\n\n#endif\n\n \n\n#if USE_POSIX_THREADS || USE_ISOC_AND_POSIX_THREADS\n\n#include <pthread.h>\n\n#if defined PTW32_VERSION || defined __MVS__\n\nconst gl_thread_t gl_null_thread  ;\n\n#endif\n\n#endif\n\n \n\n#if USE_WINDOWS_THREADS\n\n#endif\n\n \n\ngl_thread_t\ngl_thread_create (void *(*func) (void *arg), void *arg)\n{\n  gl_thread_t thread;\n  int ret;\n\n  ret = glthread_create (&thread, func, arg);\n  if (ret != 0)\n    abort ();\n  return thread;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}