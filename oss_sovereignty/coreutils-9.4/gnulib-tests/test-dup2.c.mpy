{
  "module_name": "test-dup2.c",
  "hash_id": "205897caf2b93170aa0382c2ca1c30fcd75a429b3b9b0b89a02a5ef59adee804",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-dup2.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <unistd.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (dup2, int, (int, int));\n\n#include <errno.h>\n#include <fcntl.h>\n\n#if HAVE_SYS_RESOURCE_H\n# include <sys/resource.h>\n#endif\n\n#include \"binary-io.h\"\n\n#if GNULIB_TEST_CLOEXEC\n# include \"cloexec.h\"\n#endif\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n \n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n#endif\n\n#include \"macros.h\"\n\n \n#if __GNUC__ >= 13\n# pragma GCC diagnostic ignored \"-Wanalyzer-fd-leak\"\n# pragma GCC diagnostic ignored \"-Wanalyzer-fd-use-without-check\"\n#endif\n\n \nstatic int\nis_open (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}\n\n#if GNULIB_TEST_CLOEXEC\n \nstatic int\nis_inheritable (int fd)\n{\n# if defined _WIN32 && ! defined __CYGWIN__\n   \n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return 0;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n# else\n#  ifndef F_GETFD\n#   error Please port fcntl to your platform\n#  endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n# endif\n}\n#endif  \n\n#if !O_BINARY\n# define set_binary_mode(f,m) zero ()\nstatic int zero (void) { return 0; }\n#endif\n\n \nstatic int\nis_mode (int fd, int mode)\n{\n  int value = set_binary_mode (fd, O_BINARY);\n  set_binary_mode (fd, value);\n  return mode == value;\n}\n\nint\nmain (void)\n{\n  const char *file = \"test-dup2.tmp\";\n  char buffer[1];\n  int bad_fd = getdtablesize ();\n  int fd = open (file, O_CREAT | O_TRUNC | O_RDWR, 0600);\n\n   \n  ASSERT (STDERR_FILENO < fd);\n  ASSERT (is_open (fd));\n   \n  close (fd + 1);\n  close (fd + 2);\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n\n   \n  ASSERT (dup2 (fd, fd) == fd);\n  ASSERT (is_open (fd));\n\n   \n  errno = 0;\n  ASSERT (dup2 (-1, fd) == -1);\n  ASSERT (errno == EBADF);\n  close (99);\n  errno = 0;\n  ASSERT (dup2 (99, fd) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (dup2 (AT_FDCWD, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n   \n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd + 1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_open (fd + 1));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, fd) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (is_open (fd));\n\n   \n  errno = 0;\n  ASSERT (dup2 (fd, -2) == -1);\n  ASSERT (errno == EBADF);\n  if (bad_fd > 256)\n    {\n      ASSERT (dup2 (fd, 255) == 255);\n      ASSERT (dup2 (fd, 256) == 256);\n      ASSERT (close (255) == 0);\n      ASSERT (close (256) == 0);\n    }\n  ASSERT (dup2 (fd, bad_fd - 1) == bad_fd - 1);\n  ASSERT (close (bad_fd - 1) == 0);\n  errno = 0;\n  ASSERT (dup2 (fd, bad_fd) == -1);\n  ASSERT (errno == EBADF);\n\n   \n  ASSERT (dup2 (fd, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n\n   \n  ASSERT (open (\"/dev/null\", O_WRONLY, 0600) == fd + 1);\n  ASSERT (dup2 (fd + 1, fd) == fd);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (write (fd, \"1\", 1) == 1);\n  ASSERT (dup2 (fd + 2, fd) == fd);\n  ASSERT (lseek (fd, 0, SEEK_END) == 0);\n  ASSERT (write (fd + 2, \"2\", 1) == 1);\n  ASSERT (lseek (fd, 0, SEEK_SET) == 0);\n  ASSERT (read (fd, buffer, 1) == 1);\n  ASSERT (*buffer == '2');\n\n#if GNULIB_TEST_CLOEXEC\n   \n  ASSERT (close (fd + 2) == 0);\n  ASSERT (dup_cloexec (fd) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 1) == fd + 1);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (dup2 (fd + 1, fd + 2) == fd + 2);\n  ASSERT (!is_inheritable (fd + 1));\n  ASSERT (is_inheritable (fd + 2));\n  errno = 0;\n  ASSERT (dup2 (fd + 1, -1) == -1);\n  ASSERT (errno == EBADF);\n  ASSERT (!is_inheritable (fd + 1));\n#endif\n\n   \n  set_binary_mode (fd, O_BINARY);\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  set_binary_mode (fd, O_TEXT);\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (dup2 (fd, fd + 1) == fd + 1);\n  ASSERT (is_mode (fd + 1, O_TEXT));\n\n   \n  ASSERT (close (fd + 2) == 0);\n  ASSERT (close (fd + 1) == 0);\n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}