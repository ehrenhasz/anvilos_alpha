{
  "module_name": "test-signbit.c",
  "hash_id": "b4587a60ebb3b4828ce75edf093a7c90c89bd3f58360257a34266bd2c98c2dd7",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-signbit.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <math.h>\n\n \n#ifndef signbit\n# error missing declaration\n#endif\n\n#include <float.h>\n#include <limits.h>\n\n#include \"minus-zero.h\"\n#include \"infinity.h\"\n#include \"macros.h\"\n\nfloat zerof = 0.0f;\ndouble zerod = 0.0;\nlong double zerol = 0.0L;\n\nstatic void\ntest_signbitf ()\n{\n   \n  ASSERT (!signbit (3.141f));\n  ASSERT (!signbit (3.141e30f));\n  ASSERT (!signbit (3.141e-30f));\n  ASSERT (signbit (-2.718f));\n  ASSERT (signbit (-2.718e30f));\n  ASSERT (signbit (-2.718e-30f));\n   \n  ASSERT (!signbit (0.0f));\n  if (1.0f / minus_zerof < 0)\n    ASSERT (signbit (minus_zerof));\n  else\n    ASSERT (!signbit (minus_zerof));\n   \n  ASSERT (!signbit (Infinityf ()));\n  ASSERT (signbit (- Infinityf ()));\n   \n  (void) signbit (zerof / zerof);\n#if defined FLT_EXPBIT0_WORD && defined FLT_EXPBIT0_BIT\n   \n  {\n    #define NWORDS \\\n      ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { float value; unsigned int word[NWORDS]; } memory_float;\n    memory_float m;\n    m.value = zerof / zerof;\n# if FLT_EXPBIT0_BIT > 0\n    m.word[FLT_EXPBIT0_WORD] ^= (unsigned int) 1 << (FLT_EXPBIT0_BIT - 1);\n# else\n    m.word[FLT_EXPBIT0_WORD + (FLT_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    if (FLT_EXPBIT0_WORD < NWORDS / 2)\n      m.word[FLT_EXPBIT0_WORD + 1] |= (unsigned int) 1 << FLT_EXPBIT0_BIT;\n    else\n      m.word[0] |= (unsigned int) 1;\n    (void) signbit (m.value);\n    #undef NWORDS\n  }\n#endif\n}\n\nstatic void\ntest_signbitd ()\n{\n   \n  ASSERT (!signbit (3.141));\n  ASSERT (!signbit (3.141e30));\n  ASSERT (!signbit (3.141e-30));\n  ASSERT (signbit (-2.718));\n  ASSERT (signbit (-2.718e30));\n  ASSERT (signbit (-2.718e-30));\n   \n  ASSERT (!signbit (0.0));\n  if (1.0 / minus_zerod < 0)\n    ASSERT (signbit (minus_zerod));\n  else\n    ASSERT (!signbit (minus_zerod));\n   \n  ASSERT (!signbit (Infinityd ()));\n  ASSERT (signbit (- Infinityd ()));\n   \n  (void) signbit (zerod / zerod);\n#if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n   \n  {\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { double value; unsigned int word[NWORDS]; } memory_double;\n    memory_double m;\n    m.value = zerod / zerod;\n# if DBL_EXPBIT0_BIT > 0\n    m.word[DBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (DBL_EXPBIT0_BIT - 1);\n# else\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[DBL_EXPBIT0_WORD + (DBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << DBL_EXPBIT0_BIT;\n    (void) signbit (m.value);\n    #undef NWORDS\n  }\n#endif\n}\n\nstatic void\ntest_signbitl ()\n{\n   \n  ASSERT (!signbit (3.141L));\n  ASSERT (!signbit (3.141e30L));\n  ASSERT (!signbit (3.141e-30L));\n  ASSERT (signbit (-2.718L));\n  ASSERT (signbit (-2.718e30L));\n  ASSERT (signbit (-2.718e-30L));\n   \n  ASSERT (!signbit (0.0L));\n  if (1.0L / minus_zerol < 0)\n    ASSERT (signbit (minus_zerol));\n  else\n    ASSERT (!signbit (minus_zerol));\n   \n  ASSERT (!signbit (Infinityl ()));\n  ASSERT (signbit (- Infinityl ()));\n   \n  (void) signbit (zerol / zerol);\n#if defined LDBL_EXPBIT0_WORD && defined LDBL_EXPBIT0_BIT\n   \n  {\n    #define NWORDS \\\n      ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n    typedef union { long double value; unsigned int word[NWORDS]; } memory_long_double;\n\n#if defined __powerpc__ && LDBL_MANT_DIG == 106\n     \n    #undef NWORDS\n    #define NWORDS \\\n      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n#endif\n\n    memory_long_double m;\n    m.value = zerol / zerol;\n# if LDBL_EXPBIT0_BIT > 0\n    m.word[LDBL_EXPBIT0_WORD] ^= (unsigned int) 1 << (LDBL_EXPBIT0_BIT - 1);\n# else\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      ^= (unsigned int) 1 << (sizeof (unsigned int) * CHAR_BIT - 1);\n# endif\n    m.word[LDBL_EXPBIT0_WORD + (LDBL_EXPBIT0_WORD < NWORDS / 2 ? 1 : - 1)]\n      |= (unsigned int) 1 << LDBL_EXPBIT0_BIT;\n    (void) signbit (m.value);\n    #undef NWORDS\n  }\n#endif\n}\n\nint\nmain ()\n{\n  test_signbitf ();\n  test_signbitd ();\n  test_signbitl ();\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}