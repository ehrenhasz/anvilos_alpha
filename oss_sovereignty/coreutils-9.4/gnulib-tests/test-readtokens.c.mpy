{
  "module_name": "test-readtokens.c",
  "hash_id": "440c48f4c4714fc791d63042b40e637b64abe402de3625d6db9bbe5860631d9d",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-readtokens.c",
  "human_readable_source": "/* Test the readtokens module.\n   Copyright (C) 2012-2023 Free Software Foundation, Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <https:\n\n#include <config.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"readtokens.h\"\n#include \"closeout.h\"\n#include \"macros.h\"\n\nstatic void\nbasic (void)\n{\n  char const *filename = \"in.827\";\n  int fd = open (filename, O_CREAT | O_WRONLY, 0600);\n  ASSERT (fd >= 0);\n  ASSERT (write (fd, \"a|b;c+d\", 7) == 7);\n  ASSERT (close (fd) == 0);\n\n  {\n    token_buffer tb;\n    FILE *fp = fopen (filename, \"r\");\n    ASSERT (fp);\n\n    init_tokenbuffer (&tb);\n    ASSERT (readtoken (fp, \"|;\", 2, &tb)  == 1 && tb.buffer[0] == 'a');\n    ASSERT (readtoken (fp, \"|;\", 2, &tb) == 1 && tb.buffer[0] == 'b');\n    ASSERT (readtoken (fp, \"+\", 1, &tb)  == 1 && tb.buffer[0] == 'c');\n    ASSERT (readtoken (fp, \"-\", 1, &tb) == 1 && tb.buffer[0] == 'd');\n    ASSERT (readtoken (fp, \"%\", 0, &tb) == (size_t) -1);\n    ASSERT ( ! ferror (fp));\n    ASSERT (fclose (fp) == 0);\n  }\n}\n\nint\nmain (int argc, char **argv)\n{\n  token_buffer tb;\n  char const *delim;\n  size_t delim_len;\n\n  atexit (close_stdout);\n\n  if (argc == 1)\n    {\n      basic ();\n      return 0;\n    }\n\n  init_tokenbuffer (&tb);\n\n  if (argc != 2)\n    return 99;\n\n  delim = argv[1];\n  delim_len = strlen (delim);\n\n  if (STREQ (delim, \"\\\\0\"))\n    {\n      delim = \"\";\n      delim_len = 1;\n    }\n\n  while (1)\n    {\n      size_t token_length = readtoken (stdin, delim, delim_len, &tb);\n      if (token_length == (size_t) -1)\n        break;\n      fwrite (tb.buffer, 1, token_length, stdout);\n      putchar (':');\n    }\n  putchar ('\\n');\n  free (tb.buffer);\n\n  ASSERT ( ! ferror (stdin));\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}