{
  "module_name": "test-select.h",
  "hash_id": "211f07b81c72efdc9eeaa8293513448fc2ba2180ba7725b702f96abc861e44f6",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-select.h",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <errno.h>\n\n#include \"macros.h\"\n\n#if defined _WIN32 && ! defined __CYGWIN__\n# define WINDOWS_NATIVE\n#endif\n\n#ifdef HAVE_SYS_WAIT_H\n# include <sys/wait.h>\n#endif\n\n \n#if __GNUC__ >= 13\n# pragma GCC diagnostic ignored \"-Wanalyzer-fd-use-without-check\"\n#endif\n\ntypedef int (*select_fn) (int, fd_set *, fd_set *, fd_set *, struct timeval *);\n\n\n \n\nstatic int failures;\n\nstatic void\nfailed (const char *reason)\n{\n  if (++failures > 1)\n    printf (\"  \");\n  printf (\"failed (%s)\\n\", reason);\n}\n\nstatic int\ntest (void (*fn) (select_fn), select_fn my_select, const char *msg)\n{\n  failures = 0;\n  printf (\"%s... \", msg);\n  fflush (stdout);\n  fn (my_select);\n\n  if (!failures)\n    printf (\"passed\\n\");\n\n  return failures;\n}\n\n\n \n\nstatic int\nopen_server_socket (void)\n{\n  int s, x;\n  struct sockaddr_in ia;\n\n  s = socket (AF_INET, SOCK_STREAM, 0);\n\n  x = 1;\n  setsockopt (s, SOL_SOCKET, SO_REUSEPORT, &x, sizeof (x));\n\n  memset (&ia, 0, sizeof (ia));\n  ia.sin_family = AF_INET;\n  inet_pton (AF_INET, \"127.0.0.1\", &ia.sin_addr);\n  ia.sin_port = htons (TEST_PORT);\n  if (bind (s, (struct sockaddr *) &ia, sizeof (ia)) < 0)\n    {\n      perror (\"bind\");\n      exit (77);\n    }\n\n  if (listen (s, 1) < 0)\n    {\n      perror (\"listen\");\n      exit (77);\n    }\n\n  return s;\n}\n\nstatic int\nconnect_to_socket (bool blocking)\n{\n  int s;\n  struct sockaddr_in ia;\n\n  s = socket (AF_INET, SOCK_STREAM, 0);\n\n  memset (&ia, 0, sizeof (ia));\n  ia.sin_family = AF_INET;\n  inet_pton (AF_INET, \"127.0.0.1\", &ia.sin_addr);\n  ia.sin_port = htons (TEST_PORT);\n\n  if (!blocking)\n    {\n#ifdef WINDOWS_NATIVE\n      unsigned long iMode = 1;\n      ioctl (s, FIONBIO, (char *) &iMode);\n\n#elif defined F_GETFL\n      int oldflags = fcntl (s, F_GETFL, NULL);\n\n      if (!(oldflags & O_NONBLOCK))\n        fcntl (s, F_SETFL, oldflags | O_NONBLOCK);\n#endif\n    }\n\n  if (connect (s, (struct sockaddr *) &ia, sizeof (ia)) < 0\n      && (blocking || errno != EINPROGRESS))\n    {\n      perror (\"connect\");\n      exit (77);\n    }\n\n  return s;\n}\n\n\n \n\nenum { SEL_IN = 1, SEL_OUT = 2, SEL_EXC = 4 };\n\nstatic int\ndo_select (int fd, int ev, struct timeval *timeout, select_fn my_select)\n{\n  fd_set rfds, wfds, xfds;\n  int r, rev;\n\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n  if (ev & SEL_IN)\n    FD_SET (fd, &rfds);\n  if (ev & SEL_OUT)\n    FD_SET (fd, &wfds);\n  if (ev & SEL_EXC)\n    FD_SET (fd, &xfds);\n  r = my_select (fd + 1, &rfds, &wfds, &xfds, timeout);\n  if (r < 0)\n    return r;\n\n  rev = 0;\n  if (FD_ISSET (fd, &rfds))\n    rev |= SEL_IN;\n  if (FD_ISSET (fd, &wfds))\n    rev |= SEL_OUT;\n  if (FD_ISSET (fd, &xfds))\n    rev |= SEL_EXC;\n  if (rev && r == 0)\n    failed (\"select returned 0\");\n  if (rev & ~ev)\n    failed (\"select returned unrequested events\");\n\n  return rev;\n}\n\nstatic int\ndo_select_nowait (int fd, int ev, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  return do_select (fd, ev, &tv0, my_select);\n}\n\nstatic int\ndo_select_wait (int fd, int ev, select_fn my_select)\n{\n  return do_select (fd, ev, NULL, my_select);\n}\n\n\n \n\n#ifdef INTERACTIVE\nstatic void\ntest_tty (select_fn my_select)\n{\n  if (do_select_nowait (0, SEL_IN, my_select) != 0)\n    failed (\"can read\");\n  if (do_select_nowait (0, SEL_OUT, my_select) == 0)\n    failed (\"cannot write\");\n\n  if (do_select_wait (0, SEL_IN, my_select) == 0)\n    failed (\"return with infinite timeout\");\n\n  getchar ();\n  if (do_select_nowait (0, SEL_IN, my_select) != 0)\n    failed (\"can read after getc\");\n}\n#endif\n\n\nstatic int\ndo_select_bad_nfd_nowait (int nfd, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  errno = 0;\n  return my_select (nfd, NULL, NULL, NULL, &tv0);\n}\n\nstatic void\ntest_bad_nfd (select_fn my_select)\n{\n  if (do_select_bad_nfd_nowait (-1, my_select) != -1 || errno != EINVAL)\n    failed (\"invalid errno after negative nfds\");\n   \n#if 0\n  if (do_select_bad_nfd_nowait (FD_SETSIZE + 1, my_select) != -1\n      || errno != EINVAL)\n    failed (\"invalid errno after bogus nfds\");\n#endif\n}\n\n \n\nstatic int\ndo_select_bad_fd (int fd, int ev, struct timeval *timeout, select_fn my_select)\n{\n  fd_set rfds, wfds, xfds;\n\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n  if (ev & SEL_IN)\n    FD_SET (fd, &rfds);\n  if (ev & SEL_OUT)\n    FD_SET (fd, &wfds);\n  if (ev & SEL_EXC)\n    FD_SET (fd, &xfds);\n  errno = 0;\n  return my_select (fd + 1, &rfds, &wfds, &xfds, timeout);\n   \n}\n\nstatic int\ndo_select_bad_fd_nowait (int fd, int ev, select_fn my_select)\n{\n  struct timeval tv0;\n  tv0.tv_sec = 0;\n  tv0.tv_usec = 0;\n  return do_select_bad_fd (fd, ev, &tv0, my_select);\n}\n\nstatic void\ntest_bad_fd (select_fn my_select)\n{\n   \n#if !(defined __osf__ || defined WINDOWS_NATIVE)\n  int fd;\n\n   \n# if defined __linux__ || (defined __APPLE__ && defined __MACH__) || (defined __FreeBSD__ || defined __DragonFly__) || defined __OpenBSD__ || defined __NetBSD__\n  fd = 14;\n# else\n  fd = 99;\n# endif\n   \n  if (fd >= FD_SETSIZE)\n    fd = FD_SETSIZE - 1;\n  close (fd);\n\n  if (do_select_bad_fd_nowait (fd, SEL_IN, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among rfds\");\n  if (do_select_bad_fd_nowait (fd, SEL_OUT, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among wfds\");\n  if (do_select_bad_fd_nowait (fd, SEL_EXC, my_select) == 0 || errno != EBADF)\n    failed (\"invalid fd among xfds\");\n#endif\n}\n\n\n \n\nstatic void\ntest_connect_first (select_fn my_select)\n{\n  int s = open_server_socket ();\n  struct sockaddr_in ia;\n  socklen_t addrlen;\n\n  int c1, c2;\n\n  if (do_select_nowait (s, SEL_IN | SEL_EXC, my_select) != 0)\n    failed (\"can read, socket not connected\");\n\n  c1 = connect_to_socket (false);\n\n  if (do_select_wait (s, SEL_IN | SEL_EXC, my_select) != SEL_IN)\n    failed (\"expecting readability on passive socket\");\n  if (do_select_nowait (s, SEL_IN | SEL_EXC, my_select) != SEL_IN)\n    failed (\"expecting readability on passive socket\");\n\n  addrlen = sizeof (ia);\n  c2 = accept (s, (struct sockaddr *) &ia, &addrlen);\n  ASSERT (close (s) == 0);\n  ASSERT (close (c1) == 0);\n  ASSERT (close (c2) == 0);\n}\n\n\n \n\nstatic void\ntest_accept_first (select_fn my_select)\n{\n#ifndef WINDOWS_NATIVE\n  int s = open_server_socket ();\n  struct sockaddr_in ia;\n  socklen_t addrlen;\n  char buf[3];\n  int c, pid;\n\n  pid = fork ();\n  if (pid < 0)\n    return;\n\n  if (pid == 0)\n    {\n      addrlen = sizeof (ia);\n      c = accept (s, (struct sockaddr *) &ia, &addrlen);\n      ASSERT (close (s) == 0);\n      ASSERT (write (c, \"foo\", 3) == 3);\n      ASSERT (read (c, buf, 3) == 3);\n      shutdown (c, SHUT_RD);\n      ASSERT (close (c) == 0);\n      exit (0);\n    }\n  else\n    {\n      ASSERT (close (s) == 0);\n      c = connect_to_socket (true);\n      if (do_select_nowait (c, SEL_OUT, my_select) != SEL_OUT)\n        failed (\"cannot write after blocking connect\");\n      ASSERT (write (c, \"foo\", 3) == 3);\n      wait (&pid);\n      if (do_select_wait (c, SEL_IN, my_select) != SEL_IN)\n        failed (\"cannot read data left in the socket by closed process\");\n      ASSERT (read (c, buf, 3) == 3);\n      ASSERT (write (c, \"foo\", 3) == 3);\n      (void) close (c);  \n    }\n#endif\n}\n\n\n \n\nstatic void\ntest_pair (int rd, int wd, select_fn my_select)\n{\n  char buf[3];\n  if (do_select_wait (wd, SEL_IN | SEL_OUT | SEL_EXC, my_select) != SEL_OUT)\n    failed (\"expecting writability before writing\");\n  if (do_select_nowait (wd, SEL_IN | SEL_OUT | SEL_EXC, my_select) != SEL_OUT)\n    failed (\"expecting writability before writing\");\n\n  ASSERT (write (wd, \"foo\", 3) == 3);\n  if (do_select_wait (rd, SEL_IN, my_select) != SEL_IN)\n    failed (\"expecting readability after writing\");\n  if (do_select_nowait (rd, SEL_IN, my_select) != SEL_IN)\n    failed (\"expecting readability after writing\");\n\n  ASSERT (read (rd, buf, 3) == 3);\n}\n\n\n \n\nstatic void\ntest_socket_pair (select_fn my_select)\n{\n  struct sockaddr_in ia;\n\n  socklen_t addrlen = sizeof (ia);\n  int s = open_server_socket ();\n  int c1 = connect_to_socket (false);\n  int c2 = accept (s, (struct sockaddr *) &ia, &addrlen);\n\n  ASSERT (close (s) == 0);\n\n  test_pair (c1, c2, my_select);\n  ASSERT (close (c1) == 0);\n  ASSERT (write (c2, \"foo\", 3) == 3);\n  (void) close (c2);  \n}\n\n\n \n\nstatic void\ntest_pipe (select_fn my_select)\n{\n  int fd[2];\n\n  ASSERT (pipe (fd) == 0);\n  test_pair (fd[0], fd[1], my_select);\n  ASSERT (close (fd[0]) == 0);\n  ASSERT (close (fd[1]) == 0);\n}\n\n\n \n\nstatic int\ntest_function (select_fn my_select)\n{\n  int result = 0;\n\n#ifdef INTERACTIVE\n  printf (\"Please press Enter\\n\");\n  test (test_tty, \"TTY\", my_select);\n#endif\n\n  result += test (test_bad_nfd, my_select, \"Invalid nfd test\");\n  result += test (test_bad_fd, my_select, \"Invalid fd test\");\n  result += test (test_connect_first, my_select, \"Unconnected socket test\");\n  result += test (test_socket_pair, my_select, \"Connected sockets test\");\n  result += test (test_accept_first, my_select, \"General socket test with fork\");\n  result += test (test_pipe, my_select, \"Pipe test\");\n\n  return result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}