{
  "module_name": "test-fcntl.c",
  "hash_id": "f0727611ceb1da7292d69b50b66ed39ae81766210f62c5cf962437f85d930c3a",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-fcntl.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <fcntl.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (fcntl, int, (int, int, ...));\n\n \n#include <errno.h>\n#include <stdarg.h>\n#include <unistd.h>\n\n#if defined _WIN32 && ! defined __CYGWIN__\n \n# define WIN32_LEAN_AND_MEAN\n# include <windows.h>\n \n# if GNULIB_MSVC_NOTHROW\n#  include \"msvc-nothrow.h\"\n# else\n#  include <io.h>\n# endif\n#endif\n\n#include \"binary-io.h\"\n#include \"macros.h\"\n\n \n#if __GNUC__ >= 13\n# pragma GCC diagnostic ignored \"-Wanalyzer-fd-leak\"\n# pragma GCC diagnostic ignored \"-Wanalyzer-va-arg-type-mismatch\"\n#endif\n\n#if !O_BINARY\n# define set_binary_mode(f,m) zero ()\nstatic int zero (void) { return 0; }\n#endif\n\n \nstatic bool\nis_open (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n#else\n# ifndef F_GETFL\n#  error Please port fcntl to your platform\n# endif\n  return 0 <= fcntl (fd, F_GETFL);\n#endif\n}\n\n \nstatic bool\nis_inheritable (int fd)\n{\n#if defined _WIN32 && ! defined __CYGWIN__\n   \n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD flags;\n  if (h == INVALID_HANDLE_VALUE || GetHandleInformation (h, &flags) == 0)\n    return false;\n  return (flags & HANDLE_FLAG_INHERIT) != 0;\n#else\n# ifndef F_GETFD\n#  error Please port fcntl to your platform\n# endif\n  int i = fcntl (fd, F_GETFD);\n  return 0 <= i && (i & FD_CLOEXEC) == 0;\n#endif\n}\n\n \nstatic bool\nis_mode (int fd, int mode)\n{\n  int value = set_binary_mode (fd, O_BINARY);\n  set_binary_mode (fd, value);\n  return mode == value;\n}\n\n \nstruct dummy_struct\n{\n  long filler;\n  int value;\n};\nstatic int\nfunc1 (int a, ...)\n{\n  va_list arg;\n  int i;\n  va_start (arg, a);\n  if (a < 4)\n    i = va_arg (arg, int);\n  else\n    {\n      struct dummy_struct *s = va_arg (arg, struct dummy_struct *);\n      i = s->value;\n    }\n  va_end (arg);\n  return i;\n}\nstatic int\nfunc2 (int a, ...)\n{\n  va_list arg;\n  void *p;\n  va_start (arg, a);\n  p = va_arg (arg, void *);\n  va_end (arg);\n  return func1 (a, p);\n}\n\n \nstatic void\ncheck_flags (void)\n{\n  switch (0)\n    {\n    case F_DUPFD:\n#if F_DUPFD\n#endif\n\n    case F_DUPFD_CLOEXEC:\n#if F_DUPFD_CLOEXEC\n#endif\n\n    case F_GETFD:\n#if F_GETFD\n#endif\n\n#ifdef F_SETFD\n    case F_SETFD:\n# if F_SETFD\n# endif\n#endif\n\n#ifdef F_GETFL\n    case F_GETFL:\n# if F_GETFL\n# endif\n#endif\n\n#ifdef F_SETFL\n    case F_SETFL:\n# if F_SETFL\n# endif\n#endif\n\n#ifdef F_GETOWN\n    case F_GETOWN:\n# if F_GETOWN\n# endif\n#endif\n\n#ifdef F_SETOWN\n    case F_SETOWN:\n# if F_SETOWN\n# endif\n#endif\n\n#ifdef F_GETLK\n    case F_GETLK:\n# if F_GETLK\n# endif\n#endif\n\n#ifdef F_SETLK\n    case F_SETLK:\n# if F_SETLK\n# endif\n#endif\n\n#ifdef F_SETLKW\n    case F_SETLKW:\n# if F_SETLKW\n# endif\n#endif\n\n    default:\n      ;\n    }\n}\n\nint\nmain (int argc, char *argv[])\n{\n  if (argc > 1)\n     \n    return (is_open (10) ? 42 : 0);\n\n  const char *file = \"test-fcntl.tmp\";\n  int fd;\n  int bad_fd = getdtablesize ();\n\n   \n  ASSERT (func2 (1, 2) == 2);\n  ASSERT (func2 (2, -2) == -2);\n  ASSERT (func2 (3, 0x80000000) == 0x80000000);\n  {\n    struct dummy_struct s = { 0L, 4 };\n    ASSERT (func2 (4, &s) == 4);\n  }\n  check_flags ();\n\n   \n  fd = creat (file, 0600);\n  ASSERT (STDERR_FILENO < fd);\n  close (fd + 1);\n  close (fd + 2);\n\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_DUPFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (-1, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_DUPFD_CLOEXEC, 0) == -1);\n  ASSERT (errno == EBADF);\n\n   \n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD, -1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD, bad_fd) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, -1) == -1);\n  ASSERT (errno == EINVAL);\n  errno = 0;\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, bad_fd) == -1);\n  ASSERT (errno == EINVAL\n          || errno == EMFILE  );\n\n   \n  set_binary_mode (fd, O_BINARY);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n  ASSERT (is_inheritable (fd));\n  ASSERT (is_mode (fd, O_BINARY));\n\n  ASSERT (fcntl (fd, F_DUPFD, fd) == fd + 1);\n  ASSERT (is_open (fd));\n  ASSERT (is_open (fd + 1));\n  ASSERT (!is_open (fd + 2));\n  ASSERT (is_inheritable (fd + 1));\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (is_mode (fd + 1, O_BINARY));\n  ASSERT (close (fd + 1) == 0);\n\n  ASSERT (fcntl (fd, F_DUPFD_CLOEXEC, fd + 2) == fd + 2);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (is_inheritable (fd));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd, O_BINARY));\n  ASSERT (is_mode (fd + 2, O_BINARY));\n  ASSERT (close (fd) == 0);\n\n  set_binary_mode (fd + 2, O_TEXT);\n  ASSERT (fcntl (fd + 2, F_DUPFD, fd + 1) == fd + 1);\n  ASSERT (!is_open (fd));\n  ASSERT (is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (is_inheritable (fd + 1));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd + 1, O_TEXT));\n  ASSERT (is_mode (fd + 2, O_TEXT));\n  ASSERT (close (fd + 1) == 0);\n\n  ASSERT (fcntl (fd + 2, F_DUPFD_CLOEXEC, 0) == fd);\n  ASSERT (is_open (fd));\n  ASSERT (!is_open (fd + 1));\n  ASSERT (is_open (fd + 2));\n  ASSERT (!is_inheritable (fd));\n  ASSERT (!is_inheritable (fd + 2));\n  ASSERT (is_mode (fd, O_TEXT));\n  ASSERT (is_mode (fd + 2, O_TEXT));\n  ASSERT (close (fd + 2) == 0);\n\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETFD) == -1);\n  ASSERT (errno == EBADF);\n\n   \n  {\n    int result = fcntl (fd, F_GETFD);\n    ASSERT (0 <= result);\n    ASSERT ((result & FD_CLOEXEC) == FD_CLOEXEC);\n    ASSERT (dup (fd) == fd + 1);\n    result = fcntl (fd + 1, F_GETFD);\n    ASSERT (0 <= result);\n    ASSERT ((result & FD_CLOEXEC) == 0);\n    ASSERT (close (fd + 1) == 0);\n  }\n\n#ifdef F_SETFD\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETFD, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_GETFL\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETFL) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_SETFL\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETFL, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_GETOWN\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_GETOWN) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n#ifdef F_SETOWN\n   \n  errno = 0;\n  ASSERT (fcntl (-1, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (fd + 1, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n  errno = 0;\n  ASSERT (fcntl (bad_fd, F_SETOWN, 0) == -1);\n  ASSERT (errno == EBADF);\n#endif\n\n   \n  ASSERT (close (fd) == 0);\n  ASSERT (unlink (file) == 0);\n\n   \n  (void) close (10);\n\n   \n  ASSERT (fcntl (1, F_DUPFD_CLOEXEC, 10) >= 0);\n#if defined _WIN32 && !defined __CYGWIN__\n  return _execl (\"./test-fcntl\", \"./test-fcntl\", \"child\", NULL);\n#else\n  return execl (\"./test-fcntl\", \"./test-fcntl\", \"child\", NULL);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}