{
  "module_name": "strerror_r.c",
  "hash_id": "006717c3d3ae4677590135e2270a4b7f004f6b9e0f271c1dcede06c38a17722a",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/strerror_r.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#define _NETBSD_SOURCE 1\n\n \n#include <string.h>\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#if !HAVE_SNPRINTF\n# include <stdarg.h>\n#endif\n\n#include \"strerror-override.h\"\n\n#if STRERROR_R_CHAR_P\n\n# if HAVE___XPG_STRERROR_R\n_GL_EXTERN_C int __xpg_strerror_r (int errnum, char *buf, size_t buflen);\n# endif\n\n#elif HAVE_DECL_STRERROR_R\n\n \n\n# include <limits.h>\n\n#else\n\n \n# undef strerror\n\n# if defined __NetBSD__ || defined __hpux || (defined _WIN32 && !defined __CYGWIN__) || defined __sgi || (defined __sun && !defined _LP64) || defined __CYGWIN__\n\n \n\n \n#  if HAVE_CATGETS\n#   include <nl_types.h>\n#  endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n#  if defined __hpux || defined __sgi\nextern int sys_nerr;\nextern char *sys_errlist[];\n#  endif\n\n \n#  if defined __sun && !defined _LP64\nextern int sys_nerr;\n#  endif\n\n#ifdef __cplusplus\n}\n#endif\n\n# else\n\n#  include \"glthread/lock.h\"\n\n \ngl_lock_define_initialized(static, strerror_lock)\n\n# endif\n\n#endif\n\n \n#if !HAVE_SNPRINTF\nstatic int\nlocal_snprintf (char *buf, size_t buflen, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = _vsnprintf (buf, buflen, format, args);\n  va_end (args);\n  if (buflen > 0 && (result < 0 || result >= buflen))\n    buf[buflen - 1] = '\\0';\n  return result;\n}\n# undef snprintf\n# define snprintf local_snprintf\n#endif\n\n \nstatic int\nsafe_copy (char *buf, size_t buflen, const char *msg)\n{\n  size_t len = strlen (msg);\n  size_t moved = len < buflen ? len : buflen - 1;\n\n   \n  memmove (buf, msg, moved);\n  buf[moved] = '\\0';\n  return len < buflen ? 0 : ERANGE;\n}\n\n\nint\nstrerror_r (int errnum, char *buf, size_t buflen)\n#undef strerror_r\n{\n   \n  if (buflen <= 1)\n    {\n      if (buflen)\n        *buf = '\\0';\n      return ERANGE;\n    }\n  *buf = '\\0';\n\n   \n  {\n    char const *msg = strerror_override (errnum);\n\n    if (msg)\n      return safe_copy (buf, buflen, msg);\n  }\n\n  {\n    int ret;\n    int saved_errno = errno;\n\n#if STRERROR_R_CHAR_P\n\n    {\n      ret = 0;\n\n# if HAVE___XPG_STRERROR_R\n      ret = __xpg_strerror_r (errnum, buf, buflen);\n       \n# endif\n\n      if (!*buf)\n        {\n           \n          char stackbuf[80];\n          char *errstring = strerror_r (errnum, stackbuf, sizeof stackbuf);\n          ret = errstring ? safe_copy (buf, buflen, errstring) : errno;\n        }\n    }\n\n#elif HAVE_DECL_STRERROR_R\n\n    if (buflen > INT_MAX)\n      buflen = INT_MAX;\n\n# ifdef __hpux\n     \n    {\n      char stackbuf[80];\n\n      if (buflen < sizeof stackbuf)\n        {\n          ret = strerror_r (errnum, stackbuf, sizeof stackbuf);\n          if (ret == 0)\n            ret = safe_copy (buf, buflen, stackbuf);\n        }\n      else\n        ret = strerror_r (errnum, buf, buflen);\n    }\n# else\n    ret = strerror_r (errnum, buf, buflen);\n\n     \n#  if !defined __HAIKU__\n    if (ret < 0)\n      ret = errno;\n#  endif\n# endif\n\n# if defined _AIX || defined __HAIKU__\n     \n    if (!ret && strlen (buf) == buflen - 1)\n      {\n        char stackbuf[STACKBUF_LEN];\n        size_t len;\n        strerror_r (errnum, stackbuf, sizeof stackbuf);\n        len = strlen (stackbuf);\n         \n        if (len + 1 == sizeof stackbuf)\n          abort ();\n        if (buflen <= len)\n          ret = ERANGE;\n      }\n# else\n     \n    if (ret == ERANGE && strlen (buf) < buflen - 1)\n      {\n        char stackbuf[STACKBUF_LEN];\n\n         \n        if (strerror_r (errnum, stackbuf, sizeof stackbuf) == ERANGE)\n          abort ();\n        safe_copy (buf, buflen, stackbuf);\n      }\n# endif\n\n#else  \n\n     \n\n# if defined __NetBSD__ || defined __hpux || (defined _WIN32 && !defined __CYGWIN__) || defined __CYGWIN__  \n\n     \n    if (errnum >= 0 && errnum < sys_nerr)\n      {\n#  if HAVE_CATGETS && (defined __NetBSD__ || defined __hpux)\n#   if defined __NetBSD__\n        nl_catd catd = catopen (\"libc\", NL_CAT_LOCALE);\n        const char *errmsg =\n          (catd != (nl_catd)-1\n           ? catgets (catd, 1, errnum, sys_errlist[errnum])\n           : sys_errlist[errnum]);\n#   endif\n#   if defined __hpux\n        nl_catd catd = catopen (\"perror\", NL_CAT_LOCALE);\n        const char *errmsg =\n          (catd != (nl_catd)-1\n           ? catgets (catd, 1, 1 + errnum, sys_errlist[errnum])\n           : sys_errlist[errnum]);\n#   endif\n#  else\n        const char *errmsg = sys_errlist[errnum];\n#  endif\n        if (errmsg == NULL || *errmsg == '\\0')\n          ret = EINVAL;\n        else\n          ret = safe_copy (buf, buflen, errmsg);\n#  if HAVE_CATGETS && (defined __NetBSD__ || defined __hpux)\n        if (catd != (nl_catd)-1)\n          catclose (catd);\n#  endif\n      }\n    else\n      ret = EINVAL;\n\n# elif defined __sgi || (defined __sun && !defined _LP64)  \n\n     \n    if (errnum >= 0 && errnum < sys_nerr)\n      {\n        char *errmsg = strerror (errnum);\n\n        if (errmsg == NULL || *errmsg == '\\0')\n          ret = EINVAL;\n        else\n          ret = safe_copy (buf, buflen, errmsg);\n      }\n    else\n      ret = EINVAL;\n\n# else\n\n    gl_lock_lock (strerror_lock);\n\n    {\n      char *errmsg = strerror (errnum);\n\n       \n      if (errmsg == NULL || *errmsg == '\\0')\n        ret = EINVAL;\n      else\n        ret = safe_copy (buf, buflen, errmsg);\n    }\n\n    gl_lock_unlock (strerror_lock);\n\n# endif\n\n#endif\n\n#if defined _WIN32 && !defined __CYGWIN__\n     \n    if (ret == EINVAL)\n      {\n        const char *errmsg;\n\n        switch (errnum)\n          {\n          case 100  :\n            errmsg = \"Address already in use\";\n            break;\n          case 101  :\n            errmsg = \"Cannot assign requested address\";\n            break;\n          case 102  :\n            errmsg = \"Address family not supported by protocol\";\n            break;\n          case 103  :\n            errmsg = \"Operation already in progress\";\n            break;\n          case 105  :\n            errmsg = \"Operation canceled\";\n            break;\n          case 106  :\n            errmsg = \"Software caused connection abort\";\n            break;\n          case 107  :\n            errmsg = \"Connection refused\";\n            break;\n          case 108  :\n            errmsg = \"Connection reset by peer\";\n            break;\n          case 109  :\n            errmsg = \"Destination address required\";\n            break;\n          case 110  :\n            errmsg = \"No route to host\";\n            break;\n          case 112  :\n            errmsg = \"Operation now in progress\";\n            break;\n          case 113  :\n            errmsg = \"Transport endpoint is already connected\";\n            break;\n          case 114  :\n            errmsg = \"Too many levels of symbolic links\";\n            break;\n          case 115  :\n            errmsg = \"Message too long\";\n            break;\n          case 116  :\n            errmsg = \"Network is down\";\n            break;\n          case 117  :\n            errmsg = \"Network dropped connection on reset\";\n            break;\n          case 118  :\n            errmsg = \"Network is unreachable\";\n            break;\n          case 119  :\n            errmsg = \"No buffer space available\";\n            break;\n          case 123  :\n            errmsg = \"Protocol not available\";\n            break;\n          case 126  :\n            errmsg = \"Transport endpoint is not connected\";\n            break;\n          case 128  :\n            errmsg = \"Socket operation on non-socket\";\n            break;\n          case 129  :\n            errmsg = \"Not supported\";\n            break;\n          case 130  :\n            errmsg = \"Operation not supported\";\n            break;\n          case 132  :\n            errmsg = \"Value too large for defined data type\";\n            break;\n          case 133  :\n            errmsg = \"Owner died\";\n            break;\n          case 134  :\n            errmsg = \"Protocol error\";\n            break;\n          case 135  :\n            errmsg = \"Protocol not supported\";\n            break;\n          case 136  :\n            errmsg = \"Protocol wrong type for socket\";\n            break;\n          case 138  :\n            errmsg = \"Connection timed out\";\n            break;\n          case 140  :\n            errmsg = \"Operation would block\";\n            break;\n          default:\n            errmsg = NULL;\n            break;\n          }\n        if (errmsg != NULL)\n          ret = safe_copy (buf, buflen, errmsg);\n      }\n#endif\n\n    if (ret == EINVAL && !*buf)\n      {\n#if defined __HAIKU__\n         \n        snprintf (buf, buflen, \"Unknown Application Error (%d)\", errnum);\n#else\n        snprintf (buf, buflen, \"Unknown error %d\", errnum);\n#endif\n      }\n\n    errno = saved_errno;\n    return ret;\n  }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}