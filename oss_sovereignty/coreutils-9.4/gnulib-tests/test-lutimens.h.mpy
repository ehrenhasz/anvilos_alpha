{
  "module_name": "test-lutimens.h",
  "hash_id": "0086fdfe76bbcf3c0225a7fbbb45e8e44ab9fdffc6fb58956801282f0743c3e7",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-lutimens.h",
  "human_readable_source": " \nstatic int\ntest_lutimens (int (*func) (char const *, struct timespec const *), bool print)\n{\n  int result;\n  int saved_errno;\n  struct stat st1;\n  struct stat st2;\n  bool atime_supported = true;\n\n   \n  errno = 0;\n  ASSERT (func (\"no_such\", NULL) == -1);\n  ASSERT (errno == ENOENT);\n  errno = 0;\n  ASSERT (func (\"no_such/\", NULL) == -1);\n  ASSERT (errno == ENOENT || errno == ENOTDIR);\n  errno = 0;\n  ASSERT (func (\"\", NULL) == -1);\n  ASSERT (errno == ENOENT);\n  ASSERT (close (creat (BASE \"file\", 0600)) == 0);\n  ASSERT (stat (BASE \"file\", &st1) == 0);\n  ASSERT (st1.st_atime != Y2K);\n  ASSERT (st1.st_mtime != Y2K);\n  {\n    struct timespec ts[2];\n    ts[0].tv_sec = Y2K;\n    ts[0].tv_nsec = 0;\n    ts[1] = ts[0];\n    errno = 0;\n    ASSERT (func (BASE \"file/\", ts) == -1);\n    ASSERT (errno == ENOTDIR);\n    ASSERT (stat (BASE \"file\", &st2) == 0);\n    ASSERT (st1.st_atime == st2.st_atime);\n    ASSERT (st1.st_mtime == st2.st_mtime);\n  }\n  {\n    struct timespec ts[2];\n    ts[0].tv_sec = Y2K;\n    ts[0].tv_nsec = 0;\n    ts[1] = ts[0];\n    nap ();\n    ASSERT (func (BASE \"file\", ts) == 0);\n  }\n  ASSERT (stat (BASE \"file\", &st2) == 0);\n  ASSERT (st2.st_atime == Y2K);\n  ASSERT (st2.st_mtime == Y2K);\n  if (check_ctime)\n    ASSERT (ctime_compare (&st1, &st2) < 0);\n\n   \n  if (symlink (BASE \"file\", BASE \"link\"))\n    {\n      ASSERT (unlink (BASE \"file\") == 0);\n      if (print)\n        fputs (\"skipping test: symlinks not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  errno = 0;\n  result = func (BASE \"link\", NULL);\n  saved_errno = errno;\n   \n  ASSERT (stat (BASE \"file\", &st1) == 0);\n  ASSERT (st1.st_atime == Y2K);\n  ASSERT (st1.st_mtime == Y2K);\n  ASSERT (lstat (BASE \"link\", &st1) == 0);\n  ASSERT (st1.st_atime != Y2K);\n  ASSERT (st1.st_mtime != Y2K);\n  ASSERT (unlink (BASE \"file\") == 0);\n  if (result == -1 && saved_errno == ENOSYS)\n    {\n      ASSERT (unlink (BASE \"link\") == 0);\n      if (print)\n        fputs (\"skipping test: \"\n               \"setting symlink time not supported on this file system\\n\",\n               stderr);\n      return 77;\n    }\n  ASSERT (!result);\n  ASSERT (lstat (BASE \"link\", &st1) == 0);\n   \n  nap ();\n  ASSERT (lstat (BASE \"link\", &st2) == 0);\n  if (st1.st_atime != st2.st_atime\n      || get_stat_atime_ns (&st1) != get_stat_atime_ns (&st2))\n    atime_supported = false;\n  ASSERT (st1.st_ctime == st2.st_ctime);\n  ASSERT (get_stat_ctime_ns (&st1) == get_stat_ctime_ns (&st2));\n\n   \n  {\n    struct timespec ts[2];\n    ts[0].tv_sec = Y2K;\n    ts[0].tv_nsec = UTIME_BOGUS_POS;\n    ts[1].tv_sec = Y2K;\n    ts[1].tv_nsec = 0;\n    errno = 0;\n    ASSERT (func (BASE \"link\", ts) == -1);\n    ASSERT (errno == EINVAL);\n  }\n  {\n    struct timespec ts[2];\n    ts[0].tv_sec = Y2K;\n    ts[0].tv_nsec = 0;\n    ts[1].tv_sec = Y2K;\n    ts[1].tv_nsec = UTIME_BOGUS_NEG;\n    errno = 0;\n    ASSERT (func (BASE \"link\", ts) == -1);\n    ASSERT (errno == EINVAL);\n  }\n  ASSERT (lstat (BASE \"link\", &st2) == 0);\n  if (atime_supported)\n    {\n      ASSERT (st1.st_atime == st2.st_atime);\n      ASSERT (get_stat_atime_ns (&st1) == get_stat_atime_ns (&st2));\n    }\n  ASSERT (utimecmp (BASE \"link\", &st1, &st2, 0) == 0);\n\n   \n  {\n    struct timespec ts[2];\n    ts[0].tv_sec = Y2K;\n    ts[0].tv_nsec = BILLION / 2 - 1;\n    ts[1].tv_sec = Y2K;\n    ts[1].tv_nsec = BILLION - 1;\n    nap ();\n    ASSERT (func (BASE \"link\", ts) == 0);\n    ASSERT (lstat (BASE \"link\", &st2) == 0);\n    if (atime_supported)\n      {\n        ASSERT (st2.st_atime == Y2K);\n        ASSERT (0 <= get_stat_atime_ns (&st2));\n        ASSERT (get_stat_atime_ns (&st2) < BILLION / 2);\n      }\n    ASSERT (st2.st_mtime == Y2K);\n    ASSERT (0 <= get_stat_mtime_ns (&st2));\n    ASSERT (get_stat_mtime_ns (&st2) < BILLION);\n    if (check_ctime)\n      ASSERT (ctime_compare (&st1, &st2) < 0);\n  }\n\n   \n  {\n    struct stat st3;\n    struct timespec ts[2];\n    ts[0].tv_sec = BILLION;\n    ts[0].tv_nsec = UTIME_OMIT;\n    ts[1].tv_sec = 0;\n    ts[1].tv_nsec = UTIME_NOW;\n    nap ();\n    ASSERT (func (BASE \"link\", ts) == 0);\n    ASSERT (lstat (BASE \"link\", &st3) == 0);\n    if (atime_supported)\n      {\n        ASSERT (st3.st_atime == Y2K);\n        ASSERT (0 <= get_stat_atime_ns (&st3));\n        ASSERT (get_stat_atime_ns (&st3) < BILLION / 2);\n      }\n    ASSERT (utimecmp (BASE \"link\", &st1, &st3, 0) <= 0);\n    if (check_ctime)\n      ASSERT (ctime_compare (&st2, &st3) < 0);\n    nap ();\n    ts[0].tv_nsec = 0;\n    ts[1].tv_nsec = UTIME_OMIT;\n    ASSERT (func (BASE \"link\", ts) == 0);\n    ASSERT (lstat (BASE \"link\", &st2) == 0);\n    if (atime_supported)\n      {\n        ASSERT (st2.st_atime == BILLION);\n        ASSERT (get_stat_atime_ns (&st2) == 0);\n      }\n    ASSERT (st3.st_mtime == st2.st_mtime);\n    ASSERT (get_stat_mtime_ns (&st3) == get_stat_mtime_ns (&st2));\n    if (check_ctime > 0)\n      ASSERT (ctime_compare (&st3, &st2) < 0);\n  }\n\n   \n  ASSERT (unlink (BASE \"link\") == 0);\n  ASSERT (symlink (BASE \"dir\", BASE \"link\") == 0);\n  ASSERT (mkdir (BASE \"dir\", 0700) == 0);\n  {\n    struct timespec ts[2];\n    ts[0].tv_sec = Y2K;\n    ts[0].tv_nsec = 0;\n    ts[1] = ts[0];\n    ASSERT (func (BASE \"link/\", ts) == 0);\n  }\n   \n  ASSERT (stat (BASE \"dir\", &st1) == 0);\n  ASSERT (st1.st_mtime == Y2K);\n  ASSERT (lstat (BASE \"link\", &st1) == 0);\n  ASSERT (st1.st_atime != Y2K);\n  ASSERT (st1.st_mtime != Y2K);\n  ASSERT (func (BASE \"link\", NULL) == 0);\n  ASSERT (stat (BASE \"dir\", &st1) == 0);\n  ASSERT (st1.st_mtime == Y2K);\n  ASSERT (lstat (BASE \"link\", &st1) == 0);\n  ASSERT (st1.st_atime != Y2K);\n  ASSERT (st1.st_mtime != Y2K);\n\n   \n  ASSERT (rmdir (BASE \"dir\") == 0);\n  ASSERT (unlink (BASE \"link\") == 0);\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}