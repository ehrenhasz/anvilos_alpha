{
  "module_name": "test-nstrftime.c",
  "hash_id": "0ebc455d6288340f92d24454430ec0cd75d51578fd2e353bc736001c48ba3483",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-nstrftime.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include \"strftime.h\"\n\n#include \"intprops.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"macros.h\"\n#define STREQ(a, b) (strcmp (a, b) == 0)\n\n \n#define TZ_ANGLE_BRACKETS_SHOULD_WORK (200112 <= _POSIX_VERSION)\n\nstruct posixtm_test\n{\n  time_t in;\n  int in_ns;\n  char const *fmt;\n  char const *exp;\n};\n\nstatic struct posixtm_test const T[] =\n  {\n    { 1300000000, 0,            \"%F\", \"2011-03-13\" },\n    { 0,          10,           \"%T.%N\", \"00:00:00.000000010\" },\n    { 56,         123456789,    \"%T.%12N\", \"00:00:56.123456789000\" },\n    { 0,          0,            NULL, NULL }\n  };\n\nstatic int\nposixtm_test (void)\n{\n  int fail = 0;\n  unsigned int i;\n\n  for (i = 0; T[i].fmt; i++)\n    {\n      char buf[1000];\n      time_t t = T[i].in;\n      struct tm *tm = gmtime (&t);\n      size_t n;\n\n      ASSERT (tm);\n\n      n = nstrftime (buf, sizeof buf, T[i].fmt, tm, 0, T[i].in_ns);\n      if (n == 0)\n        {\n          fail = 1;\n          printf (\"nstrftime failed with format %s\\n\", T[i].fmt);\n        }\n\n      if (! STREQ (buf, T[i].exp))\n        {\n          fail = 1;\n          printf (\"%s: result mismatch: got %s, expected %s\\n\",\n                  T[i].fmt, buf, T[i].exp);\n        }\n    }\n\n  return fail;\n}\n\nstruct tzalloc_test\n{\n  timezone_t tz;\n  char const *setting;\n};\n\nstatic struct tzalloc_test TZ[] =\n  {\n#define Pacific 0\n    { 0, \"PST8PDT,M3.2.0,M11.1.0\"      },\n#define Arizona 1\n    { 0, \"MST7\"                        },\n#define UTC 2\n    { 0, 0                             },\n#define CentEur 3\n    { 0, \"CET-1CEST,M3.5.0,M10.5.0/3\"  },\n#define Japan 4\n    { 0, \"JST-9\"                       },\n#define NZ 5\n    { 0, \"NZST-12NZDT,M9.5.0,M4.1.0/3\" },\n#define Unknown 6\n    { 0, \"<-00>0\" },\n    { 0 }\n  };\n\nstruct localtime_rz_test\n{\n   \n  struct tzalloc_test *tza;\n  time_t t;\n\n   \n  char const *exp;\n\n   \n  int ahistorical;\n};\n\nstatic struct localtime_rz_test LT[] =\n  {\n    { TZ+Pacific,          0, \"1969-12-31 16:00:00 -0800 (PST)\",  0 },\n    { TZ+Arizona,          0, \"1969-12-31 17:00:00 -0700 (MST)\",  0 },\n    { TZ+UTC    ,          0, \"1970-01-01 00:00:00 +0000 (UTC)\",  0 },\n    { TZ+CentEur,          0, \"1970-01-01 01:00:00 +0100 (CET)\",  0 },\n    { TZ+Japan  ,          0, \"1970-01-01 09:00:00 +0900 (JST)\",  0 },\n    { TZ+NZ     ,          0, \"1970-01-01 13:00:00 +1300 (NZDT)\", 1 },\n    { TZ+Pacific,  500000001, \"1985-11-04 16:53:21 -0800 (PST)\",  0 },\n    { TZ+Arizona,  500000001, \"1985-11-04 17:53:21 -0700 (MST)\",  0 },\n    { TZ+UTC    ,  500000001, \"1985-11-05 00:53:21 +0000 (UTC)\",  0 },\n    { TZ+CentEur,  500000001, \"1985-11-05 01:53:21 +0100 (CET)\",  1 },\n    { TZ+Japan  ,  500000001, \"1985-11-05 09:53:21 +0900 (JST)\",  0 },\n    { TZ+NZ     ,  500000001, \"1985-11-05 13:53:21 +1300 (NZDT)\", 0 },\n    { TZ+Pacific, 1000000002, \"2001-09-08 18:46:42 -0700 (PDT)\",  0 },\n    { TZ+Arizona, 1000000002, \"2001-09-08 18:46:42 -0700 (MST)\",  0 },\n    { TZ+UTC    , 1000000002, \"2001-09-09 01:46:42 +0000 (UTC)\",  0 },\n    { TZ+CentEur, 1000000002, \"2001-09-09 03:46:42 +0200 (CEST)\", 0 },\n    { TZ+Japan  , 1000000002, \"2001-09-09 10:46:42 +0900 (JST)\",  0 },\n    { TZ+NZ     , 1000000002, \"2001-09-09 13:46:42 +1200 (NZST)\", 0 },\n#if TZ_ANGLE_BRACKETS_SHOULD_WORK\n    { TZ+Unknown,          0, \"1970-01-01 00:00:00 -0000 (-00)\",  0 },\n    { TZ+Unknown,  500000001, \"1985-11-05 00:53:21 -0000 (-00)\",  0 },\n    { TZ+Unknown, 1000000002, \"2001-09-09 01:46:42 -0000 (-00)\",  0 },\n#endif\n    { 0 }\n  };\n\nstatic int\ntzalloc_test (void)\n{\n  int fail = 0;\n  int i;\n\n  for (i = 0; LT[i].tza; i++)\n    {\n      struct tzalloc_test *tza = LT[i].tza;\n      long lt = LT[i].t;\n      timezone_t tz = tza->tz;\n      char const *setting;\n      static char const format[] = \"%Y-%m-%d %H:%M:%S %z (%Z)\";\n      char buf[1000];\n      struct tm tm;\n      size_t n;\n\n      if (!tz && tza->setting)\n        {\n          tz = tzalloc (tza->setting);\n          if (!tz)\n            {\n              fail = 1;\n              printf (\"%s: tzalloc: %s\\n\", TZ[i].setting, strerror (errno));\n              continue;\n            }\n          tza->tz = tz;\n        }\n\n      setting = tza->setting ? tza->setting : \"UTC0\";\n\n      if (!localtime_rz (tz, &LT[i].t, &tm))\n        {\n          fail = 1;\n          printf (\"%s: %ld: localtime_rz: %s\\n\", setting, lt,\n                  strerror (errno));\n          continue;\n        }\n\n      n = nstrftime (buf, sizeof buf, format, &tm, tz, 0);\n      if (n == 0)\n        {\n          fail = 1;\n          printf (\"%s: %ld: nstrftime failed\\n\", setting, lt);\n          continue;\n        }\n\n      if (! (STREQ (buf, LT[i].exp)\n             || (!tz && n == strlen (LT[i].exp)\n                 && memcmp (buf, LT[i].exp, n - sizeof \"(GMT)\" + 1) == 0\n                 && STREQ (buf + n - sizeof \"(GMT)\" + 1, \"(GMT)\"))))\n        {\n           \n          if (!LT[i].ahistorical || tm.tm_isdst)\n            fail = 1;\n          printf (\"%s: expected \\\"%s\\\", got \\\"%s\\\"\\n\",\n                  setting, LT[i].exp, buf);\n        }\n    }\n\n  return fail;\n}\n\n\nstatic int\nquarter_test (void)\n{\n  int result = 0;\n  size_t mon;\n\n   \n  for (mon = 1; mon <= 12; mon++)\n    {\n      char out[2];\n      char exp[2] = {0,};\n      struct tm qtm = { .tm_mon = mon - 1 };\n      char fmt[3] = {'%','q','\\0'};\n\n      size_t r = nstrftime (out, sizeof (out), fmt, &qtm, 0, 0);\n      if (r == 0)\n        {\n          puts (\"nstrftime(\\\"%q\\\") failed\");\n          result = 1;\n          break;\n        }\n\n      exp[0] = mon < 4 ? '1' : mon < 7 ? '2' : mon < 10 ? '3' : '4';\n      if (strcmp (out, exp) != 0)\n        {\n          printf (\"nstrftime %%q: expected \\\"%s\\\", got \\\"%s\\\"\\n\", exp, out);\n          result = 1;\n          break;\n        }\n    }\n\n  return result;\n}\n\nstatic int\nerrno_test (void)\n{\n  int fail = 0;\n  struct tm tm = { .tm_year = 2020 - 1900, .tm_mday = 1 };\n  char buf[INT_BUFSIZE_BOUND (time_t)];\n  size_t n;\n  int bigyear = LLONG_MAX - 1900 < INT_MAX ? LLONG_MAX - 1900 : INT_MAX;\n\n  errno = 0;\n  n = nstrftime (buf, 0, \"%m\", &tm, 0, 0);\n  if (! (n == 0 && errno == ERANGE))\n    {\n      fail = 1;\n      printf (\"nstrftime failed to set errno = ERANGE\\n\");\n    }\n\n  errno = 0;\n  n = nstrftime (buf, sizeof buf, \"\", &tm, 0, 0);\n  if (! (n == 0 && errno == 0))\n    {\n      fail = 1;\n      printf (\"nstrftime failed to leave errno alone\\n\");\n    }\n\n\n  tm.tm_year = bigyear;\n  errno = 0;\n  n = nstrftime (buf, sizeof buf, \"%s\", &tm, 0, 0);\n  if (n == 0)\n    {\n      if (errno != EOVERFLOW)\n        {\n          fail = 1;\n          printf (\"nstrftime failed to set errno = EOVERFLOW\\n\");\n        }\n\n      if (mktime_z (0, &tm) != (time_t) -1)\n        {\n          fail = 1;\n          printf (\"nstrftime %%s failed but mktime_z worked for tm_year=%d\\n\",\n                  bigyear);\n        }\n    }\n  else\n    {\n      long long int text_seconds = atoll (buf);\n      if (text_seconds <= (LLONG_MAX - 1 < TYPE_MAXIMUM (time_t)\n                           ? LLONG_MAX - 1 : TYPE_MAXIMUM (time_t)))\n        {\n          time_t bigtime = text_seconds;\n          struct tm *tmp = gmtime (&bigtime);\n          if (!tmp)\n            {\n              fail = 1;\n              printf (\"gmtime failed on nstrftime result\\n\");\n            }\n          else\n            {\n              char buf1[sizeof buf];\n              size_t n1 = nstrftime (buf1, sizeof buf1, \"%s\", tmp, 0, 0);\n              buf1[n1] = '\\0';\n              if (! STREQ (buf, buf1))\n                {\n                  fail = 1;\n                  printf (\"nstrftime %%s first returned '%s', then '%s'\\n\",\n                          buf, buf1);\n                }\n            }\n        }\n    }\n\n  return fail;\n}\n\nint\nmain (void)\n{\n  int fail = 0;\n  fail |= posixtm_test ();\n  fail |= tzalloc_test ();\n  fail |= quarter_test ();\n  fail |= errno_test ();\n  return fail;\n}\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}