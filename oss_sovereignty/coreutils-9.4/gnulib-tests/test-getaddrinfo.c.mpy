{
  "module_name": "test-getaddrinfo.c",
  "hash_id": "d089073a983db02a78496bfbdf3310fc106ed5696a738b1bed363698fdd79ee3",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-getaddrinfo.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <netdb.h>\n\n#include \"signature.h\"\nSIGNATURE_CHECK (gai_strerror, char const *, (int));\n \n#if !(defined _WIN32 && !defined __CYGWIN__)\nSIGNATURE_CHECK (freeaddrinfo, void, (struct addrinfo *));\nSIGNATURE_CHECK (getaddrinfo, int, (char const *, char const *,\n                                    struct addrinfo const *,\n                                    struct addrinfo **));\n#endif\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <netinet/in.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"sockets.h\"\n\n \n#define ENABLE_DEBUGGING 0\n\n#if ENABLE_DEBUGGING\n# define dbgprintf printf\n#else\n# define dbgprintf if (0) printf\n#endif\n\n \n#ifndef AF_UNSPEC\n# define AF_UNSPEC 0\n#endif\n\n#ifndef EAI_SERVICE\n# define EAI_SERVICE 0\n#endif\n\nstatic int\nsimple (char const *host, char const *service)\n{\n  char buf[BUFSIZ];\n  static int skip = 0;\n  struct addrinfo hints;\n  struct addrinfo *ai0, *ai;\n  int res;\n  int err;\n\n   \n  if (skip)\n    return 0;\n\n  dbgprintf (\"Finding %s service %s...\\n\", host, service);\n\n   \n  memset (&hints, 0, sizeof (hints));\n  hints.ai_flags = AI_CANONNAME;\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n\n  res = getaddrinfo (host, service, 0, &ai0);\n  err = errno;\n\n  dbgprintf (\"res %d: %s\\n\", res, gai_strerror (res));\n\n  if (res != 0)\n    {\n       \n      if (res == EAI_AGAIN)\n        {\n          skip++;\n          fprintf (stderr, \"skipping getaddrinfo test: no network?\\n\");\n          return 77;\n        }\n       \n      if (res == EAI_NONAME)\n        return 0;\n       \n      if (res == EAI_SERVICE)\n        return 0;\n#ifdef EAI_NODATA\n       \n      if (res == EAI_NODATA)\n        return 0;\n#endif\n       \n      if (res == EAI_SYSTEM)\n        fprintf (stderr, \"system error: %s\\n\", strerror (err));\n\n      return 1;\n    }\n\n  for (ai = ai0; ai; ai = ai->ai_next)\n    {\n      void *ai_addr = ai->ai_addr;\n      struct sockaddr_in *sock_addr = ai_addr;\n      dbgprintf (\"\\tflags %x\\n\", ai->ai_flags + 0u);\n      dbgprintf (\"\\tfamily %x\\n\", ai->ai_family + 0u);\n      dbgprintf (\"\\tsocktype %x\\n\", ai->ai_socktype + 0u);\n      dbgprintf (\"\\tprotocol %x\\n\", ai->ai_protocol + 0u);\n      dbgprintf (\"\\taddrlen %lu: \", (unsigned long) ai->ai_addrlen);\n      dbgprintf (\"\\tFound %s\\n\",\n                 inet_ntop (ai->ai_family,\n                            &sock_addr->sin_addr,\n                            buf, sizeof (buf) - 1));\n      if (ai->ai_canonname)\n        dbgprintf (\"\\tFound %s...\\n\", ai->ai_canonname);\n\n      {\n        char ipbuf[BUFSIZ];\n        char portbuf[BUFSIZ];\n\n        res = getnameinfo (ai->ai_addr, ai->ai_addrlen,\n                           ipbuf, sizeof (ipbuf) - 1,\n                           portbuf, sizeof (portbuf) - 1,\n                           NI_NUMERICHOST|NI_NUMERICSERV);\n        dbgprintf (\"\\t\\tgetnameinfo %d: %s\\n\", res, gai_strerror (res));\n        if (res == 0)\n          {\n            dbgprintf (\"\\t\\tip %s\\n\", ipbuf);\n            dbgprintf (\"\\t\\tport %s\\n\", portbuf);\n          }\n      }\n\n    }\n\n  freeaddrinfo (ai0);\n\n  return 0;\n}\n\n#define HOST1 \"www.gnu.org\"\n#define SERV1 \"http\"\n#define HOST2 \"www.ibm.com\"\n#define SERV2 \"https\"\n#define HOST3 \"microsoft.com\"\n#define SERV3 \"http\"\n#define HOST4 \"google.org\"\n#define SERV4 \"ldap\"\n\nint main (void)\n{\n  (void) gl_sockets_startup (SOCKETS_1_1);\n\n  return simple (HOST1, SERV1)\n    + simple (HOST2, SERV2)\n    + simple (HOST3, SERV3)\n    + simple (HOST4, SERV4);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}