{
  "module_name": "test-regex.c",
  "hash_id": "b5560c38bfb2ba5bd0f08b82865ce74a1163236354fc720388c043802d799ec5",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-regex.c",
  "human_readable_source": " \nstatic int\nreally_utf8 (void)\n{\n  return strcmp (locale_charset (), \"UTF-8\") == 0;\n}\n\n \nstatic struct\n{\n  const char *pattern;\n  const char *string;\n  int flags, nmatch;\n  regmatch_t rm[5];\n} const tests[] = {\n   \n  { \"[^~]*~\", \"\\nx~y\", 0, 2, { { 0, 3 }, { -1, -1 } } },\n   \n  { \"a(.*)b\", \"a b\", REG_EXTENDED, 2, { { 0, 3 }, { 1, 2 } } },\n  { \".*|\\\\([KIO]\\\\)\\\\([^|]*\\\\).*|?[KIO]\", \"10~.~|P|K0|I10|O16|?KSb\", 0, 3,\n    { { 0, 21 }, { 15, 16 }, { 16, 18 } } },\n  { \".*|\\\\([KIO]\\\\)\\\\([^|]*\\\\).*|?\\\\1\", \"10~.~|P|K0|I10|O16|?KSb\", 0, 3,\n    { { 0, 21 }, { 8, 9 }, { 9, 10 } } },\n  { \"^\\\\(a*\\\\)\\\\1\\\\{9\\\\}\\\\(a\\\\{0,9\\\\}\\\\)\\\\([0-9]*;.*[^a]\\\\2\\\\([0-9]\\\\)\\\\)\",\n    \"a1;;0a1aa2aaa3aaaa4aaaaa5aaaaaa6aaaaaaa7aaaaaaaa8aaaaaaaaa9aa2aa1a0\", 0,\n    5, { { 0, 67 }, { 0, 0 }, { 0, 1 }, { 1, 67 }, { 66, 67 } } },\n   \n  { \"\\\\(^\\\\|foo\\\\)bar\", \"bar\", 0, 2, { { 0, 3 }, { -1, -1 } } },\n  { \"\\\\(foo\\\\|^\\\\)bar\", \"bar\", 0, 2, { { 0, 3 }, { -1, -1 } } },\n   \n  { \"(^|foo)bar\", \"bar\", REG_EXTENDED, 2, { { 0, 3 }, { -1, -1 } } },\n  { \"(foo|^)bar\", \"bar\", REG_EXTENDED, 2, { { 0, 3 }, { -1, -1 } } },\n   \n  { \"(^|foo)bar\", \"(^|foo)bar\", 0, 2, { { 0, 10 }, { -1, -1 } } },\n  { \"(foo|^)bar\", \"(foo|^)bar\", 0, 2, { { 0, 10 }, { -1, -1 } } },\n   \n  { \"()\\\\1\", \"x\", REG_EXTENDED, 2, { { 0, 0 }, { 0, 0 } } },\n  { \"()x\\\\1\", \"x\", REG_EXTENDED, 2, { { 0, 1 }, { 0, 0 } } },\n  { \"()\\\\1*\\\\1*\", \"\", REG_EXTENDED, 2, { { 0, 0 }, { 0, 0 } } },\n  { \"([0-9]).*\\\\1(a*)\", \"7;7a6\", REG_EXTENDED, 3, { { 0, 4 }, { 0, 1 }, { 3, 4 } } },\n  { \"([0-9]).*\\\\1(a*)\", \"7;7a\", REG_EXTENDED, 3, { { 0, 4 }, { 0, 1 }, { 3, 4 } } },\n  { \"(b)()c\\\\1\", \"bcb\", REG_EXTENDED, 3, { { 0, 3 }, { 0, 1 }, { 1, 1 } } },\n  { \"()(b)c\\\\2\", \"bcb\", REG_EXTENDED, 3, { { 0, 3 }, { 0, 0 }, { 0, 1 } } },\n  { \"a(b)()c\\\\1\", \"abcb\", REG_EXTENDED, 3, { { 0, 4 }, { 1, 2 }, { 2, 2 } } },\n  { \"a()(b)c\\\\2\", \"abcb\", REG_EXTENDED, 3, { { 0, 4 }, { 1, 1 }, { 1, 2 } } },\n  { \"()(b)\\\\1c\\\\2\", \"bcb\", REG_EXTENDED, 3, { { 0, 3 }, { 0, 0 }, { 0, 1 } } },\n  { \"(b())\\\\2\\\\1\", \"bbbb\", REG_EXTENDED, 3, { { 0, 2 }, { 0, 1 }, { 1, 1 } } },\n  { \"a()(b)\\\\1c\\\\2\", \"abcb\", REG_EXTENDED, 3, { { 0, 4 }, { 1, 1 }, { 1, 2 } } },\n  { \"a()d(b)\\\\1c\\\\2\", \"adbcb\", REG_EXTENDED, 3, { { 0, 5 }, { 1, 1 }, { 2, 3 } } },\n  { \"a(b())\\\\2\\\\1\", \"abbbb\", REG_EXTENDED, 3, { { 0, 3 }, { 1, 2 }, { 2, 2 } } },\n  { \"(bb())\\\\2\\\\1\", \"bbbb\", REG_EXTENDED, 3, { { 0, 4 }, { 0, 2 }, { 2, 2 } } },\n  { \"^([^,]*),\\\\1,\\\\1$\", \"a,a,a\", REG_EXTENDED, 2, { { 0, 5 }, { 0, 1 } } },\n  { \"^([^,]*),\\\\1,\\\\1$\", \"ab,ab,ab\", REG_EXTENDED, 2, { { 0, 8 }, { 0, 2 } } },\n  { \"^([^,]*),\\\\1,\\\\1,\\\\1$\", \"abc,abc,abc,abc\", REG_EXTENDED, 2,\n    { { 0, 15 }, { 0, 3 } } },\n  { \"^(.?)(.?)(.?)(.?)(.?).?\\\\5\\\\4\\\\3\\\\2\\\\1$\",\n    \"level\", REG_NOSUB | REG_EXTENDED, 0, { { -1, -1 } } },\n  { \"^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.).?\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1$|^.?$\",\n    \"level\", REG_NOSUB | REG_EXTENDED, 0, { { -1, -1 } } },\n  { \"^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.).?\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1$|^.?$\",\n    \"abcdedcba\", REG_EXTENDED, 1, { { 0, 9 } } },\n  { \"^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.).?\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1$|^.?$\",\n    \"ababababa\", REG_EXTENDED, 1, { { 0, 9 } } },\n  { \"^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?).?\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1$\",\n    \"level\", REG_NOSUB | REG_EXTENDED, 0, { { -1, -1 } } },\n  { \"^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?).?\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1$\",\n    \"ababababa\", REG_EXTENDED, 1, { { 0, 9 } } },\n   \n  { \"^a*+(.)\", \"ab\", REG_EXTENDED, 2, { { 0, 2 }, { 1, 2 } } },\n   \n  { \"^(a*)*(.)\", \"ab\", REG_EXTENDED, 3, { { 0, 2 }, { 0, 1 }, { 1, 2 } } },\n};\n\nstatic void\nbug_regex11 (void)\n{\n  regex_t re;\n  regmatch_t rm[5];\n  size_t i;\n  int n;\n\n  for (i = 0; i < sizeof (tests) / sizeof (tests[0]); ++i)\n    {\n      n = regcomp (&re, tests[i].pattern, tests[i].flags);\n      if (n != 0)\n        {\n          char buf[500];\n          regerror (n, &re, buf, sizeof (buf));\n          report_error (\"%s: regcomp %zd failed: %s\", tests[i].pattern, i, buf);\n          continue;\n        }\n\n      if (regexec (&re, tests[i].string, tests[i].nmatch, rm, 0))\n        {\n          report_error (\"%s: regexec %zd failed\", tests[i].pattern, i);\n          regfree (&re);\n          continue;\n        }\n\n      for (n = 0; n < tests[i].nmatch; ++n)\n        if (rm[n].rm_so != tests[i].rm[n].rm_so\n              || rm[n].rm_eo != tests[i].rm[n].rm_eo)\n          {\n            if (tests[i].rm[n].rm_so == -1 && tests[i].rm[n].rm_eo == -1)\n              break;\n            report_error (\"%s: regexec %zd match failure rm[%d] %d..%d\",\n                          tests[i].pattern, i, n,\n                          (int) rm[n].rm_so, (int) rm[n].rm_eo);\n            break;\n          }\n\n      regfree (&re);\n    }\n}\n\nint\nmain (void)\n{\n  static struct re_pattern_buffer regex;\n  unsigned char folded_chars[UCHAR_MAX + 1];\n  int i;\n  const char *s;\n  struct re_registers regs;\n\n#if HAVE_DECL_ALARM\n   \n  int alarm_value = 1000;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  bug_regex11 ();\n\n  if (setlocale (LC_ALL, \"en_US.UTF-8\"))\n    {\n      {\n         \n        static char const pat[] = \"insert into\";\n        static char const data[] =\n          \"\\xFF\\0\\x12\\xA2\\xAA\\xC4\\xB1,K\\x12\\xC4\\xB1*\\xACK\";\n        re_set_syntax (RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE\n                       | RE_ICASE);\n        memset (&regex, 0, sizeof regex);\n        s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n        if (s)\n          report_error (\"%s: %s\", pat, s);\n        else\n          {\n            memset (&regs, 0, sizeof regs);\n            i = re_search (&regex, data, sizeof data - 1,\n                           0, sizeof data - 1, &regs);\n            if (i != -1)\n              report_error (\"re_search '%s' on '%s' returned %d\",\n                            pat, data, i);\n            regfree (&regex);\n            free (regs.start);\n            free (regs.end);\n          }\n      }\n\n      if (really_utf8 ())\n        {\n           \n          static char const pat[] = \"[^x]x\";\n          static char const data[] =\n             \n            \"\\xe1\\x80\\x80\"\n            \"\\xe1\\x80\\xbb\"\n            \"\\xe1\\x80\\xbd\"\n            \"\\xe1\\x80\\x94\"\n            \"\\xe1\\x80\\xba\"\n            \"\\xe1\\x80\\xaf\"\n            \"\\xe1\\x80\\x95\"\n            \"\\xe1\\x80\\xba\"\n            \"x\";\n          re_set_syntax (0);\n          memset (&regex, 0, sizeof regex);\n          s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n          if (s)\n            report_error (\"%s: %s\", pat, s);\n          else\n            {\n              memset (&regs, 0, sizeof regs);\n              i = re_search (&regex, data, sizeof data - 1,\n                             0, sizeof data - 1, 0);\n              if (i != 0 && i != 21)\n                report_error (\"re_search '%s' on '%s' returned %d\",\n                              pat, data, i);\n              regfree (&regex);\n              free (regs.start);\n              free (regs.end);\n            }\n        }\n\n      if (! setlocale (LC_ALL, \"C\"))\n        {\n          report_error (\"setlocale \\\"C\\\" failed\");\n          return exit_status;\n        }\n    }\n\n  if (setlocale (LC_ALL, \"tr_TR.UTF-8\"))\n    {\n      if (really_utf8 () && towupper (L'i') == 0x0130  )\n        {\n          re_set_syntax (RE_SYNTAX_GREP | RE_ICASE);\n          memset (&regex, 0, sizeof regex);\n          static char const pat[] = \"i\";\n          s = re_compile_pattern (pat, sizeof pat - 1, &regex);\n          if (s)\n            report_error (\"%s: %s\", pat, s);\n          else\n            {\n               \n  re_set_syntax (RE_SYNTAX_EGREP | RE_HAT_LISTS_NOT_NEWLINE);\n  memset (&regex, 0, sizeof regex);\n  static char const pat_3957[] = \"a[^x]b\";\n  s = re_compile_pattern (pat_3957, sizeof pat_3957 - 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_3957, s);\n  else\n    {\n       \n      memset (&regs, 0, sizeof regs);\n      static char const data[] = \"a\\nb\";\n      i = re_search (&regex, data, sizeof data - 1, 0, sizeof data - 1, &regs);\n      if (i != -1)\n        report_error (\"re_search '%s' on '%s' returned %d\",\n                      pat_3957, data, i);\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n   \n  re_set_syntax (RE_SYNTAX_POSIX_EGREP);\n  memset (&regex, 0, sizeof regex);\n  for (i = 0; i <= UCHAR_MAX; i++)\n    folded_chars[i] = i;\n  regex.translate = folded_chars;\n  static char const pat75[] = \"a[[:@:>@:]]b\\n\";\n  s = re_compile_pattern (pat75, sizeof pat75 - 1, &regex);\n   \n  if (!s)\n    {\n      report_error (\"re_compile_pattern: failed to reject '%s'\", pat75);\n      regfree (&regex);\n    }\n\n   \n  re_set_syntax (RE_SYNTAX_POSIX_EGREP | RE_NO_EMPTY_RANGES);\n  memset (&regex, 0, sizeof regex);\n  static char const pat_b_a[] = \"a[b-a]\";\n  s = re_compile_pattern (pat_b_a, sizeof pat_b_a - 1, &regex);\n  if (s == 0)\n    {\n      report_error (\"re_compile_pattern: failed to reject '%s'\", pat_b_a);\n      regfree (&regex);\n    }\n\n   \n  memset (&regex, 0, sizeof regex);\n  static char const pat_213[] = \"{1\";\n  s = re_compile_pattern (pat_213, sizeof pat_213 - 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_213, s);\n  else\n    regfree (&regex);\n\n   \n  memset (&regex, 0, sizeof regex);\n  static char const pat_stolfi[] = \"[an\\371]*n\";\n  s = re_compile_pattern (pat_stolfi, sizeof pat_stolfi - 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_stolfi, s);\n   \n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      static char const data[] = \"an\";\n      i = re_match (&regex, data, sizeof data - 1, 0, &regs);\n      if (i != 2)\n        report_error (\"re_match '%s' on '%s' at 2 returned %d\",\n                      pat_stolfi, data, i);\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n  memset (&regex, 0, sizeof regex);\n  static char const pat_x[] = \"x\";\n  s = re_compile_pattern (pat_x, sizeof pat_x - 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_x, s);\n   \n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      static char const data[] = \"wxy\";\n      i = re_search (&regex, data, sizeof data - 1, 2, -2, &regs);\n      if (i != 1)\n        report_error (\"re_search '%s' on '%s' returned %d\", pat_x, data, i);\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n   \n  re_set_syntax (RE_SYNTAX_EMACS | RE_ICASE);\n  memset (&regex, 0, sizeof regex);\n  s = re_compile_pattern (pat_x, 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_x, s);\n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      static char const data[] = \"WXY\";\n      i = re_search (&regex, data, sizeof data - 1, 0, 3, &regs);\n      if (i < 0)\n        report_error (\"re_search '%s' on '%s' returned %d\", pat_x, data, i);\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n   \n  re_set_syntax (RE_SYNTAX_POSIX_BASIC);\n  memset (&regex, 0, sizeof regex);\n  static char const pat_sub2[] = \"\\\\(a*\\\\)*a*\\\\1\";\n  s = re_compile_pattern (pat_sub2, sizeof pat_sub2 - 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_sub2, s);\n  else\n    {\n      memset (&regs, 0, sizeof regs);\n      static char const data[] = \"a\";\n      int datalen = sizeof data - 1;\n      i = re_search (&regex, data, datalen, 0, datalen, &regs);\n      if (i != 0)\n        report_error (\"re_search '%s' on '%s' returned %d\", pat_sub2, data, i);\n      else if (regs.num_regs < 2)\n        report_error (\"re_search '%s' on '%s' returned only %d registers\",\n                      pat_sub2, data, (int) regs.num_regs);\n      else if (! (regs.start[0] == 0 && regs.end[0] == 1))\n        report_error (\"re_search '%s' on '%s' returned wrong match [%d,%d)\",\n                      pat_sub2, data, (int) regs.start[0], (int) regs.end[0]);\n      else if (! (regs.start[1] == 0 && regs.end[1] == 0))\n        report_error (\"re_search '%s' on '%s' returned wrong submatch [%d,%d)\",\n                      pat_sub2, data, (int) regs.start[1], (int) regs.end[1]);\n      regfree (&regex);\n      free (regs.start);\n      free (regs.end);\n    }\n\n   \n  re_set_syntax (RE_SYNTAX_POSIX_BASIC\n                 & ~RE_CONTEXT_INVALID_DUP\n                 & ~RE_NO_EMPTY_RANGES);\n  static char const pat_shelton[] = \"[[:alnum:]_-]\\\\\\\\+$\";\n  s = re_compile_pattern (pat_shelton, sizeof pat_shelton - 1, &regex);\n  if (s)\n    report_error (\"%s: %s\", pat_shelton, s);\n  else\n    regfree (&regex);\n\n   \n  if (REG_STARTEND == 0)\n    report_error (\"REG_STARTEND is zero\");\n\n   \n  re_set_syntax (RE_SYNTAX_POSIX_EGREP);\n  memset (&regex, 0, sizeof regex);\n  static char const pat_badback[] = \"0|()0|\\\\1|0\";\n  s = re_compile_pattern (pat_badback, sizeof pat_badback, &regex);\n  if (!s && re_search (&regex, \"x\", 1, 0, 1, &regs) != -1)\n    s = \"mishandled invalid back reference\";\n  if (s && strcmp (s, \"Invalid back reference\") != 0)\n    report_error (\"%s: %s\", pat_badback, s);\n\n#if 0\n   \n  if (sizeof (regoff_t) < sizeof (ptrdiff_t)\n      || sizeof (regoff_t) < sizeof (ssize_t))\n    report_error (\"regoff_t values are too narrow\");\n#endif\n\n  return exit_status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}