{
  "module_name": "test-pthread-mutex.c",
  "hash_id": "011581a5ba6993b1bd0a7603803e2a0ef0a906390ba4803f99195b1c29d92c16",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-pthread-mutex.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#if USE_ISOC_THREADS || USE_POSIX_THREADS || USE_ISOC_AND_POSIX_THREADS || USE_WINDOWS_THREADS\n\n \n#define ENABLE_LOCKING 1\n\n \n#define DO_TEST_LOCK 1\n#define DO_TEST_RECURSIVE_LOCK 1\n\n \n#define EXPLICIT_YIELD 1\n\n \n#define ENABLE_DEBUGGING 0\n\n \n#define THREAD_COUNT 10\n\n \n#define REPEAT_COUNT 50000\n\n#include <pthread.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if EXPLICIT_YIELD\n# include <sched.h>\n#endif\n\n#if HAVE_DECL_ALARM\n# include <signal.h>\n# include <unistd.h>\n#endif\n\n#include \"macros.h\"\n#include \"atomic-int-posix.h\"\n\n#if ENABLE_DEBUGGING\n# define dbgprintf printf\n#else\n# define dbgprintf if (0) printf\n#endif\n\n#if EXPLICIT_YIELD\n# define yield() sched_yield ()\n#else\n# define yield()\n#endif\n\n \n#if defined __MVS__\n   \n# define pthread_self_pointer() (*((void **) pthread_self ().__))\n#else\n# define pthread_self_pointer() ((void *) (uintptr_t) pthread_self ())\n#endif\n\n#define ACCOUNT_COUNT 4\n\nstatic int account[ACCOUNT_COUNT];\n\nstatic int\nrandom_account (void)\n{\n  return ((unsigned int) rand () >> 3) % ACCOUNT_COUNT;\n}\n\nstatic void\ncheck_accounts (void)\n{\n  int i, sum;\n\n  sum = 0;\n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    sum += account[i];\n  if (sum != ACCOUNT_COUNT * 1000)\n    abort ();\n}\n\n\n \n\n \n\nstatic pthread_mutex_t my_lock;\n\nstatic void *\nlock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      int i1, i2, value;\n\n      dbgprintf (\"Mutator %p before lock\\n\", pthread_self_pointer ());\n      ASSERT (pthread_mutex_lock (&my_lock) == 0);\n      dbgprintf (\"Mutator %p after  lock\\n\", pthread_self_pointer ());\n\n      i1 = random_account ();\n      i2 = random_account ();\n      value = ((unsigned int) rand () >> 3) % 10;\n      account[i1] += value;\n      account[i2] -= value;\n\n      dbgprintf (\"Mutator %p before unlock\\n\", pthread_self_pointer ());\n      ASSERT (pthread_mutex_unlock (&my_lock) == 0);\n      dbgprintf (\"Mutator %p after  unlock\\n\", pthread_self_pointer ());\n\n      dbgprintf (\"Mutator %p before check lock\\n\", pthread_self_pointer ());\n      ASSERT (pthread_mutex_lock (&my_lock) == 0);\n      check_accounts ();\n      ASSERT (pthread_mutex_unlock (&my_lock) == 0);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", pthread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", pthread_self_pointer ());\n  return NULL;\n}\n\nstatic struct atomic_int lock_checker_done;\n\nstatic void *\nlock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&lock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", pthread_self_pointer ());\n      ASSERT (pthread_mutex_lock (&my_lock) == 0);\n      check_accounts ();\n      ASSERT (pthread_mutex_unlock (&my_lock) == 0);\n      dbgprintf (\"Checker %p after  check unlock\\n\", pthread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", pthread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_pthread_mutex_normal (void)\n{\n  int i;\n  pthread_t checkerthread;\n  pthread_t threads[THREAD_COUNT];\n\n   \n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&lock_checker_done);\n  set_atomic_int_value (&lock_checker_done, 0);\n\n   \n  ASSERT (pthread_create (&checkerthread, NULL, lock_checker_thread, NULL)\n          == 0);\n  for (i = 0; i < THREAD_COUNT; i++)\n    ASSERT (pthread_create (&threads[i], NULL, lock_mutator_thread, NULL) == 0);\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    ASSERT (pthread_join (threads[i], NULL) == 0);\n  set_atomic_int_value (&lock_checker_done, 1);\n  ASSERT (pthread_join (checkerthread, NULL) == 0);\n  check_accounts ();\n}\n\n\n \n\n \n\nstatic pthread_mutex_t my_reclock;\n\nstatic void\nrecshuffle (void)\n{\n  int i1, i2, value;\n\n  dbgprintf (\"Mutator %p before lock\\n\", pthread_self_pointer ());\n  ASSERT (pthread_mutex_lock (&my_reclock) == 0);\n  dbgprintf (\"Mutator %p after  lock\\n\", pthread_self_pointer ());\n\n  i1 = random_account ();\n  i2 = random_account ();\n  value = ((unsigned int) rand () >> 3) % 10;\n  account[i1] += value;\n  account[i2] -= value;\n\n   \n  if (((unsigned int) rand () >> 3) % 2)\n    recshuffle ();\n\n  dbgprintf (\"Mutator %p before unlock\\n\", pthread_self_pointer ());\n  ASSERT (pthread_mutex_unlock (&my_reclock) == 0);\n  dbgprintf (\"Mutator %p after  unlock\\n\", pthread_self_pointer ());\n}\n\nstatic void *\nreclock_mutator_thread (void *arg)\n{\n  int repeat;\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      recshuffle ();\n\n      dbgprintf (\"Mutator %p before check lock\\n\", pthread_self_pointer ());\n      ASSERT (pthread_mutex_lock (&my_reclock) == 0);\n      check_accounts ();\n      ASSERT (pthread_mutex_unlock (&my_reclock) == 0);\n      dbgprintf (\"Mutator %p after  check unlock\\n\", pthread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Mutator %p dying.\\n\", pthread_self_pointer ());\n  return NULL;\n}\n\nstatic struct atomic_int reclock_checker_done;\n\nstatic void *\nreclock_checker_thread (void *arg)\n{\n  while (get_atomic_int_value (&reclock_checker_done) == 0)\n    {\n      dbgprintf (\"Checker %p before check lock\\n\", pthread_self_pointer ());\n      ASSERT (pthread_mutex_lock (&my_reclock) == 0);\n      check_accounts ();\n      ASSERT (pthread_mutex_unlock (&my_reclock) == 0);\n      dbgprintf (\"Checker %p after  check unlock\\n\", pthread_self_pointer ());\n\n      yield ();\n    }\n\n  dbgprintf (\"Checker %p dying.\\n\", pthread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_pthread_mutex_recursive (void)\n{\n  int i;\n  pthread_t checkerthread;\n  pthread_t threads[THREAD_COUNT];\n\n   \n  for (i = 0; i < ACCOUNT_COUNT; i++)\n    account[i] = 1000;\n  init_atomic_int (&reclock_checker_done);\n  set_atomic_int_value (&reclock_checker_done, 0);\n\n   \n  ASSERT (pthread_create (&checkerthread, NULL, reclock_checker_thread, NULL)\n          == 0);\n  for (i = 0; i < THREAD_COUNT; i++)\n    ASSERT (pthread_create (&threads[i], NULL, reclock_mutator_thread, NULL)\n            == 0);\n\n   \n  for (i = 0; i < THREAD_COUNT; i++)\n    ASSERT (pthread_join (threads[i], NULL) == 0);\n  set_atomic_int_value (&reclock_checker_done, 1);\n  ASSERT (pthread_join (checkerthread, NULL) == 0);\n  check_accounts ();\n}\n\n\n \n\nint\nmain ()\n{\n#if HAVE_DECL_ALARM\n   \n  int alarm_value = 600;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  {\n    pthread_mutexattr_t attr;\n\n    ASSERT (pthread_mutexattr_init (&attr) == 0);\n    ASSERT (pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_NORMAL) == 0);\n    ASSERT (pthread_mutex_init (&my_lock, &attr) == 0);\n    ASSERT (pthread_mutexattr_destroy (&attr) == 0);\n  }\n\n  {\n    pthread_mutexattr_t attr;\n\n    ASSERT (pthread_mutexattr_init (&attr) == 0);\n    ASSERT (pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE) == 0);\n    ASSERT (pthread_mutex_init (&my_reclock, &attr) == 0);\n    ASSERT (pthread_mutexattr_destroy (&attr) == 0);\n  }\n\n#if DO_TEST_LOCK\n  printf (\"Starting test_pthread_mutex_normal ...\"); fflush (stdout);\n  test_pthread_mutex_normal ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n#if DO_TEST_RECURSIVE_LOCK\n  printf (\"Starting test_pthread_mutex_recursive ...\"); fflush (stdout);\n  test_pthread_mutex_recursive ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}\n\n#else\n\n \n\n#include <stdio.h>\n\nint\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}