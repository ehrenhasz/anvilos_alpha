{
  "module_name": "test-tls.c",
  "hash_id": "8bb214a937db4021d673970fb18ef33dd0b4f15c542e5733317b365dfb6d158d",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-tls.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#if USE_ISOC_THREADS || USE_POSIX_THREADS || USE_ISOC_AND_POSIX_THREADS || USE_WINDOWS_THREADS\n\n#if USE_ISOC_THREADS || USE_ISOC_AND_POSIX_THREADS\n# define TEST_ISOC_THREADS 1\n#endif\n#if USE_POSIX_THREADS\n# define TEST_POSIX_THREADS 1\n#endif\n#if USE_WINDOWS_THREADS\n# define TEST_WINDOWS_THREADS 1\n#endif\n\n \n#define EXPLICIT_YIELD 1\n\n \n#define ENABLE_DEBUGGING 0\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"glthread/tls.h\"\n#include \"glthread/thread.h\"\n#include \"glthread/lock.h\"\n#include \"glthread/yield.h\"\n\n#if HAVE_DECL_ALARM\n# include <signal.h>\n# include <unistd.h>\n#endif\n\n#if ENABLE_DEBUGGING\n# define dbgprintf printf\n#else\n# define dbgprintf if (0) printf\n#endif\n\n#if EXPLICIT_YIELD\n# define yield() gl_thread_yield ()\n#else\n# define yield()\n#endif\n\nstatic void\nperhaps_yield (void)\n{\n   \n  if ((((unsigned int) rand () >> 3) % 4) == 0)\n    yield ();\n}\n\n\n \n\n \n#define THREAD_COUNT 16\n\n \n#define REPEAT_COUNT 50000\n\n#define KEYS_COUNT 4\n\nstatic gl_tls_key_t mykeys[KEYS_COUNT];\n\nstatic void *\nworker_thread (void *arg)\n{\n  unsigned int id = (unsigned int) (uintptr_t) arg;\n  int i, j, repeat;\n  unsigned int values[KEYS_COUNT];\n\n  dbgprintf (\"Worker %p started\\n\", gl_thread_self_pointer ());\n\n   \n  for (i = 0; i < KEYS_COUNT; i++)\n    {\n      values[i] = (((unsigned int) rand () >> 3) % 1000000) * THREAD_COUNT + id;\n       \n      if ((values[i] % THREAD_COUNT) != id)\n        abort ();\n    }\n  perhaps_yield ();\n\n   \n  dbgprintf (\"Worker %p before initial verify\\n\", gl_thread_self_pointer ());\n  for (i = 0; i < KEYS_COUNT; i++)\n    if (gl_tls_get (mykeys[i]) != NULL)\n      abort ();\n  dbgprintf (\"Worker %p after  initial verify\\n\", gl_thread_self_pointer ());\n  perhaps_yield ();\n\n   \n  dbgprintf (\"Worker %p before first tls_set\\n\", gl_thread_self_pointer ());\n  for (i = 0; i < KEYS_COUNT; i++)\n    {\n      unsigned int *ptr = (unsigned int *) malloc (sizeof (unsigned int));\n      *ptr = values[i];\n      gl_tls_set (mykeys[i], ptr);\n    }\n  dbgprintf (\"Worker %p after  first tls_set\\n\", gl_thread_self_pointer ());\n  perhaps_yield ();\n\n   \n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      dbgprintf (\"Worker %p doing value swapping\\n\", gl_thread_self_pointer ());\n      i = ((unsigned int) rand () >> 3) % KEYS_COUNT;\n      j = ((unsigned int) rand () >> 3) % KEYS_COUNT;\n      if (i != j)\n        {\n          void *vi = gl_tls_get (mykeys[i]);\n          void *vj = gl_tls_get (mykeys[j]);\n\n          gl_tls_set (mykeys[i], vj);\n          gl_tls_set (mykeys[j], vi);\n        }\n      perhaps_yield ();\n    }\n\n   \n  dbgprintf (\"Worker %p before final verify\\n\", gl_thread_self_pointer ());\n  for (i = 0; i < KEYS_COUNT; i++)\n    if ((*(unsigned int *) gl_tls_get (mykeys[i]) % THREAD_COUNT) != id)\n      abort ();\n  dbgprintf (\"Worker %p after  final verify\\n\", gl_thread_self_pointer ());\n  perhaps_yield ();\n\n  dbgprintf (\"Worker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_tls (void)\n{\n  int pass, i;\n\n  for (pass = 0; pass < 2; pass++)\n    {\n      gl_thread_t threads[THREAD_COUNT];\n\n      if (pass == 0)\n        for (i = 0; i < KEYS_COUNT; i++)\n          gl_tls_key_init (mykeys[i], free);\n      else\n        for (i = KEYS_COUNT - 1; i >= 0; i--)\n          gl_tls_key_init (mykeys[i], free);\n\n       \n      for (i = 0; i < THREAD_COUNT; i++)\n        threads[i] = gl_thread_create (worker_thread, (void *) (uintptr_t) i);\n\n       \n      for (i = 0; i < THREAD_COUNT; i++)\n        gl_thread_join (threads[i], NULL);\n\n      for (i = 0; i < KEYS_COUNT; i++)\n        gl_tls_key_destroy (mykeys[i]);\n    }\n}\n\n#undef KEYS_COUNT\n#undef REPEAT_COUNT\n#undef THREAD_COUNT\n\n\n \n\n \n#define THREAD_COUNT 10\n\n \n#define KEYS_COUNT 10\n\ngl_lock_define_initialized(static, sumlock)\nstatic uintptr_t sum;\n\nstatic void\ninc_sum (uintptr_t value)\n{\n  gl_lock_lock (sumlock);\n  sum += value;\n  gl_lock_unlock (sumlock);\n}\n\nstatic void\ndestructor0 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 0)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor1 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 1)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor2 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 2)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor3 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 3)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor4 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 4)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor5 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 5)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor6 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 6)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor7 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 7)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor8 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 8)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void\ndestructor9 (void *value)\n{\n  if ((((uintptr_t) value - 1) % 10) != 9)\n    abort ();\n  inc_sum ((uintptr_t) value);\n}\n\nstatic void (*destructor_table[10]) (void *) =\n  {\n    destructor0,\n    destructor1,\n    destructor2,\n    destructor3,\n    destructor4,\n    destructor5,\n    destructor6,\n    destructor7,\n    destructor8,\n    destructor9\n  };\n\nstatic gl_tls_key_t dtorcheck_keys[THREAD_COUNT][KEYS_COUNT];\n\n \nstatic void *\ndtorcheck1_thread (void *arg)\n{\n  unsigned int id = (unsigned int) (uintptr_t) arg;\n  gl_tls_key_t *keys = dtorcheck_keys[id];  \n  int i;\n\n  for (i = 0; i < KEYS_COUNT; i++)\n    gl_tls_key_init (keys[i], destructor_table[i]);\n\n  for (i = 0; i < KEYS_COUNT; i++)\n    gl_tls_set (keys[i], (void *) (uintptr_t) (10 * id + i + 1));\n\n  return NULL;\n}\n\nstatic void\ntest_tls_dtorcheck1 (void)\n{\n  gl_thread_t threads[THREAD_COUNT];\n  unsigned int id;\n  int i;\n  uintptr_t expected_sum;\n\n  sum = 0;\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    threads[id] = gl_thread_create (dtorcheck1_thread, (void *) (uintptr_t) id);\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    gl_thread_join (threads[id], NULL);\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    for (i = 0; i < KEYS_COUNT; i++)\n      gl_tls_key_destroy (dtorcheck_keys[id][i]);\n\n   \n  expected_sum = 10 * KEYS_COUNT * (THREAD_COUNT * (THREAD_COUNT - 1) / 2)\n                 + THREAD_COUNT * (KEYS_COUNT * (KEYS_COUNT - 1) / 2)\n                 + THREAD_COUNT * KEYS_COUNT;\n  if (sum != expected_sum)\n    abort ();\n}\n\n \nstatic void *\ndtorcheck2_thread (void *arg)\n{\n  unsigned int id = (unsigned int) (uintptr_t) arg;\n  gl_tls_key_t *keys = dtorcheck_keys[id];  \n  int i;\n\n  for (i = 0; i < KEYS_COUNT; i++)\n    gl_tls_key_init (keys[i], destructor_table[id]);\n\n  for (i = 0; i < KEYS_COUNT; i++)\n    gl_tls_set (keys[i], (void *) (uintptr_t) (10 * i + id + 1));\n\n  return NULL;\n}\n\nstatic void\ntest_tls_dtorcheck2 (void)\n{\n  gl_thread_t threads[THREAD_COUNT];\n  unsigned int id;\n  int i;\n  uintptr_t expected_sum;\n\n  sum = 0;\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    threads[id] = gl_thread_create (dtorcheck2_thread, (void *) (uintptr_t) id);\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    gl_thread_join (threads[id], NULL);\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    for (i = 0; i < KEYS_COUNT; i++)\n      gl_tls_key_destroy (dtorcheck_keys[id][i]);\n\n   \n  expected_sum = 10 * THREAD_COUNT * (KEYS_COUNT * (KEYS_COUNT - 1) / 2)\n                 + KEYS_COUNT * (THREAD_COUNT * (THREAD_COUNT - 1) / 2)\n                 + THREAD_COUNT * KEYS_COUNT;\n  if (sum != expected_sum)\n    abort ();\n}\n\n#undef KEYS_COUNT\n#undef THREAD_COUNT\n\n\n \n\n \n#define THREAD_COUNT 10\n\n \n#define KEYS_COUNT 10\n\n \n#define REPEAT_COUNT 100000\n\nstatic gl_tls_key_t racecheck_keys[THREAD_COUNT][KEYS_COUNT];\n\n \nstatic void *\nracecheck_thread (void *arg)\n{\n  unsigned int id = (unsigned int) (uintptr_t) arg;\n  gl_tls_key_t *keys = racecheck_keys[id];  \n  int repeat;\n  int i;\n\n  dbgprintf (\"Worker %p started\\n\", gl_thread_self_pointer ());\n\n  for (i = 0; i < KEYS_COUNT; i++)\n    {\n      gl_tls_key_init (keys[i], destructor_table[i]);\n      gl_tls_set (keys[i], (void *) (uintptr_t) (10 * id + i + 1));\n    }\n\n  for (repeat = REPEAT_COUNT; repeat > 0; repeat--)\n    {\n      i = ((unsigned int) rand () >> 3) % KEYS_COUNT;\n      dbgprintf (\"Worker %p reallocating key %d\\n\", gl_thread_self_pointer (), i);\n      gl_tls_key_destroy (keys[i]);\n      gl_tls_key_init (keys[i], destructor_table[i]);\n      gl_tls_set (keys[i], (void *) (uintptr_t) (10 * id + i + 1));\n    }\n\n  dbgprintf (\"Worker %p dying.\\n\", gl_thread_self_pointer ());\n  return NULL;\n}\n\nstatic void\ntest_tls_racecheck (void)\n{\n  gl_thread_t threads[THREAD_COUNT];\n  unsigned int id;\n  int i;\n  uintptr_t expected_sum;\n\n  sum = 0;\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    threads[id] = gl_thread_create (racecheck_thread, (void *) (uintptr_t) id);\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    gl_thread_join (threads[id], NULL);\n\n   \n  for (id = 0; id < THREAD_COUNT; id++)\n    for (i = 0; i < KEYS_COUNT; i++)\n      gl_tls_key_destroy (racecheck_keys[id][i]);\n\n   \n  expected_sum = 10 * KEYS_COUNT * (THREAD_COUNT * (THREAD_COUNT - 1) / 2)\n                 + THREAD_COUNT * (KEYS_COUNT * (KEYS_COUNT - 1) / 2)\n                 + THREAD_COUNT * KEYS_COUNT;\n  if (sum != expected_sum)\n    abort ();\n}\n\n#undef REPEAT_COUNT\n#undef KEYS_COUNT\n#undef THREAD_COUNT\n\n\n \n\nint\nmain ()\n{\n#if HAVE_DECL_ALARM\n   \n  int alarm_value = 600;\n  signal (SIGALRM, SIG_DFL);\n  alarm (alarm_value);\n#endif\n\n  printf (\"Starting test_tls ...\"); fflush (stdout);\n  test_tls ();\n  printf (\" OK\\n\"); fflush (stdout);\n\n  printf (\"Starting test_tls_dtorcheck1 ...\"); fflush (stdout);\n  test_tls_dtorcheck1 ();\n  printf (\" OK\\n\"); fflush (stdout);\n\n  printf (\"Starting test_tls_dtorcheck2 ...\"); fflush (stdout);\n  test_tls_dtorcheck2 ();\n  printf (\" OK\\n\"); fflush (stdout);\n\n   \n#if (defined _WIN32 && ! defined __CYGWIN__) && TEST_POSIX_THREADS\n  fputs (\"Skipping test: it is known to hang with the mingw-w64 winpthreads.\\n\",\n         stderr);\n  exit (77);\n#else\n  printf (\"Starting test_tls_racecheck ...\"); fflush (stdout);\n  test_tls_racecheck ();\n  printf (\" OK\\n\"); fflush (stdout);\n#endif\n\n  return 0;\n}\n\n#else\n\n \n\n#include <stdio.h>\n\nint\nmain ()\n{\n  fputs (\"Skipping test: multithreading not enabled\\n\", stderr);\n  return 77;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}