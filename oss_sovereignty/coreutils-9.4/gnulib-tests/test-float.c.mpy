{
  "module_name": "test-float.c",
  "hash_id": "43c11a23da0458f87b3891591967193e70353b21d120bcc008cbb6a6ec36fc5a",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-float.c",
  "human_readable_source": " \n\n#include <config.h>\n\n#include <float.h>\n\n \nint a[] = { FLT_RADIX };\n\n \n\n \nint fb[] =\n  {\n    FLT_MANT_DIG, FLT_MIN_EXP, FLT_MAX_EXP,\n    FLT_DIG, FLT_MIN_10_EXP, FLT_MAX_10_EXP\n  };\nfloat fc[] = { FLT_EPSILON, FLT_MIN, FLT_MAX };\n\n \n\n \nint db[] =\n  {\n    DBL_MANT_DIG, DBL_MIN_EXP, DBL_MAX_EXP,\n    DBL_DIG, DBL_MIN_10_EXP, DBL_MAX_10_EXP\n  };\ndouble dc[] = { DBL_EPSILON, DBL_MIN, DBL_MAX };\n\n \n\n \nint lb[] =\n  {\n    LDBL_MANT_DIG, LDBL_MIN_EXP, LDBL_MAX_EXP,\n    LDBL_DIG, LDBL_MIN_10_EXP, LDBL_MAX_10_EXP\n  };\nlong double lc1 = LDBL_EPSILON;\nlong double lc2 = LDBL_MIN;\n#if 0  \nlong double lc3 = LDBL_MAX;\n#endif\n\n \n\n#include \"fpucw.h\"\n#include \"macros.h\"\n\n#if FLT_RADIX == 2\n\n \nstatic float\npow2f (int n)\n{\n  int k = n;\n  volatile float x = 1;\n  volatile float y = 2;\n   \n  if (k < 0)\n    {\n      y = 0.5f;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n   \n  return x;\n}\n\n \nstatic double\npow2d (int n)\n{\n  int k = n;\n  volatile double x = 1;\n  volatile double y = 2;\n   \n  if (k < 0)\n    {\n      y = 0.5;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n   \n  return x;\n}\n\n \nstatic long double\npow2l (int n)\n{\n  int k = n;\n  volatile long double x = 1;\n  volatile long double y = 2;\n   \n  if (k < 0)\n    {\n      y = 0.5L;\n      k = - k;\n    }\n  while (k > 0)\n    {\n      if (k != 2 * (k / 2))\n        {\n          x = x * y;\n          k = k - 1;\n        }\n      if (k == 0)\n        break;\n      y = y * y;\n      k = k / 2;\n    }\n   \n  return x;\n}\n\n \n\nstatic void\ntest_float (void)\n{\n   \n  ASSERT ((FLT_MIN_EXP % 101111) == (FLT_MIN_EXP) % 101111);\n\n   \n  ASSERT ((FLT_MIN_10_EXP % 101111) == (FLT_MIN_10_EXP) % 101111);\n\n   \n  ASSERT (FLT_MANT_DIG == 24);\n  ASSERT (FLT_MIN_EXP == -125);\n  ASSERT (FLT_MAX_EXP == 128);\n\n   \n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n   \n  ASSERT (FLT_DIG == (int) ((FLT_MANT_DIG - 1) * 0.30103));\n\n   \n  ASSERT (FLT_MIN_10_EXP == - (int) (- (FLT_MIN_EXP - 1) * 0.30103));\n\n   \n  ASSERT (FLT_MAX_10_EXP == (int) (FLT_MAX_EXP * 0.30103));\n\n   \n  {\n    volatile float m = FLT_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float pow2_n = pow2f (n);  \n        volatile float x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n   \n  {\n    volatile float m = FLT_MIN;\n    volatile float x = pow2f (FLT_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n   \n  {\n    volatile float e = FLT_EPSILON;\n    volatile float me;\n    int n;\n\n    me = 1.0f + e;\n    ASSERT (me > 1.0f);\n    ASSERT (me - 1.0f == e);\n    for (n = 0; n <= 2 * FLT_MANT_DIG; n++)\n      {\n        volatile float half_n = pow2f (- n);  \n        volatile float x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0f);\n      }\n  }\n}\n\n \n\nstatic void\ntest_double (void)\n{\n   \n  ASSERT ((DBL_MIN_EXP % 101111) == (DBL_MIN_EXP) % 101111);\n\n   \n  ASSERT ((DBL_MIN_10_EXP % 101111) == (DBL_MIN_10_EXP) % 101111);\n\n   \n  ASSERT (DBL_MANT_DIG == 53);\n  ASSERT (DBL_MIN_EXP == -1021);\n  ASSERT (DBL_MAX_EXP == 1024);\n\n   \n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n   \n  ASSERT (DBL_DIG == (int) ((DBL_MANT_DIG - 1) * 0.30103));\n\n   \n  ASSERT (DBL_MIN_10_EXP == - (int) (- (DBL_MIN_EXP - 1) * 0.30103));\n\n   \n  ASSERT (DBL_MAX_10_EXP == (int) (DBL_MAX_EXP * 0.30103));\n\n   \n  {\n    volatile double m = DBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double pow2_n = pow2d (n);  \n        volatile double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n   \n  {\n    volatile double m = DBL_MIN;\n    volatile double x = pow2d (DBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n   \n  {\n    volatile double e = DBL_EPSILON;\n    volatile double me;\n    int n;\n\n    me = 1.0 + e;\n    ASSERT (me > 1.0);\n    ASSERT (me - 1.0 == e);\n    for (n = 0; n <= 2 * DBL_MANT_DIG; n++)\n      {\n        volatile double half_n = pow2d (- n);  \n        volatile double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0);\n      }\n  }\n}\n\n \n\nstatic void\ntest_long_double (void)\n{\n   \n  ASSERT ((LDBL_MIN_EXP % 101111) == (LDBL_MIN_EXP) % 101111);\n\n   \n  ASSERT ((LDBL_MIN_10_EXP % 101111) == (LDBL_MIN_10_EXP) % 101111);\n\n   \n  ASSERT (LDBL_MANT_DIG >= DBL_MANT_DIG);\n  ASSERT (LDBL_MIN_EXP - LDBL_MANT_DIG <= DBL_MIN_EXP - DBL_MANT_DIG);\n  ASSERT (LDBL_MAX_EXP >= DBL_MAX_EXP);\n\n   \n  ASSERT (LDBL_DIG == (int)((LDBL_MANT_DIG - 1) * 0.30103));\n\n   \n  ASSERT (LDBL_MIN_10_EXP == - (int) (- (LDBL_MIN_EXP - 1) * 0.30103));\n\n   \n  ASSERT (LDBL_MAX_10_EXP == (int) (LDBL_MAX_EXP * 0.30103));\n\n   \n  {\n    volatile long double m = LDBL_MAX;\n    int n;\n\n    ASSERT (m + m > m);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double pow2_n = pow2l (n);  \n        volatile long double x = m + (m / pow2_n);\n        if (x > m)\n          ASSERT (x + x == x);\n        else\n          ASSERT (!(x + x == x));\n      }\n  }\n\n   \n  {\n    volatile long double m = LDBL_MIN;\n    volatile long double x = pow2l (LDBL_MIN_EXP - 1);\n    ASSERT (m == x);\n  }\n\n   \n  {\n    volatile long double e = LDBL_EPSILON;\n    volatile long double me;\n    int n;\n\n    me = 1.0L + e;\n    ASSERT (me > 1.0L);\n    ASSERT (me - 1.0L == e);\n    for (n = 0; n <= 2 * LDBL_MANT_DIG; n++)\n      {\n        volatile long double half_n = pow2l (- n);  \n        volatile long double x = me - half_n;\n        if (x < me)\n          ASSERT (x <= 1.0L);\n      }\n  }\n}\n\nint\nmain ()\n{\n  test_float ();\n  test_double ();\n\n  {\n    DECL_LONG_DOUBLE_ROUNDING\n\n    BEGIN_LONG_DOUBLE_ROUNDING ();\n\n    test_long_double ();\n\n    END_LONG_DOUBLE_ROUNDING ();\n  }\n\n  return 0;\n}\n\n#else\n\nint\nmain ()\n{\n  fprintf (stderr, \"Skipping test: FLT_RADIX is not 2.\\n\");\n  return 77;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}