{
  "module_name": "c32rtomb.c",
  "hash_id": "6f89e236790f3d09910f9f7ff1c70dd083a4abaeb86b0a00eb93157c4c06fe7f",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/c32rtomb.c",
  "human_readable_source": " \n\n#include <config.h>\n\n \n#include <uchar.h>\n\n#include <errno.h>\n#include <wchar.h>\n\n#include \"attribute.h\"  \n#include \"localcharset.h\"\n#include \"streq.h\"\n\n#if GL_CHAR32_T_IS_UNICODE\n# include \"lc-charset-unicode.h\"\n#endif\n\nsize_t\nc32rtomb (char *s, char32_t wc, mbstate_t *ps)\n#undef c32rtomb\n{\n#if HAVE_WORKING_MBRTOC32\n\n# if C32RTOMB_RETVAL_BUG\n  if (s == NULL)\n     \n    return 1;\n# endif\n\n  return c32rtomb (s, wc, ps);\n\n#elif _GL_SMALL_WCHAR_T\n\n  if (s == NULL)\n    return wcrtomb (NULL, 0, ps);\n  else\n    {\n       \n      const char *encoding = locale_charset ();\n      if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n        {\n           \n          if (wc < 0x80)\n            {\n              s[0] = (unsigned char) wc;\n              return 1;\n            }\n          else\n            {\n              int count;\n\n              if (wc < 0x800)\n                count = 2;\n              else if (wc < 0x10000)\n                {\n                  if (wc < 0xd800 || wc >= 0xe000)\n                    count = 3;\n                  else\n                    {\n                      errno = EILSEQ;\n                      return (size_t)(-1);\n                    }\n                }\n              else if (wc < 0x110000)\n                count = 4;\n              else\n                {\n                  errno = EILSEQ;\n                  return (size_t)(-1);\n                }\n\n              switch (count)  \n                {\n                case 4: s[3] = 0x80 | (wc & 0x3f); wc = wc >> 6; wc |= 0x10000;\n                  FALLTHROUGH;\n                case 3: s[2] = 0x80 | (wc & 0x3f); wc = wc >> 6; wc |= 0x800;\n                  FALLTHROUGH;\n                case 2: s[1] = 0x80 | (wc & 0x3f); wc = wc >> 6; wc |= 0xc0;\n                s[0] = wc;\n                }\n              return count;\n            }\n        }\n      else\n        {\n          if ((wchar_t) wc == wc)\n            return wcrtomb (s, (wchar_t) wc, ps);\n          else\n            {\n              errno = EILSEQ;\n              return (size_t)(-1);\n            }\n        }\n    }\n\n#else\n\n   \n# if GL_CHAR32_T_IS_UNICODE && GL_CHAR32_T_VS_WCHAR_T_NEEDS_CONVERSION\n  if (wc != 0)\n    {\n      wc = unicode_to_locale_encoding (wc);\n      if (wc == 0)\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n# endif\n  return wcrtomb (s, (wchar_t) wc, ps);\n\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}