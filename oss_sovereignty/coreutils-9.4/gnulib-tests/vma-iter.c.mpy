{
  "module_name": "vma-iter.c",
  "hash_id": "4db5f0c1d15e920c85f64aaf8f9a35fa8a69483b6929285d12b8d6cbad9df661",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/vma-iter.c",
  "human_readable_source": " \n#if defined __sun && !defined _LP64 && _FILE_OFFSET_BITS == 64\n# undef _FILE_OFFSET_BITS\n# define _FILE_OFFSET_BITS 32\n#endif\n#ifdef __ANDROID__\n# undef _FILE_OFFSET_BITS\n#endif\n\n \n#include \"vma-iter.h\"\n\n#include <errno.h>  \n#include <stdlib.h>  \n#include <fcntl.h>  \n#include <unistd.h>  \n\n#if defined __linux__ || defined __ANDROID__\n# include <limits.h>  \n#endif\n\n#if defined __linux__ || defined __ANDROID__ || defined __FreeBSD_kernel__ || defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__ || defined __minix  \n# include <sys/types.h>\n# include <sys/mman.h>  \n#endif\n#if defined __minix\n# include <string.h>  \n#endif\n\n#if defined __FreeBSD__ || defined __FreeBSD_kernel__  \n# include <sys/types.h>\n# include <sys/mman.h>  \n# include <sys/user.h>  \n# include <sys/sysctl.h>  \n#endif\n#if defined __NetBSD__ || defined __OpenBSD__  \n# include <sys/types.h>\n# include <sys/mman.h>  \n# include <sys/sysctl.h>  \n#endif\n\n#if defined _AIX  \n# include <string.h>  \n# include <sys/types.h>\n# include <sys/mman.h>  \n# include <sys/procfs.h>  \n#endif\n\n#if defined __sgi || defined __osf__  \n# include <string.h>  \n# include <sys/types.h>\n# include <sys/mman.h>  \n# include <sys/procfs.h>  \n#endif\n\n#if defined __sun  \n# include <string.h>  \n# include <sys/types.h>\n# include <sys/mman.h>  \n \n# define _STRUCTURED_PROC 1\n# include <sys/procfs.h>  \n#endif\n\n#if HAVE_PSTAT_GETPROCVM  \n# include <sys/pstat.h>  \n#endif\n\n#if defined __APPLE__ && defined __MACH__  \n# include <mach/mach.h>\n#endif\n\n#if defined __GNU__  \n# include <mach/mach.h>\n#endif\n\n#if defined _WIN32 || defined __CYGWIN__  \n# include <windows.h>\n#endif\n\n#if defined __BEOS__ || defined __HAIKU__  \n# include <OS.h>\n#endif\n\n#if HAVE_MQUERY  \n# include <sys/types.h>\n# include <sys/mman.h>  \n#endif\n\n\n \n\n#if defined __linux__ || defined __ANDROID__ || defined __FreeBSD_kernel__ || defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__ || defined __minix  \n\n \n\n# if defined __linux__ || defined __ANDROID__\n   \n#  define MIN_LEFTOVER (73 + PATH_MAX)\n# else\n#  define MIN_LEFTOVER 1\n# endif\n\n# ifdef TEST\n \n#  define STACK_ALLOCATED_BUFFER_SIZE 32\n# else\n#  if MIN_LEFTOVER < 1024\n#   define STACK_ALLOCATED_BUFFER_SIZE 1024\n#  else\n     \n#   define STACK_ALLOCATED_BUFFER_SIZE 1\n#  endif\n# endif\n\nstruct rofile\n  {\n    size_t position;\n    size_t filled;\n    int eof_seen;\n     \n    char *buffer;\n    char *auxmap;\n    size_t auxmap_length;\n    unsigned long auxmap_start;\n    unsigned long auxmap_end;\n    char stack_allocated_buffer[STACK_ALLOCATED_BUFFER_SIZE];\n  };\n\n \nstatic int\nrof_open (struct rofile *rof, const char *filename)\n{\n  int fd;\n  unsigned long pagesize;\n  size_t size;\n\n  fd = open (filename, O_RDONLY | O_CLOEXEC);\n  if (fd < 0)\n    return -1;\n  rof->position = 0;\n  rof->eof_seen = 0;\n   \n  pagesize = 0;\n  rof->buffer = rof->stack_allocated_buffer;\n  size = sizeof (rof->stack_allocated_buffer);\n  rof->auxmap = NULL;\n  rof->auxmap_start = 0;\n  rof->auxmap_end = 0;\n  for (;;)\n    {\n       \n      if (size > MIN_LEFTOVER)\n        {\n          int n = read (fd, rof->buffer, size);\n          if (n < 0 && errno == EINTR)\n            goto retry;\n# if defined __DragonFly__\n          if (!(n < 0 && errno == EFBIG))\n# endif\n            {\n              if (n <= 0)\n                 \n                goto fail1;\n              if (n + MIN_LEFTOVER <= size)\n                {\n                   \n                  rof->filled = n;\n# if defined __linux__ || defined __ANDROID__\n                   \n                  for (;;)\n                    {\n                      n = read (fd, rof->buffer + rof->filled, size - rof->filled);\n                      if (n < 0 && errno == EINTR)\n                        goto retry;\n                      if (n < 0)\n                         \n                        goto fail1;\n                      if (n + MIN_LEFTOVER > size - rof->filled)\n                         \n                        break;\n                      if (n == 0)\n                        {\n                           \n                          close (fd);\n                          return 0;\n                        }\n                      rof->filled += n;\n                    }\n# else\n                  close (fd);\n                  return 0;\n# endif\n                }\n            }\n        }\n       \n      if (pagesize == 0)\n        {\n          pagesize = getpagesize ();\n          size = pagesize;\n          while (size <= MIN_LEFTOVER)\n            size = 2 * size;\n        }\n      else\n        {\n          size = 2 * size;\n          if (size == 0)\n             \n            goto fail1;\n          if (rof->auxmap != NULL)\n            munmap (rof->auxmap, rof->auxmap_length);\n        }\n      rof->auxmap = (void *) mmap ((void *) 0, size, PROT_READ | PROT_WRITE,\n                                   MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n      if (rof->auxmap == (void *) -1)\n        {\n          close (fd);\n          return -1;\n        }\n      rof->auxmap_length = size;\n      rof->auxmap_start = (unsigned long) rof->auxmap;\n      rof->auxmap_end = rof->auxmap_start + size;\n      rof->buffer = (char *) rof->auxmap;\n     retry:\n       \n      if (lseek (fd, 0, SEEK_SET) < 0)\n        {\n          close (fd);\n          fd = open (filename, O_RDONLY | O_CLOEXEC);\n          if (fd < 0)\n            goto fail2;\n        }\n    }\n fail1:\n  close (fd);\n fail2:\n  if (rof->auxmap != NULL)\n    munmap (rof->auxmap, rof->auxmap_length);\n  return -1;\n}\n\n \nstatic int\nrof_peekchar (struct rofile *rof)\n{\n  if (rof->position == rof->filled)\n    {\n      rof->eof_seen = 1;\n      return -1;\n    }\n  return (unsigned char) rof->buffer[rof->position];\n}\n\n \nstatic int\nrof_getchar (struct rofile *rof)\n{\n  int c = rof_peekchar (rof);\n  if (c >= 0)\n    rof->position++;\n  return c;\n}\n\n \nstatic int\nrof_scanf_lx (struct rofile *rof, unsigned long *valuep)\n{\n  unsigned long value = 0;\n  unsigned int numdigits = 0;\n  for (;;)\n    {\n      int c = rof_peekchar (rof);\n      if (c >= '0' && c <= '9')\n        value = (value << 4) + (c - '0');\n      else if (c >= 'A' && c <= 'F')\n        value = (value << 4) + (c - 'A' + 10);\n      else if (c >= 'a' && c <= 'f')\n        value = (value << 4) + (c - 'a' + 10);\n      else\n        break;\n      rof_getchar (rof);\n      numdigits++;\n    }\n  if (numdigits == 0)\n    return -1;\n  *valuep = value;\n  return 0;\n}\n\n \nstatic void\nrof_close (struct rofile *rof)\n{\n  if (rof->auxmap != NULL)\n    munmap (rof->auxmap, rof->auxmap_length);\n}\n\n#endif\n\n\n \n\n#if defined __linux__ || defined __ANDROID__ || (defined __FreeBSD_kernel__ && !defined __FreeBSD__)  \n \n\nstatic int\nvma_iterate_proc (vma_iterate_callback_fn callback, void *data)\n{\n  struct rofile rof;\n\n   \n  if (rof_open (&rof, \"/proc/self/maps\") >= 0)\n    {\n      unsigned long auxmap_start = rof.auxmap_start;\n      unsigned long auxmap_end = rof.auxmap_end;\n\n      for (;;)\n        {\n          unsigned long start, end;\n          unsigned int flags;\n          int c;\n\n           \n          if (!(rof_scanf_lx (&rof, &start) >= 0\n                && rof_getchar (&rof) == '-'\n                && rof_scanf_lx (&rof, &end) >= 0))\n            break;\n           \n          do\n            c = rof_getchar (&rof);\n          while (c == ' ');\n          flags = 0;\n          if (c == 'r')\n            flags |= VMA_PROT_READ;\n          c = rof_getchar (&rof);\n          if (c == 'w')\n            flags |= VMA_PROT_WRITE;\n          c = rof_getchar (&rof);\n          if (c == 'x')\n            flags |= VMA_PROT_EXECUTE;\n          while (c = rof_getchar (&rof), c != -1 && c != '\\n')\n            ;\n\n          if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n            {\n               \n              if (start < auxmap_start)\n                if (callback (data, start, auxmap_start, flags))\n                  break;\n              if (auxmap_end - 1 < end - 1)\n                if (callback (data, auxmap_end, end, flags))\n                  break;\n            }\n          else\n            {\n              if (callback (data, start, end, flags))\n                break;\n            }\n        }\n      rof_close (&rof);\n      return 0;\n    }\n\n  return -1;\n}\n\n#elif defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__\n\nstatic int\nvma_iterate_proc (vma_iterate_callback_fn callback, void *data)\n{\n  struct rofile rof;\n\n   \n  if (rof_open (&rof, \"/proc/curproc/map\") >= 0)\n    {\n      unsigned long auxmap_start = rof.auxmap_start;\n      unsigned long auxmap_end = rof.auxmap_end;\n\n      for (;;)\n        {\n          unsigned long start, end;\n          unsigned int flags;\n          int c;\n\n           \n          if (!(rof_getchar (&rof) == '0'\n                && rof_getchar (&rof) == 'x'\n                && rof_scanf_lx (&rof, &start) >= 0))\n            break;\n          while (c = rof_peekchar (&rof), c == ' ' || c == '\\t')\n            rof_getchar (&rof);\n           \n          if (!(rof_getchar (&rof) == '0'\n                && rof_getchar (&rof) == 'x'\n                && rof_scanf_lx (&rof, &end) >= 0))\n            break;\n# if defined __FreeBSD__ || defined __DragonFly__\n           \n          do\n            c = rof_getchar (&rof);\n          while (c == ' ');\n          do\n            c = rof_getchar (&rof);\n          while (c != -1 && c != '\\n' && c != ' ');\n           \n          do\n            c = rof_getchar (&rof);\n          while (c == ' ');\n          do\n            c = rof_getchar (&rof);\n          while (c != -1 && c != '\\n' && c != ' ');\n           \n          do\n            c = rof_getchar (&rof);\n          while (c == ' ');\n          do\n            c = rof_getchar (&rof);\n          while (c != -1 && c != '\\n' && c != ' ');\n# endif\n           \n          do\n            c = rof_getchar (&rof);\n          while (c == ' ');\n          flags = 0;\n          if (c == 'r')\n            flags |= VMA_PROT_READ;\n          c = rof_getchar (&rof);\n          if (c == 'w')\n            flags |= VMA_PROT_WRITE;\n          c = rof_getchar (&rof);\n          if (c == 'x')\n            flags |= VMA_PROT_EXECUTE;\n          while (c = rof_getchar (&rof), c != -1 && c != '\\n')\n            ;\n\n          if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n            {\n               \n              if (start < auxmap_start)\n                if (callback (data, start, auxmap_start, flags))\n                  break;\n              if (auxmap_end - 1 < end - 1)\n                if (callback (data, auxmap_end, end, flags))\n                  break;\n            }\n          else\n            {\n              if (callback (data, start, end, flags))\n                break;\n            }\n        }\n      rof_close (&rof);\n      return 0;\n    }\n\n  return -1;\n}\n\n#elif defined __minix\n\nstatic int\nvma_iterate_proc (vma_iterate_callback_fn callback, void *data)\n{\n  char fnamebuf[6+10+4+1];\n  char *fname;\n  struct rofile rof;\n\n   \n  fname = fnamebuf + sizeof (fnamebuf) - (4 + 1);\n  memcpy (fname, \"/map\", 4 + 1);\n  {\n    unsigned int value = getpid ();\n    do\n      *--fname = (value % 10) + '0';\n    while ((value = value / 10) > 0);\n  }\n  fname -= 6;\n  memcpy (fname, \"/proc/\", 6);\n\n   \n  if (rof_open (&rof, fname) >= 0)\n    {\n      unsigned long auxmap_start = rof.auxmap_start;\n      unsigned long auxmap_end = rof.auxmap_end;\n\n      for (;;)\n        {\n          unsigned long start, end;\n          unsigned int flags;\n          int c;\n\n           \n          if (!(rof_scanf_lx (&rof, &start) >= 0\n                && rof_getchar (&rof) == '-'\n                && rof_scanf_lx (&rof, &end) >= 0))\n            break;\n           \n          do\n            c = rof_getchar (&rof);\n          while (c == ' ');\n          flags = 0;\n          if (c == 'r')\n            flags |= VMA_PROT_READ;\n          c = rof_getchar (&rof);\n          if (c == 'w')\n            flags |= VMA_PROT_WRITE;\n          c = rof_getchar (&rof);\n          if (c == 'x')\n            flags |= VMA_PROT_EXECUTE;\n          while (c = rof_getchar (&rof), c != -1 && c != '\\n')\n            ;\n\n          if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n            {\n               \n              if (start < auxmap_start)\n                if (callback (data, start, auxmap_start, flags))\n                  break;\n              if (auxmap_end - 1 < end - 1)\n                if (callback (data, auxmap_end, end, flags))\n                  break;\n            }\n          else\n            {\n              if (callback (data, start, end, flags))\n                break;\n            }\n        }\n      rof_close (&rof);\n      return 0;\n    }\n\n  return -1;\n}\n\n#else\n\nstatic inline int\nvma_iterate_proc (vma_iterate_callback_fn callback, void *data)\n{\n  return -1;\n}\n\n#endif\n\n\n \n\n#if (defined __FreeBSD__ || defined __FreeBSD_kernel__) && defined KERN_PROC_VMMAP  \n\nstatic int\nvma_iterate_bsd (vma_iterate_callback_fn callback, void *data)\n{\n   \n  int info_path[] = { CTL_KERN, KERN_PROC, KERN_PROC_VMMAP, getpid () };\n  size_t len;\n  size_t pagesize;\n  size_t memneed;\n  void *auxmap;\n  unsigned long auxmap_start;\n  unsigned long auxmap_end;\n  char *mem;\n  char *p;\n  char *p_end;\n\n  len = 0;\n  if (sysctl (info_path, 4, NULL, &len, NULL, 0) < 0)\n    return -1;\n   \n  len = 2 * len + 200;\n   \n  pagesize = getpagesize ();\n  memneed = len;\n  memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n  auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                          MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n  if (auxmap == (void *) -1)\n    return -1;\n  auxmap_start = (unsigned long) auxmap;\n  auxmap_end = auxmap_start + memneed;\n  mem = (char *) auxmap;\n  if (sysctl (info_path, 4, mem, &len, NULL, 0) < 0)\n    {\n      munmap (auxmap, memneed);\n      return -1;\n    }\n  p = mem;\n  p_end = mem + len;\n  while (p < p_end)\n    {\n      struct kinfo_vmentry *kve = (struct kinfo_vmentry *) p;\n      unsigned long start = kve->kve_start;\n      unsigned long end = kve->kve_end;\n      unsigned int flags = 0;\n      if (kve->kve_protection & KVME_PROT_READ)\n        flags |= VMA_PROT_READ;\n      if (kve->kve_protection & KVME_PROT_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (kve->kve_protection & KVME_PROT_EXEC)\n        flags |= VMA_PROT_EXECUTE;\n      if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n        {\n           \n          if (start < auxmap_start)\n            if (callback (data, start, auxmap_start, flags))\n              break;\n          if (auxmap_end - 1 < end - 1)\n            if (callback (data, auxmap_end, end, flags))\n              break;\n        }\n      else\n        {\n          if (callback (data, start, end, flags))\n            break;\n        }\n      p += kve->kve_structsize;\n    }\n  munmap (auxmap, memneed);\n  return 0;\n}\n\n#elif defined __NetBSD__ && defined VM_PROC_MAP  \n\nstatic int\nvma_iterate_bsd (vma_iterate_callback_fn callback, void *data)\n{\n   \n  unsigned int entry_size =\n     \n    offsetof (struct kinfo_vmentry, kve_path);\n  int info_path[] = { CTL_VM, VM_PROC, VM_PROC_MAP, getpid (), entry_size };\n  size_t len;\n  size_t pagesize;\n  size_t memneed;\n  void *auxmap;\n  unsigned long auxmap_start;\n  unsigned long auxmap_end;\n  char *mem;\n  char *p;\n  char *p_end;\n\n  len = 0;\n  if (sysctl (info_path, 5, NULL, &len, NULL, 0) < 0)\n    return -1;\n   \n  len = 2 * len + 10 * entry_size;\n   \n  if (len > 0x100000)\n    len = 0x100000;\n   \n  len = (len / entry_size) * entry_size;\n   \n  pagesize = getpagesize ();\n  memneed = len;\n  memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n  auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                          MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n  if (auxmap == (void *) -1)\n    return -1;\n  auxmap_start = (unsigned long) auxmap;\n  auxmap_end = auxmap_start + memneed;\n  mem = (char *) auxmap;\n  if (sysctl (info_path, 5, mem, &len, NULL, 0) < 0\n      || len > 0x100000 - entry_size)\n    {\n       \n      munmap (auxmap, memneed);\n      return -1;\n    }\n  p = mem;\n  p_end = mem + len;\n  while (p < p_end)\n    {\n      struct kinfo_vmentry *kve = (struct kinfo_vmentry *) p;\n      unsigned long start = kve->kve_start;\n      unsigned long end = kve->kve_end;\n      unsigned int flags = 0;\n      if (kve->kve_protection & KVME_PROT_READ)\n        flags |= VMA_PROT_READ;\n      if (kve->kve_protection & KVME_PROT_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (kve->kve_protection & KVME_PROT_EXEC)\n        flags |= VMA_PROT_EXECUTE;\n      if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n        {\n           \n          if (start < auxmap_start)\n            if (callback (data, start, auxmap_start, flags))\n              break;\n          if (auxmap_end - 1 < end - 1)\n            if (callback (data, auxmap_end, end, flags))\n              break;\n        }\n      else\n        {\n          if (callback (data, start, end, flags))\n            break;\n        }\n      p += entry_size;\n    }\n  munmap (auxmap, memneed);\n  return 0;\n}\n\n#elif defined __OpenBSD__ && defined KERN_PROC_VMMAP  \n\nstatic int\nvma_iterate_bsd (vma_iterate_callback_fn callback, void *data)\n{\n   \n  int info_path[] = { CTL_KERN, KERN_PROC_VMMAP, getpid () };\n  size_t len;\n  size_t pagesize;\n  size_t memneed;\n  void *auxmap;\n  unsigned long auxmap_start;\n  unsigned long auxmap_end;\n  char *mem;\n  char *p;\n  char *p_end;\n\n  len = 0;\n  if (sysctl (info_path, 3, NULL, &len, NULL, 0) < 0)\n    return -1;\n   \n  len = 2 * len + 10 * sizeof (struct kinfo_vmentry);\n   \n  if (len > 0x10000)\n    len = 0x10000;\n   \n  len = (len / sizeof (struct kinfo_vmentry)) * sizeof (struct kinfo_vmentry);\n   \n  pagesize = getpagesize ();\n  memneed = len;\n  memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n  auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                          MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n  if (auxmap == (void *) -1)\n    return -1;\n  auxmap_start = (unsigned long) auxmap;\n  auxmap_end = auxmap_start + memneed;\n  mem = (char *) auxmap;\n  if (sysctl (info_path, 3, mem, &len, NULL, 0) < 0\n      || len > 0x10000 - sizeof (struct kinfo_vmentry))\n    {\n       \n      munmap (auxmap, memneed);\n      return -1;\n    }\n  p = mem;\n  p_end = mem + len;\n  while (p < p_end)\n    {\n      struct kinfo_vmentry *kve = (struct kinfo_vmentry *) p;\n      unsigned long start = kve->kve_start;\n      unsigned long end = kve->kve_end;\n      unsigned int flags = 0;\n      if (kve->kve_protection & KVE_PROT_READ)\n        flags |= VMA_PROT_READ;\n      if (kve->kve_protection & KVE_PROT_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (kve->kve_protection & KVE_PROT_EXEC)\n        flags |= VMA_PROT_EXECUTE;\n      if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n        {\n           \n          if (start < auxmap_start)\n            if (callback (data, start, auxmap_start, flags))\n              break;\n          if (auxmap_end - 1 < end - 1)\n            if (callback (data, auxmap_end, end, flags))\n              break;\n        }\n      else\n        {\n          if (start != end)\n            if (callback (data, start, end, flags))\n              break;\n        }\n      p += sizeof (struct kinfo_vmentry);\n    }\n  munmap (auxmap, memneed);\n  return 0;\n}\n\n#else\n\nstatic inline int\nvma_iterate_bsd (vma_iterate_callback_fn callback, void *data)\n{\n  return -1;\n}\n\n#endif\n\n\nint\nvma_iterate (vma_iterate_callback_fn callback, void *data)\n{\n#if defined __linux__ || defined __ANDROID__ || defined __FreeBSD_kernel__ || defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__ || defined __minix  \n\n# if defined __FreeBSD__\n   \n  int retval = vma_iterate_bsd (callback, data);\n  if (retval == 0)\n      return 0;\n\n  return vma_iterate_proc (callback, data);\n# else\n   \n  int retval = vma_iterate_proc (callback, data);\n  if (retval == 0)\n      return 0;\n\n  return vma_iterate_bsd (callback, data);\n# endif\n\n#elif defined _AIX  \n\n   \n\n  size_t pagesize;\n  char fnamebuf[6+10+4+1];\n  char *fname;\n  int fd;\n  size_t memneed;\n\n  pagesize = getpagesize ();\n\n   \n  fname = fnamebuf + sizeof (fnamebuf) - (4+1);\n  memcpy (fname, \"/map\", 4+1);\n  {\n    unsigned int value = getpid ();\n    do\n      *--fname = (value % 10) + '0';\n    while ((value = value / 10) > 0);\n  }\n  fname -= 6;\n  memcpy (fname, \"/proc/\", 6);\n\n  fd = open (fname, O_RDONLY | O_CLOEXEC);\n  if (fd < 0)\n    return -1;\n\n   \n\n  for (memneed = 2 * pagesize; ; memneed = 2 * memneed)\n    {\n       \n      void *auxmap;\n      unsigned long auxmap_start;\n      unsigned long auxmap_end;\n      ssize_t nbytes;\n\n      auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                              MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n      if (auxmap == (void *) -1)\n        {\n          close (fd);\n          return -1;\n        }\n      auxmap_start = (unsigned long) auxmap;\n      auxmap_end = auxmap_start + memneed;\n\n       \n     retry:\n      do\n        nbytes = read (fd, auxmap, memneed);\n      while (nbytes < 0 && errno == EINTR);\n      if (nbytes <= 0)\n        {\n          munmap (auxmap, memneed);\n          close (fd);\n          return -1;\n        }\n      if (nbytes == memneed)\n        {\n           \n          munmap (auxmap, memneed);\n          if (lseek (fd, 0, SEEK_SET) < 0)\n            {\n              close (fd);\n              return -1;\n            }\n        }\n      else\n        {\n          if (read (fd, (char *) auxmap + nbytes, 1) > 0)\n            {\n               \n              if (lseek (fd, 0, SEEK_SET) < 0)\n                {\n                  munmap (auxmap, memneed);\n                  close (fd);\n                  return -1;\n                }\n              goto retry;\n            }\n\n           \n          prmap_t* maps = (prmap_t *) auxmap;\n\n           \n          typedef struct\n            {\n              uintptr_t start;\n              uintptr_t end;\n              unsigned int flags;\n            }\n          vma_t;\n           \n          vma_t *vmas = (vma_t *) auxmap;\n\n          vma_t *vp = vmas;\n          {\n            prmap_t* mp;\n            for (mp = maps;;)\n              {\n                unsigned long start, end;\n\n                start = (unsigned long) mp->pr_vaddr;\n                end = start + mp->pr_size;\n                if (start == 0 && end == 0 && mp->pr_mflags == 0)\n                  break;\n                 \n                if (start < end && (mp->pr_mflags & MA_KERNTEXT) == 0)\n                  {\n                    unsigned int flags;\n                    flags = 0;\n                    if (mp->pr_mflags & MA_READ)\n                      flags |= VMA_PROT_READ;\n                    if (mp->pr_mflags & MA_WRITE)\n                      flags |= VMA_PROT_WRITE;\n                    if (mp->pr_mflags & MA_EXEC)\n                      flags |= VMA_PROT_EXECUTE;\n\n                    if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n                      {\n                         \n                        if (start < auxmap_start)\n                          {\n                            vp->start = start;\n                            vp->end = auxmap_start;\n                            vp->flags = flags;\n                            vp++;\n                          }\n                        if (auxmap_end - 1 < end - 1)\n                          {\n                            vp->start = auxmap_end;\n                            vp->end = end;\n                            vp->flags = flags;\n                            vp++;\n                          }\n                      }\n                    else\n                      {\n                        vp->start = start;\n                        vp->end = end;\n                        vp->flags = flags;\n                        vp++;\n                      }\n                  }\n                mp++;\n              }\n          }\n\n          size_t nvmas = vp - vmas;\n           \n          {\n            size_t i;\n            for (i = 1; i < nvmas; i++)\n              {\n                 \n                size_t j;\n                for (j = i; j > 0 && vmas[j - 1].start > vmas[j].start; j--)\n                  {\n                    vma_t tmp = vmas[j - 1];\n                    vmas[j - 1] = vmas[j];\n                    vmas[j] = tmp;\n                  }\n                 \n              }\n          }\n\n           \n          {\n            size_t i;\n            for (i = 0; i < nvmas; i++)\n              {\n                vma_t *vpi = &vmas[i];\n                if (callback (data, vpi->start, vpi->end, vpi->flags))\n                  break;\n              }\n          }\n\n          munmap (auxmap, memneed);\n          break;\n        }\n    }\n\n  close (fd);\n  return 0;\n\n#elif defined __sgi || defined __osf__  \n\n  size_t pagesize;\n  char fnamebuf[6+10+1];\n  char *fname;\n  int fd;\n  int nmaps;\n  size_t memneed;\n# if HAVE_MAP_ANONYMOUS\n#  define zero_fd -1\n#  define map_flags MAP_ANONYMOUS\n# else\n  int zero_fd;\n#  define map_flags 0\n# endif\n  void *auxmap;\n  unsigned long auxmap_start;\n  unsigned long auxmap_end;\n  prmap_t* maps;\n  prmap_t* mp;\n\n  pagesize = getpagesize ();\n\n   \n  fname = fnamebuf + sizeof (fnamebuf) - 1;\n  *fname = '\\0';\n  {\n    unsigned int value = getpid ();\n    do\n      *--fname = (value % 10) + '0';\n    while ((value = value / 10) > 0);\n  }\n  fname -= 6;\n  memcpy (fname, \"/proc/\", 6);\n\n  fd = open (fname, O_RDONLY | O_CLOEXEC);\n  if (fd < 0)\n    return -1;\n\n  if (ioctl (fd, PIOCNMAP, &nmaps) < 0)\n    goto fail2;\n\n  memneed = (nmaps + 10) * sizeof (prmap_t);\n   \n  memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n# if !HAVE_MAP_ANONYMOUS\n  zero_fd = open (\"/dev/zero\", O_RDONLY | O_CLOEXEC, 0644);\n  if (zero_fd < 0)\n    goto fail2;\n# endif\n  auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                          map_flags | MAP_PRIVATE, zero_fd, 0);\n# if !HAVE_MAP_ANONYMOUS\n  close (zero_fd);\n# endif\n  if (auxmap == (void *) -1)\n    goto fail2;\n  auxmap_start = (unsigned long) auxmap;\n  auxmap_end = auxmap_start + memneed;\n  maps = (prmap_t *) auxmap;\n\n  if (ioctl (fd, PIOCMAP, maps) < 0)\n    goto fail1;\n\n  for (mp = maps;;)\n    {\n      unsigned long start, end;\n      unsigned int flags;\n\n      start = (unsigned long) mp->pr_vaddr;\n      end = start + mp->pr_size;\n      if (start == 0 && end == 0)\n        break;\n      flags = 0;\n      if (mp->pr_mflags & MA_READ)\n        flags |= VMA_PROT_READ;\n      if (mp->pr_mflags & MA_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (mp->pr_mflags & MA_EXEC)\n        flags |= VMA_PROT_EXECUTE;\n      mp++;\n      if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n        {\n           \n          if (start < auxmap_start)\n            if (callback (data, start, auxmap_start, flags))\n              break;\n          if (auxmap_end - 1 < end - 1)\n            if (callback (data, auxmap_end, end, flags))\n              break;\n        }\n      else\n        {\n          if (callback (data, start, end, flags))\n            break;\n        }\n    }\n  munmap (auxmap, memneed);\n  close (fd);\n  return 0;\n\n fail1:\n  munmap (auxmap, memneed);\n fail2:\n  close (fd);\n  return -1;\n\n#elif defined __sun  \n\n   \n\n# if defined PIOCNMAP && defined PIOCMAP\n   \n\n  size_t pagesize;\n  char fnamebuf[6+10+1];\n  char *fname;\n  int fd;\n  int nmaps;\n  size_t memneed;\n#  if HAVE_MAP_ANONYMOUS\n#   define zero_fd -1\n#   define map_flags MAP_ANONYMOUS\n#  else  \n  int zero_fd;\n#   define map_flags 0\n#  endif\n  void *auxmap;\n  unsigned long auxmap_start;\n  unsigned long auxmap_end;\n  prmap_t* maps;\n  prmap_t* mp;\n\n  pagesize = getpagesize ();\n\n   \n  fname = fnamebuf + sizeof (fnamebuf) - 1;\n  *fname = '\\0';\n  {\n    unsigned int value = getpid ();\n    do\n      *--fname = (value % 10) + '0';\n    while ((value = value / 10) > 0);\n  }\n  fname -= 6;\n  memcpy (fname, \"/proc/\", 6);\n\n  fd = open (fname, O_RDONLY | O_CLOEXEC);\n  if (fd < 0)\n    return -1;\n\n  if (ioctl (fd, PIOCNMAP, &nmaps) < 0)\n    goto fail2;\n\n  memneed = (nmaps + 10) * sizeof (prmap_t);\n   \n  memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n#  if !HAVE_MAP_ANONYMOUS\n  zero_fd = open (\"/dev/zero\", O_RDONLY | O_CLOEXEC, 0644);\n  if (zero_fd < 0)\n    goto fail2;\n#  endif\n  auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                          map_flags | MAP_PRIVATE, zero_fd, 0);\n#  if !HAVE_MAP_ANONYMOUS\n  close (zero_fd);\n#  endif\n  if (auxmap == (void *) -1)\n    goto fail2;\n  auxmap_start = (unsigned long) auxmap;\n  auxmap_end = auxmap_start + memneed;\n  maps = (prmap_t *) auxmap;\n\n  if (ioctl (fd, PIOCMAP, maps) < 0)\n    goto fail1;\n\n  for (mp = maps;;)\n    {\n      unsigned long start, end;\n      unsigned int flags;\n\n      start = (unsigned long) mp->pr_vaddr;\n      end = start + mp->pr_size;\n      if (start == 0 && end == 0)\n        break;\n      flags = 0;\n      if (mp->pr_mflags & MA_READ)\n        flags |= VMA_PROT_READ;\n      if (mp->pr_mflags & MA_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (mp->pr_mflags & MA_EXEC)\n        flags |= VMA_PROT_EXECUTE;\n      mp++;\n      if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n        {\n           \n          if (start < auxmap_start)\n            if (callback (data, start, auxmap_start, flags))\n              break;\n          if (auxmap_end - 1 < end - 1)\n            if (callback (data, auxmap_end, end, flags))\n              break;\n        }\n      else\n        {\n          if (callback (data, start, end, flags))\n            break;\n        }\n    }\n  munmap (auxmap, memneed);\n  close (fd);\n  return 0;\n\n fail1:\n  munmap (auxmap, memneed);\n fail2:\n  close (fd);\n  return -1;\n\n# else\n   \n\n  size_t pagesize;\n  char fnamebuf[6+10+4+1];\n  char *fname;\n  int fd;\n  int nmaps;\n  size_t memneed;\n#  if HAVE_MAP_ANONYMOUS\n#   define zero_fd -1\n#   define map_flags MAP_ANONYMOUS\n#  else  \n  int zero_fd;\n#   define map_flags 0\n#  endif\n  void *auxmap;\n  unsigned long auxmap_start;\n  unsigned long auxmap_end;\n  prmap_t* maps;\n  prmap_t* maps_end;\n  prmap_t* mp;\n\n  pagesize = getpagesize ();\n\n   \n  fname = fnamebuf + sizeof (fnamebuf) - 1 - 4;\n  memcpy (fname, \"/map\", 4 + 1);\n  {\n    unsigned int value = getpid ();\n    do\n      *--fname = (value % 10) + '0';\n    while ((value = value / 10) > 0);\n  }\n  fname -= 6;\n  memcpy (fname, \"/proc/\", 6);\n\n  fd = open (fname, O_RDONLY | O_CLOEXEC);\n  if (fd < 0)\n    return -1;\n\n  {\n    struct stat statbuf;\n    if (fstat (fd, &statbuf) < 0)\n      goto fail2;\n    nmaps = statbuf.st_size / sizeof (prmap_t);\n  }\n\n  memneed = (nmaps + 10) * sizeof (prmap_t);\n   \n  memneed = ((memneed - 1) / pagesize + 1) * pagesize;\n#  if !HAVE_MAP_ANONYMOUS\n  zero_fd = open (\"/dev/zero\", O_RDONLY | O_CLOEXEC, 0644);\n  if (zero_fd < 0)\n    goto fail2;\n#  endif\n  auxmap = (void *) mmap ((void *) 0, memneed, PROT_READ | PROT_WRITE,\n                          map_flags | MAP_PRIVATE, zero_fd, 0);\n#  if !HAVE_MAP_ANONYMOUS\n  close (zero_fd);\n#  endif\n  if (auxmap == (void *) -1)\n    goto fail2;\n  auxmap_start = (unsigned long) auxmap;\n  auxmap_end = auxmap_start + memneed;\n  maps = (prmap_t *) auxmap;\n\n   \n  {\n    size_t remaining = memneed;\n    size_t total_read = 0;\n    char *ptr = (char *) maps;\n\n    do\n      {\n        size_t nread = read (fd, ptr, remaining);\n        if (nread == (size_t)-1)\n          {\n            if (errno == EINTR)\n              continue;\n            goto fail1;\n          }\n        if (nread == 0)\n           \n          break;\n        total_read += nread;\n        ptr += nread;\n        remaining -= nread;\n      }\n    while (remaining > 0);\n\n    nmaps = (memneed - remaining) / sizeof (prmap_t);\n    maps_end = maps + nmaps;\n  }\n\n  for (mp = maps; mp < maps_end; mp++)\n    {\n      unsigned long start, end;\n      unsigned int flags;\n\n      start = (unsigned long) mp->pr_vaddr;\n      end = start + mp->pr_size;\n      flags = 0;\n      if (mp->pr_mflags & MA_READ)\n        flags |= VMA_PROT_READ;\n      if (mp->pr_mflags & MA_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (mp->pr_mflags & MA_EXEC)\n        flags |= VMA_PROT_EXECUTE;\n      if (start <= auxmap_start && auxmap_end - 1 <= end - 1)\n        {\n           \n          if (start < auxmap_start)\n            if (callback (data, start, auxmap_start, flags))\n              break;\n          if (auxmap_end - 1 < end - 1)\n            if (callback (data, auxmap_end, end, flags))\n              break;\n        }\n      else\n        {\n          if (callback (data, start, end, flags))\n            break;\n        }\n    }\n  munmap (auxmap, memneed);\n  close (fd);\n  return 0;\n\n fail1:\n  munmap (auxmap, memneed);\n fail2:\n  close (fd);\n  return -1;\n\n# endif\n\n#elif HAVE_PSTAT_GETPROCVM  \n\n  unsigned long pagesize = getpagesize ();\n  int i;\n\n  for (i = 0; ; i++)\n    {\n      struct pst_vm_status info;\n      int ret = pstat_getprocvm (&info, sizeof (info), 0, i);\n      if (ret < 0)\n        return -1;\n      if (ret == 0)\n        break;\n      {\n        unsigned long start = info.pst_vaddr;\n        unsigned long end = start + info.pst_length * pagesize;\n        unsigned int flags = 0;\n        if (info.pst_permission & PS_PROT_READ)\n          flags |= VMA_PROT_READ;\n        if (info.pst_permission & PS_PROT_WRITE)\n          flags |= VMA_PROT_WRITE;\n        if (info.pst_permission & PS_PROT_EXECUTE)\n          flags |= VMA_PROT_EXECUTE;\n\n        if (callback (data, start, end, flags))\n          break;\n      }\n    }\n\n#elif defined __APPLE__ && defined __MACH__  \n\n  task_t task = mach_task_self ();\n  vm_address_t address;\n  vm_size_t size;\n\n  for (address = VM_MIN_ADDRESS;; address += size)\n    {\n      int more;\n      mach_port_t object_name;\n      unsigned int flags;\n       \n# if defined __aarch64__ || defined __ppc64__ || defined __x86_64__\n      struct vm_region_basic_info_64 info;\n      mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;\n\n      more = (vm_region_64 (task, &address, &size, VM_REGION_BASIC_INFO_64,\n                            (vm_region_info_t)&info, &info_count, &object_name)\n              == KERN_SUCCESS);\n# else\n      struct vm_region_basic_info info;\n      mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT;\n\n      more = (vm_region (task, &address, &size, VM_REGION_BASIC_INFO,\n                         (vm_region_info_t)&info, &info_count, &object_name)\n              == KERN_SUCCESS);\n# endif\n      if (object_name != MACH_PORT_NULL)\n        mach_port_deallocate (mach_task_self (), object_name);\n      if (!more)\n        break;\n      flags = 0;\n      if (info.protection & VM_PROT_READ)\n        flags |= VMA_PROT_READ;\n      if (info.protection & VM_PROT_WRITE)\n        flags |= VMA_PROT_WRITE;\n      if (info.protection & VM_PROT_EXECUTE)\n        flags |= VMA_PROT_EXECUTE;\n      if (callback (data, address, address + size, flags))\n        break;\n    }\n  return 0;\n\n#elif defined __GNU__  \n\n   \n\n  MEMORY_BASIC_INFORMATION info;\n  uintptr_t address = 0;\n\n  while (VirtualQuery ((void*)address, &info, sizeof(info)) == sizeof(info))\n    {\n      if (info.State != MEM_FREE)\n         \n        if (info.State != MEM_RESERVE)\n          {\n            uintptr_t start, end;\n            unsigned int flags;\n\n            start = (uintptr_t)info.BaseAddress;\n            end = start + info.RegionSize;\n            switch (info.Protect & ~(PAGE_GUARD|PAGE_NOCACHE))\n              {\n              case PAGE_READONLY:\n                flags = VMA_PROT_READ;\n                break;\n              case PAGE_READWRITE:\n              case PAGE_WRITECOPY:\n                flags = VMA_PROT_READ | VMA_PROT_WRITE;\n                break;\n              case PAGE_EXECUTE:\n                flags = VMA_PROT_EXECUTE;\n                break;\n              case PAGE_EXECUTE_READ:\n                flags = VMA_PROT_READ | VMA_PROT_EXECUTE;\n                break;\n              case PAGE_EXECUTE_READWRITE:\n              case PAGE_EXECUTE_WRITECOPY:\n                flags = VMA_PROT_READ | VMA_PROT_WRITE | VMA_PROT_EXECUTE;\n                break;\n              case PAGE_NOACCESS:\n              default:\n                flags = 0;\n                break;\n              }\n\n            if (callback (data, start, end, flags))\n              break;\n          }\n      address = (uintptr_t)info.BaseAddress + info.RegionSize;\n    }\n  return 0;\n\n#elif defined __BEOS__ || defined __HAIKU__\n   \n\n  area_info info;\n  ssize_t cookie;\n\n  cookie = 0;\n  while (get_next_area_info (0, &cookie, &info) == B_OK)\n    {\n      unsigned long start, end;\n      unsigned int flags;\n\n      start = (unsigned long) info.address;\n      end = start + info.size;\n      flags = 0;\n      if (info.protection & B_READ_AREA)\n        flags |= VMA_PROT_READ | VMA_PROT_EXECUTE;\n      if (info.protection & B_WRITE_AREA)\n        flags |= VMA_PROT_WRITE;\n\n      if (callback (data, start, end, flags))\n        break;\n    }\n  return 0;\n\n#elif HAVE_MQUERY  \n\n# if defined __OpenBSD__\n   \n  {\n    int retval = vma_iterate_bsd (callback, data);\n    if (retval == 0)\n      return 0;\n  }\n# endif\n\n  {\n    uintptr_t pagesize;\n    uintptr_t address;\n    int   address_known_mapped;\n\n    pagesize = getpagesize ();\n     \n    address = pagesize;\n    address_known_mapped = 0;\n    for (;;)\n      {\n         \n        if (address_known_mapped\n            || mquery ((void *) address, pagesize, 0, MAP_FIXED, -1, 0)\n               == (void *) -1)\n          {\n             \n            uintptr_t start = address;\n            uintptr_t end;\n\n             \n            end = (uintptr_t) mquery ((void *) address, pagesize, 0, 0, -1, 0);\n            if (end == (uintptr_t) (void *) -1)\n              end = 0;  \n            address = end;\n\n             \n            if (callback (data, start, end, 0))\n              break;\n\n            if (address < pagesize)  \n              break;\n          }\n         \n        {\n          uintptr_t query_size = pagesize;\n\n          address += pagesize;\n\n           \n          for (;;)\n            {\n              if (2 * query_size > query_size)\n                query_size = 2 * query_size;\n              if (address + query_size - 1 < query_size)  \n                {\n                  address_known_mapped = 0;\n                  break;\n                }\n              if (mquery ((void *) address, query_size, 0, MAP_FIXED, -1, 0)\n                  == (void *) -1)\n                {\n                   \n                  address_known_mapped = (query_size == pagesize);\n                  break;\n                }\n               \n              address += query_size;\n            }\n           \n          while (query_size > pagesize)\n            {\n              query_size = query_size / 2;\n              if (address + query_size - 1 >= query_size)\n                {\n                  if (mquery ((void *) address, query_size, 0, MAP_FIXED, -1, 0)\n                      != (void *) -1)\n                    {\n                       \n                      address += query_size;\n                      address_known_mapped = 0;\n                    }\n                  else\n                    address_known_mapped = (query_size == pagesize);\n                }\n            }\n           \n        }\n        if (address + pagesize - 1 < pagesize)  \n          break;\n      }\n    return 0;\n  }\n\n#else\n\n   \n  return -1;\n\n#endif\n}\n\n\n#ifdef TEST\n\n#include <stdio.h>\n\n \n\nstatic int\nvma_iterate_callback (void *data, uintptr_t start, uintptr_t end,\n                      unsigned int flags)\n{\n  printf (\"%08lx-%08lx %c%c%c\\n\",\n          (unsigned long) start, (unsigned long) end,\n          flags & VMA_PROT_READ ? 'r' : '-',\n          flags & VMA_PROT_WRITE ? 'w' : '-',\n          flags & VMA_PROT_EXECUTE ? 'x' : '-');\n  return 0;\n}\n\nint\nmain ()\n{\n  vma_iterate (vma_iterate_callback, NULL);\n\n   \n  sleep (10);\n\n  return 0;\n}\n\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}