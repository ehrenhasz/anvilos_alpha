{
  "module_name": "test-hash.c",
  "hash_id": "0877cac03a3828ffc095be2d01ff181b81e18328b09429b57a45e8d5a7bc2626",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-hash.c",
  "human_readable_source": " \n      hash_clear (ht);\n      hash_free (ht);\n\n      ht = hash_initialize (sz, NULL, hash_pjw, hash_compare_strings, NULL);\n      ASSERT (ht);\n\n      insert_new (ht, \"z\");\n      insert_new (ht, \"y\");\n      insert_new (ht, \"x\");\n      insert_new (ht, \"w\");\n      insert_new (ht, \"v\");\n      insert_new (ht, \"u\");\n\n      hash_clear (ht);\n      ASSERT (hash_get_n_entries (ht) == 0);\n      hash_free (ht);\n\n       \n      ht = hash_initialize (sz, NULL, NULL, NULL, NULL);\n      ASSERT (ht);\n      {\n        char *str = strdup (\"a\");\n        ASSERT (str);\n        insert_new (ht, \"a\");\n        insert_new (ht, str);\n        ASSERT (hash_lookup (ht, str) == str);\n        free (str);\n      }\n      hash_free (ht);\n    }\n\n  hash_reset_tuning (&tuning);\n  tuning.shrink_threshold = 0.3;\n  tuning.shrink_factor = 0.707;\n  tuning.growth_threshold = 1.5;\n  tuning.growth_factor = 2.0;\n  tuning.is_n_buckets = true;\n   \n  ht = hash_initialize (4651, &tuning, hash_pjw, hash_compare_strings,\n                        hash_freer);\n  ASSERT (!ht);\n\n   \n  tuning.growth_threshold = 0.89;\n\n   \n  for (k = 0; k < 2; k++)\n    {\n      Hash_tuning const *tune = (k == 0 ? NULL : &tuning);\n       \n      ht = hash_initialize (4651, tune, hash_pjw,\n                            hash_compare_strings, hash_freer);\n      ASSERT (ht);\n      for (i = 0; i < 10000; i++)\n        {\n          unsigned int op = rand () % 10;\n          switch (op)\n            {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n              {\n                char buf[50];\n                char const *p = uinttostr (i, buf);\n                char *p_dup = strdup (p);\n                ASSERT (p_dup);\n                insert_new (ht, p_dup);\n              }\n              break;\n\n            case 6:\n              {\n                size_t n = hash_get_n_entries (ht);\n                ASSERT (hash_rehash (ht, n + rand () % 20));\n              }\n              break;\n\n            case 7:\n              {\n                size_t n = hash_get_n_entries (ht);\n                size_t delta = rand () % 20;\n                if (delta < n)\n                  ASSERT (hash_rehash (ht, n - delta));\n              }\n              break;\n\n            case 8:\n            case 9:\n              {\n                 \n                size_t n = hash_get_n_entries (ht);\n                if (n)\n                  {\n                    size_t kk = rand () % n;\n                    void const *p;\n                    void *v;\n                    for (p = hash_get_first (ht); kk;\n                         --kk, p = hash_get_next (ht, p))\n                      {\n                         \n                      }\n                    ASSERT (p);\n                    v = hash_remove (ht, p);\n                    ASSERT (v);\n                    free (v);\n                  }\n                break;\n              }\n            }\n          ASSERT (hash_table_ok (ht));\n        }\n\n      hash_free (ht);\n    }\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}