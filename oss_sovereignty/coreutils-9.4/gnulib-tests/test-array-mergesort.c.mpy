{
  "module_name": "test-array-mergesort.c",
  "hash_id": "7b7250281d8c7ef7e05e16e8ab850cc4935c001db7f3444024ef94f1545f54e1",
  "original_prompt": "Ingested from coreutils-9.4/gnulib-tests/test-array-mergesort.c",
  "human_readable_source": " \n  for (n = 1; n <= NMAX; n++)\n    {\n      struct foo *dst;\n      struct foo *tmp;\n      double *qsort_result;\n      size_t i;\n\n      dst = (struct foo *) malloc ((n + 1) * sizeof (struct foo));\n      dst[n].x = 0x4A6A71FE;  \n      tmp = (struct foo *) malloc ((n / 2 + 1) * sizeof (struct foo));\n      tmp[n / 2].x = 0x587EF149;  \n\n      merge_sort_fromto (data, dst, n, tmp);\n\n       \n      ASSERT (dst[n].x == 0x4A6A71FE);\n      ASSERT (tmp[n / 2].x == 0x587EF149);\n\n       \n      qsort_result = (double *) malloc (n * sizeof (double));\n      for (i = 0; i < n; i++)\n        qsort_result[i] = data[i].x;\n      qsort (qsort_result, n, sizeof (double), cmp_double);\n      for (i = 0; i < n; i++)\n        ASSERT (dst[i].x == qsort_result[i]);\n\n       \n      for (i = 0; i < n; i++)\n        if (i > 0 && dst[i - 1].x == dst[i].x)\n          ASSERT (dst[i - 1].index < dst[i].index);\n\n      free (qsort_result);\n      free (tmp);\n      free (dst);\n    }\n\n   \n  for (n = 1; n <= NMAX; n++)\n    {\n      struct foo *src;\n      struct foo *tmp;\n      double *qsort_result;\n      size_t i;\n\n      src = (struct foo *) malloc ((n + 1) * sizeof (struct foo));\n      src[n].x = 0x4A6A71FE;  \n      tmp = (struct foo *) malloc ((n + 1) * sizeof (struct foo));\n      tmp[n].x = 0x587EF149;  \n\n      for (i = 0; i < n; i++)\n        src[i] = data[i];\n\n      merge_sort_inplace (src, n, tmp);\n\n       \n      ASSERT (src[n].x == 0x4A6A71FE);\n      ASSERT (tmp[n].x == 0x587EF149);\n\n       \n      qsort_result = (double *) malloc (n * sizeof (double));\n      for (i = 0; i < n; i++)\n        qsort_result[i] = data[i].x;\n      qsort (qsort_result, n, sizeof (double), cmp_double);\n      for (i = 0; i < n; i++)\n        ASSERT (src[i].x == qsort_result[i]);\n\n       \n      for (i = 0; i < n; i++)\n        if (i > 0 && src[i - 1].x == src[i].x)\n          ASSERT (src[i - 1].index < src[i].index);\n\n      free (qsort_result);\n      free (tmp);\n      free (src);\n    }\n\n  return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}